<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.imperialviolet.org/2022/09/22/passkeys.html">Original</a>
    <h1>Passkeys</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>This is an opinionated, “quick-start” guide to using passkeys as a
web developer. It’s hopefully broadly applicable, but one size will
never fit all authentication needs and this guide ignores everything
that’s optional. So take it as a worked example, but not as gospel.</p>
<p>It doesn&#39;t use any WebAuthn libraries, it just assumes that you have access to functions for verifying signatures. That mightn&#39;t be optimal—maybe finding a good library is better idea—but passkeys aren&#39;t so complex that it&#39;s unreasonable for people to know what&#39;s going on.</p>
<p>This is probably a post that&#39;ll need updating over time, making it a bad fit for a blog, so maybe I&#39;ll move it in the future. But it&#39;s here for now.</p>
<p>Platforms for developing with passkeys include:</p>
<ul>
<li>Safari on iOS 16 or macOS 13.</li>
<li>Chrome Canary (with
<code>chrome://flags#webauthn-conditional-ui</code> set) on Win­dows
22H2.</li>
<li>Chrome Canary (with
<code>chrome://flags#webauthn-conditional-ui</code> set) on mac­OS.</li>
</ul>
<h2 id="database-changes">Database changes</h2>
<p>Each user will need a passkey <a href="https://www.w3.org/TR/webauthn-2/#user-handle">user ID</a>. The
user ID identifies an account, but <a href="https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy">should
not contain</a> any personally identifiable information (PII). You
probably already have a user ID in your system, but you should make one
specifically for passkeys to more easily keep it PII-free. Create a new
column in your <code>users</code> table and populate it with large
random values for this purpose. (The following is in SQLite syntax so
you’ll need to adjust for other databases.)</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>/* SQLite can&#39;t set a non-constant DEFAULT when altering a table, only</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span> * when creating it, but this is what we would like to write. */</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>ALTER</span> <span>TABLE</span> users <span>ADD</span> <span>COLUMN</span> passkey_id <span>blob</span> <span>DEFAULT</span>(randomblob(<span>16</span>));</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>/* The CASE expression causes the function to be non-constant. */</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>UPDATE</span> USERS <span>SET</span> passkey_id<span>=</span>hex(randomblob(<span>CASE</span> <span>rowid</span> <span>WHEN</span> <span>0</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                                                      <span>THEN</span> <span>16</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                                                      <span>ELSE</span> <span>16</span> <span>END</span>));</span></code></pre></div>
<p>A user can only have a single pass<em>word</em> but can have multiple
passkeys. So create a table for them:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>CREATE</span> <span>TABLE</span> passkeys (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>id</span> <span>BLOB</span> <span>PRIMARY</span> <span>KEY</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  username STRING <span>NOT</span> <span>NULL</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  public_key_spki <span>BLOB</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  backed_up <span>BOOLEAN</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span>FOREIGN</span> <span>KEY</span>(username) <span>REFERENCES</span> users(username));</span></code></pre></div>
<h2 id="secure-contexts">Secure contexts</h2>
<p>Nothing in WebAuthn works outside of a <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">secure
context</a>, so if you’re not using HTTPS, go fix that first.</p>
<h2 id="enrolling-existing-users">Enrolling existing users</h2>
<p>When a user signs in with a password, you might want to prompt them
to create a passkey on the local device for easier sign-in next time.
First, check to see if their device has a local authenticator and that
the browser is going to support passkeys:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>if</span> (<span>!</span><span>window</span><span>.</span><span>PublicKeyCredential</span> <span>||</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span>!</span>(PublicKeyCredential <span>as</span> any)<span>.</span><span>isConditionalMediationAvailable</span>) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span>return</span><span>;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span>Promise</span><span>.</span><span>all</span>([</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    (PublicKeyCredential <span>as</span> any)<span>.</span><span>isConditionalMediationAvailable</span>()<span>,</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    PublicKeyCredential</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      <span>.</span><span>isUserVerifyingPlatformAuthenticatorAvailable</span>()])</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span>.</span><span>then</span>((values) <span>=&gt;</span> {</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (values<span>.</span><span>every</span>(x <span>=&gt;</span> x <span>===</span> <span>true</span>)) {</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      <span>promptUserToCreatePlatformCredential</span>()<span>;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  })</span></code></pre></div>
<p>(The snippets here are in TypeScript. It should be easy to convert
them to plain Javascript if that’s what you need. You might notice
several places where TypeScript’s DOM types are getting overridden
because lib.dom.d.ts hasn’t caught up. I hope these cases will disappear
in time.)</p>
<p>If the user accepts, ask the browser to create a local
credential:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>var</span> createOptions <span>:</span> CredentialCreationOptions <span>=</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span>publicKey</span><span>:</span> {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span>rp</span><span>:</span> {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>      <span>// The RP ID. This needs some thought. See comments below.</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>      <span>id</span><span>:</span> SEE_BELOW<span>,</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span>// This field is required to be set to something, but you can</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      <span>// ignore it.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      <span>name</span><span>:</span> <span>&#34;&#34;</span><span>,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span>user</span><span>:</span> {</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>      <span>// `userIdBase64` is the user&#39;s passkey ID, from the database,</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>      <span>// base64-encoded.</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      <span>id</span><span>:</span> <span>Uint8Array</span><span>.</span><span>from</span>(<span>atob</span>(userIdBase64)<span>,</span> c <span>=&gt;</span> c<span>.</span><span>charCodeAt</span>(<span>0</span>))<span>,</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>      <span>// `username` is the user&#39;s username. Whatever they would type</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>      <span>// when signing in with a password.</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>      <span>name</span><span>:</span> username<span>,</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>      <span>// `displayName` can be a more human name for the user, or</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>      <span>// just leave it blank.</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>      <span>displayName</span><span>:</span> <span>&#34;&#34;</span><span>,</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span>// This lists the ids of the user&#39;s existing credentials. I.e.</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span>//   SELECT id FROM passkeys WHERE username = ?</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span>// and supply the resulting list of values, base64-encoded, as</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span>// existingCredentialIdsBase64 here.</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span>excludeCredentials</span><span>:</span> existingCredentialIdsBase64<span>.</span><span>map</span>(id <span>=&gt;</span> {</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>      <span>return</span> {</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span>id</span><span>:</span> <span>Uint8Array</span><span>.</span><span>from</span>(<span>atob</span>(id)<span>,</span> c <span>=&gt;</span> c<span>.</span><span>charCodeAt</span>(<span>0</span>))<span>,</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>      }<span>;</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    })<span>,</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span>// Boilerplate that advertises support for P-256 ECDSA and RSA</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span>// PKCS#1v1.5. Supporting these key types results in universal</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span>// coverage so far.</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span>pubKeyCredParams</span><span>:</span> [{</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>      <span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>      <span>alg</span><span>:</span> <span>-</span><span>7</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    }<span>,</span> {</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>      <span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>      <span>alg</span><span>:</span> <span>-</span><span>257</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    }]<span>,</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    <span>// Unused during registrations, except in some enterprise</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    <span>// deployments. But don&#39;t do this during sign-in!</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    <span>challenge</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>0</span>])<span>,</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span>authenticatorSelection</span><span>:</span> {</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>      <span>authenticatorAttachment</span><span>:</span> <span>&#34;platform&#34;</span><span>,</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>      <span>requireResidentKey</span><span>:</span> <span>true</span><span>,</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    <span>// Three minutes.</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    <span>timeout</span><span>:</span> <span>180000</span><span>,</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>}<span>;</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a><span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span>(createOptions)<span>.</span><span>then</span>(</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>  handleCreation<span>,</span> handleCreationError)<span>;</span></span></code></pre></div>
<h3 id="rp-ids">RP IDs</h3>
<p>There are two levels of controls that prevent passkeys from being
used on the wrong website. You need to know about this upfront to
prevent getting stuck later.</p>
<p>“RP” stands for “relying party”. You (the website) are a “relying
party” in authentication-speak. An RP ID is a domain name and every
passkey has one that’s fixed at creation time. Every passkey operation
asserts an RP ID and, if a passkey’s RP ID doesn’t match, then it
doesn’t exist for that operation.</p>
<p>This prevents one site from using another’s passkeys. A passkey with
an RP ID of <tt>foo.com</tt> can’t be used on <tt>bar.com</tt> because
<tt>bar.com</tt> can’t assert an RP ID of <tt>foo.com</tt>. A site may
use any RP ID formed by discarding zero or more labels from the left of
its domain name until it hits an eTLD. So say that you’re
<tt>https://www.foo.co.uk</tt>: you can assert <tt>www.foo.co.uk</tt>
(discarding zero labels), <tt>foo.co.uk</tt> (discarding one label), but
not <tt>co.uk</tt> because that hits an eTLD. If you don’t set an RP ID
in a request then the default is the site’s full domain.</p>
<p>Our <tt>www.foo.co.uk</tt> example might happily be creating passkeys
with the default RP ID but later decide that it wants to move all
sign-in activity to an isolated origin,
<tt>https://accounts.foo.co.uk</tt>. But none of the passkeys could be
used from that origin! If would have needed to create them with an RP ID
of <tt>foo.co.uk</tt> in the first place to allow that.</p>
<p>But you might want to be careful about always setting the most
general RP ID because then <tt>usercontent.foo.co.uk</tt> could access
and overwrite them too. That brings us to the second control mechanism.
As you’ll see later, when a passkey is used to sign in, the browser
includes the origin that made the request in the signed data. So
<tt>accounts.foo.co.uk</tt> would be able to see that a request was
triggered by <tt>usercontent.foo.co.uk</tt> and reject it, even if the
passkey’s RP ID allowed <tt>usercontent.foo.co.uk</tt> to use it. But
that mechanism can’t do anything about <tt>usercontent.foo.co.uk</tt>
being able to overwrite them.</p>
<p>So either pick an RP ID and put it in the “SEE BELOW” placeholder,
above. Or else don’t include the <tt>rp.id</tt> field at all and use the
default.</p>
<h3 id="recording-a-passkey">Recording a passkey</h3>
<p>When the promise from <code>navigator.credentials.create</code>
resolves successfully, you have a newly created passkey! Now you have to
ensure that it gets recorded by the server.</p>
<p>The promise will result in a <a href="https://www.w3.org/TR/webauthn-2/#iface-pkcredential"><code>PublicKeyCredential</code></a>
object, the <code>response</code> field of which is an <a href="https://www.w3.org/TR/webauthn-2/#authenticatorattestationresponse"><code>AuthenticatorAttestationResponse</code></a>.
First, sanity check some data from the browser. Since this data isn’t
signed over in the configuration that we’re using, it’s fine to do this
check client-side.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>const</span> cdj <span>=</span> <span>JSON</span><span>.</span><span>parse</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span>new</span> <span>TextDecoder</span>()<span>.</span><span>decode</span>(cred<span>.</span><span>response</span><span>.</span><span>clientDataJSON</span>))<span>;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>if</span> (cdj<span>.</span><span>type</span> <span>!=</span> <span>&#39;webauthn.create&#39;</span> <span>||</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    ((<span>&#39;crossOrigin&#39;</span> <span>in</span> cdj) <span>&amp;&amp;</span> cdj<span>.</span><span>crossOrigin</span>) <span>||</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    cdj<span>.</span><span>origin</span> <span>!=</span> <span>&#39;https://YOURSITEHERE&#39;</span>) {</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span>// handle error</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Call <code>getAuthenticatorData()</code> and
<code>getPublicKey()</code> on <code>response</code> and send those
ArrayBuffers to the server.</p>
<p>At the server, we want to insert a row into the <code>passkeys</code>
table for this user. The <a href="https://w3c.github.io/webauthn/#authenticator-data">authenticator
data</a> is a fairly simple, binary format. Offset 32 contains the flags
byte. Sanity check that bit 7 is set and then extract:</p>
<ol type="1">
<li>Bit 4 as the value of <code>backed_up</code>. (I.e.
<code>(authData[32] &gt;&gt; 4) &amp; 1</code>.)</li>
<li>The big-endian, uint16 at offset 53 as the length of the credential
ID.</li>
<li>That many bytes from offset 55 as the value of <code>id</code>.</li>
</ol>
<p>The ArrayBuffer that came from <code>getPublicKey()</code> is the
value for <code>public_key_spki</code>. That should be all the values
needed to insert the row.</p>
<h3 id="handling-a-registration-exception">Handling a registration
exception</h3>
<p>The promise from <code>create()</code> might also result in an
exception. <code>InvalidStateError</code> is special and means that a
passkey already exists for the local device. This is not an error, and
no error will have been shown to the user. They’ll have seen a UI just
like they were registering a passkey but the server doesn’t need to
update anything.</p>
<p><code>NotAllowedError</code> means that the user canceled the
operation. Other exceptions mean that something more unexpected
happened.</p>
<p>To test whether an exception is one of these values do something
like:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>handleCreationError</span>(e<span>:</span> <span>Error</span>) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span>if</span> (e <span>instanceof</span> <span>DOMException</span>) {</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>switch</span> (e<span>.</span><span>name</span>) {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      <span>case</span> <span>&#39;InvalidStateError&#39;</span><span>:</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span>console</span><span>.</span><span>log</span>(<span>&#39;InvalidStateError&#39;</span>)<span>;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span>return</span><span>;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>      <span>case</span> <span>&#39;NotAllowedError&#39;</span><span>:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span>console</span><span>.</span><span>log</span>(<span>&#39;NotAllowedError&#39;</span>)<span>;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span>return</span><span>;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span>console</span><span>.</span><span>log</span>(e)<span>;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>(But obviously don’t just log them to the console in real code.)</p>
<h2 id="signing-in-with-autocomplete">Signing in with autocomplete</h2>
<p>Somewhere on your site you have username &amp; password inputs. On
the username <code>input</code> element, add <code>webauthn</code> to
the <code>autocomplete</code> attribute. So if you have:</p>
<pre><code>&lt;input type=&#34;text&#34; name=&#34;username&#34; autocomplete=&#34;username&#34;&gt;</code></pre>
<p>… then change that to …</p>
<pre><code>&lt;input type=&#34;text&#34; name=&#34;username&#34; autocomplete=&#34;username webauthn&#34;&gt;</code></pre>
<p>Autocomplete for passkeys works differently than for passwords. For
the latter, when the user selects a username &amp; password from the
pop-up, the input fields are filled for them. Then they can click a
button to submit the form and sign in. With passkeys, no fields are
filled, but rather a pending <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>
is resolved. It’s then the <em>site’s responsibility</em> to
navigate/update the page so that the user is signed in.</p>
<p>That pending promise must be set up by the site before the user
focuses the username field and triggers autocomplete. (Just adding the
<code>webauthn</code> tag doesn’t do anything if there’s not a pending
promise for the browser to resolve.) To create it, run a function at
page load that:</p>
<ol type="1">
<li>Does feature detection and, if supported,</li>
<li>Starts a “conditional” WebAuthn request to produce the promise that
will be resolved if the user selects a credential.</li>
</ol>
<p>Here’s how to do the feature detection:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>if</span> (<span>!</span><span>window</span><span>.</span><span>PublicKeyCredential</span> <span>||</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span>!</span>(PublicKeyCredential <span>as</span> any)<span>.</span><span>isConditionalMediationAvailable</span>) {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span>return</span><span>;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>(PublicKeyCredential <span>as</span> any)<span>.</span><span>isConditionalMediationAvailable</span>()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span>.</span><span>then</span>((result<span>:</span> boolean) <span>=&gt;</span> {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (<span>!</span>result) {</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      <span>return</span><span>;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span>startConditionalRequest</span>()<span>;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span></code></pre></div>
<p>Then, to start the conditional request:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>var</span> getOptions <span>:</span> CredentialRequestOptions <span>=</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span>// This is the critical option that tells the browser not to show</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span>// modal UI.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span>mediation</span><span>:</span> <span>&#34;conditional&#34;</span> <span>as</span> CredentialMediationRequirement<span>,</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span>publicKey</span><span>:</span> {</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span>challenge</span><span>:</span> <span>Uint8Array</span><span>.</span><span>from</span>(<span>atob</span>(CHALLENGE_SEE_BELOW)<span>,</span> c <span>=&gt;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                                 c<span>.</span><span>charCodeAt</span>(<span>0</span>))<span>,</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span>rpId</span><span>:</span> SAME_AS_YOU_USED_FOR_REGISTRATION<span>,</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>}<span>;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span>(getOptions)<span>.</span><span>then</span>(</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  handleSignIn<span>,</span> handleSignInError)<span>;</span></span></code></pre></div>
<h3 id="challenges">Challenges</h3>
<p>Challenges are random values, generated by the server, that are
signed over when using a passkey. Because they are large random values,
the server knows that the signature must have been generated after it
generated the challenge. This stops “replay” attacks where a signature
is captured and used multiple times.</p>
<p>Challenges are a little like a <a href="https://portswigger.net/web-security/csrf/tokens">CSRF token</a>:
they should be large (16- or 32-byte), cryptographically-random values
and stored in the session object. They should only be used once: when a
sign-in attempt is received, the challenge should be invalidated. Future
sign-in attempts will have to use a fresh challenge.</p>
<p>The snippet above has a value <code>CHALLENGE_SEE_BELOW</code> which
is assumed to be the base64-encoded challenge for the sign-in. The
sign-in page might <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XHR</a>
to get the challenge, or the challenge might be injected into the page’s
template. Either way, it must be generated at the server!</p>
<h3 id="handling-sign-in">Handling sign-in</h3>
<p>If the user selects a passkey then <code>handle­Sign­In</code> will
be called with a <a href="https://www.w3.org/TR/webauthn-2/#iface-pkcredential"><code>Public­Key­Credential</code></a>
object, the <code>response</code> field of which is a <a href="https://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse"><code>Authenticator­Assertion­Response</code></a>.
Send the Array­Buffers <code>raw­Id</code>,
<code>response.­client­Data­JSON</code>,
<code>response.­authenticator­Data</code>, and
<code>response.­signature</code> to the server.</p>
<p>At the server, first look up the passkey:
<code>SELECT (username, public_key_spki, backed_up) FROM passkey WHERE id = ?</code>
and give the value of <code>rawId</code> for matching. The
<code>id</code> column is a primary key, so there can either be zero or
one matching rows. If there are zero rows then the user is signing in
with a passkey that the server doesn’t know about—perhaps they deleted
it. This is an error, reject the sign-in.</p>
<p>Otherwise, the server now knows the claimed username and public key.
To validate the signature you’ll need to construct the signed data and
parse the public key. The <code>public_key_spki</code> values from the
database are stored in <a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.1">SubjectPublicKeyInfo</a>
format and most languages will have some way to ingest them. Here are
some examples:</p>
<ul>
<li><em>Java</em>: java.security.spec.X509EncodedKeySpec</li>
<li><em>.NET</em>:
System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo</li>
<li><em>Go</em>: crypto/x509.ParsePKIXPublicKey</li>
</ul>
<p>Your languages’s crypto library should provide a function that takes
a signature and some signed data and tells you whether that signature is
valid for a given public key. For the signature, pass in the value of
the <code>signature</code> ArrayBuffer that the client sent. For the
signed data, calculate the SHA-256 hash of <code>clientDataJSON</code>
and append it to the contents of <code>authenticatorData</code>. If the
signature isn’t valid, reject the sign-in.</p>
<p>But there are still a bunch of things that you need to check!</p>
<p>Parse the <code>clientDataJSON</code> as UTF-8 JSON and check
that:</p>
<ol type="1">
<li>The <code>type</code> member is “webauthn.get”.</li>
<li>The <code>challenge</code> member is equal to the base64url encoding
of the challenge that the server gave for this sign-in.</li>
<li>The <code>origin</code> member is equal to your site’s sign-in
origin (e.g. a string like “https://www.example.com”).</li>
<li>The <code>crossOrigin</code> member, if present, is false.</li>
</ol>
<p>There’s more! Take the <code>authenticatorData</code> and check
that:</p>
<ol type="1">
<li>The first 32 bytes are equal to the SHA-256 hash of the RP ID that
you’re using.</li>
<li>That bit zero of the byte at offset 32 is one. I.e.
<code>(authData[32] &amp; 1) == 1</code>. This is the <a href="https://www.w3.org/TR/webauthn-2/#test-of-user-presence">user
presence bit</a> that indicates that a user approved the signature.</li>
</ol>
<p>If all those checks work out then sign in the user whose passkey it
was. I.e. set a cookie and respond to the running Javascript so that it
can update the page.</p>
<p>If the stored value of <code>backed_up</code> is not equal to
<code>(authData[32] &gt;&gt; 4) &amp; 1</code> then update that in the
database.</p>
<h2 id="removing-passwords">Removing passwords</h2>
<p>Once a user is using passkeys to sign in, great! But if they were
upgraded from a password then that password is hanging around on the
account, doing nothing useful yet creating risk. It would be good to ask
the user about removing the password.</p>
<p>Doing this is reasonable if the account has a backed-up passkey. I.e.
if
<code>SELECT 1 FROM passkeys WHERE username = ? AND backed_up = TRUE</code>
has results. A site might consider prompting the user to remove the
password on an account when they sign in with a passkey and have a
backed-up one registered.</p>
<h2 id="registering-new-passkey-only-users">Registering new,
passkey-only users</h2>
<p>For sign ups of new users, consider making them passkey-only if the
feature detection (from the section on enrolling users) is happy.</p>
<p>When enrolling users where a passkey will be their only sign-in
method you really want the passkey to end up “in their pocket”, i.e. on
their phone. Otherwise they could have a passkey on the computer that
they signed-up with but, if it’s not syncing to their phone, that’s not
very convenient. There is not, currently, a great answer for this I’m
afraid! Hopefully, in a few months, calling
<code>navigator­.credentials.­create()</code> with
<code>authenticator­Selection.­authenticator­Attachment</code> set to
<code>cross-plat­form</code> will do the right thing. But with iOS 16
it’ll exclude the platform authenticator.</p>
<p>So, for now, do that on all platforms except for iOS/iPadOS, where
<code>authenticator­Attachment</code> should continue to be
<code>plat­form</code>.</p>
<p>(I’ll try and update this section when the answer is simplier!)</p>
<h2 id="settings">Settings</h2>
<p>If you’ve used security keys with any sites then you’ll have noticed
that they tend to list registered security keys in their account
settings, have users name each one, show the last-used time, and let
them be individually removed. You can do that with passkeys too if you
like, but it’s quite a lot of complexity. Instead, I think you can have
just two buttons:</p>
<p>First, a button to add a passkey that uses the
<code>createOptions</code> object from above, but with
<code>authenticatorAttachment</code> deleted in order to allow other
devices to be registered.</p>
<p>Second, a “reset passkeys” button (like a “reset password” button).
It would prompt for a new passkey registration, delete all other
passkeys, and invalidate all other active sessions for the user.</p>
<h2 id="test-vectors">Test vectors</h2>
<p>Connecting up to your language’s crypto libraries is one of the
trickier parts of this. To help, here are some test vectors to give you
a ground truth to check against, in the format of Python 3 code that
checks an assertion signature.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>import</span> codecs</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>from</span> cryptography.hazmat.primitives.asymmetric <span>import</span> ec</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>from</span> cryptography.hazmat.primitives <span>import</span> hashes</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>from</span> cryptography.hazmat.primitives.serialization <span>import</span> (</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  load_der_public_key)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span># This is the public key in SPKI format, as obtained from the</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span># `getPublicKey` call at registration time.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>public_key_spki_hex <span>=</span> <span>&#39;&#39;&#39;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span>3059301306072a8648ce3d020106082a8648ce3d03010703420004dfacc605c6</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span>e1192f4ab89671edff7dff80c8d5e2d4d44fa284b8d1453fe34ccc5742e48286</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span>d39ec681f46e3f38fe127ce27c30941252430bd373b0a12b3e94c8</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span>&#39;&#39;&#39;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span># This is the contents of the `clientDataJSON` field at assertion</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span># time. This is UTF-8 JSON that you also need to validate in several</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span># ways; see the main body of the text.</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>client_data_json_hex <span>=</span> <span>&#39;&#39;&#39;</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span>7b2274797065223a22776562617574686e2e676574222c226368616c6c656e67</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span>65223a22594934476c4170525f6653654b4d455a444e36326d74624a73345878</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span>47316e6f757642445a483664436141222c226f726967696e223a226874747073</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span>3a2f2f73656375726974796b6579732e696e666f222c2263726f73734f726967</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span>696e223a66616c73657d</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span>&#39;&#39;&#39;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span># This is the `authenticatorData` field at assertion time. You also</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span># need to validate this in several ways; see the main body of the</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span># text.</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>authenticator_data_hex <span>=</span> <span>&#39;&#39;&#39;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span>26bd7278be463761f1faa1b10ab4c4f82670269c410c726a1fd6e05855e19b46</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span>0100000cc7</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span>&#39;&#39;&#39;</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span># This is the signature at assertion time.</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>signature_hex <span>=</span> <span>&#39;&#39;&#39;</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span>3046022100af548d9095e22e104197f2810ee9563135316609bc810877d1685b</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a><span>cff62dcd5b022100b31a97961a94b4983088386fd2b7edb09117f4546cf8a5c1</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a><span>732420b2370384fd</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span>&#39;&#39;&#39;</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a><span>def</span> from_hex(h):</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    <span>return</span> codecs.decode(h.replace(<span>&#39;</span><span>\n</span><span>&#39;</span>, <span>&#39;&#39;</span>), <span>&#39;hex&#39;</span>)</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a><span>def</span> sha256(m):</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    digest <span>=</span> hashes.Hash(hashes.SHA256())</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>    digest.update(m)</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>    <span>return</span> digest.finalize()</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a><span># The signed message is calculated from the authenticator data and</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a><span># clientDataJSON, but the latter is hashed first.</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>signed_message <span>=</span> (from_hex(authenticator_data_hex) <span>+</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>                  sha256(from_hex(client_data_json_hex)))</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>public_key <span>=</span> load_der_public_key(from_hex(public_key_spki_hex))</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>public_key.verify(from_hex(signature_hex),</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>                  signed_message,</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>                  ec.ECDSA(hashes.SHA256()))</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a><span># `verify` throws an exception if the signature isn&#39;t valid.</span></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#39;ok&#39;</span>)</span></code></pre></div>
<h2 id="where-to-ask-questions">Where to ask questions</h2>
<p><a href="https://stackoverflow.com/questions/tagged/passkey">StackOverflow</a>
is a reasonable place, with the <code>passkey</code> tag.</p>

    </div></div>
  </body>
</html>
