<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.kronis.dev/articles/never-update-anything">Original</a>
    <h1>Never Update Anything</h1>
    
    <div id="readability-page-1" class="page"><section id="blog-hero">
    
    <section>
        <h2>Never update anything</h2>
<p>Here&#39;s a fair warning: this article is <a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum">reductio ad absurdum</a>, therefore you shouldn&#39;t take it as gospel. However, i do believe that this point of view is extreme enough that it usually gets shut down immediately, yet doesn&#39;t have any frank discussion about it, which makes it the perfect subject for me to write about! To reiterate, i&#39;m not suggesting that you go out there after reading this and never update any of your production software, merely consider the points that are offered here.</p>
<p>So, as the article title suggests, you should never update anything. Not your OS. Not your libraries in your software project. Not your tools. What would make someone come to this controversial idea? Actually trying to do that, of course! </p>
<p>When you&#39;re telling your colleagues that you can&#39;t really work because Windows or JetBrains IDEs need to install some updates, they&#39;ll give you understanding, yet annoyed glances. When you tell clients that you cannot ship software because first you need to spend a few days or weeks refactoring software to keep up with the latest library releases, they will express their displeasure at you and will probably look elsewhere for someone who won&#39;t care about updates. When your company won&#39;t be the first to market, because about 20% of your total development capacity needs to spent on keeping up with the technical debt, which is slowly forced upon by the industry, while another 20% of the effort needs to go to writing and maintaining a test suite, the company will suffer as a result. And once you actually do get the buy-in to update the components and when it turns out that migrating from Spring to Spring Boot is actually a herculean effort that means carrying over about 50 dependencies of a legacy Java project that has about 1 million SLoC, during which you also discover that at least 20-30 of those are painfully out of date, then you&#39;ll just start writing blog posts like this.</p>
<p>My premise is that updates are a massive waste of time, most of the time. Obviously, someone will jump out and say that &#34;Hey, if you don&#39;t update, your Windows XP installation will get added to a botnet in less than a week,&#34; and they&#39;ll also be right at the same time. </p>
<h3>Types of updates are the problem</h3>
<p>The problem here is that we never differentiate between the types of updates properly: </p>
<ul>
<li>major leaps in the development of the software which add new features</li>
<li>security updates that don&#39;t change any actual functionality apart from the security fix</li>
<li>bug fixes that should not alter any functionality in significant ways</li>
<li>small backwards compatible feature updates that are essentially opt in</li>
</ul>
<p>There are plenty of things that you might want to feasibly change and update without any of the other functionality being altered. Actually, the situation is so bad in that regard, that most if not all of our modern software only ever has feature updates which sooner or later will have breaking changes in them. Otherwise, if you wanted to eliminate the possibility of running into breaking changes entirely, the development of any library would look like this:</p>
<p><img alt="how updates would look" src="https://effectivetypescript.com/images/h/o/w/-/u/how-updates-would-look-aff7472e.jpeg"/></p>
<p>In the image, we see that we have major releases (with the &#34;V&#34; prefix), for example, we&#39;d have MySQL 5, that would eventually be updated to MySQL 6, MySQL 7 and MySQL 8 (which is funny, if you know anything about how that actually worked out). Esentially, you&#39;d have a few large releases, that represent both new features being added, as well as breaking changes. Then, you have the minor versions which introduce new functionaly (with the &#34;f&#34; prefix) and patches (with the &#34;s&#34; prefix) which in this case would mean security fixes. </p>
<p>Essentially, i&#39;m describing <a href="https://en.wikipedia.org/wiki/Software_versioning">semantic versioning</a>, where this scheme would be approximately <code>V.f.s</code>, where you have a clear distinction between the major, minor and patch versions. However, instead of abandoning minor releases, you&#39;d have to keep them up to date, since in practice different minor releases are not always compatible. If you wanted to support all of the versions of your software without forcing your users to use the new features, it would mean maintaining a new instance of your codebase for every minor release in existence. And in this case we&#39;re also simplifying things, because we assume that the patch versions will never break anything, which would probably mean that we need to preserve non-security related bugs and only fix them across minor releases.</p>
<p>You&#39;d have to backport any and all security fixes from your newest versions, should the older ones also be affected. For example, if you discover a problem in V5.2.15 and fix it in V5.2.16, then you&#39;d have to port these changes back to the current V5.1.X version and V5.0.X version, which is probably doable when you have 3 releases, but less so with 30.</p>
<p>And it goes the other way around, if you discover a problem in one of your older releases and the newer ones are also affected, then you have to port the changes forwards. For example, if you discover a problem in V5.0.14 and fix it in V5.0.15, then you&#39;d have to port these changes forwards to the current V5.1.X and V5.2.X versions, where you run into the same problem as above.</p>
<p>In practice, things almost never work like that because that necessitates too much work. If you tried doing that, your issue tracking software could look like this:</p>
<pre><code>Issue: MYSOFT-3401
Description: Security breakage in $FOO module.
Assignee: You
Status: Ready to test

Versions affected:
- V7.6.245
- V7.5.267
- ... (down to V7.0.X)
- V6.10.315
- V6.9.326
- ... (down to V6.0.X)
- V5.14.421
- V5.13.442
- ... (down to V5.0.X)

Fixed in:
- V7.6.246
- V7.5.268
- ... (down to V7.0.X)
- V6.10.316
- V6.9.327
- ... (down to V6.0.X)
- V5.14.422
- V5.13.443
- ... (down to V5.0.X)</code></pre>
<p>Of course, testing all of that would be interesting, as would fixing further issues. Imagine having to do this for every single bug report and change. You&#39;d spend days if not weeks fixing even trivial bugs if you&#39;d have to support every single release of your software. That&#39;s why a lot of companies just drop support for older packages and leave people with no updates at all in cases where a minor version actually does break something, which isn&#39;t as much solving the problem, as it is simply sweeping it under the rug. </p>
<p>I&#39;m sure that some of them would perhaps want to update their older versions, but it simply isn&#39;t feasible, perhaps apart from supporting the major version as a whole and forcing people to update to the newest minor versions to keep getting support. So in reality, the list of supported versions would indeed be just the last minor releases in the first example above, which would look a bit like the following:</p>
<p><img alt="actual updates are more like" src="https://effectivetypescript.com/images/a/c/t/u/a/actual-updates-are-more-like-e7f2dfac.jpeg"/></p>
<p>More doable, but still not good enough in my mind - minor versions are for new features, which you don&#39;t necessarily want. My experience shows that oftentimes these new and supposedly backwards compatible features still break old functionality. Perhaps it&#39;s due to some refactoring that was needed, other times there were bugs fixed that old code relied upon and assumed to be the right way to do things. </p>
<p>My pain is that you&#39;ll never actually know how far you can update, seeing as the breaking changes will get you sooner or later, even if it&#39;s supposed to just be a bug fix. In reality, you might find that you can only run your software with a subset of the released versions (orange being what you have now, green what you can update to without breakages, red being everything that won&#39;t work):</p>
<p><img alt="how far you can update without breakages" src="https://effectivetypescript.com/images/h/o/w/-/f/how-far-you-can-update-before-breakages-618dd6ac.jpeg"/></p>
<p>Now, the understandable argument here is: &#34;Breaking changes are inevitable, you should just update your code.&#34; which is fair, but at the same time kind of useless. The industry shows that there are still plenty of projects that are stuck with JDK 8 and MySQL 5.7, or even a better example, old PHP versions like 5.6.40 and realistically cannot be updated and eventually will receive no security updates either, because all of that is simply too hard. And good luck with trying to tell your clients that now you&#39;ll probably need to alter or rewrite a huge portion of your code that uses the now deprecated or removed packages - oftentimes they simply won&#39;t understand that code rots with time.</p>
<p>Worse yet, those that don&#39;t care about semantic versioning don&#39;t even attempt to keep track of all of this stuff - i&#39;ve seen projects out there in the wild, where V6.9.0 is always followed by V7.0.0 and V7.0.1 is code for &#34;we screwed up the previous release, so this is just a hotfix&#34;, plenty of people and orgs out there just look at version numbers like something to put in Jira and get paid for, rather than a measure of what the software is compatible with.</p>
<h3>Noone wants updates</h3>
<p>But that&#39;s just the tip of the iceberg. I think i&#39;ve briefly described while backporting security fixes and such is pretty hard, even though some operating systems still try to do that. Now, here&#39;s a story about why updates are actually bad. In a word: breaking changes. In the aforementioned Spring migration, i updated the <a href="https://flywaydb.org/">Flyway</a> version and ran into the following message:</p>
<pre><code>org.flywaydb.core.internal.license.FlywayEditionUpgradeRequiredException: Flyway Teams Edition or Oracle upgrade required: Oracle OLD_VERSION is no longer supported by Flyway Community Edition, but still supported by Flyway Teams Edition.</code></pre>
<p>I think that this is the inevitable future of software. &#34;Want support for older versions of stuff that you&#39;re stuck with because of organizational reasons beyond your control? Sure, pay us!&#34; If you look at the pricing page, you actually see that you&#39;d need to part with 3000 USD for that sort of a license:</p>
<p><img alt="flyway costs" src="https://effectivetypescript.com/images/f/l/w/a/y/flway-costs-0bd2cc78.jpeg"/></p>
<p>Now, i&#39;m using this as an example for intentionally breaking support for older versions in a way that will hopefully (from the company&#39;s point of view) lead to them dying off and therefore the companies won&#39;t need to explicitly support them for a long time, thus attempting to solve the problem above. However, there are also plenty of cases out there, where updates introduce other breaking changes, oftentimes being forced upon the user against their will!</p>
<p>For example, i want to use Flyway, but i don&#39;t want to be forced to use a version, which drops support for the DB that i need to use. And yet, i wasn&#39;t even consulted about this, since the newest version is mandated by Spring Boot:</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>There are plenty of cases out there like this as well! For example, Docker Desktop doesn&#39;t let you decide whether you want updates or not, unless you pay them:</p>
<p><img alt="docker desktop updates" src="https://effectivetypescript.com/images/d/o/c/k/e/docker-desktop-updates-6f750760.png"/></p>
<p>And i&#39;m sure that we&#39;ve all also heard plenty of other horror stories of this very same trend, be it <a href="https://www.howtogeek.com/670084/what-you-need-to-know-about-snaps-on-ubuntu-20.04/">Ubuntu forcing updates with snap packages</a>, or Windows 7 forcefully upgrading to newer releases when people step away from their computers for a bit.</p>
<p>In a word, the way how companies approach updates nowadays suck, especially when they break things!</p>
<h3>Updates are bad</h3>
<p>All you need to do is go to the &#34;Everything is Broken&#34; section of my blog and you will see plenty of cases of updates breaking things. In the current year, it&#39;s gotten to the point where i treat every update like a possibly completely clean wipe and install from nothing. Therefore, backups are of the utmost importance and every update needs to have at least an hour or two set aside for when things will inevitably go wrong, as they oftentimes have in the past.</p>
<p>But here&#39;s the thing - if i don&#39;t want to rely on <a href="http://www.gnu.org/philosophy/who-does-that-server-really-serve.html">SaaSS</a>, then i have to host and manage my software by myself. If i want to do that, then i need to handle the updates myself as well. Every update takes a significant amount of time and potentially can break things. And, even more importantly, if there are any non-standard configuration changes done (even the theme of this very blog), then things become more likely to break and waste my time. But i don&#39;t have unlimited amounts of time. </p>
<p>Actually, i don&#39;t have enough time to do my day job, learn new technologies for when it inevitably becomes stale and would otherwise lead to my career death, to also help my aging parents around the countryside estate with various chores, at the same time educate myself on both things in the industry and news in the world, as well as spend anywhere between 1-2 hours working out every day (a weight loss and personal wellness effort which seems to be working and about which i&#39;ll write a post some day) and have any sort of enjoyment of life in general, for example, by reading a sci-fi book in the evenings.</p>
<p>Ergo, i cannot update. Ergo, companies cannot ship features AND handle all of the updates, without having enough tests to catch all of the problems, which they will never be able to do no matter how good their tests are without slowing down their development pace to the point where they are no longer competitive.</p>
<p>Breaking feature updates of any sort are a nuisance and a direct impediment to progress more often than they&#39;re not and the more updates there are to be done, the less will be done. So don&#39;t update!</p>
<p>For example, to see why we shouldn&#39;t update software, let&#39;s take a look at <a href="https://www.npmjs.com/package/react">React</a>. To date, it has over 500 versions that have been released. No, not development snapshots (even though some experimental new versions are included), publically released versions that need to be installed, managed and coped with:</p>
<p><img alt="react versions" src="https://effectivetypescript.com/images/r/e/a/c/t/react-versions-1c6d1bd1.jpeg"/></p>
<p>But once again, that&#39;s not the full story. Creating a simple React app with <code>create-react-app</code> makes us fetch an absolutely absurd amount of code, files and folders under <code>node_modules</code>:</p>
<p><img alt="node-modules" src="https://effectivetypescript.com/images/n/o/d/e/-/node-modules-4f8c2cd7.jpeg"/></p>
<p>The idea of anyone ever understanding what&#39;s going on in there, or even auditing the security of all of it, is simply absurd! Don&#39;t believe me? Have a look at a dependency graph of this newly created &#34;Hello world&#34; project:</p>
<p><img alt="dependencies for a simple project" src="https://effectivetypescript.com/images/d/e/p/e/n/dependencies-for-a-simple-app-3da0fdaf.jpeg"/></p>
<p>There are almost 1500 different modules in there! Many of those will have updates eventually. Many of those will also have breaking changes. You will run into problems with that. And even if you don&#39;t, the chances of something malicious getting in there, or for the development stack to get too large for you to be able to explore it is a question of time, rather one of probability. Once again, do not update!</p>
<h3>A more stable world without updates</h3>
<p>Let&#39;s look at some software that&#39;s the exact opposite. It&#39;s stable, doesn&#39;t have many breaking changes, and comes with &#34;batteries included&#34;. No, i&#39;m not talking about Angular, because even that&#39;s a mess in comparison, i&#39;m talking about the <a href="https://www.lazarus-ide.org/">Lazarus IDE</a>, the modern and perhaps the only way to write Pascal code!</p>
<p><img alt="lazarus ide" src="https://effectivetypescript.com/images/l/a/z/a/r/lazarus-ide-e66e70cb.jpeg"/></p>
<p>But it&#39;s not just a tool for writing code, instead, it does something a bit more amazing and peculiar. It also includes the <a href="https://en.wikipedia.org/wiki/Lazarus_Component_Library">Lazarus Component Library</a>, a large package of components and classes that concern not only GUI development (which, by the way, is abstracted away from the platforms entirely), but also offers lots of useful functionality that would otherwise need to be installed separately in almost any other tech stack out there:</p>
<p><img alt="lazarus component library" src="https://effectivetypescript.com/images/l/a/z/a/r/lazarus-component-library-ec79c91c.png"/></p>
<p>Consider a scenario in which you want a MySQL driver for your app. In npm, you install it with bunches of dependencies. In Java, you pull it down with Maven or Gradle. In Python, you probably mess around with native extensions and have to install additional packages for your OS/container for it to even work. But with Lazarus, you drop it from the component palette into your application and are on your way. More platforms should be like that! Only support a known and trusted subset of software packages, keep them in tree and update them with the larger software package, in this case, the IDE.</p>
<p>Some of you might realize that what i&#39;m describing is actually a lot like the <a href="https://docs.freebsd.org/en/books/handbook/ports/">FreeBSD approach to packages</a> - a stable enclave of &#34;good software&#34;, that&#39;s optionally built upon by &#34;ports&#34;, external and less table packages which the user will have to install themselves while being aware that those aren&#39;t supported. This sort of discouragement is exactly what most of the developers behind npm should have experienced more of! Same for React, Angular and most other technologies out there!</p>
<p>What i&#39;m saying is that most of the integrations, dependencies and other software should be kept &#34;in-tree&#34; for most tools and packages out there. To hell with dynamic linking, use stable and minimalistic packages where needed, much like Windows does instead of Linux. Not only that, but put anything and everything you will ever need within the standard library or one or two large additional libraries. When eventually people will want to do more, provide pushback and curb their enthusiasm, make them do less instead of more. Slow down their pace of development and therefore also updates, preferring stable and good software in 5 to 10 years, as opposed to a half baked SaaS trap in 2 years, which will stop being supported in 4. Yes, at this point i&#39;m getting into why this probably won&#39;t be possible in our current society, but my thoughts on the subject are unchanged by this reality.</p>
<h3>It&#39;s already happening</h3>
<p>But that&#39;s not to say that large, breaking releases aren&#39;t already happening and that people aren&#39;t sticking with the more stable stuff. Just look at <a href="https://snyk.io/blog/developers-dont-want-to-leave-java-8-as-64-hold-firm-on-their-preferred-release/">JDK versions that are used</a> in the industry:</p>
<p><img alt="java versions" src="https://effectivetypescript.com/images/j/a/v/a/-/java-versions-dca7d97c.jpeg"/></p>
<p>The majority of existing projects out there are stuck with JDK 8, either due to their dependencies, their requirements, the ecosystem surrounding them, people not knowing about the benefits of the newer versions or simply not caring, or maybe the whole migration process being so time consuming, complicated and expensive that most companies out there simply don&#39;t want to touch the idea of doing that with a 10 foot pole. Essentially, what i described above is happening, but for all of the wrong reasons!</p>
<p>That brings me to the next point - situations like that are unavoidable. Sooner or later, there will be a significant amount of projects out there that will be stuck on old versions. There will be plenty of .NET 2.0 projects out there that will be running on dated installations of Windows Server 2012, instead of running the latest cross platform .NET Core or nowadays just .NET 5+. There will be plenty of old Java projects out there, or old PHP 5 projects out there and so on.</p>
<p>And my argument is not that this should be the expected outcome, but rather that it&#39;s something inevitable. Therefore, we should prepare for the eventual mess of legacy software, with entire languages possibly dying out and there being <a href="https://www.shrm.org/hr-today/news/hr-news/pages/desperate-need-for-cobol-programmers-underlines-importance-of-workforce-planning.aspx">significant issues in finding developers for them</a>, once it&#39;s discovered that there&#39;s actually software that&#39;s mission critical running in some old forgotten server room. And the easier we&#39;ll make dealing with old code for ourselves, the easier our lives will be - the more focus we&#39;ll put on truly non-breaking security updates that keep your dated software alive and running well, the better our future will be.</p>
<p>To that end, it&#39;s actually imperative that we slow down our development and the speed of updates, which add new features.</p>
<h3>Forcing things to slow down</h3>
<p>It&#39;s important that code written 20 years in the future remain vaguely similar to what we have now, so that old codebases can be recognized. Think Java Streams API, over syntactic sugar that changes how the actual language works. Think more along the lines of a stable base, that&#39;s well documented, thoroughly tested and <a href="https://www.youtube.com/watch?v=lFRKrHE8oPo&amp;t=518s">helps you use it with its discoverability</a>, instead of making you do some long forgotten Maven rituals that are like something out of Warhammer 40k, because noone bothered to write documentation in the pursuit of agility.</p>
<p>Bring back the old days where we engineered software to be used long term, instead of the current day world of: &#34;Move fast and break things... oh, and don&#39;t bother thinking about what&#39;ll happen in 10 years, because your CV will be full of bleeding edge stuff, your bank account will be loaded and the troubles with most of the projects behind you won&#39;t be the slightest of your concerns.&#34; Realistically, you probably don&#39;t care about this stuff, but on the grand scale of things, perhaps you should.</p>
<p>I don&#39;t know about you, but i think that we shouldn&#39;t even need containers for reproducible environments in the first place. We should take a page out of the BSD operating system group book, instead of the GNU/Linux distros that are patched together out of bunches of different pieces of software of vastly varying quality. We shouldn&#39;t bend to the whims of the businesses which want things done yesterday. We should strive for the standards of engineering, where we are in control of the stacks that we work with and actually know what&#39;s going on inside of them.</p>
<p>Why do we need a new Java version every year and to only support the LTS ones for 5 years? Why do we need multiple Ubuntu releases per year and to only support the LTS ones for 5 years? Why not a new release every 5 years with everything else between being just patches and non breaking changes and a new major release every 20 years instead?</p>
<p>If things don&#39;t work out that way, then eventually we&#39;ll just have bunches of clueless code monkeys that execute npm commands that they don&#39;t understand to use frameworks and mechanisms which they have no hope of understanding to create as much value as quickly possible in the short period before all of that goes to hell and there&#39;s the eventual breakdown of nothing working and noone having any idea of why. I&#39;m exaggerating slightly, but sooner or later software projects out there will exceed the cognitive capabilities of any single person - the only question is whether that will happen in 50 or 500 years.</p>
<h3>What to actually do now?</h3>
<p>Don&#39;t choose <a href="https://vimeo.com/156706113">Clusterpoint</a> for your project, which actually died in just a few years and now needs to be maintained in one of the legacy projects that i&#39;m stuck in. Instead, pick <a href="https://www.postgresql.org/">PostgreSQL</a> and use it for <a href="https://www.postgresql.org/docs/release/">more than 20 years</a>. Realistically, you can&#39;t avoid updates entirely, but you can at least try to decrease the frequency of them that you&#39;ll run into and will have to deal with.</p>
<p>Use self contained packages and only use them for the things that they are good for - for example, Ruby on Rails for a simple webapp will be a better choice than stitching together 20 different libraries. Having the freedom of choice in the library case will cause more problems than its worth.</p>
<p>And lastly, <a href="http://boringtechnology.club/">choose boring technology</a>. Only use software that you&#39;re sure will be supported in 10 years. Only use software, which has very few &#34;unknown unknowns&#34;. Only use software, where the development pace has slowed down to a reasonable degree, as opposed to React pulling a sneaky on everyone and introducing hooks, which was a pretty bad move, especially if you needed to migrate to them. </p>
<p>Use maintenance mode software:</p>
<ul>
<li>Debian over Fedora</li>
<li>Docker Swarm over Kubernetes</li>
<li>Java over Go</li>
<li>Angular over React</li>
</ul>
<p>Of course, this only applies to projects that you&#39;re about to start. Chances are, that if you&#39;re working in the industry and will have to handle codebases written by others, then <a href="https://earthly.dev/blog/brown-green-language/">preferring brownfield technologies will make you less happy</a>, given that there will be more bad ones out there. Your mileage may vary and don&#39;t expect all of the answers here.</p>
<p>As for the actual updates: the above approaches should decrease the frequency at which they need to be done. That said, the title of the article is not entirely honest - do install security updates and do install updates to the LTS software that you&#39;re using, be it Ubuntu LTS, Unity LTS, Java 11, or anything else... Just be sure that you have backups that work before doing that!</p>
<h3>Update</h3>
<p>I&#39;ve cleaned the text up a little bit and have decided to extract an idea about a versioning scheme out of the main body of text.</p>
<p>I believe that software could benefit from something more finely grained than semantic versioning. </p>
<p>Perhaps an alternate scheme, that goes more into detail about what&#39;s included in any given release:</p>
<ul>
<li>major new functionality changes</li>
<li>minor, backwards compatible&#39;ish functionality additions</li>
<li>patch, bug fixes that could still break code that&#39;s written with them in mind</li>
<li>security, fixes that should not affect code bugs as long as those do not concern security exploits</li>
</ul>
<p>Maybe it would be possible to have those patch versions be globally unique, so that you&#39;d know that your software <code>V5.152.4567.7213</code> has had 5 major versions released so far, 152 feature releases across those major versions, 4567 bug fixes to date and 7213 security fixes? Thus, you could tie them to Jira ticket numbers or what have you, though it would probably break some ordering of these versions somewhere, so i&#39;m not entirely sure about that. Granted, i can&#39;t actually tell whether adding that sort of complexity would actually be good for anyone, seeing as people seem to have trouble keeping themselves to the standards set forth by semantic versioning already. </p>
<h3>Update #2</h3>
<p>I&#39;ve actually written <a href="https://blog.kronis.dev/articles/stable-software-release-system">a separate article about how software versioning could be done</a>, with a larger focus on stability and backwards compatibility. I still think that i&#39;m quite there yet in regards to the quality of my writing, but it should serve as a conceptual alternative to semver, maybe it&#39;s worth a look at?</p>
<p>Someone actually posted this article on Hacker News, though sadly i missed it due to being busy with my work. Nonetheless, you can go to the thread and <a href="https://bit.ly/30i6Eep">read my comment</a>, which should provide a real world example of why breaking changes and large generational shifts can be a very time consuming thing.</p>
<p>To sum up everything above in a single sentence:</p>
<blockquote>
<p>In my eyes it could be pretty nice to have a framework version that&#39;s supported for 10-20 years and is so stable that it can be used with little to no changes for the entire expected lifetime of a system.</p>
</blockquote>
    </section>
    <i id="to-start"></i>
</section></div>
  </body>
</html>
