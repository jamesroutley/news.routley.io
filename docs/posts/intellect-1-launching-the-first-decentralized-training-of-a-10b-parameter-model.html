<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.primeintellect.ai/blog/intellect-1">Original</a>
    <h1>INTELLECT–1: Launching the First Decentralized Training of a 10B Parameter Model</h1>
    
    <div id="readability-page-1" class="page"><div><div id="blogRichText" fs-toc-element="contents" fs-toc-offsettop="45vh"><p>We&#39;re excited to launch INTELLECT-1, the first decentralized training run of a 10-billion-parameter model, inviting anyone to contribute compute and participate. This brings us one step closer towards open source AGI.</p><p>Recently, we published <a href="https://www.primeintellect.ai/blog/opendiloco">OpenDiLoCo</a>, an open-source implementation and scaling of DeepMind’s Distributed Low-Communication (DiLoCo) method, enabling globally distributed AI model training. We not only replicated and open sourced this work but successfully scaled it to the 1B parameter size.</p><p>Now, we are <strong>scaling it up by a further 10× to 10B-parameter model size, ~25x from the original research.</strong> This brings us to the third step in our <a href="https://www.primeintellect.ai/blog/introducing-prime-intellect">masterplan</a>: to collaboratively train frontier open foundation models: from language, agents to scientific models.</p><p>Our goal is to solve decentralized training step-by-step to ensure AGI will be open-source, transparent, and accessible, preventing control by a few centralized entities and accelerate human progress.</p><figure><p><iframe allowfullscreen="true" frameborder="0" scrolling="no" src="https://www.youtube.com/embed/eZ-hlkkPsIA" title="INTELLECT-1: The First Decentralized Training of a 10B Parameter Model"></iframe></p></figure><h2>Launch Partners and Contributors</h2><p>We are excited and grateful to be joined by leading open-source AI players like Hugging Face, SemiAnalysis, Arcee, Hyperbolic, Olas, Akash, Schelling AI and many others contributing compute to this decentralized training run.</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/66239f0441b09824acb92c7e/67079b8e1e9378b02a7d7e32_67079b87b20db5c1cc14292c_var%25205%2520(2).png" loading="lazy" alt=""/></p></figure><p>‍</p><h2>How To Contribute Compute</h2><p>Anyone can now contribute resources to advance open-source AI through our platform and later on also more easily with their own hardware.</p><ul role="list"><li>Dashboard  <a href="https://app.primeintellect.ai/intelligence">https://app.primeintellect.ai/intelligence</a> (watch the decentralized training and contribute compute)</li><li>Code: <a href="https://github.com/PrimeIntellect-ai/Prime">https://github.com/PrimeIntellect-ai/Prime</a></li></ul><h2>Paradigm Shift for Decentralized Training.</h2><p>As Jack Clark, co-founder of Anthropic, highlighted, no model has yet been efficiently trained at the scale of 10B parameters across globally distributed workers. Our initial OpenDiLoCo run broke through the 1B parameter barrier, and with INTELLECT-1, we are reaching a new level of scale for decentralized training.</p><p>‍</p><div><blockquote data-lang="en" data-theme="dark"><p lang="en" dir="ltr">Have there been any distributed training runs above 10bn parameters? All the papers I read about distributed training (e.g., OpenDiLoCo) seem to involve ~1bn parameter LLMs.</p>— Jack Clark (@jackclarkSF) <a href="https://twitter.com/jackclarkSF/status/1819859171703181586?ref_src=twsrc%5Etfw">August 3, 2024</a></blockquote> </div><p>DiLoCo enables the training of AI models on islands of poorly connected devices. The method allows for data parallel training on these different islands, requiring synchronization of pseudo-gradients only every few hundred steps. It significantly reduces the frequency of communication (up to 500 times), thus lowering the bandwidth requirements for distributed training.</p><figure><p><img src="https://cdn.prod.website-files.com/66239f0441b09824acb92c7e/6705c99f6c209ac777ee6bf2_6705c9867159c8d1184433a2_Group%2520482180%2520(1).png" loading="lazy" alt=""/></p></figure><p>‍</p><h2>Prime: Our Decentralized Training Framework</h2><p>Since our initial open-source release, we have improved our distributed training framework across two key dimensions:</p><h3>1. Algorithmic progress</h3><p>Many of our ablations, building on top of our <a href="https://www.primeintellect.ai/blog/opendiloco">OpenDiLoCo</a> work, have shown great promise in further reducing communication requirements. Notably, our quantization experiments on pseudo-gradients have reduced bandwidth requirements by up to 2000x, combining int8 quantization of the pseudo-gradients with an outer optimizer synchronization every 500 steps. These results have been effective at smaller scales, and we are excited to scale them to larger model sizes.</p><h3>2. Scalable Decentralized Training Framework</h3><p>Distributed training is both an engineering and research challenge. Achieving fault-tolerant <a href="https://www.semianalysis.com/p/multi-datacenter-training-openais">training across distributed data centers</a> is something even the largest AI labs are striving to solve today.</p><p>We are excited to announce the release of a new decentralized training framework called <a href="https://github.com/PrimeIntellect-ai/ZeroBand">Prime</a>. Prime enables fault-tolerant training, supports dynamic on-/off-ramping of compute resources, and optimizes communication and routing across a globally distributed network of GPUs.</p><p>This framework forms the foundation of our open-source tech stack, designed to support our own and other decentralized training algorithms beyond OpenDiLoCo. By building on this infrastructure, we aim to push the boundaries of what is possible with globally distributed AI training.</p><h3><strong>Key Features:</strong></h3><ul role="list"><li><strong>ElasticDeviceMesh for Fault Tolerant Training:</strong><ul role="list"><li>In Prime, we’ve added a new distributed abstraction called ElasticDeviceMesh which encapsulates dynamic global process groups for fault-tolerant communication across the internet and local process groups for communication within a node or datacenter.</li><li>The ElasticDeviceMesh manages the resizing of the global process groups when nodes join or leave, unlike the standard DeviceMesh in torch distributed, which will crash and require a cold restart to resize the process group.</li><li>In order to know when to resize the process groups, we use a heartbeat mechanism to discover dead nodes and remove them from the process group. Crashing nodes will attempt a best effort deathrattle to fail their own heartbeat quickly, saving its comrades the timeout.</li></ul></li><li><strong>Asynchronous distributed checkpointing</strong><ul role="list"><li>Due to the size of the model, checkpointing can be an expensive operation, taking up to 20 minutes on the nodes we tested. This would reduce our compute utilisation if it blocked the main training process.</li><li>In order to minimize the blocking time, we first checkpoint into /dev/shm which is a RAM backed filesystem. This operation is much faster and we can unblock the main training process once the checkpoint has been created in /dev/shm.</li><li>We then use two subprocesses to asynchronously copy the checkpoint out of /dev/shm into the checkpoint directory on disk as well as upload it to the remote.</li></ul></li><li><strong>Live checkpoint recovery</strong><ul role="list"><li>Nodes that wish to join the run mid-training need to be able to get the most recent state of the model and optimizer before being able to contribute to the training. They must complete this operation in the time window between two outer steps, otherwise, the checkpoint they receive would be stale.</li><li>In order to do this quickly, we have the joining nodes request the checkpoints from their peers which all host a sidecar HTTP server serving the latest checkpoint out of /dev/shm.</li><li>Once the joining node has downloaded and initialized the model, it skips the inner steps and joins the outer step with zero pseudo-gradients. This is to prevent the joining node from stalling the existing nodes. If the joining node also performed the inner steps, it would be late to the outer step by the time it took to download and load the checkpoint, reducing the clusters compute utilisation.</li></ul></li><li><strong>Custom Int8 All-Reduce Kernel</strong><ul role="list"><li>In our experiments, we found that we are able to perform int8 quantization on the pseudo gradients without any impact on the loss curves. This means that we can reduce the payload size of each outer step all-reduce by 4x if we communicate the pseudo-gradients in int8 instead of fp32.</li><li>However, we need to accumulate the reduce in fp32, dequantizing and re-quantizing intermediate results during the all-reduce. This is not supported by any collective communication libraries.</li><li>We thus implemented our own fully pipelined ring-reduce kernel in C++ which is JIT compiled as a custom operator using the torch library.</li><li>However, with the amount of quantization work we needed to perform, using the torch ops (quantize_per_tensor, scatter_add, index, etc) was too slow, resulting in underutilisation of our target network bandwidth of 4 Gbps.</li><li>We thus implemented our own multithreaded uint8 ops in C++  to perform the quantization and dequantization operations, improving the quantization speed by more than 60x.</li></ul></li><li><strong>Maximising bandwidth utilization:</strong><ul role="list"><li>By sharding our DiLoCo pseudo-gradients in a node, we can maximise network bandwidth utilization by opening multiple connections at the same time when performing the all-reduce. This yielded a transfer speed improvement of 8x on some nodes.</li><li>Relying on the public IP forward resulted in poor or unstable p2p bandwidth on some compute providers. To mitigate this, we employ VPN technology to optimize peer-to-peer connections between nodes, allowing us to better utilize the available internet bandwidth between nodes by modifying the routing of packets through the internet.</li><li>We’ve improved bandwidth utilization between nodes in similar data center settings by up to 40x compared to our OpenDiLoCo release, achieving up to 4Gb/s connections between data centers across the whole United States.</li></ul></li><li><strong>PyTorch FSDP2 / DTensor ZeRO-3 implementation</strong><ul role="list"><li>In order to fit the 10B model training within our given memory resources, we had to do shard the model weights, gradients and optimizer states between intra-node GPUs.</li><li>We achieved this using the fully_shard API from PyTorch FSDP2 which wraps the model parameters as DTensors and registers hooks to schedule all-gather and reduce-scatter on the tensors when they are used. FSDP2 also optimizes the collectives by bucketing the parameters into FSDPParamGroups. This allows us to execute the collectives on larger tensors, improving protocol-to-payload ratio and improving the overlap from pipelining. We employ the same trick for our pseudo-gradients, bucketing them by layer.</li></ul></li><li><strong>CPU Off-Loading</strong><ul role="list"><li>Our Diloco optimizer does not add any GPU overhead. All the tensors required by the Diloco optimizer are offloaded to CPU memory.</li><li>Since we only perform a global sync every hundreds of steps, the reduced speed of copying and calculating the pseudo-gradient on cpu is negligible relative to the time to execute the inner steps and all-reduce.</li></ul></li></ul><p>For more information, check out the <a href="https://github.com/PrimeIntellect-ai/ZeroBand">repo</a>, and stay tuned for our upcoming research paper.</p><p>All of this enables <strong>INTELLECT-1 to train at the 10B parameter scale with 98% compute utilization across multiple distributed workers.</strong> For our production training run, we chose to synchronize every 100 steps, which, on islands of 8xH100 nodes, takes roughly 40 minutes to complete. We quantize the pseudo-gradients to int8, reducing communication requirements by 400x. <strong>The all-reduce synchronization for the DiLoCo outer optimizer using our new framework takes less than 1 minute</strong>, minimizing communication between nodes to just 1-2% of the total training time.</p><p>‍</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/66239f0441b09824acb92c7e/670728a1606d868d79aaaf9b_67072895c1db4a0e9df11c42_cover-wide.png" loading="lazy" alt=""/></p></figure><h2>INTELLECT-1: The First Decentralized Trained 10B</h2><p>INTELLECT-1 is a 10B parameter model based on the Llama-3 architecture.</p><p>It will be the first model at this scale to be extensively trained on one of the highest-quality open-source datasets, <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu">Fineweb-Edu</a> by Hugging Face.</p><figure><p><img src="https://cdn.prod.website-files.com/66239f0441b09824acb92c7e/670728a0606d868d79aaaf95_6707284390d34e7025a8f59a_image%2520(5)%25201.png" loading="lazy" alt=""/></p></figure><p>Our curated <a href="https://huggingface.co/collections/PrimeIntellect/intellect-1-dataset-6704f3d3a9dee8678da3d407">data mix</a> consists of the following:</p><ul role="list"><li>55% <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu">Fineweb-edu</a></li><li>20% <a href="https://huggingface.co/datasets/mlfoundations/dclm-baseline-1.0-parquet">DLCM</a></li><li>20% <a href="https://huggingface.co/datasets/bigcode/the-stack-v2-dedup">Stack v2</a></li><li>5% <a href="https://huggingface.co/datasets/open-web-math/open-web-math">OpenWebMath</a></li></ul><p>As some of these datasets contain shards that contain correlated data, we pre-shuffled the datasets by random sampling from 12 streaming dataset iterators and resharding the dataset. Our pre-shuffled datasets can be found on <a href="https://huggingface.co/collections/PrimeIntellect/intellect-1-dataset-6704f3d3a9dee8678da3d407">the huggingface hub</a>. The total number of tokens in our data mix, processed with the Llama-3 tokenizer, consists of over 6 trillion tokens.</p><p>We are using the <a href="https://arxiv.org/abs/2405.18392">WSD learning rate scheduler</a>, which maintains a constant learning rate after an initial warm-up phase. This approach offers flexibility in the number of tokens we can train on, depending on the number of compute contributions. Toward the end of training, we plan to implement a cool-down phase using a high-quality dataset to further boost performance, as well as post-training optimizations.</p><h2>Next Steps:</h2><p>INTELLECT-1 is just the first step. We will continue to make progress on our <a href="https://www.primeintellect.ai/blog/our-approach-to-decentralized-training">roadmap</a> to scale decentralized training to the largest and most powerful open frontier scientific, reasoning and coding models.</p><p><strong>Our roadmap includes:</strong></p><ol role="list"><li>Scaling to larger, more powerful open frontier models in scientific, reasoning, and coding domains.</li><li>Developing a system that allows anyone to contribute their own compute resources, using proof mechanisms to ensure secure and verifiable contributions to decentralized training.</li><li>Creating a framework that enables anyone to initiate a decentralized training run, open for contributions from others.</li></ol><p>‍</p><h2>Join Us in Building the Open Future of AI</h2><p>Open-source AI is the key to countering the risks of centralization, but it requires coordinated efforts to harness distributed compute, talent, and capital to compete with leading closed-source labs.</p><p><strong>Join us to advance open and decentralized AI:</strong></p><ul role="list"><li>If you are relentlessly ambitious and want to make this happen, apply for our <a href="https://jobs.ashbyhq.com/PrimeIntellect">open roles</a>.</li><li>Collaborate on <a href="https://www.primeintellect.ai/blog/fast-compute-grants">our AI model initiatives</a> and <a href="https://github.com/PrimeIntellect-ai/OpenDiloco">open-source frameworks</a>.</li><li><a href="https://docs.primeintellect.ai/tutorials-decentralized-training/contribute-compute">Contribute compute</a> &amp; earn ownership in state-of-the-art AI models.</li></ul><p>‍</p><p>‍</p><p>‍</p><p>‍</p></div></div><div><div><p>Acknowledgements</p><p>Sami, Jackmin, and Johannes for their work on the decentralized research. Manveer, Jannik, and Kemal for their work on the platform. Elie Bakouch for his help with composing the dataset. Arthur Douillard et al. for their work on DiLoCo. Tristan Rice and Junjie Wang for discussions and ideas on fault-tolerant training. Chien-Chin Huang and Iris Zhang for ideas and discussions related to asynchronous distributed checkpointing. Yifu Wang for discussions about Tensor Parallel. Andrew Gu for convincing us to switch to FSDP2 to get rid of some weird memory allocation issues we were facing with FSDP1.</p></div></div></div>
  </body>
</html>
