<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sandbox.bio/concepts/bwt">Original</a>
    <h1>The Burrows-Wheeler Transform</h1>
    
    <div id="readability-page-1" class="page"><div><!----><h3>The Burrows-Wheeler Transform</h3> <p>By <a href="https://robert.bio" target="_blank">Robert Aboukhalil</a></p> <p><small>October 9, 2025</small></p> <p>In this interactive article, we explore the borderline-magical algorithm known as the Burrows-Wheeler Transform (BWT). It
		powers data compression in <code>bzip2</code>, and is used by sequence alignment tools like <code>bowtie</code> and <code>bwa</code>, both of which were named after the algorithm.</p> <p>The BWT has 2 key properties:</p> <ol><li>It shuffles strings such that <strong>identical letters tend to be grouped together</strong>, e.g. the BWT of <code>coconut</code> is <code>tooccun</code>.</li> <li>The transform <strong>can be reversed</strong> to get the original string back, which is what makes it useful.</li></ol> <p>Before we dive in, you should know that the BWT has a <strong>third, unofficial property: it is not intuitive</strong>. Many
		of the steps in the algorithm will seem arbitrary and it might not be clear why you&#39;re even doing them. I&#39;m hoping this
		article helps you build some intuition around the BWT.</p> <!----><h4 id="encode"><a href="#encode"><i></i><!----></a> The BWT algorithm<!----></h4><!----><!----> <p>To apply the BWT on a string like <!--[!--><!--]--><!---->, there are 3 steps to follow:</p><!----></div><div><!----><!----><h5 id="intuition"><a href="#intuition"><i></i><!----></a> What&#39;s the dollar sign for?<!----></h5><!----><!----> <p>The <code>$</code> marks the end of the string, and is needed to make the BWT reversible. Without that marker, you could still
		regenerate the matrix in Step <i></i><!---->, but you wouldn&#39;t know which row contains the original string. If it&#39;s
		an English word, you might guess it&#39;s <code>banana</code> and not <code>nabana</code>, but that&#39;s harder to do with DNA because most rotations will look reasonable.</p> <!----><h5 id="intuition"><a href="#intuition"><i></i><!----></a> Intuition behind the BWT<!----></h5><!----><!----> <p>In Step <i></i><!---->, the sorting causes rows that start the same to be more likely to be grouped together. As a
		result, the character that comes right before (i.e. the character in the last column) is also likely to be similar, based on
		repeated patterns in the English language, and also in DNA sequences!</p> <p>For example, in the BWT of <!--[!--><!--]--><!---->,
		the letter <code>c</code> is grouped because it&#39;s always followed by an <code>o</code>. Although <code>o</code> is followed by
		either <code>c</code> or <code>n</code>, it still clusters in the BWT because its corresponding rows end up being sorted next
		to each other.</p> <p>If there was a row in Step <i></i><!----> that started with a letter in between <code>c</code> and <code>n</code>, the <code>o</code>&#39;s would no longer cluster. For example, what happens to the <code>o</code>&#39;s if you add an <code>i</code> to <code>coconut</code>: <!--[!--><!--]--><!---->. Would the <code>o</code>&#39;s
		cluster if you tried <!--[!--><!--]--><!---->?</p> <p>Now it&#39;s your turn: try encoding your name or a repetitive string. Which characters can you add or remove to make the BWT
		cluster more or less?</p> <!----> <!----><h4 id="decode"><a href="#decode"><i></i><!----></a> Decoding the BWT<!----></h4><!----><!----> <p>Given the encoded string, we can reconstruct the matrix from Step <i></i><!----> as follows: Start with an empty matrix,
		prepend the BWT string, sort the strings, and repeat until the matrix is filled. Keep clicking <i>Next</i> below until you reconstruct
		the matrix; the matrix on the right shows the final answer we&#39;re working towards.</p><!----></div><div><!----><p>Once the matrix is filled, we can read off the string from any of the rows since we have the <code>$</code> marker.</p> <!----><h5 id="intuition-decoding"><a href="#intuition-decoding"><i></i><!----></a> Intuition behind the decoding algorithm<!----></h5><!----><!----> <p>Starting from an empty matrix, note that adding the BWT column and sorting gives you the <strong>first column</strong> of the
		expected BWT matrix. If you then prepend and sort a second time, you now have the <strong>first two columns</strong> of the BWT
		matrix. You can keep going to recreate the whole matrix.</p> <p>To understand why this works, let&#39;s consider a scenario where I give you the first 2 columns of the BWT matrix and ask you to
		figure out the rest. Remember that the BWT is the last column of the matrix, i.e. the characters that come right before the
		first column. So by prepending the BWT to the first column, we&#39;re still preserving the relationships between the substrings we
		reconstructed so far (you can imagine the BWT matrix rotates on itself to connect the first and last column together). Then,
		sorting the current set of substrings gives us the first 3 columns of the BWT matrix.</p> <!----> <!----><h4 id="alignment"><a href="#alignment"><i></i><!----></a> How to use BWT for sequence alignment<!----></h4><!----><!----> <p>So far, we&#39;ve seen how to use the Burrows-Wheeler Transform to encode and decode strings. That&#39;s nice and all, but how can we
		use the BWT for sequence alignment, i.e. looking for a small string in a much larger string?</p> <p>To do that, I first need to introduce yet another magical property of the BWT: <i>Last-to-first Mapping</i>.</p> <!----><h5 id="lf-mapping"><a href="#lf-mapping"><i></i><!----></a> Last-to-first Mapping property<!----></h5><!----><!----> <p>This property states that the <strong>order in which you see a letter in the first column is the same order in which you see it in the last column</strong>!</p> <p>Let&#39;s consider the word <code>banana</code>: if we annotate each letter with the number of times it occurs in the string
		before creating the BWT matrix, the letter <code>a</code> appears in the same order in both the first and last column: a<sub>2</sub>, a<sub>1</sub>, a<sub>0</sub>!</p> <div><!--[--><!--[--><!--[--><p><span>$<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>b<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>n<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>n<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--]--></div> <!----><h5 id="substring"><a href="#substring"><i></i><!----></a> Find a substring<!----></h5><!----><!----> <p>With that in mind, let&#39;s find all occurences of the pattern <code>an</code> within <code>banana</code>, using only the first
		and last columns. Let&#39;s begin by finding rows that start with the last character of the pattern (i.e. <code>n</code>)—you&#39;ll see why in a second:</p> <div><!--[--><!--[--><!--[--><p><span>$<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>b<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>n<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>n<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--]--></div> <p>Now that we have an <code>n</code> in the first column, we know that the last column is the character that comes right before <code>n</code>, so we can look for an <code>a</code> in that last column. We find two matches: a<sub>1</sub> and a<sub>0</sub>, so we can visit rows that have those characters in the first column:</p> <div><!--[--><!--[--><!--[--><p><span>$<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>b<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>n<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>n<!----><sub>undefined</sub><!----></span></p><!--]--><!--[!--><p><span>a<!----><sub>undefined</sub><!----></span></p><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--[--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--[--><!--]--><!--[!--><!--]--><!--[!--><!--]--><!--]--><!----> <!--]--></div> <p>And voilà, we found the only matches for our search query of <code>an</code> within <code>banana</code>.</p> <!----><h5 id="lf-decoding"><a href="#lf-decoding"><i></i><!----></a> Wait a minute...<!----></h5><!----><!----> <p>A few sections ago, we decoded the BWT string by recreating the entire BWT matrix, which was a lot of work. Could we instead
		use this LF property to decode the BWT string? As a matter of fact, we can!</p> <p>You can think of decoding the BWT string as a special case of searching, where we&#39;re looking for whichever string ends with <code>$</code>. So we can start by finding the <code>$</code> character, then hop around between the first and column until we find the <code>$</code> once more and we&#39;ll have recreated the reverse of the original string.</p> <!----> <!----><h4 id="next"><a href="#next"><i></i><!----></a> What&#39;s next?<!----></h4><!----><!----> <p>If you somehow made it all the way here <small>(let me know at <a href="https://sandbox.bio/cdn-cgi/l/email-protection" data-cfemail="7d0f121f180f093d12101a18131210141e0e531e1210">[email protected]</a>)</small>, and you can&#39;t get enough of the
		BWT, there&#39;s a lot more you can learn about:</p> <ul><li><strong>Suffix Arrays</strong>: It turns out the way we generated the BWT transform <a href="#encode">above</a> was quite
			inefficient. A string of length <code>n</code> has <code>n</code> rotations, so sorting that list of strings has a time
			complexity of <i>O(n)</i> rotations * <i>O(n log n)</i> comparisons = <i>O(n<sup>2</sup> log n)</i>. There&#39;s an interesting data structure
			called a Suffix Array that you can use to more efficiently generate that matrix. You can learn more about that from Ben
			Langmead&#39;s lecture notes about <a href="https://www.cs.jhu.edu/~langmea/resources/lecture_notes/09_suffix_arrays_v2.pdf" target="_blank" rel="noreferrer"><!----><!---->suffix arrays<!----></a><!----> and <a href="https://www.cs.jhu.edu/~langmea/resources/lecture_notes/bwt_and_fm_index.pdf" target="_blank" rel="noreferrer"><!----><!---->BWT and the FM index<!----></a><!---->.
			Ben&#39;s lab maintains the <a href="https://bowtie-bio.sourceforge.net/bowtie2/manual.shtml" target="_blank" rel="noreferrer"><!----><!---->bowtie2<!----></a><!----> sequence aligner,
			so his slides are a great in-depth resource.</li> <li><strong>FM Index</strong>: In the examples above, the searches were small enough that we hopped between the first and last
			column by eye by looking at every single row. But making millions of queries within a large string like the human genome
			with 3 billion basepairs would be too slow. If you want to learn about how to mitigate those issues in practice, check out
			Ben Langmead&#39;s lecture notes on the <a href="https://www.cs.jhu.edu/~langmea/resources/lecture_notes/bwt_and_fm_index.pdf#page=32" target="_blank" rel="noreferrer"><!----><!---->FM index<!----></a><!---->.</li> <li><strong>Compression</strong>: As I mentioned above, BWT helps with compression because of how it tends to cluster characters
			together. You can learn more about compression from Carl Kingsford&#39;s lecture notes on <a href="https://www.cs.cmu.edu/~15451-f18/lectures/lec25-bwt.pdf#page=7" target="_blank" rel="noreferrer"><!----><!---->BWT and compression<!----></a><!---->.</li></ul> <p>✨ Thanks to Ben Langmead, Niema Moshiri, Maria Nattestad, and Zamin Iqbal for their insightful feedback on this article.</p><!----></div></div>
  </body>
</html>
