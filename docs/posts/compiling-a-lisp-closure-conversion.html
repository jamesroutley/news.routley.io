<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/compiling-a-lisp-12/?utm_source=rss">Original</a>
    <h1>Compiling a Lisp: Closure conversion</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><span data-nosnippet="">
<em><a href="https://academic.oup.com/blog/compiling-a-lisp-0/">first</a></em> – <em><a href="https://academic.oup.com/blog/compiling-a-lisp-11/">previous</a></em>
</span></p>

<p><em>EDIT: /u/thunderseethe correctly points out that this is closure conversion,
not lambda lifting, so I have adjusted the post title from “lambda lifting” to
“closure conversion” accordingly. Thanks!</em></p>

<p>I didn’t think this day would come, but I picked up the <a href="https://academic.oup.com/assets/img/11-ghuloum.pdf">Ghuloum
tutorial</a> (PDF) again and I got a little bit further. There’s just
one caveat: I have rewritten the implementation in Python. It’s available in
the <a href="https://github.com/tekknolagi/ghuloum">same repo</a> in
<a href="https://github.com/tekknolagi/ghuloum/blob/trunk/compiler.py">compiler.py</a>.
It’s brief, coming in at a little over 300 LOC + tests (compared to the C
version’s 1200 LOC + tests).</p>

<p>I guess there’s another caveat, too, which is that the Python version has no
S-expression reader. But that’s fine: consider it an exercise for you, dear
reader. That’s hardly the most interesting part of the tutorial.</p>

<p>Oh, and I also dropped the instruction encoding. I’m doing text assembly now.
Womp womp.</p>

<p>Anyway, converting the lambdas as required in the paper requires three things:</p>

<ul>
  <li>Keeping track of which variables are bound</li>
  <li>Keeping track of which variables are free in a given lambda</li>
  <li>Keeping a running list of <code>code</code> objects that we create as we recurse</li>
</ul>

<p>We have two forms that can bind variables: <code>let</code> and <code>lambda</code>. This means that
we need to recognize the names in those special expressions and modify the
environment. What environment, you ask?</p>

<h3 id="the-closure-converter">The closure converter</h3>

<p>Well, I have this little <code>LambdaConverter</code> class.</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>labels</span><span>:</span> <span>dict</span><span>[</span><span>str</span><span>,</span> <span>list</span><span>]</span> <span>=</span> <span>{}</span>

    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>:</span> <span>set</span><span>[</span><span>str</span><span>],</span> <span>free</span><span>:</span> <span>set</span><span>[</span><span>str</span><span>]):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span>case</span> <span>_</span><span>:</span>
                <span>raise</span> <span>NotImplementedError</span><span>(</span><span>expr</span><span>)</span>

<span>def</span> <span>convert_lambdas</span><span>(</span><span>expr</span><span>):</span>
    <span>conv</span> <span>=</span> <span>LambdaConverter</span><span>()</span>
    <span>expr</span> <span>=</span> <span>conv</span><span>.</span><span>convert</span><span>(</span><span>expr</span><span>,</span> <span>set</span><span>(),</span> <span>set</span><span>())</span>
    <span>labels</span> <span>=</span> <span>[[</span><span>name</span><span>,</span> <span>code</span><span>]</span> <span>for</span> <span>name</span><span>,</span> <span>code</span> <span>in</span> <span>conv</span><span>.</span><span>labels</span><span>.</span><span>items</span><span>()]</span>
    <span>return</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>labels</span><span>,</span> <span>expr</span><span>]</span>
</code></pre></div></div>

<p>We keep the same <code>labels</code> dict for the entire recursive traversal of the
program, but we modify <code>bound</code> at each binding site and <code>free</code> only at lambdas.</p>

<p>To illustrate how they are used, let’s fill in some sample expressions: <code>3</code>,
<code>&#39;a</code>, and <code>#t</code>:</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span>case</span> <span>int</span><span>(</span><span>_</span><span>)</span> <span>|</span> <span>Char</span><span>():</span>  <span># bool(_) is implied by int(_)
</span>                <span>return</span> <span>expr</span>
            <span># ...
</span>
<span>class</span> <span>LambdaTests</span><span>(</span><span>unittest</span><span>.</span><span>TestCase</span><span>):</span>
    <span>def</span> <span>test_int</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>(</span><span>3</span><span>),</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>3</span><span>])</span>

    <span>def</span> <span>test_bool</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>(</span><span>True</span><span>),</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>True</span><span>])</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>(</span><span>False</span><span>),</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>False</span><span>])</span>

    <span>def</span> <span>test_char</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>(</span><span>Char</span><span>(</span><span>&#34;a&#34;</span><span>)),</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>Char</span><span>(</span><span>&#34;a&#34;</span><span>)])</span>
</code></pre></div></div>

<p>Well, okay, sure, we don’t actually need to think about variable names when we
are dealing with simple constants.</p>

<p>So let’s look at variables:</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span># ...
</span>            <span>case</span> <span>str</span><span>(</span><span>_</span><span>)</span> <span>if</span> <span>expr</span> <span>in</span> <span>bound</span><span>:</span>
                <span>return</span> <span>expr</span>
            <span>case</span> <span>str</span><span>(</span><span>_</span><span>):</span>
                <span>free</span><span>.</span><span>add</span><span>(</span><span>expr</span><span>)</span>
                <span>return</span> <span>expr</span>
            <span># ...
</span>
<span>class</span> <span>LambdaTests</span><span>(</span><span>unittest</span><span>.</span><span>TestCase</span><span>):</span>
    <span># ...
</span>    <span>def</span> <span>test_freevar</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>(</span><span>&#34;x&#34;</span><span>),</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>&#34;x&#34;</span><span>])</span>
</code></pre></div></div>

<p>We don’t want to actually transform the variable uses, just add some metadata
about their uses. If we have some variable <code>x</code> bound by a <code>let</code> or a <code>lambda</code>
expression, we can leave it alone. Otherwise, we need to mark it.</p>

<div><div><pre><code><span>(</span><span>let</span> <span>((</span><span>x</span> <span>5</span><span>))</span>
  <span>(</span><span>+</span> <span>x</span>        <span>; bound</span>
     <span>y</span><span>))</span>      <span>; free</span>
</code></pre></div></div>

<p>There’s one irritating special case here which is that we don’t want to
consider <code>+</code> (for example) as a free variable: it is a special language
primitive. So we consider <code>+</code> and the others as always bound.</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span># ...
</span>            <span>case</span> <span>str</span><span>(</span><span>_</span><span>)</span> <span>if</span> <span>expr</span> <span>in</span> <span>BUILTINS</span><span>:</span>
                <span>return</span> <span>expr</span>
            <span># ...
</span>
<span>class</span> <span>LambdaTests</span><span>(</span><span>unittest</span><span>.</span><span>TestCase</span><span>):</span>
    <span># ...
</span>    <span>def</span> <span>test_plus</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>(</span><span>&#34;+&#34;</span><span>),</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>&#34;+&#34;</span><span>])</span>
</code></pre></div></div>

<p>Armed with this knowledge, we can do our first recursive traversal: <code>if</code>
expressions. Since they have recursive parts and don’t bind any variables, they
are the second-simplest form for this converter.</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span># ...
</span>            <span>case</span> <span>[</span><span>&#34;if&#34;</span><span>,</span> <span>test</span><span>,</span> <span>conseq</span><span>,</span> <span>alt</span><span>]:</span>
                <span>return</span> <span>[</span><span>&#34;if&#34;</span><span>,</span>
                        <span>self</span><span>.</span><span>convert</span><span>(</span><span>test</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>),</span>
                        <span>self</span><span>.</span><span>convert</span><span>(</span><span>conseq</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>),</span>
                        <span>self</span><span>.</span><span>convert</span><span>(</span><span>alt</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>)]</span>
            <span># ...
</span>
<span>class</span> <span>LambdaTests</span><span>(</span><span>unittest</span><span>.</span><span>TestCase</span><span>):</span>
    <span># ...
</span>    <span>def</span> <span>test_if</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;if&#34;</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]),</span>
                         <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>[</span><span>&#34;if&#34;</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]])</span>
</code></pre></div></div>

<p>This test doesn’t tell us much yet (other than adding an empty <code>labels</code> and not
raising an exception). But it will soon.</p>

<h3 id="lambda">Lambda</h3>

<p>Let’s think about what <code>lambda</code> does. It’s a bunch of features in a trench
coat:</p>

<ul>
  <li>bind names</li>
  <li>allocate code</li>
  <li>capture outside environment</li>
</ul>

<p>To handle the closure conversion, we have to reason about all three.</p>

<p>First, the lambda binds its parameters as new names. In fact, those are the
<em>only</em> bound variables in a lambda. Consider:</p>

<div><div><pre><code><span>(</span><span>lambda</span> <span>()</span> <span>x</span><span>)</span>
</code></pre></div></div>

<p><code>x</code> is a free variable in that lambda! We’ll want to transform that lambda
into:</p>

<div><div><pre><code><span>;                  +-parameters</span>
<span>;                  |  +-freevars</span>
<span>;                  v  v</span>
<span>(</span><span>labels</span> <span>((</span><span>f0</span> <span>(</span><span>code</span> <span>()</span> <span>(</span><span>x</span><span>)</span> <span>x</span><span>)))</span>
  <span>(</span><span>closure</span> <span>f0</span> <span>x</span><span>))</span>
</code></pre></div></div>

<p>Even if <code>x</code> were bound by some <code>let</code> outside the lambda, it would be free in
the lambda:</p>

<div><div><pre><code><span>(</span><span>let</span> <span>((</span><span>x</span> <span>5</span><span>))</span>
  <span>(</span><span>lambda</span> <span>()</span> <span>x</span><span>))</span>
</code></pre></div></div>

<p>That means we don’t thread through the <code>bound</code> parameter to the lambda body; we
don’t care what names are bound <em>outside</em> the lambda.</p>

<p>We also want to keep track of the set of variables that are free inside the
lambda: we’ll need them to create a <code>code</code> form. Therefore, we also pass in a
new set for the lambda body’s <code>free</code> set.</p>

<p>So far, all of this environment wrangling gives us:</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span># ...
</span>            <span>case</span> <span>[</span><span>&#34;lambda&#34;</span><span>,</span> <span>params</span><span>,</span> <span>body</span><span>]:</span>
                <span>body_free</span> <span>=</span> <span>set</span><span>()</span>
                <span>body</span> <span>=</span> <span>self</span><span>.</span><span>convert</span><span>(</span><span>body</span><span>,</span> <span>set</span><span>(</span><span>params</span><span>),</span> <span>body_free</span><span>)</span>
                <span>free</span><span>.</span><span>update</span><span>(</span><span>body_free</span> <span>-</span> <span>bound</span><span>)</span>
                <span># ...
</span>                <span>return</span> <span># ???
</span>            <span># ...
</span></code></pre></div></div>

<p>There’s also <code>free.update(body_free - bound)</code> in there because any variable
free in a lambda expression is also free in the current expression—well,
except for the variables that are currently bound.</p>

<p>Last, we’ll make a <code>code</code> form and a <code>closure</code> form. The <code>code</code> gets appended
to the global list with a new label and the label gets threaded through to the
<code>closure</code>.</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span>def</span> <span>push_label</span><span>(</span><span>self</span><span>,</span> <span>params</span><span>,</span> <span>freevars</span><span>,</span> <span>body</span><span>):</span>
        <span>result</span> <span>=</span> <span>f</span><span>&#34;f</span><span>{</span><span>len</span><span>(</span><span>self</span><span>.</span><span>labels</span><span>)</span><span>}</span><span>&#34;</span>
        <span>self</span><span>.</span><span>labels</span><span>[</span><span>result</span><span>]</span> <span>=</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>params</span><span>,</span> <span>freevars</span><span>,</span> <span>body</span><span>]</span>
        <span>return</span> <span>result</span>

    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span># ...
</span>            <span>case</span> <span>[</span><span>&#34;lambda&#34;</span><span>,</span> <span>params</span><span>,</span> <span>body</span><span>]:</span>
                <span>body_free</span> <span>=</span> <span>set</span><span>()</span>
                <span>body</span> <span>=</span> <span>self</span><span>.</span><span>convert</span><span>(</span><span>body</span><span>,</span> <span>set</span><span>(</span><span>params</span><span>),</span> <span>body_free</span><span>)</span>
                <span>free</span><span>.</span><span>update</span><span>(</span><span>body_free</span> <span>-</span> <span>bound</span><span>)</span>
                <span># vvvv new below this line vvvv
</span>                <span>body_free</span> <span>=</span> <span>sorted</span><span>(</span><span>body_free</span><span>)</span>
                <span>label</span> <span>=</span> <span>self</span><span>.</span><span>push_label</span><span>(</span><span>params</span><span>,</span> <span>body_free</span><span>,</span> <span>body</span><span>)</span>
                <span>return</span> <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>label</span><span>,</span> <span>*</span><span>body_free</span><span>]</span>
            <span># ...
</span></code></pre></div></div>

<p>This is finicky! I think my first couple of versions were subtly wrong for
different reasons. Tests help a lot here. For every place in the code where I
mess with <code>bound</code> or <code>free</code> in a recursive call, I tried to have a test that
would fail if I got it wrong.</p>

<div><div><pre><code><span>class</span> <span>LambdaTests</span><span>(</span><span>unittest</span><span>.</span><span>TestCase</span><span>):</span>
    <span># ...
</span>    <span>def</span> <span>test_lambda_no_params_no_freevars</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;lambda&#34;</span><span>,</span> <span>[],</span> <span>3</span><span>]),</span>
                         <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[</span>
                             <span>[</span><span>&#34;f0&#34;</span><span>,</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>[],</span> <span>[],</span> <span>3</span><span>]],</span>
                         <span>],</span> <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>&#34;f0&#34;</span><span>]])</span>

    <span>def</span> <span>test_nested_lambda</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;lambda&#34;</span><span>,</span> <span>[</span><span>&#34;x&#34;</span><span>],</span>
                                       <span>[</span><span>&#34;lambda&#34;</span><span>,</span> <span>[</span><span>&#34;y&#34;</span><span>],</span>
                                        <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]]),</span>
                         <span>[</span><span>&#34;labels&#34;</span><span>,</span>
                          <span>[[</span><span>&#34;f0&#34;</span><span>,</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>[</span><span>&#34;y&#34;</span><span>],</span> <span>[</span><span>&#34;x&#34;</span><span>],</span> <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]],</span>
                           <span>[</span><span>&#34;f1&#34;</span><span>,</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>[</span><span>&#34;x&#34;</span><span>],</span> <span>[],</span> <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>&#34;f0&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>]]]],</span>
                          <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>&#34;f1&#34;</span><span>]])</span>
    <span># ... and many more, especially interacting with `let`
</span></code></pre></div></div>

<p>Now let’s talk about the other binder.</p>

<h3 id="let">Let</h3>

<p>Let’s think about what <code>let</code> does by examining a confusing let expression:</p>

<div><div><pre><code><span>(</span><span>let</span> <span>((</span><span>wolf</span> <span>5</span><span>)</span>
      <span>(</span><span>x</span> <span>wolf</span><span>))</span>
  <span>wolf</span><span>)</span>
</code></pre></div></div>

<p>In this expression, there are two <code>wolf</code>s. One of them is bound inside the let,
but the other is free inside the let! This is because <code>let</code> evaluates all of
its bindings without access to the bindings as they are being built up (for
that, we would need <code>let*</code>).</p>

<div><div><pre><code><span>(</span><span>let</span> <span>((</span><span>wolf</span> <span>5</span><span>)</span>   <span>; new binding  &lt;-------------+</span>
      <span>(</span><span>x</span> <span>wolf</span><span>))</span>  <span>; some other variable; free! |</span>
  <span>wolf</span><span>)</span>          <span>; bound to ------------------+</span>
</code></pre></div></div>

<p>So this must mean that:</p>

<ul>
  <li>we need to convert all of the bindings using the original <code>bound</code> and <code>free</code>,
then</li>
  <li>only for the let body, add the new bindings (and use the original <code>free</code>)</li>
</ul>

<p>Which gives us, in code:</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span># ...
</span>            <span>case</span> <span>[</span><span>&#34;let&#34;</span><span>,</span> <span>bindings</span><span>,</span> <span>body</span><span>]:</span>
                <span>new_bindings</span> <span>=</span> <span>[]</span>
                <span>for</span> <span>name</span><span>,</span> <span>val_expr</span> <span>in</span> <span>bindings</span><span>:</span>
                    <span>new_bindings</span><span>.</span><span>append</span><span>([</span><span>name</span><span>,</span> <span>self</span><span>.</span><span>convert</span><span>(</span><span>val_expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>)])</span>
                <span>names</span> <span>=</span> <span>{</span><span>name</span> <span>for</span> <span>name</span><span>,</span> <span>_</span> <span>in</span> <span>bindings</span><span>}</span>
                <span>new_body</span> <span>=</span> <span>self</span><span>.</span><span>convert</span><span>(</span><span>body</span><span>,</span> <span>bound</span> <span>|</span> <span>names</span><span>,</span> <span>free</span><span>)</span>
                <span>return</span> <span>[</span><span>&#34;let&#34;</span><span>,</span> <span>new_bindings</span><span>,</span> <span>new_body</span><span>]</span>
            <span># ...
</span>
<span>class</span> <span>LambdaTests</span><span>(</span><span>unittest</span><span>.</span><span>TestCase</span><span>):</span>
    <span># ...
</span>    <span>def</span> <span>test_let</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;x&#34;</span><span>,</span> <span>5</span><span>]],</span> <span>&#34;x&#34;</span><span>]),</span>
                         <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>[</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;x&#34;</span><span>,</span> <span>5</span><span>]],</span> <span>&#34;x&#34;</span><span>]])</span>

    <span>def</span> <span>test_let_lambda</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;x&#34;</span><span>,</span> <span>5</span><span>]],</span>
                                       <span>[</span><span>&#34;lambda&#34;</span><span>,</span> <span>[</span><span>&#34;y&#34;</span><span>],</span>
                                        <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]]),</span>
                         <span>[</span><span>&#34;labels&#34;</span><span>,</span>
                          <span>[[</span><span>&#34;f0&#34;</span><span>,</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>[</span><span>&#34;y&#34;</span><span>],</span> <span>[</span><span>&#34;x&#34;</span><span>],</span> <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]]],</span>
                          <span>[</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;x&#34;</span><span>,</span> <span>5</span><span>]],</span> <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>&#34;f0&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>]]])</span>

    <span>def</span> <span>test_let_inside_lambda</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;lambda&#34;</span><span>,</span> <span>[</span><span>&#34;x&#34;</span><span>],</span>
                                       <span>[</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;y&#34;</span><span>,</span> <span>6</span><span>]],</span>
                                        <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]]),</span>
                         <span>[</span><span>&#34;labels&#34;</span><span>,</span>
                          <span>[[</span><span>&#34;f0&#34;</span><span>,</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>[</span><span>&#34;x&#34;</span><span>],</span> <span>[],</span>
                                   <span>[</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;y&#34;</span><span>,</span> <span>6</span><span>]],</span>
                                    <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]]]],</span>
                          <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>&#34;f0&#34;</span><span>]])</span>

    <span>def</span> <span>test_paper_example</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;x&#34;</span><span>,</span> <span>5</span><span>]],</span>
                                         <span>[</span><span>&#34;lambda&#34;</span><span>,</span> <span>[</span><span>&#34;y&#34;</span><span>],</span>
                                          <span>[</span><span>&#34;lambda&#34;</span><span>,</span> <span>[],</span>
                                           <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]]]),</span>
                         <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[</span>
                             <span>[</span><span>&#34;f0&#34;</span><span>,</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>[],</span>
                               <span>[</span><span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>],</span> <span>[</span><span>&#34;+&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]],</span>
                             <span>[</span><span>&#34;f1&#34;</span><span>,</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>[</span><span>&#34;y&#34;</span><span>],</span> <span>[</span><span>&#34;x&#34;</span><span>],</span>
                               <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>&#34;f0&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&#34;y&#34;</span><span>]]],</span>
                           <span>],</span>
                          <span>[</span><span>&#34;let&#34;</span><span>,</span> <span>[[</span><span>&#34;x&#34;</span><span>,</span> <span>5</span><span>]],</span> <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>&#34;f1&#34;</span><span>,</span> <span>&#34;x&#34;</span><span>]]])</span>
    <span># ... and many more, especially interacting with `lambda`
</span></code></pre></div></div>

<h3 id="function-calls">Function calls</h3>

<p>Last, and somewhat boringly, we have function calls. The only thing to call out
is again handling these always-bound primitive operators like <code>+</code>, which we
don’t want to have a <code>funcall</code>:</p>

<div><div><pre><code><span>class</span> <span>LambdaConverter</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>convert</span><span>(</span><span>self</span><span>,</span> <span>expr</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>):</span>
        <span>match</span> <span>expr</span><span>:</span>
            <span># ...
</span>            <span>case</span> <span>[</span><span>func</span><span>,</span> <span>*</span><span>args</span><span>]:</span>
                <span>result</span> <span>=</span> <span>[]</span> <span>if</span> <span>isinstance</span><span>(</span><span>func</span><span>,</span> <span>str</span><span>)</span> <span>and</span> <span>func</span> <span>in</span> <span>BUILTINS</span> <span>else</span> <span>[</span><span>&#34;funcall&#34;</span><span>]</span>
                <span>for</span> <span>e</span> <span>in</span> <span>expr</span><span>:</span>
                    <span>result</span><span>.</span><span>append</span><span>(</span><span>self</span><span>.</span><span>convert</span><span>(</span><span>e</span><span>,</span> <span>bound</span><span>,</span> <span>free</span><span>))</span>
                <span>return</span> <span>result</span>
            <span># ...
</span>
<span>class</span> <span>LambdaTests</span><span>(</span><span>unittest</span><span>.</span><span>TestCase</span><span>):</span>
    <span># ...
</span>    <span>def</span> <span>test_call</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>assertEqual</span><span>(</span><span>convert_lambdas</span><span>([</span><span>&#34;f&#34;</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]),</span> <span>[</span><span>&#34;labels&#34;</span><span>,</span> <span>[],</span> <span>[</span><span>&#34;funcall&#34;</span><span>,</span> <span>&#34;f&#34;</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]])</span>
</code></pre></div></div>

<p>Now that we have these new <code>funcall</code>, and <code>closure</code> forms we have to compile
them into assembly.</p>

<h3 id="compiling-closure">Compiling <code>closure</code></h3>

<p>Compiling closure forms is very similar to allocating a string or a vector. In
the first cell, we want to put a pointer to the code that backs the closure
(this will be some label like <code>f12</code>). We can get a reference to that using
<code>lea</code>, since it will be a label in the assembly. Then we write it to the heap.</p>

<p>Then for each free variable, we go find out where it’s defined. Since we know
by construction that these are all strings, we don’t need to worry about having
weird recursion issues around keeping track of a moving heap pointer. Instead,
we know it’s always going to be an indirect from the stack or from the current
closure. Then we write that to the heap.</p>

<p>Then, since a closure is an object, we need to give it a tag. So we tag it with
<code>lea</code> because I felt cute. You could also use <code>or</code> or <code>add</code>. We store the
result in <code>rax</code> because that’s our compiler contract.</p>

<p>Last, we bump the heap pointer by the size of the closure.</p>

<div><div><pre><code><span>def</span> <span>compile_expr</span><span>(</span><span>expr</span><span>,</span> <span>code</span><span>,</span> <span>si</span><span>,</span> <span>env</span><span>):</span>
    <span>match</span> <span>expr</span><span>:</span>
        <span># ...
</span>        <span>case</span> <span>[</span><span>&#34;closure&#34;</span><span>,</span> <span>str</span><span>(</span><span>lvar</span><span>),</span> <span>*</span><span>args</span><span>]:</span>
            <span>comment</span><span>(</span><span>&#34;Get a pointer to the label&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;lea rax, </span><span>{</span><span>lvar</span><span>}</span><span>&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;mov </span><span>{</span><span>heap_at</span><span>(</span><span>0</span><span>)</span><span>}</span><span>, rax&#34;</span><span>)</span>
            <span>for</span> <span>idx</span><span>,</span> <span>arg</span> <span>in</span> <span>enumerate</span><span>(</span><span>args</span><span>):</span>
                <span>assert</span> <span>isinstance</span><span>(</span><span>arg</span><span>,</span> <span>str</span><span>)</span>
                <span>comment</span><span>(</span><span>f</span><span>&#34;Load closure cell #</span><span>{</span><span>idx</span><span>}</span><span>&#34;</span><span>)</span>
                <span># Just a variable lookup; guaranteed not to allocate
</span>                <span>compile_expr</span><span>(</span><span>arg</span><span>,</span> <span>code</span><span>,</span> <span>si</span><span>,</span> <span>env</span><span>)</span>
                <span>emit</span><span>(</span><span>f</span><span>&#34;mov </span><span>{</span><span>heap_at</span><span>((</span><span>idx</span><span>+</span><span>1</span><span>)</span><span>*</span><span>WORD_SIZE</span><span>)</span><span>}</span><span>, rax&#34;</span><span>)</span>
            <span>comment</span><span>(</span><span>&#34;Tag a closure pointer&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;lea rax, </span><span>{</span><span>heap_at</span><span>(</span><span>CLOSURE_TAG</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
            <span>comment</span><span>(</span><span>&#34;Bump the heap pointer&#34;</span><span>)</span>
            <span>size</span> <span>=</span> <span>align</span><span>(</span><span>WORD_SIZE</span> <span>+</span> <span>len</span><span>(</span><span>args</span><span>)</span><span>*</span><span>WORD_SIZE</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;add </span><span>{</span><span>HEAP_BASE</span><span>}</span><span>, </span><span>{</span><span>size</span><span>}</span><span>&#34;</span><span>)</span>
        <span># ...
</span></code></pre></div></div>

<p>So <code>(lambda (x) x)</code> compiles to:</p>

<div><div><pre><code><span>.intel_syntax</span>
<span>.global</span> <span>scheme_entry</span>

<span>f0:</span>
<span>mov</span> <span>rax</span><span>,</span> <span>[</span><span>rsp</span><span>-</span><span>8</span><span>]</span>
<span>ret</span>

<span>scheme_entry:</span>
<span>#</span> <span>Get</span> <span>a</span> <span>pointer</span> <span>to</span> <span>the</span> <span>label</span>
<span>lea</span> <span>rax</span><span>,</span> <span>f0</span>
<span>mov</span> <span>[</span><span>rsi</span><span>+</span><span>0</span><span>],</span> <span>rax</span>
<span>#</span> <span>Tag</span> <span>a</span> <span>cl</span><span>osure</span> <span>pointer</span>
<span>lea</span> <span>rax</span><span>,</span> <span>[</span><span>rsi</span><span>+</span><span>6</span><span>]</span>
<span>#</span> <span>Bump</span> <span>the</span> <span>heap</span> <span>pointer</span>
<span>add</span> <span>rsi</span><span>,</span> <span>16</span>
<span>ret</span>
</code></pre></div></div>

<p>and if we had a closure variable, for example <code>(let ((y 5)) (lambda () y))</code>:</p>

<div><div><pre><code><span>.intel_syntax</span>
<span>.global</span> <span>scheme_entry</span>

<span>f0:</span>
<span>mov</span> <span>rax</span><span>,</span> <span>[</span><span>rdi</span><span>+</span><span>2</span><span>]</span>
<span>ret</span>

<span>scheme_entry:</span>
<span>#</span> <span>Code</span> <span>for</span> <span>y</span>
<span>mov</span> <span>rax</span><span>,</span> <span>20</span>
<span>#</span> <span>Store</span> <span>y</span> <span>on</span> <span>the</span> <span>stack</span>
<span>mov</span> <span>[</span><span>rsp</span><span>-</span><span>8</span><span>],</span> <span>rax</span>
<span>#</span> <span>Get</span> <span>a</span> <span>pointer</span> <span>to</span> <span>the</span> <span>label</span>
<span>lea</span> <span>rax</span><span>,</span> <span>f0</span>
<span>mov</span> <span>[</span><span>rsi</span><span>+</span><span>0</span><span>],</span> <span>rax</span>
<span>#</span> <span>Load</span> <span>cl</span><span>osure</span> <span>cell</span> <span>#</span><span>0</span>
<span>mov</span> <span>rax</span><span>,</span> <span>[</span><span>rsp</span><span>-</span><span>8</span><span>]</span>
<span>mov</span> <span>[</span><span>rsi</span><span>+</span><span>8</span><span>],</span> <span>rax</span>
<span>#</span> <span>Tag</span> <span>a</span> <span>cl</span><span>osure</span> <span>pointer</span>
<span>lea</span> <span>rax</span><span>,</span> <span>[</span><span>rsi</span><span>+</span><span>6</span><span>]</span>
<span>#</span> <span>Bump</span> <span>the</span> <span>heap</span> <span>pointer</span>
<span>add</span> <span>rsi</span><span>,</span> <span>16</span>
<span>ret</span>
</code></pre></div></div>

<p>One nicety of emitting text assembly is that I can add inline comments very
easily. That’s what my <code>comment</code> function is for: it just prefixes a <code>#</code>.</p>

<p>…wait, hold on, why are we reading from <code>rdi+2</code> for a closure variable? That
doesn’t make any sense, right?</p>

<p>That’s because while we are reading off the closure, we are reading from a
tagged pointer. Since we know the index into the closure and also the tag at
compile-time, we can fold them into one neat indirect.</p>

<div><div><pre><code><span>def</span> <span>compile_lexpr</span><span>(</span><span>lexpr</span><span>,</span> <span>code</span><span>):</span>
    <span>match</span> <span>lexpr</span><span>:</span>
        <span>case</span> <span>[</span><span>&#34;code&#34;</span><span>,</span> <span>params</span><span>,</span> <span>freevars</span><span>,</span> <span>body</span><span>]:</span>
            <span>env</span> <span>=</span> <span>{}</span>
            <span>for</span> <span>idx</span><span>,</span> <span>param</span> <span>in</span> <span>enumerate</span><span>(</span><span>params</span><span>):</span>
                <span>env</span><span>[</span><span>param</span><span>]</span> <span>=</span> <span>stack_at</span><span>(</span><span>-</span><span>(</span><span>idx</span><span>+</span><span>1</span><span>)</span><span>*</span><span>WORD_SIZE</span><span>)</span>
            <span># vvvv New for closures vvvv
</span>            <span>for</span> <span>idx</span><span>,</span> <span>fvar</span> <span>in</span> <span>enumerate</span><span>(</span><span>freevars</span><span>):</span>
                <span>env</span><span>[</span><span>fvar</span><span>]</span> <span>=</span> <span>indirect</span><span>(</span><span>CLOSURE_BASE</span><span>,</span> <span>(</span><span>idx</span><span>+</span><span>1</span><span>)</span><span>*</span><span>WORD_SIZE</span> <span>-</span> <span>CLOSURE_TAG</span><span>)</span>
            <span># ^^^^ New for closures ^^^^
</span>            <span>compile_expr</span><span>(</span><span>body</span><span>,</span> <span>code</span><span>,</span> <span>si</span><span>=-</span><span>(</span><span>len</span><span>(</span><span>env</span><span>)</span><span>+</span><span>1</span><span>)</span><span>*</span><span>WORD_SIZE</span><span>,</span> <span>env</span><span>=</span><span>env</span><span>)</span>
            <span>code</span><span>.</span><span>append</span><span>(</span><span>&#34;ret&#34;</span><span>)</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>raise</span> <span>NotImplementedError</span><span>(</span><span>lexpr</span><span>)</span>
</code></pre></div></div>

<p>Now let’s call some closures…!</p>

<h3 id="compiling-funcall">Compiling <code>funcall</code></h3>

<p>I’ll start by showing the code for <code>labelcall</code> because it’s a good stepping
stone toward <code>funcall</code> (nice job, Dr Ghuloum!).</p>

<p>The main parts are:</p>

<ul>
  <li>save space on the stack for the return address</li>
  <li>compile the args onto the stack</li>
  <li>adjusting the stack pointer above the locals</li>
  <li>call</li>
  <li>bringing the stack pointer back</li>
</ul>

<p>I think in my last version (the C version) I did this recursively because
looping felt challenging to do neatly in C with the data structures I had
built but since this is Python and the wild west, we’re looping.</p>

<div><div><pre><code><span>def</span> <span>compile_expr</span><span>(</span><span>expr</span><span>,</span> <span>code</span><span>,</span> <span>si</span><span>,</span> <span>env</span><span>):</span>
    <span>match</span> <span>expr</span><span>:</span>
        <span># ...
</span>        <span>case</span> <span>[</span><span>&#34;labelcall&#34;</span><span>,</span> <span>str</span><span>(</span><span>label</span><span>),</span> <span>*</span><span>args</span><span>]:</span>
            <span>new_si</span> <span>=</span> <span>si</span> <span>-</span> <span>WORD_SIZE</span>  <span># Save a word for the return address
</span>            <span>for</span> <span>arg</span> <span>in</span> <span>args</span><span>:</span>
                <span>compile_expr</span><span>(</span><span>arg</span><span>,</span> <span>code</span><span>,</span> <span>new_si</span><span>,</span> <span>env</span><span>)</span>
                <span>emit</span><span>(</span><span>f</span><span>&#34;mov </span><span>{</span><span>stack_at</span><span>(</span><span>new_si</span><span>)</span><span>}</span><span>, rax&#34;</span><span>)</span>
                <span>new_si</span> <span>-=</span> <span>WORD_SIZE</span>
            <span># Align to one word before the return address
</span>            <span>si_adjust</span> <span>=</span> <span>abs</span><span>(</span><span>si</span><span>+</span><span>WORD_SIZE</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;sub rsp, </span><span>{</span><span>si_adjust</span><span>}</span><span>&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;call </span><span>{</span><span>label</span><span>}</span><span>&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;add rsp, </span><span>{</span><span>si_adjust</span><span>}</span><span>&#34;</span><span>)</span>
        <span># ...
</span></code></pre></div></div>

<p>A lot of this carries over exactly to <code>funcall</code>, with a couple differences:</p>

<ul>
  <li>save space on the stack for the return address <em>and the closure pointer</em></li>
  <li>compile the function expression, which can be arbitrarily complex and results
in a closure pointer</li>
  <li>save the current closure pointer</li>
  <li>set up the new closure pointer</li>
  <li>call through the new closure pointer</li>
  <li>restore the old closure pointer</li>
</ul>

<p>I think the stack adjustment math was by and away the most irritating thing to
get right here. Oh, and also remembering to untag the closure when trying to
call it.</p>

<div><div><pre><code><span>def</span> <span>compile_expr</span><span>(</span><span>expr</span><span>,</span> <span>code</span><span>,</span> <span>si</span><span>,</span> <span>env</span><span>):</span>
    <span>match</span> <span>expr</span><span>:</span>
        <span># ...
</span>        <span>case</span> <span>[</span><span>&#34;funcall&#34;</span><span>,</span> <span>func</span><span>,</span> <span>*</span><span>args</span><span>]:</span>
            <span># Save a word for the return address and the closure pointer
</span>            <span>clo_si</span> <span>=</span> <span>si</span> <span>-</span> <span>WORD_SIZE</span>
            <span>retaddr_si</span> <span>=</span> <span>clo_si</span> <span>-</span> <span>WORD_SIZE</span>
            <span>new_si</span> <span>=</span> <span>retaddr_si</span>
            <span># Evaluate arguments
</span>            <span>for</span> <span>arg</span> <span>in</span> <span>args</span><span>:</span>
                <span>compile_expr</span><span>(</span><span>arg</span><span>,</span> <span>code</span><span>,</span> <span>new_si</span><span>,</span> <span>env</span><span>)</span>
                <span>emit</span><span>(</span><span>f</span><span>&#34;mov </span><span>{</span><span>stack_at</span><span>(</span><span>new_si</span><span>)</span><span>}</span><span>, rax&#34;</span><span>)</span>
                <span>new_si</span> <span>-=</span> <span>WORD_SIZE</span>
            <span>compile_expr</span><span>(</span><span>func</span><span>,</span> <span>code</span><span>,</span> <span>new_si</span><span>,</span> <span>env</span><span>)</span>
            <span># Save the current closure pointer
</span>            <span>emit</span><span>(</span><span>f</span><span>&#34;mov </span><span>{</span><span>stack_at</span><span>(</span><span>clo_si</span><span>)</span><span>}</span><span>, </span><span>{</span><span>CLOSURE_BASE</span><span>}</span><span>&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;mov </span><span>{</span><span>CLOSURE_BASE</span><span>}</span><span>, rax&#34;</span><span>)</span>
            <span># Align to one word before the return address
</span>            <span>si_adjust</span> <span>=</span> <span>abs</span><span>(</span><span>si</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;sub rsp, </span><span>{</span><span>si_adjust</span><span>}</span><span>&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;call </span><span>{</span><span>indirect</span><span>(</span><span>CLOSURE_BASE</span><span>,</span> <span>-</span><span>CLOSURE_TAG</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;add rsp, </span><span>{</span><span>si_adjust</span><span>}</span><span>&#34;</span><span>)</span>
            <span>emit</span><span>(</span><span>f</span><span>&#34;mov </span><span>{</span><span>CLOSURE_BASE</span><span>}</span><span>, </span><span>{</span><span>stack_at</span><span>(</span><span>clo_si</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
        <span># ...
</span></code></pre></div></div>

<p>So <code>((lambda (x) x) 3)</code> compiles to:</p>

<div><div><pre><code><span>.intel_syntax</span>
<span>.global</span> <span>scheme_entry</span>

<span>f0:</span>
<span>mov</span> <span>rax</span><span>,</span> <span>[</span><span>rsp</span><span>-</span><span>8</span><span>]</span>
<span>ret</span>

<span>scheme_entry:</span>
<span>#</span> <span>Evaluate</span> <span>arguments</span>
<span>mov</span> <span>rax</span><span>,</span> <span>12</span>
<span>mov</span> <span>[</span><span>rsp</span><span>-</span><span>24</span><span>],</span> <span>rax</span>
<span>#</span> <span>Get</span> <span>a</span> <span>pointer</span> <span>to</span> <span>the</span> <span>label</span>
<span>lea</span> <span>rax</span><span>,</span> <span>f0</span>
<span>mov</span> <span>[</span><span>rsi</span><span>+</span><span>0</span><span>],</span> <span>rax</span>
<span>#</span> <span>Tag</span> <span>a</span> <span>cl</span><span>osure</span> <span>pointer</span>
<span>lea</span> <span>rax</span><span>,</span> <span>[</span><span>rsi</span><span>+</span><span>6</span><span>]</span>
<span>#</span> <span>Bump</span> <span>the</span> <span>heap</span> <span>pointer</span>
<span>add</span> <span>rsi</span><span>,</span> <span>16</span>
<span>#</span> <span>Save</span> <span>the</span> <span>current</span> <span>cl</span><span>osure</span> <span>pointer</span>
<span>mov</span> <span>[</span><span>rsp</span><span>-</span><span>16</span><span>],</span> <span>rdi</span>
<span>mov</span> <span>rdi</span><span>,</span> <span>rax</span>
<span>#</span> <span>Align</span> <span>to</span> <span>one</span> <span>word</span> <span>before</span> <span>the</span> <span>return</span> <span>address</span>
<span>sub</span> <span>rsp</span><span>,</span> <span>8</span>
<span>call</span> <span>[</span><span>rdi</span><span>-</span><span>6</span><span>]</span>
<span>#</span> <span>Rest</span><span>ore</span> <span>stack</span> <span>and</span> <span>cl</span><span>osure</span>
<span>add</span> <span>rsp</span><span>,</span> <span>8</span>
<span>mov</span> <span>rdi</span><span>,</span> <span>[</span><span>rsp</span><span>-</span><span>16</span><span>]</span>
<span>ret</span>
</code></pre></div></div>

<p>Not bad for a 300 line compiler!</p>

<h3 id="wrapping-up">Wrapping up</h3>

<p>I think that’s all there is for today, folks. We got closures, free variable
analysis, and indirect function calls. That’s pretty good.</p>

<p>Happy hacking!</p>

<h4 id="mini-table-of-contents">Mini Table of Contents</h4>

<ul>































    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-0/"><span>Overture</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-1/"><span>The smallest program</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-2/"><span>Integers</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-3/"><span>Booleans, characters, nil</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-4/"><span>Primitive unary functions</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-5/"><span>Primitive binary functions</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-6/"><span>Reader</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-7/"><span>Let</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-8/"><span>If</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-9/"><span>Heap allocation</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-10/"><span>Instruction encoding interlude</span></a>
        
    </li>



    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-11/"><span>Labelled procedure calls</span></a>
        
    </li>











































































































    <li>
        <a href="https://academic.oup.com/blog/compiling-a-lisp-12/"><span>Closure conversion</span></a>
         <span><i>(this page)</i></span> 
    </li>


</ul>


        </div></div>
  </body>
</html>
