<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mckinsey/vizro">Original</a>
    <h1>Vizro ‚Äì toolkit for creating modular data visualization applications</h1>
    
    <div id="readability-page-1" class="page"><div><p>While out on a stroll with a beautiful friend, she mentioned a screensaver she had seen that simulated a flock of birds. It made me think of the boids algorithm, and the natural and mesmerizing flocking phenomena called murmuration. I couldn‚Äôt help but think about it for the rest of the day. So, I decided to try to implement a boids simulation in webgl so that I could stop thinking about it. Its easier to express myself in code than in words, so I figured I‚Äôd just write a blog post about it.</p><figure><img src="https://glitch.at.goth.cafe/images/blog-articles/boids/boids.gif"/></figure><p>Te Boid Algorithm was created by Craig Reynolds in 1986, the term ‚Äúboid‚Äù stands for ‚Äúbird-oid object‚Äù. I always think of a new yorker saying ‚Äúbird‚Äù when I see the word ‚Äúboid‚Äù and I prefer to pronounce it that way üíú. I think the only better option would be ‚Äúbirb‚Äù. The algorithm is a simple yet elegant model for simulating the coordinated motion of a flock of birds. However, its applications extend beyond avian flocking patterns, encompassing schools of fish, crowds, and others!</p><p>Craig Reynolds introduced boids in the 1980s as a computer model for simulating the coordinated motion of flocks. Rather than controlling the entire flock‚Äôs movement, Reynolds‚Äôs model focused on the individual, allowing complex patterns to emerge naturally from the interaction of simpler agents following basic rules.</p><h2 id="the-essence-of-a-birb-boid">The Essence of a Birb (Boid)</h2><p>Each boid maintains a state that includes its position, velocity, and acceleration. Based on this state and the state of its nearby neighbors (which is controlled by a perception distance), every boid makes decisions on where to move next. These decisions arise from three simple rules: cohesion, alignment, and separation.</p><h2 id="diving-deeper-into-the-flocking-rules">Diving Deeper into the Flocking Rules</h2><h3 id="1-cohesion">1. Cohesion</h3><p>Cohesion is the behavior that encourages boids to steer towards the average position of their local flockmates. This causes them to form groups and stay together.</p><h4 id="pseudocode-for-cohesion">Pseudocode for Cohesion:</h4><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>cohesion</span>(<span>boid</span>, <span>boids</span>)<span>:</span>
</span></span><span><span>    <span>perception_radius</span> <span>=</span> <span>SOME_DISTANCE_VALUE</span> <span>// :) Usually larger than separation
</span></span></span><span><span><span></span>    <span>steering_force</span> <span>=</span> <span>Vector</span>(<span>0</span>,<span>0</span>,<span>0</span>)
</span></span><span><span>    <span>total_in_perception</span> <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>each</span> <span>other_boid</span> <span>in</span> <span>boids</span><span>:</span>
</span></span><span><span>        <span>if</span> <span>distance</span>(<span>boid</span>.<span>position</span>, <span>other_boid</span>.<span>position</span>) <span>&lt;</span> <span>perception_radius</span><span>:</span>
</span></span><span><span>            <span>steering_force</span> <span>+=</span> <span>other_boid</span>.<span>position</span>
</span></span><span><span>            <span>total_in_perception</span> <span>+=</span> <span>1</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>total_in_perception</span> <span>&gt;</span> <span>0</span><span>:</span>
</span></span><span><span>        <span>steering_force</span> <span>=</span> <span>steering_force</span> <span>/</span> <span>total_in_perception</span>  <span>// average position
</span></span></span><span><span><span></span>        <span>steering_force</span> <span>=</span> <span>steering_force</span> <span>-</span> <span>boid</span>.<span>position</span>  <span>// direction towards average position
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>return</span> <span>steering_force</span>
</span></span><span><span><span>end</span> <span>function</span>
</span></span></code></pre></div><h3 id="2-alignment">2. Alignment</h3><p>Alignment makes a boid steer in the direction that matches the average heading of its local flockmates. This creates a uniform direction for a group of boids.</p><h4 id="pseudocode-for-alignment">Pseudocode for Alignment:</h4><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>alignment</span>(<span>boid</span>, <span>boids</span>)<span>:</span>
</span></span><span><span>    <span>perception_radius</span> <span>=</span> <span>SOME_DISTANCE_VALUE</span> <span>// :) Usually larger than cohesion
</span></span></span><span><span><span></span>    <span>average_velocity</span> <span>=</span> <span>Vector</span>(<span>0</span>,<span>0</span>,<span>0</span>)
</span></span><span><span>    <span>total_in_perception</span> <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>each</span> <span>other_boid</span> <span>in</span> <span>boids</span><span>:</span>
</span></span><span><span>        <span>if</span> <span>distance</span>(<span>boid</span>.<span>position</span>, <span>other_boid</span>.<span>position</span>) <span>&lt;</span> <span>perception_radius</span><span>:</span>
</span></span><span><span>            <span>average_velocity</span> <span>+=</span> <span>other_boid</span>.<span>velocity</span>
</span></span><span><span>            <span>total_in_perception</span> <span>+=</span> <span>1</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>total_in_perception</span> <span>&gt;</span> <span>0</span><span>:</span>
</span></span><span><span>        <span>average_velocity</span> <span>=</span> <span>average_velocity</span> <span>/</span> <span>total_in_perception</span>  <span>// average velocity
</span></span></span><span><span><span></span>        <span>average_velocity</span> <span>=</span> <span>average_velocity</span>.<span>normalized</span>()  <span>// desired direction
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>return</span> <span>average_velocity</span> <span>-</span> <span>boid</span>.<span>velocity</span>  <span>// the steering force to align with others
</span></span></span><span><span><span></span><span>end</span> <span>function</span>
</span></span></code></pre></div><h3 id="3-separation">3. Separation</h3><p>Separation ensures that boids don‚Äôt get too close to one another. It calculates a force that steers each boid away from its close neighbors.</p><h4 id="pseudocode-for-separation">Pseudocode for Separation:</h4><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>separation</span>(<span>boid</span>, <span>boids</span>)<span>:</span>
</span></span><span><span>    <span>perception_radius</span> <span>=</span> <span>SOME_DISTANCE_VALUE</span>  <span>// Usually smaller to consider only close neighbors
</span></span></span><span><span><span></span>    <span>steering_force</span> <span>=</span> <span>Vector</span>(<span>0</span>,<span>0</span>,<span>0</span>)
</span></span><span><span>    <span>total_in_perception</span> <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>each</span> <span>other_boid</span> <span>in</span> <span>boids</span><span>:</span>
</span></span><span><span>        <span>distance_to_other</span> <span>=</span> <span>distance</span>(<span>boid</span>.<span>position</span>, <span>other_boid</span>.<span>position</span>)
</span></span><span><span>        <span>if</span> <span>0</span> <span>&lt;</span> <span>distance_to_other</span> <span>&lt;</span> <span>perception_radius</span><span>:</span>
</span></span><span><span>            <span>difference</span> <span>=</span> <span>boid</span>.<span>position</span> <span>-</span> <span>other_boid</span>.<span>position</span>
</span></span><span><span>            <span>difference</span> <span>=</span> <span>difference</span> <span>/</span> <span>distance_to_other</span>  <span>// Weight by distance: farther away, less influence
</span></span></span><span><span><span></span>            <span>steering_force</span> <span>+=</span> <span>difference</span>
</span></span><span><span>            <span>total_in_perception</span> <span>+=</span> <span>1</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>total_in_perception</span> <span>&gt;</span> <span>0</span><span>:</span>
</span></span><span><span>        <span>steering_force</span> <span>=</span> <span>steering_force</span> <span>/</span> <span>total_in_perception</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>steering_force</span>
</span></span><span><span><span>end</span> <span>function</span>
</span></span></code></pre></div><p>By combining the forces from these three rules, each boid determines its movement direction in the flock. This elegant trio of rules gives rise to the intricate and lifelike patterns that we witness when running a boid simulation. The magic is in the simplicity: while each individual follows basic logic, the collective exhibits complex, emergent behavior that mirrors natural phenomena. Its beautiful, even in webgl.</p><p>I‚Äôve create an implementation on glitch that you can fork and modify, or just play with. I‚Äôve also embedded it below.</p></div></div>
  </body>
</html>
