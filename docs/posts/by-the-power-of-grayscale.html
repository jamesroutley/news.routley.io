<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zserge.com/posts/grayskull/">Original</a>
    <h1>By the Power of Grayscale</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>When people talk about computer vision, they usually think of <a href="https://opencv.org/">OpenCV</a> or deep neural networks like <a href="https://arxiv.org/html/2304.00501v6">YOLO</a>. But in most cases, doing computer vision implies understanding of the core algorithms, so you can use or adapt them for your own needs.</p><p>I wanted to see how far I could go by stripping computer vision down to the bare minimum: only grayscale 8-bit images, no fancy data structures, plain old C, some byte arrays and a single header file. After all, an image is just a rectangle of numbers, right?</p><p>This post is a guided tour through the algorithms behind <a href="https://github.com/zserge/grayskull">Grayskull</a> – a minimal computer vision library designed for resource-constrained devices.</p><h2 id="pixels">Pixels</h2><p>A grayscale pixel is normally represented as a single byte, where <code>0</code> means black, <code>255</code> means white, and values in between represent various shades of gray.</p><p>A grayscale image is essentially a 2D array of these pixels, defined by its width and height, but for a simpler memory layout languages such as C often represent it as a 1D array of size <code>width * height</code>:</p><div><pre><code data-lang="c"><span>// An image of WxH pixels, stored as a flat array of bytes
</span><span></span><span>struct</span> <span>gs_image</span> <span>{</span> <span>unsigned</span> <span>w</span><span>,</span> <span>h</span><span>;</span> <span>uint8_t</span> <span>*</span><span>data</span><span>;</span> <span>};</span>

<span>// Helpers to get/set pixel values respecting the bounds
</span><span></span><span>uint8_t</span> <span>gs_get</span><span>(</span><span>struct</span> <span>gs_image</span> <span>img</span><span>,</span> <span>unsigned</span> <span>x</span><span>,</span> <span>unsigned</span> <span>y</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span><span>x</span> <span>&lt;</span> <span>img</span><span>.</span><span>w</span> <span>&amp;&amp;</span> <span>y</span> <span>&lt;</span> <span>img</span><span>.</span><span>h</span><span>)</span> <span>?</span> <span>img</span><span>.</span><span>data</span><span>[</span><span>y</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>x</span><span>]</span> <span>:</span> <span>0</span><span>;</span>
<span>}</span>
<span>void</span> <span>gs_set</span><span>(</span><span>struct</span> <span>gs_image</span> <span>img</span><span>,</span> <span>unsigned</span> <span>x</span><span>,</span> <span>unsigned</span> <span>y</span><span>,</span> <span>uint8_t</span> <span>value</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>x</span> <span>&lt;</span> <span>img</span><span>.</span><span>w</span> <span>&amp;&amp;</span> <span>y</span> <span>&lt;</span> <span>img</span><span>.</span><span>h</span><span>)</span> <span>img</span><span>.</span><span>data</span><span>[</span><span>y</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>x</span><span>]</span> <span>=</span> <span>value</span><span>;</span>
<span>}</span>

<span>// A somewhat convenient macro to iterate over all pixels
</span><span></span><span>#define gs_for(img, x, y)                \
</span><span>  for (unsigned y = 0; y &lt; (img).h; y++) \
</span><span>    for (unsigned x = 0; x &lt; (img).w; x++)
</span></code></pre></div><p>This humble start already allows us to do some tricks like inverting or mirroring images:</p><div><pre><code data-lang="c"><span>// invert image (negative): px[x,y] = 255 - px[x,y]
</span><span></span><span>gs_for</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>gs_set</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>255</span> <span>-</span> <span>gs_get</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>));</span>

<span>// mirror the image: swap px[x,y] with px[w-x-1,y]
</span><span></span><span>gs_for</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
<span>for</span> <span>(</span><span>unsigned</span> <span>y</span> <span>=</span> <span>0</span><span>;</span> <span>y</span> <span>&lt;</span> <span>img</span><span>.</span><span>h</span><span>;</span> <span>y</span><span>++</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>unsigned</span> <span>x</span> <span>=</span> <span>0</span><span>;</span> <span>x</span> <span>&lt;</span> <span>img</span><span>.</span><span>w</span><span>/</span><span>2</span><span>;</span> <span>x</span><span>++</span><span>)</span> <span>{</span> <span>// iterate only through the first half
</span><span></span>    <span>uint8_t</span> <span>tmp</span> <span>=</span> <span>gs_get</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>);</span>
    <span>gs_set</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>gs_get</span><span>(</span><span>img</span><span>,</span> <span>img</span><span>.</span><span>w</span> <span>-</span> <span>x</span> <span>-</span> <span>1</span><span>,</span> <span>y</span><span>));</span>
    <span>gs_set</span><span>(</span><span>img</span><span>,</span> <span>img</span><span>.</span><span>w</span> <span>-</span> <span>x</span> <span>-</span> <span>1</span><span>,</span> <span>y</span><span>,</span> <span>tmp</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div><p>We can just as well copy images, crop images, resize or rotate them.
It’s not computer vision yet, but still some basic image processing:</p><div><pre><code data-lang="fallback">struct gs_rect { unsigned x, y, w, h; }; // for regions of interest (ROI)

// crop image src into dst using region of interest (roi)
gs_for(roi, x, y) gs_set(dst, x, y, gs_get(src, roi.x + x, roi.y + y));

// downscale 2x: set pixel to average from 4 neighbouring pixels (2x2)
gs_for(dst, x, y) {
    unsigned sum = 0;
    for (unsigned j = 0; j &lt; 2; j++)
      for (unsigned i = 0; i &lt; 2; i++)
        sum += gs_get(src, x * 2 + i, y * 2 + j);
    gs_set(dst, x, y, sum / 4);
}
</code></pre></div><p>One can do naïve nearest-neighbour resizing, which is fast but looks blocky, or do bilinear interpolation, which is slower and requires floating point operations, but often looks better:</p><div><pre><code data-lang="c"><span>// Nearest-neighbour resize
</span><span></span><span>void</span> <span>gs_resize_nn</span><span>(</span><span>struct</span> <span>gs_image</span> <span>dst</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>src</span><span>)</span> <span>{</span>
    <span>gs_for</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
        <span>unsigned</span> <span>sx</span> <span>=</span> <span>x</span> <span>*</span> <span>src</span><span>.</span><span>w</span> <span>/</span> <span>dst</span><span>.</span><span>w</span><span>,</span> <span>sy</span> <span>=</span> <span>y</span> <span>*</span> <span>src</span><span>.</span><span>h</span> <span>/</span> <span>dst</span><span>.</span><span>h</span><span>;</span>
        <span>gs_set</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx</span><span>,</span> <span>sy</span><span>));</span>
    <span>}</span>
<span>}</span>

<span>// Bilinear resize
</span><span></span><span>GS_API</span> <span>void</span> <span>gs_resize</span><span>(</span><span>struct</span> <span>gs_image</span> <span>dst</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>src</span><span>)</span> <span>{</span>
  <span>gs_for</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
    <span>float</span> <span>sx</span> <span>=</span> <span>((</span><span>float</span><span>)</span><span>x</span> <span>+</span> <span>0.5f</span><span>)</span> <span>*</span> <span>src</span><span>.</span><span>w</span> <span>/</span> <span>dst</span><span>.</span><span>w</span><span>,</span> <span>sy</span> <span>=</span> <span>((</span><span>float</span><span>)</span><span>y</span> <span>+</span> <span>0.5f</span><span>)</span> <span>*</span> <span>src</span><span>.</span><span>h</span> <span>/</span> <span>dst</span><span>.</span><span>h</span><span>;</span>
    <span>sx</span> <span>=</span> <span>GS_MAX</span><span>(</span><span>0.0f</span><span>,</span> <span>GS_MIN</span><span>(</span><span>sx</span><span>,</span> <span>src</span><span>.</span><span>w</span> <span>-</span> <span>1.0f</span><span>)),</span> <span>sy</span> <span>=</span> <span>GS_MAX</span><span>(</span><span>0.0f</span><span>,</span> <span>GS_MIN</span><span>(</span><span>sy</span><span>,</span> <span>src</span><span>.</span><span>h</span> <span>-</span> <span>1.0f</span><span>));</span>
    <span>unsigned</span> <span>sx_int</span> <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>sx</span><span>,</span> <span>sy_int</span> <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>sy</span><span>;</span>
    <span>unsigned</span> <span>sx1</span> <span>=</span> <span>GS_MIN</span><span>(</span><span>sx_int</span> <span>+</span> <span>1</span><span>,</span> <span>src</span><span>.</span><span>w</span> <span>-</span> <span>1</span><span>),</span> <span>sy1</span> <span>=</span> <span>GS_MIN</span><span>(</span><span>sy_int</span> <span>+</span> <span>1</span><span>,</span> <span>src</span><span>.</span><span>h</span> <span>-</span> <span>1</span><span>);</span>
    <span>float</span> <span>dx</span> <span>=</span> <span>sx</span> <span>-</span> <span>sx_int</span><span>,</span> <span>dy</span> <span>=</span> <span>sy</span> <span>-</span> <span>sy_int</span><span>;</span>
    <span>uint8_t</span> <span>c00</span> <span>=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx_int</span><span>,</span> <span>sy_int</span><span>),</span> <span>c01</span> <span>=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx1</span><span>,</span> <span>sy_int</span><span>),</span>
            <span>c10</span> <span>=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx_int</span><span>,</span> <span>sy1</span><span>),</span> <span>c11</span> <span>=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx1</span><span>,</span> <span>sy1</span><span>);</span>
    <span>uint8_t</span> <span>p</span> <span>=</span> <span>(</span><span>c00</span> <span>*</span> <span>(</span><span>1</span> <span>-</span> <span>dx</span><span>)</span> <span>*</span> <span>(</span><span>1</span> <span>-</span> <span>dy</span><span>))</span> <span>+</span> <span>(</span><span>c01</span> <span>*</span> <span>dx</span> <span>*</span> <span>(</span><span>1</span> <span>-</span> <span>dy</span><span>))</span> <span>+</span> <span>(</span><span>c10</span> <span>*</span> <span>(</span><span>1</span> <span>-</span> <span>dx</span><span>)</span> <span>*</span> <span>dy</span><span>)</span> <span>+</span> <span>(</span><span>c11</span> <span>*</span> <span>dx</span> <span>*</span> <span>dy</span><span>);</span>
    <span>gs_set</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>p</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div><p><img src="https://zserge.com/grayskull-img/resize.png" alt="Resize: bilinear and nearest neighbour"/></p><p>Here’s how the original image (left) looks after bilinear resizing (middle) compared to nearest-neighbour resizing (right).</p><h2 id="image-processing">Image processing</h2><p>Now that we can manipulate individual pixels, we can start doing more serious image processing.</p><p>One useful tool is convolutional filters. A filter is a small 2D array (kernel) that is applied to each pixel in the image. The new pixel value is computed as a weighted sum of the neighbouring pixels, where weights are defined by the kernel.</p><div><pre><code data-lang="c"><span>void</span> <span>gs_filter</span><span>(</span><span>struct</span> <span>gs_image</span> <span>dst</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>src</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>kernel</span><span>,</span> <span>unsigned</span> <span>norm</span><span>)</span> <span>{</span>
    <span>gs_for</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
        <span>int</span> <span>sum</span> <span>=</span> <span>0</span><span>;</span>
        <span>gs_for</span><span>(</span><span>kernel</span><span>,</span> <span>i</span><span>,</span> <span>j</span><span>)</span> <span>{</span>
            <span>sum</span> <span>+=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>x</span> <span>+</span> <span>i</span> <span>-</span> <span>kernel</span><span>.</span><span>w</span> <span>/</span> <span>2</span><span>,</span> <span>y</span> <span>+</span> <span>j</span> <span>-</span> <span>kernel</span><span>.</span><span>h</span> <span>/</span> <span>2</span><span>)</span> <span>*</span> <span>(</span><span>int8_t</span><span>)</span><span>gs_get</span><span>(</span><span>kernel</span><span>,</span> <span>i</span><span>,</span> <span>j</span><span>);</span>
        <span>}</span>
        <span>gs_set</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>sum</span> <span>/</span> <span>norm</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>This technique can be used for blurring, sharpening, edge detection and many other effects. Here are some common kernels. Note that they are defined as signed 8-bit integers:</p><div><pre><code data-lang="c"><span>// box blur 3x3, all pixels have equal weight
</span><span></span><span>struct</span> <span>gs_image</span> <span>gs_blur_box</span> <span>=</span> <span>{</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>(</span><span>uint8_t</span> <span>*</span><span>)(</span><span>int8_t</span><span>[]){</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>}};</span>
<span>// gaussian blur 3x3, central pixels have more weight
</span><span></span><span>struct</span> <span>gs_image</span> <span>gs_blur_gaussian</span> <span>=</span> <span>{</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>(</span><span>uint8_t</span> <span>*</span><span>)(</span><span>int8_t</span><span>[]){</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>}};</span>
<span>// sharpen, enhance edges
</span><span></span><span>struct</span> <span>gs_image</span> <span>gs_sharpen</span> <span>=</span> <span>{</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>(</span><span>uint8_t</span> <span>*</span><span>)(</span><span>int8_t</span><span>[]){</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>5</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>}};</span>
<span>// emboss, make image look &#34;3D&#34;
</span><span></span><span>struct</span> <span>gs_image</span> <span>gs_emboss</span> <span>=</span> <span>{</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>(</span><span>uint8_t</span> <span>*</span><span>)(</span><span>int8_t</span><span>[]){</span><span>-</span><span>2</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>}};</span>
</code></pre></div><p>Similarly, we can apply <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel filters</a>, that are useful if we want to detect edges in the image:</p><div><pre><code data-lang="c"><span>struct</span> <span>gs_image</span> <span>gs_sobel_x</span> <span>=</span> <span>{</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>(</span><span>uint8_t</span> <span>*</span><span>)(</span><span>int8_t</span><span>[]){</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>}};</span>
<span>struct</span> <span>gs_image</span> <span>gs_sobel_y</span> <span>=</span> <span>{</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>(</span><span>uint8_t</span> <span>*</span><span>)(</span><span>int8_t</span><span>[]){</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>-</span><span>1</span><span>}};</span>

<span>void</span> <span>gs_sobel</span><span>(</span><span>struct</span> <span>gs_image</span> <span>dst</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>src</span><span>)</span> <span>{</span>
    <span>struct</span> <span>gs_image</span> <span>gx</span> <span>=</span> <span>{</span><span>src</span><span>.</span><span>w</span><span>,</span> <span>src</span><span>.</span><span>h</span><span>,</span> <span>malloc</span><span>(</span><span>src</span><span>.</span><span>w</span> <span>*</span> <span>src</span><span>.</span><span>h</span><span>)};</span>
    <span>struct</span> <span>gs_image</span> <span>gy</span> <span>=</span> <span>{</span><span>src</span><span>.</span><span>w</span><span>,</span> <span>src</span><span>.</span><span>h</span><span>,</span> <span>malloc</span><span>(</span><span>src</span><span>.</span><span>w</span> <span>*</span> <span>src</span><span>.</span><span>h</span><span>)};</span>
    <span>gs_filter</span><span>(</span><span>gx</span><span>,</span> <span>src</span><span>,</span> <span>gs_sobel_x</span><span>,</span> <span>1</span><span>);</span>
    <span>gs_filter</span><span>(</span><span>gy</span><span>,</span> <span>src</span><span>,</span> <span>gs_sobel_y</span><span>,</span> <span>1</span><span>);</span>
    <span>gs_for</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
        <span>int</span> <span>mag</span> <span>=</span> <span>sqrt</span><span>(</span><span>gs_get</span><span>(</span><span>gx</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>*</span> <span>gs_get</span><span>(</span><span>gx</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>+</span> <span>gs_get</span><span>(</span><span>gy</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>*</span> <span>gs_get</span><span>(</span><span>gy</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>));</span>
        <span>gs_set</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>GS_MIN</span><span>(</span><span>mag</span><span>,</span> <span>255</span><span>));</span>
    <span>}</span>
    <span>free</span><span>(</span><span>gx</span><span>.</span><span>data</span><span>);</span>
    <span>free</span><span>(</span><span>gy</span><span>.</span><span>data</span><span>);</span>
<span>}</span>
</code></pre></div><p>Here are some examples of these filters, notice how some of them remove the noise or enhance the edges:</p><p><img src="https://zserge.com/grayskull-img/filter.png" alt="Filters: blur, sharpen, emboss, sobel"/></p><p>The first image is the original, followed by box filter and Gaussian blur filter. Next is the sharpen filter, then emboss filter and finally Sobel filter that highlights edges.</p><h2 id="thresholding">Thresholding</h2><p>To actually “see” objects in an image, we need to segment it into foreground and background, and then operate on the foreground segments, trying to locate objects of interest.</p><p>This is much easier done when an image is binary, so that each pixel is either fully black or fully white. This conversion from grayscale to black-and-white is called thresholding.</p><p>In the simplest case we may consider any pixel above 127 white, and below – black. This is fixed-level thresholding. Of course, in darker environments this thresholding value could be too high and many meaningful details would be lost. So how to pick a threshold value more accurately?</p><div><pre><code data-lang="c"><span>// apply fixed threshold value and binarise the image
</span><span></span><span>GS_API</span> <span>void</span> <span>gs_threshold</span><span>(</span><span>struct</span> <span>gs_image</span> <span>img</span><span>,</span> <span>uint8_t</span> <span>thresh</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>unsigned</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>img</span><span>.</span><span>w</span> <span>*</span> <span>img</span><span>.</span><span>h</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>img</span><span>.</span><span>data</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>img</span><span>.</span><span>data</span><span>[</span><span>i</span><span>]</span> <span>&gt;</span> <span>thresh</span><span>)</span> <span>?</span> <span>255</span> <span>:</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><p>One approach would be to calculate the brightness distribution as a histogram. We know that there are 255 unique values of pixels in a grayscale image, so we iterate through all pixels and count how many of them have this or that value.
Analysing the resulting histogram could give us some clue about which pixel value would work best as a threshold for the particular image.</p><p>A clever way to do this is with Otsu’s method. It automatically determines the optimal threshold by testing every possible value (from 0 to 255). For each value, it splits the image’s pixels into two classes—background and foreground—and calculates their “inter-class variance.” The threshold that maximizes this variance is the one that creates the best separation between the two classes, making it the ideal choice. It works fiarly well on images with good contrast:</p><div><pre><code data-lang="c"><span>// try to find the best threshold to separate &#34;foreground&#34; from &#34;background&#34;
</span><span></span><span>uint8_t</span> <span>gs_otsu_threshold</span><span>(</span><span>struct</span> <span>gs_image</span> <span>img</span><span>)</span> <span>{</span>
  <span>unsigned</span> <span>hist</span><span>[</span><span>256</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>},</span> <span>wb</span> <span>=</span> <span>0</span><span>,</span> <span>wf</span> <span>=</span> <span>0</span><span>,</span> <span>threshold</span> <span>=</span> <span>0</span><span>;</span>
  <span>// calculate how many pixels of each brightness value we have
</span><span></span>  <span>for</span> <span>(</span><span>unsigned</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>img</span><span>.</span><span>w</span> <span>*</span> <span>img</span><span>.</span><span>h</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>hist</span><span>[</span><span>img</span><span>.</span><span>data</span><span>[</span><span>i</span><span>]]</span><span>++</span><span>;</span>
  <span>float</span> <span>sum</span> <span>=</span> <span>0</span><span>,</span> <span>sumB</span> <span>=</span> <span>0</span><span>,</span> <span>varMax</span> <span>=</span> <span>-</span><span>1.0</span><span>;</span>
  <span>for</span> <span>(</span><span>unsigned</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>256</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>sum</span> <span>+=</span> <span>(</span><span>float</span><span>)</span><span>i</span> <span>*</span> <span>hist</span><span>[</span><span>i</span><span>];</span>
  <span>// try to find the threshold that maximises inter-class variance
</span><span></span>  <span>for</span> <span>(</span><span>unsigned</span> <span>t</span> <span>=</span> <span>0</span><span>;</span> <span>t</span> <span>&lt;</span> <span>256</span><span>;</span> <span>t</span><span>++</span><span>)</span> <span>{</span>
    <span>wb</span> <span>+=</span> <span>hist</span><span>[</span><span>t</span><span>];</span>
    <span>if</span> <span>(</span><span>wb</span> <span>==</span> <span>0</span><span>)</span> <span>continue</span><span>;</span>
    <span>wf</span> <span>=</span> <span>(</span><span>img</span><span>.</span><span>w</span> <span>*</span> <span>img</span><span>.</span><span>h</span><span>)</span> <span>-</span> <span>wb</span><span>;</span>
    <span>if</span> <span>(</span><span>wf</span> <span>==</span> <span>0</span><span>)</span> <span>break</span><span>;</span>
    <span>sumB</span> <span>+=</span> <span>(</span><span>float</span><span>)</span><span>t</span> <span>*</span> <span>hist</span><span>[</span><span>t</span><span>];</span>
    <span>float</span> <span>mB</span> <span>=</span> <span>(</span><span>float</span><span>)</span><span>sumB</span> <span>/</span> <span>wb</span><span>;</span>
    <span>float</span> <span>mF</span> <span>=</span> <span>(</span><span>float</span><span>)(</span><span>sum</span> <span>-</span> <span>sumB</span><span>)</span> <span>/</span> <span>wf</span><span>;</span>
    <span>float</span> <span>varBetween</span> <span>=</span> <span>(</span><span>float</span><span>)</span><span>wb</span> <span>*</span> <span>(</span><span>float</span><span>)</span><span>wf</span> <span>*</span> <span>(</span><span>mB</span> <span>-</span> <span>mF</span><span>)</span> <span>*</span> <span>(</span><span>mB</span> <span>-</span> <span>mF</span><span>);</span>
    <span>if</span> <span>(</span><span>varBetween</span> <span>&gt;</span> <span>varMax</span><span>)</span> <span>varMax</span> <span>=</span> <span>varBetween</span><span>,</span> <span>threshold</span> <span>=</span> <span>t</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>threshold</span><span>;</span>
<span>}</span>
</code></pre></div><p>In real life, however, the lighting conditions are often uneven. In such cases a single global threshold may not work well, and neither of the possible 255 threshold values would give a good result.</p><p>To address this, we can use <a href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/adpthrsh.htm">adaptive thresholding</a>. Instead of using a single threshold for the entire image, we compute a local threshold for each pixel based on the average brightness of its neighbouring pixels. This way, we can better handle varying lighting conditions across the image:</p><div><pre><code data-lang="c"><span>gs_for</span><span>(</span><span>src</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
  <span>unsigned</span> <span>sum</span> <span>=</span> <span>0</span><span>,</span> <span>count</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>int</span> <span>dy</span> <span>=</span> <span>-</span><span>radius</span><span>;</span> <span>dy</span> <span>&lt;=</span> <span>(</span><span>int</span><span>)</span><span>radius</span><span>;</span> <span>dy</span><span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>dx</span> <span>=</span> <span>-</span><span>radius</span><span>;</span> <span>dx</span> <span>&lt;=</span> <span>(</span><span>int</span><span>)</span><span>radius</span><span>;</span> <span>dx</span><span>++</span><span>)</span> <span>{</span>
      <span>int</span> <span>sy</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>y</span> <span>+</span> <span>dy</span><span>,</span> <span>sx</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>x</span> <span>+</span> <span>dx</span><span>;</span>
      <span>if</span> <span>(</span><span>sy</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>sy</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>src</span><span>.</span><span>h</span> <span>&amp;&amp;</span> <span>sx</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>sx</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>src</span><span>.</span><span>w</span><span>)</span> <span>{</span>
        <span>sum</span> <span>+=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx</span><span>,</span> <span>sy</span><span>);</span>
        <span>count</span><span>++</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>int</span> <span>threshold</span> <span>=</span> <span>sum</span> <span>/</span> <span>count</span> <span>-</span> <span>c</span><span>;</span>
  <span>gs_set</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>(</span><span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>&gt;</span> <span>threshold</span><span>)</span> <span>?</span> <span>255</span> <span>:</span> <span>0</span><span>);</span>
<span>}</span>
</code></pre></div><p>Compare how various thresholding approaches work on the same image:</p><p><img src="https://zserge.com/grayskull-img/threshold.png" alt="Thresholding: fixed, Otsu, adaptive"/></p><p>The first image is the original, followed by fixed-level thresholding (80), then Otsu’s method and adaptive thresholding. Notice how adaptive thresholding preserves more details in both bright and dark areas of the image, while Otsu’s method struggles with uneven lighting.</p><h2 id="morphological-operations">Morphological operations</h2><p>Due to the way how image sensors work in cameras, images often contain noise.</p><p>This means that after thresholding there would be random individual pixels that do not belong to any object, or small holes in objects, or small gaps between object parts. All of this will confuse the object detection algorithms, but <a href="https://en.wikipedia.org/wiki/Mathematical_morphology">morphological operations</a> can help to clean up the binary image.</p><p>Two most common operations are erosion and dilation. Erosion removes pixels on object boundaries (shrinking the objects), while dilation adds pixels to their boundaries (expanding the objects).</p><p>There is also opening (erosion followed by dilation) and closing (dilation followed by erosion). Opening is useful for removing small objects or noise, while closing is useful for filling small holes in objects.</p><div><pre><code data-lang="c"><span>void</span> <span>gs_erode</span><span>(</span><span>struct</span> <span>gs_image</span> <span>dst</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>src</span><span>,</span> <span>unsigned</span> <span>radius</span><span>)</span> <span>{</span>
  <span>gs_for</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
    <span>uint8_t</span> <span>min_val</span> <span>=</span> <span>255</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>dy</span> <span>=</span> <span>-</span><span>radius</span><span>;</span> <span>dy</span> <span>&lt;=</span> <span>(</span><span>int</span><span>)</span><span>radius</span><span>;</span> <span>dy</span><span>++</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>int</span> <span>dx</span> <span>=</span> <span>-</span><span>radius</span><span>;</span> <span>dx</span> <span>&lt;=</span> <span>(</span><span>int</span><span>)</span><span>radius</span><span>;</span> <span>dx</span><span>++</span><span>)</span> <span>{</span>
        <span>int</span> <span>sy</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>y</span> <span>+</span> <span>dy</span><span>,</span> <span>sx</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>x</span> <span>+</span> <span>dx</span><span>;</span>
        <span>if</span> <span>(</span><span>sy</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>sy</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>src</span><span>.</span><span>h</span> <span>&amp;&amp;</span> <span>sx</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>sx</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>src</span><span>.</span><span>w</span><span>)</span> <span>{</span>
          <span>uint8_t</span> <span>val</span> <span>=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx</span><span>,</span> <span>sy</span><span>);</span>
          <span>if</span> <span>(</span><span>val</span> <span>&lt;</span> <span>min_val</span><span>)</span> <span>min_val</span> <span>=</span> <span>val</span><span>;</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>gs_set</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>min_val</span><span>);</span>
  <span>}</span>
<span>}</span>
<span>void</span> <span>gs_dilate</span><span>(</span><span>struct</span> <span>gs_image</span> <span>dst</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>src</span><span>,</span> <span>unsigned</span> <span>radius</span><span>)</span> <span>{</span>
  <span>gs_for</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>{</span>
    <span>uint8_t</span> <span>max_val</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>dy</span> <span>=</span> <span>-</span><span>radius</span><span>;</span> <span>dy</span> <span>&lt;=</span> <span>(</span><span>int</span><span>)</span><span>radius</span><span>;</span> <span>dy</span><span>++</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>int</span> <span>dx</span> <span>=</span> <span>-</span><span>radius</span><span>;</span> <span>dx</span> <span>&lt;=</span> <span>(</span><span>int</span><span>)</span><span>radius</span><span>;</span> <span>dx</span><span>++</span><span>)</span> <span>{</span>
        <span>int</span> <span>sy</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>y</span> <span>+</span> <span>dy</span><span>,</span> <span>sx</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>x</span> <span>+</span> <span>dx</span><span>;</span>
        <span>if</span> <span>(</span><span>sy</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>sy</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>src</span><span>.</span><span>h</span> <span>&amp;&amp;</span> <span>sx</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>sx</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>src</span><span>.</span><span>w</span><span>)</span> <span>{</span>
          <span>uint8_t</span> <span>val</span> <span>=</span> <span>gs_get</span><span>(</span><span>src</span><span>,</span> <span>sx</span><span>,</span> <span>sy</span><span>);</span>
          <span>if</span> <span>(</span><span>val</span> <span>&gt;</span> <span>max_val</span><span>)</span> <span>max_val</span> <span>=</span> <span>val</span><span>;</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>gs_set</span><span>(</span><span>dst</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>max_val</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div><p>Here’s how morphological operations can clean up a rather confusing image with ArUco markers:</p><p><img src="https://zserge.com/grayskull-img/morphing.png" alt="Aruco markers: original, thresholded, eroded, dilated"/></p><p>The first image is the original, followed by thresholded image (Otsu). Next we do erosion followed by dilation. Since the markers are black it might sound odd, but since morpological operations work on white pixels we essentially perform closing, but for black pixels. We could also invert the image first, then do opening and invert back.</p><p>At the end all markers are shrinked to their original dimensions and all of them are easily detectable by shape and size.</p><h2 id="blobs-and-contours">Blobs and contours</h2><p>Once we have a clean binary image, we can start detecting objects in it. A classic way to do this is by finding connected components (blobs).</p><p>A “blob” is a group of connected white pixels (255) that form an object. The simplest way to find blobs is by using a flood-fill algorithm or depth-first search (DFS) to label connected pixels:</p><div><pre><code data-lang="c"><span>void</span> <span>gs_flood_fill</span><span>(</span><span>struct</span> <span>gs_image</span> <span>img</span><span>,</span> <span>unsigned</span> <span>x</span><span>,</span> <span>unsigned</span> <span>y</span><span>,</span> <span>uint8_t</span> <span>target</span><span>,</span> <span>uint8_t</span> <span>replacement</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>x</span> <span>&gt;=</span> <span>img</span><span>.</span><span>w</span> <span>||</span> <span>y</span> <span>&gt;=</span> <span>img</span><span>.</span><span>h</span><span>)</span> <span>return</span><span>;</span>
  <span>if</span> <span>(</span><span>gs_get</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>!=</span> <span>target</span> <span>||</span> <span>gs_get</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span> <span>==</span> <span>replacement</span><span>)</span> <span>return</span><span>;</span>
  <span>gs_set</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>replacement</span><span>);</span>
  <span>gs_flood_fill</span><span>(</span><span>img</span><span>,</span> <span>x</span> <span>+</span> <span>1</span><span>,</span> <span>y</span><span>,</span> <span>target</span><span>,</span> <span>replacement</span><span>);</span>
  <span>gs_flood_fill</span><span>(</span><span>img</span><span>,</span> <span>x</span> <span>-</span> <span>1</span><span>,</span> <span>y</span><span>,</span> <span>target</span><span>,</span> <span>replacement</span><span>);</span>
  <span>gs_flood_fill</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span> <span>+</span> <span>1</span><span>,</span> <span>target</span><span>,</span> <span>replacement</span><span>);</span>
  <span>gs_flood_fill</span><span>(</span><span>img</span><span>,</span> <span>x</span><span>,</span> <span>y</span> <span>-</span> <span>1</span><span>,</span> <span>target</span><span>,</span> <span>replacement</span><span>);</span>
<span>}</span>
</code></pre></div><p>Of course this would immediately blow up your stack on most real-life images. So an iterative approach using a queue or stack is preferred.</p><p>However, it’s still a fairly suboptimal way to find blobs. A more efficient approach is a two-pass algorithm, which scans the image twice: first to assign “provisional” labels and record equivalences between them, followed by the second scan to resolve these equivalences and assign final unique labels to every blob.</p><p>It would be nice if we could use the same <code>gs_image</code> type for labels, but in most cases it would require more than 256 labels (especially for temporary provisional labels). So we need a separate array of larger integers to store labels:</p><div><pre><code data-lang="c"><span>typedef</span> <span>uint16_t</span> <span>gs_label</span><span>;</span> <span>// 64K should be enough, right?
</span><span></span>
<span>struct</span> <span>gs_blob</span> <span>{</span>
  <span>gs_label</span> <span>label</span><span>;</span> <span>// what label the blob has?
</span><span></span>  <span>unsigned</span> <span>area</span><span>;</span> <span>// how many white pixels are in a blob?
</span><span></span>  <span>struct</span> <span>gs_rect</span> <span>box</span><span>;</span> <span>// bounding box
</span><span></span>  <span>struct</span> <span>gs_point</span> <span>centroid</span><span>;</span> <span>// center of &#34;mass&#34;
</span><span></span><span>};</span>
<span>unsigned</span> <span>gs_blobs</span><span>(</span><span>struct</span> <span>gs_image</span> <span>img</span><span>,</span> <span>gs_label</span> <span>*</span><span>labels</span><span>,</span> <span>struct</span> <span>gs_blob</span> <span>*</span><span>blobs</span><span>,</span> <span>unsigned</span> <span>nblobs</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>
</code></pre></div><p>Before we go futher, let’s talk about connectivity. There are two common types of pixel connectivity: 4-connectivity and 8-connectivity. In 4-connectivity, a pixel is connected to its four direct neighbours (up, down, left, right). In 8-connectivity, a pixel is connected to all eight surrounding pixels (including diagonals). So, in case of 8-connectivity this would be one blob and in case of 4-connectivity - two separate blobs:</p><div><pre><code data-lang="fallback">......
.#..#.
.##.#.
.###..
......
</code></pre></div><p>We will be using 4-connectivity in our implementation, for simplicity. Let’s consider the following image:</p><div><pre><code data-lang="fallback">.........
.###..#..
.###.##..
.#####..#
.......##
</code></pre></div><p>We start scanning it row after row, if a white pixel is found, we check its left and top neighbours:</p><ul><li>If both are black (0), we assign a new label to the pixel, assuming that it could be a new blob.</li><li>If one of them is white, we assign its label to the current pixel, as it is a continuation of the existing known blob.</li><li>If both are white but have different labels, we assign the smallest of the labels to the current pixel and record the equivalence between the two labels in a special data structure (like a union-find).</li></ul><p>After this first pass the labels array would look like this:</p><div><pre><code data-lang="fallback">.........
.111..2..
.111.32..
.11111..4
.......55
</code></pre></div><p>Our equivalence table would look like this: <code>1 &lt;-&gt; 3, 3 &lt;-&gt; 2, 4 &lt;-&gt; 5</code>.</p><p>During the second pass we resolve the equivalences and assign final labels to each pixel. The final labels array would look like this:</p><div><pre><code data-lang="fallback">.........
.111..1..
.111.11..
.11111..4
.......44
</code></pre></div><p>During the second pass we can also calculate blob properties, such as area, bounding box and centroid. Largest blob’s area is 14 pixels, bounding box is from (1,1) to (6,3). Centroid is calculated as the average of all pixel coordinates in the blob, in our case for X it would be <code>(3*1+3*2+3*3+4+2*5+2*6)/14</code>, or rounded to 4. Y coordinate would be <code>(4*1+5*2+5*3)/14</code>, or rounded to 2. So the centroid is (4,2), which is not part of the blob “body”, but still is the center of mass.</p><p>Such geometric properties already give us plenty of information about blobs. For example, we can filter blobs by area to remove small noise blobs. We can also calculate aspect ratio (width/height) of the bounding box to filter out very tall or very wide blobs. Ratio between blob actual area and bounding box area helps to filter out blobs that are not compact enough. Rectangles tend to have a ratio of <code>1.0</code>, circles are <code>pi/4 = 0.785</code>, while lines approach to zero.</p><p>Another clues could be centroid position, orientation using moments or contour shape. There is a fairly simple method to trace a contour of a blob using the <a href="https://en.wikipedia.org/wiki/Moore_neighborhood">Moore-Neighbor tracing algorithm</a>. It starts from a known border pixel and follows the contour clockwise by checking neighbouring pixels, until it returns to the starting pixel:</p><div><pre><code data-lang="c"><span>struct</span> <span>gs_contour</span> <span>{</span> <span>struct</span> <span>gs_rect</span> <span>box</span><span>;</span> <span>struct</span> <span>gs_point</span> <span>start</span><span>;</span> <span>unsigned</span> <span>length</span><span>;</span> <span>};</span>
<span>void</span> <span>gs_trace_contour</span><span>(</span><span>struct</span> <span>gs_image</span> <span>img</span><span>,</span> <span>struct</span> <span>gs_image</span> <span>visited</span><span>,</span> <span>struct</span> <span>gs_contour</span> <span>*</span><span>c</span><span>)</span> <span>{</span>
  <span>static</span> <span>const</span> <span>int</span> <span>dx</span><span>[]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>};</span>
  <span>static</span> <span>const</span> <span>int</span> <span>dy</span><span>[]</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>};</span>
  <span>c</span><span>-&gt;</span><span>length</span> <span>=</span> <span>0</span><span>;</span>
  <span>c</span><span>-&gt;</span><span>box</span> <span>=</span> <span>(</span><span>struct</span> <span>gs_rect</span><span>){</span><span>c</span><span>-&gt;</span><span>start</span><span>.</span><span>x</span><span>,</span> <span>c</span><span>-&gt;</span><span>start</span><span>.</span><span>y</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>};</span>
  <span>struct</span> <span>gs_point</span> <span>p</span> <span>=</span> <span>c</span><span>-&gt;</span><span>start</span><span>;</span>
  <span>unsigned</span> <span>dir</span> <span>=</span> <span>7</span><span>,</span> <span>seenstart</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(;;)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>visited</span><span>.</span><span>data</span><span>[</span><span>p</span><span>.</span><span>y</span> <span>*</span> <span>visited</span><span>.</span><span>w</span> <span>+</span> <span>p</span><span>.</span><span>x</span><span>])</span> <span>c</span><span>-&gt;</span><span>length</span><span>++</span><span>;</span>
    <span>visited</span><span>.</span><span>data</span><span>[</span><span>p</span><span>.</span><span>y</span> <span>*</span> <span>visited</span><span>.</span><span>w</span> <span>+</span> <span>p</span><span>.</span><span>x</span><span>]</span> <span>=</span> <span>255</span><span>;</span>
    <span>int</span> <span>ndir</span> <span>=</span> <span>(</span><span>dir</span> <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>8</span><span>,</span> <span>found</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>8</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
      <span>int</span> <span>d</span> <span>=</span> <span>(</span><span>ndir</span> <span>+</span> <span>i</span><span>)</span> <span>%</span> <span>8</span><span>,</span> <span>nx</span> <span>=</span> <span>p</span><span>.</span><span>x</span> <span>+</span> <span>dx</span><span>[</span><span>d</span><span>],</span> <span>ny</span> <span>=</span> <span>p</span><span>.</span><span>y</span> <span>+</span> <span>dy</span><span>[</span><span>d</span><span>];</span>
      <span>if</span> <span>(</span><span>nx</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>nx</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>img</span><span>.</span><span>w</span> <span>&amp;&amp;</span> <span>ny</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>ny</span> <span>&lt;</span> <span>(</span><span>int</span><span>)</span><span>img</span><span>.</span><span>h</span> <span>&amp;&amp;</span>
          <span>img</span><span>.</span><span>data</span><span>[</span><span>ny</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>nx</span><span>]</span> <span>&gt;</span> <span>128</span><span>)</span> <span>{</span>
        <span>p</span> <span>=</span> <span>(</span><span>struct</span> <span>gs_point</span><span>){</span><span>nx</span><span>,</span> <span>ny</span><span>};</span>
        <span>dir</span> <span>=</span> <span>(</span><span>d</span> <span>+</span> <span>6</span><span>)</span> <span>%</span> <span>8</span><span>;</span>
        <span>found</span> <span>=</span> <span>1</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span><span>found</span><span>)</span> <span>break</span><span>;</span>  <span>// open contour
</span><span></span>    <span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>x</span> <span>=</span> <span>GS_MIN</span><span>(</span><span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>x</span><span>,</span> <span>p</span><span>.</span><span>x</span><span>);</span>
    <span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>y</span> <span>=</span> <span>GS_MIN</span><span>(</span><span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>y</span><span>,</span> <span>p</span><span>.</span><span>y</span><span>);</span>
    <span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>w</span> <span>=</span> <span>GS_MAX</span><span>(</span><span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>w</span><span>,</span> <span>p</span><span>.</span><span>x</span> <span>-</span> <span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>x</span> <span>+</span> <span>1</span><span>);</span>
    <span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>h</span> <span>=</span> <span>GS_MAX</span><span>(</span><span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>h</span><span>,</span> <span>p</span><span>.</span><span>y</span> <span>-</span> <span>c</span><span>-&gt;</span><span>box</span><span>.</span><span>y</span> <span>+</span> <span>1</span><span>);</span>
    <span>if</span> <span>(</span><span>p</span><span>.</span><span>x</span> <span>==</span> <span>c</span><span>-&gt;</span><span>start</span><span>.</span><span>x</span> <span>&amp;&amp;</span> <span>p</span><span>.</span><span>y</span> <span>==</span> <span>c</span><span>-&gt;</span><span>start</span><span>.</span><span>y</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>seenstart</span><span>)</span> <span>break</span><span>;</span>
      <span>seenstart</span> <span>=</span> <span>1</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div><p>This way we can extract contours for each blob and analyse their shapes or compare contour length (perimeter) to the blob area. It is also possible to approximate contours with straight lines using <a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Douglas-Peucker algirithm</a>, which replaces a curve with a series of straight line segments, while preserving the overall shape.</p><p>All of this is good if we want to detect simple objects in a static image. But what if we want to detect or track more complex objects, like faces, cars or pedestrians?</p><h2 id="keypoints-and-descriptors">Keypoints and descriptors</h2><p>A keypoint is a specific location in an image that is distinctive and can be reliably detected no matter what scale, rotation or lighting of the object are.</p><p>In practice, keypoints are often corners (also known as “features”). One of the most intuitive algorithms to detect features is <a href="https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test">FAST</a> (Features from Accelerated Segment Test). It works by examining a circle of 16 pixels around a candidate pixel (4 pixels away from it). If at least 9 of <em>contiguous</em> pixels in this <code>r=4px</code> circle around pixel <code>P</code> are all brighter or all darker - then the candidate pixel is considered a corner:</p><div><pre><code data-lang="fallback">..............
......012.....
.....F...3....
....E.....4...
....D..P..5...
....C.....6...
.....B...7....
......A98.....
..............
</code></pre></div><p>As simple as it gets, this approach finds too many features in real-life images. A solution is to keep “score” of each feature and only keep the points with the highest score. The score can be calculated as the sum of absolute differences between the candidate pixel and the contiguous pixels in the circle, or by the minimum difference between central pixel and the pixels on the circle.</p><div><pre><code data-lang="c">  <span>gs_assert</span><span>(</span><span>gs_valid</span><span>(</span><span>img</span><span>)</span> <span>&amp;&amp;</span> <span>kps</span> <span>&amp;&amp;</span> <span>nkps</span> <span>&gt;</span> <span>0</span><span>);</span>
  <span>static</span> <span>const</span> <span>int</span> <span>dx</span><span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>-</span><span>1</span><span>};</span>
  <span>static</span> <span>const</span> <span>int</span> <span>dy</span><span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span><span>-</span><span>3</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>-</span><span>3</span><span>};</span>
  <span>unsigned</span> <span>n</span> <span>=</span> <span>0</span><span>;</span>
  <span>// first pass: compute score map
</span><span></span>  <span>for</span> <span>(</span><span>unsigned</span> <span>y</span> <span>=</span> <span>3</span><span>;</span> <span>y</span> <span>&lt;</span> <span>img</span><span>.</span><span>h</span> <span>-</span> <span>3</span><span>;</span> <span>y</span><span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>unsigned</span> <span>x</span> <span>=</span> <span>3</span><span>;</span> <span>x</span> <span>&lt;</span> <span>img</span><span>.</span><span>w</span> <span>-</span> <span>3</span><span>;</span> <span>x</span><span>++</span><span>)</span> <span>{</span>
      <span>uint8_t</span> <span>p</span> <span>=</span> <span>img</span><span>.</span><span>data</span><span>[</span><span>y</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>x</span><span>];</span>
      <span>int</span> <span>run</span> <span>=</span> <span>0</span><span>,</span> <span>score</span> <span>=</span> <span>0</span><span>;</span>
      <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>16</span> <span>+</span> <span>9</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>int</span> <span>idx</span> <span>=</span> <span>(</span><span>i</span> <span>%</span> <span>16</span><span>);</span>
        <span>uint8_t</span> <span>v</span> <span>=</span> <span>img</span><span>.</span><span>data</span><span>[(</span><span>y</span> <span>+</span> <span>dy</span><span>[</span><span>idx</span><span>])</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>(</span><span>x</span> <span>+</span> <span>dx</span><span>[</span><span>idx</span><span>])];</span>
        <span>if</span> <span>(</span><span>v</span> <span>&gt;</span> <span>p</span> <span>+</span> <span>threshold</span><span>)</span> <span>{</span>
          <span>run</span> <span>=</span> <span>(</span><span>run</span> <span>&gt;</span> <span>0</span><span>)</span> <span>?</span> <span>run</span> <span>+</span> <span>1</span> <span>:</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>v</span> <span>&lt;</span> <span>p</span> <span>-</span> <span>threshold</span><span>)</span> <span>{</span>
          <span>run</span> <span>=</span> <span>(</span><span>run</span> <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>run</span> <span>-</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>run</span> <span>=</span> <span>0</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>run</span> <span>&gt;=</span> <span>9</span> <span>||</span> <span>run</span> <span>&lt;=</span> <span>-</span><span>9</span><span>)</span> <span>{</span>
          <span>score</span> <span>=</span> <span>255</span><span>;</span>
          <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>16</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
            <span>int</span> <span>d</span> <span>=</span> <span>gs_get</span><span>(</span><span>img</span><span>,</span> <span>x</span> <span>+</span> <span>dx</span><span>[</span><span>j</span><span>],</span> <span>y</span> <span>+</span> <span>dy</span><span>[</span><span>j</span><span>])</span> <span>-</span> <span>p</span><span>;</span>
            <span>if</span> <span>(</span><span>d</span> <span>&lt;</span> <span>0</span><span>)</span> <span>d</span> <span>=</span> <span>-</span><span>d</span><span>;</span>
            <span>if</span> <span>(</span><span>d</span> <span>&lt;</span> <span>score</span><span>)</span> <span>score</span> <span>=</span> <span>d</span><span>;</span>
          <span>}</span>
          <span>break</span><span>;</span>
        <span>}</span>
      <span>}</span>
      <span>scoremap</span><span>.</span><span>data</span><span>[</span><span>y</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>x</span><span>]</span> <span>=</span> <span>score</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>// second pass: non-maximum suppression
</span><span></span>  <span>for</span> <span>(</span><span>unsigned</span> <span>y</span> <span>=</span> <span>3</span><span>;</span> <span>y</span> <span>&lt;</span> <span>img</span><span>.</span><span>h</span> <span>-</span> <span>3</span><span>;</span> <span>y</span><span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>unsigned</span> <span>x</span> <span>=</span> <span>3</span><span>;</span> <span>x</span> <span>&lt;</span> <span>img</span><span>.</span><span>w</span> <span>-</span> <span>3</span><span>;</span> <span>x</span><span>++</span><span>)</span> <span>{</span>
      <span>int</span> <span>s</span> <span>=</span> <span>scoremap</span><span>.</span><span>data</span><span>[</span><span>y</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>x</span><span>],</span> <span>is_max</span> <span>=</span> <span>1</span><span>;</span>
      <span>if</span> <span>(</span><span>s</span> <span>==</span> <span>0</span><span>)</span> <span>continue</span><span>;</span>
      <span>for</span> <span>(</span><span>int</span> <span>yy</span> <span>=</span> <span>-</span><span>1</span><span>;</span> <span>yy</span> <span>&lt;=</span> <span>1</span> <span>&amp;&amp;</span> <span>is_max</span><span>;</span> <span>yy</span><span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> <span>xx</span> <span>=</span> <span>-</span><span>1</span><span>;</span> <span>xx</span> <span>&lt;=</span> <span>1</span><span>;</span> <span>xx</span><span>++</span><span>)</span> <span>{</span>
          <span>if</span> <span>(</span><span>xx</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>yy</span> <span>==</span> <span>0</span><span>)</span> <span>continue</span><span>;</span>
          <span>if</span> <span>(</span><span>scoremap</span><span>.</span><span>data</span><span>[(</span><span>y</span> <span>+</span> <span>yy</span><span>)</span> <span>*</span> <span>img</span><span>.</span><span>w</span> <span>+</span> <span>(</span><span>x</span> <span>+</span> <span>xx</span><span>)]</span> <span>&gt;</span> <span>s</span><span>)</span> <span>{</span>
            <span>is_max</span> <span>=</span> <span>0</span><span>;</span>
            <span>break</span><span>;</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
      <span>if</span> <span>(</span><span>is_max</span> <span>&amp;&amp;</span> <span>n</span> <span>&lt;</span> <span>nkps</span><span>)</span> <span>kps</span><span>[</span><span>n</span><span>++</span><span>]</span> <span>=</span> <span>(</span><span>struct</span> <span>gs_keypoint</span><span>){{</span><span>x</span><span>,</span> <span>y</span><span>},</span> <span>(</span><span>unsigned</span><span>)</span><span>s</span><span>,</span> <span>0</span><span>,</span> <span>{</span><span>0</span><span>}};</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>n</span><span>;</span>
<span>}</span>
</code></pre></div><p><img src="https://zserge.com/grayskull-img/cat-fast.png" alt="FAST keypoints detection"/></p><p>Notice how keypoints are detected on corners and distinctive features of the cat image, such as eyes, nose, whiskers and other “meaningful” corners. But how to use keypoints to detect objects?</p><p>This is where <a href="https://en.wikipedia.org/wiki/Oriented_FAST_and_rotated_BRIEF">ORB</a> enters the stage. ORB builds on top of the same FAST corner detector, it tries to find sharp intensity changes, but also adds two more components: orientation and descriptor.</p><p>Once the corners are found, ORB estimates their orientation by calculating image moments in a small patch around each keypoint. This way, each keypoint gets an angle, basically saying which way is “up” for this keypoint.</p><p>Then comes the descriptor. A descriptor is a compact representation of the local image patch around the keypoint, designed to be invariant to scale and rotation. ORB uses a modified version of <a href="https://en.wikipedia.org/wiki/BRIEF_(computer_vision_algorithm)">BRIEF</a> (Binary Robust Independent Elementary Features) descriptor, which is a clever way to encode image patch as a small bit string.</p><p>It simply compares bit intensities, if one pixel is lighter than another, it sets the corresponding bit to <code>1</code>, otherwise to <code>0</code>. By performing multiple such comparisons, we can create a binary string that represents the local image patch.</p><p>The descriptor is 256 bit long, and for each of the 256 “samples” we pick two sampling points within the patch area using some pseudo-random lookup table and encode the following bit as 0 or 1 depending on the pixel relative values.</p><p>Comparing keypoints becomes trivial, we simply XOR two bitstrings and count the bits.</p><p>Since keypoints are agnostic to rotation and lighting conditions, we can use them to detect objects in various scenarios.</p><p>One last addition to this algorithm is to resize/scale the image multiple times and detect keypoints at different scales. This way we can detect objects that are closer or further away from the camera, rotated at any angle, or partially occluded.</p><p><img src="https://zserge.com/grayskull-img/orb.png" alt="ORB keypoints detection"/></p><h2 id="lbp-cascades">LBP Cascades</h2><p>While keypoints and descriptors are great for detecting arbitrary objects, sometimes we need a more specialised approach for specific object types, like faces, vehicles, or hand gestures. This is where cascade classifiers, famously used in the <a href="https://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework">Viola-Jones object detection framework</a>, come into play.</p><p>Instead of complex Haar-like features used by Viola and Jones, we can use something simpler: <a href="https://en.wikipedia.org/wiki/Local_binary_patterns">Local Binary Patterns (LBP)</a>. LBP is a powerful texture descriptor. For each pixel, it looks at its 8 neighbours. If a neighbour is brighter than the central pixel, we write a ‘1’, otherwise a ‘0’. This gives us an 8-bit number that describes the local texture.</p><p>The “cascade” is a series of simple classifiers, or “stages”. Each stage looks at a sub-window of the image and uses a few LBP features to decide if that window could possibly contain the object of interest (e.g., a face).</p><ul><li>If the sub-window fails the test at any stage, it’s immediately rejected. This is very fast.</li><li>Only if a sub-window passes <em>all</em> stages is it classified as a positive detection.</li></ul><p>This structure allows the classifier to quickly discard the vast majority of the image, focusing computational power only on promising regions. By sliding this detection window across the entire image (and across multiple scales), we can find objects of a specific, pre-trained class. Grayskull provides a pre-trained frontal face detector that uses this exact technique.</p><p><img src="https://zserge.com/grayskull-img/lbp-faces.png" alt="LBP face detection"/></p><p>Here you can see the LBP cascade classifier in action, successfully detecting Sir Gary Oldman in all variety of his faces. The picture on the left uses minimum number of neighbours set to 4, while the right one uses 14. This means the left image detects more faces, but also has more false positives, while the right one is more conservative and only detect camera-facing images with no visual obstructions.</p><h2 id="conclusion">Conclusion</h2><p>We’ve taken a journey from the humble pixel to sophisticated object detection, all using simple C structures and fundamental algorithms. We tried to manipulate pixels, apply filters to enhance images, segment objects using thresholding, and clean them up. We then learned to find and analyze blobs, detect robust keypoints with FAST and ORB, and finally, use LBP cascades for specialized object detection.</p><p>This is the core philosophy of <a href="https://github.com/zserge/grayskull">Grayskull</a>: to demystify computer vision by providing a minimal, dependency-free, and understandable toolkit. It proves that you don’t always need massive libraries or deep learning frameworks to achieve decent results, especially on resource-constrained systems.</p><p>An image is indeed just a rectangle of numbers, and with a bit of algorithmic knowledge, you have the power to make it see. As always, I encourage you to check out the repository, experiment with the code, and maybe even try building your own simple CV project!</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href="https://github.com/zserge">Github</a>, <a href="https://mastodon.social/@zserge">Mastodon</a>, <a href="https://twitter.com/zsergo">Twitter</a> or subscribe via <a href="https://zserge.com/rss.xml">rss</a>.</p><p><em>Oct 26, 2025</em></p><p>See also:
<a href="https://zserge.com/posts/etude-in-c/">Étude in C minor</a> and <a href="https://zserge.com/posts/">more</a>.</p></div></div>
  </body>
</html>
