<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lesswrong.com/posts/eDicGjD9yte6FLSie/interpreting-neural-networks-through-the-polytope-lens">Original</a>
    <h1>Interpreting neural networks through the polytope lens (2022)</h1>
    
    <div id="readability-page-1" class="page"><p>Crossposted from the <a href="https://alignmentforum.org/posts/eDicGjD9yte6FLSie/interpreting-neural-networks-through-the-polytope-lens">AI Alignment Forum</a>. May contain more technical jargon than usual.</p><div><div><div><p id="block0">Sid Black*, Lee Sharkey*, Leo Grinsztajn, Eric Winsor, Dan Braun, Jacob Merizian, Kip Parker, Carlos Ramón Guevara, Beren Millidge, Gabriel Alfour, Connor Leahy</p><p id="block1">*equal contribution</p><p id="block3">Research from<a href="https://conjecture.dev/"> <u>Conjecture</u></a>.</p><p id="block5"><i>This post benefited from feedback from many staff at Conjecture including Adam Shimi, Nicholas Kees Dupuis, Dan Clothiaux, Kyle McDonell. Additionally, the post also benefited from inputs from Jessica Cooper, Eliezer Yudkowsky, Neel Nanda, Andrei Alexandru, Ethan Perez, Jan Hendrik Kirchner, Chris Olah, Nelson Elhage, David Lindner, Evan R Murphy, Tom McGrath, Martin Wattenberg, Johannes Treutlein, Spencer Becker-Kahn, Leo Gao, John Wentworth, and Paul Christiano and from discussions with many other colleagues working on interpretability. </i></p><p id="block7">Mechanistic interpretability aims to explain what a neural network has learned at a nuts-and-bolts level. What are the fundamental primitives of neural network representations? What basic objects should we use to describe the operation of neural networks mechanistically? Previous mechanistic descriptions have used individual neurons or their linear combinations to understand the representations a network has learned. But there are clues that neurons and their linear combinations are not the correct fundamental units of description - directions cannot describe how neural networks use nonlinearities to structure their representations. Moreover, many instances of individual neurons and their combinations are polysemantic (i.e. they have multiple unrelated meanings). Polysemanticity makes interpreting the network in terms of neurons or directions challenging since we can no longer assign a specific feature to a neural unit.  In order to find a basic unit of description that doesn’t suffer from these problems, we zoom in beyond just directions to study the way that piecewise linear activation functions (such as ReLU) partition the activation space into numerous discrete polytopes. We call this perspective the ‘polytope lens’. Although this view introduces new challenges, we think they are surmountable and that more careful consideration of the impact of nonlinearities is necessary in order to build better high-level abstractions for a mechanistic understanding of neural networks. The polytope lens makes concrete predictions about the behavior of neural networks, which we evaluate through experiments on both convolutional image classifiers and language models. Specifically, we show that polytopes can be used to identify monosemantic regions of activation space (while directions are not in general monosemantic) and that the density of polytope boundaries reflect semantic boundaries. We also outline a vision for what mechanistic interpretability might look like through the polytope lens. </p><p id="block8">How should we carve a neural network at the joints? Traditionally, mechanistic descriptions of neural circuits have been posed in terms of neurons, or linear combinations of neurons also known as  ‘directions’. Describing networks in terms of these neurons and directions has let us understand a surprising amount about what they’ve learned (<a href="https://distill.pub/2020/circuits/"><u>Cammarata et al., 2020</u></a>). But these descriptions often possess undesirable properties - such as polysemanticity and inability to account for nonlinearity - which suggest to us that they don’t always carve a network at its joints.</p><p id="block9">If not neurons or directions, then what should be the fundamental unit of a mechanistic description of what a neural network has learned? Ideally, we would want a description in terms of some object that throws away unnecessary details about the internal structure of a neural network while simultaneously retaining what’s important. In other words, we’d like a less <a href="https://en.wikipedia.org/wiki/Leaky_abstraction"><i><u>‘leaky’ abstraction</u></i></a> for describing a neural network’s mechanisms.</p><p id="block10">We propose that a particular kind of mathematical object – a ‘polytope’ – might serve us well in mechanistic descriptions of neural networks with piecewise-linear activations<span role="doc-noteref" id="fnrefyp6wk11agmm"><sup><a href="#fnyp6wk11agmm">[1]</a></sup></span>. We believe they might let us build less leaky abstractions than individual neurons and directions alone, while still permitting mechanistic understandings of neural networks of comparable length and complexity. </p><p id="block11">To help explain how the polytope lens could underlie mechanistic descriptions of neural networks, we first look at the problems that arise when using individual neurons (both biological and artificial) and then when using directions as the basic units of description and suggest how this perspective offers a potential solution. </p><h2 id="Are_individual_neurons_the_fundamental_unit_of_neural_networks_">Are individual neurons the fundamental unit of neural networks?</h2><p id="block12">Studying the function of single neurons has a long history. The dominant view in neuroscience for approximately one hundred years was the ‘neuron doctrine’ (<a href="https://www.nature.com/articles/nrn3962"><u>Yuste, 2015</u></a>). The neuron doctrine contended that the way to understand neural networks is to understand the responses  of individual neurons and their role in larger neural circuits. This led to significant successes in the study of biological neural circuits, most famously in the visual system. Early and important discoveries within this paradigm included cells in the frog retina that detect small patches of motion (fly detectors) (<a href="https://hearingbrain.org/docs/letvin_ieee_1959.pdf"><u>Lettvint et al., 1959</u></a>); cells in the visual cortex with small receptive fields that detect edges (<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1359523/"><u>Hubel and Weisel, 1962</u></a>), cells in the higher visual system that detect objects as complex as faces (<a href="https://academic.oup.com/brain/article-abstract/115/1/15/295727?redirectedFrom=fulltext&amp;login=false"><u>Sergent et al., 1992</u></a>), and many even highly abstract multimodal concepts appear to be represented in single neurons (<a href="https://www.nature.com/articles/nature03687"><u>Quiroga et al., 2005</u></a>; <a href="https://www.sciencedirect.com/science/article/pii/S0960982209013773"><u>Qurioga et al., 2009</u></a>).</p><p id="block13">Given their historic usefulness in the study of <i>biological</i> neural networks, individual neurons are a natural first place to start when interpreting <i>artificial</i> neural networks. Such an approach has led to significant progress. Many studies have suggested that it is possible to identify single neurons that responded to single features (<a href="https://arxiv.org/pdf/1312.6199.pdf"><u>Szegedy et al., 2014</u></a>, <a href="https://arxiv.org/abs/1412.6856"><u>Zhou et al., 2015</u></a>, <a href="http://netdissect.csail.mit.edu/final-network-dissection.pdf"><u>Bau et al., 2017</u></a>, <a href="https://distill.pub/2017/feature-visualization/"><u>Olah et al., 2017</u></a>). Analysis of small neural circuits has also been done by inspecting individual neurons (<a href="https://distill.pub/2020/circuits/curve-detectors/"><u>Cammarata et al., 2020</u></a>, <a href="https://distill.pub/2021/multimodal-neurons/"><u>Goh et al., 2021</u></a>).</p><p id="block14">Mathematically, it’s not immediately obvious why individual neurons would learn to represent individual features given that, at least in linear networks, the weights and activations can be represented in any desired basis. One suggestion for why this would happen is the ‘privileged basis’ hypothesis (<a href="https://transformer-circuits.pub/2021/framework/index.html#def-privileged-basis"><u>Elhage et al., 2021</u></a>; <a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al., 2022</u></a>). This hypothesis states that element-wise nonlinear activation functions encourage functionally independent input features to align with individual neurons rather than directions.</p><p id="block15">Despite both historical success and the privileged basis hypothesis, it turns out that in many circumstances networks learn features that don&#39;t perfectly align with individual neurons. Instead, there have been some suggestions that networks learn to align their represented features with directions (<a href="https://distill.pub/2018/building-blocks/"><u>Olah et al., 2018</u></a>, <a href="https://stat.columbia.edu/~cunningham/pdf/SaxenaCONB2019.pdf"><u>Saxena and Cunningham, 2019</u></a>). </p><h2 id="Are_directions_the_fundamental_unit_of_neural_networks_">Are directions the fundamental unit of neural networks?</h2><p id="block16">One of the main reasons to prefer directions over individual neurons as the functional unit of neural networks is that neurons often appear to respond to multiple, seemingly unrelated things. This phenomenon is called polysemanticity<span role="doc-noteref" id="fnreffj8lun8q4lh"><sup><a href="#fnfj8lun8q4lh">[2]</a></sup></span>. <a href="https://arxiv.org/pdf/1602.03616.pdf"><u>Nguyen et al., (2016)</u></a> (supplement) and <a href="https://distill.pub/2017/feature-visualization/"><u>Olah et al., (2017)</u></a> were perhaps the first to explicitly identify neurons that represent multiple unrelated features in convolutional image classifiers. Polysemantic neurons have also been found in large language models (<a href="https://arxiv.org/pdf/2012.14913.pdf"><u>Geva et al., 2020</u></a>) and multimodal networks (<a href="https://distill.pub/2021/multimodal-neurons/"><u>Goh et al., 2021</u></a>), and in the brain (<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3688279/"><u>Tanabe, 2013</u></a>) . They are usually found by looking at the dataset examples that maximally activate specific neurons and noticing that there are multiple distinct groups of features represented in the examples. Below are a few examples of polysemantic neurons from a convolutional image classifier (InceptionV1<span role="doc-noteref" id="fnrefo89s50smuz"><sup><a href="#fno89s50smuz">[3]</a></sup></span>) and a large language model, GPT2-Medium.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ujwl46m0pgeahjumbbee"/><figcaption>Figure: An example of a polysemantic neuron in InceptionV1 (layer inception5a, neuron 233) which seems to respond to a mix of dog noses and metal poles (and maybe boats).</figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wksyvxbbn83bjawxlcqw"/><figcaption>Figure: An example of a polysemantic neuron in GPT2-Medium. The text highlights represent the activation magnitude - the redder the text, the larger the activation. We can see that this neuron seems to react strongly to commas in lists, but also to diminutive adjectives (‘small’, ‘lame’, ‘tired’) and some prepositions (‘of’, ‘in’, ‘by’), among other features.</figcaption></figure><p id="block19">If there are fewer features than neurons (or an equal number of both), then each feature can be encoded by one orthogonal direction. To decode, we could simply determine which linear combination of neurons encodes each feature. However, if there are more features than neurons, then features must be encoded in non-orthogonal directions and can interfere with (or <a href="https://en.wikipedia.org/wiki/Aliasing"><u>alias</u></a> - see Appendix D) one another. In this case, the features are sometimes said to be represented in ‘superposition’ (<a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al., 2022</u></a>)<span role="doc-noteref" id="fnref9itzt8xhtlf"><sup><a href="#fn9itzt8xhtlf">[5]</a></sup></span>. In superposition, networks encode more features than they have orthogonal basis vectors. This introduces a problem for a naive version of the features-as-directions hypothesis: Necessarily, some feature directions will be polysemantic! If we assume that representations are purely linear, then it’s hard to see how networks could represent features in non-orthogonal directions without interference degrading their performance. Neural networks use nonlinearities to handle this issue. <a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al (2022)</u></a> argue that a Rectified Linear Unit (ReLU) activation does this through thresholding: If the interference terms are small enough not to exceed the activation threshold, then interference is ‘silenced’! For example, suppose neuron A is polysemantic and represents a cat ear, a car wheel, and a clock face, and neuron B represents a dog nose, a dumbbell, and a car wheel. When neuron A and B activate together, they can cause a downstream car neuron to activate without activating neurons that represent any of their other meanings, so long as their pre-activations are below threshold. </p><p id="block20">Beyond enabling polysemanticity, nonlinearities introduce a second problem for the features-as-directions viewpoint. The directions in each layer, caused by a direction in an earlier layer, are no longer invariant to scaling, as we would expect in a fully linear network. If we scale the activations in a particular layer in a fully linear network by some scalar multiple, we expect the class prediction to remain the same - as this is equivalent to scaling the output logits. However, if we scale the activations in a particular layer in a <i>non</i>-linear network, some neurons in later layers may ‘activate’ or ‘deactivate’. (i.e. their preactivation goes above or below threshold). In other words, scaling directions in one layer can change the direction (and hence the features represented) in later layers!</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/kjxt8tl1larln9qjed5g" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ssee8wkohhvcgzqxzqt4 110w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/rlnb6gjhloxmwoisflmt 190w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/xgeqopa7pkkjr7bx9fec 270w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/tg58offsmpwvjwfobd26 350w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/s3slfzzfsvmrx8jfdtq8 430w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ckbspute6fhjjs4azjtb 510w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/uicsffupg00bsdroh4de 590w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/jmqmtgct1cwkgbpmfkqz 670w"/><figcaption>Figure: Scaling the activations in a layer causes semantic changes later in the network despite no change in activation direction in the scaled layer. The image on the right represents the input image.</figcaption></figure><p id="block22">On the one hand, we should expect scaling the activation to change the direction in later layers. On the other, this poses a challenge to the features-as-directions view; scaling all representations relative to each other shouldn’t change their meaning except by changing their ‘intensity’. The naive version of the features-as-directions hypothesis requires the addition of something like a ‘distribution of validity’ within which directions represent the correct feature and outside of which they don’t. Unfortunately, the features-as-directions view doesn’t tell us what this distribution is. We’d like to know what the distribution is in order to know when our models might exhibit unpredictable out-of-distribution behavior. </p><p id="block23">Despite these two limitations (polysemanticity and failure to be invariant to scale), the features-as-directions view has enabled much progress in understanding circuits of some neural networks, even permitting <a href="https://distill.pub/2020/circuits/curve-circuits/"><u>Cammarata et al. (2021)</u></a> to reverse engineer some circuits and reconstruct them by hand. So the view represents at least a substantial piece of the interpretability puzzle - and it seems true that <i>some</i> directions carry a clear semantic meaning. Another reason to believe that the features-as-directions viewpoint is sensible is that, as we scale the hidden activations, neighbouring categories are quite often (but not always) semantically related. For instance, when we scale up the hidden layer activations for the cougar image, the network misclassifies it as a cheetah, which is still a big cat! </p><p id="block24">Instead of radically overhauling the features-as-directions view, perhaps it only needs some modifications to account for the effects of nonlinearities, namely:</p><ul><li id="block25">Invariances - We have shown that directions are not invariant to scaling. We want a modification that captures invariances in neural networks. For instance, we want something that points the way to ‘semantic invariances’ by identifying monosemantic components of neural networks even when subjected to certain geometric transformations (like scaling). </li><li id="block26">On/off-distribution - The features-as-directions view appears to be correct only when the scale of activations is within some permitted distribution. We want a way to talk about when activations are off-distribution with more clarity, which will hopefully let us identify regions of activation space where the behavior of our models becomes less predictable. </li></ul><p id="block27">To find an object that meets our needs, we turn to some recent developments in deep learning theory - a set of ideas that we call the ‘polytope lens’. </p><p id="block28">Let’s consider an MLP-only network which uses piecewise linear activation functions, such as ReLU<span role="doc-noteref" id="fnref662ir63ay26"><sup><a href="#fn662ir63ay26">[6]</a></sup></span>. In the first layer, each neuron partitions the input data space in two with a single hyperplane: On one side, the neuron is “on” (activated) and on the other side it’s “off”. </p><p id="block29">On one side of the boundary, the input vector is multiplied by the weights for that neuron, which is just that neuron’s row of the weight matrix. On the other side, the input is instead projected to 0, as though that row of weight matrix were set to zero. We can therefore view the layer as implementing a different affine transformation on either side of the partition. For a mathematical description, see Appendix C. </p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/fyruakial8maojftbpbd"/><figcaption><i>Figure: Affine transformations in the activated / unactivated regions of one neuron (assuming the three other neurons are activated)</i></figcaption></figure><p id="block30">The orientation of the plane defining the partition is defined by the row of the weight matrix and the height of the plane is defined by the neuron’s bias term. The example we illustrate here is for a 2-dimensional input space, but of course neural networks typically have inputs that are much higher dimensional.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/uy5vvkehakihehkglrxc"/><figcaption>Figure: Polytope boundaries are defined by the weights and bias of a neuron. The weights determine the orientation of the (hyper-) plane and the bias determines its height.</figcaption></figure><p id="block31">Considering all N neurons in layer 1 together, the input space is partitioned N times into a number of convex shapes called polytopes (which may be unbounded on some sides). Each polytope has a different affine transformation according to whether each neuron is above or below its activation threshold. This means we can entirely replace this layer by a set of affine transformations, one for each polytope. </p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/kftqf40q1dkiu2gowhwl"/><figcaption><i>Figure: Four polytopes corresponding to four different affine transformations defined by two neurons in layer 1.</i></figcaption></figure><p id="block32">As we add layers on top of layer 1, we add more neurons and, thus, more ways to partition the input space into polytopes, each with their own affine transformation. Thus, neural networks cut up the network’s input space into regions (polytopes) that each get transformed by a different set of affine transformations. Adding subsequent layers permits partition boundaries that <i>bend</i> when they intersect with the partition boundaries of earlier layers (<a href="https://arxiv.org/pdf/1906.00904.pdf"><u>Hanin and Rolnick, 2019b</u></a>). The boundaries bend in different ways depending on the weights of the neurons in later layers that activate or deactivate. </p><p id="block33">Each polytope can thus be analyzed as a fully linear subnetwork composed of a single affine transformation. Within each of these subnetworks, we would expect to see a set of interpretable directions that are scale invariant within each polytope. But the same directions in a different subnetwork might yield different interpretations. However, we should expect nearby polytope regions (subnetworks) to share similar affine transformations, and therefore similar semantics. We’ll discuss this further in the next section.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/elxirsvfculsfkjg0hwa"/><figcaption><i>Image from </i><a href="http://proceedings.mlr.press/v97/hanin19a/hanin19a.pdf"><i><u>Hanin &amp; Rolnick, 2019a</u></i></a></figcaption></figure><p id="block34">The polytope lens draws on some recent work in deep learning theory, which views neural networks as <strong>max-affine spline operators</strong> (MASOs) (<a href="http://proceedings.mlr.press/v80/balestriero18b.html"><u>Balestriero and Baraniuk, 2018</u></a>). For a mathematical description of the above perspective, see Appendix C. </p><p id="block35">The picture painted above is, of course, a simplified model of a far higher dimensional reality. When we add more neurons, we get a lot more hyperplanes and, correspondingly, a lot more polytopes! Here is a two dimensional slice of the polytopes in the 40768-dimensional input space of inception5a, with boundaries defined by all the subsequent layers:</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/mhxi6twrrg3l2hznzmt0"/><figcaption>Figure: This figure depicts the polytope boundaries that intersect with a two-dimensional slice through the 832 * 7 * 7 = 40768-dimensional input space of InceptionV1 layer inception5a. The slice was defined using the activation vectors caused by three images, one of a banana, a coffee cup, and a projector.  The boundaries are defined using all neurons from inception5a to the classification logits. There are many polytopes in high dimensional space. If we instead used a lower layer, e.g. inception3a, then there would be many, many more polytope boundaries.</figcaption></figure><p id="block36">In fact, as we add neurons, the number of polytopes the input space is partitioned into grows exponentially<span role="doc-noteref" id="fnrefnxrcvy6eqr"><sup><a href="#fnnxrcvy6eqr">[7]</a></sup></span>. Such large numbers of polytopes become quite hard to talk about! Fortunately, each polytope can be given a unique code, which we call a ‘<strong>spline code</strong>’, defined in the following way: Consider the sequence of layers from <span><span><span><span aria-label="L"><span aria-hidden="true"><span><span>L</span></span></span></span></span></span></span> to <span><span><span><span aria-label="L+K"><span aria-hidden="true"><span><span>L</span></span><span><span>+</span></span><span><span>K</span></span></span></span></span></span></span>. These layers define a set of polytope boundaries in the input space to layer <span><span><span><span aria-label="L"><span aria-hidden="true"><span><span>L</span></span></span></span></span></span></span>. A polytope’s spline code is simply a binary vector of length <span><span><span><span aria-label="M"><span aria-hidden="true"><span><span>M</span></span></span></span></span></span></span> (where <span><span><span><span aria-label="M"><span aria-hidden="true"><span><span>M</span></span></span></span></span></span></span> is the total number of neurons in layers <span><span><span><span aria-label="L"><span aria-hidden="true"><span><span>L</span></span></span></span></span></span></span> to <span><span><span><span aria-label="L+K"><span aria-hidden="true"><span><span>L</span></span><span><span>+</span></span><span><span>K</span></span></span></span></span></span></span>) with a 1 where the polytope causes a neuron to activate above threshold and 0 otherwise. Notice that we can define a code for any sequence of layers; if we define a spline code from layer <span><span><span><span aria-label="L"><span aria-hidden="true"><span><span>L</span></span></span></span></span></span></span> to <span><span><span><span aria-label="L+K"><span aria-hidden="true"><span><span>L</span></span><span><span>+</span></span><span><span>K</span></span></span></span></span></span></span>, the codes correspond to the polytopes that partition layer <span><span><span><span aria-label="L"><span aria-hidden="true"><span><span>L</span></span></span></span></span></span></span>’s input space. There is therefore a duality to spline codes: Not only are they a name for the region of input activation space contained within each polytope, but they can also be viewed as labels for pathways through layers <span><span><span><span aria-label="L"><span aria-hidden="true"><span><span>L</span></span></span></span></span></span></span> to <span><span><span><span aria-label="L+K"><span aria-hidden="true"><span><span>L</span></span><span><span>+</span></span><span><span>K</span></span></span></span></span></span></span>. </p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ljsugpo55crvffeuf8br"/><figcaption>Figure: How spline codes are constructed in an MLP with ReLU activation functions. Activations in a set of layers are binarised according to whether each neuron is above or below threshold. (Partly adapted from <a href="http://proceedings.mlr.press/v97/hanin19a/hanin19a.pdf"><u>Hanin &amp; Rolnick, 2019a</u></a>)</figcaption></figure><p id="block37">At least for deep ReLU networks, polytopes provide a mathematically correct description of how the input space is partitioned, unlike the naive version of the features-as-directions view which ignores the nonlinearities. However, polytopes are far more difficult to reason about than directions. They will need to give us greater predictive power to be worth the cost.</p><h2 id="Polytopes_as_the_atoms_of_neural_networks___polytope_regions_as_their_molecules_">Polytopes as the atoms of neural networks &amp; polytope regions as their molecules </h2><p id="block38">In the previous section, we discussed how it’s possible (in theory) to replace an entire ReLU network with each polytope’s affine transformation. Hence, polytopes provide a complete description of the input-output map of the network. Any inputs that belong to the same polytope are subject to the same affine transformation. In other words, the transformation implemented by the network is <i>invariant within a polytope</i>.</p><p id="block39">But the invariance goes even further than individual polytopes; nearby polytopes implement similar transformations. To see why, consider two polytopes that share a boundary. Their spline codes differ by <i>only one</i> neuron somewhere in the network turning on or off - in other words, the pathway taken by the activations through the network is identical except for the activation status of one neuron. Therefore, assuming the weights of some neurons aren’t unusually large, polytopes that have similar spline codes implement similar transformations in expectation<span role="doc-noteref" id="fnref7bn8gghu3b9"><sup><a href="#fn7bn8gghu3b9">[8]</a></sup></span>. Hamming distance in the space of spline codes thus corresponds to expected distance in transformation space. </p><p id="block40">It’s easy to see how this might be useful for semantics: If a network needs two similar-meaning inputs to be transformed similarly, all it needs to do is to project the inputs to nearby polytopes in hidden activation space. Here, the fundamental unit of semantics in the network, which we might call a feature, is a group of nearby polytopes that implement similar transformations. Notice that the addition of polytopes only modifies the features-as-directions view without replacing it entirely: Vectors in nearby polytopes usually share high cosine similarity, so ‘similar directions’ will correlate with ‘nearby polytopes’. Moreover, within a polytope the two views are identical.</p><p id="block41">This lets us make a few testable predictions about the relationship between semantics and polytope boundaries:</p><ul><li id="block42">Prediction 1:<i> Polysemantic directions overlap with multiple monosemantic polytope regions.</i><ul><li id="block43">The polytope lens makes a prediction about how polysemanticity is implemented in neural networks: The multiple meanings of the polysemantic direction will correspond to monosemantic regions that have nonzero inner product with that direction. </li></ul></li><li id="block44">Prediction 2 :<i> Polytope boundaries reflect semantic boundaries </i><ul><li id="block45">Networks will learn to place more polytope boundaries between inputs of different classes than between the same classes. More generally, networks will learn to have regions denser with polytope boundaries between distinct features than between similar features. </li></ul></li><li id="block46">Prediction 3: <i>Polytopes define when feature-directions are on- and off-distribution. </i><ul><li id="block47">Scaling hidden activation vectors eventually causes the prediction made by a classifier to change. It should be unsurprising that scaling the activations vectors of a nonlinear network well outside their typical distribution causes the semantics of directions to break. But neither the features-as-directions perspective nor the superposition hypothesis suggest what this distribution actually is. The polytope lens predicts that polytope boundaries define this distribution. Specifically, the class prediction made by the network should tend to change when the activation vector crosses a region of dense polytope boundaries. </li></ul></li></ul><p id="block48">We find that evidence supports predictions 1 and 2, and prediction 3 appears to be only partially supported by evidence. </p><h3 id="Prediction_1__Polysemantic_directions_overlap_with_multiple_monosemantic_polytope_regions">Prediction 1: Polysemantic directions overlap with multiple monosemantic polytope regions</h3><p id="block49">Our approach to understanding polysemantic directions is to instead begin by identifying something in a network that <i>is</i> monosemantic and work our way out from there, rather than starting with polysemantic directions and trying to figure out how they work. So, what <i>is</i> monosemantic in a neural network? </p><p id="block50">Neural networks implement approximately smooth functions, which means that small enough regions of activation space implement similar transformations. If similar representations are transformed in similar ways, it is likely that they “mean” similar things. This implies that small enough regions of activation space should be monosemantic, and indeed - this is why techniques like nearest-neighbor search work at all. <span>To verify this claim, here we collect together activations in a) the channel dimension in InceptionV1 and b) various MLP layers in GPT2 and cluster them using HDBSCAN, a hierarchical clustering technique</span><span role="doc-noteref" id="fnrefxxlcfaiw1g9"><span></span><sup><span></span><a href="#fnxxlcfaiw1g9">[9]</a></sup></span>. We observe that the majority of clusters found are monosemantic in both networks. For example, we observe clusters corresponding to specific types of animal in inception4c, and clusters responding to DNA strings, and specific emotional states in the later layers of GPT2-small. See Appendix E for more examples. </p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wwapqtkullrer4k59ep8" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/zzdbm9jil7am12wlc66r 116w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/eg82nclhvpqffaf9hvnf 196w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/yylz38a51qtedl2yoygl 276w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/aeghmxovqdvn0rd6ep0m 356w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wama4wztgk36qhmriyba 436w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/zcjwsmk7l0mxsvtrxprr 516w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ywhxb7m8snk3mkmphxan 596w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/buzwgpkobkru2ttdptky 676w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ymnxymm6yif2r7rzyoy8 756w"/><figcaption><i>Examples of clusters of activations in the output of the first branch of the 4c layer of inceptionV1. For each cluster, we plot the images and hyperpixel corresponding to the activations. Clusters were computed with HDBSCAN on the activations for one spatial dimension, and randomly chosen among clusters containing enough images.</i></figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/tmvg14vh7c1vmowuy0vm" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/n0zkmrjsnb87cucjfstf 135w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/vnlk4f3z8nc9sjhaeaka 215w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/y4s3mphunpofzcbfqgal 295w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/shjwcp3q2zglsgwsgizo 375w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/seoiziwdlma9hpzvljsh 455w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/vkvyx7nthgm1ijvwnont 535w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/oslxnje1ioalwcgmf20e 615w"/><figcaption>Figure: Dataset examples of clusters in the pre-activations of the MLP in various layers of GPT2-small. Clusters were computed using HDBSCAN on a random sample of <a href="https://pile.eleuther.ai/"><u>the pile</u></a>’s test set. Each token in the test set is treated as a separate point for clustering, and the specific token that has been clustered has been highlighted in red in each instance. We observe clusters responding both to specific tokens, and semantic concepts (typically, but not exclusively, in the later layers).</figcaption></figure><p id="block51">Instead of finding monosemantic regions by clustering activations, it’s also possible to find them by clustering spline codes. This is mildly surprising, since we’ve ostensibly removed all information about absolute magnitude - and yet it’s still possible to group similar-meaning examples together. However, a single spline code implicitly defines a set of linear constraints. These constraints, in turn, describe a set of bounding hyperplanes which confine the set of possible activations to a small region in space. Thus, much of the information about the magnitude is still retained after binarization.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/tuvh0p0qjrlddknape7l" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/dyvzw1ix2i1g130evcll 90w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/zmwc5ofpl0rs4ogjbgtp 180w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/mwtzbjgtgh1klltrff11 270w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/oyrdr12zxc6axtwdzgra 360w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/lfzhz9nww1x9nx6imudg 450w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/rd2d01nsmwrxkd8umfc5 540w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/eax5rbaub5wrcr3nkwuq 630w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/lriz9iu5suw0cbmofclj 720w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/a1deyugc5vew67gnjcgk 810w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/oivl0cljhzqsdzr3zxbq 843w"/><figcaption>Figure: Dataset examples of clusters in the pre-activations of the MLP in various layers of GPT2-small. Clusters were computed using HDBSCAN on a random sample of <a href="https://pile.eleuther.ai/"><u>the pile</u></a>’s test set. The distance matrix for clustering in the above examples was computed using hamming distance on the binarized spline codes. Each token in the test set is treated as a separate point for clustering, and the specific token that has been clustered has been highlighted in red in each instance. We observe specific clusters in earlier layers that appear to be related to detokenization - i.e grouping “http” and “https” together. Clusters later layers tend to respond to higher level semantics - synonyms for groups of patients in medical trials, for example.</figcaption></figure><p id="block52">We were interested in seeing if we would observe a similar effect with direction vectors found using dimensionality reduction techniques such as PCA or NMF. In theory, such directions should be those which explain the highest proportions of variance in the hidden space, and we would thus expect them to be amongst the most semantically consistent (monosemantic) ones.</p><p id="block53">In a “strong” version of the polytope lens - we might expect to see that even these directions, that we should expect to be monosemantic, also cross many polytope boundaries, potentially causing them to have different semantics at different magnitudes. However, the polytope lens does not preclude linear features - meaningful single directions are still possible in the latent space of a network with nonlinearities. To frame this in terms of paths through the network - it may be that there are linear features that are shared by all or most sets of paths.</p><p id="block54">To test this, we took the activations for a set of examples from a hidden layer (in this case, layer 4) of GPT2-small, and binarized them to get their spline codes. We then clustered the codes using HDBSCAN, with the same parameters as earlier experiments. Separately, we ran NMF on the raw activations (with 64 components) to find a set of directions. For each NMF vector, we measure the cosine similarity between it and each activation sample that we clustered, and plot the histograms in the below plots. The colours represent the cluster label that each activation has been assigned, each of which we have labelled with a semantic label by looking at the set of corresponding input samples. Since there are many clusters with extremely small cosine similarities that we are not interested in, we manually restrict the x-axis for each plot and display only the points with the largest similarities.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/h5sotxs9j6zlmla4oopp" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ptp1pasvppdmkb61j1d1 190w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/nxsbqvxmtx1dcwydsrxy 380w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/fgrqppdijoprifkta33n 570w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ehfk1nsqemitn90b3grb 760w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/bojfkd8bqnwpzhcpyonw 950w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/njv4jiapp2mb2nwrgvt3 1140w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/xzcgs5t2yysoo99wm57l 1330w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/q17u1n5q5qa1fmhxpzlm 1520w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/r6t6px5oun2rhjc1syqu 1710w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/kyhoxc3jodccuw9bp9nd 1863w"/><figcaption><i>Cosine similarities with respect to NMF direction 49. Activations taken from the MLP in layer 4 of GPT2-Small, using data from The Pile&#39;s test set . The dataset examples with the highest cosine similarities are shown and coloured by their cluster label (ignoring the smallest clusters).</i></figcaption></figure><p id="block56"><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/fkfzyhmhllzcwtnidedt"/><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/texh7vxiikauipzq76vf"/></p><p id="block57">The above experiments suggest that there do exist feature directions which are coherent across all polytopes in some specific layer - meaning that the affine transformations formed across the set of all polytopes are sufficiently similar to some extent.</p><h3 id="Prediction_2__Polytope_boundaries_reflect_semantic_boundaries">Prediction 2: Polytope boundaries reflect semantic boundaries</h3><p id="block58">Why should we expect polytope boundaries to reflect semantic boundaries? One geometric intuition underlying this idea is that nonlinearities are needed to silence interference between non-orthogonal features in superposition. Polytope boundaries should therefore be placed between non-orthogonal feature directions so that activations in one feature direction don’t activate the other when they shouldn’t. Another intuition is that neural networks are often used in situations where outputs are not linearly separable functions of the inputs, such as image classification. To solve such tasks, neural networks fold and squeeze the input data manifold into a shape that is linearly separable in subsequent layers (<a href="https://arxiv.org/pdf/2203.11355.pdf"><u>Keup and Helias, 2022</u></a>). Affine transformations on their own cannot improve linear separability - but since a ReLU activation maps negative values to zero, it can be thought of as making a fold in the data distribution, with the position of the dent being controlled by the previous transformation’s weights. Several ReLU neurons in combination can also act to expose inner class boundaries - making classification in later layers possible where it wasn’t in earlier ones - by “folding” regions of the distribution into new, unoccupied dimensions (see the figure below for a 1D geometric interpretation). For this reason we may expect to see a concentration of ReLU hyperplanes around such distributions, as the network acts to encode features for later layers.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/pxyzii77l2hzwktbtoka" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/dwhmntyrlhyjt9xuc0oe 120w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/qqkyjsdr3s4wo35fc0nh 240w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/dgljnan90v1bmjwpknlt 360w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wpaw3eh7qkdzgo7xg1fo 480w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/q5retmcydfyaxzqprjdu 600w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/xmh5behbszzoccpcnhsy 720w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/zhsnvuniigqrgdku0il8 840w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/onh6ocgqhocsp3nczmcz 960w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ctxqxvwlyonacxidd29t 1080w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/a2naxdjrlond6ocgsdgq 1168w"/><figcaption>Figure: How a ReLU neuron can act to expose a previously non-separable class boundary, reproduced from <a href="https://arxiv.org/pdf/2203.11355.pdf"><u>Keup and Helias, (2022)</u></a>. The solid black line is a ReLU hyperplane, and the dashed line represents a potential decision boundary. In higher dimensions - this effect requires several ReLU hyperplanes to act in conjunction.</figcaption></figure><p id="block59">Images of different classes will have many different features. Therefore, according to the polytope lens, activations caused by images from different classes should be separated by regions of denser polytope boundaries than those caused by images from the same class. Can we see this by looking at heat map visualizations of polytope density? Unfortunately, the network has too many neurons (and thus too many boundaries) to observe any differences directly.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/g0qkodv6u3zfljocqntv" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/tp4ctxjgo6ig7vgnla4u 134w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/yrxsahy0baqocmncvzvq 214w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ksrncygx8u01yukpllfd 294w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ufo8ahfauoguescvhzax 374w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wasuvotwyhzgtqwptxim 454w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/xbh7e2aoykihf3jpez2g 534w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/l7s50e6emwe6fbv001mj 614w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/iyiolarfxz5bhkhpfwql 694w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ibmumhtua0okq0gd8ior 774w"/><figcaption>Figure: Heat maps of polytope density in a 2-D slice through the 40,768-dimensional input space of layer inception5a. The 2-D slice was made such that the activation vectors of three images lie on the plane. Then we calculated the spline codes (using layers inception5a to the output) for every point in a 4,096 x 4,096 grid. Then we computed the Hamming distance between codes in adjacent pixels and applied a Gaussian smoothing. Observe that the densest region is the part of the image separating the three inputs. Method adapted from <a href="https://arxiv.org/pdf/1802.08760.pdf"><u>Novak et al., (2018)</u></a>, who calculated similar images for small networks.</figcaption></figure><p id="block60">But when we measure the polytope densities directly (by dividing the distance between two activation vector’s spline codes by their Euclidean distance, it indeed turns out to be the case that activations caused by images of different classes are separated by regions denser in polytope boundaries than activations caused by images of the same class:</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/uvb1ahqeudbq0apt387n"/><figcaption>Figure: The average normalized polytope boundary density between the activation vector caused by images of the same or different classes. The left plot is for a trained network; the right an untrained network. Since images of different classes will also produce distant activations, we should consider the density of polytope boundaries rather than the absolute number of polytope boundaries between the activations produced by different images. To calculate the polytope boundary density between two points, we simply divide the Hamming distance in between their spline codes by the Euclidean distance between them. The polytope densities are normalized by dividing by the average polytope density between all pairs of vectors (both intra and inter class). Only for the trained network is the intra-class polytope density lower. This difference increases as we move higher in the network (Figure below). The error bars are 99% bootstrapped confidence intervals. A single asterisk indicates a statistically significant difference according to a Welch&#39;s t-test (t(1873.3)=-14.7; p=3.8e-46). Note the y-axis begins at 80%; the difference is small, but significant. We see a similar story when we interpolate (instead of simply measuring the total distances) between two images of the same or different classes (Appendix A). </figcaption></figure><p id="block62">The intra- and inter-class difference is small, but significant. The difference gets more robust as we look at higher layers. The polytope lens predicts this because activations in lower layers represent low level features, which are less informative about image class than features in higher layers. For example, two images of dogs might be composed of very different sets of lines and curves, but both images will contain fur, a dog face, and a tail. Because there are more irrelevant features represented in lower layers, the percentage of polytope boundaries that relate features that are relevant to that class is smaller than between features represented in higher layers. </p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ew1gyr3kyjwa8vk1j5k4"/><figcaption>Figure: The difference between the normalized polytope density between intra- and inter-class images gets larger in layers closer to the output. </figcaption></figure><h3 id="Prediction_3__Polytopes_define_when_feature_directions_are_on__and_off_distribution">Prediction 3: Polytopes define when feature-directions are on- and off-distribution</h3><p id="block63">One of the responses to the scaling activations experiments that we’ve encountered is that we’re being unfair to the networks: We shouldn’t expect their semantics to remain intact so far outside of their typical distribution. We agree! That there exists such a distribution of validity is, in fact, a central motivation for looking at networks through the polytope lens. </p><p id="block64">The features-as-directions hypothesis doesn’t by itself make claims about the existence of a distribution of semantic validity because it assumes that representations are linear and therefore globally valid. The polytope lens predicts that scaling an activation vector will change the semantics of a given direction only when it crosses many polytope boundaries. It makes this prediction because the larger the distance between two polytopes, the more different (in expectation) is the transformation implemented by them. Polytopes boundaries thus suggest a way to identify the distribution of semantic validity. </p><p id="block65">Is this the case empirically? Partially. When we plot the local polytope density in the region near the scaled vector, we see that there is a characteristic peak between the activation vector and the origin. This peak occurs even for activation directions defined by Gaussian noise, but is absent in untrained networks (Appendix B). There appears to be a ‘shell’ of densely packed polytope boundaries surrounding the origin in every direction we looked. We’re not completely sure why polytope boundaries tend to lie in a shell, though we suspect that it’s likely related to the fact that, in high dimensional spaces, most of the hypervolume of a hypersphere is close to the surface. Scaling up the activation, we see that the vector crosses a decreasing number of polytope boundaries. This is what you’d expect of polytope boundaries that lie near the origin and extend to infinity; as a result, polytopes further from the origin will be made from boundaries that become increasingly close to being parallel. Therefore a vector crosses fewer polytope boundaries as it scales away from the center. We nevertheless see plenty of class changes in regions that are distant from the origin that have low polytope density. This wasn’t exactly what the polytope lens predicted, which was that dense polytope boundaries would be located where there were class changes. Instead we observed dense polytope boundaries as we scale <i>down </i>the activity vector and not as we scale it up. It appears that polytope boundaries only demarcate the inner bound of the distribution where a given direction means the same thing. That class changes can be observed for large magnitude activation vectors despite a low polytope boundary might simply reflect that it’s easier for large magnitude activations to move large distances when the transformations they undergo are small.</p><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/x5vqsmq1nisqmm0misyl" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/zplhcvjcuryr4z0kyage 135w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/hkm0npx3jmrfznivkgu5 215w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/spmamjy9qfovax7tuulp 295w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/xm6wsirfglhsgarudatl 375w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/h0q98biqeodipniwq8zh 455w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/dgej1nmeawyu2zrgsy3c 535w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/vvva5aan7ixzi89uparo 615w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/bwxhwubqlaimm4kssq2x 695w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/l72szfuaod9abtlqh2ly 775w"/><figcaption>Figure: The polytope density (black line) overlaying the class logits (coloured lines) for two images where the activation in a hidden layer - inception3a - is scaled. Polytope density peaks around halfway between the unscaled activation vector and the origin.</figcaption></figure><p id="block66">So polytope boundaries reflect - to some extent - the semantics learned by the network; they capture transformational invariances in the network, reflect feature boundaries, and seem to demarcate the inner bound of where feature-directions should be considered on- or off-distribution. They also seem to be involved in &#34;encoding&#34; features from raw data. Polytopes thus have many excellent properties for describing what is going on inside neural networks - but, as we will discuss in the next section, it&#39;s not clear how to harness polytopes to create <a href="https://transformer-circuits.pub/drafts/toy_model_v2/index.html"><strong>Decomposable</strong></a><strong> </strong>descriptions of the features in a network. Whilst studying neural networks through their polytope regions is a more &#34;complete&#34; description in some sense, it does not (so far) let us understand network representations in terms of features that can be understood independently. </p><p id="block67">Our effort to account for nonlinearities in neural networks has forced us to consider not just the direction of neural activations, but also their scale. This is because nonlinearities behave differently at different activation scales. Polytopes offer a way to think about how networks use nonlinearities to implement different transformations at different activation scales. But with many neurons comes exponentially many polytopes. Spline codes present a scalable way to talk about the exponential number of polytopes in neural networks since we can talk about &#34;groups&#34; or &#34;clusters&#34; of spline codes instead of individual codes.</p><p id="block68">Unfortunately, accounting for nonlinearities in this way has cost us rather a lot. Instead of dealing with globally valid feature directions, we now deal with only locally valid feature directions in activation space. By studying the structure of spline codes rather than the structure of activations, polytopes offer us the ability to identify regions of activation space that have roughly similar semantics. Are the costs worth the gains? </p><p id="block69">The short answer is that we’re not sure. The polytope lens is a way to view neural networks that puts nonlinearities front and center; but if neural networks use primarily linear representations (as hypothesized by <a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al., 2022</u></a>), then such a nonlinearity-focused perspective could potentially offer relatively little compared to a purely linear perspective, since the abstraction of a globally valid feature direction will not be particularly leaky. The lesson we take from observations of superposition and polysemanticity is that networks are often not operating in the linear regime; they suggest that they are making nontrivial use of their nonlinearities to suppress interference from polysemantic directions. This is also suggested by the empirical performance of large networks which substantially exceeds the equivalent purely linear models. It therefore appears that we need a way to account for how different regions of activation space interact differently with nonlinearities and how this affects the semantics of the network’s representations.</p><p id="block70">We ultimately think that mechanistic descriptions of networks with superposition which take nonlinearity into account will look somewhat different from previous mechanistic descriptions that tended to assume linearity (<a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al., 2022</u></a>). The polytope lens might represent an important component of such descriptions, but we’re in no way certain. If it were, what might mechanistic descriptions of neural networks look like through the polytope lens? </p><p id="block71">We think a potentially important idea for describing what neural networks have learned might be ‘<strong>representational flow</strong>’ between polytope regions. The input space of a layer may have regions that are semantically similar yet spatially distant and the job of the network is to learn how to project these spatially distant points to similar regions of output space. For example, the two images of cats in Figure Xa below are distant in input space yet semantically similar in output space; the network performs <strong>representational convergence</strong> between representations in the input and output spaces. Representational convergence may also happen between arbitrary layers, such as between the input space and layer L if the inputs happen to share features that are represented in that layers’ semantic space (Figure Xb). The converse is also possible: A network implements <strong>representational divergence</strong> if spatially similar inputs are semantically different from the perspective of the network at layer L (Figure Xc). In order to implement representational <i>convergence</i>, different polytopes need to have affine transformations that project them to similar parts of the space in later layers. Conversely, representational <i>divergence</i> requires transformations that project nearby regions of activation space to distant regions in the spaces of later layers. Networks achieve both of these things by having the right affine transformations associated with the polytope regions involved. Nonlinearities mean that vectors that have an identical direction but different scales can take different pathways through the network. The benefit of thinking about networks in terms of representational flow is that it therefore allows us to talk about the effects of nonlinearities on activation directions of different scales. </p><p id="block72"><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ah3uyhvf0gglumxcpcxj"/></p><p id="block73">Recent work on superposition by <a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al., (2022)</u></a> argues that models with superposition will only be understood if we can find a sparse overcomplete basis (or if we remove superposition altogether, an option we don’t consider here). Finding this basis seems like a crucial step toward understanding, but we don’t think it’s the full story. Even if we could describe a layer’s input features in terms of a sparse overcomplete basis, each combination of those sparse feature directions will have different patterns of interference which each interact differently with the nonlinearities. Thus, the elements of the sparse basis that are active will vary depending on the input vector; we therefore haven’t found a way around the issue that nonlinearities force us to use local, rather than global, bases.</p><p id="block74">Consequently, for most combinations it’s hard to predict exactly which activations will be above threshold without calculating the interference terms and observing empirically which are above or below threshold; this is a problem for mechanistic interpretability, where we’d like to be able to mentally model a network’s behavior without actually running it. Therefore, a sparse overcomplete basis by itself wouldn’t let us avoid accounting for nonlinearities in neural networks. Introducing assumptions about the input distribution such that interference terms are always negligibly small might however let us make predictions about a network’s behavior without adding schemes, like polytopes, that attempt to account for nonlinearities. </p><p id="block75">Our work is more closely related to the search for an overcomplete basis than it might initially appear. Clustering activations can be thought of as finding a k-sparse set of features in the activations where <span><span><span><span aria-label="k = 1"><span aria-hidden="true"><span><span>k</span></span><span><span>=</span></span><span><span>1</span></span></span></span></span></span></span> (when k is the number of active elements). In other words, finding N clusters is equivalent to finding an overcomplete basis with N basis directions, only one of which can be active at any one time. This clearly isn’t optimal for finding decomposable descriptions of neural networks; ideally we’d let more features be active at a time i.e. we’d like to let <span><span><span><span aria-label="k &gt; 1"><span aria-hidden="true"><span><span>k</span></span><span><span>&gt;</span></span><span><span>1</span></span></span></span></span></span></span>, but with clustering <span><span><span><span aria-label="k = 1"><span aria-hidden="true"><span><span>k</span></span><span><span>=</span></span><span><span>1</span></span></span></span></span></span></span>. But clustering isn’t completely senseless - If every combination of sparse overcomplete basis vectors interacts with nonlinearities in a different way, then every combination <i>behaves</i> like a different feature. Fortunately, even if it were true that every combination of sparse overcomplete features interacted with nonlinearities in a different way, their interactions almost definitely have statistical and geometric structure, which we might be able to understand. Overcomplete basis features will be one component of that structure, but they don’t account for scale; polytopes do. A path toward understanding superposition in neural networks might be an approach that describes it in terms of an overcomplete basis <i>and </i>in terms of polytopes. A potential future research direction might therefore be to find overcomplete bases in spline codes rather than simply clustering them. This might be one way to decompose the structure of representational flow into modules that account for both activation directions as well as activation scale.</p><p id="block76">Many other questions remain unaddressed in this post. We think they will be important to answer before the polytope lens can be used in as many circumstances as the features-as-directions perspective has been. </p><ul><li id="block77"><strong>Fuzzy polytope boundaries with other activations </strong>- For the sake of simplicity, we’ve been assuming that the networks discussed in the article so far have used piecewise linear activation functions such as ReLU. But many networks today, including large language models, often use smooth activations such as GELU and softmax, which mean that their polytopes won’t really be polytopes - their edges will be curvy or even ‘blurred’. Some prior work exists that extends the polytope lens to such activations (<a href="https://arxiv.org/abs/1810.09274"><u>Balestriero &amp; Baraniuk, 2018</u></a>). See Appendix C for further discussion. </li><li id="block78"><strong>How do we extend the polytope lens to transformers?</strong> Specifically, how should we talk about polytopes when attention between embedding vectors makes activations (and hence polytopes) interact multiplicatively across sequence positions? </li><li id="block79"><strong>How do adversarial examples fit into this picture?</strong> Are adversarial examples adversarial because they perturb the input such that it crosses many polytope boundaries (polytope ridges)? And can we use this potential insight in order to make networks less susceptible to such attacks? </li></ul><h2 id="Interpreting_polytopes__single_neurons__or_directions">Interpreting polytopes, single neurons, or directions</h2><p id="block80">The geometric interpretation of ReLU networks was, to our knowledge, first laid out by <a href="https://www.cs.toronto.edu/~fritz/absps/reluICML.pdf"><u>Nair and Hinton, (2010)</u></a>, who note that each unit corresponds to a hyperplane through the input space, and that N units in concert can create 2^N regions (what we call polytopes), each of which can be viewed as a separate linear model. <a href="https://arxiv.org/pdf/1312.6098.pdf"><u>Pascanu et al., (2014)</u></a> undertook a more detailed theoretical analysis of the number of these linear regions in ReLU models.</p><p id="block81">The fact that each of these regions could be identified as a unique <i>code</i>, which can then be used for interpretability analysis and clustering, was explored by <a href="https://arxiv.org/abs/1410.1165"><u>Srivastava et al., (2014)</u></a>, who studied a small MNIST network by clustering the codes at its final layer. </p><p id="block82">That these regions take the form of convex polytopes is also not a novel concept, and has been explored in a number of prior works (<a href="https://arxiv.org/abs/1805.06576"><u>Balestriero &amp; Baraniuk, 2018a</u></a>, <a href="https://arxiv.org/pdf/1802.08760.pdf"><u>Novak et al., 2018</u></a>, <a href="https://arxiv.org/pdf/1906.00904.pdf"><u>Hanin &amp; Rolnick, 2019a</u></a>, <a href="http://proceedings.mlr.press/v119/rolnick20a/rolnick20a.pdf"><u>Rolnick &amp; Kording, 2019</u></a>, <a href="https://openreview.net/forum?id=EQjwT2-Vaba"><u>Xu et al., 2021</u></a>). In this writeup, we have relied particularly heavily on conceptualizing DNNs as compositions of <i>max-affine spline operators</i>, as introduced in <a href="https://arxiv.org/abs/1805.06576"><u>Balestriero &amp; Baraniuk, (2018a)</u></a>, and expanded upon in a series of further works (<a href="https://arxiv.org/pdf/1810.09274.pdf"><u>Balestriero &amp; Baraniuk, 2018b</u></a>, <a href="https://arxiv.org/pdf/1905.08443.pdf"><u>Balestriero et al., 2019</u></a>). </p><p id="block83">However, in much of the wider interpretability field – particularly in papers focused on interpretability in language models – this point of view has gone largely unnoticed, and interpretation efforts have tended to try to identify the role of single neurons or linear combinations of neurons (directions). Interpretable neurons have been noted fairly widely in various works focusing on vision models (<a href="https://arxiv.org/pdf/1312.6199.pdf"><u>Szegedy et al., 2014</u></a>, <a href="https://arxiv.org/pdf/1704.05796.pdf"><u>Bau et al., 2017</u></a>). Interpretable directions were also a central focus of the <a href="https://distill.pub/2020/circuits/"><u>Circuits Thread, (Olah et al., 2020)</u></a>, where they used knowledge built up from interpreting neurons in early layers of inceptionv1 to hand code curve detectors that, when substituted for the curve detectors in the original network, induced minimal performance loss.  </p><p id="block84">Interpretable single neurons have also been found in language models (<a href="https://arxiv.org/abs/2012.14913"><u>Geva et al., 2020</u></a>, <a href="https://arxiv.org/pdf/2010.02695.pdf"><u>Durrani et al., 2020</u></a>, <a href="https://arxiv.org/abs/2104.08696"><u>Dai et al., 2021</u></a>, <a href="https://youtu.be/DA3AA1w5TC0?t=1044"><u>Elhage et al., 2022</u></a>), although monosemantic neurons seem comparatively less common in this class of model. <a href="https://arxiv.org/abs/2104.07143"><i><u>An Interpretability Illusion for BERT </u></i><u>(Bolukbasi et al., 2021)</u></a>, highlighted the fact that the patterns one might see when inspecting the top-k activations of some neuron may cause us to spuriously interpret it as encoding a single, simple concept, when in fact it is encoding for something far more complex. They also noted that many directions in activation space that were thought to be globally interpretable may only be locally valid.</p><h2 id="Polysemanticity_and_Superposition">Polysemanticity and Superposition</h2><p id="block85">The earliest mention of polysemanticity we could find in machine learning literature was from <a href="https://arxiv.org/pdf/1602.03616.pdf"><u>Nguyen et al., (2016)</u></a>. In their paper they identify the concept of <i>multifaceted</i> neurons. That is, neurons which fire in response to many different types of features. In this work, we define <i>polysemantic</i> neurons as neurons which fire in response to many different <i>unrelated</i> features, and they identify an example of this in their supplementary material (Figure S5).</p><p id="block86">Work by Olah et al., <a href="https://distill.pub/2017/feature-visualization/"><i><u>Feature Visualization</u></i></a>, identified another way to elicit polysemantic interpretations and helped to popularize the idea. They note that, as well as there being neurons which represent a single coherent concept, “... <i>there are also neurons that represent strange mixtures of ideas. Below, a neuron responds to two types of animal faces, and also to car bodies. Examples like these suggest that neurons are not necessarily the right semantic units for understanding neural nets</i>.”</p><figure></figure><p id="block89">Even before this, the possibility that individual neurons could respond to multiple features was discussed in some early connectionist literature, including <a href="http://www.cs.toronto.edu/~hinton/absps/shape81.pdf"><u>Hinton, (1981)</u></a>. In neuroscience, polysemanticity is usually called ‘mixed selectivity’. Neuroscience has only in the last decade or two developed the tools required to identify and study mixed selectivity. Since then, it has been the subject of increasing attention, especially its role in motor- and decision- neuroscience (<a href="https://journals.physiology.org/doi/full/10.1152/jn.00095.2007"><u>Churchland et al., 2007</u></a>; <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4412347/"><u>Rigotti et al., 2013</u></a>; <a href="https://www.nature.com/articles/nature12742"><u>Mante et al., 2013</u></a>). For a review of mixed selectivity in neuroscience, see <a href="https://earlkmiller.mit.edu/wp-content/uploads/2016/02/Fusi-Miller-Rigotti-CONB-2016.pdf"><u>Fusi et al., (2016)</u></a>.  </p><p id="block90">Recent work from <a href="https://transformer-circuits.pub/2022/toy_model/index.html#discussion"><u>Elhage et al., (2022)</u></a> sheds light on a phenomenon that they term “superposition”. Superposition occurs when a neural network represents more features than it has dimensions, and the mapping from features to orthogonal basis directions can no longer be bijective. This phenomenon is related to, but not the same as polysemanticity; it may be a cause of some of the polysemantic neurons we see in practice. They investigate toy models with non-linearities placed at the output layer, and show that superposition is a real phenomenon that can cause both mono- and polysemantic neurons to form. They also describe a simple example of computation being performed on features in superposition. Finally, they reveal that superposition can cause a different type of polytope to form - in their toy model, features are organized into geometric structures that appear to be a result of a repulsive force between feature directions which acts to reduce interference between features. It’s worth emphasizing that the polytopes discussed in their work aren’t the same kind as in ours: For one, our polytopes lie in activation space whereas theirs lie in the model weights. Perhaps a more fundamental divergence between Elhage et al.’s model and ours is the assumption of linearity - the idea that features are represented by a single direction in activation space. As we explained in earlier sections, we believe that assuming linearity will yield only partial mechanistic understanding of nonlinear networks. While globally valid feature directions would simplify analysis, in practice we struggle to see a way around nonlinearity  by assuming linear representations. </p><h2 id="A__Polytope_density_while_interpolating_between_activations_caused_by_images">A. Polytope density while interpolating between activations caused by images</h2><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/bbuppi0bcszso1z8c24v"/><figcaption>Figure: The polytope density for each class during a spherical interpolation between the activations caused by images of different classes in inception3a. The polytope codes were computed from the activations at layer 3a to the output layer. The polytope density was estimated by sampling 150 random points around each position during the interpolation and computing the number of polytopes passed through versus the euclidean distance. The interpolation path passes through multiple other classes. We see that the polytope density is highest in the intermediate region where there is much class change between intermediate classes. This trend is relatively weak, however. This provides tentative evidence in favor of the relationship between polytope density and semantic change in representation.</figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wbhvkjmby9oqrgadz2l2"/><figcaption>Figure: Mean polytope density (averaged over 200 image interpolations) by spherically interpolating between different class examples on each layer. Dotted lines represent the mean interpolation between images of the same class and solid lines represent the mean interpolation between images of different classes. The shaded regions represent the standard error of the mean. The polytope codes were computed from the embedding at the labeled layer to the output space. For lower imagenet layers, where the class labels are less informative of the semantic features, we see that the polytope density exhibits a double dip phenomenon where it increases when about half interpolated, indicating that interpolation leaves the manifold of typical activations. For later layers, the polytope density decreases and the curve flattens during interpolation implying that at these layers there are more monosemantic polytopes and the class labels are more representative of the feature distribution.</figcaption></figure><h2 id="B__Scaling_activation_vectors_and_plotting_polytope_density">B. Scaling activation vectors and plotting polytope density</h2><h3 id="Untrained_network">Untrained network</h3><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ouzhycrf0m3glph2iqgz" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/iikzek0glilr50vhwlsr 139w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/zrpbmvdvdjeqypxpul8r 219w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/rlp0mflpzbrkbybbobo6 299w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/trrtnsqus9frgsxa4zoa 379w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/gb7efrjicgklq6emhtaa 459w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/id32be0yqsbfvdgcmxaa 539w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/f4pmifz02hrccer2r5mx 619w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/nxsmyunrfmkq6qg6pqea 699w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wiqcqc2ia32qiyots8wp 779w"/><figcaption>Note that the unchanging class in the untrained network is due to a phenomenon that resembles ‘rank collapse’: Even though the input and early activations are different, the activations of the untrained network converge on the same output. We believe this might due to a quirk for our variant of InceptionV1 (perhaps its batchnorm), but we haven’t investigated why exactly this happens.</figcaption></figure><h3 id="With_Gaussian_noise_activations">With Gaussian noise activations</h3><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/p7flxebbapn9r3cdieto" srcset="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/dqm3uqced0lxlzqaoo5o 135w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/tdmzhljfaijtnt3pjybl 215w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wsxrjoyuytdfqteiftjw 295w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/qvv2llt0ut261hf4zhlh 375w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/omvnjtjjlui6sc6uityk 455w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/zi7brl0w03br68a79lvc 535w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/thwlkv629vzn9nwvquii 615w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/oudzywrjytolsoxtrwde 695w, https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/cbnzyohgk6q0w7m7fmt9 775w"/></figure><h2 id="C__Mathematical_account_of_neural_networks_as_max_affine_spline_operators__MASOs_">C. Mathematical account of neural networks as max affine spline operators (MASOs)</h2><p id="block92">In the below section we give an account of some recent theory from <a href="http://proceedings.mlr.press/v80/balestriero18b.html"><u>Balestriero and Baraniuk, (2018)</u></a> that links deep neural networks to approximation theory via spline functions and operators. More specifically, the authors describe deep neural networks with piecewise linear activation functions (like ReLU) as compositions of <i>max-affine spline operators (MASOs), </i>where each layer represents a single MASO<i>.</i> A MASO is an <i>operator</i> composed of a set of individual <i>max-affine spline</i> functions (MASs), one for each neuron in a given nonlinear layer. </p><p id="block93">We won’t go too deep into spline approximation theory here, but you can think of a spline function approximation in general as consisting of a set of partitions <span><span><span><span aria-label="\Omega^R"><span aria-hidden="true"><span><span><span><span>Ω</span></span></span><span><span><span>R</span></span></span></span></span></span></span></span></span> of the input space, with a simple local mapping in each region. The <i>affine</i> part means that this mapping consists of an affine transformation of the input in a given region: </p><p id="block94"><a href="https://www.codecogs.com/eqnedit.php?latex=a_r%20x%20%2B%20b_r%20%5C%3B%20%5Ctext%7Bfor%7D%20%5C%3B%20r%20%3D%201%2C%20...%2C%20R#0"><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/sz62rk3dottcxkihrhuy"/></a></p><p id="block95">The <i>max</i> part means that, instead of needing to specify the <i>partition</i> <i>region</i> of our input variable in order to determine the output, we can simply take the maximum value when we apply the entire set of affine transformations for each region:</p><p id="block96"><a href="https://www.codecogs.com/eqnedit.php?latex=z(x)%20%3D%20%5Cunderset%7Br%3D1%2C%20...%2C%20R%7D%7B%5Cmax%7Da_rx%2Bb_r#0"><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/hnspr8hnm0unyeiwyjjb"/></a></p><p id="block97">A visual example is helpful to understand why this works. Suppose we have a spline approximation function with <span><span><span><span aria-label="R=4"><span aria-hidden="true"><span><span>R</span></span><span><span>=</span></span><span><span>4</span></span></span></span></span></span></span> regions:</p><p id="block98"><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/ci44ywted9u4m79bv9mz"/></p><p id="block99">Each red line represents a single spline with a corresponding affine transformation (<span><span><span><span aria-label="a_r"><span aria-hidden="true"><span><span><span><span>a</span></span></span><span><span><span>r</span></span></span></span></span></span></span></span></span>, <span><span><span><span aria-label="b_r"><span aria-hidden="true"><span><span><span><span>b</span></span></span><span><span><span>r</span></span></span></span></span></span></span></span></span>), and the dotted light blue line represents the maximum value of all the affine transformations at each x location. We can see that it follows an approximation of the convex function (in dark blue).</p><p id="block100">A single ReLU unit can be expressed as a special case of <i>max-affine spline</i> with <span><span><span><span aria-label="R=2"><span aria-hidden="true"><span><span>R</span></span><span><span>=</span></span><span><span>2</span></span></span></span></span></span></span> regions:</p><p id="block101"><a href="https://www.codecogs.com/eqnedit.php?latex=relu(x)%20%3D%20%5Cunderset%7Br%3D1%2C%202%7D%7B%5Cmax%7D%20%5C%3B%20a_rx%2Bb_r#0"><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/uiblqdqb1xzxprvc2eg9"/></a></p><p id="block102">Where  <span><span><span><span aria-label="(a_1, b_1) = (0, 0)"><span aria-hidden="true"><span><span>(</span></span><span><span><span><span>a</span></span></span><span><span><span>1</span></span></span></span><span><span>,</span></span><span><span><span><span>b</span></span></span><span><span><span>1</span></span></span></span><span><span>)</span></span><span><span>=</span></span><span><span>(</span></span><span><span>0</span></span><span><span>,</span></span><span><span>0</span></span><span><span>)</span></span></span></span></span></span></span> and <span><span><span><span aria-label="(a_2, b_2) = (W_i, b_i)"><span aria-hidden="true"><span><span>(</span></span><span><span><span><span>a</span></span></span><span><span><span>2</span></span></span></span><span><span>,</span></span><span><span><span><span>b</span></span></span><span><span><span>2</span></span></span></span><span><span>)</span></span><span><span>=</span></span><span><span>(</span></span><span><span><span><span>W</span></span></span><span><span><span>i</span></span></span></span><span><span>,</span></span><span><span><span><span>b</span></span></span><span><span><span>i</span></span></span></span><span><span>)</span></span></span></span></span></span></span>, which are the weight and bias vectors for a given neuron. An entire ReLU layer can then be seen simply as a concatenation of <span><span><span><span aria-label="d"><span aria-hidden="true"><span><span>d</span></span></span></span></span></span></span> of these <span><span><span><span aria-label="R=2"><span aria-hidden="true"><span><span>R</span></span><span><span>=</span></span><span><span>2</span></span></span></span></span></span></span>  MASs, where <span><span><span><span aria-label="d"><span aria-hidden="true"><span><span>d</span></span></span></span></span></span></span> is the width of the layer – this is our MASO.</p><p id="block103">This becomes slightly more complicated for smooth activation functions like GELU and Swish. But, fortunately, in a <a href="https://arxiv.org/pdf/1810.09274.pdf"><u>later paper</u></a> the same authors extend their framework to just such functions. In summary - smooth activation functions must be represented with a <i>probabilistic</i> spline code rather than a one-hot binary code. The corresponding affine transformation at the input point is then a linear interpolation of the entire set of affine transformations, weighted by the input point’s probability of belonging to each region.</p><h2 id="D__Note_on_Terminology_of_Superposition__Interference__and_Aliasing"></h2><p id="block104">The concepts referred to by the terms ‘superposition’ and ‘interference’ <a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al., (2022)</u></a> have parallel names in other literature. We provide this footnote with the hope of inspiring links between mechanistic interpretability and related results in signal processing, systems theory, approximation theory, physics, and other fields. </p><p id="block105">The <a href="https://en.wikipedia.org/wiki/Superposition_principle"><u>superposition principle</u></a> in the theory of linear systems refers to the fact that states of or solutions to a linear system may be added together to yield another state or solution. For example, solutions to linear wave equations may be summed to yield another solution. In this sense, superposition tells us that we can mathematically deduce the action of a system on any input from its action on a set of orthogonal basis vectors. This usage clashes with its usage in the mechanistic interpretability literature so far, where it has often been used to refer to systems without such a decomposition property. ‘Interference’ generally refers to superposition applied to linear waves. Specifically, the components of two waves interfere with each other, but orthogonal components within a wave do not.</p><p id="block106">The notion of ‘superposition’ and ‘interference’ as used in <a href="https://transformer-circuits.pub/2022/toy_model/index.html"><u>Elhage et al., (2022)</u></a>, where different features fail to be completely independent and inhibit correct measurements is similar to the idea of <a href="https://en.wikipedia.org/wiki/Aliasing"><u>aliasing</u></a> in other literatures. The term &#39;aliasing&#39; originates in signal processing. In that context, aliasing arose from the indistinguishability of waves of different frequencies under discrete sampling schemes. Aliasing has come to refer more generally to the phenomenon in which a set of desired quantities (e.g. features) fails to be orthogonal with respect to a measurement basis. If we wish to determine the value of <i>n</i> features from <i>k &lt;&lt; n</i> measurements, some sets of feature values may yield the same measurements. In the case of sampling waves, high-frequency waves may appear the same as low-frequency waves. In the case of approximating functions from <i>k</i> many sample points, high-degree polynomials may take the same values on those <i>k</i> points (see <a href="https://people.maths.ox.ac.uk/trefethen/ATAP/ATAPfirst6chapters.pdf"><u>ATAP Chapter 4</u></a> for a discussion in the case of Chebyshev interpolation). In image processing, <a href="https://en.wikipedia.org/wiki/Spatial_anti-aliasing"><u>anti-aliasing</u></a> is used to deal with visual artifacts that come from high-frequency components being indistinguishable from lower frequency components. </p><p id="block107">Quantum mechanics uses the conventions we have described. A quantum system with two possible classical states <span><span><span><span aria-label="|0&gt;"><span aria-hidden="true"><span><span><span><span>|</span></span></span></span><span><span>0</span></span><span><span>&gt;</span></span></span></span></span></span></span> and <span><span><span><span aria-label="|1&gt;"><span aria-hidden="true"><span><span><span><span>|</span></span></span></span><span><span>1</span></span><span><span>&gt;</span></span></span></span></span></span></span> has its quantum state described as an orthogonal superposition of the form <span><span><span><span aria-label="a|0&gt; + b|1&gt;"><span aria-hidden="true"><span><span>a</span></span><span><span><span><span>|</span></span></span></span><span><span>0</span></span><span><span>&gt;</span></span><span><span>+</span></span><span><span>b</span></span><span><span><span><span>|</span></span></span></span><span><span>1</span></span><span><span>&gt;</span></span></span></span></span></span></span> where <i>a</i> and <i>b</i> are complex numbers. The two classical states do not ‘interfere’ with each other. Rather, two independent quantum systems may additively interfere with corresponding orthogonal components interfering. Interference and superposition in this context are not referring to entanglement. Just as we may represent <span><span><span><span aria-label="(|0&gt;+|1&gt;)/\sqrt 2"><span aria-hidden="true"><span><span>(</span></span><span><span><span><span>|</span></span></span></span><span><span>0</span></span><span><span>&gt;</span></span><span><span>+</span></span><span><span><span><span>|</span></span></span></span><span><span>1</span></span><span><span>&gt;</span></span><span><span>)</span></span><span><span><span><span>/</span></span></span></span><span><span><span><span>√</span></span><span><span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> as a superposition of the states <span><span><span><span aria-label="|0&gt;"><span aria-hidden="true"><span><span><span><span>|</span></span></span></span><span><span>0</span></span><span><span>&gt;</span></span></span></span></span></span></span> and <span><span><span><span aria-label="|1&gt;"><span aria-hidden="true"><span><span><span><span>|</span></span></span></span><span><span>1</span></span><span><span>&gt;</span></span></span></span></span></span></span> , we may also represent the state |0&gt; as a superposition of the states <span><span><span><span aria-label="(|0&gt;+|1&gt;)/\sqrt 2"><span aria-hidden="true"><span><span>(</span></span><span><span><span><span>|</span></span></span></span><span><span>0</span></span><span><span>&gt;</span></span><span><span>+</span></span><span><span><span><span>|</span></span></span></span><span><span>1</span></span><span><span>&gt;</span></span><span><span>)</span></span><span><span><span><span>/</span></span></span></span><span><span><span><span>√</span></span><span><span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> and <span><span><span><span aria-label="(|0&gt;-|1&gt;)/\sqrt 2"><span aria-hidden="true"><span><span>(</span></span><span><span><span><span>|</span></span></span></span><span><span>0</span></span><span><span>&gt;</span></span><span><span>−</span></span><span><span><span><span>|</span></span></span></span><span><span>1</span></span><span><span>&gt;</span></span><span><span>)</span></span><span><span><span><span>/</span></span></span></span><span><span><span><span>√</span></span><span><span><span><span>2</span></span></span></span></span></span></span></span></span></span></span>. The important detail regarding ‘superposition’ is the additivity, not the particular choice of classical states for our representation. The <a href="https://en.wikipedia.org/wiki/Quantum_superposition"><u>quantum harmonic oscillator</u></a> has eigenstates (orthogonal basis vectors for the system) described by <a href="https://en.wikipedia.org/wiki/Hermite_polynomials"><u>Hermite polynomials</u></a>. If we approximate the Hermite polynomials with an asymptotic approximation, we will observe aliasing due to the failure of our approximation to be perfectly orthogonal.</p><h2 id="E__Examples_of_Text_Clusters_from_GPT2_Small">E. Examples of Text Clusters from GPT2-Small</h2><h2 id="Spline_code_clusters__computed_with_codes_from_layer_L____output__">Spline code clusters (computed with codes from layer L -&gt; output):</h2><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/k719s8yvjou2wta6buhg"/><figcaption>A cluster responding to figure and table references in latex documents. </figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/mho7vnm9wlnepkgzcife"/><figcaption>A cluster responding to decimal points in numbers.</figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/xsvtk6xtjx5durzgpacs"/><figcaption>A cluster responding to words followed by commas (or conjunctive pronouns?).</figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/bncajcafhkpozbsk1n75"/><figcaption>A cluster responding to spans of time.</figcaption></figure><h2 id="Activation_clusters_"></h2><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/l9flnllcxdeoqqm7c4fk"/><figcaption>A &#39;detokenization&#39; cluster that responds both to the word “is” and its contraction.</figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/i20lt8izludhekiow1qh"/><figcaption>A cluster responding to dates.</figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/pandyd4sgurzhjddzjn0"/><figcaption>A cluster responding to forward slashes in file paths.</figcaption></figure><figure><img src="https://res.cloudinary.com/lesswrong-2-0/image/upload/f_auto,q_auto/v1/mirroredImages/eDicGjD9yte6FLSie/wtxcj62kx4gvffyc1vds"/><figcaption>A cluster responding to multiples of ten (verbal and numeric).</figcaption></figure><ol role="doc-endnotes"><li role="doc-endnote" id="fnyp6wk11agmm"><span><sup><strong><a href="#fnrefyp6wk11agmm">^</a></strong></sup></span><p id="block110">And, with some relaxations to ‘soft’ polytopes, the polytope lens might also let us mechanistically describe neural networks with activations such as GELU and Swish. Some prior work exists that extends the polytope lens to such activations (<a href="https://arxiv.org/abs/1810.09274">Balestriero &amp; Baraniuk, 2018</a>). See the Appendix C for further discussion.</p></li><li role="doc-endnote" id="fnfj8lun8q4lh"><span><sup><strong><a href="#fnreffj8lun8q4lh">^</a></strong></sup></span><p id="block112"> In neuroscience, the polysemanticity is called mixed selectivity (<a href="https://earlkmiller.mit.edu/wp-content/uploads/2016/02/Fusi-Miller-Rigotti-CONB-2016.pdf"><u>Fusi et al., 2016</u></a>)</p></li><li role="doc-endnote" id="fno89s50smuz"><span><sup><strong><a href="#fnrefo89s50smuz">^</a></strong></sup></span><p id="block114">We chose InceptionV1 since it has served as a kind of ‘model system’ in previous mechanistic interpretability work. But the Pytorch <a href="https://github.com/pytorch/vision/blob/main/torchvision/models/googlenet.py"><u>implementation</u></a> of the InceptionV1 architecture (also known as GoogLeNet), it transpires, differs from the original. The original had no batch norm, whereas the Pytorch version does.</p></li><li role="doc-endnote" id="fnesps52fntne"><span><sup><strong><a href="#fnrefesps52fntne">^</a></strong></sup></span><p id="block116">Similar encoding methods have been widely observed in neuroscience where they are called “population coding”. Population codes have been found or hypothesized to exist in many neural regions and especially the <a href="https://www.ini.uzh.ch/~kiper/georgopoulos.pdf"><u>motor cortex</u></a>.</p></li><li role="doc-endnote" id="fn9itzt8xhtlf"><span><sup><strong><a href="#fnref9itzt8xhtlf">^</a></strong></sup></span><p id="block118">The idea that non-orthogonal representations interfere with each other has a long history in machine learning, starting with the study of the memory capacity of associative memories such as Hopfield networks which face the same underlying tradeoff between information capacity and orthogonality (<a href="https://www.pnas.org/doi/pdf/10.1073/pnas.79.8.2554"><u>Hopfield, 1982</u></a>; <a href="https://authors.library.caltech.edu/7008/1/ABUieeetit85.pdf"><u>Abu-Mostafa &amp; St. Jacques, 1985</u></a>). When features are encoded in non-orthogonal directions, the activation of one feature coactivates all feature directions sharing a non-zero dot product with it, leading to interference.</p></li><li role="doc-endnote" id="fn662ir63ay26"><span><sup><strong><a href="#fnref662ir63ay26">^</a></strong></sup></span><p id="block120">The arguments we make in support of the Polytope Lens  also apply to other activation functions such as GELU. But for simplicity we stick to piecewise linear activation functions because it’s easier to think geometrically in terms of straight lines rather than curvy ones.</p></li><li role="doc-endnote" id="fnnxrcvy6eqr"><span><sup><strong><a href="#fnrefnxrcvy6eqr">^</a></strong></sup></span><p id="block122">Although exponential, it’s not as many as one would naively expect - see <a href="https://arxiv.org/abs/1906.00904"><u>Hanin &amp; Rolnick, (2019b)</u></a>.</p></li><li role="doc-endnote" id="fn7bn8gghu3b9"><span><sup><strong><a href="#fnref7bn8gghu3b9">^</a></strong></sup></span><p id="block124">This could be quantified, for instance, as the Frobenius norm of the difference matrix between the implied weight matrices of the affine transformations implemented in each polytope. </p></li><li role="doc-endnote" id="fnxxlcfaiw1g9"><span><sup><strong><a href="#fnrefxxlcfaiw1g9">^</a></strong></sup></span><p id="block126">While we use HDBSCAN in this work, the specific algorithm isn&#39;t important. Any clustering algorithm that groups together any sufficiently nearby activations or codes should yield monosemantic clusters.</p></li></ol></div></div></div></div>
  </body>
</html>
