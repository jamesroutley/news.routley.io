<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytepawn.com/randomness-extractors-making-fair-coins-out-of-biased-coins.html">Original</a>
    <h1>Randomness extractors: making fair coins out of biased coins</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h2>Introduction</h2>
<p>In a previous post titled <a href="https://bytepawn.com/fair-coin-from-biased-coin.html">Fair coin from biased coin</a>, I looked at the problem of creating a uniform random coin given access to a biased coin. I looked at multiple approaches, and determined that they&#39;re actually all the same in some sense. Recently, while reading Turing award winner <a href="https://en.wikipedia.org/wiki/Avi_Wigderson">Avi Widgerson</a>&#39;s excellent book <a href="https://www.amazon.com/Mathematics-Computation-Avi-Wigderson/dp/0691189137">Mathematics and Computation</a>, I learned that this is a simple case of a more general problem of <strong>deterministic randomness extraction</strong>: given a stream of random input bits, which are potentially biased and correlated, create a stream of output bits which are uniform random, ie. a series of fair coin tosses. The output bit stream, like in the Von Neumann case, is allowed to have a lower bitrate, ie. we don&#39;t always emit output bits on input.</p>
<p>Using the language of <a href="https://bytepawn.com/cross-entropy-joint-entropy-conditional-entropy-and-relative-entropy.html">entropy</a>, the input bit stream has non-zero, but less than 1-bit of entropy per bit: $ 0 &lt; H_{input} &lt; 1 $. We want to create an output bit stream which does have 1-bit of entropy per bit, or close to it: $ H_{output} \approx 1 $. The price we pay is (potentially) emitting less bits, ie. if the input bit stream has some bitrate $ r_{input} \: bits/sec $, then for the output bit stream $ r_{output} &lt; r_{input} $.</p>
<p>I will skip the exact mathematical definitions and theorems, and instead go step-by-step to build more sophisticated randomness extractors, with Python code samples. <a href="https://github.com/mtrencseni/playground/blob/master/Randomness%20Extractors.ipynb">The code is up on Github.</a></p>
<h2>Base classes</h2>
<p>First, let&#39;s define some Python base classes that capture the core concepts of our problem domain. A <code>BitSource</code> is something that emits bits (represented as <code>int</code>s here), while a <code>RandomnessExtractor</code> is something which internally gets bits from a <code>BitSource</code>, and sometimes emits a bit, sometimes returns <code>None</code>:</p>
<div><pre><span></span><code><span>class</span> <span>BitSource</span><span>(</span><span>ABC</span><span>):</span>
    <span>@abstractmethod</span>
    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
        <span>pass</span>


<span>class</span> <span>RandomnessExtractor</span><span>(</span><span>ABC</span><span>):</span>
    <span>@abstractmethod</span>
    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Optional</span><span>[</span><span>int</span><span>]:</span>
        <span>pass</span>
</code></pre></div>

<p>Let&#39;s define a <code>BiasedBitSource</code>:</p>
<div><pre><span></span><code><span>class</span> <span>BiasedBitSource</span><span>(</span><span>BitSource</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>bias</span><span>=</span><span>None</span><span>):</span>
        <span>if</span> <span>bias</span> <span>is</span> <span>None</span><span>:</span>
            <span>bias</span> <span>=</span> <span>random</span><span>()</span>
        <span>self</span><span>.</span><span>bias</span> <span>=</span> <span>bias</span>

    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
        <span>if</span> <span>random</span><span>()</span> <span>&lt;</span> <span>self</span><span>.</span><span>bias</span><span>:</span>
            <span>return</span> <span>0</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>1</span>
</code></pre></div>

<h2>Trivial case: fair coin from fair coin</h2>
<p>Let&#39;s define a simple <code>PasstroughExtractor</code>, which just returns the input bit stream:</p>
<div><pre><span></span><code><span>class</span> <span>PassthroughExtractor</span><span>(</span><span>RandomnessExtractor</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>bit_source</span><span>:</span> <span>BitSource</span><span>):</span>
        <span>self</span><span>.</span><span>bit_source</span> <span>=</span> <span>bit_source</span>
        <span>self</span><span>.</span><span>bits</span> <span>=</span> <span>[]</span>
    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Optional</span><span>[</span><span>int</span><span>]:</span>
        <span>bit</span> <span>=</span> <span>self</span><span>.</span><span>bit_source</span><span>.</span><span>next</span><span>()</span>
        <span>result</span> <span>=</span> <span>bit</span>
        <span>print_bits</span><span>(</span><span>bit</span><span>,</span> <span>result</span><span>)</span>
        <span>return</span> <span>result</span>
</code></pre></div>

<p>The trivial application then is:</p>
<div><pre><span></span><code><span>bit_source</span> <span>=</span> <span>BiasedBitSource</span><span>(</span><span>bias</span><span>=</span><span>0.5</span><span>)</span>
<span>extractor</span> <span>=</span> <span>PassthroughExtractor</span><span>(</span><span>bit_source</span><span>)</span>

<span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>100</span><span>):</span>
    <span>result</span> <span>=</span> <span>extractor</span><span>.</span><span>next</span><span>()</span>
</code></pre></div>

<p>Let&#39;s see it in action. The first column is always the input bit stream, the second column is the output bit stream:</p>


<h2>von Neumann: fair coin from biased coin</h2>
<p>Let&#39;s make the following two assumptions about the input bit stream:</p>
<ul>
<li>each bit in the input stream is an independent (potentially biased) coin toss</li>
<li>each bit in the input stream has identical bias (say $p=0.7$ for <code>1</code>)</li>
</ul>
<p>In other words, the input stream is made up of indepedent identical (iid) random variables. In this case, the von Neumann rule works:</p>
<ul>
<li>break the input stream into non-overlapping 2 bit pairs</li>
<li>if the 2 bits are <code>00</code> or <code>11</code>, don&#39;t emit</li>
<li>if the 2 bits are <code>01</code>, emit 1</li>
<li>if the 2 bits are <code>10</code>, emit 0</li>
</ul>
<p>This works because the probability for both <code>01</code> and <code>10</code> is $p(1-p)$. Interestingly, this is the best possible approach, whether we know the bias of the input bit stream or not. The code for the <code>VonNeumannExtractor</code> is below:</p>
<div><pre><span></span><code><span>class</span> <span>VonNeumannExtractor</span><span>(</span><span>RandomnessExtractor</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>bit_source</span><span>:</span> <span>BitSource</span><span>):</span>
        <span>self</span><span>.</span><span>bit_source</span> <span>=</span> <span>bit_source</span>
        <span>self</span><span>.</span><span>bits</span> <span>=</span> <span>[]</span>

    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Optional</span><span>[</span><span>int</span><span>]:</span>
        <span>bit</span> <span>=</span> <span>self</span><span>.</span><span>bit_source</span><span>.</span><span>next</span><span>()</span>
        <span>if</span> <span>bit</span> <span>not</span> <span>in</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>]:</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;Bit must be 0 or 1.&#34;</span><span>)</span>
        <span>self</span><span>.</span><span>bits</span><span>.</span><span>append</span><span>(</span><span>bit</span><span>)</span>
        <span>result</span> <span>=</span> <span>None</span>
        <span>if</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>bits</span><span>)</span> <span>==</span> <span>2</span><span>:</span>
            <span>if</span> <span>self</span><span>.</span><span>bits</span> <span>==</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>]:</span>
                <span>result</span> <span>=</span> <span>1</span>
            <span>elif</span> <span>self</span><span>.</span><span>bits</span> <span>==</span> <span>[</span><span>1</span><span>,</span> <span>0</span><span>]:</span>
                <span>result</span> <span>=</span> <span>0</span>
            <span>self</span><span>.</span><span>bits</span> <span>=</span> <span>[]</span>  <span># Reset for the next pair of bits</span>
        <span>print_bits</span><span>(</span><span>bit</span><span>,</span> <span>result</span><span>)</span>
        <span>return</span> <span>result</span>
</code></pre></div>

<p>Using it on a biased source with unknown bias:</p>
<div><pre><span></span><code><span>bit_source</span> <span>=</span> <span>BiasedBitSource</span><span>()</span>
<span>extractor</span> <span>=</span> <span>VonNeumannExtractor</span><span>(</span><span>bit_source</span><span>)</span>

<span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>100</span><span>):</span>
    <span>result</span> <span>=</span> <span>extractor</span><span>.</span><span>next</span><span>()</span>
</code></pre></div>

<p>Prints something like:</p>
<div><pre><span></span><code><span>0</span><span> </span><span>.</span>
<span>1</span><span> </span><span>1</span>
<span>1</span><span> </span><span>.</span>
<span>0</span><span> </span><span>0</span>
<span>0</span><span> </span><span>.</span>
<span>0</span><span> </span><span>.</span>
<span>...</span>
</code></pre></div>

<h2>Varying bias and the parity extractor</h2>
<p>In the above case, we assumed that the input stream is made up of independent, identically distributed bits. What if we give up the second condition, ie. we allow each bit in the input bit stream to have different bias? In this case, the Von Neumann trick will not work, as subsequent bits no longer have identical probabilities, so <code>01</code> and <code>10</code> no longer have equal probability. In this case, it can be shown that taking N bit blocks of the input stream, and returning the parity bit as the output stream reduces the bias, and as N gets larger, makes the output stream closer to an even coin toss.</p>
<p>Let&#39;s define an input stream with varying bias:</p>
<div><pre><span></span><code><span>class</span> <span>VaryingBiasedBitSource</span><span>(</span><span>BitSource</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>min_cutoff</span><span>=</span><span>0</span><span>,</span> <span>max_cutoff</span><span>=</span><span>1</span><span>):</span>
        <span>self</span><span>.</span><span>min_cutoff</span> <span>=</span> <span>min_cutoff</span>
        <span>self</span><span>.</span><span>max_cutoff</span> <span>=</span> <span>max_cutoff</span>
        <span>self</span><span>.</span><span>bias</span> <span>=</span> <span>random</span><span>()</span>

    <span>def</span> <span>next_bias</span><span>(</span><span>self</span><span>,</span> <span>draw</span><span>):</span>
        <span>bias</span> <span>=</span> <span>draw</span><span>**</span><span>2</span>
        <span>if</span> <span>random</span><span>()</span> <span>&lt;</span> <span>0.5</span><span>:</span>
            <span>bias</span> <span>=</span> <span>1</span> <span>-</span> <span>bias</span>
        <span>bias</span> <span>=</span> <span>max</span><span>(</span><span>self</span><span>.</span><span>min_cutoff</span><span>,</span> <span>bias</span><span>)</span>
        <span>bias</span> <span>=</span> <span>min</span><span>(</span><span>self</span><span>.</span><span>max_cutoff</span><span>,</span> <span>bias</span><span>)</span>
        <span>return</span> <span>bias</span>

    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
        <span>draw</span> <span>=</span> <span>random</span><span>()</span>
        <span>if</span> <span>draw</span> <span>&lt;</span> <span>self</span><span>.</span><span>bias</span><span>:</span>
            <span>result</span> <span>=</span> <span>0</span>
        <span>else</span><span>:</span>
            <span>result</span> <span>=</span> <span>1</span>
        <span>self</span><span>.</span><span>bias</span> <span>=</span> <span>self</span><span>.</span><span>next_bias</span><span>(</span><span>draw</span><span>)</span>
        <span>return</span> <span>result</span>
</code></pre></div>

<p>Note that there is no one right way to define the way the bits vary. I chose a specific rule to compute the next bias (with some functional and some random elements). Next, let&#39;s define the <code>ParityExtractor</code>:</p>
<div><pre><span></span><code><span>class</span> <span>ParityExtractor</span><span>(</span><span>RandomnessExtractor</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>bit_source</span><span>:</span> <span>BitSource</span><span>,</span> <span>N</span><span>:</span> <span>int</span><span>):</span>
        <span>self</span><span>.</span><span>bit_source</span> <span>=</span> <span>bit_source</span>
        <span>if</span> <span>N</span> <span>&lt;=</span> <span>0</span><span>:</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;N must be a positive integer.&#34;</span><span>)</span>
        <span>self</span><span>.</span><span>N</span> <span>=</span> <span>N</span>
        <span>self</span><span>.</span><span>bits</span> <span>=</span> <span>[]</span>

    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Optional</span><span>[</span><span>int</span><span>]:</span>
        <span>bit</span> <span>=</span> <span>self</span><span>.</span><span>bit_source</span><span>.</span><span>next</span><span>()</span>
        <span>if</span> <span>bit</span> <span>not</span> <span>in</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>]:</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;Bit must be 0 or 1.&#34;</span><span>)</span>
        <span>self</span><span>.</span><span>bits</span><span>.</span><span>append</span><span>(</span><span>bit</span><span>)</span>
        <span>result</span> <span>=</span> <span>None</span>
        <span>if</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>bits</span><span>)</span> <span>==</span> <span>self</span><span>.</span><span>N</span><span>:</span>
            <span>result</span> <span>=</span> <span>sum</span><span>(</span><span>self</span><span>.</span><span>bits</span><span>)</span> <span>%</span> <span>2</span>
            <span>self</span><span>.</span><span>bits</span> <span>=</span> <span>[]</span>  <span># Reset for the next block of N bits</span>
        <span>print_bits</span><span>(</span><span>bit</span><span>,</span> <span>result</span><span>)</span>
        <span>return</span> <span>result</span>
</code></pre></div>

<p>Let&#39;s try it:</p>
<div><pre><span></span><code><span>bit_source</span> <span>=</span> <span>VaryingBiasedBitSource</span><span>(</span><span>min_cutoff</span><span>=</span><span>0.1</span><span>,</span> <span>max_cutoff</span><span>=</span><span>0.7</span><span>)</span>
<span>extractor</span> <span>=</span> <span>ParityExtractor</span><span>(</span><span>bit_source</span><span>=</span><span>bit_source</span><span>,</span> <span>N</span><span>=</span><span>4</span><span>)</span>

<span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>100</span><span>):</span>
    <span>result</span> <span>=</span> <span>extractor</span><span>.</span><span>next</span><span>()</span>
</code></pre></div>

<p>Prints something like:</p>
<div><pre><span></span><code><span>0</span><span> </span><span>.</span>
<span>1</span><span> </span><span>.</span>
<span>0</span><span> </span><span>.</span>
<span>0</span><span> </span><span>1</span>
<span>0</span><span> </span><span>.</span>
<span>1</span><span> </span><span>.</span>
<span>1</span><span> </span><span>.</span>
<span>0</span><span> </span><span>0</span>
<span>0</span><span> </span><span>.</span>
<span>1</span><span> </span><span>.</span>
<span>1</span><span> </span><span>.</span>
<span>1</span><span> </span><span>1</span>
<span>0</span><span> </span><span>.</span>
<span>...</span>
</code></pre></div>

<h2>Markov chain input stream and the Blum extractor</h2>
<p>Let&#39;s now look at a case when the input bits are emitted by a <a href="https://en.wikipedia.org/wiki/Markov_chain">Markov Chain</a> process, ie. there are $k$ states, each state has transitions to two other states, with one transition having $p$ probability and emitting a 0 bit, the other having $1-p$ probability and emiting a 1 bit. Let&#39;s define <code>MarkovChainBitSource</code> with an example:</p>
<div><pre><span></span><code><span>class</span> <span>MarkovChainBitSource</span><span>(</span><span>BitSource</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>start_state</span><span>:</span> <span>str</span><span>):</span>
        <span>self</span><span>.</span><span>current_state</span> <span>=</span> <span>start_state</span>

    <span>@abstractmethod</span>
    <span>def</span> <span>get_transitions</span><span>(</span><span>self</span><span>,</span> <span>state</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>Dict</span><span>[</span><span>int</span><span>,</span> <span>Tuple</span><span>[</span><span>str</span><span>,</span> <span>float</span><span>]]:</span>
        <span>pass</span>

    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
        <span>transitions</span> <span>=</span> <span>self</span><span>.</span><span>get_transitions</span><span>(</span><span>self</span><span>.</span><span>current_state</span><span>)</span>
        <span>rand</span> <span>=</span> <span>random</span><span>()</span>
        <span>cumulative_probability</span> <span>=</span> <span>0.0</span>
        <span>for</span> <span>bit</span><span>,</span> <span>(</span><span>next_state</span><span>,</span> <span>probability</span><span>)</span> <span>in</span> <span>transitions</span><span>.</span><span>items</span><span>():</span>
            <span>cumulative_probability</span> <span>+=</span> <span>probability</span>
            <span>if</span> <span>rand</span> <span>&lt;</span> <span>cumulative_probability</span><span>:</span>
                <span>self</span><span>.</span><span>current_state</span> <span>=</span> <span>next_state</span>
                <span>return</span> <span>bit</span>
        <span>raise</span> <span>RuntimeError</span><span>(</span><span>&#34;Probabilities do not sum to 1.&#34;</span><span>)</span>


<span>class</span> <span>ExampleMarkovChainBitSource</span><span>(</span><span>MarkovChainBitSource</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>start_state</span><span>=</span><span>&#39;A&#39;</span><span>)</span>
        <span>self</span><span>.</span><span>transitions</span> <span>=</span> <span>{</span>
            <span>&#39;A&#39;</span><span>:</span> <span>{</span><span>0</span><span>:</span> <span>(</span><span>&#39;B&#39;</span><span>,</span> <span>0.5</span><span>),</span> <span>1</span><span>:</span> <span>(</span><span>&#39;C&#39;</span><span>,</span> <span>0.5</span><span>)},</span>
            <span>&#39;B&#39;</span><span>:</span> <span>{</span><span>0</span><span>:</span> <span>(</span><span>&#39;A&#39;</span><span>,</span> <span>0.7</span><span>),</span> <span>1</span><span>:</span> <span>(</span><span>&#39;C&#39;</span><span>,</span> <span>0.3</span><span>)},</span>
            <span>&#39;C&#39;</span><span>:</span> <span>{</span><span>0</span><span>:</span> <span>(</span><span>&#39;A&#39;</span><span>,</span> <span>0.4</span><span>),</span> <span>1</span><span>:</span> <span>(</span><span>&#39;B&#39;</span><span>,</span> <span>0.6</span><span>)},</span>
        <span>}</span>

    <span>def</span> <span>get_transitions</span><span>(</span><span>self</span><span>,</span> <span>state</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>Dict</span><span>[</span><span>int</span><span>,</span> <span>Tuple</span><span>[</span><span>str</span><span>,</span> <span>float</span><span>]]:</span>
        <span>return</span> <span>self</span><span>.</span><span>transitions</span><span>[</span><span>state</span><span>]</span>
</code></pre></div>

<p>Further, let&#39;s assume that our randomness extractor has access to the internal state of the Markov chain. In this case, the problem can be reduced to the Von Neumann case: for each state, we need to remember the last input bit the Markov chain produced when we were in this state the last time, take the current bit produced exiting this state, and apply the Von Neumann rule. Implementing this in Python is surprisingly simple:</p>
<div><pre><span></span><code><span>class</span> <span>BlumExtractor</span><span>(</span><span>RandomnessExtractor</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>bit_source</span><span>:</span> <span>MarkovChainBitSource</span><span>):</span>
        <span>self</span><span>.</span><span>bit_source</span> <span>=</span> <span>bit_source</span>
        <span>self</span><span>.</span><span>state_bits</span> <span>=</span> <span>defaultdict</span><span>(</span><span>list</span><span>)</span>  <span># Stores the last bits for each state</span>

    <span>def</span> <span>next</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Optional</span><span>[</span><span>int</span><span>]:</span>
        <span>current_state</span> <span>=</span> <span>self</span><span>.</span><span>bit_source</span><span>.</span><span>current_state</span>
        <span>bit</span> <span>=</span> <span>self</span><span>.</span><span>bit_source</span><span>.</span><span>next</span><span>()</span>
        <span>self</span><span>.</span><span>state_bits</span><span>[</span><span>current_state</span><span>]</span><span>.</span><span>append</span><span>(</span><span>bit</span><span>)</span>
        <span>result</span> <span>=</span> <span>None</span>
        <span>if</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>state_bits</span><span>[</span><span>current_state</span><span>])</span> <span>==</span> <span>2</span><span>:</span>
            <span>bits</span> <span>=</span> <span>self</span><span>.</span><span>state_bits</span><span>[</span><span>current_state</span><span>]</span>
            <span>if</span> <span>bits</span> <span>==</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>]:</span>
                <span>result</span> <span>=</span> <span>1</span>
            <span>elif</span> <span>bits</span> <span>==</span> <span>[</span><span>1</span><span>,</span> <span>0</span><span>]:</span>
                <span>result</span> <span>=</span> <span>0</span>
            <span>self</span><span>.</span><span>state_bits</span><span>[</span><span>current_state</span><span>]</span> <span>=</span> <span>[]</span>
        <span>print_bits</span><span>(</span><span>bit</span><span>,</span> <span>result</span><span>)</span>
        <span>return</span> <span>result</span>
</code></pre></div>

<p>Let&#39;s try it:</p>
<div><pre><span></span><code><span>bit_source</span> <span>=</span> <span>ExampleMarkovChainBitSource</span><span>()</span>
<span>extractor</span> <span>=</span> <span>BlumExtractor</span><span>(</span><span>bit_source</span><span>)</span>

<span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>100</span><span>):</span>
    <span>result</span> <span>=</span> <span>extractor</span><span>.</span><span>next</span><span>()</span>
</code></pre></div>

<p>Prints something like:</p>
<div><pre><span></span><code><span>0</span><span> </span><span>.</span>
<span>1</span><span> </span><span>.</span>
<span>1</span><span> </span><span>.</span>
<span>0</span><span> </span><span>0</span>
<span>1</span><span> </span><span>1</span>
<span>0</span><span> </span><span>0</span>
<span>0</span><span> </span><span>.</span>
<span>0</span><span> </span><span>.</span>
<span>1</span><span> </span><span>1</span>
<span>...</span>
</code></pre></div>

<!--What if we are not allowed access to the internal state of the Monte Carlo chain? In that case, the best we can do is use the Blum extractor, with some value of the N block size we estimate will give us a close enough approximation of a fair coin:-->

<!--```python-->
<!--bit_source = ExampleMarkovChainBitSource()-->
<!--extractor = ParityExtractor(bit_source=bit_source, N=4)-->
<!--for _ in range(100):-->
<!--    result = extractor.next()-->
<!--```-->

<h2>General case</h2>
<p>Can we produce perfectly uniform bits from a biased input source that has <em>some</em> randomness (so it&#39;s not a deterministic process), but the bits may be correlated, and we don&#39;t know how? The answer is no, if we don&#39;t know anything about the structure of the input stream, there is no general way to create even a single perfectly uniform bit.</p>
<h2>Conclusion</h2>
<p>An interesting test for this code would be to apply statistical tests on the generated output stream to test how random they are. I will do this in a subsequent post.</p>
  </div></div>
  </body>
</html>
