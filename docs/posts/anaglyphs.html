<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://glitch.at.goth.cafe/anaglyphs/">Original</a>
    <h1>Anaglyphs</h1>
    
    <div id="readability-page-1" class="page"><div><p>When I was out grocery shopping a rather handsome guy caught my eye, he had a cute tattoo of oldschool red and cyan 3D glasses. Long before 3D TVs, VR, and 3D movies with high-tech glasses, these glasses were a classic solution to produce a 3D effect: the effect is called the anaglyph effect. I was inspired to try and recreate the effect using Go and WebGL shaders.</p><h3 id="what-is-an-anaglyph">What is an Anaglyph?</h3><p>An anaglyph is a type of stereoscopic 3D image that‚Äôs created by using two differently filtered colored images, usually red and cyan, that are offset from each other at just the right offset. When the image is viewed through corresponding colored glasses, each eye only sees one of the images, and this is what creates the 3D effect.</p><h3 id="a-quick-history-lesson">A Quick History Lesson</h3><p>The concept of stereoscopic vision has been around since the 1830s when Charles Wheatstone introduced the stereoscope. However, the anaglyph technique, as we know it, only started taking shape in the 1850s.</p><p>In the 20th century, with the rise of cinema, anaglyph 3D movies became a unique attraction. The 1950s, in particular, was a decade known for its 3D movie craze, with many movies being shot in 3D and screened using anaglyph glasses. The 3D movie craze died down in the 1960s, but anaglyphs continued to be used in comic books and other media.</p><p>Modern 3D cinema no longer uses anaglyphs, having shifted to polarized or active shutter glasses. This is due to the better color accuracy, depth effect, and clarity they offer. However, anaglyphs hold a nostalgic charm for me. They are an essential part of the history of 3D visualization.</p><h3 id="3d-perception">3D Perception</h3><p>Eyes are spaced apart, so they naturally see the world from slightly different perspectives. This difference in viewpoint helps the brain perceive depth. Anaglyphs exploit this principle by presenting two slightly different images to each eye.</p><p>The most common type of anaglyph glasses has one red lens and one cyan lens. The red lens filters out the red component of the image, so only the cyan image is seen with that eye. Conversely, the cyan lens filters out the blue and green components (which combine to produce cyan), so only the red image is seen with the other eye.</p><p>When each eye sees only one of the images, and those images are slightly offset from one another (representing the slightly different viewpoints of our two eyes), the brain fuses them to create a single image with depth! Its pretty darn cool.</p><h3 id="the-glasses-and-tuning">The Glasses And Tuning</h3><p>I have a couple of 3D glasses lying around, so I decided to use them to create the anaglyph experiment.</p><figure><img src="https://jvns.ca/images/blog-articles/anaglyph/3d-glasses.png"/></figure><p>Before proceeding, I had to figure out what colors and offset to use for the anaglyph effects on images ‚Äì as you can see, the glasses are different. To get the best effect, I had to experiment with different colors and offsets to get the best effect.</p><p>When a color is viewed through a lens of the same color, it generally appears as a lighter shade of that color, sometimes even appearing white or nearly white. This is because the lens filters out all the colors in the spectrum except for the color of the lens itself. As a result, only light of that specific color wavelength passes through, making the object appear in that color or a lighter shade of it. In some cases, it might appear as if the object has ‚Äúblended‚Äù into the background if the background is also of the same color, thereby making it harder to distinguish the object.</p><p>For example, if you‚Äôre looking at a red object through a red lens, the lens allows only the red component of the light to pass through. Therefore, the red object would appear very light red or nearly white, especially if the background is also red.</p><p>We can use this effect to find the ideal colors for the right and left offsets to match the tint of the glasses. By creating two filled circles, one red and one cyan, we can adjust the tones of each until they appear as the brightest shade of red and cyan, respectively. This will ensure that the red and cyan components of the image are filtered out by the glasses, creating the anaglyph effect.</p><p>I wrote the following HTML page as a tool to help me with this process:</p><p>It allows you to experiment with different colors and offsets to find the best combination for your glasses.</p><h3 id="an-important-note-on-base-image-colors">An Important Note On Base Image Colors</h3><p>The color combination used for the anaglyph effect depends on the colors in the base image too! The goal is to use colors that are <strong>not</strong> highly present in the base image so that they can be filtered out by the glasses. For example, if the base image contains a lot of red, then red-cyan glasses would <strong>not</strong> be a good choice because the red component of the image would be filtered out! So you need to be creative when creating the base image too! I decided to go with black and white images for this experiment, which is what would have been the most prevalent in the 1950s.</p><h2 id="make-anaglyphs-in-go">Make Anaglyphs In Go</h2><p>In the Go code provided below, an anaglyph image is generated by manipulating and combining two slightly offset versions of the original image to simulate the perspectives of the left and right eyes. The steps are as follows:</p><ol><li><p>Reading the Image: The code begins by loading an image file into memory using Go‚Äôs standard image libraries.</p></li><li><p>Creating the Anaglyph Image Canvas: A new empty image with the same dimensions as the original is created to serve as the canvas for the anaglyph effect.</p></li><li><p>Manipulating Pixels: For every pixel in the original image, the code computes the corresponding positions in the left and right eye perspectives by shifting the pixel‚Äôs x-coordinate by a specified offset. The color values for these shifted positions are then retrieved.</p></li><li><p>Blending Channels: To generate the anaglyph effect, the red channel from the left-eye perspective (left offset) is combined with the green and blue channels from the right-eye perspective (right offset). This emulates the traditional red-cyan anaglyph method.</p></li><li><p>Outputting the Result: Once all pixels have been processed, the resulting anaglyph image is saved to disk.</p></li></ol><p>Understanding the Go implementation offers valuable intuition when transitioning to the more abstract realm of shaders. The detailed, step-by-step nature of the Go code makes it a helpful tool for visualizing and understanding the underlying mechanics of the anaglyph effect, setting the foundation for the more streamlined shader-based approach in the next step!</p><div><pre tabindex="0"><code data-lang="bash"><span><span>go run anaglyph.go -input<span>=</span>test_image_4.png -output<span>=</span>output.png -leftColor<span>=</span>ff0a0a -rightColor<span>=</span>00ffff -offset<span>=</span><span>8</span> 
</span></span></code></pre></div><p>This produces the following effect! If you have 3D glasses, you can try viewing the image with them to see it. If you hover your mouse over the 3D image, it will be even more pronounced and it looks like a portal into another world üòµ‚Äçüí´.</p><h4 id="no-3d">No 3D</h4><figure><img src="https://jvns.ca/images/blog-articles/anaglyph/test_image_4.png"/></figure><h4 id="yes-3d">Yes 3D</h4><figure><img src="https://jvns.ca/images/blog-articles/anaglyph/output.png"/></figure><h2 id="next-lets-make-anaglyphs-in-webgl-shaders">Next Lets Make Anaglyphs In WebGL Shaders</h2><p>Creating an anaglyph effect using a fragment shader in Three.js typically involves post-processing, the rendered scene is passed through a simple custom fragment shader to apply the anaglyph effect after the scene has been rendered in the first render pass. This is done using the EffectComposer and ShaderPass classes from the Three.js post-processing module.</p><p>If you understand the golang implementation that we worked through, then the shader implementation should be fairly straightforward. I have heavily commented it, and I hope that helps, since shader code is a bit tricky to read.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// Declare uniform variables that will be accessible from JavaScript.
</span></span></span><span><span><span>// sampler2D is a texture that we&#39;ll pass from the Three.js renderer.
</span></span></span><span><span><span>// Separation, red, and cyan are floats that control the anaglyph effect.
</span></span></span><span><span><span></span>uniform sampler2D tDiffuse;
</span></span><span><span>uniform <span>float</span> separation;
</span></span><span><span>uniform <span>float</span> red;
</span></span><span><span>uniform <span>float</span> cyan;
</span></span><span><span>
</span></span><span><span><span>// Declare varying variables that will receive interpolated values
</span></span></span><span><span><span>// from the vertex shader. In this case, we&#39;ll get texture coordinates.
</span></span></span><span><span><span></span>varying vec2 vUv;
</span></span><span><span>
</span></span><span><span><span>// main() function is the entry point of the fragment shader.
</span></span></span><span><span><span></span><span>void</span> <span>main</span>() {
</span></span><span><span>  <span>// Sample the original color from the texture at the current
</span></span></span><span><span><span></span>  <span>// texture coordinate (vUv).
</span></span></span><span><span><span></span>  vec4 color <span>=</span> <span>texture2D</span>(tDiffuse, vUv);
</span></span><span><span>
</span></span><span><span>  <span>// Sample the color for the left eye.
</span></span></span><span><span><span></span>  <span>// The texture coordinate is shifted horizontally by negative &#34;separation&#34; units.
</span></span></span><span><span><span></span>  vec4 colorL <span>=</span> <span>texture2D</span>(tDiffuse, vUv <span>+</span> <span>vec2</span>(<span>-</span>(separation <span>*</span> <span>-</span><span>1.0</span>), <span>0.0</span>));
</span></span><span><span>
</span></span><span><span>  <span>// Sample the color for the right eye.
</span></span></span><span><span><span></span>  <span>// The texture coordinate is shifted horizontally by positive &#34;separation&#34; units.
</span></span></span><span><span><span></span>  vec4 colorR <span>=</span> <span>texture2D</span>(tDiffuse, vUv <span>+</span> <span>vec2</span>(separation <span>*</span> <span>-</span><span>1.0</span>, <span>0.0</span>));
</span></span><span><span>
</span></span><span><span>  <span>// Combine the colors into an anaglyph effect.
</span></span></span><span><span><span></span>  <span>// The red component comes from the left-eye view.
</span></span></span><span><span><span></span>  <span>// The green and blue components come from the right-eye view.
</span></span></span><span><span><span></span>  <span>// We also apply the user-specified tint values for red and cyan.
</span></span></span><span><span><span></span>  gl_FragColor <span>=</span> <span>vec4</span>(colorL.r <span>*</span> red, colorR.g <span>*</span> cyan, colorR.b <span>*</span> cyan, <span>1.0</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>Now that we have the shader code, we need to set up the Three.js scene and renderer to use it. The following code snippet shows how to do this:</p><div><pre tabindex="0"><code data-lang="JavaScript"><span><span><span>// Import required Three.js modules
</span></span></span><span><span><span></span><span>import</span> <span>*</span> <span>as</span> <span>THREE</span> <span>from</span> <span>&#34;three&#34;</span>;
</span></span><span><span><span>import</span> { <span>EffectComposer</span> } <span>from</span> <span>&#34;three/examples/jsm/postprocessing/EffectComposer.js&#34;</span>;
</span></span><span><span><span>import</span> { <span>RenderPass</span> } <span>from</span> <span>&#34;three/examples/jsm/postprocessing/RenderPass.js&#34;</span>;
</span></span><span><span><span>import</span> { <span>ShaderPass</span> } <span>from</span> <span>&#34;three/examples/jsm/postprocessing/ShaderPass.js&#34;</span>;
</span></span><span><span><span>import</span> <span>*</span> <span>as</span> <span>dat</span> <span>from</span> <span>&#34;dat.gui&#34;</span>;
</span></span><span><span>
</span></span><span><span><span>// Declare global variables for scene elements and effects
</span></span></span><span><span><span></span><span>var</span> <span>camera</span>, <span>scene</span>, <span>renderer</span>, <span>composer</span>;
</span></span><span><span><span>var</span> <span>mesh</span>;
</span></span><span><span><span>var</span> <span>customPass</span>;
</span></span><span><span>
</span></span><span><span><span>// GUI parameters for shader
</span></span></span><span><span><span></span><span>var</span> <span>params</span> <span>=</span> {
</span></span><span><span>  <span>separation</span><span>:</span> <span>0.004</span>,
</span></span><span><span>  <span>red</span><span>:</span> <span>1.0</span>,
</span></span><span><span>  <span>cyan</span><span>:</span> <span>1.0</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>// Declare a group object to hold multiple cubes
</span></span></span><span><span><span></span><span>var</span> <span>cubeGroup</span>;
</span></span><span><span>
</span></span><span><span><span>// Initialize Three.js scene
</span></span></span><span><span><span></span><span>function</span> <span>init</span>() {
</span></span><span><span>  <span>// Create a WebGL renderer
</span></span></span><span><span><span></span>  <span>renderer</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>WebGLRenderer</span>();
</span></span><span><span>  <span>renderer</span>.<span>setSize</span>(window.<span>innerWidth</span>, window.<span>innerHeight</span>);
</span></span><span><span>  document.<span>body</span>.<span>appendChild</span>(<span>renderer</span>.<span>domElement</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Create a perspective camera
</span></span></span><span><span><span></span>  <span>camera</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>PerspectiveCamera</span>(
</span></span><span><span>    <span>70</span>,
</span></span><span><span>    window.<span>innerWidth</span> <span>/</span> window.<span>innerHeight</span>,
</span></span><span><span>    <span>1</span>,
</span></span><span><span>    <span>1000</span>
</span></span><span><span>  );
</span></span><span><span>  <span>camera</span>.<span>position</span>.<span>z</span> <span>=</span> <span>600</span>;
</span></span><span><span>
</span></span><span><span>  <span>// Create a scene
</span></span></span><span><span><span></span>  <span>scene</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>Scene</span>();
</span></span><span><span>
</span></span><span><span>  <span>// Add ambient light for consistent baseline lighting
</span></span></span><span><span><span></span>  <span>var</span> <span>ambientLight</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>AmbientLight</span>(<span>0x404040</span>, <span>40.0</span>);
</span></span><span><span>  <span>scene</span>.<span>add</span>(<span>ambientLight</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Add point lights for dynamic shading
</span></span></span><span><span><span></span>  <span>const</span> <span>numberOfLights</span> <span>=</span> <span>4</span>;
</span></span><span><span>  <span>for</span> (<span>let</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>numberOfLights</span>; <span>i</span><span>++</span>) {
</span></span><span><span>    <span>let</span> <span>pointLight</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>PointLight</span>(<span>0xffffff</span>, <span>10000.0</span>, <span>0</span>);
</span></span><span><span>    <span>pointLight</span>.<span>position</span>.<span>set</span>(
</span></span><span><span>      Math.<span>random</span>() <span>*</span> <span>300</span> <span>-</span> <span>150</span>,
</span></span><span><span>      Math.<span>random</span>() <span>*</span> <span>300</span> <span>-</span> <span>150</span>,
</span></span><span><span>      Math.<span>random</span>() <span>*</span> <span>300</span> <span>-</span> <span>150</span>
</span></span><span><span>    );
</span></span><span><span>    <span>scene</span>.<span>add</span>(<span>pointLight</span>);
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  <span>// Initialize cube group as a THREE.Group object
</span></span></span><span><span><span></span>  <span>cubeGroup</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>Group</span>();
</span></span><span><span>
</span></span><span><span>  <span>// Loop to create a 3x3x3 cube of smaller cubes
</span></span></span><span><span><span></span>  <span>for</span> (<span>let</span> <span>x</span> <span>=</span> <span>-</span><span>1</span>; <span>x</span> <span>&lt;=</span> <span>1</span>; <span>x</span><span>++</span>) {
</span></span><span><span>    <span>for</span> (<span>let</span> <span>y</span> <span>=</span> <span>-</span><span>1</span>; <span>y</span> <span>&lt;=</span> <span>1</span>; <span>y</span><span>++</span>) {
</span></span><span><span>      <span>for</span> (<span>let</span> <span>z</span> <span>=</span> <span>-</span><span>1</span>; <span>z</span> <span>&lt;=</span> <span>1</span>; <span>z</span><span>++</span>) {
</span></span><span><span>        <span>// Create geometry and material for each cube
</span></span></span><span><span><span></span>        <span>var</span> <span>geometry</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>BoxGeometry</span>(<span>50</span>, <span>50</span>, <span>50</span>);
</span></span><span><span>        <span>var</span> <span>material</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>MeshPhongMaterial</span>({
</span></span><span><span>          <span>color</span><span>:</span> <span>0xffffff</span>,
</span></span><span><span>          <span>flatShading</span><span>:</span> <span>true</span>,
</span></span><span><span>          <span>shininess</span><span>:</span> <span>0</span>,
</span></span><span><span>        });
</span></span><span><span>
</span></span><span><span>        <span>// Create the cube mesh and position it
</span></span></span><span><span><span></span>        <span>var</span> <span>smallCube</span> <span>=</span> <span>new</span> <span>THREE</span>.<span>Mesh</span>(<span>geometry</span>, <span>material</span>);
</span></span><span><span>        <span>smallCube</span>.<span>position</span>.<span>set</span>(<span>x</span> <span>*</span> <span>100</span>, <span>y</span> <span>*</span> <span>100</span>, <span>z</span> <span>*</span> <span>100</span>); <span>// 100 units apart
</span></span></span><span><span><span></span>
</span></span><span><span>        <span>// Add each small cube to the cube group
</span></span></span><span><span><span></span>        <span>cubeGroup</span>.<span>add</span>(<span>smallCube</span>);
</span></span><span><span>      }
</span></span><span><span>    }
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  <span>// Add the cube group to the scene
</span></span></span><span><span><span></span>  <span>scene</span>.<span>add</span>(<span>cubeGroup</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Initialize post-processing composer
</span></span></span><span><span><span></span>  <span>composer</span> <span>=</span> <span>new</span> <span>EffectComposer</span>(<span>renderer</span>);
</span></span><span><span>  <span>composer</span>.<span>addPass</span>(<span>new</span> <span>RenderPass</span>(<span>scene</span>, <span>camera</span>));
</span></span><span><span>
</span></span><span><span>  <span>// Define custom shader for anaglyph effect
</span></span></span><span><span><span></span>  <span>var</span> <span>customShader</span> <span>=</span> {
</span></span><span><span>    <span>uniforms</span><span>:</span> {
</span></span><span><span>      <span>tDiffuse</span><span>:</span> { <span>value</span><span>:</span> <span>null</span> },
</span></span><span><span>      <span>separation</span><span>:</span> { <span>value</span><span>:</span> <span>params</span>.<span>separation</span> },
</span></span><span><span>      <span>red</span><span>:</span> { <span>value</span><span>:</span> <span>params</span>.<span>red</span> },
</span></span><span><span>      <span>cyan</span><span>:</span> { <span>value</span><span>:</span> <span>params</span>.<span>cyan</span> },
</span></span><span><span>    },
</span></span><span><span>    <span>vertexShader</span><span>:</span> <span>`
</span></span></span><span><span><span>      // Declare a varying variable vUv. Varying variables are used to pass
</span></span></span><span><span><span>      // data from the vertex shader to the fragment shader.
</span></span></span><span><span><span>      // &#39;vec2&#39; means it&#39;s a 2D vector, which is perfect for 2D texture coordinates.
</span></span></span><span><span><span>      varying vec2 vUv;
</span></span></span><span><span><span>
</span></span></span><span><span><span>      // main() function is the entry point of the vertex shader.
</span></span></span><span><span><span>      void main() {
</span></span></span><span><span><span>
</span></span></span><span><span><span>        // Assign the built-in &#39;uv&#39; attribute to our varying variable &#39;vUv&#39;.
</span></span></span><span><span><span>        // &#39;uv&#39; holds the 2D texture coordinates provided by the geometry.
</span></span></span><span><span><span>        // These coordinates will be interpolated for each fragment and
</span></span></span><span><span><span>        // accessible in the fragment shader.
</span></span></span><span><span><span>        vUv = uv;
</span></span></span><span><span><span>
</span></span></span><span><span><span>        // Calculate the clip-space position of the current vertex.
</span></span></span><span><span><span>        // &#39;projectionMatrix&#39; is the camera&#39;s projection matrix,
</span></span></span><span><span><span>        // &#39;modelViewMatrix&#39; is the model-view matrix containing the
</span></span></span><span><span><span>        // model&#39;s position, rotation and scale combined with the camera&#39;s position and orientation.
</span></span></span><span><span><span>        // &#39;position&#39; is the local position of the vertex.
</span></span></span><span><span><span>        // Multiply these together to get the clip-space position.
</span></span></span><span><span><span>        // We also set the w component to 1.0, as it&#39;s a homogeneous coordinate.
</span></span></span><span><span><span>        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
</span></span></span><span><span><span>      }
</span></span></span><span><span><span>    `</span>,
</span></span><span><span>    <span>fragmentShader</span><span>:</span> <span>`
</span></span></span><span><span><span>      // Declare uniform variables that will be accessible from JavaScript.
</span></span></span><span><span><span>      // sampler2D is a texture that we&#39;ll pass from the Three.js renderer.
</span></span></span><span><span><span>      // Separation, red, and cyan are floats that control the anaglyph effect.
</span></span></span><span><span><span>      uniform sampler2D tDiffuse;
</span></span></span><span><span><span>      uniform float separation;
</span></span></span><span><span><span>      uniform float red;
</span></span></span><span><span><span>      uniform float cyan;
</span></span></span><span><span><span>
</span></span></span><span><span><span>      // Declare varying variables that will receive interpolated values
</span></span></span><span><span><span>      // from the vertex shader. In this case, we&#39;ll get texture coordinates.
</span></span></span><span><span><span>      varying vec2 vUv;
</span></span></span><span><span><span>
</span></span></span><span><span><span>      // main() function is the entry point of the fragment shader.
</span></span></span><span><span><span>      void main() {
</span></span></span><span><span><span>        // Sample the original color from the texture at the current
</span></span></span><span><span><span>        // texture coordinate (vUv).
</span></span></span><span><span><span>        vec4 color = texture2D(tDiffuse, vUv);
</span></span></span><span><span><span>
</span></span></span><span><span><span>        // Sample the color for the left eye.
</span></span></span><span><span><span>        // The texture coordinate is shifted horizontally by negative &#34;separation&#34; units.
</span></span></span><span><span><span>        vec4 colorL = texture2D(tDiffuse, vUv + vec2(-(separation * -1.0), 0.0));
</span></span></span><span><span><span>
</span></span></span><span><span><span>        // Sample the color for the right eye.
</span></span></span><span><span><span>        // The texture coordinate is shifted horizontally by positive &#34;separation&#34; units.
</span></span></span><span><span><span>        vec4 colorR = texture2D(tDiffuse, vUv + vec2(separation * -1.0, 0.0));
</span></span></span><span><span><span>
</span></span></span><span><span><span>        // Combine the colors into an anaglyph effect.
</span></span></span><span><span><span>        // The red component comes from the left-eye view.
</span></span></span><span><span><span>        // The green and blue components come from the right-eye view.
</span></span></span><span><span><span>        // We also apply the user-specified tint values for red and cyan.
</span></span></span><span><span><span>        gl_FragColor = vec4(colorL.r * red, colorR.g * cyan, colorR.b * cyan, 1.0);
</span></span></span><span><span><span>      }
</span></span></span><span><span><span>    `</span>,
</span></span><span><span>  };
</span></span><span><span>
</span></span><span><span>  <span>// Add custom shader pass to composer
</span></span></span><span><span><span></span>  <span>customPass</span> <span>=</span> <span>new</span> <span>ShaderPass</span>(<span>customShader</span>);
</span></span><span><span>  <span>composer</span>.<span>addPass</span>(<span>customPass</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Initialize GUI for user controls
</span></span></span><span><span><span></span>  <span>const</span> <span>gui</span> <span>=</span> <span>new</span> <span>dat</span>.<span>GUI</span>();
</span></span><span><span>  <span>gui</span>.<span>add</span>(<span>params</span>, <span>&#34;separation&#34;</span>, <span>0.0</span>, <span>0.2</span>).<span>onChange</span>((<span>value</span>) =&gt; {
</span></span><span><span>    <span>customPass</span>.<span>uniforms</span>[<span>&#34;separation&#34;</span>].<span>value</span> <span>=</span> <span>value</span>;
</span></span><span><span>  });
</span></span><span><span>  <span>gui</span>.<span>add</span>(<span>params</span>, <span>&#34;red&#34;</span>, <span>0.0</span>, <span>1.0</span>).<span>onChange</span>((<span>value</span>) =&gt; {
</span></span><span><span>    <span>customPass</span>.<span>uniforms</span>[<span>&#34;red&#34;</span>].<span>value</span> <span>=</span> <span>value</span>;
</span></span><span><span>  });
</span></span><span><span>  <span>gui</span>.<span>add</span>(<span>params</span>, <span>&#34;cyan&#34;</span>, <span>0.0</span>, <span>1.0</span>).<span>onChange</span>((<span>value</span>) =&gt; {
</span></span><span><span>    <span>customPass</span>.<span>uniforms</span>[<span>&#34;cyan&#34;</span>].<span>value</span> <span>=</span> <span>value</span>;
</span></span><span><span>  });
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Main animation loop
</span></span></span><span><span><span></span><span>function</span> <span>animate</span>() {
</span></span><span><span>  <span>requestAnimationFrame</span>(<span>animate</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Rotate the whole cube group
</span></span></span><span><span><span></span>  <span>cubeGroup</span>.<span>rotation</span>.<span>x</span> <span>+=</span> <span>0.005</span>;
</span></span><span><span>  <span>cubeGroup</span>.<span>rotation</span>.<span>y</span> <span>+=</span> <span>0.005</span>;
</span></span><span><span>
</span></span><span><span>  <span>// Rotate each individual cube within the group
</span></span></span><span><span><span></span>  <span>cubeGroup</span>.<span>children</span>.<span>forEach</span>((<span>cube</span>) =&gt; {
</span></span><span><span>    <span>cube</span>.<span>rotation</span>.<span>x</span> <span>+=</span> <span>0.01</span>;
</span></span><span><span>    <span>cube</span>.<span>rotation</span>.<span>y</span> <span>+=</span> <span>0.01</span>;
</span></span><span><span>  });
</span></span><span><span>
</span></span><span><span>  <span>composer</span>.<span>render</span>();
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Execute the initialization function
</span></span></span><span><span><span></span><span>init</span>();
</span></span><span><span><span>// Start the animation loop
</span></span></span><span><span><span></span><span>animate</span>();
</span></span></code></pre></div><p>and the result is:</p><figure><img src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExYzYzbHBiZ2luYmlhbzAwcXdjdzZxMXVjYm1hZHZlcjAyMHR4Y2F6cyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/TsGalP84lw04L4Da2d/giphy.gif"/></figure><h3 id="wrapping-up">Wrapping Up</h3><p>I hope you made it this far, and had fun with me! I have added all of the code for the JavaScript into a running example that you can experiment with here:</p><p>Sending good vibes &lt;3</p></div></div>
  </body>
</html>
