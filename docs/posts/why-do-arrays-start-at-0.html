<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/why-do-arrays-start-at-0/">Original</a>
    <h1>Why do arrays start at 0?</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    
                        <p>I was at my wits end for this newsletter after my first two ideas hit research barriers. Then someone linked me this <a href="https://exple.tive.org/blarg/2013/10/22/citation-needed/" target="_blank">story about why arrays start at 0</a> and <em>bam</em> I had my topic. Specifically, arguing that said link is wrong and does not, in fact, fully explain why arrays start at 0.</p>
<p>You should read it for full context, but the gist of Hoye’s argument is this:</p>
<ol>
<li>Back in the old days, all languages were either 1-indexed or “arbitrarily-indexed”, meaning you could pick an “index range” like <code>0:10</code> or <code>-1:25</code>.</li>
<li>Dr. Martin Richards was tasked to write a language for the IBM 7094. That computer had a special job deck to calculate yacht handicaps for the president of IBM, which took priority over all other jobs. </li>
<li>To keep people from having their jobs cut short by yacht-racing, Richards designed the language to compile as fast as possible. One optimization was setting arrays to start at 0.</li>
<li>The language, BCPL, went on to inspire B, which went on to inspire C. C was so popular it made everybody switch from 1-indexing to 0-indexing.</li>
</ol>
<p>I have a lot of problems with this article, like the author quoting Richards and then immediately turning around and claiming he said the opposite, as well as mocking anybody who thinks that 0-indexing could possibly be <em>good</em>:</p>
<blockquote>
<p>So if your answer started with “because in C…”, you’ve been repeating a good story you heard one time, without ever asking yourself if it’s true. […] And that’s the most coherent argument I can find; there are dozens of other arguments for zero-indexing involving “natural numbers” or “elegance” or some other unresearched hippie voodoo nonsense that are either wrong or too dumb to rise to the level of wrong.</p>
</blockquote>
<p>I may <em>think</em> that counting 0 as a natural number makes a lot of math more elegant, but clearly I’m just too dumb to rise to the level of wrong.</p>
<p>Regardless, Hoye’s core point is it doesn’t matter what the practical benefits are, the historical context is that barely anybody used 0-indexing before BCPL came along and ruined everything. He gives two example languages:</p>
<blockquote>
<p>Algol 60 uses one-indexed arrays, and arrays in Fortran are arbitrarily indexed – they’re just a range from X to Y, and X and Y don’t even need to be positive integers.</p>
</blockquote>
<p>He got these backwards. <a href="https://web.eecs.umich.edu/~bchandra/courses/papers/Naure_Algol60.pdf" target="_blank">Algol 60</a> had index ranges while <a href="http://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf" target="_blank">early FORTRAN</a> was 1-indexed and later <em>moved to</em> index ranges. Both assumed you’d pick the range you’d use for your particular problem.</p>
<p>This roughly matches how it works in the sciences. I skimmed a few math and physics books I have and they regularly switch between 1-indexing and 0-indexing depending on the problem. Analysis, polynomials, and sums seem to always be 0-indexed, while matrix operations and enumerating membership is always done 1-indexed. Since a lot of early computer development was done to support the hard sciences, I’m not surprised they tried to be flexible.</p>
<h3>What about other early languages?</h3>
<p>Hoye claims that both 1-indexing and index ranges were arbitrarily widespread, while 0-indexing was nonexistent:</p>
<blockquote>
<p>The fact of it is this: before pointers, structs, C and Unix existed, at a time when other languages with a lot of resources and (by the standard of the day) user populations behind them were one- or arbitrarily-indexed, somebody decided that the right thing was for arrays to start at zero.</p>
</blockquote>
<p>I went through a lot of different pre-C languages, and here’s what I found:</p>
<ul>
<li><em>O-indexed</em>: <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf" target="_blank">LISP 1.5</a>, <a href="https://web.archive.org/web/20141027172442/http://www.softwarepreservation.org/projects/apl/Books/APROGRAMMING%20LANGUAGE" target="_blank">APL</a></li>
<li><em>1-indexed</em>: <a href="https://web.archive.org/web/20141027172442/http://www.softwarepreservation.org/projects/apl/Books/APROGRAMMING%20LANGUAGE" target="_blank">APL</a>, BASIC, early FORTRAN</li>
<li><em>Index ranges</em>: ALGOL-60, later FORTRAN, <a href="http://www.ancientgeek.org.uk/CPL/CPL_Elementary_Programming_Manual.pdf" target="_blank">CPL</a>, <a href="https://web.archive.org/web/20040923044556/http://www.macs.hw.ac.uk/~rjp/bookhtml/chap10.html" target="_blank">SIMULA</a>, <a href="http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-225.pdf" target="_blank">CLU</a>, <a href="http://www.bitsavers.org/pdf/ibm/360/pli/C28-6571-1_PL_I_Language_Specifications_Jul65.pdf" target="_blank">PL/1</a>, <a href="https://www.livingcomputers.org/UI/UserDocs/Tops-10-v7-04/6_COBOL-68_Language_Manual.pdf" target="_blank">COBOL</a> (I <em>think</em>?), Pascal, ALGOL-68, <a href="https://apps.dtic.mil/sti/pdfs/ADA101061.pdf" target="_blank">JOVIAL</a></li>
</ul>
<p>(APL is a special case: it did <em>not</em> have index ranges, rather you could pick just the starting index, which <em>must</em> be 0 or 1.)</p>
<p>So fixed 1-indexing was <em>not</em> common. Rather, all the languages with user populations had <em>index ranges</em>. Now this isn’t exactly a stunning defense of 0-indexing, because almost all of the index ranged languages had syntactic sugar for 1-indexing. Like in ALGOL <code>array V[0:3]</code> started at 0, but <code>array V[3]</code> started at one. Nevertheless, it shows that you can’t simply say “0-indexing was never used until BCPL”. And in fact if you check contemporaneous papers, <a href="https://academic.oup.com/comjnl/article-pdf/10/4/321/1258064/10-4-321.pdf" target="_blank">at least some of them explicitly choose ranging from 0</a>.</p>
<h3>The 0’s take over</h3>
<p>Now for the interesting question: why did we move from index ranges to 0-indexing? Despite my overal dislike of the article, I can’t deny that BCPL likely had a massive influence on this. Most modern languages have at least <em>some</em> C influence in them. But I don’t think that’s the whole story. Unrelated to BCPL, there are signs that people were seriously considering 0-indexing.</p>
<p>First of all, in 1982, Dijkstra <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" target="_blank">disavowed both index ranges and 1-indexing</a>. Dijkstra isn’t someone who’s going to be influenced by the trends of C. He even said that ALGOL 60 (his baby) and Pascal got it wrong!</p>
<p>Second, APL can have 0- or 1-indexing, Iverson exclusively uses 0-indexing in his book<sup id="fnref:book"><a href="#fn:book">1</a></sup> to discuss microcomputers:</p>
<p><img alt="&#34;The two systems of greatest interest are the common 1-origin system, which will be employed almost exclusively in this chapter, and the 0-originsystem. The latter system is particularly convenient whenever the index itself must be represented in a positional number system and will therefore be employed exclusively in the treatment of computer organization in Chapter 2.&#34;" src="https://buttondown.s3.amazonaws.com/images/08037e25-cccd-475b-bc04-ba53ad7c85ea.png"/> </p>
<p>Third, wire formats like EBDIC and ASCII “started from 0”, since they considered the 0-byte a valid unit.</p>
<p>These all point to one reason why 0-indexing might be preferred: it matches machine semantics more. Hoye casually dismisses this argument by saying</p>
<blockquote>
<p>The usual arguments involving pointer arithmetic and incrementing by sizeof(struct) and so forth describe features that are nice enough once you’ve got the hang of them, but they’re also post-facto justifications. This is obvious if you take the most cursory look at the history of programming languages; C inherited its array semantics from B, which inherited them in turn from BCPL, and though BCPL arrays are zero-origin, the language doesn’t support pointer arithmetic, much less data structures. </p>
</blockquote>
<p>However, right after that he quotes the inventor of BCPL:</p>
<blockquote>
<p>BCPL was essentially designed as typeless language close to machine code. Just as in machine code registers are typically all the same size and contain values that represent almost anything, such as integers, machine addresses, truth values, characters, etc. BCPL has typeless variables just like machine registers capable of representing anything. If a BCPL variable represents a pointer, it points to one or more consecutive words of memory. These words are the same size as BCPL variables. Just as machine code allows address arithmetic so does BCPL, so if p is a pointer p+1 is a pointer to the next word after the one p points to. Naturally p+0 has the same value as p. </p>
</blockquote>
<p>This <em>directly contradicts what Richards is saying</em>, so Hoye just handwaves it away as <em>really</em> being about compilation efficiency, not about mechanical sympathy.</p>
<h3>Unfounded speculation</h3>
<p>Originally languages used index ranges because that let people pick the appropriate abstraction for their problem. They defaulted to 1 because that’s what humans are used to. Over time, languages moved away from index ranges <em>maybe</em> because it was too complicated to implement, <em>and/or</em> made collaboration harder (you don’t know your imported library’s style), <em>and/or</em> made resizing arrays harder. Some languages like BASIC went for 1-indexing because of familiarity. Other languages, like BCPL, went for 0-indexing because that’s closer to the machine level, as we see with APL and wire formats.</p>
<p>(And also it represents the natural numbers better, if you’re willing to accept some hippie voodoo nonsense.)</p>
<p><em>If</em> this theory is correct, we’d have seen 0-indexing gradually overtake 1-indexing even without BCPL, but BCPL dramatically accelerated the timeline. And IMO that’s the right choice, if you have to pick one, I’d much rather have 0-indexing than 1-indexing.<sup id="fnref:sequences"><a href="#fn:sequences">2</a></sup></p>
<p>I want to reiterate that this is <em>speculation</em>. I don’t know if it’s possible to find a definite answer, but if it is it would take a lot more research time then I’m willing to put into this newsletter.</p>
<h3>Lessons</h3>
<ul>
<li>Things can have more than one cause. Don’t trust easy explanations.</li>
<li>Always look for information that refutes your theory, not just information that supports it. Hoye stopped as soon as he had a satisfying answer and didn’t keep researching.</li>
<li>Don’t be a dick.</li>
<li>It is tragically easy to trick me into doing free research.</li>
</ul>
<hr/>
<h3>Update for the Internets</h3>
<p>This was sent as part of an email newsletter; you can subscribe <a href="https://buttondown.email/hillelwayne/" target="_blank">here</a>. Common topics are <a href="https://buttondown.email/hillelwayne/archive/why-uml-really-died/" target="_blank">software history</a>, <a href="https://buttondown.email/hillelwayne/archive/10-misconceptions-about-formal-methods/" target="_blank">formal methods</a>, the <a href="https://buttondown.email/hillelwayne/archive/reject-simplicity-embrace-complexity/" target="_blank">theory of software engineering</a>, and <a href="https://buttondown.email/hillelwayne/archive/whats-the-most-expensive-software-per-byte/" target="_blank">silly research dives</a>. Updates are usually 1x a week. I also have a <a href="https://www.hillelwayne.com/" target="_blank">website</a> where I put my polished writing (the newsletter is more for off-the-cuff stuff).</p>

                    
                
            </div></div>
  </body>
</html>
