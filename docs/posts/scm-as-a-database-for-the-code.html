<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/gritzko/6e81b5391eacb585ae207f5e634db07e">Original</a>
    <h1>SCM as a database for the code</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div id="file-scmandllm-md">
      
      <div id="file-scmandllm-md-readme" tabindex="0" role="region" aria-label="SCMandLLM.md content, created by gritzko on 08:44AM today.">
    <article itemprop="text">
<p dir="auto">Software development is changing rapidly and the tool stack has yet to catch
up. As we see, the value of IDEs diminishes as developers are less inclined to
edit the code now. More and more of the work is browsing and talking to LLMs,
less and less is coding and debugging. About 8 years ago I gave a talk at the
internal JetBrains conference &#34;Code is hypertext, IDE is a browser&#34;. Those
points look even more relevant now: effective browsing of code and history is
a prerequisite to effective understanding. Understanding underlies everything
now. No understanding = no control, then a developer is like a rider who fell
off a LLM horse with his foot caught in the stirrup (you may search YouTube to
understand what I mean).</p>
<p dir="auto"><code>git</code> is increasingly becoming a point of friction. LLMs have high throughput
in regard to code edits. Sorting out the changes then takes disproportionate
time and often repeats your previous work, if you <em>actually</em> read the diffs during
the session, which I highly recommend. Even single-person development now becomes
collaborative: at the very least, your collaborator is an LLM. In calm waters,
running several agents is nothing special. Then I have an entire team, with
all the merges and rebases (which we like to do beyond any measure).</p>
<p dir="auto">That is why I think it is the right time to look for git replacements, and
that is why I am working on one.  I definitely reject the &#34;git compatible&#34;
approach despite the immense gravitation of the existing mass of git repos.
<a href="https://www.jj-vcs.dev/latest/" rel="nofollow"><code>jj</code></a> to <code>git</code> is what <code>subversion</code> was to <code>cvs</code>. What we need is what
<code>git</code> was to <code>cvs</code>: a level-up. All the long-standing and all the new issues are
all rooted in the core architecture of git. In any other case, those issues
would be fixed by now just by gradual and incremental improvement.</p>
<p dir="auto">The issues are:</p>
<ul dir="auto">
<li>
<p dir="auto">The monorepo problem: git has difficulty dividing the codebase into modules
and joining them back. Apart from the fact that git submodules have been
improvised clumsily and haunt us ever since, the very conceptual approach to
splitting and joining the code is lacking. All the Big-monorepo companies
either use something else or build on top of git.</p>
</li>
<li>
<p dir="auto">The split/join problem has way more implications. Suppose, for example, I
want to keep my prompts and plans in a separate repo, but join them in when
necessary. Or, go full JTPP - &#34;just the prompt, please&#34;.
Git has no solution for such &#34;overlay branches&#34;, in principle.
There is a source tree in git, there is a build tree somewhere else, and
there is a prompt/todo/plan tree in yet another different place.</p>
</li>
<li>
<p dir="auto">The merge/rebase problem: merge commits create quite a lot of friction,
while rebases discard the context and imply hierarchy. Fundamentally, git
merges are an act of will, they are not deterministic. Hence, a merge has
to be recorded with all the ceremony. On top of that, git is not
syntax-aware, so false conflicts are pretty common.
Manual resolution of trivial conflicts is another aspect of friction.</p>
</li>
<li>
<p dir="auto">Lack of any any code insight features better than <code>grep</code>. If SCM is a
database for the code, there must be a well-developed query language.
I want to see what changed in a particular function since day D or
what new uses it had in that time. Like git meets IDEA.
IDE/LSP gives us spatial structure of the code, SCM adds temporal dimension.
That is especially valuable when investigating what agents <em>actually</em> did.</p>
</li>
<li>
<p dir="auto">Data accretion problem: once you commit things into the repo, they are tied
in the Merkle graph forever. There are ways to receive only the latest
version, but any general pay-as-you-go mode is lacking.
git&#39;s data integrity model is blockchain-like: all or nothing.
(In fact, a lot of history is trimmed by rebases, as things would be
unmanageable otherwise. That is also an issue, as the actual lineage of
an edit gets discarded entirely.)</p>
</li>
<li>
<p dir="auto">The data model problem: git internally works with blobs, which is quite
blunt. In fact, we got to the bottom of it: git is a <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects" rel="nofollow">content-addressable
filesystem</a>, not a content-addressable database.</p>
</li>
</ul>
<p dir="auto">Overall, we need a <em>database</em> for the code!</p>
<p dir="auto">Again, these points I mentioned at various conferences during the past 10
years, and many other people in the CRDT community talked about &#34;overlay
branches&#34; and &#34;CRDT revision control&#34; for 10-15 years. In essence it all boils
down to two things:</p>
<ol dir="auto">
<li>versioning data structures, not blobs and</li>
<li>having formal deterministic merge algorithms (associative, commutative,
idempotent).</li>
</ol>
<p dir="auto">One approach to it was to represent text as a CRDT vector of letters, and it
was quite popular in the field. <a href="https://zed.dev/blog/sequoia-backs-zed#introducing-deltadb-operation-level-version-control" rel="nofollow">Zed&#39;s DeltaDB</a> aligns with that
<a href="https://zed.dev/blog/crdts" rel="nofollow">approach</a>. I also made such systems in the past. It is safe to assume it
the default. On the other hand, if we look into the inners of any <a href="https://www.jetbrains.com/help/idea/psi-viewer.html" rel="nofollow">JetBrains
IDE</a> or <a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" rel="nofollow">LLVM internals</a>, we will see AST trees. Because code has
structure. If you want to treat all source code the same, you use line-based
text (like all UNIX tools do). If you want to do fancy stuff, you parse the
source and work with ASTs. Git is a filesystem, so it treats everything as a
blob (git diff receives input blobs and reconstructs the most plausible edits
<a href="https://nathaniel.ai/myers-diff/" rel="nofollow">algorithmically</a>).</p>
<p dir="auto">Here I see the opportunity: a revision control system working with AST-like
trees, with very formal, deterministic and reversible split/join/fork/merge
semantics and a structure-aware query language. As a substrate, I use
<a href="https://github.com/gritzko/librdx">Replicated Data eXchange format (RDX)</a>, a JSON superset with very nice
CRDT merge semantics.</p>
<p dir="auto"><strong>Part II. Inner workings of CRDT revision control.</strong></p>
<p dir="auto"><strong>Part III. The outer interface (no clusterfuck this time!)</strong></p>
<p dir="auto"><strong>Part IV. Experiments.</strong></p>
<p dir="auto"><strong>Part V. The Vision.</strong></p>
</article>
  </div>

  </div>

</div></div>
  </body>
</html>
