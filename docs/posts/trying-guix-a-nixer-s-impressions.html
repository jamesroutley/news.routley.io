<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tazj.in/blog/trying-guix">Original</a>
    <h1>Trying Guix: A Nixer&#39;s impressions</h1>
    
    <div id="readability-page-1" class="page"><article><h2>Trying Guix: A Nixer&#39;s Impressions</h2>

<p>People occasionally ask me how I think Guix compares to Nix. Let me set the stage: I&#39;ve been using Nix for many years, have large projects using Nix, used to be very active in the Nix community, and even wrote <em>multiple</em> Nix language interpreters, so I&#39;d say that I&#39;m at least <em>fairly comfortable</em> with Nix.</p>
<p>I&#39;m also one of those people who live in Emacs. I&#39;m no stranger to Lisps (although my experience with Scheme is limited) and am very fond of them. It feels natural that people ask me about my views on Guix.</p>
<p>The thing is: I haven&#39;t actually ever used Guix, so I just don&#39;t <em>know</em>. But there&#39;s an easy way to find out: let&#39;s try it! So that&#39;s what I did this weekend.</p>
<p>Here are a few things I ran into and found noteworthy. My goal was to take my <a href="https://unchartevice.ru/">Unchartevice</a> laptop with its strange Zhaoxin x86_64-compatible CPU and see if I could get all the way to my standard <a href="https://github.com/YaLTeR/niri">niri</a> desktop. There&#39;s no overarching point here, just observations a user of one or the other system might find interesting.</p>
<p><em>Spoiler:</em> I didn&#39;t manage, but I saw a lot of interesting stuff. Knowing myself, I&#39;ll probably keep trying when some free time shows up.</p>
<p>A quick note before we begin: Technically, Guix uses a fork of the Nix daemon for the low-level primitives of functional package management (the <del>Nix</del> Guix Store, derivations, substitutions, and all that stuff are <em>basically</em> the same). The projects forked a long time ago, and development has diverged significantly since then. The similarities end here, however: Guix is not &#34;just&#34; Nix with Scheme — it&#39;s a complete alternative ecosystem built in parallel on top of the same foundational infrastructure. A mental model of &#34;Nix with Lisp syntax&#34; will <strong>not</strong> work in practice when approaching Guix.</p>
<p>Anyway, here we go.</p>
<h2><a href="#nonguix" aria-hidden="true" id="nonguix"></a>nonguix</h2>
<p>The very first thing I ran into is more political, but I must mention it, as almost everyone trying the Guix System will face this immediately. <a href="#architectural-differences">Skip</a> this if you want to get straight into the technical stuff.</p>
<p>Guix is the GNU system, and as such takes software freedoms very seriously. Guix does not recommend and does not ship the proprietary blobs needed for most modern hardware. The FSF has <a href="https://ryf.fsf.org/categories/laptops">a website</a> that lists laptops that work without them, but it is <em>very</em> limited. The <a href="https://guix.gnu.org/blog/2025/guix-user-and-contributor-survey-2024-the-results-part-2/#:~:text=posts%20for%20more.-,Proprietary%20drivers,-Proprietary%20drivers%20is">majority</a> of Guix System users use something called <a href="https://gitlab.com/nonguix/nonguix"><code>nonguix</code></a> that adds these blobs, giving you access to things such as wireless internet.</p>
<p>I don&#39;t want to make this post about the political side of software freedoms, but I had to use <code>nonguix</code> to get internet working on the machine, which had very immediate technical effects that bring me to:</p>
<h2><a href="#architectural-differences" aria-hidden="true" id="architectural-differences"></a>Architectural Differences</h2>
<p>A major and immediate difference between Guix and Nix is that they layer things differently. Nix works like this:</p>
<pre><span>[ nix-daemon ] &lt;-&gt; [ Nix CLI ] &lt;- [ Nix code ]
</span></pre>
<p>The brackets here are intended to signify <em>independence</em>: You can mix (to some extent) separately built nix-daemons and Nix CLIs, and you can use almost any version of Nix from the last 8 years or so to evaluate almost any Nix code (let&#39;s, please, not get into <del>why flakes are nonsense</del> why this is only &#34;almost&#34; true).</p>
<p>The Nix CLI knows nothing about nixpkgs. In most Nix code, something, somewhere will <code>import</code> a commit of nixpkgs, which yields an enormous data structure lazily containing all Nix packages, and then use bits of this structure. Importing multiple nixpkgs commits is no problem—it just means that you have <em>two</em> large data structures now. In effect, this means that you can mix and match nixpkgs commits (or other Nix config) freely <em>within the language</em>, and Nix always evaluates the entire thing.</p>
<p>In fact, in TVL <a href="https://code.tvl.fyi/tree/third_party/nixpkgs/default.nix?id=f3a844f1be8d814252a2f78d8092499789215d29#n55">we mix nixpkgs commits</a> all the time, because we track unstable releases and occasionally need to pick software from an older stable commit.</p>
<p>Guix doesn&#39;t work like this, and I found it very confusing at first. That&#39;s not to say it&#39;s bad — it&#39;s just different:</p>
<pre><span>[ guix-daemon ] &lt;-&gt; [ guix CLI + profile ] &lt;- [ Guix user code ]
</span></pre>
<p>As in Nix, the Guix daemon converses with the CLI over an RPC interface. The difference is that the Guix CLI runs in a fixed profile that has <em>all</em> of the packages and modules from all channels <em>baked in</em>. In contrast to Nix, the Guix package/service set is not one big data structure, but a namespaced hierarchy of Scheme modules. The Guix CLI is a Scheme environment in which packages, services and so on are available for import in user code.</p>
<p>This means that to change the Guix version (i.e., commit in their <a href="https://codeberg.org/guix/guix/">monorepo</a>, which is the implementation of the CLI <em>and</em> of the package set, as if <code>NixOS/nix</code> and <code>NixOS/nixpkgs</code> were one) you essentially <em>rebuild Guix</em>. In Guix land, this happens through a command called <code>guix pull</code>, which ultimately yields (as I understand it) a new <code>guix</code> binary with a hardcoded profile.</p>
<p>This has two effects that were noticeable to me:</p>
<ol>
<li>Switching between versions is always at least a two-step process: Rebuild Guix, then rebuild your config. You can&#39;t easily, as in Nix, just import a different Guix commit in your code.</li>
<li>Running <code>guix pull</code> is slow, and this makes the initial bootstrapping experience very frustrating. It&#39;s super-easy to build a configuration from some Guix commit, then run the wrong command and cache-bust everything as the commit changed (which, due to nonguix, often leads to a full Linux kernel rebuild—something you do <em>not</em> want to do on a Zhaoxin KX-6640MA!).</li>
</ol>
<p>There isn&#39;t a right-or-wrong here: Guix uses a different model from Nix. For me, Nix&#39;s feels more natural, but this might just be bias due to familiarity.</p>
<p>For what it&#39;s worth, Liam from the <code>#guix</code> IRC channel pointed me <a href="https://codeberg.org/guix/guix/issues/431#issuecomment-5528810">towards a method</a> for handling Guix &#34;pins&#34; in a better way, but I haven&#39;t tried it out yet.</p>
<p>Another thing that seems architecturally different is profile-wide installs of packages. In Guix they seem to be preferred over the Nix approach of creating isolated environments for specific programs with helpers. The most noticeable one for me was Emacs: People usually install Emacs packages right into their system or user profile from which Emacs loads them, whereas Nix has <code>emacs.withPackages</code> that takes a list of packages and builds a full Emacs with these packages baked in.</p>
<p>I haven&#39;t figured out if there is an equivalent to Nix&#39;s <code>emacs.withPackages</code>. Maybe I didn&#39;t look at the right people&#39;s configs? If there isn&#39;t, this kind of design makes some experimentation harder than on Nix: It&#39;s seemingly more difficult to try out packages without affecting the global namespace.</p>
<h2><a href="#documentation--onboarding" aria-hidden="true" id="documentation--onboarding"></a>Documentation &amp; Onboarding</h2>
<p>Guix&#39;s community has a much more focused culture. The Nix community is currently a bit of a mess of different corporate interests pulling in different directions with little ideology and direction.</p>
<p>Guix&#39;s clear focus allows to get some stuff done that I think would be difficult to organize in Nix. An area where this is noticeable is documentation: Guix&#39;s is many times better than Nix&#39;s. It is structured logically, available in <code>info</code>, all the Scheme constructs needed are documented like any other Scheme code, and so on.</p>
<p>The thing is, I&#39;m not actually sure if Guix&#39;s better documentation helps smooth the onboarding in any way because you have to already know Scheme, which is a more complex language than Nix. On the other hand, the skill of knowing Scheme translates to other domains, so you might argue that learning Scheme is an investment that pays off more than learning the Nix language.</p>
<p>Another thing that complicates onboarding is the whole nonguix situation: There are no recent ISO images for installers with unfree firmware, and there&#39;s only a handful of posts strewn across the internet that will help you get up-and-running.</p>
<p>Maybe the documentation in both cases (Nix and Guix) isn&#39;t really going to help beginners, but it helps confident users more effectively use the system. Guix does this better.</p>
<h2><a href="#performance" aria-hidden="true" id="performance"></a>Performance</h2>
<p>Guix is noticeably slower than Nix. We complain about NixOS evaluation with C++ Nix taking a long time, but Guix feels an order of magnitude slower.</p>
<p>On this laptop, a <code>guix pull</code> (remember, this is the equivalent to updating your nixpkgs pin on Nix) can easily take 30-50 minutes. After that you still need to evaluate the system config, check for substitutes, build it, and so on. Sure, this is a laptop with a CPU broadly equivalent to old Intel Atom CPUs, but on this same machine Nix performs much better (evaluating and switching to a new system config in 5-10 minutes).</p>
<p>Apparently once the system is stable, and commits don&#39;t keep changing much, performance improves - but I haven&#39;t reached that state yet, and getting there is hard.</p>
<p>Due to the kernel rebuilds I ended up installing Guix on <code>nevsky</code>, the powerful TVL build server, and building the system config there (the Guix package manager runs well on NixOS, and vice-versa). I couldn&#39;t figure out an easy way to get the system closure from there to the laptop though, as <code>guix copy --from=...</code> doesn&#39;t seem to work for HTTP substitution. It seems like evaluating the config locally is unavoidable.</p>
<p>I&#39;m curious why this is: The Guile interpreter has a JIT, and Guix has a more imperative evaluation model which should (unintuitively) be able to avoid some of the work happening in Nix&#39;s magic recursive fixpoint sets. Maybe there are some low-hanging fruits and performance just hasn&#39;t been a priority? I don&#39;t know, but I&#39;d be interested in finding out.</p>
<p>Of course, a CPU with these performance characteristics is an outlier in 2025, but it makes the difference more noticeable.</p>
<h2><a href="#shepherd-vs-systemd" aria-hidden="true" id="shepherd-vs-systemd"></a>Shepherd vs. systemd</h2>
<p>The Guix system does not use <code>systemd</code>. This is great—I&#39;ve <a href="https://t.me/tazlog/65">ranted</a> before (in Russian) about how much I dislike the current state of <code>systemd</code>, and there are much <a href="https://blog.darknedgy.net/technology/2015/10/11/0/">more detailed</a> posts about why systemd, albeit being an improvement over what came before it, is not very good.</p>
<p>Guix instead uses <a href="https://www.gnu.org/software/shepherd/">Shepherd</a>, an init system written in Scheme. I don&#39;t have much to say about it yet, but it seems fairly straightforward and has excellent documentation. Once I continue with my experiment, I&#39;ll take a look again.</p>
<h2><a href="#conclusion" aria-hidden="true" id="conclusion"></a>Conclusion</h2>
<p>Where I ended up after hacking on this for the weekend:</p>
<p>I&#39;ve got Guix running on the laptop, however without a graphical UI. Some hardware configuration bits are missing, and as there doesn&#39;t seem to be an equivalent to <code>nixos-generate-config</code> I still have to invest some time in guessing <em>which</em> bits. I failed to configure the same channels that I used during installation on the machine itself, so now I have to go through at least one more extremely slow <code>guix pull</code> cycle to evaluate and be able to substitute the next config generation, which is already built on <code>nevsky</code>. Feels like I&#39;m doing something wrong, but that is learning.</p>
<p>Despite the problems I ran into, Guix is still intriguing: Lisp is a big plus, and the Guix ecosystem feels a lot more coherent than Nix. Would Guix be able to give me anything that Nix doesn&#39;t? I don&#39;t know. My first milestone would be just getting something equivalent to my NixOS desktop config running there, and figuring out a quicker way to iterate. The rest comes later.</p>

</article></div>
  </body>
</html>
