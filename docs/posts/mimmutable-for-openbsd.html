<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/915640/53bc300d11179c62/">Original</a>
    <h1>mimmutable() for OpenBSD</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
Virtual-memory systems provide a great deal of flexibility in how memory
can be mapped and protected.  Unfortunately, memory-management flexibility
can also be useful to attackers bent on compromising a system.  In the
OpenBSD world, a new system call is being added to reduce this flexibility;
it is, though, a system call that almost no code is expected to use.
</p><p>
OpenBSD founder Theo de Raadt first <a href="https://lwn.net/Articles/915661/">proposed</a> a new system call, called
<tt>mimmutable()</tt>, at the beginning of September.  After numerous
revisions, the system call looks to be merged as:
</p><pre>    int mimmutable(void *addr, size_t len);
</pre>
<p>
A call to <tt>mimmutable()</tt> will render the mapping of the <tt>len</tt>
bytes of 
memory starting at <tt>addr</tt> immutable, meaning that the
kernel will not allow any changes to either the memory protections or the
mapping in that range.  As a result, system calls like <tt>mmap()</tt> or
<tt>mprotect()</tt> that would affect that range will, instead, fail.
</p><p>
At first glance, <tt>mimmutable()</tt> looks similar in spirit to OpenBSD&#39;s
<a href="https://man.openbsd.org/pledge.2"><tt>pledge()</tt></a>, which
restricts the system calls that the calling process may use.  But, while
<tt>pledge()</tt> calls appear in numerous programs in the OpenBSD
repository, <tt>mimmutable()</tt> calls will be rare indeed.  Most
developers lack a detailed understanding of the memory layout of their
programs and are not well placed to render portions of their
address space immutable, but the kernel and the linker are a different
story.
</p><p>
The details of how <tt>mimmutable()</tt> will be used are described in
detail in <a href="https://lwn.net/Articles/915662/">this email from De Raadt</a>.  In
simplified form, it starts when the kernel loads a new executable image;
once the text, stack, and data areas have been mapped, they will be made
immutable before the program even starts running.  For static binaries, the
C runtime will do a bit of fixup and then use <tt>mimmutable()</tt> to make
most of the rest of the mapped address space immutable as well.  For dynamically
linked binaries, the shared-library linker (<tt>ld.so</tt>) performs a
similar set of tasks, mapping each library into the address space, then
making most of those mappings immutable.

</p><p>
All of this will happen automatically, without any awareness on the part of
the program being loaded.
The end result will be a process that cannot make changes to almost all of
its mapped address space (though it can always create new mappings in parts
of the address space that have not yet been mapped).  There is one little
exception:
</p><blockquote>
	So this static executable is completely immutable, except for the
	OPENBSD_MUTABLE region.  This annotation is used in one place now,
	deep inside libc&#39;s malloc(3) code, where a piece of code flips a
	data structure between readonly and read-write as a security
	measure.  That does not become immutable.
</blockquote>
<p>
Making this whole scheme work requires changes beyond just the OpenBSD
kernel; the compiler toolchain, in particular, needed enhancements to mark
the sections that must remain mutable when the program is loaded.  There
were evidently some programs that needed tweaks to work properly in this
environment; since OpenBSD manages the kernel and user space together, it
is able to make the sort of changes that Linux, out of fear of causing
user-space regressions, normally cannot.
</p><p>
Even so, implementing <tt>mimmutable()</tt> involves a fair amount of
fiddly work; one would assume that the OpenBSD developers expect to see a
corresponding benefit.  One obvious place is with executable memory.
OpenBSD has long gone out of its way to prevent memory from being
simultaneously 
writable and executable, but the protection that comes from this
restriction goes away if an attacker is somehow able to load malicious code
into a writable region, then change the permissions afterward.  Nailing
down the protections for a process&#39;s data areas will make that kind of
attack impossible.
</p><p>
Beyond that, though, OpenBSD uses a couple of memory protections that are
not present in Linux.  One of those marks executable memory that is
empowered to call into the kernel; on OpenBSD systems, only the C library
is given that capability.  That will prevent hostile code loaded elsewhere
from making direct system calls; protecting the rest of a process with
<tt>mimmutable()</tt> will prevent the changing of protections to allow
system calls from elsewhere (such changes would be done with <a href="https://man.openbsd.org/msyscall"><tt>msyscall()</tt></a> on
OpenBSD).
</p><p>
OpenBSD also has a special marker for memory regions that are intended to
hold stacks.  Whenever a process enters the kernel, its stack pointer is
checked to see whether it is, indeed, pointing into a stack region; if not,
the process is killed.  This check thwarts &#34;stack pivot&#34; attacks, where an
attacker redirects the stack pointer into a region of memory that is more
conducive to the attack being performed.  Once again, <tt>mimmutable()</tt>
will prevent an attacker from turning ordinary data regions into
stack-capable regions.
</p><p>
It is possible that a system call like <tt>mimmutable()</tt> could be used
to improve security on Linux systems, but it would be a harder project.
Linux kernel developers lack the ability to modify user-space programs in
lockstep, so it is harder to make this kind of change without breaking
somebody&#39;s code somewhere.  For example, adding a &#34;direct system calls
allowed&#34; protection bit could easily break a lot of programs under Linux that, for
whatever reason, are not using the C-library wrappers and are calling
directly into the kernel.
</p><p>
Similar roadblocks apply for restrictions on stack pointers.  The kernel
does have 
a &#34;grows down&#34; bit that identifies stack regions â€” but only those that can
grow.  Multithreaded programs often create threads with fixed-length stacks
that will lack this bit.  As a result, any user-space program that creates
stacks for threads would need modification to set such a bit explicitly,
and kernel developers cannot make such modifications happen.  So
stack-pointer checks are not likely to come to Linux anytime soon.
</p><p>
Still, there may be value in a system call that makes memory mappings
immutable.  Getting such a thing into Linux would require a developer
interested in implementing it, a demonstration that user-space code would
make use of it, and some sort of convincing story describing attacks that
would be thwarted by it.  There would probably also be a need to get
changes into the toolchains to support this feature. 
It&#39;s a high bar, as is normally the case for new
system calls, but perhaps somebody might eventually be inspired to try to
get a patch over it.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Security/Index/">Security</a></td><td><a href="https://lwn.net/Security/Index/#OpenBSD">OpenBSD</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
