<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ferret-lang.org/">Original</a>
    <h1>Ferret: A functional, lazy language for realtime embedded control systems</h1>
    
    <div id="readability-page-1" class="page"><div id="content">



<div id="outline-container-sec-1">
<h2 id="sec-1">Getting Started</h2>
<div id="outline-container-sec-1-1">
<h3 id="sec-1-1">What Is Ferret</h3>
<div id="text-1-1">
<p>
Ferret is a free software lisp implementation designed to be used in
real time embedded control systems. Ferret lisp compiles down to self
contained <b>C++11</b>. Generated code is portable between any Operating
System and/or Microcontroller that supports a <b>C++11</b> compliant
compiler. It has been verified to run on architectures ranging from
embedded systems with as little as <b>2KB of RAM</b> to general purpose
computers running Linux/Mac OS X/Windows.
</p>

<ul>
<li>General Purpose Computers
<ul>
<li>Clang on Mac OS X
</li>
<li>GCC &amp; Clang on Linux
</li>
</ul>
</li>
<li>Microcontrollers
<ul>
<li>Arduino 
<ul>
<li>Uno / Atmega328
</li>
<li>Due / AT91SAM3X8E
</li>
<li>101 / Intel Curie
</li>
</ul>
</li>
<li>Teensy
<ul>
<li>2.0 / 16 MHz AVR
</li>
<li>3.2 / Cortex-M4
</li>
<li>3.6 / Cortex-M4F
</li>
</ul>
</li>
<li>SparkFun SAMD21 Mini / ATSAMD21G18 - ARM Cortex-M0+
</li>
<li>NodeMcu - ESP8266
</li>
</ul>
</li>
<li><a href="#sec-2-2">Hardware / Operating System Support</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2">
<h3 id="sec-1-2">Features</h3>
<div id="text-1-2">
<ul>
<li>Tailored for Real Time Control Applications. (Deterministic Execution.)
</li>
<li>Immutable Data Structures
</li>
<li>Functional
</li>
<li>Macros
</li>
<li>Easy FFI (Inline C,C++. See <a href="#sec-4-7">Accessing C,C++ Libraries</a>)
</li>
<li>Easily Embeddable (i.e Ferret fns are just C++ functors.)
</li>
<li>Memory Pooling (Ability to <b>run without heap memory</b>. See <a href="#sec-4-2">Memory Management</a>)
</li>
<li>Destructuring
</li>
<li>Module System
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3">
<h3 id="sec-1-3">Download</h3>
<div id="text-1-3">
<p>
Ferret is available as prebuilt and source code distributions. See
<a href="#sec-2-5">Building From Sources</a> for links to source distribution.
</p>

<p><img src="https://badge.fury.io/gh/nakkaya%2Fferret.svg"/>

<a href="https://travis-ci.org/nakkaya/ferret/builds">
  <img src="https://travis-ci.org/nakkaya/ferret.svg?branch=master"/>
</a></p><p>
Platform independent builds (requires JVM),
</p>

<ul>
<li><a href="https://ferret-lang.org/builds/ferret.jar">Standalone Jar</a>
</li>
<li><a href="https://ferret-lang.org/builds/ferret">Executable</a> (Requires Bash)
</li>
</ul>

<p>
Supported package managers,
</p>

<ul>
<li>Debian/Ubuntu
</li>
</ul>

<div>

<pre><span>echo</span> <span>&#34;deb [trusted=yes]\</span>
<span> https://ferret-lang.org/debian-repo ferret-lisp main&#34;</span> &gt;&gt; /etc/apt/sources.list
apt-get update
apt-get install ferret-lisp
</pre>
</div>

<ul>
<li>Clojars - <a href="https://clojars.org/ferret">https://clojars.org/ferret</a>
</li>
</ul>


</div>
</div>

<div id="outline-container-sec-1-4">
<h3 id="sec-1-4">A glimpse of Ferret</h3>
<div id="text-1-4">
<p>
On any system, we can just compile a program directly into an
executable. Here&#39;s a program that sums the first 5 positive numbers.
</p>

<div>

<pre><span>;;; </span><span>lazy-sum.clj</span>
(<span>defn</span> <span>positive-numbers</span>
  ([]
   (positive-numbers 1))
  ([n]
   (<span>cons</span> n (<span>lazy-seq</span> (positive-numbers (<span>inc</span> n))))))

(<span>println</span> (<span>-&gt;&gt;</span> (positive-numbers)
              (<span>take</span> 5)
              (<span>apply</span> +)))
</pre>
</div>

<p>
We can compile this program using <b>ferret</b>, creating an executable named
<b>lazy-sum</b>.
</p>

<pre>$ ./ferret -i lazy-sum.clj
$ g++ -std=c++11 -pthread lazy-sum.cpp -o lazy-sum
$ ./lazy-sum
15
</pre>

<p>
Output will be placed in a a file called <b>lazy-sum.cpp</b>. When <b>-c</b>
flag is used ferret will call <b>g++</b> or if set <b>CXX</b> environment
variable on the resulting <b>cpp</b> file.
</p>

<pre>$ ./ferret -i lazy-sum.clj -c
$ ./lazy-sum
15
</pre>

<p>
Following shows a blink example for Arduino. (See section <a href="#sec-2-2-1">Arduino Boards</a> for more info on how to use Ferret lisp on Arduino boards.) 
</p>

<div>

<pre><span>;;; </span><span>blink.clj</span>
(<span>require</span> &#39;[ferret.arduino <span>:as</span> gpio])

(gpio/pin-mode 13 <span>:output</span>)

(forever
 (gpio/digital-write 13 1)
 (sleep 500)
 (gpio/digital-write 13 0)
 (sleep 500))
</pre>
</div>

<pre>$ ./ferret -i blink.clj -o blink/blink.ino
</pre>

<p>
Then upload as usual. Following is another example, showing the usage
of <a href="#sec-4-2">Memory Pooling</a>. Program will blink two LEDs simultaneously at
different frequencies (Yellow LED at 5 hz Blue LED at 20 hz). It uses
a memory pool of 512 bytes allocated at compile time instead of
calling malloc/free at runtime.
</p>

<div>

<pre>(configure-runtime! FERRET_MEMORY_POOL_SIZE 512
                    FERRET_MEMORY_POOL_PAGE_TYPE byte)

(<span>require</span> &#39;[ferret.arduino <span>:as</span> gpio])

(<span>def</span> <span>yellow-led</span> 13)
(<span>def</span> <span>blue-led</span>   12)

(gpio/pin-mode yellow-led <span>:output</span>)
(gpio/pin-mode blue-led   <span>:output</span>)

(<span>defn</span> <span>make-led-toggler</span> [pin]
  (<span>fn</span> []
    (<span>-&gt;&gt;</span> (gpio/digital-read pin)
         (<span>bit-xor</span> 1)
         (gpio/digital-write pin))))

(<span>def</span> <span>job-one</span>
  (fn-throttler (make-led-toggler yellow-led) 5 <span>:second</span> <span>:non-blocking</span>))

(<span>def</span> <span>job-two</span>
  (fn-throttler (make-led-toggler blue-led)  20 <span>:second</span> <span>:non-blocking</span>))

(forever
 (job-one)
 (job-two))
</pre>
</div>

<pre>$ ./ferret -i ferret-multi-led.clj -o ferret-multi-led/ferret-multi-led.ino
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2">
<h2 id="sec-2">Overview</h2>
<div id="text-2">
<p>
Ferret is a functional, lazy language designed to be used in real time
embedded control systems. It is heavily inspired by Clojure both
syntactically and semantically.  Functions / Macros that are present
in both Ferret and Clojure should mimic their Clojure counter
parts. If they don&#39;t it is considered a bug. (or not possible to
implement with the current implementation.)
</p>

<p>
This document is not intended to be a full lisp tutorial. It is a
specification of the subset of lisp implemented by Ferret, and the
particular workings of the <a href="#sec-4">Runtime</a> and <a href="#sec-5">Core</a> library. Any getting
started guide for Clojure should get you upto speed on Ferret.
</p>
</div>

<div id="outline-container-sec-2-1">
<h3 id="sec-2-1">Documentation Structure</h3>
<div id="text-2-1">
<p>
This is a literate program, inspired by Donald Knuth (Knuth, Donald
“Literate Programming (1984)” Literate Programming CSLI, p99). It is
intended to be read like a novel from cover to cover. The ideas are
expressed clearly but they are grounded in the actual source code.
</p>

<p>
The compiler and the C++ runtime needed is split into three sections.
</p>

<ul>
<li><a href="#sec-3">Compiler</a>
</li>
<li><a href="#sec-4">Runtime</a>
</li>
<li><a href="#sec-5">Core</a>
</li>
</ul>

<p>
<a href="#sec-3">Compiler</a> section contains the actual compiler written in Clojure. It
takes the Ferret code and converts it to a Intermediate
representation by taking the Ferret form and running it <a href="#sec-3-1">through some
transformations</a>. This IR is then run through <a href="#sec-3-2">Code Generation</a> module to
create C++ code. <a href="#sec-4">Runtime</a> contains the C++ runtime needed to support
Ferret such as <a href="#sec-4-1">Object System</a>, <i>Memory Pooling</i>, <a href="#sec-4-2-3">Garbage Collection</a>. It
is written in a mixture of C++ and Ferret DSL. <a href="#sec-5">Core</a> is the standard
library of Ferret, provides a ton of general-purpose functionality for
writing robust, maintainable embedded applications.
</p>
</div>
</div>

<div id="outline-container-sec-2-2">
<h3 id="sec-2-2">Hardware / Operating System Support</h3>
<p>
Ferret does not depend on any external dependencies (Including the C++
Standard Library). Unit tests are run on Mac OS X and Linux, any
operating system with a C++11 compiler is supported. When running on a
microcontroller ferret will check if it is a supported platform during
compile time and enable hardware specific features. (Currently only
UART is hardware specific.) If running on an unknown hardware it
will run in <b>safe mode</b> (UART disabled.). Everything else is supported
in safe mode. Like operating system support any embedded system with a
C++11 compiler is supported. See <a href="#sec-1-1">What Is Ferret</a> for a list of
currently supported microcontrollers.
</p>

<div id="outline-container-sec-2-2-1">
<h4 id="sec-2-2-1">Arduino Boards</h4>
<div id="text-2-2-1">
<p>
Ferret standard library has built in support for Arduino library. <b>Any
board</b> that Arduino IDE supports should work with Ferret lisp. 
</p>

<p>
<b>Post Arduino 1.5.0</b>, Ferret compiler can upload directly to a Arduino
board by adding the following build command to the top of the file,
</p>

<div>

<pre>(configure-ferret! <span>:command</span> <span>&#34;~/apps/arduino-1.8.0/arduino \\</span>
<span>                               --board arduino:sam:arduino_due_x_dbg \\</span>
<span>                               --port /dev/ttyACM0 \\</span>
<span>                               --upload ./blink.cpp&#34;</span>)
</pre>
</div>

<p>
When <b>-c</b> option is passed Ferret will execute the above command and
upload the solution to the board. (See <a href="https://github.com/arduino/Arduino/blob/master/build/shared/manpage.adoc">ARDUINO(1) Manual Page</a> for
details.)
</p>

<pre>$ ./ferret -i blink.clj -c
</pre>

<p>
Sample Makefile for automating compilation and upload on an Arduino,
</p>

<div>

<pre><span>FERRET</span>  = ferret
<span>INPUT</span>   = core.clj
<span>OUTPUT</span>  = core.ino
<span>ARDUINO</span> = ~/arduino-1.8.5/arduino
<span>BOARD</span>   = arduino:sam:arduino_due_x_dbg
<span>PORT</span>    = /dev/ttyACM0
<span>RM</span>      = rm -f

<span>.PHONY</span>: verify upload clean

<span>default</span>: verify

<span>core</span>: core.clj
        $(<span>FERRET</span>) -o $(<span>OUTPUT</span>)

<span>verify</span>: core
        $(<span>ARDUINO</span>) --board $(<span>BOARD</span>) --verify $(<span>OUTPUT</span>)

<span>upload</span>: core
        $(<span>ARDUINO</span>) --board $(<span>BOARD</span>) --port $(<span>PORT</span>) --upload $(<span>OUTPUT</span>)

<span>clean</span>:
        $(<span>RM</span>) $(<span>OUTPUT</span>)
</pre>
</div>

<p>
<b>Pre Arduino 1.5.0</b>, recommended way is to go to preferences and set
Arduino IDE to use an External Editor. This way when Ferret recompiles
the sketch changes will be automatically picked up by the IDE ready to
be uploaded. To automatically rename the <b>cpp</b> file to <b>ino</b> or <b>pde</b>
use the following option,
</p>

<div>

<pre>(configure-ferret! <span>:command</span> <span>&#34;mv blink.cpp blink.ino&#34;</span>)
</pre>
</div>

<p>
Then compile with,
</p>

<pre>$ ./ferret -i blink.clj -c
</pre>

<p>
Result will be <b>blink.ino</b> ready to be uploaded. Any changes to the
<b>clj</b> file should be picked up by the IDE.
</p>
</div>
</div>

<div id="outline-container-sec-2-2-2">
<h4 id="sec-2-2-2">Yocto</h4>
<div id="text-2-2-2">
<p>
Install <a href="https://wiki.yoctoproject.org/wiki/Building_your_own_recipes_from_first_principles">Yocto</a> and create a package for your application. A sample
recipe for a simple Ferret application is given below.
</p>

<pre>recipes-example/
└── core
    ├── core-0.1
    │   └── core.clj
    └── core_0.1.bb
</pre>

<div>

<pre><span>;; </span><span>core.clj</span>
(<span>println</span> <span>&#34;Hello World!&#34;</span>)
</pre>
</div>

<div>

<pre># core_0.1.bb
SUMMARY = <span>&#34;Simple Ferret application&#34;</span>
SECTION = <span>&#34;examples&#34;</span>
LICENSE = <span>&#34;MIT&#34;</span>
LIC_FILES_CHKSUM = <span>&#34;file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302&#34;</span>

SRC_URI = <span>&#34;file://core.cpp&#34;</span>

S = <span>&#34;${WORKDIR}&#34;</span>

do_compile() {
         ferret -i ./core.clj
         ${CXX} -std=c++11 core.cpp -o core
}

do_install() {
         install -d ${D}${bindir}
         install -m 0755 core ${D}${bindir}
}
</pre>
</div>

<p>
Finally add the application to your <code>layer.conf</code>.
</p>

<pre>IMAGE_INSTALL_append = &#34; core&#34;
</pre>
</div>
</div>

<div id="outline-container-sec-2-2-3">
<h4 id="sec-2-2-3">Raspberry Pi</h4>
<div id="text-2-2-3">
<p>
Clone required layers,
</p>

<pre>git clone -b jethro git://git.yoctoproject.org/meta-raspberrypi
</pre>

<p>
Add <code>meta-raspberrypi</code> to <code>BBLAYERS</code> in <code>build/conf/bblayers.conf</code>,
and and Select your machine type in <code>build/conf/local.conf</code>. See
<a href="https://meta-raspberrypi.readthedocs.io/en/latest/layer-contents.html#supported-machines">Supported Machines</a> for <code>MACHINE</code> type. Build the image,
</p>

<pre>bitbake rpi-basic-image
</pre>

<p>
Write the image,
</p>

<pre>dd if=tmp/deploy/images/raspberrypi2/rpi-basic-image-raspberrypi2.rpi-sdimg of=/dev/mmcblk0
</pre>
</div>
</div>
</div>





<div id="outline-container-sec-2-5">
<h3 id="sec-2-5">Building From Sources</h3>
<div id="text-2-5">
<p>
All source code for the project is kept in a single <code>org-mode</code> file
named <code>ferret.org</code>. <code>emacs</code> is used to extract the sources and
documentation.
</p>

<p><img src="https://img.shields.io/github/last-commit/nakkaya/ferret.svg"/>
<img src="https://img.shields.io/github/issues/nakkaya/ferret.svg"/></p><p>
The latest sources are available at,
</p>

<ul>
<li><a href="https://github.com/nakkaya/ferret">Github</a>
</li>
</ul>

<p>
Dependencies,
</p>

<ul>
<li>make
</li>
<li>Java
</li>
<li>Emacs (&gt;= 24.5)
</li>
<li>Leiningen
</li>
</ul>

<p>
Assuming all of the above is in your path just run,
</p>

<pre>make
</pre>

<p>
This will extract the source from <code>ferret.org</code> file to current directory and
build the <code>jar</code> and <code>executable</code> distributions to <code>bin/</code>
directory. <code>Makefile</code> assumes it is running on a <code>*NIX</code> based system
if not, open <code>ferret.org</code> file using <code>emacs</code> and run,
</p>

<pre>M-x org-babel-tangle
</pre>

<p>
that will extract the source code then you can threat it as any other
Clojure/Lein project. Documentation can be built using,
</p>

<pre>make docs
</pre>

<p>
Unit tests can be run using,
</p>

<pre>make test
</pre>

<p>
A release can be made by running,
</p>

<pre>make docker-release
</pre>

<p>
This will compile <code>ferret</code> run unit tests against all supported
compilers/frameworks and generate a <code>release/</code> folder containing
deployment files.
</p>
</div>
</div>

<div id="outline-container-sec-2-6">
<h3 id="sec-2-6">License</h3>
<div id="text-2-6">
<p>
BSD 2-Clause License
</p>

<p>
Copyright (c) 2019, Nurullah Akkaya
All rights reserved.
</p>

<p>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
</p>

<ul>
<li>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
</li>

<li>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
</li>
</ul>

<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3">
<h2 id="sec-3">Compiler</h2>
<div id="text-3">
<p>
Ferret has a similar architecture to other modern compilers,
</p>


<div id="fig:compiler_architecture">
<p><img src="https://ferret-lang.org/ferret-styles/graphs/compiler_arch.png" alt="compiler_arch.png"/>
</p>
<p><span>Figure 1:</span> Ferret Compiler Architecture</p>
</div>

<p>
First, an input file containing Ferret code is loaded from the
command line. From there a series of source-to-source transformations
are performed on the AST to expand macros, perform optimizations, and
make the code easier to compile to C++. (Optionally these intermediate
representations (IR) can be printed out in a readable format to aid
debugging.) The final AST is then output as a .cpp file and the C++
compiler is invoked to create the final executable or object file.
</p>
</div>

<div id="outline-container-sec-3-1">
<h3 id="sec-3-1">Compilation</h3>
<div id="text-3-1">
<p>
Ferret (or any other Lisp) has features not provided by C++ such as
automatic memory management i.e. garbage collection (GC), closures
etc. Source-to-source transformations are used to add constructs
required by C++, restructure Ferret forms in preparation to generate
C++ code. Final intermediate representation can be directly compiled
to C++. Any Ferret form go through nine transformations before they
are passed to the code generation phase. Each transformation makes a
separate pass over the form, this makes the compiler easier to
maintain.
</p>

<div>

<pre>(<span>defn</span> <span>compile</span> [form options]
  (<span>-&gt;&gt;</span> (ferret-runtime options form)
       (remove-assertions options)
       (expand-macros)
       (let-&gt;fn)
       (do-&gt;fn)
       (fn-&gt;lift)
       (fn-&gt;inline options)
       (escape-analysis)
       (symbol-conversion)))
</pre>
</div>
</div>

<div id="outline-container-sec-3-1-1">
<h4 id="sec-3-1-1">Modules</h4>
<div id="text-3-1-1">
<p>
Supported <code>require</code> forms for importing modules,
</p>

<div>

<pre>(<span>require</span> &#39;package.io)

(<span>require</span> &#39;[package.io <span>:as</span> io])

(<span>require</span> &#39;[package.io <span>:as</span> io]
         &#39;[package.udp <span>:as</span> udp])
</pre>
</div>

<p>
Helper functions or variables in modules that should not be exposed
outside the namespace can be defined using the following form,
</p>

<div>

<pre>(<span>def</span> <span>^</span>{<span>:private</span> true}  helper-var <span>:value</span>)

(<span>defn</span> <span>^</span>{<span>:private</span> true} helper-fn [] 42)
</pre>
</div>

<p>
If a file named <code>deps.clj</code> is found on the same path as the input
file. Modules listed in it can be downloaded using <code>--deps</code> CLI
argument.
</p>

<div>

<pre><span>;;</span><span>deps.clj</span>
(git <span>:url</span>    <span>&#34;https://github.com/nakkaya/ferret-opencv.git&#34;</span>)

(git <span>:url</span>    <span>&#34;https://github.com/nakkaya/ferret-mosquitto.git&#34;</span>
     <span>:commit</span> <span>&#34;8c8c0890194a0b98130a3d4d78b71c99b833b12a&#34;</span>)
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>checkout-deps</span> [path]
  (<span>when</span> (io/file-exists (<span>str</span> path <span>&#34;/deps.clj&#34;</span>))
    (<span>let</span> [deps (<span>-&gt;</span> (read-clojure-file <span>&#34;deps.clj&#34;</span>)
                   (parser/<span>peek</span> (parser/form? &#39;git)))
          deps (<span>map</span> (<span>fn</span> [[_ &amp; kvs]] (<span>apply</span> hash-map kvs)) deps)]
      (<span>doseq</span> [{url <span>:url</span> commit <span>:commit</span>} deps]
        (<span>let</span> [folder (<span>str</span> path (jgit-util/name-from-uri url))]
          (info <span>&#34;dep =&gt;&#34;</span> url)
          (<span>when</span> (io/file-exists folder)
            (org.apache.commons.io.FileUtils/deleteDirectory
             (java.io.File. folder)))
          (<span>let</span> [repo (jgit/git-clone-full
                      url (org.apache.commons.io.FilenameUtils/normalize folder))]
            (jgit/git-checkout (<span>:repo</span> repo)
                               (<span>if</span> commit
                                 commit
                                 <span>&#34;master&#34;</span>))))))))
</pre>
</div>

<p>
Compiler will look for a file under current working directory called,
<code>package/io.clj</code> all expression in the that file will be added to the
front of the current form with symbols renamed from <code>some-fn</code> to
<code>io/some-function</code>.
</p>

<div>

<pre>(<span>defn</span> <span>import-modules-select-require</span> [form]
  (<span>let</span> [norm-require (<span>fn</span> [f]
                       (<span>if</span> (<span>symbol?</span> f)
                         [f <span>:as</span> f]
                         f))]
    (<span>-&gt;&gt;</span> (parser/<span>peek</span> form (parser/form? &#39;require))
         (<span>reduce</span> (<span>fn</span>[h v]
                   (<span>if</span> (<span>=</span> 2 (<span>count</span> v))
                     <span>;; </span><span>require single module</span>
                     (<span>conj</span> h (norm-require (<span>-&gt;&gt;</span> v last last)))
                     <span>;; </span><span>require multiple modules</span>
                     (<span>concat</span> h (<span>map</span> #(norm-require (<span>last</span> %)) (<span>rest</span> v))))) [])
         (<span>map</span> (<span>fn</span> [[mod _ as]] [mod as]))
         (<span>reduce</span> (<span>fn</span>[h [mod as]]
                   (<span>if</span> (h mod)
                     (<span>assoc</span> h mod (<span>conj</span> (h mod) as))
                     (<span>assoc</span> h mod [as]))) {}))))
</pre>
</div>

<p>
Extract the list of packages and aliases from the form. Returns a map
of <code>mod / aliases</code> pairs.
</p>

<div>

<pre>(<span>defn</span> <span>import-modules-load-modules</span> [package-list options]
  (<span>-&gt;&gt;</span> package-list
       (<span>reduce</span> (<span>fn</span>[h [m aliases]]
                 (<span>let</span> [file-name      (<span>str</span> (.replace (<span>str</span> m) <span>&#34;.&#34;</span> <span>&#34;/&#34;</span>) <span>&#34;.clj&#34;</span>)
                       mod            (<span>-&gt;</span> (<span>if</span> (clojure.java.io/resource file-name)
                                            file-name
                                            (<span>str</span> (<span>:path</span> options) file-name))
                                          (read-clojure-file)
                                          (parser/<span>drop</span> (parser/form? &#39;configure-runtime!))
                                          (parser/<span>drop</span> (parser/form? &#39;configure-ferret!)))
                       macro-symbols  (<span>-&gt;&gt;</span> (parser/<span>peek</span> mod (parser/form? &#39;defmacro))
                                           (<span>map</span> second)
                                           (<span>into</span> #{}))
                       def-symbols    (<span>-&gt;&gt;</span> (parser/<span>peek</span> (expand-macros mod) (parser/form? &#39;def))
                                           (<span>map</span> second)
                                           (<span>into</span> #{}))
                       replace?       (set/<span>union</span> macro-symbols def-symbols)
                       mod            (parser/transform
                                       mod
                                       #(<span>and</span> (<span>symbol?</span> %)
                                             (replace? %))
                                       #(parser/new-symbol m <span>&#34;_&#34;</span> %))]
                   (<span>reduce</span> (<span>fn</span> [h v] (<span>conj</span> h v)) h mod)))
               [])
       lazy-seq))
</pre>
</div>

<p>
Loads all modules listed in the package list. When a module is loaded
all its symbols are replaced with its module name except <code>core</code>
functions. Module names acts as namespaces. Returns a form that the is
concatenation of all modules listed in form.
</p>

<div>

<pre>(<span>defn</span> <span>import-modules-convert-alias-to-module</span> [package-list form]
  (<span>let</span> [alias-to-mod (<span>reduce</span> (<span>fn</span>[h [mod aliases]]
                               (<span>reduce</span> (<span>fn</span>[h v] (<span>assoc</span> h v mod)) h aliases))
                             {} package-list)]
    (parser/transform form symbol?
                      (<span>fn</span> [f]
                        (<span>if-let</span> [[_ alias fn] (<span>re-find</span> #<span>&#34;(.*?)/(.*)&#34;</span> (<span>str</span> f))]
                          (<span>if-let</span> [mod-sym (alias-to-mod (<span>symbol</span> alias))]
                            (parser/new-symbol mod-sym <span>&#34;_&#34;</span> fn)
                            f)
                          f)))))
</pre>
</div>

<p>
Convert all aliased symbols in the form to their fully qualified
modules names. So <code>helper-a</code> defined in module <code>util.db</code> becomes
<code>util_db_helper-a</code>.
</p>

<div>

<pre>(<span>defn</span> <span>import-modules</span> [form options]
  (<span>let</span> [package-list (import-modules-select-require form)
        form         (parser/<span>drop</span> form (parser/form? &#39;require))
        modules      (import-modules-load-modules package-list options)
        non-public?  (<span>-&gt;&gt;</span> modules
                          (<span>reduce</span> (<span>fn</span>[private-symbols mod]
                                    (<span>-&gt;</span> mod
                                        (parser/<span>peek</span> #(<span>and</span> (<span>symbol?</span> %)
                                                           (<span>-&gt;</span> % meta <span>:private</span>)))
                                        (<span>concat</span> private-symbols))) [])
                          (<span>into</span> #{}))
        form         (import-modules-convert-alias-to-module package-list form)
        violations   (parser/peek form #(non-public? %) #(zip/node (zip/<span>up</span> %)))]
    (<span>when</span> (<span>not</span> (<span>empty?</span> violations))
      (<span>doseq</span> [v violations]
        (warn <span>&#34;non-public-access =&gt;&#34;</span> v))
      (io/exit-failure))
    (shake-concat modules form)))

(<span>defn</span> <span>import-modules-all</span> [form options]
  (<span>loop</span> [f form]
    (<span>let</span> [expanded (import-modules f options)]
      (<span>if</span> (<span>=</span> f expanded)
        expanded
        (<span>recur</span> expanded)))))
</pre>
</div>

<p>
Generates the required runtime for the form by importing the required
modules and concatenate the required runtime from <a href="#sec-5">Core</a>.
</p>

<div>

<pre>(<span>defn</span> <span>ferret-runtime</span> [options form]
  (<span>-&gt;&gt;</span> (<span>-&gt;</span> form
           (import-modules-all options)
           (expand-reader-macros))
       (shake-concat (read-clojure-file <span>&#34;ferret/core.clj&#34;</span>))
       <span>;; </span><span>tag form with the build info</span>
       (<span>cons</span> `(~&#39;native-define ~(<span>try</span>
                                  (<span>let</span> [version (io/read-file-from-url <span>&#34;build.info&#34;</span>)]
                                    (<span>str</span> <span>&#34;// ferret-lisp &#34;</span> version))
                                  (<span>catch</span> Exception e
                                    (<span>str</span> <span>&#34;// ferret-lisp&#34;</span>)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-2">
<h4 id="sec-3-1-2">Macros</h4>
<div id="text-3-1-2">
<p>
Process some supported reader macros, <code>@</code> and <code>#(some-fn)</code> and convert
<code>map</code> reader forms to Ferret <code>d-list</code>.  Maps are zero or more
key/value pairs enclosed in braces: <code>{:a 1 :b 2}</code>.
</p>

<div>

<pre>(<span>defn</span> <span>expand-reader-macros</span> [form]
  (<span>-&gt;</span> form
      (parser/transform
       (parser/form? &#39;clojure.core/<span>deref</span>)
       (<span>fn</span> [f] (<span>cons</span> &#39;deref (<span>rest</span> f))))
      (parser/transform
       map?
       (<span>fn</span> [x]
         (<span>-&gt;&gt;</span> (<span>seq</span> x)
              (<span>reduce</span>
               (<span>fn</span>[h [k v]]
                 (<span>conj</span> h k v)) [])
              (<span>seq</span>)
              (<span>cons</span> &#39;fir-new-map))))))
</pre>
</div>

<p>
Prepare form <code>f</code> for macro expansion,
</p>

<div>

<pre>(<span>defn</span> <span>macro-normalize</span> [f]
  (parser/transform f
                    (parser/form? &#39;let)
                    (<span>fn</span> [[_ bindings &amp; body]]
                      `(~&#39;let* ~(<span>apply</span> list bindings) <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="522c12303d362b">[email protected]</a>))))
</pre>
</div>

<p>
Macro expansion is done by reading all the macros present in
<code>src/lib/ferret/core.clj</code> and combining them with user defined macros. They
are evaluated in a temporary namespace, using <code>parser/transform</code> we iterate
all the macros used in the code that we are compiling and expand them
in the temporary namespace then the node is replaced with its expanded
form.
</p>

<div>

<pre>(<span>defn</span> <span>expand-macros-single</span> [form]
  (<span>let</span> [core-macros (<span>-&gt;&gt;</span> (read-clojure-file <span>&#34;ferret/core.clj&#34;</span>)
                         (<span>filter</span> (parser/form? &#39;defmacro)))
        core-macro-symbols (<span>into</span> #{} (<span>map</span> second core-macros))
        form-macros (<span>-&gt;&gt;</span> (<span>filter</span> (parser/form? &#39;defmacro) form)
                         (<span>filter</span> (<span>fn</span> [[_ name]]
                                   (<span>not</span> (core-macro-symbols name)))))
        form-macro-symbols (<span>map</span> second form-macros)
        form (parser/<span>drop</span> form (parser/form? &#39;defmacro))
        temp-ns (<span>gensym</span>)
        macro-symbols (<span>concat</span> core-macro-symbols form-macro-symbols)]

    (<span>create-ns</span> temp-ns)
    (<span>binding</span> [*ns* (<span>the-ns</span> temp-ns)]
      (<span>refer</span> &#39;clojure.core <span>:exclude</span> (<span>concat</span> macro-symbols [&#39;fn &#39;def]))
      (<span>use</span> &#39;[compiler.io <span>:only</span> [exit-failure]])
      (<span>use</span> &#39;[compiler.core <span>:only</span> [symbol-conversion]])
      (<span>use</span> &#39;[compiler.parser <span>:only</span> [new-fir-fn]])

      (<span>doseq</span> [m (<span>concat</span> core-macros form-macros)]
        (<span>eval</span> m)))

    (<span>let</span> [form (<span>-&gt;</span> form
                   (macro-normalize)
                   (expand-reader-macros)
                   (parser/transform
                    (<span>fn</span> [f]
                      (<span>some</span> true? (<span>map</span> #(parser/form? % f) macro-symbols)))
                    (<span>fn</span> [f]
                      (<span>binding</span> [*ns* (<span>the-ns</span> temp-ns)]
                        (<span>-&gt;</span> (walk/<span>macroexpand-all</span> f)
                            <span>;;</span><span>strip ns from symbols</span>
                            (parser/transform symbol? #(<span>-&gt;</span> % name symbol)))))))]
      (<span>remove-ns</span> temp-ns)
      form)))

(<span>defn</span> <span>expand-macros-aux</span> [form]
  (<span>loop</span> [f form]
    (<span>let</span> [expanded (expand-macros-single f)]
      (<span>if</span> (<span>=</span> f expanded)
        expanded
        (<span>recur</span> expanded)))))

(<span>def</span> <span>expand-macros</span> (<span>memoize</span> expand-macros-aux))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-3">
<h4 id="sec-3-1-3">let-&gt;fn</h4>
<div id="text-3-1-3">
<p>
<code>let</code> forms are transformed into nested functions which are then
called immediately, bindings are setup in the outer function,
expressions are placed in the inner function which takes the bindings
as arguments.
</p>

<p>
So following form,
</p>

<div>

<pre>(let-&gt;fn &#39;(let* [a 1
                 b 2]
            (<span>+</span> a b)))
</pre>
</div>

<p>
after transformation becomes,
</p>

<div>

<pre>((fn* [a__1548] ((fn* [b__1549] (<span>+</span> a__1548 b__1549)) 2)) 1)
</pre>
</div>

<div>

<pre>(<span>deftest</span> let-test
  (<span>let</span> [args (<span>list</span> <span>&#34;1&#34;</span> <span>&#34;2&#34;</span>)]
    (<span>is</span> (<span>=</span> args (<span>rest</span> *command-line-args*))))

  (<span>let</span> [a 1]
    (<span>is</span> (<span>=</span> 1 a)))

  (<span>let</span> [a 1
        a 3]
    (<span>is</span> (<span>=</span> 3 a)))

  (<span>let</span> [a 1
        b 2]
    (<span>is</span> (<span>=</span> 3 (<span>+</span> a b))))

  (<span>let</span> [a 1
        b 2
        c 3]
    (<span>is</span> (<span>=</span> 6 (<span>+</span> a b c))))

  (<span>let</span> [a 1
        b 2]
    (<span>let</span> []
      (<span>is</span> (<span>=</span> 3 (<span>+</span> a b)))))

  (<span>let</span> [x 42]
    (<span>defn</span> <span>let-over-lambda</span> [] x))

  (<span>is</span> (<span>=</span> 42 (let-over-lambda))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>let-closure</span> [bindings body]
  (<span>if</span> (<span>empty?</span> bindings)
    `((~&#39;fir-let-fn () <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="7907391b161d00">[email protected]</a>))
    (<span>apply</span>
     (<span>fn</span> <span>close</span> [[arg val] &amp; more]
       (<span>if</span> (<span>empty?</span> more)
         `((~&#39;fir-let-fn [~arg] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="9ce2dcfef3f8e5">[email protected]</a>) ~val)
         `((~&#39;fir-let-fn [~arg] ~(<span>apply</span> close more)) ~val)))
     (<span>partition</span> 2 bindings))))

(<span>defn</span> <span>let-assert</span> [bindings body]
  (<span>when</span> (<span>odd?</span> (<span>count</span> bindings))
    (warn
     (<span>str</span> <span>&#34;let requires an even number of forms in binding vector =&gt; &#34;</span> bindings))
    (io/exit-failure)))

(<span>defn</span> <span>let-&gt;fn</span> [form]
  (<span>-&gt;</span> form

      (parser/transform (parser/form? &#39;let*)
                        (<span>fn</span> [[_ bindings &amp; body]]
                          (let-assert bindings body)
                          (let-closure bindings body)))

      (parser/transform (parser/form? &#39;fir-let-fn)
                        (<span>fn</span> [[_ args &amp; body]]
                          (parser/new-fir-fn <span>:args</span> args <span>:body</span> body)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-4">
<h4 id="sec-3-1-4">do-&gt;fn</h4>
<div id="text-3-1-4">
<p>
A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.
</p>





<div>

<pre>(<span>defn</span> <span>do-&gt;fn</span> [form]
  (parser/transform form
                    (parser/form? &#39;do)
                    (<span>fn</span> [f] `(~(parser/new-fir-fn <span>:body</span> (<span>rest</span> f))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-5">
<h4 id="sec-3-1-5">fn-&gt;lift</h4>
<div id="text-3-1-5">
<p>
<code>fn-&gt;lift</code> handles the problem of free variables. Free
variables passed to a nested function must be captured in a closure so
they can be referenced at runtime. The closure conversion
transformation modifies function definitions as necessary to create new
closures.
</p>

<div>

<pre>(<span>defn</span> <span>make-adder</span> [x]
  (<span>fn</span> [n] (<span>+</span> x n)))

(<span>def</span> <span>adder</span>
  (make-adder 1))

(<span>def</span> <span>fibo</span>
  (<span>fn</span> [n]
    (<span>if</span> (<span>&lt;</span> n 2)
      1
      (<span>+</span> (fibo (<span>-</span> n 1))
         (fibo (<span>-</span> n 2))))))

(<span>deftest</span> fn-&gt;list-test
  (<span>is</span> (<span>=</span> 10 (adder 9)))
  (<span>is</span> (<span>=</span> 89 (fibo 10))))
</pre>
</div>

<p>
in the above snippet <code>x</code> is a free variable, when the function
<code>make-adder</code> returns, it needs to have a way of referencing that
variable when it is used. The way Ferret handles this is that, every
function will pass its arguments to inner functions (if any) it
contains.
</p>

<div>

<pre>(fn-&gt;lift &#39;(fn* [x]
                (fn* [n] (<span>+</span> x n))))
</pre>
</div>

<p>
Above form will be converted to,
</p>

<div>

<pre>(fir-defn-heap G__1333  (x) (n)  (<span>+</span> x n))
(fir-defn-heap G__1334  ()  (x)  (fir-fn-heap G__1333 x))
(fir-fn-heap G__1334)
</pre>
</div>

<p>
What this means is, define a functor named <code>G__3154</code> that holds a
reference to <code>x</code>, and another functor <code>G__1334</code> that has no
state. When we create an instance of <code>G__1333</code> we pass <code>x</code> to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.
</p>

<div>

<pre>(<span>defn</span> <span>fn-defined?</span> [fns env args body]
  (<span>if-let</span> [fn-name (@fns (<span>concat</span> [env args] body))]
    (<span>apply</span> list &#39;fir-fn-heap fn-name env)))

(<span>defn</span> <span>define-fn</span> [fns env name args body]
  (<span>let</span> [n (<span>if</span> name
            name
            (<span>gensym</span> <span>&#34;FN__&#34;</span>))]
    (<span>swap!</span> fns assoc (<span>concat</span> [env args] body) n)
    (<span>apply</span> list &#39;fir-fn-heap n env)))

(<span>defn</span> <span>fn-&gt;lift</span>
  ([form]
   (<span>let</span> [fns  (<span>atom</span> (ordered-map/ordered-map))
         form (fn-&gt;lift form fns)
         fns  (<span>map</span> (<span>fn</span> [[body name]] (<span>concat</span> [&#39;fir-defn-heap name] body)) @fns)]
     (<span>concat</span> fns form)))
  ([form fns &amp; [env]]
   (parser/transform
    form
    (parser/form? &#39;fn*)
    (<span>fn</span> [sig]
      (<span>let</span> [[name args body] (parser/split-fn sig)
            <span>;; </span><span>transform named recursion in body</span>
            body (<span>if</span> name
                   (parser/transform
                    body
                    (parser/form? name)
                    (<span>fn</span> [[_ &amp; args]]
                      (<span>cons</span>
                       (<span>apply</span> list &#39;fir-fn-heap name env)
                       args)))
                   body)
            body (fn-&gt;lift body fns (<span>concat</span> args env))
            symbols (parser/symbol-set body)
            env  (<span>-&gt;&gt;</span> (set/<span>intersection</span>
                       symbols
                       (<span>into</span> #{} (<span>flatten</span> env)))
                      (<span>into</span> ()))

            args (<span>if</span> (parser/ffi-fn?
                      (<span>filter</span> #(<span>not</span> (parser/form? &#39;native-declare %)) body))
                   args
                   (parser/transform args
                                     symbol?
                                     (<span>fn</span> [v]
                                       (<span>if</span> (<span>or</span> (<span>not</span> (parser/fn-arg-symbol? v))
                                               (symbols v))
                                         v &#39;_))))]
        (<span>if-let</span> [n (fn-defined? fns env args body)]
          n
          (define-fn fns env name args body)))))))
</pre>
</div>

<div>

<pre>(<span>deftest</span> test-fn-&gt;lift
  (<span>let</span> [prg-a (<span>compile</span> &#39;((<span>defn</span> <span>one-plus-one</span> []
                           (<span>+</span> 1 1))

                         (<span>while</span> true
                           (<span>+</span> 1 1))) {})
        prg-b (fn-&gt;lift
               &#39;(fn* outer [a]
                     (fn* inner-a [b]
                          (<span>+</span> a b))
                     (fn* inner-b [c] c)))

        prg-c (fn-&gt;lift
               &#39;((fn* inner-a [a]
                      ((fn* inner-b [b]
                            ((fn* inner-c [c] (<span>+</span> b c))
                             3))
                       2))
                 1))
        prg-d (fn-&gt;lift
               &#39;((fn* inner-a [a]
                      ((fn* inner-b [b]
                            ((fn* inner-c [c] (<span>+</span> b))
                             3))
                       2))
                 1))]
    <span>;;</span><span>while shoud use one-plus-one in its body</span>
    <span>;;</span><span>check fn-defined?</span>
    (<span>is</span> (<span>=</span> 2 (<span>count</span> (parser/<span>peek</span> prg-a (<span>fn</span> [f] (<span>=</span> &#39;one_plus_one f))))))

    (<span>is</span> (<span>=</span> 1 (<span>-&gt;&gt;</span> (<span>fn</span> [f] (<span>=</span> &#39;(fir-defn-heap inner-a (a) [b] (<span>+</span> a b)) f))
                  (parser/<span>peek</span> prg-b)
                  count)))
    (<span>is</span> (<span>=</span> 1 (<span>-&gt;&gt;</span> (<span>fn</span> [f] (<span>=</span> &#39;(fir-defn-heap inner-b () [c] c) f))
                  (parser/<span>peek</span> prg-b)
                  count)))
    (<span>is</span> (<span>=</span> 1 (<span>-&gt;&gt;</span> (<span>fn</span> [f] (<span>=</span> &#39;(fir-defn-heap inner-c (b) [c] (<span>+</span> b c)) f))
                  (parser/<span>peek</span> prg-c)
                  count)))
    (<span>is</span> (<span>=</span> 1 (<span>-&gt;&gt;</span> (<span>fn</span> [f] (<span>=</span> &#39;(fir-defn-heap inner-c (b) [_] (<span>+</span> b)) f))
                  (parser/<span>peek</span> prg-d)
                  count)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-6">
<h4 id="sec-3-1-6">Symbol Conversion</h4>
<div id="text-3-1-6">
<p>
Some symbols valid in lisp are not valid C++ identifiers. This
transformation converts all symbols that are not legal C++ identifiers
into legal ones.
</p>

<div>

<pre>(<span>defn</span> <span>escape-cpp-symbol</span> [s]
  (clojure.string/escape
   (<span>str</span> s)
   {\- \_ \* <span>&#34;_star_&#34;</span> \+ <span>&#34;_plus_&#34;</span> \/ <span>&#34;_slash_&#34;</span>
    \&lt; <span>&#34;_lt_&#34;</span> \&gt; <span>&#34;_gt_&#34;</span> \= <span>&#34;_eq_&#34;</span> \? <span>&#34;_QMARK_&#34;</span>
    \! <span>&#34;_BANG_&#34;</span> \# <span>&#34;_&#34;</span>}))

(<span>defn</span> <span>symbol-conversion</span> [form]
  (<span>let</span> [c (<span>comp</span> #(<span>symbol</span> (escape-cpp-symbol %))
                #(<span>cond</span> (<span>=</span> &#39;not %) &#39;_not_
                       <span>:default</span> %))]
    (parser/transform form symbol? c)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-7">
<h4 id="sec-3-1-7">Remove Assertions</h4>
<div id="text-3-1-7">
<div>

<pre>(<span>defn</span> <span>remove-assertions</span> [options form]
  (<span>if</span> (<span>:release</span> options)
    (<span>do</span> (info <span>&#34;option =&gt; release mode&#34;</span>)
        (parser/<span>drop</span> form (parser/form? &#39;assert)))
    form))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-8">
<h4 id="sec-3-1-8">Optimizations</h4>
<div id="outline-container-sec-3-1-8-1">
<h5 id="sec-3-1-8-1">Inline Functions</h5>
<div id="text-3-1-8-1">
<p>
This optimization trades memory for performance. When a global
variable pointing to a function is defined, memory for that function
is allocated at the start of the program and never released until
program exits even if the said function is called only once in the
program. In order to keep the memory usage low Ferret will replace all
functions calls with new function objects. So every time a function is
called a new function object is created used and released. If
performance is more important than memory usage this optimization can
be disabled using compiler option <code>--global-functions</code>. This
optimization can be turned of on a per <code>def</code> basis by setting the
metadata of the object to <code>^volatile</code> <code>true</code>,
</p>

<div>

<pre>(<span>defn</span> <span>^volatile</span> no-inline [] 42)
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>inline-defn?</span> [f]
  (<span>and</span> (parser/form? &#39;def f)
       (<span>-&gt;</span> f second meta <span>:tag</span> (<span>not=</span> &#39;volatile))
       (parser/form? &#39;fir-fn-heap
                     (<span>-&gt;&gt;</span> f (<span>drop</span> 2) first))))

(<span>defn</span> <span>fn-&gt;inline</span> [options form]
  (<span>if</span> (<span>:global-functions</span> options)
    form
    (<span>let</span> [defns      (<span>-&gt;&gt;</span> (parser/<span>peek</span> form inline-defn?)
                          (<span>filter</span> #(<span>=</span> 2 (<span>-&gt;</span> % last count))))
          fn-table   (<span>map</span> (<span>fn</span> [[_ name [_ gensym]]] [name gensym]) defns)
          impl-table (<span>apply</span> hash-map (<span>flatten</span> fn-table))
          defn?      (<span>fn</span> [f]
                       (<span>and</span> (inline-defn? f)
                            (impl-table (<span>second</span> f))))
          invoke     #(<span>if-let</span> [imp (impl-table %)]
                        (<span>list</span> &#39;fir-fn-heap imp)
                        %)
          no-defn    (<span>reduce</span> (<span>fn</span>[h v] (parser/<span>drop</span> h defn?)) form defns)
          inlined    (<span>reduce</span> (<span>fn</span>[h [name gensym]]
                               (parser/transform h
                                                 #(<span>or</span> (parser/form? name %)
                                                      (parser/form? &#39;def %))
                                                 (<span>fn</span> [f] (<span>map</span> invoke f))))
                             no-defn fn-table)]
      (<span>reduce</span> (<span>fn</span>[h [name gensym]]
                (parser/transform h #(<span>and</span> (<span>symbol?</span> %)
                                          (<span>=</span> % gensym))
                                  (<span>fn</span> [_] (<span>identity</span> name))))
              inlined fn-table))))
</pre>
</div>

<div>

<pre>(<span>deftest</span> test-fn-&gt;inline
  (<span>let</span> [prg-a (<span>compile</span> &#39;((<span>defn</span> <span>fn-inline</span> [x] x)
                         (<span>defn</span> <span>^volatile</span> fn-no-inline [y] y)
                         (fn-inline 42)
                         (fn-no-inline 42)) {})]
    (<span>is</span> (<span>=</span> 1 (<span>-&gt;&gt;</span> (<span>fn</span> [f] (<span>=</span> &#39;(fn_no_inline 42) f))
                  (parser/<span>peek</span> prg-a)
                  count)))
    (<span>is</span> (<span>=</span> 1 (<span>-&gt;&gt;</span> (<span>fn</span> [f] (<span>=</span> &#39;((fir_fn_stack fn_inline) 42) f))
                  (parser/<span>peek</span> prg-a)
                  count)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-8-2">
<h5 id="sec-3-1-8-2">Tree Shaking</h5>
<div id="text-3-1-8-2">
<p>
Concats two forms. Shakes the first form by removing any symbols not
present in second form.
</p>

<p>
In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don&#39;t
use <code>println</code> anywhere in the code it won&#39;t be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of <code>println</code> it will pull <code>apply</code>, <code>print</code> and
<code>newline</code> with it.
</p>

<div>

<pre>(<span>defn</span> <span>shake-concat</span>
  ([header form]
   (<span>let</span> [shakeable? (<span>fn</span> [f]
                      (<span>or</span> (parser/form? &#39;defn f)
                          (parser/form? &#39;defnative f)))
         header-symbols (<span>-&gt;&gt;</span> (parser/<span>peek</span> header seq?)
                             (parser/symbol-set))
         header-fns (<span>-&gt;&gt;</span> (parser/<span>peek</span> header shakeable?)
                         (<span>map</span> #(<span>vector</span> (<span>second</span> %) %))
                         (<span>into</span> {}))
         header-non-shakeable (parser/<span>drop</span> header shakeable?)
         form-expanded (expand-macros (<span>concat</span> header-non-shakeable form))
         fns (<span>atom</span> #{})
         _ (shake-concat form-expanded header-fns fns header-non-shakeable)
         header-shaked (parser/<span>drop</span> header (<span>fn</span> [f]
                                             (<span>and</span> (shakeable? f)
                                                  (<span>not</span> (@fns (<span>second</span> f))))))]
     (<span>concat</span> header-shaked form)))
  ([form built-in fns non-shakeable]
   (parser/transform form symbol?
                     #(<span>do</span>
                        (<span>if-let</span> [f (built-in %)]
                          (<span>when</span> (<span>not</span> (@fns %))
                            (<span>swap!</span> fns conj %)
                            (shake-concat (expand-macros (<span>concat</span> non-shakeable f))
                                          built-in fns non-shakeable))) %))))
</pre>
</div>

<div>

<pre>(<span>deftest</span> three-shaking
  (<span>is</span> (<span>=</span> &#39;((<span>defn</span> <span>c</span> [] 1)
           (<span>defn</span> <span>b</span> [] (c))
           (<span>defn</span> <span>a</span> [] (b))
           (a))
         (shake-concat &#39;((<span>defn</span> <span>no-call-a</span> [])
                         (defnative no-call-b [] (on <span>&#34;&#34;</span> <span>&#34;&#34;</span>))
                         (<span>defn</span> <span>c</span> [] 1)
                         (<span>defn</span> <span>b</span> [] (c))
                         (<span>defn</span> <span>a</span> [] (b)))
                       &#39;((a)))))

  (<span>is</span> (<span>=</span> &#39;((<span>defn</span> <span>y</span> [])
           (<span>let</span> [a 1]
             (<span>defn</span> <span>b</span> []))
           (<span>println</span> (b) (y)))
         (shake-concat &#39;((<span>defn</span> <span>x</span> [] )
                         (<span>defn</span> <span>y</span> [] )
                         (<span>let</span> [a 1]
                           (<span>defn</span> <span>b</span> [] )
                           (<span>defn</span> <span>c</span> [] a)))
                       &#39;((<span>println</span> (b) (y))))))

  (<span>is</span> (<span>=</span> &#39;((<span>defn</span> <span>p-create</span> []) (<span>defn</span> <span>p-update</span> []))
         (<span>take</span> 2 (shake-concat &#39;((<span>defn</span> <span>p-create</span> [])
                                 (<span>defn</span> <span>p-update</span> [])
                                 (<span>defmacro</span> <span>pc</span> [&amp; options]
                                   `(<span>let</span> [controller# (p-create)]
                                     (<span>fn</span> [input#] (p-update)))))
                               &#39;((pc))))))

  (<span>is</span> (<span>=</span> &#39;(<span>defn</span> <span>new-lazy-seq</span> [f] )
         (<span>first</span> (shake-concat &#39;((<span>defn</span> <span>new-lazy-seq</span> [f] )
                                (<span>defmacro</span> <span>lazy-seq</span> [&amp; body]
                                  `(new-lazy-seq (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="f886b89a979c81">[email protected]</a>)))
                                (<span>defn</span> <span>range</span>
                                  ([high]
                                   (<span>range</span> 0 high))
                                  ([low high]
                                   (<span>if</span> (<span>&lt;</span> low high)
                                     (<span>cons</span> low (<span>lazy-seq</span>
                                                (<span>range</span> (<span>inc</span> low) high)))))))
                              &#39;((<span>range</span> 10)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-8-3">
<h5 id="sec-3-1-8-3">Escape Analysis</h5>
<div id="text-3-1-8-3">
<p>
Determines that a certain allocation never escapes the local
function. This means that allocation can be done on the stack.
</p>

<div>

<pre>(<span>defn</span> <span>escape-analysis</span> [form]
  (<span>-&gt;&gt;</span> form
       (escape-fn-calls)
       (escape-fn-inheritance)))
</pre>
</div>

<div>

<pre>(<span>deftest</span> test-escape-analysis
  (<span>let</span> [prg-a (<span>compile</span> &#39;((<span>defn</span> <span>self</span> [x] x)
                         (self 42)) {})
        prg-b (<span>compile</span> &#39;((<span>defn</span> <span>self</span> [x] x)
                         (self self)) {})

        prg-c (<span>compile</span> &#39;((<span>defn</span> <span>multi</span> ([x] x))) {})]

    (<span>is</span> (<span>not</span> (<span>empty?</span> (parser/<span>peek</span> prg-a (parser/form? &#39;fir_defn_stack)))))
    (<span>is</span> (<span>not</span> (<span>empty?</span> (parser/<span>peek</span>
                      prg-a (<span>fn</span> [f] (<span>=</span> &#39;(fir_fn_stack self) f))))))

    (<span>is</span> (<span>not</span> (<span>empty?</span> (parser/<span>peek</span> prg-b (parser/form? &#39;fir_defn_heap)))))
    (<span>is</span> (<span>not</span> (<span>empty?</span> (parser/<span>peek</span>
                      prg-b (<span>fn</span> [f] (<span>=</span> &#39;((fir_fn_stack self) (fir_fn_heap self)) f))))))

    (<span>is</span> (<span>=</span> (<span>-&gt;&gt;</span> (parser/<span>peek</span> prg-c (parser/form? &#39;fir_defn_arity))
                first second first second second)
           (<span>-&gt;&gt;</span> (parser/<span>peek</span> prg-c (parser/form? &#39;fir_defn_stack)) first second)))))
</pre>
</div>
</div>

<div id="outline-container-sec-3-1-8-3-1">
<h6 id="sec-3-1-8-3-1">Function Calls</h6>
<div id="text-3-1-8-3-1">
<p>
Some function calls can be optimized away depending on the following
heuristics. User programs has no access to dispatch functions used by
multi-arity functions. They can be safely escaped and replaced by the
stack allocated versions. If dispatch functions can be resolved in
compile time they will be replaced. By default Ferret assumes all
functions can escape their scope and they are allocated on the
heap. Functions proven to not escape their scope are replaced with
stack allocated functions.
</p>

<div>

<pre>(<span>defn</span> <span>escape-fn-calls</span> [form]
  (<span>let</span> [arity (parser/<span>peek</span>
               form
               (<span>fn</span> [f]
                 (<span>and</span> (parser/form? &#39;fir-defn-heap f)
                      (<span>-&gt;</span> (parser/<span>peek</span> f (parser/form? &#39;fir-defn-arity))
                          (<span>empty?</span>)
                          (<span>not</span> )))))
        arity (<span>reduce</span>
               (<span>fn</span> [h [_ name _ _ [_ dispatch [_ default]] <span>:as</span> form]]
                 (<span>let</span> [jmp (<span>if</span> default
                             {<span>:default</span> default}
                             {})
                       jmp (<span>reduce</span> (<span>fn</span>[h [arity [_ call]]]
                                     (<span>assoc</span> h arity call))
                                   jmp dispatch)]
                   (<span>assoc</span> h name jmp)))
               {} arity)
        arity-renames (<span>reduce</span> (<span>fn</span> [h [name jmps]]
                                (<span>reduce</span>
                                 (<span>fn</span> [h jump]
                                   (<span>assoc</span> h jump (<span>gensym</span> (<span>str</span> name <span>&#34;__&#34;</span>))))
                                 h (<span>vals</span> jmps)))
                              {} arity)]
    (<span>-&gt;</span> form
        <span>;; </span><span>resolve arity calls</span>
        (parser/transform
         (parser/form? &#39;fir-defn-arity)
         (<span>fn</span> [f]
           (parser/transform f
                             (parser/form? &#39;fir-fn-heap)
                             (<span>fn</span> [[_ &amp; f]]
                               `(~&#39;fir-fn-stack <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="3d437d5b">[email protected]</a>)))))
        (parser/transform
         (<span>fn</span> [f]
           (<span>and</span> (<span>seq?</span> f)
                (parser/form? &#39;fir-fn-heap (<span>first</span> f))
                (arity (<span>-&gt;</span> f first second))))
         (<span>fn</span> [f]
           (<span>let</span> [[[_ fn] &amp; args] f
                 dispatch ((arity fn) (<span>count</span> args))
                 default  ((arity fn) <span>:default</span>)]
             (<span>cond</span> dispatch `((~&#39;fir-fn-heap ~dispatch) <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="6e102e0f1c091d">[email protected]</a>)
                   default  `((~&#39;fir-fn-heap ~default)  <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="7c023c1d0e1b0f">[email protected]</a>)
                   <span>:default</span> f))))
        (parser/transform
         (<span>fn</span> [f]
           (<span>and</span> (<span>symbol?</span> f)
                (arity-renames f)))
         (<span>fn</span> [f]
           (arity-renames f)))
        <span>;; </span><span>resolve fn calls</span>
        (parser/transform
         (<span>fn</span> [f]
           (<span>and</span> (<span>seq?</span> f)
                (parser/form? &#39;fir-fn-heap (<span>first</span> f))))
         (<span>fn</span> [f]
           (<span>let</span> [[[_ &amp; fn] &amp; args] f]
             `((~&#39;fir-fn-stack <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="ceb08ea8a0">[email protected]</a>) <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="f886b8998a9f8b">[email protected]</a>)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-8-3-2">
<h6 id="sec-3-1-8-3-2">Function Inheritance</h6>
<div id="text-3-1-8-3-2">
<p>
Each Ferret <code>fn</code> generates a corresponding C++ class that extends a
Ferret Object. If a function can be proven to be only allocated on the
stack in all uses of the said function, it can be replaced with a C++
POD type. This saves program space since said function does not need
to inherit from a Ferret Object.
</p>

<div>

<pre>(<span>defn</span> <span>escape-fn-inheritance</span> [form]
  (<span>let</span> [heap-fns (<span>-&gt;&gt;</span> (parser/<span>peek</span> form (parser/form? &#39;fir-fn-heap))
                      (<span>map</span> second)
                      (<span>into</span> #{}))
        stack-fns (<span>-&gt;&gt;</span> (parser/<span>peek</span> form (parser/form? &#39;fir-fn-stack))
                       (<span>map</span> second)
                       (<span>into</span> #{}))
        escapeable-fns (set/<span>difference</span> stack-fns heap-fns)]
    (parser/transform form
                      (<span>fn</span> [f]
                        (<span>and</span> (<span>seq?</span> f)
                             (<span>=</span> (<span>first</span> f) &#39;fir-defn-heap)
                             (escapeable-fns (<span>second</span> f))))
                      (<span>fn</span> [[_ &amp; f]]
                        `(~&#39;fir-defn-stack <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="611f2107">[email protected]</a>)))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-9">
<h4 id="sec-3-1-9">Parser</h4>
<div id="text-3-1-9">
<p>
Ferret programs are read using the Clojure reader via <code>read-string</code>,
</p>

<div>

<pre>(<span>defn</span> <span>read-clojure-file</span> [f]
  (<span>let</span> [ns (<span>gensym</span>)
        ns-str (<span>str</span> ns)]
    (<span>create-ns</span> ns)
    (<span>binding</span> [*ns* (<span>the-ns</span> ns)]
      (<span>refer</span> &#39;clojure.core)
      (<span>-&gt;</span> (<span>read-string</span> (<span>str</span> \( (io/read-file f) \)))
          (parser/transform
           symbol?
           #(<span>if</span> (<span>=</span> (<span>namespace</span> %) ns-str)
              (<span>-&gt;</span> % name symbol)
              %))
          <span>;;</span><span>replace clojure.core/fn with fn</span>
          <span>;;</span><span>replace clojure.core/while with while</span>
          (parser/transform
           (<span>fn</span> [x]
             (<span>and</span> (parser/form? &#39;quote x)
                  (<span>or</span> (<span>=</span> &#39;clojure.core/fn    (<span>second</span> x))
                      (<span>=</span> &#39;clojure.core/defn  (<span>second</span> x))
                      (<span>=</span> &#39;clojure.core/<span>while</span> (<span>second</span> x)))))
           (<span>fn</span> [[_ s]] `&#39;~(<span>-&gt;</span> s name symbol)))))))
</pre>
</div>

<p>
Each transformation happens by walking over the program form. Forms
are selected using <code>form?</code> function.
</p>

<div>

<pre>(form? &#39;fn* &#39;(fn* [n] (<span>+</span> x n)))
<span>;; </span><span>true</span>
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>form?</span>
  ([s]
   #(form? s %))
  ([s f]
   (<span>and</span> (<span>seq?</span> f)
        (<span>=</span> (<span>first</span> f) s))))
</pre>
</div>

<p>
Returns the set of symbols used in the form.
</p>

<div>

<pre>(<span>defn</span> <span>symbol-set</span> [form]
  (<span>-&gt;&gt;</span> form flatten (<span>filter</span> symbol?) (<span>into</span> #{})))
</pre>
</div>

<p>
Splits a function form into compnents.
</p>

<div>

<pre>(<span>defn</span> <span>split-fn</span> [sig]
  (<span>let</span> [name (<span>if</span> (<span>symbol?</span> (<span>second</span> sig)) (<span>second</span> sig) nil)
        sig  (<span>if</span> name (clojure.core/<span>drop</span> 2 sig) (<span>rest</span> sig))
        [args &amp; body] sig]
    [name args body]))
</pre>
</div>

<p>
Predicate for checking if function body is a FFI call or not.
</p>

<div>

<pre>(<span>defn</span> <span>ffi-fn?</span> [body]
  (<span>and</span> (<span>not</span> (<span>nil?</span> body))
       (<span>not</span> (<span>empty?</span> body))
       (<span>-&gt;&gt;</span> (<span>map</span> string? body)
            (<span>every?</span> true?))))
</pre>
</div>

<p>
Predicate for checking if a symbol in <code>fn</code> arguments is a valid symbol
or not.
</p>

<div>

<pre>(<span>defn</span> <span>fn-arg-symbol?</span> [s]
  (<span>and</span> (<span>symbol?</span> s)
       (<span>not=</span> s &#39;&amp;)
       (<span>not=</span> s &#39;_)
       (<span>not=</span> s &#39;fir-destructure-associative)))
</pre>
</div>

<p>
During each pass we iterate over the nodes in the form using one of
three functions, <code>transform</code> , <code>drop</code> and <code>peek</code>. They
all take a s-expression and a predicate. If the predicate returns
true, <code>transform</code> will call <code>f</code> passing the current node as an argument
and replace that node with <code>f</code> &#39;s return value, <code>drop</code> on the
other hand does what its name suggests and removes the node when
predicate returns true. <code>peek</code> is used to peek at sections of
the form, does not alter the form only returns the list of nodes
matching the predicate.
</p>

<div>

<pre>(<span>defn</span> <span>transform</span> [tree pred f]
  (walk/<span>prewalk</span> (<span>fn</span> [form]
                  (<span>if</span> (pred form)
                    (<span>let</span> [new-form (f form)
                          meta (<span>meta</span> form)]
                      (<span>if</span> (<span>and</span> (<span>instance?</span> clojure.lang.IMeta form)
                               (<span>instance?</span> clojure.lang.IMeta new-form))
                        (<span>with-meta</span> new-form meta)
                        new-form))
                    form))
                tree))

(<span>defn</span> <span>drop</span> [tree pred]
  (<span>if</span> (<span>every?</span> true? (<span>map</span> #(pred %) tree))
    (<span>list</span> )
    (<span>loop</span> [loc (zip/<span>seq-zip</span> tree)]
      (<span>if</span> (zip/<span>end?</span> loc)
        (zip/<span>root</span> loc)
        (<span>recur</span>
         (zip/<span>next</span>
          (<span>if</span> (pred (zip/<span>node</span> loc))
            (zip/<span>remove</span> loc)
            loc)))))))

(<span>defn</span> <span>peek</span> [tree pred &amp; [node-fn]]
  (<span>let</span> [node-fn (<span>if</span> node-fn
                  node-fn
                  #(zip/<span>node</span> %))]
    (<span>loop</span> [loc (zip/<span>seq-zip</span> tree)
           nodes []]
      (<span>if</span> (zip/<span>end?</span> loc)
        nodes
        (<span>recur</span>
         (zip/<span>next</span> loc)
         (<span>if</span> (pred (zip/<span>node</span> loc))
           (<span>conj</span> nodes (node-fn loc))
           nodes))))))
</pre>
</div>

<p>
Takes a <b>fn</b> form and converts all argument symbols with their unique
replacements. This is needed because most lisp forms are represented
as <code>fn</code>&#39;s and some forms such as <code>let</code> need to be able to shadow
already defined variable names.
</p>

<div>

<pre>(<span>fn</span> [a b] (<span>list</span> a b))
<span>;;</span><span>becomes</span>
(<span>fn</span> [a__1510 b__1511] (<span>list</span> a__1510 b__1511))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>new-symbol</span> [&amp; parts]
  (<span>let</span> [parts (<span>map</span> #(.replace (<span>str</span> %) <span>&#34;.&#34;</span> <span>&#34;_&#34;</span>) parts)]
    (<span>symbol</span> (<span>apply</span> str parts))))

(<span>defn</span> <span>fn-make-unique</span> [args body]
  (<span>if</span> (<span>string?</span>  (<span>-&gt;&gt;</span> body
                     (<span>filter</span> #(<span>not</span> (form? &#39;native-declare %)))
                     first))
    [args body]
    (<span>let</span> [unique-args (<span>-&gt;&gt;</span> args
                           flatten
                           (<span>filter</span> fn-arg-symbol?)
                           (<span>map</span> #(new-symbol % (<span>gensym</span> <span>&#34;__&#34;</span>))))
          replace? (<span>-&gt;&gt;</span> (<span>interleave</span> (<span>-&gt;&gt;</span> args
                                         flatten
                                         (<span>filter</span> fn-arg-symbol?))
                                    unique-args)
                        (<span>apply</span> hash-map))
          body      (transform body #(replace? %) #(replace? %))
          replace?  (<span>merge</span> replace? {&#39;fir-new-map &#39;fir-destructure-associative})
          args      (transform args #(replace? %) #(replace? %))]
      [args body])))

(<span>defn</span> <span>new-fir-fn</span>
  ([&amp; {<span>:keys</span> [name args body escape] <span>:or</span> {escape  true
                                          args    []}}]
   (<span>let</span> [name-unique (<span>if</span> name
                       (new-symbol name (<span>gensym</span> <span>&#34;__&#34;</span>)))
         [args body] (<span>if</span> escape
                       (fn-make-unique args body)
                       [args body])
         body        (<span>if</span> name-unique
                       (transform body #(<span>=</span> % name) (<span>fn</span> [_] name-unique))
                       body)]
     (<span>if</span> name-unique
       `(fn* ~name-unique ~args <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="cdb38dafa2a9b4">[email protected]</a>)
       `(fn* ~args <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="2b556b49444f52">[email protected]</a>)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2">
<h3 id="sec-3-2">Code Generation</h3>
<div id="text-3-2">
<p>
The compiler&#39;s code generation phase takes a single pass over the
transformed lisp code and outputs C++ code. All Ferret modules and
the program code is amalgamated in to a single source file which
allows the generated code to be compiled as a single translation
unit.This allows many compilers to do optimization&#39;s that would not be
possible if the files were compiled separately. Code generation is
done by running <code>emit</code> on the final intermediate representation.
</p>

<div>

<pre>(<span>emit</span> options &#39;(<span>list</span> 1 2 3) (<span>ref</span> {}))
<span>;;</span><span>&#34;run(list,obj&lt;number&gt;(1),obj&lt;number&gt;(2),obj&lt;number&gt;(3))&#34;</span>

(<span>emit</span> options &#39;(<span>+</span> 1 2) (<span>ref</span> {}))
<span>;;</span><span>&#34;run(+,obj&lt;number&gt;(1),obj&lt;number&gt;(2))&#34;</span>

(<span>emit</span> options &#39;(<span>if</span> (<span>&lt;</span> a b)
                 b a)
              (<span>ref</span> {}))
<span>;;</span><span>&#34;((&lt;,b,a) ? a : b)&#34;</span>
</pre>
</div>

<div>

<pre>(<span>defmulti</span> <span>emit</span> (<span>fn</span> [_ f _]
                 (<span>cond</span> (parser/form? &#39;(fir_fn_stack list) f)   &#39;fir_inline_list
                       (parser/form? &#39;(fir_fn_stack first) f)  &#39;fir_inline_first
                       (parser/form? &#39;(fir_fn_stack rest) f)   &#39;fir_inline_rest
                       (parser/form? &#39;fir_defn_heap f)   &#39;fir_defn_heap
                       (parser/form? &#39;fir_defn_stack f)  &#39;fir_defn_stack
                       (parser/form? &#39;fir_defn_arity f)  &#39;fir_defn_arity
                       (parser/form? &#39;fir_fn_heap f)     &#39;fir_fn_heap
                       (parser/form? &#39;fir_fn_stack f)    &#39;fir_fn_stack
                       (parser/form? &#39;list f)            &#39;list
                       (parser/form? &#39;defobject f)       &#39;defobject
                       (parser/form? &#39;matrix f)          &#39;matrix
                       (parser/form? &#39;native_header f)   &#39;native_header
                       (parser/form? &#39;native_declare f)  &#39;native_declare
                       (parser/form? &#39;native_define f)   &#39;native_define
                       (parser/form? &#39;if f)              &#39;if
                       (parser/form? &#39;def f)             &#39;def
                       (parser/form? &#39;fir_new_map f)     &#39;fir_new_map
                       (<span>symbol?</span> f)                 <span>:symbol</span>
                       (<span>keyword?</span> f)                <span>:keyword</span>
                       (<span>number?</span> f)                 <span>:number</span>
                       (<span>nil?</span> f)                    <span>:nil</span>
                       (<span>char?</span> f)                   <span>:char</span>
                       (<span>string?</span> f)                 <span>:string</span>
                       (<span>instance?</span>
                        java.util.regex.Pattern f) <span>:regex-pattern</span>
                       (<span>or</span> (<span>true?</span> f) (<span>false?</span> f))   <span>:boolean</span>
                       (<span>seq?</span> f)                    <span>:invoke-fn</span>
                       <span>:default</span>                    <span>:unsupported-form</span>)))

(<span>defmethod</span> <span>emit</span> <span>:unsupported-form</span> [_ form _]
  (warn <span>&#34;unsupported form =&gt;&#34;</span> form)
  (io/exit-failure))

(<span>defn</span> <span>emit-ast</span> [options ast state]
  (<span>reduce</span> (<span>fn</span>[h v] (<span>conj</span> h (<span>emit</span> options v state))) [] ast))
</pre>
</div>

<p>
Code generation for a Ferret program is done by running <code>emit</code> on all
nodes of the program AST.
</p>

<div>

<pre>(<span>defn</span> <span>append-to!</span> [r ks v]
  (<span>let</span> [cv (<span>reduce</span> (<span>fn</span>[h v] (v h)) @r ks)]
    (<span>swap!</span> r assoc-in ks (<span>conj</span> cv v))
    <span>&#34;&#34;</span>))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>emit-source</span> [form options]
  (<span>let</span> [state (<span>atom</span> {<span>:native-headers</span> []
                     <span>:native-declarations</span> []
                     <span>:objects</span> []
                     <span>:symbol-table</span> #{}
                     <span>:lambdas</span> []
                     <span>:native-defines</span> []})
        ast (<span>compile</span> form options)
        body (emit-ast options ast state)]
    (<span>when</span> (<span>:ast</span> options)
      (pprint/pprint ast))
    (<span>assoc</span> @state <span>:body</span> body)))
</pre>
</div>
</div>

<div id="outline-container-sec-3-2-1">
<h4 id="sec-3-2-1">Object Types</h4>
<div id="text-3-2-1">
<div>

<pre>(<span>defmethod</span> <span>emit</span> <span>:symbol</span> [_ form state] (<span>str</span> form))

(<span>defmethod</span> <span>emit</span> <span>:string</span> [_ form state]
  (<span>str</span> <span>&#34;obj&lt;string&gt;(\&#34;&#34;</span> (io/escape-string form) <span>&#34;\&#34;,&#34;</span> (<span>count</span> form) <span>&#34;)&#34;</span>))

(<span>defmethod</span> <span>emit</span> <span>:boolean</span> [_ form state]
  (<span>if</span> (<span>true?</span> form)
    (<span>str</span> <span>&#34;cached::true_o&#34;</span>)
    (<span>str</span> <span>&#34;cached::false_o&#34;</span>)))

(<span>defmethod</span> <span>emit</span> <span>:nil</span> [_ form state] <span>&#34;nil()&#34;</span>)

(<span>defmethod</span> <span>emit</span> <span>:keyword</span> [_ form _]
  (<span>str</span> <span>&#34;obj&lt;keyword&gt;(&#34;</span> (<span>reduce</span> (<span>fn</span>[h v] (<span>+</span> h (<span>int</span> v))) 0 (<span>str</span> form)) <span>&#34;)&#34;</span>))

(<span>defmethod</span> <span>emit</span> <span>:char</span> [_ form state] (<span>str</span> <span>&#34;obj&lt;number&gt;(&#34;</span> (<span>int</span> form) <span>&#34;)&#34;</span>))

(<span>defmethod</span> <span>emit</span> <span>:number</span> [_ form state] (<span>str</span> <span>&#34;obj&lt;number&gt;(&#34;</span> (<span>double</span> form) <span>&#34;)&#34;</span>))

(<span>defmethod</span> <span>emit</span> &#39;fir_new_map [options [_ &amp; kvs] state]
  (<span>let</span> [kvs (<span>partition</span> 2 kvs)
        keys (<span>-&gt;&gt;</span> (<span>map</span> first kvs)
                  (<span>map</span> #(<span>emit</span> options % state))
                  (<span>interpose</span> \,))
        vals (<span>-&gt;&gt;</span> (<span>map</span> second kvs)
                  (<span>map</span> #(<span>emit</span> options % state))
                  (<span>interpose</span> \,))]
    (<span>str</span> <span>&#34;obj&lt;map_t&gt;(&#34;</span>
         <span>&#34;rt::list(&#34;</span> (<span>apply</span> str keys) <span>&#34;),&#34;</span>
         <span>&#34;rt::list(&#34;</span> (<span>apply</span> str vals) <span>&#34;))&#34;</span>)))

(<span>defmethod</span> <span>emit</span> <span>:regex-pattern</span> [options regex state]
  (<span>emit</span> options
        (org.apache.commons.lang.StringEscapeUtils/unescapeJava
         (<span>str</span> regex))
        state))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-2">
<h4 id="sec-3-2-2">Special Forms</h4>
<div id="text-3-2-2">
<p>
Special forms have evaluation rules that differ from standard Ferret
evaluation rules and are understood directly by the compiler. Most
special forms define control structures or perform variable
bindings—things which functions cannot do.
</p>

<div>

<pre>(<span>defmethod</span> <span>emit</span> &#39;def [options [_ name &amp; form] state]
  (append-to! state [<span>:symbol-table</span>] name)
  (<span>str</span> <span>&#34;(&#34;</span> name <span>&#34; = &#34;</span> (<span>apply</span> str (emit-ast options form state)) <span>&#34;)&#34;</span>))

(<span>defmethod</span> <span>emit</span> &#39;if [options [_ cond t f] state]
  (<span>let</span> [cond (<span>emit</span> options cond state)
        t (<span>emit</span> options t state)
        f (<span>if</span> (<span>nil?</span> f) <span>&#34;nil()&#34;</span> (<span>emit</span> options f state))]
    (<span>apply</span> str <span>&#34;(&#34;</span> cond <span>&#34; ? &#34;</span> t <span>&#34; : &#34;</span> f <span>&#34;)&#34;</span>)))

(<span>defn</span> <span>defobject</span> [name f options]
  (<span>let</span> [def (io/read-file (<span>first</span> f) options)]
    (render-template
     <span>&#34;#ifndef FERRET_OBJECT_$guard$</span>
<span>      #define FERRET_OBJECT_$guard$</span>
<span>       $body$</span>
<span>      #endif&#34;</span>
     <span>:guard</span>       (.toUpperCase (<span>str</span> name))
     <span>:body</span>        def)))

(<span>defmethod</span> <span>emit</span> &#39;list [options [fn &amp; args] state]
  (<span>let</span> [elements  (<span>-&gt;&gt;</span> (emit-ast options args state)
                       (<span>interpose</span> \,)
                       (<span>apply</span> str))]
    (<span>str</span> <span>&#34;rt::list(&#34;</span> elements <span>&#34;)&#34;</span>)))

(<span>defmethod</span> <span>emit</span> &#39;defobject [options [_ name &amp; spec] state]
  (append-to! state [<span>:objects</span>] (defobject name spec options)))

(<span>defmethod</span> <span>emit</span> &#39;matrix [options [_ elements] state]
  (<span>let</span> [rows (<span>count</span> elements)
        cols (<span>-&gt;</span> elements first count)
        elements (<span>apply</span> concat elements)
        elements (<span>map</span> #(<span>if</span> (<span>number?</span> %)
                         (<span>str</span> <span>&#34;real_t(&#34;</span> % <span>&#34;)&#34;</span>)
                         (<span>str</span>
                          <span>&#34;number::to&lt;real_t&gt;&#34;</span>
                          <span>&#34;(&#34;</span> (<span>emit</span> options % state) <span>&#34;)&#34;</span>))
                      elements)
        elements (<span>apply</span> str (<span>interpose</span> \, elements))
        matrix-t (<span>str</span> <span>&#34;size_t(&#34;</span> rows <span>&#34;), size_t(&#34;</span> cols <span>&#34;),&#34;</span> elements)
        matrix-decl (<span>str</span> <span>&#34;obj&lt;matrix_t&gt;(&#34;</span> matrix-t <span>&#34;)&#34;</span>)]
    matrix-decl))

(<span>defmethod</span> <span>emit</span> &#39;native_header [_ [_ &amp; declarations] state]
  (append-to! state [<span>:native-headers</span>] declarations))

(<span>defmethod</span> <span>emit</span> &#39;native_declare [_ [_ declaration] state]
  (append-to! state [<span>:native-declarations</span>] declaration))

(<span>defmethod</span> <span>emit</span> &#39;native_define [_ [_ define] state]
  (append-to! state [<span>:native-defines</span>] define))
</pre>
</div>

<p>
Inline primitive sequence operations. Some sequence operations such as
<code>first</code> / <code>rest</code> are implemented as native C++ functions instead of
executing a Ferret <code>fn</code> for these operations, these can be replaced
with calls to native implementations resulting in much smaller code.
</p>

<div>

<pre>(<span>defmethod</span> <span>emit</span> &#39;fir_inline_list [options [_ &amp; args] state]
  (<span>str</span> <span>&#34;rt::list(&#34;</span> (<span>apply</span> str (<span>interpose</span> \, (emit-ast options args state))) <span>&#34;)&#34;</span>))

(<span>defmethod</span> <span>emit</span> &#39;fir_inline_first [options [_ &amp; seq] state]
  (<span>str</span> <span>&#34;rt::first(&#34;</span> (<span>apply</span> str (emit-ast options seq state)) <span>&#34;)&#34;</span>))

(<span>defmethod</span> <span>emit</span> &#39;fir_inline_rest [options [_ &amp; seq] state]
  (<span>str</span> <span>&#34;rt::rest(&#34;</span> (<span>apply</span> str (emit-ast options seq state)) <span>&#34;)&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-3">
<h4 id="sec-3-2-3">Functions</h4>
<div id="text-3-2-3">
<div>

<pre>(<span>defn</span> <span>norm-fn-env</span> [env]
  (<span>-&gt;&gt;</span> env
       (<span>flatten</span>)
       (<span>filter</span> #(<span>and</span> (<span>not</span> (<span>=</span> &#39;&amp; %))
                     (<span>not</span> (<span>=</span> &#39;_ %))
                     (<span>not</span> (<span>=</span> <span>:as</span> %))))))

(<span>defn</span> <span>new-fn-heap</span> [l]
  (<span>let</span> [n (<span>second</span> l)
        e (norm-fn-env (<span>drop</span> 2 l))]
    (<span>if</span> (<span>empty?</span> e)
      (<span>str</span> <span>&#34;obj&lt;&#34;</span> n <span>&#34;&gt;()&#34;</span>)
      (<span>str</span> <span>&#34;obj&lt;&#34;</span> n <span>&#34;&gt;(&#34;</span> (<span>apply</span> str (<span>interpose</span> \, e)) <span>&#34;)&#34;</span>))))

(<span>defn</span> <span>new-fn-stack</span> [l]
  (<span>let</span> [n (<span>second</span> l)
        e (norm-fn-env (<span>drop</span> 2 l))]
    (<span>if</span> (<span>empty?</span> e)
      (<span>str</span> n <span>&#34;()&#34;</span>)
      (<span>str</span> n <span>&#34;(&#34;</span> (<span>apply</span> str (<span>interpose</span> \, e)) <span>&#34;)&#34;</span>))))

(<span>defn</span> <span>invoke-fn</span> [n args]
  (<span>if</span> (<span>empty?</span> args)
    (<span>str</span> <span>&#34;run(&#34;</span> n <span>&#34;)&#34;</span>)
    (<span>str</span> <span>&#34;run(&#34;</span> n <span>&#34;,&#34;</span>  (<span>apply</span> str (<span>interpose</span> \, args))<span>&#34;)&#34;</span>)))
</pre>
</div>

<p>
Initialize function arguments. Clojure style sequential destructuring
is supported.
</p>

<div>

<pre>(<span>defn</span> <span>destructure-test-1</span> [[a b c]]
  (<span>list</span> a b c))

(<span>defn</span> <span>destructure-test-2</span> [[a [b] c]]
  b)

(<span>defn</span> <span>destructure-test-3</span> [[a [_ b] c]]
  b)

(<span>defn</span> <span>destructure-test-4</span> [&amp; a]
  a)

(<span>defn</span> <span>destructure-test-5</span> []
  (<span>let</span> [[a b c] (<span>list</span> 1 2 3)]
    (<span>list</span> a b c)))

(<span>defn</span> <span>destructure-test-6</span> []
  (<span>let</span> [[_ _ a] (<span>list</span> 1 2 3)]
    a))

(<span>defn</span> <span>destructure-test-7</span> [a b &amp; [c d]]
  (<span>list</span> c d))

(<span>defn</span> <span>destructure-test-8</span> [{a <span>:a</span>} b {c <span>:c</span>}]
  (<span>list</span> a b c))

(<span>deftest</span> destructuring-test
  (<span>is</span> (<span>=</span> 3                   (<span>count</span> (destructure-test-1 (<span>list</span> 1 2 3)))))
  (<span>is</span> (<span>=</span> 2                   (destructure-test-2 (<span>list</span> 1 (<span>list</span> 2) 3))))
  (<span>is</span> (<span>=</span> 3                   (destructure-test-3 (<span>list</span> 1 (<span>list</span> 2 3) 3))))
  (<span>is</span> (<span>=</span> (<span>list</span> (<span>list</span> 1 2 3)) (destructure-test-4 (<span>list</span> 1 2 3))))
  (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3)        (destructure-test-8 {<span>:a</span> 1} 2 {<span>:c</span> 3})))

  (<span>let</span> [a (<span>list</span> 1 2 3 4)
        [b c &amp; r] a]

    (<span>is</span> (<span>=</span> 1          b))
    (<span>is</span> (<span>=</span> 2          c))
    (<span>is</span> (<span>=</span> (<span>list</span> 3 4) r)))

  (<span>let</span> [a 1 b 2
        [c &amp; r] (<span>list</span> 4 5)]

    (<span>is</span> (<span>=</span> 1 a))
    (<span>is</span> (<span>=</span> 2 b))
    (<span>is</span> (<span>=</span> 4 c))
    (<span>is</span> (<span>=</span> (<span>list</span> 5) r)))

  (<span>let</span> [[a &amp; r] (<span>list</span> 1 2 3)
        rr (<span>rest</span> r)]
    (<span>is</span> (<span>=</span> (<span>list</span> 3) rr)))

  (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3) (destructure-test-5)))
  (<span>is</span> (<span>=</span> 3            (destructure-test-6)))
  (<span>is</span> (<span>=</span> (<span>list</span> 3 4)   (destructure-test-7 1 2 3 4)))

  (<span>let</span> [[a &amp; b <span>:as</span> all-list]   (<span>list</span> 1 2 3)
        [c     <span>:as</span> other-list] all-list]
    (<span>is</span> (<span>=</span> 1            a))
    (<span>is</span> (<span>=</span> (<span>list</span> 2 3)   b))
    (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3) all-list))
    (<span>is</span> (<span>=</span> 1            c))
    (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3) other-list)))

  (<span>let</span> [[_ _ a] (<span>list</span> 1 2 3)
        [_ b] (<span>list</span> 4 5 6)]
    (<span>is</span> (<span>=</span> 3 a))
    (<span>is</span> (<span>=</span> 5 b)))

  (<span>let</span> [a (<span>list</span> 1 2 3)
        [b c d e f g] a]
    (<span>is</span> (<span>=</span> 1   b))
    (<span>is</span> (<span>=</span> 2   c))
    (<span>is</span> (<span>=</span> 3   d))
    (<span>is</span> (<span>=</span> nil e))
    (<span>is</span> (<span>=</span> nil f))
    (<span>is</span> (<span>=</span> nil g))))
</pre>
</div>

<div>

<pre>(<span>declare</span> destructure-arguments)

(<span>defn</span> <span>destructure-nth-rest</span> [parent pos]
  (<span>reduce</span> (<span>fn</span>[h v] (<span>str</span> v <span>&#34;(&#34;</span> h <span>&#34;)&#34;</span>)) parent (<span>repeat</span> pos <span>&#34;rt::rest&#34;</span>)))

(<span>defn</span> <span>destructure-nth</span> [parent pos]
  (<span>str</span> <span>&#34;rt::first(&#34;</span> (destructure-nth-rest parent pos) <span>&#34;)&#34;</span>))

(<span>defn</span> <span>destructure-get</span> [name parent key]
  (<span>str</span> <span>&#34;ref &#34;</span> name <span>&#34; = &#34;</span>
       parent <span>&#34;.cast&lt;map_t&gt;()-&gt;val_at(rt::list(&#34;</span> (<span>emit</span> nil key nil) <span>&#34;));&#34;</span>))

(<span>defn</span> <span>new-fn-arg</span> [name parent pos]
  (<span>let</span> [value (destructure-nth parent pos)
        tag   (<span>-&gt;</span> name meta <span>:tag</span>)]
    (<span>condp</span> = tag
      &#39;bool_t     (<span>str</span> <span>&#34;bool &#34;</span> name <span>&#34; = &#34;</span> <span>&#34;bool(&#34;</span> value <span>&#34;)&#34;</span>)
      &#39;real_t     (<span>str</span> <span>&#34;real_t &#34;</span> name <span>&#34; = &#34;</span> <span>&#34;number::to&lt;real_t&gt;(&#34;</span> value <span>&#34;)&#34;</span>)
      &#39;number_t   (<span>str</span> <span>&#34;number_t &#34;</span> name <span>&#34; = &#34;</span> <span>&#34;number::to&lt;number_t&gt;(&#34;</span> value <span>&#34;)&#34;</span>)
      &#39;size_t     (<span>str</span> <span>&#34;size_t &#34;</span> name <span>&#34; = &#34;</span> <span>&#34;number::to&lt;size_t&gt;(&#34;</span> value <span>&#34;)&#34;</span>)
      &#39;byte       (<span>str</span> <span>&#34;byte &#34;</span> name <span>&#34; = &#34;</span> <span>&#34;number::to&lt;byte&gt;(&#34;</span> value <span>&#34;)&#34;</span>)
      &#39;c_str      (<span>str</span> <span>&#34;var &#34;</span> name <span>&#34;_packed = string::pack(&#34;</span> value <span>&#34;);\n&#34;</span>
                       <span>&#34;char* &#34;</span> name <span>&#34; = &#34;</span> <span>&#34;string::c_str(&#34;</span> name <span>&#34;_packed)&#34;</span>)
      &#39;matrix     (<span>str</span> <span>&#34;matrix &amp;&#34;</span> name <span>&#34; = &#34;</span> <span>&#34;value&lt;matrix&gt;::to_reference(&#34;</span> value <span>&#34;)&#34;</span>)
      (<span>str</span> <span>&#34;ref &#34;</span> name <span>&#34; = &#34;</span> value))))

(<span>defn</span> <span>new-fn-var-arg</span> [name parent pos]
  (<span>str</span> <span>&#34;ref &#34;</span> name <span>&#34; = &#34;</span> (destructure-nth-rest parent pos)))

(<span>defn</span> <span>destructure-associative</span> [name parent pos]
  (<span>let</span> [tmp-name (<span>gensym</span>)]
    [(new-fn-arg tmp-name parent pos)
     (<span>map</span> (<span>fn</span> [[s k]] (destructure-get s tmp-name k)) name)]))

(<span>defn</span> <span>destructure-sequential</span> [args parent]
  (<span>reduce</span>
   (<span>fn</span> [h [pos name]]
     (<span>let</span> [name (<span>cond</span>
                  (<span>symbol?</span> name)
                  (new-fn-arg name parent pos)

                  (parser/form? &#39;fir_destructure_associative name)
                  (<span>let</span> [[_ &amp; args ] name
                        args (<span>-&gt;&gt;</span> args
                                  (<span>partition</span> 2)
                                  (<span>remove</span> #(<span>=</span> (<span>first</span> %) &#39;_))
                                  flatten
                                  (<span>apply</span> hash-map))]
                    (destructure-associative args parent pos))

                  (<span>coll?</span>   name)
                  (destructure-arguments name (destructure-nth parent pos)))]
       (<span>conj</span> h name))) [] args))

(<span>defn</span> <span>destructure-var-args</span> [name parent pos]
  (<span>cond</span> (<span>nil?</span>     name)  []
        (<span>symbol?</span>  name)  (new-fn-var-arg name parent pos)
        (<span>coll?</span>    name)  (<span>let</span> [tmp-name (<span>gensym</span>)]
                           [(new-fn-var-arg tmp-name parent pos)
                            (destructure-arguments name tmp-name)])))

(<span>defn</span> <span>destructure-as-arg</span> [name parent]
  (<span>if</span> (<span>symbol?</span>     name)
    (new-fn-var-arg name parent 0)
    []))

(<span>defn</span> <span>destructure-arguments</span>
  ([args]
   (<span>-&gt;&gt;</span> (destructure-arguments args <span>&#34;_args_&#34;</span>) flatten))
  ([args parent]
   (<span>let</span> [t-args         args
         args           (<span>take-while</span> #(<span>and</span> (<span>not=</span> % &#39;&amp;) (<span>not=</span> % <span>:as</span>)) t-args)
         var-args       (<span>-&gt;&gt;</span> t-args (<span>drop-while</span> #(<span>not=</span> % &#39;&amp;)) second)
         as-arg         (<span>-&gt;&gt;</span> t-args (<span>drop-while</span> #(<span>not=</span> % <span>:as</span>)) second)
         args-indexed   (<span>-&gt;&gt;</span>  args
                              (<span>map-indexed</span> (<span>fn</span> [p v] [p v]))
                              (<span>filter</span> #(<span>not=</span> (<span>second</span> %) &#39;_)))
         as-arg         (destructure-as-arg as-arg parent)
         var-args       (destructure-var-args var-args parent (<span>count</span> args))
         args           (destructure-sequential args-indexed parent)]
     [args var-args as-arg])))
</pre>
</div>

<div>

<pre>(<span>defmethod</span> <span>emit</span> <span>:invoke-fn</span> [options [fn &amp; args] state]
  (invoke-fn (<span>emit</span> options fn state) (emit-ast options args state)))

(<span>defmethod</span> <span>emit</span> &#39;fir_fn_heap [_ f state]
  (new-fn-heap f))

(<span>defmethod</span> <span>emit</span> &#39;fir_fn_stack [_ f state]
  (new-fn-stack f))

(<span>defn</span> <span>emit-lambda</span> [options name env args body state]
  (<span>let</span> [native-declarations (<span>filter</span> (parser/form? &#39;native_declare) body)
        return (<span>fn</span> [b] (<span>conj</span> (<span>pop</span> b) (<span>str</span> <span>&#34;return &#34;</span> (<span>last</span> b))))
        body (<span>filter</span> #(<span>not</span> (parser/form? &#39;native_declare %)) body)
        body (<span>cond</span>  (<span>empty?</span> body)
                    [<span>&#34;return nil()&#34;</span>]
                    <span>;; </span><span>multi arity dispacth</span>
                    (parser/form? &#39;fir_defn_arity (<span>first</span> body))
                    (return
                     (<span>emit</span> options (<span>first</span> body) state))
                    <span>;; </span><span>ffi call</span>
                    (parser/ffi-fn? body)
                    (<span>let</span> [buffer (StringBuilder.)]
                      (<span>doseq</span> [b body]
                        (.append buffer b))
                      (<span>let</span> [body (.toString buffer)]
                        (<span>cond</span> (.contains body <span>&#34;__result&#34;</span>)
                              [<span>&#34;var __result&#34;</span> body <span>&#34;return __result&#34;</span>]
                              (.contains body <span>&#34;return&#34;</span>)
                              [body]
                              <span>:default</span> [body <span>&#34;return nil()&#34;</span>])))
                    <span>;; </span><span>s-expression</span>
                    <span>:default</span> (return
                              (emit-ast options body state)))
        env  (norm-fn-env env)
        vars (destructure-arguments args)]
    (<span>doseq</span> [dec native-declarations] 
      (<span>emit</span> options dec state))
    {<span>:name</span> name <span>:env</span> env <span>:args</span> args <span>:vars</span> vars <span>:body</span> body}))

(<span>defmethod</span> <span>emit</span> &#39;fir_defn_heap [options [_ name env args &amp; body] state]
  (append-to! state [<span>:lambdas</span>] (emit-lambda options name env args body state)))

(<span>defmethod</span> <span>emit</span> &#39;fir_defn_stack [options [_ name env args &amp; body] state]
  (append-to! state [<span>:lambdas</span>] (<span>-&gt;</span> (emit-lambda options name env args body state)
                                   (<span>assoc</span> <span>:stack</span> true))))
</pre>
</div>

<div>

<pre>(<span>defmethod</span> <span>emit</span> &#39;fir_defn_arity [_ [_ switch default] state]
  (<span>let</span> [default (<span>if</span> default
                  (<span>str</span> (new-fn-stack default) <span>&#34;.invoke(_args_)&#34;</span>)
                  <span>&#34;nil()&#34;</span>)
        switch  (render-template
                 <span>&#34;switch(rt::count(_args_)) {</span>
<span>                  $fns: {fn|</span>
<span>                    case $fn.case$ :</span>
<span>                       return $fn.fn$.invoke(_args_); };separator=\&#34;\n\&#34;$</span>
<span>                  }&#34;</span>
                 <span>:fns</span> (<span>map</span> (<span>fn</span> [[s f]] {<span>:fn</span> (new-fn-stack f) <span>:case</span> s}) switch))]
    [switch default]))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>lambda-definitions</span> [fns]
  (render-template
   <span>&#34;$fns: {fn|</span>
<span>      $if(!fn.stack)$</span>
<span>       class $fn.name$ final : public lambda_i{</span>
<span>      $else$</span>
<span>       class $fn.name$  \\{</span>
<span>      $endif$</span>
<span>        $fn.env:{const var $it$;} ;separator=\&#34;\n\&#34;$</span>
<span>      public:</span>
<span>        $if(fn.env)$</span>
<span>          explicit $fn.name$ ($fn.env:{ref $it$} ;separator=\&#34;,\&#34;$) :</span>
<span>            $fn.env:{$it$($it$)} ;separator=\&#34;,\&#34;$ { }</span>
<span>        $endif$</span>

<span>        var invoke (ref _args_) const $if(!fn.stack)$ final $endif$ ;</span>
<span>      };};separator=\&#34;\n\n\&#34;$&#34;</span>
   <span>:fns</span> fns))

(<span>defn</span> <span>lambda-implementations</span> [fns]
  (render-template
   <span>&#34;$fns: {fn|</span>
<span>      inline var $fn.name$::invoke (ref _args_) const {</span>
<span>        (void)(_args_);</span>
<span>        $fn.vars:{$it$;} ;separator=\&#34;\n\&#34;$</span>

<span>        $fn.body:{$it$;} ;separator=\&#34;\n\&#34;$</span>
<span>      }</span>
<span>     };separator=\&#34;\n\n\&#34;$&#34;</span>
   <span>:fns</span> fns))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-4">
<h4 id="sec-3-2-4">Program</h4>
<div id="text-3-2-4">
<p>
Generated C++ code has the following structure, (All Ferret code is
defined within <code>ferret</code> namespace, all Ferret macros starts with
<code>FERRET_</code>, all user defined functions are defined in file name
namespace.)
</p>

<ul>
<li>Detect Hardware
</li>
<li>Include files
</li>
<li>Ferret Header (src/runtime/runtime.h)
</li>
<li>Ferret Native Runtime Prototypes (rt::first, rt::rest
etc.)
</li>
<li>Native Declarations
</li>
<li>Object Definitions
</li>
<li>Symbol Definitions
</li>
<li>Native Runtime Implementations
</li>
<li>Lambda Prototypes
</li>
<li>Lambda Implementations
</li>
<li>Ferret Main
</li>
<li>Hardware Dependent Main Functions
</li>
</ul>

<div>

<pre>(<span>defn</span> <span>program-template</span> [source options]
  (<span>let</span> [{<span>:keys</span> [body lambdas symbol-table native-headers objects
                native-declarations native-defines]} source
        native-headers (<span>-&gt;&gt;</span> native-headers flatten (<span>into</span> #{}))
        file-ns        (<span>-&gt;</span> options <span>:base-name</span> escape-cpp-symbol)
        main           (render-template
                        (io/read-file <span>&#34;main.cpp&#34;</span>)
                        <span>:file</span>       file-ns)]
    (render-template
     <span>&#34;</span>
<span>        $native_defines:{$it$} ;separator=\&#34;\n\&#34;$</span>
<span>        $native_headers:{#include \&#34;$it$\&#34;} ;separator=\&#34;\n\&#34;$</span>

<span>        #ifndef FERRET_RUNTIME_H</span>
<span>        #define FERRET_RUNTIME_H</span>
<span>         $ferret_h$</span>
<span>        #endif</span>

<span>        // Objects</span>
<span>        namespace ferret{</span>
<span>         $objects:{$it$} ;separator=\&#34;\n\&#34;$</span>
<span>        }</span>

<span>        // Symbols</span>
<span>        namespace $file${</span>
<span>         using namespace ferret;</span>

<span>         #if defined(ARDUINO)</span>
<span>           typedef ferret::boolean boolean;</span>
<span>         #endif</span>

<span>         $symbols:{var $it$;} ;separator=\&#34;\n\&#34;$</span>
<span>        }</span>

<span>        $native_declarations:{$it$} ;separator=\&#34;\n\&#34;$</span>

<span>        // Runtime Implementations</span>
<span>        #ifndef FERRET_RUNTIME_CPP</span>
<span>        #define FERRET_RUNTIME_CPP</span>
<span>         $ferret_cpp$</span>
<span>        #endif</span>

<span>        // Lambda Prototypes</span>
<span>        namespace $file${</span>
<span>          $lambda_classes:{$it$} ;separator=\&#34;\n\&#34;$</span>
<span>        }</span>

<span>        // Command Line Arguments</span>
<span>        #if defined(FERRET_STD_LIB) &amp;&amp;               \\</span>
<span>            !defined(FERRET_DISABLE_CLI_ARGS) &amp;&amp;     \\</span>
<span>            !defined(FERRET_DISABLE_STD_MAIN)</span>
<span>          ferret::var _star_command_line_args_star_;</span>
<span>        #endif</span>

<span>        // Lambda Implementations</span>
<span>        namespace $file${</span>
<span>          $lambda_bodies:{$it$} ;separator=\&#34;\n\&#34;$</span>
<span>        }</span>

<span>        // Program Run</span>
<span>        namespace $file${</span>
<span>         void main(){</span>
<span>          $body:{$it$;} ;separator=\&#34;\n\&#34;$ </span>
<span>         }</span>
<span>        }</span>

<span>        $ferret_main$&#34;</span>
     <span>:file</span>                 file-ns
     <span>:native_defines</span>       native-defines
     <span>:ferret_h</span>             (io/read-file <span>&#34;runtime.h&#34;</span>)
     <span>:native_headers</span>       native-headers
     <span>:objects</span>              objects
     <span>:symbols</span>              symbol-table
     <span>:native_declarations</span>  native-declarations
     <span>:ferret_cpp</span>           (io/read-file <span>&#34;runtime.cpp&#34;</span>)
     <span>:lambda_classes</span>       (lambda-definitions lambdas)
     <span>:lambda_bodies</span>        (lambda-implementations lambdas)
     <span>:body</span>                 (<span>filter</span> #(<span>not</span> (<span>empty?</span> %)) body)
     <span>:ferret_main</span>          main)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-3">
<h3 id="sec-3-3">Main</h3>
<div id="outline-container-sec-3-3-1">
<h4 id="sec-3-3-1">Options</h4>
<div id="text-3-3-1">
<p>
Default compile options, 
</p>

<div>

<pre>(<span>defn</span> <span>compile-options</span> [&amp; [options]]
  (<span>merge</span> {<span>:compiler</span> <span>&#34;g++&#34;</span>
          <span>:compiler-options</span> [<span>&#34;-std=c++11&#34;</span>]
          <span>:source-extension</span> io/extension-cpp
          <span>:base-name</span> <span>&#34;solution&#34;</span>
          <span>:binary-file</span> <span>&#34;solution&#34;</span>}
         options))

(<span>defn</span> <span>file-name</span> [options]
  (<span>str</span> (<span>:base-name</span> options) <span>&#34;.&#34;</span> (<span>:source-extension</span> options)))

(<span>defn</span> <span>cpp-file-name</span> [options]
  (<span>str</span> (<span>:output-path</span> options) (file-name options)))
</pre>
</div>

<p>
Read the <i>cpp</i> file parse build options embedded in
it. <code>configure-ferret!</code> macro can embed build options into C++
files. These can be used later when build the binary.
</p>

<div>

<pre>(<span>defn</span> <span>compile-options-parse-source</span> [file]
  (<span>try</span>
    (<span>let</span> [program (<span>slurp</span> file)
          options (<span>-&gt;&gt;</span> program
                       (<span>re-seq</span> #<span>&#34;(?s)build-conf-begin.*?//(.*?)// build-conf-end&#34;</span>)
                       (<span>map</span> second)
                       (<span>map</span> #(.replaceAll % <span>&#34;//&#34;</span> <span>&#34;&#34;</span>))
                       (<span>map</span> #(.replaceAll % <span>&#34;\n&#34;</span> <span>&#34; &#34;</span>))
                       (<span>map</span> read-string))
          keys (<span>-&gt;&gt;</span> options
                    (<span>map</span> #(<span>keys</span> %))
                    flatten
                    (<span>into</span> #{})
                    (<span>into</span> []))
          combine (<span>fn</span> [key]
                    (<span>-&gt;&gt;</span> options
                         (<span>reduce</span> (<span>fn</span>[h v]
                                   (<span>if</span> (<span>nil?</span> (<span>key</span> v))
                                     h
                                     (<span>apply</span> merge (<span>flatten</span> [h (<span>key</span> v)])))) #{})
                         (<span>into</span> [])))]
      (compile-options
       (<span>reduce</span> (<span>fn</span>[h v]
                 (<span>assoc</span> h v (combine v))) {} keys)))
    (<span>catch</span> Exception e
      (compile-options {}))))
</pre>
</div>

<p>
Takes the compiler CLI arguments and a file name, returns a map of
build options.
</p>

<div>

<pre>(<span>defn</span> <span>build-specs</span> [input args]
  (<span>fn</span> []
    (<span>let</span> [args             (<span>fn</span> [k]
                             (<span>-&gt;&gt;</span> args <span>:options</span> k))
          output           (<span>if</span> (args <span>:output</span>)
                             (args <span>:output</span>)
                             input)
          output-path      (io/file-path output)
          output-extension (<span>if</span> (args <span>:output</span>) 
                             (io/file-extension (args <span>:output</span>))
                             io/extension-cpp)
          base-name        (io/file-base-name output)
          input-path       (io/file-path input)
          output-file      (io/make-file output-path base-name output-extension)
          binary-file      (<span>if</span> (args <span>:binary</span>) 
                             (args <span>:binary</span>)
                             base-name)
          default-options  (compile-options-parse-source output-file)]
      (<span>-&gt;</span> default-options
          (<span>assoc</span> <span>:input-file</span>         input)
          (<span>assoc</span> <span>:base-name</span>          base-name)
          (<span>assoc</span> <span>:path</span>               input-path)
          (<span>assoc</span> <span>:output-path</span>        output-path)
          (<span>assoc</span> <span>:source-extension</span>   output-extension)
          (<span>assoc</span> <span>:binary-file</span>        binary-file)
          (<span>assoc</span> <span>:ast</span>                (args <span>:ast</span>))
          (<span>assoc</span> <span>:compile-program</span>    (args <span>:compile</span>))
          (<span>assoc</span> <span>:release</span>            (args <span>:release</span>))
          (<span>assoc</span> <span>:format-code</span>        (<span>not</span> (args <span>:disable-formatting</span>)))
          (<span>assoc</span> <span>:global-functions</span>   (args <span>:global-functions</span>))
          (<span>assoc</span> <span>:extra-source-files</span>
                 (<span>cond</span> (<span>not</span> (<span>empty?</span> (<span>:arguments</span> args)))
                       (<span>:arguments</span> args)
                       (<span>not</span> (<span>empty?</span> (<span>:extra-source-files</span> default-options)))
                       (<span>:extra-source-files</span> default-options)
                       <span>:default</span> []))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-2">
<h4 id="sec-3-3-2">Compile to C++</h4>
<div id="text-3-3-2">
<p>
Compile the form to C++,
</p>

<div>

<pre>(<span>defn</span> <span>compile-&gt;cpp</span> [form options]
  (<span>let</span> [file-name (cpp-file-name options)
        source    (emit-source form options)
        program   (program-template source options)]
    (io/write-to-file file-name program)
    (info <span>&#34;compiled&#34;</span> <span>&#34;=&gt;&#34;</span> file-name)
    true))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-3">
<h4 id="sec-3-3-3">Compile to Binary</h4>
<div id="text-3-3-3">
<p>
Pick compiler to use. If set, use the value of <code>CXX</code> environment
variable, if not set use the default compiler <code>gcc</code>,
</p>

<div>

<pre>(<span>defn</span> <span>cxx-compiler</span> [options]
  (<span>let</span> [compiler    (<span>if</span> (System/getenv <span>&#34;CXX&#34;</span>)
                      (System/getenv <span>&#34;CXX&#34;</span>)
                      (<span>:compiler</span> options))
        env-options (<span>if</span> (System/getenv <span>&#34;CXXFLAGS&#34;</span>)
                      (<span>seq</span> (.split (System/getenv <span>&#34;CXXFLAGS&#34;</span>) <span>&#34; &#34;</span>)))
        options     (<span>-&gt;&gt;</span> (<span>:compiler-options</span> options) (<span>map</span> str))]
    [compiler (<span>concat</span> options env-options)]))
</pre>
</div>

<p>
Compiler build command,
</p>

<div>

<pre>(<span>defn</span> <span>cxx-command</span> [options]
  (<span>if</span> (<span>:command</span> options)
    (<span>flatten</span> [<span>&#34;/usr/bin/env&#34;</span> <span>&#34;sh&#34;</span> <span>&#34;-c&#34;</span> (<span>:command</span> options)])
    (<span>let</span> [[cxx cxx-options] (cxx-compiler options)
          source-files  (<span>map</span> #(<span>let</span> [extension (io/file-extension %)]
                                [(<span>cond</span> (<span>=</span> extension <span>&#34;c&#34;</span>) [<span>&#34;-x&#34;</span> <span>&#34;c&#34;</span>]
                                       (<span>=</span> extension <span>&#34;c++&#34;</span>) [<span>&#34;-x&#34;</span> <span>&#34;c++&#34;</span>]
                                       <span>:default</span> <span>&#34;&#34;</span>)
                                 %])
                             (<span>:extra-source-files</span> options))]
      (<span>flatten</span> [cxx cxx-options source-files
                [<span>&#34;-x&#34;</span> <span>&#34;c++&#34;</span>] (file-name options)
                [<span>&#34;-o&#34;</span> (<span>:binary-file</span> options)]]))))
</pre>
</div>

<p>
Run the compiler on the generated source and create the binary,
</p>

<div>

<pre>(<span>defn</span> <span>compile-&gt;binary</span> [options]
  (<span>let</span> [command (cxx-command options)]
    (info <span>&#34;building&#34;</span> <span>&#34;=&gt;&#34;</span> (<span>apply</span> str (<span>interpose</span> <span>&#34; &#34;</span> command)))
    (<span>let</span> [build-dir (<span>:output-path</span> options)
          ret (<span>try</span>
                (with-sh-dir build-dir
                  (<span>apply</span> sh command))
                (<span>catch</span> Exception e
                  (warn (<span>str</span> <span>&#34;error executing C++ compiler.&#34;</span>))
                  (warn (<span>str</span> <span>&#34;&#34;</span> (.getMessage e)))
                  (io/exit-failure)))]
      (<span>if</span> (<span>not=</span> 0 (<span>:exit</span> ret))
        (<span>do</span> (warn <span>&#34;build error&#34;</span>)
            (warn (<span>:err</span> ret))
            (io/exit-failure)))
      true)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-4">
<h4 id="sec-3-3-4">Build Solution</h4>
<div id="text-3-3-4">
<p>
Compile and build program,
</p>

<div>

<pre>(<span>defn</span> <span>clang-format</span> [options]
  (<span>let</span> [file (cpp-file-name options)
        source (<span>try</span> (with-sh-dir <span>&#34;./&#34;</span>
                      (sh <span>&#34;clang-format&#34;</span> <span>&#34;-style&#34;</span> <span>&#34;{Standard: Cpp11}&#34;</span> file))
                    (<span>catch</span> Exception e nil))]
    (<span>if</span> source
      (<span>do</span> (info <span>&#34;formatting code&#34;</span>)
          (io/write-to-file file (<span>:out</span> source))))))

(<span>defn</span> <span>build-solution</span> [spec-fn]
  (<span>let</span> [{<span>:keys</span> [input-file compile-program format-code path]} (spec-fn)]
    (info <span>&#34;dir =&gt;&#34;</span> path)
    (info <span>&#34;file =&gt;&#34;</span> input-file)

    (compile-&gt;cpp (read-clojure-file input-file) (spec-fn))

    (<span>when</span> format-code
      (clang-format (spec-fn)))

    (<span>when</span> compile-program
      (compile-&gt;binary (spec-fn)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-5">
<h4 id="sec-3-3-5">Compiler Main</h4>
<div id="text-3-3-5">
<p>
Compiler options,
</p>

<div>

<pre>(<span>def</span> <span>program-options</span>
  [[<span>&#34;-i&#34;</span> <span>&#34;--input FILE&#34;</span>         <span>&#34;Input File&#34;</span> <span>:default</span> <span>&#34;./core.clj&#34;</span>]
   [<span>&#34;-o&#34;</span> <span>&#34;--output FILE&#34;</span>        <span>&#34;Output C++ File&#34;</span>]
   [<span>&#34;-b&#34;</span> <span>&#34;--binary FILE&#34;</span>        <span>&#34;Output Binary File&#34;</span>]
   [<span>&#34;-c&#34;</span> <span>&#34;--compile&#34;</span>            <span>&#34;Compile to Binary&#34;</span>]
   [nil  <span>&#34;--deps&#34;</span>               <span>&#34;Checkout Input Dependencies&#34;</span>]
   [<span>&#34;-w&#34;</span> <span>&#34;--watch-input&#34;</span>        <span>&#34;Automatically Recompile Input File on Change&#34;</span>]
   [nil  <span>&#34;--release&#34;</span>            <span>&#34;Compile in Release Mode. Strip Debug Information&#34;</span>]
   [nil  <span>&#34;--disable-formatting&#34;</span> <span>&#34;Disables Output File Formatting Using clang-format&#34;</span>]
   [nil  <span>&#34;--global-functions&#34;</span>   <span>&#34;Disables inline-global-fns Optimization&#34;</span>]
   [nil  <span>&#34;--ast&#34;</span>                <span>&#34;Print Intermediate AST&#34;</span>]
   [nil  <span>&#34;--silent&#34;</span>             <span>&#34;Silent or quiet mode&#34;</span>]
   [<span>&#34;-h&#34;</span> <span>&#34;--help&#34;</span>               <span>&#34;Print Help&#34;</span>]])
</pre>
</div>

<p>
Compiler <i>main</i>,
</p>

<div>

<pre>(<span>defn</span> <span>-main</span> [&amp; args]
  (<span>try</span>
    (<span>let</span> [args (parse-opts args program-options)
          {<span>:keys</span> [help input deps watch-input silent]} (<span>:options</span> args)]

      (<span>when</span> help
        (<span>try</span>
          (<span>let</span> [version (io/read-file <span>&#34;build.info&#34;</span>)]
            (<span>print</span> <span>&#34;ferret-lisp&#34;</span> version))
          (<span>catch</span> Exception e
            (<span>print</span> <span>&#34;ferret-lisp&#34;</span>)))
        (<span>println</span> )
        (<span>println</span> )
        (<span>println</span> (<span>:summary</span> args))
        (io/exit-success))

      (<span>when</span> silent
        (System/setProperty <span>&#34;org.slf4j.simpleLogger.defaultLogLevel&#34;</span> <span>&#34;warn&#34;</span>))

      (<span>when</span> (<span>not</span> (io/file-exists input))
        (warn <span>&#34;no input file&#34;</span>)
        (io/exit-failure))

      (<span>let</span> [specs (build-specs input args)]

        (<span>when</span> deps
          (<span>try</span>
            (checkout-deps (<span>:path</span> (specs)))
            (<span>catch</span> Exception e
              (io/exit-failure)))
          (io/exit-success))

        (<span>if</span> (<span>not</span> watch-input)
          (build-solution specs)
          (<span>do</span> (watcher/watcher [input]
                               (watcher/rate 1000)
                               (watcher/on-change
                                (<span>fn</span> [_] (build-solution specs))))
              @(<span>promise</span>)))
        (<span>shutdown-agents</span>))
      (io/exit-success))
    (<span>catch</span> Exception e
      (stacktrace/<span>print-stack-trace</span> e 10))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-4">
<h3 id="sec-3-4">I/O</h3>
<div id="text-3-4">
<p>
Common I/O operations.
</p>

<div>

<pre>(<span>def</span> <span>extension-cpp</span> <span>&#34;cpp&#34;</span>)

(<span>defn</span> <span>os-name</span> []
  (<span>let</span> [os (<span>-&gt;</span> (System/getProperty <span>&#34;os.name&#34;</span>) .toLowerCase)]
    (<span>cond</span> (.contains os <span>&#34;win&#34;</span>)      <span>:windows</span>
          (.contains os <span>&#34;mac&#34;</span>)      <span>:mac</span>
          (<span>or</span> (.contains os <span>&#34;nix&#34;</span>)
              (.contains os <span>&#34;nux&#34;</span>)
              (.contains os <span>&#34;aix&#34;</span>)) <span>:unix</span>
          (.contains os <span>&#34;sunos&#34;</span>)    <span>:solaris</span>)))

(<span>defn</span> <span>exit-failure</span> []
  (System/exit 1))

(<span>defn</span> <span>exit-success</span> []
  (System/exit 0))

(<span>defn</span> <span>read-file-from-url</span> [f]
  (<span>with-open</span> [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
              rdr (BufferedReader. (InputStreamReader. in))]
    (<span>apply</span> str (<span>interpose</span> \newline (<span>line-seq</span> rdr)))))

(<span>defn</span> <span>read-file</span> [f &amp; [options]]
  (<span>try</span>
    (read-file-from-url f)
    (<span>catch</span> Exception e-url
      (<span>try</span>
        (<span>if</span> (<span>nil?</span> options)
          (FileUtils/readFileToString (file f))
          (FileUtils/readFileToString (file (<span>str</span> (<span>:path</span> options) f))))
        (<span>catch</span> Exception e-path
          (warn <span>&#34;error reading =&gt;&#34;</span> f)
          (exit-failure))))))

(<span>defn</span> <span>write-to-file</span> [f s]
  (FileUtils/writeStringToFile (file f) (.trim s)))

(<span>defn</span> <span>escape-string</span> [s]
  (org.apache.commons.lang.StringEscapeUtils/escapeJava s))

(<span>defn</span> <span>file-path</span> [file]
  (<span>let</span> [path (<span>str</span> (org.apache.commons.io.FilenameUtils/getPrefix file)
                  (org.apache.commons.io.FilenameUtils/getPath file))]
    (<span>if</span> (<span>empty?</span> path)
      <span>&#34;./&#34;</span>
      path)))

(<span>defn</span> <span>file-extension</span> [f]
  (org.apache.commons.io.FilenameUtils/getExtension f))

(<span>defn</span> <span>file-base-name</span> [f]
  (org.apache.commons.io.FilenameUtils/getBaseName f))

(<span>defn</span> <span>file-exists</span> [f]
  (.exists (file f)))

(<span>defn</span> <span>make-file</span> [p n e]
  (file (<span>str</span> p n <span>&#34;.&#34;</span> e)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4">
<h2 id="sec-4">Runtime</h2>
<p>
Runtime needed to support <a href="#sec-5">Core</a>. <a href="#sec-4-1">Object system</a>, <i>Memory Management</i> etc.
</p>

<div id="outline-container-sec-4-1">
<h3 id="sec-4-1">Object System</h3>
<div id="outline-container-sec-4-1-1">
<h4 id="sec-4-1-1">Base</h4>
<div id="text-4-1-1">
<p>
All our types are derived from the base Object type. Which is a
<code>typedef</code> of <code>obj::base&lt;FERRET_RC_POLICY,FERRET_ALLOCATOR&gt;</code>. See
<a href="#sec-4-2-3">Reference Counting</a> for available reference counting policies and
<i>Memory Allocation</i> for available allocation policies.
</p>

<div>

<pre><span>template</span>&lt;<span>typename</span>&gt;
<span>void</span> <span>type_id</span>(){}

<span>using</span> <span>type_id_t</span> = <span>void</span>(*)();
<span>typedef</span> <span>type_id_t</span> <span>type_t</span>;

<span>class</span> <span>var</span>;
<span>typedef</span> <span>var</span> <span>const</span> &amp; <span>ref</span>;
<span>class</span> <span>seekable_i</span>;

<span>template</span> &lt;<span>typename</span> <span>rc</span>&gt;
<span>class</span> <span>object_i</span> : <span>public</span> <span>rc</span>{
<span>public</span>:
  <span>object_i</span>() { }
  <span>virtual</span> ~<span>object_i</span>() { };

  <span>virtual</span> <span>type_t</span> <span>type</span>() <span>const</span> = 0;

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>virtual</span> <span>void</span> <span>stream_console</span>() <span>const</span> {
    <span>rt</span>::print(<span>&#34;var#&#34;</span>);
    <span>const</span> <span>void</span>* <span>addr</span> = <span>this</span>;
    <span>rt</span>::print(addr);
  }
<span>#endif</span>

  <span>virtual</span> <span>bool</span> <span>equals</span>(<span>ref</span>) <span>const</span>;

  <span>virtual</span> <span>seekable_i</span>* <span>cast_seekable_i</span>() { <span>return</span> <span>nullptr</span>; }

  <span>void</span>* <span>operator</span> <span>new</span>(<span>size_t</span>, <span>void</span>* <span>ptr</span>){ <span>return</span> ptr; }
  <span>void</span>  <span>operator</span> <span>delete</span>(<span>void</span> * <span>ptr</span>){ <span>FERRET_ALLOCATOR</span>::free(ptr); }
};

<span>typedef</span> <span>object_i</span>&lt;FERRET_RC_POLICY&gt; <span>object</span>;
</pre>
</div>

<p>
A <code>pointer_t</code> holds a pointer to a Ferret object. Default <code>pointer_t</code>
does nothing and delegates all requests to a regular <code>object *</code>.  See
<a href="#sec-4-2-1">Pointers</a> for rationale.
</p>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_POINTER_T)
<span>  #define</span> <span>FERRET_POINTER_T</span> <span>memory</span>::<span>pointer</span>&lt;object&gt;
<span>#endif</span>

<span>typedef</span> <span>FERRET_POINTER_T</span> <span>pointer_t</span>;
</pre>
</div>

<p>
A <code>var</code> holds a pointer to an object, everything is passed around as
<code>vars</code> it is responsible for incrementing/decrementing the reference
count, when it reaches zero it will automatically free the object.
</p>

<div>

<pre><span>class</span> <span>var</span>{
<span>public</span>:
  <span>explicit</span> <span>inline</span> <span>var</span>(<span>object</span>* <span>o</span> = <span>nullptr</span>) : obj(o) { inc_ref(); }
  <span>inline</span> <span>var</span>(<span>ref</span> <span>o</span>)   : obj(o.obj) { inc_ref(); }
  <span>inline</span> <span>var</span>(<span>var</span>&amp;&amp; <span>o</span>) : obj(o.detach()) { }

  ~<span>var</span>() { dec_ref(); }

  <span>inline</span> <span>var</span>&amp; <span>operator</span><span>=</span>(<span>var</span>&amp;&amp; <span>other</span>){
    <span>if</span> (<span>this</span> != &amp;other){
      dec_ref();
      obj = other.detach();
    }
    <span>return</span> *<span>this</span>;
  }

  <span>inline</span> <span>var</span>&amp; <span>operator</span><span>=</span> (<span>ref</span> <span>other</span>){
    <span>if</span> (obj != other.obj){
      dec_ref();
      obj = other.obj;
      inc_ref();
    }
    <span>return</span> *<span>this</span>;
  }

  <span>bool</span> <span>equals</span> (<span>ref</span>) <span>const</span>;

  <span>bool</span> <span>operator</span><span>==</span>(<span>ref</span> <span>other</span>) <span>const</span> { <span>return</span> equals(other); }

  <span>bool</span> <span>operator</span><span>!=</span>(<span>ref</span> <span>other</span>) <span>const</span> { <span>return</span> !equals(other); }

  <span>void</span>* <span>operator</span> <span>new</span>(<span>size_t</span>, <span>void</span>* <span>ptr</span>){ <span>return</span> ptr; }

  <span>operator</span> <span>bool</span>() <span>const</span>;

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> {
    <span>if</span> (obj != <span>nullptr</span> )
      obj-&gt;stream_console();
    <span>else</span>
      <span>rt</span>::print(<span>&#34;nil&#34;</span>);
  }
<span>#endif</span>

  <span>inline</span> <span>object</span>* <span>get</span>() <span>const</span> { <span>return</span> obj; }

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>inline</span> <span>T</span>* <span>cast</span>() <span>const</span> { <span>return</span> <span>static_cast</span>&lt;<span>T</span>*&gt;((<span>object</span>*)obj); }

  <span>inline</span> <span>bool</span> <span>is_type</span>(<span>type_t</span> <span>type</span>) <span>const</span> {
    <span>if</span> (obj)
      <span>return</span> (<span>static_cast</span>&lt;<span>object</span>*&gt;(obj)-&gt;type() == type);
    <span>return</span> <span>false</span>;
  }

  <span>inline</span> <span>bool</span> <span>is_nil</span>() <span>const</span> { <span>return</span> (obj == <span>nullptr</span>); }

<span>private</span>:
  <span>object</span>* <span>detach</span>(){
    <span>object</span>* <span>_obj</span> = obj;
    obj = <span>nullptr</span>;
    <span>return</span> _obj;
  }

  <span>inline</span> <span>void</span> <span>inc_ref</span>(){
<span>#if</span> !<span>defined</span>(FERRET_DISABLE_RC)
    <span>// </span><span>Only change if non-null</span>
    <span>if</span> (obj) obj-&gt;inc_ref();
<span>#endif</span>
  }

  <span>inline</span> <span>void</span> <span>dec_ref</span>(){
<span>#if</span> !<span>defined</span>(FERRET_DISABLE_RC)
    <span>// </span><span>Only change if non-null</span>
    <span>if</span> (obj){
      <span>// </span><span>Subtract and test if this was the last pointer.</span>
      <span>if</span> (obj-&gt;dec_ref()){
        <span>delete</span> obj;
        obj = <span>nullptr</span>;
      }
    }
<span>#endif</span>
  }

  <span>pointer_t</span> <span>obj</span>;
};

<span>template</span>&lt;&gt;
<span>inline</span> <span>seekable_i</span>* <span>var</span>::<span>cast</span>&lt;<span>seekable_i</span>&gt;() <span>const</span> { <span>return</span> obj != <span>nullptr</span> ? obj-&gt;cast_seekable_i() : <span>nullptr</span>; }

<span>template</span> &lt;<span>typename</span> <span>rc</span>&gt;
<span>bool</span> <span>object_i</span>&lt;<span>rc</span>&gt;::<span>equals</span>(<span>ref</span> <span>o</span>) <span>const</span> {
  <span>return</span> (<span>this</span> == o.get());
}

<span>#ifdef</span> FERRET_STD_LIB
<span>std</span>::<span>ostream</span> &amp;<span>operator</span><span>&lt;&lt;</span>(<span>std</span>::<span>ostream</span> &amp;<span>os</span>, <span>var</span> <span>const</span> &amp;v) {
  v.stream_console();
  <span>return</span> os;
}
<span>#endif</span>
</pre>
</div>

<p>
All object allocations are done using <code>obj</code> function. It will return a
new <code>var</code> containing a pointer to an <a href="#sec-4-1">Object</a>. <code>nil</code> is represented as a
<code>var</code> pointing to <code>nullptr</code>.
</p>

<div>

<pre><span>var</span> <span>two</span> = obj&lt;number&gt;(2);
<span>var</span> <span>some_nil</span> = nil();
</pre>
</div>

<div>

<pre><span>template</span>&lt;<span>typename</span> <span>FT</span>, <span>typename</span>... Args&gt;
<span>inline</span> <span>var</span> <span>obj</span>(<span>Args</span>... <span>args</span>) {
  <span>void</span> * <span>storage</span> = <span>FERRET_ALLOCATOR</span>::allocate&lt;<span>FT</span>&gt;();
  <span>return</span> var(<span>new</span>(storage) <span>FT</span>(args...));
}

<span>inline</span> <span>var</span> <span>nil</span>(){
  <span>return</span> var();
}
</pre>
</div>


</div>
</div>

<div id="outline-container-sec-4-1-2">
<h4 id="sec-4-1-2">Objects</h4>
<div id="outline-container-sec-4-1-2-1">
<h5 id="sec-4-1-2-1">Boolean</h5>
<div id="text-4-1-2-1">
<p>
The boolean type has two values, false and true, which represent the
traditional boolean values.
</p>

<div>

<pre>(defobject boolean <span>&#34;boolean_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>boolean</span> <span>final</span> : <span>public</span> <span>object</span> {
  <span>const</span> <span>bool</span> <span>value</span>;
<span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>boolean</span>&gt;; }

  <span>bool</span> <span>equals</span>(<span>ref</span> <span>o</span>) <span>const</span> <span>final</span> {
    <span>return</span> (value == o.cast&lt;<span>boolean</span>&gt;()-&gt;container());
  }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>if</span> (value)
      <span>rt</span>::print(<span>&#34;true&#34;</span>);
    <span>else</span>
      <span>rt</span>::print(<span>&#34;false&#34;</span>);
  }
<span>#endif</span>

  <span>explicit</span> <span>boolean</span>(<span>bool</span> <span>b</span>) : value(b) {} 

  <span>bool</span> <span>container</span>() <span>const</span> {
    <span>return</span> value;
  }
};

<span>namespace</span> <span>cached</span>{
  <span>const</span> <span>var</span> <span>true_o</span> = obj&lt;::<span>ferret</span>::boolean&gt;(<span>true</span>);
  <span>const</span> <span>var</span> <span>false_o</span> = obj&lt;::<span>ferret</span>::boolean&gt;(<span>false</span>);
}

<span>var</span>::<span>operator</span> <span>bool</span>() <span>const</span> {
  <span>if</span> (obj == <span>nullptr</span>)
    <span>return</span> <span>false</span>;
  <span>else</span> <span>if</span> (obj-&gt;type() == (<span>type_t</span>)<span>type_id</span>&lt;<span>boolean</span>&gt;)
    <span>return</span> cast&lt;<span>boolean</span>&gt;()-&gt;container();
  <span>else</span>
    <span>return</span> <span>true</span>;
}

<span>bool</span> <span>var</span>::<span>equals</span> (<span>ref</span> <span>other</span>) <span>const</span> {
  <span>if</span> (get() == other.get())
    <span>return</span> <span>true</span>;

  <span>if</span> (!is_nil() &amp;&amp; !other.is_nil()){

    <span>if</span> (<span>rt</span>::is_seqable(*<span>this</span>) &amp;&amp; <span>rt</span>::is_seqable(other))
      <span>return</span> <span>seekable_i</span>::equals(*<span>this</span>, other);
    <span>else</span> <span>if</span> (obj-&gt;type() != other.get()-&gt;type())
      <span>return</span> <span>false</span>;
    <span>else</span>
      <span>return</span> get()-&gt;equals(other);

  }<span>else</span>
    <span>return</span> <span>false</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-2">
<h5 id="sec-4-1-2-2">Pointer / Value</h5>
<div id="text-4-1-2-2">
<p>
A <code>pointer</code> object keeps a reference to a C++ pointer.
</p>

<div>

<pre><span>var</span> <span>num</span> = obj&lt;pointer&gt;(<span>new</span> <span>int</span>(42));
<span>int</span> *<span>ptr</span> = <span>pointer</span>::to_pointer&lt;<span>int</span>&gt;(ptr);
</pre>
</div>

<div>

<pre>(<span>deftest</span> pointer-test
  (<span>let</span> [a-ptr (cxx <span>&#34;return obj&lt;pointer&gt;(nullptr);&#34;</span>)
        b-ptr (cxx <span>&#34;return obj&lt;pointer&gt;(new int);&#34;</span>)

        gc    (<span>fn</span> [p]
                <span>&#34;delete pointer::to_pointer&lt;int&gt;(p);&#34;</span>)]

    (<span>is</span> (<span>=</span> true  (<span>=</span> a-ptr a-ptr)))
    (<span>is</span> (<span>=</span> false (<span>=</span> a-ptr b-ptr)))
    (<span>is</span> (<span>=</span> true  (<span>=</span> b-ptr b-ptr)))

    (gc b-ptr)))
</pre>
</div>

<div>

<pre>(defobject pointer <span>&#34;pointer_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>pointer</span> <span>final</span> : <span>public</span> <span>object</span> {
  <span>void</span> * <span>payload</span>;
<span>public</span>:


  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>pointer</span>&gt;; }

  <span>bool</span> <span>equals</span>(<span>ref</span> <span>o</span>) <span>const</span> <span>final</span> {
    <span>return</span> (payload == o.cast&lt;<span>pointer</span>&gt;()-&gt;payload);
  }

  <span>explicit</span> <span>pointer</span>(<span>void</span>* <span>p</span>) : payload(p) {}

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt; <span>static</span> <span>T</span>* <span>to_pointer</span>(<span>ref</span> <span>v</span>){
    <span>return</span> ((<span>T</span> *) v.cast&lt;<span>pointer</span>&gt;()-&gt;payload);
  }
  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt; <span>static</span> <span>T</span>&amp; <span>to_reference</span>(<span>ref</span> <span>v</span>){
    <span>return</span> (*(<span>pointer</span>::to_pointer&lt;<span>T</span>&gt;(v)));
  }
};
</pre>
</div>

<p>
A <code>value</code> object keeps a native object. Useful when working with
modern C++ libraries that use smart pointers for memory management.
</p>

<div>

<pre>(native-declare <span>&#34;class data{</span>
<span>                     int x;</span>
<span>                   public: </span>

<span>                     explicit data(int _x) : x(_x) {} </span>

<span>                     int  content() { return x; }</span>
<span>                     void inc() { x++; }</span>
<span>                   };&#34;</span>)

(<span>defn</span> <span>make-data</span> [x]
  <span>&#34;return obj&lt;value&lt;data&gt;&gt;(number::to&lt;number_t&gt;(x))&#34;</span>)

(<span>defn</span> <span>get-data</span> [x]
  <span>&#34;return obj&lt;number&gt;((number_t) value&lt;data&gt;::to_value(x).content());&#34;</span>)

(<span>defn</span> <span>inc-data</span> [x]
  <span>&#34;data &amp; d = value&lt;data&gt;::to_reference(x);</span>
<span>     d.inc();&#34;</span>)

(<span>deftest</span> value-test
  (<span>let</span> [obj-42 (make-data 42)
        obj-24 (make-data 24)
        val-42 (get-data obj-42)
        val-24 (get-data obj-24)]
    (<span>is</span> (<span>=</span>    obj-42 obj-42))
    (<span>is</span> (<span>not=</span> obj-42 obj-24))
    (<span>is</span> (<span>=</span>    val-42 42))
    (<span>is</span> (<span>=</span>    val-24 24))
    (<span>is</span> (<span>=</span>    25     (<span>do</span> (inc-data obj-24)
                         (get-data obj-24))))))
</pre>
</div>

<div>

<pre>(defobject value <span>&#34;value_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
<span>class</span> <span>value</span> <span>final</span> : <span>public</span> <span>object</span> {
  <span>T</span> <span>payload</span>;
<span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>value</span>&gt;; }

  <span>template</span> &lt;<span>typename</span>... Args&gt;
  <span>explicit</span> <span>value</span>(<span>Args</span>&amp;&amp;... args) : payload(<span>static_cast</span>&lt;<span>Args</span>&amp;&amp;&gt;(args)...) { } 

  <span>T</span> <span>to_value</span>() <span>const</span> {
    <span>return</span> payload;
  }

  <span>static</span> <span>T</span> <span>to_value</span>(<span>ref</span> <span>v</span>){
    <span>return</span> v.cast&lt;<span>value</span>&lt;<span>T</span>&gt;&gt;()-&gt;payload;
  }

  <span>T</span> &amp; <span>to_reference</span>() {
    <span>return</span> payload;
  }

  <span>static</span> <span>T</span> &amp; <span>to_reference</span>(<span>ref</span> <span>v</span>) {
    <span>return</span> v.cast&lt;<span>value</span>&lt;<span>T</span>&gt;&gt;()-&gt;to_reference();
  }  
};

<span>typedef</span> <span>value</span>&lt;matrix&gt; <span>matrix_t</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-3">
<h5 id="sec-4-1-2-3">Number</h5>
<div id="text-4-1-2-3">
<p>
The number type represents real (double-precision floating-point)
numbers. Ferret has no integer type. On systems without hardware
support for floating point Ferret programs can be configured to use
fixed point numbers. (See <i>Numeric Tower</i> runtime.)
</p>

<div>

<pre>(defobject number <span>&#34;number_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>number</span> <span>final</span> : <span>public</span> <span>object</span> {
  <span>const</span> <span>real_t</span> <span>n</span>;
<span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>number</span>&gt;; }

  <span>bool</span> <span>equals</span>(<span>ref</span> <span>o</span>) <span>const</span> <span>final</span> {
    <span>return</span> (<span>rt</span>::abs(n - <span>number</span>::to&lt;<span>real_t</span>&gt;(o)) &lt; real_epsilon);
  }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>rt</span>::print(n);
  }
<span>#endif</span>

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt; <span>explicit</span> <span>number</span>(<span>T</span> <span>x</span>) : n(<span>real_t</span>(<span>x</span>)) {} 

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt; <span>static</span> <span>T</span> <span>to</span>(<span>ref</span> <span>v</span>){
    <span>return</span> (<span>T</span>)v.cast&lt;<span>number</span>&gt;()-&gt;n;
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-4">
<h5 id="sec-4-1-2-4">Sequence</h5>
<div id="text-4-1-2-4">
<p>
Sequences are collections. They implement the seekable interface
directly. count is O(n). conj puts the item at the front of the list.
</p>

<div>

<pre>(defobject empty_sequence <span>&#34;empty_sequence_o.h&#34;</span>)
(defobject sequence <span>&#34;sequence_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>empty_sequence</span> <span>final</span> : <span>public</span> <span>object</span> {

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>empty_sequence</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>rt</span>::print(<span>&#34;()&#34;</span>);
  }
<span>#endif</span>
};

<span>namespace</span> <span>cached</span>{
  <span>const</span> <span>var</span> <span>empty_sequence_o</span> = obj&lt;::<span>ferret</span>::empty_sequence&gt;();
}
</pre>
</div>

<div>

<pre>  <span>class</span> <span>sequence</span> <span>final</span> : <span>public</span> <span>object</span>, <span>public</span> <span>seekable_i</span> {
    <span>const</span> <span>var</span> <span>next</span>;
    <span>const</span> <span>var</span> <span>data</span>;
  <span>public</span>:

    <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>sequence</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
    <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
      <span>seekable_i</span>::stream_console(var((<span>object</span>*)<span>this</span>));
    }
<span>#endif</span>

    <span>explicit</span> <span>sequence</span>(<span>ref</span> <span>d</span> = nil(), <span>ref</span> <span>n</span> = nil()) : next(n), data(d) {} 

    <span>virtual</span> <span>seekable_i</span>* <span>cast_seekable_i</span>() { <span>return</span> <span>this</span>; }

    <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>) <span>final</span> {
      <span>return</span> obj&lt;<span>sequence</span>&gt;(x, var(<span>this</span>));
    }

    <span>var</span> <span>first</span>() <span>final</span> {
      <span>return</span> data;
    }

    <span>var</span> <span>rest</span>() <span>final</span> {
      <span>return</span> next;
    }

    <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
    <span>static</span> <span>T</span> <span>to</span>(<span>ref</span>){
      <span>T</span>::unimplemented_function;
    }

    <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
    <span>static</span> <span>var</span> <span>from</span>(<span>T</span>){
      <span>T</span>::unimplemented_function; <span>return</span> nil();
    }

  };

  <span>namespace</span> <span>runtime</span> {
    <span>inline</span> <span>var</span> <span>list</span>() { 
      <span>return</span> <span>cached</span>::empty_sequence_o;
    }
    <span>inline</span> <span>var</span> <span>list</span>(<span>ref</span> <span>v</span>) { 
      <span>return</span> obj&lt;<span>sequence</span>&gt;(v,<span>cached</span>::empty_sequence_o);
    }

    <span>template</span> &lt;<span>typename</span>... Args&gt;
    <span>inline</span> <span>var</span> <span>list</span>(<span>ref</span> <span>first</span>, <span>Args</span> <span>const</span> &amp; ... args) { 
      <span>return</span> obj&lt;<span>sequence</span>&gt;(first, list(args...));
    }
  }

<span>  #ifdef</span> FERRET_STD_LIB
  <span>typedef</span> ::<span>std</span>::<span>vector</span>&lt;<span>var</span>&gt;  <span>std_vector</span>;

  <span>template</span> &lt;&gt; <span>std_vector</span> <span>sequence</span>::<span>to</span>(<span>ref</span> <span>v</span>) { 
    <span>std_vector</span> <span>ret</span>;
    for_each(i, v)
      ret.push_back(i);
    <span>return</span> ret;
  }

  <span>template</span> &lt;&gt; <span>var</span> <span>sequence</span>::<span>from</span>(<span>std_vector</span> <span>v</span>) { 
    <span>var</span> <span>ret</span>;
    <span>std</span>::<span>vector</span>&lt;<span>var</span>&gt;::<span>reverse_iterator</span> <span>rit</span>;
    <span>// </span><span>cppcheck-suppress postfixOperator</span>
    <span>for</span>(rit = v.rbegin(); rit != v.rend(); rit++)
      ret = <span>rt</span>::cons(*rit,ret);
    <span>return</span> ret;
  }
<span>  #endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-5">
<h5 id="sec-4-1-2-5">Lazy Sequence</h5>
<div id="text-4-1-2-5">
<p>
Ferret supports lazily evaluated sequences. This means that sequence
elements are not available ahead of time and produced as the result of
a computation. The computation is performed as needed when lazy
sequence is iterated. By default Ferret <code>lazy_sequence=s does not
cache their values unless forced using =lazy-seq-cache</code>.
</p>

<div>

<pre>(defobject lazy_sequence <span>&#34;lazy_sequence_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>lazy_sequence</span> <span>final</span> : <span>public</span> <span>object</span>, <span>public</span> <span>seekable_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>bool</span> <span>cache</span>;
  <span>var</span> <span>thunk</span>;
  <span>var</span> <span>data</span>;
  <span>var</span> <span>seq</span>;

  <span>void</span> <span>yield</span>(){
    <span>if</span> (thunk.is_nil())
      <span>return</span>;

    seq = run(thunk);

    <span>if</span> (data.is_nil()){
      data = <span>rt</span>::first(seq);
      seq = <span>rt</span>::rest(seq);
    }

    thunk = nil();
  }

<span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>lazy_sequence</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>seekable_i</span>::stream_console(var((<span>object</span>*)<span>this</span>));
  }
<span>#endif</span>

  <span>explicit</span> <span>lazy_sequence</span>(<span>ref</span> <span>t</span>, <span>bool</span> <span>c</span> = <span>false</span>) : cache(c), thunk(t) {}
  <span>explicit</span> <span>lazy_sequence</span>(<span>ref</span> <span>d</span>, <span>ref</span> <span>t</span>, <span>bool</span> <span>c</span> = <span>false</span>) : cache(c), thunk(t), data(d) {}

  <span>virtual</span> <span>seekable_i</span>* <span>cast_seekable_i</span>() { <span>return</span> <span>this</span>; }

  <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>) <span>final</span> {
    <span>lock_guard</span> <span>guard</span>(lock);

    <span>if</span> (data.is_nil())
      <span>return</span> obj&lt;<span>lazy_sequence</span>&gt;(x, thunk, cache);

    <span>return</span> obj&lt;sequence&gt;(x, var((<span>object</span>*)<span>this</span>));
  }

  <span>var</span> <span>first</span>() <span>final</span> {
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>if</span> (cache)
      yield();
    <span>else</span>
      <span>if</span> (data.is_nil())
        <span>return</span> <span>rt</span>::first(run(thunk));
    <span>return</span> data;
  }

  <span>var</span> <span>rest</span>() <span>final</span> {
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>var</span> <span>tail</span>;

    <span>if</span> (cache){
      yield();
      tail = seq;
    }<span>else</span>{
      tail = run(thunk);
      <span>if</span> (data.is_nil())
        <span>return</span> <span>rt</span>::rest(tail);
    }

    <span>if</span> (tail.is_nil())
      <span>return</span> <span>rt</span>::<span>list</span>();

    <span>return</span> tail;
  }

  <span>static</span> <span>var</span> <span>from</span>(<span>ref</span> <span>seq</span>) {
    <span>class</span> <span>walk</span> : <span>public</span> <span>lambda_i</span> {
      <span>var</span> <span>seq</span>;
    <span>public</span>:
      <span>explicit</span> <span>walk</span>(<span>ref</span> <span>s</span>) : seq(s) { }
      <span>var</span> <span>invoke</span>(<span>ref</span>) <span>const</span> <span>final</span> {
        <span>var</span> <span>tail</span> = <span>rt</span>::rest(seq);
        <span>if</span> (tail.is_nil())
          <span>return</span> nil();

        <span>return</span> obj&lt;<span>lazy_sequence</span>&gt;(<span>rt</span>::first(seq), obj&lt;<span>walk</span>&gt;(tail), <span>true</span>);
      }
    };

    <span>return</span> obj&lt;<span>lazy_sequence</span>&gt;(obj&lt;<span>walk</span>&gt;(seq), <span>true</span>);
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-6">
<h5 id="sec-4-1-2-6">Array Sequence</h5>
<div id="text-4-1-2-6">
<p>
Creates a view of an array.
</p>

<div>

<pre>(<span>deftest</span> array-seq-test
  (<span>is</span> (<span>=</span> (cxx <span>&#34;int buff[3] = {1,2,3};</span>
<span>               return obj&lt;array_seq&lt;int, number&gt;&gt;(buff, size_t(3));&#34;</span>)
         (<span>list</span> 1 2 3))))
</pre>
</div>

<div>

<pre>(<span>deftest</span> dense-list-test
  (<span>is</span> (<span>=</span> (cxx <span>&#34;return rt::dense_list</span>
<span>                   (obj&lt;number&gt;(42), obj&lt;number&gt;(43));&#34;</span>)
         (<span>list</span> 42 43))))
</pre>
</div>

<div>

<pre>(defobject array_sequence <span>&#34;array_sequence_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>template</span>&lt;<span>typename</span> <span>element_t</span>, <span>typename</span> <span>object_t</span>&gt;
<span>class</span> <span>array_seq</span> : <span>public</span> <span>object</span> , <span>public</span> <span>seekable_i</span> {
  <span>size_t</span> <span>pos</span>;

<span>public</span>:
  <span>typedef</span> <span>array</span>&lt;<span>element_t</span>&gt; <span>array_t</span>;
  <span>typedef</span> <span>value</span>&lt;<span>array_t</span>&gt; <span>value_t</span>;

  <span>var</span> <span>storage</span>;

  <span>explicit</span> <span>array_seq</span>(<span>const</span> <span>element_t</span>* <span>src</span>, <span>size_t</span> <span>s</span> = 0)
    : pos (0), storage(obj&lt;<span>value_t</span>&gt;(src, s)) { }

  <span>explicit</span> <span>array_seq</span>(<span>var</span> <span>b</span>, <span>size_t</span> <span>p</span> = 0) : pos(p), storage(b){ }

  <span>explicit</span> <span>array_seq</span>(<span>size_t</span> <span>size</span>) : pos(0), storage(obj&lt;<span>value_t</span>&gt;(size)){ }

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>array_seq</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
    <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
      <span>seekable_i</span>::stream_console(var((<span>object</span>*)<span>this</span>));
    }
<span>#endif</span>

  <span>virtual</span> <span>seekable_i</span>* <span>cast_seekable_i</span>() { <span>return</span> <span>this</span>; }

  <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>) <span>final</span> {
    <span>return</span> obj&lt;sequence&gt;(x, var(<span>this</span>));
  }

  <span>var</span> <span>first</span>() <span>final</span> {
    <span>array_t</span>&amp; <span>b</span> = <span>value_t</span>::to_reference(storage);
    <span>return</span> obj&lt;<span>object_t</span>&gt;(b[pos]);
  }

  <span>var</span> <span>rest</span>() <span>final</span> {
    <span>array_t</span>&amp; <span>b</span> = <span>value_t</span>::to_reference(storage);

    <span>if</span> (pos &lt; b.size() - 1)
      <span>return</span> obj&lt;<span>array_seq</span>&gt;(storage, pos + 1);

    <span>return</span> <span>rt</span>::<span>list</span>();
  }
};
</pre>
</div>

<div>

<pre><span>template</span> &lt;&gt;
<span>class</span> <span>array</span>&lt;var&gt; {
  <span>size_t</span>  <span>_size</span>{0};

  <span>var</span>* <span>allocate</span>(){
    <span>var</span>* <span>storage</span> = <span>static_cast</span>&lt;<span>var</span>*&gt;(<span>FERRET_ALLOCATOR</span>::allocate(<span>_size</span> * <span>sizeof</span>(<span>var</span>))) ;
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; _size; i++)
      <span>new</span> (&amp;storage[i]) <span>var</span>();
    <span>return</span> storage;
  }

<span>public</span>:

  var* <span>data</span> {<span>nullptr</span>};

  <span>explicit</span> <span>inline</span> <span>array</span>(<span>size_t</span> <span>s</span> = 0) : _size(s), <span>data</span>(<span>allocate</span>()) { }

  <span>inline</span> <span>array</span>(<span>array</span>&amp;&amp; <span>m</span>) :
    _size(m.size()), data(m.data) { m.data = <span>nullptr</span>; }

  <span>inline</span> <span>array</span>(<span>array</span>&amp; <span>m</span>) : _size(m.size()), <span>data</span>(<span>allocate</span>()) {
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; _size; i++)
      data[i] = m.data[i];
  }

  ~<span>array</span>(){
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; size(); i++)
      (&amp;data[i])-&gt;~var();
    <span>FERRET_ALLOCATOR</span>::free(<span>data</span>);
  }

  <span>inline</span> <span>array</span>&amp; <span>operator</span><span>=</span>(<span>array</span>&amp;&amp; <span>x</span>){
    data = x.data;
    _size = x._size;
    x.data = <span>nullptr</span>;
    <span>return</span> *<span>this</span>;
  }

  <span>inline</span> <span>var</span>&amp; <span>operator</span> <span>[]</span>(<span>size_t</span> <span>idx</span>)      { <span>return</span> data[idx]; }
  <span>inline</span> <span>var</span> <span>operator</span> <span>[]</span>(<span>size_t</span> <span>idx</span>) <span>const</span> { <span>return</span> data[idx]; }

  <span>inline</span> <span>var</span>*    <span>begin</span>() <span>const</span> { <span>return</span> &amp;data[0];      }
  <span>inline</span> <span>var</span>*    <span>end</span>()   <span>const</span> { <span>return</span> &amp;data[_size];  }
  <span>inline</span> <span>size_t</span>  <span>size</span>()  <span>const</span> { <span>return</span> _size;         }
};
</pre>
</div>

<div>

<pre><span>typedef</span> <span>array</span>&lt;var&gt; <span>var_array_t</span>;
<span>typedef</span> <span>value</span>&lt;<span>var_array_t</span>&gt; <span>var_array</span>;
<span>typedef</span> <span>array_seq</span>&lt;var,var&gt; <span>var_array_seq</span>;

<span>template</span>&lt;&gt;
<span>class</span> <span>array_seq</span>&lt;var,var&gt; : <span>public</span> object , <span>public</span> seekable_i {
  <span>size_t</span> <span>pos</span>{0};

  <span>inline</span> <span>static</span> <span>void</span> <span>into_aux</span>(ref){ }

  <span>template</span>&lt;<span>typename</span>... Args&gt;
  <span>inline</span> <span>static</span> <span>void</span> <span>into_aux</span>(<span>ref</span> <span>arr</span>, <span>ref</span> <span>first</span>, <span>Args</span>... <span>rest</span>){
    <span>auto</span>&amp; <span>data</span> = <span>var_array</span>::to_reference(arr);
    data[data.size() - <span>sizeof</span>...(rest) - 1] = first;
    into_aux(arr, rest...);
  }

<span>public</span>:
  <span>var</span> <span>storage</span>;

  <span>explicit</span> <span>array_seq</span>(<span>var</span> <span>b</span>, <span>size_t</span> <span>p</span> = 0) : pos(p), storage(b){ }

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;array_seq&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
    <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
      <span>seekable_i</span>::stream_console(var((<span>object</span>*)<span>this</span>));
    }
<span>#endif</span>

  <span>virtual</span> <span>seekable_i</span>* <span>cast_seekable_i</span>() { <span>return</span> <span>this</span>; }

  <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>) <span>final</span> {
    <span>return</span> obj&lt;sequence&gt;(x, var(<span>this</span>));
  }

  <span>var</span> <span>first</span>() <span>final</span> {
    <span>var_array_t</span>&amp; <span>b</span> = <span>var_array</span>::to_reference(storage);
    <span>return</span> b[pos];
  }

  <span>var</span> <span>rest</span>() <span>final</span> {
    <span>var_array_t</span>&amp; <span>b</span> = <span>var_array</span>::to_reference(storage);

    <span>if</span> (pos &lt; b.size() - 1)
      <span>return</span> obj&lt;array_seq&gt;(storage, pos + 1);

    <span>return</span> <span>rt</span>::<span>list</span>();
  }

  <span>template</span>&lt;<span>typename</span>... Args&gt;
  <span>static</span> <span>inline</span> <span>var</span> <span>into</span>(<span>Args</span>... <span>rest</span>){
    <span>var</span> <span>arr</span> = obj&lt;<span>var_array</span>&gt;(<span>sizeof</span>...(rest));
    into_aux(arr, rest...);
    <span>return</span> obj&lt;<span>var_array_seq</span>&gt;(arr);
  }
};

<span>namespace</span> <span>runtime</span>{
  <span>template</span>&lt;<span>typename</span>... Args&gt;
  <span>static</span> <span>inline</span> <span>var</span> <span>dense_list</span>(<span>Args</span>... <span>rest</span>){
    <span>return</span> <span>var_array_seq</span>::into(rest...);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-7">
<h5 id="sec-4-1-2-7">D-List</h5>
<div id="text-4-1-2-7">
<p>
D-List, or Detached List, analogous to an A-List or a P-List are  more
suited to embedded systems. For quite small values of n it is more
efficient in terms of time and space than more sophisticated
strategies such as hash tables.
</p>

<p>
A D-list is a cons of a list of keys and a list of values, i.e.:
</p>

<pre>((key1 key2 ...) val1 val2 ...)
</pre>

<div>

<pre>(<span>deftest</span> d-list-test
  (<span>let</span> [m (new-d-list 0 (<span>list</span> 0 1)
                      1 (<span>list</span> 1 2))
        mr {<span>:a</span> 1 <span>:b</span> 2}
        mn {1 2 3 4}]

    (<span>is</span> (<span>=</span> {1 2}                         {1 2}))
    (<span>is</span> (<span>not=</span> mn                         {1 2}))
    (<span>is</span> (<span>=</span> (<span>list</span> 0 1)                    (<span>keys</span> m)))
    (<span>is</span> (<span>=</span> (<span>list</span> (<span>list</span> 0 1) (<span>list</span> 1 2))  (<span>vals</span> m)))
    (<span>is</span> (<span>=</span> (<span>list</span> 1 2)                    (m 1)))
    (<span>is</span> (<span>=</span> m                             m))
    (<span>is</span> (<span>=</span> (<span>list</span> 0)                      (<span>keys</span> (<span>dissoc</span> m 1))))
    (<span>is</span> (<span>=</span> mr                            mr))
    (<span>is</span> (<span>=</span> (<span>list</span> <span>:a</span> <span>:b</span>)                  (<span>keys</span> mr)))
    (<span>is</span> (<span>=</span> (<span>list</span> 1  2)                   (<span>vals</span> mr)))
    (<span>is</span> (<span>=</span> 1                             (<span>:a</span> mr)))
    (<span>is</span> (<span>=</span> 1                             (<span>get</span> mr <span>:a</span> 10)))
    (<span>is</span> (<span>=</span> 10                            (<span>get</span> mr <span>:c</span> 10)))
    (<span>is</span> (<span>=</span> 1                             (mr <span>:a</span>)))
    (<span>is</span> (<span>=</span> 1                             (mr <span>:a</span> 10)))
    (<span>is</span> (<span>=</span> 10                            (mr <span>:c</span> 10)))
    (<span>is</span> (<span>=</span> 1                             (<span>:a</span> mr)))
    (<span>is</span> (<span>=</span> 1                             (<span>:a</span> mr 10)))
    (<span>is</span> (<span>=</span> 10                            (<span>:c</span> mr 10)))
    (<span>is</span> (<span>=</span> 6                             (<span>-&gt;&gt;</span> mn
                                              (<span>map</span> second)
                                              (<span>apply</span> +))))))
</pre>
</div>

<div>

<pre>(defobject d-list <span>&#34;d_list_o.h&#34;</span>)

(<span>defn</span> <span>new-d-list-aux</span> [keys vals]
  <span>&#34;return obj&lt;d_list&gt;(keys, vals);&#34;</span>)

(<span>defmacro</span> <span>new-d-list</span> [&amp; args]
  (<span>let</span> [kvs (<span>partition</span> 2 args)
        keys (<span>map</span> first kvs)
        vals (<span>map</span> second kvs)]
    `(new-d-list-aux
      (<span>list</span> <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="403e002b253933">[email protected]</a>) (<span>list</span> <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="037d4375626f70">[email protected]</a>))))

(<span>defn</span> <span>assoc</span> [m k v]
  <span>&#34;return m.cast&lt;map_t&gt;()-&gt;assoc(k,v);&#34;</span>)

(<span>defn</span> <span>dissoc</span> [m k]
  <span>&#34;return m.cast&lt;map_t&gt;()-&gt;dissoc(k);&#34;</span>)

(<span>defn</span> <span>get</span> [m &amp; args]
  <span>&#34;return m.cast&lt;map_t&gt;()-&gt;val_at(args);&#34;</span>)

(<span>defn</span> <span>vals</span> [m]
  <span>&#34;return m.cast&lt;map_t&gt;()-&gt;vals();&#34;</span>)

(<span>defn</span> <span>keys</span> [m]
  <span>&#34;return m.cast&lt;map_t&gt;()-&gt;keys();&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>d_list</span> <span>final</span> : <span>public</span> <span>lambda_i</span>, <span>public</span> <span>seekable_i</span> {

  <span>var</span> <span>data</span>;

  <span>var</span> <span>dissoc_aux</span>(<span>ref</span> <span>k</span>) <span>const</span> {
    <span>ref</span> <span>_keys</span> = <span>rt</span>::first(data);
    <span>var</span> <span>_values</span> = <span>rt</span>::rest(data);

    <span>var</span> <span>new_keys</span>;
    <span>var</span> <span>new_values</span>;

    <span>for_each</span>(i, _keys){
      <span>if</span> ( i == k)
        <span>continue</span>;
      new_keys = <span>rt</span>::cons(i, new_keys);
      new_values = <span>rt</span>::cons(<span>rt</span>::first(_values), new_values);
      _values = <span>rt</span>::rest(_values);
    }

    <span>return</span> <span>rt</span>::cons(new_keys,new_values);
  }

 <span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>d_list</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    data.stream_console();
  }
<span>#endif</span>

  <span>explicit</span> <span>d_list</span>() : data(<span>rt</span>::<span>list</span>(<span>rt</span>::<span>list</span>())) { }
  <span>explicit</span> <span>d_list</span>(<span>ref</span> <span>l</span>) : data(l) { }

  <span>var</span> <span>assoc</span>(<span>ref</span> <span>k</span>, <span>ref</span> <span>v</span>) <span>const</span> {
    <span>ref</span> <span>map</span> = dissoc_aux(k);
    <span>ref</span> <span>_keys</span> = <span>rt</span>::first(map);
    <span>ref</span> <span>_values</span> = <span>rt</span>::rest(map);

    <span>return</span> obj&lt;<span>d_list</span>&gt;(<span>rt</span>::cons(<span>rt</span>::cons(k,_keys),
                                     <span>rt</span>::cons(v,_values)));
  }

  <span>var</span> <span>dissoc</span>(<span>ref</span> <span>k</span>) <span>const</span> {
    <span>return</span> obj&lt;<span>d_list</span>&gt;(dissoc_aux(k));
  }

  <span>var</span> <span>val_at</span>(<span>ref</span> <span>args</span>) <span>const</span> {
    <span>ref</span> <span>key</span> = <span>rt</span>::first(args);
    <span>ref</span> <span>not_found</span> = <span>rt</span>::first(<span>rt</span>::rest(args));

    <span>ref</span> <span>_keys</span> = <span>rt</span>::first(data);
    <span>var</span> <span>_values</span> = <span>rt</span>::rest(data);

    <span>for_each</span>(i, _keys){
      <span>if</span> (key == i)
        <span>return</span> <span>rt</span>::first(_values);

      _values = <span>rt</span>::rest(_values);
    }

    <span>if</span> (!not_found.is_nil()){
      <span>return</span> not_found;
    }<span>else</span>{
      <span>return</span> nil();  
    }
  }

  <span>var</span> <span>invoke</span>(<span>ref</span> <span>args</span>) <span>const</span> <span>final</span> {
    <span>return</span> val_at(args);
  }

  <span>var</span> <span>vals</span> () <span>const</span> { <span>return</span> <span>rt</span>::rest(data);}
  <span>var</span> <span>keys</span> () <span>const</span> { <span>return</span> <span>rt</span>::first(data);}

  <span>virtual</span> <span>seekable_i</span>* <span>cast_seekable_i</span>() { <span>return</span> <span>this</span>; }

  <span>var</span> <span>cons</span>(<span>ref</span> <span>v</span>) <span>final</span> {
    <span>return</span> <span>rt</span>::<span>list</span>(v,data);
  }

  <span>var</span> <span>first</span>() <span>final</span> {
    <span>ref</span> <span>_keys</span> = <span>rt</span>::first(data);
    <span>ref</span> <span>_values</span> = <span>rt</span>::rest(data);
    <span>return</span> <span>rt</span>::<span>list</span>(<span>rt</span>::<span>first</span>(<span>_keys</span>),<span>rt</span>::<span>first</span>(<span>_values</span>));
  }

  <span>var</span> <span>rest</span>() <span>final</span> {
    <span>ref</span> <span>_keys</span> = <span>rt</span>::first(data);
    <span>ref</span> <span>_values</span> = <span>rt</span>::rest(data);

    <span>if</span>(<span>rt</span>::rest(_keys).is_type(<span>type_id</span>&lt;empty_sequence&gt;))
      <span>return</span> <span>rt</span>::<span>list</span>();

    <span>return</span> obj&lt;<span>d_list</span>&gt;(<span>rt</span>::cons(<span>rt</span>::rest(_keys),<span>rt</span>::rest(_values)));
  }
};

<span>template</span>&lt;&gt;
<span>inline</span> <span>var</span> <span>obj</span>&lt;<span>d_list</span>&gt;(<span>var</span> <span>keys</span>, <span>var</span> <span>vals</span>) {
  <span>void</span> * <span>storage</span> = <span>FERRET_ALLOCATOR</span>::allocate&lt;<span>d_list</span>&gt;();
  <span>return</span> var(<span>new</span>(storage) <span>d_list</span>(<span>rt</span>::cons(keys,vals)));
}

<span>#if</span> !<span>defined</span>(FERRET_MAP_TYPE)
<span>typedef</span> <span>d_list</span> <span>map_t</span>;
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-8">
<h5 id="sec-4-1-2-8">Keyword</h5>
<div id="text-4-1-2-8">
<p>
Keywords are symbolic identifiers that evaluate to themselves. They
provide very fast equality tests. A <code>keyword</code> holds a simple hash of
the keyword as <code>number_t</code>.
</p>

<div>

<pre>(<span>deftest</span> keyword-test
  (<span>is</span> (<span>=</span> true  (<span>=</span> <span>:test</span>  <span>:test</span>)))
  (<span>is</span> (<span>=</span> false (<span>=</span> <span>:test</span>  <span>:other_test</span>)))
  (<span>is</span> (<span>=</span> true  (<span>=</span> <span>:space</span> (cxx <span>&#34;return obj&lt;keyword&gt;(\&#34;:space\&#34;)&#34;</span>)))))
</pre>
</div>

<div>

<pre>(defobject keyword <span>&#34;keyword_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>keyword</span> <span>final</span> : <span>public</span> <span>lambda_i</span> {
  <span>const</span> <span>number_t</span> <span>hash</span>;

  <span>static</span> <span>constexpr</span> <span>number_t</span> <span>hash_key</span>(<span>const</span> <span>char</span> * <span>key</span>){
    <span>return</span> *key ? (<span>number_t</span>)*key + hash_key(key + 1) : 0;
  }

<span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>keyword</span>&gt;; }

  <span>bool</span> <span>equals</span>(<span>ref</span> <span>o</span>) <span>const</span> <span>final</span> { <span>return</span> (hash == o.cast&lt;<span>keyword</span>&gt;()-&gt;hash); }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>rt</span>::print(<span>&#34;keyword#&#34;</span>);
    <span>rt</span>::print(hash);
  }
<span>#endif</span>

  <span>explicit</span> <span>keyword</span>(<span>number_t</span> <span>w</span>) : hash(w) {} 
  <span>explicit</span> <span>keyword</span>(<span>const</span> <span>char</span> * <span>str</span>): <span>hash</span>(<span>hash_key</span>(str)) { }

  <span>var</span> <span>invoke</span>(<span>ref</span> <span>args</span>) <span>const</span> <span>final</span> {
    <span>ref</span> <span>map</span> = <span>rt</span>::first(args);
    <span>ref</span> <span>map_args</span> = <span>rt</span>::cons(var((<span>object</span>*)<span>this</span>), <span>rt</span>::rest(args));

    <span>if</span> (map.is_type(<span>type_id</span>&lt;<span>map_t</span>&gt;)){
      <span>return</span> map.cast&lt;<span>map_t</span>&gt;()-&gt;val_at(map_args);
    }

    <span>return</span> nil();
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-9">
<h5 id="sec-4-1-2-9">String</h5>
<div id="text-4-1-2-9">
<p>
Ferret strings are represented as a <a href="#sec-4-1-2-4">Sequence</a> of numbers each
representing a character in the string. This scheme uses more memory
but provides low memory fragmentation and ability to use sequence
operations on strings.
</p>

<div>

<pre>(defobject string <span>&#34;string_o.h&#34;</span>)
</pre>
</div>

<div>

<pre>(<span>deftest</span> string-test
  (<span>let</span> [s1       <span>&#34;Some String&#34;</span>
        s1-added <span>&#34;ASome String&#34;</span>
        s2       <span>&#34;Other String&#34;</span>

        s1-ret   (<span>fn</span> []
                   <span>&#34;return obj&lt;string&gt;(\&#34;Some String\&#34;);&#34;</span>)
        s1-eq    (<span>fn</span> [s]
                   <span>&#34;return obj&lt;boolean&gt;((string::to&lt;std::string&gt;(s) == \&#34;Some String\&#34;))&#34;</span>)

        s2       <span>&#34;Ali Topu At&#34;</span>

        s3       (<span>fn</span> [] <span>&#34;std::string s = \&#34;Some String\&#34;;</span>
<span>                          return obj&lt;string&gt;(s);&#34;</span>)]

    (<span>is</span> (<span>=</span> s2        (new-string <span>&#34;Ali Topu At&#34;</span>)))
    (<span>is</span> (<span>=</span> false     (<span>=</span> s1 s2)))
    (<span>is</span> (<span>=</span> true      (<span>=</span> s1 s1)))
    (<span>is</span> (<span>=</span> true      (<span>=</span> s1 (s3))))
    (<span>is</span> (<span>=</span> false     (<span>=</span> s1 3.14)))
    (<span>is</span> (<span>=</span> true      (<span>=</span> s1 (s1-ret))))
    (<span>is</span> (<span>=</span> true      (s1-eq s1)))
    (<span>is</span> (<span>=</span> 99        \c))
    (<span>is</span> (<span>=</span> \S        (<span>first</span> s1)))
    (<span>is</span> (<span>=</span> s1-added  (<span>cons</span> 65 s1)))
    (<span>is</span> (<span>=</span> s1        (<span>rest</span> (<span>cons</span> 65 s1))))
    (<span>is</span> (<span>=</span> 11        (<span>count</span> s1)))
    (<span>is</span> (<span>true?</span>       (<span>string?</span> s1)))
    (<span>is</span> (<span>false?</span>      (<span>string?</span> 42)))))
</pre>
</div>

<p>
Defines a function that returns a given string. Can be used to return
strings from functions. Due to the way FFI interface is designed
strings can not be returned from functions because they are
interpreted as FFI calls.
</p>

<div>

<pre>(<span>defn</span> <span>new-string</span>
  ([]
   <span>&#34;&#34;</span>)
  ([x]
   <span>&#34;return obj&lt;string&gt;(x);&#34;</span>)
  ([x y]
   (new-string (<span>concat</span> x y)))
  ([x y &amp; more]
   (new-string (<span>concat</span> x y) (<span>apply</span> concat more))))
</pre>
</div>

<div>

<pre><span>class</span> <span>string</span> <span>final</span> : <span>public</span> <span>object</span>, <span>public</span> <span>seekable_i</span> {
  <span>var</span> <span>data</span>;

  <span>typedef</span> <span>array_seq</span>&lt;byte, number&gt; <span>array_seq_t</span>;
  <span>typedef</span> <span>array</span>&lt;byte&gt; <span>array_t</span>;

  <span>void</span> <span>from_char_pointer</span>(<span>const</span> <span>char</span> * <span>str</span>, <span>int</span> <span>length</span>){
    data = obj&lt;<span>array_seq_t</span>&gt;((<span>byte</span>*)str, (<span>size_t</span>)(length + 1));

    <span>var</span> <span>seq</span> = (data.cast&lt;<span>array_seq_t</span>&gt;()-&gt;storage);
    <span>auto</span> &amp; <span>arr</span> = <span>value</span>&lt;<span>array_t</span>&gt;::to_reference(seq).data;
    arr[length] = 0x00;
  }

<span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>string</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>var</span> <span>packed</span> = <span>string</span>::pack(var((<span>object</span>*)<span>this</span>));
    <span>char</span>* <span>str</span> = <span>string</span>::c_str(packed);
    <span>rt</span>::print(str);
  }
<span>#endif</span>

  <span>explicit</span> <span>string</span>() : data(<span>rt</span>::<span>list</span>()) {} 

  <span>explicit</span> <span>string</span>(<span>ref</span> <span>s</span>) : data(s) {}

  <span>explicit</span> <span>string</span>(<span>const</span> <span>char</span> * <span>str</span>) {
    <span>int</span> <span>length</span> = 0;
    <span>for</span> (length = 0; str[length] != 0x00; ++length);
    from_char_pointer(str, length);
  }

  <span>explicit</span> <span>string</span>(<span>const</span> <span>char</span> * <span>str</span>,<span>number_t</span> <span>length</span>) { from_char_pointer(str,length); }

  <span>virtual</span> <span>seekable_i</span>* <span>cast_seekable_i</span>() { <span>return</span> <span>this</span>; }

  <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>) <span>final</span> {
    <span>return</span> obj&lt;<span>string</span>&gt;(<span>rt</span>::cons(x,data));
  }

  <span>var</span> <span>first</span>() <span>final</span> {
    <span>return</span> <span>rt</span>::first(data);
  }

  <span>var</span> <span>rest</span>() <span>final</span> {
    <span>ref</span> <span>r</span> = <span>rt</span>::rest(data);

    <span>if</span> (r.is_type(<span>type_id</span>&lt;<span>array_seq_t</span>&gt;))
      <span>if</span> (<span>rt</span>::first(r) == obj&lt;number&gt;(0))
        <span>return</span> <span>rt</span>::<span>list</span>();

    <span>if</span> (!r.is_type(<span>type_id</span>&lt;empty_sequence&gt;))
      <span>return</span> obj&lt;<span>string</span>&gt;(r);

    <span>return</span> <span>rt</span>::<span>list</span>();
  }

  <span>static</span> <span>var</span> <span>pack</span>(<span>ref</span> <span>s</span>)  {
    <span>if</span> (s.cast&lt;<span>string</span>&gt;()-&gt;data.is_type(<span>type_id</span>&lt;<span>array_seq_t</span>&gt;))
      <span>return</span> s.cast&lt;<span>string</span>&gt;()-&gt;data;

    <span>size_t</span> <span>size</span> = <span>rt</span>::count(s);
    <span>var</span> <span>packed_array</span> = obj&lt;<span>value</span>&lt;<span>array_t</span>&gt;&gt;(size + 1);
    <span>auto</span>&amp; <span>packed_data</span> = <span>value</span>&lt;<span>array_t</span>&gt;::to_reference(packed_array).data;

    <span>size_t</span> <span>pos</span> = 0;
    <span>for_each</span>(c, s){
      packed_data[pos] = <span>number</span>::to&lt;<span>byte</span>&gt;(c);
      pos++;
    }
    packed_data[pos] = 0x00;

    <span>return</span> obj&lt;<span>array_seq_t</span>&gt;(packed_array);
  }

  <span>static</span> <span>char</span>* <span>c_str</span>(<span>ref</span> <span>s</span>)  {
    <span>var</span> <span>seq</span> = (s.cast&lt;<span>array_seq_t</span>&gt;()-&gt;storage);
    <span>auto</span> &amp; <span>str</span> = <span>value</span>&lt;<span>array</span>&lt;<span>byte</span>&gt;&gt;::to_reference(seq).data;
    <span>return</span> (<span>char</span>*) str;
  }

  <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
  <span>static</span> <span>T</span> <span>to</span>(<span>ref</span>){
    <span>T</span>::unimplemented_function;
  }
};

<span>#ifdef</span> FERRET_STD_LIB
<span>template</span>&lt;&gt;
<span>inline</span> <span>var</span> <span>obj</span>&lt;<span>string</span>&gt;(<span>std</span>::<span>string</span> <span>s</span>) {
  <span>void</span> * <span>storage</span> = <span>FERRET_ALLOCATOR</span>::allocate&lt;<span>string</span>&gt;();
  <span>return</span> var(<span>new</span>(storage) <span>string</span>(s.c_str(), (<span>number_t</span>)s.size()));
}

<span>template</span> &lt;&gt; ::<span>std</span>::<span>string</span> <span>string</span>::<span>to</span>(<span>ref</span> <span>str</span>) {
  <span>var</span> <span>packed</span> = <span>string</span>::pack(str);
  <span>return</span> <span>std</span>::<span>string</span>(<span>string</span>::<span>c_str</span>(<span>packed</span>));
}
<span>#endif</span>

<span>#ifdef</span> FERRET_HARDWARE_ARDUINO
<span>template</span>&lt;&gt;
<span>inline</span> <span>var</span> <span>obj</span>&lt;<span>string</span>&gt;(<span>String</span> <span>s</span>) {
  <span>void</span> * <span>storage</span> = <span>FERRET_ALLOCATOR</span>::allocate&lt;<span>string</span>&gt;();
  <span>return</span> var(<span>new</span>(storage) <span>string</span>(s.c_str(), (<span>number_t</span>)s.length()));
}

<span>template</span> &lt;&gt; <span>String</span> <span>string</span>::<span>to</span>(<span>ref</span> <span>str</span>) {
  <span>var</span> <span>packed</span> = <span>string</span>::pack(str);
  <span>return</span> String(<span>string</span>::c_str(packed));
}
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-10">
<h5 id="sec-4-1-2-10">Atom</h5>
<div id="text-4-1-2-10">
<p>
Atoms provide a way to manage shared, synchronous, independent state.
The intended use of atom is to hold one of Ferret’s immutable data
structures.  You create an atom with <code>atom</code>, and can access its state
with <code>deref/@</code>.  To change the value of an atom, you can use <code>swap!</code>
or <code>reset!</code>. Changes to atoms are always free of race conditions.
</p>

<div>

<pre>(<span>deftest</span> atom-test
  (<span>let</span> [a (<span>atom</span> nil)
        b (<span>atom</span> nil)]

    (<span>is</span> (<span>=</span> nil          (<span>deref</span> a)))
    (<span>is</span> (<span>=</span> 1            @(<span>atom</span> 1)))

    (<span>is</span> (<span>=</span> 1            (<span>do</span> (<span>reset!</span> a 1)   (<span>deref</span> a))))
    (<span>is</span> (<span>=</span> 2            (<span>do</span> (<span>swap!</span>  a inc) (<span>deref</span> a))))

    (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3) (<span>do</span> (<span>reset!</span> a (<span>list</span> 1 2 3))
                            (<span>deref</span> a))))
    (<span>is</span> (<span>=</span> 6            (<span>do</span> (<span>swap!</span>  a (<span>fn</span> [l] (<span>reduce</span> + l)))
                            (<span>deref</span> a))))

    (<span>is</span> (<span>=</span> true         (<span>=</span> a a)))
    (<span>is</span> (<span>=</span> false        (<span>=</span> a b)))
    (<span>is</span> (<span>=</span> false        (<span>=</span> a 3.14)))))
</pre>
</div>

<div>

<pre>(defobject atomic <span>&#34;atomic_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>atomic</span> <span>final</span> : <span>public</span> <span>deref_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>var</span> <span>data</span>;

  <span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>atomic</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>rt</span>::print(<span>&#34;atom&lt;&#34;</span>);
    data.stream_console();
    <span>rt</span>::print(<span>&#39;&gt;&#39;</span>);
  }
<span>#endif</span>

  <span>explicit</span> <span>atomic</span>(<span>ref</span> <span>d</span>) : data(d) {} 

  <span>var</span> <span>swap</span>(<span>ref</span> <span>f</span>, <span>ref</span> <span>args</span>){
    <span>lock_guard</span> <span>guard</span>(lock);
    data = f.cast&lt;lambda_i&gt;()-&gt;invoke(<span>rt</span>::cons(data, args));
    <span>return</span> data;
  }

  <span>var</span> <span>reset</span>(<span>ref</span> <span>newval</span>){
    <span>lock_guard</span> <span>guard</span>(lock);
    data = newval;
    <span>return</span> data;
  }

  <span>var</span> <span>deref</span>() <span>final</span> {
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>return</span> data;
  }
};
</pre>
</div>

<p>
Operations on <code>atoms</code>
</p>

<div>

<pre>(<span>defn</span> <span>atom</span> [x]
  <span>&#34;return obj&lt;atomic&gt;(x)&#34;</span>)

(<span>defn</span> <span>swap!</span> [a f &amp; args]
  <span>&#34;return a.cast&lt;atomic&gt;()-&gt;swap(f,args);&#34;</span>)

(<span>defn</span> <span>reset!</span> [a newval]
  <span>&#34;return a.cast&lt;atomic&gt;()-&gt;reset(newval);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-11">
<h5 id="sec-4-1-2-11">Future</h5>
<div id="text-4-1-2-11">
<p>
Takes a body of expressions and yields a future object that will
invoke the body in another thread, and will cache the result and
return it on all subsequent calls to <code>deref</code>. If the computation has
not yet finished, calls to <code>deref</code> will block.
</p>

<div>

<pre>(<span>deftest</span> future-test
  (<span>is</span> (<span>=</span> 42    @(<span>future</span> (<span>+</span> 41 1))))
  (<span>is</span> (<span>=</span> 42    @(<span>future</span> (sleep 100) (<span>+</span> 40 2))))

  (<span>is</span> (<span>=</span> false  (<span>future-done?</span>
                 (<span>future</span> (sleep 100) <span>:false</span>))))

  (<span>is</span> (<span>=</span> true   (<span>let</span> [f (<span>future</span> <span>:true</span>)]
                  (<span>deref</span> f)
                  (<span>future-done?</span> f))))

  (<span>is</span> (<span>=</span> 42    @(thread #(<span>+</span> 41 1)))))
</pre>
</div>

<div>

<pre>(defobject async <span>&#34;async_o.h&#34;</span>)

(<span>defmacro</span> <span>future</span> [&amp; body]
  `(_future_ (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="d2ac92b0bdb6ab">[email protected]</a>)))

(<span>defn</span> <span>_future_</span> [f] <span>&#34;return obj&lt;async&gt;(f);&#34;</span>)

(<span>defn</span> <span>future-done?</span> [f]
  <span>&#34;if (f.cast&lt;async&gt;()-&gt;is_ready())</span>
<span>     return cached::true_o;</span>
<span>   else</span>
<span>     return cached::false_o;&#34;</span>)
</pre>
</div>

<p>
Divert <b>depricated</b> thread macro which runs the given lambda in a
thread to <code>future</code>,
</p>

<div>

<pre>(<span>defn</span> <span>thread</span> [f]
  <span>&#34;return obj&lt;async&gt;(f);&#34;</span>)
</pre>
</div>

<div>

<pre><span>#ifdef</span> FERRET_STD_LIB
<span>class</span> <span>async</span> <span>final</span> : <span>public</span> <span>deref_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>bool</span> <span>cached</span>;
  <span>var</span> <span>value</span>;
  <span>var</span> <span>fn</span>;
  <span>std</span>::<span>future</span>&lt;<span>var</span>&gt; <span>task</span>;

  <span>inline</span> <span>var</span> <span>exec</span>() {
    <span>return</span> run(fn);
  }

  <span>public</span>:

  <span>explicit</span> <span>async</span>(<span>ref</span> <span>f</span>) :
    cached(<span>false</span>), value(nil()), fn(f), 
    task(<span>std</span>::<span>async</span>(<span>std</span>::<span>launch</span>::async, [<span>this</span>](){ <span>return</span> exec(); })){ }

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>async</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>rt</span>::print(<span>&#34;future&lt;&#34;</span>);
    fn.stream_console();
    <span>rt</span>::print(<span>&#39;&gt;&#39;</span>);
  }
<span>#endif</span>

  <span>bool</span> <span>is_ready</span>(){
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>if</span> (cached)
      <span>return</span> <span>true</span>;
    <span>return</span> task.wait_for(<span>std</span>::<span>chrono</span>::seconds(0)) == <span>std</span>::<span>future_status</span>::ready;
  }

  <span>void</span> <span>get</span>(){
    <span>if</span> (!cached){
      value = task.get();
      cached = <span>true</span>;
    }
  }

  <span>var</span> <span>deref</span>() <span>final</span> {
    <span>lock_guard</span> <span>guard</span>(lock);
    get();
    <span>return</span> value;
  }
};
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2-12">
<h5 id="sec-4-1-2-12">Delay</h5>
<div id="text-4-1-2-12">
<p>
Takes a body of expressions and yields a Delay object that will invoke
the body only the first time it is forced (with <code>force</code> or <code>deref</code>),
and will cache the result and return it on all subsequent force
calls.
</p>

<div>

<pre>(<span>deftest</span> delay-test
  (<span>let</span> [d (<span>delay</span>   (<span>+</span> 1 1))]

    (<span>is</span> (<span>=</span> true    (<span>delay?</span> d)))
    (<span>is</span> (<span>=</span> 2       @d))
    (<span>is</span> (<span>=</span> 2       @d))
    (<span>is</span> (<span>=</span> 42      (<span>force</span> (<span>delay</span> 42))))))
</pre>
</div>

<div>

<pre>(defobject delayed <span>&#34;delayed_o.h&#34;</span>)

(<span>defn</span> <span>_delay_</span> [f]
  <span>&#34;return obj&lt;delayed&gt;(f)&#34;</span>)

(<span>defmacro</span> <span>delay</span> [&amp; body]
  `(_delay_ (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="5b251b39343f22">[email protected]</a>)))

(<span>defn</span> <span>delay?</span> [d]
  <span>&#34;if (d.is_type(type_id&lt;delayed&gt;))</span>
<span>     return cached::true_o;</span>
<span>   else</span>
<span>     return cached::false_o;&#34;</span>)

(<span>defn</span> <span>force</span> [d] @d)
</pre>
</div>

<div>

<pre><span>class</span> <span>delayed</span> <span>final</span> : <span>public</span> <span>deref_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>var</span> <span>fn</span>;
  <span>var</span> <span>val</span>;

  <span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>delayed</span>&gt;; }

  <span>explicit</span> <span>delayed</span>(<span>ref</span> <span>f</span>) : fn(f) {} 

  <span>var</span> <span>deref</span>() <span>final</span> {
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>if</span> (!fn.is_nil()){
      val = fn.cast&lt;lambda_i&gt;()-&gt;invoke(nil());
      fn = nil();
    }
    <span>return</span> val;
  }
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3">
<h4 id="sec-4-1-3">Interfaces</h4>
<p>
Just like Clojure, Ferret is written in terms of
abstractions. Currently there are abstractions for sequences,
collections and callability.
</p>

<div id="outline-container-sec-4-1-3-1">
<h5 id="sec-4-1-3-1">Seekable</h5>
<div id="text-4-1-3-1">
<p>
All sequence functions (first, second, rest etc.) use this interface
to iterate seekable containers.
</p>

<div>

<pre>(defobject seekable_i <span>&#34;seekable_i.h&#34;</span>)
</pre>
</div>

<div>

<pre>  <span>class</span> <span>seekable_i</span> {
  <span>public</span>:

    <span>virtual</span> <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>) = 0;
    <span>virtual</span> <span>var</span> <span>first</span>() = 0;
    <span>virtual</span> <span>var</span> <span>rest</span>() = 0;

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
    <span>static</span> <span>void</span> <span>stream_console</span>(<span>ref</span> <span>coll</span>) {
      <span>var</span> <span>tail</span> = <span>rt</span>::rest(coll);

      <span>rt</span>::print(<span>&#39;(&#39;</span>);
      <span>if</span> (tail)
        <span>rt</span>::first(coll).stream_console();

      <span>for_each</span>(i, tail){
        <span>rt</span>::print(<span>&#39; &#39;</span>);
        i.stream_console();
      }
      <span>rt</span>::print(<span>&#39;)&#39;</span>);
    }
<span>#endif</span>

    <span>static</span> <span>bool</span> <span>equals</span>(<span>var</span> <span>lhs</span>, <span>var</span> <span>rhs</span>) {

      <span>for</span>(;;lhs = <span>rt</span>::rest(lhs), rhs = <span>rt</span>::rest(rhs)){

        <span>ref</span> <span>lf</span> = <span>rt</span>::first(lhs);
        <span>ref</span> <span>rf</span> = <span>rt</span>::first(rhs);

        <span>if</span> (lf.is_nil() &amp;&amp; rf.is_nil())
          <span>return</span> <span>true</span>;

        <span>if</span> (lf != rf)
          <span>return</span> <span>false</span>;
      }
    }
  };
</pre>
</div>

<p>
C++ API for the interface,
</p>

<div>

<pre>  <span>namespace</span> <span>runtime</span> {
    <span>var</span> <span>list</span>(<span>ref</span> <span>v</span>);
    <span>template</span> &lt;<span>typename</span>... Args&gt;
    <span>var</span> <span>list</span>(<span>ref</span> <span>first</span>, <span>Args</span> <span>const</span> &amp; ... args);

    <span>inline</span> <span>bool</span> <span>is_seqable</span>(<span>ref</span> <span>seq</span>);

    <span>inline</span> <span>var</span> <span>first</span>(<span>ref</span> <span>seq</span>);
    <span>inline</span> <span>var</span> <span>rest</span>(<span>ref</span> <span>seq</span>);
    <span>inline</span> <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>, <span>ref</span> <span>seq</span>);

    <span>var</span> <span>nth</span>(<span>var</span> <span>seq</span>, <span>number_t</span> <span>index</span>);
    <span>var</span> <span>nthrest</span>(<span>var</span> <span>seq</span>, <span>number_t</span> <span>index</span>);

    <span>inline</span> <span>size_t</span> <span>count</span>(<span>ref</span> <span>seq</span>);

    <span>inline</span> <span>var</span> <span>range</span>(<span>number_t</span> <span>low</span>, <span>number_t</span> <span>high</span>);
  }

<span>#define</span> <span>for_each</span>(<span>x</span>,<span>xs</span>) <span>for</span>(<span>var</span> <span>_tail_</span> = <span>rt</span>::rest(xs), <span>x</span> = <span>rt</span>::first(xs);     \
                           !_tail_.is_nil();                                 \
                           x = <span>rt</span>::first(_tail_), _tail_ = <span>rt</span>::rest(_tail_))
</pre>
</div>

<p>
Implementations for the C++ Seekable API,
</p>

<div>

<pre><span>namespace</span> <span>runtime</span> {
  <span>inline</span> <span>bool</span> <span>is_seqable</span>(<span>ref</span> <span>coll</span>){
    <span>if</span>(coll.cast&lt;seekable_i&gt;())
      <span>return</span> <span>true</span>;
    <span>else</span>
      <span>return</span> <span>false</span>;
  }

  <span>inline</span> <span>var</span> <span>first</span>(<span>ref</span> <span>seq</span>){
    <span>if</span> (seq.is_nil() || seq.is_type(<span>type_id</span>&lt;empty_sequence&gt;))
      <span>return</span> nil();
    <span>return</span> seq.cast&lt;seekable_i&gt;()-&gt;first();
  }

  <span>inline</span> <span>var</span> <span>rest</span>(<span>ref</span> <span>seq</span>){
    <span>if</span> (seq.is_nil() || seq.is_type(<span>type_id</span>&lt;empty_sequence&gt;))
      <span>return</span> nil();
    <span>return</span> seq.cast&lt;seekable_i&gt;()-&gt;rest();
  }

  <span>inline</span> <span>var</span> <span>cons</span>(<span>ref</span> <span>x</span>, <span>ref</span> <span>seq</span>){
    <span>if</span> (seq.is_nil() || seq.is_type(<span>type_id</span>&lt;empty_sequence&gt;))
      <span>return</span> <span>rt</span>::<span>list</span>(<span>x</span>);
    <span>return</span> seq.cast&lt;seekable_i&gt;()-&gt;cons(x);
  }

  <span>var</span> <span>nth</span>(<span>var</span> <span>seq</span>, <span>number_t</span> <span>index</span>){
    <span>if</span> (index &lt; 0)
      <span>return</span> nil();

    <span>for</span>(<span>number_t</span> <span>i</span> = 0; i &lt; index; i++)
      seq = <span>rt</span>::rest(seq);
    <span>return</span> <span>rt</span>::first(seq);
  }

  <span>var</span> <span>nthrest</span>(<span>var</span> <span>seq</span>, <span>number_t</span> <span>index</span>){
    <span>for</span>(<span>number_t</span> <span>i</span> = 0; i &lt; index; i++)
      seq = <span>rt</span>::rest(seq);

    <span>if</span> (seq.is_nil())
      <span>return</span> <span>rt</span>::<span>list</span>(); 

    <span>return</span> seq;
  }

  <span>inline</span> <span>size_t</span> <span>count</span>(<span>ref</span> <span>seq</span>){
    <span>size_t</span> <span>acc</span> = 0;

    <span>for</span>(<span>var</span> <span>tail</span> = <span>rt</span>::rest(seq);
        !tail.is_nil();
        tail = <span>rt</span>::rest(tail))
      acc++;

    <span>return</span> acc;
  }

  <span>inline</span> <span>var</span> <span>range</span>(<span>number_t</span> <span>low</span>, <span>number_t</span> <span>high</span>){
    <span>class</span> <span>seq</span> : <span>public</span> <span>lambda_i</span> {
      <span>number_t</span> <span>low</span>, <span>high</span>;
    <span>public</span>:
      <span>explicit</span> <span>seq</span>(<span>number_t</span> <span>l</span>, <span>number_t</span> <span>h</span>) : low(l), high(h) { }
      <span>var</span> <span>invoke</span>(<span>ref</span>) <span>const</span> <span>final</span> {
        <span>if</span> (low &lt; high)
          <span>return</span> obj&lt;lazy_sequence&gt;(obj&lt;number&gt;(low), obj&lt;<span>seq</span>&gt;((low + 1), high));
        <span>return</span> nil();
      }
    };
    <span>return</span> obj&lt;lazy_sequence&gt;(obj&lt;<span>seq</span>&gt;(low, high));
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3-2">
<h5 id="sec-4-1-3-2">Lambda</h5>
<div id="text-4-1-3-2">
<p>
Every lambda object implements the <code>lambda_i</code> interface. All lambdas are
executed via <code>invoke</code> method that takes a sequence of vars as argument
or <code>nil()</code> if there are non, this allows us to execute them in a
uniform fashion.
</p>

<div>

<pre>(defobject lambda_i <span>&#34;lambda_i.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>struct</span> <span>lambda_i</span> : <span>public</span> <span>object</span> {
  <span>virtual</span> <span>var</span> <span>invoke</span>(<span>ref</span> <span>args</span>) <span>const</span> = 0;
  <span>type_t</span> <span>type</span>() <span>const</span> { <span>return</span> <span>type_id</span>&lt;<span>lambda_i</span>&gt;; }
};
</pre>
</div>

<p>
Function invocation,
</p>

<div>

<pre><span>template</span>&lt;<span>typename</span> <span>T</span>, <span>typename</span>... Args&gt;
<span>inline</span> <span>var</span> <span>run</span>(<span>T</span> <span>const</span> &amp; <span>fn</span>, <span>Args</span> <span>const</span> &amp; ... args);

<span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
<span>inline</span> <span>var</span> <span>run</span>(<span>T</span> <span>const</span> &amp; <span>fn</span>);

<span>template</span>&lt;&gt;
<span>inline</span> <span>var</span> <span>run</span>(ref);

<span>namespace</span> <span>runtime</span>{
  <span>inline</span> <span>var</span> <span>apply</span>(<span>ref</span> <span>fn</span>, <span>ref</span> <span>argv</span>);
}
</pre>
</div>

<div>

<pre><span>template</span>&lt;<span>typename</span> <span>T</span>, <span>typename</span>... Args&gt;
<span>inline</span> <span>var</span> <span>run</span>(<span>T</span> <span>const</span> &amp; <span>fn</span>, <span>Args</span> <span>const</span> &amp; ... args) {
  <span>return</span> fn.invoke(<span>rt</span>::<span>list</span>(args...));
}

<span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
<span>inline</span> <span>var</span> <span>run</span>(<span>T</span> <span>const</span> &amp; <span>fn</span>) {
  <span>return</span> fn.invoke(nil());
}

<span>template</span>&lt;&gt;
<span>inline</span> <span>var</span> <span>run</span>(<span>ref</span> <span>fn</span>) {
  <span>return</span> fn.cast&lt;lambda_i&gt;()-&gt;invoke(nil());
}

<span>template</span>&lt;<span>typename</span>... Args&gt;
<span>inline</span> <span>var</span> <span>run</span>(<span>ref</span> <span>fn</span>, <span>Args</span> <span>const</span> &amp; ... args) {
  <span>return</span> fn.cast&lt;lambda_i&gt;()-&gt;invoke(<span>rt</span>::<span>list</span>(args...));
}

<span>namespace</span> <span>runtime</span> {
  <span>inline</span> <span>var</span> <span>apply</span>(<span>ref</span> <span>f</span>, <span>ref</span> <span>argv</span>){
    <span>if</span> (<span>rt</span>::rest(argv).is_type(<span>type_id</span>&lt;empty_sequence&gt;))
      <span>return</span> f.cast&lt;lambda_i&gt;()-&gt;invoke(<span>rt</span>::first(argv));

    <span>struct</span>{
      <span>var</span> <span>operator</span><span>()</span>(<span>ref</span> <span>seq</span>) <span>const</span> {
        <span>ref</span> <span>head</span> = <span>rt</span>::first(seq);

        <span>if</span> (head.is_nil())
          <span>return</span> <span>cached</span>::empty_sequence_o;

        <span>if</span> (head.cast&lt;seekable_i&gt;())
          <span>return</span> head;

        <span>return</span> <span>rt</span>::cons(head, (*<span>this</span>)(<span>rt</span>::<span>rest</span>(<span>seq</span>)));
      }
    } <span>spread</span>;

    <span>return</span> f.cast&lt;lambda_i&gt;()-&gt;invoke(spread(argv));
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3-3">
<h5 id="sec-4-1-3-3">Deref</h5>
<div id="text-4-1-3-3">
<div>

<pre>(defobject deref_i <span>&#34;deref_i.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>deref_i</span> : <span>public</span> <span>object</span> {
 <span>public</span>:

  <span>virtual</span> <span>var</span> <span>deref</span>() = 0;
};
</pre>
</div>

<p>
Operations on <code>deref_i</code>
</p>

<div>

<pre>(<span>defn</span> <span>deref</span> [a]
  <span>&#34;return a.cast&lt;deref_i&gt;()-&gt;deref();&#34;</span>)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-2">
<h3 id="sec-4-2">Memory Management</h3>
<div id="text-4-2">
<p>
Ferret is designed to be used on embedded systems which means,
</p>

<ul>
<li>Latency is more important then through put.
</li>
<li>Can&#39;t have unpredictable GC pauses when running.
</li>
</ul>

<p>
So the default memory management is done using reference
counting. Unlike other lisp implementations, Ferret supports various
memory management schemes,
</p>

<ul>
<li><b>malloc/free</b> - Allocations are handled by the system
implementation. (Default memory management.)
</li>
<li><b>Memory Pooling</b> - On memory constraint systems such as
microcontrollers Ferret can use a memory pool to avoid heap
fragmentation and calling malloc/free. Effectively running with
no heap, allocating all memory at compile time on the stack.
</li>
<li><b>Third party allocators</b> (i.e tcmalloc)
</li>
<li><b>Third party garbage collectors</b> (i.e The Boehm-Demers-Weiser
conservative garbage collector.) - All memory is managed by a third
party GC disables reference counting.
</li>
</ul>

<p>
To enable memory pooling,
</p>

<pre>(configure-runtime! FERRET_MEMORY_POOL_SIZE 256)
</pre>

<p>
This will create a pool object as a global variable that holds an
array of <code>256</code> <code>size_t=s. By default page size is
=sizeof(size_t)</code>. This can be changed using,
</p>

<pre>(configure-runtime! FERRET_MEMORY_POOL_PAGE_TYPE byte)
</pre>

<p>
Memory pooling is intended for embedded systems where calling
malloc/free is not desired.
</p>

<p>
Steps for using <b>tcmalloc</b> on Mac OS X, install dependencies, 
</p>

<pre>brew install google-perftools
</pre>

<p>
Then from your program you can link to it using,
</p>

<div>

<pre>(configure-ferret! <span>:compiler-options</span> [<span>&#34;-std=c++11&#34;</span>
                                      <span>&#34;-L/usr/local/Cellar/gperftools/2.4/lib/&#34;</span>
                                      <span>&#34;-ltcmalloc&#34;</span>])
</pre>
</div>

<p>
Steps for using <b>Boehm garbage collector</b> on Linux, install dependencies,
</p>

<pre>apt-get install libgc-dev
</pre>

<p>
Enable and configure GC
</p>

<div>

<pre>(configure-runtime! FERRET_MEMORY_BOEHM_GC TRUE)
(configure-ferret! <span>:command</span> <span>&#34;g++ -std=c++11 core.cpp -lgc&#34;</span>)
</pre>
</div>
</div>

<div id="outline-container-sec-4-2-1">
<h4 id="sec-4-2-1">Pointers</h4>
<div id="text-4-2-1">
<p>
Each <code>var</code> holds a reference to a Ferret object using one of the
pointer types below. Default <code>pointer_t</code> does nothing and delegates
all requests to a regular <code>object *</code>. Using this scheme allows
optional use of tagged pointers on systems that support them.
</p>

<div>

<pre><span>namespace</span> <span>memory</span> {
  <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
  <span>class</span> <span>pointer</span>{
    <span>T</span> *<span>ptr</span>;

  <span>public</span>:

    <span>inline</span> <span>explicit</span> <span>pointer</span>(<span>T</span> *<span>p</span> = <span>nullptr</span>) : ptr(p){ }
    <span>inline</span> <span>operator</span> <span>T</span>* () <span>const</span> { <span>return</span> ptr; }

    <span>inline</span> <span>pointer</span>&amp; <span>operator</span><span>=</span> (<span>T</span> *<span>other</span>){
      ptr = other;
      <span>return</span> *<span>this</span>;
    }

    <span>inline</span> <span>T</span> *<span>operator</span><span>-&gt;</span>() <span>const</span> { <span>return</span> ptr; }
  };
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2">
<h4 id="sec-4-2-2">Allocators</h4>
<div id="outline-container-sec-4-2-2-1">
<h5 id="sec-4-2-2-1">Pool</h5>
<div id="text-4-2-2-1">
<p>
When <code>FERRET_MEMORY_POOL_SIZE</code> is defined Ferret programs will use a
memory pool called <code>memory::allocator::program_memory</code> instead of
<code>mallac</code>, <code>free</code> for memory allocation, depending on the pool size
Ferret will allocate <code>N</code> bytes of memory on stack and all memory
allocation happens in this memory pool useful when working with very
limited amount of memory, such as micro controllers where you want
complete control over the memory and you need deterministic timing
requirements.
</p>

<p>
This allocator uses a bit-map to keep track of the used and unused
memory locations for its book-keeping purposes. This allocator will
make use of 1 single bit to keep track of whether it has been
allocated or not. A bit 0 indicates free, while 1 indicates
allocated. This has been done so that you can easily check a
collection of bits for a free block. This kind of Bitmapped strategy
works best for single object allocations ,we do not need to choose any
size for the block which will be represented by a single bit. This
will be the size of the parameter around which the allocator has been
parameterized. Thus, close to optimal performance will result.
</p>

<div>

<pre><span>#if</span> <span>defined</span>(FERRET_MEMORY_POOL_SIZE) &amp;&amp; !<span>defined</span>(FERRET_ALLOCATOR)

<span> #define</span> <span>FERRET_ALLOCATOR</span> <span>memory</span>::<span>allocator</span>::pool

<span> #if</span> !<span>defined</span>(FERRET_MEMORY_POOL_PAGE_TYPE)
<span>  #define</span> <span>FERRET_MEMORY_POOL_PAGE_TYPE</span> size_t
<span> #endif</span>

<span>namespace</span> <span>memory</span>{
  <span>namespace</span> <span>allocator</span>{

    <span>memory_pool</span>&lt;FERRET_MEMORY_POOL_PAGE_TYPE, FERRET_MEMORY_POOL_SIZE&gt; <span>program_memory</span>;

    <span>class</span> <span>pool</span>{
    <span>public</span>:

      <span>static</span> <span>void</span> <span>init</span>(){ }

      <span>static</span> <span>inline</span> <span>void</span>*  <span>allocate</span>(<span>size_t</span> <span>s</span>){
        <span>return</span> program_memory.allocate(s);
      }

      <span>template</span>&lt;<span>typename</span> <span>FT</span>&gt;
      <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(){ <span>return</span> allocate(<span>sizeof</span>(<span>FT</span>)); }

      <span>static</span> <span>inline</span> <span>void</span>   <span>free</span>(<span>void</span> * <span>ptr</span>){ program_memory.free(ptr); }
    };
  }
}
<span>#endif</span>
</pre>
</div>

<p>
Pool allocator uses circular first-fit strategy, when <code>allocate</code> is
called the pool will scan the memory pool using the <code>used</code> bit array
to find a block of memory big enough to satisfy the request. If found,
it will the mark the region as used and return a pointer from <code>pool</code>
array to the user which points to the memory block.
</p>

<p>
When a <code>free</code> request is received, we resolve the pointer in to the
memory pool read the book keeping information on how much memory
is allocated to this pointer and set these pages to unused.
</p>

<p>
Memory pool has several advantages, it will avoid fragmentation,
function related to each other will always keep their data close
to each other in the array which improves data locality.
</p>

<div>

<pre><span>#define</span> <span>FERRET_MEMORY_POOL_SIZE</span> 4_MB
<span>#define</span> <span>FERRET_BITSET_WORD_TYPE</span> <span>unsigned</span> <span>int</span>

<span>#include</span> <span>&lt;cassert&gt;</span>
<span>#include</span> <span>&lt;runtime.h&gt;</span>

<span>int</span> <span>main</span>() {
  <span>using</span> <span>namespace</span> <span>ferret</span>::<span>memory</span>;
  <span>using</span> <span>namespace</span> <span>allocator</span>;

  assert(0  == align_req(0,8));
  assert(7  == align_req(1,8));
  assert(0  == align_req(8,8));

  assert(0  == align_of(0,8));
  assert(8  == align_of(1,8));
  assert(8  == align_of(8,8));

  alignas(16) <span>int</span> <span>buff</span> [4];
  assert(0  == align_req&lt;<span>int16_t</span>&gt;(buff));
  assert(<span>reinterpret_cast</span>&lt;<span>std</span>::uintptr_t&gt;(buff) == align_of&lt;<span>int16_t</span>&gt;(buff));

  <span>size_t</span> <span>byte_s</span> = <span>sizeof</span>(<span>ferret</span>::byte);

  <span>memory_pool</span>&lt;<span>ferret</span>::byte, 8, <span>unsigned</span> <span>char</span>&gt; <span>nano_pool</span>;

  <span>void</span>* <span>a</span> = nano_pool.allocate(byte_s);
  assert(<span>nullptr</span>  != a);
  assert(2        == nano_pool.used.ffr(0));
  assert(<span>nullptr</span>  != nano_pool.allocate(byte_s));
  assert(4        == nano_pool.used.ffr(0));

  <span>void</span>* <span>c</span> = nano_pool.allocate(byte_s);

  assert(<span>nullptr</span>  != c);
  assert(6        == nano_pool.used.ffr(0));
  assert(<span>nullptr</span>  != nano_pool.allocate(byte_s));

  nano_pool.free(c);

  assert(4        == nano_pool.used.ffr(0));
  assert(6        == nano_pool.used.ffs(4));
  assert(<span>nullptr</span>  != nano_pool.allocate(byte_s));

  <span>memory_pool</span>&lt;<span>ferret</span>::byte, 16, <span>unsigned</span> <span>char</span>&gt; <span>tiny_pool</span>;

  assert(0        == tiny_pool.used.ffr(0));
  assert(<span>nullptr</span>  != tiny_pool.allocate(<span>byte_s</span> * 2));
  assert(3        == tiny_pool.used.ffr(0));

  <span>void</span>* <span>p</span> = tiny_pool.allocate(<span>byte_s</span> * 4);

  assert(<span>nullptr</span>  != p);
  assert(8        == tiny_pool.used.ffr(0));

  tiny_pool.free(p);

  assert(3        == tiny_pool.used.ffr(0));
  assert(<span>nullptr</span>  == tiny_pool.allocate(<span>byte_s</span> * 40));
  assert(<span>nullptr</span>  != tiny_pool.allocate(<span>byte_s</span> * 6));
  assert(<span>nullptr</span>  != tiny_pool.allocate(<span>byte_s</span> * 1));
  assert(<span>nullptr</span>  != tiny_pool.allocate(<span>byte_s</span> * 1));
  assert(<span>nullptr</span>  == tiny_pool.allocate(<span>byte_s</span> * 10));

  <span>memory_pool</span>&lt;<span>uint64_t</span>, 256&gt; <span>big_pool</span>;

  assert(0        == big_pool.used.ffr(0));

  p = big_pool.allocate(1);

  assert(<span>nullptr</span>  != p);

  assert(2        == big_pool.used.ffr(0));

  big_pool.free(p);

  assert(0        == big_pool.used.ffr(0));
  assert(<span>nullptr</span>  == big_pool.allocate(2048));
  assert(0        == big_pool.used.ffr(0));

  <span>return</span> 0;
}
</pre>
</div>

<div>

<pre><span>#ifdef</span> FERRET_MEMORY_POOL_SIZE
<span>namespace</span> <span>memory</span>{
  <span>namespace</span> <span>allocator</span>{
    <span>template</span>&lt;<span>typename</span> <span>page_t</span>, <span>size_t</span> <span>pool_size</span>,
             <span>typename</span> <span>bitset_word_t</span> = <span>FERRET_BITSET_WORD_TYPE</span>&gt;
    <span>struct</span> <span>memory_pool</span> {
      <span>bitset</span>&lt;pool_size, <span>bitset_word_t</span>&gt; <span>used</span>;
      <span>page_t</span> <span>pool</span>[pool_size];
      <span>size_t</span> <span>next_ptr</span>;

      <span>memory_pool</span>() : pool{0}, next_ptr(0) { }

      <span>inline</span> <span>size_t</span> <span>scan</span>(<span>size_t</span> <span>n_pages</span>, <span>size_t</span> <span>from_page</span> = 0) <span>const</span> {
        <span>for</span>(;;){
          <span>size_t</span> <span>begin</span> = used.ffr(from_page);
          <span>size_t</span> <span>end</span>   = begin + n_pages;

          <span>if</span> (end &gt; pool_size)
            <span>return</span> pool_size;

          <span>if</span> (used.ffs(begin, end) &gt;= end)
            <span>return</span> begin;

          from_page = end;
        }
      }

      <span>void</span> *<span>allocate</span>(<span>size_t</span> <span>req_size</span>){
        req_size = align_of(req_size, <span>sizeof</span>(<span>page_t</span>)) + <span>sizeof</span>(<span>page_t</span>);
        <span>size_t</span> <span>n_pages</span> = req_size / <span>sizeof</span>(<span>page_t</span>);
        <span>size_t</span> <span>page</span>   = scan(n_pages, next_ptr);

        <span>if</span> (page == pool_size){
          page = scan(n_pages);
          <span>if</span> (page == pool_size)
            <span>return</span> <span>nullptr</span>;
        }

        pool[page] = (<span>page_t</span>)n_pages;
        next_ptr = page + n_pages;
        used.flip(page, next_ptr);

        <span>return</span> &amp;pool[++page];
      }

      <span>void</span> <span>free</span>(<span>void</span> *<span>p</span>){
        <span>ptrdiff_t</span> <span>begin</span> = (<span>static_cast</span>&lt;<span>page_t</span> *&gt;(p) - pool) - 1;
        <span>ptrdiff_t</span> <span>end</span> = begin + (<span>ptrdiff_t</span>)pool[begin];
        used.flip((<span>size_t</span>)begin, (<span>size_t</span>)end);
      }
    };
  }
}
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2-2">
<h5 id="sec-4-2-2-2">LibGC</h5>
<div id="text-4-2-2-2">
<p>
When <code>FERRET_MEMORY_BOEHM_GC</code> is defined Ferret programs will use
Boehm-Demers-Weiser&#39;s GC is a garbage collecting storage
allocator. The collector automatically recycles memory when it
determines that it can no longer be used. 
</p>

<p>
Code must be linked against the GC library. On most UNIX platforms,
depending on how the collector is built, this will be gc.a or
libgc.{a,so}.
</p>

<div>

<pre><span>#ifdef</span> FERRET_MEMORY_BOEHM_GC

<span>#define</span> <span>FERRET_ALLOCATOR</span> <span>memory</span>::<span>allocator</span>::gc
<span>#define</span> <span>FERRET_DISABLE_RC</span> <span>true</span>

<span>#include</span> <span>&lt;gc.h&gt;</span>

<span>namespace</span> <span>memory</span>{
  <span>namespace</span> <span>allocator</span>{

    <span>class</span> <span>gc</span>{
    <span>public</span>:

      <span>static</span> <span>void</span> <span>init</span>(){ GC_INIT(); }

      <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(<span>size_t</span> <span>s</span>){
<span>#ifdef</span> FERRET_DISABLE_MULTI_THREADING
        <span>return</span> GC_MALLOC(s);
<span>#else</span>
        <span>return</span> GC_MALLOC_ATOMIC(s);
<span>#endif</span>
      }

      <span>template</span>&lt;<span>typename</span> <span>FT</span>&gt;
      <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(){ <span>return</span> allocate(<span>sizeof</span>(<span>FT</span>)); }

      <span>static</span> <span>inline</span> <span>void</span>  <span>free</span>(<span>void</span> * <span>ptr</span>){ }
    };
  }
}
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2-3">
<h5 id="sec-4-2-2-3">System</h5>
<div id="text-4-2-2-3">
<p>
<i>Object</i>s are allocated from system implementation. (Default memory
allocator used.)
</p>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_ALLOCATOR)

<span>#define</span> <span>FERRET_ALLOCATOR</span> <span>memory</span>::<span>allocator</span>::system

<span>namespace</span> <span>memory</span>{
  <span>namespace</span> <span>allocator</span>{

    <span>class</span> <span>system</span>{
    <span>public</span>:

      <span>static</span> <span>void</span> <span>init</span>(){ }

      <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(<span>size_t</span> <span>s</span>){ <span>return</span> ::malloc(s); }

      <span>template</span>&lt;<span>typename</span> <span>FT</span>&gt;
      <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(){ <span>return</span> allocate(<span>sizeof</span>(<span>FT</span>)); }

      <span>static</span> <span>inline</span> <span>void</span>  <span>free</span>(<span>void</span> * <span>ptr</span>){ ::free(ptr); } 
    };
  }
}
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2-4">
<h5 id="sec-4-2-2-4">Synchronized</h5>
<div id="text-4-2-2-4">
<p>
Synchronizes access to other allocators.
</p>

<div>

<pre><span>namespace</span> <span>memory</span>{
  <span>namespace</span> <span>allocator</span>{
    <span>class</span> <span>synchronized</span>{
      <span>static</span> <span>mutex</span> <span>lock</span>;
    <span>public</span>:

      <span>static</span> <span>void</span> <span>init</span>(){ <span>FERRET_ALLOCATOR</span>::init(); }

      <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(<span>size_t</span> <span>s</span>){
        <span>lock_guard</span> <span>guard</span>(lock);
        <span>return</span> <span>FERRET_ALLOCATOR</span>::allocate(s);
      }

      <span>template</span>&lt;<span>typename</span> <span>FT</span>&gt;
      <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(){ <span>return</span> allocate(<span>sizeof</span>(<span>FT</span>)); }

      <span>static</span> <span>inline</span> <span>void</span>  <span>free</span>(<span>void</span> * <span>ptr</span>){
        <span>lock_guard</span> <span>guard</span>(lock);
        <span>FERRET_ALLOCATOR</span>::free(ptr);
      }
    };
  }
}
</pre>
</div>

<p>
Enable synchronized access,
</p>

<div>

<pre><span>#if</span>  !<span>defined</span>(FERRET_DISABLE_MULTI_THREADING)

<span>  #if</span> <span>defined</span>(FERRET_MEMORY_POOL_SIZE) || <span>defined</span>(FERRET_HARDWARE_ARDUINO)
    <span>mutex</span> <span>memory</span>::<span>allocator</span>::<span>synchronized</span>::<span>lock</span>;
<span>    #undef</span>  FERRET_ALLOCATOR
<span>    #define</span> <span>FERRET_ALLOCATOR</span> <span>memory</span>::<span>allocator</span>::synchronized
<span>  #endif</span>

<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2-5">
<h5 id="sec-4-2-2-5">Allocator API</h5>
<div id="text-4-2-2-5">
<p>
User defined allocators are supported. A Ferret allocator is a class
with three static functions,
</p>

<ul>
<li><code>init()</code> - Initializes the allocator.
</li>
<li><code>allocate&lt;T&gt;()</code> - Allocates Ferret object T.
</li>
<li><code>free(void*)</code> - Frees the memory.
</li>
</ul>

<p>
Allocators are defined seperately in header files. They can then be
used by including the header files.
</p>

<div>

<pre><span>#include</span> <span>&lt;stdlib.h&gt;</span>

<span>struct</span> <span>allocator_user</span>{
  <span>static</span> <span>bool</span> <span>loaded</span>;

  <span>static</span> <span>void</span> <span>init</span>(){ loaded = <span>true</span>; }

  <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(<span>size_t</span> <span>s</span>){ <span>return</span> ::malloc(s); }

  <span>template</span>&lt;<span>typename</span> <span>FT</span>&gt;
  <span>static</span> <span>inline</span> <span>void</span>* <span>allocate</span>(){ <span>return</span> allocate(<span>sizeof</span>(<span>FT</span>)); }

  <span>static</span> <span>inline</span> <span>void</span>  <span>free</span>(<span>void</span> * <span>ptr</span>){ ::free(ptr); } 
};

<span>bool</span> <span>allocator_user</span>::<span>loaded</span> = <span>false</span>;

<span>#define</span> <span>FERRET_ALLOCATOR</span> allocator_user
</pre>
</div>

<div>

<pre>(native-header <span>&#34;allocator_user.h&#34;</span>)

(<span>assert</span> (cxx <span>&#34;__result = obj&lt;boolean&gt;(allocator_user::loaded)&#34;</span>))
</pre>
</div>

<p>
Helper functions for user defined allocators.
</p>

<div>

<pre><span>namespace</span> <span>memory</span>{
  <span>inline</span> <span>size_t</span> <span>align_of</span>(<span>uintptr_t</span> <span>size</span>, <span>size_t</span> <span>align</span>){
    <span>return</span> (size + align - 1) &amp; ~(align - 1);
  }

  <span>template</span>&lt;<span>class</span> <span>T</span>&gt;
  <span>size_t</span> <span>align_of</span>(<span>const</span> <span>void</span> * <span>ptr</span>) {
    <span>return</span> align_of(<span>reinterpret_cast</span>&lt;<span>uintptr_t</span>&gt;(ptr), <span>sizeof</span>(T));
  }

  <span>inline</span> <span>size_t</span> <span>align_req</span>(<span>uintptr_t</span> <span>size</span>, <span>size_t</span> <span>align</span>){
    <span>size_t</span> <span>adjust</span> = align - (size &amp; (align - 1));

    <span>if</span>(adjust == align)
      <span>return</span> 0;
    <span>return</span> adjust;
  }

  <span>template</span>&lt;<span>class</span> <span>T</span>&gt;
  <span>size_t</span> <span>align_req</span>(<span>const</span> <span>void</span> * <span>ptr</span>) {
    <span>return</span> align_req(<span>reinterpret_cast</span>&lt;<span>uintptr_t</span>&gt;(ptr), <span>sizeof</span>(T));
  }

  <span>template</span> &lt;<span>typename</span>... Ts&gt;
  <span>constexpr</span> <span>size_t</span> <span>max_sizeof</span>() {
    <span>return</span> <span>rt</span>::max(<span>sizeof</span>(Ts)...);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2-6">
<h5 id="sec-4-2-2-6">Alloca</h5>
<div id="text-4-2-2-6">
<p>
<code>alloca</code> is a special allocator used by the <b>compiler</b>. If a variable
can be proven to not escape its scope, storage for it can be allocated
on the <b>stack</b> instead of the heap.
</p>

<div>

<pre><span>#undef</span> alloca

<span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
<span>class</span> <span>alloca</span> {

  <span>byte</span> <span>memory</span> [<span>sizeof</span>(<span>T</span>)];

<span>public</span>:

  <span>template</span>&lt;<span>typename</span>... Args&gt;
  <span>inline</span> <span>explicit</span> <span>alloca</span>(<span>Args</span>... <span>args</span>) {
    (<span>new</span>(memory) <span>T</span>(args...))-&gt;inc_ref();
  }

  <span>inline</span> <span>operator</span> <span>object</span>*() {
    <span>return</span> (<span>object</span>*)memory;
  }
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-3">
<h4 id="sec-4-2-3">Reference Counting</h4>
<div id="text-4-2-3">
<p>
Garbage collection is handled by reference counting. Reference count
is kept within the <a href="#sec-4-1-1">obj::base</a> using one of the following reference
counting policies.
</p>

<ul>
<li><code>atomic_rc</code> - Atomic reference counting. (using <code>std::atomic&lt;unsigned int&gt;</code>)
</li>
<li><code>rc</code> - Non Atomic reference counting. (using <code>unsigned int</code>)
</li>
<li><code>no_rc</code> - No reference counting.
</li>
</ul>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_RC_POLICY)
<span>namespace</span> <span>memory</span> {
  <span>namespace</span> <span>gc</span> {

<span>#if</span> !<span>defined</span>(FERRET_RC_TYPE)
<span>  #define</span> <span>FERRET_RC_TYPE</span> <span>unsigned</span> <span>int</span>
<span>#endif</span>

<span>#if</span> <span>defined</span>(FERRET_DISABLE_RC)

<span>#define</span> <span>FERRET_RC_POLICY</span> <span>memory</span>::<span>gc</span>::no_rc

    <span>class</span> <span>no_rc</span>{
    <span>public</span>:

      <span>inline</span> <span>void</span> <span>inc_ref</span>() { }
      <span>inline</span> <span>bool</span> <span>dec_ref</span>() { <span>return</span> <span>false</span>; }
    };

<span>#else</span>

    <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
    <span>class</span> <span>rc</span>{
    <span>public</span>:
      <span>rc</span>() : ref_count(0) {}

      <span>inline</span> <span>void</span> <span>inc_ref</span>() { ref_count++; }
      <span>inline</span> <span>bool</span> <span>dec_ref</span>() { <span>return</span> (--ref_count == 0); }

    <span>private</span>:
      <span>T</span> <span>ref_count</span>;
    };    

<span>    #if</span> <span>defined</span>(FERRET_DISABLE_MULTI_THREADING) || !<span>defined</span>(FERRET_STD_LIB)
<span>      #define</span> <span>FERRET_RC_POLICY</span> <span>memory</span>::<span>gc</span>::<span>rc</span>&lt;FERRET_RC_TYPE&gt;
<span>    #endif</span>

<span>    #if</span> <span>defined</span>(FERRET_STD_LIB) &amp;&amp; !<span>defined</span>(FERRET_DISABLE_MULTI_THREADING)
<span>      #define</span> <span>FERRET_RC_POLICY</span> <span>memory</span>::<span>gc</span>::rc&lt;::<span>std</span>::<span>atomic</span>&lt;FERRET_RC_TYPE&gt;&gt;
<span>    #endif</span>
<span>#endif</span>
  }
}
<span>#endif</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3">
<h3 id="sec-4-3">Numeric Tower</h3>
<div id="text-4-3">
<p>
In the interest of simplicity Ferret supports only one type of number:
floating point numbers. By default these are double precision floating
point numbers. However Ferret programs can easily be recompiled to
support any real number type the system supports.
</p>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_NUMBER_TYPE)
<span>   #define</span> <span>FERRET_NUMBER_TYPE</span> <span>int</span>
<span>#endif</span>

<span>#if</span> !<span>defined</span>(FERRET_REAL_TYPE)
<span>   #define</span> <span>FERRET_REAL_TYPE</span>   <span>double</span>
<span>#endif</span>

<span>#if</span> !<span>defined</span>(FERRET_REAL_EPSILON)
<span>   #define</span> <span>FERRET_REAL_EPSILON</span>   0.0001
<span>#endif</span>

  <span>int</span> <span>req_real_precision</span>(<span>double</span> <span>t</span>) {
    <span>return</span> ((-1 * (<span>int</span>)log10(t)));
  }

  <span>typedef</span> <span>FERRET_NUMBER_TYPE</span>  <span>number_t</span>;                   <span>// </span><span>Whole number Container.</span>
  <span>typedef</span> <span>FERRET_REAL_TYPE</span>    <span>real_t</span>;                     <span>// </span><span>Real number Container.</span>
  <span>const</span>   <span>real_t</span>              <span>real_epsilon</span>(FERRET_REAL_EPSILON);
  <span>const</span>   <span>int</span>                 <span>real_precision</span> = req_real_precision(FERRET_REAL_EPSILON);
</pre>
</div>
</div>

<div id="outline-container-sec-4-3-1">
<h4 id="sec-4-3-1">Math</h4>
<div id="text-4-3-1">
<p>
Math functions.
</p>

<div>

<pre><span>namespace</span> <span>runtime</span>{
<span>  #undef</span> min
<span>  #undef</span> max
<span>  #undef</span> abs

  <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
  <span>static</span> <span>constexpr</span> <span>T</span> <span>max</span>(<span>T</span> <span>a</span>, <span>T</span> <span>b</span>) {
    <span>return</span> a &lt; b ? b : a;
  }

  <span>template</span> &lt;<span>typename</span> <span>T</span>, <span>typename</span>... Ts&gt;
  <span>static</span> <span>constexpr</span> <span>T</span> <span>max</span>(<span>T</span> <span>a</span>, <span>Ts</span>... <span>bs</span>) {
    <span>return</span> max(a, max(bs...));
  }

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>constexpr</span> <span>T</span> <span>min</span>(<span>T</span> <span>a</span>, <span>T</span> <span>b</span>){
    <span>return</span> ((a) &lt; (b) ? (a) : (b));
  }

  <span>template</span> &lt;<span>typename</span> <span>T</span>, <span>typename</span>... Ts&gt;
  <span>static</span> <span>constexpr</span> <span>T</span> <span>min</span>(<span>T</span> <span>a</span>, <span>Ts</span>... <span>bs</span>) {
    <span>return</span> min(a, min(bs...));
  }

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>constexpr</span> <span>T</span> <span>abs</span>(<span>T</span> <span>a</span>){
    <span>return</span> ((a) &lt; (<span>T</span>)0 ? -(a) : (a));
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-2">
<h4 id="sec-4-3-2">Fixed Point Math</h4>
<div id="text-4-3-2">
<p>
A fixed point number, like a floating point number, is an approximate
representation of a rational number. Unlike floating point numbers
exponent in a fixed point numbers is constant, this allows fixed point
numbers to be represented internally as integers and the operations on
fixed point numbers can be performed using integer arithmetic. This
can often improve the speed of arithmetic operation on embedded
systems without a built in FPU.
</p>

<p>
Fixed point numbers can be enabled by overriding the
<code>FERRET_REAL_TYPE</code> definition. Following defines fixed point numbers
as 32 bit integers with 8 bits used as fractional part.
</p>

<div>

<pre>(configure-runtime! FERRET_REAL_TYPE <span>&#34;ferret::fixed_real&lt;32,8&gt;&#34;</span>)
</pre>
</div>

<p>
or you can automatically calculate required fraction bits using a
literal. Following defines a 32 bit <code>fixed_real</code> with 0.01 fractional
accuracy using 6 bits for fraction.
</p>

<div>

<pre>(configure-runtime! FERRET_REAL_TYPE <span>&#34;ferret::fixed_real&lt;32,0.01_QN&gt;&#34;</span>)
</pre>
</div>

<div>

<pre>(configure-runtime! FERRET_REAL_TYPE    <span>&#34;ferret::fixed_real&lt;24,16&gt;&#34;</span>
                    FERRET_REAL_EPSILON 0.0001)

(cxx <span>&#34;static_assert(sizeof(int24_t) == 3 * sizeof(byte), \&#34;\&#34;);&#34;</span>)
(cxx <span>&#34;static_assert(sizeof(int24_t) ==     sizeof(real_t), \&#34;\&#34;);&#34;</span>)

(<span>deftest</span> math
  (<span>is</span> (<span>=</span>  3    (<span>+</span>  1.25   1.75)))
  (<span>is</span> (<span>=</span>  0.5  (<span>-</span> -1.25  -1.75)))
  (<span>is</span> (<span>=</span>  255  (<span>+</span>  254    1)))
  (<span>is</span> (<span>=</span>  255  (<span>+</span>  253.4  1.6)))
  (<span>is</span> (<span>=</span> -255  (<span>-</span> -254    1))))

(<span>run-all-tests</span>)
</pre>
</div>

<div>

<pre><span>#include</span> <span>&lt;cassert&gt;</span>
<span>#include</span> <span>&lt;runtime.h&gt;</span>

<span>int</span> <span>main</span>() {
  <span>typedef</span> <span>ferret</span>::<span>fixed_real</span>&lt;32,8&gt; <span>fix_32</span>;
  <span>typedef</span> <span>ferret</span>::<span>fixed_real</span>&lt;64,8&gt; <span>fix_64</span>;

  <span>// </span><span>Test Casting</span>
  assert((<span>char</span>)          <span>fix_32</span>(<span>char</span>(25))  == <span>char</span>(25));
  assert((<span>int</span>)           <span>fix_32</span>(<span>int</span>(1024)) == <span>int</span>(1024));
  assert((<span>long</span>)          <span>fix_64</span>(<span>long</span>(25))  == <span>long</span>(25));
  assert((<span>unsigned</span> <span>long</span>) <span>fix_64</span>(2500UL)    == 2500UL);

  <span>long</span> <span>max_int</span> = <span>std</span>::<span>numeric_limits</span>&lt;<span>int</span>&gt;::max() + 1024L;
  assert((<span>long</span>)fix_64(max_int) == ((<span>long</span>)<span>std</span>::<span>numeric_limits</span>&lt;<span>int</span>&gt;::max() + 1024L));

  <span>// </span><span>Test Arithmetic</span>
  <span>fix_32</span> <span>x</span>;
  <span>fix_32</span> <span>y</span>;
  x = 10;
  y = 0.250;
  assert(10.25 == (<span>double</span>)(x + y));

  x = fix_32(0);
  <span>for</span>(<span>int</span> <span>i</span> = 0; i &lt; 100; i++)
    x += fix_32(0.0625);
  assert((<span>double</span>)x == 6.25);

  x = fix_32(22.75);
  y = fix_32(12.5);
  assert((<span>double</span>)(x + y) == 35.25);

  x = fix_32(22.75);
  y = fix_32(22.5);
  assert((<span>double</span>)(x - y) ==  0.25);
  assert((<span>double</span>)(y - x) == -0.25);

  x = fix_32(-0.25);
  y = fix_32(4);
  assert((<span>double</span>)(x / y) ==  -0.0625);

  x = fix_32(-0.0625);
  y = fix_32(-10);
  assert((<span>double</span>)(x - y) ==  9.9375);

  x = fix_32(9.9375);
  y = fix_32(-3);
  assert((<span>double</span>)(x * y) ==  -29.8125);

  x = fix_32(-29.8125);
  y = fix_32(0.1875);
  assert((<span>double</span>)(x - y) ==  -30);

  <span>return</span> 0;
}
</pre>
</div>

<div>

<pre><span>#if</span> !<span>defined</span>(__clang__)
<span>constexpr</span> <span>auto</span> <span>operator</span> <span>&#34;&#34;</span> _QN(<span>long</span> <span>double</span> <span>x</span>) -&gt; <span>int</span> {
  <span>return</span> (<span>int</span>)::floor(::log(1.0/(<span>double</span>)x)/::log(2));
}
<span>#endif</span>

<span>template</span>&lt;<span>int</span> <span>bits</span>&gt; <span>struct</span> <span>fixed_real_container</span>;
<span>template</span>&lt;&gt; <span>struct</span> <span>fixed_real_container</span>&lt;8&gt;  { <span>typedef</span> <span>int8_t</span>  <span>base_type</span>;
                                             <span>typedef</span> <span>int16_t</span> <span>next_type</span>; };
<span>template</span>&lt;&gt; <span>struct</span> <span>fixed_real_container</span>&lt;16&gt; { <span>typedef</span> <span>int16_t</span> <span>base_type</span>;
                                             <span>typedef</span> <span>int24_t</span> <span>next_type</span>; };
<span>template</span>&lt;&gt; <span>struct</span> <span>fixed_real_container</span>&lt;24&gt; { <span>typedef</span> <span>int24_t</span> <span>base_type</span>;
                                             <span>typedef</span> <span>int32_t</span> <span>next_type</span>; };
<span>template</span>&lt;&gt; <span>struct</span> <span>fixed_real_container</span>&lt;32&gt; { <span>typedef</span> <span>int32_t</span> <span>base_type</span>;
                                             <span>typedef</span> <span>int64_t</span> <span>next_type</span>; };
<span>template</span>&lt;&gt; <span>struct</span> <span>fixed_real_container</span>&lt;64&gt; { <span>typedef</span> <span>int64_t</span> <span>base_type</span>;
                                             <span>typedef</span> <span>int64_t</span> <span>next_type</span>; };

<span>#pragma</span> pack(push, 1)
<span>template</span>&lt;<span>int</span> <span>bits</span>, <span>int</span> <span>exp</span>&gt;
<span>class</span> <span>fixed_real</span> {
  <span>typedef</span> <span>fixed_real</span> <span>fixed</span>;
  <span>typedef</span> <span>typename</span> <span>fixed_real_container</span>&lt;bits&gt;::<span>base_type</span> <span>base</span>;
  <span>typedef</span> <span>typename</span> <span>fixed_real_container</span>&lt;bits&gt;::<span>next_type</span> <span>next</span>;

  <span>base</span> <span>m</span>;
  <span>static</span> <span>const</span> <span>int</span> <span>N</span>      = (exp - 1);
  <span>static</span> <span>const</span> <span>int</span> <span>factor</span> = 1 &lt;&lt; N;

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>inline</span> <span>base</span> <span>from</span>(<span>T</span> <span>d</span>) <span>const</span> { <span>return</span> (<span>base</span>)(<span>d</span> * <span>factor</span>); }

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>inline</span> <span>T</span> <span>to_rational</span>() <span>const</span> { <span>return</span> T(m) / factor; }

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>inline</span> <span>T</span> <span>to_whole</span>() <span>const</span> { <span>return</span> (<span>T</span>)(m &gt;&gt; N); }

<span>public</span>:

  <span>//</span><span>from types</span>
  <span>explicit</span> <span>fixed_real</span>( )           : m(0) { }
  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>explicit</span> <span>fixed_real</span>(<span>T</span> <span>v</span>)         : m(from&lt;<span>T</span>&gt;(<span>v</span>)) {}

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>fixed</span>&amp; <span>operator</span><span>=</span>(<span>T</span> <span>v</span>)        { m = from&lt;<span>T</span>&gt;(v); <span>return</span> *<span>this</span>; }

  <span>//</span><span>to types</span>
  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>operator</span> <span>T</span>()           <span>const</span> { <span>return</span> to_whole&lt;<span>T</span>&gt;();    }
  <span>operator</span> <span>double</span>()      <span>const</span> { <span>return</span> to_rational&lt;<span>double</span>&gt;(); }

  <span>// </span><span>operations</span>
  <span>fixed</span>&amp; <span>operator</span><span>+=</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>) { m += x.m; <span>return</span> *<span>this</span>; }
  <span>fixed</span>&amp; <span>operator</span><span>-=</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>) { m -= x.m; <span>return</span> *<span>this</span>; }
  <span>fixed</span>&amp; <span>operator</span><span>*=</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>) { m = (<span>base</span>)(((<span>next</span>)m * (<span>next</span>)x.m) &gt;&gt; N); <span>return</span> *<span>this</span>; }
  <span>fixed</span>&amp; <span>operator</span><span>/=</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>) { m = (<span>base</span>)(((<span>next</span>)m * factor) / x.m); <span>return</span> *<span>this</span>; }
  <span>fixed</span>&amp; <span>operator</span><span>*=</span> (<span>int</span> <span>x</span>)          { m *= x; <span>return</span> *<span>this</span>; }
  <span>fixed</span>&amp; <span>operator</span><span>/=</span> (<span>int</span> <span>x</span>)          { m /= x; <span>return</span> *<span>this</span>; }
  <span>fixed</span>  <span>operator</span><span>-</span>  ( )              { <span>return</span> fixed(-m); }

  <span>// </span><span>friend functions</span>
  <span>friend</span> <span>fixed</span> <span>operator</span><span>+</span> (<span>fixed</span> <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x += y; }
  <span>friend</span> <span>fixed</span> <span>operator</span><span>-</span> (<span>fixed</span> <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x -= y; }
  <span>friend</span> <span>fixed</span> <span>operator</span><span>*</span> (<span>fixed</span> <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x *= y; }
  <span>friend</span> <span>fixed</span> <span>operator</span><span>/</span> (<span>fixed</span> <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x /= y; }

  <span>// </span><span>comparison operators</span>
  <span>friend</span> <span>bool</span> <span>operator</span><span>==</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x.m == y.m; }
  <span>friend</span> <span>bool</span> <span>operator</span><span>!=</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x.m != y.m; }
  <span>friend</span> <span>bool</span> <span>operator</span><span>&gt;</span>  (<span>const</span> <span>fixed</span>&amp; <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x.m &gt; y.m; }
  <span>friend</span> <span>bool</span> <span>operator</span><span>&lt;</span>  (<span>const</span> <span>fixed</span>&amp; <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x.m &lt; y.m; }
  <span>friend</span> <span>bool</span> <span>operator</span><span>&gt;=</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x.m &gt;= y.m; }
  <span>friend</span> <span>bool</span> <span>operator</span><span>&lt;=</span> (<span>const</span> <span>fixed</span>&amp; <span>x</span>, <span>const</span> <span>fixed</span>&amp; <span>y</span>) { <span>return</span> x.m &lt;= y.m; }

<span>#if</span> <span>defined</span>(FERRET_STD_LIB)
  <span>friend</span> <span>std</span>::<span>ostream</span>&amp; <span>operator</span><span>&lt;&lt;</span> (<span>std</span>::<span>ostream</span>&amp; <span>stream</span>, <span>const</span> <span>fixed</span>&amp; <span>x</span>) {
    stream &lt;&lt; (<span>double</span>)x;
    <span>return</span> stream;
  }
<span>#endif</span>
};
<span>#pragma</span> pack(pop)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-3">
<h4 id="sec-4-3-3">Matrices</h4>
<div id="text-4-3-3">
<p>
A matrix is a two-dimensional array often used for linear algebra.
</p>

<div>

<pre><span>#include</span> <span>&lt;cassert&gt;</span>
<span>#include</span> <span>&lt;runtime.h&gt;</span>

<span>int</span> <span>main</span>() {
  <span>using</span> <span>namespace</span> <span>ferret</span>;

  <span>//</span><span>initializers</span>
  assert((<span>matrix</span>::zeros(2,2)  == <span>matrix</span>::into&lt;2,2&gt;(0,0,0,0)));
  assert((<span>matrix</span>::ones(2,2)   == <span>matrix</span>::into&lt;2,2&gt;(1,1,1,1)));
  assert((<span>matrix</span>::eye(2)      == <span>matrix</span>::into&lt;2,2&gt;(1,0,0,1)));
  assert((<span>matrix</span>::full(2,2,4) == <span>matrix</span>::into&lt;2,2&gt;(4,4,4,4)));

  <span>//</span><span>shape</span>
  assert((<span>matrix</span>::row_count(<span>matrix</span>::zeros(2,3))    == 2));
  assert((<span>matrix</span>::column_count(<span>matrix</span>::zeros(2,3)) == 3));

  <span>//</span><span>operations</span>
  <span>matrix</span> <span>ones</span>  = <span>matrix</span>::ones(2,2);
  <span>matrix</span> <span>zeros</span> = <span>matrix</span>::zeros(2,2);
  <span>matrix</span> <span>twos</span>  = <span>matrix</span>::full(2,2,2);

  assert((ones - ones == zeros));
  assert((ones + ones == twos));
  assert((<span>ones</span> * 2    == twos));

  <span>auto</span> <span>v3d</span> = <span>matrix</span>::into&lt;1,3&gt;(0, 10, 0);

  assert((<span>matrix</span>::norm_euclidean(v3d) == 10));
  assert((<span>matrix</span>::normalise(v3d)      == <span>matrix</span>::into&lt;1,3&gt;(0, 1, 0)));
  <span>return</span> 0;
}
</pre>
</div>

<div>

<pre><span>class</span> <span>matrix</span> {
  <span>//</span><span>row-major</span>
  <span>array</span>&lt;<span>real_t</span>&gt; <span>data</span>;
  <span>//</span><span>shape</span>
  <span>size_t</span>  <span>rows</span>{0};
  <span>size_t</span>  <span>cols</span>{0};

  <span>inline</span> <span>static</span> <span>void</span> <span>into_aux</span>(<span>matrix</span> &amp;){ }

  <span>template</span>&lt;<span>typename</span>... Args&gt;
  <span>inline</span> <span>static</span> <span>void</span> <span>into_aux</span>(<span>matrix</span> &amp;<span>m</span>, <span>real_t</span> <span>first</span>, <span>Args</span>... <span>rest</span>){
    m.data[m.data.size() - <span>sizeof</span>...(rest) - 1] = first;
    into_aux(m, rest...);
  }

<span>public</span>:
  <span>inline</span> <span>matrix</span>(<span>size_t</span> <span>r</span> = 0, <span>size_t</span> <span>c</span> = 0) :
    data(<span>r</span> * <span>c</span>), <span>rows</span>(<span>r</span>) , <span>cols</span>(<span>c</span>) { }

  <span>template</span>&lt;<span>typename</span>... Args&gt;
  <span>inline</span> <span>matrix</span>(<span>size_t</span> <span>rows</span>, <span>size_t</span> <span>cols</span>, <span>Args</span>... <span>elements</span>)
    : matrix(rows,<span>cols</span>) {
    into_aux(*<span>this</span>, elements...);
  }

  <span>inline</span> <span>matrix</span>(<span>matrix</span>&amp;&amp; <span>m</span>) :
    data(m.data), rows(m.rows), cols(m.cols) { }

  <span>inline</span> <span>matrix</span>(<span>matrix</span>&amp; <span>m</span>)
    : matrix(m.rows,m.cols){
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; data.size(); i++)
      data[i] = m.data[i];
  }

  <span>inline</span> <span>matrix</span> <span>operator</span><span>+</span> (<span>const</span> <span>matrix</span>&amp; <span>m</span>) <span>const</span> {
    <span>matrix</span> <span>sum</span>(rows,<span>cols</span>);
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; data.size(); i++)
      sum.data[i] = data[i] + m.data[i];
    <span>return</span> sum;
  }

  <span>inline</span> <span>matrix</span> <span>operator</span><span>-</span> (<span>const</span> <span>matrix</span>&amp; <span>m</span>) <span>const</span> {
    <span>matrix</span> <span>diff</span>(rows,<span>cols</span>);
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; data.size(); i++)
      diff.data[i] = data[i] - m.data[i];
    <span>return</span> diff;
  }

  <span>matrix</span> <span>operator</span><span>*</span> (<span>const</span> <span>matrix</span>&amp; <span>m</span>) <span>const</span> {
    <span>matrix</span> <span>mul</span> = <span>matrix</span>::zeros(rows, m.cols);

    <span>if</span> (cols != m.rows)
      <span>return</span> mul;

    <span>for</span> (<span>size_t</span> <span>i</span> = 0; i &lt; rows; i++) {
      <span>for</span> (<span>size_t</span> <span>j</span> = 0; j &lt; m.cols; j++) {
        <span>for</span> (<span>size_t</span> <span>k</span> = 0; k &lt; m.rows; k++) {
          mul(i,j, mul(i,j) + <span>operator</span>()(i,k) * m(k,j));
        }
      }
    }

    <span>return</span> mul;
  }

  <span>matrix</span> <span>operator</span><span>*</span> (<span>const</span> <span>real_t</span>&amp; <span>val</span>) <span>const</span> {
    <span>matrix</span> <span>mul</span>(<span>rows</span>,<span>cols</span>);
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; data.size(); i++)
      mul.data[i] = data[i] * val;
    <span>return</span> mul;
  }

  <span>inline</span> <span>real_t</span> <span>operator</span><span>()</span>(<span>size_t</span> <span>row</span>, <span>size_t</span> <span>col</span>) <span>const</span> {
    <span>return</span> data[row * cols + col];
  }

  <span>inline</span> <span>void</span> <span>operator</span><span>()</span>(<span>size_t</span> <span>row</span>, <span>size_t</span> <span>col</span>, <span>real_t</span> <span>val</span>) {
    data[row * cols + col] = val;
  }

  <span>inline</span> <span>matrix</span>&amp; <span>operator</span><span>=</span>(<span>matrix</span>&amp;&amp; <span>x</span>){
    data = array&lt;<span>real_t</span>&gt;(x.data);
    rows = x.rows;
    cols = x.cols;
    <span>return</span> *<span>this</span>;
  }

  <span>inline</span> <span>bool</span> <span>operator</span> <span>==</span>(<span>const</span> <span>matrix</span>&amp; <span>m</span>) <span>const</span> {
    <span>for</span> (<span>size_t</span> <span>i</span> = 0; i &lt; data.size(); i++)
      <span>if</span> (data[i] != m.data[i])
        <span>return</span> <span>false</span>;
    <span>return</span> <span>true</span>;
  }

<span>#if</span> <span>defined</span>(FERRET_STD_LIB)
  <span>friend</span> <span>std</span>::<span>ostream</span>&amp; <span>operator</span><span>&lt;&lt;</span> (<span>std</span>::<span>ostream</span>&amp; <span>stream</span>, <span>const</span> <span>matrix</span>&amp; <span>x</span>) {
    stream &lt;&lt; <span>&#34;[&#34;</span>;
    <span>for</span> (<span>size_t</span> <span>r</span> = 0; r &lt; x.rows; r++){
      stream &lt;&lt; <span>&#34;[&#34;</span>;
      stream &lt;&lt; x(<span>r</span>, 0);
      <span>for</span> (<span>size_t</span> <span>c</span> = 1; c &lt; x.cols; c++)
        stream &lt;&lt; <span>&#34; &#34;</span> &lt;&lt; x(<span>r</span>,c);
      stream &lt;&lt; <span>&#34;]&#34;</span>;
    }
    <span>return</span> stream &lt;&lt; <span>&#34;]&#34;</span>;
  }
<span>#endif</span>

  <span>inline</span> <span>static</span> <span>matrix</span> <span>empty</span>(<span>size_t</span> <span>r</span> = 0, <span>size_t</span> <span>c</span> = 0) {
    <span>return</span> matrix(<span>r</span>,c);
  }

  <span>inline</span> <span>static</span> <span>void</span> <span>fill</span>(<span>matrix</span>&amp; <span>m</span>, <span>real_t</span> <span>val</span>) {
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; m.data.size(); i++)
      m.data[i] = val;
  }

  <span>inline</span> <span>static</span> <span>matrix</span> <span>zeros</span>(<span>size_t</span> <span>r</span> = 0, <span>size_t</span> <span>c</span> = 0) {
    <span>matrix</span> <span>m</span>(<span>r</span>,c);
    fill(<span>m</span>, real_t(0));
    <span>return</span> m;
  }

  <span>inline</span> <span>static</span> <span>matrix</span> <span>ones</span>(<span>size_t</span> <span>r</span> = 0, <span>size_t</span> <span>c</span> = 0) {
    <span>matrix</span> <span>m</span>(<span>r</span>,c);
    fill(<span>m</span>, real_t(1));
    <span>return</span> m;
  }

  <span>inline</span> <span>static</span> <span>matrix</span> <span>full</span>(<span>size_t</span> <span>r</span> = 0, <span>size_t</span> <span>c</span> = 0, <span>real_t</span> <span>v</span> = real_t(0)) {
    <span>matrix</span> <span>m</span>(<span>r</span>,c);
    fill(<span>m</span>, v);
    <span>return</span> m;
  }

  <span>static</span> <span>matrix</span> <span>eye</span>(<span>size_t</span> <span>n</span> = 1){
    <span>matrix</span> <span>m</span> = <span>matrix</span>::zeros(n,n);

    <span>for</span>(<span>size_t</span> <span>r</span> = 0; r &lt; m.rows; r++)
      <span>m</span>(<span>r</span>,<span>r</span>,real_t(1));

    <span>return</span> m;
  }

  <span>template</span>&lt;<span>size_t</span> <span>rows</span>, <span>size_t</span> <span>cols</span>, <span>typename</span>... Args&gt;
  <span>inline</span> <span>static</span> <span>matrix</span> <span>into</span>(<span>Args</span>... <span>rest</span>){
    <span>matrix</span> <span>m</span>(<span>rows</span>, <span>cols</span>);
    into_aux(<span>m</span>, rest...);
    <span>return</span> m;
  }

  <span>inline</span> <span>static</span> <span>size_t</span> <span>row_count</span>(<span>const</span> <span>matrix</span>&amp; <span>m</span>){
    <span>return</span> m.rows;
  }

  <span>inline</span> <span>static</span> <span>size_t</span> <span>column_count</span>(<span>const</span> <span>matrix</span>&amp; <span>m</span>){
    <span>return</span> m.cols;
  }

  <span>static</span> <span>real_t</span> <span>norm_euclidean</span>(<span>const</span> <span>matrix</span>&amp; <span>m</span>){
    <span>real_t</span> <span>norm</span> = real_t(0);

    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; m.data.size(); i++){
      norm += m.data[i] * m.data[i];
    }

    <span>return</span> real_t(sqrt((<span>double</span>)norm));
  }

  <span>static</span> <span>matrix</span> <span>normalise</span>(<span>const</span> <span>matrix</span>&amp; <span>m</span>){
    <span>real_t</span> <span>mag</span> = <span>matrix</span>::norm_euclidean(<span>m</span>);
    <span>matrix</span> <span>norm</span> = <span>matrix</span>::zeros(m.rows,m.cols);

    <span>if</span> (mag == real_t(0))
      <span>return</span> norm;

    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; m.data.size(); i++)
      norm.data[i] = m.data[i] / mag;

    <span>return</span> norm;
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4">
<h4 id="sec-4-3-4">Literals</h4>
<div id="text-4-3-4">
<p>
Math related string literals.
</p>

<div>

<pre><span>constexpr</span> <span>auto</span> <span>operator</span> <span>&#34;&#34;</span> _MB( <span>unsigned</span> <span>long</span> <span>long</span> <span>const</span> <span>x</span> ) -&gt; <span>long</span> {
  <span>return</span> 1024L * 1024L * (<span>long</span>)x;
}

<span>constexpr</span> <span>auto</span> <span>operator</span> <span>&#34;&#34;</span> _KB( <span>unsigned</span> <span>long</span> <span>long</span> <span>const</span> <span>x</span> ) -&gt; <span>long</span> {
  <span>return</span> 1024L * (<span>long</span>)x;
}

<span>constexpr</span> <span>auto</span> <span>operator</span> <span>&#34;&#34;</span> _pi(<span>long</span> <span>double</span> <span>x</span>) -&gt; <span>double</span> {
  <span>return</span> 3.14159265358979323846 * (<span>double</span>)x;
}

<span>constexpr</span> <span>auto</span> <span>operator</span> <span>&#34;&#34;</span> _pi(<span>unsigned</span> <span>long</span> <span>long</span> <span>int</span>  <span>x</span>) -&gt; <span>double</span> {
  <span>return</span> 1.0_pi * (<span>double</span>)x;
}

<span>constexpr</span> <span>auto</span> <span>operator</span> <span>&#34;&#34;</span> _deg(<span>long</span> <span>double</span> <span>x</span>) -&gt; <span>double</span> {
  <span>return</span> (1.0_pi * (<span>double</span>)x) / 180;
}

<span>constexpr</span> <span>auto</span> <span>operator</span> <span>&#34;&#34;</span> _deg(<span>unsigned</span> <span>long</span> <span>long</span> <span>int</span>  <span>x</span>) -&gt; <span>double</span> {
  <span>return</span> 1.0_deg * (<span>double</span>)x;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-4">
<h3 id="sec-4-4">Native Types</h3>
<p>
C++ types used by the Ferret runtime. Most embedded systems does
not provide standard types such as <code>std::array</code> so Ferret
provides its own types that are portable across architectures.
</p>

<div id="outline-container-sec-4-4-1">
<h4 id="sec-4-4-1">byte</h4>
<div id="text-4-4-1">
<p>
<code>byte</code> is a collection of bits.
</p>


</div>
</div>

<div id="outline-container-sec-4-4-2">
<h4 id="sec-4-4-2">int24_ t</h4>
<div id="text-4-4-2">
<p>
24 bit <b>Little-endian</b> integer type.
</p>

<div>

<pre><span>#pragma</span> pack(push, 1)
<span>class</span> <span>int24_t</span> {
<span>protected</span>:
  <span>byte</span> <span>word</span>[3];
<span>public</span>:
  <span>int24_t</span>(){ }

  <span>template</span>&lt;<span>typename</span> <span>T</span>&gt;
  <span>explicit</span> <span>int24_t</span>( <span>T</span> <span>const</span> &amp; <span>val</span> ) {
    *<span>this</span>   = (<span>int32_t</span>)val;
  }

  <span>int24_t</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) {
    *<span>this</span>   = val;
  }

  <span>operator</span> <span>int32_t</span>() <span>const</span> {
    <span>if</span> (word[2] &amp; 0x80) { <span>// </span><span>negative? - then sign extend.</span>
      <span>return</span>
        (<span>int32_t</span>)(((<span>uint32_t</span>)0xff    &lt;&lt; 24) |
                  ((<span>uint32_t</span>)word[2] &lt;&lt; 16) |
                  ((<span>uint32_t</span>)word[1] &lt;&lt; 8)  |
                  ((<span>uint32_t</span>)word[0] &lt;&lt; 0));
    }<span>else</span>{
      <span>return</span>
        (<span>int32_t</span>)(((<span>uint32_t</span>)word[2] &lt;&lt; 16) |
                  ((<span>uint32_t</span>)word[1] &lt;&lt; 8)  |
                  ((<span>uint32_t</span>)word[0] &lt;&lt; 0));
    }
  }

  <span>int24_t</span>&amp; <span>operator</span> <span>=</span>( <span>const</span> <span>int24_t</span>&amp; <span>input</span> ) {
    word[0]   = input.word[0];
    word[1]   = input.word[1];
    word[2]   = input.word[2];

    <span>return</span> *<span>this</span>;
  }

  <span>int24_t</span>&amp; <span>operator</span> <span>=</span>( <span>const</span> <span>int32_t</span> <span>input</span> ) {
    word[0]   = ((<span>byte</span>*)&amp;input)[0];
    word[1]   = ((<span>byte</span>*)&amp;input)[1];
    word[2]   = ((<span>byte</span>*)&amp;input)[2];

    <span>return</span> *<span>this</span>;
  }

  <span>int24_t</span> <span>operator</span> <span>+</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> int24_t( (<span>int32_t</span>)*<span>this</span> + (<span>int32_t</span>)val );
  }

  <span>int24_t</span> <span>operator</span> <span>-</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> int24_t( (<span>int32_t</span>)*<span>this</span> - (<span>int32_t</span>)val );
  }

  <span>int24_t</span> <span>operator</span> <span>*</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> int24_t( (<span>int32_t</span>)*<span>this</span> * (<span>int32_t</span>)val );
  }

  <span>int24_t</span> <span>operator</span> <span>/</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> int24_t( (<span>int32_t</span>)*<span>this</span> / (<span>int32_t</span>)val );
  }

  <span>int24_t</span>&amp; <span>operator</span> <span>+=</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) {
    *<span>this</span>   = *<span>this</span> + val;
    <span>return</span> *<span>this</span>;
  }

  <span>int24_t</span>&amp; <span>operator</span> <span>-=</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) {
    *<span>this</span>   = *<span>this</span> - val;
    <span>return</span> *<span>this</span>;
  }

  <span>int24_t</span>&amp; <span>operator</span> <span>*=</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) {
    *<span>this</span>   = *<span>this</span> * val;
    <span>return</span> *<span>this</span>;
  }

  <span>int24_t</span>&amp; <span>operator</span> <span>/=</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) {
    *<span>this</span>   = *<span>this</span> / val;
    <span>return</span> *<span>this</span>;
  }

  <span>int24_t</span> <span>operator</span> <span>-</span>() {
    <span>return</span> int24_t( -(<span>int32_t</span>)*<span>this</span> );
  }

  <span>bool</span> <span>operator</span> <span>==</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> (<span>int32_t</span>)*<span>this</span> == (<span>int32_t</span>)val;
  }

  <span>bool</span> <span>operator</span> <span>!=</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> (<span>int32_t</span>)*<span>this</span> != (<span>int32_t</span>)val;
  }

  <span>bool</span> <span>operator</span> <span>&gt;=</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> (<span>int32_t</span>)*<span>this</span> &gt;= (<span>int32_t</span>)val;
  }

  <span>bool</span> <span>operator</span> <span>&lt;=</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> (<span>int32_t</span>)*<span>this</span> &lt;= (<span>int32_t</span>)val;
  }

  <span>bool</span> <span>operator</span> <span>&gt;</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> (<span>int32_t</span>)*<span>this</span> &gt; (<span>int32_t</span>)val;
  }

  <span>bool</span> <span>operator</span> <span>&lt;</span>( <span>const</span> <span>int24_t</span>&amp; <span>val</span> ) <span>const</span> {
    <span>return</span> (<span>int32_t</span>)*<span>this</span> &lt; (<span>int32_t</span>)val;
  }
};
<span>#pragma</span> pack(pop)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4-3">
<h4 id="sec-4-4-3">array</h4>
<div id="text-4-4-3">
<p>
<code>array</code> is a container that encapsulates fixed size arrays.
</p>

<div>

<pre><span>#include</span> <span>&lt;cassert&gt;</span>
<span>#include</span> <span>&lt;runtime.h&gt;</span>

<span>int</span> <span>main</span>() {
  <span>using</span> <span>namespace</span> <span>ferret</span>;

  <span>array</span>&lt;<span>char</span>&gt; <span>buffer</span>(16);
  assert((buffer.size() == 16));

  <span>array</span>&lt;<span>char</span>&gt; <span>str</span>(<span>&#34;abcde&#34;</span>,5);
  assert((str[0] == <span>&#39;a&#39;</span>));
  assert((str[1] == <span>&#39;b&#39;</span>));
  assert((str[4] == <span>&#39;e&#39;</span>));

  <span>array</span>&lt;<span>int</span>&gt; <span>numbers</span> {1, 2, 3, 4, 5};
  assert((numbers[0] == 1));
  assert((numbers[1] == 2));
  assert((numbers[2] == 3));
  assert((numbers[3] == 4));
  assert((numbers[4] == 5));

  <span>// </span><span>cppcheck-suppress useStlAlgorithm</span>
  <span>for</span> (<span>int</span>&amp; <span>x</span> : numbers) { x++; }

  assert((numbers[0] == 2));
  assert((numbers[1] == 3));
  assert((numbers[2] == 4));
  assert((numbers[3] == 5));
  assert((numbers[4] == 6));

  <span>return</span> 0;
}
</pre>
</div>

<div>

<pre><span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
<span>class</span> <span>array</span> {
  <span>size_t</span>  <span>_size</span>{0};

<span>public</span>:

  T* <span>data</span> {<span>nullptr</span>};

  <span>explicit</span> <span>inline</span> <span>array</span>(<span>size_t</span> <span>s</span> = 0) : _size(s) {
    data = (<span>T</span> *)<span>FERRET_ALLOCATOR</span>::allocate(<span>_size</span> * <span>sizeof</span>(<span>T</span>));
  }

  <span>explicit</span> <span>inline</span> <span>array</span>(<span>const</span> <span>T</span>* <span>source</span>, <span>size_t</span> <span>s</span> = 0) : _size(s) {
    data = (<span>T</span> *)<span>FERRET_ALLOCATOR</span>::allocate(<span>_size</span> * <span>sizeof</span>(<span>T</span>));
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; _size; i++)
      data[i] = source[i];
  }

<span>#if</span> <span>defined</span>(FERRET_STD_LIB)
  <span>explicit</span> <span>inline</span> <span>array</span>(<span>std</span>::<span>initializer_list</span>&lt;<span>T</span>&gt; <span>source</span>) :
    _size(source.size()) {
    data = (<span>T</span> *)<span>FERRET_ALLOCATOR</span>::allocate(<span>_size</span> * <span>sizeof</span>(<span>T</span>));
    <span>size_t</span> <span>idx</span> = 0;
    <span>for</span>(<span>auto</span> <span>item</span> : source){  
      data[idx] = item;
      idx++;
    }
  }
<span>#endif</span>

  <span>inline</span> <span>array</span>(<span>array</span>&amp;&amp; <span>m</span>) :
    data(m.data), _size(m.size()) { m.data = <span>nullptr</span>; }

  <span>inline</span> <span>array</span>(<span>array</span>&amp; <span>m</span>) : _size(m.size()){
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; _size; i++)
      data[i] = m.data[i];
  }

  ~<span>array</span>(){
    <span>FERRET_ALLOCATOR</span>::free(data);
  }


  <span>inline</span> <span>array</span>&amp; <span>operator</span><span>=</span>(<span>array</span>&amp;&amp; <span>x</span>){
    data = x.data;
    _size = x._size;
    x.data = <span>nullptr</span>;
    <span>return</span> *<span>this</span>;
  }

  <span>inline</span> <span>T</span>&amp; <span>operator</span> <span>[]</span>(<span>size_t</span> <span>idx</span>)      { <span>return</span> data[idx]; }
  <span>inline</span> <span>T</span> <span>operator</span> <span>[]</span>(<span>size_t</span> <span>idx</span>) <span>const</span> { <span>return</span> data[idx]; }

  <span>inline</span> <span>T</span>*      <span>begin</span>() <span>const</span> { <span>return</span> &amp;data[0];      }
  <span>inline</span> <span>T</span>*      <span>end</span>()   <span>const</span> { <span>return</span> &amp;data[_size];  }
  <span>inline</span> <span>size_t</span>  <span>size</span>()  <span>const</span> { <span>return</span> _size;         }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4-4">
<h4 id="sec-4-4-4">bitset</h4>
<div id="text-4-4-4">
<p>
<code>bitset</code> represents a fixed-size sequence of N bits.
</p>

<div>

<pre><span>#include</span> <span>&lt;cassert&gt;</span>
<span>#include</span> <span>&lt;runtime.h&gt;</span>

<span>int</span> <span>main</span>() {
  <span>using</span> <span>namespace</span> <span>ferret</span>;

  assert(FERRET_BITSET_USE_COMPILER_INTRINSICS == <span>true</span>);

  <span>bitset</span>&lt;32&gt; <span>bs_a</span>;
  assert(32 == bs_a.ffs(0));
  <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; 2; i++)  bs_a.set(i);
  assert(0  == bs_a.ffs(0));
  assert(1  == bs_a.ffs(1));
  <span>for</span>(<span>size_t</span> <span>i</span> = 7; i &lt; 16; i++) bs_a.set(i);
  assert(2  == bs_a.ffr(0));
  assert(5  == bs_a.ffr(5));
  assert(16 == bs_a.ffr(10));
  assert(32 == bs_a.ffs(31));

  <span>bitset</span>&lt;64&gt; <span>bs_b</span>;
  assert(0  == bs_b.ffr(0));
  assert(64 == bs_b.ffs(0));
  <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; 8; i++)   bs_b.set(i);
  assert(0  == bs_b.ffs(0));
  assert(5  == bs_b.ffs(5));
  assert(8  == bs_b.ffr(5));
  <span>for</span>(<span>size_t</span> <span>i</span> = 16; i &lt; 48; i++) bs_b.set(i);
  assert(16 == bs_b.ffs(8));
  assert(48 == bs_b.ffr(16));

  <span>bitset</span>&lt;1024&gt; <span>bs_c</span>;
  assert(0     == bs_c.ffr(0));
  assert(1024  == bs_c.ffs(0));
  <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; 32; i++)  bs_c.set(i);
  assert(0     == bs_c.ffs(0));
  assert(32    == bs_c.ffr(0));
  <span>for</span>(<span>size_t</span> <span>i</span> = 256; i &lt; 512; i++) bs_c.set(i);
  assert(256   == bs_c.ffs(256));
  assert(512   == bs_c.ffr(256));
  <span>for</span>(<span>size_t</span> <span>i</span> = 768; i &lt; 1024; i++) bs_c.set(i);
  assert(1024  == bs_c.ffr(768));

  <span>bitset</span>&lt;1024&gt; <span>bs_d</span>;
  assert(0    == bs_d.ffr(0));
  bs_d.flip(0);
  assert(1    == bs_d.ffr(0));
  bs_d.flip(0);
  assert(0    == bs_d.ffr(0));

  assert(1024 == bs_d.ffs(0));
  bs_d.set(0, 1024);
  assert(0 == bs_d.ffs(0));
  bs_d.reset(0, 1024);
  assert(1024 == bs_d.ffs(0));
  bs_d.flip(0, 1024);
  assert(0 == bs_d.ffs(0));
  bs_d.flip(0, 1024);
  assert(1024 == bs_d.ffs(0));

  bs_d.set(256,512);
  bs_d.set(768,1024);

  assert(512  == bs_d.ffr(256));
  assert(256  == bs_d.ffs(256));
  assert(1024 == bs_d.ffr(768));
  assert(768  == bs_d.ffs(768));

  bs_d.reset(0,1024);
  <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; 87; i++)  bs_d.set(i);
  <span>for</span>(<span>size_t</span> <span>i</span> = 90; i &lt; 94; i++)  bs_d.set(i);
  <span>for</span>(<span>size_t</span> <span>i</span> = 106; i &lt; 111; i++)  bs_d.set(i);
  <span>for</span>(<span>size_t</span> <span>i</span> = 136; i &lt; 149; i++)  bs_d.set(i);

  assert(106 == bs_d.ffs(94,100));

  assert((15    == <span>bitset</span>&lt;8,<span>unsigned</span> <span>char</span>&gt;::bit_block(0,4)));
  assert((15    == <span>bitset</span>&lt;32,<span>unsigned</span> <span>int</span>&gt;::bit_block(0,4)));
  assert((60    == <span>bitset</span>&lt;32,<span>unsigned</span> <span>int</span>&gt;::bit_block(2,4)));
  assert((1024  == <span>bitset</span>&lt;32,<span>unsigned</span> <span>int</span>&gt;::bit_block(10,1)));
  assert((3072  == <span>bitset</span>&lt;32,<span>unsigned</span> <span>int</span>&gt;::bit_block(10,2)));
  assert((98304 == <span>bitset</span>&lt;32,<span>unsigned</span> <span>int</span>&gt;::bit_block(15,2)));
  assert((-1U   == <span>bitset</span>&lt;32,<span>unsigned</span> <span>int</span>&gt;::bit_block(0,60)));
  assert((-1U   == <span>bitset</span>&lt;32,<span>unsigned</span> <span>int</span>&gt;::bit_block(0,32)));

  <span>return</span> 0;
}
</pre>
</div>

<div>

<pre><span>#undef</span> bit

<span>#if</span> !<span>defined</span>(FERRET_BITSET_WORD_TYPE)
<span>  #define</span> <span>FERRET_BITSET_WORD_TYPE</span> <span>unsigned</span> <span>int</span>
<span>  #if</span> <span>defined</span>(__clang__) || <span>defined</span>(__GNUG__)
<span>    #define</span> <span>FERRET_BITSET_USE_COMPILER_INTRINSICS</span> <span>true</span>
<span>  #endif</span>
<span>#endif</span>

<span>template</span>&lt;<span>size_t</span> <span>S</span>, <span>typename</span> <span>word_t</span> = <span>FERRET_BITSET_WORD_TYPE</span>&gt;
<span>class</span> <span>bitset</span> {
  <span>static</span> <span>const</span> <span>size_t</span> <span>bits_per_word</span> = <span>sizeof</span>(<span>word_t</span>) * 8;
  <span>static</span> <span>const</span> <span>size_t</span> <span>n_words</span> = S / bits_per_word;

  static_assert((S % bits_per_word) == 0, <span>&#34;bitset size must be a multiple of word_t&#34;</span>);

  <span>word_t</span> <span>bits</span>[n_words];

  <span>inline</span> <span>size_t</span> <span>word</span> (<span>size_t</span> <span>i</span>) <span>const</span> { <span>return</span> i / bits_per_word; }
  <span>inline</span> <span>size_t</span> <span>bit</span>  (<span>size_t</span> <span>i</span>) <span>const</span> { <span>return</span> i % bits_per_word; }

<span>public</span>:
  <span>bitset</span>() : bits{ <span>word_t</span>(0x00) } { }

  <span>inline</span> <span>void</span> <span>set</span>   (<span>size_t</span> <span>b</span>){
    bits[word(b)] = (<span>word_t</span>)(<span>bits</span>[word(b)] |  (word_t(1) &lt;&lt; (<span>bit</span>(<span>b</span>))));
  }

  <span>inline</span> <span>void</span> <span>set</span> (<span>size_t</span> <span>b</span>, <span>size_t</span> <span>e</span>){
    <span>size_t</span> <span>word_ptr</span> = word(b);
    <span>size_t</span> <span>n_bits</span> = e - b;

    bits[word_ptr] = (<span>word_t</span>)(<span>bits</span>[word_ptr] | bit_block(<span>bit</span>(<span>b</span>), n_bits));

    n_bits -= bits_per_word - bit(b);
    word_ptr++;
    <span>size_t</span> <span>last_word</span> = (<span>word</span>(<span>e</span>) == n_words) ? n_words : word(e) + 1;
    <span>for</span> (; word_ptr &lt; last_word; word_ptr++){
      bits[word_ptr] = (<span>word_t</span>)(<span>bits</span>[word_ptr] | bit_block(0, n_bits));
      n_bits -= bits_per_word;
    }
  }

  <span>inline</span> <span>void</span> <span>reset</span> (<span>size_t</span> <span>b</span>){
    bits[word(b)] = (<span>word_t</span>)(<span>bits</span>[word(b)] &amp; ~(word_t(1) &lt;&lt; (<span>bit</span>(<span>b</span>))));
  }

  <span>inline</span> <span>void</span> <span>reset</span> (<span>size_t</span> <span>b</span>, <span>size_t</span> <span>e</span>){
    <span>size_t</span> <span>word_ptr</span> = word(b);
    <span>size_t</span> <span>n_bits</span> = e - b;

    bits[word_ptr] = (<span>word_t</span>)(<span>bits</span>[word_ptr] &amp; ~bit_block(<span>bit</span>(<span>b</span>), n_bits));

    n_bits -= bits_per_word - bit(b);
    word_ptr++;
    <span>size_t</span> <span>last_word</span> = (<span>word</span>(<span>e</span>) == n_words) ? n_words : word(e) + 1;
    <span>for</span> (; word_ptr &lt; last_word; word_ptr++){
      bits[word_ptr] = (<span>word_t</span>)(<span>bits</span>[word_ptr] &amp; ~bit_block(0, n_bits));
      n_bits -= bits_per_word;
    }
  }

  <span>inline</span> <span>void</span> <span>flip</span> (<span>size_t</span> <span>b</span>){
    bits[word(b)] = (<span>word_t</span>)(<span>bits</span>[word(b)] ^  (word_t(1) &lt;&lt; (<span>bit</span>(<span>b</span>))));
  }

  <span>inline</span> <span>void</span> <span>flip</span> (<span>size_t</span> <span>b</span>, <span>size_t</span> <span>e</span>){
    <span>size_t</span> <span>word_ptr</span> = word(b);
    <span>size_t</span> <span>n_bits</span> = e - b;

    bits[word_ptr] = (<span>word_t</span>)(<span>bits</span>[word_ptr] ^ bit_block(<span>bit</span>(<span>b</span>), n_bits));

    n_bits -= bits_per_word - bit(b);
    word_ptr++;
    <span>size_t</span> <span>last_word</span> = (<span>word</span>(<span>e</span>) == n_words) ? n_words : word(e) + 1;
    <span>for</span> (; word_ptr &lt; last_word; word_ptr++){
      bits[word_ptr] = (<span>word_t</span>)(<span>bits</span>[word_ptr] ^ bit_block(0, n_bits));
      n_bits -= bits_per_word;
    }
  }

  <span>inline</span> <span>bool</span> <span>test</span>  (<span>size_t</span> <span>b</span>) <span>const</span> {
    <span>return</span> (<span>bits</span>[word(b)] &amp; (word_t(1) &lt;&lt; (<span>bit</span>(<span>b</span>))));
  }

  <span>inline</span> <span>size_t</span> <span>ffs</span>(<span>size_t</span> <span>b</span> = 0, <span>size_t</span> <span>e</span> = S) <span>const</span> {
<span>#if</span> <span>defined</span>(FERRET_BITSET_USE_COMPILER_INTRINSICS)
      <span>// </span><span>search first word</span>
      <span>size_t</span> <span>word_ptr</span> = word(b);
      <span>word_t</span> <span>this_word</span> = bits[word_ptr];

      <span>// </span><span>mask off bits below bound</span>
      this_word &amp;= (~<span>static_cast</span>&lt;<span>word_t</span>&gt;(0)) &lt;&lt; bit(b);

      <span>if</span> (this_word != <span>static_cast</span>&lt;<span>word_t</span>&gt;(0))
        <span>return</span> ((<span>word_ptr</span> * bits_per_word) + (<span>size_t</span>) __builtin_ctz(this_word));

      <span>// </span><span>check subsequent words</span>
      word_ptr++;
      <span>size_t</span> <span>last_word</span> = (<span>word</span>(<span>e</span>) == n_words) ? n_words : word(e) + 1;
      <span>for</span> (; word_ptr &lt; last_word; word_ptr++){
        this_word = bits[word_ptr];
        <span>if</span> (this_word != <span>static_cast</span>&lt;<span>word_t</span>&gt;(0))
          <span>return</span> ((<span>word_ptr</span> * bits_per_word) + (<span>size_t</span>) __builtin_ctz(this_word));
      }
<span>#else</span>
      <span>for</span>(<span>size_t</span> <span>i</span> = b; i &lt; e; i++)
        <span>if</span> (test(i))
          <span>return</span> i;
<span>#endif</span>
    <span>return</span> S;
  }

  <span>inline</span> <span>size_t</span> <span>ffr</span>(<span>size_t</span> <span>b</span> = 0, <span>size_t</span> <span>e</span> = S) <span>const</span> {
<span>#if</span> <span>defined</span>(FERRET_BITSET_USE_COMPILER_INTRINSICS)
      <span>// </span><span>same as ffs but complements word before counting</span>
      <span>size_t</span> <span>word_ptr</span> = word(b);
      <span>word_t</span> <span>this_word</span> = ~bits[word_ptr];

      this_word &amp;= (~<span>static_cast</span>&lt;<span>word_t</span>&gt;(0)) &lt;&lt; bit(b);

      <span>if</span> (this_word != <span>static_cast</span>&lt;<span>word_t</span>&gt;(0))
        <span>return</span> ((<span>word_ptr</span> * bits_per_word) + (<span>size_t</span>) __builtin_ctz(this_word));

      word_ptr++;
      <span>size_t</span> <span>last_word</span> = (<span>word</span>(<span>e</span>) == n_words) ? n_words : word(<span>e</span>) + 1;
      <span>for</span> (; word_ptr &lt; last_word; word_ptr++){
        this_word = ~bits[word_ptr];
        <span>if</span> (this_word != <span>static_cast</span>&lt;<span>word_t</span>&gt;(0))
          <span>return</span> ((<span>word_ptr</span> * bits_per_word) + (<span>size_t</span>) __builtin_ctz(this_word));
      }
<span>#else</span>
      <span>for</span>(<span>size_t</span> <span>i</span> = b; i &lt; e; i++)
        <span>if</span> (!test(i))
          <span>return</span> i;
<span>#endif</span>
    <span>return</span> S;
  }

  <span>// </span><span>Return word with length-n bit block starting at bit p set.</span>
  <span>// </span><span>Both p and n are effectively taken modulo bits_per_word.</span>
  <span>static</span> <span>inline</span> <span>word_t</span> <span>bit_block</span>(<span>size_t</span> <span>p</span>, <span>size_t</span> <span>n</span>){
    <span>if</span> (n &gt;= bits_per_word)
      <span>return</span> (<span>word_t</span>)(word_t(-1) &lt;&lt; p);

    <span>word_t</span> <span>x</span> = (<span>word_t</span>)((word_t(1) &lt;&lt; n) - word_t(1));
    <span>return</span>  (<span>word_t</span>)(x &lt;&lt; p);
  }

<span>#if</span> <span>defined</span>(FERRET_STD_LIB)
  <span>friend</span> <span>std</span>::<span>ostream</span>&amp; <span>operator</span><span>&lt;&lt;</span> (<span>std</span>::<span>ostream</span>&amp; <span>stream</span>, <span>bitset</span>&amp; x) {
    <span>for</span>(<span>size_t</span> <span>i</span> = 0; i &lt; S; i++)
      stream &lt;&lt; x.test(i);
    <span>return</span> stream;
  }
<span>#endif</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4-5">
<h4 id="sec-4-4-5">mutex</h4>
<div id="text-4-4-5">
<p>
Locking abstractions for various platforms. They are disabled when
running single threaded or on an embedded platform. (<code>FERRET_STD_LIB</code>
not defined.)
</p>

<div>

<pre><span>#if</span> <span>defined</span>(FERRET_DISABLE_MULTI_THREADING)
  <span>class</span> <span>mutex</span> {
  <span>public</span>:
    <span>void</span> <span>lock</span>()   {} 
    <span>void</span> <span>unlock</span>() {} 
  };
<span>#else</span>
<span>  #if</span> <span>defined</span>(FERRET_STD_LIB)
    <span>class</span> <span>mutex</span> {
      ::<span>std</span>::<span>mutex</span> <span>m</span>;
    <span>public</span>:
      <span>void</span> <span>lock</span>()   { m.lock();   } 
      <span>void</span> <span>unlock</span>() { m.unlock(); }
    };
<span>  #endif</span>

<span>  #if</span> <span>defined</span>(FERRET_HARDWARE_ARDUINO)
    <span>class</span> <span>mutex</span> {
    <span>public</span>:
      <span>void</span> <span>lock</span>()   { noInterrupts(); } 
      <span>void</span> <span>unlock</span>() { interrupts();   }
    };
<span>  #endif</span>
<span>#endif</span>

<span>class</span> <span>lock_guard</span>{
  <span>mutex</span> &amp; <span>_ref</span>;
<span>public</span>:
  <span>explicit</span> <span>lock_guard</span>(<span>const</span> <span>lock_guard</span> &amp;) = <span>delete</span>;
  <span>explicit</span> <span>lock_guard</span>(<span>mutex</span> &amp; <span>mutex</span>) : _ref(<span>mutex</span>) { _ref.lock(); };
  ~<span>lock_guard</span>() { _ref.unlock(); }
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-5">
<h3 id="sec-4-5">Initialization</h3>
<div id="outline-container-sec-4-5-1">
<h4 id="sec-4-5-1">Detect Hardware</h4>
<div id="text-4-5-1">
<p>
Check for supported hardware or platform. If running on a known
hardware or platform break out of <b>Safe Mode</b> and set a flag
indicating platform.
</p>

<div>

<pre><span># define</span> <span>FERRET_CONFIG_SAFE_MODE</span> TRUE

<span>#if</span> !<span>defined</span>(FERRET_SAFE_MODE)
<span>  #if</span> <span>defined</span>(__APPLE__) ||                       \
    <span>defined</span>(_WIN32) ||                            \
    <span>defined</span>(__linux__) ||                         \
    <span>defined</span>(__unix__) ||                          \
    <span>defined</span>(_POSIX_VERSION)

<span>    # undef</span>  FERRET_CONFIG_SAFE_MODE
<span>    # define</span> <span>FERRET_STD_LIB</span> TRUE
<span>  #endif</span>

<span>  #if</span> <span>defined</span>(ARDUINO)

<span>    # define</span> <span>FERRET_HARDWARE_ARDUINO</span> TRUE

<span>    #if</span> !<span>defined</span>(FERRET_HARDWARE_ARDUINO_UART_PORT)
<span>      # define</span> <span>FERRET_HARDWARE_ARDUINO_UART_PORT</span> Serial
<span>    #endif</span>
<span>  #endif</span>

<span>  #if</span> <span>defined</span>(FERRET_HARDWARE_ARDUINO)
<span>    # undef</span>  FERRET_CONFIG_SAFE_MODE
<span>    # define</span> <span>FERRET_DISABLE_STD_MAIN</span> TRUE
<span>  #endif</span>
<span>#endif</span>

<span>#if</span> <span>defined</span>(FERRET_CONFIG_SAFE_MODE)
<span>  # define</span> <span>FERRET_DISABLE_MULTI_THREADING</span> TRUE
<span>  # define</span> <span>FERRET_DISABLE_STD_OUT</span> TRUE
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5-2">
<h4 id="sec-4-5-2">Import libraries</h4>
<div id="text-4-5-2">
<div>

<pre><span>#ifdef</span> FERRET_STD_LIB
<span> #include</span> <span>&lt;iostream&gt;</span>
<span> #include</span> <span>&lt;iomanip&gt;</span>
<span> #include</span> <span>&lt;sstream&gt;</span>
<span> #include</span> <span>&lt;cstdio&gt;</span>
<span> #include</span> <span>&lt;cstdlib&gt;</span>
<span> #include</span> <span>&lt;cstddef&gt;</span>
<span> #include</span> <span>&lt;cmath&gt;</span>
<span> #include</span> <span>&lt;vector&gt;</span>
<span> #include</span> <span>&lt;algorithm&gt;</span>
<span> #include</span> <span>&lt;chrono&gt;</span>
<span> #include</span> <span>&lt;atomic&gt;</span>
<span> #include</span> <span>&lt;mutex&gt;</span>
<span> #include</span> <span>&lt;thread&gt;</span>
<span> #include</span> <span>&lt;future&gt;</span>
<span>#endif</span>

<span>#ifdef</span> FERRET_HARDWARE_ARDUINO
<span> #include</span> <span>&lt;Arduino.h&gt;</span>
<span> #include</span> <span>&lt;stdio.h&gt;</span>
<span> #include</span> <span>&lt;stdlib.h&gt;</span>
<span> #include</span> <span>&lt;stdint.h&gt;</span>
<span>#endif</span>

<span>#ifdef</span> FERRET_CONFIG_SAFE_MODE
<span> #include</span> <span>&lt;stdio.h&gt;</span>
<span> #include</span> <span>&lt;stdlib.h&gt;</span>
<span> #include</span> <span>&lt;stdint.h&gt;</span>
<span> #include</span> <span>&lt;math.h&gt;</span>
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5-3">
<h4 id="sec-4-5-3">Initialize Hardware</h4>
<div id="text-4-5-3">
<p>
Default UART rate (if supported),
</p>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_UART_RATE)
<span>  # define</span> <span>FERRET_UART_RATE</span> 9600
<span>#endif</span>
</pre>
</div>

<p>
Default stream size, represents the number of characters transferred
in an I/O operation or the size of an I/O buffer.
</p>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_IO_STREAM_SIZE)
<span>  # define</span> <span>FERRET_IO_STREAM_SIZE</span> 80
<span>#endif</span>
</pre>
</div>

<p>
Setup dummy IO,
</p>

<div>

<pre><span>#if</span> <span>defined</span>(FERRET_DISABLE_STD_OUT)
   <span>namespace</span> <span>runtime</span>{
     <span>void</span> <span>init</span>(){ }

     <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
     <span>void</span> <span>print</span>(<span>T</span>){ }
   }
<span>#endif</span>
</pre>
</div>

<p>
Setup IO for general purpose OS,
</p>

<div>

<pre><span>#if</span> <span>defined</span>(FERRET_STD_LIB) &amp;&amp; !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>namespace</span> <span>runtime</span>{
    <span>void</span> <span>init</span>(){}

    <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
    <span>void</span> <span>print</span>(<span>const</span> <span>T</span> &amp; <span>t</span>){ <span>std</span>::cout &lt;&lt; t; }

    <span>template</span> &lt;&gt;
    <span>void</span> <span>print</span>(<span>const</span> <span>real_t</span> &amp; <span>n</span>){
      <span>std</span>::cout &lt;&lt; <span>std</span>::fixed &lt;&lt; <span>std</span>::setprecision(real_precision) &lt;&lt; n;
    }

    <span>void</span> <span>read_line</span>(<span>char</span> *<span>buff</span>, <span>std</span>::<span>streamsize</span> <span>len</span>){
      <span>std</span>::cin.getline(buff, len);
    }
  }
<span>#endif</span>
</pre>
</div>

<p>
Setup IO for Arduino boards,
</p>

<div>

<pre><span>#if</span> <span>defined</span>(FERRET_HARDWARE_ARDUINO) &amp;&amp; !<span>defined</span>(FERRET_DISABLE_STD_OUT) 
  <span>namespace</span> <span>runtime</span>{
    <span>void</span> <span>init</span>(){ FERRET_HARDWARE_ARDUINO_UART_PORT.begin(FERRET_UART_RATE); }

    <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
    <span>void</span> <span>print</span>(<span>const</span> <span>T</span> <span>t</span>){ FERRET_HARDWARE_ARDUINO_UART_PORT.print(t); }

    <span>template</span> &lt;&gt;
    <span>// </span><span>cppcheck-suppress passedByValue</span>
    <span>void</span> <span>print</span>(<span>const</span> <span>real_t</span> <span>d</span>){
      FERRET_HARDWARE_ARDUINO_UART_PORT.print(<span>double</span>(<span>d</span>), real_precision);
    }

    <span>template</span> &lt;&gt;
    <span>void</span> <span>print</span>(<span>void</span> *<span>p</span>){
      FERRET_HARDWARE_ARDUINO_UART_PORT.print((<span>size_t</span>)p,HEX);
    }

    <span>template</span> &lt;&gt; <span>void</span> <span>print</span>(<span>const</span> <span>void</span> * <span>const</span> <span>p</span>){
      FERRET_HARDWARE_ARDUINO_UART_PORT.print((<span>size_t</span>)p, HEX);
    }

    <span>void</span> <span>read_line</span>(<span>char</span> *<span>buff</span>, <span>size_t</span> <span>len</span>){
      <span>byte</span> <span>idx</span> = 0;
      <span>char</span> <span>c</span>;
      <span>do</span>{
        <span>while</span> (FERRET_HARDWARE_ARDUINO_UART_PORT.available() == 0);
        c = FERRET_HARDWARE_ARDUINO_UART_PORT.read();
        buff[idx++] = c;
      }<span>while</span> (c != <span>&#39;\n&#39;</span>);
      buff[--idx] = 0x00;
    }
   }
<span>#endif</span>
</pre>
</div>

<p>
Prints data to the output stream as human-readable ASCII text followed
by a newline character (<code>ASCII 10</code>, or <code>\n</code>).
</p>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
   <span>namespace</span> <span>runtime</span>{
     <span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
     <span>void</span> <span>println</span>(<span>T</span> <span>t</span>){
       print(t);
       print((<span>char</span>)0xA);
     }
   }
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5-4">
<h4 id="sec-4-5-4">Program Run</h4>
<div id="text-4-5-4">
<p>
Unless <code>FERRET_DISABLE_STD_MAIN</code> is <b>defined</b> a <code>main</code> function is
defined which is the designated start of the
program. <code>program::main()</code> function contains all compiled
code. Executing this function has equivalent semantics to loading the
source file into a virgin interpreter and then terminating its
execution. If <code>FERRET_PROGRAM_MAIN</code> is defined, it will be called
right after <code>program::main()</code>.
</p>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_MAIN)
<span> #if</span> <span>defined</span>(FERRET_DISABLE_CLI_ARGS) || !<span>defined</span>(FERRET_STD_LIB)
  <span>int</span> <span>main</span>()
<span> #else</span>
  <span>int</span> <span>main</span>(<span>int</span> <span>argc</span>, <span>char</span>* <span>argv</span>[])
<span> #endif</span>
  {     
    <span>using</span> <span>namespace</span> <span>ferret</span>;
    <span>FERRET_ALLOCATOR</span>::init();
    <span>rt</span>::init();

<span>   #if</span> <span>defined</span>(FERRET_STD_LIB) &amp;&amp; !<span>defined</span>(FERRET_DISABLE_CLI_ARGS)
    <span>for</span> (<span>int</span> <span>i</span> = argc - 1; i &gt; -1 ; i--)
      _star_command_line_args_star_ =  <span>rt</span>::cons(obj&lt;<span>string</span>&gt;(argv[i]),_star_command_line_args_star_);
<span>   #endif</span>

    $file$::main();

<span>   #if</span> <span>defined</span>(FERRET_PROGRAM_MAIN)
    run(FERRET_PROGRAM_MAIN);
<span>   #endif</span>

    <span>return</span> 0;
  }
<span>#endif</span>
</pre>
</div>

<p>
When a supported Arduino board is <a href="#sec-4-5-1">detected</a>. Instead of using a
standard <code>main</code> function, Ferret uses Arduino compatible boot
procedure. 
</p>

<div>

<pre><span>#if</span> <span>defined</span>(FERRET_HARDWARE_ARDUINO)
  <span>void</span> <span>setup</span>(){
    <span>using</span> <span>namespace</span> <span>ferret</span>;
    <span>FERRET_ALLOCATOR</span>::init();
    <span>rt</span>::init();

<span>    #if</span> <span>defined</span>(FERRET_PROGRAM_MAIN)
      $file$::main();
<span>    #endif</span>
  }

  <span>void</span> <span>loop</span>(){
    <span>using</span> <span>namespace</span> <span>ferret</span>;
<span>    #if</span> !<span>defined</span>(FERRET_PROGRAM_MAIN)
      $file$::main();
<span>    #endif</span>          

<span>    #if</span> <span>defined</span>(FERRET_PROGRAM_MAIN)
      run(FERRET_PROGRAM_MAIN);
<span>    #endif</span>
  }
<span>#endif</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-6">
<h3 id="sec-4-6">Configuration</h3>
<div id="text-4-6">
<p>
Ferret defaults to running in safe mode, which means 
</p>

<ul>
<li>Multi threading is disabled.
</li>
<li>Console output is disabled.
</li>
</ul>

<p>
Safe mode only requires a C++11 compiler, no third party library is
required including the C++ standard library. Following options can be
configured using <code>#define</code> directives, or using <code>native-define</code> or
<code>configure-runtime!</code> from program code. Unless these options are
overridden in source file, they are auto configured during compilation
on supported platforms. (i.e Multi threading will be enabled on
Linux or Mac OS X.) On unsupported platforms Ferret defaults to
running in safe mode.
</p>

<pre>(configure-runtime! FERRET_DISABLE_STD_OUT true)
</pre>

<pre>|------------------------------------+--------------+----------------------------------------------------------|
| Define                             | Defult Value | Description                                              |
|------------------------------------+--------------+----------------------------------------------------------|
| FERRET_SAFE_MODE                   | false        | Force Safe Mode.                                         |
| FERRET_DISABLE_CLI_ARGS            | false        | Disable command line arguments.                          |
| FERRET_DISABLE_STD_OUT             | false        | Disables output stream. (Reduces code size.)             |
| FERRET_DISABLE_MULTI_THREADING     | false        | Disable atomic reference counting.                       |
| FERRET_DISABLE_STD_MAIN            | false        | Disables auto execution of program::main()               |
| FERRET_DISABLE_RC                  | Not Defined  | Disable reference counting. (When using third party GCs) |
| FERRET_RC_TYPE                     | unsigned int | Type to use to hold the object reference count.          |
| FERRET_PROGRAM_MAIN                | Not Defined  | A function to execute after program::main()              |
| FERRET_UART_RATE                   | 9600         | Set default UART rate.                                   |
| FERRET_HARDWARE_ARDUINO_UART_PORT  | Serial       | Set default UART port.                                   |
| FERRET_NUMBER_TYPE                 | int          | Default number_t type.                                   |
| FERRET_REAL_TYPE                   | double       | Default real_t type.                                     |
| FERRET_REAL_EPSILON                | 0.0001       | Least significant digit representable.                   |
|------------------------------------+--------------+----------------------------------------------------------|
</pre>
</div>
</div>

<div id="outline-container-sec-4-7">
<h3 id="sec-4-7">Accessing C,C++ Libraries</h3>
<div id="text-4-7">
<p>
Ferret provides the ability to embed C++ language source code within a
Ferret program. A Ferret function can contain a short program written
in C++ language, which is executed whenever this funtion is executed.
Ferret&#39;s FFI is modeled after Gambit scheme. Whereas Gambit scheme
lets you embed C into Scheme, Ferret lets you embed C or C++ into
lisp.
</p>

<p>
Native headers can be imported using,
</p>

<div>

<pre>(native-header <span>&#34;thirt_party_header.h&#34;</span>)
</pre>
</div>

<p>
Top level statements can be declared using,
</p>

<div>

<pre>(native-declare <span>&#34;int i = 0;&#34;</span>)
</pre>
</div>

<p>
Ferret objects can be created using the <code>obj</code> function. If a function
only contains a string such as, 
</p>

<div>

<pre>(<span>defn</span> <span>inc-int</span> [] <span>&#34;__result =  obj&lt;number&gt;(i++);&#34;</span>)
</pre>
</div>

<p>
It is assumed to be a native function string, it is taken as C++
code. You can then use it like any other ferret function.
</p>

<div>

<pre>(<span>deftest</span> inc-int-test
  (<span>is</span> (<span>=</span> 0 (inc-int)))
  (<span>is</span> (<span>=</span> 1 (inc-int))))
</pre>
</div>

<p>
Another option is to use the <code>cxx</code> macro,
</p>

<div>

<pre>(<span>def</span> <span>dac-0</span> (cxx <span>&#34;__result =  obj&lt;number&gt;(DAC0);&#34;</span>))
</pre>
</div>

<p>
Ferret objects can be converted to/from their native counter parts,
i.e a Ferret sequence can be converted to <code>std::vector</code> to be sorted
by <code>std::sort</code> using a Ferret function,
</p>

<div>

<pre>(<span>defn</span> <span>my-sort</span> [f seq]
  <span>&#34;std_vector vec = sequence::to&lt;std_vector&gt;(seq);</span>
<span>   std::sort(vec.begin(), vec.end(), [f](var a, var b) { return run(f,a,b); });</span>
<span>   __result = sequence::from&lt;std_vector&gt;(vec);&#34;</span>)
</pre>
</div>

<div>

<pre>(<span>deftest</span> my-sort-test
  (<span>is</span> (<span>=</span> (<span>list</span> 3 2 1) (my-sort &gt; (<span>list</span> 1 3 2))))
  (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3) (my-sort &lt; (<span>list</span> 1 3 2)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>my-find</span> [item seq]
  <span>&#34;std_vector vec = sequence::to&lt;std_vector&gt;(seq);</span>
<span>   std_vector::iterator it = find (vec.begin(), vec.end(), item);</span>

<span>   if(it != vec.end())</span>
<span>     __result = cached::true_o;&#34;</span>)

(<span>deftest</span> my-find-test
  (<span>is</span> (<span>=</span>  nil   (my-find (<span>list</span> 5 5)
                         (<span>list</span> (<span>list</span> 1 2)
                               (<span>list</span> 2 3)
                               (<span>list</span> 4 5)))))
  (<span>is</span> (<span>=</span>  true  (my-find (<span>list</span> 1 2)
                         (<span>list</span> (<span>list</span> 1 2)
                               (<span>list</span> 2 3)
                               (<span>list</span> 4 5)))))
  (<span>is</span> (<span>=</span>  true  (my-find (<span>list</span> 4 5)
                         (<span>list</span> (<span>list</span> 1 2)
                               (<span>list</span> 2 3)
                               (<span>list</span> 4 5))))))
</pre>
</div>

<p>
In addition to <code>defn</code> form there is also a <code>defnative</code> form which
allows you to define different function bodies for different <code>#define</code>
directives,
</p>

<div>

<pre>(defnative get-char []
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      <span>&#34;return obj&lt;number&gt;(getchar());&#34;</span>))
</pre>
</div>

<p>
This function when compiled on a system that defines <code>GNU_GCC</code> will
return the result of <code>getchar</code> as a <code>number</code> , on ANY other system it
will produce a compiler error. You can have multiple <code>on</code> blocks per
<code>defnative</code>,
</p>

<div>

<pre>(defnative sleep [^number_t t]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      <span>&#34;auto duration = ::std::chrono::milliseconds(t);</span>
<span>       ::std::this_thread::sleep_for(duration);&#34;</span>)
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::delay(t);&#34;</span>))
</pre>
</div>

<p>
This way a single function can be defined for multiple
systems. Reverse is also possible, since all built in data structures
are immutable you can freely call Ferret code from C++,
</p>

<div>

<pre><span>var</span> <span>alist</span> = <span>rt</span>::<span>list</span>(obj&lt;number&gt;(1),obj&lt;number&gt;(2),obj&lt;number&gt;(3));

<span>int</span> <span>sum</span> = 0;
<span>for_each</span>(it, alist){
  sum += <span>number</span>::to&lt;<span>number_t</span>&gt;(it);
}

::<span>std</span>::cout &lt;&lt; sum &lt;&lt; ::<span>std</span>::endl;

<span>//</span><span>or</span>

<span>var</span> <span>res</span> = _plus_().invoke(alist);
res.stream_console();
::<span>std</span>::cout &lt;&lt; ::<span>std</span>::endl;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5">
<h2 id="sec-5">Core</h2>
<p>
The standard library of Ferret, provides a ton of general-purpose
functionality for writing robust, maintainable embedded
applications.
</p>

<div id="outline-container-sec-5-1">
<h3 id="sec-5-1">Logic</h3>
<div id="outline-container-sec-5-1-1">
<h4 id="sec-5-1-1">true?</h4>
<div id="text-5-1-1">
<div>

<pre>(<span>deftest</span> true?-test
  (<span>is</span> (<span>=</span> true  (<span>true?</span> true)))
  (<span>is</span> (<span>=</span> false (<span>true?</span> false))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>true?</span> [x]
  <span>&#34;if (x)</span>
<span>     return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-2">
<h4 id="sec-5-1-2">false?</h4>
<div id="text-5-1-2">
<div>

<pre>(<span>deftest</span> false?-test
  (<span>is</span> (<span>=</span> false (<span>false?</span> true)))
  (<span>is</span> (<span>=</span> true  (<span>false?</span> false))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>false?</span> [x]
  <span>&#34;if (!x)</span>
<span>     return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-3">
<h4 id="sec-5-1-3">nil?</h4>
<div id="text-5-1-3">
<div>

<pre>(<span>deftest</span> nil?-test
  (<span>is</span> (<span>=</span> false (<span>=</span> nil 1)))
  (<span>is</span> (<span>=</span> false (<span>=</span> 1 nil)))
  (<span>is</span> (<span>=</span> true  (<span>=</span> nil nil))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>nil?</span> [x]
  <span>&#34;if (x.is_nil())</span>
<span>       return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-1-4">
<h4 id="sec-5-1-4">not</h4>
<div id="text-5-1-4">
<div>

<pre>(<span>defn</span> <span>not</span> [x]
  <span>&#34;if (x)</span>
<span>     return cached::false_o;</span>
<span>   return cached::true_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-5">
<h4 id="sec-5-1-5">=</h4>
<div id="text-5-1-5">
<div>

<pre>(<span>deftest</span> =-test
  (<span>is</span> (<span>=</span> true   (<span>=</span> true true)))
  (<span>is</span> (<span>=</span> false  (<span>not</span> (<span>=</span> true true))))
  (<span>is</span> (<span>=</span> false  (<span>not</span> 1)))
  (<span>is</span> (<span>=</span> true   (<span>=</span> 2)))
  (<span>is</span> (<span>=</span> false  (<span>=</span> 2 3)))
  (<span>is</span> (<span>=</span> true   (<span>=</span> 2 2 2 2)))
  (<span>is</span> (<span>=</span> true   (<span>=</span> 2 2.0 2)))
  (<span>is</span> (<span>=</span> false  (<span>=</span> 2 2 2 2 3 5))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>=</span> [&amp; args]
  <span>&#34;var curr = rt::first(args);</span>
<span>   for_each(it, rt::rest(args)){</span>
<span>    if (curr != it)</span>
<span>      return cached::false_o;</span>
<span>    curr = it;</span>
<span>   }</span>
<span>   return cached::true_o;&#34;</span>)
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-5-1-7">
<h4 id="sec-5-1-7">identical?</h4>
<div id="text-5-1-7">
<p>
Tests if 2 arguments are the same object.
</p>

<div>

<pre>(<span>defn</span> <span>identical?</span> [x y]
  <span>&#34;if(x.get() == y.get())</span>
<span>    return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-8">
<h4 id="sec-5-1-8">&lt;</h4>
<div id="text-5-1-8">
<div>

<pre>(<span>deftest</span> &lt;-test
  (<span>is</span> (<span>=</span> true  (<span>&lt;</span> 2)))
  (<span>is</span> (<span>=</span> true  (<span>&lt;</span> 2 3 4 5))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>&lt;</span> [&amp; args]
  <span>&#34;var a = rt::first(args);</span>

<span>   for_each(b, rt::rest(args)){</span>
<span>    if (number::to&lt;real_t&gt;(a) &gt;= number::to&lt;real_t&gt;(b))</span>
<span>      return cached::false_o;</span>
<span>    a = b;</span>
<span>   }</span>

<span>   return cached::true_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-9">
<h4 id="sec-5-1-9">&gt;</h4>
<div id="text-5-1-9">
<div>

<pre>(<span>deftest</span> &gt;-test
  (<span>is</span> (<span>=</span> true  (<span>&gt;</span> 2)))
  (<span>is</span> (<span>=</span> false (<span>&gt;</span> 2 3 4 5)))
  (<span>is</span> (<span>=</span> true  (<span>&gt;</span> 6 5 4 3))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>&gt;</span> [&amp; args]
  <span>&#34;var a = rt::first(args);</span>

<span>   for_each(b, rt::rest(args)){</span>
<span>    if (number::to&lt;real_t&gt;(a) &lt;= number::to&lt;real_t&gt;(b))</span>
<span>      return cached::false_o;</span>
<span>    a = b;</span>
<span>   }</span>

<span>   return cached::true_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-10">
<h4 id="sec-5-1-10">&gt;=</h4>
<div id="text-5-1-10">
<div>

<pre>(<span>deftest</span> &gt;=-test
  (<span>is</span> (<span>=</span> true  (<span>&gt;=</span> 2)))
  (<span>is</span> (<span>=</span> true  (<span>&gt;=</span> 5 4 3 2 2 2)))
  (<span>is</span> (<span>=</span> false (<span>&gt;=</span> 5 1 3 2 2 2))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>&gt;=</span> [&amp; args]
  <span>&#34;var a = rt::first(args);</span>

<span>   for_each(b, rt::rest(args)){</span>
<span>    if (number::to&lt;real_t&gt;(a) &lt; number::to&lt;real_t&gt;(b))</span>
<span>      return cached::false_o;</span>
<span>    a = b;</span>
<span>   }</span>

<span>   return cached::true_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-11">
<h4 id="sec-5-1-11">&lt;=</h4>
<div id="text-5-1-11">
<div>

<pre>(<span>deftest</span> &lt;=-test
  (<span>is</span> (<span>=</span> true  (<span>&lt;=</span> 2)))
  (<span>is</span> (<span>=</span> true  (<span>&lt;=</span> 2 2 3 4 5)))
  (<span>is</span> (<span>=</span> false (<span>&lt;=</span> 2 2 1 3 4))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>&lt;=</span> [&amp; args]
  <span>&#34;var a = rt::first(args);</span>

<span>   for_each(b, rt::rest(args)){</span>
<span>    if (number::to&lt;real_t&gt;(a) &gt; number::to&lt;real_t&gt;(b))</span>
<span>      return cached::false_o;</span>
<span>    a = b;</span>
<span>   }</span>

<span>   return cached::true_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-12">
<h4 id="sec-5-1-12">and</h4>
<div id="text-5-1-12">
<div>

<pre>(<span>deftest</span> and-test
  (<span>is</span> (<span>=</span> true  (<span>let</span> [a 1]
                 (<span>and</span> (<span>&gt;</span> a 0) (<span>&lt;</span> a 10)))))

  (<span>is</span> (<span>=</span> false (<span>let</span> [a 11]
                 (<span>and</span> (<span>&gt;</span> a 0) (<span>&lt;</span> a 10)))))

  (<span>is</span> (<span>=</span> true  (<span>and</span> true  (<span>identity</span> true))))
  (<span>is</span> (<span>=</span> false (<span>and</span> true  (<span>identity</span> false)))))
</pre>
</div>


</div>
</div>

<div id="outline-container-sec-5-1-13">
<h4 id="sec-5-1-13">or</h4>
<div id="text-5-1-13">
<div>

<pre>(<span>deftest</span> or-test
  (<span>is</span> (<span>=</span> true  (<span>or</span>  true  (<span>identity</span> false))))
  (<span>is</span> (<span>=</span> false (<span>or</span>  false (<span>identity</span> false)))))
</pre>
</div>


</div>
</div>
</div>

<div id="outline-container-sec-5-2">
<h3 id="sec-5-2">Flow</h3>
<div id="outline-container-sec-5-2-1">
<h4 id="sec-5-2-1">if</h4>
<div id="text-5-2-1">
<div>

<pre>(<span>deftest</span> if-test
  (<span>is</span> (<span>=</span> 2     (<span>if</span> 1
                 2)))
  (<span>is</span> (<span>=</span> 1     (<span>if</span> (<span>zero?</span> 0)
                 1 -1)))
  (<span>is</span> (<span>=</span> -1    (<span>if</span> (<span>zero?</span> 1)
                 1 -1)))

  (<span>is</span> (<span>=</span> 2     (<span>if</span> nil
                 1 2))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-2">
<h4 id="sec-5-2-2">when</h4>
<div id="text-5-2-2">
<div>

<pre>(<span>deftest</span> when-test
  (<span>is</span> (<span>=</span> 1     (<span>when</span> (<span>&lt;</span> 2 3) 1)))
  (<span>is</span> (<span>=</span> 2     (<span>when</span> true    2))))
</pre>
</div>


</div>
</div>

<div id="outline-container-sec-5-2-3">
<h4 id="sec-5-2-3">cond</h4>
<div id="text-5-2-3">
<div>

<pre>(<span>defn</span> <span>pos-neg-or-zero</span> [n]
  (<span>cond</span>
    (<span>&lt;</span> n 0) -1
    (<span>&gt;</span> n 0)  1
    <span>:else</span>    0))

(<span>deftest</span> cond-test
  (<span>is</span> (<span>=</span> -1  (pos-neg-or-zero -5)))
  (<span>is</span> (<span>=</span>  1  (pos-neg-or-zero  5)))
  (<span>is</span> (<span>=</span>  0  (pos-neg-or-zero  0))))
</pre>
</div>

<div>

<pre>(<span>defmacro</span> <span>cond</span> [&amp; clauses]
  (<span>when</span> clauses
    `(<span>if</span> ~(<span>first</span> clauses)
       ~(<span>if</span> (<span>next</span> clauses)
          (<span>second</span> clauses)
          (<span>throw</span> (IllegalArgumentException.
                  <span>&#34;cond requires an even number of forms&#34;</span>)))
       (<span>cond</span> <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="e997a9">[email protected]</a>(<span>next</span> (<span>next</span> clauses))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-4">
<h4 id="sec-5-2-4">while</h4>
<div id="text-5-2-4">
<p>
Repeatedly executes <code>body</code> while <code>test</code> is true. Presumes some
side-effect will cause <code>test</code> to become <code>false/nil</code>. Returns <code>nil</code>.
</p>

<div>

<pre>(<span>defn</span> <span>_while_</span> [pred fn]
  <span>&#34;while(run(pred))</span>
<span>     run(fn);&#34;</span>)

(<span>defmacro</span> <span>while</span> [test &amp; body]
  `(_while_ (<span>fn</span> [] ~test) (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="512f11333e3528">[email protected]</a>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-5">
<h4 id="sec-5-2-5">while-let</h4>
<div id="text-5-2-5">
<p>
Repeatedly executes body while test expression is true, evaluating the
body with binding-form bound to the value of test. 
</p>

<div>

<pre>(<span>deftest</span> while-let-test
  (<span>let</span> [lst (<span>atom</span> (<span>list</span> 1 2 3 4 5))
        acc (<span>atom</span> )]

    (while-let [item (<span>first</span> @lst)]
      (<span>swap!</span> lst rest)
      (<span>swap!</span> acc conj item))

    (<span>is</span> (<span>=</span> (<span>list</span> ) @lst))
    (<span>is</span> (<span>=</span> (<span>list</span> 5 4 3 2 1) @acc))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>_while-let_</span> [pred fn]
  <span>&#34;var v;</span>
<span>   while((v = run(pred)))</span>
<span>     run(fn,v);&#34;</span>)

(<span>defmacro</span> <span>while-let</span>
  [[form test] &amp; body]
  `(_while-let_ (<span>fn</span> [] ~test) (<span>fn</span> [~form] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="2856684a474c51">[email protected]</a>)))
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-5-2-7">
<h4 id="sec-5-2-7">if-let</h4>
<div id="text-5-2-7">
<div>

<pre>(<span>deftest</span> if-let-test
  (<span>is</span> (<span>=</span> nil   (<span>if-let</span> [a nil] a)))
  (<span>is</span> (<span>=</span> 5     (<span>if-let</span> [a 5]   a)))
  (<span>is</span> (<span>=</span> 2     (<span>if-let</span> [[_ a]  (<span>list</span> 1 2)] a))))
</pre>
</div>

<div>

<pre>(<span>defmacro</span> <span>if-let</span>
  ([bindings then]
   `(<span>if-let</span> ~bindings ~then nil))
  ([bindings then else &amp; oldform]
   (<span>let</span> [form (bindings 0) tst (bindings 1)]
     `(let* [temp# ~tst]
        (<span>if</span> temp#
          (let* [~form temp#]
            ~then)
          ~else)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-8">
<h4 id="sec-5-2-8">when-let</h4>
<div id="text-5-2-8">
<p>
When test is true, evaluates body with binding-form bound to the value of test.
</p>

<div>

<pre>(<span>deftest</span> when-let-test
  (<span>is</span> (<span>=</span> nil   (<span>when-let</span> [a nil] a)))
  (<span>is</span> (<span>=</span> 5     (<span>when-let</span> [a 5]   a)))
  (<span>is</span> (<span>=</span> 2     (<span>when-let</span> [[_ a]  (<span>list</span> 1 2)] a))))
</pre>
</div>

<div>

<pre>(<span>defmacro</span> <span>when-let</span>
  [bindings &amp; body]
  (<span>let</span> [form (bindings 0) tst (bindings 1)]
    `(let* [temp# ~tst]
       (<span>when</span> temp#
         (let* [~form temp#]
           <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="e698a68489829f">[email protected]</a>)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-3">
<h3 id="sec-5-3">Iteration</h3>
<div id="outline-container-sec-5-3-1">
<h4 id="sec-5-3-1">doseq</h4>
<div id="text-5-3-1">
<div>

<pre>(<span>defmacro</span> <span>doseq</span> [binding &amp; body]
  `(_doseq_ ~(<span>second</span> binding)
            (<span>fn</span> [~(<span>first</span> binding)] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="8af4cae8e5eef3">[email protected]</a>)))

(<span>defn</span> <span>_doseq_</span> [seq f] <span>&#34;for_each(it, seq) run(f,it);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-3-2">
<h4 id="sec-5-3-2">dotimes</h4>
<div id="text-5-3-2">
<div>

<pre>(<span>defmacro</span> <span>dotimes</span> [binding &amp; body]
  `(_dotimes_ ~(<span>second</span> binding)
              (<span>fn</span> [~(<span>first</span> binding)] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="d5ab95b7bab1ac">[email protected]</a>)))

(<span>defn</span> <span>_dotimes_</span> [^number_t t f] <span>&#34;for(number_t i = 0; i &lt; t; i++) run(f,obj&lt;number&gt;(i));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-3-3">
<h4 id="sec-5-3-3">for</h4>
<div id="text-5-3-3">
<p>
List comprehension. Takes a list of one or more binding-form/collection-expr
pairs and yields a lazy sequence of evaluations of body-exprs. Collections are
iterated over in a nested fashion with the rightmost binding being evaluated
over first.
</p>

<div>

<pre>(<span>deftest</span> for-test
  (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3) (<span>for</span> [x (<span>list</span> 1 2 3)] x)))
  (<span>is</span> (<span>=</span> (<span>list</span> 1 4 6) (<span>for</span> [x (<span>list</span> 1 2 3)] (<span>*</span> x 2))))
  (<span>is</span> (<span>=</span> (<span>list</span> 4 5 6 8 10 12 12 15 18)
         (<span>for</span> [x (<span>list</span> 1 2 3)
               y (<span>list</span> 4 5 6)]
           (<span>*</span> x y)))))
</pre>
</div>

<div>

<pre>(<span>defmacro</span> <span>for</span> [bindings &amp; body]
  (<span>if</span> (<span>seq</span> bindings)
    `(<span>flatten</span> (<span>map</span> (<span>fn</span> [~(<span>first</span> bindings)] (~&#39;for ~(<span>drop</span> 2 bindings) <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="f18fb1939e9588">[email protected]</a>))
          ~(<span>second</span> bindings)))
    `(<span>do</span> <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="d9a799bbb6bda0">[email protected]</a>)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-4">
<h3 id="sec-5-4">Sequential</h3>
<div id="outline-container-sec-5-4-1">
<h4 id="sec-5-4-1">list</h4>
<div id="text-5-4-1">
<p>
Creates a new list. See also <i>Spacial Forms</i>.
</p>

<div>

<pre>(<span>deftest</span> list-test
  (<span>is</span> (<span>=</span> true  (<span>=</span> (<span>list</span> )       (<span>list</span> ))))
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>list</span> )       (<span>list</span> 1 2 3))))
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>list</span> )       (<span>list</span> nil))))
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>list</span> 1 2 3)  (<span>list</span> 1 2))))
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>list</span> 1 2)    (<span>list</span> 1 2 3))))
  (<span>is</span> (<span>=</span> true  (<span>=</span> (<span>list</span> 1 2 3)  (<span>list</span> 1 2 3))))
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>list</span> 1 2 3)  (<span>list</span> 1 2 4))))
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>list</span> 1 1 3)  (<span>list</span> 1 2 3)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>list</span> [&amp; xs] <span>&#34;return xs;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-2">
<h4 id="sec-5-4-2">list?</h4>
<div id="text-5-4-2">
<p>
Returns true if <code>x</code> implements <a href="#sec-4-1-2-4">Sequence</a>.
</p>

<div>

<pre>(<span>defn</span> <span>list?</span> [x]
  <span>&#34;if (x.is_type(type_id&lt;sequence&gt;))</span>
<span>     return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-3">
<h4 id="sec-5-4-3">seqable?</h4>
<div id="text-5-4-3">
<p>
Return true if the <code>x</code> implements <code>seekable_i</code>.
</p>

<div>

<pre>(<span>deftest</span> seqable?-test
  (<span>is</span> (seqable? (<span>list</span> 1 2 3))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>seqable?</span> [coll]
  <span>&#34;if (rt::is_seqable(coll))</span>
<span>     return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-4">
<h4 id="sec-5-4-4">cons</h4>
<div id="text-5-4-4">
<p>
Returns a new seq where x is the first element and seq is the rest.
</p>

<div>

<pre>(<span>deftest</span> cons-test
  (<span>is</span> (<span>=</span> (<span>list</span> 1)           (<span>cons</span> 1 nil)))
  (<span>is</span> (<span>=</span> (<span>list</span> nil)         (<span>cons</span> nil nil)))

  (<span>is</span> (<span>=</span> (<span>list</span> 3 3 4)       (<span>cons</span> 3 (<span>rest</span> (<span>rest</span> (<span>list</span> 1 2 3 4))))))
  (<span>is</span> (<span>=</span> 3                  (<span>first</span> (<span>cons</span> 3 (<span>rest</span> (<span>rest</span> (<span>list</span> 1 2 3 4))))))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>cons</span> [x seq] <span>&#34;return rt::cons(x, seq);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-5">
<h4 id="sec-5-4-5">first</h4>
<div id="text-5-4-5">
<p>
Returns the first item in the collection.
</p>

<div>

<pre>(<span>deftest</span> first-test
  (<span>is</span> (<span>=</span> 1   (<span>first</span> (<span>list</span> 1 2 3 4))))
  (<span>is</span> (<span>nil?</span>  (<span>first</span> (<span>rest</span> (<span>rest</span> (<span>list</span>)))))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>first</span> [x]
  <span>&#34;return rt::first(x);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-6">
<h4 id="sec-5-4-6">second</h4>
<div id="text-5-4-6">
<p>
Returns the first item in the collection.
</p>

<div>

<pre>(<span>deftest</span> second-test
  (<span>is</span> (<span>=</span> 2 (<span>second</span> (<span>list</span> 1 2 3 4)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>second</span> [x]
  <span>&#34;return rt::first(rt::rest(x));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-7">
<h4 id="sec-5-4-7">rest</h4>
<div id="text-5-4-7">
<p>
Returns a possibly empty seq of the items after the first.
</p>

<div>

<pre>(<span>deftest</span> rest-test
  (<span>is</span> (<span>=</span> (<span>list</span> 2 3 4)  (<span>rest</span> (<span>list</span> 1 2 3 4))))
  (<span>is</span> (<span>=</span> (<span>list</span> 3 4)    (<span>rest</span> (<span>rest</span> (<span>list</span> 1 2 3 4))))))
</pre>
</div>


<div>

<pre>(<span>defn</span> <span>rest</span> [x] <span>&#34;return rt::rest(x);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-8">
<h4 id="sec-5-4-8">nth</h4>
<div id="text-5-4-8">
<p>
Returns the value at the index.
</p>

<div>

<pre>(<span>deftest</span> nth-test
  (<span>is</span> (<span>=</span> 1   (<span>nth</span> (<span>list</span> 1 2 3)  0)))
  (<span>is</span> (<span>=</span> 2   (<span>nth</span> (<span>list</span> 1 2 3)  1)))
  (<span>is</span> (<span>=</span> 3   (<span>nth</span> (<span>list</span> 1 2 3)  2)))
  (<span>is</span> (<span>=</span> nil (<span>nth</span> (<span>list</span> 1 2 3)  10)))
  (<span>is</span> (<span>=</span> nil (<span>nth</span> (<span>list</span> 1 2 3) -10))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>nth</span> [coll ^number_t index]
  <span>&#34;return rt::nth(coll,index);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-9">
<h4 id="sec-5-4-9">nthrest</h4>
<div id="text-5-4-9">
<p>
Returns the nth rest of coll, coll when n is 0.
</p>

<div>

<pre>(<span>deftest</span> nthrest-test
  (<span>is</span> (<span>=</span> (<span>list</span> 0 1 2 3 4 5 6 7 8 9)  (<span>nthrest</span> (<span>range</span> 10) 0)))
  (<span>is</span> (<span>=</span> (<span>list</span> )                     (<span>nthrest</span> (<span>range</span> 10) 20)))
  (<span>is</span> (<span>=</span> (<span>list</span> 5 6 7 8 9)            (<span>nthrest</span> (<span>range</span> 10) 5))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>nthrest</span> [coll ^number_t n]
  <span>&#34;return rt::nthrest(coll,n);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-10">
<h4 id="sec-5-4-10">count</h4>
<div id="text-5-4-10">
<p>
Returns the number of items in the collection. (count nil) returns
</p>
<ol>
<li></li>
</ol>

<div>

<pre>(<span>deftest</span> count-test
  (<span>is</span> (<span>=</span> 0  (<span>count</span> (<span>list</span> ))))
  (<span>is</span> (<span>=</span> 4  (<span>count</span> (<span>list</span> 1 2 3 4)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>count</span> [s] <span>&#34;return obj&lt;number&gt;(rt::count(s))&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-11">
<h4 id="sec-5-4-11">lazy-seq</h4>
<div id="text-5-4-11">
<div>

<pre>(<span>defn</span> <span>lazy-countdown</span> [n]
  (<span>if</span> (<span>&gt;=</span> n 0)
    (<span>cons</span> n (<span>lazy-seq</span> (lazy-countdown (<span>-</span> n 1))))))

(<span>defn</span> <span>ints-from</span> [n]
  (<span>cons</span> n (<span>lazy-seq</span> (ints-from (<span>inc</span> n)))))

(<span>defn</span> <span>fib-seq</span>
  ([]
   (fib-seq 0 1))
  ([a b]
   (<span>lazy-seq</span>
    (<span>cons</span> b (fib-seq b (<span>+</span> a b))))))

(<span>deftest</span> lazy-seq-test
  (<span>is</span> (<span>=</span> 0 (<span>count</span> (<span>lazy-seq</span> ))))
  (<span>is</span> (<span>=</span> (<span>list</span> 1 2)  (<span>cons</span> 1 (<span>cons</span> 2 (<span>lazy-seq</span> )))))

  (<span>is</span> (<span>=</span> 10    (<span>first</span> (ints-from 10))))
  (<span>is</span> (<span>=</span> 11    (<span>first</span> (<span>rest</span> (ints-from 10)))))
  (<span>is</span> (<span>=</span> 12    (<span>first</span> (<span>rest</span> (<span>rest</span> (ints-from 10))))))

  (<span>is</span> (<span>=</span> 10    (<span>first</span> (lazy-countdown 10))))
  (<span>is</span> (<span>=</span> 9     (<span>first</span> (<span>rest</span> (lazy-countdown 10)))))
  (<span>is</span> (<span>=</span> 8     (<span>first</span> (<span>rest</span> (<span>rest</span> (lazy-countdown 10))))))
  (<span>is</span> (<span>=</span> 11    (<span>count</span> (lazy-countdown 10)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>new-lazy-seq</span>
  ([thunk]
   <span>&#34;return obj&lt;lazy_sequence&gt;(thunk);&#34;</span>)
  ([data thunk]
   <span>&#34;return obj&lt;lazy_sequence&gt;(data, thunk);&#34;</span>))

(<span>defmacro</span> <span>lazy-seq</span> [&amp; body]
  `(new-lazy-seq (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="2856684a474c51">[email protected]</a>)))

(<span>defn</span> <span>lazy-seq-cache</span> [seq]
  <span>&#34;return lazy_sequence::from(seq);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-12">
<h4 id="sec-5-4-12">map</h4>
<div id="text-5-4-12">
<p>
Returns a lazy sequence consisting of the result of applying f to
the set of first items of each coll, followed by applying f to the
set of second items in each coll, until any one of the colls is
exhausted.
</p>

<div>

<pre>(<span>deftest</span> map-test
  (<span>is</span> (<span>=</span> 2   (<span>first</span> (<span>map</span> inc (<span>list</span> 1 2 3)))))
  (<span>is</span> (<span>=</span> 0   (<span>first</span> (<span>map</span> dec (<span>list</span> 1 2 3)))))
  (<span>is</span> (<span>=</span> 4   (<span>first</span> (<span>map</span> (<span>fn</span> [x] (<span>+</span> 3 x)) (<span>list</span> 1 2 3)))))
  (<span>is</span> (<span>=</span> 3   (<span>count</span> (<span>map</span> inc (<span>list</span> 1 2 3)))))
  (<span>is</span> (<span>=</span> (<span>list</span> 2 4 6) (<span>map</span> + (<span>list</span> 1 2 3) (<span>list</span> 1 2 3)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>map</span>
  ([f coll]
   (<span>lazy-seq</span>
    (<span>if</span> (seqable? coll)
      (<span>cons</span> (f (<span>first</span> coll))
          (<span>map</span> f (<span>rest</span> coll))))))
  ([f &amp; cols]
   (<span>lazy-seq</span>
    (<span>if</span> (<span>every?</span> seqable? cols)
      (<span>cons</span> (<span>apply</span> f (<span>map</span> first cols))
            (<span>apply</span> map f (<span>map</span> rest cols)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-13">
<h4 id="sec-5-4-13">reduce</h4>
<div id="text-5-4-13">
<div>

<pre>(<span>deftest</span> reduce-test
  (<span>is</span> (<span>=</span> 21               (<span>reduce</span> + (<span>list</span> 1 2 3 4 5 6))))
  (<span>is</span> (<span>=</span> (<span>list</span> 6 5 4 3 2) (<span>reduce</span> (<span>fn</span> [h v] (<span>conj</span> h (<span>inc</span> v))) (<span>list</span>) (<span>list</span> 1 2 3 4 5))))
  (<span>is</span> (<span>=</span> (<span>list</span> 4 3 2 1 0) (<span>reduce</span> (<span>fn</span> [h v] (<span>conj</span> h (<span>dec</span> v))) (<span>list</span>) (<span>list</span> 1 2 3 4 5)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>reduce</span>
  ([f xs]
   (<span>reduce</span> f (<span>first</span> xs) (<span>rest</span> xs)))
  ([f acc coll]
   <span>&#34;__result = acc;</span>
<span>    for_each(i, coll)</span>
<span>     __result = run(f, __result, i);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-14">
<h4 id="sec-5-4-14">range</h4>
<div id="text-5-4-14">
<div>

<pre>(<span>deftest</span> range-test
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>range</span> 10) (<span>range</span> 15))))
  (<span>is</span> (<span>=</span> false (<span>=</span> (<span>range</span> 15) (<span>range</span> 10))))
  (<span>is</span> (<span>=</span> true  (<span>=</span> (<span>range</span> 10) (<span>range</span> 10))))

  (<span>is</span> (<span>=</span> 10  (<span>apply</span> + (<span>range</span> 5))))
  (<span>is</span> (<span>=</span> 5   (<span>count</span>   (<span>range</span> 5)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>range</span>
  ([high]
   (<span>range</span> 0 high))
  ([^number_t low ^number_t high]
   <span>&#34;return rt::range(low, high)&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-15">
<h4 id="sec-5-4-15">take</h4>
<div id="text-5-4-15">
<div>

<pre>(<span>deftest</span> take-test
  (<span>is</span> (<span>=</span> 2   (<span>-&gt;&gt;</span> (<span>map</span> inc (<span>list</span> 1 2 3))
                  (<span>take</span> 2)
                  (<span>first</span>))))

  (<span>is</span> (<span>=</span> 3   (<span>-&gt;&gt;</span> (<span>map</span> inc (<span>list</span> 1 2 3))
                  (<span>take</span> 20)
                  (<span>count</span>))))

  (<span>is</span> (<span>=</span> 3   (<span>-&gt;&gt;</span> (<span>map</span> inc (<span>list</span> 1 2 3))
                  (<span>take</span> 2)
                  (<span>rest</span>)
                  (<span>first</span>))))

  (<span>is</span> (<span>=</span> 3   (<span>-&gt;&gt;</span> (<span>map</span> inc (<span>list</span> 1 2 3))
                  (<span>take</span> 20)
                  (<span>count</span>))))


  (<span>=</span> (<span>list</span> 1 1 2 3 5) (<span>take</span> 5 (fib-seq)))
  (<span>=</span> 12               (<span>apply</span> + (<span>take</span> 5 (fib-seq)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>take</span> [n coll]
  (<span>lazy-seq</span>
   (<span>if</span> (seqable? coll)
     (<span>if</span> (<span>&gt;</span> n 0)
       (<span>cons</span> (<span>first</span> coll)
             (<span>take</span> (<span>-</span> n 1) (<span>rest</span> coll)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-16">
<h4 id="sec-5-4-16">take-while</h4>
<div id="text-5-4-16">
<div>

<pre>(<span>deftest</span> take-while-test
  (<span>is</span> (<span>=</span> (<span>list</span> -2 -1)          (<span>take-while</span> neg? (<span>list</span> -2 -1 0 1 2 3))))
  (<span>is</span> (<span>=</span> (<span>list</span> -2 -1 0 1 2)    (<span>take-while</span> #(<span>&lt;</span> % 3) (<span>list</span> -2 -1 0 1 2 3))))
  (<span>is</span> (<span>=</span> (<span>list</span> -2 -1 0 1 2 3)  (<span>take-while</span> #(<span>&lt;=</span> % 3) (<span>list</span> -2 -1 0 1 2 3))))
  (<span>is</span> (<span>=</span> (<span>list</span> -2 -1 0 1 2 3)  (<span>take-while</span> #(<span>&lt;=</span> % 4) (<span>list</span> -2 -1 0 1 2 3)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>take-while</span> [pred s]
  (<span>lazy-seq</span>
   (<span>if</span> (<span>and</span> (seqable? s)
            (pred (<span>first</span> s)))
     (<span>cons</span> (<span>first</span> s) (<span>take-while</span> pred (<span>rest</span> s))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-17">
<h4 id="sec-5-4-17">drop</h4>
<div id="text-5-4-17">
<p>
Returns a lazy sequence of all but the first n items in coll.
</p>

<div>

<pre>(<span>deftest</span> drop-test
  (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3 4) (<span>drop</span> 0 (<span>list</span> 1 2 3 4))))
  (<span>is</span> (<span>=</span> (<span>list</span> 2 3 4)   (<span>drop</span> 1 (<span>list</span> 1 2 3 4))))
  (<span>is</span> (<span>=</span> (<span>list</span> 3 4)     (<span>drop</span> 2 (<span>list</span> 1 2 3 4))))
  (<span>is</span> (<span>=</span> (<span>list</span> )        (<span>drop</span> 4 (<span>list</span> 1 2 3 4))))
  (<span>is</span> (<span>=</span> (<span>list</span> )        (<span>drop</span> 5 (<span>list</span> 1 2 3 4)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>drop</span> [^number_t n coll]
  <span>&#34;return rt::nthrest(coll, n);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-18">
<h4 id="sec-5-4-18">drop-while</h4>
<div id="text-5-4-18">
<p>
Returns a lazy sequence of the items in coll starting from the
first item for which (pred item) returns logical false.
</p>

<div>

<pre>(<span>deftest</span> drop-while-test
  (<span>let</span> [my-list (<span>list</span> 1 2 3 4 5 6)]
    (<span>is</span> (<span>=</span> (<span>list</span> 3 4 5 6) (<span>drop-while</span> #(<span>&gt;</span> 3 %)  my-list)))
    (<span>is</span> (<span>=</span> (<span>list</span> 4 5 6)   (<span>drop-while</span> #(<span>&gt;=</span> 3 %) my-list)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>drop-while-aux</span> [p c]
  <span>&#34;__result = c;</span>
<span>   while(run(p,__result))</span>
<span>     __result = rt::rest(__result);&#34;</span>)

(<span>defn</span> <span>drop-while</span> [pred coll]
  (<span>lazy-seq</span>
   (drop-while-aux #(<span>and</span> (seqable? %) (pred (<span>first</span> %))) coll)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-19">
<h4 id="sec-5-4-19">concat</h4>
<div id="text-5-4-19">
<div>

<pre>(<span>deftest</span> concat-test
  (<span>let</span> [a-list (<span>concat</span> (<span>list</span> 1 2 3) (<span>list</span> 4 5 6))
        b-list (<span>concat</span> (<span>list</span> 1 2 3) (<span>list</span> 4 5 6) (<span>list</span> 7 8 9))]

    (<span>is</span> (<span>=</span> 0      (<span>count</span> (<span>concat</span> ))))
    (<span>is</span> (<span>=</span> 1      (<span>first</span> a-list)))
    (<span>is</span> (<span>=</span> 4      (<span>first</span> (<span>drop</span> 3 a-list))))
    (<span>is</span> (<span>=</span> 21     (<span>reduce</span> + a-list)))
    (<span>is</span> (<span>=</span> b-list (<span>list</span> 1 2 3 4 5 6 7 8 9)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>concat</span>
  ([]
   (<span>list</span>))
  ([x]
   (<span>if</span> (seqable? x)
     (<span>cons</span> (<span>first</span> x) (<span>lazy-seq</span> (<span>concat</span> (<span>rest</span> x))))))
  ([x y]
   (<span>if</span> (seqable? x)
     (<span>cons</span> (<span>first</span> x) (<span>lazy-seq</span> (<span>concat</span> (<span>rest</span> x) y)))
     (<span>concat</span> y)))
  ([x y &amp; more]
   (<span>concat</span> (<span>concat</span> x y) (<span>apply</span> concat more))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-20">
<h4 id="sec-5-4-20">apply</h4>
<div id="text-5-4-20">
<p>
Applies fn <code>f</code> to the argument list formed by prepending intervening
arguments to <code>argv</code>.
</p>

<div>

<pre>(<span>deftest</span> apply-test
  (<span>is</span> (<span>=</span> 21 (<span>apply</span> +       (<span>list</span> 1 2 3 4 5 6))))
  (<span>is</span> (<span>=</span> 9  (<span>apply</span> + 1 2   (<span>list</span> 1 2 3))))
  (<span>is</span> (<span>=</span> 12 (<span>apply</span> + 1 2 3 (<span>list</span> 1 2 3)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>apply</span> [f &amp; argv]
  <span>&#34;return rt::apply(f,argv);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-21">
<h4 id="sec-5-4-21">conj</h4>
<div id="text-5-4-21">
<div>

<pre>(<span>deftest</span> conj-test
  (<span>is</span> (<span>=</span> (<span>list</span> 4 3 2 1 1 2) (<span>conj</span> (<span>list</span> 1 2) 1 2 3 4)))
  (<span>is</span> (<span>=</span> (<span>list</span> 4 3 2 1)     (<span>conj</span> nil 1 2 3 4))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>conj</span> [coll &amp; xs]
  (<span>reduce</span> (<span>fn</span>[h v] (<span>cons</span> v h)) (<span>if</span> (<span>nil?</span> coll) (<span>list</span>) coll) xs))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-22">
<h4 id="sec-5-4-22">reverse</h4>
<div id="text-5-4-22">
<div>

<pre>(<span>deftest</span> reverse-test
  (<span>is</span> (<span>=</span> (<span>list</span> 6 5 4 3 2 1) (<span>reverse</span> (<span>list</span> 1 2 3 4 5 6)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>reverse</span> [s]
  (<span>reduce</span> (<span>fn</span>[h v] (<span>cons</span> v h)) (<span>list</span>) s))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-23">
<h4 id="sec-5-4-23">filter</h4>
<div id="text-5-4-23">
<p>
Returns a lazy sequence of the items in <code>coll</code> for which <code>(pred item)</code>
returns logical <code>true</code>.
</p>

<div>

<pre>(<span>deftest</span> filter-test
  (<span>is</span> (<span>=</span> 1  (<span>-&gt;&gt;</span> (<span>list</span> false false true)
                 (<span>filter</span> true?)
                 (<span>count</span> ))))

  (<span>is</span> (<span>=</span> 2  (<span>-&gt;&gt;</span> (<span>list</span> true false true false false)
                 (<span>filter</span> true?)
                 (<span>count</span> ))))

  (<span>is</span> (<span>=</span> 2  (<span>-&gt;&gt;</span> (<span>list</span> true false true false)
                 (<span>filter</span> true?)
                 (<span>count</span> ))))

  (<span>is</span> (<span>=</span> 2  (<span>-&gt;&gt;</span> (<span>list</span> true false true false)
                 (<span>filter</span> false?)
                 (<span>count</span> ))))

  (<span>is</span> (<span>=</span> 3  (<span>-&gt;&gt;</span> (<span>list</span> true false true false false)
                 (<span>filter</span> false?)
                 (<span>count</span> ))))

  (<span>is</span> (<span>=</span> 2  (<span>-&gt;&gt;</span> (<span>list</span> true false true false false)
                 (<span>filter</span> (<span>fn</span> [x] (<span>not</span> (<span>false?</span> x))))
                 (<span>count</span> ))))

  (<span>is</span> (<span>=</span> 0  (<span>-&gt;&gt;</span> (<span>list</span> false false)
                 (<span>filter</span> true?)
                 (<span>count</span>)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>filter</span> [pred coll]
  (<span>lazy-seq</span>
   (<span>if</span> (seqable? coll)
     (<span>let</span> [[f &amp; r] coll]
       (<span>if</span> (pred f)
         (<span>cons</span> f (<span>filter</span> pred r))
         (<span>filter</span> pred r))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-24">
<h4 id="sec-5-4-24">repeatedly</h4>
<div id="text-5-4-24">
<div>

<pre>(<span>deftest</span> repeatedly-test
  (<span>is</span> (<span>=</span> 1 (<span>first</span> (<span>repeatedly</span> 3 (<span>fn</span> [] 1)))))
  (<span>is</span> (<span>=</span> 3 (<span>count</span> (<span>repeatedly</span> 3 (<span>fn</span> [] 1)))))

  (<span>is</span> (<span>=</span> 3 (<span>count</span> (lazy-seq-cache (<span>repeatedly</span> 3 (<span>fn</span> [] 1))))))

  (<span>is</span> (<span>=</span> 2 (<span>-&gt;&gt;</span> (<span>repeatedly</span> 3 (<span>fn</span> [] 1))
                (<span>map</span> inc)
                first)))

  (<span>is</span> (<span>=</span> 2 (<span>-&gt;&gt;</span> (<span>repeatedly</span> (<span>fn</span> [] 1))
                (<span>take</span> 3)
                (<span>map</span> inc)
                reverse
                first)))

  (<span>let</span> [xs (lazy-seq-cache (<span>repeatedly</span> #(<span>rand</span>)))]
    (<span>is</span> (<span>=</span> (<span>take</span> 5 xs) (<span>take</span> 5 xs)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>repeatedly</span>
  ([f]   (<span>lazy-seq</span> (<span>cons</span> (f) (<span>repeatedly</span> f))))
  ([n f] (<span>take</span> n (<span>repeatedly</span> f))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-25">
<h4 id="sec-5-4-25">partition</h4>
<div id="text-5-4-25">
<div>

<pre>(<span>deftest</span> partition-test
  (<span>is</span> (<span>=</span> (<span>list</span> (<span>list</span> 0 1 2 3)
               (<span>list</span> 4 5 6 7))
         (<span>partition</span> 4 (<span>range</span> 10))))

  (<span>is</span> (<span>=</span> (<span>list</span> (<span>list</span> 0 1 2 3)
               (<span>list</span> 4 5 6 7))
         (<span>partition</span> 4 (<span>range</span> 8))))

  (<span>is</span> (<span>=</span> (<span>list</span> (<span>list</span> 0 1 2 3)
               (<span>list</span> 6 7 8 9)
               (<span>list</span> 12 13 14 15))
         (<span>partition</span> 4 6 (<span>range</span> 20))))

  (<span>is</span> (<span>=</span> (<span>list</span> (<span>list</span> 0 1 2)
               (<span>list</span> 6 7 8)
               (<span>list</span> 12 13 14)
               (<span>list</span> 18 19 42))
         (<span>partition</span> 3 6 (<span>list</span> 42) (<span>range</span> 20))))

  (<span>is</span> (<span>=</span> (<span>list</span> (<span>list</span> 0 1 2 3)
               (<span>list</span> 6 7 8 9)
               (<span>list</span> 12 13 14 15)
               (<span>list</span> 18 19 42 43))
         (<span>partition</span> 4 6 (<span>list</span> 42 43 44 45) (<span>range</span> 20)))))
</pre>
</div>


<div>

<pre>(<span>defn</span> <span>partition</span>
  ([n coll]
   (<span>partition</span> n n coll))
  ([n step coll]
   (<span>lazy-seq</span>
    (<span>if</span> (seqable? coll)
      (<span>let</span> [p (<span>take</span> n coll)]
        (<span>when</span> (<span>=</span> n (<span>count</span> p))
          (<span>cons</span> p (<span>partition</span> n step (<span>nthrest</span> coll step))))))))
  ([n step pad coll]
   (<span>lazy-seq</span>
    (<span>if</span> (seqable? coll)
      (<span>let</span> [p (<span>take</span> n coll)]
        (<span>if</span> (<span>=</span> n (<span>count</span> p))
          (<span>cons</span> p (<span>partition</span> n step pad (<span>nthrest</span> coll step)))
          (<span>list</span> (<span>take</span> n (<span>concat</span> p pad)))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-26">
<h4 id="sec-5-4-26">every?</h4>
<div id="text-5-4-26">
<p>
Returns true if (pred x) is logical true for every x in coll, else
false.
</p>

<div>

<pre>(<span>deftest</span> every?-test
  (<span>is</span> (<span>=</span> false (<span>every?</span> false? (<span>list</span> true false))))
  (<span>is</span> (<span>=</span> true  (<span>every?</span> false? (<span>list</span> false false)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>every?</span> [pred coll]
  <span>&#34;for_each(i, coll){</span>
<span>     if (!run(pred, i))</span>
<span>      return cached::false_o;</span>
<span>   }</span>
<span>   return cached::true_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-27">
<h4 id="sec-5-4-27">interleave</h4>
<div id="text-5-4-27">
<p>
Returns a lazy seq of the first item in each coll, then the second etc.
</p>

<div>

<pre>(<span>deftest</span> interleave-test
  (<span>is</span> (<span>=</span> (<span>list</span> 1 3 2 4) (<span>interleave</span> (<span>list</span> 1 2) (<span>list</span> 3 4))))
  (<span>is</span> (<span>=</span> (<span>list</span> 1 3)     (<span>interleave</span> (<span>list</span> 1 2) (<span>list</span> 3)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>interleave</span>
  ([s1 s2]
   (<span>lazy-seq</span>
    (<span>when</span> (<span>and</span> (seqable? s1)
               (seqable? s2))
      (<span>cons</span> (<span>first</span> s1) (<span>cons</span> (<span>first</span> s2)
                             (<span>interleave</span> (<span>rest</span> s1) (<span>rest</span> s2))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-28">
<h4 id="sec-5-4-28">flatten</h4>
<div id="text-5-4-28">
<p>
Takes any nested combination of sequential things and returns their
contents as a single, flat sequence.  <code>(flatten nil)</code> returns an empty
sequence.
</p>

<div>

<pre>(<span>deftest</span> flatten-test
  (<span>is</span> (<span>=</span> (<span>list</span> 1 2 3 4 5) (<span>flatten</span> (<span>list</span> 1 2 (<span>list</span> 3) 4 5)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>flatten</span> [s]
  (<span>lazy-seq</span>
   (<span>if</span> (seqable? s)
     (<span>if</span> (seqable? (<span>first</span> s))
       (<span>concat</span> (<span>flatten</span> (<span>first</span> s)) (<span>flatten</span> (<span>rest</span> s)))
       (<span>cons</span> (<span>first</span> s) (<span>flatten</span> (<span>rest</span> s)))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-5">
<h3 id="sec-5-5">Math</h3>
<div id="text-5-5">
<div>

<pre>(<span>deftest</span> number-test
  (<span>is</span> (<span>=</span> 0.5       1/2))
  (<span>is</span> (<span>=</span> 0.33333   1/3))
  (<span>is</span> (<span>=</span> 3501      0xDAD))
  (<span>is</span> (<span>=</span> 2748      0xABC)))
</pre>
</div>
</div>

<div id="outline-container-sec-5-5-1">
<h4 id="sec-5-5-1">zero?</h4>
<div id="text-5-5-1">
<div>

<pre>(<span>deftest</span> zero?-test
  (<span>is</span> (<span>=</span> true  (<span>zero?</span> 0)))
  (<span>is</span> (<span>=</span> false (<span>zero?</span> 10)))
  (<span>is</span> (<span>=</span> true  (<span>zero?</span> (<span>-</span> 1 1))))
  (<span>is</span> (<span>=</span> true  (<span>zero?</span> (<span>-</span> 1.2 1.2))))
  (<span>is</span> (<span>=</span> true  (<span>zero?</span> (<span>+</span> 1.2 -1.2)))))
</pre>
</div>


</div>
</div>

<div id="outline-container-sec-5-5-2">
<h4 id="sec-5-5-2">pos?</h4>
<div id="text-5-5-2">
<div>

<pre>(<span>deftest</span> pos?-test
  (<span>is</span> (<span>=</span> true  (<span>pos?</span> 1)))
  (<span>is</span> (<span>=</span> true  (<span>pos?</span> 0.2)))
  (<span>is</span> (<span>=</span> false (<span>pos?</span> 0))))
</pre>
</div>


</div>
</div>

<div id="outline-container-sec-5-5-3">
<h4 id="sec-5-5-3">neg?</h4>
<div id="text-5-5-3">
<div>

<pre>(<span>deftest</span> neg?-test
  (<span>is</span> (<span>=</span> false (<span>neg?</span> 1)))
  (<span>is</span> (<span>=</span> true  (<span>neg?</span> -1))))
</pre>
</div>


</div>
</div>

<div id="outline-container-sec-5-5-4">
<h4 id="sec-5-5-4">+</h4>
<div id="text-5-5-4">
<p>
Returns the sum of nums. <code>(+ )</code> returns 0.
</p>

<div>

<pre>(<span>deftest</span> add-test
  (<span>is</span> (<span>=</span> 0.6        (<span>+</span> 0.3 0.3)))
  (<span>is</span> (<span>=</span> 0          (<span>+</span> )))
  (<span>is</span> (<span>=</span> 1          (<span>+</span> 1)))
  (<span>is</span> (<span>=</span> 10         (<span>+</span> 1 2 3 4)))
  (<span>is</span> (<span>=</span> 10         (<span>+</span> 1 2.0 3 4))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>+</span> [&amp; args]
  <span>&#34;real_t value(0.0);</span>

<span>   for_each(i, args)</span>
<span>    value = value + number::to&lt;real_t&gt;(i);</span>

<span>   __result = obj&lt;number&gt;(value);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-5">
<h4 id="sec-5-5-5">-</h4>
<div id="text-5-5-5">
<p>
Subtracts nums and returns the result.
</p>

<div>

<pre>(<span>deftest</span> sub-test
  (<span>is</span> (<span>=</span> -1         (<span>-</span> 1)))
  (<span>is</span> (<span>=</span> 0          (<span>-</span> 4 2 2)))
  (<span>is</span> (<span>=</span> 0          (<span>-</span> 4 2 2.0))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>-</span> [&amp; args]
  <span>&#34;__result = rt::first(args);</span>
<span>   real_t value = number::to&lt;real_t&gt;(__result);</span>
<span>   size_t count = 1;</span>

<span>   for_each(i, rt::rest(args)){</span>
<span>    value = (value - number::to&lt;real_t&gt;(i));</span>
<span>    count++;</span>
<span>   }</span>

<span>   if (count == 1)</span>
<span>    value = value * real_t(-1.0);</span>

<span>   __result = obj&lt;number&gt;(value);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-6">
<h4 id="sec-5-5-6">*</h4>
<div id="text-5-5-6">
<p>
Returns the product of nums. <code>(* )</code> returns 1.
</p>

<div>

<pre>(<span>deftest</span> mul-test
  (<span>is</span> (<span>=</span> 1          (<span>*</span> )))
  (<span>is</span> (<span>=</span> 8          (<span>*</span> 2 2 2)))
  (<span>is</span> (<span>=</span> 8          (<span>*</span> 2.0 2 2))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>*</span> [&amp; args]
  <span>&#34;real_t value(1.0);</span>

<span>   for_each(i, args)</span>
<span>    value = (value * number::to&lt;real_t&gt;(i));</span>

<span>   __result = obj&lt;number&gt;(value);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-7">
<h4 id="sec-5-5-7">/</h4>
<div id="text-5-5-7">
<p>
If no denominators are supplied, returns <code>1 / numerator</code>, else returns
numerator divided by all of the denominators.
</p>

<div>

<pre>(<span>deftest</span> div-test
  (<span>is</span> (<span>=</span> 1          (<span>/</span> 1)))
  (<span>is</span> (<span>=</span> 0.5        (<span>/</span> 2)))
  (<span>is</span> (<span>=</span> 1          (<span>/</span> 4 2 2)))
  (<span>is</span> (<span>=</span> 1          (<span>/</span> 4 2 2.0))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>/</span> [&amp; args]
  <span>&#34;__result = rt::first(args);</span>
<span>   real_t value = number::to&lt;real_t&gt;(__result);</span>
<span>   size_t count = 1;</span>

<span>   for_each(i, rt::rest(args)){</span>
<span>    value = (value / number::to&lt;real_t&gt;(i));</span>
<span>    count++;</span>
<span>   }</span>

<span>   if (count == 1)</span>
<span>    value = real_t(1.0) / value;</span>

<span>   __result = obj&lt;number&gt;(value);&#34;</span>)
</pre>
</div>
</div>
</div>





<div id="outline-container-sec-5-5-10">
<h4 id="sec-5-5-10">min / max</h4>
<div id="text-5-5-10">
<div>

<pre>(<span>deftest</span> min-max-test
  (<span>is</span> (<span>=</span> 1          (<span>min</span> 1)))
  (<span>is</span> (<span>=</span> 1          (<span>min</span> 2 1)))
  (<span>is</span> (<span>=</span> 1          (<span>min</span> 3 5 7 1)))
  (<span>is</span> (<span>=</span> 1          (<span>max</span> 1)))
  (<span>is</span> (<span>=</span> 2          (<span>max</span> 2 1)))
  (<span>is</span> (<span>=</span> 7          (<span>max</span> 3 5 7 1))))
</pre>
</div>

<p>
Returns the least of the nums.
</p>

<div>

<pre>(<span>defn</span> <span>min</span> [&amp; args]
  <span>&#34;__result = rt::first(args);</span>
<span>   for_each(i, rt::rest(args))</span>
<span>    if (number::to&lt;real_t&gt;(__result) &gt; number::to&lt;real_t&gt;(i))</span>
<span>     __result = i;&#34;</span>)
</pre>
</div>

<p>
Returns the greatest of the nums.
</p>

<div>

<pre>(<span>defn</span> <span>max</span> [&amp; args]
  <span>&#34;__result = rt::first(args);</span>
<span>   for_each(i, rt::rest(args))</span>
<span>    if (number::to&lt;real_t&gt;(__result) &lt; number::to&lt;real_t&gt;(i))</span>
<span>     __result = i;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-11">
<h4 id="sec-5-5-11">rem</h4>
<div id="text-5-5-11">
<div>

<pre>(<span>defn</span> <span>rem</span> [^number_t num ^number_t div]
  <span>&#34;return obj&lt;number&gt;((num % div));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-12">
<h4 id="sec-5-5-12">mod</h4>
<div id="text-5-5-12">
<div>

<pre>(<span>deftest</span> mod-test
  (<span>is</span> (<span>=</span> 0          (<span>mod</span> 2 2)))
  (<span>is</span> (<span>=</span> 0          (<span>mod</span> 4 2)))
  (<span>is</span> (<span>=</span> 1          (<span>mod</span> 5 2)))
  (<span>is</span> (<span>=</span> 1          (<span>mod</span> 8 7))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>mod</span> [num div] 
  (<span>let</span> [m (<span>rem</span> num div)] 
    (<span>if</span> (<span>or</span> (<span>zero?</span> m) (<span>=</span> (<span>pos?</span> num) (<span>pos?</span> div)))
      m 
      (<span>+</span> m div))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-13">
<h4 id="sec-5-5-13">floor</h4>
<div id="text-5-5-13">
<div>

<pre>(<span>deftest</span> floor-test
  (<span>is</span> (<span>=</span> 1          (floor 1.1)))
  (<span>is</span> (<span>=</span> 1          (floor 1.5)))
  (<span>is</span> (<span>=</span> 1          (floor 1.9))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>floor</span> [^number_t x] <span>&#34;return obj&lt;number&gt;(x);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-14">
<h4 id="sec-5-5-14">interp</h4>
<div id="text-5-5-14">
<p>
One-dimensional linear interpolation.
</p>

<div>

<pre>(<span>deftest</span> interp-test
  (<span>is</span> (<span>=</span> 100  (interp 10 0 10 0 100)))
  (<span>is</span> (<span>=</span>  80  (interp  8 0 10 0 100)))
  (<span>is</span> (<span>=</span>  70  (interp  7 0 10 0 100)))
  (<span>is</span> (<span>=</span>  50  (interp  5 0 10 0 100)))
  (<span>is</span> (<span>=</span>  20  (interp  2 0 10 0 100)))
  (<span>is</span> (<span>=</span>   0  (interp  0 0 10 0 100))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>interp</span> [^real_t x
              ^real_t in-min ^real_t in-max
              ^real_t out-min ^real_t out-max]
  <span>&#34;return obj&lt;number&gt;((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-15">
<h4 id="sec-5-5-15">clip</h4>
<div id="text-5-5-15">
<p>
Clip (limit) the values in number.
</p>

<div>

<pre>(<span>deftest</span> clip-test
  (<span>is</span> (<span>=</span>   5 (clip   10   0  5)))
  (<span>is</span> (<span>=</span>  10 (clip   10   0 20)))
  (<span>is</span> (<span>=</span>   0 (clip   10 -10  0)))
  (<span>is</span> (<span>=</span> -10 (clip -100 -10  0))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>clip</span> [^real_t x ^real_t min ^real_t max]
  <span>&#34;return obj&lt;number&gt;(rt::max(rt::min(max, x), min));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-16">
<h4 id="sec-5-5-16">abs</h4>
<div id="text-5-5-16">
<p>
Returns the absolute value of a number.
</p>

<div>

<pre>(<span>deftest</span> abs-test
  (<span>is</span> (<span>=</span>   42 (abs -42)))
  (<span>is</span> (<span>=</span>   42 (abs  42)))
  (<span>is</span> (<span>=</span>   42.42 (abs -42.42)))
  (<span>is</span> (<span>=</span>   42.42 (abs  42.42))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>abs</span> [^real_t x]
  <span>&#34;return obj&lt;number&gt;(rt::abs(x));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-17">
<h4 id="sec-5-5-17">bit-and</h4>
<div id="text-5-5-17">
<div>

<pre>(<span>deftest</span> bit-and-test
  (<span>is</span> (<span>=</span> 0          (<span>bit-and</span>  4 3)))
  (<span>is</span> (<span>=</span> 0          (<span>bit-and</span>  0 1))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-and</span> [^number_t x ^number_t y] <span>&#34;return obj&lt;number&gt;((x &amp; y));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-18">
<h4 id="sec-5-5-18">bit-not</h4>
<div id="text-5-5-18">
<div>

<pre>(<span>deftest</span> bit-not-test
  (<span>is</span> (<span>=</span> -5         (<span>bit-not</span>  4)))
  (<span>is</span> (<span>=</span> -1         (<span>bit-not</span>  0))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-not</span> [^number_t x] <span>&#34;return obj&lt;number&gt;(~x);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-19">
<h4 id="sec-5-5-19">bit-or</h4>
<div id="text-5-5-19">
<div>

<pre>(<span>deftest</span> bit-or-test
  (<span>is</span> (<span>=</span> 7          (<span>bit-or</span>   4 3)))
  (<span>is</span> (<span>=</span> 1          (<span>bit-or</span>   0 1))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-or</span> [^number_t x ^number_t y] <span>&#34;return obj&lt;number&gt;((x | y ));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-20">
<h4 id="sec-5-5-20">bit-xor</h4>
<div id="text-5-5-20">
<div>

<pre>(<span>deftest</span> bit-xor-test
  (<span>is</span> (<span>=</span> 0          (<span>bit-xor</span>  4 4)))
  (<span>is</span> (<span>=</span> 1          (<span>bit-xor</span>  1 0))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-xor</span> [^number_t x ^number_t y] <span>&#34;return obj&lt;number&gt;((x ^ y ));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-21">
<h4 id="sec-5-5-21">bit-shift-left</h4>
<div id="text-5-5-21">
<div>

<pre>(<span>deftest</span> bit-shift-left-test
  (<span>is</span> (<span>=</span> 8          (<span>bit-shift-left</span> 4 1)))
  (<span>is</span> (<span>=</span> 16         (<span>bit-shift-left</span> 4 2))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-shift-left</span> [^number_t x ^number_t n] <span>&#34;return obj&lt;number&gt;((x &lt;&lt; n ));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-22">
<h4 id="sec-5-5-22">bit-shift-right</h4>
<div id="text-5-5-22">
<div>

<pre>(<span>deftest</span> bit-shift-right-test
  (<span>is</span> (<span>=</span> 2          (<span>bit-shift-right</span> 4 1)))
  (<span>is</span> (<span>=</span> 1          (<span>bit-shift-right</span> 4 2))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-shift-right</span> [^number_t x ^number_t n] <span>&#34;return obj&lt;number&gt;((x &gt;&gt; n ));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-23">
<h4 id="sec-5-5-23">bit-extract</h4>
<div id="text-5-5-23">
<p>
From <code>x</code> extract <code>k</code> bits starting from position <code>p</code>.
</p>

<div>

<pre>(<span>deftest</span> bit-extract-test
  (<span>is</span> (<span>=</span> 1          (bit-extract 1781 0 2)))
  (<span>is</span> (<span>=</span> 2          (bit-extract 1781 1 2)))
  (<span>is</span> (<span>=</span> 245        (bit-extract 1781 0 8)))
  (<span>is</span> (<span>=</span> 15         (bit-extract 1781 4 4)))
  (<span>is</span> (<span>=</span> 111        (bit-extract 1781 4 8)))
  (<span>is</span> (<span>=</span> 20         (bit-extract 500  0 5)))
  (<span>is</span> (<span>=</span> 15         (bit-extract 500  5 6))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-extract</span> [^number_t x ^number_t p ^number_t k]
  <span>&#34;__result = obj&lt;number&gt;((x &gt;&gt; p) &amp; ((1 &lt;&lt; k) - 1));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-24">
<h4 id="sec-5-5-24">bit-override</h4>
<div id="text-5-5-24">
<p>
Override <code>len</code> bits in <code>dst</code> starting from <code>pos</code> using bits from <code>src</code>.
</p>

<div>

<pre>(<span>deftest</span> bit-override-test
  (<span>is</span> (<span>=</span> 0xAC3A     (bit-override 0xAAAA 0x0C30 4 8)))
  (<span>is</span> (<span>=</span> 0xBBCC     (bit-override 0xBBBB 0xAACC 0 8)))
  (<span>is</span> (<span>=</span> 0xBACB     (bit-override 0xBBBB 0xAACC 4 8)))
  (<span>is</span> (<span>=</span> 0xBBBB     (bit-override 0xAAAA 0xBBBB 0 16))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>bit-override</span> [^number_t dst ^number_t src ^number_t pos ^number_t len]
  <span>&#34;number_t mask = (((number_t)1 &lt;&lt; len) - 1) &lt;&lt; pos;</span>
<span>   number_t num = (dst &amp; ~mask) | (src &amp; mask);</span>
<span>   return obj&lt;number&gt;(num);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-25">
<h4 id="sec-5-5-25">encode/decode-int16</h4>
<div id="text-5-5-25">
<div>

<pre>(<span>deftest</span> encode-decode-int16-test
  (<span>is</span> (<span>=</span> 0          (decode-int16 (encode-int16 0))))
  (<span>is</span> (<span>=</span> 512        (decode-int16 (encode-int16 512))))
  (<span>is</span> (<span>=</span> 1024       (decode-int16 (encode-int16 1024))))
  (<span>is</span> (<span>=</span> 2048       (decode-int16 (encode-int16 2048))))
  (<span>is</span> (<span>=</span> 32000      (decode-int16 (encode-int16 32000)))))
</pre>
</div>

<p>
Split a number into bytes.
</p>

<div>

<pre>(<span>defn</span> <span>encode-int16</span> [n] 
  <span>&#34;int16_t val = number::to&lt;int16_t&gt;(n);</span>
<span>   byte *p = (byte*)&amp;val;</span>
<span>   for (int i = (sizeof(int16_t) -1); i &gt;= 0; i--)</span>
<span>     __result = rt::cons(obj&lt;number&gt;((number_t)p[i]),__result);&#34;</span>)
</pre>
</div>

<p>
Combine a list of bytes to a number.
</p>

<div>

<pre>(<span>defn</span> <span>decode-int16</span> [s]
  <span>&#34;int16_t val = 0;</span>
<span>   byte *p = (byte*)&amp;val; </span>

<span>   size_t index = 0;</span>
<span>   for_each(i, s){</span>
<span>     p[index] = number::to&lt;byte&gt;(i);</span>
<span>     index++;</span>
<span>   }</span>

<span>   return obj&lt;number&gt;(val);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-26">
<h4 id="sec-5-5-26">encode/decode-float</h4>
<div id="text-5-5-26">
<div>

<pre>(<span>deftest</span> encode-decode-float-test
  (<span>is</span> (<span>=</span> 0          (decode-float (encode-float 0))))
  (<span>is</span> (<span>=</span> 512        (decode-float (encode-float 512))))
  (<span>is</span> (<span>=</span> 1024       (decode-float (encode-float 1024))))
  (<span>is</span> (<span>=</span> 2048       (decode-float (encode-float 2048))))
  (<span>is</span> (<span>=</span> 32000      (decode-float (encode-float 32000))))
  (<span>is</span> (<span>=</span> 512        (decode-float (<span>list</span> 0 0 0 68 42)))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>encode-float</span> [n] 
  <span>&#34;static_assert(sizeof(float) == 4 * sizeof(byte), \&#34;\&#34;);</span>
<span>   float val = number::to&lt;float&gt;(n);</span>
<span>   byte *p = (byte*)&amp;val;</span>
<span>   for (int i = (sizeof(float) -1); i &gt;= 0; i--)</span>
<span>     __result = rt::cons(obj&lt;number&gt;(p[i]),__result);&#34;</span>)
</pre>
</div>

<p>
Combine a list of bytes to a number.
</p>

<div>

<pre>(<span>defn</span> <span>decode-float</span> [s]
  <span>&#34;union {</span>
<span>    float f;</span>
<span>    byte b[4];</span>
<span>   } u;</span>
<span>   static_assert(sizeof(float) == 4 * sizeof(byte), \&#34;\&#34;);</span>

<span>   size_t index = 0;</span>
<span>   for_each(i, s){</span>
<span>     if (index &gt; 3)</span>
<span>      break;</span>
<span>     u.b[index] = number::to&lt;byte&gt;(i);</span>
<span>     index++;</span>
<span>   }</span>

<span>   return obj&lt;number&gt;(u.f);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-27">
<h4 id="sec-5-5-27">sqrt</h4>
<div id="text-5-5-27">
<p>
Square root.
</p>

<div>

<pre>(<span>deftest</span> sqrt-test
  (<span>is</span> (<span>=</span> 32         (sqrt 1024)))
  (<span>is</span> (<span>=</span> 2          (sqrt 4))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>sqrt</span> [^real_t s]
  <span>&#34;return obj&lt;number&gt;(::sqrt(s));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-28">
<h4 id="sec-5-5-28">pow</h4>
<div id="text-5-5-28">
<p>
Returns base raised to the power exponent:
</p>

<div>

<pre>(<span>deftest</span> pow-test
  (<span>is</span> (<span>=</span> 8          (pow 2 3)))
  (<span>is</span> (<span>=</span> 16         (pow 2 4))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>pow</span> [^real_t b ^real_t e]
  <span>&#34;return obj&lt;number&gt;(::pow(b, e));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-29">
<h4 id="sec-5-5-29">cos</h4>
<div id="text-5-5-29">
<p>
Returns the cosine of an angle of x radians.
</p>

<div>

<pre>(<span>deftest</span> cos-test
  (<span>is</span> (<span>=</span> 1          (cos 0)))
  (<span>is</span> (<span>=</span> -0.99999   (cos 3.145))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>cos</span> [^real_t s]
  <span>&#34;return obj&lt;number&gt;(::cos(s));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-30">
<h4 id="sec-5-5-30">sin</h4>
<div id="text-5-5-30">
<p>
Returns the sine of an angle of x radians.
</p>

<div>

<pre>(<span>deftest</span> sin-test
  (<span>is</span> (<span>=</span> 0          (sin 0)))
  (<span>is</span> (<span>=</span> -0.00340   (sin 3.145))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>sin</span> [^real_t s]
  <span>&#34;return obj&lt;number&gt;(::sin(s));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-31">
<h4 id="sec-5-5-31">asin</h4>
<div id="text-5-5-31">
<p>
Returns the principal value of the arc sine of x, expressed in radians.
</p>

<div>

<pre>(<span>defn</span> <span>asin</span> [^real_t x]
  <span>&#34;return obj&lt;number&gt;(::asin(x));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-32">
<h4 id="sec-5-5-32">atan2</h4>
<div id="text-5-5-32">
<p>
Returns the principal value of the arc tangent of y/x, expressed in radians.
</p>

<div>

<pre>(<span>deftest</span> aton2-test
  (<span>is</span> (<span>=</span> 0.98279    (atan2 45 30))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>atan2</span> [^real_t x ^real_t y]
  <span>&#34;return obj&lt;number&gt;(::atan2(x,y));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-33">
<h4 id="sec-5-5-33">log / log10</h4>
<div id="text-5-5-33">
<div>

<pre>(<span>deftest</span> log-test
  (<span>is</span> (<span>=</span> 2.30258    (log 10)))
  (<span>is</span> (<span>=</span> 2          (log10 100))))
</pre>
</div>

<p>
Returns the natural logarithm of x.
</p>

<div>

<pre>(<span>defn</span> <span>log</span> [^real_t x]
  <span>&#34;return obj&lt;number&gt;(::log(x));&#34;</span>)
</pre>
</div>

<p>
Returns the natural logarithm of x.
</p>

<div>

<pre>(<span>defn</span> <span>log10</span> [^real_t x]
  <span>&#34;return obj&lt;number&gt;(::log10(x));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-34">
<h4 id="sec-5-5-34">to-degrees/radians</h4>
<div id="text-5-5-34">
<div>

<pre>(<span>deftest</span> to-degrees-radians-test
  (<span>is</span> (<span>=</span> 180.19522  (to-degrees 3.145)))
  (<span>is</span> (<span>=</span> 3.14159    (to-radians 180))))
</pre>
</div>

<p>
Converts an angle measured in radians to an approximately equivalent
angle measured in degrees.
</p>

<div>

<pre>(<span>defn</span> <span>to-degrees</span> [^real_t x]
  <span>&#34;return obj&lt;number&gt;((x * 180.0 / 1_pi));&#34;</span>)
</pre>
</div>

<p>
Converts an angle measured in degrees to an approximately equivalent
angle measured in radians.
</p>

<div>

<pre>(<span>defn</span> <span>to-radians</span> [^real_t x]
  <span>&#34;return obj&lt;number&gt;((x * 1_pi / 180.0));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-35">
<h4 id="sec-5-5-35">rand</h4>
<div id="text-5-5-35">
<p>
Returns a random floating point number between 0 (inclusive) and n
(default 1) (exclusive).
</p>

<div>

<pre>(<span>deftest</span> random-test
  (<span>is</span> (<span>=</span> true       (<span>not</span> (<span>nil?</span> (<span>rand</span>)))))
  (<span>is</span> (<span>=</span> true       (<span>not</span> (<span>nil?</span> (<span>rand</span> 15))))))
</pre>
</div>

<div>

<pre>(defnative rand-aux []
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;random&#34;</span>)
      <span>&#34;::std::random_device ferret_random_device;</span>
<span>       ::std::mt19937_64 ferret_random_generator(ferret_random_device());</span>
<span>       ::std::uniform_real_distribution&lt;ferret::real_t&gt; ferret_random_distribution(0.0,1.0);&#34;</span>
      <span>&#34;return obj&lt;number&gt;(ferret_random_distribution(ferret_random_generator));&#34;</span>))

(<span>defn</span> <span>rand</span>
  ([]
   (rand-aux))
  ([x]
   (<span>*</span> x (rand-aux))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5-36">
<h4 id="sec-5-5-36">rand-int</h4>
<div id="text-5-5-36">
<p>
Returns a random integer between 0 (inclusive) and n (exclusive).
</p>

<div>

<pre>(<span>defn</span> <span>rand-int</span>
  [x]
  (floor (<span>rand</span> x)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-6">
<h3 id="sec-5-6">Matrices</h3>
<div id="text-5-6">
<div>

<pre>(<span>require</span> &#39;[ferret.matrix <span>:as</span> m])

(<span>def</span> <span>pi</span> 3.1415)

(<span>defn</span> <span>rot</span> [turns]
  (<span>let</span> [a (<span>*</span> 2 pi turns)]
    (matrix
     [[   (cos a)  (sin a)]
      [(<span>-</span> (sin a)) (cos a)]])))

(<span>-&gt;&gt;</span> (matrix [[3] [4]])
     (m/mmul (rot 1/8))
     (m/<span>seq</span>))

(<span>assert</span> (<span>=</span> (<span>-&gt;&gt;</span> (matrix [[3] [4]])
                (m/mmul (rot 1/8))
                (m/<span>seq</span>))
           (<span>list</span> 4.9497 0.7072)))
</pre>
</div>
</div>

<div id="outline-container-sec-5-6-1">
<h4 id="sec-5-6-1">row-count</h4>
<div id="text-5-6-1">
<p>
Returns the number of rows in a matrix.
</p>

<div>

<pre>(<span>defn</span> <span>row-count</span> [^matrix u]
  <span>&#34;return obj&lt;number&gt;(matrix::row_count(u));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-2">
<h4 id="sec-5-6-2">column-count</h4>
<div id="text-5-6-2">
<p>
Returns the number of columns in a matrix.
</p>

<div>

<pre>(<span>defn</span> <span>column-count</span> [^matrix u]
  <span>&#34;return obj&lt;number&gt;(matrix::column_count(u));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-3">
<h4 id="sec-5-6-3">zeros</h4>
<div id="text-5-6-3">
<p>
Constructs a new zero-filled numerical matrix with the given
dimensions.
</p>

<div>

<pre>(<span>defn</span> <span>zeros</span> [^size_t r, ^size_t c]
  <span>&#34;return obj&lt;matrix_t&gt;(matrix::zeros(r, c));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-4">
<h4 id="sec-5-6-4">ones</h4>
<div id="text-5-6-4">
<p>
Constructs a new zero-filled numerical matrix with the given
dimensions.
</p>

<div>

<pre>(<span>defn</span> <span>ones</span> [^size_t r, ^size_t c]
  <span>&#34;return obj&lt;matrix_t&gt;(matrix::ones(r,c));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-5">
<h4 id="sec-5-6-5">full</h4>
<div id="text-5-6-5">
<p>
Fills a matrix with a single scalar value.
</p>

<div>

<pre>(<span>defn</span> <span>full</span> [^size_t r, ^size_t c, ^real_t v]
  <span>&#34;return obj&lt;matrix_t&gt;(matrix::ones(r,c,v));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-6">
<h4 id="sec-5-6-6">eye</h4>
<div id="text-5-6-6">
<p>
Identity matrix. Returns an n-by-n identity matrix with ones on the
main diagonal and zeros elsewhere.
</p>

<div>

<pre>(<span>defn</span> <span>eye</span> [^size_t n]
  <span>&#34;return obj&lt;matrix_t&gt;(matrix::eye(n));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-7">
<h4 id="sec-5-6-7">add</h4>
<div id="text-5-6-7">
<p>
Performs element-wise addition on matrices.
</p>

<div>

<pre>(<span>defn</span> <span>add</span> [^matrix u ^matrix v]
  <span>&#34;return obj&lt;matrix_t&gt;(u + v);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-8">
<h4 id="sec-5-6-8">sub</h4>
<div id="text-5-6-8">
<p>
Performs element-wise subtraction on matrices.
</p>

<div>

<pre>(<span>defn</span> <span>sub</span> [^matrix u ^matrix v]
  <span>&#34;return obj&lt;matrix_t&gt;(u - v);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-9">
<h4 id="sec-5-6-9">mul</h4>
<div id="text-5-6-9">
<p>
Performs element-wise multipication with scalar on matrices.
</p>

<div>

<pre>(<span>defn</span> <span>mul</span> [^matrix u ^real_t s]
  <span>&#34;return obj&lt;matrix_t&gt;(u * s);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-10">
<h4 id="sec-5-6-10">mmul</h4>
<div id="text-5-6-10">
<p>
Performs matrix multiplication on matrices.
</p>

<div>

<pre>(<span>defn</span> <span>mmul</span> [^matrix u ^matrix v]
  <span>&#34;return obj&lt;matrix_t&gt;(u * v);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-11">
<h4 id="sec-5-6-11">equals</h4>
<div id="text-5-6-11">
<p>
Returns <code>true</code> if both matrices are numerically equal.
</p>

<div>

<pre>(<span>defn</span> <span>equals</span> [^matrix u ^matrix v]
  <span>&#34;if (u == v)</span>
<span>       return cached::true_o;</span>
<span>   else</span>
<span>       return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-12">
<h4 id="sec-5-6-12">normalise</h4>
<div id="text-5-6-12">
<p>
Normalises a matrix (scales to unit length). Returns a new normalised
matrix.
</p>

<div>

<pre>(<span>defn</span> <span>normalise</span> [^matrix u]
  <span>&#34;return obj&lt;matrix_t&gt;(matrix::normalise(u));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-13">
<h4 id="sec-5-6-13">norm</h4>
<div id="text-5-6-13">
<p>
Calcualtes the Euclidean norm of matrix.
</p>

<div>

<pre>(<span>defn</span> <span>norm</span> [^matrix u]
  <span>&#34;return obj&lt;number&gt;(matrix::norm_euclidean(u));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-14">
<h4 id="sec-5-6-14">mset!</h4>
<div id="text-5-6-14">
<p>
Mutates a scalar value in a matrix at the specified position.
</p>

<div>

<pre>(<span>defn</span> <span>mset!</span> [^matrix u ^size_t r ^size_t c ^real_t v]
  <span>&#34;u(r, c, v);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-15">
<h4 id="sec-5-6-15">mget</h4>
<div id="text-5-6-15">
<p>
Gets a scalar value from a matrix at the specified position.
</p>

<div>

<pre>(<span>defn</span> <span>mget</span> [^matrix u ^size_t r ^size_t c]
  <span>&#34;return obj&lt;number&gt;(u(r, c));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-16">
<h4 id="sec-5-6-16">cout</h4>
<div id="text-5-6-16">
<p>
Pretty-prints a matrix to <code>std::cout</code>.
</p>

<div>

<pre>(<span>defn</span> <span>cout</span> [^matrix u]
  <span>&#34;std::cout &lt;&lt; u;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-6-17">
<h4 id="sec-5-6-17">seq</h4>
<div id="text-5-6-17">
<p>
Converts <code>matrix</code> to a <code>lazy-seq</code>.
</p>

<div>

<pre>(<span>defn</span> <span>seq</span> [u]
  <span>&#34;return obj&lt;array_seq&lt;real_t, number&gt;&gt;(u);&#34;</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-7">
<h3 id="sec-5-7">Timing</h3>
<div id="outline-container-sec-5-7-1">
<h4 id="sec-5-7-1">millis</h4>
<div id="text-5-7-1">
<p>
Return current time in milliseconds,
</p>

<div>

<pre>(<span>deftest</span> millis-test
  (<span>let</span> [now (millis)]
    (sleep 150)
    (<span>is</span> (<span>&gt;=</span> (<span>-</span> (millis) now) 100))))
</pre>
</div>

<div>

<pre>(defnative millis []
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      <span>&#34;auto now = ::std::chrono::system_clock::now();</span>
<span>       auto epoch = now.time_since_epoch();</span>
<span>       auto time = ::std::chrono::duration_cast&lt;::std::chrono::milliseconds&gt;(epoch).count();</span>
<span>       return obj&lt;number&gt;(time);&#34;</span>)
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;return obj&lt;number&gt;(::millis());&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-7-2">
<h4 id="sec-5-7-2">micros</h4>
<div id="text-5-7-2">
<p>
Return current time in microseconds,
</p>

<div>

<pre>(defnative micros []
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      <span>&#34;auto now = ::std::chrono::high_resolution_clock::now();</span>
<span>       auto epoch = now.time_since_epoch();</span>
<span>       auto time = ::std::chrono::duration_cast&lt;::std::chrono::microseconds&gt;(epoch).count();</span>
<span>       return obj&lt;number&gt;(time);&#34;</span>)
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;return obj&lt;number&gt;(::micros());&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-7-3">
<h4 id="sec-5-7-3">sleep</h4>
<p>
Sleep current thread for <b>t</b> milliseconds,
</p>
</div>

<div id="outline-container-sec-5-7-4">
<h4 id="sec-5-7-4">sleep-micros</h4>
<div id="text-5-7-4">
<p>
Sleep current thread for <b>t</b> microseconds,
</p>

<div>

<pre>(defnative sleep-micros [^number_t t]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      <span>&#34;auto duration = ::std::chrono::microseconds(t);</span>
<span>       ::std::this_thread::sleep_for(duration);&#34;</span>)
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::delayMicroseconds(t);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-7-5">
<h4 id="sec-5-7-5">elapsed-micros</h4>
<div id="text-5-7-5">
<p>
Port of Teensy elapsedMicros API,
</p>

<div>

<pre>(defobject elapsed_micros <span>&#34;elapsed_micros_o.h&#34;</span>)

(<span>defn</span> <span>new-elapsed-micros</span> []
  <span>&#34;return obj&lt;elapsed_micros&gt;();&#34;</span>)

(<span>defn</span> <span>elapsed-micros?</span> [t ^real_t n]
  <span>&#34;if (t.cast&lt;elapsed_micros&gt;()-&gt;is_elapsed(n))</span>
<span>     return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)

(<span>defn</span> <span>elapsed-micros-now</span> [t]
  <span>&#34;return obj&lt;number&gt;(t.cast&lt;elapsed_micros&gt;()-&gt;elapsed());&#34;</span>)

(<span>defn</span> <span>elapsed-micros-reset</span> [t]
  <span>&#34;t.cast&lt;elapsed_micros&gt;()-&gt;reset()&#34;</span>)
</pre>
</div>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_SAFE_MODE)
<span>class</span> <span>elapsed_micros</span> : <span>public</span> <span>object</span> {
  <span>mutex</span> <span>lock</span>;
  <span>unsigned</span> <span>long</span> <span>us</span>;

<span>#if</span> <span>defined</span>(FERRET_HARDWARE_ARDUINO)
  <span>inline</span> <span>unsigned</span> <span>long</span> <span>now</span>() <span>const</span>{
    <span>return</span> ::micros();
  }
<span>#elif</span> <span>defined</span>(FERRET_STD_LIB)
  <span>inline</span> <span>unsigned</span> <span>long</span> <span>now</span>() <span>const</span>{
    <span>auto</span> <span>now</span> = ::<span>std</span>::<span>chrono</span>::<span>high_resolution_clock</span>::now();
    <span>auto</span> <span>epoch</span> = now.time_since_epoch();
    <span>return</span> (<span>unsigned</span> <span>long</span>)::<span>std</span>::<span>chrono</span>::duration_cast&lt;::<span>std</span>::<span>chrono</span>::microseconds&gt;(epoch).count();
  }
<span>#endif</span>

 <span>public</span>:

  <span>elapsed_micros</span>(<span>void</span>) { us = now(); }

  <span>void</span> <span>reset</span>() {
    <span>lock_guard</span> <span>guard</span>(lock);
    us = now();
  }

  <span>type_t</span> <span>type</span>() <span>const</span> { <span>return</span> <span>type_id</span>&lt;<span>elapsed_micros</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> {
    <span>rt</span>::print(<span>&#34;micros#&#34;</span>);
    <span>rt</span>::print(elapsed());
  }
<span>#endif</span>

  <span>inline</span> <span>real_t</span> <span>elapsed</span>() <span>const</span> { <span>return</span> (<span>real_t</span>)(now() - us); }
  <span>inline</span> <span>bool</span> <span>is_elapsed</span>(<span>real_t</span> <span>t</span>) <span>const</span> { <span>return</span> (elapsed() &gt;= t); }
};
<span>#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-7-6">
<h4 id="sec-5-7-6">benchmark</h4>
<div id="text-5-7-6">
<p>
Benchmark a function. Run function <code>f</code> <code>n</code> times and print execution
statistics.
</p>

<div>

<pre>(benchmark #(<span>reduce</span> + (<span>range</span> 1000)) 10000)
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>benchmark</span>
  ([f]
   (benchmark f 100))
  ([f ^number_t n]
   <span>&#34;elapsed_micros timer;</span>

<span>    run(f);</span>
<span>    real_t elapsed = timer.elapsed() / real_t(1000.0);</span>

<span>    real_t min = elapsed;</span>
<span>    real_t max = elapsed;</span>
<span>    real_t sum = real_t(0.0);</span>
<span>    real_t sum_sq = real_t(0.0);</span>

<span>    for(number_t i =0; i &lt; n; i++){</span>
<span>      timer.reset();</span>
<span>      run(f);</span>
<span>      real_t elapsed = timer.elapsed() / real_t(1000.0);</span>

<span>      #if defined(FERRET_BENCHMARK_VERBOSE)</span>
<span>         rt::println(elapsed);</span>
<span>      #endif</span>

<span>      sum += elapsed;</span>
<span>      sum_sq += (elapsed * elapsed);</span>
<span>      if (elapsed &lt; min)</span>
<span>        min = elapsed;</span>
<span>      if (elapsed &gt; max)</span>
<span>        max = elapsed;</span>
<span>      }</span>

<span>      real_t mean = (real_t)(sum / n);</span>
<span>      real_t stdev = (real_t)sqrt((sum_sq / n) - (mean * mean));</span>

<span>      rt::print(\&#34;\\t mean: \&#34;);</span>
<span>      rt::println(mean);</span>

<span>      rt::print(\&#34;\\tstdev: \&#34;);</span>
<span>      rt::println(stdev);</span>

<span>      rt::print(\&#34;\\t  min: \&#34;);</span>
<span>      rt::println(min);</span>

<span>      rt::print(\&#34;\\t  max: \&#34;);</span>
<span>      rt::println(max);</span>

<span>      rt::print(\&#34;\\trange: \&#34;);</span>
<span>      rt::println((max - min));&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-7-7">
<h4 id="sec-5-7-7">fn-throttler</h4>
<div id="text-5-7-7">
<p>
Returns a new function that limits the throughput of the given
function. When called faster than <code>=rate=</code> it can either block or
return <code>=nil=</code> immediately.
</p>

<div>

<pre>(<span>defn</span> <span>ping</span> []
  (<span>println</span> <span>&#34;Ping!&#34;</span>))

(<span>def</span> <span>throttled-ping</span> (fn-throttler ping 1 <span>:second</span> <span>:blocking</span>))

<span>;; </span><span>Ping console every second</span>
(forever
 (throttled-ping))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>ping</span> [] true)

(<span>deftest</span> fn-throttler-test
  (<span>let</span> [throttled-ping (fn-throttler ping 1 <span>:second</span> <span>:blocking</span>)
        begin (millis)]

    (throttled-ping)
    (throttled-ping)
    (throttled-ping)

    (<span>is</span> (<span>&gt;</span> (<span>-</span> (millis) begin) 2000))
    (<span>is</span> (throttled-ping)))


  (<span>let</span> [throttled-ping (fn-throttler ping 1 <span>:second</span> <span>:non-blocking</span>)
        begin (millis)]

    (throttled-ping)
    (throttled-ping)
    (throttled-ping)

    (<span>is</span> (<span>nil?</span> (throttled-ping)))
    (<span>is</span> (<span>&lt;</span> (<span>-</span> (millis) begin) 1000))))
</pre>
</div>

<div>

<pre>(defobject fn_throttler_o <span>&#34;fn_throttler_o.h&#34;</span>)

(<span>defn</span> <span>new-fn-throttler</span> [f ^real_t rate ^bolean block]
  <span>&#34;return obj&lt;fn_throttler&gt;(f, rate, block);&#34;</span>)

(<span>defmacro</span> <span>fn-throttler</span> [f rate unit policy]
  (<span>let</span> [unit-&gt;ms {<span>:microsecond</span> 1 <span>:millisecond</span> 1000
                  <span>:second</span> 1000000 <span>:minute</span> 60000000
                  <span>:hour</span> 3600000000 <span>:day</span> 86400000000
                  <span>:month</span> 2678400000000}
        rate (<span>/</span> (unit-&gt;ms unit) rate)]
    `(new-fn-throttler ~f ~rate ~(<span>=</span> policy <span>:blocking</span>))))
</pre>
</div>

<div>

<pre><span>#if</span> !<span>defined</span>(FERRET_SAFE_MODE)
<span>class</span> <span>fn_throttler</span> : <span>public</span> <span>lambda_i</span> {
  <span>var</span> <span>fn</span>;
  <span>elapsed_micros</span> <span>timer</span>;
  <span>real_t</span> <span>rate</span>;
  <span>bool</span> <span>blocking</span>;

<span>#if</span> <span>defined</span>(FERRET_HARDWARE_ARDUINO)
  <span>inline</span> <span>void</span> <span>_wait</span>(<span>real_t</span> <span>t</span>) <span>const</span>{
    ::delayMicroseconds((<span>number_t</span>)t);
  }
<span>#elif</span> <span>defined</span>(FERRET_STD_LIB)
  <span>inline</span> <span>void</span> <span>_wait</span>(<span>real_t</span> <span>t</span>) <span>const</span>{
    <span>auto</span> <span>duration</span> = ::<span>std</span>::<span>chrono</span>::microseconds((<span>number_t</span>)t);
    ::<span>std</span>::<span>this_thread</span>::sleep_for(duration);
  }
<span>#endif</span>

  <span>var</span> <span>exec</span>(<span>ref</span> <span>args</span>){
    <span>if</span> (blocking)
      _wait(rate - timer.elapsed());

    <span>if</span> (timer.is_elapsed(rate)){
      timer.reset();
      <span>return</span> <span>rt</span>::apply(fn, args);
    }

    <span>return</span> nil();
  }

<span>public</span>:

  <span>explicit</span> <span>fn_throttler</span>(<span>var</span> <span>f</span>, <span>real_t</span> <span>r</span>, <span>bool</span> <span>b</span>) : fn(f), rate(r), blocking (b) { }

  <span>var</span> <span>invoke</span>(<span>ref</span> <span>args</span>) <span>const</span> <span>final</span> {
    <span>return</span> var((<span>object</span>*)<span>this</span>).cast&lt;<span>fn_throttler</span>&gt;()-&gt;exec(args);
  }
};
<span>#endif</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-8">
<h3 id="sec-5-8">String</h3>
<div id="outline-container-sec-5-8-1">
<h4 id="sec-5-8-1">string?</h4>
<div id="text-5-8-1">
<p>
Return <code>true</code> if <code>s</code> is a <code>string</code>.
</p>

<div>

<pre>(<span>defn</span> <span>string?</span> [s]
  <span>&#34;if (s.is_type(type_id&lt;string&gt;))</span>
<span>     return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-8-2">
<h4 id="sec-5-8-2">ston</h4>
<div id="text-5-8-2">
<p>
Parses the Ferret <code>string</code> <code>str</code>, interpreting its content as a number
and returns its value as a Ferret <code>number</code>.
</p>

<div>

<pre>(<span>deftest</span> ston-test
  (<span>is</span> (<span>=</span>  1234.1234 (ston  <span>&#34;1234.1234&#34;</span>)))
  (<span>is</span> (<span>=</span> -1234.1234 (ston <span>&#34;-1234.1234&#34;</span>)))
  (<span>is</span> (<span>=</span>  1234.1234 (ston  <span>&#34;1 2 3 4. 1 2 3 4 &#34;</span>))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>ston</span> [str]
  <span>&#34;var seq = str;</span>
<span>   real_t factor = 1;</span>
<span>   real_t value = 0;</span>

<span>   if (number::to&lt;byte&gt;(rt::first(seq)) == &#39;-&#39;){</span>
<span>     seq = rt::rest(seq);</span>
<span>     factor = -1;</span>
<span>   }</span>

<span>   bool point_passed = false;</span>
<span>   for_each(i, seq){</span>
<span>     byte ch = number::to&lt;byte&gt;(i);</span>

<span>     if (ch == &#39;.&#39;){</span>
<span>       point_passed = true;</span>
<span>       continue;</span>
<span>     }</span>

<span>     number_t d = ch - &#39;0&#39;;</span>
<span>     if (d &gt;= 0 &amp;&amp; d &lt;= 9){</span>
<span>       if (point_passed)</span>
<span>         factor /= real_t(10.0);</span>
<span>       value = value * real_t(10.0) + real_t(d);</span>
<span>     }</span>
<span>   }</span>

<span>   return obj&lt;number&gt;(value * factor);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-8-3">
<h4 id="sec-5-8-3">ntos</h4>
<div id="text-5-8-3">
<p>
Converts a Ferret <code>number</code> to a Ferret <code>string</code>,
</p>

<div>

<pre>(<span>deftest</span> ntos-test
  (<span>is</span> (<span>=</span>  (ntos -12.34)      (new-string <span>&#34;-12.3400&#34;</span>)))
  (<span>is</span> (<span>=</span>  (ntos  12.001)     (new-string <span>&#34;12.0010&#34;</span>)))
  (<span>is</span> (<span>=</span>  (ntos  154.132341) (new-string <span>&#34;154.1323&#34;</span>))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>ntos</span> [^real_t f]
  <span>&#34;number_t n = (number_t)f;</span>
<span>   number_t sign;</span>

<span>   if ((sign = n) &lt; 0){</span>
<span>      n = -n;</span>
<span>      f = -f;</span>
<span>   }</span>

<span>   var s;</span>

<span>   f = (f - n) + 10;</span>
<span>   for (int i = real_precision; i &gt;= 1; i--){</span>
<span>      number_t ch = ((number_t)(f * ::pow(10, i)) % 10) + &#39;0&#39;;</span>
<span>      s = rt::cons(obj&lt;number&gt;(ch), s);</span>
<span>   }</span>

<span>   s = rt::cons(obj&lt;number&gt;(&#39;.&#39;), s);</span>

<span>   do {</span>
<span>     s = rt::cons(obj&lt;number&gt;(n % 10 + &#39;0&#39;), s);</span>
<span>    } while ((n /= 10) &gt; 0);</span>

<span>   if (sign &lt; 0)</span>
<span>     s = rt::cons(obj&lt;number&gt;(&#39;-&#39;), s);</span>

<span>   return obj&lt;string&gt;(s);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-8-4">
<h4 id="sec-5-8-4">str-tok</h4>
<div id="text-5-8-4">
<p>
Returns a <code>lazy-seq</code> of tokens in <code>str</code> separated by <code>delimeter</code>.
</p>

<div>

<pre>(<span>assert</span> (<span>=</span> (str-tok <span>&#34;- This, a sample string.&#34;</span> <span>&#34; ,.-&#34;</span>)
           (<span>list</span> <span>&#34;This&#34;</span> <span>&#34;a&#34;</span> <span>&#34;sample&#34;</span> <span>&#34;string&#34;</span>)))
</pre>
</div>


<div>

<pre>(defnative str-tok [str delimeter]
  (on <span>&#34;defined FERRET_RUNTIME_H&#34;</span>
      (<span>&#34;string.h&#34;</span>)
      <span>&#34;var packed_delimeter = string::pack(delimeter);</span>
<span>       var packed_str = string::pack(str);</span>

<span>       class seq : public lambda_i {</span>
<span>         var s;</span>
<span>         var d;</span>
<span>       public:</span>
<span>         explicit seq(ref str = nil(), ref del = nil()) : s(str), d(del) { }</span>
<span>         var invoke(ref) const final {</span>
<span>           char* token = strtok(NULL, string::c_str(d));</span>
<span>           if (token != nullptr)</span>
<span>             return obj&lt;lazy_sequence&gt;(obj&lt;string&gt;(token),obj&lt;seq&gt;(s, d));</span>
<span>           return nil();</span>
<span>         }</span>
<span>       };</span>

<span>       char* token = strtok(string::c_str(packed_str), </span>
<span>                            string::c_str(packed_delimeter)); </span>

<span>       if (token != nullptr)</span>
<span>         return obj&lt;lazy_sequence&gt;(obj&lt;string&gt;(token),</span>
<span>                                   obj&lt;seq&gt;(packed_str, packed_delimeter));</span>

<span>       return nil();&#34;</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-9">
<h3 id="sec-5-9">Functions</h3>
<div id="outline-container-sec-5-9-1">
<h4 id="sec-5-9-1">fn</h4>
<div id="text-5-9-1">
<p>
Define a <code>fn</code>,
</p>



<p>
Define a <code>fn</code> and bind <code>name</code> to it,
</p>



<p>
Define a multi-arity function that counts the number of its arguments
and then dispatches on the number of arguments to each implementation.
</p>

<div>

<pre>(<span>fn</span>
  ([a] 1)
  ([a b] 2)
  ([a b &amp; c] 3)
  ([a b [c d] &amp; e] 4))
</pre>
</div>

<div>

<pre>(<span>deftest</span> fn-test
  (<span>let</span> [f1 (<span>fn</span> [])
        f2 (<span>fn</span> [])

        m-func (<span>fn</span>
                 ([a] 1)
                 ([a b] 2)
                 ([a b c] 3))

        n-func (<span>do</span> (<span>fn</span>
                     ([]    0)
                     ([x]   1)
                     ([x y] 2)))]

    (<span>is</span> (<span>=</span> true  (<span>=</span> f1 f1)))
    (<span>is</span> (<span>=</span> false (<span>=</span> f1 f2)))

    (<span>is</span> (<span>=</span> 1 (m-func 1)))
    (<span>is</span> (<span>=</span> 2 (m-func 1 2)))
    (<span>is</span> (<span>=</span> 3 (m-func 1 2 3)))

    (<span>is</span> (<span>=</span> 0 (n-func)))
    (<span>is</span> (<span>=</span> 1 (n-func 1)))
    (<span>is</span> (<span>=</span> 2 (n-func 1 2)))

    (<span>is</span> (<span>=</span> 3      (#(<span>+</span> 1 2))))
    (<span>is</span> (<span>=</span> 11     ((<span>fn</span> [n] (<span>+</span> n 1)) 10)))
    (<span>is</span> (<span>=</span> 3      (((<span>fn</span> [n] (<span>fn</span> [n] n)) 3) 3))))

  (<span>is</span> (<span>=</span> (<span>list</span> 5 6 7 8 9)
         ((<span>fn</span> <span>recursive-range</span> [x y]
            (<span>if</span> (<span>&lt;</span> x y)
              (<span>cons</span> x (recursive-range (<span>inc</span> x) y))))
          5 10))))
</pre>
</div>

<p>
Functions may also define a variable number of arguments - this is
known as a &#34;variadic&#34; function. The variable arguments must occur at
the end of the argument list. They will be collected in a sequence for
use by the function.
</p>

<p>
The beginning of the variable arguments is marked with <code>&amp;</code>
</p>

<div>

<pre>(<span>defn</span> <span>hello</span> [greeting &amp; who]
  (<span>println</span> greeting who))
</pre>
</div>

<p>
See <a href="#sec-4-7">Accessing C,C++ Libraries</a> for information on how to use Ferret
with external libraries.
</p>

<div>

<pre>(<span>defmacro</span> <span>fn</span> [&amp; sig]
  (<span>let</span> [name (<span>if</span> (<span>symbol?</span> (<span>first</span> sig)) (<span>first</span> sig) nil)
        body (<span>if</span> name (<span>rest</span> sig) sig)]
    (<span>if</span> (<span>vector?</span> (<span>first</span> body))
      (<span>let</span> [[args &amp; body] body]
        (new-fir-fn <span>:name</span> name <span>:args</span> args <span>:body</span> body))
      <span>;; </span><span>handle multi arity function</span>
      (<span>let</span> [fns   (<span>map</span> (fn* [body]
                            (<span>let</span> [[args &amp; body] body]
                              (new-fir-fn <span>:args</span> args <span>:body</span> body)))
                       body)
            arity (<span>-&gt;&gt;</span> (<span>map</span> first body)
                       (<span>map</span> (fn* [args] (<span>filter</span> #(<span>not</span> (<span>=</span> % &#39;&amp;)) args)))
                       (<span>map</span> #(<span>count</span> %)))
            fns   (<span>-&gt;&gt;</span> (<span>interleave</span> arity fns)
                       (<span>partition</span> 2)
                       (<span>sort-by</span> first))
            fns   (<span>if</span> (<span>-&gt;&gt;</span> fns last second second      <span>;; </span><span>last arity arguments</span>
                           (<span>take-last</span> 2) first (<span>=</span> &#39;&amp;)) <span>;; </span><span>check &amp;</span>
                    (<span>let</span> [switch        (<span>drop-last</span> 1 fns)
                          [[_ default]] (<span>take-last</span> 1 fns)]
                      `(fir-defn-arity ~switch ~default))
                    `(fir-defn-arity ~fns))]
        (new-fir-fn <span>:escape</span> false <span>:name</span> name <span>:body</span> [fns])))))
</pre>
</div>

<p>
A simple macro for calling inline C++,
</p>

<div>

<pre>(<span>defmacro</span> <span>cxx</span> [&amp; body]
  (<span>let</span> [body (<span>apply</span> str body)]
    `((<span>fn</span> [] ~body))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-9-2">
<h4 id="sec-5-9-2">defnative</h4>
<div id="text-5-9-2">
<p>
Allows a function to be defined for multiple platforms see <a href="#sec-4-7">Accessing C,C++ Libraries</a> for
examples.
</p>

<div>

<pre>(<span>defmacro</span> <span>defnative</span> [name args &amp; form]
  (<span>let</span> [includes (<span>-&gt;&gt;</span> (<span>filter</span> #(<span>seq?</span> (<span>nth</span> % 2)) form)
                      (<span>map</span> #(<span>cons</span> (<span>nth</span> % 1) (<span>apply</span> list (<span>nth</span> % 2))))
                      (<span>map</span> (<span>fn</span> [form]
                             (<span>let</span> [[guard &amp; headers] form]
                               (<span>str</span> <span>&#34;\n#if &#34;</span> guard <span>&#34; \n&#34;</span>
                                    (<span>apply</span> str (<span>map</span> #(<span>str</span> <span>&#34;#include \&#34;&#34;</span> % <span>&#34;\&#34;\n&#34;</span>) headers))
                                    <span>&#34;#endif\n&#34;</span>))))
                      (<span>map</span> #(<span>list</span> &#39;native-declare %)))
        enabled (<span>-&gt;</span> (symbol-conversion name)
                    (<span>str</span> <span>&#34;_enabled&#34;</span>)
                    .toUpperCase)
        body (<span>-&gt;&gt;</span> (<span>map</span> #(<span>vector</span> (<span>second</span> %) (<span>last</span> %)) form)
                  (<span>map</span> #(<span>str</span> <span>&#34;\n#if &#34;</span> (<span>first</span> %) <span>&#34; \n&#34;</span>
                             <span>&#34;#define &#34;</span> enabled <span>&#34;\n&#34;</span>
                             (<span>second</span> %)
                             <span>&#34;\n#endif\n&#34;</span>))
                  (<span>apply</span> str))
        body (<span>str</span> body
                  <span>&#34;\n#if !defined &#34;</span> enabled <span>&#34; \n&#34;</span>
                  <span>&#34;# error &#34;</span> (symbol-conversion name)
                  <span>&#34; Not Supported on This Platform \n&#34;</span>
                  <span>&#34;#endif\n&#34;</span>)
        pre-ample (<span>-&gt;&gt;</span> (<span>map</span> #(<span>vector</span> (<span>second</span> %) (<span>drop-last</span> (<span>drop</span> 3 %))) form)
                       (<span>remove</span> #(<span>empty?</span> (<span>second</span> %)))
                       (<span>map</span> #(<span>str</span> <span>&#34;\n#if &#34;</span> (<span>first</span> %) <span>&#34; \n&#34;</span>
                                  (<span>apply</span> str (<span>map</span> (<span>fn</span> [line] (<span>str</span> line <span>&#34;\n&#34;</span>)) (<span>second</span> %)))
                                  <span>&#34;\n#endif\n&#34;</span>))
                       (<span>map</span> #(<span>list</span> &#39;native-declare %)))]
    `(<span>def</span> <span>~name</span> (<span>fn</span> <span>~args</span> <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="750b351c1b161900111006">[email protected]</a> <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="205e605052450d414d504c45">[email protected]</a>  ~body))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-9-3">
<h4 id="sec-5-9-3">-&gt;</h4>
<div id="text-5-9-3">
<p>
Threads the expr through the forms. Inserts x as the
second item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
second item in second form, etc.
</p>

<div>

<pre>(<span>defmacro</span> <span>-&gt;</span> [x &amp; forms]
  (<span>loop</span> [x x, forms forms]
    (<span>if</span> forms
      (<span>let</span> [form (<span>first</span> forms)
            threaded (<span>if</span> (<span>seq?</span> form)
                       `(~(<span>first</span> form) ~x <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="a7d9e7">[email protected]</a>(<span>next</span> form))
                       (<span>list</span> form x))]
        (<span>recur</span> threaded (<span>next</span> forms)))
      x)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-9-4">
<h4 id="sec-5-9-4">-&gt;&gt;</h4>
<div id="text-5-9-4">
<p>
Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc.
</p>

<div>

<pre>(<span>defmacro</span> <span>-&gt;&gt;</span> [x &amp; forms]
  (<span>loop</span> [x x, forms forms]
    (<span>if</span> forms
      (<span>let</span> [form (<span>first</span> forms)
            threaded (<span>if</span> (<span>seq?</span> form)
                       `(~(<span>first</span> form) <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="e49aa4">[email protected]</a>(<span>next</span> form)  ~x)
                       (<span>list</span> form x))]
        (<span>recur</span> threaded (<span>next</span> forms)))
      x)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-9-5">
<h4 id="sec-5-9-5">doto</h4>
<div id="text-5-9-5">
<p>
Evaluates x then calls all of the methods and functions with the
value of x supplied at the front of the given arguments.  The forms
are evaluated in order.  Returns x.
</p>

<div>

<pre>(<span>require</span> &#39;[ferret.matrix <span>:as</span> m])

(<span>deftest</span> doto-test
    (<span>let</span> [mat (m/zeros 2 2)]
      (<span>doto</span> mat
        (m/mset! 0 0 1)
        (m/mset! 0 1 1)
        (m/mset! 1 0 1)
        (m/mset! 1 1 1))
      (<span>is</span> (<span>=</span> (<span>list</span> 1 1 1 1) (m/<span>seq</span> mat)))))
</pre>
</div>


</div>
</div>

<div id="outline-container-sec-5-9-6">
<h4 id="sec-5-9-6">comment</h4>
<div id="text-5-9-6">
<p>
Ignores body, yields nil.
</p>

<div>

<pre>(<span>defmacro</span> <span>comment</span>
  [&amp; body])
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-10">
<h3 id="sec-5-10">I/O</h3>
<div id="outline-container-sec-5-10-1">
<h4 id="sec-5-10-1">command-line-args</h4>
<p>
Variable <code>*command-line-args*</code> contains the sequence of the supplied
command line arguments, or nil if none were supplied.
</p>
</div>

<div id="outline-container-sec-5-10-2">
<h4 id="sec-5-10-2">print</h4>
<div id="text-5-10-2">
<p>
Prints the object(s) to <code>STD_OUT</code>.
</p>

<div>

<pre>(defnative print [&amp; more]
  (on <span>&#34;!defined(FERRET_DISABLE_STD_OUT)&#34;</span>
      <span>&#34;if (more.is_nil())</span>
<span>         return nil();</span>
<span>       ref f = rt::first(more);</span>
<span>       f.stream_console();</span>
<span>       ref r = rt::rest(more);</span>
<span>       for_each(it, r){</span>
<span>        rt::print(&#39; &#39;);</span>
<span>        it.stream_console();</span>
<span>       }</span>
<span>       return nil();&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-3">
<h4 id="sec-5-10-3">println</h4>
<div id="text-5-10-3">
<p>
Same as print followed by (newline).
</p>

<div>

<pre>(<span>defn</span> <span>println</span> [&amp; more]
  (<span>apply</span> print more)
  (cxx <span>&#34;rt::print((char)0xA);&#34;</span>))
</pre>
</div>
</div>
</div>

<p id="outline-container-sec-5-10-4">
<h4 id="sec-5-10-4">get-char</h4>
</p>
<div id="outline-container-sec-5-10-5">
<h4 id="sec-5-10-5">read-line</h4>
<div id="text-5-10-5">
<p>
Reads the next line from default I/O stream.
</p>

<div>

<pre>(<span>defn</span> <span>read-line</span> []
  <span>&#34;char buf[FERRET_IO_STREAM_SIZE] = {0};</span>
<span>   rt::read_line(buf, FERRET_IO_STREAM_SIZE);</span>
<span>   return obj&lt;string&gt;(buf);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-6">
<h4 id="sec-5-10-6">slurp</h4>
<div id="text-5-10-6">
<div>

<pre>(defnative slurp [^c_str f]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;fstream&#34;</span>)
      <span>&#34;std::ifstream ifs(f, std::ios::in | std::ios::binary | std::ios::ate);</span>

<span>       if (!ifs.good())</span>
<span>         return nil();</span>

<span>       std::ifstream::pos_type file_size = ifs.tellg();</span>
<span>       ifs.seekg(0, std::ios::beg);</span>

<span>       var data = obj&lt;array_seq&lt;byte, number&gt;&gt;(size_t(file_size));</span>
<span>       var storage = (data.cast&lt;array_seq&lt;byte, number&gt;&gt;()-&gt;storage);</span>
<span>       auto&amp; arr = value&lt;array&lt;byte&gt;&gt;::to_reference(storage).data;</span>

<span>       ifs.read((char*)arr, file_size);</span>

<span>       return obj&lt;string&gt;(data);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-7">
<h4 id="sec-5-10-7">sh</h4>
<div id="text-5-10-7">
<div>

<pre>(defnative sh [^c_str cmd]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;memory&#34;</span>)
      <span>&#34;::std::shared_ptr&lt;FILE&gt; pipe(popen(cmd, \&#34;r\&#34;), pclose);</span>
<span>       if (!pipe) </span>
<span>         return nil();</span>
<span>       char buffer[128];</span>
<span>       ::std::string result = \&#34;\&#34;;</span>
<span>       while (!feof(pipe.get()))</span>
<span>        if (fgets(buffer, 128, pipe.get()) != NULL)</span>
<span>         result += buffer;</span>
<span>       return obj&lt;string&gt;(result);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-8">
<h4 id="sec-5-10-8">lock-memory</h4>
<div id="text-5-10-8">
<p>
Wraps mlockall - locks the address space of process.
</p>

<div>

<pre>(defnative lock-memory []
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;sys/mman.h&#34;</span>)
      <span>&#34;mlockall(MCL_CURRENT | MCL_FUTURE);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-9">
<h4 id="sec-5-10-9">pr-object-sizes</h4>
<div id="text-5-10-9">
<div>

<pre>(<span>defn</span> <span>pr-object-sizes</span> []
  (<span>println</span> <span>&#34;Machine Types&#34;</span>)
  (<span>println</span> <span>&#34;\t*void:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(void*));&#34;</span>))
  (<span>println</span> <span>&#34;\treal_t:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(real_t));&#34;</span>))
  (<span>println</span> <span>&#34;\tnumber_t:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(number_t));&#34;</span>))
  (<span>println</span> <span>&#34;Object Types&#34;</span>)
  (<span>println</span> <span>&#34;\tvar:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(var));&#34;</span>))
  (<span>println</span> <span>&#34;\tobject:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(object));&#34;</span>))
  (<span>println</span> <span>&#34;\tnumber:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(number));&#34;</span>))
  (<span>println</span> <span>&#34;\tkeyword:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(keyword));&#34;</span>))
  (<span>println</span> <span>&#34;\tboolean:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(boolean));&#34;</span>))
  (<span>println</span> <span>&#34;\tempty_sequence:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(empty_sequence));&#34;</span>))
  (<span>println</span> <span>&#34;\tsequence:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(sequence));&#34;</span>))
  (<span>println</span> <span>&#34;\tlazy_sequence:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(lazy_sequence));&#34;</span>))
  (<span>println</span> <span>&#34;\tatom:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(atomic));&#34;</span>))
  (<span>println</span> <span>&#34;\td_list:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(d_list));&#34;</span>))
  (<span>println</span> <span>&#34;\tpointer:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(pointer));&#34;</span>))
  (<span>println</span> <span>&#34;\telapsed_micros:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(elapsed_micros));&#34;</span>))
  (<span>println</span> <span>&#34;\tpid_controller&lt;real_t&gt;:\t&#34;</span>
           (cxx <span>&#34;return obj&lt;number&gt;(sizeof(pid_controller&lt;real_t&gt;));&#34;</span>))
  (<span>println</span> <span>&#34;\tdelayed:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(delayed));&#34;</span>))
  (<span>println</span> <span>&#34;\tstring:\t\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(string));&#34;</span>))
  (<span>println</span> <span>&#34;Interface Types&#34;</span>)
  (<span>println</span> <span>&#34;\tseekable_i:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(seekable_i));&#34;</span>))
  (<span>println</span> <span>&#34;\tlambda_i:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(lambda_i));&#34;</span>))
  (<span>println</span> <span>&#34;\tderef_i:\t\t&#34;</span> (cxx <span>&#34;return obj&lt;number&gt;(sizeof(deref_i));&#34;</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-10">
<h4 id="sec-5-10-10">memory-pool-free-space</h4>
<div id="text-5-10-10">
<div>

<pre>(defnative memory-pool-free-space []
  (on <span>&#34;defined FERRET_MEMORY_POOL_SIZE&#34;</span>
      <span>&#34;size_t acc = 0;</span>
<span>       for(size_t i = 0; i &lt; FERRET_MEMORY_POOL_PAGE_COUNT; i++)</span>
<span>         if(memory::allocator::program_memory.used.get(i) == false)</span>
<span>           acc++;</span>
<span>       return obj&lt;number&gt;((acc*sizeof(FERRET_MEMORY_POOL_PAGE_TYPE)));&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-11">
<h4 id="sec-5-10-11">system-exit</h4>
<div id="text-5-10-11">
<div>

<pre>(<span>defn</span> <span>system-exit</span> []
  <span>&#34;::exit(0);&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-12">
<h4 id="sec-5-10-12">system-abort</h4>
<div id="text-5-10-12">
<div>

<pre>(<span>defn</span> <span>system-abort</span> []
  <span>&#34;::abort();&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-13">
<h4 id="sec-5-10-13">system-halt</h4>
<div id="text-5-10-13">
<div>

<pre>(<span>defn</span> <span>system-halt</span> [code]
  (forever (sleep 1000)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-14">
<h4 id="sec-5-10-14">file</h4>
<div id="text-5-10-14">
<p>
<code>ferret.io.file</code> includes functions for creating and manipulating
files in a portable manner.
</p>

<div>

<pre>(<span>require</span> &#39;[ferret.io.file <span>:as</span> f])

(<span>assert</span> (<span>true?</span>  (f/exists <span>&#34;project.clj&#34;</span>)))
(<span>assert</span> (<span>false?</span> (f/exists <span>&#34;dummy_file.clj&#34;</span>)))

(<span>assert</span> (<span>true?</span>  (f/mkdir <span>&#34;src/dummy_directory&#34;</span>)))
(<span>assert</span> (<span>true?</span>  (seqable? (f/<span>seq</span> <span>&#34;src/dummy_directory&#34;</span>))))
(<span>assert</span> (<span>false?</span> (f/mkdir <span>&#34;src&#34;</span>)))

(<span>assert</span> (<span>=</span> (<span>list</span> ) (f/open-dir <span>&#34;src/dummy_directory&#34;</span>)))
(<span>assert</span> (<span>nil?</span>      (f/open-dir <span>&#34;project.clj&#34;</span>)))


(<span>assert</span> (<span>true?</span>  (f/rmdir <span>&#34;src/dummy_directory&#34;</span>)))
</pre>
</div>

<div>

<pre>(defnative open-dir [^c_str directory]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;dirent.h&#34;</span>
       <span>&#34;string.h&#34;</span>)
      <span>&#34;DIR *d;</span>
<span>       struct dirent *dir;</span>
<span>       d = opendir(directory);</span>
<span>       if (d) {</span>
<span>         __result = rt::list();</span>
<span>         while ((dir = readdir(d)) != NULL) {</span>
<span>           if (!strcmp(dir-&gt;d_name, \&#34;.\&#34;) || !strcmp(dir-&gt;d_name, \&#34;..\&#34;)){</span>
<span>             continue;</span>
<span>           }</span>
<span>           __result = rt::cons(obj&lt;string&gt;(dir-&gt;d_name), __result);</span>
<span>         }</span>
<span>         closedir(d);</span>
<span>        }</span>
<span>       return __result;&#34;</span>))

(defnative mkdir [^c_str dir]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;sys/stat.h&#34;</span>
       <span>&#34;sys/types.h&#34;</span>)
      <span>&#34;int result = mkdir(dir, 0755);</span>
<span>       if (result == 0)</span>
<span>         return cached::true_o;</span>
<span>       return cached::false_o;&#34;</span>))

(defnative rmdir [^c_str dir]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;unistd.h&#34;</span>)
      <span>&#34;int result = rmdir(dir);</span>
<span>       if (result == 0)</span>
<span>         return cached::true_o;</span>
<span>       return cached::false_o;&#34;</span>))

(defnative exists [^c_str file]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      (<span>&#34;unistd.h&#34;</span>)
      <span>&#34;if (access( file, F_OK ) != -1)</span>
<span>        return cached::true_o;</span>
<span>       return cached::false_o;&#34;</span>))

(defnative remove [^c_str file]
  (on <span>&#34;defined FERRET_STD_LIB&#34;</span>
      <span>&#34;int result = remove(file);</span>
<span>       if (result == 0)</span>
<span>         return cached::true_o;</span>
<span>       return cached::false_o;&#34;</span>))

(<span>defn</span> <span>seq-flat</span> [s]
  (<span>lazy-seq</span>
   (<span>if</span> (seqable? s)
     (<span>let</span> [[head &amp; tail] s]
       (<span>if</span> (<span>not</span> (<span>string?</span> head))
         (<span>concat</span> (seq-flat head) (seq-flat tail))
         (<span>cons</span> head (seq-flat tail)))))))

(<span>defn</span> <span>seq-walk</span> [dir]
  (<span>map</span> (<span>fn</span> [f]
         (<span>let</span> [file (new-string dir <span>&#34;/&#34;</span> f)]
           (<span>if</span> (open-dir file)
             (new-lazy-seq file #(seq-walk file))
             file)))
       (open-dir dir)))

(<span>defn</span> <span>seq</span> [dir]
  (seq-flat
   (seq-walk dir)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-15">
<h4 id="sec-5-10-15">multicast-socket</h4>
<div id="text-5-10-15">
<p>
The multicast datagram socket class is useful for sending and
receiving IP multicast packets. A MulticastSocket is a (UDP)
datagram socket, with additional capabilities for joining &#34;groups&#34; of
other multicast hosts on the internet.
</p>

<p>
A multicast group is specified by a class D IP address and by a
standard UDP port number. Class D IP addresses are in the range
224.0.0.0 to 239.255.255.255, inclusive. The address 224.0.0.0 is
reserved and should not be used.
</p>

<p>
One would join a multicast group by first creating a <code>multicast-socket</code>
with the desired IP and port. When one sends a message to a multicast
group, all subscribing recipients to that host and port receive the
message. When a socket subscribes to a multicast group/port, it
receives datagrams sent by other hosts to the group/port, as do all
other members of the group and port.
</p>

<div>

<pre>(<span>require</span> &#39;[ferret.io.net.multicast <span>:as</span> multicast])

(<span>def</span> <span>sender</span>   (multicast/socket <span>&#34;224.5.23.2&#34;</span> 10005))
(<span>def</span> <span>receiver</span> (multicast/socket <span>&#34;224.5.23.2&#34;</span> 10005))

(<span>def</span> <span>data-out</span> (<span>list</span> 1 2 3 4 5))

(<span>assert</span> (multicast/<span>send</span> sender data-out))
(<span>assert</span> (multicast/pending? receiver))

(<span>def</span> <span>data-in</span> (multicast/recv receiver))

(<span>assert</span> (<span>=</span> data-in data-out))
</pre>
</div>

<div>

<pre>(native-header <span>&#34;fcntl.h&#34;</span>
               <span>&#34;unistd.h&#34;</span>
               <span>&#34;arpa/inet.h&#34;</span>
               <span>&#34;netdb.h&#34;</span>
               <span>&#34;netinet/in.h&#34;</span>
               <span>&#34;sys/poll.h&#34;</span>
               <span>&#34;sys/socket.h&#34;</span>
               <span>&#34;sys/types.h&#34;</span>
               <span>&#34;string.h&#34;</span>)

(defobject multicast-socket <span>&#34;io/net/multicast_o.h&#34;</span>)

(<span>defn</span> <span>socket</span> [ip port]
  <span>&#34;return obj&lt;multicast_socket&gt;(ip,port);&#34;</span>)

(<span>defn</span> <span>pending?</span> [con]
  <span>&#34;if (con.cast&lt;multicast_socket&gt;()-&gt;have_pending_data())</span>
<span>     return cached::true_o;</span>
<span>   return cached::false_o;&#34;</span>)

(<span>defn</span> <span>send</span> [con data]
  <span>&#34;datagram_t buffer(max_data_gram_size);</span>
<span>   size_t idx = 0; </span>

<span>   for_each(b, data)</span>
<span>    buffer[idx++] = (byte)number::to&lt;number_t&gt;(b);</span>

<span>   if (con.cast&lt;multicast_socket&gt;()-&gt;send(buffer,idx))</span>
<span>      return cached::true_o;</span>
<span>    return cached::false_o;&#34;</span>)

(<span>defn</span> <span>byte</span> [data ^size_t curr]
  <span>&#34;datagram_t&amp; buffer = value&lt;datagram_t&gt;::to_reference(data);</span>
<span>   return obj&lt;number&gt;(buffer[curr]);&#34;</span>)

(<span>defn</span> <span>data-seq</span>
  ([[size data]]
   (data-seq size data 0))
  ([size data curr]
   (<span>if</span> (<span>&lt;</span> curr size)
     (<span>cons</span> (<span>byte</span> data curr)
           (<span>lazy-seq</span> (data-seq size data (<span>inc</span> curr)))))))

(<span>defn</span> <span>read</span> [conn]
  <span>&#34;return conn.cast&lt;multicast_socket&gt;()-&gt;recv();&#34;</span>)

(<span>defn</span> <span>recv</span> [conn]
  (data-seq (<span>read</span> conn)))
</pre>
</div>

<div>

<pre><span>const</span> <span>size_t</span> <span>max_data_gram_size</span> = 65507;
<span>typedef</span> <span>ferret</span>::<span>array</span>&lt;<span>ferret</span>::byte&gt; <span>datagram_t</span>;

<span>namespace</span> <span>multicast_aux</span> {
  <span>class</span> <span>address</span>{
    <span>sockaddr</span> <span>addr</span>;
    <span>socklen_t</span> <span>addr_len</span>;

  <span>public</span>:
    <span>address</span>(){
      memset(&amp;addr, 0, <span>sizeof</span>(addr));
      addr_len = 0;
    }

    <span>address</span>(<span>const</span> <span>char</span> *<span>hostname</span>, <span>unsigned</span> <span>short</span> <span>port</span>){
      set_host(hostname, port);
    }

    <span>address</span>(<span>const</span> <span>address</span> &amp;<span>src</span>){ copy(src); }

    ~<span>address</span>() { reset(); }

    <span>bool</span> <span>set_host</span>(<span>const</span> <span>char</span> *<span>hostname</span>, <span>unsigned</span> <span>short</span> <span>port</span>);
    <span>void</span> <span>set_any</span>(<span>unsigned</span> <span>short</span> <span>port</span> = 0);

    <span>bool</span> <span>operator</span><span>==</span>(<span>const</span> <span>address</span> &amp;<span>a</span>) <span>const</span>{
      <span>return</span> addr_len == a.addr_len &amp;&amp; memcmp(&amp;addr, &amp;a.addr, addr_len) == 0;
    }

    <span>void</span> <span>copy</span>(<span>const</span> <span>address</span> &amp;<span>src</span>){
      memcpy(&amp;addr, &amp;src.addr, src.addr_len);
      addr_len = src.addr_len;
    }

    <span>void</span> <span>reset</span>(){
      memset(&amp;addr, 0, <span>sizeof</span>(addr));
      addr_len = 0;
    }

    <span>void</span> <span>clear</span>(){
      reset();
    }

    <span>in_addr_t</span> <span>get_in_addr</span>() <span>const</span>;

    <span>friend</span> <span>class</span> <span>udp</span>;
  };

  <span>class</span> <span>udp</span>{
    <span>int</span> <span>fd</span>;

  <span>public</span>:
    <span>unsigned</span> <span>sent_packets</span>;
    <span>size_t</span> <span>sent_bytes</span>;
    <span>unsigned</span> <span>recv_packets</span>;
    <span>size_t</span> <span>recv_bytes</span>;

  <span>public</span>:
    <span>udp</span>() : fd(-1) { close(); }
    ~<span>udp</span>(){ close(); }

    <span>bool</span> <span>open</span>(<span>const</span> <span>char</span> *<span>server_host</span>, <span>unsigned</span> <span>short</span> <span>port</span>, <span>bool</span> <span>blocking</span>);
    <span>bool</span> <span>add_multicast</span>(<span>const</span> <span>address</span> &amp;<span>multiaddr</span>, <span>const</span> <span>address</span> &amp;<span>interface</span>);
    <span>void</span> <span>close</span>();
    <span>bool</span> <span>is_open</span>() <span>const</span>{ <span>return</span> fd &gt;= 0; }

    <span>bool</span> <span>send</span>(<span>const</span> <span>void</span> *<span>data</span>, <span>size_t</span> <span>length</span>, <span>const</span> <span>address</span> &amp;<span>dest</span>);
    <span>ssize_t</span> <span>recv</span>(<span>address</span> &amp;<span>src</span>, <span>datagram_t</span> &amp; <span>recv_buf</span>);

    <span>bool</span> <span>wait</span>(<span>int</span> <span>timeout_ms</span> = -1) <span>const</span>;
    <span>bool</span> <span>have_pending_data</span>() <span>const</span>;
  };

  <span>bool</span> <span>address</span>::<span>set_host</span>(<span>const</span> <span>char</span> *<span>hostname</span>, <span>unsigned</span> <span>short</span> <span>port</span>){
    <span>addrinfo</span> *<span>res</span> = <span>nullptr</span>;
    getaddrinfo(hostname, <span>nullptr</span>, <span>nullptr</span>, &amp;res);
    <span>if</span> (res == <span>nullptr</span>) {
      <span>return</span> <span>false</span>;
    }

    memset(&amp;addr, 0, <span>sizeof</span>(addr));
    addr_len = res-&gt;ai_addrlen;
    memcpy(&amp;addr, res-&gt;ai_addr, addr_len);
    freeaddrinfo(res);

    <span>// </span><span>set port for internet sockets</span>
    <span>sockaddr_in</span> *<span>sockname</span> = <span>reinterpret_cast</span>&lt;<span>sockaddr_in</span> *&gt;(&amp;addr);
    <span>if</span> (sockname-&gt;sin_family == AF_INET) {
      sockname-&gt;sin_port = htons(port);
    }
    <span>else</span> {
      <span>// </span><span>TODO: any way to set port in general?</span>
    }

    <span>return</span> <span>true</span>;
  }

  <span>void</span> <span>address</span>::<span>set_any</span>(<span>unsigned</span> <span>short</span> <span>port</span>){
    memset(&amp;addr, 0, <span>sizeof</span>(addr));
    <span>sockaddr_in</span> *<span>s</span> = <span>reinterpret_cast</span>&lt;<span>sockaddr_in</span> *&gt;(&amp;addr);
    s-&gt;sin_addr.s_addr = htonl(INADDR_ANY);
    s-&gt;sin_port = htons(port);
    addr_len = <span>sizeof</span>(sockaddr_in);
  }

  <span>in_addr_t</span> <span>address</span>::<span>get_in_addr</span>() <span>const</span>{
    <span>const</span> <span>sockaddr_in</span> *<span>s</span> = <span>reinterpret_cast</span>&lt;<span>const</span> <span>sockaddr_in</span> *&gt;(&amp;addr);
    <span>return</span> s-&gt;sin_addr.s_addr;
  }

  <span>bool</span> <span>udp</span>::<span>open</span>(<span>const</span> <span>char</span> *<span>server_host</span>, <span>unsigned</span> <span>short</span> <span>port</span>, <span>bool</span> <span>blocking</span>){
    <span>// </span><span>open the socket</span>
    <span>if</span> (fd &gt;= 0) {
      ::close(fd);
    }
    fd = socket(PF_INET, SOCK_DGRAM, 0);

    <span>// </span><span>set socket as non-blocking</span>
    <span>int</span> <span>flags</span> = fcntl(fd, F_GETFL, 0);
    <span>if</span> (flags &lt; 0) {
      flags = 0;
    }
    fcntl(fd, F_SETFL, flags | (blocking ? 0 : O_NONBLOCK));

    <span>int</span> <span>reuse</span> = 1;
    <span>if</span> (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, <span>reinterpret_cast</span>&lt;<span>const</span> <span>char</span> *&gt;(&amp;reuse), <span>sizeof</span>(reuse)) != 0) {
      fprintf(stderr, <span>&#34;ERROR WHEN SETTING SO_REUSEADDR ON udp SOCKET\n&#34;</span>);
      fflush(stderr);
    }

    <span>int</span> <span>yes</span> = 1;
    <span>// </span><span>allow packets to be received on this host</span>
    <span>if</span> (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, <span>reinterpret_cast</span>&lt;<span>const</span> <span>char</span> *&gt;(&amp;yes), <span>sizeof</span>(yes)) != 0) {
      fprintf(stderr, <span>&#34;ERROR WHEN SETTING IP_MULTICAST_LOOP ON udp SOCKET\n&#34;</span>);
      fflush(stderr);
    }

    <span>// </span><span>bind socket to port if nonzero</span>
    <span>if</span> (port != 0) {
      <span>sockaddr_in</span> <span>sockname</span>;
      sockname.sin_family = AF_INET;
      sockname.sin_addr.s_addr = htonl(INADDR_ANY);
      sockname.sin_port = htons(port);
      bind(fd, <span>reinterpret_cast</span>&lt;<span>struct</span> <span>sockaddr</span> *&gt;(&amp;sockname), <span>sizeof</span>(sockname));
    }

    <span>// </span><span>add udp multicast groups</span>
    <span>address</span> <span>multiaddr</span>, <span>interface</span>;
    multiaddr.set_host(server_host, port);
    interface.set_any();

    <span>return</span> add_multicast(multiaddr, interface);
  }

  <span>bool</span> <span>udp</span>::<span>add_multicast</span>(<span>const</span> <span>address</span> &amp;<span>multiaddr</span>, <span>const</span> <span>address</span> &amp;<span>interface</span>){
    <span>struct</span> <span>ip_mreq</span> <span>imreq</span>;
    imreq.imr_multiaddr.s_addr = multiaddr.get_in_addr();
    imreq.imr_interface.s_addr = interface.get_in_addr();

    <span>int</span> <span>ret</span> = setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;imreq, <span>sizeof</span>(imreq));

    <span>return</span> ret == 0;
  }

  <span>void</span> <span>udp</span>::<span>close</span>(){
    <span>if</span> (fd &gt;= 0) {
      ::close(fd);
    }
    fd = -1;

    sent_packets = 0;
    sent_bytes = 0;
    recv_packets = 0;
    recv_bytes = 0;
  }

  <span>bool</span> <span>udp</span>::<span>send</span>(<span>const</span> <span>void</span> *<span>data</span>, <span>size_t</span> <span>length</span>, <span>const</span> <span>address</span> &amp;<span>dest</span>){
    <span>ssize_t</span> <span>len</span> = sendto(fd, data, length, 0, &amp;dest.addr, dest.addr_len);

    <span>if</span> (len &gt; 0) {
      sent_packets++;
      sent_bytes += (<span>size_t</span>)len;
    }

    <span>return</span> (len &gt;= 0 &amp;&amp; (<span>size_t</span>)len == length);
  }

  <span>ssize_t</span> <span>udp</span>::<span>recv</span>(<span>address</span> &amp;<span>src</span>, <span>datagram_t</span> &amp; <span>recv_buf</span>){
    src.addr_len = <span>sizeof</span>(src.addr);
    <span>ssize_t</span> <span>len</span> = recvfrom(fd, recv_buf.data, max_data_gram_size, 0, &amp;src.addr, &amp;src.addr_len);

    <span>if</span> (len &gt; 0) {
      recv_packets++;
      recv_bytes += (<span>size_t</span>)len;
    }

    <span>return</span> len;
  }

  <span>bool</span> <span>udp</span>::<span>have_pending_data</span>() <span>const</span>{
    <span>return</span> wait(0);
  }

  <span>bool</span> <span>udp</span>::<span>wait</span>(<span>int</span> <span>timeout_ms</span>) <span>const</span>{
    <span>static</span> <span>const</span> <span>bool</span> <span>debug</span> = <span>false</span>;
    <span>static</span> <span>bool</span> <span>pendingData</span> = <span>false</span>;
    <span>pollfd</span> <span>pfd</span>;
    pfd.fd = fd;
    pfd.events = POLLIN;
    pfd.revents = 0;

    <span>bool</span> <span>success</span> = (poll(&amp;pfd, 1, timeout_ms) &gt; 0);

    <span>if</span> (!success) {
      <span>// </span><span>Poll now claims that there is no pending data.</span>
      <span>// </span><span>What did have_pending_data get from Poll most recently?</span>
      <span>if</span> (debug) {
        printf(<span>&#34;wait failed, have_pending_data=%s\n&#34;</span>, (pendingData ? <span>&#34;true&#34;</span> : <span>&#34;false&#34;</span>));
      }
    }
    pendingData = success;
    <span>return</span> success;
  }
}

<span>class</span> <span>multicast_socket</span> <span>final</span> : <span>public</span> <span>object</span> {
  <span>std</span>::<span>string</span> <span>ip</span>;
  <span>unsigned</span> <span>short</span> <span>port</span>;
  <span>multicast_aux</span>::<span>udp</span> <span>net</span>;
  <span>mutex</span> <span>lock</span>;

<span>public</span>:

  <span>type_t</span> <span>type</span>() <span>const</span> <span>final</span> { <span>return</span> <span>type_id</span>&lt;<span>multicast_socket</span>&gt;; }

<span>#if</span> !<span>defined</span>(FERRET_DISABLE_STD_OUT)
  <span>void</span> <span>stream_console</span>() <span>const</span> <span>final</span> {
    <span>rt</span>::print(<span>&#34;multicast_socket&lt;&#34;</span>);
    <span>rt</span>::print(ip);
    <span>rt</span>::print(<span>&#39; &#39;</span>);
    <span>rt</span>::print(port);
    <span>rt</span>::print(<span>&#39;&gt;&#39;</span>);
  }
<span>#endif</span>

  <span>explicit</span> <span>multicast_socket</span>(<span>ref</span> <span>i</span>, <span>ref</span> <span>p</span>) :
    ip(<span>string</span>::to&lt;<span>std</span>::<span>string</span>&gt;(i)),
    port((<span>unsigned</span> <span>short</span>)<span>number</span>::to&lt;<span>number_t</span>&gt;(p)) {
    net.open(ip.c_str(), port,<span>true</span>);
  }

  <span>bool</span> <span>have_pending_data</span>() <span>const</span> {
    <span>return</span> net.have_pending_data();
  }

  <span>bool</span> <span>send</span>(<span>datagram_t</span> &amp; <span>data</span>, <span>size_t</span> <span>size</span>) {
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>multicast_aux</span>::<span>address</span> <span>dest_addr</span>(ip.c_str(), port);
    <span>return</span> net.send(data.data, size, dest_addr);
  }

  <span>var</span> <span>recv</span>(){
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>multicast_aux</span>::<span>address</span> <span>src_addr</span>(ip.c_str(), port);

    <span>var</span> <span>buffer</span> = obj&lt;<span>value</span>&lt;<span>datagram_t</span>&gt;&gt;(max_data_gram_size);
    <span>number_t</span> <span>read</span> = (<span>number_t</span>)net.recv(src_addr, <span>value</span>&lt;<span>datagram_t</span>&gt;::to_reference(buffer));

    <span>return</span> <span>rt</span>::<span>list</span>(obj&lt;number&gt;(<span>read</span>), buffer);
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-10-16">
<h4 id="sec-5-10-16">serial-port</h4>
<div id="text-5-10-16">
<p>
<code>ferret.io.serial</code> includes functions for creating and manipulating
serial ports in a portable manner. For example, a serial port may be
opened in RAW mode at baud rate (assumes 8 data bits, no parity, one
stop bit) using,
</p>

<div>

<pre>(<span>require</span> &#39;[ferret.io.serial <span>:as</span> serial])

(<span>def</span> <span>dev</span> (serial/open <span>&#34;/dev/ttyArduino&#34;</span>))
</pre>
</div>

<p>
Once opened, port is ready for <code>read=/=write</code>.
</p>

<div>

<pre>(<span>when</span> (<span>not</span> dev)
  (system-exit))

(sleep 2500)

(<span>let</span> [data-out (<span>list</span> \4 \2 \newline)]
  (<span>doseq</span> [byte data-out]
    (serial/write dev byte))

  (sleep 100)

  (<span>let</span> [data-in (<span>repeatedly</span> 3 #(serial/<span>read</span> dev))]
    (<span>assert</span> (<span>=</span> data-in data-out))))
</pre>
</div>

<div>

<pre>(native-header <span>&#34;termios.h&#34;</span>
               <span>&#34;fcntl.h&#34;</span>
               <span>&#34;unistd.h&#34;</span>
               <span>&#34;sys/ioctl.h&#34;</span>)

(<span>defn</span> <span>open-aux</span> [^c_str port speed v-min v-time]
  <span>&#34;struct termios toptions;</span>
<span>   int fd;</span>

<span>   fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);</span>

<span>   if (fd == -1){</span>
<span>     return nil();</span>
<span>    }else{</span>

<span>     if (tcgetattr(fd, &amp;toptions) &lt; 0) {</span>
<span>       return nil();</span>
<span>     }else{</span>

<span>     speed_t rate = B9600;</span>

<span>     switch (number::to&lt;number_t&gt;(speed)) {</span>
<span>         case 9600:</span>
<span>             rate = B9600;</span>
<span>             break;</span>
<span>         case 19200:</span>
<span>             rate = B19200;</span>
<span>             break;</span>
<span>         case 38400:</span>
<span>             rate = B38400;</span>
<span>             break;</span>
<span>         case 57600:</span>
<span>             rate = B57600;</span>
<span>             break;</span>
<span>         case 115200:</span>
<span>             rate = B115200;</span>
<span>             break;</span>
<span>         case 230400:</span>
<span>             rate = B230400;</span>
<span>             break;</span>
<span>         case 460800:</span>
<span>             rate = B460800;</span>
<span>             break;</span>
<span>         case 500000:</span>
<span>             rate = B500000;</span>
<span>             break;</span>
<span>         case 576000:</span>
<span>             rate = B576000;</span>
<span>             break;</span>
<span>         case 921600:</span>
<span>             rate = B921600;</span>
<span>             break;</span>
<span>         case 1000000:</span>
<span>             rate = B1000000;</span>
<span>             break;</span>
<span>         case 1152000:</span>
<span>             rate = B1152000;</span>
<span>             break;</span>
<span>         case 1500000:</span>
<span>             rate = B1500000;</span>
<span>             break;</span>
<span>         case 2000000:</span>
<span>             rate = B2000000;</span>
<span>             break;</span>
<span>         case 2500000:</span>
<span>             rate = B2500000;</span>
<span>             break;</span>
<span>         case 3000000:</span>
<span>             rate = B3000000;</span>
<span>             break;</span>
<span>         case 3500000:</span>
<span>             rate = B3500000;</span>
<span>             break;</span>
<span>         case 4000000:</span>
<span>             rate = B4000000;</span>
<span>             break;</span>
<span>         default: </span>
<span>             return nil();</span>
<span>      }</span>

<span>      cfsetispeed(&amp;toptions, rate);</span>
<span>      cfsetospeed(&amp;toptions, rate);</span>

<span>      // 8N1</span>
<span>      toptions.c_cflag &amp;= (tcflag_t)~PARENB;</span>
<span>      toptions.c_cflag &amp;= (tcflag_t)~CSTOPB;</span>
<span>      toptions.c_cflag &amp;= (tcflag_t)~CSIZE;</span>
<span>      toptions.c_cflag |= (tcflag_t)CS8;</span>
<span>      // no flow control</span>
<span>      toptions.c_cflag &amp;= (tcflag_t)~CRTSCTS;</span>

<span>      toptions.c_cflag |= (tcflag_t)CREAD | CLOCAL;  // turn on READ &amp; ignore ctrl lines</span>
<span>      toptions.c_iflag &amp;= (tcflag_t)~(IXON | IXOFF | IXANY); // turn off s/w flow ctrl</span>

<span>      toptions.c_lflag &amp;= (tcflag_t)~(ICANON | ECHO | ECHOE | ISIG); // make raw</span>
<span>      toptions.c_oflag &amp;= (tcflag_t)~OPOST; // make raw</span>

<span>      toptions.c_cc[VMIN]  = (cc_t)number::to&lt;number_t&gt;(v_min);</span>
<span>      toptions.c_cc[VTIME] = (cc_t)number::to&lt;number_t&gt;(v_time);</span>

<span>      if( tcsetattr(fd, TCSANOW, &amp;toptions) &lt; 0) {</span>
<span>       return nil();</span>
<span>      }else</span>
<span>        return obj&lt;number&gt;(fd);</span>
<span>    }</span>
<span>   }&#34;</span>)

(<span>defn</span> <span>open</span>
  ([port]
   (open-aux port 9600 0 20))
  ([port speed]
   (open-aux port speed 0 20))
  ([port speed v-min v-time]
   (open-aux port speed v-min v-time)))


(<span>defn</span> <span>write</span> [^number_t port ^byte data]
  <span>&#34;byte b[1] = {data};</span>
<span>   write(port, b, 1);&#34;</span>)

(<span>defn</span> <span>available</span> [^number_t port]
  <span>&#34;int bytes_ready;</span>
<span>   int op = ioctl(port, FIONREAD, &amp;bytes_ready);</span>
<span>   if (op == -1)</span>
<span>     return nil();</span>
<span>   return obj&lt;number&gt;(bytes_ready);&#34;</span>)

(<span>defn</span> <span>read</span> [^number_t port]
  <span>&#34;char b[1] = {0};</span>
<span>   ssize_t bytes_read = read(port, b, 1);</span>

<span>   if (bytes_read == -1)</span>
<span>     return nil();</span>
<span>   else</span>
<span>     return obj&lt;number&gt;(b[0]);&#34;</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-11">
<h3 id="sec-5-11">Control</h3>
<div id="outline-container-sec-5-11-1">
<h4 id="sec-5-11-1">State Machines</h4>
<div id="text-5-11-1">
<p>
This macro allows users to define state machines using the following
DSL,
</p>

<div>

<pre>(<span>defn</span> <span>^volatile</span> led-off [] <span>:off</span>)
(<span>defn</span> <span>^volatile</span> led-on  [] <span>:on</span>)

(<span>def</span> <span>light-switch</span>
  (fsm
   (led-off (<span>fn</span> [] true) led-on)
   (led-on  (<span>fn</span> [] true) led-off)))

(<span>def</span> <span>inf-loop</span>
  (<span>let</span> [setup  (<span>fn</span> [] <span>:setup</span>)
        exec   (<span>fn</span> [] <span>:exec</span>)]
    (fsm
     (setup  exec))))

(<span>deftest</span> fsm-test
  (<span>is</span> (<span>=</span> <span>:off</span> (light-switch)))
  (<span>is</span> (<span>=</span> <span>:on</span>  (light-switch)))
  (<span>is</span> (<span>=</span> <span>:off</span> (light-switch)))
  (<span>is</span> (<span>=</span> <span>:on</span>  (light-switch)))

  (<span>is</span> (<span>=</span> <span>:setup</span> (inf-loop)))
  (<span>is</span> (<span>=</span> <span>:exec</span>  (inf-loop)))
  (<span>is</span> (<span>=</span> <span>:exec</span>  (inf-loop)))
  (<span>is</span> (<span>=</span> <span>:exec</span>  (inf-loop))))
</pre>
</div>

<p>
Each transition takes a list of <code>fn</code>, <code>state</code> pairs, first function that
returns true, returns the next state.
</p>

<div>

<pre><span>class</span> <span>fsm</span> <span>final</span> : <span>public</span> <span>lambda_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>var</span> <span>state</span>;
  <span>var</span> <span>transitions</span>;
<span>public</span>:

  <span>inline</span> <span>fsm</span>(<span>ref</span> <span>s</span>, <span>ref</span> <span>t</span>) : state(s), transitions(t){ }

  <span>inline</span> <span>var</span> <span>invoke</span>(<span>ref</span>) <span>const</span> <span>final</span> {
    <span>return</span> var((<span>object</span>*)<span>this</span>).cast&lt;<span>fsm</span>&gt;()-&gt;yield();
  }

  <span>var</span> <span>yield</span>() {
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>var</span> <span>value</span>;

    <span>if</span> (state.is_type(<span>type_id</span>&lt;lambda_i&gt;))
      value = run(state);
    <span>else</span>
      value = state;

    <span>var</span> <span>next</span> = transitions.cast&lt;lambda_i&gt;()-&gt;invoke(<span>rt</span>::<span>list</span>(<span>state</span>));

    <span>if</span> (next.is_nil())
      next = state;

    state = next;
    <span>return</span> value;
  }

};
</pre>
</div>

<div>

<pre>(defobject fsm <span>&#34;fsm_o.h&#34;</span>)

(<span>defn</span> <span>new-fsm</span> [state transitions]
  <span>&#34;return obj&lt;fsm&gt;(state, transitions)&#34;</span>)

(<span>defmacro</span> <span>fsm</span> [&amp; transitions]
  (<span>let</span> [fsm-state (<span>gensym</span>)
        switch    (<span>-&gt;&gt;</span> (<span>reduce</span>
                        (<span>fn</span> [h v]
                          (<span>let</span> [[state &amp; conds] v
                                at-state `(<span>=</span> ~state ~fsm-state)
                                jmp (<span>if</span> (<span>=</span> (<span>count</span> conds) 1)
                                      (<span>first</span> conds)
                                      (<span>-&gt;&gt;</span> (<span>reduce</span>
                                            (<span>fn</span> [h v]
                                              (<span>let</span> [[check state] v]
                                                (<span>conj</span> h `(~check) state)))
                                            [&#39;cond] (<span>partition</span> 2 conds))
                                           (<span>apply</span> list)))]
                            (<span>conj</span> h at-state jmp)))
                        [&#39;cond] transitions)
                       (<span>apply</span> list))]
    `(new-fsm
      ~(<span>-&gt;</span> transitions first first)
      (<span>fn</span> [~fsm-state] ~switch))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-11-2">
<h4 id="sec-5-11-2">PID Control</h4>
<div id="text-5-11-2">
<p>
From Wikipedia: 
</p>

<blockquote>
<p>
A PID controller calculates an &#39;error&#39; value as the difference between
a measured [Input] and a desired setpoint. The controller attempts to
minimize the error by adjusting [an Output].
</p>
</blockquote>

<p>
From <a href="https://playground.arduino.cc/Code/PIDLibrary">PIDLibrary</a>,
</p>

<blockquote>
<p>
So, you tell the PID what to measure (the &#34;Input&#34;,) Where you want
that measurement to be (the &#34;Setpoint&#34;,) and the variable to adjust
that can make that happen (the &#34;Output&#34;.) The PID then adjusts the
output trying to make the input equal the setpoint.
</p>
</blockquote>

<div>

<pre>(<span>deftest</span> pid-controller-test
  (<span>let</span> [controller (pid-controller <span>:kp</span> 1
                                   <span>:ki</span> 1
                                   <span>:kd</span> 0
                                   <span>:set-point</span> 5
                                   <span>:bounds</span> [0 10 0 20]
                                   <span>:continuous</span> false)]

    (<span>is</span> (<span>=</span> 10 (controller 0)))
    (<span>is</span> (<span>=</span> 15 (controller 0)))
    (<span>is</span> (<span>=</span> 20 (controller 0)))
    (<span>is</span> (<span>=</span> 20 (controller 0))))

  (<span>let</span> [sp-fn (<span>fn</span> [] 5)
        controller (pid-controller <span>:kp</span> 1
                                   <span>:ki</span> 0
                                   <span>:kd</span> 1
                                   <span>:set-point</span> sp-fn
                                   <span>:bounds</span> [0 10 0 20]
                                   <span>:continuous</span> false)]

    (<span>is</span> (<span>=</span> 10 (controller 0)))
    (<span>is</span> (<span>=</span> 5  (controller 0)))))
</pre>
</div>

<p>
Ported from,
</p>

<div>

<pre><span>/*</span>
<span> * *********************************************************</span>
<span> * Copyright (c) 2009 - 2015, DHBW Mannheim - Tigers Mannheim</span>
<span> * Project: TIGERS - Sumatra</span>
<span> * Date: Jun 10, 2015</span>
<span> * Author(s): Nicolai Ommer &lt;<a href="https://ferret-lang.org/cdn-cgi/l/email-protection#dcb2b5bfb3b0bdb5f2b3b1b1b9aefaffeae8e7bbb1bdb5b0f2bfb3b1">nicolai.ommer@gmail.com</a>&gt;</span>
<span> * *********************************************************</span>
<span> */</span>

<span>/**</span>
<span> * </span><span>@author</span><span> Nicolai Ommer </span><span>&lt;<a href="https://ferret-lang.org/cdn-cgi/l/email-protection#fe90979d91929f97d09193939b8cd8ddc8cac599939f9792d09d9193">nicolai.ommer@gmail.com</a>&gt;</span>
<span> */</span>
</pre>
</div>

<div>

<pre>(defobject pid_controller <span>&#34;pid_controller_o.h&#34;</span>)
</pre>
</div>

<div>

<pre><span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
<span>class</span> <span>pid_controller</span> : <span>public</span> <span>lambda_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>mutable</span> <span>T</span> <span>setpoint</span>;
  <span>mutable</span> <span>T</span> <span>prev_error</span>;
  <span>mutable</span> <span>T</span> <span>total_error</span>;
  <span>mutable</span> <span>T</span> <span>error</span>;
  <span>mutable</span> <span>T</span> <span>result</span>;
  <span>mutable</span> <span>T</span> <span>input</span>;

  <span>T</span> <span>p</span>;
  <span>T</span> <span>i</span>;
  <span>T</span> <span>d</span>;
  <span>T</span> <span>maximum_output</span>;
  <span>T</span> <span>minimum_output</span>;
  <span>T</span> <span>maximum_input</span>;
  <span>T</span> <span>minimum_input</span>;
  <span>bool</span> <span>continuous</span>;
  <span>var</span> <span>setpoint_fn</span>;

  <span>void</span> <span>set_setpoint</span>(<span>ref</span> <span>p</span>) {
    <span>lock_guard</span> <span>guard</span>(lock);
    <span>T</span> <span>sp</span> = <span>number</span>::to&lt;<span>T</span>&gt;(p);
    <span>if</span> (maximum_input &gt; minimum_input) {
      <span>if</span> (sp &gt; maximum_input) {
        setpoint = maximum_input;
      } <span>else</span> <span>if</span> (sp &lt; minimum_input) {
        setpoint = minimum_input;
      } <span>else</span> {
        setpoint = sp;
      }
    } <span>else</span> {
      setpoint = sp;
    }
  }

  <span>var</span> <span>step</span>(<span>ref</span> <span>in</span>) {
    <span>lock_guard</span> <span>guard</span>(lock);
    input = <span>number</span>::to&lt;<span>T</span>&gt;(in);

    <span>// </span><span>Calculate the error signal</span>
    error = setpoint - input;

    <span>// </span><span>If continuous is set to true allow wrap around</span>
    <span>if</span> (continuous) {
      <span>if</span> (<span>rt</span>::abs(error) &gt; ((maximum_input - minimum_input) / real_t(2))) {
        <span>if</span> (error &gt; real_t(0)) {
          error = (error - maximum_input) + minimum_input;
        } <span>else</span> {
          error = (error + maximum_input) - minimum_input;
        }
      }
    }

    <span>/*</span>
<span>     * Integrate the errors as long as the upcoming integrator does</span>
<span>     * not exceed the minimum and maximum output thresholds</span>
<span>     */</span>
    <span>if</span> ((((total_error + error) * i) &lt; maximum_output) &amp;&amp;
        (((total_error + error) * i) &gt; minimum_output)) {
      total_error += error;
    }

    <span>// </span><span>Perform the primary PID calculation</span>
    result = ((p * error) + (i * total_error) + (d * (error - prev_error)));

    <span>// </span><span>Set the current error to the previous error for the next cycle</span>
    prev_error = error;

    <span>// </span><span>Make sure the final result is within bounds</span>
    <span>if</span> (result &gt; maximum_output) {
      result = maximum_output;
    } <span>else</span> <span>if</span> (result &lt; minimum_output) {
      result = minimum_output;
    }

    <span>return</span> obj&lt;number&gt;(result);
  }

<span>public</span>:
  <span>pid_controller</span>(<span>T</span> <span>kp</span>, <span>T</span> <span>ki</span>, <span>T</span> <span>kd</span>,
                 <span>T</span> <span>inMin</span>, <span>T</span> <span>inMax</span>, <span>T</span> <span>outMin</span>, <span>T</span> <span>outMax</span>,
                 <span>bool</span> <span>cont</span>,
                 <span>ref</span> <span>sp</span>):
    p(kp),
    i(ki),
    d(kd),
    maximum_output(outMax),
    minimum_output(outMin),
    maximum_input(inMax),
    minimum_input(inMin),
    continuous(cont){

    <span>if</span> (sp.is_type(<span>type_id</span>&lt;lambda_i&gt;)){
      setpoint_fn = sp;
      set_setpoint(run(setpoint_fn));
    }<span>else</span>{
      set_setpoint(sp);
    }

    prev_error = 0;
    total_error = 0;
    error = 0;
    result = 0;
    input = 0;
  }

  <span>var</span> <span>invoke</span>(<span>ref</span> <span>args</span>) <span>const</span> <span>final</span> {
    <span>if</span> (!setpoint_fn.is_nil())
      var((<span>object</span>*)<span>this</span>).cast&lt;<span>pid_controller</span>&lt;<span>T</span>&gt;&gt;()
        -&gt;set_setpoint(run(setpoint_fn));

    <span>return</span> var((<span>object</span>*)<span>this</span>).cast&lt;<span>pid_controller</span>&lt;<span>T</span>&gt;&gt;()
      -&gt;step(<span>rt</span>::first(args));
  }
};
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>new-pid-controller</span> [^real_t kp ^real_t ki ^real_t kd
                          ^real_t i-min ^real_t i-max
                          ^real_t o-min ^real_t o-max
                          ^bool_t cont
                          sp]
  <span>&#34;return obj&lt;pid_controller&lt;real_t&gt;&gt;(kp, ki, kd, i_min, i_max, o_min, o_max, cont, sp);&#34;</span>)

(<span>defmacro</span> <span>pid-controller</span> [&amp; options]
  (<span>let</span> [defaults {<span>:kp</span> 0 <span>:ki</span> 0 <span>:kd</span> 0 <span>:set-point</span> 0 <span>:bounds</span> [-1 1 -1 1] <span>:continuous</span> false}
        options (<span>merge</span> defaults (<span>apply</span> hash-map options))
        {<span>:keys</span> [container kp ki kd set-point bounds continuous]} options
        [in-min in-max out-min out-max] bounds]
    `(new-pid-controller ~kp ~ki ~kd ~in-min ~in-max ~out-min ~out-max ~continuous ~set-point)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-11-3">
<h4 id="sec-5-11-3">Moving Average Filter</h4>
<div id="text-5-11-3">
<p>
A First order IIR filter (exponentially decaying moving average
filter) to approximate a K sample first order IIR filter to
approximate a K sample moving average. This filter approximates a
moving average of the last K samples by setting the value of alpha to
1/K.
</p>

<div>

<pre>(<span>deftest</span> moving-average-filter-test
  (<span>let</span> [f (new-moving-average-filter 0.1)]

    (<span>is</span> (<span>=</span> 1.00 (f 10)))
    (<span>is</span> (<span>=</span> 1.90 (f 10)))
    (<span>is</span> (<span>=</span> 2.71 (f 10)))))
</pre>
</div>

<div>

<pre>(defobject moving_average_filter <span>&#34;moving_average_filter_o.h&#34;</span>)

(<span>defn</span> <span>new-moving-average-filter</span> [^real_t a]
  <span>&#34;return obj&lt;moving_average_filter&lt;real_t&gt;&gt;(a);&#34;</span>)
</pre>
</div>

<div>

<pre><span>template</span> &lt;<span>typename</span> <span>T</span>&gt;
<span>class</span> <span>moving_average_filter</span> : <span>public</span> <span>lambda_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>T</span> <span>alpha</span>;
  <span>mutable</span> <span>T</span> <span>avrg</span>;

  <span>var</span> <span>step</span>(<span>T</span> <span>data</span>) {
    <span>lock_guard</span> <span>guard</span>(lock);
    avrg = ((alpha * data) + ((1. - alpha) * avrg));
    <span>return</span> obj&lt;number&gt;(avrg);
  }

<span>public</span>:

  <span>explicit</span> <span>moving_average_filter</span>(<span>T</span> <span>a</span>) : alpha(a), avrg(0) { }

  <span>var</span> <span>invoke</span>(<span>ref</span> <span>args</span>) <span>const</span> <span>final</span> {
    <span>return</span> var((<span>object</span>*)<span>this</span>).cast&lt;<span>moving_average_filter</span>&lt;<span>T</span>&gt;&gt;()
      -&gt;step(<span>number</span>::to&lt;<span>T</span>&gt;(<span>rt</span>::first(args)));
  }
};
</pre>
</div>

<ul>
<li><a href="https://electronics.stackexchange.com/a/34426">http://electronics.stackexchange.com/a/34426</a>
</li>
<li><a href="https://stackoverflow.com/a/3761318">http://stackoverflow.com/a/3761318</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5-12">
<h3 id="sec-5-12">Arduino</h3>
<div id="outline-container-sec-5-12-1">
<h4 id="sec-5-12-1">pin-mode</h4>
<div id="text-5-12-1">
<p>
Configures the specified pin to behave either as an input or an
output.
</p>

<div>

<pre>(<span>defmacro</span> <span>pin-mode</span> [pin mode]
  (<span>let</span> [mode    (<span>-&gt;</span> mode name .toUpperCase)
        isr-pin (<span>gensym</span>)]
    `(<span>do</span>
       (<span>def</span> <span>~isr-pin</span> ~pin)
       (cxx
        ~(<span>str</span> <span>&#34;::pinMode(number::to&lt;int&gt;(&#34;</span> isr-pin <span>&#34;) , &#34;</span> mode <span>&#34;);&#34;</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-2">
<h4 id="sec-5-12-2">digital-write</h4>
<div id="text-5-12-2">
<p>
Write a HIGH or a LOW value to a digital pin.
</p>

<div>

<pre>(defnative digital-write [^number_t pin ^number_t val]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::digitalWrite(pin, val);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-3">
<h4 id="sec-5-12-3">digital-read</h4>
<div id="text-5-12-3">
<p>
Reads the value from a specified digital pin, either HIGH or LOW.
</p>

<div>

<pre>(defnative digital-read [^number_t pin]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;return obj&lt;number&gt;(::digitalRead(pin));&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-4">
<h4 id="sec-5-12-4">analog-write</h4>
<div id="text-5-12-4">
<p>
Writes an analog value (PWM wave) to a pin.
</p>

<div>

<pre>(defnative analog-write [^number_t pin ^number_t val]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::analogWrite(pin,val);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-5">
<h4 id="sec-5-12-5">analog-read</h4>
<div id="text-5-12-5">
<p>
Reads the value from the specified analog pin.
</p>

<div>

<pre>(defnative analog-read [^number_t pin]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;return obj&lt;number&gt;(::analogRead(pin));&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-6">
<h4 id="sec-5-12-6">analog-write-resolution</h4>
<div id="text-5-12-6">
<p>
Sets the resolution of the <b>analog-write</b>
</p>

<div>

<pre>(defnative analog-write-resolution [^number_t bit]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::analogWriteResolution(bit);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-7">
<h4 id="sec-5-12-7">analog-read-resolution</h4>
<div id="text-5-12-7">
<p>
Sets the size (in bits) of the value returned by <b>analog-read</b>.
</p>

<div>

<pre>(defnative analog-read-resolution [^number_t bit]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::analogReadResolution(bit);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-8">
<h4 id="sec-5-12-8">bounce</h4>
<div id="text-5-12-8">
<p>
Bounce object can be used to reliably read push buttons or mechanical
sensors which have contacts that &#34;chatter&#34; or &#34;bounce&#34;.
</p>

<div>

<pre>(<span>require</span> &#39;[ferret.arduino <span>:as</span> gpio])

(<span>def</span> <span>button</span> (gpio/new-bounce 7 250))

(<span>while</span> true
  (<span>when</span> (<span>pos?</span> (button))
    (<span>println</span> <span>&#34;Pressed!&#34;</span>))
  (sleep 250))
</pre>
</div>

<div>

<pre>(defobject bounce <span>&#34;arduino/bounce_o.h&#34;</span>)

(<span>defn</span> <span>new-bounce</span> [^number_t x ^number_t t-debounce]
  <span>&#34;return obj&lt;bounce&gt;(x, t_debounce);&#34;</span>)
</pre>
</div>

<div>

<pre><span>class</span> <span>bounce</span> <span>final</span> : <span>public</span> <span>lambda_i</span> {
  <span>mutex</span> <span>lock</span>;
  <span>void</span> (<span>bounce</span>::* <span>fsm_state</span>)();
  <span>byte</span> <span>state</span>;
  <span>byte</span> <span>last_state</span>;
  <span>unsigned</span> <span>long</span> <span>t_debounce</span>;
  <span>unsigned</span> <span>long</span> <span>t_last_debounce</span>;
  <span>byte</span> <span>pin</span>;

  <span>void</span> <span>debounce</span>(){
    <span>int</span> <span>reading</span> = digitalRead(pin);

    <span>// </span><span>reset the debouncing timer</span>
    <span>if</span> (reading != last_state){
      t_last_debounce = millis();
      last_state = reading;
    }

    <span>if</span> ((::millis() - t_last_debounce) &gt; t_debounce){
      <span>if</span> (reading == LOW)
        fsm_state = &amp;<span>bounce</span>::off;
      <span>else</span>
        fsm_state = &amp;<span>bounce</span>::on;
    }
  }

  <span>void</span> <span>init</span>(){
    pinMode(pin, INPUT);
    fsm_state = &amp;<span>bounce</span>::debounce;
  }

  <span>void</span> <span>on</span>(){
    state = 1;
    fsm_state = &amp;<span>bounce</span>::debounce;
  }

  <span>void</span> <span>off</span>(){
    state = 0;
    fsm_state = &amp;<span>bounce</span>::debounce;
  }

  <span>var</span> <span>step</span>(){
    <span>lock_guard</span> <span>guard</span>(lock);
    (<span>this</span>-&gt;*fsm_state)();
    <span>return</span> obj&lt;number&gt;(state);
  }

 <span>public</span>:

  <span>explicit</span> <span>bounce</span>(<span>number_t</span> <span>p</span>, <span>number_t</span> <span>t_db</span>) :
    fsm_state(&amp;<span>bounce</span>::init),
    state(0),
    last_state(0),
    t_debounce(t_db),
    t_last_debounce(millis()),
    pin(p)
    {}

  <span>var</span> <span>invoke</span>(<span>ref</span> <span>args</span>) <span>const</span> <span>final</span> {
    <span>return</span> var((<span>object</span>*)<span>this</span>).cast&lt;<span>bounce</span>&gt;()-&gt;step();
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-9">
<h4 id="sec-5-12-9">random</h4>
<div id="text-5-12-9">
<div>

<pre>(defnative random-seed [^number_t pin]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;randomSeed(analogRead(pin));&#34;</span>))

(defnative random [^number_t x]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;return obj&lt;number&gt;(random(x));&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-10">
<h4 id="sec-5-12-10">tone/noTone</h4>
<div id="text-5-12-10">
<p>
Generates a square wave of the specified frequency (and 50% duty
cycle) on a pin.
</p>

<div>

<pre>(defnative tone [^number_t pin ^number_t freq]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::tone(pin, freq);&#34;</span>))

(defnative no-tone [^number_t pin]
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      <span>&#34;::noTone(pin);&#34;</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-11">
<h4 id="sec-5-12-11">attach-interrupt</h4>
<div id="text-5-12-11">
<p>
Registers an interrupt function for the given pin and mode. See
<a href="https://www.arduino.cc/en/Reference/AttachInterrupt">attachInterrupt()</a> for more information.
</p>

<div>

<pre>(<span>require</span> &#39;[ferret.arduino <span>:as</span> gpio])

(<span>def</span> <span>input-pin</span>  3)
(<span>def</span> <span>debug-pin</span> 13)

(gpio/pin-mode debug-pin <span>:output</span>)

(<span>defn</span> <span>control-light</span> []
  (<span>-&gt;&gt;</span> (gpio/digital-read  input-pin)
       (gpio/digital-write debug-pin)))

(gpio/attach-interrupt input-pin <span>:change</span> control-light)

(forever
 (sleep 100))
</pre>
</div>

<div>

<pre>(<span>defmacro</span> <span>attach-interrupt</span> [pin mode callback]
  (<span>let</span> [mode    (<span>-&gt;</span> mode name .toUpperCase)
        isr-fn  (<span>gensym</span>)
        isr-pin (<span>gensym</span>)]
    `(<span>do</span>
       (<span>def</span> <span>~isr-fn</span>  ~callback)
       (<span>def</span> <span>~isr-pin</span> ~pin)
       (cxx
        ~(<span>str</span> <span>&#34;::pinMode(number::to&lt;int&gt;(&#34;</span> isr-pin <span>&#34;) , INPUT_PULLUP);\n&#34;</span>
              <span>&#34;auto isr_pin = digitalPinToInterrupt(number::to&lt;int&gt;(&#34;</span> isr-pin <span>&#34;));\n&#34;</span>
              <span>&#34;::attachInterrupt(isr_pin, [](){ run(&#34;</span> isr-fn <span>&#34;);}, &#34;</span> mode <span>&#34;);&#34;</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-12">
<h4 id="sec-5-12-12">no-interrupt</h4>
<div id="text-5-12-12">
<p>
Executes critical section with interrupts disabled.
</p>

<div>

<pre>(<span>defmacro</span> <span>no-interrupt</span> [&amp; body]
  `(no-interrupt-aux  (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="423c02202d263b">[email protected]</a>)))

(<span>defn</span> <span>no-interrupt-aux</span> [f]
  <span>&#34;noInterrupts();</span>
<span>   __result = run(f);</span>
<span>   interrupts();&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-13">
<h4 id="sec-5-12-13">detach-interrupt</h4>
<div id="text-5-12-13">
<p>
Turns off the given interrupt.
</p>

<pre>(detach-interrupt input-pin)
</pre>

<div>

<pre>(<span>defn</span> <span>detach-interrupt</span> [^number_t p]
  <span>&#34;detachInterrupt(digitalPinToInterrupt(p));&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-14">
<h4 id="sec-5-12-14">SPI</h4>
<p>
Serial Peripheral Interface (SPI) is a synchronous serial data
protocol used by microcontrollers for communicating with one or more
peripheral devices over short distances. It can also be used for
communication between two microcontrollers. This is a wrapper around
Arduino SPI library see <a href="https://www.arduino.cc/en/Reference/SPI">documentation</a> for more details.
</p>

<div id="outline-container-sec-5-12-14-1">
<h5 id="sec-5-12-14-1">Initialization</h5>
<div id="text-5-12-14-1">
<div>

<pre>(defnative spi-begin []
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      (<span>&#34;SPI.h&#34;</span>)
      <span>&#34;SPI.begin();&#34;</span>))

(<span>defn</span> <span>spi-end</span> []
  <span>&#34;SPI.end();&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-14-2">
<h5 id="sec-5-12-14-2">Settings</h5>
<div id="text-5-12-14-2">
<div>

<pre>(<span>defmacro</span> <span>spi-settings</span> [max-speed data-order data-mode]
  (<span>let</span> [speed      (<span>*</span> max-speed 1000000)
        data-order (<span>if</span> (<span>=</span> data-order <span>:msb-first</span>)
                     <span>&#34;MSBFIRST&#34;</span>
                     <span>&#34;LSBFIRST&#34;</span>)
        data-mode  (<span>condp</span> = data-mode
                     <span>:mode-0</span> <span>&#34;SPI_MODE0&#34;</span>
                     <span>:mode-1</span> <span>&#34;SPI_MODE1&#34;</span>
                     <span>:mode-2</span> <span>&#34;SPI_MODE2&#34;</span>
                     <span>:mode-3</span> <span>&#34;SPI_MODE3&#34;</span>)]
    `(cxx ~(<span>str</span> <span>&#34;return obj&lt;value&lt;SPISettings&gt;&gt;(&#34;</span> speed <span>&#34;,&#34;</span> data-order <span>&#34;,&#34;</span> data-mode <span>&#34;);&#34;</span>))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-14-3">
<h5 id="sec-5-12-14-3">Transaction</h5>
<div id="text-5-12-14-3">
<div>

<pre>(<span>defn</span> <span>with-spi-aux</span> [conf f]
  <span>&#34;SPI.beginTransaction(value&lt;SPISettings&gt;::to_reference(conf));</span>
<span>   __result = run(f);</span>
<span>   SPI.endTransaction();&#34;</span>)

(<span>defmacro</span> <span>with-spi</span> [conf &amp; body]
  `(with-spi-aux ~conf (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="0779476568637e">[email protected]</a>)))

(<span>defn</span> <span>spi-write</span> [^number_t val]
  <span>&#34;return obj&lt;number&gt;(SPI.transfer(val));&#34;</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-15">
<h4 id="sec-5-12-15">Wire</h4>
<div id="text-5-12-15">
<p>
This library allows you to communicate with I2C / TWI devices. See
<a href="https://www.arduino.cc/en/Reference/Wire">documentation</a> for more information.
</p>

<div>

<pre>(defnative wire-begin []
  (on <span>&#34;defined FERRET_HARDWARE_ARDUINO&#34;</span>
      (<span>&#34;Wire.h&#34;</span>)
      <span>&#34;Wire.begin();&#34;</span>))

(<span>defn</span> <span>with-wire-aux</span> [^number_t addr f]
  <span>&#34;Wire.beginTransmission(addr);</span>
<span>   __result = run(f);</span>
<span>   Wire.endTransmission();&#34;</span>)

(<span>defmacro</span> <span>with-wire</span> [addr &amp; body]
  `(with-wire-aux ~addr (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="7907391b161d00">[email protected]</a>)))

(<span>defn</span> <span>wire-write</span> [^number_t val]
  <span>&#34;Wire.write(val);&#34;</span>)

(<span>defn</span> <span>wire-read</span> []
  <span>&#34;return obj&lt;number&gt;(Wire.read());&#34;</span>)

(<span>defn</span> <span>wire-request-from</span> [^number_t addr ^number_t bytes]
  <span>&#34;Wire.requestFrom(addr, bytes);&#34;</span>)

(<span>defn</span> <span>wire-available</span> []
  <span>&#34;__result = obj&lt;number&gt;(Wire.available());&#34;</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-16">
<h4 id="sec-5-12-16">Watchdog Timer</h4>
<p>
A watchdog timer is an electronic timer that is used to detect and
recover from program malfunctions. During normal operation, the
program regularly resets the watchdog timer to prevent it from
elapsing, or &#34;timing out&#34;.
</p>

<div id="outline-container-sec-5-12-16-1">
<h5 id="sec-5-12-16-1">AVR</h5>
<div id="text-5-12-16-1">
<div>

<pre>(<span>require</span> &#39;[ferret.arduino.avr <span>:as</span> avr])

<span>;; </span><span>initialize </span>
(avr/wdt-enable 1000)

(<span>while</span> true
  <span>;; </span><span>do stuff</span>
  (avr/wdt-reset))
</pre>
</div>

<div>

<pre>(<span>defmacro</span> <span>wdt-enable</span> [timer]
  (<span>let</span> [timer (<span>condp</span> = timer
                15   <span>&#34;WDTO_15MS&#34;</span>
                30   <span>&#34;WDTO_30MS&#34;</span>
                60   <span>&#34;WDTO_60MS&#34;</span>
                120  <span>&#34;WDTO_120MS&#34;</span>
                250  <span>&#34;WDTO_250MS&#34;</span>
                500  <span>&#34;WDTO_500MS&#34;</span>
                1000 <span>&#34;WDTO_1S&#34;</span>
                2000 <span>&#34;WDTO_2S&#34;</span>
                4000 <span>&#34;WDTO_4S&#34;</span>
                8000 <span>&#34;WDTO_8S&#34;</span>)]
    `(cxx ~(<span>str</span> <span>&#34;wdt_enable(&#34;</span> timer <span>&#34;)&#34;</span>))))

(defnative wdt-reset []
  (on <span>&#34;defined __AVR_ARCH__&#34;</span>
      (<span>&#34;avr/wdt.h&#34;</span>)
      <span>&#34;wdt_reset();&#34;</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-12-17">
<h4 id="sec-5-12-17">ESP32</h4>
<div id="text-5-12-17">
<p>
Bindings for Arduino core for ESP32 WiFi chip.
</p>

<div>

<pre>(native-header <span>&#34;WiFi.h&#34;</span>
               <span>&#34;HTTPClient.h&#34;</span>)

(<span>defn</span> <span>wifi-connect</span> [^c_str ssid ^c_str password]
  <span>&#34;WiFi.begin(ssid, password);</span>
<span>   while (WiFi.status() != WL_CONNECTED)</span>
<span>     delay(100);&#34;</span>)

(<span>defn</span> <span>http-get</span>
  ([url]
   (http-get url {}))
  ([^c_str u opts]
   <span>&#34;HTTPClient http;</span>
<span>    String url(u);</span>

<span>    // check :query-params</span>
<span>    if (var params = run(opts, obj&lt;keyword&gt;(1313))){</span>
<span>       url += \&#34;?\&#34;;</span>
<span>       for_each(param, params){</span>
<span>          auto key = string::to&lt;String&gt;(rt::first(param));</span>
<span>          auto val = string::to&lt;String&gt;(rt::first(rt::rest(param)));</span>
<span>          url += key + \&#34;=\&#34;+ val + \&#34;&amp;\&#34;;</span>
<span>       }</span>
<span>    }</span>

<span>    http.begin(url);</span>
<span>    auto http_status = http.GET();</span>

<span>    var data;</span>
<span>    if(http_status == HTTP_CODE_OK)</span>
<span>      data = obj&lt;string&gt;(http.getString().c_str());</span>

<span>    http.end();</span>
<span>    return rt::list(obj&lt;number&gt;(http_status), data);&#34;</span>))

(<span>defn</span> <span>http-post</span>
  ([url]
   (http-post url {}))
  ([^c_str url opts]
   <span>&#34;HTTPClient http;</span>
<span>    http.begin(url);</span>

<span>    //check :headers</span>
<span>    if (var headers = run(opts, obj&lt;keyword&gt;(790))){</span>
<span>       for_each(header, headers){</span>
<span>          auto key = string::to&lt;String&gt;(rt::first(header));</span>
<span>          auto val = string::to&lt;String&gt;(rt::first(rt::rest(header)));</span>
<span>          http.addHeader(key,val);</span>
<span>       }</span>
<span>    }</span>

<span>    auto http_status = http.POST(string::to&lt;String&gt;(run(opts, obj&lt;keyword&gt;(488))));</span>

<span>    var data;</span>
<span>    if(http_status == HTTP_CODE_OK || http_status == HTTP_CODE_CREATED)</span>
<span>      data = obj&lt;string&gt;(http.getString().c_str());</span>

<span>    http.end();</span>
<span>    return rt::list(obj&lt;number&gt;(http_status), data);&#34;</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-13">
<h3 id="sec-5-13">Testing</h3>
<div id="outline-container-sec-5-13-1">
<h4 id="sec-5-13-1">assert</h4>
<div id="text-5-13-1">
<p>
Evaluates expr and aborts if it does not evaluate to logical true.
</p>

<div>

<pre>(<span>defn</span> <span>aborted?</span> [return-code]
  (<span>=</span> 134 return-code))

(<span>deftest</span> test-unit-test
  (<span>is</span> (aborted? (check-form &#39;((<span>assert</span> (<span>=</span> 2 1))))))
  (<span>is</span> (<span>zero?</span>    (check-form &#39;((<span>assert</span> (<span>=</span> 2 1))) {<span>:release</span> true}))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>assert-aux</span> [f cb]
  (<span>when</span> (<span>not</span> (f))
    (cb)))

(<span>defmacro</span> <span>assert</span>
  ([exp]
   `(~&#39;assert
     ~exp
     (~&#39;println
      <span>&#34;err&#34;</span> ~(<span>-&gt;</span> exp pr-str (clojure.string/escape {\\ <span>&#34;\\\\&#34;</span>})))
     (system-abort)))
  ([exp &amp; callback]
   `(assert-aux (<span>fn</span> [] ~exp) (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="82fcc2e1e3eeeee0e3e1e9">[email protected]</a>))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-13-2">
<h4 id="sec-5-13-2">deftest</h4>
<div id="text-5-13-2">
<p>
Support for Clojure style unit testing. See <a href="#sec-6-1">Unit Testing</a> for more
information.
</p>

<div>

<pre>(<span>defn</span> <span>aborted?</span> [return-code]
  (<span>=</span> 134 return-code))

(<span>deftest</span> test-unit-test
  (<span>is</span> (<span>zero?</span>    (check-form &#39;((<span>run-all-tests</span>)))))
  (<span>is</span> (aborted? (check-form &#39;((<span>deftest</span> some-test
                                (<span>is</span> (<span>=</span> 2 3)))
                              (<span>run-all-tests</span>)))))
  (<span>is</span> (<span>zero?</span>    (check-form &#39;((<span>deftest</span> some-test
                                (<span>is</span> (<span>=</span> 2 2)))
                              (<span>run-all-tests</span>)))))
  (<span>is</span> (aborted? (check-form &#39;((<span>deftest</span> some-test
                                (<span>is</span> (<span>=</span> 5 (<span>apply</span> + (<span>list</span> 1 2 3)))))
                              (<span>run-all-tests</span>)))))

  (<span>is</span> (<span>zero?</span>    (check-form &#39;((<span>deftest</span> some-test
                                (<span>is</span> (<span>=</span> 6 (<span>apply</span> + (<span>list</span> 1 2 3)))))
                              (<span>run-all-tests</span>))))))
</pre>
</div>

<div>

<pre>(<span>defn</span> <span>is-aux-expect</span> [ex-fb form-fn form-str]
  (<span>let</span> [expect (ex-fb)
        got  (form-fn)]
    (<span>when</span> (<span>not=</span>  expect got)
      (<span>println</span> <span>&#34;err&#34;</span> form-str <span>&#34;\n exp&#34;</span> expect <span>&#34;\n got&#34;</span> got)
      (system-abort))))

(<span>defmacro</span> <span>is</span> [form]
  (<span>cond</span> (<span>=</span> (<span>first</span> form) &#39;=)
        (<span>let</span> [[_ expected form] form]
          `(is-aux-expect
            (<span>fn</span> [] ~expected) (<span>fn</span> [] ~form)
            ~(<span>-&gt;</span> form pr-str (clojure.string/escape {\\ <span>&#34;\\\\&#34;</span>}))))
        <span>:default</span> `(~&#39;assert ~form)))

(<span>defmacro</span> <span>deftest</span> [name &amp; exprs]
  (<span>defonce</span> <span>fir-unit-tests</span> (<span>atom</span> []))
  (<span>swap!</span> fir-unit-tests conj name)
  `(<span>def</span> <span>~name</span> (<span>fn</span> [] <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="0b754b6e737b7978">[email protected]</a>)))

(<span>defmacro</span> <span>run-all-tests</span> []
  (<span>if</span> (<span>bound?</span> #&#39;fir-unit-tests)
    `(<span>do</span> <a href="https://ferret-lang.org/cdn-cgi/l/email-protection" data-cfemail="4b350b">[email protected]</a>(<span>map</span> #(<span>list</span> %) @fir-unit-tests)
         (system-exit))
    `(system-exit)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-14">
<h3 id="sec-5-14">Compiler</h3>
<div id="outline-container-sec-5-14-1">
<h4 id="sec-5-14-1">configure-runtime!</h4>
<div id="text-5-14-1">
<p>
Configure Ferret Runtime options. See table in <a href="#sec-4-6">Configuration</a> section.
</p>

<div>

<pre>(<span>defmacro</span> <span>configure-runtime!</span> [&amp; body]
  `(native-define ~(<span>-&gt;&gt;</span> (<span>partition</span> 2 body)
                        (<span>map</span> #(<span>str</span> <span>&#34;#define &#34;</span> (<span>first</span> %) <span>&#34; &#34;</span> (<span>second</span> %) <span>&#34;\n&#34;</span>))
                        (<span>list</span>))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-14-2">
<h4 id="sec-5-14-2">configure-ferret!</h4>
<div id="text-5-14-2">
<p>
Embed compilations options.
</p>

<div>

<pre>(<span>defmacro</span> <span>configure-ferret!</span> [&amp; body]
  `(native-define ~(<span>str</span> <span>&#34;// build-conf-begin\n&#34;</span>
                        <span>&#34;//&#34;</span> (<span>str</span> (<span>apply</span> hash-map body)) <span>&#34;\n&#34;</span>
                        <span>&#34;// build-conf-end\n&#34;</span>)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6">
<h2 id="sec-6">Testing</h2>
<div id="outline-container-sec-6-1">
<h3 id="sec-6-1">Unit Testing</h3>
<div id="text-6-1">
<p>
The reliability and robustness of Ferret is achieved in part by
thorough and careful testing. Ferret lisp has built-in support for
unit testing using an API that mimics <a href="https://clojure.github.io/clojure/clojure.test-api.html">clojure.test</a>.
</p>

<p>
The core of the library is the &#34;is&#34; macro, which lets you make
assertions of any arbitrary expression, which will print a message if
the assertion fails.
</p>

<div>

<pre>(<span>is</span> (<span>=</span> 42 (meaning-of-life)))
</pre>
</div>

<p>
These assertions can be grouped using a <a href="#sec-5-13-2">deftest</a> form which defines a
test function with no arguments. Tests can be defined separately from
the rest of the code, even in a different module.
</p>

<div>

<pre>(<span>defn</span> <span>meaning-of-life</span> [] 42)

(<span>deftest</span> life-test
  (<span>is</span> (<span>=</span> 42 (meaning-of-life))))

(<span>run-all-tests</span>)
</pre>
</div>

<p>
This will create a function named <code>life-test</code>, which can be called
like any other function.  Therefore, tests can be grouped and
composed, in a style similar to the test framework in Peter Seibel&#39;s
&#34;Practical Common Lisp&#34; Finally all tests in the current program can
be run using the <a href="#sec-5-13-2">run-all-tests</a>.
</p>
</div>
</div>

<div id="outline-container-sec-6-2">
<h3 id="sec-6-2">Continuous Integration</h3>
<div id="text-6-2">
<p>
Each new commit is tested against a set of assertions.  Tests are run
by the CI system for the following compilers/frameworks, 
</p>

<ul>
<li>GCC 5
</li>
<li>Clang 7.0
</li>
<li>Arduino 1.8.7
</li>
</ul>

<p>
Most tests are done using the built in unit testing framework, but certain
tests, those that target the workings of the compiler are easier to do
using <code>clojure.test</code> framework by compiling forms using Ferret then
comparing the their runtime output to their expected output. All
generated code is statically checked using <code>cppcheck</code> and tested
against memory leaks and undefined behavior.
</p>

<p>
Build options,
</p>

<ul>
<li>-std=c++11
</li>
<li>-pedantic
</li>
<li>-Werror
</li>
<li>-Wall
</li>
<li>-Wextra
</li>
<li>-Wconversion
</li>
<li>-Wpointer-arith
</li>
<li>-Wmissing-braces
</li>
<li>-Woverloaded-virtual
</li>
<li>-Wuninitialized
</li>
<li>-Winit-self
</li>
<li>-Wsign-conversion
</li>
<li>-fno-rtti
</li>
<li>-fsanitize=undefined,address,leak
</li>
<li>-ggdb
</li>
</ul>

<p>
Static code analysis (cppcheck) options,
</p>

<ul>
<li>–std=c++11
</li>
<li>–template=gcc
</li>
<li>–enable=all
</li>
<li>–error-exitcode=1
</li>
</ul>

<p>
Valgrind options,
</p>

<ul>
<li>–quiet
</li>
<li>–leak-check=full
</li>
<li>–error-exitcode=1
</li>
<li>–track-origins=yes
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-7">
<h2 id="sec-7">Roadmap</h2>
<div id="outline-container-sec-7-1">
<h3 id="sec-7-1">Compiler</h3>
<div id="text-7-1">
<ul>
<li><b>fn</b>
<ul>
<li>Pre/Post conditions for functions.
<ul>
<li>By default print error and abort. 
</li>
<li>Let user define a callback function.
</li>
</ul>
</li>
<li>Documentation String
</li>
</ul>
</li>
<li><b>deps.clj</b>
<ul>
<li>Support private git repositories. (HTTPS / SSH)
</li>
<li>Recursively resolve dependencies of dependencies.
</li>
</ul>
</li>
<li><b>Escape Analysis</b> 
<ul>
<li>Tag if an object escapes via metadata
</li>
<li>Emit stack object types for escaped variables.
</li>
<li>Certain forms generate functions that never escape. These can be
generated on the stack.
</li>
<li>Extend escape analysis for other types. Currently escape
analysis is only used for functions.    
</li>
<li>Since Ferret does whole-program compilation. Implement
optimizations from Stalin Scheme compiler.
<ul>
<li><a href="https://github.com/barak/stalin">https://github.com/barak/stalin</a>
</li>
<li><a href="https://news.ycombinator.com/item?id=8214343">https://news.ycombinator.com/item?id=8214343</a>
</li>
<li><a href="https://justindomke.wordpress.com/2009/02/23/the-stalin-compiler/">https://justindomke.wordpress.com/2009/02/23/the-stalin-compiler/</a>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Multimethods</b>
</li>
<li><b>Hardware Support</b> - On an unknown arch Ferret will run in safe
mode. See <a href="#sec-2-2">Hardware / Operating System Support</a>.
<ul>
<li>Support for user supplied machine architectures.
</li>
<li><code>defnative</code> calls in <code>compiler.core</code> are arch dependent.
<ul>
<li>Aggregate <code>on</code> sections from multiple modules.
</li>
<li>Autogenerate combined <code>defnative</code>.
</li>
</ul>
</li>
<li>Runtime contains arch specific <code>ifdefs</code>
</li>
<li><code>arch.clj</code> similar to <code>deps.clj</code> where platform specific calls
can be loaded from a file.
</li>
<li>Or user tags functions via metadata that provides overrides for
arch specific core functions.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-2">
<h3 id="sec-7-2">Data Structures</h3>
<div id="text-7-2">
<ul>
<li><b>atomic</b> 
<ul>
<li>Implement add-watch
<ul>
<li><a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/ARef.java">https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/ARef.java</a>
</li>
<li><a href="https://clojuredocs.org/clojure.core/add-watch">https://clojuredocs.org/clojure.core/add-watch</a>
</li>
<li><a href="https://stackoverflow.com/questions/13371123/how-do-refs-notify-its-watches-in-clojure">https://stackoverflow.com/questions/13371123/how-do-refs-notify-its-watches-in-clojure</a>
</li>
<li><a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Atom.java">https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Atom.java</a>
</li>
</ul>
</li>
<li>Current implementation uses <code>std::mutex</code> for
synchronization. Clojure uses <code>AtomicReference</code>, <code>std::atomic</code> 
provides same behaviour.
<ul>
<li><a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Atom.java">https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Atom.java</a>
</li>
<li><a href="http://www.cplusplus.com/reference/atomic/">http://www.cplusplus.com/reference/atomic/</a>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Tagged Pointers</b>
<ul>
<li><a href="https://www.snellman.net/blog/archive/2017-09-04-lisp-numbers/">https://www.snellman.net/blog/archive/2017-09-04-lisp-numbers/</a>
</li>
<li><a href="https://drmeister.wordpress.com/2015/05/16/tagged-pointers-and-immediate-fixnums-characters-and-single-floats-in-clasp/">https://drmeister.wordpress.com/2015/05/16/tagged-pointers-and-immediate-fixnums-characters-and-single-floats-in-clasp/</a>
</li>
<li><a href="https://nikic.github.io/2012/02/02/Pointer-magic-for-efficient-dynamic-value-representations.html">https://nikic.github.io/2012/02/02/Pointer-magic-for-efficient-dynamic-value-representations.html</a>
</li>
<li><a href="https://foonathan.net/blog/2016/12/28/variant.html">https://foonathan.net/blog/2016/12/28/variant.html</a>
</li>
<li><a href="https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations">http://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations</a>
</li>
<li><a href="https://blogs.oracle.com/jrose/fixnums-in-the-vm">https://blogs.oracle.com/jrose/fixnums-in-the-vm</a>
</li>
</ul>
</li>
<li><b>Memory Pool</b> 
<ul>
<li>Allow chainable allocators. i.e Use system
allocator until OOM then switch to pool allocator or vice versa.
<ul>
<li><a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U&amp;t=2457s">CppCon 2015: Andrei Alexandrescu std::allocator</a>
</li>
<li><a href="https://github.com/FelixPetriconi/AllocatorBuilder">Allocator Builder</a>
</li>
<li><a href="https://github.com/mtrebi/memory-allocators">https://github.com/mtrebi/memory-allocators</a>
</li>
<li><a href="https://www.gamedev.net/articles/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/">C++: Custom memory allocation</a>
</li>
<li><a href="http://brnz.org/hbr/?p=1735">A little bit of floating point in a memory allocator — Part 1: Background</a>
</li>
<li><a href="https://www.sqlite.org/malloc.html">https://www.sqlite.org/malloc.html</a>
</li>
</ul>
</li>
<li>Ability to run functions on different Memory Pools.
<ul>
<li>Improved data locality and safety.
</li>
<li>Optionally disable reference counting to improve performance since
whole pool can be garbage collected when done.
</li>
<li>Stalin also does very good lifetime analysis to reduce the
amount of garbage needing collection. i.e. it will compute good
places in the stack to create a heap, then objects that are
determined to be born and die within that sub-stack are
allocated from that heap. When the stack unwinds past that
point, the entire local heap can be released in one fell swoop.
</li>
</ul>
</li>
</ul>
</li>
<li>C++ implementations of Clojure&#39;s persistent data structures. 
<ul>
<li><a href="https://github.com/mninja/persistent-data-structures">https://github.com/mninja/persistent-data-structures</a>
</li>
<li><a href="https://news.ycombinator.com/item?id=13049843">Immer: immutable and persistent data structures for C++</a>
</li>
<li><a href="https://www.reddit.com/r/cpp/comments/8utg8u/postmodern_immutable_vector_now_boost_licensed/">Postmodern Immutable Vector</a>
</li>
</ul>
</li>
<li><b>Finger Trees</b> - As basis for other functional data structures
i.e. Set, Vector
<ul>
<li><a href="http://www.staff.city.ac.uk/~ross/papers/FingerTree.html">http://www.staff.city.ac.uk/~ross/papers/FingerTree.html</a>
</li>
<li><a href="https://github.com/clojure/data.finger-tree/tree/4262f5899a6932b5ab48705c523a15328f902ff6">https://github.com/clojure/data.finger-tree/tree/4262f5899a6932b5ab48705c523a15328f902ff6</a>
</li>
<li><a href="https://www.youtube.com/watch?v=UXdr_K0Lwg4">https://www.youtube.com/watch?v=UXdr_K0Lwg4</a>
</li>
</ul>
</li>
<li><b>Channels</b>
<ul>
<li><a href="https://www.reddit.com/r/cpp/comments/6p3zch/diy_channels/">https://www.reddit.com/r/cpp/comments/6p3zch/diy_channels/</a>
</li>
</ul>
</li>
<li><b>Co-Operative Multitasking</b> - For Embedded Systems.
<ul>
<li><a href="http://soda.swedish-ict.se/2372/1/SICS-T--2005-05--SE.pdf">http://soda.swedish-ict.se/2372/1/SICS-T--2005-05--SE.pdf</a>
</li>
<li><a href="https://forum.pjrc.com/threads/25628-Lightweight-Teensy3-x-Fibers-Library-(C-)-Available">https://forum.pjrc.com/threads/25628-Lightweight-Teensy3-x-Fibers-Library-(C-)-Available</a>
</li>
<li><a href="https://github.com/ve3wwg/teensy3_fibers/blob/1ba0c1e79a423f097e12e6c4176b40cf9d4f44e4/fibers.cpp">https://github.com/ve3wwg/teensy3_fibers/blob/1ba0c1e79a423f097e12e6c4176b40cf9d4f44e4/fibers.cpp</a>
</li>
<li><a href="https://news.ycombinator.com/item?id=11323660">Simple coroutines for games in C++</a>
</li>
<li><a href="https://hackage.haskell.org/package/Workflow-0.8.3/docs/Control-Workflow.html">Control.Workflow</a>
</li>
<li><a href="https://news.ycombinator.com/item?id=9402314">Coroutines in C with Arbitrary Arguments</a>
</li>
<li><a href="https://github.com/akouz/a_coos/tree/1a56f686a24c2085fe82986d568f4577b068c0da">https://github.com/akouz/a_coos/tree/1a56f686a24c2085fe82986d568f4577b068c0da</a>
</li>
<li><a href="https://github.com/mikaelpatel/Arduino-Scheduler/tree/d09521f7dc1447ddaea09e32413cf6e96e9e6816">https://github.com/mikaelpatel/Arduino-Scheduler/tree/d09521f7dc1447ddaea09e32413cf6e96e9e6816</a>
</li>
<li><a href="http://dotat.at/cgi/git/picoro.git/tree">http://dotat.at/cgi/git/picoro.git/tree</a>
</li>
</ul>
</li>
<li><b>Unbounded Precision Integers</b>
<ul>
<li><a href="https://rushter.com/blog/python-integer-implementation/">Python internals: Arbitrary-precision integer implementation</a>
</li>
<li><a href="https://github.com/kokke/tiny-bignum-c">https://github.com/kokke/tiny-bignum-c</a>
</li>
<li><a href="https://gist.github.com/nvurgaft/0344b2aa4704219d07005e4d8b1d88a2">https://gist.github.com/nvurgaft/0344b2aa4704219d07005e4d8b1d88a2</a>
</li>
<li><a href="http://www.more-magic.net/posts/numeric-tower-part-2.html">CHICKEN&#39;s numeric tower: part 2</a>
</li>
<li><a href="https://web.archive.org/web/20101208222557/http://www.mactech.com/articles/mactech/Vol.08/08.03/BigNums/index.html">Arbitrarily Large Bignums</a>
</li>
<li>From p.11: PICOBIT: A Compact Scheme System for Microcontrollers
<ul>
<li>Larger values are needed in some embedded applications.
<ul>
<li>48 bit integers to store MAC addresses.
</li>
<li>SHA family of cryptographic hashing functions, which need
values up to 512 bits wide.
</li>
<li>If an application keeps track of time at the microsecond level
using a 32-bit value, a wraparound will occur every hour or
so.
</li>
</ul>
</li>
<li>Unbounded precision integers are encoded in PICOBIT as linked
lists of 16 bit values. At the end of each list is either the
integer 0 or -1, to represent the sign. 0, -1 and other small
integers have dedicated encodings and do not need to be
represented as linked lists. The use of this “little-endian”
representation simplifies the bignum algorithms in particular
for numbers of different lengths.
</li>
<li>On versions of PICOBIT which do not support unbounded precision
integers (including PICOBIT Light), integers are limited to 24
bits, and encoded directly in the object.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>








</div>
</div><div id="postamble">
<p>Created: 2020-01-29 Wed 09:43</p>
<p><a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="https://orgmode.org">Org</a> mode 8.2.10)</p>
<p><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div></div>
  </body>
</html>
