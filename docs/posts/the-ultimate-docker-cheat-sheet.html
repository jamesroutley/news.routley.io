<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devopscycle.com/blog/the-ultimate-docker-cheat-sheet/">Original</a>
    <h1>The Ultimate Docker Cheat Sheet</h1>
    
    <div id="readability-page-1" class="page"><div>
	<div data-padding-pos="all" data-has-bg-color="false" data-bg-color="" data-bg-opacity="1" data-animation="" data-delay="0">
		<div>
			<div>
				
<div>
	<div>
		<p>Get your Docker Cheat Sheet as <a href="http://devopscycle.com/wp-content/uploads/sites/4/2023/12/the-ultimate-docker-cheat-sheet-1.pdf" target="_blank" rel="noreferrer noopener" data-type="attachment" data-id="902">PDF</a> or as an <a href="http://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-4.png" target="_blank" rel="noreferrer noopener" data-type="attachment" data-id="900">image</a>. To follow this article, make sure your development machine has <a href="https://docs.docker.com/get-docker/" target="_blank" rel="noreferrer noopener">Docker installed</a>. In this blog post, we write our own Dockerfiles, learn how to create images, and finally run them as container. The complete source code is available on <a href="https://github.com/aichbauer/the-ultimate-docker-cheat-sheet" target="_blank" rel="noreferrer noopener">GitHub</a>.</p>

	</div>
</div>



<h2>Table of Contents</h2>




<h2 id="download-the-ultimate-docker-cheat-sheet">Download The Ultimate Docker Cheat Sheet</h2>
<div>
	<p>Please <a href="http://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-1.pdf" target="_blank" rel="noreferrer noopener" data-type="attachment" data-id="902">download</a> your Docker Cheat Sheet to follow along with this article. You are also welcome to share it with your colleagues and friends.</p>
</div>



<div data-max-width="100%" data-max-width-mobile="default" data-shadow="none" data-animation="none">
      <div>
        <div> 
          <p><a href="http://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-4.png" target="_blank">
              <img data-delay="0" height="1087" width="768" data-animation="none" src="https://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-copy-768x1087.webp" alt="The Ultimate Docker Cheat Sheet" srcset="https://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-copy-768x1087.webp 768w, https://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-copy-212x300.webp 212w, https://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-copy-724x1024.webp 724w, https://devopscycle.com/wp-content/uploads/sites/4/2023/11/the-ultimate-docker-cheat-sheet-copy.webp 800w" sizes="(max-width: 768px) 100vw, 768px"/>
            </a>
          </p>
        </div>
      </div>
      </div><h2 id="what-is-the-difference-between-a-dockerfile-an-image-and-a-container">Do You Want More Resources Like This?</h2>
<div>
	<p>Be the first to join our new <a href="https://discord.gg/7xpRbG2gY9" target="_blank" rel="noopener">community</a> and stay up-to-date on the latest DevOps topics (free cookies for the first 42 arrivals!). Don’t miss out on any new resources by signing up for our <a href="#newsletter">newsletter</a>. Get access to our latest resources and insights directly in your inbox!</p>
</div>



<h2>What Is The Difference Between A Dockerfile, An Image And A Container?</h2>
<div>
	<p>All these things build on top of each other. You need a Dockerfile to create an image, and you need an Image to create a Container.</p>
</div>




<div>
	<div>
		<ul>
<li><strong>Dockerfile:</strong> The first step in using Docker is writing a Dockerfile. It is an essential blueprint for constructing Docker images. It is a text file, is usually named “Dockerfile” without any extension, and contains a series of instructions. Each line in this file represents a new instruction, forming a stack of layers. Each layer is cache-able. When you build an image twice, it will use the cache. When you change a line in the file, it rebuilds all instructions after and including the change.</li>
<li><strong>Image:</strong> Building a Dockerfile outputs a Docker image. You can think of an image like an executable. Just like clicking an icon (executable) on your desktop to launch an application. You can start an image to launch a container. The Docker image encapsulates your application code and all its dependencies. This includes the runtime and system libraries. It is a self-contained unit that ensures consistency and portability across various environments. For example, your development machine and your production server.</li>
<li><strong>Container:</strong> This is a dynamic, running instance of a Docker image. An executed image spawns a container with the command in the Dockerfile. Important to note: one image can give life to many containers. If Linux is your operating system, the Docker container will run as a process on the host machine. If you have a Windows or macOS machine, docker will run in a virtual machine (VM). The container will use the same kernel, either the kernel of Linux or the VM on Windows or macOS. The container itself is not a virtual machine. The container cannot see other processes of the host and has its own file system. This is why it seems as it is a virtual machine. But in reality, it shares the kernel of the host machine (or the kernel of the VM).</li>
</ul>
	</div>
</div>




<div>
	<p>In conclusion: the Dockerfile is the base for an image, and an image is used to create a container. A container is running as a process on the host machine. Yet, it has its own file system and is separated from the other processes.</p>
</div>



<h2 id="how-do-you-create-a-dockerfile">How Do You Create A Dockerfile?</h2>
<div>
	<p>To generate a Dockerfile, you can create a plain text file. This article will use the command line for it:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-1" data-shcb-language-name="Dockerfile" data-shcb-language-slug="dockerfile"><code><span># create a new file in your current working directory called Dockerfile</span>
$ touch Dockerfile
<span># open the file in your favorite editor (we are using Visual Studio Code)</span>
<span># if you do not have the code command installed, you will need to open it manually</span>
$ code Dockerfile</code><small id="shcb-language-1"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>A Dockerfile holds all the instructions to build, start and run your application. Every command that you otherwise need to execute manually is written in a single file. It starts by using a base image. This is usually a small Linux distribution like alpine. If you have to execute a binary, you should use <code>FROM <a href="https://hub.docker.com/_/scratch/" target="_blank" rel="noreferrer noopener">scratch</a></code>. This article uses a <a href="https://fastify.dev/" target="_blank" rel="noreferrer noopener">Fastify</a> server, so it uses an <a href="https://www.alpinelinux.org/" target="_blank" rel="noreferrer noopener">alpine</a> image configured for <a href="https://nodejs.org/en" target="_blank" rel="noreferrer noopener">Node.js</a>. You can view the complete code on <a href="https://github.com/aichbauer/the-ultimate-docker-cheat-sheet" target="_blank" rel="noreferrer noopener">GitHub</a>.</p>
</div>




<div>
	<p>Now we will edit the Dockerfile in Visual Studio Code:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-2" data-shcb-language-name="Dockerfile" data-shcb-language-slug="dockerfile"><code><span><span># the next line sets the base image for this image</span>
</span><span><span># the base image is also based on a Dockerfile</span>
</span><span><span># see: https://hub.docker.com/layers/library/node/18-alpine/images/sha256-a0b787b0d53feacfa6d606fb555e0dbfebab30573277f1fe25148b05b66fa097</span>
</span><span><span># node provides official images for Node.js and</span>
</span><span><span># alpine: a lightweight Linux distribution to reduce image size</span>
</span><span><span>FROM</span> node:<span>18</span>-alpine
</span>
<span><span># sets the working directory inside the image</span>
</span><span><span># all commands after this instruction will be</span>
</span><span><span># executed inside this directory</span>
</span><span><span>WORKDIR</span><span> /app</span>
</span>
<span><span># copies the package.json and package-lock.json</span>
</span><span><span># from the client (e.g., your server or your development machine)</span>
</span><span><span># into the /app directory inside the image</span>
</span><span><span># before running npm ci to </span>
</span><span><span># get the advantage of layer caching</span>
</span><span><span>COPY</span><span> ./package* .</span>
</span>
<span><span># installs all node.js dependencies</span>
</span><span><span># npm ci is similar to npm install but intended to be</span>
</span><span><span># used in continuous integration (CI) environments</span>
</span><span><span># it will do a clean installion based on the package-lock.json</span>
</span><span><span>RUN</span><span> npm ci</span>
</span>
<span><span># copies the source code into the image</span>
</span><span><span>COPY</span><span> . .</span>
</span>
<span><span># this runs the build command specified in the package.json</span>
</span><span><span>RUN</span><span> npm run build:server</span>
</span>
<span><span># the EXPOSE instruction does not actually expose the port 300 of this image</span>
</span><span><span># this is documentation so that we know which port we need to expose</span>
</span><span><span># we do this when starting the container with the --publish flag</span>
</span><span><span>EXPOSE</span> <span>3000</span>
</span>
<span><span># executes the server.js file that is located in the build directory</span>
</span><span><span>CMD</span><span> [<span>&#34;node&#34;</span>, <span>&#34;./build/index.js&#34;</span>]</span>
</span>
</code><small id="shcb-language-2"><span>Code language:</span> <span>Dockerfile</span> <span>(</span><span>dockerfile</span><span>)</span></small></pre>
	</div>
</div>



<h3 id="what-is-a-multistage-dockerfile">What Is A Multistage Dockerfile?</h3>
<div>
	<p>You can compose a Dockerfile with many stages. You can think of one stage, as one image. Furthermore, you can then use materials like files from one stage in another stage. A new stage always starts with the line <code>FROM &lt;base-image&gt;</code>. You name a stage using the <code>as</code> keyword. This article uses a simple HTML and JavaScript file as our client application. As a web server, we will use <a href="https://www.nginx.com/" target="_blank" rel="noreferrer noopener">NGINX</a>. You can view the complete code on <a href="https://github.com/aichbauer/the-ultimate-docker-cheat-sheet" target="_blank" rel="noreferrer noopener" data-type="link" data-id="https://github.com/aichbauer/the-ultimate-docker-cheat-sheet">GitHub</a>.</p>
</div>




<div>
	<p>A typical approach is to have a <code>builder stage</code>, with a larger base image. This image holds all executables and libraries needed to build your source code.</p>
</div>




<div>
	<p>The second stage is the <code>serve stage</code> and has a small base image. The benefit is fewer dependencies and libraries. Just enough to execute and serve your application.</p>
</div>




<div>
	<p>With this approach, you make your final image both smaller and more secure. As the image size decreases and the image consists of fewer libraries. Fewer system libraries means it has a lower attack surface. Multistage Dockerfiles are not limited to this use case and can have more than two stages as well.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-3" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># lets create a new Dockerfile for our frontend application</span>
<span># as we can specify a file in the build command, we name this Dockerfile.client</span>
$ touch Dockerfile.client
<span># open the file in your favorite editor (we are using Visual Studio Code)</span>
<span># if you do not have the code command installed, you will need to open it</span>
$ code Dockerfile.client</code><small id="shcb-language-3"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>Here is an example of a multistage app:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-4" data-shcb-language-name="Dockerfile" data-shcb-language-slug="dockerfile"><code><span><span># the base image</span>
</span><span><span># name it builder</span>
</span><span><span># you can reference this stage</span>
</span><span><span># in other stages by this name</span>
</span><span><span>FROM</span> node:<span>18</span>-alpine as builder
</span>
<span><span># working directory inside the image</span>
</span><span><span>WORKDIR</span><span> /app</span>
</span>
<span><span># copies files from the client to the image</span>
</span><span><span>COPY</span><span> ./package* .</span>
</span>
<span><span># run a command inside the image</span>
</span><span><span>RUN</span><span> npm ci</span>
</span>
<span><span># copies files from the client to the image</span>
</span><span><span>COPY</span><span> . .</span>
</span>
<span><span># run a command inside the container</span>
</span><span><span># this will create a new folder in called dist in our app directory</span>
</span><span><span># inside the dist directory, you will find the</span>
</span><span><span># final HTML and JavaScript file</span>
</span><span><span>RUN</span><span> npm run build:client</span>
</span>
<span><span># serve stage</span>
</span><span><span># slim nginx base image named as serve</span>
</span><span><span># will start nginx as non root user</span>
</span><span><span>FROM</span> nginxinc/nginx-unprivileged:<span>1.24</span> as serve
</span>
<span><span># we can now copy things from the first stage to the second</span>
</span><span><span># we copy the build output to the directory where nginx serves files</span>
</span><span><span>COPY</span><span> --from=builder /app/dist /var/www</span>
</span>
<span><span># we overwrite the default config with our own</span>
</span><span><span># if you take a look at the GitHub repository, you</span>
</span><span><span># see the .nginx directory with the nginx.conf</span>
</span><span><span># here we only use the port 80</span>
</span><span><span># in production, you would also want to make sure</span>
</span><span><span># all requests, even in your internal network or Kubernetes cluster</span>
</span><span><span># is served via HTTPS when dealing with sensible data</span>
</span><span><span>COPY</span><span> --from=builder /app/.nginx/nginx.conf /etc/nginx/conf.d/default.conf</span>
</span>
<span><span># the EXPOSE instruction does not actually expose the port 80 of this image</span>
</span><span><span># this is documentation so that we know which port we need to expose</span>
</span><span><span># we do this when starting the container with the --publish flag</span>
</span><span><span>EXPOSE</span> <span>80</span>
</span>
<span><span># The command used when the image is started as a container</span>
</span><span><span># <span>Note:</span> for Docker containers (or for debugging),</span>
</span><span><span># the &#34;daemon off;&#34; directive which is used in this example</span>
</span><span><span># tells nginx to stay in the foreground.</span>
</span><span><span># for containers, this is useful.</span>
</span><span><span># best practice: one container = one process.</span>
</span><span><span># one server (container) has only one service.</span>
</span><span><span>CMD</span><span> [<span>&#34;nginx&#34;</span>, <span>&#34;-g&#34;</span>, <span>&#34;daemon off;&#34;</span>]</span>
</span>
</code><small id="shcb-language-4"><span>Code language:</span> <span>Dockerfile</span> <span>(</span><span>dockerfile</span><span>)</span></small></pre>
	</div>
</div>



<h2 id="how-do-you-create-a-docker-image">How Do You Create A Docker Image?</h2>
<div>
	<p>We use the Docker CLI to build images out of our Dockerfiles.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-5" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># list the directory to make sure you are in the directory with the Dockerfile</span>
$ ls
<span># if not, change the directory with &#34;cd ./path/to/directory-with-Dockerfile&#34;</span>
<span># build an Image out of the Dockerfile in the current working directory</span>
$ docker build .
<span># if you want to build another Dockerfile in this directory, use the --file flag</span>
<span># e.g., --file &lt;filename&gt;</span>
$ docker build --file Dockerfile.client .</code><small id="shcb-language-5"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>Creating an image from a Dockerfile only requires the <code>docker build</code> command. Without specifying a name and tag, you can reference the image only by its image ID.</p>
</div>



<h3 id="how-do-you-list-all-images">How Do You List All Images?</h3>
<div>
	<div>
		<pre aria-describedby="shcb-language-6" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># list all local images on the client (your server or your development machine)</span>
$ docker image ls
<span># find your image ID</span></code><small id="shcb-language-6"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>If you want to give your image a name, you need to use the <code>--tag</code> (shorthand syntax: <code>-t</code>) flag while building the image. You will need this if you are working with a registry like <a href="https://hub.docker.com/" target="_blank" rel="noreferrer noopener">Docker Hub</a>.</p>
</div>



<h3 id="how-do-you-name-your-images">How Do You Name Your Images?</h3>
<div>
	<p>To name and tag your image, use the following pattern: <code>&lt;name&gt;:&lt;tag&gt;</code>. This is usually translated into <code>&lt;username&gt;/&lt;repository&gt;:&lt;version&gt;</code>. The username corresponds to the username of the registry.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-7" data-shcb-language-name="PHP" data-shcb-language-slug="php"><code><span># build and tag your image</span>
<span># a tag consists of a name and a tag, which is separated by a colon (:)</span>
$ docker build --tag examplename/examplerepository-server:<span>0.1</span><span>.0</span> .
<span># or</span>
$ docker build --file Dockerfile.client --tag examplename/examplerepository-client:<span>0.1</span><span>.0</span> .
<span># list all local images</span>
$ docker image ls
<span># you will see your image with a proper repository name and a tag</span></code><small id="shcb-language-7"><span>Code language:</span> <span>PHP</span> <span>(</span><span>php</span><span>)</span></small></pre>
	</div>
</div>



<h2 id="how-do-you-create-a-container">How Do You Create A Container?</h2>
<div>
	<p>A container is a running image. You can run images with the CLI command <code>docker run &lt;image-name&gt;</code>:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-8" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># start our image</span>
$ docker run examplename/examplerepository-server:0.1.0
<span># or</span>
$ docker run examplename/examplerepository-client:0.1.0</code><small id="shcb-language-8"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>Every Docker installation comes with a local registry. Docker stores your images here. First, the <code>docker run</code> command will look at the local registry and try to find the image. This will happen with our image, since we built it on the same machine we are executing the <code>docker run</code> command. If it does not find the image locally, it will take a look at the Docker Hub registry. You can also get images from other registries (e.g., your self-hosted registry). For that, you can use the URL of the self-hosted registry.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-9" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># try to find an image on another registry</span>
$ docker run https://registrydomain.com/examplename/examplerepository-server:0.1.0</code><small id="shcb-language-9"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>If you run an image, it starts in a foreground process. The container is running as a process in the terminal where you executed the <code>docker run</code> command. If you kill the terminal, it will stop the container immediately. To let your container run on your machine or server, you can run the container as a background process. In that way, you can close your terminal with no worries.</p>
</div>



<h3 id="how-do-you-run-containers-in-the-background">How Do You Run Containers In The Background?</h3>
<div>
	<p>The <code>--detached</code> (shorthand syntax: <code>-d</code>) flag will start containers in a background process:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-10" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># run container in the background</span>
$ docker run --detached examplename/examplerepository-server:0.1.0
<span># or</span>
$ docker run --detached examplename/examplerepository-client:0.1.0</code><small id="shcb-language-10"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>You will see that the command will exit, and you can use the terminal again.</p>
</div>



<h3 id="how-do-you-list-all-containers">How Do You List All Containers?</h3>
<div>
	<p>Docker will only show the running containers.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-11" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># list all running containers</span>
$ docker container ls
<span># short</span>
$ docker ps</code><small id="shcb-language-11"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>If you want to see all containers, even the stopped containers, you need to pass the flag <code>--all</code> (shorthand syntax: <code>-a</code>).</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-12" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># list all stopped and running containers</span>
$ docker container ls --all</code><small id="shcb-language-12"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>



<h3 id="how-do-you-stop-and-remove-containers">How Do You Stop And Remove Containers?</h3>
<div>
	<p>Occasionally, you would like to stop containers. When you stop containers, they are still on the system, you can start them again. If you wish to clean the container from the system, you will need to remove it. You can only remove a stopped container.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-13" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># stop a container</span>
$ container stop &lt;container-id&gt;
<span># start a container</span>
$ container start &lt;container-id&gt;
<span># restart container</span>
$ container restart &lt;container-id&gt;
<span># remove a stopped container</span>
$ container rm &lt;container-id&gt;</code><small id="shcb-language-13"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>If you wish to remove a container as soon as you stop it, you can pass the <code>--rm</code> flag when starting a container. Only use this if your container is stateless. If your container has its own state, make sure to use volumes to preserve it. Otherwise, all your data inside the container is lost when your container stops.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-14" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># automatically remove a container after it stops</span>
$ docker run --rm examplename/examplerepository-server:0.1.0
<span># or</span>
$ docker run --rm examplename/examplerepository-client:0.1.0</code><small id="shcb-language-14"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>



<h3 id="what-if-i-killed-the-terminal-but-the-container-is-still-running">What If I Killed The Terminal, But The Container Is Still Running?</h3>
<div>
	<p>Sometimes signals are not passed to the container properly. Imagine you have killed your terminal because you could not stop the container with CTRL+C. But If you try to restart the container, it tells you that the port is already allocated. This means your old container is still running. To kill a container, run the following command:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-15" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># kill a container</span>
$ docker <span>kill</span> &lt;conatiner-id&gt;</code><small id="shcb-language-15"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>



<h3 id="how-do-you-access-containers-from-the-host-system">How Do You Access Containers From The Host System?</h3>
<div>
	<p>Usually, a Docker container exposes one or many ports. You can access the application which is running inside the container via those ports. To have access to these ports, you need to publish those port during the container creation. Another way to access containers from the host system is by executing commands inside them. This is often used for debugging or single use container application.</p>
</div>



<h3 id="how-do-you-publish-ports">How Do You Publish Ports?</h3>
<div>
	<p>To expose the ports to the host system, you need to add the <code>--publish</code> (shorthand syntax: <code>-p</code>) flag.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-16" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># publish ports, e.g., forward container port to a port on the host system</span>
$ docker run --publish 3000:3000 examplename/examplerepository-server:0.1.0
<span># or</span>
$ docker run --publish 80:80 examplename/examplerepository-server:0.1.0
<span># if you run both containers, the server and the client</span>
<span># and you visit the localhost:80 in your browser</span>
<span># you should see the message Hello World</span></code><small id="shcb-language-16"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>In the first example above, we bind the port 3000 from the container to the port 3000 on the host system. The host system is your development machine or your server. The format is the following <code>--publish &lt;hostport&gt;:&lt;containerport&gt;</code>.</p>
</div>



<h3 id="how-do-you-access-a-running-container">How Do You Access A Running Container?</h3>
<div>
	<p>Sometimes, you want access to a container. This can be beneficial for debugging.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-17" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># access the container</span>
$ docker <span>exec</span> --interactive --tty &lt;container-id&gt; &lt;shell-command&gt;</code><small id="shcb-language-17"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p><code>--interactive --tty</code> (shorthand syntax <code>-it</code>) instructs Docker to allocate a pseudo-TTY connection. In this way, the containers’ stdin (standard input) creates an interactive shell in the container.</p>
</div>




<div>
	<p>You can execute any command that would be possible within the container. If you have a Debian container running, you would be able to list the directory:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-18" data-shcb-language-name="PHP" data-shcb-language-slug="php"><code><span># list the directory inside the container</span>
$ docker exec --interactive --tty &lt;container-id&gt; ls</code><small id="shcb-language-18"><span>Code language:</span> <span>PHP</span> <span>(</span><span>php</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>You can even create a secure shell like connection with the following command:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-19" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># SSH into the container (if the `sh` command exists in the container)</span>
$ docker <span>exec</span> --interactive --tty &lt;container-id&gt; sh
<span># this will keep the connection to the container open</span>
<span># and you can execute multiple commands within the container</span>
<span># to exit the container, run the following</span>
$ <span>exit</span></code><small id="shcb-language-19"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>



<h2 id="how-do-you-persist-data-with-docker-volumes">How Do You Persist Data With Docker Volumes?</h2>
<div>
	<p>Data that is stored inside a container is not persisted by default. When you stop and remove a container, all data from this container is lost. In our application, if you click the button on the website (<a href="http://localhost/" target="_blank" rel="noopener">http://localhost:80</a>) we will write “New message” into a JSON file inside the container. Now if we stop and remove the container, all those messages are deleted as well.</p>
</div>




<div>
	<p>If you want to persist data between container starts, you need to use volumes. There are two different volume types: named volumes and mounted volumes. Named volumes are completely handled by Docker, a mounted volume is managed by you. For a mounted volume, you need to specify the location on the host system where this data will be stored. We use the <code>--volume</code> (shorthand <code>-v</code>) in our run command.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-20" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># using a named volume</span>
<span># everything within this path of the container will be stored</span>
<span># in a volume named &lt;volume-name&gt;</span>
$ docker run --volume &lt;volume-name&gt;:/path/<span>in</span>/container &lt;image-name&gt;

<span># using a mounted volume</span>
<span># everything inside the path of the container will be stored </span>
<span># in the path of the host</span>
$ docker run --volume /path/on/host:/path/<span>in</span>/container &lt;image-name&gt;</code><small id="shcb-language-20"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>




<div>
	<p>For our application, we need to use the following command for the server container:</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-21" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># create a volume called server-volume</span>
<span># we store the content of /app/build/data within our container</span>
<span># on our host machine (your dev machine or your server)</span>
docker run --volume server-volume:/app/build/data --publish 3000:3000 examplename/examplerepository-server:0.1.0</code><small id="shcb-language-21"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>



<h3 id="how-do-you-list-all-volumes">How Do You List All Volumes?</h3>
<div>
	<p>You can get an overview of all volumes and their metadata by listing them.</p>
</div>




<div>
	<div>
		<pre aria-describedby="shcb-language-22" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><code><span># list all volumes</span>
$ docker volume ls

<span># here you will see the location where Docker will store the named volumes</span>
<span># on the host machine</span></code><small id="shcb-language-22"><span>Code language:</span> <span>Bash</span> <span>(</span><span>bash</span><span>)</span></small></pre>
	</div>
</div>



<h2 id="conclusion">Conclusion</h2>
<div>
	<p>In this article we learned the difference between a Dockerfile, an image and a container. You can now write your Dockerfiles to create images. Furthermore, you can start containers and access them from the host system. Additionally, you also learned how to persist data between container starts.</p>
</div>




<div>
	<p>If you need help with your containerization, <a href="https://calendly.com/devopsberatung/meet" target="_blank" rel="noreferrer noopener nofollow">feel free to contact us</a>, or join our new community for further questions and discussions (free cookies for the first 42 arrivals)!</p>
</div>



<p><a role="button" target="_blank" href="https://discord.gg/7xpRbG2gY9" data-color-override="#6bf4b2" data-hover-color-override="false" data-hover-text-color-override="#fff"><span>Join Our Community</span><i></i></a></p><div>
	<p>You liked this article? Share it with your colleagues and friends.</p>
</div>



<h2 id="newsletter">Sign up for our newsletter!</h2>
<div>
	<p>Do not miss out on our latest tips, guides, and updates – sign up for our newsletter now! We promise to only send you the most relevant and useful information. Be part of our journey in exploring the world of Docker and beyond.</p>
</div>








<h2>Author</h2>





			</div> 
		</div>
	</div> 
</div></div>
  </body>
</html>
