<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://somerandomidiot.com/blog/2022/02/25/faithful-high-resolution-textures/">Original</a>
    <h1>Faithful High Resolution Textures</h1>
    
    <div id="readability-page-1" class="page"><div id="main">



<div>

  

  <p>I discovered a while ago that some games companies charge extra for “high resolution textures” for their games. This phrase stuck with me until it finally found an outlet: it obviously needs to be rendered in glorious 4-color CGA as a puzzle solution to the 1987 DOS implementation of the popular American game show, “Wheel of Fortune”.</p>

<p>Wheel of Fortune begins its 39th season on September 13, 2021. I watched it frequently growing up, both live and in re-runs on the Game Show Network.  The game is played with three players, a giant roulette-style wheel, and a secret English phrase. Players take turns spinning the wheel, choosing letters to reveal, and win a round by guessing the secret phrase correctly.</p>

<p>The <a href="https://archive.org/details/msdos_Wheel_of_Fortune_1987">1987 DOS version of Wheel of Fortune</a> can be played for free on archive.org.  I also grew up with this implementation and its square-wave rendition of the 80s-era theme song “Changing Keys”, which is a Grade A cognitohazard earworm.</p>

<p>Wheel of Fortune is the ugliest computer game I have fond memories of playing (particularly the animation of the host’s low-res high heels clicking across the stage), and the combination of this memory and its phrase-based gameplay made it the perfect expression of “high resolution textures”.</p>

<p>My course of action was obvious:</p>

<ul>
<li>obtain a copy of the 1987 DOS version of Wheel of Fortune</li>
<li>figure out its file format for puzzle solutions</li>
<li>coerce it into using “high resolution textures” as a puzzle solution</li>
<li>run the game with this puzzle solution and capture a screenshot</li>
<li>transform the screenshot into a cross-stitch pattern</li>
<li>make the pattern into a throw pillow</li>
<li>enjoy the feeling of victory over the games industry I feel by having distilled this phrase into something punchable</li>
</ul>



<p>We’ll say for the purposes of this article that I dug up the original 5.25” floppies I played Wheel of Fortune on as a youth, asked someone with a working floppy drive to read them onto something modern for me, and transferred those files to something modern.  That’s definitely what I did.</p>

<p>The results of doing so are something like:</p>

<pre><code>user@emulators:~/wheel_of_fortune/wheel-of-fortune$ ls -alh
total 356K
drwxr-xr-x 2 user user 4.0K Sep 11 16:49 .
drwxr-xr-x 4 user user 4.0K Aug 25 13:00 ..
-rw-r--r-- 1 user user  52K Nov 16  1999 Answers.dat
-rw-r--r-- 1 user user 2.7K May  2  1987 Champs.dat
-rw-r--r-- 1 user user  162 Nov 16  1999 Clist.dat
-rw-r--r-- 1 user user  14K May  4  1987 Girl.dat
-rw-r--r-- 1 user user  60K May  7  1987 Menu.exe
-rw-r--r-- 1 user user  27K May  4  1987 Values.dat
-rw-r--r-- 1 user user 183K May  4  1987 Wheels.dat
</code></pre>



<p><code>Menu.exe</code> is the game itself. <code>Answers.dat</code> is the file of interest, from which Wheel of Fortune loads a list of potential secret phrases for the game.  In order to get our screenshot, one needs to figure out how to inject <code>high resolution textures</code> into <code>Answers.dat</code>. So what’s <code>Answers.dat</code> look like?</p>

<pre><code>user@emulators:~/wheel_of_fortune/wheel-of-fortune$ xxd Answers.dat |head -20
00000000: f003 ffff ffff ffff ffff ffff ffff ffff  ................
00000010: ffff ffff ffff ffff ffff ffff ffff ff8f  ................
00000020: ff0f 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000c0: 0000 0000 0000 0000 0f6a 6a6a 6a6a 6a6a  .........jjjjjjj
000000d0: 6a6a 6a6a 6a41 252e 2f46 3541 332e 222a  jjjjjA%./F5A3.&#34;*
000000e0: 4141 4b4b 3f23 2e4b 2924 2a3f 4b4b 4b45  AAKK?#.K)$*?KKKE
000000f0: 4545 4545 4545 4545 4545 4545 0208 061f  EEEEEEEEEEEE....
00000100: 0f6a 0918 0519 196a 6a41 4120 2f25 4123  .j.....jjAA /%A#
00000110: 2d34 2441 4141 4b4b 4b38 2322 2e27 2f4b  -4$AAAKKK8#&#34;.&#39;/K
00000120: 4b4b 4b45 4545 4545 4545 4545 4545 4545  KKKEEEEEEEEEEEEE
00000130: 0b6a 6a6a 6a6a 6a6a 6a6a 6a6a 6a41 412a  .jjjjjjjjjjjjAA*
</code></pre>

<p>Well, those aren’t plaintext strings. :/</p>

<p>Luckily, <code>dosbox</code> has a <a href="https://www.vogons.org/viewtopic.php?t=3944">super helpful debugger</a>.  Running the game, pausing it when the phrase has been displayed, and running <code>memdumpbin</code> gives a greppable view of the program’s memory, revealing the plaintext:</p>

<pre><code>000284c0: 0000 0000 0000 0000 0100 2020 2020 2020  ..........
000284d0: 2020 2020 2020 2020 4652 454e 4348 2041          FRENCH A
000284e0: 4e44 2020 2049 4e44 4941 4e20 5741 5220  ND   INDIAN WAR
000284f0: 2020 2020 2020 2020 2020 2020 2020 0000                ..
00028500: 0100 0f01 0000 0000 0000 5353 5353 5353  ..........SSSSSS
</code></pre>

<p>So somewhere in <code>Answers.dat</code>, there’s a phrase corresponding to <code>FRENCH AND   INDIAN WAR</code>.  And more interestingly, the phrase appears to be padded with <code>0x20</code> - the same character that separates the words.  I leapt to the conclusion that the program just processes <code>0x20</code> as an unprintable and unguessable character, and that all the answers would have a lot of <code>0x20</code>s in their plaintext.</p>

<p>Given that, and noticing that the answer board in the game is a consistent 13 characters wide by 4 characters tall, it wasn’t a stretch to assume that <code>Answers.dat</code> contains some number of fixed-width entries 52 bytes in length representing answers.</p>

<p>The cyphertext we see exhibits a lot of repeated characters - <code>0x6a</code>, <code>0x45</code> are super visible in the excerpt above. Might they correspond to <code>0x20</code> XOR <code>secret_key</code>?  There are a lot of utilities for automatically applying XOR values to byte fields; <a href="https://github.com/hellman/xortool">xortool</a> was easily to hand, and quickly gave me enough results to realize that there were 4 XOR “key” values of one byte each, applied to all the characters in each “line”.</p>

<p>Let’s have another look at the cyphertext from our first example. The first several lines don’t have the repetitive structure we’d expect from stanzas of 4*13 characters, so let’s skip to something likely-looking:</p>

<pre><code>000000c0: 0000 0000 0000 0000 0f6a 6a6a 6a6a 6a6a  .........jjjjjjj
000000d0: 6a6a 6a6a 6a41 252e 2f46 3541 332e 222a  jjjjjA%./F5A3.&#34;*
000000e0: 4141 4b4b 3f23 2e4b 2924 2a3f 4b4b 4b45  AAKK?#.K)$*?KKKE
000000f0: 4545 4545 4545 4545 4545 4545 0208 061f  EEEEEEEEEEEE....
00000100: 0f6a 0918 0519 196a 6a41 4120 2f25 4123  .j.....jjAA /%A#
00000110: 2d34 2441 4141 4b4b 4b38 2322 2e27 2f4b  -4$AAAKKK8#&#34;.&#39;/K
00000120: 4b4b 4b45 4545 4545 4545 4545 4545 4545  KKKEEEEEEEEEEEEE
00000130: 0b6a 6a6a 6a6a 6a6a 6a6a 6a6a 6a41 412a  .jjjjjjjjjjjjAA*
</code></pre>

<p>Our first 13 characters get XOR’ed with 0x4a, to give 13 “ ” characters:</p>

<pre><code>let bytewise_xor key s = String.map (fun c -&gt; (int_of_char c) lxor key |&gt; Char.chr) s;;
val bytewise_xor : int -&gt; string -&gt; string = &lt;fun&gt;
bytewise_xor 0x4a &#34;jjjjjjjjjjjjA&#34;;;
- : string = &#34;            \011&#34;
</code></pre>

<p>We’d expect the game to render this as a “blank” first line, with no guessable characters. Surprisingly, the last character renders outside of the usable printable ASCII space – let’s put a pin in that.</p>

<p>Our second line gives us a lot of 0x20’s if we XOR it with 0x61, so let’s try our <code>bytewise_xor</code> with that:</p>

<pre><code>bytewise_xor 0x61 &#34;\x25\x2e\x2f\x46\x35\x41\x33\x2e\x22\x2a\x41\x41\x41\x4b&#34;;;
- : string = &#34;DON&#39;T ROCK   *&#34;
</code></pre>

<p>Once again our last character is surprising; maybe we’re off by one?</p>

<pre><code>bytewise_xor 0x61 &#34;\x41\x25\x2e\x2f\x46\x35\x41\x33\x2e\x22\x2a\x41\x41\x41&#34;;;
- : string = &#34; DON&#39;T ROCK   &#34;
</code></pre>

<p>That looks a bit more like what we expect, so what’s the result if we shove our first line analysis over by one character?</p>

<pre><code>bytewise_xor 0x4a &#34;\x0fjjjjjjjjjjjj&#34;;;
- : string = &#34;E            &#34;
</code></pre>

<p>Hm, still a bit weird; we’ll keep our pin in it, but let’s assume the chunking that gives us a clear “ DON’T ROCK   ” is the correct one for the moment, and see about the third line:</p>

<pre><code>bytewise_xor 0x6b &#34;KK?#\x2eK)$*?KKK&#34;;;
- : string = &#34;  THE BOAT   &#34;
</code></pre>

<p>Definitely a Wheel-of-Fortune looking phrase! (And only good advice in the most literal sense.)  Our last line is another blank one:</p>

<pre><code>bytewise_xor 0x65 &#34;EEEEEEEEEEEEE&#34;;;
- : string = &#34;             &#34;
</code></pre>

<p>Given this, we can try to figure out where the boundaries between answers are, and “decrypt” them. <a href="https://github.com/inhabitedtype/angstrom">Angstrom</a> is a good fit for a character-based parser like this:</p>

<pre><code>let bytewise_xor key s = 
  String.map (fun c -&gt; (int_of_char c) lxor key |&gt; Char.chr) s

let s1_key = 0x4a
let s2_key = 0x61
let s3_key = 0x6b
let s4_key = 0x65

(* the answers file starts with 200 characters that aren&#39;t answers,
   so let&#39;s ignore them *)
let header_length = 200

module Parser = struct
  open Angstrom
  (* skip the first 200 bytes *)
  let header = take header_length

  (* a parser for our mystery byte at the beginning of line 1 *)
  let mystery_byte = any_uint8

  (* take the rest of the characters and &#34;decrypt&#34; them *)
  let l1 = take 12 &gt;&gt;| bytewise_xor s1_key
  let l2 = take 13 &gt;&gt;| bytewise_xor s2_key
  let l3 = take 13 &gt;&gt;| bytewise_xor s3_key
  let l4 = take 13 &gt;&gt;| bytewise_xor s4_key

  (* parse answers one by one *)
  let answer =
    mystery_byte &gt;&gt;= fun c -&gt;
    l1 &gt;&gt;= fun l1 -&gt; 
    l2 &gt;&gt;= fun l2 -&gt;
    l3 &gt;&gt;= fun l3 -&gt;
    l4 &gt;&gt;= fun l4 -&gt;
    return (c, l1, l2, l3, l4)

  (* the file consists of the header, which we ignore, and then
     an arbitrary (to us, anyway!) number of answers *)
  let file = header &gt;&gt;= fun _ -&gt; many answer

end
</code></pre>

<p>Invoking this parser on the <code>ANSWERS.DAT</code> distributed with Wheel of Fortune gives us the satisfying result of every answer in order:</p>

<pre><code>$ dune exec -- decoder ~/Downloads/wheel-of-fortune/answers.bak|head -4
f: [            ] [ DON&#39;T ROCK  ] [  THE BOAT   ] [             ]
2: [BLUE CROSS  ] [  AND BLUE   ] [   SHIELD    ] [             ]
b: [            ] [  KINGSTON   ] [   JAMAICA   ] [             ]
8: [            ] [ COPERNICUS  ] [             ] [             ]
</code></pre>

<p>That first thing is our mystery byte, so let’s see what values we get for it:</p>

<pre><code>$ dune exec -- decoder ~/Downloads/wheel-of-fortune/answers.bak|sort|cut -f1 -d&#39; &#39;|uniq -c
    104 0:
     42 2:
    193 8:
    158 9:
    168 b:
     27 c:
    106 d:
     21 e:
    189 f:
</code></pre>

<p>There aren’t too many values used here, so maybe we can figure out what they mean by looking at what answers they’re associated with:</p>

<pre><code>$  dune exec -- decoder ~/Downloads/wheel-of-fortune/answers.bak|sort|grep -E &#34;^f:&#34;|head -5
f: [ A DIAMOND  ] [   IN THE    ] [    ROUGH    ] [             ]
f: [            ] [   ALL OR    ] [   NOTHING   ] [             ]
f: [A NEW BROOM ] [   SWEEPS    ] [    CLEAN    ] [             ]
f: [            ] [   AT THE    ] [ CROSSROADS  ] [             ]
f: [            ] [ BEHIND THE  ] [ EIGHT BALL  ] [             ]
</code></pre>

<p>The stuff with <code>f</code> seems to be phrases? Wheel of Fortune provides a “category” for each clue, so maybe this byte is that.  “Phrase” seems as good a category as any for “HIGH RESOLUTION TEXTURES”, so let’s try writing a printer and writing our clue into <code>ANSWERS.DAT</code> with that category.</p>



<p><a href="https://github.com/inhabitedtype/faraday">Faraday</a>, Angstrom’s close friend, is pretty easy to write a complementary printer in:</p>

<pre><code>  let header b =
    for _ = 0 to (header_length - 1) do
      Faraday.write_uint8 b 0
    done


  let literally_answer b first_byte s1 s2 s3 s4 =
    let open Faraday in
    write_uint8 b first_byte;
    write_string b ~len:12 (bytewise_xor s1_key s1);
    write_string b ~len:13 (bytewise_xor s2_key s2);
    write_string b ~len:13 (bytewise_xor s3_key s3);
    write_string b ~len:13 (bytewise_xor s4_key s4);
    ()

  let spaces_string n = String.init n (fun _ -&gt; &#39; &#39;)

  let answer b first_byte l =
    let f = literally_answer b first_byte in
    match l with
    | a :: b :: c :: d :: _ -&gt; f a b c d
    | a :: b :: c :: [] -&gt; f a b c (spaces_string 13)
    | a :: b :: [] -&gt; f (spaces_string 12) a b (spaces_string 13)
    | a :: [] -&gt; f (spaces_string 12) a (spaces_string 13) (spaces_string 13)
    | [] -&gt; f (spaces_string 12) (spaces_string 13) (spaces_string 13) (spaces_string 13)
</code></pre>

<p>Using this program to make a new <code>ANSWERS.DAT</code> seems like it should work, but we encounter a problem: the program crashes immediately on an attempted division by zero. Using the “header” from the shipped <code>ANSWERS.DAT</code> keeps this from happening, so our header definition ends up a bit more complicated:</p>

<pre><code>  let header b =
    Faraday.write_uint8 b 0xf0;
    Faraday.write_uint8 b 0x01;
    for _ = 0 to 197 do
      Faraday.write_uint8 b 0
    done
</code></pre>

<p>If we write a new <code>ANSWERS.DAT</code> with just one answer in it, the program again crashes after trying to read off the end of the file. We can ensure that we always get our clue for the all-important screenshot by just writing the same clue over and over. The original <code>ANSWERS.DAT</code> has 1008 answers, so we can write our answer 1008 times.</p>

<p>Such a file starts off like this:</p>

<pre><code>$ dune exec -- encoder Answers.dat 15 &#34;    HIGH    &#34; &#34;  RESOLUTION &#34; &#34;   TEXTURES  &#34;
$ xxd Answers.dat |head -100
00000000: f001 0000 0000 0000 0000 0000 0000 0000  ................
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000c0: 0000 0000 0000 0000 0f6a 6a6a 6a02 030d  .........jjjj...
000000d0: 026a 6a6a 6a41 4133 2432 2e2d 3435 282e  .jjjjAA3$2.-45(.
000000e0: 2f41 4b4b 4b3f 2e33 3f3e 392e 384b 4b45  /AKKK?.3?&gt;9.8KKE
000000f0: 4545 4545 4545 4545 4545 4545 0f6a 6a6a  EEEEEEEEEEEE.jjj
00000100: 6a02 030d 026a 6a6a 6a41 4133 2432 2e2d  j....jjjjAA3$2.-
</code></pre>

<p>And if we copy this <code>Answers.dat</code> to where Wheel of Fortune expects to see it, we finally get our prize!</p>



<p>Screenshots are Ctrl+F5 in Dosbox.</p>

<p><img src="https://liquorix.net/images/wof_success.png" title="Success!" alt="a screenshot from 1987 Wheel of Fortune with the solved puzzle &#39;HIGH RESOLUTION TEXTURES&#39;"/></p>



<p><a href="https://github.com/glasnt/ih">ih</a> is a Python program for transforming raster images into cross-stitch patterns.  <a href="https://github.com/yomimono/stitchcraft">stitchcraft</a> is capable of doing further transformations and estimates with the generated cross-stitch pattern.  We’ll use those tools together to get a vaguely-sensible pattern.</p>

<p>The raw screenshot makes a REAL big cross-stitch pattern!  Cropping it and scaling it down by 50% yields a somewhat more reasonable estimate of effort. Here’s the <code>Makefile</code> for a maximally-reasonable, still-satisfactory result:</p>

<pre><code>$ cat Makefile
SOURCE ?= wheel-bonus-solution.png

scaled.png : $(SOURCE)
	convert -sample 50% -crop 320x100+0+0 $&lt; $@

wheel.layers : scaled.png
	ih -o json -p floss $&lt; &gt; $@

wheel.pattern : wheel.layers
	assemble -g 18 --bg=0,0,0 -i $&lt; -o $@ --exclude=310

wheel.pdf : wheel.pattern
	stitchpattern -w &#34;winners get a free trip to http://stitch.website&#34; -i $&lt; -o $@

wheel.png : wheel.pattern
	listing -i $&lt; -o $@
</code></pre>

<p><code>stitchcraft</code>’s automatic estimation tools give the following for even our smaller <code>wheel.pattern</code>:</p>

<pre><code> estimate wheel.pattern
aida cloth: 20.00 by 8.00 inches (including 1.00 margin) - approximate cost: USD 1.5
a scroll frame with small dimension of 7 inches
custom frame, of minimum size 8.0 x 20.0
DMC 703: Chartreuse: 2184 stitches (582.40 linear inches, 0.93 standard skeins, USD 0.93, ~21840 seconds)
DMC 307: Lemon: 11457 stitches (3055.20 linear inches, 4.88 standard skeins, USD 4.88, ~114570 seconds)
DMC 3801: Melon Very Dark: 340 stitches (90.67 linear inches, 0.14 standard skeins, USD 0.14, ~3400 seconds)
total cost: 6; total time: 139810 seconds (2330 minutes) (39 hours)
</code></pre>



<p>Looking at this estimate and my lovely screenshot, I concluded that I had exorcised the “HIGH RESOLUTION TEXTURES” demon and didn’t need to continue.  If you feel like concluding this effort, feel free to take up the torch and let me know how it goes - I bet punching that pillow is real satisfying.</p>

<p>The parser and printer I wrote for this silly endeavor is available <a href="https://github.com/yomimono/answer-af">on GitHub</a>, for fellow nostalgics.</p>
  
  




</div>

</div></div>
  </body>
</html>
