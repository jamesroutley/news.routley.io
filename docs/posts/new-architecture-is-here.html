<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here">Original</a>
    <h1>New Architecture is here</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container"><p>React Native 0.76 with the New Architecture by default is now available on npm!</p>
<p>In the <a href="https://reactnative.dev/blog/2024/10/23/release-0.76-new-architecture">0.76 release blog post</a>, we shared a list of significant changes included in this version. In this post, we provide an overview of the New Architecture and how it shapes the future of React Native.</p>
<p>The New Architecture adds full support for modern React features, including <a href="https://react.dev/blog/2022/03/29/react-v18#new-suspense-features" target="_blank" rel="noopener noreferrer">Suspense</a>, <a href="https://react.dev/blog/2022/03/29/react-v18#new-feature-transitions" target="_blank" rel="noopener noreferrer">Transitions</a>, <a href="https://react.dev/blog/2022/03/29/react-v18#new-feature-automatic-batching" target="_blank" rel="noopener noreferrer">automatic batching</a>, and <a href="https://react.dev/reference/react/useLayoutEffect" target="_blank" rel="noopener noreferrer"><code>useLayoutEffect</code></a>. The New Architecture also includes new <a href="https://reactnative.dev/docs/next/turbo-native-modules-introduction">Native Module</a> and <a href="https://reactnative.dev/docs/next/fabric-native-components-introduction">Native Component</a> systems that let you write type-safe code with direct access to native interfaces without a bridge.</p>
<p>This release is the result of a ground-up rewrite of React Native we’ve been working on since 2018, and we’ve taken extra care to make the New Architecture a gradual migration for most apps. In 2021, we created <a href="https://github.com/reactwg/react-native-new-architecture/" target="_blank" rel="noopener noreferrer">the New Architecture Working Group</a> to collaborate with the community on ensuring a smooth upgrade experience for the entire React ecosystem.</p>
<p>Most apps will be able to adopt React Native 0.76 with the same level of effort as any other release. The most popular React Native libraries already support the New Architecture. The New Architecture also includes an automatic interoperability layer to enable backward compatibility with libraries targeting the old architecture.</p>
<p>Over the past several years of development, our team has publicly shared our vision for the New Architecture. If you missed any of these talks, check them out here:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=52El0EUI6D0" target="_blank" rel="noopener noreferrer">React Native EU 2019 - The New React Native</a></li>
<li><a href="https://www.youtube.com/watch?v=FZ0cG47msEk" target="_blank" rel="noopener noreferrer">React Conf 2021 - React 18 Keynote</a></li>
<li><a href="https://www.youtube.com/watch?v=Q6TkkzRJfUo" target="_blank" rel="noopener noreferrer">App.js 2022 - Bringing the New React Native Architecture to the OSS Community</a></li>
<li><a href="https://www.youtube.com/watch?v=Q5SMmKb7qVI" target="_blank" rel="noopener noreferrer">React Conf 2024 - Day 2 Keynote</a></li>
</ul>
<h2 id="what-is-the-new-architecture">What is the New Architecture<a href="#what-is-the-new-architecture" aria-label="Direct link to What is the New Architecture" title="Direct link to What is the New Architecture">​</a></h2>
<p>The New Architecture is a complete rewrite of the major systems that underpin React Native, including how components are rendered, how JavaScript abstractions communicates with native abstractions, and how work is scheduled across different threads. Although most users should not have to think about how these systems work, these changes bring improvements and new capabilities.</p>
<p>In the old architecture, React Native communicated with the native platform using an asynchronous bridge. To render a component or call a native function, React Native needed to serialize and enqueue native functions calls with the bridge, which would be processed asynchronously. The benefit of this architecture is that the main thread was never blocked for rendering updates or handling native module function calls, since all work was done on a background thread.</p>
<p>However, users expect immediate feedback to interactions to feel like a native app. This means some updates need to render synchronously in response to user input, potentially interrupting any in-progress render. Since the old architecture was only asynchronous, we needed to rewrite it to allow for both asynchronous and synchronous updates.</p>
<p>Additionally, in the old architecture, serializing function calls over the bridge quickly became a bottleneck, especially for frequent updates or large objects. This made it hard for apps to achieve 60+ FPS reliably. There were also synchronization issues: when the JavaScript and native layer got out of sync, it was impossible to reconcile them synchronously, resulting bugs like lists showing frames of empty space and visual UI jumps due to intermediate states rendering.</p>
<p>Finally, since the old architecture kept a single copy of the UI using the native hierarchy, and mutated that copy in place, layout could only be computed on a single thread. This made it impossible to process urgent updates like user inputs, and layout could not be read synchronously, such as reading in a layout effect to update the position of a tooltip.</p>
<p>All of these problems meant that it was not possible to properly support React’s concurrent features. To solve these problems, the New Architecture includes four main parts:</p>
<ul>
<li>The New Native Module System</li>
<li>The New Renderer</li>
<li>The Event Loop</li>
<li>Removing the Bridge</li>
</ul>
<p>The New Module system allows the React Native Renderer to have synchronous access to the native layer, which allows it to handle events, schedule updates, and read layout both asynchronously and synchronously. The new Native Modules are also lazily loaded by default, giving apps a significant performance gain.</p>
<p>The New Renderer can handle multiple in progress trees across multiple threads, which allows React to process multiple concurrent update priorities, either on the main thread or a background thread. It also supports reading layout from multiple threads synchronously or asynchronously, to support more responsive UIs without jank.</p>
<p>The new Event Loop can process tasks on the JavaScript thread in a well-defined order. This allows React to interrupt rendering to process events so urgent user events can take priority over lower priority UI transitions. The Event Loop also aligns with web specifications, so we can support for browser features like microtasks, <code>MutationObserver</code>, and <code>IntersectionObserver</code>.</p>
<p>Finally, removing the bridge allows for faster startup and direct communication between JavaScript and the native runtime, so that the cost of switching work is minimized. This also allows for better error reporting, debugging, and reducing crashes from undefined behavior.</p>
<p>The New Architecture is now ready to be used in production. It is already used at scale at Meta in the Facebook app and in other products. We successfully used React Native and the New Architecture in the Facebook and Instagram app we developed for our <a href="https://engineering.fb.com/2024/10/02/android/react-at-meta-connect-2024/" target="_blank" rel="noopener noreferrer">Quest devices</a>.</p>
<p>Our partners have already been using the New Architecture in production for months now: have a look at these success stories by <a href="https://blog.swmansion.com/sunrising-new-architecture-in-the-new-expensify-app-729d237a02f5" target="_blank" rel="noopener noreferrer">Expensify</a> and <a href="https://blog.kraken.com/product/engineering/how-kraken-fixed-performance-issues-via-incremental-adoption-of-the-react-native-new-architecture" target="_blank" rel="noopener noreferrer">Kraken</a>, and give <a href="https://github.com/bluesky-social/social-app/releases/tag/1.92.0-na-rc.2" target="_blank" rel="noopener noreferrer">BlueSky</a> a shot with their new release.</p>
<h3 id="new-native-modules">New Native Modules<a href="#new-native-modules" aria-label="Direct link to New Native Modules" title="Direct link to New Native Modules">​</a></h3>
<p>The new Native Module System is a major rewrite of how JavaScript and the native platform communicate. It’s written entirely in C++, which unlocks many new capabilities:</p>
<ul>
<li>Synchronous access to and from the native runtime</li>
<li>Type safety between JavaScript and native code</li>
<li>Code sharing across platforms</li>
<li>Lazy module loading by default</li>
</ul>
<p>In the new Native Module system, JavaScript and the native layer can now synchronously communicate with each other through the JavaScript Interface (JSI), without the need to use an asynchronous bridge. This means your custom Native Modules can now synchronously call a function, return a value, and pass that value back to another Native Module function.</p>
<p>In the old architecture, in order to handle a response from native function calls, you needed to provide a callback, and the value returned needed to be serializable:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span>nativeModule</span><span>.</span><span>getValue</span><span>(</span><span>value </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  nativeModule</span><span>.</span><span>doSomething</span><span>(</span><span>value</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<p>In the New Architecture, you can make synchronous calls to native functions:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>const</span><span> value </span><span>=</span><span> nativeModule</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span>nativeModule</span><span>.</span><span>doSomething</span><span>(</span><span>value</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<p>With the New Architecture, you can finally leverage the full power of a C++ native implementation while still accessing it from JavaScript/TypeScript APIs. The New Module System supports <a href="https://reactnative.dev/docs/next/the-new-architecture/pure-cxx-modules">modules written in C++</a> so you can write your module once, and it works across all platforms, including Android, iOS, Windows, and macOS. Implementing modules in C++ allows for more fine-grained memory management and performance optimizations.</p>
<p>Additionally, with <a href="https://reactnative.dev/docs/next/the-new-architecture/what-is-codegen">Codegen</a>, your modules can define a strongly typed contract between the JavaScript layer and the native layer. From our experience, cross-boundary type errors are one of the most common sources of crashes in cross-platform apps. Codegen lets you overcome those problems while also generating boilerplate code for you.</p>
<p>Finally, modules are now lazily loaded: they are loaded in memory only when they’re effectively needed rather than at startup. This reduces the app startup time and keeps it low as the application grows in complexity.</p>
<p>Popular libraries such as <a href="https://github.com/mrousavy/react-native-mmkv" target="_blank" rel="noopener noreferrer">react-native-mmkv</a> have already seen benefits from migrating to the new Native Modules:</p>
<blockquote>
<p>“The new Native Modules greatly simplified setup, autolinking, and initialization for <code>react-native-mmkv</code>. Thanks to the New Architecture, <code>react-native-mmkv</code> is now a pure C++ Native Module, which allows it to work on any platform. The new Codegen allows MMKV to be fully type-safe, which fixed a long-standing <code>NullPointerReference</code> issue by enforcing null-safety, and being able to call Native Module functions synchronously allowed us to replace custom JSI access with the new Native Module API.”</p>
<p><a href="https://twitter.com/mrousavy" target="_blank" rel="noopener noreferrer">Marc Rousavy</a>, creator of <code>react-native-mmkv</code></p>
</blockquote>
<h3 id="new-renderer">New Renderer<a href="#new-renderer" aria-label="Direct link to New Renderer" title="Direct link to New Renderer">​</a></h3>
<p>We&#39;ve also completely rewritten the Native Renderer, adding several benefits:</p>
<ul>
<li>Updates can be rendered on different threads at different priorities.</li>
<li>Layout can be read synchronously and across different threads.</li>
<li>The renderer is written in C++ and shared across all platforms.</li>
</ul>
<p>The updated Native Renderer now stores the view hierarchy in an immutable tree structure. This means that the UI is stored in a way that cannot be changed directly, allowing for thread-safe processing of updates. This allows it to handle multiple in-progress trees, each representing a different version of the user interface. As a result, updates can be rendered in the background without blocking the UI (such as during transitions) or on the main thread (in response to user input).</p>
<p>By supporting multiple threads, React can interrupt a low-priority update to render an urgent one, such as those generated by user inputs, and then resume the low-priority update as needed. The new renderer can also read layout information synchronously and across different threads. This enables background computation for low-priority updates and synchronous reads when needed, such as repositioning a tooltip.</p>
<p>Finally, rewriting the renderer in C++ allows it to be shared across all platforms. This ensures that the same code runs on iOS, Android, Windows, macOS, and any other React Native-supported platform, providing consistent rendering capabilities without needing re-implementation for each platform.</p>
<p>This is a significant step towards our <a href="https://reactnative.dev/blog/2021/08/26/many-platform-vision">Many Platform Vision</a>. For example, View Flattening was an Android-only optimisation to avoid deep layout trees. The new renderer, with shared C++ core, <a href="https://github.com/reactwg/react-native-new-architecture/discussions/110" target="_blank" rel="noopener noreferrer">brings this feature to iOS</a>. This optimisation is automatic and does not require setup, it comes for free with the shared renderer.</p>
<p>With these changes, React Native now fully supports Concurrent React features like Suspense and Transitions, making it easier to build complex user interfaces that respond quickly to user input without jank, delays, or visual jumps. In the future, we will leverage these new capabilities to bring more improvements to built-in components such as FlatList and TextInput.</p>
<p>Popular libraries like <a href="https://docs.swmansion.com/react-native-reanimated/" target="_blank" rel="noopener noreferrer">Reanimated</a> are already taking advantage of the New Renderer:</p>
<blockquote>
<p>“Reanimated 4, currently in development, introduces a new animation engine that works directly with the New Renderer, allowing it to handle animations and manage layout across different threads. The New Renderer’s design is what truly enables these features to be built without relying on numerous workarounds. Moreover, because it’s implemented in C++ and shared across platforms, large portions of Reanimated can be written once, reducing platform-specific issues, minimizing the codebase, and streamlining adoption for out-of-tree platforms.”</p>
<p><a href="https://x.com/kzzzf" target="_blank" rel="noopener noreferrer">Krzysztof Magiera</a>, creator of <a href="https://docs.swmansion.com/react-native-reanimated/" target="_blank" rel="noopener noreferrer">Reanimated</a></p>
</blockquote>
<h3 id="the-event-loop">The Event Loop<a href="#the-event-loop" aria-label="Direct link to The Event Loop" title="Direct link to The Event Loop">​</a></h3>
<p>The New Architecture allowed us to implement a well-defined event loop processing model, as described in this <a href="https://github.com/react-native-community/discussions-and-proposals/blob/main/proposals/0744-well-defined-event-loop.md" target="_blank" rel="noopener noreferrer">RFC</a>. This RFC follows the specifications described in the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener noreferrer">HTML Standard</a>, and it describes how React Native should perform tasks on the JavaScript thread.</p>
<p>Implementing a well-defined event loop closes gaps between React DOM and React Native: the behavior of a React Native application is now closer to the behavior of a React DOM application, making it easier to learn once, and write anywhere.</p>
<p>The event loop brings many benefits to React Native:</p>
<ul>
<li>The ability to interrupt rendering to process events and tasks</li>
<li>Closer alignment with web specifications</li>
<li>Foundation for more browser features</li>
</ul>
<p>With the Event Loop, React is able to predictably order updates and events. This allows React to interrupt a low priority update with an urgent user event, and the New Renderer allows us to render those updates independently.</p>
<p>The Event Loops also aligns the behavior of events and task like timers with web specifications, which means React Native works more like what users are familiar with in the Web, and allows for better code sharing between React DOM and React Native.</p>
<p>It also allows for the implementation of more compliant browser features like microtasks, <code>MutationObserver</code>, and <code>IntersectionObserver</code>. These features are not ready to use in React Native yet, but we are working on bringing them to you in the future.</p>
<p>Finally, the Event Loop and the New Renderer changes to support reading layout synchronously allow React Native to add proper support for <code>useLayoutEffect</code> to read layout information synchronously and update the UI in the same frame. This allows you to position elements correctly before they are displayed to the user.</p>
<p>See <a href="https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here#uselayouteffect"><code>useLayoutEffect</code></a> for more details.</p>
<h3 id="removing-the-bridge">Removing the Bridge<a href="#removing-the-bridge" aria-label="Direct link to Removing the Bridge" title="Direct link to Removing the Bridge">​</a></h3>
<p>In the New Architecture, we&#39;ve also fully removed React Native&#39;s dependency on the bridge, replacing it with direct, efficient communication between JavaScript and native code using JSI:</p>
<p><img decoding="async" loading="lazy" src="https://reactnative.dev/assets/images/0.76-bridge-diagram-a653d794d04871e5b7a026e35d8edf03.png" width="1143" height="736"/></p>
<p>Removing the bridge improves startup time by avoiding bridge initialization. For example, in the old architecture, in order to provide global methods to JavaScript, we would need to initialize a module in JavaScript on startup, causing a small delay in app startup time:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>import</span><span> </span><span>{</span><span>NativeTimingModule</span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;NativeTimingModule&#39;</span><span>;</span><span></span><br/></span><span><span>global</span><span>.</span><span>setTimeout</span><span> </span><span>=</span><span> </span><span>timer</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span>NativeTimingModule</span><span>.</span><span>setTimeout</span><span>(</span><span>timer</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>setTimeout</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>}</span><span>,</span><span> </span><span>100</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<p>In the New Architecture, we can directly bind methods from C++:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span>runtime</span><span>.</span><span>global</span><span>(</span><span>)</span><span>.</span><span>setProperty</span><span>(</span><span>runtime</span><span>,</span><span> </span><span>&#34;setTimeout&#34;</span><span>,</span><span> createTimer</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>setTimeout</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>}</span><span>,</span><span> </span><span>100</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<p>The rewrite also improves error reporting, particularly for JavaScript crashes at startup, and reduces crashes from undefined behavior. If crashes occur, the new <a href="https://reactnative.dev/docs/next/react-native-devtools">React Native DevTools</a> simplify debugging and support the New Architecture.</p>
<p>The bridge remains for backward compatibility to support gradual migration to the New Architecture. In the future, we will remove the bridge code completely.</p>
<h3 id="gradual-migration">Gradual Migration<a href="#gradual-migration" aria-label="Direct link to Gradual Migration" title="Direct link to Gradual Migration">​</a></h3>
<p>We expect most apps can upgrade to 0.76 with the same effort as any other release.</p>
<p>When you upgrade to 0.76, the New Architecture and React 18 are enabled by default. However, to use concurrent features and gain the full benefits of the New Architecture, your app and libraries will need to be gradually migrated to fully support the New Architecture.</p>
<p>When you first upgrade, your app will run on the New Architecture with an automatic interoperability layer with the old architecture. For most apps, this will work without any changes, but there are <a href="https://github.com/reactwg/react-native-new-architecture/discussions/237" target="_blank" rel="noopener noreferrer">known limitations</a> with the interop layer, as it does not support accessing custom Shadow Nodes or concurrent features.</p>
<p>To use concurrent features, apps will also need to be updated to support <a href="https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react" target="_blank" rel="noopener noreferrer">Concurrent React</a> by following the <a href="https://react.dev/reference/rules" target="_blank" rel="noopener noreferrer">Rules of React</a>. To migrate your JavaScript code to React 18 and its semantics, follow the <a href="https://react.dev/blog/2022/03/08/react-18-upgrade-guide" target="_blank" rel="noopener noreferrer">React 18 Upgrade guide</a>.</p>
<p>The overall strategy is to get your application running on the New Architecture without breaking existing code. You can then gradually migrate your app at your own pace. For new surfaces that have migrated all modules to the New Architecture, you can start using concurrent features immediately. For existing surfaces, you may need to address some issues and migrate modules before adding concurrent features.</p>
<p>We&#39;ve collaborated with the most popular React Native libraries to ensure support for the New Architecture. More than 850 libraries are already compatible, including all libraries with over 200K weekly downloads (~10% of downloaded libraries). You can check library compatibility with the New Architecture on the <a href="https://reactnative.directory" target="_blank" rel="noopener noreferrer">reactnative.directory</a> website:</p>
<p><img decoding="async" loading="lazy" src="https://reactnative.dev/assets/images/0.76-directory-85387cf0da638f887bbf996c39db432d.png" width="1999" height="785"/></p>
<p>For more details on upgrading, see <a href="https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here#how-to-upgrade">How to Upgrade</a> below.</p>
<h2 id="new-features">New Features<a href="#new-features" aria-label="Direct link to New Features" title="Direct link to New Features">​</a></h2>
<p>The New Architecture includes full support for React 18, concurrent features, and <code>useLayoutEffect</code> in React Native. For a full list of React 18 features, please see the <a href="https://react.dev/blog/2021/12/17/react-conf-2021-recap#react-18-and-concurrent-features" target="_blank" rel="noopener noreferrer">React 18 blog post</a>.</p>
<h3 id="transitions">Transitions<a href="#transitions" aria-label="Direct link to Transitions" title="Direct link to Transitions">​</a></h3>
<p>Transitions are a new concept in React 18 to distinguish between urgent and non-urgent updates.</p>
<ul>
<li><strong>Urgent updates</strong> reflect direct interaction, like typing and pressing.</li>
<li><strong>Transition updates</strong> transition the UI from one view to another.</li>
</ul>
<p>Urgent updates need immediate response to match our intuitions about how physical objects behave. However, transitions are different because the user doesn’t expect to see every intermediate value on screen. In the New Architecture, React Native is able to support rendering urgent updates and transition updates separately.</p>
<p>Typically, for the best user experience, a single user input should result in both an urgent update and a non-urgent one. Similar to ReactDOM, events like <code>press</code> or <code>change</code> are handled as urgent and rendered immediately. You can use the <code>startTransition</code> API inside an input event to inform React which updates are “transitions” and can be deferred to the background:</p>
<div><div><pre tabindex="0"><code><span><span>import</span><span> </span><span>{</span><span>startTransition</span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;react&#39;</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>setCount</span><span>(</span><span>input</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>startTransition</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>setNumberOfTiles</span><span>(</span><span>input</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<p>Separating urgent events from transitions allows for a more responsive user interface, and a more intuitive user experience.</p>
<p>Here&#39;s a comparison of the old architecture without transitions and the new architecture with transitions. Imagine that each tile isn&#39;t a trivial view with a background color, but a rich component containing images and other components that are expensive to render. <strong>After</strong> using <code>useTransition</code> you avoid thrashing your app with updates and falling behind.</p>

<p>For more information, see <a href="https://reactnative.dev/docs/0.75/the-new-architecture/landing-page#support-for-concurrent-renderer-and-features">Support for Concurrent Renderer and Features</a>.</p>
<h3 id="automatic-batching">Automatic Batching<a href="#automatic-batching" aria-label="Direct link to Automatic Batching" title="Direct link to Automatic Batching">​</a></h3>
<p>When upgrading to the New Architecture, you will benefit from automatic batching from React 18.</p>
<p>Automatic batching allows React to batch together more state updates when rendering to avoid the rendering of intermediate states. This allows React Native to be faster and less susceptible to lags, without any additional code from the developer.</p>

<p>In the old architecture, more intermediate states are rendered, and the UI keeps updating even when the slider stops moving. The New Architecture, renders fewer intermediate states and completes the rendering much sooner thanks to automatically batching the updates.</p>
<p>For more information, see <a href="https://reactnative.dev/docs/0.75/the-new-architecture/landing-page#support-for-concurrent-renderer-and-features">Support for Concurrent Renderer and Features</a>.</p>
<h3 id="uselayouteffect">useLayoutEffect<a href="#uselayouteffect" aria-label="Direct link to useLayoutEffect" title="Direct link to useLayoutEffect">​</a></h3>
<p>Building on the Event Loop and the ability to read layout synchronously, in the New Architecture we added proper support for <code>useLayoutEffect</code> in React Native.</p>
<p>In the old architecture, you needed to use the asynchronous <code>onLayout</code> event to read layout information of a view (which was also asynchronous). As a result there would be at least one frame where the layout was incorrect until the layout was read and updated, causing issues like tooltips placed in the wrong position:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>const</span><span> onLayout </span><span>=</span><span> </span><span>React</span><span>.</span><span>useCallback</span><span>(</span><span>event </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  ref</span><span>.</span><span>current</span><span>?.</span><span>measureInWindow</span><span>(</span><span>(</span><span>x</span><span>,</span><span> y</span><span>,</span><span> width</span><span>,</span><span> height</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>setPosition</span><span>(</span><span>{</span><span>x</span><span>,</span><span> y</span><span>,</span><span> width</span><span>,</span><span> height</span><span>}</span><span>)</span><span>;</span><span></span><br/></span><span><span>  </span><span>}</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>&lt;</span><span>ViewWithTooltip</span><span></span><br/></span><span><span>  </span><span>onLayout</span><span>=</span><span>{</span><span>onLayout</span><span>}</span><span></span><br/></span><span><span>  </span><span>ref</span><span>=</span><span>{</span><span>ref</span><span>}</span><span></span><br/></span><span><span>  </span><span>position</span><span>=</span><span>{</span><span>position</span><span>}</span><span></span><br/></span><span><span></span><span>/&gt;</span><span>;</span><br/></span></code></pre></div></div>
<p>The New Architecture fixes this by allowing synchronous access to layout information in <code>useLayoutEffect</code>:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> rect </span><span>=</span><span> ref</span><span>.</span><span>current</span><span>?.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>  </span><span>setPosition</span><span>(</span><span>rect</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>&lt;</span><span>ViewWithTooltip</span><span> </span><span>ref</span><span>=</span><span>{</span><span>ref</span><span>}</span><span> </span><span>position</span><span>=</span><span>{</span><span>position</span><span>}</span><span> </span><span>/&gt;</span><span>;</span><br/></span></code></pre></div></div>
<p>This change allows you to read layout information synchronously and update the UI in the same frame, allowing you to position elements correctly before they are displayed to the user:</p>

<p>For more information, see the docs for <a href="https://reactnative.dev/docs/0.75/the-new-architecture/landing-page#synchronous-layout-and-effects">Synchronous Layout and Effects</a>.</p>
<h3 id="full-support-for-suspense">Full Support for Suspense<a href="#full-support-for-suspense" aria-label="Direct link to Full Support for Suspense" title="Direct link to Full Support for Suspense">​</a></h3>
<p>Suspense lets you declaratively specify the loading state for a part of the component tree if it’s not yet ready to be displayed:</p>
<div><div><pre tabindex="0"><code><span><span>&lt;</span><span>Suspense</span><span> </span><span>fallback</span><span>=</span><span>{</span><span>&lt;</span><span>Spinner</span><span> </span><span>/&gt;</span><span>}</span><span>&gt;</span><span></span><br/></span><span><span>  </span><span>&lt;</span><span>Comments</span><span> </span><span>/&gt;</span><span></span><br/></span><span><span></span><span>&lt;/</span><span>Suspense</span><span>&gt;</span><br/></span></code></pre></div></div>
<p>We introduced a limited version of Suspense several years ago, and React 18 added full support. Until now, React Native was not able to support concurrent rendering for Suspense.</p>
<p>The New Architecture includes full support for Suspense introduced in React 18. This means that you can now use Suspense in React Native to handle loading states for your components, and the suspended content will render in the background while the loading state is displayed, giving higher priority to user input on visible content.</p>
<p>For more, see the <a href="https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md" target="_blank" rel="noopener noreferrer">RFC for Suspense in React 18</a>.</p>
<h2 id="how-to-upgrade">How to Upgrade<a href="#how-to-upgrade" aria-label="Direct link to How to Upgrade" title="Direct link to How to Upgrade">​</a></h2>
<p>To upgrade to 0.76, follow the steps in the <a href="https://reactnative.dev/blog/2024/10/23/release-0.76-new-architecture#upgrade-to-076">release post</a>. Since this release also upgrades to React 18, you will also need to follow the <a href="https://react.dev/blog/2022/03/08/react-18-upgrade-guide" target="_blank" rel="noopener noreferrer">React 18 Upgrade guide</a>.</p>
<p>These steps should be enough for most apps to upgrade to the New Architecture thanks to the interop layer with the old architecture. However, to take full advantage of the New Architecture and to start using concurrent features, you will need to migrate your custom Native Modules and Native Components to support the new Native Module and Native Component APIs.</p>
<p>Without migrating your custom Native Modules, you will not get the benefits of shared C++, synchronous method calls, or type-safety from codegen. Without migrating your Native Components, you will not be able to use concurrent features. We recommend migrating all Native Components and Native Modules to the New Architecture as soon as possible.</p>
<div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</p><p>In a future release, we will remove the interop layer and modules will need to support the New Architecture.</p></div>
<h3 id="apps">Apps<a href="#apps" aria-label="Direct link to Apps" title="Direct link to Apps">​</a></h3>
<p>If you are an app developer, to fully support the New Architecture, you will need to upgrade your libraries, custom Native Components, and custom Native Modules to fully support the New Architecture.</p>
<p>We&#39;ve collaborated with the most popular React Native libraries to ensure support for the New Architecture. You can check library compatibility with the New Architecture on the <a href="https://reactnative.directory" target="_blank" rel="noopener noreferrer">reactnative.directory</a> website.</p>
<p>If any of the libraries your app depends on are not compatible yet, you can:</p>
<ul>
<li>Open an issue with the library and ask the author to migrate to the New Architecture.</li>
<li>If the library is not maintained, consider alternative libraries with the same features.</li>
<li><a href="https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here#opt-out">Opt-out from the New Architecture</a> while those libraries are migrated.</li>
</ul>
<p>If your app has custom Native Modules or custom Native Components, we expect them to work fine, thanks to our <a href="https://github.com/reactwg/react-native-new-architecture/discussions/135" target="_blank" rel="noopener noreferrer">interop layer</a>. However, we recommend upgrading them to the new Native Module and Native Component APIs to fully support the New Architecture and adopt concurrent features.</p>
<p>Please follow these guides to migrate your modules and components to the New Architecture:</p>
<ul>
<li><a href="https://reactnative.dev/docs/next/turbo-native-modules-introduction">Native Modules</a></li>
<li><a href="https://reactnative.dev/docs/next/fabric-native-components-introduction">Native Components</a></li>
</ul>
<h3 id="libraries">Libraries<a href="#libraries" aria-label="Direct link to Libraries" title="Direct link to Libraries">​</a></h3>
<p>If you are a library maintainer, please first test that your library works with the interop layer. If it does not, please open an issue on the <a href="https://github.com/reactwg/react-native-new-architecture/" target="_blank" rel="noopener noreferrer">New Architecture Working Group</a>.</p>
<p>To fully support the New Architecture, we recommend migrating your library to the new Native Module and Native Component APIs as soon as possible. This will allow users of your library to take full advantage of the New Architecture and support concurrent features.</p>
<p>You can follow these guides to migrate your modules and components to the New Architecture:</p>
<ul>
<li><a href="https://reactnative.dev/docs/next/turbo-native-modules-introduction">Native Modules</a></li>
<li><a href="https://reactnative.dev/docs/next/fabric-native-components-introduction">Native Components</a></li>
</ul>
<h3 id="opt-out">Opt-out<a href="#opt-out" aria-label="Direct link to Opt-out" title="Direct link to Opt-out">​</a></h3>
<p>If, for any reason, the New Architecture is not behaving properly in your application, there is always the option to opt-out from it until you are ready to turn it on again.</p>
<p>To opt-out from the New Architecture:</p>
<ul>
<li>On Android, modify the <code>android/gradle.properties</code> file and turn off the <code>newArchEnabled</code> flag</li>
</ul>
<div><div><pre tabindex="0"><code><span><span>-</span><span>newArchEnabled=true</span><br/></span><span><span></span><span>+</span><span>newArchEnabled=false</span><br/></span></code></pre></div></div>
<ul>
<li>On iOS, you can reinstall the dependencies by running the command:</li>
</ul>
<div><div><pre tabindex="0"><code><span><span>RCT_NEW_ARCH_ENABLED</span><span>=</span><span>0</span><span> bundle </span><span>exec</span><span> pod </span><span>install</span><br/></span></code></pre></div></div>
<h2 id="thanks">Thanks<a href="#thanks" aria-label="Direct link to Thanks" title="Direct link to Thanks">​</a></h2>
<p>Delivering the New Architecture to the OSS community has been a huge effort that took us several years of research and development. We want to take a moment to thank all the current and past members of the React team who helped us achieve this result.</p>
<p>We are also extremely grateful to all the partners who collaborated with us to make this happen. Specifically, we would like to call out:</p>
<ul>
<li><a href="https://expo.dev/" target="_blank" rel="noopener noreferrer">Expo</a>, for adopting the New Architecture early on, and for supporting the work on migrating the most popular libraries.</li>
<li><a href="https://swmansion.com/" target="_blank" rel="noopener noreferrer">Software Mansion</a>, for maintaining crucial libraries in the ecosystem, for migrating them to the New Architecture early and for all the help in investigating and fixing various issues.</li>
<li><a href="https://www.callstack.com/" target="_blank" rel="noopener noreferrer">Callstack</a>, for maintaining crucial libraries in the ecosystem, for migrating them to the New Architecture early and for the support with the work on the Community CLI.</li>
<li><a href="https://opensource.microsoft.com/" target="_blank" rel="noopener noreferrer">Microsoft</a>, for adding the New Architecture implementation for <code>react-native-windows</code> and <code>react-native-macos</code> as well as in several other developer tools.</li>
<li><a href="https://www.expensify.com/" target="_blank" rel="noopener noreferrer">Expensify</a>, <a href="https://www.kraken.com/" target="_blank" rel="noopener noreferrer">Kraken</a>, <a href="https://bsky.app/" target="_blank" rel="noopener noreferrer">BlueSky</a> and <a href="https://www.brigad.co/" target="_blank" rel="noopener noreferrer">Brigad</a> for pioneering the adoption of the New Architecture and reporting various issues so that we could fix them for everyone else.</li>
<li>All the independent library maintainers and developers who contributed to the New Architecture by testing it, fixing some of the issues, and opening questions on unclear matters so that we could clear them.</li>
</ul></div></div>
  </body>
</html>
