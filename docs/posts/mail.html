<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jamiepalatnik.com/mail/">Original</a>
    <h1>Mail</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>
It’s been six and a half years since my last installment <a href="https://blog.veitheller.de/scheme-macros/">in my series on Scheme macros</a>, and I thought it was high time for another one.
  </p>
<p>
If you’re new here (or, you know, you’ve only been around for the last six years and haven’t looked at the backlog), in this series we implement things usually reserved for language features as Scheme macros.
  </p>
<p>
I haven’t written a Scheme macro in years. The last big one I wrote is probably for my contribution to the paper <a href="https://dl.acm.org/doi/10.1145/3468264.3468574">“Efficient module-level dynamic analysis for dynamic languages with module recontextualization”</a>, and that was four years ago and using Racket. Time to combat atrophy, and do something cool! I dusted off <a href="https://github.com/zepto-lang/zepto">zepto</a>, the Scheme I built a decade or so ago, and got to work (to my surprise, it even compiled after some minor GHC-mandated updates).
  </p>
<p>
I decided it’s time to implement algebraic data types (ADTs, also known as sum types), i.e. types with multiple constructors, and a pattern matching API to go with it, all in about 27 lines of code. But be warned: it’s pretty dense!
  </p>

<p>
First, let’s look at an API we want to implement. We want to be able to define a type like so:
  </p>
<div>
  <div><pre><code>(defadt Expr
  (Lit n)
  (Add x y)
  (Mul x y))</code></pre>
    </div>
  
</div>
<p>
This defines a type <code>Expr</code> that knows how to construct literals, add, and multiply. An expression calculator could then look like this:
  </p>
<div>
  <div><pre><code>(define (eval-expr e)
  (match e
    ((Lit n) n)
    ((Add x y) (+ (eval-expr x) (eval-expr y)))
    ((Mul x y) (* (eval-expr x) (eval-expr y)))
    (else (error &#34;bad Expr&#34;))))</code></pre>
    </div>
  
</div>
<p>
It pattern-matches on the expression type and binds into variables. As an extra challenge, I also want to be able to write guard expressions:
  </p>
<div>
  <div>
      <pre><code>(match (Lit 5)
  ((Lit n) :when (negative? n) &#39;neg)
  ((Lit _) &#39;pos)
  (else &#39;not-a-lit))</code></pre>
    </div>
  
</div>
<p>
These are arbitrary expressions that I can use for the components of my ADT.
  </p>
<p>
And that’s about it! Let’s crack our knuckles and get to work!
  </p>

<p>
Let’s start with the ADT. For the purposes of this blog post, we will ignore all other affordances Scheme might have for us (record types and the like), and we will conjure data types out of nothing but lists.
  </p>

<div>
  <div>
      <pre><code>(define-syntax defadt
  (syntax-rules ()
    ((_ Name) (begin))
    ((_ Name (Ctor field ...) rest ...)
     ; what do we do here?
     ))))</code></pre>
    </div>
  
</div>
<p>
First we define a based case for our macro, since it will be recursive. Then we define the head clause of our main rule, where we take one of the constructors. What do we do with it, though? We need to at least define a function named after the constructor that instantiates the data type, and probably also a function that checks for the data type. Taking our example from above and the <code>Lit</code> expression that takes a literal, we would define <code>(Lit &lt;n&gt;)</code> and <code>(Lit? &lt;to-check&gt;)</code>, then go to our next constructor. So, let’s do just that:
  </p>
<div>
  <div>
      <pre><code>(define-syntax defadt
  (syntax-rules ()
    ((_ Name) (begin))
    ((_ Name (Ctor field ...) rest ...)
     (begin
       (define (Ctor field ...) (cons &#39;Ctor (list field ...)))
       (eval (macro-expand
       	`(define (,(string-&gt;symbol (++ (symbol-&gt;string &#39;Ctor) &#34;?&#34;)) v)
       		(and (list? v) (eq? (car v) &#39;,&#39;Ctor))))
       	(current-env))
       (defadt Name rest ...)))))</code></pre>
    </div>
  
</div>
<p>
This is a bit ugly, mostly due to me forgetting most of how I do things in zepto. The first definition is easy, it literally just makes a function that takes all the fields and puts them in a list that we then tag with the name of the type, such that <code>(Lit 5)</code> would end up being encoded as <code>&#39;(Lit 5)</code>.
  </p>
<p>
So far, so good. I am not very happy with the second definition, since it calls <code>macro-expand</code> and <code>eval</code> manually, a sign that we don’t know how to do something. My problem here was that I needed to construct the symbol <code>ConstructorName + ?</code> and splice that in the definition, and I forgot how to do it. In the end, it’s literally just a check of whether we have a list and whether the constructor name is the first argument. Good enough for us.
  </p>
<p>
We then recurse, removing the first constructor, such that we eventually reach the empty base case.
  </p>

<p>
The meat of our definition lies in the matcher, however. Let’s build a skeleton as before.
  </p>
<div>
  <div>
      <pre><code>(define-syntax match
  (syntax-rules (:when else)
    ((_ e (else body ...)) (begin body ...))
    ((_ e ((Ctor vars ...) :when g body ...) rest ...)
       ; match with guard
       )
    ((_ e ((Ctor vars ...) body ...) rest ...)
       ; match without guard
       )
    ((_ e) (error &#34;match: no clause matched&#34;))))</code></pre>
    </div>
  
</div>
<p>
We define a <code>match</code> macro with the special keywords <code>else</code> and <code>:when</code>. The <code>else</code> clause is easy, it just unconditionally executes the body. Likewise, a matcher without anything will just error. The complicated branches are the ones that actually do the matching, with or without guard.
  </p>
<p>
We will need recursion once more, and we will start with the slightly simpler matcher without guard expression:
  </p>
<div>
  <div><pre><code>(define-syntax match
  (syntax-rules (:when else)
    ((_ e (else body ...)) (begin body ...))
    ((_ e ((Ctor vars ...) :when g body ...) rest ...)
     ; with guard
     )
    ((_ e ((Ctor vars ...) body ...) rest ...)
     (let ((tmp e))
       (if (and (list? tmp) (eq? (car tmp) &#39;Ctor))
           (apply (lambda (vars ...) body ...)
                  (cdr tmp))
           (match tmp rest ...))))
    ((_ e) (error &#34;match: no clause matched&#34;))))</code></pre>
    </div>
  
</div>
<p>
Oof, that’s a handful. So first we create a temporary variable for our matchable expression (this makes sure that it gets evaluated once, not multiple times). We then check if it quacks like a duck (it is a correctly tagged list), and if so, we apply the value to an anonymous function that’s made up of the match variables and body.
  </p>
<p>
Let’s go through an illustrative example:
  </p>
<div>
  <div>
      <pre><code>(match (Lit 5)
  ((Lit x) (* x 5)))
  
 ; expands to (partial expansion before let etc)
 
 (let ((tmp (Lit 5)))
 	(if (and (list? tmp) (eq? (car tmp) &#39;Lit))
 		(apply (lambda (x) (* x 5)) &#39;(5))
 		(error &#34;match: no clause matched&#34;)))</code></pre>
    </div>
  
</div>
<p>
You can also play around with it using <code>macro-expand</code> on your own time, but be warned: <code>let</code> and <code>and</code> are also macros, and the expanded expression is actually a bit more complicated!
  </p>
<p>
The guarded clause is only slightly more complicated.
  </p>
<div>
  <div>
      <pre><code>(define-syntax match
  (syntax-rules (:when else)
    ((_ e (else body ...)) (begin body ...))
    ((_ e ((Ctor vars ...) :when g body ...) rest ...)
     (let ((tmp e))
       (if (and (list? tmp) (eq? (car tmp) &#39;Ctor))
           (apply (lambda (vars ...)
                     (if g
                       (begin body ...)
                       (match tmp rest ...)))
                  (cdr tmp))
           (match tmp rest ...))))
    ((_ e ((Ctor vars ...) body ...) rest ...)
     ; without guard
    ((_ e) (error &#34;match: no clause matched&#34;))))</code></pre>
    </div>
  
</div>
<p>
It essentially does the same thing, but has an <code>if</code> clause inside the <code>lambda</code> that will go to the rest of the match if the clause doesn’t hold.
  </p>
<p>
Why there and not in the outside <code>if</code>? We need access to the bound variables, and we only have that inside of the <code>lambda</code> expression. The generated code will be quite ugly, but we don’t really care, since noone should ever need to see it.
  </p>
<p>
And that’s it! We’ve implemented a full ADT and pattern matcher.
  </p>

<p>
A few potential next steps could be:
  </p>
<div>
  <ul><li>Add a function that checks for the main algebraic data type (i.e. <code>Expr?</code>). This requires fiddling a bit with the recursion scheme in the macro.</li>
<li>Unify the guarded and unguarded macro clauses. This requires rewriting the macro form to funnel one style into the other (probably unguarded into guarded using a <code>:when true</code> form).</li>
<li>Add exhaustiveness checks in the <code>match</code> macro.</li>
<li>Add nested destructuring for <code>match</code>.</li></ul>
</div>
<p>
There are even more things you could spend time on, like <code>let</code>-style destructuring and the like. The possibilities are endless!
  </p>

<p>
In this blog post, we implemented full ADT support and pattern matching in two macros and under 30 lines of code. Not too shabby, right?
  </p>
<p>
Let me know if you want me to revive this series, I have a few more idea for funky macros up my sleeve!
  </p>
      
    </div></div>
  </body>
</html>
