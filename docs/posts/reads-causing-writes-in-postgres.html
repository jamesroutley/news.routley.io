<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jesipow.com/blog/postgres-reads-cause-writes/">Original</a>
    <h1>Reads Causing Writes in Postgres</h1>
    
    <div id="readability-page-1" class="page"><section><div><header><nav><a href="https://jesipow.com/blog/">Alex Jesipow</a></nav></header><p><em>2024-12-21</em></p><p>It is good practice to regularly inspect the statements running in the hot path of your Postgres instance. One way to do this is to examine the <code>pg_stat_statements</code> <a href="https://www.postgresql.org/docs/current/pgstatstatements.html" rel="noopener" target="_blank">view</a>, which shows various statistics about the SQL statements executed by the Postgres server.</p><p>Among many other interesting columns, you will find the <code>shared_blks_dirtied</code> and <code>shared_blks_written</code> columns. They keep track of how many blocks, Postgres&#39; smallest unit of I/O, in the shared buffer cache are modified by a statement and (ultimately) written to disk.</p><p>One observation you may make when inspecting the view is that <code>SELECT</code> queries show non-zero values in the <code>shared_blks_written</code> and <code>shared_blks_dirtied</code> columns. This seems counterintuitive at first as it indicates that a simple <code>SELECT</code> query, which you would expect to only read data, can in fact cause data to be written (keeping track of the statement statistics themselves is not what causes these writes).</p><p>This article discusses two mechanisms, setting hint bits for transaction state tracking and page pruning, that can cause writes by read-only statements. Before we can go into detail about these mechanisms themselves, however, we first have to understand how Postgres organises table data and manages concurrency.</p><h3 id="multi-version-concurrency-control">Multi-version concurrency control</h3><p>Postgres allows multiple clients to read and write data concurrently using multi-version concurrency control (MVCC). As the name suggests, it uses multiple versions of the same logical table row to ensure that clients always have a consistent (albeit potentially different) view of data - even if other clients make changes to the same data at the same time.</p><p>One client will only ever see at most one such row version (although which one exactly may change throughout the lifetime of a transaction). Different clients interacting with the same table row concurrently may see different versions of that row.</p><p>There are many possible side-effects that result from supporting concurrency in a database. For example, it can happen that in one and the same transaction reading the same row multiple times may show different data (i.e. row versions) - even if the row was not modified by the reading transaction. This phenomenon, known as non-repeatable read, can happen if another client&#39;s transaction changed and committed that row in the meantime.</p><p>Depending on the requirements, clients may wish to use a stricter <a href="https://www.postgresql.org/docs/current/transaction-iso.html" rel="noopener" target="_blank">level of isolation</a> from other transactions to reduce (or even entirely eliminate) such concurrency effects. Of course, stricter transaction isolation levels have performance implications that should be considered carefully.</p><p>There are many more interesting concurrency effects, but more details are beyond the scope of this article. We will continue to focus on how row versions work in Postgres.</p><h3 id="tables-pages-and-tuples">Tables, pages and tuples</h3><p>To make this article easier to follow, we&#39;ll use a small example. Let&#39;s say we have a library of books at home and we occasionally lend the books to friends. Even though we sadly only have one book currently in our collection, we keep track of it in a <code>books</code> table.</p><pre data-lang="sql"><code data-lang="sql">CREATE TABLE books (
	id integer PRIMARY KEY,
	title char(800) NOT NULL,
	author char(600) NOT NULL,
	lent_to char(400)
);
INSERT INTO books VALUES (1, &#39;Designing Data-Intensive Applications&#39;, &#39;Martin Kleppmann&#39;, &#39;Alice&#39;);
SELECT * FROM books;
</code></pre><pre><code> id |                 title                  |      author       | lent_to
----+----------------------------------------+-------------------+---------
  1 | Designing Data-Intensive Applications  | Martin Kleppmann  | Alice
</code></pre><p>How is this data physically represented in Postgres?</p><p>On disk, the data for a table is separated into three different kinds of files, also known as forks:</p><ul><li>the main fork, storing the main table data</li><li>the free space map (FSM), keeping track of available space in the table</li><li>the visibility map (VM), holding information about pages with row versions visible to all active transactions (more later)</li></ul><p>Files in the main fork are logically split into blocks. They are, as mentioned in the introduction, the smallest unit of data Postgres will read from or write to disk. A block is also often referred to as a page, even though technically they are <a href="https://github.com/postgres/postgres/blob/master/src/include/storage/bufpage.h#L26-L30" rel="noopener" target="_blank">not exactly</a> the same.</p><p>I will not go into more details on the file structure, for the purposes in this post it is sufficient to consider a table as a collection of so-called heap pages. A heap page is a container that can hold one or more row versions, often also referred to as heap tuples or simply items.</p><p>Pages always have a fixed size, usually 8192 bytes, regardless of how many tuples they currently contain. To avoid costly (de-)serialisation, there is no difference in how pages are stored on disk or in memory.</p><pre><code>HEAP PAGE LAYOUT

Byte                                                          |---lp_len---|
0       24   28   32   pd_lower                 pd_upper     lp_off                 8192
+--------+----+----+----+-----------//-----------+------------+------------+---------+
|        |    |    |    |-&gt;                    &lt;-|            |            |         |
| PAGE   | It.| It.| It.|         FREE           |            |            |         |
|        | ID | ID | ID |                        |   Item 3   |   Item 2   |  Item 1 |
| HEADER | 1  | 2  | 3  |         SPACE          |            |            |         |
|        |    |    |    |-&gt;                    &lt;-|            |            |         |
+--------+----+----+----+-----------//-----------+------------+------------+---------+
            |    |    |                          ^            ^            ^
            |    |    +--------------------------+            |            |
            |    +--------------------------------------------+            |
            +--------------------------------------------------------------+
</code></pre><p>The diagram above illustrates the memory layout of a heap page. The first 24 bytes are occupied by the page header, followed by item identifiers - each 4 bytes long - which store an offset to the start of the actual item, its length and state.</p><p>Between the item identifiers and the items themselves is unallocated space that can be used for new data. New items are allocated from the bottom (right in the diagram above) of the page upwards, while new identifiers are added from the top.</p><p>Indexes are also organised in pages, but they have an additional area called &#34;special space&#34; allocated at the very end of the page for index-specific data. There is no special space allocated for heap pages, however.</p><p>Items in index or heap pages need to point to items in other heap pages. Such a reference, known as a <code>CTID</code>, always points to a page and the number of the item identifiers, e.g. <code>(0, 3)</code>. The referenced item identifier in turn keeps track of the offset to the actual item within the page as shown above. This indirection allows moving items around inside the page without breaking outside pointers and therefore requires the identifiers to not be moved until freed. We will encounter this in more detail later.</p><h3 id="inspecting-pages">Inspecting pages</h3><p>To see how our <code>books</code> table is represented in pages and tuples we need some special tools. Thankfully, Postgres offers many functions to inspect its inner workings.</p><p>We first need to get access to several such functions from the <code>pageinspect</code> <a href="https://www.postgresql.org/docs/17/pageinspect.html" rel="noopener" target="_blank">module</a>. The <code>page_header</code> function converts the raw page data returned by <code>get_raw_page</code> into a human readable format. We only look at header fields most relevant for our exploration:</p><pre data-lang="sql"><code data-lang="sql">CREATE EXTENSION pageinspect;

SELECT lower, upper, special, pagesize, prune_xid FROM page_header(get_raw_page(&#39;books&#39;, 0));
</code></pre><pre><code> lower | upper | special | pagesize | prune_xid
-------+-------+---------+----------+-----------
    28 |  6352 |    8192 |     8192 |         0
</code></pre><p>The first four values <code>lower</code>, <code>upper</code>, <code>special</code>, <code>pagesize</code> are byte offsets within the page. We see that the page has a size of 8kB and since this is a heap page there is no special space allocated (it points to the very end of the page). Also, there is currently only a single item identifier present since <code>lower</code> is at byte 28 (as discussed above, a single identifier is 4 bytes and the header itself is 24 bytes).</p><p>We can infer two more pieces of information from the <code>upper</code> value: the item size is 1840 bytes (<code>pagesize - upper</code>) and the page therefore has 6504 bytes (<code>upper - lower</code>) of unallocated space.</p><p>The value in <code>prune_xid</code> refers to a transaction ID (or none if 0 as in our case), more details on that later.</p><p>To inspect the tuples in the page, we can use the <code>heap_page_items</code> function. I again chose only a subset of the fields for clarity:</p><pre data-lang="sql"><code data-lang="sql">SELECT
    lp, lp_off, lp_flags, lp_len, t_xmin, t_xmax, t_ctid, t_infomask, t_infomask2, t_hoff, t_data
FROM heap_page_items(get_raw_page(&#39;books&#39;, 0));
</code></pre><pre><code> lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_ctid | t_infomask | t_infomask2 | t_hoff | t_data
----+--------+----------+--------+--------+--------+--------+------------+-------------+--------+--------
  1 |   6352 |        1 |   1840 |   1148 |      0 | (0,1)  |       2306 |           4 |     24 | .....
</code></pre><p>Confirming our observation from the page header, so far there is only a single row version in the page.</p><p>The <code>lp</code> prefix of the first four columns stands for &#34;line pointer&#34; and corresponds to the data of the item identifier. The first <code>lp</code> column represents the item number in the current page, <code>lp_off</code> the offset in bytes where the actual item starts within the page, <code>lp_flags</code> the status of the item and <code>lp_len</code> its length in bytes (see the page layout illustration above).</p><p>Since there is only a single item in the page, the <code>lp_off</code> value corresponds to the <code>upper</code> value of the page header. We can now also confirm what we already derived from the page header: the item is 1840 bytes long.</p><p>The <code>t_hoff</code> value is an offset from the start of the item to the start of user data, which is stored in the <code>t_data</code> column. I removed the actual content in the output above as it is not relevant for the purposes of our investigation.</p><p>The remaining header columns <code>t_xmin</code>, <code>t_xmax</code>, <code>t_ctid</code>, <code>t_infomask</code> are the most interesting as they play an important role when rows are modified and to determine which, if any, row version to return to the client. We will discuss them in more detail next.</p><h3 id="row-updates">Row updates</h3><p>Let&#39;s say Alice finished reading our book and since it&#39;s so good we immediately lend it out again, this time to Bob. We update our table:</p><pre data-lang="sql"><code data-lang="sql">UPDATE books SET lent_to = &#39;Bob&#39; where id = 1;
</code></pre><p>How is this update reflected under the hood?</p><pre data-lang="sql"><code data-lang="sql">SELECT lp, lp_off, lp_flags, lp_len, t_xmin, t_xmax, t_infomask, t_infomask2
FROM heap_page_items(get_raw_page(&#39;books&#39;, 0));
</code></pre><pre><code> lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_infomask | t_infomask2
----+--------+----------+--------+--------+--------+------------+-------------
  1 |   6352 |        1 |   1840 |   1148 |   1149 |        258 |       16388
  2 |   4512 |        1 |   1840 |   1149 |      0 |      10242 |       32772
</code></pre><p>With MVCC, the previous tuple cannot be updated in place by changing <code>t_data</code>. Instead a second tuple, a new row version, is added for the update. Data that has not changed between versions is also present in the new tuple. As discussed earlier, the second tuple is added above the first one, shown by the lower <code>lp_off</code> value. Both tuples are in the <code>normal</code> state (<code>lp_flags</code>) and have the same size (<code>lp_len</code>).</p><p>The interesting aspects are the <code>t_xmin</code> and <code>t_xmax</code> values. They respectively indicate which transaction IDs inserted and deleted a particular row version.</p><p>Transaction IDs form the basis for Postgres&#39; MVCC mechanism and, to simplify, you can think of them as points in time at which data was modified. Using them as values for <code>t_xmin</code> and <code>t_xmax</code> therefore defines time spans in which particular row versions are visible. This enables consistent views of the same data despite concurrent updates.</p><p>A <code>t_xmax</code> value of 0 is a special value indicating that the tuple has not been deleted and is the latest version of the row. As shown in the example, in simplified terms, a row update can be considered as deleting the previous version (setting <code>t_xmax</code>) and inserting a new one (with the same ID for <code>t_xmin</code>).</p><p>However, the <code>t_xmin</code> and <code>t_xmax</code> values by themselves are not enough to determine which row version is visible in a given situation. It is not clear from the IDs alone whether or not the transaction was actually committed. Making row versions from uncommitted transactions visible, a &#34;dirty read&#34;, is not allowed in Postgres, regardless of the transaction isolation level.</p><p>This is where the <code>t_infomask</code> and <code>t_infomask2</code> columns come in. They store extra information that help determine the state of the inserting / deleting transaction. We can use the <code>heap_tuple_infomask_flags</code> function to decode their meaning:</p><pre data-lang="sql"><code data-lang="sql">SELECT lp, t_xmin, t_xmax, t_infomask, t_infomask2, raw_flags
FROM heap_page_items(get_raw_page(&#39;books&#39;, 0)),
LATERAL heap_tuple_infomask_flags(t_infomask, t_infomask2);
</code></pre><pre><code> lp | t_xmin | t_xmax | t_infomask | t_infomask2 |       raw_flags
----+--------+--------+------------+-------------+-----------------------
  1 |   1148 |   1149 |        258 |       16388 | {HEAP_XMIN_COMMITTED}
  2 |   1149 |      0 |      10242 |       32772 | {HEAP_XMAX_INVALID}
</code></pre><p>I removed some of the <code>raw_flags</code> values which are not relevant right now. We can see the <code>HEAP_XMIN_COMMITTED</code> flag for the first row version, indicating that the transaction that inserted that tuple was committed and <code>HEAP_XMAX_INVALID</code> for the second row version, indicating that the 0 value should be ignored (because it is not a transaction ID).</p><p>This raises the question: why aren&#39;t we seeing a <code>HEAP_XMAX_COMMITTED</code> flag for the first tuple and similarly a <code>HEAP_XMIN_COMMITTED</code> flag for the second tuple? After all, the update we performed earlier is already committed.</p><p>The reason for this state is that when a new row version is added and/or a previous one modified, the hint bits for the transaction state cannot be updated at the same time since it is not clear if the transaction making the change will commit or not.</p><p>There is also no record-keeping of which pages were modified by a transaction (it would be expensive to do so) and so once a transaction is committed this event is not reflected in the affected pages. Instead, Postgres keeps track of commit status of all transactions in a separate commit log (in the <code>pg_xact</code> directory).</p><h3 id="hint-bit-updates">Hint bit updates</h3><p>As we saw in the last example, this leaves row versions that were modified by a previous transaction in an ambiguous state: is a particular tuple visible or not? Put differently: was the transaction that made a change to the tuple committed or not? The server has to consult the commit log to answer this question.</p><p>Once answered, any statement accessing tuples in such a state sets the hint bits in the infomask on the relevant tuple headers to record the answer - you see where this is going. This way the ambiguity about a tuple&#39;s visibility is resolved for subsequent statements which avoids the extra check of the commit log.</p><p>Recording this answer can cause a write by a simple <code>SELECT</code> query.</p><p>We can verify this easily in our example, simply by reading from our table now:</p><pre data-lang="sql"><code data-lang="sql">EXPLAIN (ANALYZE, BUFFERS, COSTS OFF) SELECT * FROM books;
</code></pre><pre><code>                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on books (actual time=0.015..0.016 rows=1 loops=1)
   Buffers: shared hit=1 dirtied=1
 Planning:
   Buffers: shared hit=11
 Planning Time: 0.369 ms
 Execution Time: 0.033 ms
</code></pre><p>I used <code>EXPLAIN</code> with a couple of options to show the execution plan of that statement. The <code>ANALYZE</code> option makes the statement get executed and <code>BUFFERS</code> shows how it interacted with the internal cache where the page for our table is kept (<code>COSTS OFF</code> to make the output easier to read).</p><p>By <code>SELECT</code>ing the entire table, we of course had to read from the single page stored in shared buffers (<code>hit=1</code>), and, crucially, while doing so we &#34;dirtied&#34; the page which means that our statement modified the page. A dirtied page means that it will have to be written to disk sooner or later (either when the <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER" rel="noopener" target="_blank">background writer</a> processes it or when it gets evicted from the shared buffers cache).</p><p>Checking the tuples in the page again to verify the hint bits were updated:</p><pre><code> lp | t_xmin | t_xmax | t_infomask | t_infomask2 |                raw_flags
----+--------+--------+------------+-------------+-------------------------------------------
  1 |   1148 |   1149 |       1282 |       16388 | {HEAP_XMIN_COMMITTED,HEAP_XMAX_COMMITTED}
  2 |   1149 |      0 |      10498 |       32772 | {HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}
</code></pre><p>Now the flags show that the transaction updating our row was committed.</p><p>Another <code>SELECT</code> does not dirty the page again:</p><pre><code>                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on books (actual time=0.028..0.030 rows=1 loops=1)
   Buffers: shared hit=1
 Planning Time: 0.591 ms
 Execution Time: 0.051 ms
</code></pre><p>We covered a lot of ground now and explored the first of the two mechanisms that can cause writes by read queries. Let&#39;s move on to the second: page pruning.</p><h3 id="page-pruning">Page pruning</h3><p>As seen above, updates (or deletes) of a row will leave old row versions in the page - even if they are no longer visible to any transaction.</p><p>Such outdated dead tuples must be garbage collected as the database would otherwise need an ever-increasing amount of storage. Compared to the heavy <code>VACUUM</code>, page pruning is a much more lightweight process as it only deletes outdated row versions within a single heap page.</p><p>Indexes may still reference the outdated tuples. This is not an issue though as the item pointers themselves are not removed, only the actual items in the page. We&#39;ll see this in more detail shortly.</p><p>The pruning process can, in principle, be triggered by any statement accessing a heap page. But even though it is a fairly lightweight process, it would still be expensive to attempt pruning every single time a page is accessed.</p><p>Instead, it is only triggered when available space in a page is limited and pruning is likely to be useful. When a table row is updated the oldest unpruned transaction ID of any of the page tuples&#39; <code>x_max</code> field is stored in the page header as a hint field (<code>prune_xid</code>).</p><p>A subsequent statement accessing the page uses this hint to check if pruning is likely to be useful at all. Then, if there is less than 10% or less than <a href="https://www.postgresql.org/docs/17/sql-createtable.html#RELOPTION-FILLFACTOR" rel="noopener" target="_blank">fillfactor</a> percent of unallocated space in a page, pruning will kick in and try to make room for a new tuple.</p><p>Let&#39;s continue with our small library example and see that process directly in the database. To start from a clean slate, we truncate the table (the page and with it all previous tuples backing the table are wiped). After the insert, we update the row three times so that the page is almost completely full:</p><pre data-lang="sql"><code data-lang="sql">TRUNCATE books;

INSERT INTO books VALUES (1, &#39;Designing Data-Intensive Applications&#39;, &#39;Martin Kleppmann&#39;, &#39;Alice&#39;);
UPDATE books SET lent_to = &#39;Bob&#39; where id = 1;
UPDATE books SET lent_to = &#39;Charlie&#39; where id = 1;
UPDATE books SET lent_to = &#39;Doris&#39; where id = 1;

SELECT flags, lower, upper, special, pagesize, prune_xid
FROM page_header(get_raw_page(&#39;books&#39;, 0));
</code></pre><pre><code> flags | lower | upper | special | pagesize | prune_xid
-------+-------+-------+---------+----------+-----------
     0 |    40 |   832 |    8192 |     8192 |      1152
</code></pre><p>The page has no special flags set, it only has 792 bytes of free space remaining (<code>upper - lower</code>) and <code>prune_xid</code> is set to transaction ID <code>1152</code> - providing the hint that there are unpruned tuples in the page.</p><p>Let&#39;s see the page items:</p><pre data-lang="sql"><code data-lang="sql">SELECT
    lp, lp_off, lp_flags, lp_len, t_xmin, t_xmax, t_ctid, t_infomask, t_infomask2
FROM heap_page_items(get_raw_page(&#39;books&#39;, 0));
</code></pre><pre><code> lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_ctid | t_infomask | t_infomask2
----+--------+----------+--------+--------+--------+--------+------------+-------------
  1 |   6352 |        1 |   1840 |   1151 |   1152 | (0,2)  |       1282 |       16388
  2 |   4512 |        1 |   1840 |   1152 |   1153 | (0,3)  |       9474 |       49156
  3 |   2672 |        1 |   1840 |   1153 |   1154 | (0,4)  |       8450 |       49156
  4 |    832 |        1 |   1840 |   1154 |      0 | (0,4)  |      10242 |       32772
</code></pre><p>There are four tuples, corresponding to the initial insert and the three updates of course. As we already saw earlier, every updating transaction set its ID as the <code>t_xmax</code> on the previous row version rendering it invisible to any newer transactions. The <code>lp_flags</code> are all <code>1</code> <a href="https://github.com/postgres/postgres/blob/master/src/include/storage/itemid.h#L39" rel="noopener" target="_blank">indicating</a> normal, in use, tuples. We&#39;ll discuss <code>t_ctid</code> in more detail in a bit.</p><p>Since there is less than 10% of free space remaining in our page (fillfactor is at 100 percent per default, so it has no effect) and <code>prune_xid</code> is non-zero, the next access to the page will trigger the pruning mechanism:</p><pre data-lang="sql"><code data-lang="sql">EXPLAIN (ANALYZE, BUFFERS, COSTS OFF) SELECT * FROM books;
</code></pre><pre><code>                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on books (actual time=0.037..0.038 rows=1 loops=1)
   Buffers: shared hit=1 dirtied=1
 Planning:
   Buffers: shared hit=11
 Planning Time: 0.292 ms
 Execution Time: 0.047 ms
</code></pre><p>The query plan again shows that the page was dirtied by a read-only query.</p><p>Let&#39;s verify that this time the pruning mechanism modified our page.</p><pre><code> flags | lower | upper | special | pagesize | prune_xid
-------+-------+-------+---------+----------+-----------
     1 |    40 |  6352 |    8192 |     8192 |         0
</code></pre><p>First, in the page header we can see that the <code>prune_xid</code> was reset to 0. The flags <code>1</code> <a href="https://github.com/postgres/postgres/blob/master/src/include/storage/bufpage.h" rel="noopener" target="_blank">indicate</a> that the page has free lines. The number of pointers has not changed (<code>lower</code> is still <code>40</code> bytes), but we now have <code>6312</code> bytes available again in the page.</p><p>Looking at the page items once more, we can make a few observations.</p><pre><code> lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_ctid | t_infomask | t_infomask2
----+--------+----------+--------+--------+--------+--------+------------+-------------
  1 |      4 |        2 |      0 |        |        |        |            |
  2 |      0 |        0 |      0 |        |        |        |            |
  3 |      0 |        0 |      0 |        |        |        |            |
  4 |   6352 |        1 |   1840 |   1154 |      0 | (0,4)  |      10498 |       32772
</code></pre><p>Firstly, we still see the four line pointers. Only the last update (<code>t_ctid (0,4)</code>) remains as a normal (<code>lp_flags 1</code>) tuple. It was moved to the bottom of the page (<code>lp_off</code>) so that available space is not fragmented. The two lines in the middle are unused (<code>lp_flags 0</code>) and can immediately be reused for the next tuple.</p><p>Line 1 looks different, however. The flag is set to <code>redirect</code> and <code>lp_off</code> is used as a link to the redirected line number. But why redirect at all?</p><p>I briefly touched on this earlier: Tuple 1, being the original row version, is still referenced from the <code>books_pkey</code> index which was automatically created as it backs the primary key constraint on the <code>id</code> column. As mentioned above, heap pruning only touches a single heap page and therefore does not modify the index. Of course, the reference must not be broken and so line pointer 1 has to remain where it is and since it cannot point to the now deleted original row version, it redirects to the latest version of the original tuple.</p><hr/><p>We discussed now what we set out to do: investigate two mechanisms that can cause writes for simple read queries.</p><p>However, ending the article after this last example would feel unsatisfying, as you may ask: why was only the original row version included in the index and not the later versions? Put differently again, why aren&#39;t line pointers 2 and 3 redirecting to item 4?</p><p>Let&#39;s briefly discuss one last topic to answer this question.</p><h4 id="hot-updates">HOT updates</h4><p>Postgres can use an optimisation called heap-only tuples (HOT) to record certain row updates only on the heap, i.e. in the main table data, and avoid having to update indexes as well. HOT updates are only possible if the update does not change any columns that are indexed (otherwise the index would be incorrect) and if there is enough free space in the same page containing the previous row version (as in our example).</p><p>Dead tuples can be reclaimed more easily this way as they would otherwise only be removed by a more expensive <code>VACUUM</code>.</p><p>Continuing our example with two more updates, the previously deallocated space gets filled again:</p><pre data-lang="sql"><code data-lang="sql">UPDATE books SET lent_to = &#39;Emily&#39; where id = 1;
UPDATE books SET lent_to = &#39;Franz&#39; where id = 1;
</code></pre><p>This time, we again want to look at <code>raw_flags</code> of the tuple headers as they provide additional context (I removed the flags related to commit status for clarity in the output below):</p><pre data-lang="sql"><code data-lang="sql">SELECT lp, lp_off, lp_flags, lp_len, t_xmin, t_xmax, t_ctid, t_infomask, t_infomask2, raw_flags
FROM heap_page_items(get_raw_page(&#39;books&#39;, 0)),
LATERAL heap_tuple_infomask_flags(t_infomask, t_infomask2);
</code></pre><pre><code> lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_ctid | t_infomask | t_infomask2 |                    raw_flags
----+--------+----------+--------+--------+--------+--------+------------+-------------+------------------------------------------------
  1 |      4 |        2 |      0 |        |        |        |            |             |
  2 |   4512 |        1 |   1840 |   1155 |   1156 | (0,3)  |       8450 |       49156 | {HEAP_UPDATED,HEAP_HOT_UPDATED,HEAP_ONLY_TUPLE}
  3 |   2672 |        1 |   1840 |   1156 |      0 | (0,3)  |      10242 |       32772 | {HEAP_UPDATED,HEAP_ONLY_TUPLE}
  4 |   6352 |        1 |   1840 |   1154 |   1155 | (0,2)  |       9474 |       49156 | {HEAP_UPDATED,HEAP_HOT_UPDATED,HEAP_ONLY_TUPLE}
</code></pre><p>All three normal line pointers have the <code>HEAP_ONLY_TUPLE</code>, signalling the tuple is not referenced in an index. As already discussed, line pointer 1 redirects to pointer 4. Line pointer 4 has the <code>HEAP_HOT_UPDATED</code> flag set, indicating that there is another tuple with a newer version - the <code>t_ctid</code> column links to the next version (line pointer 2). The same logic applies to row version 2 linking to item 3. Item 3 does not have the <code>HEAP_HOT_UPDATED</code> flag set and has <code>t_ctid</code> pointing to itself, ending the HOT update chain and signalling that it is the latest version.</p><p>While this optimisation can save updating indexes, the downside is that this chain must be followed to find the latest visible row version.</p><p>If there is not enough space for the update in the page containing the current row version, then the new version has to be inserted in the next page and into indexes.</p><p>In this article I tried to provide some details about two mechanisms that can cause writes for simple read queries and some of the implications of Postgres&#39; mutli-version concurrency control.</p><p>The next time you encounter dirtied buffers in the output of your query plan, or see positive values for written or dirtied blocks in the <code>pg_stat_statements</code> view for read-only queries, I hope this article convinced you that these are indications of normal and useful behaviour of your Postgres server.</p><p>If you want to learn more about the inner workings of Postgres, reading more of the <a href="https://www.postgresql.org/docs/17/internals.html" rel="noopener" target="_blank">documentation</a> is always a good starting point. I can also highly recommend <a href="https://postgrespro.com/community/books/internals" rel="noopener" target="_blank">PostgreSQL 14 Internals</a> by Egor Rogov. Most of the details described there are still relevant and applicable to PostgreSQL 17.</p><hr/></div></section></div>
  </body>
</html>
