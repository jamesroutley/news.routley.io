<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/">Original</a>
    <h1>How to (and how not to) fix color banding</h1>
    
    <div id="readability-page-1" class="page"><div><p>I <strong>love</strong> to use soft gradients as backdrops when doing graphics programming, a love started by a <a href="https://corona-renderer.com/">Corona Renderer</a> product shot <a href="https://forum.corona-renderer.com/index.php?topic=11345">sample scene</a> shared by user <a href="https://forum.corona-renderer.com/index.php?action=profile;u=9510">romullus</a> and its use of radial gradients to highlight the product. But they are quite horrible from a design standpoint, since they produce awful <a href="https://en.wikipedia.org/wiki/Colour_banding">color banding</a>, also referred to as <a href="https://en.wikipedia.org/wiki/Posterization">posterization</a>. Depending on things like screen type, gradient colors, viewing environment, etc., the effect can be sometimes not present at all, yet sometimes painfully obvious. Let’s take a look at what I mean. The following is a WebGL Canvas drawing a black &amp; white, dark and soft half-circle gradient.</p><blockquote><details><summary><a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/screenshot_gradient.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/screenshot_gradient.png" alt=""/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	tex <span>=</span> vtx<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/banding.fs">banding.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>vec3</span> outsidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.15</span><span>)</span><span>;</span>
	<span>vec3</span> insidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.2</span><span>)</span><span>;</span>
	<span>vec3</span> bgcolor <span>=</span> <span>mix</span><span>(</span>insidecolor<span>,</span> outsidecolor<span>,</span>
					   <span>length</span><span>(</span><span>vec2</span><span>(</span>tex<span>.</span>x<span>,</span> tex<span>.</span>y <span>*</span> <span>0.5</span> <span>+</span> <span>1.0</span><span>)</span><span>)</span><span>)</span><span>;</span>
	gl_FragColor <span>=</span> <span>vec4</span><span>(</span>bgcolor<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>
<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>

	
	<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>)</span><span>;</span>
	<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>)</span><span>;</span>

	<span>const</span> shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
	gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>createAndCompileShader</span><span>(</span><span>type<span>,</span> source</span><span>)</span> <span>{</span>
		<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
		gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>.</span>text<span>)</span><span>;</span>
		gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span> <span>{</span>
			console<span>.</span><span>error</span><span>(</span>gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
		<span>}</span>
		<span>return</span> shader<span>;</span>
	<span>}</span>

	
	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientWidth <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientHeight <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>
			<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>This produces a 24-bit (8-bits per channel) image with clearly visible banding steps. If you don’t see the banding due to being a bright environment or having the screen brightness set to very low, reference the pictures below. Here is what it should look like on an 8-bit panel, specifically the <a href="https://jp.ext.hp.com/monitors/business/z_z24n_g2/">HP Z24n G2</a> monitor that is connected to my laptop. It should also look the same on a high-end 10-bit or 12-bit panel, since WebGL doesn’t allow high bit-depth output. The image is brightness and contrast boosted, to make the steps obvious.</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/Banding.jpg" alt="Photo: WebGL color banding, on an 8-bit panel, contrast and brightness boosted"/><figcaption>Photo: WebGL color banding, on a 8-bit panel, contrast and brightness boosted</figcaption></figure><p>Many Laptop screens are in fact 6-bit panels performing dithering to fake an 8-bit output. This includes even high-priced workstations replacements, like the <a href="https://support.hp.com/us-en/document/c06909298#AbT5">HP Zbook Fury 15 G7</a> and its <a href="https://www.panelook.com/N156HCA-GA3__15.6__overview_33518.html">6-bit LCD panel</a>, that I sit in front of right now. What you can see are <em>some</em> banding steps being a clean uniform color and <em>some</em> of them being dithered via the panel’s integrated look-up table to achieve a perceived 8-bit output via <a href="https://en.wikipedia.org/wiki/Ordered_dithering">ordered dithering</a>. Though note, how the dithering does <strong>not</strong> result in the banding steps being broken up, it just dithers the color step itself. Capturing this via a photo is a bit difficult, since there is also the pattern of individual pixels messing with the capture and introducing <a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern">moiré </a>and interference patterns.</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/Dithering.jpg" alt="Photo: Above WebGL color banding sample, on a 6-bit panel, contrast and brightness boosted"/><figcaption>Photo: WebGL color banding, on a 6-bit panel, contrast and brightness boosted.</figcaption></figure><blockquote><p>It&#39;s not obvious from the photo, but the dither pattern is distinctly visible when looking closely with the naked eye.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"/></blockquote><h2 id="magic-glsl-one-liner" tabindex="-1">Magic GLSL One-liner <a href="#magic-glsl-one-liner">#</a></h2><p>Let’s fix this. The main point of this article is to share how I get banding free gradients in one GLSL fragment shader, rendering in a single pass and without sampling or texture taps to achieve banding free-ness. It involves the best noise one-liner I have ever seen. That genius one-liner is not from me, but from <a href="http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare">Jorge Jimenez’s presentation on how Gradient noise was implemented in Call of Duty Advanced Warfare</a>. You can read it on the presentation’s slide 123 onwards. It’s described as:</p><blockquote><p>[…] a noise function that we could classify as being half way between dithered and random, and that we called <strong><em>Interleaved Gradient Noise</em></strong>.</p></blockquote><p>Here is what the raw noise looks like. The following WebGL Canvas is set to render at the same pixel density as your screen. (Though some Screen DPI and Browser zoom levels will result in it being one pixel off and there being a tiny bit of interpolation)</p><blockquote><details><summary><a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/raw_noise.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/raw_noise.png" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/noise.vs">noise.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/noise.fs">noise.fs</a></summary><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>



<span>float</span> <span>gradientNoise</span><span>(</span><span>in</span> <span>vec2</span> uv<span>)</span>
<span>{</span>
	<span>return</span> <span>fract</span><span>(</span><span>52.9829189</span> <span>*</span> <span>fract</span><span>(</span><span>dot</span><span>(</span>uv<span>,</span> <span>vec2</span><span>(</span><span>0.06711056</span><span>,</span> <span>0.00583715</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	gl_FragColor <span>=</span> <span>vec4</span><span>(</span><span>vec3</span><span>(</span><span>0.0</span><span>)</span> <span>+</span> <span>gradientNoise</span><span>(</span>gl_FragCoord<span>.</span>xy<span>)</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>
<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>

	
	<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>)</span><span>;</span>
	<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>)</span><span>;</span>

	<span>const</span> shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
	gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>createAndCompileShader</span><span>(</span><span>type<span>,</span> source</span><span>)</span> <span>{</span>
		<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
		gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>.</span>text<span>)</span><span>;</span>
		gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span> <span>{</span>
			console<span>.</span><span>error</span><span>(</span>gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
		<span>}</span>
		<span>return</span> shader<span>;</span>
	<span>}</span>

	
	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientWidth <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientHeight <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>
			<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>Now let’s combine both previous WebGL examples to clear the color banding and get a smooth half-circle gradient.</p><blockquote><details><summary><a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/screenshot_gradient_dither.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p>You <em><strong>have</strong></em> to view this at 1:1 pixel scale, otherwise your browser’s will counteract the pixel sized dither and re-introduce color banding!</p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	tex <span>=</span> vtx<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/gradient.fs">gradient.fs</a></summary><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>



<span>float</span> <span>gradientNoise</span><span>(</span><span>in</span> <span>vec2</span> uv<span>)</span>
<span>{</span>
	<span>return</span> <span>fract</span><span>(</span><span>52.9829189</span> <span>*</span> <span>fract</span><span>(</span><span>dot</span><span>(</span>uv<span>,</span> <span>vec2</span><span>(</span><span>0.06711056</span><span>,</span> <span>0.00583715</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>vec3</span> outsidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.15</span><span>)</span><span>;</span>
	<span>vec3</span> insidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.2</span><span>)</span><span>;</span>
	<span>vec3</span> bgcolor <span>=</span> <span>mix</span><span>(</span>insidecolor<span>,</span> outsidecolor<span>,</span>
					   <span>length</span><span>(</span><span>vec2</span><span>(</span>tex<span>.</span>x<span>,</span> tex<span>.</span>y <span>*</span> <span>0.5</span> <span>+</span> <span>1.0</span><span>)</span><span>)</span><span>)</span><span>;</span>
	bgcolor <span>+=</span> <span>(</span><span>1.0</span> <span>/</span> <span>255.0</span><span>)</span> <span>*</span> <span>gradientNoise</span><span>(</span>gl_FragCoord<span>.</span>xy<span>)</span> <span>-</span> <span>(</span><span>0.5</span> <span>/</span> <span>255.0</span><span>)</span><span>;</span>

	gl_FragColor <span>=</span> <span>vec4</span><span>(</span>bgcolor<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>
<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>

	
	<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>)</span><span>;</span>
	<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>)</span><span>;</span>

	<span>const</span> shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
	gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>createAndCompileShader</span><span>(</span><span>type<span>,</span> source</span><span>)</span> <span>{</span>
		<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
		gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>.</span>text<span>)</span><span>;</span>
		gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span> <span>{</span>
			console<span>.</span><span>error</span><span>(</span>gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
		<span>}</span>
		<span>return</span> shader<span>;</span>
	<span>}</span>

	
	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientWidth <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientHeight <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>
			<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/banding-free.jpg" alt="Photo: Above WebGL Gradient with Interleaved Gradient Noise applied, on an 8-bit panel. Brightness &amp; contrast boosted"/><figcaption>Photo: Above WebGL Gradient with Interleaved Gradient Noise applied, on an 8-bit panel. Brightness &amp; contrast boosted</figcaption></figure><blockquote><p>Perfectly smooth on my monitor with the 8-bit panel!</p><img src="https://blog.frost.kiwi/assets/kiwis/party.svg"/></blockquote><p>Same monitor and photo setup as the color-banded mess from the beginning of the article. No trickery with different zoom levels or filters. The noise is essentially invisible. It’s my own article and still I’m surprised myself at the effectiveness of that simple one-liner.</p><p>Technically, the proper way to achieve banding free-ness is to perform <a href="https://en.wikipedia.org/wiki/Error_diffusion">error diffusion dithering</a>, since that would breakup just the quantized steps of the gradient, without touching the color between the steps. But other than <a href="https://en.wikipedia.org/wiki/Ordered_dithering">ordered dithering</a>, there is no GPU friendly way to do this and even very faint <a href="https://en.wikipedia.org/wiki/Ordered_dithering">ordered dithering</a> is detectable by human vision, since it applies a fixed pattern. When talking about gradients, adding noise works just fine though, even though it’s not proper error diffusion. Simply applying noise with the strength of one 8-bit grayscale value <code>(1.0 / 255.0) * gradientNoise(gl_FragCoord.xy)</code> side-steps a bunch of issues and the code footprint is tiny to boot. Additionally we subtract the average added brightness of <code>(0.5 / 255.0)</code> to keep the brightness the same, since we are introducing the noise via addition, though the difference is barely noticeable. Here is a part of the gradient with a threshold applied and zoomed in, to see how both gradient and noise interact.</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/threshold.png" alt="Above WebGL gradient thresholded and zoomed in"/><figcaption>Above WebGL gradient thresholded and zoomed in</figcaption></figure><p>Here is how I usually use this Shader setup to draw a background for objects and scenes to live on.</p><blockquote><details><summary><a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/radial.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p>You <em><strong>have</strong></em> to view this at 1:1 pixel scale, otherwise your browser’s will counteract the pixel sized dither and re-introduce color banding!</p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	tex <span>=</span> vtx<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/full_example.fs">full_example.fs</a></summary><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>



<span>float</span> <span>gradientNoise</span><span>(</span><span>in</span> <span>vec2</span> uv<span>)</span>
<span>{</span>
	<span>return</span> <span>fract</span><span>(</span><span>52.9829189</span> <span>*</span> <span>fract</span><span>(</span><span>dot</span><span>(</span>uv<span>,</span> <span>vec2</span><span>(</span><span>0.06711056</span><span>,</span> <span>0.00583715</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>vec3</span> outsidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.22</span><span>,</span> <span>0.23</span><span>,</span> <span>0.25</span><span>)</span><span>;</span>
	<span>vec3</span> insidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.40</span><span>,</span> <span>0.41</span><span>,</span> <span>0.45</span><span>)</span><span>;</span>
	<span>vec3</span> bgcolor <span>=</span> <span>mix</span><span>(</span>insidecolor<span>,</span> outsidecolor<span>,</span>
					   <span>length</span><span>(</span>tex<span>)</span><span>)</span><span>;</span>
	bgcolor <span>+=</span> <span>(</span><span>1.0</span> <span>/</span> <span>255.0</span><span>)</span> <span>*</span> <span>gradientNoise</span><span>(</span>gl_FragCoord<span>.</span>xy<span>)</span> <span>-</span> <span>(</span><span>0.5</span> <span>/</span> <span>255.0</span><span>)</span><span>;</span>

	gl_FragColor <span>=</span> <span>vec4</span><span>(</span>bgcolor<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>
<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>

	
	<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>)</span><span>;</span>
	<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>)</span><span>;</span>

	<span>const</span> shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
	gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
	gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>createAndCompileShader</span><span>(</span><span>type<span>,</span> source</span><span>)</span> <span>{</span>
		<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
		gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>.</span>text<span>)</span><span>;</span>
		gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span> <span>{</span>
			console<span>.</span><span>error</span><span>(</span>gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
		<span>}</span>
		<span>return</span> shader<span>;</span>
	<span>}</span>

	
	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientWidth <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>canvas<span>.</span>clientHeight <span>*</span> window<span>.</span>devicePixelRatio<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>
			<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><h3 id="don%E2%80%99t-double-dither" tabindex="-1">Don’t Double Dither <a href="#don%E2%80%99t-double-dither">#</a></h3><p>But what about that 6-bit laptop screen? Let’s take a look, by photographing the dithered gradient like in the beginning of the article…</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/6-bit_banding_8-bit_noise.jpg" alt="Interference patterns from both forms of dither interfering"/><figcaption>Interference patterns from both forms of dither interfering</figcaption></figure><blockquote><p>...ohh you gotta be kidding me</p><img src="https://blog.frost.kiwi/assets/kiwis/facepalm.svg"/></blockquote><p>Both the 6-bit screen’s dithering pattern and our Interleaved Gradient Noise interfere with each other. Exactly the color bands where the panel performs the dithering, we can see the the interference appearing in the form of saw-tooth ridges. Maybe by increasing the noise strength to correspond to 6-bit values? <code>(1.0 / 64.0) * gradientNoise(gl_FragCoord.xy) - (0.5 / 64.0)</code> By dividing by 64 instead of 255, we get 6-bit noise. Let’s see…</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/6-bit_banding_6-bit_noise.jpg" alt="Interference patterns from both forms of dither interfering"/><figcaption>Interference patterns from both forms of dither interfering with 6-bit noise</figcaption></figure><blockquote><p>...it&#39;s worse!</p><img src="https://blog.frost.kiwi/assets/kiwis/miffed.svg"/></blockquote><p>Clearly obvious diagonal stripes throughout the whole gradient. Yeah, 6-bit panels are a travesty. Especially on a product of this caliber. I mean the old <a href="https://www.youtube.com/watch?v=Fs4GjDiOie8">Thinkpad T500 &amp; X200 I hardware modded</a> have 6-bit panels, but those are multiple tech generations old. We could tweak the noise algorithm, but it’s just not worth to drop our denominator so low. It’s 2024 in a couple days and every human being deserves at least 256 different shades in each color channel.</p><h3 id="bufferless-version" tabindex="-1">Bufferless Version <a href="#bufferless-version">#</a></h3><p>Here is what the shaders look like if you use OpenGL 3.3, OpenGL 2.1 with the <a href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"><code>GL_EXT_gpu_shader4</code></a> extension (<code>#version</code> would have to change) or WebGL2 and want to skip the Vertex Buffer setup by putting the fullscreen triangle into the vertex shader. If you get an error around <code>gl_VertexID</code> missing, you don’t have <a href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"><code>GL_EXT_gpu_shader4</code></a> enabled.</p><p>These can be rewritten to work with even the most basic OpenGL or WebGL standard by uploading the vertex buffer prior, as done in all the WebGL examples up till now. The fragment shader stays basically the same.</p><details><summary>Bufferless Vertex Shader</summary><pre><code><span><span>#</span><span>version</span> <span><span>330</span></span></span>
<span>out</span> <span>vec2</span> tex<span>;</span>

<span>const</span> <span>vec2</span> pos<span>[</span><span>3</span><span>]</span> <span>=</span> <span>vec2</span><span>[</span><span>]</span> <span>(</span>
    <span>vec2</span><span>(</span><span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>)</span><span>,</span>
    <span>vec2</span><span>(</span> <span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>)</span><span>,</span>
    <span>vec2</span><span>(</span><span>-</span><span>1.0</span><span>,</span>  <span>3.0</span><span>)</span>
<span>)</span><span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> pos<span>[</span>gl_VertexID<span>]</span><span>;</span>
    gl_Position <span>=</span> <span>vec4</span><span>(</span>pos<span>[</span>gl_VertexID<span>]</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>Bufferless Fragment Shader</summary><pre><code><span><span>#</span><span>version</span> <span><span>330</span></span></span>
<span>in</span> <span>vec2</span> tex<span>;</span>
<span>out</span> <span>vec4</span> Out_Color<span>;</span>



<span>float</span> <span>gradientNoise</span><span>(</span><span>in</span> <span>vec2</span> uv<span>)</span>
<span>{</span>
    <span>return</span> <span>fract</span><span>(</span><span>52.9829189</span> <span>*</span> <span>fract</span><span>(</span><span>dot</span><span>(</span>uv<span>,</span> <span>vec2</span><span>(</span><span>0.06711056</span><span>,</span> <span>0.00583715</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>vec3</span> outsidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.22</span><span>,</span> <span>0.23</span><span>,</span> <span>0.25</span><span>)</span><span>;</span>
<span>vec3</span> insidecolor <span>=</span> <span>vec3</span><span>(</span><span>0.40</span><span>,</span> <span>0.41</span><span>,</span> <span>0.45</span><span>)</span><span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>vec3</span> bgcolor <span>=</span> <span>mix</span><span>(</span>insidecolor<span>,</span> outsidecolor<span>,</span>
                       <span>sqrt</span><span>(</span>tex<span>.</span>x <span>*</span> tex<span>.</span>x <span>+</span> tex<span>.</span>y <span>*</span> tex<span>.</span>y<span>)</span><span>)</span><span>;</span>

    
    bgcolor <span>+=</span> <span>(</span><span>1.0</span> <span>/</span> <span>255.0</span><span>)</span> <span>*</span> <span>gradientNoise</span><span>(</span>gl_FragCoord<span>.</span>xy<span>)</span> <span>-</span> <span>(</span><span>0.5</span> <span>/</span> <span>255.0</span><span>)</span><span>;</span>
    Out_Color <span>=</span> <span>vec4</span><span>(</span>bgcolor<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><h2 id="what-are-the-big-boys-doing%3F" tabindex="-1">What are the big-boys doing? <a href="#what-are-the-big-boys-doing%3F">#</a></h2><p>To finish off, let’s take a look how color banding is solved in other pieces of software. Not <em>just</em> in the context of gradients, but also beyond.</p><h3 id="alien%3A-isolation" tabindex="-1">Alien: Isolation <a href="#alien%3A-isolation">#</a></h3><p>I consider <a href="https://en.wikipedia.org/wiki/Alien:_Isolation">Alien: Isolation</a> to be a technical master piece in terms of lighting, especially considering the time it was released. They faked realtime global illumination in a really interesting fashion, with the flashlight lighting up the area when shining directly at a wall fairly close and casting a redish ambiance when shining at a deep red door. It’s mostly a hardcoded fake effect working with specific surfaces, but I digress…</p><p>Horror games like Alien: Isolation have a lot of dark scenes with lights creating gradient like falloffs. These are very prone to color banding. The programmers over at <a href="https://www.creative-assembly.com/">creative assembly</a> show multiple ways of tackling this. Let’s take a look at how by dissecting this scene.</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/mission5.jpg" alt="Stage 5 of Alien: Isolation"/><figcaption>Stage 5 of <a href="https://en.wikipedia.org/wiki/Alien:_Isolation">Alien: Isolation</a></figcaption></figure><p>I photographed the middle of the scene, as viewed on my <a href="https://www.dell.com/en-us/shop/alienware-34-curved-qd-oled-gaming-monitor-aw3423dw/apd/210-bcye/monitors-monitor-accessories">Alienware AW3423DW</a>. In this first example, without any color banding mitigation and again with brightness &amp; contrast boosted for clarity within this article. In real-life the color banding is obviously visible when gaming in a dark environment. These are actual photos and not screenshots, which will matter a little later.</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/DeepNo-DebandNo.png" alt="Photo: Strong Color-Banding under the light, contrast &amp; brightness boosted"/><figcaption>Photo: Strong Color-Banding under the light, contrast &amp; brightness boosted</figcaption></figure><h4 id="film-grain" tabindex="-1">Film grain <a href="#film-grain">#</a></h4><p>There is of course the easy way of just slapping a lot of film grain everywhere and Alien: Isolation is definitely guilty of this. In fact way more egregious than other games, with the VHS aesthetic of huge dark blobs.</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/filmgrain.png" alt="Use of Filmgrain, right side brightness &amp; contrast boosted"/><figcaption>Screenshot: Use of Filmgrain, right side brightness &amp; contrast boosted</figcaption></figure><p>It’s not quite as bad when turned down to lower settings and during gameplay it’s animated, but I’m still not a fan. Let’s see if we can do one better…</p><h4 id="deep-color" tabindex="-1">Deep-Color <a href="#deep-color">#</a></h4><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/DeepColor%20On.jpg" alt="Deep Color setting in Alien: Isolation"/><figcaption>Deep Color setting in Alien: Isolation</figcaption></figure><p><em>Deep Color</em> is what Alien: Isolation calls rendering and outputting at 10-bits per channel. The way this setting works is absolutely not obvious though. You can turn it on, but it will only be actually active under a certain set of circumstances:</p><ul><li>Anti-Aliasing <strong>has</strong> to be disabled.<ul><li>That’s a serious bummer. None of the Anti-Aliasing shaders handle the 10-bit signal and just crush the result back down to 8-bit. It’s as if you didn’t turn it on at all :[</li></ul></li><li>Your monitor needs to accept a 10 or 12-bit signal. Otherwise, the game won’t switch into that higher bit-depth mode.<ul><li>Interestingly enough, the monitor doesn’t need to be in that mode, but that mode just has to be <em>available</em> and the switching happens automatically, which I did not expect. In the case of my monitor, this entails switching from 175hz to 144hz, to unlock the 10-bit color option.</li></ul></li></ul><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/DeepYes-DebandNo.png" alt="Photo: No Color-banding thanks to 10-bit output (contrast &amp; brightness boosted)"/><figcaption>Photo: No Color-banding thanks to deep-color (contrast &amp; brightness boosted)</figcaption></figure><blockquote><p>What an excellent result! All banding banished to the shadow realm.</p><img src="https://blog.frost.kiwi/assets/kiwis/surprised.svg"/></blockquote><p>No tricks with different processing of the photo either. The camera captured the exact same exposure and the brightness was boosted in the same way. I suspect, that it’s not just the output being 10-bit, that is giving such a good result, but also some passes being merged at a higher bit-depth and thus reducing color banding further. The result is just way too good for being a mere bump from 256 -&gt; 1024 steps per channel. Please note, that this is in no way shape or form related to <strong>the standard</strong> of HDR. In fact, HDR is explicitly disabled in Windows.</p><p>Of course, you need to have a rather expensive screen, being able to run 10-bits per channel or higher. And even if, sometimes the graphics card you have doesn’t have the right generation of connector, leading you to have to drop color-resolution and/or refresh-rate in order to do so. What else is there?</p><h4 id="reshade%E2%80%99s-deband-effect" tabindex="-1">Reshade’s Deband Effect <a href="#reshade%E2%80%99s-deband-effect">#</a></h4><p><a href="https://reshade.me">ReShade</a> (sometimes mistakenly referred to as <a href="https://github.com/CeeJayDK/SweetFX">SweetFx</a>, a shader collection that used to be part of it) is a popular graphics hook, that applies various effects on top of many games, with many presets custom tuned by the community. ReShade’s versatility and maturity has proven itself over many years of releases and broad palette of supported games. Among the effects you can apply is “Deband” (Simply called “Dither” in the past).</p><figure><img src="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/SweeFX_Deband.fx.png" alt="ReShade&#39;s Deband effect menu"/><figcaption>ReShade&#39;s Deband effect menu</figcaption></figure><p>The <code>Deband.fx</code> Shader (Source code below, for reference) applies dithering to areas, that it detects as affected by color banding, based on the <a href="https://en.wikipedia.org/wiki/Contrast_(vision)#Weber_contrast">“Weber Ratio”</a>.</p><details><summary><a href="https://reshade.me">ReShade</a>&#39;s <a href="https://github.com/crosire/reshade-shaders/blob/slim/Shaders/Deband.fx">Deband.fx</a> source code, for reference</summary><pre><code>

<span><span>#</span><span>include</span> <span>&#34;ReShadeUI.fxh&#34;</span></span>
<span><span>#</span><span>include</span> <span>&#34;ReShade.fxh&#34;</span></span>

<span>uniform</span> <span>bool</span> enable_weber <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding analysis&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Weber ratio&#34;</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;Weber ratio analysis that calculates the ratio of the each local pixel&#39;s intensity to average background intensity of all the local pixels.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;radio&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>true</span><span>;</span>

<span>uniform</span> <span>bool</span> enable_sdeviation <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding analysis&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Standard deviation&#34;</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;Modified standard deviation analysis that calculates nearby pixels&#39; intensity deviation from the current pixel instead of the mean.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;radio&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>true</span><span>;</span>

<span>uniform</span> <span>bool</span> enable_depthbuffer <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding analysis&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Depth detection&#34;</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;Allows depth information to be used when analysing banding, pixels will only be analysed if they are in a certain depth. (e.g. debanding only the sky)&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;radio&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>false</span><span>;</span>

<span>uniform</span> <span>float</span> t1 <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding analysis&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Standard deviation threshold&#34;</span><span>;</span>
    ui_max <span>=</span> <span>0.5</span><span>;</span>
    ui_min <span>=</span> <span>0.0</span><span>;</span>
    ui_step <span>=</span> <span>0.001</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;Standard deviations lower than this threshold will be flagged as flat regions with potential banding.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;slider&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>0.007</span><span>;</span>

<span>uniform</span> <span>float</span> t2 <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding analysis&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Weber ratio threshold&#34;</span><span>;</span>
    ui_max <span>=</span> <span>2.0</span><span>;</span>
    ui_min <span>=</span> <span>0.0</span><span>;</span>
    ui_step <span>=</span> <span>0.01</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;Weber ratios lower than this threshold will be flagged as flat regions with potential banding.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;slider&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>0.04</span><span>;</span>

<span>uniform</span> <span>float</span> banding_depth <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding analysis&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Banding depth&#34;</span><span>;</span>
    ui_max <span>=</span> <span>1.0</span><span>;</span>
    ui_min <span>=</span> <span>0.0</span><span>;</span>
    ui_step <span>=</span> <span>0.001</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;Pixels under this depth threshold will not be processed and returned as they are.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;slider&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>1.0</span><span>;</span>

<span>uniform</span> <span>float</span> range <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding detection &amp; removal&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Radius&#34;</span><span>;</span>
    ui_max <span>=</span> <span>32.0</span><span>;</span>
    ui_min <span>=</span> <span>1.0</span><span>;</span>
    ui_step <span>=</span> <span>1.0</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;The radius increases linearly for each iteration. A higher radius will find more gradients, but a lower radius will smooth more aggressively.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;slider&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>24.0</span><span>;</span>

<span>uniform</span> <span>int</span> iterations <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Banding detection &amp; removal&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Iterations&#34;</span><span>;</span>
    ui_max <span>=</span> <span>4</span><span>;</span>
    ui_min <span>=</span> <span>1</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;The number of debanding steps to perform per sample. Each step reduces a bit more banding, but takes time to compute.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;slider&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>1</span><span>;</span>

<span>uniform</span> <span>int</span> debug_output <span>&lt;</span>
    ui_category <span>=</span> <span>&#34;Debug&#34;</span><span>;</span>
    ui_items <span>=</span> <span>&#34;None\0Blurred (LPF) image\0Banding map\0&#34;</span><span>;</span>
    ui_label <span>=</span> <span>&#34;Debug view&#34;</span><span>;</span>
    ui_tooltip <span>=</span> <span>&#34;Blurred (LPF) image: Useful when tweaking radius and iterations to make sure all banding regions are blurred enough.\nBanding map: Useful when tweaking analysis parameters, continuous green regions indicate flat (i.e. banding) regions.&#34;</span><span>;</span>
    ui_type <span>=</span> <span>&#34;combo&#34;</span><span>;</span>
<span>&gt;</span> <span>=</span> <span>0</span><span>;</span>


<span>uniform</span> <span>int</span> drandom <span>&lt;</span> source <span>=</span> <span>&#34;random&#34;</span><span>;</span> min <span>=</span> <span>0</span><span>;</span> max <span>=</span> <span>32767</span><span>;</span> <span>&gt;</span><span>;</span>

<span>float</span> <span>rand</span><span>(</span><span>float</span> x<span>)</span>
<span>{</span>
    <span>return</span> <span>frac</span><span>(</span>x <span>/</span> <span>41.0</span><span>)</span><span>;</span>
<span>}</span>

<span>float</span> <span>permute</span><span>(</span><span>float</span> x<span>)</span>
<span>{</span>
    <span>return</span> <span>(</span><span>(</span><span>34.0</span> <span>*</span> x <span>+</span> <span>1.0</span><span>)</span> <span>*</span> x<span>)</span> <span>%</span> <span>289.0</span><span>;</span>
<span>}</span>

<span>float3</span> <span>PS_Deband</span><span>(</span><span>float4</span> vpos <span>:</span> SV_Position<span>,</span> <span>float2</span> texcoord <span>:</span> TexCoord<span>)</span> <span>:</span> SV_Target
<span>{</span>
    <span>float3</span> ori <span>=</span> <span>tex2Dlod</span><span>(</span>ReShade<span>::</span>BackBuffer<span>,</span> <span>float4</span><span>(</span>texcoord<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>)</span><span>.</span>rgb<span>;</span>

    <span>if</span> <span>(</span>enable_depthbuffer <span>&amp;&amp;</span> <span>(</span>ReShade<span>::</span><span>GetLinearizedDepth</span><span>(</span>texcoord<span>)</span> <span>&lt;</span> banding_depth<span>)</span><span>)</span>
        <span>return</span> ori<span>;</span>

    
    <span>float3</span> m <span>=</span> <span>float3</span><span>(</span>texcoord <span>+</span> <span>1.0</span><span>,</span> <span>(</span>drandom <span>/</span> <span>32767.0</span><span>)</span> <span>+</span> <span>1.0</span><span>)</span><span>;</span>
    <span>float</span> h <span>=</span> <span>permute</span><span>(</span><span>permute</span><span>(</span><span>permute</span><span>(</span>m<span>.</span>x<span>)</span> <span>+</span> m<span>.</span>y<span>)</span> <span>+</span> m<span>.</span>z<span>)</span><span>;</span>

    
    <span>float</span> dir  <span>=</span> <span>rand</span><span>(</span><span>permute</span><span>(</span>h<span>)</span><span>)</span> <span>*</span> <span>6.2831853</span><span>;</span>
    <span>float2</span> o<span>;</span>
    <span>sincos</span><span>(</span>dir<span>,</span> o<span>.</span>y<span>,</span> o<span>.</span>x<span>)</span><span>;</span>
    
    
    <span>float2</span> pt<span>;</span>
    <span>float</span> dist<span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> iterations<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
        dist <span>=</span> <span>rand</span><span>(</span>h<span>)</span> <span>*</span> range <span>*</span> i<span>;</span>
        pt <span>=</span> dist <span>*</span> BUFFER_PIXEL_SIZE<span>;</span>
    
        h <span>=</span> <span>permute</span><span>(</span>h<span>)</span><span>;</span>
    <span>}</span>
    
    
    <span>float3</span> ref<span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span>
        <span>tex2Dlod</span><span>(</span>ReShade<span>::</span>BackBuffer<span>,</span> <span>float4</span><span>(</span><span>mad</span><span>(</span>pt<span>,</span>                  o<span>,</span> texcoord<span>)</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>)</span><span>.</span>rgb<span>,</span> 
        <span>tex2Dlod</span><span>(</span>ReShade<span>::</span>BackBuffer<span>,</span> <span>float4</span><span>(</span><span>mad</span><span>(</span>pt<span>,</span>                 <span>-</span>o<span>,</span> texcoord<span>)</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>)</span><span>.</span>rgb<span>,</span> 
        <span>tex2Dlod</span><span>(</span>ReShade<span>::</span>BackBuffer<span>,</span> <span>float4</span><span>(</span><span>mad</span><span>(</span>pt<span>,</span> <span>float2</span><span>(</span><span>-</span>o<span>.</span>y<span>,</span>  o<span>.</span>x<span>)</span><span>,</span> texcoord<span>)</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>)</span><span>.</span>rgb<span>,</span> 
        <span>tex2Dlod</span><span>(</span>ReShade<span>::</span>BackBuffer<span>,</span> <span>float4</span><span>(</span><span>mad</span><span>(</span>pt<span>,</span> <span>float2</span><span>(</span> o<span>.</span>y<span>,</span> <span>-</span>o<span>.</span>x<span>)</span><span>,</span> texcoord<span>)</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>)</span><span>.</span>rgb  
    <span>}</span><span>;</span>

    
    <span>float3</span> mean <span>=</span> <span>(</span>ori <span>+</span> ref<span>[</span><span>0</span><span>]</span> <span>+</span> ref<span>[</span><span>1</span><span>]</span> <span>+</span> ref<span>[</span><span>2</span><span>]</span> <span>+</span> ref<span>[</span><span>3</span><span>]</span><span>)</span> <span>*</span> <span>0.2</span><span>;</span>
    <span>float3</span> k <span>=</span> <span>abs</span><span>(</span>ori <span>-</span> mean<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>j<span>)</span> <span>{</span>
        k <span>+=</span> <span>abs</span><span>(</span>ref<span>[</span>j<span>]</span> <span>-</span> mean<span>)</span><span>;</span>
    <span>}</span>

    k <span>=</span> k <span>*</span> <span>0.2</span> <span>/</span> mean<span>;</span>

    
    <span>float3</span> sd <span>=</span> <span>0.0</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>j<span>)</span> <span>{</span>
        sd <span>+=</span> <span>pow</span><span>(</span>ref<span>[</span>j<span>]</span> <span>-</span> ori<span>,</span> <span>2</span><span>)</span><span>;</span>
    <span>}</span>

    sd <span>=</span> <span>sqrt</span><span>(</span>sd <span>*</span> <span>0.25</span><span>)</span><span>;</span>

    
    <span>float3</span> output<span>;</span>

    <span>if</span> <span>(</span>debug_output <span>==</span> <span>2</span><span>)</span>
        output <span>=</span> <span>float3</span><span>(</span><span>0.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
    <span>else</span>
        output <span>=</span> <span>(</span>ref<span>[</span><span>0</span><span>]</span> <span>+</span> ref<span>[</span><span>1</span><span>]</span> <span>+</span> ref<span>[</span><span>2</span><span>]</span> <span>+</span> ref<span>[</span><span>3</span><span>]</span><span>)</span> <span>*</span> <span>0.25</span><span>;</span>

    
    <span>bool3</span> banding_map <span>=</span> <span>true</span><span>;</span>

    <span>if</span> <span>(</span>debug_output <span>!=</span> <span>1</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>enable_weber<span>)</span>
            banding_map <span>=</span> banding_map <span>&amp;&amp;</span> k <span>&lt;=</span> t2 <span>*</span> iterations<span>;</span>

        <span>if</span> <span>(</span>enable_sdeviation<span>)</span>
            banding_map <span>=</span> banding_map <span>&amp;&amp;</span> sd <span>&lt;=</span> t1 <span>*</span> iterations<span>;</span>
    <span>}</span>

	
	
	<span>float</span> grid_position <span>=</span> <span>frac</span><span>(</span><span>dot</span><span>(</span>texcoord<span>,</span> <span>(</span>BUFFER_SCREEN_SIZE <span>*</span> <span>float2</span><span>(</span><span>1.0</span> <span>/</span> <span>16.0</span><span>,</span> <span>10.0</span> <span>/</span> <span>36.0</span><span>)</span><span>)</span> <span>+</span> <span>0.25</span><span>)</span><span>)</span><span>;</span>

	
	<span>float</span> dither_shift <span>=</span> <span>0.25</span> <span>*</span> <span>(</span><span>1.0</span> <span>/</span> <span>(</span><span>pow</span><span>(</span><span>2</span><span>,</span> BUFFER_COLOR_BIT_DEPTH<span>)</span> <span>-</span> <span>1.0</span><span>)</span><span>)</span><span>;</span>

	
	<span>float3</span> dither_shift_RGB <span>=</span> <span>float3</span><span>(</span>dither_shift<span>,</span> <span>-</span>dither_shift<span>,</span> dither_shift<span>)</span><span>;</span> 

	
	dither_shift_RGB <span>=</span> <span>lerp</span><span>(</span><span>2.0</span> <span>*</span> dither_shift_RGB<span>,</span> <span>-</span><span>2.0</span> <span>*</span> dither_shift_RGB<span>,</span> grid_position<span>)</span><span>;</span> 
    
    <span>return</span> banding_map <span>?</span> output <span>+</span> dither_shift_RGB <span>:</span> ori<span>;</span>
<span>}</span>

<span>technique</span> Deband <span>&lt;</span>
ui_tooltip <span>=</span> <span>&#34;Alleviates color banding by trying to approximate original color values.&#34;</span><span>;</span>
<span>&gt;</span>
<span>{</span>
    <span>pass</span>
    <span>{</span>
        <span>VertexShader</span> <span>=</span> PostProcessVS<span>;</span>
        <span>PixelShader</span> <span>=</span> PS_Deband<span>;</span>
    <span>}</span>
<span>}</span></code></pre></details></div></div>
  </body>
</html>
