<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/05/15/ro/">Original</a>
    <h1>SSD death, tricky read-only filesystems, and systemd magic?</h1>
    
    
<p>
Oh, yesterday was a barrel of laughs.  I&#39;ve said a lot that I hate 
hardware, and it&#39;s pretty clear that hardware hates me right back.
</p>
<p>
I have this old 2012-ish Mac Mini which has long since stopped getting 
OS updates from Apple.  It&#39;s been through a lot.  I upgraded the memory 
on it at some point, and maybe four years ago I bought one of those 
&#34;HDD to SSD&#34; kits from one of the usual Mac rejuvenation places.  Both 
of those moves gave it a lot of life, but it&#39;s nothing compared to the 
flexibility I got by moving to Debian.
</p>
<p>
Then a couple of weeks ago, the SSD decided to start going stupid on me.  
This manifested as smartd logging some complaint and then also barking 
about not having any way to send mail.  What can I say - it&#39;s 2024 and 
I don&#39;t run SMTP stuff any more.  It looked like this:
</p>
<pre class="terminal">Apr 29 07:52:23 mini smartd[1140]: Device: /dev/sda [SAT], 1 Currently unreadable (pending) sectors
Apr 29 07:52:23 mini smartd[1140]: Sending warning via /usr/share/smartmontools/smartd-runner to root ...
Apr 29 07:52:23 mini smartd[1140]: Warning via /usr/share/smartmontools/smartd-runner to root produced unexpected output (183 bytes) to STDOUT/STDERR:
Apr 29 07:52:23 mini smartd[1140]: /etc/smartmontools/run.d/10mail:
Apr 29 07:52:23 mini smartd[1140]: Your system does not have /usr/bin/mail.  Install the mailx or mailutils package
</pre>
<p>
Based on the &#34;(pending)&#34; thing, I figured maybe it would eventually 
reallocate itself and go back to a normal and quiet happy place.  I 
ran some backups and then took a few days to visit family.  When I got 
back, it was still happening, so I went to the store and picked up a new 
SSD, knowing full well that replacing it was going to suck.
</p>
<p>
Thus began the multi-hour process of migrating the data from the failing 
drive to the new one across a temporary USB-SATA rig that was super 
slow.  Even though I was using tar (and
<a href="https://rachelbythebay.com/w/2011/12/11/cloning/">not dd,</a>
thank you very much), it still managed to tickle the wrong parts of the 
old drive, and it eventually freaked out.  ext4 dutifully failed into 
read-only mode, and the copy continued.
</p>
<p>
I was actually okay with this because it meant I didn&#39;t have to go to 
any lengths to freeze everything on the box.  Now nothing would change 
during the copy, so that&#39;s great!  Only, well, it exposed a neat little 
problem: Debian&#39;s smartmontools can&#39;t send a notification if it&#39;s 
pointed at a disk that just made the filesystem fail into read-only 
mode.
</p>
<p>
Yes, really, check this out.
</p>
<pre class="terminal">May 14 20:04:47 mini smartd[1993]: Sending warning via /usr/share/smartmontools/smartd-runner to root ...
May 14 20:04:47 mini smartd[1993]: Warning via /usr/share/smartmontools/smartd-runner to root produced unexpected output (92 bytes) to STDOUT/STDERR:
May 14 20:04:47 mini smartd[1993]: mktemp: failed to create file via template ‘/tmp/tmp.XXXXXXXXXX’: Read-only file system
May 14 20:04:47 mini smartd[1993]: Warning via /usr/share/smartmontools/smartd-runner to root: failed (32-bit/8-bit exit status: 256/1)
</pre>
<p>
There it is last night attempting to warn me that things are still bad 
(and in fact have gotten worse) ... and failing miserably.  What&#39;s going 
on here?  It comes from what they have in that smartd-runner script.  
Clearly, they meant well, but it has some issues in certain corner 
cases.
</p>
<p>
This is the entirety of that script:
</p>
<pre class="terminal">#!/bin/bash -e

tmp=$(mktemp)
cat &gt;$tmp

run-parts --report --lsbsysinit --arg=$tmp --arg=&#34;$1&#34; \
    --arg=&#34;$2&#34; --arg=&#34;$3&#34; -- /etc/smartmontools/run.d

rm -f $tmp
</pre>
<p>
Notice run-parts.  It&#39;s an interesting little tool which lets you run a 
bunch of things that don&#39;t have to know about each other.  This lets you 
drop stuff into the /etc/smartmontools/run.d directory and get 
notifications without having to modify anything else.  When you have a 
bunch of potential sources for customizations, a &#34;.d&#34; directory can be 
rather helpful.
</p>
<p>
But, there&#39;s a catch: smartd (well, smartd_warning.sh) fires off this 
giant multi-line message to stdout when it invokes that handler.  The 
handler obviously can&#39;t consume stdin more than once, so it first socks 
it away in a temporary file and then hands that off to the individual 
notifier items in the run.d path.  That way, they all get a fresh copy 
of it.
</p>
<p>
Unfortunately, mktemp requires opening a file for writing, and it tends 
to use a real disk-based filesystem (i.e., whatever&#39;s behind /tmp) to do 
its thing.  It *could* be repointed somewhere else with either -p or 
TMPDIR in the environment (/dev/shm?  /run/something?), but it&#39;s not.
</p>
<p>
This is another one of those &#34;oh yeah&#34; or &#34;hidden gotcha&#34; type things.  
Sometimes, the unhappy path on a system is *really* toxic.  Things you 
take for granted (like writing a file) won&#39;t work.  If you&#39;re supposed 
to operate in that situation and still succeed, it might take some extra 
work.
</p>
<p>
As for the machine, it&#39;s fine now.  And hey, now I have yet another 
device I can plug in any time I want to make smartd start doing stuff.  
That&#39;s useful, right?
</p>
<p>
...
</p>
<p>
One random side note: you might be wondering how I have messages from 
the systemd journal about it not being able to write to the disk.  I was 
storing this stuff to another system as it happened, and it&#39;s in my 
notes, but I just pulled this back out of journalctl right now, and it 
hit me while writing this.  Now I&#39;m wondering how I have them, too!
</p>
<p>
Honestly, I have no idea how this happened.  Clearly, I have some   
learning to do here.  How do you have a read-only filesystem that still 
manages to accept appends to the systemd journal?  Where the hell does 
that thing live?
</p>
<p>
The box has /, /boot, /boot/efi, and swap.  / (dm-1) went readonly.
The journals are in /var/log/journal, which is just part of /.
</p>
<p>
If a tree falls in a forest and nobody&#39;s around...
</p>
<p>
...
</p>
<p>
Late update: yeah, okay, I missed something here.  I&#39;m obviously looking 
at the new SSD on the machine now, right?  That SSD got a copy of 
whatever was readable from the old one, which turned out to be the 
entire system... *including* the systemd journal files.
</p>
<p>
Those changes weren&#39;t managing to get flushed to the old disk with the 
now-RO filesystem, but they were apparently hanging out in buffers and 
were available for reading... or something?  That makes sense, right?
</p>
<p>
So, any time I copied something from the failing drive, I was scooping 
up whatever it could read from that filesystem.  The telling part is 
that while these journals do cover the several hours it took to copy 
all of the stuff through that USB 2-&gt;SATA connection, they don&#39;t 
include the system shutdown.  Clearly, that happened *after* the last 
copy ran.  Obviously.
</p>
<p>
Now, if those journal entries had made it onto the original disk, then 
it would mean that I have a big hole in my understanding of what  
&#34;read-only filesystem&#34; means even after years of doing this.  That&#39;d be 
weird, right?
</p>
<p>
Just to be really sure before sending off this update, I broke out the 
failing SSD and hooked it up to that adapter again, then went through 
the incantations to mount it, and sure enough:
</p>
<pre class="terminal">-rw-r-----+ 1 root systemd-timesync 16777216 May 14 17:06 system.journal
</pre>
<p>
The last entry in that log is this:
</p>
<pre class="terminal">May 14 17:06:38 mini kernel: ata1: EH complete
</pre>
<p>
There we go.  Not so spooky after all.
</p>

  </body>
</html>
