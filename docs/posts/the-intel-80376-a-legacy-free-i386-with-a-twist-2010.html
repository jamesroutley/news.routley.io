<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pagetable.com/?p=460">Original</a>
    <h1>The Intel 80376 – A legacy-free i386 with a twist (2010)</h1>
    
    <div id="readability-page-1" class="page"><div id="page">
		<div id="content">
			
	<div id="primary">
		<main id="main">
			
<article id="post-460" itemtype="https://schema.org/CreativeWork" itemscope="">
	<div>
		
		<!-- .entry-header -->

		
		<div itemprop="text">
			<p>25 years after the introduction of the 32 bit Intel i386 CPU, all Intel compatibles still start up (and wake up!) in 16 bit stone-age mode, and they have to be <a href="http://www.pagetable.com/?p=276">switched into 32/64 bit mode</a> to be usable.</p>
<p>Wouldn’t it be nice if a modern i386/x86_64 CPU started at least in 32 bit protected mode? Can’t they make a legacy-free CPU that does not support 16 bit mode at all? Such a CPU exists, well, existed. It’s the 1989-2001 <a href="http://en.wikipedia.org/wiki/Intel_80376">Intel 80376</a>, an embedded version of the Intel i386.</p>
<p>The <a href="http://datasheets.chipdb.org/Intel/x86/376/datashts/24018204.PDF">datasheet</a> describes all the interesting differences. The 80376 does not support any 16 bit mode, so the “D” bit in segment descriptors must be set to 1 (page 25), forcing 32 bit code and data segments. 286-style descriptors are not supported either (page 27). (The 0x66 and 0x67 opcode prefixes still exists, so code can work on 16 bit registers and generate 16 bit addresses (page 14), just like an i386 in 32 bit mode.)</p>
<p>Since the CPU does not support 16 bit modes, it cannot do real mode, so CR0.PE is always 1. Consequently, a 80376 starts up in 32 bit protected mode, but otherwise, startup is just like on the i386 (page 19): EIP is 0x0000FFF0, CS is 0xF000, CS.BASE is 0xFFFF0000, CS.LIMIT is 0xFFFF, and the other segment registers are 0x0000, with a base of 0x00000000 and a limit of 0xFFFF. No GDT is set up, and in order to get the system into a sane state, loading a GDT and reloading the segment registers is still necessary. Too bad they didn’t set all bases to 0, all limits to 0xFFFFFFFF and EIP to 0xFFFFFFF0.</p>
<p>The 80376 is designed to be forward-compatible with the i386, so unsupported features are documented as “reserved” or “must be 0/1”, and legacy properties like the garbled segment descriptors are unchanged. All (properly written) 80376 software should also run on an i386 (page 1) – except for the first few startup instructions of course. Intel provides the following code sequence (page 20) that is to be executed directly after RESET to distinguish between the 80376 and the i386:</p>
<pre>smsw bx
test bl, 1
jnz is_80376
</pre>
<p>This tests for CR0.PE, which is hardcoded to 1 on the 80376 and is 0 on RESET on an i386. The three instructions are bitness agnostic, i.e. the encoding is identical in 16 and 32 bit mode.</p>
<p>Sounds like the perfect CPU? Well, here comes the catch: The 80376 doesn’t do paging. CR2 and CR3 don’t exist (it is undocumented whether accessing them causes an exception), CR0.PG is hardcoded to 0 (page 8) and the #PF exception does not exist (page 17). A man can dream though… a man can dream.</p>
		</div><!-- .entry-content -->

					<!-- .entry-meta -->
			</div><!-- .inside-article -->
</article><!-- #post-## -->

					

							</main><!-- #main -->
	</div><!-- #primary -->

	<!-- #secondary -->

	</div><!-- #content -->
</div></div>
  </body>
</html>
