<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sigplan.org/2022/01/13/provably-space-efficient-parallel-functional-programming/">Original</a>
    <h1>Provably Space-Efficient Parallel Functional Programming</h1>
    
    <div id="readability-page-1" class="page"><div>
					<h2><span>The Elephant</span></h2>
<p><span>Hardware is more parallel than ever.  For example, processors today have as many as </span><a href="https://www.amd.com/en/products/cpu/amd-epyc-7713p"><span>64 cores</span></a><span>. To write parallel programs for such hardware, researchers have converged on using </span><b>implicit parallelism</b><span>, where the programmer expresses all opportunities for parallelism, and the compiler and run-time system then work together to manage parallel execution, relieving the programmer from an otherwise tedious and difficult task. Using functional languages also helps the programmer with an important safety concern—data races—by allowing greater control over effects, and even hiding effects behind pure interfaces that are safe for parallelism.  </span></p>
<p><b>Implicitly-parallel functional programming can therefore be a game changer for parallelism, but there is the elephant in the room: poor performance. </b><span>The primary reason for poor performance is memory. In particular, functional programs allocate memory at a high rate, and this rate is further increased by parallelism, where multiple cores can allocate memory at the same time. This high allocation rate is beyond what can be handled efficiently by traditional memory managers.</span></p>
<p><span>We believe that it is possible to solve this problem. We want to make the elephant vanish, but with no tricks like <a href="https://www.thegreatharryhoudini.com/vanishingelephant.html">Houdini</a></span>: our goal is to make the elephant vanish for real.</p>
<div id="attachment_2510"><p><img aria-describedby="caption-attachment-2510" loading="lazy" src="https://blog.sigplan.org/wp-content/uploads/2022/01/speedups-843x1024.png" alt="Across 15 benchmarks, MPL achieves speedups between 12x and 50x" width="299" height="363"/></p><p id="caption-attachment-2510">MPL speedups on 70 threads. Sequential baseline times (MLton, in seconds) written in parentheses.</p></div>
<p><span>We have been working on this problem by utilizing a memory property of parallel functional programs called <em>disentanglement</em>. (It appears that we are the first to discover this property.)  Using disentanglement, we partition memory into heaps and distribute heaps among threads with a </span><i><span>heap scheduler.</span></i><span>  Each thread manages its assigned heap independently, in parallel, and without communicating with other threads. In our </span><a href="https://dl.acm.org/doi/10.1145/3371115"><span>POPL 2020 paper</span></a><span>, we formulated disentanglement and proposed a memory partitioning strategy.  In our </span><a href="https://dl.acm.org/doi/10.1145/3434299"><span>POPL 2021 paper</span></a><span> (which won a Distinguished Paper award), we proposed a specific heap scheduler and showed that it yields provable work and space bounds. We implemented these techniques in the </span><a href="https://github.com/MPLLang/mpl"><span>MPL compiler</span></a><span> for parallel ML and were able to obtain impressive speedups: up to 50x on 70 cores with respect to MLton (our sequential baseline), as shown in the figure on the right.  MPL also appears to compete well with procedural languages such as Java, Go, and even C/C++, in terms of both time and space. In comparison to other functional languages, a </span><a href="https://dl.acm.org/doi/10.1145/3473596"><span>recent paper from ICFP 2021</span></a><span> measures that MPL’s parallel performance is on average 2x faster than both multicore OCaml and parallel Haskell (GHC).</span></p>

<h2><span>The Vanishing Elephant</span></h2>
<h3><span>What is disentanglement?</span></h3>
<p><span>Disentanglement is a memory property that enforces a disciplined use of effects. </span><span>It holds for an execution if concurrently executing threads are (roughly speaking) “oblivious” to each other’s allocations. More specifically, for any two concurrent threads A and B, if thread A acquires a reference to data allocated by thread B, then we say the two threads are <em>entangled</em>. This motivates the name: disentanglement ensures freedom from entanglement.<br/>
</span></p>
<p><span>Many parallel programs are naturally disentangled, or can be made so with only small changes to allocation patterns, partly because entanglement is often indicative of a data race. Note however that disentanglement does not outlaw data races—it only restricts a thread to access objects allocated </span><i><span>before</span></i><span> (as defined by sequential dependencies) the thread started, in addition to those objects allocated by the thread itself. For example, two concurrently executing threads can simultaneously inspect and update objects allocated by the parent thread that spawned them.  Disentanglement differs from separation logic in this respect: it does not insist on partitioning objects into disjoint heaps, and allows access to any previously allocated object (as determined by sequential and parallel dependencies).  We view disentanglement as generalizing the notion of “time” as it relates to memory for parallel programs: in both sequential and disentangled parallel programs, an instruction can only access objects that are allocated before it.</span></p>
<p><span>Disentanglement opens a new perspective on parallel memory management: rather than viewing memory as a global shared resource, we can instead organize memory as a distributed structure that mirrors (i.e., corresponds with) the structure of parallelism in the program. In a fork-join program, this structure is a dynamic tree or “hierarchy”: tasks may spawn two or more children to execute in parallel, and must wait for all children to complete before continuing.</span></p>
<div id="attachment_2426"><p><img aria-describedby="caption-attachment-2426" loading="lazy" src="https://blog.sigplan.org/wp-content/uploads/2021/11/de-1024x303.png" alt="" width="1024" height="303" srcset="https://blog.sigplan.org/wp-content/uploads/2021/11/de-980x290.png 980w, https://blog.sigplan.org/wp-content/uploads/2021/11/de-480x142.png 480w" sizes="(min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw"/></p><p id="caption-attachment-2426">In disentangled fork-join program, memory forms a dynamic tree structure, enabling mutators and collectors to cooperate (rather than compete) when operating on the memory.</p></div>
<p><span>As we discuss next in more detail, </span><b>disentangling memory enables naturally parallel memory management</b><span>. For example, the leaves of the tree are independent of each other, allowing for allocations and garbage collections to proceed entirely in parallel.</span></p>
<h2><span>Hierarchical memory management</span></h2>
<p><span>Hierarchical memory management takes advantage of disentanglement by organizing memory into a tree. The idea is to create dynamic tree of heaps called the </span><b><i>heap hierarchy</i></b>, where we give <span>each task its own local heap for allocations. As the computation progresses, the heap hierarchy folds and unfolds, mirroring the tree of tasks: when a task is forked, it is given a fresh, empty heap; when a task joins its parent, its heap is also merged into its parent.</span></p>
<p><img loading="lazy" src="https://blog.sigplan.org/wp-content/uploads/2021/11/fj-1024x474.png" alt="At a fork, heap A is given two fresh child heaps, B and C. After the join, all three (A, B, and C) are merged." width="419" height="194"/></p>
<p><b>In the heap hierarchy, disentanglement guarantees a crucial property: </b><b><i>absence of cross-pointers</i></b><span>. That is, every object in memory might have pointers to objects above or below in the tree, but never across.</span></p>
<p><img loading="lazy" src="https://blog.sigplan.org/wp-content/uploads/2021/11/def-1024x912.png" alt="A visualization of which pointers are permitted by disentanglement (up, down, internal) and which are disallowed (cross)." width="230" height="205"/></p>
<p><b>The absence of cross-pointers unlocks parallel garbage collection</b><span>: leaf heaps can be collected completely independently in parallel, without any synchronization, using either </span><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Moving_vs._non-moving"><span>moving or non-moving techniques</span></a><span>. Internal heaps can be collected independently, too, although with a bit of bookkeeping. The idea is to “take a snapshot” at the moment a heap becomes internal (which occurs when its corresponding task spawns new subtasks) and use this snapshot as a conservative root-set for garbage collection.</span></p>
<h3><span>Heap scheduling</span></h3>
<p><span>With disentanglement and hierarchical memory management, the run-time system can reclaim objects from any heap independently with little-to-no synchronization. But, now that the memory is organized into separate heaps, reclaiming all garbage precisely and efficiently becomes more difficult.  Intuitively, there are two reasons why. First, the reclamation algorithm might work with outdated information (i.e., root set), which leads to uncollected garbage. Second, because the reclamation algorithm operates on a small region of memory (a heap), it might waste work by triggering too frequently.</span></p>
<p><span>To solve these problems we developed a </span><b><i>heap scheduler</i></b><span> which clusters heaps so that larger amounts of memory can be collected precisely and efficiently. The idea is to assign a cluster of heaps to each processor dynamically based on task scheduling decisions, and allow each processor to garbage-collect its cluster. When clustering, size matters. On the one hand, we could have lots of small clusters, which would increase parallelism, but lead to wasted work and space. On the other hand, we could use a few large clusters, which would improve work and space but lead to less parallelism. We aim for the sweet spot: less total work and space, and lots of parallelism.</span></p>
<div id="attachment_2429"><p><img aria-describedby="caption-attachment-2429" loading="lazy" src="https://blog.sigplan.org/wp-content/uploads/2021/11/spines-1024x720.png" alt="Visualization of spine-based clustering in a large heap hierarchy." width="434" height="305"/></p><p id="caption-attachment-2429">Our heap scheduler clusters heaps along spines in the heap hierarchy, and assigns each spine to a processor.</p></div>
<p><b>Showing some spine. </b><span>Our heap scheduling algorithm clusters the “spines” of the hierarchy and assigns each spine to a processor: in each spine, one child of every parent is always on the same processor, so the pointers within spines are precise.  Because each processor owns its own spine, it can operate on the spine independently. The heap scheduler creates spines by “listening” to the task scheduler, e.g., a work-stealing scheduler. When a processor (worker) steals a child, a new heap is created and assigned to the thief. When tasks have completed and are ready to join, the heap scheduler joins the corresponding heaps and assigns the resulting heap to whichever processor executes the continuation. This way, tasks and their corresponding heaps are always scheduled in tandem.</span></p>
<p><span>We analyze work and space of parallel runs by relating them to sequential executions. The key insight is that each spine corresponds exactly to a segment of a sequential execution. We can therefore bound space usage by allowing each processor to collect its own spine using a standard amortization-based policy (e.g., after performing GC on a spine, a processor waits until its spine is at least twice as large before triggering another GC). On </span><i><span>P</span></i><span> processors, this leads to a worst-case bound of approximately </span><i><span>P</span></i><span> times the sequential space overall.<br/>
</span></p>
<p><b>How well does MPL work outside the research lab? </b><span>At Carnegie Mellon University, the introductory data structures and algorithms course (with over 500 students per year, mostly sophomore undergraduates) covers parallel and sequential algorithms together. In this course, we use Parallel ML with our MPL compiler as the implementation infrastructure. We provide students with their own dedicated 64-core machines for experimentation (via a cloud platform) and many students observe significant speedups in practice. The programming assignments include parallel algorithms with divide-and-conquer, dynamic programming, and graphs. Because the students write functional programs, they usually do not have to worry about race-conditions at all. </span></p>
<p><span>Using functional programming with our MPL compiler, undergraduate students learn parallel algorithms and implement them in practice without experiencing additional difficulties due to parallelism. This contrasts with our prior experience using procedural languages. In particular, when we used C and C++ for some assignments, we found that a majority of our students spent many hours debugging race conditions, which does not make meaningful contributions to the learning goals of an algorithms class.</span></p>

<p><span>Researchers have for decades extolled the benefits of functional programming for parallelism, which has become an important and relevant problem. Functional parallel programs, however, have traditionally suffered from poor performance in practice, primarily because automatic memory management is difficult to scale.  Our research has made significant progress on this challenge by identifying and exploiting a memory property of parallel programs, called disentanglement, to support parallel memory management by partitioning the memory into smaller heaps that operate independently.  By using an insight on clustering heaps, we are able to establish work and space bounds.  Our implementation experience with the MPL compiler shows that these techniques are also highly practical, yielding good performance and scalability.  Research thus far shows that disentanglement is a promising approach to managing memory but we seem to have barely scratched the surface. Future research directions include generalizing the technique beyond fork-join program, allowing and managing entanglement without harming the benefits of disentanglement, and improving resource bounds.</span></p>
<p><strong>Bios</strong>: <a href="https://www.umut-acar.org/">Umut Acar</a> is an associate professor at Carnegie Mellon University; <a href="https://www.cs.cmu.edu/~jatina/">Jatin Arora</a> and <a href="https://www.cs.cmu.edu/~swestric/">Sam Westrick</a> are his PhD students there. Their research focuses on the theory and practice of programming, including the design, analysis, and implementation of programming languages and algorithms.</p>
<p><strong>Disclaimer:</strong> <em>These posts are written by individual contributors to share their thoughts on the SIGPLAN blog for the benefit of the community. Any views or opinions represented in this blog are personal, belong solely to the blog author and do not represent those of ACM SIGPLAN or its parent organization, ACM.</em></p>
					</div></div>
  </body>
</html>
