<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2022/03/10/Things-I-hate-about-Rust-redux">Original</a>
    <h1>Things I hate about Rust, redux</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://blog.yossarian.net/">Home</a></li>
    <li><a href="https://blog.yossarian.net/tags">Tags</a></li>
    <li><a href="https://blog.yossarian.net/series">Series</a></li>
    <li><a href="https://blog.yossarian.net/favorites">Favorites</a></li>
    <li><a href="https://blog.yossarian.net/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net">Main Site</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Mar 10, 2022</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://blog.yossarian.net/tags#programming">programming</a>,
        
          <a href="https://blog.yossarian.net/tags#rant">rant</a>,
        
          <a href="https://blog.yossarian.net/tags#rust">rust</a>
        
      </span>
    

       

    
  </p>
</h2>

<p><img src="https://blog.yossarian.net/assets/rust-angrier.png" alt="A picture of Ferris, the Rust mascot, with a poorly drawn &#34;angry&#34; expression"/></p>

<p>Two years ago, I <a href="https://blog.yossarian.net/2020/05/20/Things-I-hate-about-rust">wrote a post</a>
with a handful of grievances about <a href="https://www.rust-lang.org/">Rust</a>, a language that I then
(and still) consider my favorite compiled language.</p>

<p>In the two years since I’ve gone from considering myself <em>familiar</em> with Rust,
to <em>comfortable</em> in it, to <em>thinking in Rust</em> even when writing in other languages
(sometimes to my detriment). So, like two years ago, this post should be read
<strong>from a place of love</strong> for Rust, and not a cheap attempt to knock it.</p>

<h2 id="intoiterator-is-too-overloaded"><code>IntoIterator</code> is too overloaded</h2>

<p>Here is how the <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code> docs</a>
explain the trait:</p>

<blockquote>
  <p>Conversion into an Iterator.</p>

  <p>By implementing IntoIterator for a type, you define how it will be converted to an iterator.
This is common for types which describe a collection of some kind.</p>
</blockquote>

<p>If that sounds <em>extremely generic</em> to you, it’s because it is! Here are just a few of the ways
<code>IntoIterator</code> is used in the wild, using a generic <code>Container&lt;T&gt;</code> for motivation:</p>

<ul>
  <li>
    <p>For producing “normal” borrowing iterators: <code>&amp;T for T in Container&lt;T&gt;</code></p>
  </li>
  <li>
    <p>For producing iterators over mutable references: <code>&amp;mut T for T in Container&lt;T&gt;</code></p>
  </li>
  <li>
    <p>For producing “consuming” (i.e., by-value) iterators: <code>T for T in Container&lt;T&gt;</code></p>
  </li>
  <li>
    <p>For producing “owned” (i.e., copying or cloning) iterators: <code>T for T in Container&lt;T: Clone&gt;</code><sup id="fnref:cloned" role="doc-noteref"><a href="#fn:cloned" rel="footnote">1</a></sup></p>
  </li>
</ul>

<p>Each of these can be a useful iterator to have, which is why container types frequently have
multiple <code>Item</code>-variant <code>IntoIterator</code> implementations. Those implementations are, in turn,
occasionally (optionally!) disambiguated with aliases: <code>iter_mut()</code>, <code>drain()</code><sup id="fnref:notanalias" role="doc-noteref"><a href="#fn:notanalias" rel="footnote">2</a></sup>, &amp;c.</p>

<p>The downside is comprehension: absent of context, an <code>into_iter()</code> could be doing <em>any</em> of the
above<sup id="fnref:ordifferent" role="doc-noteref"><a href="#fn:ordifferent" rel="footnote">3</a></sup>, leaving it to me (or any other poor soul) to read further into the iterator’s
consumer to determine what’s <em>actually</em> going on. It’s never <em>ambiguous</em> (only one selection is
possible at compile time!), but it <em>can</em> be difficult to rapidly comprehend in the manner that
Rust otherwise facilitates.</p>

<p><code>IntoIterator</code> is already firmly baked into Rust’s core, so it’s probably too late to devolve it
into the half dozen traits that it conceptually covers. But if I could turn back time:</p>

<ul>
  <li>
    <p><code>IntoIterator</code> itself could be spelled <code>AsIterator</code> or <code>ToIterator</code> instead, to prevent
the misleading ownership connotation of
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>.</p>
  </li>
  <li>
    <p><code>OwningIterator</code> and <code>BorrowingIterator</code> would solve the ownership overlap, providing
<code>iter_owned()</code> and <code>iter()</code> respectively. I’m not sure how nicely this would play
with the overall soundness of Rust’s traits and types, but I can dream.</p>
  </li>
</ul>

<h2 id="its-difficult-to-write-high-assurance-rust">It’s difficult to write “high-assurance” Rust</h2>

<p>Rust’s safety is a sort of inverted Faustian bargain: in exchange for a small amount
of control over memory layout, we get <em>complete</em> spatial and temporal memory safety,
automatic memory management without a garbage collector, and zero-cost abstractions
that let us take full advantage of our optimizing compilers.</p>

<p>As such, when I say that “high-assurance” Rust is difficult, I don’t mean Safe Rust.
What I mean is that we’ve made a trade: in exchange for all of this safety, we’ve accepted
a certain amount of mandatory invariant enforcement — the Rust standard library
will <em>panic</em> when an invariant <em>would</em> produce unsafety, and community maintained
libraries will use <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a>,
<a href="https://doc.rust-lang.org/std/macro.assert.html"><code>assert!</code></a>, and the like to trade
the occasional uncontrolled program termination for slightly better programming
ergonomics (fewer <code>Option</code>s and <code>Result</code>s).</p>

<p>Invariant enforcement is a good thing and, by and large, both Rust’s internal
and community uses of panics are judicious: by <em>convention</em>, panicking functions tend to
have either (1) a non-panicking <code>Result</code> or <code>Option</code> alternative, or (2) failure conditions
that are environmental in a way that mandates program termination anyways (e.g., stack exhaustion).</p>

<p>The end result: the Rust standard library and ecosystem are full of panics that <em>almost</em> never
occur, panics that are only specified informally (i.e., in human-readable documentation).
But “almost never” isn’t always good enough: it’s sometimes nice to have the assurance that
<em>no code being executed can possibly panic</em>.</p>

<p>To the best of my knowledge, there are only imperfect solutions to this:</p>

<ul>
  <li>
    <p>You can use <a href="https://github.com/rust-lang/rust-clippy"><code>clippy</code></a> to ban <em>source-level</em> panics
in your own code, primarily by using the
<a href="https://rust-lang.github.io/rust-clippy/master/#expect_used"><code>expect_used</code></a>,
<a href="https://rust-lang.github.io/rust-clippy/master/#unwrap_used"><code>unwrap_used</code></a>,
and <a href="https://rust-lang.github.io/rust-clippy/master/#panic"><code>panic</code></a> lints. Each of these
is disabled by default, so users need to explicitly opt into them.</p>

    <p>These lints work excellently for <strong>first-party</strong> code! But they can’t prevent panics
in <strong>third-party</strong> code<sup id="fnref:thirdparty" role="doc-noteref"><a href="#fn:thirdparty" rel="footnote">4</a></sup>, because <code>clippy</code> only analyzes the <em>source</em> of the active
crate. In other words, <code>clippy</code> <strong>won’t</strong> catch the following under any circumstances:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>use</span> <span>thirdparty</span><span>;</span>

<span>fn</span> <span>foo</span><span>()</span> <span>{</span>
  <span>thirdparty</span><span>::</span><span>calls_unwrap_internally</span><span>();</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>Rust prides itself on its rich package ecosystem, which means that just about any third-party
dependency can introduce implicit panics. Not so good.</p>
  </li>
  <li>
    <p>You can use a crate like <a href="https://docs.rs/no-panic/latest/no_panic/"><code>no_panic</code></a><sup id="fnref:dontpanic" role="doc-noteref"><a href="#fn:dontpanic" rel="footnote">5</a></sup>
to catch panics by promoting them into compiler (really linker) errors. This is incredibly clever,
but with a variety of downsides:</p>

    <ul>
      <li>
        <p>It <em>fundamentally</em> relies on the compiler to optimize away unreachable panics, making
it unreliable at lower optimization levels (particularly, the default debug build level).
Similar, any tweaking of Rust’s panicking behavior (e.g., a different panicking strategy
like <code>panic = &#34;abort&#34;</code>) can break the linker trick being used here.</p>
      </li>
      <li>
        <p>It doesn’t work <em>directly</em> on library crates, since library crates don’t directly invoke the
linker. In order to be effective, the “leaf” build needs to be something that requires the linker,
like an executable or shared object.</p>
      </li>
      <li>
        <p>Because the errors happen at link-time instead of compile time, they’re largely stripped
of their source context. <code>no_panic</code> is clever and uses a procedural macro to parse the function
signature and present it as part of the linker error<sup id="fnref:cursed" role="doc-noteref"><a href="#fn:cursed" rel="footnote">6</a></sup>, but that’s just about the limit
of the context it can provide.</p>

        <p>The example in the README demonstrates this inscrutability:</p>

        <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre>   Compiling no-panic-demo v0.0.1
error: linking with `cc` failed: exit code: 1
  |
  = note: /no-panic-demo/target/release/deps/no_panic_demo-7170785b672ae322.no_p
anic_demo1-cba7f4b666ccdbcbbf02b7348e5df1b2.rs.rcgu.o: In function `_$LT$no_pani
c_demo..demo..__NoPanic$u20$as$u20$core..ops..drop..Drop$GT$::drop::h72f8f423002
b8d9f&#39;:
          no_panic_demo1-cba7f4b666ccdbcbbf02b7348e5df1b2.rs:(.text._ZN72_$LT$no
_panic_demo..demo..__NoPanic$u20$as$u20$core..ops..drop..Drop$GT$4drop17h72f8f42
3002b8d9fE+0x2): undefined reference to `

      ERROR[no-panic]: detected panic in function `demo`
      &#39;
      collect2: error: ld returned 1 exit status
</pre></td></tr></tbody></table></code></pre></div>        </div>

        <p>You can <em>maybe</em> see the inner callsite responsible for the panic, but not easily.</p>
      </li>
    </ul>
  </li>
</ul>

<p>In sum, it’s <strong>very difficult</strong> to write <strong>provably</strong> non-panicking code in Rust in 2022. Avoiding
explicit panics in first-party code is perfectly possible (and even ergonomic!); it’s the panics
embedded in third-party dependencies and runtime code that are nearly impossible to track.</p>

<p>I have some ideas for improving this, ones that are outside the scope of this gripe-fest.
Maybe another time.</p>

<h2 id="integration-tests-feel-bolted-on">Integration tests feel bolted on</h2>

<p>Integration tests are one of Cargo’s more oblique features: in addition to hosting your tests in-tree
(i.e., in a <code>mod tests</code> in each <code>foo.rs</code> file), you can <em>also</em> create a parallel <code>tests/</code> tree
for tests whose scope reaches beyond the unit level.</p>

<p>In other words, if your source tree looks like this:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td><pre>src/
├── kbs2
│   ├── agent.rs
│   ├── backend.rs
│   ├── command.rs
│   ├── config.rs
│   ├── generator.rs
│   ├── input.rs
│   ├── mod.rs
│   ├── record.rs
│   ├── session.rs
│   └── util.rs
└── main.rs
tests/
├── common
│   └── mod.rs
├── test_kbs2_init.rs
└── test_kbs2.rs
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…then your <code>cargo test</code> output might look something like this:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td><pre><span>william@janus kbs2 [0:0] integration-tests $</span><span> </span>cargo <span>test</span>
<span>   Compiling kbs2 v0.6.0-rc.1 (/home/william/devel/self/kbs2)
    Finished test [unoptimized + debuginfo] target(s) in 4.25s
     Running unittests (target/debug/deps/kbs2-2dd9eb541b527992)

running XX tests
test kbs2::backend::tests::test_ragelib_create_keypair ... ok
test kbs2::config::tests::test_initialize_wrapped ... ok
test kbs2::backend::tests::test_ragelib_create_wrapped_keypair ... ok
test kbs2::backend::tests::test_ragelib_rewrap_keyfile ... ok

</span><span>test result: ok. XX passed;</span><span> </span>0 failed<span>;</span> 0 ignored<span>;</span> 0 measured<span>;</span> 0 filtered out<span>;</span> finished <span>in </span>8.75s
<span>
     Running tests/test_kbs2.rs (target/debug/deps/test_kbs2-4f1d8387af33e18c)

running 3 tests
test test_kbs2_version ... ok
test test_kbs2_help ... ok
test test_kbs2_completions ... ok

</span><span>test result: ok. 3 passed;</span><span> </span>0 failed<span>;</span> 0 ignored<span>;</span> 0 measured<span>;</span> 0 filtered out<span>;</span> finished <span>in </span>0.03s
<span>
     Running tests/test_kbs2_init.rs (target/debug/deps/test_kbs2_init-d890a2d5d4f7537d)

running 1 test
test test_kbs2_init ... ok

</span><span>test result: ok. 1 passed;</span><span> </span>0 failed<span>;</span> 0 ignored<span>;</span> 0 measured<span>;</span> 0 filtered out<span>;</span> finished <span>in </span>0.01s
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is a fantastic feature: you don’t need to do <em>anything special</em> to do integration testing
on a Rust codebase!</p>

<p>Except…</p>

<ul>
  <li>
    <p>Cargo doesn’t understand how to run integration tests against a binary-only crate: if your
<code>src</code> tree has <strong>only</strong> <code>main.rs</code> and no <code>lib.rs</code>, then you won’t be able to <code>use some::mod</code>
from under <code>test/</code>. This is a
<a href="https://users.rust-lang.org/t/integration-tests-for-binary-crates/21373">known issue</a>, one without
a satisfying fix or workaround that <em>doesn’t</em> involve turning your binary’s APIs into a public
interface<sup id="fnref:notaproblem" role="doc-noteref"><a href="#fn:notaproblem" rel="footnote">7</a></sup>.</p>
  </li>
  <li>
    <p>Every <em>file</em> in the <code>tests</code> directory is a separate crate, compiled to its own executable.
This is a reasonable decision, with undesirable consequences:</p>

    <ul>
      <li>
        <p>There is no <em>naive</em> way to mark a file under <code>tests/</code> as <strong>not</strong> containing integration tests.</p>

        <p><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#submodules-in-integration-tests">As the documentation notes</a>,
adding <code>tests/common.rs</code> to manage shared helpers will add a <code>common</code> section to your
<code>cargo test</code> output. The “official” workaround is to make <code>common.rs</code> into a directory-style
module instead (<code>common.rs -&gt; common/mod.rs</code>), which <code>cargo test</code> then apparently ignores
for test collection purposes. It’s not the end of the world, but it feels like an incidental
hack (it presumably works because <code>cargo test</code> doesn’t recurse through <code>tests/</code>, which
doesn’t seem to be explicitly documented anywhere).</p>
      </li>
      <li>
        <p>More annoyingly: because each file under <code>tests/</code> is its own binary, Rust’s otherwise
excellent dead code detection <strong>does not work correctly</strong> on integration tests.</p>

        <p><a href="https://github.com/rust-lang/rust/issues/46379">This issue</a> contains the full detail, but
to summarize: if <code>test_foo.rs</code> and <code>test_bar.rs</code> make disjoint use of <code>common/mod.rs</code>, then
<code>rustc</code> will see “unused” code in the compilations of both <code>test_foo</code> and <code>test_bar</code>, despite
the totality of all integration tests having complete coverage for <code>common/mod.rs</code>.</p>

        <p>This is again mentioned only obliquely in the documentation: you have to know that separate
compilations mean that Cargo won’t track dead code in your helper modules, even though
the “pattern” of submodules under <code>tests/</code> is one that Cargo otherwise knows about.</p>

        <p>The fix? I don’t think it’s a good one, but I ended up putting <code>#![allow(dead_code)]</code>
at the top of my <code>common</code> integration test module.</p>
      </li>
    </ul>
  </li>
</ul>

<p>These are trivial quality-of-developer-life things, each of which has a <em>very good</em> reason
for not being different<sup id="fnref:deadcode" role="doc-noteref"><a href="#fn:deadcode" rel="footnote">8</a></sup>. But they’re still a drag!</p>

<h2 id="bonus-cargo-install-is-too-eager">Bonus: <code>cargo install</code> is too eager</h2>

<p><code>cargo install</code> is the main interface for installing user-facing executables from the crates
ecosystem. Because it’s built right into the Rust toolchain, lots of projects list <code>cargo install $FOO</code>
as a recommended installation technique. So far, so good.</p>

<p>What’s not so good is <em>how</em> <code>cargo install</code> chooses to do builds. Unlike <code>cargo build</code>,
<code>cargo install</code> <strong>ignores <code>Cargo.lock</code> by default</strong>, meaning that a different but “compatible”
(per <a href="https://semver.org/">SemVer</a>) version might be selected for the final compiled product.</p>

<p>There are (at least) two problems with this:</p>

<ol>
  <li>
    <p>It violates some of the (perhaps incorrectly) presumed consistency of telling users to
run <code>cargo install</code> to install your program: each user may have a slightly different dependency tree
depending on <em>when</em> they ran <code>cargo install</code>. Debugging small compatibility errors then becomes
an exercise in frustration, as users and maintainers determine the relevant differences in their
dependency trees.</p>
  </li>
  <li>
    <p>More perniciously: <code>cargo</code>’s interpretation of semantic versioning diverges from the normal interpretation:</p>

    <ul>
      <li>
        <p><code>cargo install</code> (and other <code>cargo</code> subcommands?) treat <code>0.X.Y</code> and <code>0.X.Z</code> as compatible
 releases, despite the SemVer spec <a href="https://semver.org/#spec-item-4">explicitly saying otherwise</a>.</p>
      </li>
      <li>
        <p><code>cargo install</code> treats pre-release versions (e.g. <code>2.0.0-pre.1</code>) as compatible with both
 their major release (i.e. <code>2.0.0</code>) and <em>all other pre-releases in the same range</em>
 (e.g. <code>2.0.0-pre.2</code>), despite the SemVer spec warning that prereleases
 <a href="https://semver.org/#spec-item-9">must be treated as unstable and non-API-conforming</a>.</p>
      </li>
    </ul>
  </li>
</ol>

<p>The former behavior can be frustrating, but is ultimately justifiable in an ecosystem that largely
respects semantic versioning: it almost always makes sense to install <code>foo 1.2.4</code> instead of
<code>foo 1.2.3</code>. When a package misbehaves (i.e., fails to follow SemVer) or this behavior simply isn’t
desired for whatever reason, <code>cargo install --locked</code> provides an escape hatch (albeit not
a default one).</p>

<p>The latter behavior is, in my opinion, unjustifiable: it’s inconsistent with the compatibility
standards established by SemVer and otherwise respected by Cargo (and the overwhelming majority
of crates in the ecosystem), and directly interferes with any attempts to use pre-releases
(as well as release candidates, betas, &amp;c.) in a stable manner in programs that ordinary
users are expected to install.</p>

<p>The umbrella issue for this has been open since 2019, and is tracked
<a href="https://github.com/rust-lang/cargo/issues/7169">here</a>. Prominent projects that have had
<code>cargo install</code> failures due to it include (in no particular order):</p>

<ul>
  <li><a href="https://github.com/sharkdp/bat/issues/1991"><code>bat</code></a> (SemVer violation)</li>
  <li><a href="https://github.com/dtolnay/cargo-expand/issues/122"><code>cargo-expand</code></a> (SemVer violation)</li>
  <li><a href="https://github.com/BurntSushi/xsv/issues/268"><code>xsv</code></a> (Dependencies require a newer compiler<sup id="fnref:msrv" role="doc-noteref"><a href="#fn:msrv" rel="footnote">9</a></sup>)</li>
  <li><a href="https://github.com/launchbadge/sqlx/issues/1378"><code>sqlx</code></a> (Incorrect beta/rc upgrade)</li>
  <li><a href="https://github.com/EmbarkStudios/cargo-deny/issues/331"><code>cargo-deny</code></a> (SemVer violation)</li>
  <li><a href="https://github.com/rust-secure-code/cargo-geiger/issues/185"><code>cargo-geiger</code></a> (Dependencies require a newer compiler)</li>
  <li><a href="https://github.com/immunant/c2rust/issues/323"><code>c2rust</code></a> (Dependencies require a newer compiler)</li>
  <li><a href="https://github.com/str4d/rage/pull/187"><code>rage</code></a> (Incorrect beta/rc upgrade)</li>
</ul>

<h2 id="wrapup-and-honorable-mentions">Wrapup and honorable(?) mentions</h2>

<p>At the end of the day, Rust is still my preferred compiled language and development ecosystem.
I see the increase in visible problems as a function of my increased familiarity with the language,
not as insurmountable flaws — after all, similar problems exist in just about every language
(and packaging ecosystem).</p>

<p>I didn’t want to bloat this post with <em>too</em> many grievances, so here’s a smattering of other
(more minor?) things that I’ve noticed over the years:</p>

<ul>
  <li>
    <p>The static analysis story for side effects and accidental data use still isn’t great in Rust
— it’s remarkably easy to cause unintentional side effects by forgetting to use closures in
long “fluent” method compositions, or to accidentally drop data during I/O by dropping a buffered
I/O handle that still has pending content.</p>
  </li>
  <li>
    <p><code>Pin&lt;T&gt;</code> and co. aren’t very ergonomic, and self-referential structs are even less ergonomic.
I would absolutely <em>love</em> to see a <code>&#39;self</code> lifetime that doesn’t require a third party crate
like <a href="https://github.com/joshua-maros/ouroboros"><code>ouroboros</code></a>.</p>
  </li>
  <li>
    <p>Procedural macros are hard to write, harder than they should be.
<a href="https://crystal-lang.org">Crystal</a> has a wonderful and extremely ergonomic
<a href="https://crystal-lang.org/reference/1.3/syntax_and_semantics/macros/index.html">macro system</a> that
Rust could learn from, one that doesn’t require ad-hoc reinterpretation of language tokens and
that integrates seamlessly with syntax highlighting in editors.</p>
  </li>
</ul>

<hr/>




<hr/>


<span>
  Discussions:
  
  <a href="https://www.reddit.com/r/enosuchblog/comments/tb0mmy/things_i_hate_about_rust_redux/">Reddit</a>
  

  
  <a href="https://twitter.com/8x5clPW2/status/1501936493362700293">Twitter</a>
  
</span>

<hr/>



  






</div>
  </body>
</html>
