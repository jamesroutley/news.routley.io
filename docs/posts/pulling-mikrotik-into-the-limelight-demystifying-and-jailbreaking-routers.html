<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://margin.re/2022/06/pulling-mikrotik-into-the-limelight/">Original</a>
    <h1>Pulling MikroTik into the Limelight Demystifying and Jailbreaking RouterS</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<article>
<p>So, you want to start reverse engineering MikroTik routers. Where do you start? As opposed to many routers which act more as a collection of independent binaries for each service, MikroTik devices implement a system of interconnected binaries which perform tasks for one another. Unfortunately, there is limited publicly available information about how this system-wide implementation works, and the good, technical information available is now a few years old. In that time, MikroTik released a number of minor version updates and one major revision software upgrade, making some of the technical details obsolete.</p><p>Consequently, we are left generally in the dark as to how MikroTik works, and digging into its dense, hand-rolled C++ binaries filled with custom library calls is a daunting task.</p><p>This blog post, which overviews <a href="https://github.com/MarginResearch/resources/blob/83e402a86370f7c3acf8bb3ad982c1fee89c9b53/documents/Pulling_MikroTik_into_the_Limelight.pdf">our presentation at REcon 2022</a>, outlines key knowledge and introduces tools that we created during our research over the past handful of months.</p><p><strong>The goal of that talk, and this post, is to refresh the publicly available MikroTik knowledge and provide a crash course on MikroTik internals that will bring you from potentially zero experience to a point where you are familiar and comfortable with key MikroTik concepts and abstractions.</strong></p><p>This knowledge will jump-start your research, tool development, or whatever MikroTik-related tinkering in which you are interested. Let&#39;s get started!</p><h2 id="overview">Overview</h2><p>We approach our overarching goal in four ways: first, we dive into MikroTik&#39;s RouterOS operating system, understanding how it loads firmware and boots processes. Specifically, we focus on how firmware packages are cryptographically signed, and how we can bypass signing to obtain a developer shell in a MikroTik RouterOS virtual machine. Next, we focus on a key concept central to MikroTik: its proprietary messaging protocol used for IPC. Third, we dive into how we can authenticate to different services, specifically reviewing a proprietary, hand-rolled cryptographic protocol used for multiple publicly exposed services. Finally, we introduce a novel post-authentication jailbreak for MikroTik devices running v6 firmware (current long-term release branch) that pops a shell on any virtual or physical device.</p><ol><li><a href="https://margin.re/2022/6/pulling-mikrotik-into-the-limelight#diving-deep-into-routeros-internals">Diving Deep into RouterOS Internals</a></li><li><a href="https://margin.re/2022/6/pulling-mikrotik-into-the-limelight#routeros-ipc">RouterOS IPC</a></li><li><a href="https://margin.re/2022/6/pulling-mikrotik-into-the-limelight#hand-rolled-authentication">Hand-rolled Authentication</a></li><li><a href="https://margin.re/2022/6/pulling-mikrotik-into-the-limelight#jailbreaking-routeros">Jailbreaking RouterOS</a></li></ol><h2 id="diving-deep-into-routeros-internals">Diving Deep into RouterOS Internals</h2><h4 id="npk-files-and-backdoors">NPK Files and Backdoors</h4><p>Unlike some IoT devices which frustratingly require intercepting software downloads or extracting firmware directly from hardware, MikroTik hosts its proprietary firmware on <a href="https://mikrotik.com/download/archive">its software downloads page</a>. This conveniently allows us to investigate firmware components and understand how RouterOS, MikroTik’s customized operating system, is organized. Opening up the file system, we see the following components:</p><ul><li><code>/flash/rw/{disk, logs, tmp, store...}</code> - writable region</li><li><code>/lib</code> - core libraries</li><li><code>/nova/bin</code> - system binaries</li><li><code>/nova/lib</code> - system libraries</li><li><code>/nova/etc</code> - system configuration</li><li><code>/pckg/{name}/nova/{bin, lib, etc}</code> - package data</li></ul><p>RouterOS software is distributed in .npk files (which we think stands for “nova package”). In recent versions of RouterOS, each NPK file contains a squashfs with the package data along with a cryptographic signature that RouterOS verifies during installation and every reboot.</p><figure><img src="https://margin.re/attachments/limelight_1.png" alt="npk format" loading="lazy"/></figure><p>While RouterOS is locked down - meaning we cannot easily get a developer shell - there is a known backdoor that has existed for a long time. Specifically, if we login as the <code>devel</code> user with the admin password <em>and</em> have the <code>option</code> package installed, RouterOS launches <code>/pckg/option/bin/bash</code> instead of the default restricted shell.</p><p>That is exactly what we want for security research! However, there are two problems:</p><ol><li>The <code>option</code> package does not exist outside of MikroTik offices (of course...)</li><li>Packages are signed, which means we cannot easily construct our own <code>option</code> package</li></ol><p>In some previous versions of RouterOS it was possible to leverage known CVEs to “install” the <code>option</code> package post-boot and enable this developer backdoor. See <a href="https://github.com/tenable/routeros/tree/master/cleaner_wrasse">Jacob Baines’s Cleaner Wrasse program</a> for an example of an automated tool that accomplishes this.</p><p><em>However, since version 6.44 (2019), this tool no longer works and we need a different strategy…</em></p><h4 id="bypassing-signature-validation">Bypassing Signature Validation</h4><p>Since we are hackers with unfettered access to the RouterOS firmware, let&#39;s go straight to the source and figure out how RouterOS actually validates packages. After a bit of poking around, we discover that package validation occurs in the <code>init</code> binary, a part of the compressed <code>initrd.rgz</code> file located in the disk image&#39;s boot sector.</p><figure><img src="https://margin.re/attachments/limelight_2.png" alt="replacing initrd.rgz" loading="lazy"/></figure><p>Luckily for us, the <code>init</code> binary invokes a single function to validate each package. We can find this function by looking for a reference to the <code>%s/flash/var/pdb/%s/disabled</code> string. In pseudo-code, the function works as follows:</p><pre><code>int check_signature(...){
    // magic
    snprintf(buf, 0x80, &#34;%s/flash/var/pdb/%s/disabled&#34;);
    return is_valid;
}</code></pre><p>All we need to do to bypass signature validation is find this function and patch it to return 1 every time. However, we run into a problem when we try to recompress this and patch our original <code>initrd.rgz</code>…</p><p>It turns out that the kernel is very finicky about what <code>initrd.rgz</code> looks like. Specifically, we need to make sure that we match the expected size (both compressed and decompressed) and also the exact position in the disk image. If we do not match these properties then the kernel fails to decompress <code>initrd.rgz</code> and the router fails to boot.</p><h4 id="the-entropy-trick">The &#34;Entropy Trick&#34;</h4><p>To solve the first two constraints, we make use of an “entropy trick.” Specifically, we create a dummy file, <code>pad</code>, inside our <code>initrd</code> directory and adjust its size to match the decompressed size of the original <code>initrd</code> directory. Then, by adjusting the amount of entropy in the file, we control the compressed size of <code>initrd.rgz</code>:</p><figure><img src="https://margin.re/attachments/limelight_3.png" alt="entropy trick for init recompression" loading="lazy"/></figure><p>For example, if <code>pad</code> contains all zeros (low entropy), its compressed size is small. On the other hand, if <code>pad</code> contains all random bytes (high entropy), its compressed size is large. As long as our target size falls between these two extremes, we can perform a binary search on the ratio of zeros to random bytes in order to exactly match the original compressed size.</p><h4 id="ctrlh">Ctrl+H</h4><p>Unfortunately, if we now mount the filesystem in the boot image and copy over our modified <code>initrd.rgz</code> file, the kernel <em>still</em> won’t boot. This is because the kernel expects that <code>initrd.rgz</code> resides at a very specific location in the boot image. When we mount the filesystem and copy the file, it adjusts the position of the actual data. This problem is relatively easy to fix; we can simply do a find-and-replace for every 512 byte sector of the original <code>initrd.rgz</code> and swap it with our modified <code>initrd.rgz</code>. This strategy effectively operates on the raw bytes in the disk image instead of mounting the boot sector as a filesystem.</p><figure><img src="https://margin.re/attachments/limelight_4.png" alt="finding and replacing initrd.rgz sectors" loading="lazy"/></figure><h4 id="unlocking-the-backdoor">Unlocking the Backdoor</h4><p>Now that we have successfully patched out signature validation, we are free to install a fake <code>option</code> package (with an invalid signature) and enable our persistent developer backdoor!</p><p>It is also helpful to include busybox in the <code>option</code> package for reverse engineering research, since recent versions of RouterOS do not actually ship with any standard <code>/bin</code> tools.</p><p>Once we reboot, we can simply <code>telnet -l devel &lt;ip&gt;</code> and provide the admin password to get a familiar bash shell!</p><figure><img src="https://margin.re/attachments/limelight_5.png" alt="developer shell on RouterOS VM" loading="lazy"/></figure><h2 id="routeros-ipc">RouterOS IPC</h2><h4 id="nova-messages">Nova Messages</h4><p>MikroTik designs RouterOS in a very modular fashion. The operating system contains more than 80 processes which communicate with each other through internal messages, and each process is generally responsible for one specific feature. For example, the <code>user</code> binary handles authentication for all other processes.</p><p>Upon boot, the <code>init</code> process spawns <code>/nova/bin/loader</code> which is RouterOS’s main control process. <code>loader</code> is responsible for spawning all of the other processes and managing interprocess communication. In some sense, <code>/nova/bin/loader</code> is “the router’s router.”</p><p>RouterOS implements the bulk of its IPC in the <code>libumsg.so</code> shared library. This library contains methods for serializing and deserializing messages, constructing abstraction layers to handle requests, and facilitating process-wide communication abstractions. The extensive utilization of this custom framework across RouterOS binaries is one of the things that makes RouterOS a difficult reverse engineering target.</p><p>So let’s break it down together.</p><p>We’ll start with the core player: “Nova Message” (<code>nv::message</code> internally). A nova message is a typed, key-value mapping. It comes in two flavors: a pseudo-JSON variant (now deprecated), and a serialized binary variant. You can recognize the binary messages because they always start with <code>M2</code> in ascii:</p><figure><img src="https://margin.re/attachments/limelight_6.png" alt="JSON and binary message format" loading="lazy"/></figure><h4 id="dissecting-a-message">Dissecting a Message</h4><p>Reverse engineering this message protocol shows that there are six types of data, which can each exist as a single value or as a list. We include the following cheat sheet to describe the serialization format in depth, and you can also find some open-source libraries which implement this protocol.</p><figure><img src="https://margin.re/attachments/limelight_7.png" alt="message cheat sheet" loading="lazy"/></figure><p>Each nova message key is a 24-bit integer and certain keys have a special meaning inside RouterOS. For example, keys of the form <code>0xFFxxxx</code> correspond to the <code>SYS</code> namespace and are used during message routing:</p><figure><img src="https://margin.re/attachments/limelight_8.png" alt="SYS namespace" loading="lazy"/></figure><p>Particularly of interest are the keys for <code>SYS_TO</code> (destination binary), <code>SYS_FROM</code> (origin binary), and <code>SYS_CMD</code> (what operation to invoke).</p><p>Armed with this information, we can now start to make sense of some RouterOS code. In the following image, we see <code>www</code> sending an authentication request to <code>user</code>. It constructs a new nova message, setting <code>SYS_TO</code> to the address <code>[13, 4]</code> and setting <code>SYS_CMD</code> to <code>1</code>.</p><figure><img src="https://margin.re/attachments/limelight_9.png" alt="IPC between www and user" loading="lazy"/></figure><h4 id="turning-x3-into-pseudo-xml">Turning x3 into Pseudo-XML</h4><p>So how do we actually know which process <code>[13, 4]</code> corresponds to? First, remember that <code>/nova/bin/loader</code> is responsible for spawning all the processes. When we look inside <code>loader</code>, we see it reads from a configuration file at <code>/nova/etc/loader/system.x3</code> using functions in the <code>libuxml++.so</code> library. Unfortunately, this .x3 file is not plain XML but appears to be some serialized format. With a bit of reverse engineering and some coffee, we recover MikroTik’s “pseudo-XML” format specification:</p><figure><img src="https://margin.re/attachments/limelight_9.5.png" alt="x3 to xml format" loading="lazy"/></figure><p>And now we can convert this serialized file into a more readable XML format:</p><figure><img src="https://margin.re/attachments/limelight_9.75.png" alt="system.x3 output" loading="lazy"/></figure><p>Aha! Here we clearly see a list of process entries. And each entry has a parameter <code>7</code> which seems to correspond to the file path and a parameter <code>4</code> which must correspond to the RouterOS ID.</p><h4 id="nova-handlers">Nova Handlers</h4><p>So that explains the <code>13</code> (<code>user</code>&#39;s ID), but what is the deal with the <code>4</code>?</p><p>It turns out that RouterOS processes can register “Nova Handlers” (<code>nv::Handler</code>) which act as subsidiary components, capable of handling and responding to their own requests. In this case, we see that <code>user</code> registers several handlers in <code>main</code>, one of which is registered at index <code>4</code>:</p><figure><img src="https://margin.re/attachments/limelight_10.png" alt="handler hierarchy" loading="lazy"/></figure><p>Neat!</p><p>It’s worth noting that every process also constructs a “Nova Looper” (<code>nv::Looper</code>) which acts at the interconnect between the process (e.g. <code>/nova/bin/user</code>) and the main controller (<code>/nova/bin/loader</code>). The <code>Looper</code> also contains a default handler, so if we were to send a message to address <code>[13]</code> (instead of <code>[13,4]</code>), for example, it would be handled by <code>user</code>’s <code>Looper</code> rather than a registered <code>Handler</code>.</p><h4 id="ipc-message-routing">IPC Message Routing</h4><p>So this is cool and all, but how does it actually work? What actually happens when <code>www</code> exchanges a message? How does the message end up in <code>user</code>’s login handler?</p><p>Let’s take a look at an example request and response. In this example, we have two processes: <code>foo</code> (at address <code>12</code>) and <code>bar</code> (at address <code>34</code>). Additionally, <code>bar</code> has a handler registered at address <code>50</code>. In this example, <code>foo</code> sends a request to <code>bar/sub</code> and then <code>bar/sub</code> responds:</p><figure><img src="https://margin.re/attachments/limelight_11.png" alt="message proxying example" loading="lazy"/></figure><p>Request (in blue):</p><ol><li><code>foo</code> constructs a message with <code>SYS_TO=[34,50]</code> (<code>bar/sub</code>) and <code>SYS_FROM=[]</code> and invokes <code>Looper.exchMessage()</code></li><li><code>foo</code>’s <code>Looper</code> forwards this message to <code>loader</code> over a socket created when <code>loader</code> spawned <code>foo</code></li><li><code>loader</code> receives the message, determines it is from <code>foo</code> based on the receiving socket, and determines the destination is <code>bar</code> (based on the first entry in <code>SYS_TO</code>)</li><li><code>loader</code> prepends <code>12</code> to <code>SYS_FROM</code>, strips <code>34</code> from <code>SYS_TO</code>, and forwards the message over a socket connected to <code>bar</code></li><li><code>bar</code>’s <code>Looper</code> receives the message and, seeing that <code>SYS_TO</code> is not empty, it locates a handler with address <code>50</code></li><li><code>bar</code>’s <code>Looper</code> successfully identifies the <code>sub</code> handler, strips <code>50</code> from <code>SYS_TO</code>, and forwards the message (in the same process) to <code>bar/sub</code></li><li><code>bar/sub</code> receives the message and, seeing that <code>SYS_TO</code> is empty, handles the message directly</li></ol><p>Response (in yellow):</p><ol><li>After <code>bar/sub</code> generates a response, it flips the <code>SYS_TO</code> and <code>SYS_FROM</code> lists in the original message.  Now, <code>SYS_TO=[12]</code> (<code>foo</code>) and <code>SYS_FROM=[]</code></li><li><code>bar/sub</code> pushes the message up to its parent <code>Looper</code></li><li><code>bar</code>’s <code>Looper</code> receives the message and identifies which handler sent it. In this case it is <code>bar/sub</code>, so it prepends <code>50</code> to <code>SYS_FROM</code> and forwards the message to <code>Loader</code> over a pre-established socket</li><li><code>loader</code> receives the message, identifies the origin is <code>bar</code> (based on the incoming socket), and identifies the destination is <code>foo</code> (based on the first entry in <code>SYS_TO</code>)</li><li><code>loader</code> prepends <code>34</code> to <code>SYS_FROM</code> and strips the first entry from <code>SYS_TO</code> and then forwards the message to <code>foo</code> over a socket</li><li><code>foo</code> receives the message and, seeing as <code>SYS_TO</code> is empty, handles it</li><li><code>foo</code>’s <code>Looper</code> identifies this is a response to a previous request, prepares the return value, and returns execution to <code>looper.exchMessage()</code></li></ol><p>This is a really cool way of routing messages and provides some useful features:</p><p>First, since <code>SYS_FROM</code> is constructed piece-by-piece as a message moves up the stack, this protocol protects against forgery; a binary or handler cannot spoof a source ID.</p><p>Secondly, <code>loader</code> is not just the hub of all process management, but also all message proxying. This means that <code>loader</code> is free to terminate services that are only intermittently needed (e.g., the <code>user</code> authentication binary) to free resources. If any services later require user authentication, <code>loader</code> receives a message destined for the now-terminated service and restarts it prior to proxying the message!</p><p>Finally, since message routing is performed dynamically, specific handlers can be refactored to other processes without much difficulty.</p><h4 id="multicast-and-broadcast">Multicast and Broadcast</h4><p>While most RouterOS messages are point-to-point (e.g. remote procedure calls or notification messages), RouterOS also provides functionality for multicast and broadcast.</p><figure><img src="https://margin.re/attachments/limelight_11.5.png" alt="multicast and broadcast" loading="lazy"/></figure><p>A binary sends a multicast message by setting <code>SYS_TO</code> equal to <code>[0xFF0002]</code> followed by a list of targets. Or for a broadcast message, a binary simply sets <code>SYS_TO</code> equal to <code>[0xFF0001]</code>. Internally, <code>loader</code> parses these special formats and duplicates the message as necessary.</p><h4 id="hooking-loader-to-visualize-ipc">Hooking loader to Visualize IPC</h4><p>Knowing all of these details, we wrote a tool to trace every internal RouterOS message. Because <code>loader</code> handles all messages, we need only sniff traffic passing through <code>loader</code>. Specifically, we proxy all messages from <code>loader</code> and forward them to a graphical front-end to visualize and decompose them. Included below is a demo of the tool. Notice that when we log in to the web interface there is a burst of authentication and data retrieval messages. Then, as we paginate through the web interface, we see additional requests for required data.</p><figure><div><video src="https://margin.re/content/media/2022/11/out.mp4" poster="https://img.spacergif.org/v1/3044x1840/0a/spacer.png" width="3044" height="1840" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Download <a href="https://github.com/MarginResearch/resources/blob/f4b09f2a9fab3a044cd6ebbda438c9b3e06097e3/videos/mikrotik_message_vizualization.mp4">here</a></figcaption></figure><h2 id="hand-rolled-authentication">Hand-rolled Authentication</h2><h4 id="security-through-obscurity">Security through Obscurity</h4><p>Our next goal is to understand MikroTik&#39;s authentication scheme so that we can build configuration or research tooling that hits post-authorization endpoints. It is therefore time to talk about everyone&#39;s favorite topic: <strong>cryptographic protocols</strong>!</p><p>Initial investigation shows that the <code>www</code> binary, listening for web configuration traffic on port 80, uses a standard Elliptic Curve Diffie-Hellman (ECDH) protocol to generate a shared secret over the Curve25519 elliptic curve, which is subsequently used to generate RC4 transfer and receive stream cipher keys.</p><p>That is all rather generic...<em>too generic</em> for the likes of MikroTik.</p><p>Thrillingly (or tragically, depending on your perspective), the <code>mproxy</code> binary listening for Winbox traffic on port 8291 seemingly does not use ECDH. Investigation of internal messages from <code>mproxy</code> to <code>user</code> shows a different series of data exchanged when compared against <code>www</code>’s authentication protocol.</p><p>In a rare stroke of luck, <a href="https://wiki.mikrotik.com/wiki/Manual:Security">MikroTik’s wiki page</a> details that Winbox uses “EC-SRP5” for authentication.  Elliptic Curve Secure Remote Protocol (EC-SRP) is a rather obscure protocol, and the internet is fairly void of any good guides detailing its implementation. After a lot of digging through archives and cryptography guides, we find that the Wayback Machine holds the keys to the puzzle in the form of an <a href="https://web.archive.org/web/20131228182531/http://grouper.ieee.org/groups/1363/passwdPK/submissions/p1363ecsrp.pdf">IEEE submission draft from 2001</a>.</p><p>To the best of our knowledge, <em>this draft was never actually included as an IEEE standard,</em> yet it is a great resource as it meticulously details EC-SRP&#39;s cryptographic calculations. Let&#39;s dive into it!</p><figure><img src="https://margin.re/attachments/limelight_12.png" alt="IEEE draft protocol" loading="lazy"/></figure><p>Ouch. That is a bit more complicated than ECDH. Let&#39;s break it down piece by piece so we are not overwhelmed.</p><h4 id="rationalizing-the-differences">Rationalizing the Differences</h4><p>What we first notice is that this guide has some noticeable differences compared to the MikroTik implementation. Two major discrepancies jump out.</p><p>First, the guide makes no reference to the Montgomery (Curve25519) curve and all calculations are performed over the Weierstrass curve. However, with some extensive reverse engineering we find that RouterOS only converts Weierstrass curve points to Montgomery form right before public keys are shared, and it performs all elliptic curve math over the Weierstrass curve.</p><p>So we can abstract away that detail and focus on the math.</p><p>The second difference is that MikroTik seemingly performs more math operations under the hood, convoluting the high-level operations that the IEEE submission draft details. Dynamic reverse engineering shows us that elliptic curve calculations result in points with z coordinates, which is curious given the commonly defined Weierstrass equation is two-dimensional: <code>Y<sup>2</sup>=X<sup>3</sup>+aX+b</code>. With yet more research we find that MikroTik actually performs calculations using the projective Weierstrass form in three dimensions, <code>y<sup>2</sup>=x<sup>3</sup>+axz<sup>4</sup>+bz<sup>6</sup></code>, and later projects the three dimensional point onto the plane <code>Z=1</code> to convert back into two dimensions.</p><p>Again, this is an implementation detail that we can abstract away for the sake of our comparison.</p><p><strong>With these two details out of the way, we can focus on a one-to-one comparison between MikroTik and IEEE submission draft operations.</strong></p><h4 id="fingerprinting-the-similaritiesor-lack-thereof"><strong>Fingerprinting the Similarities...(or lack thereof)</strong></h4><p>The first thing we notice is that the client public key calculation is identical, and also matches ECDH. The server public key calculation diverges from ECDH because it injects username and password information into the calculation to perform authentication during the key exchange. This is a feature of Password-Authenticated Key Exchanges (PAKEs), which is a core concept of all Secure Remote Protocols, including EC-SRP.</p><p>Unfortunately, when we compare MikroTik&#39;s server public key implementation against the draft, we find a significant difference: <em>MikroTik hashes the x coordinate of a generated <code>γ</code></em> <em>point twice, whereas the draft only hashes once</em>.</p><figure><img src="https://margin.re/attachments/limelight_13.png" alt="public key derivation" loading="lazy"/></figure><p>This is concerning because hashes are, by definition, irreversible. The MikroTik client will consequently need to compensate when performing its calculation to account for this difference.</p><p>It is therefore unsurprising when we find that there are a number of differences in the MikroTik calculation, as shown below in orange, versus the IEEE submission draft. <strong>It is rather remarkable that, even with these alterations, the MikroTik server and client still successfully generate a mutual shared secret</strong>. Feel free to marvel at that realization, we surely did!</p><figure><img src="https://margin.re/attachments/limelight_14.png" alt="crypto comparison" loading="lazy"/></figure><h4 id="finalizing-the-protocol">Finalizing the Protocol</h4><p>There are a few final details required to successfully authenticate now that we have our shared secret. These include:</p><ul><li>Preparing and transmitting confirmation codes to confirm that both sides share the same secret. This also guarantees authentication, since an incorrect username or password would generate a wildly different point</li><li>Generating AES-CBC and HMAC keys for tx and rx</li><li>Implementing unique block padding for the AES cipher, which is almost-but-not-quite PKCS7</li><li>Accounting for fragmented messages over 255 bytes in length</li></ul><p>With those final details in place, we can now send encrypted messages and decrypt received messages from the MikroTik server!</p><h4 id="tools-and-further-reading">Tools and Further Reading</h4><p>If you are only interested in the final result, have no fear. We implemented a client version of Winbox and MAC Telnet (another common RouterOS configuration) service that you can plug-and-play. For those more interested in watching the authentication scheme progress, we also have a Winbox server implementation that can connect to the Winbox client. These tools are included in the first link below.</p><p>For those interested in the IEEE submission draft protocol, we created a client and server version of that protocol available in the second link.</p><p>Finally, we have additional details on the EC-SRP protocol and MikroTIk’s projective space calculations in a previous blog post, which you will find in the third link.</p><ol><li><a href="https://github.com/MarginResearch/mikrotik_authentication">MikroTik Authentication</a></li><li><a href="https://github.com/MarginResearch/EC-SRP">EC-SRP Authentication, as defined in the IEEE draft</a></li><li><a href="https://github.com/MarginResearch/resources/blob/83e402a86370f7c3acf8bb3ad982c1fee89c9b53/documents/Pulling_MikroTik_into_the_Limelight.pdf">MikroTik Authentication Revealed</a></li></ol><h2 id="jailbreaking-routeros">Jailbreaking RouterOS</h2><h4 id="listening-in-on-a-conversation-between-wwwand-itself">Listening in on a Conversation between www...and Itself?</h4><p>Let’s dive into a remote jailbreak we discovered in RouterOS! Our journey starts with the <code>www</code> binary which manages MikroTik’s WebFig web configuration portal exposed on port 80 by default.</p><p>After a bit of initial reverse engineering, we discover that <code>www</code> uses a servlet model to handle requests. This is a fairly common pattern for web servers and generally makes code nice and modular. Specifically, <code>www</code> registers certain url prefixes to servlets which implement the actual <code>doGet</code>, <code>doPost</code>, etc., methods.</p><p>For example, if we load <code>/jsproxy/…</code>, the <code>jsproxy</code> servlet handles these requests. Similarly if we load <code>/scep/…</code>, this request is handled by the <code>scep</code> servlet. You get the picture. In total there are seven of these custom servlets (not including the built-in servlets like <code>dir</code>).</p><p>Interestingly, the code for these servlets is actually separated into special <code>.p</code> shared libraries located in <code>/nova/etc/www</code>. For example, the code for the jsproxy servlet is located in <code>/nova/etc/www/jsproxy.p</code>.</p><p>In the spirit of conserving virtual memory, <code>www</code> utilizes lazy loading when dealing with servlets. <code>www</code> loads no servlets initially, and only upon the first request to a servlet is one actually loaded.</p><p>That seems like a pretty good model; but as we use the message tracer we noticed something interesting when a servlet is loaded. Specifically we see a strange message from <code>www</code> to <code>www/2</code> (handler #2).</p><figure><img src="https://margin.re/attachments/limelight_15.png" alt="FoisHandler and intercepted message" loading="lazy"/></figure><p>There are two things that caught our attention:</p><ol><li>Why is <code>www</code> sending a message to itself?</li><li>Why do some of the values look like virtual addresses? (note: we’re looking at 32-bit x86 here). IPC messaging is for sending messages <em>between</em> processes, and virtual addresses should be meaningless</li></ol><p>When we examine the handler for <code>www/2</code> we see something even more frightening: <em>it appears to pull a pointer from the message object and invoke it as a function</em>?!?</p><p>It turns out that when a servlet is first loaded, it needs to register itself with the <code>www</code> process. And even though the servlet is loaded in the <em>same process </em>as <code>www</code>, the MikroTik developers decided to use IPC to perform this initial handshake rather than doing something more reasonable like having <code>www</code> look up any needed symbols in the servlet library…</p><p>Very spicy! If we could hit this handler with an arbitrary message, we could invoke any pointer and surely get a shell! <strong>But can we hit it?</strong></p><h4 id="permission-escalation-to-super-admin">Permission Escalation to super-admin</h4><p>As an end-user, it is possible to send arbitrary messages into the system through one of the several proxy binaries, but we need to authenticate first. And since we already reverse-engineered the Winbox client as described in the previous section, all the hard authentication work is done! We can send arbitrary messages, but unfortunately hitting the handler is not quite that easy.</p><p>It turns out that RouterOS handlers are also gated based on a policy bitmask. In this case, our vulnerable handler <code>www/2</code> (handler #2, FoisHandler) has a required policy of <code>0x80000000</code> which is unattainable via the GUI configuration panel. As an admin, our default policy bitmask is <code>0x5FFFE</code> and the maximum we can set is <code>0x7FFFE</code>.</p><p>Messages initiated internally have a maximum permission level by default, i.e., they run with super-admin privileges. But all of the messages we proxy through our Winbox client have their permission level set to something lower, which means we can never actually hit this handler with a proxied message.</p><p>Or can we?</p><p>The GUI controls policy levels with checkboxes that indicate certain privileges (e.g., read, write, ssh, reboot, etc). Using our message tracer, we see that internally this results in a single message sent with a combined bitmask value to indicate the permission level. The GUI will never send a message with a permission greater than <code>0x7FFFE</code>, but what if we just send our own message with a permission of <code>0xFFFFFFFF</code>?</p><figure><img src="https://margin.re/attachments/limelight_16.png" alt="permission escalation" loading="lazy"/></figure><p><strong>This actually works and successfully upgrades our permission level from admin to super-admin, allowing us to hit the vulnerable handler!</strong></p><h4 id="ropping-and-popping">ROPping and Popping</h4><p>The last step is to achieve RCE, which we can do with the following steps:</p><ol><li>Upload a stage2 payload and busybox using FTP. The stage2 will execute a netcat listener using busybox and listen for traffic on port 1337. Because the exploit is post-authentication, we can use MikroTik’s FTP server to achieve this</li><li>Send a crafted message to <code>user</code> to escalate our privileges</li><li>Send a crafted message to FoisHandler, including a ROP chain in the body of our message which is stored on the stack</li><li>Hijack PC using the controlled function pointer and pivot to the ROP chain</li><li>ROP to <code>chmod</code> to set our stage2 to executable</li><li>ROP to execute stage2</li><li>Connect to the new reverse shell listening on port 1337</li></ol><figure><img src="https://margin.re/attachments/limelight_17.png" alt="remote jailbreak" loading="lazy"/></figure><h4 id="poc-or-gtfo">POC or GTFO</h4><p>And just like that, we remotely jailbreak RouterOS for the first time in three years! It should be noted that this exploit is only viable on RouterOS v6, as FoisHandler was removed in the v7 overhaul.</p><p>Interested in trying it out? <a href="https://github.com/MarginResearch/FOISted">Our FOISted tool</a> automatically jailbreaks RouterOS versions 6.34 (2016) to 6.49.6 (latest v6 release as of this post). Simply point it at your router&#39;s IP, provide credentials, and enjoy your shell!</p><h2 id="conclusion">Conclusion</h2><p>This blog post covered a lot, so it is worth rehashing the knowledge you gained if you stuck with us:</p><ul><li>We now understand the construction of MikroTik firmware packages, and how to bypass cryptographic signing to get a developer shell on the RouterOS virtual machine</li><li>We took a deep dive into the IPC message protocol, how messages are crafted, and how <code>loader</code> acts as the “router’s router”</li><li>We endured a chaotic adventure into EC-SRP5 as implemented by MikroTik for its Winbox and MAC Telnet services, and now have client programs that perform authentication on our behalf</li><li>We added a novel jailbreak to our toolkit that exploits two post-authentication vulnerabilities to root any RouterOS v6 device, physical or virtual</li></ul><p>Our intent for this post is to document these concepts and refresh the publicly available knowledge of MikroTik and RouterOS, with hopes of lowering the barrier to entry for other interested researchers and tinkerers. This is especially important because MikroTik gravitates towards obscurity, cluching tight to their hand-rolled source code and often leaving customer questions about implementation details unanswered.</p><p><strong>You are now ready to start your own adventure into MikroTik research</strong>! Armed with this knowledge, together we can pull this target from the fringes of obscurity back into the limelight!</p><p><em><a href="https://github.com/MarginResearch/resources/blob/87d70bc5a257690b9a9822d210b407779903aca1/documents/Pulling_MikroTik_into_the_Limelight.pdf">You can find the full slide deck for this presentation here.</a></em></p>
</article>
</div>
</div></div>
  </body>
</html>
