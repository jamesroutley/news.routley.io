<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://depot.dev/blog/buildkit-in-depth">Original</a>
    <h1>BuildKit in depth: Docker&#39;s build engine explained</h1>
    
    <div id="readability-page-1" class="page"><div><p>This article explains how BuildKit works in depth, why it&#39;s faster than Docker&#39;s previous build engine, and what it looks like under the hood.</p>

<p>BuildKit is Docker&#39;s new default build engine <a href="https://docs.docker.com/engine/release-notes/23.0/#2300">as of Docker Engine v23.0</a>.</p>
<p>Despite BuildKit being used by millions of developers, the documentation out there is relatively sparse. This has led to it being seen as a bit of a black box. At <a href="https://depot.dev/">Depot</a>, we&#39;ve been working with (and reverse engineering) BuildKit for years and have developed a deep understanding of it throughout this process. Now we understand the inner workings, we have a better appreciation for it and want to share that knowledge with you.</p>
<p>In this article, we explain how BuildKit works under the hood, covering everything from frontends and backends to LLB (low-level build) and DAGs (directed acyclic graphs). We help to demystify BuildKit and explain why it&#39;s such an improvement over Docker&#39;s original build engine.</p>
<h2 id="what-is-buildkit"><a aria-hidden="true" tabindex="-1" href="#what-is-buildkit"><span></span></a>What is BuildKit?</h2>
<p>BuildKit is a build engine that takes a configuration file (such as a Dockerfile) and converts it into a built artifact (such as a Docker image). It&#39;s faster than Docker&#39;s original build engine due to its ability to optimize your build by parallelizing build steps whenever possible and through more advanced <a href="https://docs.docker.com/build/guide/layers/">layer caching</a> capabilities.</p>
<h2 id="buildkit-speeds-up-docker-builds-with-parallelization"><a aria-hidden="true" tabindex="-1" href="#buildkit-speeds-up-docker-builds-with-parallelization"><span></span></a>BuildKit speeds up Docker builds with parallelization</h2>
<p>A Dockerfile can consist of build <em>stages</em>, each of which can contain one or more <em>steps</em>. BuildKit can determine the dependencies between each stage in the build process. If two stages can be run in parallel, they will be. Stages are a great way to break your Docker image build up into parallelizable steps — for example, you could install your dependencies, build your application at the same time, and then combine the two to form your final image.</p>
<p>To take advantage of parallelization, you must rewrite your Dockerfile to use multi-stage builds. A <em>stage</em> is a section of your Dockerfile that starts with a <code>FROM</code> statement and continues until you reach another <code>FROM</code> statement. Stages can be run in parallel, so by this mechanism, the steps in one stage can run in parallel with the steps in another.</p>
<p>It&#39;s worth noting that the steps <em>within</em> a stage run in a linear order, but the order in which stages run may not be linear. To determine the order in which stages will be run, BuildKit detects the name of each stage — which, for a Dockerfile, is the word after the <code>as<em> </em></code>keyword in a <code>FROM </code>statement.</p>
<p>To determine the stage that another stage depends on, we look at the word <em>after</em> the <code>FROM</code> keyword. In the example below, <code>FROM docker-image as stage1</code> means that the <code>stage1</code> stage depends on the Docker image from Docker Hub, and <code>FROM stage1 as stage2</code> means that the <code>stage2</code> stage depends on the <code>stage1</code> stage. It&#39;s possible to chain many stages together in this way.</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="" data-theme="default"><code data-language="" data-theme="default"><span data-line=""><span>FROM docker-image as stage1</span></span>
<span data-line=""><span>RUN command1</span></span>
<span data-line=""><span></span></span>
<span data-line=""><span>FROM stage1 as stage2</span></span>
<span data-line=""><span>RUN command2</span></span>
<span data-line=""><span></span></span>
<span data-line=""><span>FROM stage2 as stage3</span></span>
<span data-line=""><span>RUN command3</span></span></code></pre></div>
<p>It&#39;s also possible to have multiple stages depend on one stage:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="" data-theme="default"><code data-language="" data-theme="default"><span data-line=""><span>FROM docker-image as parent</span></span>
<span data-line=""><span>…</span></span>
<span data-line=""><span>FROM parent as child1</span></span>
<span data-line=""><span>…</span></span>
<span data-line=""><span>FROM parent as child2</span></span></code></pre></div>
<p>BuildKit is able to evaluate the structure of these <code>FROM </code>statements and work out the dependency tree between the steps in each stage.</p>
<h3 id="optimize-your-dockerfile-to-take-advantage-of-parallelization"><a aria-hidden="true" tabindex="-1" href="#optimize-your-dockerfile-to-take-advantage-of-parallelization"><span></span></a>Optimize your Dockerfile to take advantage of parallelization</h3>
<p>Rewriting your Dockerfile to use multi-stage builds will allow you to take advantage of the speed improvements that BuildKit brings to Docker.</p>
<p>In the example below you can see an unoptimized file with a single stage and an optimized file with two stages: one named <code>build</code>, and another which is unnamed (this is the naming convention for the final stage in a Dockerfile).</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image1.webp" alt="Comparison of two Dockerfiles that both build and deploy a production Node application. One is unoptimized for BuildKit and has a single stage. The other is optimized for BuildKit, and uses two different stages that run in parallel. The code for both Dockerfiles is made available in GitHub later in the article." width="1200" height="675" decoding="async" loading="lazy"/></p>
<p><span><p>Optimizing this Dockerfile allows steps such as enabling Corepack to run in parallel with copying the package.json
file and the pnpm-lock.yaml file into the /app directory.</p></span></p><p>Once your Dockerfile has been optimized to run in multiple stages, BuildKit can run them in parallel. Below you can see the difference between using BuildKit to run multiple stages in parallel (for building and deploying a Node app) and running all steps sequentially (without multi-stage builds). This Node app deployment example will be used throughout this article, and the Dockerfiles — both optimized for BuildKit (multi-stage) and unoptimized (basic) — are <a href="https://github.com/depot/examples/tree/main/buildkit">available on our GitHub</a>.</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image2.webp" alt="Flow diagram showing how the different RUN statements of a Dockerfile are processed, with and without BuildKit. The “without BuildKit” diagram shows a sequential line of steps. The “with BuildKit” diagram shows two branches where stages are running in parallel." width="1200" height="1260" decoding="async" loading="lazy"/></p>
<p><span><p>If you use BuildKit to parallelize your stages, your build will complete much faster.</p></span></p><h2 id="buildkit-speeds-up-docker-builds-with-layer-caching"><a aria-hidden="true" tabindex="-1" href="#buildkit-speeds-up-docker-builds-with-layer-caching"><span></span></a>BuildKit speeds up Docker builds with layer caching</h2>
<p>BuildKit is also able to improve build performance through clever use of layer caching. With layer caching, each step of your Dockerfile (such as <code>RUN</code>, <code>COPY</code>, and <code>ADD</code>) is cached individually, as a separate reusable layer.</p>
<p>Often, individual layers can be reused, as the results of a build step can be retrieved from the cache rather than rebuilt every time. This eliminates many steps from the build process and often dramatically increases overall build performance.</p>
<p>The hierarchy of layers in BuildKit&#39;s layer cache is a tree structure, so if one build step has changed between builds, that build step plus all its child steps in the hierarchy must be rebuilt. With traditional single-stage builds, every single step depends on the previous step, so it can be immensely frustrating if you have a RUN statement that invalidates the cache in an early part of your Dockerfile — because all subsequent statements must be recomputed any time that statement runs. <a href="https://depot.dev/blog/faster-builds-with-docker-caching#order-your-layers-wisely">The order of your statements</a> in a Dockerfile has a major impact on optimizing your build to leverage caching.</p>
<p>However, if you&#39;ve optimized your Dockerfile for BuildKit, used multi-stage builds, and ordered your statements to maximize cache hits, you can reuse previous build results much more frequently.</p>
<h2 id="buildkit-under-the-hood"><a aria-hidden="true" tabindex="-1" href="#buildkit-under-the-hood"><span></span></a>BuildKit under the hood</h2>
<p>&#34;BuildKit builds are based on a binary intermediate format called LLB that is used for defining the dependency graph for processes running part of your build. tl;dr: LLB is to Dockerfile what LLVM IR is to C.&#34;</p>
<p>— <a href="https://github.com/moby/buildkit#exploring-llb">BuildKit&#39;s README file</a>.</p>
<p>To truly understand how BuildKit works, let&#39;s unpack this statement. BuildKit has taken inspiration from compiler designers by creating an intermediate representation between the input and the output to its system. In compiler design, an intermediate representation is a data structure or some human-readable code (such as assembly language) that sits between the source code input and the machine code output. This intermediate representation is later converted into different types of machine code for each different machine the code needs to run on.</p>
<p>BuildKit uses this same principle by inserting an intermediate representation between the Dockerfile input and the final Docker image. BuildKit&#39;s intermediate representation is known as a low-level build (LLB), which is a directed acyclic graph (DAG) data structure that sits at the heart of BuildKit&#39;s information flow.</p>
<h2 id="the-flow-of-information-through-buildkit-frontends-backends-and-llb"><a aria-hidden="true" tabindex="-1" href="#the-flow-of-information-through-buildkit-frontends-backends-and-llb"><span></span></a>The flow of information through BuildKit: frontends, backends and LLB</h2>
<p>Continuing with the compiler comparison, BuildKit also uses the concept of frontends and backends.</p>
<p>The frontend is the part of BuildKit that takes the input (usually a Dockerfile) and converts it to LLB. BuildKit has frontends for a variety of different inputs including <a href="https://nixos.org/">Nix</a>, <a href="https://openllb.github.io/hlb/">HLB</a>, and <a href="https://github.com/vito/bass">Bass</a>, all of which take different inputs but build Docker images, and <a href="https://github.com/denzp/cargo-wharf">CargoWharf</a>, which is used to build something else entirely (a Rust project). This shows the versatility BuildKit has to build many different types of artifacts, even though the most common use currently is building Docker images from Dockerfiles.</p>
<p>The backend takes the LLB as an input and converts it into a build artifact (such as a Docker image) for the machine architecture that you&#39;ve specified. It builds the artifact by using a <a href="https://opensource.com/article/21/9/container-runtimes">container runtime</a> — either runc or containerd (which uses runc under the hood anyway).</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image3.webp" alt="Diagram showing the flow of information through BuildKit: the Dockerfile to the BuildKit frontend, and then to the LLB, then to the BuildKit backend and finally to the Docker image." width="1200" height="548" decoding="async" loading="lazy"/></p>
<p><span><p>BuildKit&#39;s frontend acts as an interface between the input (Dockerfile) and the LLB. The backend is the interface
between the LLB and the output (Docker image).</p></span></p><h2 id="buildkits-llb"><a aria-hidden="true" tabindex="-1" href="#buildkits-llb"><span></span></a>BuildKit&#39;s LLB</h2>
<p>We&#39;ve referred to the LLB a few times so far — but what exactly is it?</p>
<p>It&#39;s a <em>directed acyclic graph (DAG) data structure</em>, which is a special type of <a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">graph data structure</a>. In a DAG, each event is represented as a node with arrows that flow in a particular direction, hence the word “directed.” Arrows start at a <em>parent node</em> and end on a <em>child node</em>. Child nodes are only allowed to execute after <em>all</em> parent nodes have finished executing.</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image4.webp" alt="A diagram of a directed acyclic graph (DAG). It consists of a number of nodes that have all been labeled alphabetically. All the nodes are connected by various arrows and the arrows are all pointing in one direction." width="1200" height="630" decoding="async" loading="lazy"/></p>
<p>There can be no loops in a DAG, hence the word “acyclic.” This is necessary for modeling build steps, as if a build process allowed loops, the process would never complete because two steps would require each other to finish before each one starts!</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image5.webp" alt="A small DAG is shown with just two nodes, A and B. An arrow points from A to B. A further arrow that points from B to A is highlighted red and crossed out to emphasize that this direction of travel is not allowed in a DAG. Allowing flow from A to B and then back to A again would count as a cycle, which is not allowed." width="1200" height="394" decoding="async" loading="lazy"/></p>
<p>BuildKit&#39;s LLB DAG is used to represent which build steps depend on each other and the order in which everything needs to happen. This ensures that certain steps don&#39;t occur before other steps are completed (like installing a package before downloading it).</p>
<p>In the case of Docker builds, BuildKit uses its Docker frontend to create the LLB from the Dockerfile. For example, <a href="https://github.com/depot/examples/blob/main/buildkit/multi-stage/Dockerfile">this Dockerfile</a> for building and deploying a Node app would create the following LLB DAG:</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image6.webp" alt="A diagram of the LLB DAG for the above Dockerfile. Each node is a particular type of LLB operation such as SourceOp, ExecOp, or FileOp." width="1200" height="630" decoding="async" loading="lazy"/></p>
<p><span><p>In this LLB DAG, each node represents an operation that can happen. Each LLB operation can take one or more
filesystems as its input and output one or more filesystems.</p></span></p><p>To help you understand more about the LLB operations that your Dockerfile would translate to, we built a free tool that converts any given Dockerfile into LLB through a real-time editor. Our <a href="https://depot.dev/blog/dockerfile-explorer">Dockerfile Explorer</a> is easy to use — simply paste your Dockerfile into the box on the left and then view the LLB operations on the right.</p>
<p>Our Node Dockerfile creates a number of LLB operations, the first three of which can be viewed below. Each operation has a type such as SourceOp or ExecOp, a unique identifier in the form of a hash value, and some extra data like the environment and the commands to be run. The hash values indicate the dependencies between the operations. For example, the first ExecOp operation has a hash value of <code>0534a47f</code>, and the second ExecOp operation takes as its input an operation with a hash of the same value (<code>0534a47f</code>). This shows that these two operations are directly linked on the LLB DAG.</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image7.webp" alt="Screenshot of Depot&#39;s Dockerfile Explorer, showing three different operations: a SourceOp and two ExecOps. The output hash of the first ExecOp is highlighted, as is the input hash of the second ExecOp, and it shows the hashes are the same." width="960" height="583" decoding="async" loading="lazy"/></p>
<h2 id="the-different-buildkit-llb-operations-explained"><a aria-hidden="true" tabindex="-1" href="#the-different-buildkit-llb-operations-explained"><span></span></a>The different BuildKit LLB operations explained</h2>
<h3 id="sourceop"><a aria-hidden="true" tabindex="-1" href="#sourceop"><span></span></a>SourceOp</h3>
<p>This loads source files or images from a source location, such as DockerHub, a Git repository, or your local build context.</p>
<p>All SourceOp operations that originated from a Dockerfile have been generated from Dockerfile <code>FROM</code> statements.</p>
<h3 id="execop"><a aria-hidden="true" tabindex="-1" href="#execop"><span></span></a>ExecOp</h3>
<p>ExecOp always executes a command. It&#39;s equivalent to Dockerfile <code>RUN</code> statements.</p>
<h3 id="fileop"><a aria-hidden="true" tabindex="-1" href="#fileop"><span></span></a>FileOp</h3>
<p>This is for operations that relate to files or directories, including Dockerfile statements such as <code>ADD</code> (add a file or directory), <code>COPY</code> (copy a file or directory), or <code>WORKDIR</code> (set the working directory of your Docker container).</p>
<p>It&#39;s possible to use this operation to copy the output of other steps in different stages into a single step. Using <a href="https://github.com/depot/examples/blob/main/buildkit/multi-stage/Dockerfile">our example Dockerfile</a>, the <code>COPY --from</code> statement copies some of the resources from the output of the previous <code>build</code> stage into the final stage.</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="" data-theme="default"><code data-language="" data-theme="default"><span data-line=""><span>FROM node:20</span></span>
<span data-line=""><span>…</span></span>
<span data-line=""><span>COPY --from=build /appbuild /app/build</span></span></code></pre></div>
<p>We can use the Dockerfile Explorer to see how BuildKit deals with this — it takes the output of the final step in each stage and adds them together.</p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image8.webp" alt="Screenshot within the Dockerfile Explorer. It shows that the hash of the final steps in the build stage is b71bec19." width="931" height="220" decoding="async" loading="lazy"/></p>
<p><img src="https://isakfalk.com/images/buildkit-in-depth-image9.webp" alt="Screenshot within the Dockerfile Explorer. It shows that the hash of the penultimate step of the final stage is 3ca1e723 and that the final FileOp step (which copies files from the build stage to the final stage) takes both b71bec19 and 3ca1e723 as inputs." width="931" height="391" decoding="async" loading="lazy"/></p>
<h3 id="mergeop"><a aria-hidden="true" tabindex="-1" href="#mergeop"><span></span></a>MergeOp</h3>
<p>MergeOp allows you to merge multiple inputs into a single flat layer (and is the underlying mechanism behind Docker&#39;s <code>COPY --link</code>).</p>
<h3 id="diffop"><a aria-hidden="true" tabindex="-1" href="#diffop"><span></span></a>DiffOp</h3>
<p>This is a way of calculating the difference between two inputs and producing a single output with the difference represented as a new layer, which you might then want to merge into another layer using MergeOp.</p>
<p>However, this operation is currently not available for the Dockerfile frontend.</p>
<h3 id="buildop"><a aria-hidden="true" tabindex="-1" href="#buildop"><span></span></a>BuildOp</h3>
<p>This is an <a href="https://github.com/moby/buildkit/blob/master/solver/pb/ops.proto#L186C1-L187C73">experimental</a> operation that implements nested LLB builds (for example, running one LLB build that produces another dynamic LLB).</p>
<p>This operation is also unavailable for the Docker frontend.</p>
<h2 id="buildkit-speeds-up-your-docker-builds-using-its-llb-dag"><a aria-hidden="true" tabindex="-1" href="#buildkit-speeds-up-your-docker-builds-using-its-llb-dag"><span></span></a>BuildKit speeds up your Docker builds using its LLB DAG</h2>
<p>Although BuildKit can take multiple frontends, the Dockerfile frontend is by far the most popular. BuildKit uses its Dockerfile frontend to convert statements from your Dockerfile into a DAG of LLB operations — including SourceOp, ExecOp and FileOp — and then it uses that LLB format to build an artifact, like a Docker image, for the specified architectures that were requested.</p>
<p>At Depot, we&#39;ve taken what was already great about BuildKit and further optimized it to build Docker images up to 40x faster on cloud builders with persistent caching. We&#39;ve developed our own <a href="https://isakfalk.com/blog/introducing-depot">drop-in replacement CLI</a>, <code>depot build</code>, that can be used to replace your existing <code>docker build</code> wherever you&#39;re building images today. Sign up today for our <a href="https://isakfalk.com/sign-up">7-day free trial</a> and try it out for yourself.</p>
<h2 id="related-articles"><a aria-hidden="true" tabindex="-1" href="#related-articles"><span></span></a>Related Articles</h2>
<ul>
<li><a href="https://isakfalk.com/blog/depot-magic-explained">How Depot speeds up Docker builds</a></li>
<li><a href="https://isakfalk.com/blog/how-to-use-buildkit-cache-mounts-in-ci">How to use BuildKit cache mounts in CI providers</a></li>
</ul></div></div>
  </body>
</html>
