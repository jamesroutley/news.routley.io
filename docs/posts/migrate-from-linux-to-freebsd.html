<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://klarasystems.com/articles/easily-migrate-from-linux-to-freebsd/">Original</a>
    <h1>Migrate from Linux to FreeBSD</h1>
    
    <div id="readability-page-1" class="page"><div>




<div>
<div>
<div>
<p>If you are already experienced with Linux, FreeBSD should feel very familiar. The operating systems have a lot in common, due both to their Unix heritage and many shared modern components. Much of what may be unfamiliar to a Linux user adopting FreeBSD is also inconsistent between Linux distributions themselves.  </p>



<p>In this article, we will cover some of the conceptual differences between Linux and FreeBSD, and go on to contrast some aspects of the basic system utilities and the differing views of hardware given by the two systems.</p>



<hr/>



<h2><span><b>Structure and </b></span><strong><strong>Organization </strong></strong></h2>



<p>The fact that FreeBSD is a more unified entity is a significant difference of note. On Linux there is a diverse range of choices covering the core components needed to build on the kernel to form a usable working system. While this diversity does bring an element of choice it can lead to a lack cohesion.  FreeBSD components are all developed together so where a change has an impact across subsystems developers can consider the full picture. Though we have a FreeBSD focus here, it is actually Linux that is the outlier in this regard–most operating systems are complete unified entities with a clear separation to applications. </p>



<p>In practical terms the apparent difference if you come to FreeBSD with existing knowledge of Linux is greater separation between the base system and user-installed packages. The base system includes all necessary core functionality, and is updated as a single unit. Additional optional software is installed from ports or packages and managed separately.   </p>



<p>This separation is reflected in the filesystem hierarchy, as any program installed via ports or packages is located in <em>/usr/local/bin</em> or <em>/usr/local/sbin</em>, while similar core system utilties run from /usr/bin or /usr/sbin. For the duration of a release (a major version number like 13.*), the base system ABI and API remains stable, and the distinction between base system and installed packages remains clear. Being able to combine a stable base system with up-to-date 3rd party applications and packages can be an advantage over Linux distributions where using long-term support releases often entails being pinned to older versions of the packages as well. </p>



<p>Under FreeBSD, the <strong>ports</strong> system enables easy access to and building of optional software from source, while the <strong>pkg</strong> command retrieves binary packages and is analogous to tools like <strong>apt</strong>, <strong>yum</strong>, <strong>dnf</strong> and <strong>pacman</strong> on Linux. </p>



<p>There is also the option to configure and compile both ports and the base system manually. We went into more detail on this in the article “Customizing FreeBSD Ports and Packages”. [https://klarasystems.com/articles/customizing-freebsd-ports-and-packages/]</p>







<div>




<div>
<div>
<div>
<p><strong>You might also be interested in</strong></p>



<h2><strong>Get more out of your FreeBSD development</strong></h2>



<p>Kernel development is crucial to many companies. If you have a FreeBSD implementation or you’re looking at scoping out work for the future, our team can help you further enable your efforts.</p>




</div>
</div>
</div>




</div>




</div>
</div>



<h2><strong>System Utilities </strong></h2>



<p>From the early days of Linux, the GNU project was used as the source for many traditional Unix command-line utilities. GNU conventions for such things as command-line options have thus been influential on Linux.  </p>



<p>On FreeBSD, many commands lack the GNU-inspired long form and optional options, and don’t allow options to come after non-optional arguments. For example, in the following command the long form <strong>–all</strong> is not recognized, so the <strong>-l </strong>will be treated as a filename instead of the “long-form listing” argument: </p>



<pre><code>ls --all file –l </code></pre>



<p>You’ll find some commands like <strong>grep</strong> and <strong>diff</strong> on FreeBSD that are largely compatible with their GNU counterparts, but many commands have remained somewhat simpler, only picking up the more useful enhancements.  Should a FreeBSD user need them, the GNU coreutils themselves may also be installed directly from ports or packages. </p>



<p>One prominent command where you may notice significant differences when coming from Linux is the <strong>ps</strong> command. The origins of this go back to earlier Unix history and the division between System V and BSD. System V adopted the conventional <strong>‘-’</strong> prefix for options to <strong>ps</strong> but used different letters. On Linux, <strong>ps</strong> accepts either the BSD options without a <strong>‘-’</strong> prefix or the System V ones with it.   </p>



<p>If you’re accustomed to typing a command like <strong>ps -ef</strong> to list every process with full details then you’ll discover that doesn’t work on FreeBSD. This may be the case if your early Unix experience was on a System V based OS such as Solaris or IRIX.  </p>



<p>While the option letters differ, the functionality is much the same. To list all processes you would use <strong>ps ax</strong>. There isn’t a direct counterpart to <strong>-f</strong> unless you select explicit fields to output with <strong>-o</strong> but <strong>ps aux</strong> is a common short form that includes more detail in the output. Arguably, BSD syntax is a better choice even for Linux users themselves, since it functions as well under most Linux distros as it does under BSD—which makes using the BSD syntax an easy way to increase portability of scripts and a sysadmin’s working toolkit. </p>



<p>Linux also exposes a lot of information about processes in a special filesystem mounted at <em>/proc</em>. FreeBSD can optionally provide this as part of the Linuxulator compatibility subsystem, but the corresponding native interface is via the <strong>procstat</strong> command rather than a special psuedo filesystem. </p>



<h2><strong><strong>Hardware Information</strong></strong></h2>



<p>Managing hardware is one of the primary roles of an operating system. Both Linux and FreeBSD present special device files in <em>/dev</em> which correspond to hardware devices such as disks. These special files allow applications to interact with hardware device drivers using standard input/output operations, and act as a mechanism for identifying and naming devices.  </p>



<p>In the past you would find a fixed static structure below /dev but on a modern system, you’ll find a dynamically updated view of currently attached hardware. This means that the <strong>ls</strong> command on <em>/dev</em> works as a simple way to discover what hardware is available on the system.  </p>



<p>FreeBSD and Linux populate /dev using different mechanisms. FreeBSD has a special in-kernel devfs filesystem which exposes the device view based on the internal kernel structures, while Linux uses <em>udev</em> to implement a similar system in userspace. Putting that detail aside, both systems include commands to give richer details of the detected hardware. </p>



<p>On Linux, there are a number of commands with names starting with ls. This can vary between distributions but examples include <strong>lsblk</strong>, <strong>lspci</strong>, <strong>lsusb</strong>, <strong>lsscsi</strong>, <strong>lshw</strong>, <strong>lscpu</strong> and <strong>lsmem</strong>. Some of these have fairly direct counterparts on FreeBSD like <strong>pciconf</strong> for <strong>lspci</strong> and <strong>usbconfig</strong> for <strong>lsusb</strong>.  </p>



<p>For some basic values, you can use the <strong>sysctl</strong> command, for example <strong>sysctl -n hw.physmem</strong> outputs the amount of RAM and <strong>sysctl -n kern.disks</strong> lists the attached disks.</p>



<h3><strong><strong>Disks</strong></strong></h3>



<p>On Linux, <strong>lsblk</strong> is used for listing disks (block devices). These typically have names like <em>/dev/sda</em>, <em>/dev/sdb</em> etc with numeric suffixes for partitions, e.g.  <em>/dev/sda1</em>. This naming covers most hardware types but you may come across other names such as <em>/dev/sr0</em> for an optical drive or <em>/dev/mmcblk0</em> for MMC memory.  </p>



<p>On FreeBSD, device names reflect the hardware driver with documentation in a man page in section 4, e.g. <strong>ada(4)</strong> for the ATA driver. While there is an <strong>lsblk</strong> command in FreeBSD ports there are also options within the base system.  There are two relevant subsystems: </p>



<ul>
<li>CAM unifies the interface to low-level SCSI, ATA, NVMe etc devices.  </li>
</ul>



<ul>
<li>GEOM deals with block devices and layering further block level features like RAID and encryption on them. </li>
</ul>



<p>Using the CAM subsystem, we can list disks with the command <strong>camcontrol devlist</strong>.  This requires root permissions, and produces a succinct list of devices and their hardware address. <strong>camcontrol</strong> allows various low-level commands to be sent to disk devices. One simple example is <strong>camcontrol eject</strong> which can be used to eject removable devices such as CDs. </p>



<p>Using the GEOM layer, the command for listing disks would be <strong>geom disk list</strong>.  This outputs a good amount of detail—but unlike the Linux <strong>lsblk</strong> command, FreeBSD’s <strong>lsblk </strong>doesn’t include disk partitions. To list partitions under FreeBSD, use <strong>geom part list</strong> or just <strong>gpart list</strong>.  </p>



<p>Aside from the obsoleted <strong>fdisk</strong> tool, <strong>gpart</strong> is FreeBSD’s primary tool for managing disk partitions.  </p>



<p>A technical curiosity you may notice is that disks appear as character devices on FreeBSD but as block devices on Linux. In ls listings, this is visible as a c rather than a b in the first character on each line: </p>



<pre><code>freebsd% ls -l /dev/ada0 

crw-r-----  1 root  operator  0x67 16 Jul 08:04 /dev/ada0 

linux$ ls -l /dev/sda  

brw-rw---- 1 root disk 8, 0 Feb 27 13:17 /dev/sda</code></pre>



<p>On other Unix systems you may have had to contend with both forms existing and needing to know to use the block device with the <strong>mount</strong> command and the character device with most other commands. The use of a character device ensures unbuffered, <em>raw</em> access rather than implying single byte reads and writes.  </p>



<p>While FreeBSD dropped block device files, Linux added a flag for programs to use when opening the device to select raw access. The upshot is that on either Linux or FreeBSD, you’ll only need to be concerned with one canonical device file when identifying a storage device.  </p>



<p>The canonical device names found directly under /dev can depend on the order in which disks are detected, so are not guaranteed to be stable between reboots under either Linux or FreeBSD. It is wise to use a stable device name in <em>/etc/</em>fstab or when adding disks to a ZFS pool. On Linux, stable device names can be found in /dev/disk/by-id or /dev/disk/by-label. </p>



<p>FreeBSD provides similar stable device names in /dev/gpt for GPT partition labels, as well as /dev/diskid and /dev/gptid for autogenerated IDs, but the autogenerated IDs are disabled by the installer. They can be enabled by adding the following lines to <em>/boot/loader.conf</em>: </p>



<pre><code>kern.geom.label.disk_ident.enable=&#34;1&#34; 

kern.geom.label.gptid.enable=&#34;1&#34;</code></pre>



<p>After a reboot, <em>/dev/diskid</em> and <em>/dev/gptid</em> will be available. </p>



<p>In addition to providing a stable device name, labels allow descriptive information to be attached such as the physical location—so it’s good practice to label your disks. </p>



<p>FreeBSD mirrors the device files under names reflecting labels under <em>/dev/label</em> or <em>/dev/gpt</em> where GPT partitioning is used.  Run <strong>glabel status</strong> to list existing labels. <strong>glabel</strong> also allows labels to be added, for example: </p>



<pre><code>glabel label slot3 /dev/ada2 </code></pre>



<p>For NVMe drives FreeBSD exposes both an <strong>nvd </strong>and <strong>nvme</strong> device file. The <strong>nvd(4)</strong> driver is used with GEOM to expose the disk but some things like the <strong>smartd(8)</strong> disk monitoring daemon needs to use the <strong>nvme(4)</strong> device. </p>



<p>Once you’ve identified your disk, commands like <strong>fsck</strong> and <strong>mount</strong> work much the same between FreeBSD and Linux, although the available filesystems differ. For things like USB sticks, the old DOS FAT filesystem is named msdosfs on FreeBSD rather than vfat. And the equivalent for Linux bind mounts involves a special nullfs filesystem. </p>



<p>Modern FreeBSD installations typically use OpenZFS as the default filesystem, whereas most Linux distributions default to ext4. When OpenZFS isn’t desired or appropriate, FreeBSD offers UFS2 as an effective, simpler filesystem roughly similar in performance, capabilities, and resource consumption to Linux’s ext4. </p>



<h2><strong><strong>Networking</strong></strong></h2>



<p>Most Linux distributions moved away from the traditional Unix tools like <strong>netstat</strong>, <strong>route, arp,</strong> and <strong>ifconfig</strong> for network configuration in favor of the new <strong>ip </strong>command. However, the older tools are still generally available on Linux— perhaps because it is very simple to use <strong>ifconfig</strong> and <strong>route,</strong> and they can be fairly forgiving to variations in exact syntax. </p>



<p>To list available network interfaces under FreeBSD, the most well-known command is <strong>ifconfig -l</strong> but it is useful to be aware of <strong>netstat -i</strong> which provides a more succinct list along with packet statistics. The interfaces have names based on the driver, so <strong>em0</strong> would be the first device created with the <strong>em(4)</strong> driver.  Configuring an interface with an IP address and using it for a static route can be as simple as the following example: </p>



<pre><code>ifconfig em0 10.0.1.2/24 

  route add 10.0.128.0/24 10.0.1.1</code></pre>



<p>To list routes, the command is <strong>netstat -rn</strong>, which may not be as obvious as <strong>ip route show</strong> on Linux. The Linux <strong>ss</strong> command for probing sockets often gets mentioned as being a replacement for <strong>netstat,</strong> but <strong>netstat</strong> is focused on statistics and covers much else besides sockets. For listing open network sockets, FreeBSD’s <strong>sockstat</strong> tool is generally easier to use than <strong>netstat -a</strong>. </p>



<p>FreeBSD configures network devices on boot with stanzas in <em>/etc/rc.conf</em>. This style of configuration is similar to <em>/etc/network/interfaces</em> found in older versions of Debian, or <em>/etc/sysconfig/network-scripts</em> in older Redhat versions. </p>



<p>FreeBSD does not currently offer dynamic, desktop-focused management of network interfaces similar to what the <a href="https://netplan.io/" target="_blank" rel="noreferrer noopener">netplan</a> or NetworkManager systems provide to Linux distributions—but for more typical and largely static network configurations, you won’t miss the added complexity those solutions bring with them. </p>



<h2><strong><strong>User Management</strong></strong></h2>



<p>The basic commands for creating and managing users on FreeBSD are well covered in the FreeBSD handbook [https://docs.freebsd.org/en/books/handbook/basics/#users-synopsis] and don’t differ markedly from what you may have seen on Linux. The recommended commands on Linux can vary between distributions, but typically you’ll find combinations of either <strong>useradd</strong> or <strong>adduser</strong>.  </p>



<p>FreeBSD also offers a <strong>pw</strong> utility which combines all of adding, removing, and modifying both users and groups into a single tool. For user management, a more general configuration management tool such as ansible can be worth considering. Ansible has the advantage of using identical syntax across operating systems. </p>



<p>On Linux systems, it is very common to use <strong>sudo</strong> for operations that require root permissions. FreeBSD traditionally relies on the simpler <strong>su</strong> command instead, and does not include <strong>sudo</strong> by default, although it is available to install as a package. </p>



<p>From a security standpoint, the benefit of <strong>sudo</strong> is that it is more granular, as only individual commands are run privileged.  Needing to prefix specific commands may also protect against typing errors and user-error relative to an interactive root session. However, the fact that the shell lacks privileged access to the filesystem can make <strong>sudo</strong> less convenient, needing tricks such as running <strong>sudo tee</strong> as a workaround for redirection.  </p>



<p> Fundamentally, <strong>sudo</strong> adds significant attack surface because it is a powerful tool with many features like support for security policies defined in LDAP, so the system is likely more secure without it. If you need the additional functionality <strong>sudo</strong> offers, either <strong>sudo</strong> or <strong>doas</strong> (a minimal alternative) may easily be installed from ports or packages. </p>



<p>When setting up a FreeBSD system note that only users that are members of the <strong><em>wheel</em></strong> group are permitted to change to root with <strong>su</strong>. This adds a layer of security, and is similar to the <strong>sudo</strong> and/or <strong>wheel</strong> groups often found on Linux distributions.</p>



<h2><strong><strong><strong>Want More?</strong></strong></strong></h2>



<p>Subscribe to the Klara articles feed to get notified when the next part of our migrating from Linux to FreeBSD series is published. </p>
</div>




</div></div>
  </body>
</html>
