<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.quarkslab.com/defeating-ebpf-uprobe-monitoring.html">Original</a>
    <h1>Defeating eBPF Uprobe Monitoring</h1>
    
    <div id="readability-page-1" class="page"><div>

        <!--/.well -->

        <div>
<section id="content">
<article>
<header>

</header>
<div>
  

  <p>This article introduces a kind of eBPF program that may be used to monitor userspace programs. It first introduces you to eBPF and uprobes and then explores the flaws that we found in uprobes.</p>

  <p>This blog post presents a topic that I tackled during my internship on
eBPF for security. All the examples work with Linux and x86_64
architecture.</p>
<div id="introduction">
<h2>Introduction</h2>
<p>Monitoring what happens on your system is really important. eBPF can
help you to do so on your Linux server by hooking specific programs to
various system-wide events. You can gather a lot of
information by hooking into kernel or userspace functions. For example, you can read the
content of encrypted communication between two processes or find
which process uses a specific function of a library. A good way to
understand eBPF is to keep this diagram in mind:</p>
<p><img alt="diagram explaining ebpf" src="https://blog.quarkslab.com/resources/2022-08-24_eBPF-uprobe/eBPF.png"/></p><p>To create your own eBPF program, choose one of the eBPF libraries, it
will generate an eBPF bytecode and then call the <tt>bpf</tt> syscall to load it
in the kernel. On the kernel side, your program will be verified and
loaded if it is safe. You must also keep in mind that there are different
types of eBPF programs (adapted to the triggering event) and each one has
access to different eBPF helpers and contexts. The current tools using
eBPF for monitoring often involve kprobes (kernel probes). As an example, this kind of program
allows you to record each time a process uses a syscall.
However, not all interesting information can be captured this way. This is why new
research is being conducted on uprobes (userland probes) to monitor in userland.</p>
</div>
<div id="uprobes-the-basics">
<h2>Uprobes: the basics</h2>
<div id="definition">
<h3>Definition</h3>
<p>Uprobes are a kernel feature that allows hooking into any instruction
of any userspace program. When these hooks are triggered, an event is
created and the context of the probed program is provided to the
handlers (for example, an eBPF program). You can then log the CPU
registers&#39; values or execute an eBPF program. For example, the
<a href="https://github.com/quarkslab/peetch">peetch</a> collection of tools, developed
by Quarkslab, uses eBPF with uprobes hooks on <tt>SSL_read()</tt> and <tt>SSL_write()</tt>
OpenSSL functions to log the TLS messages system-wide and access data in plaintext.</p>
</div>
<div id="how-to-create-one">
<h3>How to create one</h3>
<p>You can create a uprobe with the <tt>/sys</tt> pseudo-filesystem by adding a line
to the <tt>/sys/kernel/debug/tracing/uprobe_events</tt> file. The syntax is the
following:</p>
<pre>p[:[GRP/]EVENT] PATH:OFFSET [FETCHARGS] : Set a uprobe
r[:[GRP/]EVENT] PATH:OFFSET [FETCHARGS] : Set a return uprobe (uretprobe)
-:[GRP/]EVENT                           : Clear uprobe or uretprobe event
</pre>
<p>For more details, see the <a href="https://www.kernel.org/doc/Documentation/trace/uprobetracer.txt">kernel
documentation</a>.</p>
</div>
<div id="example">
<h3>Example</h3>
<p>The best way to learn is to practice. Let’s create a uprobe that prints
every command issued on the system.</p>
<p>First, we need to find a place to hook. We have chosen <tt>readline()</tt>
from the <tt>bash</tt> binary. That&#39;s a good choice because our command is
returned at the end of the function. Now, let’s find the offset of
<tt>readline</tt> into <tt>/bin/bash</tt>. A quick way to achieve this is
to use <tt>gdb</tt>:</p>
<div><pre><span></span>gdb /bin/bash
<span>(</span>gdb<span>)</span> p readline
<span>$1</span> <span>=</span> <span>{</span>&lt;text variable, no debug info&gt;<span>}</span> 0xd5690 &lt;readline&gt;
</pre></div>
<p>As given by gdb above, our offset is <tt>0xd5690</tt>. The kernel documentation explains that we
can print the return value in a uretprobe. Uretprobes are just uprobes
placed at the end of the function. Our command must begin with <tt>r:</tt>
for &#34;uretprobe&#34; followed by the name of our probe <tt>bashReadline</tt>, the path of
the binary <tt>/bin/bash</tt>, the offset <tt>0xd5690</tt> and the return value
printed as a string: <tt><span>cmd=+0($retval):string</span></tt>.</p>
<div><pre><span></span><span># First log-in as root.</span>

<span># This line creates a uretprobe named bashReadline at offset 0xd5690 of /bin/bash program that prints the return value as a string.</span>
<span>echo</span> <span>&#39;r:bashReadline /bin/bash:0xd5690 cmd=+0($retval):string&#39;</span> &gt;&gt; /sys/kernel/tracing/uprobe_events

<span># When the uprobe is added, activate it with this command:</span>
<span>echo</span> <span>1</span> &gt; /sys/kernel/tracing/events/uprobes/bashReadline/enable

cat /sys/kernel/tracing/trace_pipe
    bash-24834   <span>[</span><span>010</span><span>]</span> ..... <span>26372</span>.295012: bashReadline: <span>(</span>0x5630d6af8015 &lt;- 0x5630d6b98690<span>)</span> <span>cmd</span><span>=</span><span>&#34;cat trace_pipe &#34;</span>
   &lt;...&gt;-14869   <span>[</span><span>014</span><span>]</span> ..... <span>26393</span>.048772: bashReadline: <span>(</span>0x55f2c8640015 &lt;- 0x55f2c86e0690<span>)</span> <span>cmd</span><span>=</span><span>&#34;ls&#34;</span>
    bash-14869   <span>[</span><span>014</span><span>]</span> ..... <span>26399</span>.267734: bashReadline: <span>(</span>0x55f2c8640015 &lt;- 0x55f2c86e0690<span>)</span> <span>cmd</span><span>=</span><span>&#34;whoami&#34;</span>
   &lt;...&gt;-24909   <span>[</span><span>010</span><span>]</span> ..... <span>26428</span>.810573: bashReadline: <span>(</span>0x5638c7785015 &lt;- 0x5638c7825690<span>)</span> <span>cmd</span><span>=</span><span>&#34;cat /etc/passwd&#34;</span>
</pre></div>
<div id="warning">
<h4>Warning</h4>
<ul>
<li>If you receive the error <em>Device or resource busy</em> while writing to
the <tt>uprobe_events</tt> file, set
<tt>/sys/kernel/tracing/events/uprobes/enabled</tt> to <tt>0</tt> and try again.</li>
<li>If you receive <em>Invalid argument</em>, read the
<tt>/sys/kernel/tracing/error_log</tt> file for details.</li>
<li>Your kernel must have <tt>CONFIG_UPROBES</tt> enabled (on by default if
your Linux kernel is version 3.5 or higher).</li>
</ul>
</div>
</div>
<div id="level-up-with-ebpf">
<h3>Level-up with eBPF</h3>
<p>If you want to do more than printing, and add some logic to your uprobe,
you can use an eBPF program. To simplify, we will use the bcc python
package that does the hard work for us. You just have to create a bpf
object with the constructor, and hook it to the uretprobe with the
<tt>attach_uretprobe()</tt> method. Finally, we write a little eBPF
program that reads the command and the current user id, and prints it if
the user is root.</p>
<div><pre><span></span><span>#!/usr/bin/python3</span>

<span>from</span> <span>bcc</span> <span>import</span> <span>BPF</span>
<span>from</span> <span>time</span> <span>import</span> <span>sleep</span>


<span># load BPF program</span>
<span>bpf_text</span><span>=</span><span>&#34;&#34;&#34;</span>
<span>#include &lt;linux/sched.h&gt;</span>

<span>int printForRoot(struct pt_regs *ctx){</span>

<span>    char command[16] = </span><span>{}</span><span>;</span>

<span>    //use a bpf helper to get the user id.</span>
<span>    uid_t uid = bpf_get_current_uid_gid() &amp; 0xffffffff;</span>

<span>    //another bpf helper to read a string in userland</span>
<span>    bpf_probe_read_user_str(&amp;command, sizeof(command), (void *)PT_REGS_RC(ctx));</span>

<span>    if(uid == 0){</span>
<span>        bpf_trace_printk(&#34;Command from root: </span><span>%s</span><span>&#34;,command);</span>
<span>    }</span>
<span>    return 0;</span>
<span>}</span>
<span>&#34;&#34;&#34;</span>


<span>b</span> <span>=</span> <span>BPF</span><span>(</span><span>text</span><span>=</span><span>bpf_text</span><span>)</span>
<span>b</span><span>.</span><span>attach_uretprobe</span><span>(</span><span>name</span><span>=</span><span>&#34;/bin/bash&#34;</span><span>,</span> <span>sym</span><span>=</span><span>&#34;readline&#34;</span><span>,</span> <span>fn_name</span><span>=</span><span>&#34;printForRoot&#34;</span><span>)</span>

<span>while</span><span>(</span><span>1</span><span>):</span>
    <span>sleep</span><span>(</span><span>1</span><span>)</span>
</pre></div>
<div><pre><span></span>cat /sys/kernel/tracing/trace_pipe
    bash-9442    <span>[</span><span>000</span><span>]</span> d...1  <span>2634</span>.932058: bpf_trace_printk: Command from root: whoami
    bash-9442    <span>[</span><span>000</span><span>]</span> d...1  <span>3575</span>.645538: bpf_trace_printk: Command from root: <span>cd</span> /root/
    bash-9442    <span>[</span><span>000</span><span>]</span> d...1  <span>3584</span>.413448: bpf_trace_printk: Command from root: sl
</pre></div>
<p>Now that you know how to use uprobes, the next section will show you the
kernel side.</p>
</div>
</div>
<div id="how-uprobes-work-under-the-hood">
<h2>How uprobes work under the hood</h2>
<div id="uprobe-creation">
<h3>Uprobe creation</h3>
<p>The kernel implements uprobes as special breakpoints that are used only
by the kernel. Uprobes are made of the program file inode, the
instruction offset, the list of related actions and the replaced
instruction code. When you create a probe, it is added to a specific
binary tree.</p>
<p>When setting up a uprobe, the kernel calls
<a href="https://github.com/torvalds/linux/blob/12c3e0c92fd7cb3d3b698d84fdde7dccb6ba8822/kernel/trace/trace_uprobe.c#L795">probes_write()</a>
and
<a href="https://github.com/torvalds/linux/blob/12c3e0c92fd7cb3d3b698d84fdde7dccb6ba8822/kernel/trace/trace_uprobe.c#L717">trace_uprobe_create()</a>
which calls
<a href="https://github.com/torvalds/linux/blob/12c3e0c92fd7cb3d3b698d84fdde7dccb6ba8822/kernel/trace/trace_uprobe.c#L537">__trace_uprobe_create()</a>.
This last function takes as arguments our line from <tt>uprobe_events</tt>
and calls <tt>kern_path()</tt> which gets the inode of the file corresponding
to our path.</p>
<p>Then later <tt>register_trace_uprobe()</tt>, <tt>_add_event_to_tracers()</tt> and
other functions create the pseudo-directory
<tt><span>/sys/kernel/tracing/events/uprobes/&lt;EVENT&gt;/</span></tt> and some files (<tt>enable</tt>,
<tt>id</tt>, …).</p>
<div><pre><span></span><span>probes_write</span><span>(){</span>
   <span>trace_uprobe_create</span><span>(){</span>
      <span>/*</span>
<span>       * Argument syntax:</span>
<span>       *  - Add uprobe: p|r[:[GRP/]EVENT] PATH:OFFSET[%return][(REF)] [FETCHARGS]</span>
<span>       */</span>
      <span>__trace_uprobe_create</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>const</span> <span>char</span> <span>**</span><span>argv</span><span>);</span>
   <span>}</span>
<span>}</span>
</pre></div>
</div>
<div id="uprobe-activation">
<h3>Uprobe activation</h3>
<p>When we enable the uprobe, the following nested calls are made:
<a href="https://github.com/torvalds/linux/blob/4d66020dcef83314092f2c8c89152a8d122627e2/kernel/trace/trace_uprobe.c#L1438">trace_uprobe_register()</a>
=&gt;
<a href="https://github.com/torvalds/linux/blob/4d66020dcef83314092f2c8c89152a8d122627e2/kernel/trace/trace_uprobe.c#L1088">probe_event_enable()</a>
=&gt;
<a href="https://github.com/torvalds/linux/blob/4d66020dcef83314092f2c8c89152a8d122627e2/kernel/trace/trace_uprobe.c#L1053">trace_uprobe_enable()</a>
=&gt;
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1135">uprobe_register()</a>.</p>
<p>This last function calls two other interesting ones:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L721">alloc_uprobe()</a>
that creates a <a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/events/uprobes.c#L55">struct
uprobe</a>
with the inode, offset and replaced instruction; and calls
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L700">insert_uprobe()</a>
that adds this uprobe to the uprobe rb_tree.</li>
<li><a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1029">register_for_each_vma()</a>
that loops on all existing virtual memory areas and find the ones
that correspond to some uprobe&#39;s inode (and verify
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L121">valid_vma()</a>). On these vma it calls
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L890">install_breakpoint()</a> that copies the full probed instruction in <tt>arch.insn</tt> - a struct
that depends on the current architecture - and then replaces it with a breakpoint.</li>
</ul>
<pre>trace_uprobe_register(){
   probe_event_enable(){
      trace_uprobe_enable(){
         uprobe_register(){
            alloc_uprobe(){
               struct uprobe{
                  inode;
                  offset;
                  insn;
               }
               insert_uprobe();
            }
            register_for_each_vma(){
               if(valid_vma){
                  install_breakpoint();
               }
            }
         }
      }
   }
}
</pre>
</div>
<div id="detection-of-new-program-instances">
<h3>Detection of new program instances</h3>
<p>When an ELF program is executed, its memory is mapped using the mmap
syscall. The function <tt>mmap_region/vma_merge</tt> =&gt;
<a href="https://github.com/torvalds/linux/blob/f56dbdda4322d33d485f3d30f3aabba71de9098c/mm/mmap.c#L746">__vma_adjust()</a>
is called in the kernel to manage this mapping.
<a href="https://github.com/torvalds/linux/blob/f56dbdda4322d33d485f3d30f3aabba71de9098c/mm/mmap.c#L746">__vma_adjust()</a>
is a helper function used when Virtual Memory Areas are added/modified.
It calls
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1356">uprobe_mmap()</a>
for file-backed vma. The code section of our program is linked to its
program file so
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1356">uprobe_mmap()</a>
is called for the vma containing our uprobe.</p>
<p>If
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L121">valid_vma()</a>
is ok, it uses
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1287">build_probe_list()</a>
to find all the uprobes matching this inode in the uprobe rb_tree and
calls
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L890">install_breakpoint()</a>
for each one.</p>
<pre>SYS_mmap(){
   mmap_region/vma_merge(){
      __vma_adjust(){
         uprobe_mmap(){
            if(valid_vma){
               build_probe_list(){
                  for each uprobe:
                     install_breakpoint();
               }
            }
         }
      }
   }
}
</pre>
<p><strong>Remember that uprobes are added to new program
instances during the mmap call!</strong></p>
</div>
<div id="uprobe-event">
<h3>Uprobe event</h3>
<p>When the breakpoint is reached, an int3 exception is triggered.
<a href="https://github.com/torvalds/linux/blob/d6ecaa0024485effd065124fe774de2e22095f2d/arch/x86/kernel/traps.c#L780">do_int3()</a>
calls <a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/notifier.c#L535">notify_die(DIE_INT3,
…)</a>,
then <a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/notifier.c#L211">atomic_notifier_call_chain(&amp;die_chain,
…)</a>
is called. The chain <em>die_chain</em> contains all notifiers previously
registered via
<a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/notifier.c#L552">register_die_notifier()</a>.
<a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/notifier.c#L211">atomic_notifier_call_chain</a>
calls
<a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/notifier.c#L64">notifier_call_chain()</a>
which informs the notifiers registered in the chain about an event via
their notifier_call attribute. For our uprobe it’s
<a href="https://github.com/torvalds/linux/blob/6daa755f813e6aa0bcc97e352666e072b1baac25/arch/x86/kernel/uprobes.c#L999">arch_uprobe_exception_notify()</a>
that was set at
<a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/events/uprobes.c#L2345">uprobe_init()</a>.
It calls
<a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/events/uprobes.c#L2315">uprobe_pre_sstep_notifier()</a>
which set <em>TIF_UPROBE</em> flag. While returning to userspace, the thread
notices the <em>TIF_UPROBE</em> flag and calls <a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/events/uprobes.c#L2298">uprobe_notify_resume(struct
pt_regs *
regs)</a>
which calls
<a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/kernel/events/uprobes.c#L2186">handle_swbp(regs)</a>.</p>
<p>This function does two main things:</p>
<ol>
<li><a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L2067">handler_chain(find_active_uprobe())</a>
which executes the handlers of this uprobe. For example, a
<tt>perf_event</tt> used by an eBPF program.</li>
<li><a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1923">pre_ssout()</a>
which prepares to single-step the probed instruction. This
instruction can’t be executed in program memory because the original
instruction has been replaced by the uprobe breakpoint opcode. Kernel
developers first tried to remove the breakpoint temporarily but there
were some issues, so they chose to execute this instruction out of
line (also called xol) in a new memory area. So, it first calls
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1605">xol_get_insn_slot</a>
to get the xol virtual address, and this function uses
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1524">get_xol_area()</a>
that will setup the <tt>[uprobes]</tt> special virtual memory area if it is
not yet created with
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1436">xol_add_vma()</a>
=&gt; <tt>install_special_mapping()</tt>. This vma is the place where the
original instruction will be executed out of line. To continue with
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L1923">pre_ssout()</a>,
it uses
<a href="https://github.com/torvalds/linux/blob/f56dbdda4322d33d485f3d30f3aabba71de9098c/arch/powerpc/kernel/uprobes.c#L64">arch_uprobe_pre_xol()</a>
that calls <tt>regs_set_return_ip(regs, <span>current-&gt;utask-&gt;xol_vaddr)</span></tt> and
<tt>user_enable_single_step()</tt>. At this point
<tt><span>current-&gt;utask-&gt;xol_vaddr</span></tt> points to the allocated XOL slot
previously created. So this function sets the program counter to
the place where the copy of the original instruction is and activates
the single step mode. Then, this instruction will be executed and the
program will be stopped again.</li>
</ol>
<p><a href="https://github.com/torvalds/linux/blob/6daa755f813e6aa0bcc97e352666e072b1baac25/arch/x86/kernel/uprobes.c#L961">arch_uprobe_post_xol</a>
is called from
<a href="https://github.com/torvalds/linux/blob/cdeffe87f790dfd1baa193020411ce9a538446d7/kernel/events/uprobes.c#L2294">uprobe_notify_resume</a>
when the single-step is over. This function prepares to resume
execution after the single-step and calls the post_xol handler. By
default it is
<a href="https://github.com/torvalds/linux/blob/6daa755f813e6aa0bcc97e352666e072b1baac25/arch/x86/kernel/uprobes.c#L554">default_post_xol_op</a>
(see also <tt>branch_post_xol_op</tt>). The new <tt>RIP</tt> register is relative to the copied
instruction, so it makes it relative to the original instruction (with
some exceptions like return, call, absolute or indirect jump). If
the instruction used <tt>RIP</tt> then it is replaced by
another register. The value of this register is restored and finally the
program execution is resumed.</p>
<div><pre><span></span><span>[...]</span>
<span>uprobe_init</span><span>(){</span>
   <span>register_die_notifier</span><span>(</span><span>arch_uprobe_exception_notify</span><span>);</span>
<span>}</span>
<span>[...]</span><span>//breakpoint is reached</span>
<span>do_int3</span><span>(){</span>
   <span>notify_die</span><span>(</span><span>DIE_INT3</span><span>,</span> <span>...){</span>
      <span>atomic_notifier_call_chain</span><span>(</span><span>&amp;</span><span>die_chain</span><span>,</span> <span>...){</span>
         <span>notifier_call_chain</span><span>(){</span>
            <span>for</span> <span>each</span><span>:</span>
               <span>notifier_call</span> <span>=</span> <span>arch_uprobe_exception_notify</span><span>(){</span>
                  <span>uprobe_pre_sstep_notifier</span><span>(){</span>
                     <span>//set TIF_UPROBE flag</span>
                  <span>}</span>
               <span>}</span>
         <span>}</span>
      <span>}</span>
   <span>}</span>
<span>}</span>
<span>[...]</span>
<span>exit_to_user_mode_prepare</span><span>()</span> <span>{</span>
   <span>exit_to_user_mode_loop</span><span>()</span> <span>{</span>
       <span>uprobe_notify_resume</span><span>(</span><span>struct</span> <span>pt_regs</span> <span>*</span> <span>regs</span><span>){</span>
          <span>handle_swbp</span><span>(</span><span>regs</span><span>){</span>
             <span>handler_chain</span><span>(</span><span>find_active_uprobe</span><span>());</span>
             <span>pre_ssout</span><span>(){</span>
                <span>xol_get_insn_slot</span><span>(){</span>
                    <span>get_xol_area</span><span>(){</span>
                        <span>__create_xol_area</span><span>(){</span>
                            <span>xol_add_vma</span><span>(){</span>
                                <span>install_special_mapping</span><span>();</span>
                            <span>}</span>
                        <span>}</span>
                    <span>}</span>
                <span>}</span>
                <span>arch_uprobe_pre_xol</span><span>(){</span>
                   <span>regs_set_return_ip</span><span>(</span><span>regs</span><span>,</span> <span>current</span><span>-&gt;</span><span>utask</span><span>-&gt;</span><span>xol_vaddr</span><span>);</span>
                <span>}</span>
                <span>user_enable_single_step</span><span>();</span>
             <span>}</span>
          <span>}</span>
       <span>}</span>
    <span>}</span>
<span>}</span>
<span>[...]</span><span>//single_step</span>
<span>uprobe_notify_resume</span><span>(</span><span>struct</span> <span>pt_regs</span> <span>*</span> <span>regs</span><span>){</span>
   <span>arch_uprobe_post_xol</span><span>(){</span>
      <span>post_xol</span> <span>=</span> <span>default_post_xol_op</span><span>();</span>
   <span>}</span>
<span>}</span>
</pre></div>
<p><strong>To sum up, when the breakpoint is reached, the handlers are executed,
and then the original instruction that was replaced by the breakpoint is
executed in a special virtual memory area.</strong></p>
</div>
</div>
<div id="playing-with-uprobes">
<h2>Playing with uprobes</h2>
<p>We have seen that the uprobes/eBPF combo is a very efficient way to
obtain data on all the processes of your system. At Quarkslab for example
we created <a href="https://github.com/quarkslab/peetch">peetch</a> which records all the TLS
connections in plaintext (before the encryption process). But can this
data be trusted from a security perspective or is it just informative ?</p>
<p>In this section we consider that we write a program that will be
monitored/inspected with uprobes. Let’s see what we can do with these
uprobes.</p>
<div id="detecting-uprobes">
<h3>Detecting uprobes</h3>
<p>Uprobes are based on breakpoints, so we can use common anti-debug tricks
to detect them. The quick and dirty way for a monitored program to
detect a breakpoint/uprobe is to read its <tt>.text</tt> memory and search
for the breakpoint opcode.</p>
<p>The code snippet below implements this in C, by reading the first byte
of <tt>tracedFunction</tt> and checking if it corresponds to the breakpoint
opcode (0xcc).</p>
<div><pre><span></span><span>unsigned</span> <span>char</span> <span>*</span> <span>functionBytes</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span> <span>*</span><span>)</span> <span>&amp;</span><span>tracedFunction</span><span>;</span>

<span>if</span> <span>(</span><span>functionBytes</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>0xcc</span><span>){</span>
   <span>printf</span><span>(</span><span>&#34;Detected uprobe breakpoint in beginning of tracedFunction.</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>The problem is that you may have to check every instruction and compare it
with the real one in the binary file to avoid false positives.</p>
<p>Another way is to detect a uprobe after it has been triggered. Using our
knowledge about the kernel inner workings, we know that a special memory
mapping called <tt>[uprobes]</tt> is created to execute the probed
instruction out of line. So our monitored program can read
<tt>/proc/self/maps</tt> and search for such a mapping.</p>
<div><pre><span></span><span>bool</span> <span>detect_uprobes</span><span>(){</span>
   <span>FILE</span> <span>*</span> <span>memfile</span> <span>=</span> <span>fopen</span><span>(</span><span>&#34;/proc/self/maps&#34;</span><span>,</span> <span>&#34;r&#34;</span><span>);</span>

   <span>char</span> <span>line</span><span>[</span><span>200</span><span>];</span>
   <span>while</span><span>(</span><span>fgets</span><span>(</span><span>line</span><span>,</span> <span>200</span><span>,</span> <span>memfile</span><span>)</span> <span>!=</span> <span>NULL</span><span>){</span>

      <span>char</span> <span>*</span> <span>uprobes_str</span> <span>=</span> <span>strstr</span><span>(</span><span>line</span><span>,</span><span>&#34;[uprobes]&#34;</span><span>);</span><span>//search for &#34;[uprobes]&#34; in line</span>
      <span>if</span><span>(</span><span>uprobes_str</span> <span>!=</span> <span>NULL</span><span>){</span>
         <span>return</span> <span>true</span><span>;</span>
      <span>}</span>
   <span>}</span>

   <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</pre></div>
</div>
<div id="escaping-uprobe-monitoring">
<h3>Escaping uprobe monitoring</h3>
<p>From the <a href="#uprobe-activation">Uprobe activation</a> and
<a href="#detection-of-new-program-instances">Detection of new program instances</a> paragraphs
we know that the function <tt>valid_vma()</tt> is always called before adding
the breakpoint. Let’s see the code of this function:</p>
<div><pre><span></span><span>static</span> <span>bool</span> <span>valid_vma</span><span>(</span><span>struct</span> <span>vm_area_struct</span> <span>*</span><span>vma</span><span>,</span> <span>bool</span> <span>is_register</span><span>){</span>
   <span>vm_flags_t</span> <span>flags</span> <span>=</span> <span>VM_HUGETLB</span> <span>|</span> <span>VM_MAYEXEC</span> <span>|</span> <span>VM_MAYSHARE</span><span>;</span>

   <span>if</span> <span>(</span><span>is_register</span><span>)</span>
      <span>flags</span> <span>|=</span> <span>VM_WRITE</span><span>;</span>

   <span>return</span> <span>vma</span><span>-&gt;</span><span>vm_file</span> <span>&amp;&amp;</span> <span>(</span><span>vma</span><span>-&gt;</span><span>vm_flags</span> <span>&amp;</span> <span>flags</span><span>)</span> <span>==</span> <span>VM_MAYEXEC</span><span>;</span>
<span>}</span>
</pre></div>
<p>During the uprobe registering, <tt>is_register</tt> is enabled. Our code is
backed by the program file so <tt><span>vma-&gt;vm_file</span></tt> is <strong>true</strong>, and our code
has the execution flag, so <tt>VM_MAY_EXEC</tt> is also <strong>true</strong>. The
interesting point of this function is that if our code has the
<tt>VM_WRITE</tt> flag, the virtual memory area is not considered to be a
valid vma, so the breakpoint is never added in our code section
(<tt>.text</tt>).</p>
<p>A simple way to do that is to edit the permission of the ELF segment
containing the <tt>.text</tt> section, and Quarkslab provides a nice tool to do
that: <a href="https://lief-project.github.io/">lief</a>.</p>
<div><pre><span></span><span>import</span> <span>lief</span>

<span>prog</span> <span>=</span> <span>&#34;./bin/prog&#34;</span>
<span>binary</span> <span>=</span> <span>lief</span><span>.</span><span>parse</span><span>(</span><span>prog</span><span>)</span>

<span>binary</span><span>.</span><span>segment_from_offset</span><span>(</span><span>binary</span><span>.</span><span>get_section</span><span>(</span><span>&#34;.text&#34;</span><span>)</span><span>.</span><span>offset</span><span>)</span><span>.</span><span>flags</span> <span>=</span> <span>lief</span><span>.</span><span>ELF</span><span>.</span><span>SEGMENT_FLAGS</span><span>(</span><span>7</span><span>)</span>

<span>binary</span><span>.</span><span>write</span><span>(</span><span>prog</span><span>)</span>
</pre></div>
<p>Here is a program that combines all these techniques:</p>
<div><pre><span></span><span>char</span> <span>isRoot</span><span>(</span><span>int</span> <span>uid</span><span>){</span>

    <span>if</span><span>(</span><span>detect_uprobes</span><span>()){</span>
        <span>printf</span><span>(</span><span>&#34;Previous uprobe usage detected.</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>}</span><span>else</span><span>{</span>
        <span>printf</span><span>(</span><span>&#34;No uprobe has been activated.</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>uid</span> <span>==</span> <span>0</span><span>;</span>

<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>*</span> <span>argv</span><span>[]){</span>

    <span>if</span><span>(</span><span>argc</span> <span>==</span> <span>2</span> <span>&amp;&amp;</span> <span>argv</span><span>[</span><span>1</span><span>][</span><span>0</span><span>]</span> <span>==</span> <span>&#39;1&#39;</span><span>){</span>
        <span>unsigned</span> <span>char</span> <span>*</span> <span>funcBytes</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span> <span>*</span><span>)</span> <span>&amp;</span><span>isRoot</span><span>;</span>

        <span>if</span> <span>(</span><span>funcBytes</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>0xcc</span><span>)</span> <span>{</span>
            <span>int</span> <span>pagesize</span> <span>=</span> <span>sysconf</span><span>(</span><span>_SC_PAGE_SIZE</span><span>);</span>
            <span>char</span> <span>*</span> <span>debut_page</span> <span>=</span> <span>((</span><span>char</span> <span>*</span><span>)</span> <span>&amp;</span><span>isRoot</span><span>)</span> <span>-</span> <span>((</span><span>long</span><span>)</span><span>&amp;</span><span>isRoot</span> <span>%</span> <span>pagesize</span><span>);</span><span>//find page aligned address</span>
            <span>mprotect</span><span>(</span><span>debut_page</span><span>,</span> <span>pagesize</span><span>,</span> <span>PROT_WRITE</span> <span>|</span> <span>PROT_READ</span> <span>|</span> <span>PROT_EXEC</span><span>);</span>
            <span>printf</span><span>(</span><span>&#34;Detected uprobe breakpoint at the beginning of tracedFunction.</span><span>\n</span><span>&#34;</span><span>);</span>
            <span>funcBytes</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0xf3</span><span>;</span>
        <span>}</span>
    <span>}</span><span>else</span> <span>if</span><span>(</span><span>argc</span> <span>!=</span> <span>2</span> <span>||</span> <span>argv</span><span>[</span><span>1</span><span>][</span><span>0</span><span>]</span> <span>!=</span> <span>&#39;0&#39;</span><span>){</span>
        <span>printf</span><span>(</span><span>&#34;Usage:</span><span>\n\t</span><span>%s 0 : to disable anti-uprobe</span><span>\n\t</span><span>%s 1 : to enable anti-uprobe</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>0</span><span>],</span> <span>argv</span><span>[</span><span>0</span><span>]);</span>
        <span>exit</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>

    <span>//PoC function</span>
    <span>isRoot</span><span>(</span><span>getuid</span><span>());</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</pre></div>
<p>This program has two modes:
(0) without any detection (i.e. regular execution), and
(1) with the detection of breakpoints (and
patching) on <tt>isRoot</tt>. In both cases, it uses the 2nd detection technique to find
if any uprobe was activated.</p>
<p>Let’s give it a try:</p>
<div><pre><span></span>-------------------------------------------------------     <span># We begin without uprobe</span>
user@pc:~/ebpf-for-security/uprobe$ ./bin/prog
Usage:
    ./bin/prog <span>0</span> : to disable anti-uprobe
    ./bin/prog <span>1</span> : to <span>enable</span> anti-uprobe

user@pc:~/ebpf-for-security/uprobe$ ./bin/prog <span>0</span>
No uprobe has been activated.
Print from testFunction

user@pc:~/ebpf-for-security/uprobe$ gdb ./bin/prog -q       <span># We find isRoot function offset</span>
Reading symbols from ./bin/prog...
<span>(</span>gdb<span>)</span> p isRoot
<span>$1</span> <span>=</span> <span>{</span>void <span>()}</span> 0x1320 &lt;isRoot&gt;

-------------------------------------------------------     <span># Now we activate the uprobe</span>
root@pc:~# <span>echo</span> <span>&#39;p:isRootFunction /home/cglenaz/Documents/eBPF/gitlab/ebpf-for-security/uprobe/bin/prog:0x1320 uid=%di:u32&#39;</span> &gt; /sys/kernel/tracing/uprobe_events
-------------------------------------------------------
user@pc:~/ebpf-for-security/uprobe$ ./bin/prog <span>0</span>
Previous uprobe usage detected.                             <span># our uprobe is detected!</span>
-------------------------------------------------------     <span># Let&#39;s read the uprobe output:</span>
cat /sys/kernel/tracing/trace_pipe
prog-19936   <span>[</span><span>013</span><span>]</span> ..... <span>19399</span>.726502: isRootFunction: <span>(</span>0x55ff8a5b8320<span>)</span> <span>uid</span><span>=</span><span>1000</span>   <span># The uprobe has intercepted the uid</span>
-------------------------------------------------------
user@pc:~/ebpf-for-security/uprobe$ ./bin/prog <span>1</span>            <span># we test the first detection and mitigation strategy</span>
Detected uprobe breakpoint in beginning of testFunction.
No uprobe has been activated.                               <span># it works</span>
-------------------------------------------------------     <span># Let&#39;s see if something is printed:</span>
cat /sys/kernel/tracing/trace_pipe
                                                            <span># nothing is printed in trace_pipe because the uprobe is not activated</span>
-------------------------------------------------------
user@pc:~/ebpf-for-security/uprobe$ python3 permission.py   <span># now we patch the binary with lief</span>
user@pc:~/ebpf-for-security/uprobe$ ./bin/prog <span>0</span>
No uprobe has been activated.                               <span># no more uprobe on this program</span>
-------------------------------------------------------
cat /sys/kernel/tracing/trace_pipe
                                                            <span># nothing again in trace_pipe</span>
-------------------------------------------------------
</pre></div>
<p>It works very well on our program&#39;s <tt>isRoot</tt> function but this trick
doesn’t work for shared libraries. Plus, you must be root to edit
privileged ELF libraries such as the libc one, so you have
to modify the permission when they are already loaded in program
memory before using them (or you could also write a custom ELF loader
that adds write permission to every library). Your program can once-again read
<tt>/proc/self/maps</tt> to find all executable vma from libraries.</p>
<p>Example:</p>
<pre>55cc466af000-55cc466b1000 r--p 00000000 fd:01 22282389                   /usr/bin/cat
55cc466b1000-55cc466b5000 r-xp 00002000 fd:01 22282389                   /usr/bin/cat
55cc466b5000-55cc466b7000 r--p 00006000 fd:01 22282389                   /usr/bin/cat
55cc466b7000-55cc466b8000 r--p 00007000 fd:01 22282389                   /usr/bin/cat
55cc466b8000-55cc466b9000 rw-p 00008000 fd:01 22282389                   /usr/bin/cat
55cc4807f000-55cc480a0000 rw-p 00000000 00:00 0                          [heap]
7f32c7ce9000-7f32c7d0b000 rw-p 00000000 00:00 0
7f32c7d0b000-7f32c8af2000 r--p 00000000 fd:01 22287657                   /usr/lib/locale/locale-archive
7f32c8af2000-7f32c8af5000 rw-p 00000000 00:00 0
7f32c8af5000-7f32c8b1d000 r--p 00000000 fd:01 22288450                   /usr/lib/x86_64-linux-gnu/libc.so.6
7f32c8b1d000-7f32c8cb2000 r-xp 00028000 fd:01 22288450                   /usr/lib/x86_64-linux-gnu/libc.so.6
7f32c8cb2000-7f32c8d0a000 r--p 001bd000 fd:01 22288450                   /usr/lib/x86_64-linux-gnu/libc.so.6
7f32c8d0a000-7f32c8d0e000 r--p 00214000 fd:01 22288450                   /usr/lib/x86_64-linux-gnu/libc.so.6
7f32c8d0e000-7f32c8d10000 rw-p 00218000 fd:01 22288450                   /usr/lib/x86_64-linux-gnu/libc.so.6
7f32c8d10000-7f32c8d1d000 rw-p 00000000 00:00 0
7f32c8d30000-7f32c8d32000 rw-p 00000000 00:00 0
7f32c8d32000-7f32c8d34000 r--p 00000000 fd:01 22288113                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f32c8d34000-7f32c8d5e000 r-xp 00002000 fd:01 22288113                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f32c8d5e000-7f32c8d69000 r--p 0002c000 fd:01 22288113                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f32c8d6a000-7f32c8d6c000 r--p 00037000 fd:01 22288113                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f32c8d6c000-7f32c8d6e000 rw-p 00039000 fd:01 22288113                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffd18ebb000-7ffd18edc000 rw-p 00000000 00:00 0                          [stack]
7ffd18ee6000-7ffd18eea000 r--p 00000000 00:00 0                          [vvar]
7ffd18eea000-7ffd18eec000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
</pre>
<p>The virtual memory areas of interest:</p>
<pre>7f32c8b1d000-7f32c8cb2000 r-xp 00028000 fd:01 22288450                   /usr/lib/x86_64-linux-gnu/libc.so.6
7f32c8d34000-7f32c8d5e000 r-xp 00002000 fd:01 22288113                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</pre>
<p>Then for each vma you must unmap the vma with the <tt>munmap</tt> system call to
remove uprobes and remap the exact same vma with the write permission
using the <tt>mmap</tt> system call. There is just one caveat: you can’t use the
<tt>mmap</tt> function from the libc when the libc is unmapped. That’s why
you have to hardcode the syscall assembly instruction directly in your
program.</p>
<div><pre><span></span><span>extern</span> <span>long</span> <span>int</span> <span>syscall</span> <span>(</span><span>long</span> <span>int</span> <span>__sysno</span><span>,</span> <span>...){</span>

    <span>asm</span><span>(</span><span>&#34;mov    %rdi,%rax&#34;</span><span>);</span>
    <span>asm</span><span>(</span><span>&#34;mov    %rsi,%rdi&#34;</span><span>);</span>
    <span>asm</span><span>(</span><span>&#34;mov    %rdx,%rsi&#34;</span><span>);</span>
    <span>asm</span><span>(</span><span>&#34;mov    %rcx,%rdx&#34;</span><span>);</span>
    <span>asm</span><span>(</span><span>&#34;mov    %r8,%r10&#34;</span><span>);</span>
    <span>asm</span><span>(</span><span>&#34;mov    %r9,%r8&#34;</span><span>);</span>
    <span>asm</span><span>(</span><span>&#34;mov    0x10(%rbp),%r9&#34;</span><span>);</span>
    <span>asm</span><span>(</span><span>&#34;syscall&#34;</span><span>);</span>
<span>}</span>

<span>void</span> <span>remove_lib_uprobes</span><span>(){</span>

   <span>FILE</span> <span>*</span> <span>memfile</span> <span>=</span> <span>fopen</span><span>(</span><span>&#34;/proc/self/maps&#34;</span><span>,</span> <span>&#34;r&#34;</span><span>);</span>

   <span>char</span> <span>line</span><span>[</span><span>200</span><span>];</span>
   <span>while</span><span>(</span><span>fgets</span><span>(</span><span>line</span><span>,</span> <span>200</span><span>,</span> <span>memfile</span><span>)</span> <span>!=</span> <span>NULL</span><span>){</span>

      <span>char</span> <span>*</span> <span>lib_str</span> <span>=</span> <span>strstr</span><span>(</span><span>line</span><span>,</span><span>&#34;.so&#34;</span><span>);</span><span>//find all libraries</span>
      <span>char</span> <span>*</span> <span>r_xp</span> <span>=</span> <span>strstr</span><span>(</span><span>line</span><span>,</span><span>&#34;r-xp&#34;</span><span>);</span><span>// only their code sections</span>

      <span>if</span><span>(</span><span>lib_str</span> <span>!=</span> <span>NULL</span> <span>&amp;&amp;</span> <span>r_xp</span> <span>!=</span> <span>NULL</span><span>){</span>

         <span>//read the start and end address. And the file offset.</span>
         <span>char</span> <span>*</span> <span>dash</span> <span>=</span> <span>strchr</span><span>(</span><span>line</span><span>,</span> <span>&#39;-&#39;</span><span>);</span>
         <span>dash</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
         <span>char</span> <span>*</span> <span>space</span> <span>=</span> <span>strchr</span><span>(</span><span>dash</span> <span>+</span> <span>1</span><span>,</span> <span>&#39; &#39;</span><span>);</span>
         <span>space</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
         <span>char</span> <span>*</span> <span>space2</span> <span>=</span> <span>strchr</span><span>(</span><span>space</span> <span>+</span> <span>1</span><span>,</span> <span>&#39; &#39;</span><span>);</span>
         <span>space2</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
         <span>char</span> <span>*</span> <span>space3</span> <span>=</span> <span>strchr</span><span>(</span><span>space2</span> <span>+</span> <span>1</span><span>,</span> <span>&#39; &#39;</span><span>);</span>
         <span>space3</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>

         <span>unsigned</span> <span>long</span> <span>addr1</span> <span>=</span> <span>strtol</span><span>(</span><span>line</span><span>,</span> <span>NULL</span><span>,</span> <span>16</span><span>);</span>
         <span>unsigned</span> <span>long</span> <span>addr2</span> <span>=</span> <span>strtol</span><span>(</span><span>dash</span> <span>+</span> <span>1</span><span>,</span> <span>NULL</span><span>,</span> <span>16</span><span>);</span>
         <span>unsigned</span> <span>long</span> <span>offset</span> <span>=</span> <span>strtol</span><span>(</span><span>space2</span> <span>+</span> <span>1</span><span>,</span> <span>NULL</span><span>,</span> <span>16</span><span>);</span>
         <span>unsigned</span> <span>long</span> <span>delta</span> <span>=</span> <span>addr2</span><span>-</span><span>addr1</span><span>;</span>

         <span>//now read the library file name</span>

         <span>// Locate the last occurrence of space in line (the one before the lib name)</span>
         <span>char</span> <span>*</span> <span>name_lib</span> <span>=</span> <span>strrchr</span><span>(</span><span>space3</span> <span>+</span> <span>1</span><span>,</span> <span>&#39; &#39;</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
         <span>name_lib</span><span>[</span><span>strlen</span><span>(</span><span>name_lib</span><span>)</span><span>-</span><span>1</span><span>]</span> <span>=</span> <span>0</span><span>;</span> <span>//replace the \n by &#39;\0&#39;</span>
         <span>long</span> <span>int</span> <span>fd</span> <span>=</span> <span>open</span><span>(</span><span>name_lib</span><span>,</span>  <span>O_RDONLY</span><span>);</span>

         <span>syscall</span><span>(</span><span>SYS_munmap</span><span>,(</span><span>void</span> <span>*</span><span>)</span> <span>addr1</span><span>,</span> <span>delta</span><span>);</span>
         <span>syscall</span><span>(</span><span>SYS_mmap</span><span>,(</span><span>void</span> <span>*</span><span>)</span> <span>addr1</span><span>,</span> <span>delta</span><span>,</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span> <span>PROT_EXEC</span> <span>|</span> <span>PROT_READ</span> <span>|</span> <span>PROT_WRITE</span><span>,</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span> <span>MAP_PRIVATE</span><span>,</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span> <span>fd</span><span>,</span> <span>(</span><span>void</span> <span>*</span><span>)</span> <span>offset</span><span>);</span>

      <span>}</span>
   <span>}</span>
<span>}</span>
</pre></div>
</div>
<div id="providing-fake-information">
<h3>Providing fake information</h3>
<p>Now that we can detect and disable uprobes, we could try to send fake
context information to an eBPF program hooked on a uprobe. Let’s try to
fake the output of <tt>sudo peetch tls <span>--content</span></tt>. Our program will send
a GET request to the “evil” file but peetch will monitor a request to the
“test” file. How is this even possible? We will use a race-condition
between the moment where the uprobe breakpoint is triggered and when the
message is actually encrypted. The first strategy is to create another
thread and hope it will change the filename at the right moment; but
this method only works 50% of the time, we can do better. In fact, we have
control over our program execution so we can just fork our program into
two processes:</p>
<ul>
<li>a child that calls <tt>SSL_write</tt> with the fake filename and in which
we put a breakpoint just before this call.</li>
<li>a parent that attaches to the child with <tt>PTRACE_SEIZE</tt> and executes
the CHILD one instruction at a time using <tt>PTRACE_SINGLESTEP</tt>.
Starting from the breakpoint we must step the instructions that set
the ptrace arguments in registers and the ones that prepare the jump
to the library. In our case they consist of exactly 9 instructions
between the breakpoint and the second instruction of ptrace. Then
when the child is at the second instruction of <tt>SSL_write</tt>, the uprobe
is already executed so we can now change the message buffer from
<tt>SSL_write</tt> to the real filename. We copy the registers using
<tt>PTRACE_GETREGS</tt>, modify the <tt>rsi</tt> value (<tt>rsi</tt> is used for
the second argument), and call <tt>PTRACE_SETREGS</tt>. Finally we can
resume the child execution with <tt>PTRACE_CONT</tt>.</li>
</ul>
<p>Note that this second method requires a higher privilege than the first one
because it uses the ptrace syscall.</p>
<div><pre><span></span><span>void</span> <span>SSL_write_race_condition</span><span>(</span><span>SSL</span><span>*</span> <span>ssl</span><span>,</span> <span>char</span> <span>*</span> <span>realName</span><span>,</span> <span>char</span> <span>*</span> <span>fakeName</span><span>){</span>

   <span>char</span> <span>format</span><span>[]</span> <span>=</span> <span>&#34;GET /%s HTTP/1.0</span><span>\r\n\r\n</span><span>&#34;</span><span>;</span>

   <span>int</span> <span>fakeMsgLen</span> <span>=</span> <span>strlen</span><span>(</span><span>format</span><span>)</span> <span>+</span> <span>strlen</span><span>(</span><span>fakeName</span><span>);</span>

   <span>char</span> <span>realMsg</span><span>[</span><span>fakeMsgLen</span><span>];</span>
   <span>char</span> <span>fakeMsg</span><span>[</span><span>fakeMsgLen</span><span>];</span>
   <span>sprintf</span><span>(</span><span>fakeMsg</span><span>,</span> <span>format</span><span>,</span> <span>fakeName</span><span>);</span>
   <span>sprintf</span><span>(</span><span>realMsg</span><span>,</span> <span>format</span><span>,</span> <span>realName</span><span>);</span>

   <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>Message before the uprobe: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>fakeMsg</span><span>);</span>

   <span>pid_t</span> <span>pid_fils</span> <span>=</span> <span>fork</span><span>();</span>

   <span>if</span><span>(</span><span>pid_fils</span> <span>!=</span> <span>0</span><span>){</span>

      <span>ptrace</span><span>(</span><span>PTRACE_SEIZE</span><span>,</span> <span>pid_fils</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>);</span>
      <span>printf</span><span>(</span><span>&#34;Attached</span><span>\n</span><span>&#34;</span><span>);</span>
      <span>wait</span><span>(</span><span>NULL</span><span>);</span>

      <span>struct</span> <span>user_regs_struct</span> <span>luser</span><span>;</span>
      <span>for</span><span>(</span><span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span><span>&lt;</span><span>9</span><span>;</span> <span>i</span><span>++</span><span>){</span><span>//9 instructions between int3 and the first instruction of SSL_write</span>

         <span>ptrace</span><span>(</span><span>PTRACE_SINGLESTEP</span><span>,</span> <span>pid_fils</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>);</span><span>//step one instruction</span>
         <span>wait</span><span>(</span><span>NULL</span><span>);</span><span>//wait for the step to be done</span>
      <span>}</span>

      <span>ptrace</span><span>(</span><span>PTRACE_GETREGS</span><span>,</span> <span>pid_fils</span><span>,</span> <span>NULL</span><span>,</span> <span>&amp;</span><span>luser</span><span>);</span>
      <span>luser</span><span>.</span><span>rsi</span> <span>=</span> <span>(</span><span>long</span> <span>long</span> <span>unsigned</span> <span>int</span><span>)</span> <span>realMsg</span><span>;</span><span>//change the SSL_write second argument to our real message</span>
      <span>printf</span><span>(</span><span>&#34;Set rsi to realMsg...</span><span>\n</span><span>&#34;</span><span>);</span>

      <span>ptrace</span><span>(</span><span>PTRACE_SETREGS</span><span>,</span> <span>pid_fils</span><span>,</span> <span>NULL</span><span>,</span> <span>&amp;</span><span>luser</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>);</span>
      <span>ptrace</span><span>(</span><span>PTRACE_CONT</span><span>,</span> <span>pid_fils</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>);</span><span>//continue the SSL_write</span>
      <span>printf</span><span>(</span><span>&#34;Continue execution of SSL_write</span><span>\n</span><span>&#34;</span><span>);</span>
      <span>exit</span><span>(</span><span>1</span><span>);</span>

   <span>}</span><span>else</span><span>{</span>
      <span>ptrace</span><span>(</span><span>PTRACE_TRACEME</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>);</span><span>//wait for the parent to trace this child</span>
      <span>__asm__</span><span>(</span><span>&#34;int3&#34;</span><span>);</span><span>//the breakpoint to stop the child just before SSL_write</span>
      <span>SSL_write</span><span>(</span><span>ssl</span><span>,</span> <span>fakeMsg</span><span>,</span> <span>fakeMsgLen</span><span>);</span> <span>// encrypt and send message</span>
   <span>}</span>
<span>}</span>
</pre></div>
<p>Now, we have to create a test HTTPS server:</p>
<div><pre><span></span><span>from</span> <span>http.server</span> <span>import</span> <span>HTTPServer</span><span>,</span> <span>BaseHTTPRequestHandler</span>
<span>import</span> <span>ssl</span>
<span>from</span> <span>io</span> <span>import</span> <span>BytesIO</span>



<span>class</span> <span>SimpleHTTPRequestHandler</span><span>(</span><span>BaseHTTPRequestHandler</span><span>):</span>

    <span>def</span> <span>do_GET</span><span>(</span><span>self</span><span>):</span>

        <span>if</span> <span>self</span><span>.</span><span>path</span> <span>==</span> <span>&#34;/test&#34;</span><span>:</span>
            <span>self</span><span>.</span><span>send_response</span><span>(</span><span>200</span><span>)</span>
            <span>self</span><span>.</span><span>send_header</span><span>(</span><span>&#39;Content-Type&#39;</span><span>,</span> <span>&#39;text/html&#39;</span><span>)</span>
            <span>self</span><span>.</span><span>send_header</span><span>(</span><span>&#39;Content-Length&#39;</span><span>,</span> <span>str</span><span>(</span><span>len</span><span>(</span><span>b</span><span>&#39;&lt;html&gt;Hello, world!&lt;/html&gt;</span><span>\r\n\r\n</span><span>&#39;</span><span>)))</span>
            <span>self</span><span>.</span><span>end_headers</span><span>()</span>
            <span>self</span><span>.</span><span>wfile</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#34;&lt;html&gt;Hello, world!&lt;/html&gt;</span><span>\r\n\r\n</span><span>&#34;</span><span>)</span>

        <span>elif</span> <span>self</span><span>.</span><span>path</span> <span>==</span> <span>&#34;/evil&#34;</span><span>:</span>
            <span>self</span><span>.</span><span>send_response</span><span>(</span><span>200</span><span>)</span>
            <span>self</span><span>.</span><span>send_header</span><span>(</span><span>&#39;Content-Type&#39;</span><span>,</span> <span>&#39;text/html&#39;</span><span>)</span>
            <span>self</span><span>.</span><span>send_header</span><span>(</span><span>&#39;Content-Length&#39;</span><span>,</span> <span>str</span><span>(</span><span>len</span><span>(</span><span>b</span><span>&#39;&lt;html&gt;Hello, evil man!&lt;/html&gt;</span><span>\r\n\r\n</span><span>&#39;</span><span>)))</span>
            <span>self</span><span>.</span><span>end_headers</span><span>()</span>
            <span>self</span><span>.</span><span>wfile</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#39;&lt;html&gt;Hello, evil man!&lt;/html&gt;</span><span>\r\n\r\n</span><span>&#39;</span><span>)</span>

        <span>return</span> <span>True</span>



<span>httpd</span> <span>=</span> <span>HTTPServer</span><span>((</span><span>&#39;localhost&#39;</span><span>,</span> <span>4443</span><span>),</span> <span>SimpleHTTPRequestHandler</span><span>)</span>

<span>#first create key : openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365</span>
<span>#(example key pass = pass)</span>

<span>httpd</span><span>.</span><span>socket</span> <span>=</span> <span>ssl</span><span>.</span><span>wrap_socket</span> <span>(</span><span>httpd</span><span>.</span><span>socket</span><span>,</span>
    <span>keyfile</span><span>=</span><span>&#34;./key.pem&#34;</span><span>,</span>
    <span>certfile</span><span>=</span><span>&#39;./cert.pem&#39;</span><span>,</span> <span>server_side</span><span>=</span><span>True</span><span>)</span>

<span>httpd</span><span>.</span><span>serve_forever</span><span>()</span>
</pre></div>
<p>This python server responds “Hello, evil man!” if we request the <em>/evil</em>
endpoint, and “Hello, world!” for the <em>/test</em> endpoint.</p>
<p>Then we start peetch and launch our attack.</p>
<p>Let’s see the result:</p>
<pre>Message before the uprobe: GET /test HTTP/1.0

Attached
rip=0x5613718b8deb
Single-step
rip=0x5613718b8df1
Single-step
rip=0x5613718b8df8
Single-step
rip=0x5613718b8dff
Single-step
rip=0x5613718b8e02
Single-step
rip=0x5613718b8e05
Single-step
rip=0x5613718b8510
Single-step
rip=0x5613718b8514
Single-step
rip=0x7f3fe29ba240
Single-step
Set rsi to realMsg...

Continue execution of SSL_write
[+] Server data received :
HTTP/1.0 200 OK
Server: BaseHTTP/0.6 Python/3.10.4
Date: Wed, 06 Jul 2022 09:25:21 GMT
Content-Type: text/html
Content-Length: 29

&lt;html&gt;Hello, evil man!&lt;/html&gt;
</pre>
<p>It works well, the filename was replaced before the message is sent, so
we receive the “Hello, evil man!” message. Let’s check if peetch is
aware of our evilness:</p>
<pre>&lt;- client (12918) 127.0.0.1/4443 TLS1.3 None

   0000  47 45 54 20 2F 74 65 73 74 20 48 54 54 50 2F 31  GET /test HTTP/1
   0010  2E 30 0D 0A 0D 0A 00 00                          .0......

-&gt; client (12918) 127.0.0.1/4443 TLS1.3 None

   0000  48 54 54 50 2F 31 2E 30 20 32 30 30 20 4F 4B 0D  HTTP/1.0 200 OK.
   0010  0A 53 65 72 76 65 72 3A 20 42 61 73 65 48 54 54  .Server: BaseHTT
   0020  50 2F 30 2E 36 20 50 79 74 68 6F 6E 2F 33 2E 31  P/0.6 Python/3.1
   0030  30 2E 34 0D 0A 44 61 74 65 3A 20 57 65 64 2C 20  0.4..Date: Wed,
</pre>
<p>The attack is successful, peetch has monitored the fake message!</p>
<p>Our attack now works every time a message is sent and it can easily be
adapted to different situations. Therefore, we can use this
attack to provide fake information to any uprobe detected with the previous
methods.</p>
<p>Looking from the other side, this attack is easy to detect. You can use
kprobes to trace any <tt>PTRACE_SETREGS</tt> and watch if the <tt>rip</tt>
register is in the function that contains your uprobe. However, the
attack can also be done using threads (with less accuracy) and would
be more difficult to detect. But anyway, what would be the point of
working on it if an attacker can use our previous tricks and easily
disable any uprobe?</p>
</div>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>We found that a program can do whatever we want to fool uprobes on its
own code and libraries, thus eBPF programs based on uprobes are not a
reliable way to monitor <em>untrusted</em> programs, they are however a powerful
tool to gather information. If you want to monitor a program to detect
malicious behavior, kprobes are more suitable for this purpose. They
offer basically the same features as uprobes but on the kernel side.
The race-condition can <a href="https://media.defcon.org/DEF%20CON%2029/DEF%20CON%2029%20presentations/Rex%20Guo%20Junyuan%20Zeng%20-%20Phantom%20Attack%20-%20%20Evading%20System%20Call%20Monitoring.pdf">still be an issue with them</a> so it is better to hook kprobes at secure points like those defined in LSM (Linux Security Modules).</p>
</div>

</div><!-- /.entry-content -->

                </article>
                </section>
        </div><!--/span-->

      </div></div>
  </body>
</html>
