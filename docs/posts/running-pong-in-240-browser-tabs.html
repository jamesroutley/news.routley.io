<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eieio.games/blog/running-pong-in-240-browser-tabs">Original</a>
    <h1>Running Pong in 240 Browser Tabs</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>What do you do with your unclosed browser tabs? I find that they take up a lot of screen space. So this week I figured out how to run pong inside mine.</p>
<div><video controls="" playsinline="" poster="/images/running-pong-in-240-browser-tabs/gameplay-firstframe.png" width="2032" height="1142" preload="metadata" alt="A chrome window plays pong. There are 8 chrome windows stacked on top of each other with the tab bars very close to each other. Each tab bar has 30 tabs. The pong balls and paddles move from a canvas in the foregrounded chrome window to the tab bar above. The ball and paddles continue to move."><p>Loading...</p></video><p>putting that space to good use</p></div>
<p>That‚Äôs 240 browser tabs in a tight 8x30 grid. And they‚Äôre running pong! The ball and paddles are able to cleanly move between the canvas in the foregrounded window and all of the tabs above.</p>
<p>You can see the (awful) code <a href="https://github.com/nolenroyalty/faviconic">here</a>. But how does this work?</p>
<!-- -->
<h2 id="toc:inspiration">Inspiration</h2>
<p>This project was inspired by my friend Tru, who made a <a href="https://mewtru.com/flappyfavi">version of Flappy Bird that runs in a favicon</a> <a>1</a> (Flappy Favi) last week.</p>
<div data-is-footnote="true"><div><div><div><p><span>1</span></p><p>A favicon is the little image that a browser shows you in the tab bar when you
visit a website.</p></div></div></div></div>
<p>FlappyFavi is great, but it‚Äôs a little hard to see what‚Äôs going on because favicons are so small. I figured I could fix that.</p>

<p>My best idea for how to fix this was by drawing an image across multiple tabs. And that gave me a few problems:</p>
<ul>
<li>How do I create a nice grid of tabs to draw on?</li>
<li>How do I update those tabs, even when they‚Äôre backgrounded?</li>
<li>How do the tabs coordinate?</li>
</ul>
<h2 id="toc:prototyping">Prototyping</h2>
<p>My first problem was figuring out how to make a grid of tabs. I started by opening up a chrome window and mashing the ‚Äúnew tab‚Äù button until the tabs were really small. That gave me something that looked like this:</p>
<div><p><img alt="A tiny row of tabs. The favicons form a grid." loading="lazy" width="526" height="78" decoding="async" data-nimg="1" src="https://newslttrs.com/images/running-pong-in-240-browser-tabs/tabbar-single.png"/></p><p>nice and small</p></div>
<p>That seemed promising! We‚Äôve got a nice grid. And if I opened a second window and positioned it just right I could add a second row.</p>
<p>But I wanted a <em>big</em> grid. Doing this by hand would be a pain. So I turned to one of my favorite tools: AppleScript.</p>
<p>AppleScript is a <a href="https://eieio.games/blog/flappy-bird-in-macos-finder/#toc:vsync-at-home-applescript-and-double-buffering">powerful and bizarre</a> way to control programs on Mac; you <em>almost</em> write English, but it‚Äôs verbose and strict enough that mostly you end up writing Python with a lot of extra words.</p>
<p>But it was a great fit here. I wrote a script that opened up 8 chrome windows with 30 tabs each, carefully positioning each chrome window to stack on top of each other.</p>
<div><video controls="" playsinline="" poster="/images/running-pong-in-240-browser-tabs/many-window-open-firstframe.png" width="1672" height="942" preload="metadata" alt="a series of chrome windows opening. Each window quickly opens, is repositioned, and then opens 30 tabs. The windows are nicely stacked."><p>Loading...</p></video><p>I think it&#39;s pretty fun to watch this at work!</p></div>
<p>There were a couple of annoying problems here - for example, chrome tries to re-open your closed tabs, so the script needs to clear those out at the start.</p>
<p>But the code ends up being relatively simple. The core looks like this:</p>
<pre><code><span>
</span><span><span>set</span> bounds <span>of</span> newWindow <span>to</span> <span>{</span>x<span>,</span> y<span>,</span> x <span>+</span> width<span>,</span> y <span>+</span> height<span>}</span>
</span><span><span>global</span> tabCount
</span><span><span>set</span> tabCount <span>to</span> <span>0</span>
</span><span>
</span><span><span>tell</span> newWindow
</span><span>  <span>set</span> URL <span>of</span> active tab <span>to</span> baseURL <span>&amp;</span> <span>&#34;windowIndex=&#34;</span> <span>&amp;</span> windowNum <span>&amp;</span> <span>&#34;&amp;tabIndex=&#34;</span> <span>&amp;</span> tabCount
</span><span><span>end</span> <span>tell</span>
</span><span>
</span><span><span>set</span> tabCount <span>to</span> <span>(</span>tabCount <span>+</span> <span>1</span><span>)</span>
</span><span>
</span><span>
</span><span><span>repeat</span> <span>(</span>numTabs <span>-</span> <span>1</span><span>)</span> <span>times</span>
</span><span>  <span>tell</span> newWindow
</span><span>    <span>if</span> windowNum <span>is</span> <span>(</span>maxWindows <span>-</span> <span>1</span><span>)</span> <span>and</span> tabCount <span>is</span> <span>(</span>numTabs <span>-</span> <span>1</span><span>)</span> <span>then</span>
</span><span>      make new tab <span>with</span> properties <span>{</span>URL<span>:</span>baseUrl <span>&amp;</span> <span>&#34;windowIndex=&#34;</span> <span>&amp;</span> windowNum <span>&amp;</span> <span>&#34;&amp;tabIndex=&#34;</span> <span>&amp;</span> tabCount <span>&amp;</span> <span>&#34;&amp;isMain=true&amp;numWindows=&#34;</span> <span>&amp;</span> maxWindows <span>&amp;</span> <span>&#34;&amp;numTabs=&#34;</span> <span>&amp;</span> numTabs <span>&amp;</span> <span>&#34;&amp;fullWidth=&#34;</span> <span>&amp;</span> fullWidth<span>}</span>
</span><span>    <span>else</span>
</span><span>      make new tab <span>with</span> properties <span>{</span>URL<span>:</span>baseURL <span>&amp;</span> <span>&#34;windowIndex=&#34;</span> <span>&amp;</span> windowNum <span>&amp;</span> <span>&#34;&amp;tabIndex=&#34;</span> <span>&amp;</span> tabCount<span>}</span>
</span><span>    <span>end</span> <span>if</span>
</span><span>  <span>end</span> <span>tell</span>
</span><span>  <span>set</span> tabCount <span>to</span> <span>(</span>tabCount <span>+</span> <span>1</span><span>)</span>
</span><span><span>end</span> <span>repeat</span>
</span></code></pre>
<h3 id="toc:fast-favicon-updates">Fast favicon updates</h3>
<p>The next problem was around <em>updating</em> favicons.</p>
<p>By default browsers look at some known URLs for favicons. But you can also add an element in the <code>head</code> of your HTML that says ‚Äúhey, my favicon is here.‚Äù</p>
<p>If you update that element, the browser will change the icon. This is how FlappyFavi works. Anecdotally it seems like chrome will update the icon about 4 times a second <a>2</a>.</p>
<div data-is-footnote="true"><div><div><div><p><span>2</span></p><p>I‚Äôm not sure how other browsers handle this. Notably Firefox lets you upload
<em>animated</em> favicons, which would have been really useful here. But Firefox
didn‚Äôt let me make a grid of tabs small enough that I could draw effectively
to it, so I stuck with Chrome. Wish I could have played with animations
though!</p></div></div></div></div>
<p>But it wasn‚Äôt clear to me how this would work when a tab was backgrounded. Browsers restrict the resources that a tab has access to when it is backgrounded to improve performance - and most of our tabs wouldn‚Äôt be in the foreground!</p>
<p>I did some simple testing with a tiny loop that updated the favicon every 250 ms. And sure enough, that loop only ran ~once a second in a backgrounded tab!</p>
<div><video controls="" playsinline="" poster="/images/running-pong-in-240-browser-tabs/favicon-throttling-firstframe.png" width="520" height="294" preload="metadata" alt="Two chrome tabs. Their favicons cycle between emojis. The foregrounded tab cycles 4 times faster."><p>Loading...</p></video><p>the backgrounded tab is too slow!</p></div>
<p>My <code>setInterval</code> loop was being throttled! I started kicking around ideas for how to work around this.</p>
<p>My first idea was to abuse the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">web audio APIs</a> - I know they have good support for audio continuing in the background and you can add some kinds of callbacks to audio code; I tried playing an inaudible tone and putting my code in the audio thread to see if that‚Äôd help. But I couldn‚Äôt get this working.</p>
<p>So I tried out <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">web workers</a>. Web workers are a way to offload a computationally-heavy task off of the main browser thread (so that you don‚Äôt block rendering). And I thought they might be less throttled.</p>
<p>I moved my timer to the web worker and had it post messages back to the main document when my timer triggered. And this worked great!</p>
<div><video controls="" playsinline="" poster="/images/running-pong-in-240-browser-tabs/favicon-webworker-firstframe.png" width="410" height="232" preload="metadata" alt="Two chrome tabs. Their favicons cycle between emojis. The foregrounded and backgrounded tabs are in sync."><p>Loading...</p></video><p>nice and synced up</p></div>
<p>The code here is a little long but relatively simple. We have a worker that cycles through emojis and turns them into data URLs that we pass back to the main tab, which updates the favicon.</p>
<details><summary><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> <!-- -->web worker favicon code</summary><pre><code><span>
</span><span>
</span><span><span>let</span> intervalId <span>=</span> <span>null</span><span>;</span>
</span><span><span>let</span> counter <span>=</span> <span>0</span><span>;</span>
</span><span><span>const</span> emojis <span>=</span> <span>[</span><span>&#34;üåû&#34;</span><span>,</span> <span>&#34;üåú&#34;</span><span>,</span> <span>&#34;‚≠ê&#34;</span><span>,</span> <span>&#34;üåé&#34;</span><span>,</span> <span>&#34;üöÄ&#34;</span><span>]</span><span>;</span>
</span><span><span>let</span> currentIndex <span>=</span> <span>0</span><span>;</span>
</span><span>
</span><span><span>function</span> <span>drawEmoji</span><span>(</span><span>emoji</span><span>)</span> <span>{</span>
</span><span>  
</span><span>  <span>const</span> canvas <span>=</span> <span>new</span> <span>OffscreenCanvas</span><span>(</span><span>32</span><span>,</span> <span>32</span><span>)</span><span>;</span>
</span><span>  <span>const</span> ctx <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#34;2d&#34;</span><span>)</span><span>;</span>
</span><span>
</span><span>  ctx<span>.</span><span>font</span> <span>=</span> <span>&#34;28px serif&#34;</span><span>;</span>
</span><span>  ctx<span>.</span><span>fillText</span><span>(</span>emoji<span>,</span> <span>2</span><span>,</span> <span>24</span><span>)</span><span>;</span>
</span><span>
</span><span>  
</span><span>  canvas<span>.</span><span>convertToBlob</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>blob</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>    <span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
</span><span>    reader<span>.</span><span>onloadend</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>      counter<span>++</span><span>;</span>
</span><span>      <span>postMessage</span><span>(</span><span>{</span>
</span><span>        <span>type</span><span>:</span> <span>&#34;update&#34;</span><span>,</span>
</span><span>        <span>dataUrl</span><span>:</span> reader<span>.</span><span>result</span><span>,</span>
</span><span>        <span>counter</span><span>:</span> counter<span>,</span>
</span><span>      <span>}</span><span>)</span><span>;</span>
</span><span>    <span>}</span><span>;</span>
</span><span>    reader<span>.</span><span>readAsDataURL</span><span>(</span>blob<span>)</span><span>;</span>
</span><span>  <span>}</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span>self<span>.</span><span>onmessage</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
</span><span>  <span>if</span> <span>(</span>e<span>.</span><span>data</span><span>.</span><span>command</span> <span>===</span> <span>&#34;start&#34;</span><span>)</span> <span>{</span>
</span><span>    <span>const</span> interval <span>=</span> e<span>.</span><span>data</span><span>.</span><span>interval</span><span>;</span>
</span><span>    <span>if</span> <span>(</span>intervalId<span>)</span> <span>clearInterval</span><span>(</span>intervalId<span>)</span><span>;</span>
</span><span>
</span><span>    intervalId <span>=</span> <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>      <span>drawEmoji</span><span>(</span>emojis<span>[</span>currentIndex<span>]</span><span>)</span><span>;</span>
</span><span>      currentIndex <span>=</span> <span>(</span>currentIndex <span>+</span> <span>1</span><span>)</span> <span>%</span> emojis<span>.</span><span>length</span><span>;</span>
</span><span>    <span>}</span><span>,</span> interval<span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>drawEmoji</span><span>(</span>emojis<span>[</span>currentIndex<span>]</span><span>)</span><span>;</span>
</span><span>  <span>}</span> <span>else</span> <span>if</span> <span>(</span>e<span>.</span><span>data</span><span>.</span><span>command</span> <span>===</span> <span>&#34;stop&#34;</span><span>)</span> <span>{</span>
</span><span>    <span>if</span> <span>(</span>intervalId<span>)</span> <span>{</span>
</span><span>      <span>clearInterval</span><span>(</span>intervalId<span>)</span><span>;</span>
</span><span>      intervalId <span>=</span> <span>null</span><span>;</span>
</span><span>    <span>}</span>
</span><span>  <span>}</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span>
</span><span>worker<span>.</span><span>onmessage</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
</span><span>  <span>if</span> <span>(</span>e<span>.</span><span>data</span><span>.</span><span>type</span> <span>===</span> <span>&#34;update&#34;</span><span>)</span> <span>{</span>
</span><span>    <span>let</span> link <span>=</span>
</span><span>      <span>document</span><span>.</span><span>querySelector</span><span>(</span><span>&#34;link[rel*=&#39;icon&#39;]&#34;</span><span>)</span> <span>||</span>
</span><span>      <span>document</span><span>.</span><span>createElement</span><span>(</span><span>&#34;link&#34;</span><span>)</span><span>;</span>
</span><span>    link<span>.</span><span>type</span> <span>=</span> <span>&#34;image/x-icon&#34;</span><span>;</span>
</span><span>    link<span>.</span><span>rel</span> <span>=</span> <span>&#34;shortcut icon&#34;</span><span>;</span>
</span><span>    link<span>.</span><span>href</span> <span>=</span> e<span>.</span><span>data</span><span>.</span><span>dataUrl</span><span>;</span>
</span><span>    <span>document</span><span>.</span><span>head</span><span>.</span><span>appendChild</span><span>(</span>link<span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span><span>}</span><span>;</span>
</span></code></pre></details>
<p>So that gives us quick updates. But if we want something to run across all of our tabs we need those tabs to synchronize. How should our tabs communicate?</p>
<h3 id="toc:tab-communication">Tab communication</h3>
<p>Tab communication had two sub problems:</p>
<ul>
<li>How does each tab know where it is? That is, how do I know that I‚Äôm the third tab in the second window?</li>
<li>What communication channel should I use to update my tabs?</li>
</ul>
<p>The first problem was relatively easy - you might have noticed the solution in my AppleScript code above. I had my script pass in the current window and tab index as a query parameter. Each tab just needs to extract those query parameters and it knows its window and tab index - basically its x and y coordinates.</p>
<p>The second problem was a little more interesting. The most obvious solution to me was to use websockets - I could have a server that each tab connected to, and that server could tell each tab what to do.</p>
<p>I whipped up a simple proof of concept. On load, tabs (inside a web worker) created a websocket connection to a server and then updated their favicon based on the data the server sent. The server sent two different images, staggered based on whether the tab‚Äôs index was even or odd.</p>

<p>This worked ok. I saw two problems:</p>
<ul>
<li><strong>Aesthetics:</strong> I just didn‚Äôt want to have a server! I wanted to be able to deploy this to browser tabs across the world.</li>
<li><strong>Syncing:</strong> The tabs were out of sync! The server pumped out updates to a tab as soon as it connected, and it took a while for every tab to load.</li>
</ul>
<p>To address the first point, I moved to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API">broadcast channels</a> - basically a way to distribute information across different tabs on the same domain. This was different from websockets - websockets are 1 to 1 but broadcasting is 1 to many. But that seemed like a better fit for what I was doing anyway.</p>
<p>The second just required a little more code. I taught backgrounded tabs to send a <code>registration</code> message containing their tab and window index over the broadcast channel. The <code>main</code> tab <a>3</a> (the one in the foreground, which isn‚Äôt throttled) listened for these messages and sent back an <code>ack</code>, after which the backgrounded tab would stop trying to register. And then once the main tab had received registration events for every backgrounded tab, it started running the animation.</p>
<div data-is-footnote="true"><div><div><div><p><span>3</span></p><p>My applescript added an extra query parameter to tell the last tab opened that
it was the main tab, along with parameters telling it how many windows and
tabs were opened.<!-- --> </p></div></div></div></div>
<details><summary><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> <!-- -->registration code</summary><pre><code><span>
</span><span>bc <span>=</span> <span>new</span> <span>BroadcastChannel</span><span>(</span><span>&#34;bc&#34;</span><span>)</span><span>;</span>
</span><span>bc<span>.</span><span>addEventListener</span><span>(</span><span>&#34;message&#34;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>  <span>const</span> msg <span>=</span> event<span>.</span><span>data</span><span>;</span>
</span><span>  <span>if</span> <span>(</span><span>!</span>msg<span>)</span> <span>return</span><span>;</span>
</span><span>  <span>else</span> <span>if</span> <span>(</span>
</span><span>    msg<span>.</span><span>type</span> <span>===</span> <span>&#34;ack&#34;</span> <span>&amp;&amp;</span>
</span><span>    msg<span>.</span><span>tabIndex</span> <span>===</span> tabIndex <span>&amp;&amp;</span>
</span><span>    msg<span>.</span><span>windowIndex</span> <span>===</span> windowIndex
</span><span>  <span>)</span> <span>{</span>
</span><span>    <span>clearInterval</span><span>(</span>regInterval<span>)</span><span>;</span>
</span><span>    registrationDone <span>=</span> <span>true</span><span>;</span>
</span><span>    <span>postMessage</span><span>(</span><span>{</span> <span>type</span><span>:</span> <span>&#34;registration-ack&#34;</span> <span>}</span><span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span><span>}</span><span>)</span><span>;</span>
</span><span>
</span><span>regInterval <span>=</span> <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>  bc<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>type</span><span>:</span> <span>&#34;register&#34;</span><span>,</span> tabIndex<span>,</span> windowIndex <span>}</span><span>)</span><span>;</span>
</span><span><span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
</span><span>
</span><span>
</span><span><span>const</span> bc <span>=</span> <span>new</span> <span>BroadcastChannel</span><span>(</span><span>&#34;bc&#34;</span><span>)</span><span>;</span>
</span><span><span>const</span> registrations <span>=</span> <span>{</span><span>}</span><span>;</span>
</span><span><span>if</span> <span>(</span>data <span>&amp;&amp;</span> data<span>.</span><span>type</span> <span>===</span> <span>&#34;register&#34;</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> key <span>=</span> <span><span>`</span><span>tab_</span><span><span>${</span>data<span>.</span><span>tabIndex</span><span>}</span></span><span>_</span><span><span>${</span>data<span>.</span><span>windowIndex</span><span>}</span></span><span>`</span></span><span>;</span>
</span><span>  <span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>Registered: </span><span><span>${</span>key<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
</span><span>  registrations<span>[</span>key<span>]</span> <span>=</span> <span>true</span><span>;</span>
</span><span>  bc<span>.</span><span>postMessage</span><span>(</span><span>{</span>
</span><span>    <span>type</span><span>:</span> <span>&#34;ack&#34;</span><span>,</span>
</span><span>    <span>tabIndex</span><span>:</span> data<span>.</span><span>tabIndex</span><span>,</span>
</span><span>    <span>windowIndex</span><span>:</span> data<span>.</span><span>windowIndex</span><span>,</span>
</span><span>  <span>}</span><span>)</span><span>;</span>
</span><span>
</span><span>  <span>const</span> expected <span>=</span> numTabs <span>*</span> numWindows<span>;</span>
</span><span>  <span>if</span> <span>(</span><span>Object</span><span>.</span><span>keys</span><span>(</span>registrations<span>)</span><span>.</span><span>length</span> <span>===</span> expected<span>)</span> <span>{</span>
</span><span>    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;All tabs registered. Beginning...&#34;</span><span>)</span><span>;</span>
</span><span>    <span>runLoopGeneric</span><span>(</span><span>{</span>
</span><span>      bc<span>,</span>
</span><span>      worker<span>,</span>
</span><span>      numTabs<span>,</span>
</span><span>      numWindows<span>,</span>
</span><span>      fullWidth<span>,</span>
</span><span>      <span>impl</span><span>:</span> <span>&#34;pong&#34;</span><span>,</span>
</span><span>    <span>}</span><span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span><span>}</span>
</span></code></pre></details>
<h2 id="toc:from-canvas-to-tab-bar">From canvas to tab bar</h2>
<p>Once I had reasonable control over my tabs, I started thinking about what I should actually build. I thought it‚Äôd be cool if I could draw something in my foregrounded tab and then have that move ‚Äúinto‚Äù the tab bar.</p>
<p>I started with a simple rectangle.</p>

<p>To do this I needed to imagine a canvas that extended from my foregrounded window through all of the favicons above it, and then draw to the favicons as well as the main canvas based on an object‚Äôs position.</p>
<p>There‚Äôs this quote from Teller (of Penn and Teller) that I think about a lot when I make projects like this.</p>
<blockquote><p>Sometimes magic is just someone spending more time on something than anyone
else might reasonably expect.</p></blockquote>
<p>And while I want to be careful to not make <em>too much</em> of this comparison - I am no Teller!! - I had it in mind while doing this.</p>
<p>There‚Äôs no magic here. Honestly, I just spent a while taking measurements.</p>
<div><p><img alt="Several stacked chrome windows. Measurements indicate how tall and wide various spans (like the distance between the left side of the window and the first tab) are" loading="lazy" width="1900" height="1314" decoding="async" data-nimg="1" src="https://newslttrs.com/images/running-pong-in-240-browser-tabs/annotated-chrome.png"/></p><p>thank you tldraw</p></div>
<p>There are 92 pixels between the left side of a chrome window and the first favicon (at least with this many tabs open). And 58 pixels between the bottom of a favicon and the top of the actual window. And favicons are 16x16, and, and, and‚Ä¶</p>
<p>My code takes all of those measurements, along with some information about the number of open tabs and windows, and uses it to:</p>
<ul>
<li>Calculate the width of the canvas that it displays, so that it‚Äôs perfectly aligned with the favicons above it.</li>
<li>Calculate the width of each tab</li>
<li>Determine with width and height of the entire ‚Äúcanvas‚Äù that it‚Äôs drawing to - including the rows of favicons, the URL bar, and the actual canvas in the window.</li>
</ul>
<div><p><img alt="Code that encodes the pixel measurements from the above image." loading="lazy" width="1330" height="468" decoding="async" data-nimg="1" src="https://newslttrs.com/images/running-pong-in-240-browser-tabs/code-measurements.png"/></p><p>this was finicky!</p></div>
<p>We then simulate a rectangle moving across our ‚Äúfull‚Äù canvas. When part of it is below the URL bar, we draw it to our ‚Äúreal canvas.‚Äù But we also calculate which parts of it are ‚Äúabove‚Äù the URL bar, and broadcast that to our other tabs. Each tab calculates its own pixel coordinates (based on the math we did above) and updates itself with white or black pixels based on where the rectangle is.</p>
<details><summary><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> <!-- -->rectangle code</summary><pre><code><span>
</span><span><span>function</span> <span>transmitSquareCoords</span><span>(</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> copied <span>=</span> <span>{</span> <span>...</span>square <span>}</span><span>;</span>
</span><span>  updateMap <span>=</span> <span>{</span><span>}</span><span>;</span>
</span><span>  <span>for</span> <span>(</span><span>let</span> t <span>=</span> <span>0</span><span>;</span> t <span>&lt;</span> numTabs <span>-</span> <span>1</span><span>;</span> t<span>++</span><span>)</span> <span>{</span>
</span><span>    <span>for</span> <span>(</span><span>let</span> w <span>=</span> <span>0</span><span>;</span> w <span>&lt;</span> numWindows<span>;</span> w<span>++</span><span>)</span> <span>{</span>
</span><span>      pixels <span>=</span> <span>[</span><span>]</span><span>;</span>
</span><span>      <span>const</span> <span>PIXEL_COUNT</span> <span>=</span> <span>4</span><span>;</span>
</span><span>      <span>const</span> <span>FAVICON_SIZE</span> <span>=</span> <span>16</span><span>;</span>
</span><span>      <span>const</span> <span>MULT</span> <span>=</span> <span>FAVICON_SIZE</span> <span>/</span> <span>PIXEL_COUNT</span><span>;</span>
</span><span>      <span>for</span> <span>(</span><span>let</span> yy <span>=</span> <span>0</span><span>;</span> yy <span>&lt;</span> <span>PIXEL_COUNT</span><span>;</span> yy<span>++</span><span>)</span> <span>{</span>
</span><span>        <span>for</span> <span>(</span><span>let</span> xx <span>=</span> <span>0</span><span>;</span> xx <span>&lt;</span> <span>PIXEL_COUNT</span><span>;</span> xx<span>++</span><span>)</span> <span>{</span>
</span><span>          <span>let</span> x <span>=</span> tabSingle <span>*</span> t <span>+</span> <span>(</span>tabSingle <span>-</span> <span>16</span><span>)</span> <span>/</span> <span>2</span> <span>+</span> xx <span>*</span> <span>MULT</span><span>;</span>
</span><span>          <span>let</span> y <span>=</span> <span>TOP_TO_FAVICON</span> <span>+</span> <span>HARDCODED_WINDOW_DIFF</span> <span>*</span> w <span>+</span> yy <span>*</span> <span>MULT</span><span>;</span>
</span><span>          <span>let</span> thisSquare <span>=</span> <span>{</span>
</span><span>            x<span>,</span>
</span><span>            y<span>,</span>
</span><span>            <span>w</span><span>:</span> <span>MULT</span><span>,</span>
</span><span>            <span>h</span><span>:</span> <span>MULT</span><span>,</span>
</span><span>          <span>}</span><span>;</span>
</span><span>          <span>if</span> <span>(</span><span>intersects</span><span>(</span>thisSquare<span>,</span> copied<span>)</span><span>)</span> <span>{</span>
</span><span>            pixels<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span><span>;</span>
</span><span>          <span>}</span> <span>else</span> <span>{</span>
</span><span>            pixels<span>.</span><span>push</span><span>(</span><span>0</span><span>)</span><span>;</span>
</span><span>          <span>}</span>
</span><span>        <span>}</span>
</span><span>      <span>}</span>
</span><span>      <span>const</span> key <span>=</span> <span><span>`</span><span>tab_</span><span><span>${</span>t<span>}</span></span><span>_</span><span><span>${</span>w<span>}</span></span><span>`</span></span><span>;</span>
</span><span>      updateMap<span>[</span>key<span>]</span> <span>=</span> pixels<span>;</span>
</span><span>    <span>}</span>
</span><span>  <span>}</span>
</span><span>  bc<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>type</span><span>:</span> <span>&#34;update&#34;</span><span>,</span> <span>pixels</span><span>:</span> updateMap <span>}</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span><span>function</span> <span>updateFavicon</span><span>(</span><span>pixels</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> canvas <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>&#34;canvas&#34;</span><span>)</span><span>;</span>
</span><span>  canvas<span>.</span><span>width</span> <span>=</span> <span>4</span><span>;</span>
</span><span>  canvas<span>.</span><span>height</span> <span>=</span> <span>4</span><span>;</span>
</span><span>  <span>const</span> ctx <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#34;2d&#34;</span><span>)</span><span>;</span>
</span><span>  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>16</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
</span><span>    <span>const</span> x <span>=</span> i <span>%</span> <span>4</span><span>,</span>
</span><span>      y <span>=</span> <span>Math</span><span>.</span><span>floor</span><span>(</span>i <span>/</span> <span>4</span><span>)</span><span>;</span>
</span><span>    ctx<span>.</span><span>fillStyle</span> <span>=</span> pixels<span>[</span>i<span>]</span> <span>?</span> <span>&#34;#000&#34;</span> <span>:</span> <span>&#34;#fff&#34;</span><span>;</span>
</span><span>    ctx<span>.</span><span>fillRect</span><span>(</span>x<span>,</span> y<span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span>  <span>const</span> faviconURL <span>=</span> canvas<span>.</span><span>toDataURL</span><span>(</span><span>&#34;image/png&#34;</span><span>)</span><span>;</span>
</span><span>  <span>let</span> link <span>=</span> <span>document</span><span>.</span><span>querySelector</span><span>(</span><span>&#34;link[rel=&#39;icon&#39;]&#34;</span><span>)</span><span>;</span>
</span><span>  <span>if</span> <span>(</span><span>!</span>link<span>)</span> <span>{</span>
</span><span>    link <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>&#34;link&#34;</span><span>)</span><span>;</span>
</span><span>    link<span>.</span><span>rel</span> <span>=</span> <span>&#34;icon&#34;</span><span>;</span>
</span><span>    <span>document</span><span>.</span><span>head</span><span>.</span><span>appendChild</span><span>(</span>link<span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span>  link<span>.</span><span>href</span> <span>=</span> faviconURL<span>;</span>
</span><span><span>}</span>
</span></code></pre></details>
<h3 id="toc:making-it-faster">Making it faster</h3>
<p>This worked ok! But it used a surprising amount of resources - you can see that because the animation on the canvas starts and stops, even though it‚Äôs being drawn inside <code>requestAnimationFrame</code> and <em>should</em> be smooth.</p>
<p>Since the animation was jerky, I figured something on the foregrounded tab‚Äôs thread was using too many resources. There wasn‚Äôt <em>that</em> much going on there, but I figured maybe I was transmitting too much data.</p>
<p>My main thread computed the state of every favicon pixel and then stuff that into the broadcast channel, which was read by hundreds of tabs. You could imagine a broadcast implementation that did a copy for every tab‚Ä¶maybe that was too much copying? I was skeptical, but had no better guess.</p>
<p>I reworked my code to just broadcast the <em>position</em> of the square and had each tab compute on the fly whether its favicon intersected with the square. But this didn‚Äôt seem to help! I was baffled.</p>
<p>I fell back on the age-old technique of disabling different bits of code until stuff worked, and eventually I hit on the issue; I was creating hundreds of favicons a second, and that was too slow.</p>
<p>Basically, my code did something like this in each tab to create a 4x4 black and white image and turn that into a URL that I could point my favicon to.</p>
<pre><code><span><span>const</span> ctx <span>=</span> bwCanvas<span>.</span><span>getContext</span><span>(</span><span>&#34;2d&#34;</span><span>)</span><span>;</span>
</span><span><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> x <span>=</span> i <span>%</span> width<span>;</span>
</span><span>  <span>const</span> y <span>=</span> <span>Math</span><span>.</span><span>floor</span><span>(</span>i <span>/</span> width<span>)</span><span>;</span>
</span><span>  <span>const</span> index <span>=</span> <span>(</span>y <span>*</span> width <span>+</span> x<span>)</span> <span>*</span> <span>4</span><span>;</span>
</span><span>  ctx<span>.</span><span>fillStyle</span> <span>=</span> pixels<span>[</span>i<span>]</span> <span>?</span> <span>BLACK</span> <span>:</span> <span>WHITE</span><span>;</span>
</span><span>  ctx<span>.</span><span>fillRect</span><span>(</span>x<span>,</span> y<span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span><span>return</span> bwCanvas<span>.</span><span>toDataURL</span><span>(</span><span>&#34;image/png&#34;</span><span>)</span><span>;</span>
</span></code></pre>
<p>And this code re-ran on each ‚Äúframe‚Äù whether the resulting canvas had changed or not. I had hundreds of tabs that were re-creating tiny white square favicons multiple times a second!</p>
<p>I updated my code to only update the favicon if something changed and performance improved dramatically.</p>

<p>To be honest, I‚Äôm still a little confused about why this work slowed down my animation. I understand how doing too much work in other tabs could slow down my whole machine (and I was using a decent amount of CPU), but my machine had plenty of cores to spare! I‚Äôm clearly ignorant of some aspect of browser resource usage.</p>
<h2 id="toc:so-what-do-we-build">So what do we build?</h2>
<p>After getting my moving square working, I spent some time cleaning up my code just enough that I had a little ‚Äúengine‚Äù that I could write my code against. And then I started thinking of games to make.</p>
<p>The first game I thought of was snake. I figured that snake was naturally block-based (which fits well with the favicons) and pretty easy to program. So I wrote the first part of a snake implementation <a>4</a>.</p>
<div data-is-footnote="true"><div><div><div><p><span>4</span></p><p>The snake trick were you move it by keeping an array of snake positions and on
every tick just chop off the tail and add a new head based on the current
direction always delights me</p></div></div></div></div>
<p>But I quickly ran into a problem. Maybe you can see it.</p>
<div><video controls="" playsinline="" poster="/images/running-pong-in-240-browser-tabs/faviconic-snake-firstframe.png" width="1598" height="802" preload="metadata" alt="A game of snake. The snake moves between a canvas in a foregrounded chrome tab and the rows of favicons above."><p>Loading...</p></video><p>this was pretty fun to play with</p></div>
<p>The issue - at least to me - is that snake is <em>too</em> block-based. Some of the beauty of the moving rectangle animation is how it moves from continuous (on the canvas) to discrete (in the tab bar). I think it‚Äôs most natural to think of snake as a game operating over a discrete (and small) set of snake cell sized blocks.</p>
<p>So I tried to come up with a new game <a>5</a>. Eventually I settled on Pong, since the ball and tabs would have to regularly move between the canvas and the tab bar, which I thought was a cool effect.</p>
<div data-is-footnote="true"><div><div><div><p><span>5</span></p><p>Thanks for everyone on
<a href="https://bsky.app/profile/itseieio.bsky.social/post/3lihzhirmcc2j">bsky</a> and
<a href="https://x.com/itseieio/status/1891929602722869741">twitter</a> that offered game
ideas without knowing what I was trying to do!</p></div></div></div></div>
<h3 id="toc:implementing-pong">Implementing pong</h3>
<p>And then I implemented pong!</p>
<p>To be honest, I don‚Äôt have too much to say about this part. I have enough practice writing games that getting pong working once I had a good API for drawing was pretty simple.</p>
<p>I guess I can give you a few notes on my implementation:</p>
<ul>
<li>The computer player (on the right side) just tries to keep the center of its paddle aligned with the center of the ball at all times</li>
<li>I do some simple trig to compute the angle the ball should bounce off of the paddle (relative to the paddle‚Äôs center). This is totally unrealistic, but it prevents the ball from always keeping the same angle.</li>
<li>I wrote what has to be at least my 20th ‚Äúdo these two squares intersect‚Äù function for this.</li>
</ul>
<p>I was really happy with the effect of the ball and paddles smoothly sliding into the favicons, and ended up adding a trail to the ball to try to emphasize the movement.</p>
<div><video controls="" playsinline="" poster="/images/running-pong-in-240-browser-tabs/gameplay-firstframe.png" width="2032" height="1142" preload="metadata" alt="A chrome window plays pong. There are 8 chrome windows stacked on top of each other with the tab bars very close to each other. Each tab bar has 30 tabs. The pong balls and paddles move from a canvas in the foregrounded chrome window to the tab bar above. The ball and paddles continue to move."><p>Loading...</p></video><p>I&#39;ve stared at this for too long to know if the trail is ugly</p></div>
<p>The <a href="https://github.com/nolenroyalty/faviconic">code</a> is open source but extremely ugly; I never really left prototype mode on this one. Sorry about that.</p>
<h2 id="toc:wrapping-up">Wrapping up</h2>
<p>This was a fun one! Thanks again to <a href="https://mewtru.com/">Tru</a> for the inspiration.</p>
<p>I wrote this project while in batch at the <a href="https://www.recurse.com/">Recurse Center</a> a (free!) place that is like a writer‚Äôs retreat for programming. Recurse is really special, and it motivated me to get this post out the door today so that I could show this project during Recurse‚Äôs weekly presentations.</p>
<p>I love Recurse a lot, and being in batch again has motivated me to really up my output - this is my 4th game in the last ~40 days! If you liked this project I think that you should <a href="https://www.recurse.com/apply">consider applying</a>.</p>
<p>Thanks for reading - I‚Äôll be back with more nonsense soon :)</p></article></div>
  </body>
</html>
