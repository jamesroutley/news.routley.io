<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xania.org/202512/02-adding-integers">Original</a>
    <h1>Addressing the adding situation</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        

        <p>Written by me, proof-read by an LLM.
</p>
<p><a href="https://xania.org/202512/01-xor-eax-eax">Yesterday</a> we saw how compilers zero registers efficiently. Today let’s look at something a tiny bit less trivial (though not by much): adding two integers. What do you think a simple x86 function to add two ints<sup id="fnref:abi"><a href="#fn:abi">1</a></sup> would look like? An <code>add</code>, right? Let’s take a look!</p>


<p>Probably not what you were thinking, right? x86 is unusual in mostly having a maximum of two operands per instruction<sup id="fnref:but"><a href="#fn:but">2</a></sup>. There’s no <code>add</code> instruction to add <code>edi</code> to <code>esi</code>, putting the result in <code>eax</code>. On an ARM machine this would be a simple <code>add r0, r0, r1</code> or similar, as ARM has a separate destination operand. On x86, things like <code>add</code> are not <code>result = lhs + rhs</code> but <code>lhs += rhs</code>. This can be a limitation, as we don’t get to control which register the result goes into, and we in fact lose the old value of <code>lhs</code>.</p>
<p>So how do compilers work around this limitation? The answer lies in an unexpected place - the sophisticated memory addressing system of the x86. Nearly every operand can be a memory reference - there’s no specific “load” or “store”; a <code>mov</code> can just refer to memory directly. Those memory references are pretty rich: you can refer to memory addressed by a constant, relative to a register, or relative to a register plus an offset (optionally multiplied by 1, 2, 4 or 8). Something like <code>add eax, word ptr [rdi + rsi * 4 + 0x1000]</code> is still a single instruction<sup id="fnref:cisc"><a href="#fn:cisc">3</a></sup>!</p>
<p>Sometimes you don’t want to <em>access</em> the memory at one of these complex addresses, you just want to calculate what the address would be. Sort of like C’s “address-of” (<code>&amp;</code>) operator. That’s what <code>lea</code> (<a href="https://www.felixcloutier.com/x86/lea">Load Effective Address</a>) does: it calculates the address without touching memory.</p>
<p>Why is this useful for addition? Well, if we’re not actually accessing memory, we can abuse the addressing hardware as a calculator! That complex addressing mode with its register-plus-register-times-scale is really just shifting and adding - so <code>lea</code> becomes a cheeky way to do three-operand addition<sup id="fnref:three"><a href="#fn:three">4</a></sup>.</p>
<p>The compiler writes our simple addition in terms of the address of memory at <code>rdi</code> offset by <code>rsi</code>. We get a full add of two registers <em>and</em> we get to specify the destination too. You’ll notice that the operands are referenced as <code>rdi</code> and <code>rsi</code> (the 64-bit version) even though we only wanted a 32-bit add: because we are using the memory addressing system it unconditionally calculates a 64-bit address. However, in this case it doesn’t matter; those top bits<sup id="fnref:zero"><a href="#fn:zero">5</a></sup> are discarded when the result is written to the 32-bit <code>eax</code>.</p>
<p>Using <code>lea</code> often saves an instruction, is useful if both of the operands are still needed later on in other calculations (as it leaves them unchanged), and can execute on x86’s <a href="https://mattgodbolt.github.io/ooo/#/0/1">multiple execution units</a> in the same cycle. Compilers know this though, so you don’t have to worry!</p>
<p><em>See <a href="https://youtu.be/BOvg0sGJnes">the video</a> that accompanies this post.</em></p>
<hr/>
<p><em>This post is day 2 of <a href="https://xania.org/AoCO2025">Advent of Compiler Optimisations 2025</a>,
a 25-day series exploring how compilers transform our code.</em></p>
<p><em>This post was written by a human (<a href="https://xania.org/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read by LLMs and humans.</em></p>
<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>
or <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,
or by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>

    </div>
</div></div>
  </body>
</html>
