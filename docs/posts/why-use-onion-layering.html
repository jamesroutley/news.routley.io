<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://garrettdbates.com/2024/07/07/why-use-onion-layering.html">Original</a>
    <h1>Why Use Onion Layering?</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <h2 id="motivation">Motivation</h2>
<p>There is a constant assault on our code base in the form of feature enhancements, bug fixes, and hygiene. Envision each incoming change as a bomb ðŸ’£, and the damage it does is based on the number of files impacted. Onion layering promises to reduce this blast radius.</p>

<h3 id="reduces-blast-radius-of-change">Reduces blast radius of change</h3>
<p><img src="https://garrettdbates.com/assets/why-use-onion-layering/change-damage.png" alt="Code Base Damage"/></p>

<p>Each change bomb is typically unique and requires a deep understanding of our code bases existing behaviors. Onion layering promises to reduce the time to understand existing behaviors.</p>

<h3 id="accelerates-understanding">Accelerates understanding</h3>
<p><img src="https://garrettdbates.com/assets/why-use-onion-layering/change-time.png" alt="Reduces time to understand existing behaviors"/></p>

<h2 id="examples">Examples</h2>

<h3 id="adding-a-field-to-our-api">Adding a field to our API</h3>

<p>Imagine the most annoying possible client of our microservice. Suppose they want a new field, and they insist that it be named a certain way. Not only that but the API Stewards mandate that the new field be prefixed with a 25 character prefix and 45 character suffix.</p>

<p>The resulting request object that hits our system is horrifyingly ugly. It will sit in the .api.* layer of our onion architecture, and <strong>it will go no further</strong>. Our .core.* classes will not be beholden to the insane demands of our clients. Instead we can represent this new field in an idiomatic way that feels native to the language we are using.</p>

<p>Onion layering reduced how much pain our clients inflicted on our code base to the .api.* package and in doing so also increased the readability of our .core.* package.</p>

<p><img src="https://garrettdbates.com/assets/why-use-onion-layering/example-damage-control.png" alt="Example damage control"/></p>

<h3 id="introducing-a-new-downstream-dependency">Introducing a new downstream dependency</h3>

<p>Imagine the most annoying possible microservice dependency. Suppose every input field is an acronym, they are using SOAP, and output is spread across response headers, body, and cookies.</p>

<p>The raw code to interact with this dependency is horrifyingly ugly. It will sit in the .infra.* layer of our onion architecture, and <strong>it will go no further</strong>. Our .core.* classes will not be beholden to speak the insane language of our downstream dependency. Instead we will reflect exactly what we need via an interface in .core.*.</p>

<p>Onion layering reduced how much pain our dependency inflicted on our code base to the .infra.* package and in doing so also increased the readability of our .core.* package.</p>

<p><img src="https://garrettdbates.com/assets/why-use-onion-layering/damage-control-dependency.png" alt="Example damage control - dependency"/></p>

<h3 id="introducing-a-new-library-dependency">Introducing a new library dependency</h3>

<p>Imagine the most annoying possible library dependency. Suppose they have an interface we need to use, but constructing the object requires 10 configuration fields, 5 separate object dependencies, encryption algorithm selection, and a custom HTTP client.</p>

<p>The raw code to wire up this dependency is completely irrelevant to our existing behaviors. It will sit in the .config.* layer of our onion architecture, and <strong>it will go no further</strong>.</p>

<p>Onion layering isolates the distracting details of our new library into the .config.* package and in doing so also increases the readability of the rest of our code base.</p>

<p><img src="https://garrettdbates.com/assets/why-use-onion-layering/configuration-example.png" alt="Example clarity - configuration isolation"/></p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
