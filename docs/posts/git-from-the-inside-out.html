<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out">Original</a>
    <h1>Git from the Inside Out</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>This essay explains how Git works.  It assumes you understand Git well enough to use it to version control your projects.</p>

<p>The essay focuses on the graph structure that underpins Git and the way the properties of this graph dictate Git’s behavior. Looking at fundamentals, you build your mental model on the truth rather than on hypotheses constructed from evidence gathered while experimenting with the API. This truer model gives you a better understanding of what Git has done, what it is doing, and what it will do.</p>

<p>The text is structured as a series of Git commands run on a single project. At intervals, there are observations about the graph data structure that Git is built on. These observations illustrate a property of the graph and the behavior that this property produces.</p>

<p>After reading, if you wish to go even deeper into Git, you can look at the <a href="http://gitlet.maryrosecook.com/docs/gitlet.html">heavily annotated source code</a> of my implementation of Git in JavaScript.</p>

<h2 id="create-the-project">Create the project</h2>

<div><pre><code>~ $ mkdir alpha
~ $ cd alpha
</code></pre></div>
<p>The user creates <code>alpha</code>, a directory for their project.</p>

<div><pre><code>~/alpha $ mkdir data
~/alpha $ printf &#39;a&#39; &gt; data/letter.txt
</code></pre></div>
<p>They move into the <code>alpha</code> directory and create a directory called <code>data</code>. Inside, they create a file called <code>letter.txt</code> that contains <code>a</code>. The alpha directory looks like this:</p>

<div><pre><code>alpha
└── data
    └── letter.txt
</code></pre></div>
<h2 id="initialize-the-repository">Initialize the repository</h2>

<div><pre><code>~/alpha $ git init
          Initialized empty Git repository
</code></pre></div>
<p><code>git init</code> makes the current directory into a Git repository. To do this, it creates a <code>.git</code> directory and writes some files to it. These files define everything about the Git configuration and the history of the project. They are just ordinary files. No magic in them. The user can read and edit them with a text editor or shell. Which is to say: the user can read and edit the history of their project as easily as their project files.</p>

<p>The <code>alpha</code> directory now looks like this:</p>

<div><pre><code>alpha
├── data
|   └── letter.txt
└── .git
    ├── objects
    etc...
</code></pre></div>
<p>The <code>.git</code> directory and its contents are Git’s. All the other files are collectively known as the working copy. They are the user’s.</p>

<h2 id="add-some-files">Add some files</h2>

<div><pre><code>~/alpha $ git add data/letter.txt
</code></pre></div>
<p>The user runs <code>git add</code> on <code>data/letter.txt</code>. This has two effects.</p>

<p>First, it creates a new blob file in the <code>.git/objects/</code> directory.</p>

<p>This blob file contains the compressed content of <code>data/letter.txt</code>. Its name is derived by hashing its content. Hashing a piece of text means running a program on it that turns it into a smaller<sup id="fnref:1"><a href="#fn:1">1</a></sup> piece of text that uniquely<sup id="fnref:2"><a href="#fn:2">2</a></sup> identifies the original. For example, Git hashes <code>a</code> to <code>2e65efe2a145dda7ee51d1741299f848e5bf752e</code>. The first two characters are used as the name of a directory inside the objects database: <code>.git/objects/2e/</code>. The rest of the hash is used as the name of the blob file that holds the content of the added file: <code>.git/objects/2e/65efe2a145dda7ee51d1741299f848e5bf752e</code>.</p>

<p>Notice how just adding a file to Git saves its content to the <code>objects</code> directory. Its content will still be safe inside Git if the user deletes <code>data/letter.txt</code> from the working copy.</p>

<p>Second, <code>git add</code> adds the file to the index. The index is a list that contains every file that Git has been told to keep track of. It is stored as a file at <code>.git/index</code>. Each line of the file maps a tracked file to the hash of its content at the moment it was added. This is the index after the <code>git add</code> command is run:</p>

<div><pre><code>data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e
</code></pre></div>
<p>The user makes a file called <code>data/number.txt</code> that contains <code>1234</code>.</p>

<div><pre><code>~/alpha $ printf &#39;1234&#39; &gt; data/number.txt
</code></pre></div>
<p>The working copy looks like this:</p>

<div><pre><code>alpha
└── data
    └── letter.txt
    └── number.txt
</code></pre></div>
<p>The user adds the file to Git.</p>


<p>The <code>git add</code> command creates a blob object that contains the content of <code>data/number.txt</code>. It adds an index entry for <code>data/number.txt</code> that points at the blob. This is the index after the <code>git add</code> command is run a second time:</p>

<div><pre><code>data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e
data/number.txt 274c0052dd5408f8ae2bc8440029ff67d79bc5c3
</code></pre></div>
<p>Notice that only the files in the <code>data</code> directory are listed in the index, though the user ran <code>git add data</code>. The <code>data</code> directory is not listed separately.</p>

<div><pre><code>~/alpha $ printf &#39;1&#39; &gt; data/number.txt
~/alpha $ git add data
</code></pre></div>
<p>When the user originally created <code>data/number.txt</code>, they meant to type <code>1</code>, not <code>1234</code>. They make the correction and add the file to the index again. This command creates a new blob with the new content. And it updates the index entry for <code>data/number.txt</code> to point at the new blob.</p>

<h2 id="make-a-commit">Make a commit</h2>

<div><pre><code>~/alpha $ git commit -m &#39;a1&#39;
          [master (root-commit) 774b54a] a1
</code></pre></div>
<p>The user makes the <code>a1</code> commit. Git prints some data about the commit.  These data will make sense shortly.</p>

<p>The commit command has three steps. It creates a tree graph to represent the content of the version of the project being committed. It creates a commit object. It points the current branch at the new commit object.</p>

<h3 id="create-a-tree-graph">Create a tree graph</h3>

<p>Git records the current state of the project by creating a tree graph from the index. This tree graph records the location and content of every file in the project.</p>

<p>The graph is composed of two types of object: blobs and trees.</p>

<p>Blobs are stored by <code>git add</code>. They represent the content of files.</p>

<p>Trees are stored when a commit is made. A tree represents a directory in the working copy.</p>

<p>Below is the tree object that records the contents of the <code>data</code> directory for the new commit:</p>

<div><pre><code>100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt
100664 blob 56a6051ca2b02b04ef92d5150c9ef600403cb1de number.txt
</code></pre></div>
<p>The first line records everything required to reproduce <code>data/letter.txt</code>.  The first part states the file’s permissions.  The second part states that the content of this entry is represented by a blob, rather than a tree.  The third part states the hash of the blob.  The fourth part states the file’s name.</p>

<p>The second line records the same for <code>data/number.txt</code>.</p>

<p>Below is the tree object for <code>alpha</code>, which is the root directory of the project:</p>

<div><pre><code>040000 tree 0eed1217a2947f4930583229987d90fe5e8e0b74 data
</code></pre></div>
<p>The sole line in this tree points at the <code>data</code> tree.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/1-a1-tree-graph.png" alt="Tree graph for the `a1` commit"/></p>
<p>Tree graph for the `a1` commit</p>

<p>In the graph above, the <code>root</code> tree points at the <code>data</code> tree. The <code>data</code> tree points at the blobs for <code>data/letter.txt</code> and <code>data/number.txt</code>.</p>

<h3 id="create-a-commit-object">Create a commit object</h3>

<p><code>git commit</code> creates a commit object after creating the tree graph. The commit object is just another text file in <code>.git/objects/</code>:</p>

<div><pre><code>tree ffe298c3ce8bb07326f888907996eaa48d266db4
author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500
committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500

a1
</code></pre></div>
<p>The first line points at the tree graph. The hash is for the tree object that represents the root of the working copy.  That is: the <code>alpha</code> directory.  The last line is the commit message.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/2-a1-commit.png" alt="`a1` commit object pointing at its tree graph"/></p>
<p>`a1` commit object pointing at its tree graph</p>

<h3 id="point-the-current-branch-at-the-new-commit">Point the current branch at the new commit</h3>

<p>Finally, the commit command points the current branch at the new commit object.</p>

<p>Which is the current branch? Git goes to the <code>HEAD</code> file at <code>.git/HEAD</code> and finds:</p>


<p>This says that <code>HEAD</code> is pointing at <code>master</code>.  <code>master</code> is the current branch.</p>

<p><code>HEAD</code> and <code>master</code> are both refs. A ref is a label used by Git or the user to identify a specific commit.</p>

<p>The file that represents the <code>master</code> ref does not exist, because this is the first commit to the repository. Git creates the file at <code>.git/refs/heads/master</code> and sets its content to the hash of the commit object:</p>

<div><pre><code>74ac3ad9cde0b265d2b4f1c778b283a6e2ffbafd
</code></pre></div>
<p>(If you are typing in these Git commands as you read, the hash of your <code>a1</code> commit will be different from the hash of mine. Content objects like blobs and trees always hash to the same value. Commits do not, because they include dates and the names of their creators.)</p>

<p>Let’s add <code>HEAD</code> and <code>master</code> to the Git graph:</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/3-a1-refs.png" alt="`master` pointing at the `a1` commit"/></p>
<p>`HEAD` pointing at `master` and `master` pointing at the `a1` commit</p>

<p><code>HEAD</code> points at <code>master</code>, as it did before the commit. But <code>master</code> now exists and points at the new commit object.</p>

<h2 id="make-a-commit-that-is-not-the-first-commit">Make a commit that is not the first commit</h2>

<p>Below is the Git graph after the <code>a1</code> commit. The working copy and index are included.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/4-a1-wc-and-index.png" alt="`a1` commit shown with the working copy and index"/></p>
<p>`a1` commit shown with the working copy and index</p>

<p>Notice that the working copy, index, and <code>a1</code> commit all have the same content for <code>data/letter.txt</code> and <code>data/number.txt</code>. The index and <code>HEAD</code> commit both use hashes to refer to blob objects, but the working copy content is stored as text in a different place.</p>

<div><pre><code>~/alpha $ printf &#39;2&#39; &gt; data/number.txt
</code></pre></div>
<p>The user sets the content of <code>data/number.txt</code> to <code>2</code>. This updates the working copy, but leaves the index and <code>HEAD</code> commit as they are.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/5-a1-wc-number-set-to-2.png" alt="`data/number.txt` set to `2` in the working copy"/></p>
<p>`data/number.txt` set to `2` in the working copy</p>

<div><pre><code>~/alpha $ git add data/number.txt
</code></pre></div>
<p>The user adds the file to Git. This adds a blob containing <code>2</code> to the <code>objects</code> directory. It points the index entry for <code>data/number.txt</code> at the new blob.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/6-a1-wc-and-index-number-set-to-2.png" alt="`data/number.txt` set to `2` in the working copy and index"/></p>
<p>`data/number.txt` set to `2` in the working copy and index</p>

<div><pre><code>~/alpha $ git commit -m &#39;a2&#39;
          [master f0af7e6] a2
</code></pre></div>
<p>The user commits. The steps for the commit are the same as before.</p>

<p>First, a new tree graph is created to represent the content of the index.</p>

<p>The index entry for <code>data/number.txt</code> has changed.  The old <code>data</code> tree no longer reflects the indexed state of the <code>data</code> directory.  A new <code>data</code> tree object must be created:</p>

<div><pre><code>100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt
100664 blob d8263ee9860594d2806b0dfd1bfd17528b0ba2a4 number.txt
</code></pre></div>
<p>The new <code>data</code> tree hashes to a different value from the old <code>data</code> tree.  A new <code>root</code> tree must be created to record this hash:</p>

<div><pre><code>040000 tree 40b0318811470aaacc577485777d7a6780e51f0b data
</code></pre></div>
<p>Second, a new commit object is created.</p>

<div><pre><code>tree ce72afb5ff229a39f6cce47b00d1b0ed60fe3556
parent 774b54a193d6cfdd081e581a007d2e11f784b9fe
author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500
committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500

a2
</code></pre></div>
<p>The first line of the commit object points at the new <code>root</code> tree object. The second line points at <code>a1</code>: the commit’s parent. To find the parent commit, Git went to <code>HEAD</code>, followed it to <code>master</code> and found the commit hash of <code>a1</code>.</p>

<p>Third, the content of the <code>master</code> branch file is set to the hash of the new commit.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/7-a2.png" alt="`a2` commit"/></p>
<p>`a2` commit</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/8-a2-just-objects-commits-and-refs.png" alt="Git graph without the working copy and index"/></p>
<p>Git graph without the working copy and index</p>

<p><strong>Graph property</strong>: content is stored as a tree of objects. This means that only diffs are stored in the objects database. Look at the graph above. The <code>a2</code> commit reuses the <code>a</code> blob that was made before the <code>a1</code> commit. Similarly, if a whole directory doesn’t change from commit to commit, its tree and all the blobs and trees below it can be reused. Generally, there are few content changes from commit to commit. This means that Git can store large commit histories in a small amount of space.</p>

<p><strong>Graph property</strong>: each commit has a parent. This means that a repository can store the history of a project.</p>

<p><strong>Graph property</strong>: refs are entry points to one part of the commit history or another. This means that commits can be given meaningful names. The user organizes their work into lineages that are meaningful to their project with concrete refs like <code>fix-for-bug-376</code>. Git uses symbolic refs like <code>HEAD</code>, <code>MERGE_HEAD</code> and <code>FETCH_HEAD</code> to support commands that manipulate the commit history.</p>

<p><strong>Graph property</strong>: the nodes in the <code>objects/</code> directory are immutable. This means that content is edited, not deleted. Every piece of content ever added and every commit ever made is somewhere in the <code>objects</code> directory<sup id="fnref:3"><a href="#fn:3">3</a></sup>.</p>

<p><strong>Graph property</strong>: refs are mutable. Therefore, the meaning of a ref can change. The commit that <code>master</code> points at might be the best version of a project at the moment, but, soon enough, it will be superseded by a newer and better commit.</p>

<p><strong>Graph property</strong>: the working copy and the commits pointed at by refs are readily available, but other commits are not. This means that recent history is easier to recall, but that it also changes more often. Or: Git has a fading memory that must be jogged with increasingly vicious prods.</p>

<p>The working copy is the easiest point in history to recall because it is in the root of the repository. Recalling it doesn’t even require a Git command. It is also the least permanent point in history. The user can make a dozen versions of a file but Git won’t record any of them unless they are added.</p>

<p>The commit that <code>HEAD</code> points at is very easy to recall. It is at the tip of the branch that is checked out. To see its content, the user can just stash<sup id="fnref:4"><a href="#fn:4">4</a></sup> and then examine the working copy. At the same time, <code>HEAD</code> is the most frequently changing ref.</p>

<p>The commit that a concrete ref points at is easy to recall. The user can simply check out that branch. The tip of a branch changes less often than <code>HEAD</code>, but often enough for the meaning of a branch name to be changeable.</p>

<p>It is difficult to recall a commit that is not pointed at by any ref.  The further the user goes from a ref, the harder it will be for them to construct the meaning of a commit. But the further back they go, the less likely it is that someone will have changed history since they last looked<sup id="fnref:5"><a href="#fn:5">5</a></sup>.</p>

<h2 id="check-out-a-commit">Check out a commit</h2>

<div><pre><code>~/alpha $ git checkout 37888c2
          You are in &#39;detached HEAD&#39; state...
</code></pre></div>
<p>The user checks out the <code>a2</code> commit using its hash. (If you are running these Git commands, this one won’t work. Use <code>git log</code> to find the hash of your <code>a2</code> commit.)</p>

<p>Checking out has four steps.</p>

<p>First, Git gets the <code>a2</code> commit and gets the tree graph it points at.</p>

<p>Second, it writes the file entries in the tree graph to the working copy. This results in no changes. The working copy already has the content of the tree graph being written to it because <code>HEAD</code> was already pointing via <code>master</code> at the <code>a2</code> commit.</p>

<p>Third, Git writes the file entries in the tree graph to the index. This, too, results in no changes. The index already has the content of the <code>a2</code> commit.</p>

<p>Fourth, the content of <code>HEAD</code> is set to the hash of the <code>a2</code> commit:</p>

<div><pre><code>f0af7e62679e144bb28c627ee3e8f7bdb235eee9
</code></pre></div>
<p>Setting the content of <code>HEAD</code> to a hash puts the repository in the detached <code>HEAD</code> state. Notice in the graph below that <code>HEAD</code> points directly at the <code>a2</code> commit, rather than pointing at <code>master</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/9-a2-detached-head.png" alt="Detached `HEAD` on `a2` commit"/></p>
<p>Detached `HEAD` on `a2` commit</p>

<div><pre><code>~/alpha $ printf &#39;3&#39; &gt; data/number.txt
~/alpha $ git add data/number.txt
~/alpha $ git commit -m &#39;a3&#39;
          [detached HEAD 3645a0e] a3
</code></pre></div>
<p>The user sets the content of <code>data/number.txt</code> to <code>3</code> and commits the change. Git goes to <code>HEAD</code> to get the parent of the <code>a3</code> commit.  Instead of finding and following a branch ref, it finds and returns the hash of the <code>a2</code> commit.</p>

<p>Git updates <code>HEAD</code> to point directly at the hash of the new <code>a3</code> commit. The repository is still in the detached <code>HEAD</code> state. It is not on a branch because no commit points at either <code>a3</code> or one of its descendants. This means it is easy to lose.</p>

<p>From now on, trees and blobs will mostly be omitted from the graph diagrams.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/10-a3-detached-head.png" alt="`a3` commit that is not on a branch"/></p>
<p>`a3` commit that is not on a branch</p>

<h2 id="create-a-branch">Create a branch</h2>

<div><pre><code>~/alpha $ git branch deputy
</code></pre></div>
<p>The user creates a new branch called <code>deputy</code>. This just creates a new file at <code>.git/refs/heads/deputy</code> that contains the hash that <code>HEAD</code> is pointing at: the hash of the <code>a3</code> commit.</p>

<p><strong>Graph property</strong>: branches are just refs and refs are just files. This means that Git branches are lightweight.</p>

<p>The creation of the <code>deputy</code> branch puts the new <code>a3</code> commit safely on a branch. <code>HEAD</code> is still detached because it still points directly at a commit.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/11-a3-on-deputy.png" alt="`a3` commit now on the `deputy` branch"/></p>
<p>`a3` commit now on the `deputy` branch</p>

<h2 id="check-out-a-branch">Check out a branch</h2>

<div><pre><code>~/alpha $ git checkout master
          Switched to branch &#39;master&#39;
</code></pre></div>
<p>The user checks out the <code>master</code> branch.</p>

<p>First, Git gets the <code>a2</code> commit that <code>master</code> points at and gets the tree graph the commit points at.</p>

<p>Second, Git writes the file entries in the tree graph to the files of the working copy. This sets the content of <code>data/number.txt</code> to <code>2</code>.</p>

<p>Third, Git writes the file entries in the tree graph to the index. This updates the entry for <code>data/number.txt</code> to the hash of the <code>2</code> blob.</p>

<p>Fourth, Git points <code>HEAD</code> at <code>master</code> by changing its content from a hash to:</p>


<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/12-a3-on-master-on-a2.png" alt="`master` checked out and pointing at the `a2` commit"/></p>
<p>`master` checked out and pointing at the `a2` commit</p>

<h2 id="check-out-a-branch-that-is-incompatible-with-the-working-copy">Check out a branch that is incompatible with the working copy</h2>

<div><pre><code>~/alpha $ printf &#39;789&#39; &gt; data/number.txt
~/alpha $ git checkout deputy
          Your changes to these files would be overwritten
          by checkout:
            data/number.txt
          Commit your changes or stash them before you
          switch branches.
</code></pre></div>
<p>The user accidentally sets the content of <code>data/number.txt</code> to <code>789</code>. They try to check out <code>deputy</code>. Git prevents the check out.</p>

<p><code>HEAD</code> points at <code>master</code> which points at <code>a2</code> where <code>data/number.txt</code> reads <code>2</code>. <code>deputy</code> points at <code>a3</code> where <code>data/number.txt</code> reads <code>3</code>. The working copy version of <code>data/number.txt</code> reads <code>789</code>. All these versions are different and the differences must be resolved.</p>

<p>Git could replace the working copy version of <code>data/number.txt</code> with the version in the commit being checked out.  But it avoids data loss at all costs.</p>

<p>Git could merge the working copy version with the version being checked out.  But this is complicated.</p>

<p>So, Git aborts the check out.</p>

<div><pre><code>~/alpha $ printf &#39;2&#39; &gt; data/number.txt
~/alpha $ git checkout deputy
          Switched to branch &#39;deputy&#39;
</code></pre></div>
<p>The user notices that they accidentally edited <code>data/number.txt</code> and sets the content back to <code>2</code>. They check out <code>deputy</code> successfully.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/13-a3ondeputy.png" alt="`deputy` checked out"/></p>
<p>`deputy` checked out</p>

<h2 id="merge-an-ancestor">Merge an ancestor</h2>

<div><pre><code>~/alpha $ git merge master
          Already up-to-date.
</code></pre></div>
<p>The user merges <code>master</code> into <code>deputy</code>. Merging two branches means merging two commits. The first commit is the one that <code>deputy</code> points at: the receiver. The second commit is the one that <code>master</code> points at: the giver. For this merge, Git does nothing. It reports it is <code>Already up-to-date.</code>.</p>

<p><strong>Graph property</strong>: the series of commits in the graph are interpreted as a series of changes made to the content of the repository. This means that, in a merge, if the giver commit is an ancestor of the receiver commit, Git will do nothing. Those changes have already been incorporated.</p>

<h2 id="merge-a-descendent">Merge a descendent</h2>

<div><pre><code>~/alpha $ git checkout master
          Switched to branch &#39;master&#39;
</code></pre></div>
<p>The user checks out <code>master</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/14-a3-on-master-on-a2.png" alt="`master` checked out and pointing at the `a2` commit"/></p>
<p>`master` checked out and pointing at the `a2` commit</p>

<div><pre><code>~/alpha $ git merge deputy
          Fast-forward
</code></pre></div>
<p>They merge <code>deputy</code> into <code>master</code>. Git discovers that the receiver commit, <code>a2</code>, is an ancestor of the giver commit, <code>a3</code>. It can do a fast-forward merge.</p>

<p>It gets the giver commit and gets the tree graph that it points at. It writes the file entries in the tree graph to the working copy and the index. It “fast-forwards” <code>master</code> to point at <code>a3</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/15-a3-on-master.png" alt="`a3` commit from `deputy` fast-forward merged into `master`"/></p>
<p>`a3` commit from `deputy` fast-forward merged into `master`</p>

<p><strong>Graph property</strong>: the series of commits in the graph are interpreted as a series of changes made to the content of the repository. This means that, in a merge, if the giver is a descendent of the receiver, history is not changed. There is already a sequence of commits that describe the change to make: the sequence of commits between the receiver and the giver. But, though the Git history doesn’t change, the Git graph does change. The concrete ref that <code>HEAD</code> points at is updated to point at the giver commit.</p>

<h2 id="merge-two-commits-from-different-lineages">Merge two commits from different lineages</h2>

<div><pre><code>~/alpha $ printf &#39;4&#39; &gt; data/number.txt
~/alpha $ git add data/number.txt
~/alpha $ git commit -m &#39;a4&#39;
          [master 7b7bd9a] a4
</code></pre></div>
<p>The user sets the content of <code>number.txt</code> to <code>4</code> and commits the change to <code>master</code>.</p>

<div><pre><code>~/alpha $ git checkout deputy
          Switched to branch &#39;deputy&#39;
~/alpha $ printf &#39;b&#39; &gt; data/letter.txt
~/alpha $ git add data/letter.txt
~/alpha $ git commit -m &#39;b3&#39;
          [deputy 982dffb] b3
</code></pre></div>
<p>The user checks out <code>deputy</code>. They set the content of <code>data/letter.txt</code> to <code>b</code> and commit the change to <code>deputy</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/16-a4-b3-on-deputy.png" alt="`a4` committed to `master`, `b3` committed to `deputy` and `deputy` checked out"/></p>
<p>`a4` committed to `master`, `b3` committed to `deputy` and `deputy` checked out</p>

<p><strong>Graph property</strong>: commits can share parents. This means that new lineages can be created in the commit history.</p>

<p><strong>Graph property</strong>: commits can have multiple parents. This means that separate lineages can be joined by a commit with two parents: a merge commit.</p>

<div><pre><code>~/alpha $ git merge master -m &#39;b4&#39;
          Merge made by the &#39;recursive&#39; strategy.
</code></pre></div>
<p>The user merges <code>master</code> into <code>deputy</code>.</p>

<p>Git discovers that the receiver, <code>b3</code>, and the giver, <code>a4</code>, are in different lineages. It makes a merge commit. This process has eight steps.</p>

<p>First, Git writes the hash of the giver commit to a file at <code>alpha/.git/MERGE_HEAD</code>. The presence of this file tells Git it is in the middle of merging.</p>

<p>Second, Git finds the base commit: the most recent ancestor that the receiver and giver commits have in common.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/17-a4-b3-on-deputy.png" alt="`a3`, the base commit of `a4` and `b3`"/></p>
<p>`a3`, the base commit of `a4` and `b3`</p>

<p><strong>Graph property</strong>: commits have parents. This means that it is possible to find the point at which two lineages diverged. Git traces backwards from <code>b3</code> to find all its ancestors and backwards from <code>a4</code> to find all its ancestors. It finds the most recent ancestor shared by both lineages, <code>a3</code>. This is the base commit.</p>

<p>Third, Git generates the indices for the base, receiver and giver commits from their tree graphs.</p>

<p>Fourth, Git generates a diff that combines the changes made to the base by the receiver commit and the giver commit. This diff is a list of file paths that point to a change: add, remove, modify or conflict.</p>

<p>Git gets the list of all the files that appear in the base, receiver or giver indices. For each one, it compares the index entries to decide the change to make to the file. It writes a corresponding entry to the diff. In this case, the diff has two entries.</p>

<p>The first entry is for <code>data/letter.txt</code>. The content of this file is <code>a</code> in the base, <code>b</code> in the receiver and <code>a</code> in the giver. The content is different in the base and receiver. But it is the same in the base and giver. Git sees that the content was modified by the receiver, but not the giver. The diff entry for <code>data/letter.txt</code> is a modification, not a conflict.</p>

<p>The second entry in the diff is for <code>data/number.txt</code>. In this case, the content is the same in the base and receiver, and different in the giver. The diff entry for <code>data/letter.txt</code> is also a modification.</p>

<p><strong>Graph property</strong>: it is possible to find the base commit of a merge. This means that, if a file has changed from the base in just the receiver or giver, Git can automatically resolve the merge of that file. This reduces the work the user must do.</p>

<p>Fifth, the changes indicated by the entries in the diff are applied to the working copy. The content of <code>data/letter.txt</code> is set to <code>b</code> and the content of <code>data/number.txt</code> is set to <code>4</code>.</p>

<p>Sixth, the changes indicated by the entries in the diff are applied to the index. The entry for <code>data/letter.txt</code> is pointed at the <code>b</code> blob and the entry for <code>data/number.txt</code> is pointed at the <code>4</code> blob.</p>

<p>Seventh, the updated index is committed:</p>

<div><pre><code>tree 20294508aea3fb6f05fcc49adaecc2e6d60f7e7d
parent 982dffb20f8d6a25a8554cc8d765fb9f3ff1333b
parent 7b7bd9a5253f47360d5787095afc5ba56591bfe7
author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500
committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500

b4
</code></pre></div>
<p>Notice that the commit has two parents.</p>

<p>Eighth, Git points the current branch, <code>deputy</code>, at the new commit.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/18-b4-on-deputy.png" alt="`b4`, the merge commit resulting from the recursive merge of `a4` into `b3`"/></p>
<p>`b4`, the merge commit resulting from the recursive merge of `a4` into `b3`</p>

<h2 id="merge-two-commits-from-different-lineages-that-both-modify-the-same-file">Merge two commits from different lineages that both modify the same file</h2>

<div><pre><code>~/alpha $ git checkout master
          Switched to branch &#39;master&#39;
~/alpha $ git merge deputy
          Fast-forward
</code></pre></div>
<p>The user checks out <code>master</code>. They merge <code>deputy</code> into <code>master</code>. This fast-forwards <code>master</code> to the <code>b4</code> commit. <code>master</code> and <code>deputy</code> now point at the same commit.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/19-b4-master-deputy-on-b4.png" alt="`deputy` merged into `master` to bring `master` up to the latest commit, `b4`"/></p>
<p>`deputy` merged into `master` to bring `master` up to the latest commit, `b4`</p>

<div><pre><code>~/alpha $ git checkout deputy
          Switched to branch &#39;deputy&#39;
~/alpha $ printf &#39;5&#39; &gt; data/number.txt
~/alpha $ git add data/number.txt
~/alpha $ git commit -m &#39;b5&#39;
          [deputy bd797c2] b5
</code></pre></div>
<p>The user checks out <code>deputy</code>. They set the content of <code>data/number.txt</code> to <code>5</code> and commit the change to <code>deputy</code>.</p>

<div><pre><code>~/alpha $ git checkout master
          Switched to branch &#39;master&#39;
~/alpha $ printf &#39;6&#39; &gt; data/number.txt
~/alpha $ git add data/number.txt
~/alpha $ git commit -m &#39;b6&#39;
          [master 4c3ce18] b6
</code></pre></div>
<p>The user checks out <code>master</code>. They set the content of <code>data/number.txt</code> to <code>6</code> and commit the change to <code>master</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/20-b5-on-deputy-b6-on-master.png" alt="`b5` commit on `deputy` and `b6` commit on `master`"/></p>
<p>`b5` commit on `deputy` and `b6` commit on `master`</p>

<div><pre><code>~/alpha $ git merge deputy
          CONFLICT in data/number.txt
          Automatic merge failed; fix conflicts and
          commit the result.
</code></pre></div>
<p>The user merges <code>deputy</code> into <code>master</code>. There is a conflict and the merge is paused. The process for a conflicted merge follows the same first six steps as the process for an unconflicted merge: set <code>.git/MERGE_HEAD</code>, find the base commit, generate the indices of the base, receiver and giver commits, create a diff, update the working copy and update the index. Because of the conflict, the seventh commit step and eighth ref update step are never taken. Let’s go through the steps again and see what happens.</p>

<p>First, Git writes the hash of the giver commit to a file at <code>.git/MERGE_HEAD</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/21-b6-on-master-with-merge-head.png" alt="`MERGE_HEAD` written during merge of `b5` into `b6`"/></p>
<p>`MERGE_HEAD` written during merge of `b5` into `b6`</p>

<p>Second, Git finds the base commit, <code>b4</code>.</p>

<p>Third, Git generates the indices for the base, receiver and giver commits.</p>

<p>Fourth, Git generates a diff that combines the changes made to the base by the receiver commit and the giver commit. This diff is a list of file paths that point to a change: add, remove, modify or conflict.</p>

<p>In this case, the diff contains only one entry: <code>data/number.txt</code>. The entry is marked as a conflict because the content for <code>data/number.txt</code> is different in the receiver, giver and base.</p>

<p>Fifth, the changes indicated by the entries in the diff are applied to the working copy. For a conflicted area, Git writes both versions to the file in the working copy. The content of <code>data/number.txt</code> is set to:</p>

<div><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
6
=======
5
&gt;&gt;&gt;&gt;&gt;&gt;&gt; deputy
</code></pre></div>
<p>Sixth, the changes indicated by the entries in the diff are applied to the index. Entries in the index are uniquely identified by a combination of their file path and stage. The entry for an unconflicted file has a stage of <code>0</code>. Before this merge, the index looked like this, where the <code>0</code>s are stage values:</p>

<div><pre><code>0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748
0 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb
</code></pre></div>
<p>After the merge diff is written to the index, the index looks like this:</p>

<div><pre><code>0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748
1 data/number.txt bf0d87ab1b2b0ec1a11a3973d2845b42413d9767
2 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb
3 data/number.txt 7813681f5b41c028345ca62a2be376bae70b7f61
</code></pre></div>
<p>The entry for <code>data/letter.txt</code> at stage <code>0</code> is the same as it was before the merge. The entry for <code>data/number.txt</code> at stage <code>0</code> is gone. There are three new entries in its place. The entry for stage <code>1</code> has the hash of the base <code>data/number.txt</code> content. The entry for stage <code>2</code> has the hash of the receiver <code>data/number.txt</code> content. The entry for stage <code>3</code> has the hash of the giver <code>data/number.txt</code> content. The presence of these three entries tells Git that <code>data/number.txt</code> is in conflict.</p>

<p>The merge pauses.</p>

<div><pre><code>~/alpha $ printf &#39;11&#39; &gt; data/number.txt
~/alpha $ git add data/number.txt
</code></pre></div>
<p>The user integrates the content of the two conflicting versions by setting the content of <code>data/number.txt</code> to <code>11</code>. They add the file to the index.  Git adds a blob containing <code>11</code>. Adding a conflicted file tells Git that the conflict is resolved. Git removes the <code>data/number.txt</code> entries for stages <code>1</code>, <code>2</code> and <code>3</code> from the index.  It adds an entry for <code>data/number.txt</code> at stage <code>0</code> with the hash of the new blob. The index now reads:</p>

<div><pre><code>0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748
0 data/number.txt 9d607966b721abde8931ddd052181fae905db503
</code></pre></div>
<div><pre><code>~/alpha $ git commit -m &#39;b11&#39;
          [master 251a513] b11
</code></pre></div>
<p>Seventh, the user commits. Git sees <code>.git/MERGE_HEAD</code> in the repository, which tells it that a merge is in progress. It checks the index and finds there are no conflicts. It creates a new commit, <code>b11</code>, to record the content of the resolved merge. It deletes the file at <code>.git/MERGE_HEAD</code>. This completes the merge.</p>

<p>Eighth, Git points the current branch, <code>master</code>, at the new commit.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/22-b11-on-master.png" alt="`b11`, the merge commit resulting from the conflicted, recursive merge of `b5` into `b6`"/></p>
<p>`b11`, the merge commit resulting from the conflicted, recursive merge of `b5` into `b6`</p>

<h2 id="remove-a-file">Remove a file</h2>

<p>This diagram of the Git graph includes the commit history, the trees and blobs for the latest commit, and the working copy and index:</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/23-b11-with-objects-wc-and-index.png" alt="The working copy, index, `b11` commit and its tree graph"/></p>
<p>The working copy, index, `b11` commit and its tree graph</p>

<div><pre><code>~/alpha $ git rm data/letter.txt
          rm &#39;data/letter.txt&#39;
</code></pre></div>
<p>The user tells Git to remove <code>data/letter.txt</code>.  The file is deleted from the working copy. The entry is deleted from the index.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/24-b11-letter-removed-from-wc-and-index.png" alt="After `data/letter.txt` `rm`ed from working copy and index"/></p>
<p>After `data/letter.txt` `rm`ed from working copy and index</p>

<div><pre><code>~/alpha $ git commit -m &#39;11&#39;
          [master d14c7d2] 11
</code></pre></div>
<p>The user commits. As part of the commit, as always, Git builds a tree graph that represents the content of the index. <code>data/letter.txt</code> is not included in the tree graph because it is not in the index.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/25-11.png" alt="`11` commit made after `data/letter.txt` `rm`ed"/></p>
<p>`11` commit made after `data/letter.txt` `rm`ed</p>

<h2 id="copy-a-repository">Copy a repository</h2>

<div><pre><code>~/alpha $ cd ..
      ~ $ cp -R alpha bravo
</code></pre></div>
<p>The user copies the contents of the <code>alpha/</code> repository to the <code>bravo/</code> directory. This produces the following directory structure:</p>

<div><pre><code>~
├── alpha
|   └── data
|       └── number.txt
└── bravo
    └── data
        └── number.txt
</code></pre></div>
<p>There is now another Git graph in the <code>bravo</code> directory:</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/26-11-cp-alpha-to-bravo.png" alt="New graph created when `alpha` `cp`ed to `bravo`"/></p>
<p>New graph created when `alpha` `cp`ed to `bravo`</p>

<h2 id="link-a-repository-to-another-repository">Link a repository to another repository</h2>

<div><pre><code>      ~ $ cd alpha
~/alpha $ git remote add bravo ../bravo
</code></pre></div>
<p>The user moves back into the <code>alpha</code> repository. They set up <code>bravo</code> as a remote repository on <code>alpha</code>. This adds some lines to the file at <code>alpha/.git/config</code>:</p>

<div><pre><code>[remote &#34;bravo&#34;]
	url = ../bravo/
</code></pre></div>
<p>These lines specify that there is a remote repository called <code>bravo</code> in the directory at <code>../bravo</code>.</p>

<h2 id="fetch-a-branch-from-a-remote">Fetch a branch from a remote</h2>

<div><pre><code>~/alpha $ cd ../bravo
~/bravo $ printf &#39;12&#39; &gt; data/number.txt
~/bravo $ git add data/number.txt
~/bravo $ git commit -m &#39;12&#39;
          [master 94cd04d] 12
</code></pre></div>
<p>The user goes into the <code>bravo</code> repository. They set the content of <code>data/number.txt</code> to <code>12</code> and commit the change to <code>master</code> on <code>bravo</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/27-12-bravo.png" alt="`12` commit on `bravo` repository"/></p>
<p>`12` commit on `bravo` repository</p>

<div><pre><code>~/bravo $ cd ../alpha
~/alpha $ git fetch bravo master
          Unpacking objects: 100%
          From ../bravo
            * branch master -&gt; FETCH_HEAD
</code></pre></div>
<p>The user goes into the <code>alpha</code> repository. They fetch <code>master</code> from <code>bravo</code> into <code>alpha</code>. This process has four steps.</p>

<p>First, Git gets the hash of the commit that master is pointing at on <code>bravo</code>. This is the hash of the <code>12</code> commit.</p>

<p>Second, Git makes a list of all the objects that the <code>12</code> commit depends on: the commit object itself, the objects in its tree graph, the ancestor commits of the <code>12</code> commit and the objects in their tree graphs. It removes from this list any objects that the <code>alpha</code> object database already has.  It copies the rest to <code>alpha/.git/objects/</code>.</p>

<p>Third, the content of the concrete ref file at <code>alpha/.git/refs/remotes/bravo/master</code> is set to the hash of the <code>12</code> commit.</p>

<p>Fourth, the content of <code>alpha/.git/FETCH_HEAD</code> is set to:</p>

<div><pre><code>94cd04d93ae88a1f53a4646532b1e8cdfbc0977f branch &#39;master&#39; of ../bravo
</code></pre></div>
<p>This indicates that the most recent fetch command fetched the <code>12</code> commit of <code>master</code> from <code>bravo</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/28-12-fetched-to-alpha.png" alt="`alpha` after `bravo/master` fetched"/></p>
<p>`alpha` after `bravo/master` fetched</p>

<p><strong>Graph property</strong>: objects can be copied. This means that history can be shared between repositories.</p>

<p><strong>Graph property</strong>: a repository can store remote branch refs like <code>alpha/.git/refs/remotes/bravo/master</code>. This means that a repository can record locally the state of a branch on a remote repository. It is correct at the time it is fetched but will go out of date if the remote branch changes.</p>

<h2 id="merge-fetch_head">Merge FETCH_HEAD</h2>

<div><pre><code>~/alpha $ git merge FETCH_HEAD
          Updating d14c7d2..94cd04d
          Fast-forward
</code></pre></div>
<p>The user merges <code>FETCH_HEAD</code>. <code>FETCH_HEAD</code> is just another ref. It resolves to the <code>12</code> commit, the giver. <code>HEAD</code> points at the <code>11</code> commit, the receiver. Git does a fast-forward merge and points <code>master</code> at the <code>12</code> commit.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/29-12-merged-to-alpha.png" alt="`alpha` after `FETCH_HEAD` merged"/></p>
<p>`alpha` after `FETCH_HEAD` merged</p>

<h2 id="pull-a-branch-from-a-remote">Pull a branch from a remote</h2>

<div><pre><code>~/alpha $ git pull bravo master
          Already up-to-date.
</code></pre></div>
<p>The user pulls <code>master</code> from <code>bravo</code> into <code>alpha</code>. Pull is shorthand for “fetch and merge <code>FETCH_HEAD</code>”. Git does these two commands and reports that <code>master</code> is <code>Already up-to-date</code>.</p>

<h2 id="clone-a-repository">Clone a repository</h2>

<div><pre><code>~/alpha $ cd ..
      ~ $ git clone alpha charlie
          Cloning into &#39;charlie&#39;
</code></pre></div>
<p>The user moves into the directory above. They clone <code>alpha</code> to <code>charlie</code>. Cloning to <code>charlie</code> has similar results to the <code>cp</code> the user did to produce the <code>bravo</code> repository. Git creates a new directory called <code>charlie</code>. It inits <code>charlie</code> as a Git repo, adds <code>alpha</code> as a remote called <code>origin</code>, fetches <code>origin</code> and merges <code>FETCH_HEAD</code>.</p>

<h2 id="push-a-branch-to-a-checked-out-branch-on-a-remote">Push a branch to a checked-out branch on a remote</h2>

<div><pre><code>      ~ $ cd alpha
~/alpha $ printf &#39;13&#39; &gt; data/number.txt
~/alpha $ git add data/number.txt
~/alpha $ git commit -m &#39;13&#39;
          [master 3238468] 13
</code></pre></div>
<p>The user goes back into the <code>alpha</code> repository. They set the content of <code>data/number.txt</code> to <code>13</code> and commit the change to <code>master</code> on <code>alpha</code>.</p>

<div><pre><code>~/alpha $ git remote add charlie ../charlie
</code></pre></div>
<p>They set up <code>charlie</code> as a remote repository on <code>alpha</code>.</p>

<div><pre><code>~/alpha $ git push charlie master
          Writing objects: 100%
          remote error: refusing to update checked out
          branch: refs/heads/master because it will make
          the index and work tree inconsistent
</code></pre></div>
<p>They push <code>master</code> to <code>charlie</code>.</p>

<p>All the objects required for the <code>13</code> commit are copied to <code>charlie</code>.</p>

<p>At this point, the push process stops. Git, as ever, tells the user what went wrong. It refuses to push to a branch that is checked out on the remote. This makes sense. A push would update the remote index and <code>HEAD</code>. This would cause confusion if someone were editing the working copy on the remote.</p>

<p>At this point, the user could make a new branch, merge the <code>13</code> commit into it and push that branch to <code>charlie</code>. But, really, they want a repository that they can push to whenever they want. They want a central repository that they can push to and pull from, but that no one commits to directly. They want something like a GitHub remote. They want a bare repository.</p>

<h2 id="clone-a-bare-repository">Clone a bare repository</h2>

<div><pre><code>~/alpha $ cd ..
      ~ $ git clone alpha delta --bare
          Cloning into bare repository &#39;delta&#39;
</code></pre></div>
<p>The user moves into the directory above. They clone <code>delta</code> as a bare repository. This is an ordinary clone with two differences. The <code>config</code> file indicates that the repository is bare. And the files that are normally stored in the <code>.git</code> directory are stored in the root of the repository:</p>

<div><pre><code>delta
├── HEAD
├── config
├── objects
└── refs
</code></pre></div>
<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/30-13-alpha-cloned-to-delta-bare.png" alt="`alpha` and `delta` graphs after `alpha` cloned to `delta`"/></p>
<p>`alpha` and `delta` graphs after `alpha` cloned to `delta`</p>

<h2 id="push-a-branch-to-a-bare-repository">Push a branch to a bare repository</h2>

<div><pre><code>      ~ $ cd alpha
~/alpha $ git remote add delta ../delta
</code></pre></div>
<p>The user goes back into the <code>alpha</code> repository. They set up <code>delta</code> as a remote repository on <code>alpha</code>.</p>

<div><pre><code>~/alpha $ printf &#39;14&#39; &gt; data/number.txt
~/alpha $ git add data/number.txt
~/alpha $ git commit -m &#39;14&#39;
          [master cb51da8] 14
</code></pre></div>
<p>They set the content of <code>data/number.txt</code> to <code>14</code> and commit the change to <code>master</code> on <code>alpha</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/31-14-alpha.png" alt="`14` commit on `alpha`"/></p>
<p>`14` commit on `alpha`</p>

<div><pre><code>~/alpha $ git push delta master
          Writing objects: 100%
          To ../delta
            3238468..cb51da8 master -&gt; master
</code></pre></div>
<p>They push <code>master</code> to <code>delta</code>. Pushing has three steps.</p>

<p>First, all the objects required for the <code>14</code> commit on the <code>master</code> branch are copied from <code>alpha/.git/objects/</code> to <code>delta/objects/</code>.</p>

<p>Second, <code>delta/refs/heads/master</code> is updated to point at the <code>14</code> commit.</p>

<p>Third, <code>alpha/.git/refs/remotes/delta/master</code> is set to point at the <code>14</code> commit. <code>alpha</code> has an up-to-date record of the state of <code>delta</code>.</p>

<p><img src="https://donnywinston.com/images/two/git-from-the-inside-out/32-14-pushed-to-delta.png" alt="`14` commit pushed from `alpha` to `delta`"/></p>
<p>`14` commit pushed from `alpha` to `delta`</p>

<h2 id="summary">Summary</h2>

<p>Git is built on a graph. Almost every Git command manipulates this graph. To understand Git deeply, focus on the properties of this graph, not workflows or commands.</p>

<p>To learn more about Git, investigate the <code>.git</code> directory. It’s not scary. Look inside. Change the content of files and see what happens. Create a commit by hand. Try and see how badly you can mess up a repo. Then repair it.</p>



  </article></div>
  </body>
</html>
