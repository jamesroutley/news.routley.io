<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://roman.pt/posts/dont-let-dicts-spoil-your-code/">Original</a>
    <h1>Don&#39;t let dicts spoil your code (2020)</h1>
    
    <div id="readability-page-1" class="page"><div><figure><img src="https://roman.pt/posts/dont-let-dicts-spoil-your-code/splash_hued0d13a2034a04fbb4bcad55138bdafa_423992_1000x400_fill_q75_box_smart1.jpg" width="1000" alt="Balance"/><figcaption>Photo by <a href="https://unsplash.com/@martinsanchez">Martin Sanchez</a></figcaption></figure><p>How often do your simple prototypes or ad-hoc scripts turn into fully-fledged applications?</p><p>The simplicity of organic code growth has a flip side: it becomes too hard to maintain. The proliferation of dicts as primary data structures is a clear signal of tech debt in your code. Fortunately, modern Python provides many viable alternatives to plain dicts.</p><h2 id="whats-wrong-with-dicts">What’s wrong with dicts?</h2><h3 id="dicts-are-opaque">Dicts are opaque</h3><p>Functions that accept dicts are a nightmare to extend and modify. Usually, to change the function that takes a dictionary, you must manually trace the calls back to the roots, where this dict was created. There is often more than one call path, and if a program grows without a plan, you’ll likely have discrepancies in the dict structures.</p><h3 id="dicts-are-mutable">Dicts are mutable</h3><p>Changing dict values to fit a specific workflow is tempting, and programmers often abuse this functionality. In-place mutations may have different names: pre-processing, populating, enriching, data massage, etc. The result is the same. This manipulation hinders the structure of your data and makes it dependent on the workflow of your application.</p><p>Not only do dicts allow you to change their data, but they also allow you to change the very structure of objects. You can add or delete fields or change their types at will. Resorting to this is the worst felony you can commit to your data.</p><h2 id="treat-dicts-as-the-wire-format">Treat dicts as the wire format</h2><p>A common source of dicts in the code is deserializing from JSON. For example, from a third-party API response.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> requests<span>.</span>get(<span>&#34;https://api.github.com/repos/imankulov/empty&#34;</span>)<span>.</span>json()
</span></span><span><span>{<span>&#39;id&#39;</span>: <span>297081773</span>,
</span></span><span><span> <span>&#39;node_id&#39;</span>: <span>&#39;MDEwOlJlcG9zaXRvcnkyOTcwODE3NzM=&#39;</span>,
</span></span><span><span> <span>&#39;name&#39;</span>: <span>&#39;empty&#39;</span>,
</span></span><span><span> <span>&#39;full_name&#39;</span>: <span>&#39;imankulov/empty&#39;</span>,
</span></span><span><span> <span>&#39;private&#39;</span>: <span>False</span>,
</span></span><span><span><span>...</span>
</span></span><span><span>}
</span></span></code></pre></div><p><em>A dict, returned from the API.</em></p><p>Make a habit of treating dicts as a “wire format” and convert them immediately to data structures providing semantics.</p><figure><img src="https://roman.pt/posts/dont-let-dicts-spoil-your-code/serializer-deserializer.png" alt="Use serializer and deserializer to convert between wire format and internal representation" width="600"/><figcaption><p>Use serializer and deserializer to convert between wire format and internal representation</p></figcaption></figure><p>The implementation is straightforward.</p><ul><li>Define your domain models. A domain model is simply a class in your application.</li><li>Fetch and deserialize in the same step.</li></ul><p>In Domain-Driven Design (DDD), this pattern is known as the anti-corruption layer. On top of semantic clarity, domain models provide a natural layer that decouples the exterior architecture from your application’s business logic.</p><p>Two implementations of a function retrieving repository info from GitHub:</p><div><p><i data-feather="alert-octagon"></i>
Returning a dict</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>requests</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>get_repo</span>(repo_name: <span>str</span>):
</span></span><span><span>    <span>&#34;&#34;&#34;Return repository info by its name.&#34;&#34;&#34;</span>
</span></span><span><span>    <span>return</span> requests<span>.</span>get(<span>f</span><span>&#34;https://api.github.com/repos/</span><span>{</span>repo_name<span>}</span><span>&#34;</span>)<span>.</span>json()
</span></span></code></pre></div><p>The output of the function is opaque and needlessly verbose. The format is defined outside of your code.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> get_repo(<span>&#34;imankulov/empty&#34;</span>)
</span></span><span><span>{<span>&#39;id&#39;</span>: <span>297081773</span>,
</span></span><span><span> <span>&#39;node_id&#39;</span>: <span>&#39;MDEwOlJlcG9zaXRvcnkyOTcwODE3NzM=&#39;</span>,
</span></span><span><span> <span>&#39;name&#39;</span>: <span>&#39;empty&#39;</span>,
</span></span><span><span> <span>&#39;full_name&#39;</span>: <span>&#39;imankulov/empty&#39;</span>,
</span></span><span><span> <span>&#39;private&#39;</span>: <span>False</span>,
</span></span><span><span> <span># Dozens of lines with unnecessary attributes, URLs, etc.</span>
</span></span><span><span> <span># ...</span>
</span></span><span><span>}
</span></span></code></pre></div></div><div><p><i data-feather="check-square"></i>
Returning a domain model</p><div><pre tabindex="0"><code data-lang="python"><span><span>
</span></span><span><span><span>class</span> <span>GitHubRepo</span>:
</span></span><span><span>    <span>&#34;&#34;&#34;GitHub repository.&#34;&#34;&#34;</span>
</span></span><span><span>    <span>def</span> __init__(self, owner: <span>str</span>, name: <span>str</span>, description: <span>str</span>):
</span></span><span><span>        self<span>.</span>owner <span>=</span> owner
</span></span><span><span>        self<span>.</span>name <span>=</span> name
</span></span><span><span>        self<span>.</span>description <span>=</span> description
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>full_name</span>(self) <span>-&gt;</span> <span>str</span>:
</span></span><span><span>        <span>&#34;&#34;&#34;Get the repository full name.&#34;&#34;&#34;</span>
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;</span><span>{</span>self<span>.</span>owner<span>}</span><span>/</span><span>{</span>self<span>.</span>name<span>}</span><span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>get_repo</span>(repo_name: <span>str</span>) <span>-&gt;</span> GitHubRepo:
</span></span><span><span>    <span>&#34;&#34;&#34;Return repository info by its name.&#34;&#34;&#34;</span>
</span></span><span><span>    data <span>=</span> requests<span>.</span>get(<span>f</span><span>&#34;https://api.github.com/repos/</span><span>{</span>repo_name<span>}</span><span>&#34;</span>)<span>.</span>json()
</span></span><span><span>    <span>return</span> GitHubRepo(data[<span>&#34;owner&#34;</span>][<span>&#34;login&#34;</span>], data[<span>&#34;name&#34;</span>], data[<span>&#34;description&#34;</span>])
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> get_repo(<span>&#34;imankulov/empty&#34;</span>)
</span></span><span><span><span>&lt;</span>GitHubRepo at <span>0x103023520</span><span>&gt;</span>
</span></span></code></pre></div></div><p>While the example below has more code, this solution is better than the previous one if we maintain and extend the codebase.</p><p>Let’s see what the differences are.</p><ul><li>The data structure is clearly defined, and we can document it with as many details as necessary.</li><li>The class also has a method <code>full_name()</code> implementing some class-specific business logic. Unlike dicts, data models allow you to co-locate the code and data.</li><li>GitHub API’s dependency is isolated in the function <code>get_repo()</code>. The GitHubRepo object doesn’t need to know anything about the external API and how objects are created. This way, you can modify the deserializer independently from the model or add new ways of creating objects: from pytest fixtures, the GraphQL API, the local cache, etc.</li></ul><p>☝️ Ignore fields coming from the API if you don’t need them. Keep only those that you use.</p><p>In many cases, you can and should ignore most of the fields coming from the API, adding only the fields that the application uses. Not only duplicating the fields is a waste of time, but it also makes the class structure rigid, making it hard to adopt changes in the business logic or add support to the new version of the API. From the point of view of testing, fewer fields mean fewer headaches in instantiating the objects.</p><h2 id="streamline-model-creation">Streamline model creation</h2><p>Wrapping dicts require creating a lot of classes. You can simplify your work by employing a library that makes “better classes” for you.</p><h3 id="create-models-with-dataclasses">Create models with dataclasses</h3><p>Starting from version 3.7, Python provides <a href="https://docs.python.org/3/library/dataclasses.html">Data Classes</a>. The <code>dataclasses</code> module of the standard library provides a decorator and functions for automatically adding generated special methods such as <code>__init__()</code> and <code>__repr__()</code> to your classes. Therefore, you write less boilerplate code.</p><p>I use dataclasses for small projects or scripts where I don’t want to introduce extra dependencies. That’s how the <code>GitHubRepo</code> model looks like with dataclasses.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>dataclasses</span> <span>import</span> dataclass
</span></span><span><span>
</span></span><span><span><span>@dataclass</span>(frozen<span>=</span><span>True</span>)
</span></span><span><span><span>class</span> <span>GitHubRepo</span>:
</span></span><span><span>    <span>&#34;&#34;&#34;GitHub repository.&#34;&#34;&#34;</span>
</span></span><span><span>    owner: <span>str</span>
</span></span><span><span>    name: <span>str</span>
</span></span><span><span>    description: <span>str</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>full_name</span>(self) <span>-&gt;</span> <span>str</span>:
</span></span><span><span>        <span>&#34;&#34;&#34;Get the repository full name.&#34;&#34;&#34;</span>
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;</span><span>{</span>self<span>.</span>owner<span>}</span><span>/</span><span>{</span>self<span>.</span>name<span>}</span><span>&#34;</span>
</span></span></code></pre></div><p>When I create Data Classes, my Data Classes are almost always defined as frozen. Instead of modifying an object, I create a new instance with <code>dataclasses.replace()</code>. Read-only attributes bring peace of mind to a developer, reading and maintaining your code.</p><h3 id="alternatively-create-models-with-pydantic">Alternatively, create models with Pydantic</h3><p>Recently <a href="https://pydantic-docs.helpmanual.io/">Pydantic</a>, a third-party data-validation library became my go-to choice for model definition. Compared with dataclasses, they are much more powerful. I especially like their serializers and deserializers, automatic type conversions, and custom validators.</p><p>Serializers simplify storing records to external storage, for example, for caching. Type conversions are especially helpful when converting a complex hierarchical JSON to a hierarchy of objects. And validators are helpful for everything else.</p><p>With Pydantic, the same model can look like this.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>pydantic</span> <span>import</span> BaseModel
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>GitHubRepo</span>(BaseModel):
</span></span><span><span>    <span>&#34;&#34;&#34;GitHub repository.&#34;&#34;&#34;</span>
</span></span><span><span>    owner: <span>str</span>
</span></span><span><span>    name: <span>str</span>
</span></span><span><span>    description: <span>str</span>
</span></span><span><span>
</span></span><span><span>    <span>class</span> <span>Config</span>:
</span></span><span><span>        frozen <span>=</span> <span>True</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>full_name</span>(self) <span>-&gt;</span> <span>str</span>:
</span></span><span><span>        <span>&#34;&#34;&#34;Get the repository full name.&#34;&#34;&#34;</span>
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;</span><span>{</span>self<span>.</span>owner<span>}</span><span>/</span><span>{</span>self<span>.</span>name<span>}</span><span>&#34;</span>
</span></span></code></pre></div><p>You can find some examples of me using Pydantic, in the post <a href="https://roman.pt/posts/time-series-caching/">Time Series Caching with Python and Redis</a>.</p><h2 id="for-legacy-codebase-annotate-dicts-as-typedict">For legacy codebase, annotate dicts as TypeDict</h2><p>Python 3.8 introduced so-called <a href="https://www.python.org/dev/peps/pep-0589/">TypedDicts</a>. In runtime, they behave like regular dicts but provide extra information about their structure for developers, type validators, and IDEs.</p><p>If you come across the dict-heavy legacy code and can’t refactor everything yet, at least you can annotate your dicts as typed ones.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>typing</span> <span>import</span> TypedDict
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>GitHubRepo</span>(TypedDict):
</span></span><span><span>    <span>&#34;&#34;&#34;GitHub repository.&#34;&#34;&#34;</span>
</span></span><span><span>    owner: <span>str</span>
</span></span><span><span>    name: <span>str</span>
</span></span><span><span>    description: <span>str</span>
</span></span><span><span>
</span></span><span><span>repo: GitHubRepo <span>=</span> {
</span></span><span><span>    <span>&#34;owner&#34;</span>: <span>&#34;imankulov&#34;</span>,
</span></span><span><span>    <span>&#34;name&#34;</span>: <span>&#34;empty&#34;</span>,
</span></span><span><span>    <span>&#34;description&#34;</span>: <span>&#34;An empty repository&#34;</span>,
</span></span><span><span>}
</span></span></code></pre></div><p>Below, I provide two screenshots from PyCharm to show how adding typing information can streamline your development experience with the IDE and protect you against errors.</p><figure><img src="https://roman.pt/posts/dont-let-dicts-spoil-your-code/typed-dict-value-type.png" alt="PyCharm knows about the value type and provides autocomplete" width="650"/><figcaption><p>PyCharm knows about the value type and provides autocomplete</p></figcaption></figure><figure><img src="https://roman.pt/posts/dont-let-dicts-spoil-your-code/typed-dict-missing-key.png" alt="PyCharm knows about the missing key and issues a warning" width="650"/><figcaption><p>PyCharm knows about the missing key and issues a warning</p></figcaption></figure><h2 id="for-key-value-stores-annotate-dicts-as-mappings">For key-value stores, annotate dicts as mappings</h2><p>A legitimate use-case of dict is a key-value store where all the values have the same type, and keys are used to look up the value by key.</p><div><pre tabindex="0"><code data-lang="python"><span><span>colors <span>=</span> {
</span></span><span><span>    <span>&#34;red&#34;</span>: <span>&#34;#FF0000&#34;</span>,
</span></span><span><span>    <span>&#34;pink&#34;</span>: <span>&#34;#FFC0CB&#34;</span>,
</span></span><span><span>    <span>&#34;purple&#34;</span>: <span>&#34;#800080&#34;</span>,
</span></span><span><span>}
</span></span></code></pre></div><p><em>A dict, used as a mapping.</em></p><p>When instantiating or passing such dict to a function, consider hiding implementation details by annotating the variable type as Mapping or MutableMapping. On the one hand, it may sound like overkill. Dict is default and by far the most common implementation of a MutableMapping. On the other hand, by annotating a variable with mapping, you can specify the types for keys and values. Besides, in the case of a Mapping type, you send a clear message that an object is supposed to be immutable.</p><div><p>Example</p><p>I defined a color mapping and annotated a function. Notice how the function uses the operation allowed for dicts but disallowed for Mapping instances.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># file: colors.py</span>
</span></span><span><span><span>from</span> <span>typing</span> <span>import</span> Mapping
</span></span><span><span>
</span></span><span><span>colors: Mapping[<span>str</span>, <span>str</span>] <span>=</span> {
</span></span><span><span>    <span>&#34;red&#34;</span>: <span>&#34;#FF0000&#34;</span>,
</span></span><span><span>    <span>&#34;pink&#34;</span>: <span>&#34;#FFC0CB&#34;</span>,
</span></span><span><span>    <span>&#34;purple&#34;</span>: <span>&#34;#800080&#34;</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>def</span> <span>add_yellow</span>(colors: Mapping[<span>str</span>, <span>str</span>]):
</span></span><span><span>    colors[<span>&#34;yellow&#34;</span>] <span>=</span> <span>&#34;#FFFF00&#34;</span>
</span></span><span><span>
</span></span><span><span><span>if</span> __name__ <span>==</span> <span>&#34;__main__&#34;</span>:
</span></span><span><span>    add_yellow(colors)
</span></span><span><span>    <span>print</span>(colors)
</span></span></code></pre></div><p>Despite wrong types, no issues in runtime.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ python colors.py
</span></span><span><span><span>{</span><span>&#39;red&#39;</span>: <span>&#39;#FF0000&#39;</span>, <span>&#39;pink&#39;</span>: <span>&#39;#FFC0CB&#39;</span>, <span>&#39;purple&#39;</span>: <span>&#39;#800080&#39;</span>, <span>&#39;yellow&#39;</span>: <span>&#39;#FFFF00&#39;</span><span>}</span>
</span></span></code></pre></div><p>To check the validity, I can use mypy, which raises an error.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ mypy colors.py
</span></span><span><span>colors.py:11: error: Unsupported target <span>for</span> indexed assignment <span>(</span><span>&#34;Mapping[str, str]&#34;</span><span>)</span>
</span></span><span><span>Found <span>1</span> error in <span>1</span> file <span>(</span>checked <span>1</span> <span>source</span> file<span>)</span>
</span></span></code></pre></div></div><h2 id="take-dicts-under-control">Take dicts under control</h2><p>Keep an eye on your dicts. Don’t let them take control of your application. As with every piece of technical debt, the further you postpone introducing proper data structures, the more complex the transition becomes.</p></div></div>
  </body>
</html>
