<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://ratfactor.com/zig/hard">Original</a>
    <h1>Zig is hard but worth it</h1>
    
    <div id="readability-page-1" class="page"><article>
        <header>
            
            
            
            
            
            
                Page created: <span>2023-05-22</span>
            
            
                , updated: <span>2023-05-31</span>
                
            
            
        </header>

        
        <div>
<p><img src="http://ratfactor.com/zig/zighard_700px.jpg" alt="drawing of a sad rat sitting on the curb while three lizards say…​"/>
</p>
</div>
<p>&#34;I learned Zig in a weekend! …​Six hours! …​6µs!&#34; say the blissful lizards.
Followed by something to the effect of, &#34;It’s easy to pick up because
the syntax is so simple.&#34;</p>

<p>Clearly, many folks really <em>do</em> find Zig easy to learn.  Veteran C programmers,
in particular, seem to find Zig a natural and logical next step.
Kelley’s fun and enlightening talk,
<a href="https://www.youtube.com/watch?v=Gv2I7qTux7g">The Road to Zig 1.0</a>
(youtube.com),
presents Zig as exactly this: &#34;C, but with the problems fixed.&#34;</p>
<p>And it’s also true that Zig has a <em>relatively</em> small amount of syntax.
For some, it is apparently possible to &#34;pick it up&#34; in the span of time it takes to read
<a href="https://ziglang.org/documentation/master/">a single page of documentation</a>
(ziglang.org).
<em>(Mind you, that &#34;single page&#34; is on the order of 256 printed pages.)</em></p>
<p>The problem, of course, is that there’s not a direct correlation between the
slimness of a language’s syntax and ease of learning.  If there were, the
simplicity of Lisp’s S-expressions would make it trivial to &#34;pick up&#34; during
lunch. Or Forth, with it’s space-separated words would take, well, <em>you just
learned it.</em> <strong>Enjoy!</strong> Of course, I’m being a bit silly here. Zig is a
relatively &#34;small&#34; and &#34;simple&#34; language and that <em>does</em> aid learning. (By
contrast, nobody but a savant is going to &#34;pick up&#34; C++ or Rust from scratch in
an afternoon. They’re just too big for that.)</p>
<p>But I’d like to state for the record that if you find Zig difficult to master,
<strong>you are not alone</strong>. If your programming background is like mine (or even if it’s less weird than mine),
Zig can be challenging.</p>
<p>I’d like to enumerate the reasons I believe this is, <em>and</em> why most of the
reasons are actually very wonderful things about the language and well worth
the effort to overcome.</p>
<div>
<h2 id="_zig_is_new">Zig is new</h2>
<div>
<p>Let’s get this out of the way: You can’t just go into the bookstore and buy a
Zig book. And even if you could, it would be out of date in a month. Zig is
changing rapidly. (If I didn’t have help, I doubt I would have been able to
keep
<a href="https://github.com/ratfactor/ziglings">Ziglings</a>
(github.com)
up to date on my own when I was busy with other projects!)</p>
<p>Crucially, there is basically <em>no</em> documentation for the standard library
except for the source code itself. (To be fair, some parts are well commented
and much of it is surprisingly readable.) Everything else is scattered across
the Web, but you’ll have to see for yourself if the examples still compile.</p>
<p><strong>Why that’s good:</strong> It’s not. It may be <em>exciting</em>, but it’s
terrible for learning. Let’s move on.</p>
</div>
</div>
<div>
<h2 id="_zig_forces_you_to_make_choices">Zig forces you to make choices</h2>
<div>
<p>Depending on your background, you might also not be used to having to think in
terms of exact numeric types (<code>u8</code>, <code>i16</code>, <code>f64</code>, etc.) <em>for every single
runtime value in your program</em>. Handling &#34;strings&#34; means dealing with pointers,
sentinel termination, arrays, and slices.  This will slow you down very quickly
if you’re used to dynamic languages which (very conveniently) handle these
details for you.</p>
<p>If you’re new to manual memory management, you already have a pretty big hurdle
to get over.</p>
<p>That’s true regardless of language.</p>
<p>But Zig throws another level of decision-making at you that (most?) developers are
rarely asked to make: Choosing a memory allocation <em>strategy</em>.</p>
<p>And you won’t get far without making a decision. A significant portion of the
Zig standard library requires that you provide an allocator.</p>
<p>That’s a heck of a thing to ask of a beginner!</p>
<p><strong>Why that’s good:</strong> This is actually one of the coolest things about Zig.
To write performant software (or even just as a learning exercise),
we <em>should</em> learn about obtaining and using memory. We <em>should</em> be
allowed to pick the best types and allocators for our application.</p>
<p>(It’s also perfectly fine to pick something like <code>i64</code> for numbers and the
<code>GeneralPurposeAllocator</code> to get you going. You can always change strategies
later.)</p>
</div>
</div>
<div>
<h2 id="_zig_is_pedantic">Zig is pedantic</h2>
<div>
<p>Something that makes Zig harder to learn <em>up front</em>, but easier in the long
run is lack of undefined behavior.
While C presents itself as a compact language, learning how to avoid
undefined behavior takes time to master because the language itself
is more than happy to let you do all sorts of incorrect things.
Zig makes undefined behavior an error.</p>
<p>I’ve been a Rust noob and a Zig noob. The thing they have in common is fighting
with the compiler because I know what I want to do, but I don’t
know <em>how to express it</em>.</p>
<p>Zig’s type system is logical enough, but it still takes time to learn how to
create (and especially) cast types correctly because there are so many possible
combinations of the basic building-blocks:</p>
<div>
<ul>
<li>
<p><code>var</code> vs <code>const</code></p>
</li>
<li>
<p>optional values (<code>?</code>)</p>
</li>
<li>
<p>error unions (<code>!</code>)</p>
</li>
<li>
<p>single vs many-item pointers (<code><strong></strong></code><strong> and <code>[</code></strong><code>]</code>)</p>
</li>
<li>
<p>slices of arrays (<code>[]</code> and <code>[x..y]</code>)</p>
</li>
<li>
<p>sentinel termination (<code>[n:null]</code>)</p>
</li>
</ul>
</div>
<p>Put enough of these together and you can end up with something like
<code>[*:null]const ?[*:0]const u8</code>
(a real example I personally struggled with early on).</p>
<p>There are certain bits of code I could have written faster in <em>assembly language</em>
than Zig because it took me a long time to figure out how to express my intent.</p>
<p><strong>Why that’s good:</strong> Zig is <em>trying to help</em>. C and assemblers don’t much
care what I do with my memory, so they make it &#34;easy&#34; to write code that
performs actions regardless of type. But if I get it wrong (and I will), the program
will segfault. The language won’t get in my way, but it won’t help me either.
Zig makes you get it right, and that’s <strong>a good thing</strong>. Slower and more tedious,
especially at first, but good.</p>
</div>
</div>
<div>
<h2 id="_zig_has_comptime">Zig has comptime</h2>
<div>
<p>Plenty of languages have metaprogramming, but none are exactly alike.
C’s preprocessor won’t prepare you for Zig’s compile time execution.
Macros won’t prepare you for it.
The run-time introspection of various dynamic languages won’t prepare you
for it either.</p>
<p>Zig’s <code>comptime</code> is its own thing. And you’ll need to learn about it
or you’ll run into errors early on that otherwise won’t make sense
because <em>it’s happening whether you ask for it or not</em>.</p>
<p>Within a specific set of rules (including the explicit use of the <code>comptime</code>
keyword), &#34;regular&#34; Zig code will run at compile time, resulting in a runtime
executable with values pre-calculated, unneeded code removed, loops &#34;unrolled&#34;,
and code generated inline to work with different data types.</p>
<p><strong>Why that’s good:</strong> Only time will tell if <code>comptime</code> is the
&#34;greatest thing since sliced bread&#34; or not. But so far, it seems to be
a pretty solid concept. By executing portions of the program at compile
time, a large number of tricky language problems have been solved without
introducing too many additional concepts.</p>
</div>
</div>
<div>
<h2 id="_what_is_hard_versus_easy_anyway">What is &#34;hard&#34; versus &#34;easy&#34;, anyway?</h2>
<div>
<p>The
<a href="https://ziglang.org/">Zig Programming Language</a>
(ziglang.org)
home page doesn’t contain the word &#34;easy&#34;, but it does contain
the word &#34;simple&#34;.</p>
<p>As Rich Hickey teaches us in his brilliant
<a href="https://www.youtube.com/watch?v=SxdOUGdseq4">Simple Made Easy</a>
(youtube.com),
easy things seem easy primarily because they are <strong>familiar</strong>.
Easy is subjective.
But simple things are simple because they do not complicate; they have <strong>fewer
concepts</strong>.
Simple is objective.</p>
<p>(Simple is often elegant as well, but then we’re back to being subjective.)</p>
<p>Zig may be easy for some and not for others (like me!), but it <em>definitely</em>
strives to be simple, uniform, and correct.  And for that reason, I think it’s
worth the investment.</p>

</div>
</div>

        
    </article></div>
  </body>
</html>
