<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/zwegner/x86-sat">Original</a>
    <h1>Basic SAT model of x86 instructions using Z3, autogenerated from Intel docs</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">This is a rudimentary attempt to build an autogenerated formal-ish model of
x86 intrinsics by interpreting Intel&#39;s instruction pseudocode, transforming
it into a model for <a href="https://github.com/Z3Prover/z3">Z3</a>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/zwegner/x86-sat/blob/master/screenshots/overview-1.png"><img src="https://github.com/zwegner/x86-sat/raw/master/screenshots/overview-1.png" alt="overview image"/></a></p>

<p dir="auto"><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/" rel="nofollow">Intel&#39;s Intrinsics Guide</a> provides an interactive
guide with data for each x86 intrinsic instruction, including a pseudocode that specifies the instruction&#39;s
behavior. The intrinsics guide is backed by an XML file with all of this data in an easily parseable format,
which we use here to build a Z3 model.</p>
<p dir="auto">So far, only these features of Intel&#39;s pseudocode are supported:</p>
<ul dir="auto">
<li>Basic unary/binary arithmetic/bitwise operations, and ternary conditionals</li>
<li>Bit slices, both reading and writing</li>
<li><code>IF</code>/<code>CASE</code> conditionals (which are predicated when they can&#39;t be statically resolved)</li>
<li><code>FOR</code> loops</li>
<li>Function definitions/calls
See <code>tokens</code>/<code>rules</code> in <code>parse.py</code> for the most up-to-date information.</li>
</ul>
<p dir="auto">There are many functions used in Intel&#39;s documentation that are not explicitly given in the XML. For now,
these are almost all unsupported (see functions defined in <code>intr_builtins.py</code> for the current list).</p>
<p dir="auto">This method of generating models is inherently limited. The intrinsics only cover a subset of x86
instructions (presumably until a PDF reader is added), so this will mostly be
useful for investigating hand-rolled SIMD code, etc. Handling memory might be possible but would
certainly be very slow. Handling control flow is likely out of scope for now too.</p>
<p dir="auto">There are quite possibly bugs in this implementation, which can be pretty hard to find and fix.
There are also definitely bugs in Intel&#39;s code (see below), so this shouldn&#39;t be relied on
for anything serious.</p>
<p dir="auto">So far, this can do some interesting non-trivial things, like derive lookup
tables for <code>vpternlogd</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="check_print(_mm512_ternarylogic_epi32(_mm512_set1_epi8(0xAA),
       _mm512_set1_epi8(0xCC), _mm512_set1_epi8(0xF0), i) == _mm512_set1_epi8(0x57))
# -&gt; [y = 0x1f]"><pre><span>check_print</span>(<span>_mm512_ternarylogic_epi32</span>(<span>_mm512_set1_epi8</span>(<span>0xAA</span>),
       <span>_mm512_set1_epi8</span>(<span>0xCC</span>), <span>_mm512_set1_epi8</span>(<span>0xF0</span>), <span>i</span>) <span>==</span> <span>_mm512_set1_epi8</span>(<span>0x57</span>))
<span># -&gt; [y = 0x1f]</span></pre></div>
<p dir="auto">...or find an index vector for <code>vpermb</code> that reverses its input:</p>
<div dir="auto" data-snippet-clipboard-copy-content="values = range(2, 3*64, 3)
check(_mm512_set_epi8(*values) == _mm512_permutexvar_epi8(b, _mm512_set_epi8(*reversed(values))))
# &lt;- [b = 0x000102030405060708090a0b0c0d0e0f1011...]"><pre><span>values</span> <span>=</span> <span>range</span>(<span>2</span>, <span>3</span><span>*</span><span>64</span>, <span>3</span>)
<span>check</span>(<span>_mm512_set_epi8</span>(<span>*</span><span>values</span>) <span>==</span> <span>_mm512_permutexvar_epi8</span>(<span>b</span>, <span>_mm512_set_epi8</span>(<span>*</span><span>reversed</span>(<span>values</span>))))
<span># &lt;- [b = 0x000102030405060708090a0b0c0d0e0f1011...]</span></pre></div>
<p dir="auto">...or <strong>find a bug in Intel&#39;s pseudocode</strong>. Turns out that last one gives <code>unsat</code>, which didn&#39;t make sense.
Investigating further, I noticed that I wasn&#39;t getting the right result for a <code>_mm512_set_epi8(*range(64))</code>,
which led me to find this bug in the <code>_mm512_set_epi8</code> pseudocode:</p>
<div dir="auto" data-snippet-clipboard-copy-content=" dst[495:488] := e61
 dst[503:496] := e62
-dst[511:503] := e63
+dst[511:504] := e63
 dst[MAX:512] := 0"><pre> dst[495:488] := e61
 dst[503:496] := e62
<span><span>-</span>dst[511:503] := e63</span>
<span><span>+</span>dst[511:504] := e63</span>
 dst[MAX:512] := 0</pre></div>
<p dir="auto">All of these intrinsic functions used in these examples (and the ones in <code>test.py</code>) are completely
autogenerated from Intel&#39;s data; there&#39;s no manual intrinsics created whatsoever.</p>

<p dir="auto">To use this, you must first download the latest XML from Intel&#39;s Intrinsics Guide
(currently here: <a href="https://www.intel.com/content/dam/develop/public/us/en/include/intrinsics-guide/data-latest.xml" rel="nofollow">https://www.intel.com/content/dam/develop/public/us/en/include/intrinsics-guide/data-latest.xml</a>)
and save it as <code>data.xml</code> in the current directory. I don&#39;t believe I can legally
redistribute this file myself.</p>
<p dir="auto">This project requires Z3, and my <a href="https://github.com/zwegner/sprdpl">sprdpl</a> parsing library
(included as a submodule).</p>
<p dir="auto">The library has two primary APIs for looking up and using intrinsics:</p>
<ul dir="auto">
<li>The <code>parse_whitelist()</code> function, which returns a dictionary of intrinsic objects, suitable for
injecting directly into global scope:</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="intrinsics = parse_whitelist(&#39;data.xml&#39;, regex=&#39;_mm256_set1_epi(8|32)&#39;)
globals().update(intrinsics)
check_print(_mm256_set1_epi8(0) == _mm256_set1_epi32(0))"><pre><span>intrinsics</span> <span>=</span> <span>parse_whitelist</span>(<span>&#39;data.xml&#39;</span>, <span>regex</span><span>=</span><span>&#39;_mm256_set1_epi(8|32)&#39;</span>)
<span>globals</span>().<span>update</span>(<span>intrinsics</span>)
<span>check_print</span>(<span>_mm256_set1_epi8</span>(<span>0</span>) <span>==</span> <span>_mm256_set1_epi32</span>(<span>0</span>))</pre></div>
<ul dir="auto">
<li>The <code>parse_meta()</code> function, which returns a magic object that lazily parses intrinsics pseudocode
whenever attributes are accessed, like so:</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="meta = parse_meta(&#39;data.xml&#39;)
check_print(meta._mm256_xor_si256(0, 1) == 1)
# .prefixed() allows reducing duplicated prefixes:
avx = meta.prefixed(&#39;_mm256_&#39;)
check_print(avx.set1_epi8(0) == 0)"><pre><span>meta</span> <span>=</span> <span>parse_meta</span>(<span>&#39;data.xml&#39;</span>)
<span>check_print</span>(<span>meta</span>.<span>_mm256_xor_si256</span>(<span>0</span>, <span>1</span>) <span>==</span> <span>1</span>)
<span># .prefixed() allows reducing duplicated prefixes:</span>
<span>avx</span> <span>=</span> <span>meta</span>.<span>prefixed</span>(<span>&#39;_mm256_&#39;</span>)
<span>check_print</span>(<span>avx</span>.<span>set1_epi8</span>(<span>0</span>) <span>==</span> <span>0</span>)</pre></div>
<p dir="auto">See <code>test.py</code> for various example use cases.</p>
</article>
          </div></div>
  </body>
</html>
