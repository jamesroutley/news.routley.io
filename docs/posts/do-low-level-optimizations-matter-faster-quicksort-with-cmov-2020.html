<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cantrip.org/sortfast.html">Original</a>
    <h1>Do low-level optimizations matter? Faster quicksort with cmov (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>

   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
   <meta name="viewport" content="width=device-width, user-scalable=no"/>
   <title></title>



<h3 id="do-low-level-optimizations-matter">Do Low-level Optimizations Matter?</h3>
<p><em>by Nathan Myers, ncm at cantrip dot org, 2020-01-09</em></p>
<p>Collectively, we have been thinking about sorting for longer than we have had computers. There is still an active literature <a href="#fn1" id="fnref1"><sup>1</sup></a>,<a href="#fn2" id="fnref2"><sup>2</sup></a>,<a href="#fn3" id="fnref3"><sup>3</sup></a>. We are taught that how the counts of comparisons and swaps vary with problem size is what matters: as problems get bigger, order dominates, and anything else is buried in the noise. We learn that the best in-place sorts run in time around <em>kN lg2(N)</em>, and a better sort algorithm has a smaller <em>k</em>, or is better-behaved for chosen input.</p>
<p>We ought to be able to sort pretty fast, by now, using a Standard Library sort. Sorting is real work: if you need it to go faster, you probably need to spend more on hardware. You can’t cheat on that.</p>
<p>Or can you? The classic sorting research was conducted on machines from many generations ago. While today’s are made to seem similar from the outside, inside they are very, very different. Do we still understand what affects sorting speed today? Maybe the rules have changed.</p>
<h3 id="laboratory">Laboratory</h3>
<p>Trying out ideas with Standard Library sort implementations can be tricky; as they have been tuned, they have become complicated. Results can be confusing. We need a laboratory: simple sorts, and simple data<a href="#fn4" id="fnref4"><sup>4</sup></a>. So, let us begin with a file of a hundred-million totally random integers:</p>
<pre><code>  $ dd if=/dev/urandom count=100 bs=4000000 of=1e8ints</code></pre>
<p>This is objectively the worst case, containing the greatest possible entropy; but also the best case, hiding no surprises. We can map this file into our process, and the OS will copy it from the file buffer cache, the work showing up as <code>sys</code> time. All the rest of the run time is spent on nothing but sorting.</p>
<p>Next, we need a baseline, using <code>std::sort</code>, for reference:</p>
<pre><code>  #include &lt;sys/mman.h&gt;
  #include &lt;fcntl.h&gt;
  #include &lt;algorithm&gt;

  static const int size = 100&#39;000&#39;000;

  int main(int, char**) {
    int fd = ::open(&#34;1e8ints&#34;, O_RDONLY);
    int perms = PROT_READ|PROT_WRITE;
    int flags = MAP_PRIVATE|MAP_POPULATE|MAP_NORESERVE;
    auto* a = (int*) ::mmap(
      nullptr, size * sizeof(int), perms, flags, fd, 0);

    std::sort(a, a + size);

    return a[0] == a[size - 1];
  }</code></pre>
<p>The <code>return</code> statement keeps the compiler from optimizing away the whole program. Trying it<a href="#fn5" id="fnref5"><sup>5</sup></a>:</p>
<pre><code>  $ g++ -O3 -march=native sort_base.cc &amp;&amp; time ./a.out

  real  0m7.365
  user  0m7.257
  sys   0m0.108s</code></pre>
<p>We see about <code>73ns</code> per element. <em>lg2(1e8)</em> is about 27, making <em>k</em> a bit less than <code>3ns</code>. Each time <code>std::sort</code> looks at an element, it spends, on average, <code>3ns</code>, presumably on shuffling it from memory to cache to register to ALU, and maybe back to cache and to memory. This happens 27 times before the element ends up where it belongs. (Nobody said, in school, that <em>k</em> has a unit, but for our purposes, it’s nanoseconds.)</p>
<h4 id="reality-check">Reality Check</h4>
<p>Just for a reality check, let’s plug in a radix sort. It is an unfair comparison, on several axes, but it suggests a hard upper bound on the kind of improvement we can reasonably hope for. This function distributes elements to one of 256 buckets, and then copies them back, in stable bucket order, and again for the next byte.</p>
<pre><code>  #include &lt;vector&gt;
  #include &lt;cstring&gt;

  void sort_radix256(unsigned* begin, unsigned* end) {
    std::vector&lt;int&gt; buckets[256];
    for (auto&amp; v : buckets) v.reserve((end - begin)/128);
    for (int byte = 0; byte != sizeof(unsigned); ++byte) {
      for (unsigned* p = begin; p != end; ++p) {
        buckets[*p &amp; 0xff].push_back((*p &gt;&gt; 8) | (*p &lt;&lt; 24));
      }
      unsigned* p = begin;
      for (auto&amp; v : buckets) {
        std::memcpy(p, v.data(), v.size() * sizeof(unsigned));
        p += v.size();
        v.clear();
  } } }

  - auto* a = (int*) ::mmap(
  + auto* a = (unsigned*) ::mmap(

  - std::sort(a, a + size);
  + sort_radix256(a, a + size);

  real  0m1.193s
  user  0m0.985s
  sys   0m0.208s</code></pre>
<p>We see the OS spending extra time initializing memory (two thirds of it to zeroes), because radix sorting is not done in place. The rest of the time is spent copying the input to buckets and back, four passes in all, <code>2.5ns</code> per element per pass. When you can use it, and for big enough N, radix sort always wins, because it’s O(N): in this case, 4N. Notably, the sequence of instructions is almost the same, no matter what the values of the elements are. All that varies is which bucket each element goes into.</p>
<p>This radix sort would be easy to make even faster. Instead, let us make one that is slower, but that shares important qualities with in-place sorts. Instead of 256 buckets, this will use just two. The first pass picks a bucket according to the low bit, the next pass uses the next bit, and on around.</p>
<pre><code>  void sort_radix2(unsigned* begin, unsigned* end) {
    std::vector&lt;unsigned&gt; a_buckets[2];
    for (auto&amp; v : a_buckets) v.reserve((end - begin)/3);
    int i = 0;
    for (; i &lt; (end - begin) / 2; ++i) a_buckets[0].push_back(begin[i]);
    for (; i &lt; (end - begin); ++i) a_buckets[1].push_back(begin[i]);

    std::vector&lt;unsigned&gt; b_buckets[2];
    for (auto&amp; v : b_buckets) v.reserve((end - begin)/3);

    for (int bit = 0; bit != 8 * sizeof(unsigned); ++bit) {
      for (int j = 0; j != 2; ++j) {
        for (unsigned v : a_buckets[j]) {
          b_buckets[v &amp; 0x1].push_back((v &gt;&gt; 1) | (v &lt;&lt; 31));
        }
      }
      std::swap(a_buckets[0], b_buckets[0]), b_buckets[0].clear();
      std::swap(a_buckets[1], b_buckets[1]), b_buckets[1].clear();
    }

    for (auto bucket : a_buckets)
      for (unsigned v : bucket) *begin++ = v;
  }

  - sort_radix256(a, a + size);
  + sort_radix2(a, a + size);

  real  0m4.759s
  user  0m4.543s
  sys   0m0.216s
</code></pre>
<p>It’s slower, because it examines each element 32 times. It’s not <em>N lg2(N)</em>, but <em>32N</em>. This <code>4.5s</code> is remarkably close to our <code>std::sort</code> baseline, <code>7.3s</code>. Maybe we can think of the difference between <code>4.5s</code> and our baseline as what we pay for the generality of <code>std::sort</code>? <em>32N</em> is not far from <em>27N</em>. Should we take <code>4.5s</code> <code>*</code> <em>27/32</em> <em>=</em> <code>3.8s</code> as an ultimate stretch goal?</p>
<h4 id="starting-point-quicksort">Starting Point: <code>quicksort</code></h4>
<p>Let’s see how well we can do with a regular sorting algorithm. Start by pasting in a bog-standard quicksort<a href="#fn6" id="fnref6"><sup>6</sup></a>:</p>
<pre><code>  int* partition(int* begin, int* end) {
    int pivot = end[-1];
    int* left = begin;
    for (int* right = begin; right &lt; end - 1; ++right) {
      if (*right &lt;= pivot) {
        int tmp = *left; *left = *right, *right = tmp;
        ++left;
      }
    }
    int tmp = *left; *left = end[-1], end[-1] = tmp;
    return left;
  }

  void quicksort(int* begin, int* end) {
    while (end - begin &gt; 1) {
      int* mid = partition(begin, end);
      quicksort(begin, mid);
      begin = mid + 1;
  } }

  - auto* a = (unsigned*) ::mmap(
  + auto* a = (int*) ::mmap(

  - radix_sort2(a, a + size);
  + quicksort(a, a + size);

  real  0m8.309s
  user  0m8.193s
  sys   0m0.116s</code></pre>
<p>This is really not bad. The <code>std::sort</code> in the standard library, at <code>7.3s</code>, is a lot more code than we see here, but it has to perform well on tricky cases we won’t be testing.</p>
<h4 id="what-is-new">What Is New?</h4>
<p>What is different in modern CPUs from the machines the algorithms we use were originally tuned for? Well, lots. Today they have up to a half-billion transistors per core, not just the thousands originally used to execute a notably similar instruction set. (Imagine, in each generation, being asked to find a way to use another million, ten million, hundred million! more transistors, to get better benchmark times.)</p>
<p>We have many more caches, registers, instruction decoders, and functional units–barrel shifters, multipliers, ALUs<a href="#fn7" id="fnref7"><sup>7</sup></a>. There’s even a little just-in-time compiler, <em>in hardware</em>, to translate complex-instruction sequences into simpler ones, with its own peephole optimizer, and a cache of its output. A small-enough loop can execute entirely from that cache.</p>
<p>One thing wholly new is the <em>branch predictor</em><a href="#fn8" id="fnref8"><sup>8</sup></a>. Technically, it’s another cache, one that accumulates a history of which way was chosen on each of the last M conditional branch points encountered during execution. (The number M is secret.) Branch prediction matters because of something else that’s wholly new: <em>speculative execution</em><a href="#fn9" id="fnref9"><sup>9</sup></a>.</p>
<p>When regular execution needs to stop and wait on a result, speculative execution can run on ahead, stuffing pipelines with work from upcoming loop iterations. Because the values needed to decide which way a conditional branch will go haven’t been computed yet, it has to <em>guess</em>, based on the pattern of what has happened before at that instruction address. When the branch predictor guesses wrong, a lot of work may need to be discarded, but whenever it guesses right, that work has already been done when regular execution gets there.</p>
<p>These days, often, most of the work gets done speculatively, so it is vitally important to guess right. Branch predictors have become astonishingly good at discovering patterns in our code, and guessing right. Nowadays, they use a neural net to identify such patterns; the branch prediction cache holds sets of coefficients for the neural net.</p>
<p>Branching on random data, though, is the worst case for any branch predictor, no matter how smart, because it can never find more regularity than the data has. Here, it guesses wrong half the time, and work is done and then discarded. The pipelines never fill, and functional units sit idle.</p>
<h4 id="adaptation">Adaptation</h4>
<p>If we want to better adapt our algorithm to the way a modern CPU works, we need to protect speculative execution against randomness in our data. Our only available course is to eliminate conditional branches that depend on that data.</p>
<p>So, let’s see what our conditional branches are doing. In this quicksort, there are only three conditional branches.</p>
<p>The first check, at the top of <code>quicksort</code> itself:</p>
<pre><code>    while (end - begin &gt; 1) {</code></pre>
<p>detects when recursion has bottomed out. It evaluates to <code>true</code> half the time, on a complicated schedule, but it is evaluated only about N times, and hardly depends on the input.</p>
<p>The second:</p>
<pre><code>    for (int* right = begin; right &lt; end - 1; ++right) {</code></pre>
<p>controls the loop in <code>partition</code> that walks through a subrange of the input. It runs about <em>N lg2(N)</em> times, but usually it’s taken. It, too, doesn’t depend much on input values. It gets hard to predict only when <code>begin</code> is very close to <code>end</code>, a small multiple of N times.</p>
<p>The third conditional branch:</p>
<pre><code>      if (*right &lt;= pivot) {</code></pre>
<p>happens <em>N lg2(N)</em> times, too, but it depends directly on the values of elements in the input, <em>every time</em>. To prevent missed branch predictions, we must find a way to avoid that branch. We need identically the same sequence of instructions executed in the true <em>and</em> the false case–and just have <em>nothing change</em>, in the false case.</p>
<p>The portable way to do this is to turn the result of the comparison into a regular value, and then do ordinary arithmetic with it. Sometimes, we can use the boolean value itself, as is. Perhaps the simplest possible example is:</p>
<pre><code>  if (a &lt; b) ++i;</code></pre>
<p>which can always be transformed, via conversion to <code>int</code>, to:</p>
<pre><code>  i += (a &lt; b);</code></pre>
<p>A more general method is to convert the boolean value into a mask value, of all zeroes or all ones. Then we can use bitwise operations to produce different results for the all-zeroes and the all-ones cases. For a slightly more complicated example, here we add up two seconds/nanoseconds pairs:</p>
<pre><code>  secs = secs1 + secs2, nsecs = nsecs1 + nsecs2;
  if (nsecs &gt;= 1&#39;000&#39;000&#39;000) {
    ++secs, nsecs -= 1&#39;000&#39;000&#39;000;
  }</code></pre>
<p>This transforms to:</p>
<pre><code>  secs = secs1 + secs2, nsecs = nsecs1 + nsecs2;
  int carry = (nsecs &gt;= 1&#39;000&#39;000&#39;000);
  secs += carry, nsecs -= ((-carry) &amp; 1&#39;000&#39;000&#39;000);</code></pre>
<p>With a carry, <code>(-carry)</code> is 111…111, and it subtracts a billion; with no carry, <code>(-carry)</code> is zero, and it subtracts zero.</p>
<h4 id="a-new-primitive-swap_if">A New Primitive, <code>swap_if</code></h4>
<p>How can we use this method in our sort? First, let us make a <code>swap_if</code>:</p>
<pre><code>  inline bool swap_if(bool c, int&amp; a, int&amp; b) {
    int ta = a, mask = -c;  // false -&gt; 0, true -&gt; 111..111
    a = (b &amp; mask) | (ta &amp; ~mask);
    b = (ta &amp; mask) | (b &amp; ~mask);
    return c;
  }</code></pre>
<p>In our <code>partition</code> function, then, we can transform</p>
<pre><code>    if (*right &lt;= pivot) {
      int tmp = *left; *left = *right, *right = tmp;
      ++left;
    }</code></pre>
<p>into just</p>
<pre><code>    left += swap_if(*right &lt;= pivot, *left, *right);</code></pre>
<p>This expands to more code, and all of it runs on every iteration, not just half of them, as before. But now, there is no branch to predict, or to mis-predict. It is just straight-line code.</p>
<p>Trying it:</p>
<pre><code>  $ g++ -O3 -march=native sort_swap_if.cc &amp;&amp; time ./a.out

  real  0m5.792s
  user  0m5.679s
  sys   0m0.112s</code></pre>
<p>This is excellent! <code>5.7s</code> is 1.44x better than before, and 1.29x as fast as <code>std::sort</code>.</p>
<p>Another way to make a value control what happens is indexing. (We have already seen an example of this, in the second radix sort presented above.) The boolean value is used as an array index:</p>
<pre><code>    int v[2] = { a, b };
    b = v[1-c], a = v[c];

  real  0m4.576s
  user  0m4.459s
  sys   0m0.116s</code></pre>
<p>Even better! This is 1.84x as fast as the naïve quicksort, even though the values have to take a detour through L1 cache so they can have addresses. This version is easily generalized to types that are not just a machine word:</p>
<pre><code>  template &lt;typename T&gt;
  bool swap_if(bool c, T&amp; a, T&amp; b) {
    T v[2] = { std::move(a), std::move(b) };
    b = std::move(v[1-c]), a = std::move(v[c]);
    return c;
  }</code></pre>
<p>When <code>T</code> is <code>int</code>, compilers generate identical code for the template version,</p>
<p>For completeness, there is also:</p>
<pre><code>    uint64_t both = (uint64_t(uint32_t(a)) &lt;&lt; 32) | uint32_t(b);
    int shift = c * 32;
    both = (both &lt;&lt; shift) | (both &gt;&gt; (64 - shift));
    a = int(uint32_t(both &amp; 0xffffffff)), b = int(both &gt;&gt; 32);</code></pre>
<p>The line with the shifts turns into a single “rotate” instruction. But this is not faster than the indexed version: it runs in <code>4.8s</code>.</p>
<h4 id="cmov-considered-disturbing"><code>cmov</code> Considered Disturbing</h4>
<p>How does the first, “and-and-or”, version do on Clang:</p>
<pre><code>  $ clang++ -O3 -march=native sort_swap_if.cc &amp;&amp; time ./a.out

  real  0m3.551s
  user  0m3.430s
  sys   0m0.120s</code></pre>
<p><em>HOLY CRAP! <code>3.4s</code>? What just happened?</em></p>
<p>Weren’t we just guessing that <code>3.8s</code> was as fast as we should ever hope to get? This is 2.4x as fast as quicksort, and more than 2x as fast as <code>std::sort</code>! This raises <em>so many</em> questions.</p>
<p>First, why the big difference between G++ and Clang? A quick detour through Godbolt<a href="#fn10" id="fnref10"><sup>10</sup></a> reveals what is going on. G++ actually generated the four “<code>and</code>”, and two “<code>or</code>” instructions seen in <code>swap_if</code>. But Clang’s optimizer recognized what we were trying to do with the masks, and replaced it all with a pair of simple <code>cmov</code>, conditional-move, instructions. (On top of that, it unrolled the loop in <code>partition</code>.)</p>
<p>What is the <code>cmov</code> instruction? It has been in ARM forever. Back in 2000, AMD included <code>cmov</code> in its 64-bit x86 ISA extensions. Then, Intel had to adopt them when Itanium flopped.</p>
<p><code>cmov</code> just copies a value from one place to another–register to register, register to memory, memory to register–but <em>only if</em> a condition-code flag has been set, such as by a recent comparison instruction. Since <code>cmov</code> replaces a conditional branch, the result of the comparison doesn’t need to be predicted. The execution unit doesn’t know <em>which</em> value it will end up with, but it knows where it will be, and can schedule copying that out to cache, and eventually memory, and run on ahead, without discarding anything.</p>
<p>Why doesn’t G++ generate <code>cmov</code> instructions? Older releases did, in fact, often enough to generate bug reports<a href="#fn11" id="fnref11"><sup>11</sup></a>. It turned out that, any time a subsequent loop iteration depends on the result, and the branch would have been predicted correctly, <code>cmov</code> may be slower than a branch, sometimes <em>much</em> slower. <code>cmov</code> can stall speculation all by itself.</p>
<p>The latest designs from Intel and AMD are said to avoid the <code>cmov</code> pipeline stall, often, but Gcc has not caught up with them yet.</p>
<p>For more on <code>cmov</code> and pessimization in G++, follow links in <a href="#fn12" id="fnref12"><sup>12</sup></a>.</p>
<p>In this case, though, nothing later depends on the result–it just gets stored, and the loop moves on–so this is a poster-child case for using <code>cmov</code>.</p>
<p>Clang, it turns out, can turn a simpler definition of <code>swap_if</code> into <code>cmov</code> instructions:</p>
<pre><code>    int ta = a, tb = b;
    a = c ? tb : ta;
    b = c ? ta : tb;</code></pre>
<p>But for this, G++ just generates a badly-predicted branch. I have not discovered a way to persuade G++ to produce <code>cmov</code> instructions (not even in old releases, and not even with the new <code>__builtin_expect_with_probability</code> intrinsic, probability 0.5). Even “profile-guided optimization” doesn’t help. (In the Linux kernel, wherever a <code>cmov</code> is needed, a macro expands directly to assembly code.) Looking into G++, it appears that it refuses to emit a <code>cmov</code> if anything else follows it in the “basic block”, even if what follows ought to be another <code>cmov</code> <a href="#fn13" id="fnref13"><sup>13</sup></a>.</p>
<h4 id="faster-than-pessimized-radix-sort">Faster Than (Pessimized) Radix Sort?</h4>
<p>Another big question: how could the Clanged version be even faster than our target time? This might come back to <code>cmov</code>, again. Radix sort always performs the same number of copy operations. So, also, do our first three versions of <code>swap_if</code>, as compiled by G++. But with <code>cmov</code>, only <em>half</em> of the swap operations end up needing to copy the pair of words out to L1 cache<a href="#fn14" id="fnref14"><sup>14</sup></a>,<a href="#fn15" id="fnref15"><sup>15</sup></a>, and thereby, perhaps, delay reading the next pair from it. There may be other reasons: radix sort sweeps majestically, sequentially through the whole sequence, relying on the prefetcher to keep ahead of it, while quicksort spends much of its time noodling around with values in L1 cache.</p>
<p>In the original quicksort, <em>k</em> was almost <code>3ns</code>, but now it is just <code>1.3ns</code>. More than <em>half</em> of the time we thought was being spent on honest computation was wasted, sitting stalled on branch mis-predictions! Who knows how much is still wasted? (Actually, the CPU knows: it keeps a count of how many of various cache misses happened, and you can read those out, given some care, with <code>perf</code><a href="#fn16" id="fnref16"><sup>16</sup></a>.)</p>
<h4 id="next">Next</h4>
<p>What can we do with what we’ve discovered? Sure, we can make our own programs faster, particularly if we are using Clang. But it would be better if we could make all programs faster.</p>
<p>We could propose a new library function, <code>std::swap_if</code>. Then, implementers could ensure it uses <code>cmov</code> for machine-word types (including pointers and floating-point values, and even small objects like <code>std::string_view</code>), and use it in their sorting and partitioning code. We could use it in our own programs, too. But for it to do much good, we would need to get it into a Standard, and then persuade many people to change a lot of code.</p>
<p>The experience with Clang’s optimizer hints at an alternative: Why can’t compilers recognize the sequence we did, and perform their own transformation?</p>
<p>This would be way better; just recompile, and all code gets faster, some a <em>lot</em> faster, with no need to rewrite any of it. The <code>std::sort</code> implementions in libstdc++ and libc++ are quite a bit more complicated than our toy quicksort, but maybe a compiler could spot places to transform that look unpromising to us.</p>
<p>Getting this optimization into compilers depends on those few who can add a new optimization to G++’s or Clang’s code generator taking time away from other optimization work. Doesn’t a 2x improvement over current <code>std::sort</code> automatically deserve that kind of attention? But it might not be so easy: too often, <code>cmov</code> is <em>slower</em>. The optimizer doesn’t just need to recognize when it <em>could</em> substitute <code>cmov</code> for a branch, it needs to decide whether it <em>should</em>.</p>
<p>While the optimizer knows whether anything depends on the result, it doesn’t know whether the input would have patterns that the branch predictor could tease out. Such an optimization would need a great deal of testing to ensure it doesn’t pessimize (too much) code.</p>
<p>Still, Clang, at least, seems to be all-in on plugging in <code>cmov</code> where it seems to make sense. It just needs to learn to recognize the conditionally-swapping and the conditionally-incrementing cases. It should be able to compose those into the transformation used here, and thence to <code>cmov</code>.</p>
<h4 id="conclusion">Conclusion</h4>
<p>What can we conclude from this discovery? Before we conclude anything, we should remind ourselves of its limitations. The tests run were on completely random data. Truly random data seldom occurs in real life. If there is a pattern in the data, the branch predictor might be able to find and exploit it. Shouldn’t it get that chance, sometimes?</p>
<p>Furthermore, the idea was tested on only the simplest possible elements, where both comparing and swapping were as cheap as they ever can be. While sorting word-sized objects is still an important use case, real sorting problems often have very different time budgets. We never changed the number or kind of comparisons performed, but the first big improvements doubled the number of copies; then the final improvement halved them again. A copy is a quarter or a third of a swap, but a dramatic change in their number had comparatively little effect on run time.</p>
<p>For many object types, the self-moves seen in the simplest, conditional-expression <code>swap_if</code> version are not permitted. For a production library, we might need to specialize on whether self-moves are allowed.</p>
<p>Our deep takeaway might be that counting comparisons and swaps ignores what are, today, the actually expensive operations: cache misses, of all kinds. Despite the millions of transistors devoted to the task, caches miss, sometimes systematically. Any time the number of misses, of all kinds, is not directly proportional to the number of operations counted, an analysis may produce the wrong answer, and lead us to bad choices.</p>
<p>But a lesson for the working programmer might be that, sometimes, you know the problem better than the compiler or cache systems, and measuring can lead you to simple code changes<a href="#fn17" id="fnref17"><sup>17</sup></a> that avoid costly misses, with sometimes dramatic results.</p>
<h4 id="recommendations">Recommendations</h4>
<p>Do these results suggest improvements to our Standard Library?</p>
<p>In C++, a factor of two in performance matters. We need two versions of each of the Standard sort, partition, binary search, merge, and heap algorithms that constitute nearly half of <code>&lt;algorithm&gt;</code><a href="#fn18" id="fnref18"><sup>18</sup></a>: one set that shields the branch predictor, and a second set that exposes the branch predictor to any patterns it can tease out. But this does <em>not</em> mean we need that many new named library functions! Instead, we can bind the choice to an optional property of the comparison predicate. The default should be to shield the branch predictor, at least for small types, because the consequence of failing to protect it can be so severe.</p>
<p>A branchless <code>std::swap_if</code> would be good to have in the Standard Library<a href="#fn19" id="fnref19"><sup>19</sup></a>, even after optimizers learn to generate it themselves, because optimizers are sometimes too cautious. We should consider carefully, also, whether <code>std::count_if</code> merits attention.</p>
<h4 id="more-to-come">More to Come</h4>
<p>Is that everything? Just the one weird trick?</p>
<p>No! This was <em>just one example</em>. Modern CPU chips are packed to the rafters with dodgy gimcracks. They have pre-fetchers, micro-op caches with micro-op fusion, register renaming, a shadow return-address stack, pipelines everywhere, atomic interlocks, translation lookaside buffers, hugepages, vector units. Caches collude with one another over private buses.</p>
<p>It all makes many programs go faster than they have any business going, but not necessarily <em>your</em> program. A better algorithm is no longer enough to get top performance; your program needs to join in the dance of the million-transistor accelerators. Anybody who insists C is close to the machine is, at best, deluded.</p>
<p>Can the dance of the gimcracks drive <em>k</em> south of one nanosecond? Stay tuned<a href="#fn20" id="fnref20"><sup>20</sup></a>.</p>
<p>Finally: If you control a budget, and depend on the performance of software, it might be a good use of that budget to help improve compilers and standard libraries in the ways suggested.</p>
<p><em>The author thanks Andrei Alexandrescu for a most thorough and helpful review of an early, and very different, draft of this article.</em></p>



</div></div>
  </body>
</html>
