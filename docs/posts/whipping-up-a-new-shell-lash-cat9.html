<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arcan-fe.com/2022/10/15/whipping-up-a-new-shell-lashcat9/">Original</a>
    <h1>Whipping up a new Shell – Lash#Cat9</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>This article introduces the first release of ‘Lash#Cat9’, a different kind of command-line shell.</p>



<p>A big change is that it is communicating with the display server directly, instead of being restricted and filtered by a terminal emulator. The source code repository with instructions for running it yourself can be found here: <a href="https://github.com/letoram/cat9">https://github.com/letoram/cat9</a>. A concatenation of all the clips here can be found in this <a href="https://www.youtube.com/watch?v=39ob0IO2Za0">(youtube-link)</a>.</p>



<p>Cat9 serves as the practical complement to the article on ‘<a href="https://arcan-fe.com/2022/04/02/the-day-of-a-new-command-line-interface-shell/">The day of a new command-line interface: shell</a>‘. That article also covers the design/architectural considerations on a system level, as well as more generic advancements to displacing the terminal emulator.</p>



<p>The rest of the article will work through the major features and how they came about.</p>



<p>A guiding principle is the role of the textual shell as <em>a frontend</em> instead of a clunky programming environment. The shell presents a user-facing, <em>interactive</em> interface to make other complex tools more approachable or to glue them together into a more advanced weapon. Cat9 is entirely written in Lua, so scripting in it is a given, but also relatively uninteresting as a feature — there are better languages around for systems programming, and better UI paradigms for automating work flows.</p>



<p>Another is that of <em>delegation</em> – textual shells naturally evolved without assuming a graphical one being present. That is rarely the case today, yet the language for sharing between the two is unrefined, crude and fragile. The graphical shell is infinitely more capable of decorating and managing windows, animating transitions, routing inputs and tuning pixels for specific displays. It should naturally be in charge of such actions.</p>



<p>Another is to make experience <em>self documenting </em>– that the emergent patterns on how your use of command line processing gets extracted and remembered in a form where re-use becomes natural. Primitive forms of this are completions from command history and aliases, but there is much more to be done here.</p>



<p><strong>Prestudy</strong></p>



<p>I collected history from a few weeks of regular terminal use along with screen recordings of the desktop window management side. I then proceeded to manually sift through these, looking for signs of poor posture. I found plenty.</p>



<p>This is a humbling experience. The main conclusion drawn is that I am mostly a hapless twit who default to repeating the same things hoping for different outcomes. I consistently confuse ‘src’ and ‘dst’ for ‘ln -s’; ‘ls’ gets spelled ‘sl’ much too often; ifconfig remains the preferred choice to ‘ip’ even though its main output typically is ‘file not found’ these days; nearly every tool that expects regular expressions are first fed plaintext strings. When I actually want to use a regular expression I consistently pick the wrong expression language.</p>



<p>The signal to noise ratio in the history is abysmal. About 90% of scrollback contents were leftovers from cd, ls and tab completion sprinkled with repeated runs of the same command through sudo, with minor tweaks to the arguments or to get a redirection for stderr. Redirections that were then left in the file system, with descriptive names like “boogeraids2000”.</p>



<p>The screen recordings were also revealing. Some notable time sinks:</p>



<ul>
<li>Copy paste across line-feeds and resizing windows to deal with incorrect wrapping.</li>



<li>Spinning up new terminals to work around man or vim hogging the alt screen.</li>



<li>Digging around in ps/proc/… for PIDs.</li>



<li>Redirecting to temporary files to transfer job outputs between windows or for later comparison.</li>



<li>Switching vim buffers between horizontal/vertical to fight the tiling WM.</li>
</ul>



<p>All these can be fixed with relatively minor effort.</p>



<p><strong>Improvements</strong></p>



<p><em>Get the prompt out of the way.</em></p>



<p>Starting with the prompt – obvious bits are that its contents should be ephemeral and disappear after running a command. It should reflect information about the current context (directory, etc.) and whatever else of immediate short lived value. The point is to clean this up:</p>


<div>
<figure><a href="https://arcanfe.files.wordpress.com/2022/09/mess.png"><img data-attachment-id="8549" data-permalink="https://arcan-fe.com/2022/10/15/whipping-up-a-new-shell-lashcat9/mess/" data-orig-file="https://arcanfe.files.wordpress.com/2022/09/mess.png" data-orig-size="586,338" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="mess" data-image-description="" data-image-caption="" data-medium-file="https://arcanfe.files.wordpress.com/2022/09/mess.png?w=300" data-large-file="https://arcanfe.files.wordpress.com/2022/09/mess.png?w=586" src="https://arcanfe.files.wordpress.com/2022/09/mess.png?w=586" alt="" srcset="https://arcanfe.files.wordpress.com/2022/09/mess.png 586w, https://arcanfe.files.wordpress.com/2022/09/mess.png?w=150 150w, https://arcanfe.files.wordpress.com/2022/09/mess.png?w=300 300w" sizes="(max-width: 586px) 100vw, 586px"/></a><figcaption>Old prompts polluting the history, bad / silent commands not pruned, dated command contents left around, …</figcaption></figure></div>


<p>Instead we get this:</p>



<figure><figcaption>Video clip of new prompt behaviour in two shell instances running side by side</figcaption></figure>



<ul>
<li>Prompt is updated live regardless of input and can change its layout template dynamically.</li>



<li>Prompt format and contents depends on window management state (focus, unfocus).</li>



<li>Silent commands are kept away from the history.</li>



<li>Completions come up without interaction and do not trample/shuffle actual contents.</li>



<li>Commands that only resulted in errors are automatically delay purged.</li>
</ul>



<p><em>Compartment</em></p>



<p>The previous options for compartmentation was a choice between juggling between a ‘foreground’ job and ‘background’ jobs. For this to work you needed either a fragile weave of signalling (SIGSTP, …) and file redirections — or spin up new terminals, either through a terminal multiplexer (a terminal emulator inside a terminal emulator inside ..) or new windows.</p>



<p>I find those solutions both noisy and distracting. Instead, I now have this:</p>



<figure><figcaption>Video clip of job compartments.</figcaption></figure>



<ul>
<li>Every command-line submitted now becomes its own job.</li>



<li>Jobs can reference each other.</li>



<li>Job context (environment variables, working directory, …) is saved and tracked.</li>



<li>The jobs are presented in order of importance (active ones take priority over passive ones).</li>



<li>Spawning new jobs automatically folds old ones into a collapsed form.</li>



<li>Individual controls, status and statistics are added to a stateful bar at the top of the job.</li>



<li>Job contexts can be reused for new commands.</li>
</ul>



<p><em>Remember everything, but right to be forgotten</em>.</p>



<p>In the terminal world, all job outputs either get composed unto one shared buffer with a certain amount of memory (scrollback history); fight for a scratchpad (“altscreen mode”) or are redirected to files or other jobs. This happens regardless of stream source or job state (foreground/background).</p>



<p>With real compartmentation and much larger memory and CPU budgets thanks to server side text rendering, we can do much better:</p>



<figure></figure>



<ul>
<li>Stdout and Stderr are tracked separately.</li>



<li>All job output is kept, tracked and addressed individually.</li>



<li>Contents can be forgotten, or selectively processed.</li>



<li>Completed jobs can be repeated, appending to the existing output or replacing that of previous runs.</li>



<li>Jobs can be repeated with an edited command-line.</li>
</ul>



<p><em>Cooperate with the outer windowing system</em></p>



<p>Now that the shell can talk directly to the window manager without having the conversation dumbed down by a terminal emulator sitting in between, new integration options are possible:</p>



<figure><figcaption>Showing different forms of desktop / window manager cooperation</figcaption></figure>



<ul>
<li>Snapshot the output of a job to a new window.</li>



<li>Window creation hints to window manager, like vertical split or tabbed.</li>



<li>Open applications and media embedded, with controls for position and size.</li>



<li>Detach and reattach embedded media, preserving input routing.</li>



<li>Directly route contents to clipboard and other data sharing mechanisms.</li>



<li>Trigger GUI file pickers.</li>
</ul>



<p><em>Let legacy in</em></p>



<p>Now with a fairly functional environment, the last part is to account for all the edge cases where we still need access to the old world in various degrees:</p>



<figure><figcaption>Showing how traditional terminal emulation and legacy shells can still be accessed</figcaption></figure>



<ul>
<li>Send data from a job to external processing pipes (#0 | grep hi).</li>



<li>Request a new window, attach a terminal emulator to it and run a pty dependent command (!vim).</li>



<li>Setup a PTY and attach a VTxxx view to it: (p! ls –color=yes).</li>
</ul>



<p><em>Streamline command structure</em></p>



<p>The foundation to cat9 is the command-line language itself. All the UI elements that you see, mouse gestures and key bindings map to the same things that you could type in manually:</p>



<figure><figcaption>Showing the connection between command line, input bindings, mouse input and event hooks</figcaption></figure>



<ul>
<li>Hooks and event actions can be added after a command has been setup or is running.</li>



<li>Mouse actions, bindings (clicking shown in clip: <em>view #csel $=crow</em> as in ‘cursor job, cursor row’).</li>



<li>Aliases and pre-commit expansion.</li>
</ul>



<p>With these basics sorted out, it is time to build something more interesting.</p>



<p><strong>Special Topic: Views on Life</strong></p>



<p>Now that jobs keep their data around in nicely tracked structures rather than a prematurely composed and broken ‘scrollback buffer’, we can do something more. While we have data in its raw form, we can look at it through various lenses to get different representations of the data. These are baked into the ‘view’ builtin.</p>



<p>Simply put, they parse the data and reformat the contents by adding annotations, structures, formatting and so on. The current builtin ones are all shown in this clip:</p>



<figure><figcaption>Dynamically switching between job visualisers/parsers, “views”</figcaption></figure>



<p>In this one you see ‘wrap’ and ‘filter’ along with some options like line numbers and column wrapping.  Filter even goes so far as to have an interactive mode that live-applies the filter as it is being written.</p>



<p>With the original data retained, re-executing previous pipelines is not needed, and the choice between using the formatted output and the original data is available when copying in/out.</p>



<p>This is one of the features that will be expanded heavily in future versions as we try to improve the presentation of the many ad-hoc text formats.</p>



<p><strong>Special Topic: State Actor</strong></p>



<p>This is a good one. Regular windowing systems provide Clipboard as well as Drag and Drop as forms of interactive data sharing. Some go further and also allow sequenced picking/sharing, like the “share” button popular in mobile operating systems. Arcan adds a state store/restore action to the mix. </p>



<p>This means that at any point, the windowing system can request that a state snapshot is created, or request that the application reverts to a provided one.</p>



<p>Examples of what gets stored in such a state blob here are configuration changes; command history; environment variables; aliases and so on. While this offloads the ‘where are my dot files’ responsibility, more interesting is that states can be transferred between instances at runtime.</p>



<p>Combine this with the job system: by marking a job as persistent, the command creating a job will be added to the state store. In the following clip you can see it being used to an interesting effect:</p>



<figure><figcaption>Per job state persistence across sessions</figcaption></figure>



<p>I first start a new cat9 session, run two jobs and mark one as persistent manual and other as automatic. Shutting down and restarting and you can see how the jobs come back, with the automatic one starting immediately. In the next clip I go one step further and copy the state between two live instances. </p>



<figure><figcaption>Dragging a persisted job between independent instances</figcaption></figure>



<p>When combined with remote shells, this becomes a really potent administration and automation tool. Perform a task once; visually confirm that the results matched expectations; Save the state and replay wherever and whenever. Use that for knowledge sharing, or hook it up to an event source for snapshotting and rollback to give anything history/undo. </p>



<p><strong>Special Topic: Frontending</strong></p>



<p>There is little consistency between many popular tools, no matter if they come as “argv hell”, “CLIs within the CLI” or “lots of small binaries”. This is natural, but also undesired from a user perspective. It feels rather futile to have gone through the strides of building a CLI that behaves like you want it to —  just to have the work be undone by the tools you launch from it.</p>



<p>I am no stranger to uphill battles, but the odds of getting the likes of wpa_supplicant, git, gdb/lldb or ffmpeg to change their evil ways and follow the one true path are slim to none. The passive aggressive form of dealing with this is what bash_completion and the likes do – create helper scripts that at least make polite suggestions while building the command line. This works poorly when the tool is interactive. Other options include defining better programmable interfaces, language server style external oracles, then hope for the main drivers to convert.</p>



<p>With the extensive scripting, parsing and rendering options available to us now – there is a more actively aggressive way. In Cat9, you can define multiple sets of builtins and views, and switch between them. This means that you can create a set of builtins for a specific logical function, like networking, programming or debugging, then swap between those as needed.</p>



<p>This, along with views, will be the more active area being developed for future releases. The following short clip shows an early ‘in progress’ such set for networking.</p>



<figure><figcaption>Swap sets of builtins commands at runtime to build logically grouped CLIs</figcaption></figure>



<p>In the clip you can see the set of builtins being swapped to ‘networking’ which new builtins such as ‘wifi’. You can see the live completion of available SSIDs appearing asynchronously as a scan is complete. Commands can still be forwarded ‘raw’ with the output packaged into its own job that can be used by the other builtins. It can also attach polling status about signal levels and connection into the prompt, using all the same infrastructure as the previous demonstrations.</p>



<p><strong>In Closing</strong></p>



<p>I hope this conveyed some of the benefits of leaving the shackles of terminal emulators and its more abstract form of ‘virtualisation for compatibility through emulation as default’ behind. There are a whole lot more ideas to squeeze into this setup now that all the grunt work has been dealt with. </p>



<p>Better CLIs as part of better TUIs are key for making <a href="https://www.divergent-desktop.org/blog/2020/08/10/principles-overview/#p1">professional computing</a> more accessible to budding sprout experts and cognitively challenged alike. The building blocks are here for your ‘speech- assisted’ command-lines without having to have a screen reader try and make sense of a poorly segmented word soup, or for your red team approved secret “leave no trace” cleanup sauce. </p>



<p>The last article in this series will dip into the programmable surface – how the APIs replacing curses work and integrate with the display server / window manager.</p>
											</div></div>
  </body>
</html>
