<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wuffs.org/blog/emulating-mac-compilers">Original</a>
    <h1>Mpw-Emu: Emulating 1998-Vintage Mac Compilers</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapperGrid">
    




    <section id="body">
        
<p>
	<time datetime="2022-02-28T22:05:00+00:00">
		Published 28th Feb 2022
	</time>
</p>

<p>Wherein I run classic Mac command-line development tools on a modern computer, using Rust, Unicorn Engine and a pile of hacks.</p>

<hr/>

<p>I&#39;ve been poking on-and-off at the classic Mac version of Yoot Tower, an underrated simulation game. I&#39;ve wanted to try my hand at decompiling it, but to do that, I need a comparable compiler.</p>
<p>I won&#39;t talk too much about the game here because I would like to write another post about it at some point, but to cut a long story short, it appears to be compiled using <a href="http://macintoshgarden.org/apps/codewarrior-professional-release-1">Metrowerks CodeWarrior Pro 1</a> and the Metrowerks PowerPlant library from Pro 2.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/emulating-mac-compilers/cw_ide.png"><img alt="The CodeWarrior IDE on a Mac emulator, showing the project view and a template code file" src="https://wuffs.org/user/pages/02.blog/emulating-mac-compilers/cw_ide.png"/></a></p>
<p>These tools run okay in an emulated Mac OS environment using QEMU (except for the debugger), but it&#39;s not the most pleasant experience.</p>
<p>Getting files in and out of QEMU requires faffing about with networking, and editing code in an IDE from 1998 is cute but rather impractical for somebody used to VSCode and Neovim. There&#39;s also a strange issue where the mouse cursor occasionally jumps to the corner of the screen. There&#39;s fixes and workarounds for these issues, but it would be a lot nicer if I could just use my standard text editor outside the emulator.</p>

<p>With GameCube/Wii nonsense, I can run the command-line CodeWarrior compiler on a modern system very easily - it&#39;s a 32-bit Windows executable that runs natively under practically any Windows, or in WINE on Linux and Mac.</p>
<p>Unfortunately, the same isn&#39;t true here. Macintosh Garden has a Windows disc image for CW Pro 1 which supports cross-compilation, but Metrowerks only saw fit to support building code for 68K Macs from it, and Yoot Tower is PowerPC.</p>
<p>There was still hope, though. The CodeWarrior Reference CD contained documentation for a command-line compiler, which I spent an embarrassingly long time trying to find. It turns out it&#39;s included as part of their MPW package.</p>

<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/emulating-mac-compilers/mpw.png"><img alt="The default instructional document in MPW" src="https://wuffs.org/images/8/4/8/a/b/848ab9d8c85e7fabd325822aa0ae42a1e47609c3-mpw.png"/></a></p>
<p>MPW is the <a href="https://en.wikipedia.org/wiki/Macintosh_Programmer&#39;s_Workshop">Macintosh Programmer&#39;s Workshop</a>, a rather strange tool that represents 80s Apple&#39;s take on a combined IDE and shell. You get a persistent document you can enter commands into, and you execute one by placing the cursor on the line and pressing ⌘-Enter - with the output being added to the document underneath.</p>
<p>All of the tools I needed could be accessed via MPW. Could I get these to run externally somehow?</p>
<p>There&#39;s an existing project on GitHub (<a href="https://github.com/ksherlock/mpw">ksherlock/mpw</a>) which does this, but only for 68K executables, so that wouldn&#39;t do the job for me. It&#39;s definitely possible, though... am I masochistic enough to try and implement my own? <em>(Spoiler: yes)</em></p>
<p>I&#39;ve never touched any form of classic Mac development before, so this is a bit of an adventure. Here&#39;s an introduction to the platform just so you know what we&#39;re dealing with.</p>

<p>When you think of a Mac today, what comes to mind is probably <del>Mac OS X</del> macOS - a Unix-like system built on top of the XNU kernel. It&#39;s got lots of proprietary Apple libraries on top of it, fancy graphics, and various quirks, but it&#39;s still POSIX-compliant.</p>
<p>You could be forgiven for looking at a screenshot of Mac OS 9 and thinking it&#39;s broadly the same. While the user interface has many similarities, that&#39;s pretty much where it ends.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/emulating-mac-compilers/system6.png"><img alt="Emulated System 6, showing the About window and the Control Panel" src="https://wuffs.org/images/7/7/9/3/3/77933bbde06ecc704384ebc51f1d5c15625d48aa-system6.png"/></a></p>
<p>The first Mac had a Motorola 68000 microprocessor, 128KB of RAM and a basic (by our current standards) operating system. The screen was black and white (you didn&#39;t even get shades of grey), and you could only run one app at a time, but it was still pretty cool. This was almost two years before the first Windows was released!</p>
<p>The OS <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS#Release_history">slowly evolved</a> throughout the years, gaining features like networking, multitasking, system extensions and virtual memory. We take it all for granted today, but this probably seemed revolutionary at the time.</p>
<p>The System 7 series in the 1990s also saw Apple&#39;s first CPU architecture transition, where they moved the Mac from Motorola&#39;s 68K chips to PowerPC, as well as including an emulator that allowed 68K executables to run.</p>
<p>If you think this stuff is interesting, <a href="https://www.folklore.org/">Folklore.org</a> has a ton of fun stories and anecdotes about the development of the original Mac and its operating system. I&#39;ve wasted far too much time reading them :p</p>
<p>Classic Mac OS was wildly different from its competitors, which was both an advantage and a disadvantage. We struggle today with the differences between Windows and Unix-likes (a recurring issue with cross-platform development tools), such as path separators, but even these aren&#39;t quite as stark as the differences between the classic Mac and everything else.</p>
<h2>File Management</h2>
<p>I&#39;d say this is probably <em>the</em> biggest thing that separates the classic Mac from... everything else. Graphical file managers on Windows and other Unix-likes were built to display a hierarchical file system that already existed. On the Mac, the GUI was designed first, and then the file system was built under it.</p>
<p>Take a hypothetical file on a typical Windows 95 system called <code>passport.pdf</code>. This is essentially what the OS knows about the file...</p>
<ul>
<li>It&#39;s called <code>passport.pdf</code>, so it&#39;s probably a PDF</li>
<li>It exists within <code>C:\My Documents\Important</code></li>
<li>It contains a stream of bytes, which may or may not be a PDF ¯\_(ツ)_/¯</li>
<li>It has timestamps for when it was created, modified and last accessed</li>
<li>It has attributes (read-only, hidden, system)</li>
</ul>

<p>Mac OS keeps track of a boatload of extra stuff. This is what you could expect from a similar breakdown of a Mac file.</p>
<ul>
<li>It&#39;s called <code>Passport</code>, and exists inside directory ID 37
<ul>
<li>If you dig through the tree, you could get the path <code>Macintosh HD:Documents:Important:Passport</code></li>
<li>The Mac OS APIs mostly avoid using paths, preferring to identify files by their name and parent directory ID</li>
</ul></li>
<li>Its type code is <code>PDF</code>, and its creator code is <code>CAR0</code></li>
<li>Its data fork contains a stream of bytes, which is probably a PDF</li>
<li>Its resource fork is empty (more on this later)</li>
<li>It has timestamps for when it was created and modified</li>
<li>It has lots of attributes (locked, ...)</li>
<li>It has Finder-specific data: visual position in its parent directory, user-specified tags, and more</li>
</ul>
<p>Very different. Not necessarily better or worse in every aspect, but of course this is a bit of a problem for interoperability.</p>
<h3>Extensions vs. Type/Creator Codes</h3>
<p>Identifying files has been a perennial issue in computing. MS-DOS used three-letter file extensions, and these stayed around into Windows. If I take a photo and rename it from <code>dog.jpg</code> to <code>dog.exe</code>, Windows will happily try to execute it, and then tell me it&#39;s not a valid application. If I rename it to <code>dog.xlsx</code>, then it&#39;ll try to open Excel, which will of course have no idea what to do.</p>
<p>The Mac went for codes instead, which are stored in the file system metadata and cannot be easily changed. (It&#39;s possible of course, but not through the standard Finder interface.)</p>
<p>Here&#39;s some I found on my emulator, for a rough idea about how they were used...</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Name in Finder</th>
<th>Type</th>
<th>Creator</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acrobat Reader executable</td>
<td>application program</td>
<td><code>APPL</code></td>
<td><code>CAR0</code></td>
</tr>
<tr>
<td>PDF</td>
<td>Acrobat™ Reader 4.0 document</td>
<td><code>PDF</code></td>
<td><code>CAR0</code></td>
</tr>
<tr>
<td>Readme text file</td>
<td>SimpleText text document</td>
<td><code>TEXT</code></td>
<td><code>ttxt</code></td>
</tr>
<tr>
<td>C++ file created in CodeWarrior</td>
<td>CodeWarrior text file</td>
<td><code>TEXT</code></td>
<td><code>CWIE</code></td>
</tr>
<tr>
<td>Object file compiled by CodeWarrior</td>
<td>CodeWarrior library</td>
<td><code>MPLF</code></td>
<td><code>CWIE</code></td>
</tr>
<tr>
<td>Finder executable</td>
<td>file</td>
<td><code>FNDR</code></td>
<td><code>MACS</code></td>
</tr>
<tr>
<td>Chicago fonts</td>
<td>font suitcase</td>
<td><code>FFIL</code></td>
<td><code>DMOV</code></td>
</tr>
<tr>
<td>QuickTime movie</td>
<td>QuickTime Player document</td>
<td><code>MooV</code></td>
<td><code>TVOD</code></td>
</tr>
<tr>
<td>Yoot Tower save game</td>
<td>Yoot Tower document</td>
<td><code>T2Dc</code></td>
<td><code>PPT2</code></td>
</tr>
<tr>
<td>Yoot Tower plugin</td>
<td>Yoot Tower document</td>
<td><code>MvPI</code></td>
<td><code>PPT2</code></td>
</tr>
</tbody>
</table>
<p>Note that different kinds of text files share the same <code>TEXT</code> type, but have a different creator, so the OS knows which application they&#39;re associated with.</p>
<p>CodeWarrior will refuse to compile C++ code that&#39;s in a file without the <code>TEXT</code> type, but it doesn&#39;t care about the creator, so it&#39;s okay with me writing C++ in SimpleText.</p>
<h3>Resources</h3>
<p>Mac OS has a rather intricate subsystem for storing resources alongside files, in what&#39;s called the <strong>resource fork</strong>. This is basically a B-side to a file, and uses a standard container format.</p>
<p>The OS gives you tools for reading and writing resources. There&#39;s various standard resource types that store all sorts of things (icons, cursors, pictures, sounds, string tables, window layouts, ...) but you can also create your own types with custom formats.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/emulating-mac-compilers/resedit.png"><img alt="Netscape Communicator open in ResEdit, showing off some menus, icons and a dialog box" src="https://wuffs.org/images/a/7/4/b/f/a74bfa48ef61b755335161989119a1db12cf4085-resedit.png"/></a></p>
<p>Instead of trying to explain them, I&#39;ll just show you a screenshot from ResEdit (Apple&#39;s graphical tool for viewing + editing resources).</p>
<p>Here you can see some resources from <code>DLOG</code> (dialog box templates), <code>MENU</code> (menus), <code>PICT</code> (bitmap images) and <code>BNDL</code> (icons used for files in the Finder).</p>

<p>Note how the <code>BNDL</code> resource, at the bottom right, maps specific icons to specific type IDs. This is what determines whether a file created by Netscape (creator code <code>MOSS</code>) looks like a webpage, a preference file, a URL, or something else altogether. <em>It all comes together!</em></p>
<p>Since resources can be modified on-the-fly, Apple even encourages applications to use them for storing user data like preferences. Not every app does this, but this means that you can actually have a single file which is a self-contained unit and can be taken to another machine easily.</p>
<p>Or, well, it&#39;s easy if you only interact with other Macs...</p>
<h3>Entering and Leaving the Mac World</h3>
<p>How do you take one of these files elsewhere? A PDF or a text file is pretty straightforward - they don&#39;t use resources. But say I want to upload my cool new Mac app to my Linux web server - what now?</p>
<p>There were a few different options for this back in the day, like <a href="https://en.wikipedia.org/wiki/MacBinary">MacBinary</a> and <a href="https://en.wikipedia.org/wiki/BinHex">BinHex</a>. You may have seen old Mac files with the <code>.hqx</code> extension around - that&#39;s BinHex!</p>
<p>These are just schemes that take the two forks and relevant metadata and combine them into a single blob which can be passed around on non-Mac systems easily.</p>
<p>If I upload a file from Internet Explorer 5 for Mac, the server will receive a MacBinary formatted blob. Likewise, if I download a MacBinary file, it will automatically be decoded.</p>

<p>The resource fork isn&#39;t really used by post-OS X Mac software, but the functionality lives around - and the modern macOS Finder still supports metadata, so that needs to go somewhere.</p>
<p><a href="https://en.wikipedia.org/wiki/AppleSingle_and_AppleDouble_formats">AppleDouble</a> lives on today, which is Apple&#39;s own portability implementation that stores the resource fork + metadata in a separate file. You have probably seen these without realising, in the form of files that have names starting in <code>._</code> and <code>.DS_Store</code> - a phenomenon so hateful that someone once riffed on it by making a Twitter bot that automatically replied to any tweet mentioning <code>.DS_Store</code> with the word <code>.DS_Store</code> and a file emoji. </p>
<h2>Pascal Strings</h2>
<p>Another fun quirk about programming for the classic Mac is that the libraries were all created to target Pascal, with C/C++ as a second-class citizen. This is most obvious when dealing with strings.</p>
<p>C does not have first-class strings, and instead uses arrays of characters where the string is terminated by a null character (zero). Pascal actually has strings, but they&#39;re encoded differently: the first byte represents the amount of characters in the string.</p>
<table>
<thead>
<tr>
<th>String</th>
<th>C</th>
<th>Pascal</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#34;Hi&#34;</td>
<td><code>48 69 00</code></td>
<td><code>02 48 69</code></td>
</tr>
<tr>
<td>&#34;Hey&#34;</td>
<td><code>48 65 79 00</code></td>
<td><code>03 48 65 79</code></td>
</tr>
<tr>
<td>&#34;Hola&#34;</td>
<td><code>48 6F 6C 61 00</code></td>
<td><code>04 48 6F 6C 61</code></td>
</tr>
</tbody>
</table>
<p>Compilers for the Mac try to paper over these differences by letting you enter Pascal string literals using special syntax (<code>&#34;\pHey&#34;</code> generates a string containing the appropriate length prefix), but you still have to be mindful of it while writing code.</p>
<h2>Memory Management</h2>
<p>Memory is a scarce resource on old machines. Mac OS has a fairly complex memory manager to try and get the most out of it. There are two main ways to allocate memory.</p>
<h3>Pointers</h3>
<p><code>NewPtr</code> is analogous to standard C&#39;s <code>malloc</code>, and simply gives you a block of memory you can work with. You can free it using <code>DisposePtr</code>, or resize it using <code>SetPtrSize</code>. (Unlike C&#39;s <code>realloc</code>, this will only work if there&#39;s enough space to resize the block - it will not reallocate it elsewhere for you.)</p>
<h3>Handles</h3>
<p><code>NewHandle</code> is the entry point to the Mac&#39;s relocatable memory blocks, and that&#39;s where things get fun. You are given a pointer to a pointer to a memory block. This allows the OS to move the blocks around to minimise fragmentation of the heap.</p>
<p>Say you call <code>NewHandle(1024)</code>, requesting a kilobyte of memory. You might receive the handle <code>(void **) 0x10330404</code>, which can be dereferenced to <code>(void *) 0x10801000</code> (your 1024-byte long block).</p>
<p>At some point later on, you ask for a much larger allocation of 300KB. There isn&#39;t enough contiguous space to fulfil that, but wait-- if we relocate your 1024-byte block at <code>0x10801000</code> elsewhere, now we have 300KB to give you.</p>
<p>The OS quietly moves your 1024-byte block to <code>0x10653400</code>, and writes that address to <code>0x10330404</code>.</p>
<p>You didn&#39;t store the address of the block, you stored the address of the <em>handle</em>. The next time you want to access the block, you&#39;ll dereference <code>(void **) 0x10330404</code>, which now contains the new location of the block. Success!</p>

<p>There are various control functions that allow you to influence the behaviour of the memory manager. For example, you can use <code>HLock</code> and <code>HUnlock</code> to temporarily stop the OS from relocating specific blocks, in case you need to work with interior pointers directly.</p>
<p>There&#39;s enough RAM on modern systems that I haven&#39;t bothered implementing relocations into my emulator. It implements the Handle functions so that the guest application can allocate memory, but it will never actually relocate the block unless <code>SetHandleSize</code> is used to make it larger.</p>
<h2>Executables</h2>
<p>Mac OS supports two executable formats, XCOFF and the newer PEF (Preferred Executable Format). For the time being, I&#39;ve only investigated and implemented PEF support.</p>
<p>PEF is a pretty straightforward format for both executables and shared libraries, so there&#39;s not really much to say about it.</p>
<p>Hopefully, this has given you enough of a background on the classic Mac OS to follow along with the next parts. It&#39;s time to write some code!</p>

<p>My first goal was to try and make sense of Mac executables, so I started with a trivial disassembler.</p>
<p>The PEF structure is documented by Apple&#39;s Inside Macintosh, which is kindly <a href="https://web.archive.org/web/20020208214155/http://developer.apple.com/techpubs/mac/runtimehtml/RTArch-89.html">archived</a> by the Wayback Machine. I threw together some Rust code using <a href="https://github.com/jam1garner/binread">binread</a> to parse the structures and print them out, so I had a better idea what I was dealing with.</p>

<p>The files I was looking at all followed a fairly straightforward template.</p>
<ul>
<li><strong>Section 0: Code</strong>
<ul>
<li>Contains all the PowerPC instructions, and some debugging structures directly following functions</li>
<li>Ghidra calls them &#39;PEF_Debug&#39;, CodeWarrior&#39;s dumping tool calls them &#39;traceback tables&#39;</li>
</ul></li>
<li><strong>Section 1: Data</strong>
<ul>
<li>Contains the Table of Contents (pointers to all data used)</li>
<li>Contains all constant data</li>
<li>Contains placeholders for all global data</li>
<li>No distinction is made between any of these, they&#39;re lumped into the same block</li>
<li>Encoded using a rudimentary compression format called &#39;pattern-initialised data&#39;</li>
</ul></li>
<li><strong>Section 2: Loader</strong>
<ul>
<li>Contains the entry point and initialisation/termination function addresses</li>
<li>Contains info about imported symbols and libraries</li>
<li>Contains a hash table of exported symbols</li>
<li>Contains relocations</li>
</ul></li>
</ul>
<h2>Table of Contents</h2>
<p>The TOC is the most interesting part of the PowerPC Mac ABI. Consider this dilemma...</p>
<p>PowerPC instructions are a fixed 32 bits. Loading a 32-bit address into a register therefore requires two instructions.</p>
<pre><code>lis r3, 0x8042       # set r3 to 0x8042 &lt;&lt; 16
ori r3, r3, 0xF980   # r3 = r3 | 0xF980</code></pre>
<p>This takes extra space and also requires more relocations, as each and every load must be adjusted when the executable is loaded into memory.</p>

<p>This is where the TOC comes in, as an index of all addresses required by the executable. Register 2 (sometimes called <em>rtoc</em>) is always a pointer to a specific location in the Data section.</p>
<p>PowerPC&#39;s load and store instructions allow you to specify a location by using a register and a signed 16-bit offset. Hence, if rtoc is set to <code>0x8042F980</code> and you want to read the pointer stored at <code>0x8042F878</code>, you can use the instruction <code>lwz r3, -0x108(r2)</code> and do it easily.</p>
<h3>Transition Vectors and Glue Functions</h3>
<p>Assuming that r2 always points to the same location is all well and good inside your executable, but what do you do if you need to call a function from a different library - which almost certainly has a different TOC?</p>
<p>Code is addressed using what&#39;s called a <strong>transition vector</strong>. This is just a tiny structure that contains an address to the code and the address of that code&#39;s TOC.</p>
<p>The linker generates <strong>glue functions</strong> which are tiny helpers for this purpose. Here&#39;s what happens, with annotations for those of you who aren&#39;t as familiar with PowerPC assembly.</p>
<pre><code>    # calling an imported function (&#39;GetDateTime&#39;)
    bl GetDateTime           # call the glue function
    lwz r2, 0x14(r1)         # reload rtoc from a fixed location on the stack
    # ... (more stuff) ...

GetDateTime:
    lwz r12, -0x7ED4(r2)     # load a pointer to the transition vector from the TOC, into r12
    stw r2, 0x14(r1)         # save our current rtoc to the stack
    lwz r0, 0(r12)           # load a pointer to GetDateTime&#39;s code into r0
    lwz r2, 4(r12)           # load GetDateTime&#39;s rtoc value
    mtctr r0                 # move the code pointer from r0 into the special CTR register
    bctr                     # jump to the CTR register (without updating the return address)</code></pre>
<p>It saves the current TOC address to the stack, switches to the target function&#39;s TOC, calls it, and then reloads it.</p>
<p>Note that the <code>lwz r2, 0x14(r1)</code> instruction must be in the calling function and cannot be in the glue function. This is because the glue function performs a tail call (jumps straight to the target function).</p>
<p>Performing any extra operations in the glue function would require it to set up a stack frame so that it can save LR (the return address) and that would have a performance impact, so on the whole it makes more sense to just take the one-instruction penalty after each call.</p>
<h2>Relocations</h2>
<p>The PEF loader section can contain multiple relocation blocks, applied to different sections - but so far I&#39;ve only seen files that contain one block, applied to the data section.</p>
<p>Relocations are stored as a stream of commands which are executed in order. I won&#39;t go into detail here (you can read <a href="https://web.archive.org/web/20020112071109/http://developer.apple.com/techpubs/mac/runtimehtml/RTArch-98.html">the official docs</a> if you&#39;re really curious), but a typical stream looks like this.</p>
<ul>
<li>Write pointers to 12 imported symbols</li>
<li>Write pointer to imported symbol 13</li>
<li>Write pointers to 4 imported symbols</li>
<li>Skip 36 bytes and add the data section&#39;s base address to 4 consecutive pointers</li>
<li>Add the code section&#39;s base address to 17 consecutive pointers</li>
</ul>
<p>Most commands support a repeat count, and it even has a command which allows you to repeat a whole group of commands a specific amount of times. It&#39;s clearly optimised for space.</p>
<h2>Verifying my Code</h2>
<p>I had been analysing Mac executables using Ghidra, but it does some post-processing on PEF files and it wasn&#39;t clear to me what was part of the file and what was added by Ghidra.</p>
<p>I ended up implementing a simple disassembler using <a href="https://github.com/capstone-rust/capstone-rs">capstone-rs</a> which would take a PEF and spit out assembly, complete with labels for code/data references.</p>
<p>One neat trick is that since these binaries conform strictly to certain rules (e.g. always accessing pointers through the TOC), it makes it really easy to discover references which would normally require a certain level of code analysis.</p>
<p>After I&#39;d gotten that working, I decided to take what I&#39;d written and pivot into writing an emulator.</p>
<p><code>$ cargo new mpw-emu</code></p>

<p>The obvious choice to start with here is <a href="https://www.unicorn-engine.org/">Unicorn Engine</a>, which is essentially the CPU emulator from QEMU made into an embeddable library. I&#39;ve used it for a bunch of projects before. They&#39;ve brought Rust bindings into the tree now which is also quite cool!</p>
<h2>Bare Minimum</h2>
<p>I started by taking the PEF loading code I&#39;d written for my disassembler and reworking it so that it would &#34;link&#34; the executable into a byte array, with a fixed load address at <code>0x10000000</code>.</p>
<p>The process is pretty simple:</p>
<ol>
<li>Map some address space for the executable, and load in the results of my linker</li>
<li>Map some address space for dynamically allocated memory and for the stack</li>
<li>Set the stack pointer</li>
<li>Set the program counter and TOC pointer (using the entry point specified by the PEF)</li>
<li>Start the emulator</li>
</ol>
<p>Well, mostly. I&#39;ve glossed over one important aspect here, which is libraries. A fully-fledged Mac emulator would load these from Mac OS, and the linker would just match up all the transition vectors with the corresponding functions from libraries. We&#39;re not doing that, so we need some way to implement their behaviour.</p>
<h2>Hooking Imports</h2>
<p>The glue functions in the code I&#39;m emulating will automatically jump to a particular transition vector (a pair of values holding a code address and a TOC pointer) for each function. The challenge is... how do I make my own code run when this occurs?</p>
<p>Unicorn has various hooks where you can set a callback to be executed when a specific event occurs. One of them is &#34;interrupt&#34;, which for PowerPC is linked to the <code>sc</code> (Supervisor Call) instruction. If I make the emulator execute <code>sc</code>, then I can do something special.</p>
<p>I allocated some space for a tiny function which just executes <code>sc</code> and then returns. I can then insert that into the imported functions&#39; transition vectors. There&#39;s a TOC pointer I don&#39;t need, but I can use that as a bit of information that tells me <em>which</em> function was executed.</p>
<pre><code>for (i, sym) in loader.imported_symbols.iter().enumerate() {
    match sym.class {
        pef::SymbolClass::TVect =&gt; {
            let shim = self.allocate_memory(8);
            self.set_u32(shim, sc_thunk);
            self.set_u32(shim + 4, i as u32);
            self.shim_addrs.push(shim);
        }
        pef::SymbolClass::Data =&gt; {
            let shim = self.allocate_memory(1024);
            self.shim_addrs.push(shim);
        }
        _ =&gt; panic!()
    }
}</code></pre>
<p>I ended up with this logic. Pointers to functions receive this fake transition vector that contains the imported symbol&#39;s index as the TOC pointer, and pointers to data receive a 1024-byte placeholder block.</p>
<pre><code>fn intr_hook(uc: &amp;mut EmuUC, _number: u32) {
    let rtoc = uc.reg_read(RegisterPPC::GPR2).unwrap();
    let lr = uc.reg_read(74).unwrap();
    let pc = uc.pc_read().unwrap();

    let state = Rc::clone(uc.get_data());
    let mut state = state.borrow_mut();

    if state.exit_status.is_some() {
        // we have exited, go away
        // (unicorn keeps running code afterwards)
        uc.emu_stop().unwrap();
        return;
    }

    match state.imports[rtoc as usize].func {
        Some(func) =&gt; {
            let mut arg_reader = helpers::ArgReader::new();
            match func(uc, &amp;mut state, &amp;mut arg_reader) {
                Ok(Some(result)) =&gt; uc.reg_write(RegisterPPC::GPR3, result.into()).unwrap(),
                Ok(None) =&gt; {},
                Err(e) =&gt; {
                    error!(target: &#34;emulator&#34;, &#34;Error {e:?} while executing {} (lr={lr:08x})&#34;, state.imports[rtoc as usize].name);
                }
            }
        }
        None =&gt; {
            warn!(target: &#34;emulator&#34;, &#34;Unimplemented call to {} @{lr:08X}&#34;, state.imports[rtoc as usize].name);
        }
    }

    // NOTE: next unicorn will not need this i think?
    uc.set_pc(pc + 4).unwrap();
}</code></pre>
<p>The plan works! Whenever the emulator calls a library function, it loads the function&#39;s index into rtoc (r2) and invokes <code>sc</code>. Then, my hook looks at r2 to determine which function we should try and simulate.</p>
<h2>Floating Point</h2>
<p>I got a strange failure early on which didn&#39;t make sense. After looking at the relevant code in Ghidra, the problem became obvious - the emulator didn&#39;t know how to execute floating point instructions.</p>
<p>The FPU is turned off by default. The fix was simple - set the corresponding bit in the MSR (machine state register).</p>
<pre><code>// enable floating point
uc.reg_write(77, uc.reg_read(77)? | (1 &lt;&lt; 13))?;</code></pre>
<p>With that, we&#39;re ready to go.</p>

<p>The CodeWarrior C/C++ compiler (MWCPPC) imports over a hundred library functions, but I didn&#39;t want to just implement every single one right off the bat - I wanted to see results faster than that, so I ran it and implemented things as they came up.</p>
<p>Passing command line arguments required me to feed it the typical <code>argc</code> and <code>argv</code>, which in MPW land seem to be fetched from an imported data symbol called <code>_IntEnv</code>. I wrote some code to pass the arguments through and store them in the right location, and that made the compiler happy enough to print out some error messages. Progress!</p>
<h2>C Library</h2>
<p>I had to implement a decent amount of C standard library functions. For the most part, this isn&#39;t too big a deal. They&#39;re well-defined and well-documented, and most of the ones used in MWCPPC are quite simple.</p>
<p>At one point I had the compiler running and spitting out object files, but they didn&#39;t seem to be correct; they included code but no strings or names. It would also crash if I added a virtual method. After a few hours of frustration, I realised MWCPPC has an <code>-e</code> parameter which runs the preprocessor and spits out the resulting output. I tried it and got this result:</p>
<pre><code>  ();   { :  ~() { } };    [] = &#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;;  ( ,  ) { ();  ( * ) + ; }  ( *) {  (  = ;  &lt; ; ) { []  []; } }</code></pre>
<p>Oops? I wondered what could be going wrong here, so I had a look at my library functions instead... and realised that I&#39;d screwed up <code>memcpy</code> and it wasn&#39;t actually copying. Fixing that made everything work!</p>

<p>The most painful part of the C library to deal with was definitely <code>printf</code>. There are a couple of Rust crates that implement C-ish printf, but neither would have worked for me due to my constraints.</p>
<p>One implements <code>printf</code> with a variadic API, like the real C version. The other one accepts a slice of types, but you&#39;re expected to know what they are beforehand.</p>
<p>I have no way to build up a list of arguments without actually processing the format string, and there&#39;s one big thing that makes this tricky with PowerPC: floating point values are stored in a separate set of registers. I cannot tell the difference between <code>func(1.0, 100)</code> and <code>func(100, 1.0)</code> as in both cases, r3 will contain 100 and fp1 will contain 1.0.</p>
<p>I ended up implementing my own, which doesn&#39;t currently include every part of the standard feature set, but does enough to run MWCPPC correctly.</p>
<h2>Macintosh Toolbox</h2>
<p>The largest chunk of the work here is certainly in implementing the Toolbox APIs. I mainly need to be concerned with resources, memory management and file management. I went into detail earlier in this post about these three features, but I haven&#39;t really explained <em>how</em> I emulated them.</p>
<p>There&#39;s a number of function calls I can either ignore entirely, or simply return static values from.</p>
<p>MWCPPC makes calls to functions in QuickDraw (graphics API) to set up graphics state and set the mouse cursor, but these don&#39;t actually matter to us.</p>
<p>There&#39;s also the Gestalt, which is a mechanism by which applications can get info about the system. There is a <a href="https://web.archive.org/web/20020106045454/http://developer.apple.com/techpubs/mac/OSUtilities/OSUtilities-13.html#MARKER-9-463">wide variety</a> of &#39;selectors&#39;, ranging from the AppleTalk version number to the amount of NuBus slots present. Thankfully we can ignore most of them and just implement the ones that MWCPPC asks for.</p>
<p>I tell it that we have an alias manager, no special OS features, and no support for FindFolder. Skipping the latter two saves me some work, but it does get me the warning &#34;<em>-mf ignored since your system doesn&#39;t support Real Temp Memory</em>&#34;.</p>
<h2>Resources</h2>
<p>Toolbox exposes APIs for manipulating resources, but MWCPPC doesn&#39;t need most of them which is lucky. I can get away with just implementing <code>GetResource</code> and <code>Get1Resource</code>, which return a handle containing the resource&#39;s data.</p>
<p>I parse the executable&#39;s resources and load them into a Rust structure on startup (memory is way cheaper in 2022 than in the 1990s after all!), and I also have a <code>HashMap&lt;(FourCC, i16), u32&gt;</code> storing which resources have already been loaded into the emulated memory.</p>
<p>When a resource is requested, I check the map to see if it&#39;s already loaded. If not, I allocate a new handle and copy the resource&#39;s data to that handle.</p>
<h2>Memory Management</h2>
<p>This is a necessity for anything non-trivial. My first shot at the emulator didn&#39;t actually support freeing memory, I would just increment a pointer every time an allocation was performed. It worked OK, but I knew I would need something a <em>little</em> more robust so I sunk some time into writing a minimal memory manager.</p>
<p>What I came up with is not really optimal, but it&#39;s reasonably simple and that fits the bill here.</p>
<p>I allocate a fixed amount of address space (currently 8MB) towards dynamic allocations. I reserve a little space at the beginning for handles, and then the rest is split into blocks which are connected in a linked list.</p>
<p>At the start, the entire region is covered by one large block of free space. Each block has a 16-byte header with information.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>User Size</td>
<td>Size of the user-requested allocation, or <code>0x80000000</code> if the block is free</td>
</tr>
<tr>
<td>4</td>
<td>Block Size</td>
<td>Size of this block, including header</td>
</tr>
<tr>
<td>8</td>
<td>Prev</td>
<td>Pointer to the previous block, or 0</td>
</tr>
<tr>
<td>12</td>
<td>Next</td>
<td>Pointer to the next block, or 0</td>
</tr>
</tbody>
</table>
<p>There are four core operations that I need to support.</p>
<h3>NewPtr/NewHandle</h3>
<p>I scan the list of blocks, starting at the end, looking for the first block which is free and able to hold the requested allocation (rounded up to 16 bytes).</p>
<p>Once a suitable block is found, I compare its size to the requested allocation. If there&#39;s at least 32 bytes left over, then I split the block in two, creating a used block (just big enough to hold the allocation) and a free block (with the remaining space). If not, I simply mark the entire block as used.</p>
<h3>DisposePtr/DisposeHandle</h3>
<p>I subtract 16 from the pointer to get the address of the allocation block, and then mark it as free.</p>
<p>If the next block after it is free, then I merge it into the disposed block, creating one large big block.</p>
<p>If the previous block before it is free, then I merge it into the disposed block, creating one large big block.</p>
<p>This means that two free blocks should never appear consecutively in the list (as they&#39;ll be merged together by the Dispose operation), which simplifies the process of finding an appropriate free block when allocating memory.</p>
<h3>GetPtrSize/GetHandleSize</h3>
<p>This one is straightforward. I subtract 16 from the pointer to get the address of the allocation block, and then return the user size from it.</p>
<h3>SetPtrSize</h3>
<p>Block resizing is trickier, and I was worried about screwing it up. I managed to implement both of these operations using the methods I&#39;d already built, which I was quite pleased with.</p>
<p><code>SetPtrSize</code> allows you to make a block smaller, and <em>possibly</em> allows you to make it larger, but this can fail as there may not be enough space directly following it.</p>
<ul>
<li>If the next block is free, then merge it with the block that&#39;s being resized
<ul>
<li>This grows the block to its maximum size, up to either the next used block <em>or</em> the end of the heap</li>
</ul></li>
<li>If the block has enough space to fit the desired size, then change its user size to match
<ul>
<li>If the new user size is larger than the old size, fill the extra space with null bytes</li>
</ul></li>
<li>Regardless of whether it succeeded or not, split the block into a used + free pair again</li>
</ul>
<p>This elegantly handles both growing and shrinking the allocation. In either case, the resulting state will contain a used block that&#39;s only as big as necessary, and a free block with any leftover space.</p>
<h3>SetHandleSize</h3>
<p><code>SetHandleSize</code> always allows you to resize a block - handles are relocatable, so the OS can simply allocate a new contiguous block and move your data over if necessary.</p>
<p>I first try to use <code>SetPtrSize</code> to resize the backing buffer to the requested size. If this doesn&#39;t work, I allocate a new backing buffer, update the handle to point to it, move the data over and then free the old buffer.</p>
<h3>Other Nonsense</h3>
<p>The Mac OS memory subsystem supports a bunch of other stuff, like the ability to lock a handle so that the OS won&#39;t relocate its backing buffer, but I haven&#39;t implemented any of it.</p>
<p>If I run into memory issues, I can expand the heap size, or possibly even add the ability to dynamically grow it. I&#39;m keeping it simple for now though as this may just not be necessary at all for my use cases.</p>
<h2>File Management</h2>
<p>As I explained in an earlier part of this article, file management is where classic Mac OS is just completely out of touch with every other OS. This makes it an interesting challenge to try and give the guest application access to files.</p>
<p>Files and directories are accessed using an object called <code>FSSpec</code>, which contains a volume ID, a directory ID and the name of the file/directory. There&#39;s no absolute path to a file, because Mac OS doesn&#39;t want you to do that.</p>
<p>There&#39;s also multiple different kinds of file system APIs that operate at different levels of abstraction. The documentation is littered with warnings which quite frankly terrify me.</p>
<blockquote>
<p><a href="https://web.archive.org/web/20020224083751/http://developer.apple.com/techpubs/mac/Files/Files-211.html">HOpen</a>: If you use <code>HOpen</code> to try to open a file whose name begins with a period, you might mistakenly open a driver instead; subsequent attempts to write data might corrupt data on the target device. To avoid these problems, you should always use <code>HOpenDF</code> instead of <code>HOpen</code>.</p>
<p><a href="https://web.archive.org/web/20011217193144/http://developer.apple.com/techpubs/mac/Files/Files-129.html">FSClose</a>: Make sure that you do not call <code>FSClose</code> with a file reference number of a file that has already been closed. Attempting to close the same file twice may result in loss of data on a volume. See &#34;File Control Blocks&#34; on page 2-81 for a description of how this can happen.</p>
</blockquote>

<p>I ended up doing something rather hacky which I&#39;m not all too happy with, but it&#39;s a compromise that I might revisit later.</p>
<p>I ignore volumes entirely, exposing everything as if it were part of the &#39;default volume&#39; with ID 0. I assign IDs sequentially to directories whenever the guest application needs to learn about a directory.</p>
<p>I implemented enough of the functions to make MWCPPC run and generate object files, but I&#39;m almost certainly going to need to put more in later on.</p>
<p>At some point I might have to implement the functions that allow for iteration through a directory&#39;s contents, and that scares me a bit :p</p>
<h2>Smoke Test</h2>
<p>It works!</p>
<pre><code>$ ./target/debug/mpw-emu MWCPPC.bin example.cp
### MWCPPC.bin Usage Warning:
# -mf ignored since your system doesn&#39;t support Real Temp Memory
### MWCPPC.bin Usage Warning:
# the environment variable &#39;MWCIncludes&#39; is not set</code></pre>
<p>At some point I&#39;ll hopefully get the disassembler to work too - I need to implement more junk for it. It currently chokes on me hardcoding the type ID of input files as <code>TEXT</code>, and if I change that, then it fails because it uses a different function for opening files that I haven&#39;t yet gotten to work.</p>
<pre><code>$ RUST_LOG=debug ./target/debug/mpw-emu MWDumpPPC.bin example.cp.o
[2022-02-28T21:35:19Z DEBUG linker] Section: None Default=0 Size(Total=17460, Unpacked=17460, Packed=17460) Kind(Section=Code, Share=GlobalShare) Align=4
[2022-02-28T21:35:19Z DEBUG linker] Section: None Default=0 Size(Total=7B08, Unpacked=5FDC, Packed=4BCD) Kind(Section=PatternInitData, Share=ProcessShare) Align=4
[2022-02-28T21:35:19Z DEBUG linker] Section: None Default=0 Size(Total=0, Unpacked=0, Packed=5C4) Kind(Section=Loader, Share=GlobalShare) Align=4
[2022-02-28T21:35:19Z DEBUG stdlib] _IntEnv ptr is at: 1011F3D4
[2022-02-28T21:35:19Z DEBUG emulator] Main: code=10000218, rtoc=10017460
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to setvbuf @10006904
[2022-02-28T21:35:19Z INFO  stdlib] signal(2, 10017D84)
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to TrapAvailable @100007B0
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to SetResLoad @1000035C
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to SetResLoad @1000041C
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to CurResFile @1000693C
[2022-02-28T21:35:19Z INFO  files] MakeResolvedFSSpec(vol=0, dir=0, name=&#34;example.cp.o&#34;, spec=1011ECF8, ...)
[2022-02-28T21:35:19Z DEBUG fs] 10 =&gt; &#34;/Users/ash/src/mpw-emu&#34;
[2022-02-28T21:35:19Z INFO  files] HCreate(vol=0, dir=10, name=&#34;example.cp.o&#34;)
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to CurResFile @100064DC
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to FSpOpenDF @100147F0
[2022-02-28T21:35:19Z INFO  files] MakeResolvedFSSpec(vol=0, dir=0, name=&#34;SysErrs.Err&#34;, spec=1011EB1C, ...)
[2022-02-28T21:35:19Z INFO  files] MakeResolvedFSSpec(vol=0, dir=0, name=&#34;SysErrs.Err&#34;, spec=1011EB1C, ...)
[2022-02-28T21:35:19Z INFO  files] MakeResolvedFSSpec(vol=0, dir=0, name=&#34;SysErrs.Err&#34;, spec=1011EB1C, ...)
### MWDumpPPC.bin Linker Error:
# Can?t read library file ?example.cp.o?.
# OS error -4872 (Error message file not available)
[2022-02-28T21:35:19Z WARN  emulator] Unimplemented call to UseResFile @10006648
# errors caused tool to abort
[2022-02-28T21:35:19Z INFO  stdlib] exit(1)</code></pre>
<p>But hey, we&#39;re getting there!</p>
<p>I tend to write projects in a very experimental and messy fashion as I learn what I&#39;m doing, and then I&#39;ll clean them up once I&#39;m more familiar with the problem space.</p>
<p>I originally had all of my standard library functions in a single <code>match</code> block, but I&#39;ve broken them out into individual functions and split them into files based on what C header they come from. I also created an <code>ArgReader</code> object which wraps argument parsing, making this whole business way more elegant.</p>

<p>Now that the codebase is less of a trash fire, I&#39;d like to make more progress and run some of the other MPW tools. There&#39;s almost certainly more issues that will arise with MWCPPC that I haven&#39;t yet come across in my limited testing.</p>
<p>I still have my pipe dream of decompiling Yoot Tower, but that&#39;s a fairly hefty task so in all likelihood it won&#39;t actually happen. At least I&#39;ve had some fun with this project...</p>
<p>Find the source code on GitHub here: <a href="https://github.com/Treeki/mpw-emu/">https://github.com/Treeki/mpw-emu/</a></p>

<hr/>
<p>
		<b>Previous Post:</b> <a href="https://wuffs.org/blog/reversing-games-with-hashcat">Reversing Games with... Hashcat???</a>
	<br/>
	
	</p>
    </section>


</div></div>
  </body>
</html>
