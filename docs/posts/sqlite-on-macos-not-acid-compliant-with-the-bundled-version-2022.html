<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bonsaidb.io/blog/acid-on-apple/">Original</a>
    <h1>SQLite on macOS: Not ACID compliant with the bundled version (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    
    <p>
        
        Written by <a href="https://github.com/ecton">Jonathan Johnson</a>.
        
        
        Published 2022-06-14.
        
        
    </p>
    
    <p>I&#39;m building <a href="https://bonsaidb.io/about">a database</a>, and I consider SQLite a &#34;gold standard&#34; to
compare my database against. While benchmarking new code recently, I noticed
Apple&#39;s bundled version of SQLite is not ACID compliant.</p>
<p>I do not consider myself an expert on these topics. If there are any errors in
my analysis, please reach out to me, and I will correct them immediately. I&#39;m
learning by doing, and as evidenced by <a href="https://bonsaidb.io/blog/durable-writes">my last post on this
topic</a>, I have made my own fair share of mistakes in
trying to implement a fast, ACID-compliant database.</p>
<h2 id="">


<a href="#Confusion%20about%20SQLite%20and%20F_BARRIERFSYNC" name="Confusion%20about%20SQLite%20and%20F_BARRIERFSYNC">
    Confusion about SQLite and F_BARRIERFSYNC
    <i></i>
</a></h2>
<p>On February 17, 2022, <a href="https://twitter.com/numist/status/1494392674014531593">Scott Perry wrote this in a conversation on
Twitter:</a></p>
<blockquote>
<p>There&#39;s a third sync operation that lets you have your performance and write
ordering too: F_BARRIERFSYNC. SQLite already uses it on Darwin, and it&#39;s part
of the best practices guide for I/O reduction.
<a href="https://developer.apple.com/documentation/xcode/reducing-disk-writes">https://developer.apple.com/documentation/xcode/reducing-disk-writes</a></p>
</blockquote>
<p>Some people (myself included) interpretted the statement &#34;SQLite already uses it
on Darwin&#34; to mean that it&#39;s the default behavior. My post will show that this
is not the case. By default, the bundled version of SQLite distributed in macOS
12.4 (21F79) relies on <code>fsync()</code> for synchronization.</p>
<p>From my investigation, Apple&#39;s version of SQLite instead replaces <code>PRAGMA fullfsync = on</code>&#39;s implementation to use <code>F_BARRIERFSYNC</code>.</p>
<p>SQLite users who are expecting <code>PRAGMA fullfsync</code> to provide durability
guarantees in the event of power failures or kernel panics can <a href="https://twitter.com/numist/status/1536859148897226753">override xSync
via a custom VFS</a> or build SQLite from source.</p>
<p>To understand why, let&#39;s review how to ensure persistent writes on Apple&#39;s
operating systems.</p>
<h2 id="-1">


<a href="#Recap%3A%20How%20to%20guarantee%20data%20is%20saved%20to%20disk%20on%20Mac/iOS%3F" name="Recap%3A%20How%20to%20guarantee%20data%20is%20saved%20to%20disk%20on%20Mac/iOS%3F">
    Recap: How to guarantee data is saved to disk on Mac/iOS?
    <i></i>
</a></h2>
<p>There are two APIs we need to cover: <code>fsync()</code> and <code>fcntl()</code>. On Linux,
<code>fsync()</code> is the system call that is tells the kernel to fully synchronize its
file state with the disk. It is debatable whether the original POSIX
specification intends for this level of durability guarantees of <code>fsync()</code>, but
on Linux it tries its best to guarantee all bits changed have been synchronized
to the disk including issuing a flush of any affected volatile write caches.</p>
<p>However, on macOS, the man page for <code>fsync()</code> reads:</p>
<blockquote>
<p>Note that while fsync() will flush all data from the host to the drive (i.e.
the &#34;permanent storage device&#34;), the drive itself may not physically write the
data to the platters for quite some time and it may be written in an
out-of-order sequence.</p>
<p>Specifically, if the drive loses power or the OS crashes, the application may
find that only some or none of their data was written.  The disk drive may
also re-order the data so that later writes may be present, while earlier
writes are not.</p>
<p>This is not a theoretical edge case.  This scenario is easily reproduced with
real world workloads and drive power failures.</p>
<p>For applications that require tighter guarantees about the integrity of their
data, Mac OS X provides the F_FULLFSYNC fcntl.  The F_FULLFSYNC fcntl asks the
drive to flush all buffered data to permanent storage.  Applications, such as
databases, that require a strict ordering of writes should use F_FULLFSYNC to
ensure that their data is written in the order they expect.  Please see
fcntl(2) for more detail.</p>
</blockquote>
<p>Apple&#39;s documentation clearly states that for any guarantees about data loss due
to power loss or kernel panic, you must use the <code>fcntl()</code> API with the
<code>F_FULLFSYNC</code> command.</p>
<p>Back in February of this year, this topic circulated fairly widely, and <a href="https://mjtsai.com/blog/2022/02/17/apple-ssd-benchmarks-and-f_fullsync/">this
post from Michael Tsai</a> has a summary of the findings. In short, it was
noted that <code>F_FULLFSYNC</code> is incredibly slow in its current implementation. It
was noted that Apple points users to another <code>fcntl()</code> command in its <a href="https://developer.apple.com/documentation/xcode/reducing-disk-writes">&#34;Reducing
Disk Writes&#34;</a> article:</p>
<blockquote>
<p>Some apps require a write barrier to ensure data persistence before subsequent
operations can proceed. Most apps can use the fcntl(<em>:</em>:) F_BARRIERFSYNC for
this.</p>
<p>Only use F_FULLFSYNC when your app requires a strong expectation of data
persistence. Note that F_FULLFSYNC represents a best-effort guarantee that iOS
writes data to the disk, but data can still be lost in the case of sudden
power loss.</p>
</blockquote>
<p><code>F_BARRIERFSYNC</code> issues an IO barrier such that all subsequent IO operations
must wait for all current writes to succeed. The <code>fcntl()</code> call returns after
issuing the barrier, but before the data is synchronized. This is why using
<code>F_BARRIERFSYNC</code> doesn&#39;t fulfill the durability requirement of ACID: the changes
are confirmed before the data is fully synchronized.</p>
<p>I should note that while <code>fcntl()</code> is an API that is available on Linux,
<code>F_FULLFSYNC</code> and <code>F_BARRIERFSYNC</code> are specific to Apple OSes. Linux has no need
for these options as <code>fsync()</code> provides the guarantees needed.</p>
<h2 id="-2">


<a href="#Does%20SQLite%20use%20F_BARRIERFSYNC%20on%20Apple%20OSes%3F" name="Does%20SQLite%20use%20F_BARRIERFSYNC%20on%20Apple%20OSes%3F">
    Does SQLite use F_BARRIERFSYNC on Apple OSes?
    <i></i>
</a></h2>
<p>When starting my new low-level storage layer (<a href="https://github.com/khonsulabs/sediment">Sediment</a>), I added
support to optionally use <code>F_BARRIERFSYNC</code> instead of <code>F_FULLFSYNC</code> on macOS.
By default, <code>F_FULLSYNC</code> would still be used as I wanted the user to explicitly
opt-out of ACID if they needed the extra performance on Apple hardware. This was
based on the idea that SQLite was using this same approach to achieve its very
fast speed on macOS.</p>
<p>Yesterday, I created a simple benchmark to see where Sediment&#39;s performance was
currently at. I&#39;m not ready to share numbers, and that&#39;s not the point of this
post. The summary, however, is that Sediment was faster than SQLite on Linux,
but slower than SQLite on my M1 Macbook Air.</p>
<p>That puzzled me, because if both SQLite and Sediment are using the same
synchronization primitives, how could the performance difference be inverted
between by switching operating systems? I decided to investigate how SQLite
utilized <code>F_BARRIERFSYNC</code>.</p>
<p>My first stop was the documentation. SQLite has a pragma to <a href="http://www3.sqlite.org/pragma.html#pragma_fullfsync">enable
<code>F_FULLFSYNC</code></a>, but I could not find any documentation talking
about <code>F_BARRIERFSYNC</code>. The documentation for <code>PRAGMA fullfsync</code> states that the
default value is off.</p>
<p>My next stop was the SQLite source code: <code>full_fsync()</code> is defined in
<a href="https://sqlite.org/src/file?name=src/os_unix.c&amp;ci=b1be2259">os_unix.c</a>. Its responsibility is to perform a full fsync based
on the available and configured options. This section is what is relevant for
Apple OSes:</p>
<pre data-lang="c"><code data-lang="c"><span>#elif</span><span> HAVE_FULLFSYNC
</span><span>  </span><span>if</span><span>( fullSync ){
</span><span>    rc = </span><span>osFcntl</span><span>(fd, F_FULLFSYNC, </span><span>0</span><span>);
</span><span>  }</span><span>else</span><span>{
</span><span>    rc = </span><span>1</span><span>;
</span><span>  }
</span><span>  </span><span>/* If the FULLFSYNC failed, fall back to attempting an fsync().
</span><span>  ** It shouldn&#39;t be possible for fullfsync to fail on the local 
</span><span>  ** file system (on OSX), so failure indicates that FULLFSYNC
</span><span>  ** isn&#39;t supported for this file system. So, attempt an fsync 
</span><span>  ** and (for now) ignore the overhead of a superfluous fcntl call.  
</span><span>  ** It&#39;d be better to detect fullfsync support once and avoid 
</span><span>  ** the fcntl call every time sync is called.
</span><span>  */
</span><span>  </span><span>if</span><span>( rc ) rc = </span><span>fsync</span><span>(fd);
</span><span>
</span><span>#elif defined</span><span>(__APPLE__)
</span><span>  </span><span>/* fdatasync() on HFS+ doesn&#39;t yet flush the file size if it changed correctly
</span><span>  ** so currently we default to the macro that redefines fdatasync to fsync
</span><span>  */
</span><span>  rc = </span><span>fsync</span><span>(fd);
</span></code></pre>
<p>The SQLite source code shows the implementation for calling <code>fcntl()</code> with
<code>F_FULLFSYNC</code>, but has no mention of <code>F_BARRIERFSYNC</code>.</p>
<p>There&#39;s one last thing to check: maybe Apple ships a custom build of SQLite that
utilizes <code>F_BARRIERFSYNC</code>. The best way to verify is to use dtrace to log out
the system calls the process makes.</p>
<p>I disabled System Integrity Protection so that I could trace the <code>sqlite3</code>
executable that ships with macOS 12.4 (21F79):</p>
<pre data-lang="sh"><code data-lang="sh"><span>~ </span><span>% sudo dtruss</span><span> -t</span><span> fcntl sqlite3 test.sqlite
</span><span>SYSCALL</span><span>(args)    = </span><span>return
</span><span>SQLite</span><span> version 3.37.0 2021-12-09 01:34:53
</span><span>Enter </span><span>&#34;</span><span>.help</span><span>&#34; for usage hints.
</span><span>fcntl</span><span>(0x3, 0x5F, 0x1)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x3F, 0x6BDBD9C0)   = </span><span>3</span><span> 0
</span><span>fcntl</span><span>(0x4, 0x32, 0x16BDBDDA8)   = </span><span>0</span><span> 0
</span><span>
</span><span>sqlite</span><span>&gt; insert into test (a) </span><span>values</span><span> (1);
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBD0B8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBD0B8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBD0B8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBCBA8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDE98)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDE98)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDE98)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDF08)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x4, 0x5F, 0x1)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x4, 0x3F, 0x1)   = </span><span>3</span><span> 0
</span><span>fcntl</span><span>(0x5, 0x5F, 0x1)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDEE8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDEE8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x5, 0x5F, 0x1)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDE88)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDE88)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16BDBDEB8)   = </span><span>0</span><span> 0
</span></code></pre>
<p>This log shows all of the <code>fcntl()</code> calls issued by SQLite to perform the
<code>insert into test (a) values (1);</code> statement. The second argument is the
command. We can see SQLite is using commands 0x3F, 0x5A, and 0x5F. In decimal,
those are 63, 90, and 95 respectively. Looking in <code>fcntl.h</code>, we see these values:</p>
<pre data-lang="c"><code data-lang="c"><span>#define </span><span>F_FULLFSYNC             </span><span>51      </span><span>/* fsync + ask the drive to flush to the media */
</span><span>#define </span><span>F_GETPROTECTIONCLASS    </span><span>63      </span><span>/* Get the protection class of a file from the EA, returns int */
</span><span>#define </span><span>F_BARRIERFSYNC          </span><span>85      </span><span>/* fsync + issue barrier to drive */
</span></code></pre>
<p>The commands for 90 and 95 <a href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/sys/fcntl.h#L360-L370">are private</a>:</p>
<pre data-lang="c"><code data-lang="c"><span>#define </span><span>F_OFD_SETLK             </span><span>90      </span><span>/* Acquire or release open file description lock */
</span><span>#define </span><span>F_SETCONFINED           </span><span>95      </span><span>/* &#34;confine&#34; OFD to process */
</span></code></pre>
<p>We did not see any <code>fcntl()</code> calls with the command argument being 85 (0x55).
Let&#39;s try enabling <code>PRAGMA fullfsync</code>:</p>
<pre data-lang="sh"><code data-lang="sh"><span>sqlite</span><span>&gt; pragma fullfsync=on;
</span><span>sqlite</span><span>&gt; insert into test (a) </span><span>values</span><span> (1);
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DEF8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DEF8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DEF8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DF68)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x4, 0x5F, 0x1)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x4, 0x3F, 0x1)   = </span><span>3</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DF48)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DF48)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x4, 0x55, 0x0)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x5, 0x5F, 0x1)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x4, 0x55, 0x0)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x55, 0x0)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DEE8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DEE8)   = </span><span>0</span><span> 0
</span><span>fcntl</span><span>(0x3, 0x5A, 0x16DD9DF18)   = </span><span>0</span><span> 0
</span></code></pre>
<p>As expected, we have a new <code>fcntl()</code> command: 0x55. Unexpectedly, however,
instead of enabling <code>F_FULLFSYNC</code> (0x33) as we would expect from reading the
publicly available SQLite code, we see 0x55 instead which is <code>F_BARRIERFSYNC</code>.</p>
<p>To summarize, Apple&#39;s SQLite doesn&#39;t use <code>F_BARRIERFSYNC</code> or <code>F_FULLFSYNC</code> by
default, and it replaces <code>fcntl(.., F_FULLFSYNC, ..)</code> with <code>fcntl(.., F_BARRIERFSYNC, ..)</code> when <code>PRAGMA fullfsync</code> is enabled.</p>
<p>This behavior was <a href="https://twitter.com/numist/status/1536830264214638593">confirmed by Scott
Perry</a> as I was editing
this post.</p>
<h2 id="-3">


<a href="#How%20important%20is%20this%3F" name="How%20important%20is%20this%3F">
    How important is this?
    <i></i>
</a></h2>
<p>For most consumer applications, <code>F_BARRIERFSYNC</code> will be enough to provide
reasonable durability with the benefit of performing much more quickly. However,
there are some situations where true ACID compliance is desired. Many (but not
all) of those situations involve server software.</p>
<p>With Apple no longer shipping server hardware and the performance of
<code>F_FULLFSYNC</code> <a href="https://news.ycombinator.com/item?id=30371857">on Apple&#39;s drives</a>, it&#39;s hard to fault Apple for
making the decision to use <code>F_BARRIERFSYNC</code> in their version of SQLite. I wish
they would have opted to do it in a different way, such as a new pragma or
changing the default <code>fsync()</code> behavior instead of replacing <code>PRAMGA fullfsync</code>.</p>
<p>It&#39;s very confusing when a feature that&#39;s <a href="http://www3.sqlite.org/pragma.html#pragma_fullfsync">documented to be specific to
macOS</a> doesn&#39;t behave as documented on macOS. As it stands, if
a developer wants the documented behavior, the easiest way probably is to build
SQLite from source.</p>
<p>I did not test any of these findings on iOS -- it&#39;s been years since I have
tried doing any tracing on a device. I suspect Apple doesn&#39;t maintain separate
versions of SQLite for iOS and macOS, but because their version of SQLite is
closed source, we cannot verify easily.</p>
<p>Regardless of whether Apple changes how SQLite synchronizes in the future, I
encourage Apple to publish their updates to SQLite alongside their other open
source repositories. I can&#39;t imagine the changes made to SQLite would be
considered proprietary, and the ability to understand what differs between
SQLite&#39;s source code and the shipping version in Apple&#39;s operating systems is
important in understanding what guarantees SQLite provides on Apple&#39;s hardware.</p>

</div></div>
  </body>
</html>
