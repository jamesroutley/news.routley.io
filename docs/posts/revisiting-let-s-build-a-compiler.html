<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2025/revisiting-lets-build-a-compiler/">Original</a>
    <h1>Revisiting &#34;Let&#39;s Build a Compiler&#34;</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>There&#39;s an old compiler-building tutorial that has become part of the field&#39;s
lore: the <a href="https://compilers.iecc.com/crenshaw/">Let&#39;s Build a Compiler</a>
series by Jack Crenshaw (published between 1988 and 1995).</p>
<p>I <a href="https://eli.thegreenplace.net/2003/07/29/great-compilers-tutorial">ran into it in 2003</a>
and was very impressed, but it&#39;s now 2025 and this tutorial is still being mentioned quite
often <a href="https://hn.algolia.com/?dateRange=pastYear&amp;page=0&amp;prefix=true&amp;query=crenshaw&amp;sort=byDate&amp;type=all">in Hacker News threads</a>.
Why is that? Why does a tutorial from 35
years ago, built in Pascal and emitting Motorola 68000 assembly - technologies that
are virtually unknown for the new generation of programmers - hold sway over
compiler enthusiasts? I&#39;ve decided to find out.</p>
<p>The tutorial is <a href="https://compilers.iecc.com/crenshaw/">easily available and readable online</a>, but
just re-reading it seemed insufficient. So I&#39;ve decided on meticulously
translating the compilers built in it to Python and emit a more modern target -
WebAssembly. It was an enjoyable process and I want to share the outcome and
some insights gained along the way.</p>
<p>The result is <a href="https://github.com/eliben/letsbuildacompiler">this code repository</a>.
Of particular interest is the <a href="https://github.com/eliben/letsbuildacompiler/blob/main/TUTORIAL.md">TUTORIAL.md file</a>,
which describes how each part in the original tutorial is mapped to my code. So
if you want to read the original tutorial but play with code you can actually
easily try on your own, feel free to follow my path.</p>
<div id="a-sample">
<h2>A sample</h2>
<p>To get a taste of the input language being compiled and the output my compiler
generates, here&#39;s a sample program in the KISS language designed by Jack
Crenshaw:</p>
<div><pre><span></span>var X=0

 { sum from 0 to n-1 inclusive, and add to result }
 procedure addseq(n, ref result)
     var i, sum  { 0 initialized }
     while i &lt; n
         sum = sum + i
         i = i + 1
     end
     result = result + sum
 end

 program testprog
 begin
     addseq(11, X)
 end
 .
</pre></div>
<p>It&#39;s from part 13 of the tutorial, so it showcases procedures along with control
constructs like the <tt>while</tt> loop, and passing parameters both by value and by
reference. Here&#39;s the WASM text generated by my compiler for part 13:</p>
<div><pre><span></span><span>(</span><span>module</span>
  <span>(</span><span>memory</span> <span>8</span><span>)</span>
  <span>;; Linear stack pointer. Used to pass parameters by ref.</span>
  <span>;; Grows downwards (towards lower addresses).</span>
  <span>(</span><span>global</span> <span>$__sp</span> <span>(</span><span>mut</span> <span>i32</span><span>)</span> <span>(</span><span>i32.const</span> <span>65536</span><span>))</span>

  <span>(</span><span>global</span> <span>$X</span> <span>(</span><span>mut</span> <span>i32</span><span>)</span> <span>(</span><span>i32.const</span> <span>0</span><span>))</span>

  <span>(</span><span>func</span> <span>$ADDSEQ</span> <span>(</span><span>param</span> <span>$N</span> <span>i32</span><span>)</span> <span>(</span><span>param</span> <span>$RESULT</span> <span>i32</span><span>)</span>
    <span>(</span><span>local</span> <span>$I</span> <span>i32</span><span>)</span>
    <span>(</span><span>local</span> <span>$SUM</span> <span>i32</span><span>)</span>
    <span>loop</span> <span>$loop1</span>
      <span>block</span> <span>$breakloop1</span>
        <span>local.get</span> <span>$I</span>
        <span>local.get</span> <span>$N</span>
        <span>i32.lt_s</span>
        <span>i32.eqz</span>
        <span>br_if</span> <span>$breakloop1</span>
        <span>local.get</span> <span>$SUM</span>
        <span>local.get</span> <span>$I</span>
        <span>i32.add</span>
        <span>local.set</span> <span>$SUM</span>
        <span>local.get</span> <span>$I</span>
        <span>i32.const</span> <span>1</span>
        <span>i32.add</span>
        <span>local.set</span> <span>$I</span>
        <span>br</span> <span>$loop1</span>
      <span>end</span>
    <span>end</span>
    <span>local.get</span> <span>$RESULT</span>
    <span>local.get</span> <span>$RESULT</span>
    <span>i32.load</span>
    <span>local.get</span> <span>$SUM</span>
    <span>i32.add</span>
    <span>i32.store</span>
  <span>)</span>

  <span>(</span><span>func</span> <span>$main</span> <span>(</span><span>export</span> <span>&#34;main&#34;</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span>
    <span>i32.const</span> <span>11</span>
    <span>global.get</span> <span>$__sp</span>      <span>;; make space on stack</span>
    <span>i32.const</span> <span>4</span>
    <span>i32.sub</span>
    <span>global.set</span> <span>$__sp</span>
    <span>global.get</span> <span>$__sp</span>
    <span>global.get</span> <span>$X</span>
    <span>i32.store</span>
    <span>global.get</span> <span>$__sp</span>    <span>;; push address as parameter</span>
    <span>call</span> <span>$ADDSEQ</span>
    <span>;; restore parameter X by ref</span>
    <span>global.get</span> <span>$__sp</span>
    <span>i32.load</span> <span>offset</span><span>=</span><span>0</span>
    <span>global.set</span> <span>$X</span>
    <span>;; clean up stack for ref parameters</span>
    <span>global.get</span> <span>$__sp</span>
    <span>i32.const</span> <span>4</span>
    <span>i32.add</span>
    <span>global.set</span> <span>$__sp</span>
    <span>global.get</span> <span>$X</span>
  <span>)</span>
<span>)</span>
</pre></div>
<p>You&#39;ll notice that there is some trickiness in the emitted code w.r.t. handling
the by-reference parameter (my <a href="https://eli.thegreenplace.net/2025/notes-on-the-wasm-basic-c-abi/">previous post</a>
deals with this issue in more detail). In general, though, the emitted code is
inefficient - there is close to 0 optimization applied.</p>
<p>Also, if you&#39;re very diligent you&#39;ll notice something odd about the global
variable <tt>X</tt> - it seems to be implicitly returned by the generated <tt>main</tt>
function. This is just a testing facility that makes my compiler easy to test.
All the compilers are extensively tested - usually by running the
generated WASM code <a href="#footnote-1" id="footnote-reference-1">[1]</a> and verifying expected results.</p>
</div>
<div id="insights-what-makes-this-tutorial-so-special">
<h2>Insights - what makes this tutorial so special?</h2>
<p>While reading the original tutorial again, I had on opportunity to reminisce on
what makes it so effective. Other than the very fluent and conversational
writing style of Jack Crenshaw, I think it&#39;s a combination of two key
factors:</p>
<ol>
<li>The tutorial builds a recursive-descent parser step by step, rather than
giving a long preface on automata and table-based parser generators. When
I first encountered it (in 2003), it was taken for granted that if you want
to write a parser then lex + yacc are the way to go <a href="#footnote-2" id="footnote-reference-2">[2]</a>. Following the
development of a simple and clean hand-written
parser was a revelation that wholly changed my approach to the subject;
subsequently, hand-written recursive-descent parsers have been my go-to approach
<a href="https://eli.thegreenplace.net/tag/recursive-descent-parsing">for almost 20 years now</a>.</li>
<li>Rather than getting stuck in front-end minutiae, the tutorial goes straight
to generating working assembly code, from very early on. This was also a
breath of fresh air for engineers who grew up with more traditional courses
where you spend 90% of the time on parsing, type checking and other semantic
analysis and often run entirely out of steam by the time code generation
is taught.</li>
</ol>
<p>To be honest, I don&#39;t think either of these are a big problem with modern
resources, but back in the day the tutorial clearly hit the right nerve with
many people.</p>
</div>
<div id="what-else-does-it-teach-us">
<h2>What else does it teach us?</h2>
<p>Jack Crenshaw&#39;s tutorial takes the <a href="https://en.wikipedia.org/wiki/Syntax-directed_translation">syntax-directed translation</a>
approach, where code is emitted <em>while parsing</em>, without having to divide the
compiler into explicit phases with IRs. As I said above, this is a fantastic
approach for getting started, but in the latter parts of the tutorial it starts
showing its limitations. Especially once we get to types, it becomes painfully
obvious that it would be very nice if we knew the types of expressions <em>before</em>
we generate code for them.</p>
<p>I don&#39;t know if this is implicated in Jack Crenshaw&#39;s abandoning the tutorial
at some point after part 14, but it may very well be. He keeps writing how
the emitted code is clearly sub-optimal <a href="#footnote-3" id="footnote-reference-3">[3]</a> and can be improved, but IMHO it&#39;s
just not that easy to improve using the syntax-directed translation strategy.
With perfect hindsight vision, I would probably use Part 14 (types) as a turning
point - emitting some kind of AST from the parser and then doing simple type
checking and analysis on that AST prior to generating code from it.</p>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>All in all, the original tutorial remains a wonderfully readable introduction
to building compilers. This post and the <a href="https://github.com/eliben/letsbuildacompiler">GitHub repository</a>
it describes are a modest
contribution that aims to improve the experience of folks reading the original
tutorial today and not willing to use obsolete technologies. As always, let
me know if you run into any issues or have questions!</p>
<hr/>



</div>

            </div></div>
  </body>
</html>
