<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bref.sh/docs/case-studies/treezor">Original</a>
    <h1>A bank runs serverless with PHP and AWS Lambda</h1>
    
    <div id="readability-page-1" class="page"><article><main>

<p>This case study dives into how Treezor went serverless for their banking platform.
From legacy code running on servers to a serverless monolith, and then event-driven microservices on AWS with Bref.</p>
<img loading="lazy" width="747" height="383" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftreezor-illustration.7877e561.jpeg&amp;w=750&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftreezor-illustration.7877e561.jpeg&amp;w=1920&amp;q=75 2x" src="https://bref.sh/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftreezor-illustration.7877e561.jpeg&amp;w=1920&amp;q=75"/>
<p><a href="https://www.treezor.com/" target="_blank" rel="noreferrer">Treezor<span> (opens in a new tab)</span></a> is a banking-as-a-service platform that serves millions of transactions every day. <strong>You might be using it every day</strong> through its clients: neobanks, employee benefit cards, company travel cards, and many other financial services.</p>
<p>Because Treezor&#39;s clients have very different use cases, the platform&#39;s infrastructure must be able <strong>to scale and be resilient</strong> to accommodate various usage patterns. Whether it&#39;s a luncheon voucher transaction spike at lunchtime or a monthly batch of transactions by corporate clients. On top of that, some API endpoints need to respond fast, <strong>in near real-time</strong>, for example to authorize live credit card payments.</p>
<p>To build such a platform, Treezor migrated from a legacy PHP application running on servers to a serverless architecture running on AWS Lambda with Bref. They did such a migration in 3 steps:</p>
<ul>
<li>First, they validated the serverless infrastructure by building a new service as a serverless PHP application.</li>
<li>Then, they did a &#34;lift-and-shift&#34; migration by <strong>running the legacy PHP application on AWS Lambda</strong>.</li>
<li>Finally, they slowly refactored the legacy application into multiple <strong>PHP microservices</strong> using the &#34;strangler&#34; pattern.</li>
</ul>
<p>Let&#39;s explore this serverless migration in more detail.</p>
<h2>The original legacy stack<a href="#the-original-legacy-stack" id="the-original-legacy-stack" aria-label="Permalink for this section"></a></h2>
<p>The original stack was a legacy PHP monolith, built with no framework, running on <a href="https://ovh.com/" target="_blank" rel="noreferrer">OVH<span> (opens in a new tab)</span></a> servers.</p>
<p>That monolith was responsible for the &#34;Core Banking&#34; API, i.e. handling all the critical operations of the system, like authorizing credit card payments or executing bank transfers.</p>
<p>Because it was running on servers, handling unpredictable traffic spikes was challenging.</p>
<h2>Validating the serverless infrastructure<a href="#validating-the-serverless-infrastructure" id="validating-the-serverless-infrastructure" aria-label="Permalink for this section"></a></h2>
<p>Migrating a Core Banking system to a new infrastructure is not something you do every day. To make sure that AWS and <a href="https://aws.amazon.com/lambda/" target="_blank" rel="noreferrer">AWS Lambda<span> (opens in a new tab)</span></a> were a good fit, the team first wanted to validate the stack.</p>
<p>They did so by <strong>building a new service entirely serverless</strong> (greenfield project). They built it using PHP, Lumen, Bref, AWS Lambda, SQS, DynamoDB, SNS, S3, and KMS.</p>
<p>That new service was the API exposed to Treezor&#39;s client to manage day-to-day bank operations. It was deployed to production at the end of 2020 and was a success. It was able to scale and handle the incoming traffic.</p>
<p>To confirm that serverless worked well with other use cases, including the most complex ones, they did a second migration and <strong>routed a part of live credit card transactions to the new serverless app</strong>. If it worked with the live credit card traffic, it meant that the rest of the Treezor platform could run as serverless too.</p>
<p>That migration was also a success and cleared the way for migrating more APIs.</p>
<h2>Lift-and-shift the legacy monolith on AWS Lambda<a href="#lift-and-shift-the-legacy-monolith-on-aws-lambda" id="lift-and-shift-the-legacy-monolith-on-aws-lambda" aria-label="Permalink for this section"></a></h2>
<p>The next step was to migrate the legacy PHP monolith from servers to AWS Lambda.</p>
<p>Doing <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="noreferrer">a complete rewrite was unrealistic<span> (opens in a new tab)</span></a>. It would have meant completely halting all other developments, investing months (or even years) into the new system, and crossing fingers for the rewrite to actually be a success.</p>
<p>Instead, the team used Bref&#39;s <a href="https://bref.sh/docs/runtimes/fpm-runtime">PHP-FPM runtime</a>. This AWS Lambda runtime runs PHP &#34;as usual&#34;, like on any server, using PHP-FPM. It allowed taking the monolithic codebase and running it as an HTTP application on AWS Lambda.</p>
<p>To do a controlled migration, the team deployed the application both to the servers and to AWS Lambda. <strong>Only 10 lines of code needed to be changed</strong> to run the monolith on AWS Lambda.</p>
<p>Using API Gateway, they were able to <strong>route some of the API traffic to AWS Lambda and the rest to the old stack running on servers</strong>. In case of any issue, it was possible to roll back the endpoint to the server stack.</p>
<p><img loading="lazy" width="1173" height="545" decoding="async" data-nimg="1" src="https://bref.sh/_next/static/media/treezor-1.a99dbb51.svg"/></p>
<p>In October 2021, they successfully migrated their first API route to AWS Lambda, the most critical one handling all live credit card transactions. Over the following year, more and more API endpoints were migrated away from the servers to AWS Lambda.</p>
<p>The migration of other API endpoints started in March 2022. Over the following year, the team migrated all API endpoints, cron tasks, and batch scripts to AWS Lambda. The servers were finally shut down in March 2023.</p>
<p>The entire migration took 1 year of planning and design, and 1 year of implementation. The main challenge was dealing with cron tasks running for more than 15 minutes (the maximum execution time on AWS Lambda). They needed to be split into smaller tasks. The Bref runtime also needed some customizations, for example to run custom PHP versions.</p>
<p><strong>The migration was a complete success</strong>, and this is reflected in the key metrics tracked for the migration. With the new serverless stack:</p>
<ul>
<li>API response times were <strong>2.5 times faster</strong>.</li>
<li>On-call alerts were <strong>divided by 2</strong> or even 3 times.</li>
<li>API endpoint timeouts for card transactions were <strong>reduced by a factor of 10</strong>.</li>
</ul>
<h2>Refactoring to serverless microservices<a href="#refactoring-to-serverless-microservices" id="refactoring-to-serverless-microservices" aria-label="Permalink for this section"></a></h2>
<p>Now that the infrastructure was running smoothly, the team turned to the code itself. The goal: turning the legacy PHP monolith into a maintainable system.</p>
<p>Headcount in the Treezor IT department was growing and having all teams work on a single monolith was painful. The target architecture was set: a collection of <strong>domain-oriented microservices</strong>.</p>
<p>The use of API Gateway routing turned useful here too: it allowed applying the &#34;strangler&#34; pattern. As each domain was spun out into a separate service, the API Gateway routes could be transparently updated to point to the new services.</p>
<p><img loading="lazy" width="793" height="615" decoding="async" data-nimg="1" src="https://bref.sh/_next/static/media/treezor-2.76f1aa05.svg"/></p>
<p>The migration to microservices is still an ongoing work. As of today, the stack is <strong>90% serverless on AWS</strong> and deployed with Terraform.</p>
<p>Some new services are implemented in Go, but a majority are using PHP with Bref. API Gateway is used for <a href="https://bref.sh/docs/use-cases/http">HTTP APIs</a>, and EventBridge is used for <a href="https://bref.sh/docs/use-cases/eventbridge">asynchronous communication between services</a>. Other AWS services are used inside services to handle specific use cases, for example <a href="https://bref.sh/docs/use-cases/sqs">job queues with SQS</a>, DynamoDB databases, SNS for parallelizing tasks, or even Kinesis for data pipelines.</p>
<h2>Conclusion<a href="#conclusion" id="conclusion" aria-label="Permalink for this section"></a></h2>
<p>I find Treezor&#39;s story fascinating because it illustrates two very different use cases:</p>
<ul>
<li>Being able to <strong>lift and shift</strong> existing PHP applications to AWS Lambda with very few changes.</li>
<li>And later going &#34;all-in&#34; on <strong>event-driven microservices</strong> and taking full advantage of what AWS has to offer.</li>
</ul>
<p>It shows that both options are valid and have their own benefits.</p>
<p>First, <strong>using AWS Lambda as a scalable PHP hosting platform works well</strong>. For those who want scalability and simplicity, it is possible to avoid vendor lock-in and use AWS Lambda like any other hosting platform.</p>
<p>Second, AWS Lambda has great integrations with other AWS services. That allows building <strong>event-driven microservices by composing the best AWS services for the use case</strong>: SQS for infinitely scalable queues, EventBridge for asynchronous communication between services, DynamoDB for very optimized data storage, API Gateway for out-of-the-box caching, security and advanced routing for APIs... And much more of course.</p>
<p>Treezor&#39;s story also shows that the first option can be a good stepping stone to the second, removing some of the risk of a cloud migration.</p>
<p>Thank you <a href="https://www.treezor.com/" target="_blank" rel="noreferrer">Treezor<span> (opens in a new tab)</span></a>, and thank you <a href="https://www.linkedin.com/in/nicolasbordes/" target="_blank" rel="noreferrer">Nicolas<span> (opens in a new tab)</span></a> and <a href="https://www.linkedin.com/in/julien-mortuaire-29126528/" target="_blank" rel="noreferrer">Julien<span> (opens in a new tab)</span></a> for sharing that story with us!</p>
<p>And if you want to work with Bref every day, <a href="https://www.welcometothejungle.com/fr/companies/treezor" target="_blank" rel="noreferrer">Treezor is hiring<span> (opens in a new tab)</span></a> 😉</p></main></article></div>
  </body>
</html>
