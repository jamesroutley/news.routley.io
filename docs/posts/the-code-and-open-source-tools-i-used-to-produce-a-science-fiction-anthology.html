<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://compellingsciencefiction.com/posts/the-code-and-open-source-tools-i-used-to-produce-a-science-fiction-anthology.html">Original</a>
    <h1>The code and open-source tools I used to produce a science fiction anthology</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>
Last month I published <em><a href="https://thinkweirder.com">Think Weirder: The Year&#39;s Best Science Fiction Ideas</a></em>, a 16-story anthology featuring Greg Egan, Isabel J. Kim, Ray Nayler, Caroline M. Yoachim, and twelve other wonderful authors. The book ended up being the #1 New Release in the Short Stories Anthologies category for a short time on Amazon, outselling many other newly released short story anthologies published by the big NYC publishers with large marketing departments.
</p><p>
I&#39;m not a professional publisher. I have a full-time job and two small kids, so all of this work happened after my kids went to sleep. I had to use my time judiciously, which meant creating an efficient process. Fortunately I&#39;m a programmer, and it turns out that programming skills translate surprisingly well to book publishing. This post is about how I built a complete publishing pipeline using Python, YAML files, and LaTeX — and why you might want to do something similar if you&#39;re considering publishing a book. I know that by writing this I&#39;ll have my choices questioned by professional designers, but hopefully the software concepts will be helpful.
</p><p><strong>My initial thought: can I really do ALL of this?</strong>
</p><p>
When I started this project, I had some worries. Professional publishers have entire departments of specialists. How could I possibly handle all of that myself?
</p><p>
The answer turned out to be: build tools that automate the repetitive parts, and use simple file formats that make everything transparent and debuggable.
</p><p><strong>Step 1: Tracking stories with plain text files</strong>
</p><p>
The first challenge was tracking hundreds of candidate stories from different magazines. I read 391 stories published in 2024 before selecting the final 16. That&#39;s a lot of stories to keep organized.
</p><p>
I could have used a spreadsheet, but I went with plain YAML files instead. Here&#39;s why this worked well for me:
</p><div>
<ul>
<li><strong>Git-friendly</strong>: Every decision I made was tracked in version control</li>
<li><strong>Human-readable</strong>: I could open any file in a text editor and understand what I was looking at</li>
<li><strong>Easy to build scripts around:</strong> I wrote several Python functions to do different kinds of metadata introspection that I&#39;ll go through</li>
</ul>
</div><p>
The structure looks like this:
</p><div>
<pre><code>data/
  story-progress.yaml       # Central tracking file
  markets.yaml              # Magazine metadata
  themes.yaml               # Theme occurrence tracking
  subgenres.yaml            # Subgenre tallies
stories/
  clarkesworld-magazine/
    nelson_11_24.yaml       # Individual story files
    pak_06_24.yaml
  reactor-magazine/
    larson_breathing.yaml
  ...</code></pre>
</div><p>
Each story file is pure YAML containing the full story text plus metadata:
</p><div>
<pre><code>title: &#34;Twenty-Four Hours&#34;
author: H.H. Pak
market: clarkesworld-magazine
url: https://clarkesworldmagazine.com/pak_06_24/
word_count: 4540
year: 2024
slug: pak_06_24
summary: ...</code></pre>
</div><p>
Not all stories have public URLs available, but that&#39;s OK because all of the fields are optional. The central <code>story-progress.yaml</code> tracks editorial state:
</p><div>
<pre><code>clarkesworld-magazine-nelson_11_24:
  title: &#34;LuvHome™&#34;
  author: Resa Nelson
  market: clarkesworld-magazine
  status: accepted  # or: not_started/relevant/rejected
  date_added: &#39;2024-09-08T08:22:47.033192&#39;</code></pre>
</div><p><strong>Step 2: A simple command-line tool</strong>
</p><p>
I built a small Python CLI tool (<code>se.py</code>) to help me navigate all this data. Since I do all this work at night after my kids go to sleep, I wanted something fast that mirrored a lot of the other work I do on the command line. The tool is simple:
</p><div>
<pre><code>python se.py —help
usage: se.py [-h] {markets,stories,relevant,decide,accepted,compile} ...

Story Evaluator CLI

positional arguments:
  {markets,stories,relevant,decide,accepted,compile}
                        Available commands
    markets             List markets
    stories             Manage stories
    relevant            List URLs for stories marked as relevant
    decide              Make accept/reject decisions on relevant stories
    accepted            Manage accepted stories
    compile             Show anthology compilation statistics

optional arguments:
  -h, —help            show this help message and exit</code></pre>
</div><p>
The <code>compile</code> command ended up being really useful — it gave me instant feedback on anthology size and composition:
</p><div>
<pre><code>ANTHOLOGY COMPILATION STATISTICS
============================================================
Total Stories: 16
Total Word Count: 115,093 words
Average Word Count: 7,193 words
Unique Authors: 16
Markets Represented: 4

STORIES BY MARKET:
  analog-magazine: 2 stories (12.5%)
  asimovs-magazine: 2 stories (12.5%)
  clarkesworld-magazine: 10 stories (62.5%)
  reactor-magazine: 2 stories (12.5%)</code></pre>
</div><p>
This was really helpful during the selection process. I could quickly check how far along I was toward my ~120k word goal, and make sure I hadn&#39;t accidentally included multiple stories by the same author.
</p><p><strong>Step 3: Typesetting the print book</strong>
</p><p>
This part surprised me the most. I initially thought I&#39;d have to learn Adobe InDesign or pay someone to do the typesetting. But I decided to use LaTeX instead, since I had some previous experience with it (another publishing friend sent me some of his example files, and I had some academic experience). The process worked out better than expected.
</p><p>
I used XeLaTeX with the <code>memoir</code> document class. Here&#39;s what I liked about this approach:
</p><div>
<ul>
<li><strong>Reproducible</strong>: I can rebuild the entire book from source in a few seconds, and I can use the same templates next year</li>
<li><strong>Professional typography</strong>: LaTeX handles ligatures, kerning, and line breaking better than I could manually</li>
<li><strong>Custom fonts</strong>: I used Crimson Pro for body text and Rajdhani for titles</li>
<li><strong>Again, version control that I&#39;m used to</strong>: The entire book is just text files in Git</li>
</ul>
</div><p>
The main parts of the master file for the book are really simple:
</p><div>
<pre><code>\documentclass[final,11pt,twoside]{memoir}
\usepackage{compelling}

\begin{document}
\begin{frontmatter}
  \include{title}
  \tableofcontents
\end{frontmatter}

\begin{mainmatter}
  \include{introduction}
  \include{death-and-the-gorgon}
  \include{the-best-version-of-yourself}
  % ... 14 more stories
  \include{acknowledgements}
\end{mainmatter}
\end{document}</code></pre>
</div><div><p>
All the formatting rules live in <code>compelling.sty</code>, a custom style package. <a href="http://compellingsciencefiction.com/artifacts/compelling.sty">Here&#39;s a link to the full, messy file</a>. Some highlights:
</p></div><div>
<pre><code>% 6x9 inch trade paperback size
\setstocksize{9in}{6in}
\settrimmedsize{9in}{6in}{*}

% Margins
\setlrmarginsandblock{1.00in}{0.75in}{*}
\setulmarginsandblock{0.75in}{0.75in}{*}

% Typography nerding
\usepackage[final,protrusion=true,factor=1125,
            stretch=70,shrink=70]{microtype}

% Custom fonts loaded from local files
\setromanfont[
  Ligatures=TeX,
  Path=./Crimson_Pro/static/,
  UprightFont=CrimsonPro-Regular,
  BoldFont=CrimsonPro-Bold,
  ItalicFont=CrimsonPro-Italic,
  BoldItalicFont=CrimsonPro-BoldItalic
]{Crimson Pro}


\setsansfont[
  Path=./Rajdhani/,
  UprightFont=Rajdhani-Bold,
  BoldFont=Rajdhani-Bold,
  ItalicFont=Rajdhani-Bold,
  BoldItalicFont=Rajdhani-Bold
]{Rajdhani}

% Chinese font family for CJK characters
\newfontfamily\chinesefont{PingFang SC}</code></pre>
</div><p>
The <code>microtype</code> package does a lot of subtle work with character spacing and line breaking that makes the text look professionally typeset.
</p><p>
I wanted story titles in bold sans-serif with author names underneath in a lighter gray. Here&#39;s how I set that up:
</p><div>
<pre><code>\renewcommand{\chapter}[2]{
    \pagestyle{DefaultStyle}
    \stdchapter*{
        \sffamily
        \LARGE 
        \textbf{\MakeUppercase{#1}}
        \\ 
        \large 
        \color{dark-gray} 
        {\MakeUppercase{#2}}
    }
    \addcontentsline{toc}{chapter}{
        \protect\parbox[t]{\dimexpr\textwidth-3em}{
            \sffamily#1
            \\ 
            \protect\small
            \protect\color{gray}
            \protect\textit{#2}
        }
    }
    \def\leftmark{#1}
    \def\rightmark{#2}
}</code></pre>
</div><p>
This redefines the <code>chapter</code> command to take two arguments, the title and byline, and sets up both the chapter formatting, TOC formatting, and makes sure that the title and byline are printed in the headers on alternating pages.
</p><p>
Now every story file just says:
</p><div>
<pre><code>\chapter{Death and the Gorgon}{by Greg Egan}
[story content]</code></pre>
</div><p>
Most authors send me stories as HTML, PDF, or word, so I needed a way to convert them to LaTeX. I wrote a simple Python script to do this, which saved me a huge amount of manual formatting work.
</p><p><strong>Step 4: Creating the ebook</strong>
</p><p>
Print was one thing, but I also needed an ebook. This turned out to be easier than I expected because I could reuse all the LaTeX source I&#39;d already created.
</p><p>
I used Pandoc to convert from LaTeX to EPUB:
</p><div>
<pre><code># Convert LaTeX to EPUB
pandoc 2025.tex -o Think_Weirder_2025.epub \
  —toc \
  —epub-cover-image=cover_optimized.jpg \
  —css=epub-style.css \
  —metadata title=&#34;Think Weirder&#34; \
  —metadata author=&#34;Edited by Joe Stech&#34;</code></pre>
</div><p>
Pandoc&#39;s default table of contents only showed story titles. But I wanted author names too, like you see in print anthologies. EPUBs are just zipped collections of XHTML files, so I wrote a small post-processing script:
</p><div>
<pre><code>def modify_toc(nav_content, authors):
    &#34;&#34;&#34;Add author bylines to TOC entries.&#34;&#34;&#34;
    pattern = r&#39;&lt;a href=&#34;([^&#34;]+)&#34;&gt;([^&lt;]+)&lt;/a&gt;&#39;

    def add_author(match):
        href, title = match.group(1), match.group(2)
        chapter_id = extract_id_from_href(href)

        if chapter_id in authors:
            author = authors[chapter_id]
            return f&#39;&lt;a href=&#34;{href}&#34;&gt;{title}&lt;br /&gt;\n&#39; \
                   f&#39;&lt;em&gt;{author}&lt;/em&gt;&lt;/a&gt;&#39;
        return match.group(0)

    return re.sub(pattern, add_author, nav_content)</code></pre>
</div><p>
The script unzips the EPUB, finds the navigation file, adds author bylines, and rezips everything. Now the ebook table of contents matches the print version.
</p><p><strong>What I learned</strong>
</p><p>
The whole process took longer than I expected — many months of night work. The simple software I wrote really made it a feasible one-person project though, and motivates me to go through the whole process again next year.
</p><p><strong>Staying organized is crucial.</strong> When hundreds of stories are involved, it&#39;s easy to forget details, so using <code>se.py</code> to save metadata in the moment that could be sliced and diced later was so important.
</p><p><strong>Reproducible builds were a lifesaver.</strong> I made changes to the book layout right up until the week before publication. Because I could rebuild the entire book in seconds, and everything was backed up in git, I could experiment freely without worrying about breaking things.
</p><p><strong>Simple file formats made me comfortable.</strong> When something went wrong, I could always open a YAML file or look at the LaTeX source and understand what was happening. I never hit a point where the tools were a black box.
</p><p><strong>I didn&#39;t need to understand everything up front.</strong> I learned LaTeX details as I went (arguably I still don&#39;t really understand LaTeX). Same with Pandoc. I got something basic working first, then incrementally improved it.
</p><p><strong>Can you do this too?</strong>
</p><p>
If you&#39;re thinking about publishing a book — whether it&#39;s an anthology, a novel, or a collection of technical writing — I think this approach is worth considering. There&#39;s something motivating about having a detailed understanding of every step in the production process. If you have questions feel free to reach out, I love talking about this hobby! You can email me at joe@thinkweirder.com.
</p><p>
And if you enjoy concept-driven science fiction that is heavy on novel ideas, check out <em><a href="https://thinkweirder.com">Think Weirder!</a></em>
</p></div></div>
  </body>
</html>
