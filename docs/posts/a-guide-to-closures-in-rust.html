<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hashrust.com/blog/a-guide-to-closures-in-rust/">Original</a>
    <h1>A guide to closures in Rust</h1>
    
    <div id="readability-page-1" class="page"><article>
            

<p><strong>2023-05-22</strong></p>
<h2 id="introduction">Introduction</h2>
<p>A closure is like an anonymous function. It can be called, like a function can be called. But it has a couple of dissimilarities with a function that make it suitable for use in situations where a function will be a poor fit. First, you can write it inline which makes the code very concise. And second, it can capture variables from outside its scope. This high level description might make you believe that closures are simple. But there&#39;s more to them than you might think. Don&#39;t worry though, in this post we will explore in detail about what closures are and when to use them.</p>
<h2 id="what-is-a-closure">What is a closure</h2>
<p>If you had a function like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>add</span></span><span><span><span>(</span><span>a</span><span>:</span> <span>i32</span>, <span>b</span><span>:</span> <span>i32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span></span></span></span>
    a <span>+</span> b
<span><span>}</span></span>
</code></pre>
<p>And you wanted to write a closure similar to it, you will write:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>|</span>a<span>:</span> <span>i32</span><span>,</span> b<span>:</span> <span>i32</span><span>|</span> <span><span>-&gt;</span> <span>i32</span></span> <span><span>{</span></span></span>
    a <span>+</span> b
<span><span>}</span></span><span>;</span>
</code></pre>
<p>Its syntax is mostly similar to the function, apart from a few things. First, there is no <code>fn</code> keyword. Second, it doesn&#39;t have a name. And third, we write the arguments inside the <code>|</code> characters instead of <code>(</code> and <code>)</code>. Since it doesn&#39;t have a name, you need to assign it to a variable before you can call it:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span>
<span>let</span> <span>add_closure</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>a</span><span>:</span> <span>i32</span><span>,</span> <span>b</span><span>:</span> <span>i32</span><span>|</span></span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span></span></span>
    a <span>+</span> b
<span><span>}</span></span><span>;</span>

<span>let</span> sixty_six <span>=</span> <span>add_closure</span><span><span>(</span><span>42</span><span>,</span> <span>24</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>That was the most verbose way of writing a closure. Quite a few elements of a closure are optional. For example, you can omit the type annotations:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span>
<span>let</span> <span>add_closure</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>a</span><span>,</span> <span>b</span><span>|</span></span> </span><span><span><span>{</span></span></span>
    a <span>+</span> b 
<span><span>}</span></span><span>;</span>

<span>let</span> sixty_six <span>=</span> <span>add_closure</span><span><span>(</span><span>42</span><span>,</span> <span>24</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>The types were inferred from where the closure was called and from its return expression. You can also omit the <code>{</code> and <code>}</code> braces if the body of the closure is a single expression:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span>
<span>let</span> <span>add_closure</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>a</span><span>,</span> <span>b</span><span>|</span></span> </span><span>a <span>+</span> b</span><span>;</span>
<span>let</span> sixty_six <span>=</span> <span>add_closure</span><span><span>(</span><span>42</span><span>,</span> <span>24</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Removing the optional parts made the closure very compact.</p>
<p>That&#39;s it about how you write closures. Pretty boring, right? Looks like closures are just anonymous functions with some syntactical differences. Fortunately, that&#39;s not the entire picture. Closures have a superpower that functions don&#39;t. They can capture variables from their environment. What do I mean by that? Let&#39;s take a look:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Here the <code>capture_i</code> closure prints the value of the variable <code>i</code>(duh!). But this illustrates a key capability of closures. If you look closely, <code>i</code> is not a variable passed to or defined inside the closure. <code>i</code> exists outside the closure and yet the closure can access it. This ability to access variables from a scope outside of the closure&#39;s definition is called capturing from the environment. To prove that this capacity is exclusive to closures, try capturing a variable in a function:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>foo</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>let</span> i <span>=</span> <span>42</span><span>;</span>
    <span><span><span>fn</span> </span><span>bar</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span>
        
        
        <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
    <span><span>}</span></span>
<span><span>}</span></span>
</code></pre>
<p>The compiler helpfully tells us that if your intention was to capture <code>i</code> from the environment, use a closure.</p>
<h2 id="when-to-use-a-closure">When to use a closure</h2>
<p>This is all great, but when would you use a closure? I mean why would you write this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>When you can write this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Much simpler, right. Well, the examples above were a little contrived. A real closure usage would look more like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>create_adder</span></span><span><span><span>(</span><span>a</span><span>:</span> <span>i32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> impl Fn<span>(</span><span>i32</span><span>)</span> </span><span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span></span></span></span>
    <span>move</span> <span>|</span>b<span>|</span> a <span>+</span> b
<span><span>}</span></span>

<span>let</span> add_5 <span>=</span> <span>create_adder</span><span><span>(</span><span>5</span></span><span><span>)</span></span><span>;</span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{}</span><span>&#34;</span></span></span><span><span>,</span> <span>add_5</span><span><span>(</span><span>4</span></span><span><span>)</span></span><span>)</span></span><span>;</span> 
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{}</span><span>&#34;</span></span></span><span><span>,</span> <span>add_5</span><span><span>(</span><span>20</span></span><span><span>)</span></span><span>)</span></span><span>;</span> 
</code></pre>
<p>A lot is going on here, so let&#39;s break it down. First we have a function <code>create_adder</code> which returns a closure. The closure returned by <code>create_adder</code> captures <code>a</code>. Then we call <code>create_adder</code> by passing 5 for <code>a</code>. This gives us a closure which adds 5 to whatever we pass to it. Then we call this closure twice and print the results.</p>
<p>A few pieces of new syntax is worth discussing here. First, notice the <code>move</code> keyword in front of the closure. I&#39;ll explain what the <code>move</code> keyword does later in the article. For now just trust me that it is needed for the code to compile. Next, notice the return value of <code>create_adder</code>: <code>Fn(i32) -&gt; i32</code>. <code>Fn</code> is a trait implemented by the closure we return. Again, I will talk about closure traits in much more detail later in the article. For now the important bit to appreciate is how closure trait syntax is different from other traits. Normally, if we have a trait like <code>Copy</code> we just use its name: <code>impl Copy</code>. But a closure trait includes the signature of the closure as well. So a closure like <code>|a: i32, b: u32| -&gt; usize </code> implements a trait which is written like: <code>Fn(i32, u32) -&gt; usize</code>. And the trait for a closure with no arguments or return value is written like <code>Fn()</code>.</p>
<p>Above you could see that the <code>add_5</code> closure, carried around a logic of &#34;adds five&#34; inside it. It is this power of passing around logic that makes closures so unique. They are very useful in allowing a caller to decide what logic executes inside the guts of a function. For example if you want something like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>some_fn</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    
    
    
<span><span>}</span></span>
</code></pre>
<p>Then receiving a closure in an argument and calling that in line2 will get you what you want. To show you a concrete example, the <a href="https://doc.rust-lang.org/src/core/option.rs.html#985"><code>unwrap_or_else</code> method on <code>Option</code></a> looks like this (simplified for clarity):</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span></span><span><span><span>&lt;</span>T<span>&gt;</span></span></span><span> <span>Option</span><span><span>&lt;</span>T<span>&gt;</span></span> </span><span><span><span>{</span></span></span></span>
    <span><span><span>fn</span> </span><span>unwrap_or_else</span></span><span><span>&lt;</span>F<span>&gt;</span></span><span><span><span>(</span><span>self</span>, <span>f</span><span>:</span> F</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> T</span></span>
    <span><span>where</span></span>
        F<span>:</span> FnOnce<span>(</span><span>)</span> -&gt; T,
    <span><span><span>{</span></span></span>
        <span>match</span> <span>self</span> <span><span>{</span></span>
            <span>Some</span><span><span>(</span>x</span><span><span>)</span></span> <span>=&gt;</span> x<span>,</span>
            <span>None</span> <span>=&gt;</span> <span>f</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
        <span><span>}</span></span>
    <span><span>}</span></span>
<span><span>}</span></span>
</code></pre>
<p>Here you can see that the closure <code>f</code> is only called when <code>self</code> is <code>None</code>. The caller decides what <code>f</code> will return, the rest of the logic is always the same. Another example from the standard library where closures are used extensively is the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> trait</a>.</p>
<p>The code inside the body of a closure influences two aspects of the closure – how a closure captures variables from their environment and which closure traits does the closure implement. Let&#39;s see how.</p>
<h2 id="how-closures-capture-their-environment">How closures capture their environment</h2>
<p>For a minute, let&#39;s go back to the following example you saw before:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Here the closure&#39;s body prints <code>i</code>. So it needs to only immutably borrow <code>i</code>. How do we know? To confirm we can try to use <code>i</code> between the closure definition and the call to closure by, for example, adding a <code>println!</code> between these two lines:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Inside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>If <code>i</code> is borrowed immutably the code should compile, otherwise the borrow checker should shout at us. Since the above code compiles, we can say that <code>i</code> is captured immutably, right? Not so fast. Although the code compiles, we have a flaw in our reasoning. Can you spot what it is? Because <code>i</code> is <code>i32</code> which is <code>Copy</code> the closure could have just copied <code>i</code>. We haven&#39;t proved that <code>i</code> is immutably borrowed. We need a type which is not copy. A <code>String</code> would do:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i<span>:</span> <span>String</span> <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Inside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>This code works, so finally we have proved that <code>i</code> is only immutably borrowed by the above closure. That is the first way closures capture variables: by borrowing immutably. But those are not the only kind of closures. Consider this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> <span>mut</span> animal <span>=</span> <span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>mut</span> <span>capture_animal</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span>
    animal<span>.</span><span>push_str</span><span><span>(</span><span><span>&#34;</span>es<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>

<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>capture_animal</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>This code is very similar to the previous one but here the closure mutates the string <code>animal</code> by pushing a suffix &#34;es&#34; to it. Which means the closure should mutably borrow <code>animal</code>. And indeed, it does because the borrow checker complains about the <code>println!</code> statement. To make the code compile we need to move this line after the call to the closure:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> <span>mut</span> animal <span>=</span> <span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>mut</span> <span>capture_animal</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span>
    animal<span>.</span><span>push_str</span><span><span>(</span><span><span>&#34;</span>es<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>
<span>capture_animal</span><span><span>(</span></span><span><span>)</span></span><span>;</span> 
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span> 
</code></pre>
<p>That is the second way closures capture: by borrowing mutably. The third way closures capture variables is by moving them inside their bodies. For example:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> animal <span>=</span> <span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>capture_animal</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span>
    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Dropping <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
    <span>drop</span><span><span>(</span>animal</span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>
<span>capture_animal</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Here the <code>animal</code> is dropped inside the closure. This means the following wouldn&#39;t work:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> animal <span>=</span> <span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>capture_animal</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span>
    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Dropping <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
    <span>drop</span><span><span>(</span>animal</span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>

<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>capture_animal</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>And neither would moving the <code>println!</code> statement after the closure call:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> animal <span>=</span> <span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>capture_animal</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span>
    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Dropping <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
    <span>drop</span><span><span>(</span>animal</span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>
<span>capture_animal</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>This makes sense because <code>animal</code> is moved into the closure. Borrow checker has every right to call out this code as unsound. In summary, closures capture variables from their environment by either immutably borrowing, mutably borrowing or moving. Not too different from how the rest of Rust works.</p>
<p>Finally, let&#39;s talk about that <code>move</code> keyword you saw earlier. Remember this example from before in which the closure captured <code>i</code> by immutable borrow:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i<span>:</span> <span>String</span> <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Inside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>All the <code>move</code> keyword does is force the closure to take ownership of the variable:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i<span>:</span> <span>String</span> <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>

<span>let</span> capture_i <span>=</span> <span>move</span> <span>||</span> <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Inside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Outside closure: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Once the <code>move</code> keyword forces <code>i</code> to be moved into the closure, the usual caveats apply. So you should know why the second <code>println!</code> statement in the code above needs to be commented out. Having understood that, can you puzzle out why the following works:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i<span>:</span> <span>String</span> <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> i_ref <span>=</span> <span>&amp;</span>i<span>;</span>
<span>let</span> capture_i <span>=</span> <span>move</span> <span>||</span> <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i_ref}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i_ref}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Here we are moving a reference into the closure. So <code>i</code> is essentially immutably borrowed by this closure even though we used the <code>move</code> keyword. This is a neat trick to remember for when you have more than one variable being captured by a closure and you want some of them to move into the closure but others only immutably/mutably borrowed. But when would you want to force variables to move into the closure by using the <code>move</code> keyword? Take this example:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>create_pluralizer</span></span><span><span><span>(</span><span>mut</span> <span>animal</span><span>:</span> String</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> impl FnMut<span>(</span><span>)</span></span> </span><span><span><span>{</span></span></span></span>

    <span>||</span> <span><span>{</span></span>
        animal<span>.</span><span>push_str</span><span><span>(</span><span><span>&#34;</span>es<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
        <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Pluralized animal: <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
    <span><span>}</span></span>
<span><span>}</span></span>

<span>let</span> <span>mut</span> pluralize_fox <span>=</span> <span>create_pluralizer</span><span><span>(</span><span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
<span>pluralize_fox</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Here the closure captures <code>animal</code> by mutable borrow. But that is not sufficient. Because <code>animal</code> is moved into the <code>create_pluralizer</code> function, it is dropped at its end. So later when the returned closure is called it will access a dropped <code>animal</code>. A big no no. To fix this the compiler suggests adding the <code>move</code> keyword in front of the closure:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>create_pluralizer</span></span><span><span><span>(</span><span>mut</span> <span>animal</span><span>:</span> String</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> impl FnMut<span>(</span><span>)</span></span> </span><span><span><span>{</span></span></span></span>
    <span>move</span> <span>||</span> <span><span>{</span> </span>
        animal<span>.</span><span>push_str</span><span><span>(</span><span><span>&#34;</span>es<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
        <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Pluralized animal: <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
    <span><span>}</span></span>
<span><span>}</span></span>

<span>let</span> <span>mut</span> pluralize_fox <span>=</span> <span>create_pluralizer</span><span><span>(</span><span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
<span>pluralize_fox</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Which does fix the issue. Another time you would want to use <code>move</code> is when you are spawning a new thread. A new thread takes a closure and if you want to force move some data to the new thread, you can use the <code>move</code> keyword:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> animal <span>=</span> <span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>

<span>std<span>::</span></span><span>thread<span>::</span></span>spawn<span><span>(</span><span>move</span> <span>||</span> <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Animal owned by this thread: <span>{animal}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span><span>)</span></span>
    <span>.</span><span>join</span><span><span>(</span></span><span><span>)</span></span>
    <span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>But don&#39;t worry too much about this keyword. Most of the time when the compiler suggests to use it, you can mechanically follow its advice and you won&#39;t go wrong.</p>
<h2 id="how-closures-implement-the-closure-traits">How closures implement the closure traits</h2>
<p>There are three traits, <code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code>, that the compiler automatically implements for closures based on what the code inside them does:</p>
<ol>
<li>Compiler implements <code>Fn</code> for those closures which do not mutate or move the captured variables out of the closure. This also includes those closures which do not capture any variables at all. Such a closure can be called multiple times, even in parallel on multiple threads (though you might need additional bounds like <code>Send</code>, <code>Sync</code> and <code>&#39;static</code>).</li>
<li>Compiler implements <code>FnMut</code> for those closures which mutate any captured variables but don&#39;t move them out of the closure. Such a closure can be called multiple times but not in parallel on multiple threads.</li>
<li>Compiler implements <code>FnOnce</code> for those closures which move the captured variables out of the closure, for example by dropping them. Such a closure can be called only once because after calling it the first time it no longer owns the captured variable. Note that the <code>move</code> keyword does not affect whether this trait is implemented or not. <code>move</code> only forces the captured variables to be moved <em>into</em> the closure while <code>FnOnce</code> is implemented if the captured variable is moved <em>out</em>.</li>
</ol>
<p>The <code>Fn</code> trait is a subtrait of <code>FnMut</code> and the <code>FnMut</code> trait is a subtrait of <code>FnOnce</code>. This has a few implications:</p>
<ol>
<li>Every closure implementing <code>Fn</code> trait implements <code>FnMut</code> as well as <code>FnOnce</code>. Which means anywhere an <code>FnMut</code> or <code>FnOnce</code> is expected a closure implementing <code>Fn</code> can be passed.</li>
<li>Every closure implementing <code>FnMut</code>  trait implements <code>FnOnce</code>. Which means anywhere an <code>FnOnce</code> is expected a closure implementing <code>FnMut</code> can be passed.</li>
</ol>
<p>These traits are critical in using closures because the concrete type of a closure can&#39;t be written:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> closure <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span><span>;</span></span>
</code></pre>
<p>Each closure has an anonymous type assigned to it by the compiler. Even two identical closures have different types:</p>
<pre data-lang="rust"><code data-lang="rust"><span>    <span>let</span> <span>mut</span> <span>closure1</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span><span>;</span></span>
    <span>let</span> <span>closure2</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span><span>;</span>
    closure1 <span>=</span> closure2<span>;</span>
</code></pre>
<p>So the only way to refer to closures is through these traits.</p>
<p>Now let&#39;s say we have a function that takes an <code>Fn</code> closure as an argument and calls it:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>Fn</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
</code></pre>
<p>As you can see, a closure which implements the <code>Fn</code> trait can be called multiple times. This trait is implemented automatically by those closures which either capture nothing or capture by an immutable borrow. For example:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>

<span>let</span> <span>capture_nothing</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>I capture nothing<span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>I capture i immutably: <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>call_closure</span><span><span>(</span>capture_nothing</span><span><span>)</span></span><span>;</span>
<span>call_closure</span><span><span>(</span>capture_i</span><span><span>)</span></span><span>;</span>
</code></pre>
<p>But if we try to mutate the captured variables, things no longer work:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> <span>mut</span> i <span>=</span> <span>42</span><span>;</span></span>
<span>call_closure</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span></span>
    i <span>+=</span> <span>1</span><span>;</span>
    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span>
<span><span>}</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>This makes sense, the <code>call_closure</code> method expects an <code>Fn</code> closure which guarantees that it won&#39;t mutate the state. But our closure is mutating the state. The compiler suggests that we change the trait bound in <code>call_closure</code> to <code>FnMut</code> instead. Let&#39;s try that:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span>
<span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>FnMut</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
</code></pre>
<p>It still doesn&#39;t work. Why does the compiler want <code>c</code> to be mutable? This has to do with how closures are implemented by the compiler which is discussed later in the article. For now let&#39;s just blindly follow the compiler and make <code>c</code> mutable:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>FnMut</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>mut</span> <span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
</code></pre>
<p>This finally works. The callee expects an <code>FnMut</code> and the caller passes an <code>FnMut</code>. So what happens if we pass an <code>Fn</code> closure to a function expecting an <code>FnMut</code> closure:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>FnMut</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>mut</span> <span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
<span>let</span> i <span>=</span> <span>42</span><span>;</span>

<span>let</span> <span>fn_closure</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>call_closure</span><span><span>(</span>fn_closure</span><span><span>)</span></span><span>;</span>
</code></pre>
<p>This still works because the <code>FnMut</code> trait bound says that the caller <em>may</em> pass a closure that mutates, not that they have to. In other words, this works because <code>Fn</code> is a subtrait of <code>FnMut</code>. Which means that all closures which implement <code>Fn</code> also implement <code>FnMut</code>.</p>
<p>Let&#39;s extend the example one more time:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span>
<span>let</span> i <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span>call_closure</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span></span>
    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Dropping <span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
    <span>drop</span><span><span>(</span>i</span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>This time we drop <code>i</code> inside the closure. Though the compiler error is not as clear this time, we can figure out what is wrong. Notice that <code>call_closure</code> calls the closure twice, but we are passing a closure that drops <code>i</code>. That would be a double free if allowed. We are passing a <code>FnOnce</code> closure to a function that expects an <code>FnMut</code> closure. So let&#39;s fix it by calling the closure only once and changing the bound to <code>FnOnce</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>FnOnce</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
</code></pre>
<p>The <code>FnOnce</code> trait bound means that the caller <em>might</em> pass a closure that can be called only once. They are not forced to. For example passing an <code>FnMut</code> works:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>FnOnce</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
<span>let</span> <span>mut</span> i <span>=</span> <span><span>&#34;</span>fox<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

<span>let</span> <span>fn_mut_closure</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span></span></span>
    i<span>.</span><span>push_str</span><span><span>(</span><span><span>&#34;</span>es<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>
<span>call_closure</span><span><span>(</span>fn_mut_closure</span><span><span>)</span></span><span>;</span>
</code></pre>
<p>And so does passing an <code>Fn</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>FnOnce</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
<span>let</span> i <span>=</span> <span>42</span><span>;</span>

<span>let</span> <span>fn_closure</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>call_closure</span><span><span>(</span>fn_closure</span><span><span>)</span></span><span>;</span>
</code></pre>
<p>These work is because both <code>Fn</code> and <code>FnMut</code> are subtraits of <code>FnOnce</code>. An important point to note is that the <code>move</code> keyword doesn&#39;t necessarily mean that the closure will implement the <code>FnOnce</code> trait. For example, the following closure implements <code>Fn</code> even though <code>move</code> is used:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> capture_i <span>=</span> <span>move</span> <span>||</span> <span><span>{</span></span>
    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>
</code></pre>
<p>Which trait is implemented is decided by what the closure does with the captured variable, not how it is captured. <code>move</code> only forces the captured variable to be moved <em>into</em> the closure while <code>FnOnce</code> is implemented if the closure moves the captured variable <em>out</em>. Apart from dropping a captured variable, another example of moving a captured variable out of the closure is the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>mut</span> strings <span>=</span> <span>Vec</span><span><span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>
<span>let</span> capture_i<span>:</span> <span>&amp;</span>dyn <span>FnOnce</span><span><span>(</span></span><span><span>)</span></span> <span>=</span> <span>&amp;</span><span>move</span> <span>||</span> <span><span>{</span></span>
    strings<span>.</span><span>push</span><span><span>(</span>i</span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>
</code></pre>
<p>Here the captured <code>i</code> is pushed into <code>strings</code> vec. This moves <code>i</code> out of the closure which makes it implement <code>FnOnce</code>. Even if you remove the <code>move</code> keyword, it is still <code>FnOnce</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span><span>&#34;</span>42<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span></span>
<span>let</span> <span>mut</span> strings <span>=</span> <span>Vec</span><span><span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>

<span>let</span> capture_i<span>:</span> <span>&amp;</span>dyn <span>FnOnce</span><span><span>(</span></span><span><span>)</span></span> <span>=</span> <span>&amp;</span><span>||</span> <span><span>{</span></span>
    strings<span>.</span><span>push</span><span><span>(</span>i</span><span><span>)</span></span><span>;</span>
<span><span>}</span></span><span>;</span>
</code></pre>
<p><code>move</code> keyword made no difference to which trait was implemented.</p>
<p>In the examples above you might have noticed a tug-of-war between the caller and callee. If the callee accepts <code>FnOnce</code> it gets the least freedom in what it can do with the closure – it can just call it once. But the caller is free to pass any closure at all. Because all closures implement <code>FnOnce</code> by virtue of the subtrait/supertrait relationships. </p>
<p>If the callee takes an <code>FnMut</code> it gets a little more leeway. Now it can call the closure multiple times, but it still can&#39;t, for example, call the closure concurrently on multiple threads, because that would lead to data races. The caller in turn gets restricted a little bit more. It can&#39;t, for example, drop a captured variable or otherwise move it outside the closure. </p>
<p>And finally when the callee takes an <code>Fn</code> it is free to do almost anything with it – call it multiple times, even on different threads concurrently. The caller instead has its hands tied in that it can&#39;t even mutate the captured variables in the closure.</p>
<p>This inverse relationship between how much freedom does the caller and callee have should inform your API design. Try to give as much power to the caller as possible by accepting the least restrictive trait bounds; that is, prefer taking an <code>FnOnce</code> to <code>FnMut</code> and an <code>FnMut</code> to an <code>Fn</code>.</p>
<h2 id="function-pointers">Function pointers</h2>
<p>A function pointer is just that: a pointer to a function. For example:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>add</span></span><span><span><span>(</span><span>a</span><span>:</span> <span>i32</span>, <span>b</span><span>:</span> <span>i32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span></span></span></span>
    a <span>+</span> b
<span><span>}</span></span>
<span>let</span> func_ptr<span>:</span> <span>fn</span><span><span>(</span><span>i32</span><span>,</span> <span>i32</span></span><span><span>)</span></span> <span><span>-&gt;</span> <span>i32</span> </span><span>=</span> add<span>;</span>
</code></pre>
<p>Here the <code>func_ptr</code> is a function pointer which points to the <code>add</code> function. Note the type of the function pointer: <code>fn(i32, i32) -&gt; i32</code>. It starts with a lowercase f. Unlike a closure trait a function pointer type is not a trait.</p>
<p>Closures which don&#39;t capture any variable at all are like functions. Hence such closures can be coerced into function pointers:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> func_ptr<span>:</span> <span>fn</span><span><span>(</span><span>i32</span><span>,</span> <span>i32</span></span><span><span>)</span></span> <span><span>-&gt;</span> <span>i32</span> </span><span>=</span> <span><span><span>|</span></span></span><span><span><span>a</span><span>,</span> <span>b</span><span>|</span></span> </span><span>a <span>+</span> b</span><span>;</span> </span>
</code></pre>
<p>But if the closure captures a variable, it can no longer be coerced:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>

<span>let</span> func_ptr<span>:</span> <span>fn</span><span><span>(</span><span>i32</span><span>,</span> <span>i32</span></span><span><span>)</span></span> <span><span>-&gt;</span> <span>i32</span> </span><span>=</span> <span><span><span>|</span></span></span><span><span><span>a</span><span>,</span> <span>b</span><span>|</span></span> </span><span>a <span>+</span> i</span><span>;</span>
</code></pre>
<p>And since functions can&#39;t capture any environment, they are like an <code>Fn</code> closure that captures nothing. And because <code>Fn</code> is the lowest in the trait hierarchy, all function pointers implement all the closure traits:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_fn_once</span></span><span><span>&lt;</span>C<span>:</span> <span>FnOnce</span><span>(</span><span>i32</span>, <span>i32</span><span>)</span> <span>-&gt;</span> <span>i32</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span><span>1</span><span>,</span> <span>2</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>

<span><span><span>fn</span> </span><span>call_fn_mut</span></span><span><span>&lt;</span>C<span>:</span> <span>FnMut</span><span>(</span><span>i32</span>, <span>i32</span><span>)</span> <span>-&gt;</span> <span>i32</span><span>&gt;</span></span><span><span><span>(</span><span>mut</span> <span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span>
    <span>c</span><span><span>(</span><span>1</span><span>,</span> <span>2</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>

<span><span><span>fn</span> </span><span>call_fn</span></span><span><span>&lt;</span>C<span>:</span> <span>Fn</span><span>(</span><span>i32</span>, <span>i32</span><span>)</span> <span>-&gt;</span> <span>i32</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span>
    <span>c</span><span><span>(</span><span>1</span><span>,</span> <span>2</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>

<span><span><span>fn</span> </span><span>add</span></span><span><span><span>(</span><span>a</span><span>:</span> <span>i32</span>, <span>b</span><span>:</span> <span>i32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span></span></span>
    a <span>+</span> b
<span><span>}</span></span>

<span>call_fn_once</span><span><span>(</span>add</span><span><span>)</span></span><span>;</span>
<span>call_fn_mut</span><span><span>(</span>add</span><span><span>)</span></span><span>;</span>
<span>call_fn</span><span><span>(</span>add</span><span><span>)</span></span><span>;</span>
</code></pre>
<p>So when should you use a function pointer and when a closure? Your first choice should be a closure because it gives  the caller more freedom in what to pass. For example, the <code>call_fn</code> can accept both a closure and a function pointer:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_fn</span></span><span><span>&lt;</span>C<span>:</span> <span>Fn</span><span>(</span><span>i32</span>, <span>i32</span><span>)</span> <span>-&gt;</span> <span>i32</span><span>&gt;</span></span><span><span><span>(</span><span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span><span>1</span><span>,</span> <span>2</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>

<span><span><span>fn</span> </span><span>add</span></span><span><span><span>(</span><span>a</span><span>:</span> <span>i32</span>, <span>b</span><span>:</span> <span>i32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span></span></span>
    a <span>+</span> b
<span><span>}</span></span>

<span>call_fn</span><span><span>(</span>add</span><span><span>)</span></span><span>;</span>
<span>call_fn</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>a</span><span>,</span> <span>b</span><span>|</span></span> </span><span>a <span>+</span> b</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>There are times when using a function pointer makes sense. For example, when you are calling C code through FFI it&#39;s ok to use function pointers because C doesn&#39;t understand Rust closures. Another reason to pick a function pointer can be performance. Since closures can only be used through closure traits, all the usual tradeoffs for traits apply. You have to pick between static vs dynamic dispatch, for example. You can sidestep this concern by using function pointers. But measure before you go this route. In short, prefer closures and use function pointers only when you have to.</p>
<h2 id="how-the-compiler-implements-closures">How the compiler implements closures</h2>
<p>Even if you understood everything until now, you might have nagging questions about how closures <em>actually</em> work. What does it mean to pass a closure around? Where does it store captured variables? Well it&#39;s quite simple, the compiler uses a struct to store the captured variables. For example a closure like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> i <span>=</span> <span>42</span><span>;</span></span>
<span>let</span> <span>capture_i</span> <span>=</span> <span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{i}</span><span>&#34;</span></span></span><span><span>)</span></span></span><span>;</span>
<span>capture_i</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Is desugared into something like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span>
<span><span>struct</span> </span><span><span><span>Closure</span><span><span>&lt;</span><span>&#39;a</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span></span></span>
    <span>i</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span>
<span><span>}</span></span>

<span><span>impl</span> </span><span>Fn <span>for</span></span><span> <span>Closure</span><span><span>&lt;</span>&#39;<span>_</span><span>&gt;</span></span> </span><span><span><span>{</span></span></span>
    <span><span><span>fn</span> </span><span>call</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span>
        <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{}</span><span>&#34;</span></span></span><span><span>,</span> <span>self</span><span>.</span>i<span>)</span></span><span>;</span>
    <span><span>}</span></span>
<span><span>}</span></span>

<span>let</span> i <span>=</span> <span>42</span><span>;</span>
<span>let</span> capture_i <span>=</span> Closure <span><span>{</span> i<span>:</span> <span>&amp;</span>i </span><span><span>}</span></span><span>;</span>
capture_i<span>.</span><span>call</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</code></pre>
<p>Here the closure captures a reference to <code>i</code> that is why the <code>Closure</code> struct&#39;s <code>i</code> has a type <code>&amp;&#39;a i32</code>. Then the compiler implements the <code>Fn</code> trait for this struct and calling the closure calls the <code>call</code> method of the <code>Fn</code> trait. The idea is similar for closures which capture variables by mutable reference and which capture by taking ownership.</p>
<p>You are now in a position to understand why we had to make <code>c</code> mutable for an <code>FnMut</code> closure. The example where we did this is replicated below for convenience:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>call_closure</span></span><span><span>&lt;</span>C<span>:</span> <span>FnMut</span><span>(</span><span>)</span><span>&gt;</span></span><span><span><span>(</span><span>mut</span> <span>c</span><span>:</span> C</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span></span></span></span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>c</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span><span>}</span></span>
</code></pre>
<p>We had to make <code>c</code> mutable because the <code>FnMut</code> trait is defined something like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>pub</span> <span>trait</span> <span>FnMut</span> : FnOnce</span></span>
<span><span>{</span></span>
    <span><span><span>fn</span> </span><span>call_mut</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span>;</span>
<span><span>}</span></span>
</code></pre>
<p>(The actual <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code> is defined like this</a>, I simplified it for ease of understanding). The <code>call_mut</code> method takes <code>self</code> by <code>&amp;mut</code> which is why compiler wants <code>c</code> to be <code>mut</code>. If you want to dig deeper into closures, you can take a look at an explanation of <a href="https://rustc-dev-guide.rust-lang.org/closure.html">how closures are expanded by the compiler</a>. Or <a href="https://github.com/rust-lang/rust/blob/4eb5225cdf0b6e5a3cefccf4172eb0b2a496b6a2/compiler/rustc_middle/src/ty/sty.rs#L131">take a look at their actual representation in rustc</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Closures in Rust, like many other languages, are a useful tool to make your APIs more fluent and the code more concise and expressive. But due to Rust&#39;s unique safety guarantees they are also a little harder to master. Hopefully this article gave you a thorough understanding in them. Please 🙏 don&#39;t forget to share on Twitter 👇.</p>



        </article></div>
  </body>
</html>
