<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nomadiq.hashnode.dev/reimagining-front-end-web-development-with-htmx-and-hyperscript">Original</a>
    <h1>Reimagining front-end web development with htmx and hyperscript</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div id="post-content-wrapper"><p>We all know that to create an interactive front end for your website you need JavaScript. Not just vanilla JS, mind: we&#39;re in 2022, and to create an acceptable UI you need to be using a framework like React or Vue.js. Right?</p>
<p>Wrong.</p>
<p>In recent years, a few mavericks and renegades have started to turn away from the world of JS frameworks and the inevitable bloated <em>node_modules</em> folders. But what if you want a smooth single-page app experience, rather than waiting for the whole page to render every time you click a button? Of course, nobody wants to write a load of boilerplate JS for every little interaction. This is where <em>hypermedia</em> in the form of <a target="_blank" href="https://htmx.org/">htmx</a> and <a target="_blank" href="https://hyperscript.org/">hyperscript</a> come in.</p>
<p>These two open-source toolkits, both developed by <a target="_blank" href="https://github.com/bigskysoftware">Big Sky Software</a> and collaborators, provide a host of HTML attributes to deal with AJAX requests, partial DOM updates, CSS transitions, event handling, Server-Sent Events and WebSockets in a clear, user-friendly syntax. There are a number of excellent tutorials online demonstrating the capabilities of these tools; I particularly like <a target="_blank" href="https://www.youtube.com/channel/UCTwxaBjziKfy6y_uWu30orA">BugBytes&#39; tutorials on YouTube</a>. In this article, I&#39;m going to show you how I used them in my <a target="_blank" href="https://github.com/nomadiq-sw/member-zone">current project</a>, which is a simple membership/subscription tracking site made with Django.</p>
<p>My goal was to allow users to add memberships to their personal lists via a form in a modal (pop-up) dialog, and to edit or delete existing memberships from a table which would be updated with no page reload. The starting point was <a target="_blank" href="https://blog.benoitblanchon.fr/django-htmx-modal-form/">this excellent article</a> by Benoit Blanchon; in Benoit&#39;s article he uses htmx, but eschews the less-mature hyperscript in favour of some simple JS functions. Since htmx and hyperscript are developed with the same philosophy and are <a target="_blank" href="https://htmx.org/docs/#hyperscript">designed to work well together</a>, I decided to go all-in on the hypermedia hype train and try not to use a single line of &#39;pure&#39; JavaScript. Another minor difference is that I&#39;m using TailwindCSS whereas Benoit uses Bootstrap, so the names of some of the utility classes will be different.</p>
<h3 id="heading-modal-dialog-and-form-submission">Modal dialog and form submission</h3>
<p>The first step is to allow the modal dialog containing the form to be opened and closed, with the possibility of submitting the form. Since I&#39;m using <a target="_blank" href="https://daisyui.com/">daisyUI</a>, a ready-made modal component is available which can be opened or closed by adding or removing the <code>.modal-open</code> class.
<img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1656669132894/hSpZfv5yo.png?auto=compress,format&amp;format=webp" alt="Modal_form_screenshot_2.png"/>
This is a classic use-case for hyperscript; the &#39;New&#39; button adds the class to the modal, while the &#39;Close&#39; button removes it.</p>
<pre><code><span>&lt;</span><span>!</span><span>-</span><span>-</span> <span>&#39;New&#39;</span> button on the main <span>&#39;my-memberships&#39;</span> page <span>-</span><span>-</span><span>&gt;</span>
<span>&lt;</span>button <span>_</span><span>=</span><span>&#34;on htmx:afterRequest add .modal-open to #modal&#34;</span>
        hx<span>-</span>get<span>=</span><span>&#34;{% url &#39;my-memberships&#39; %}&#34;</span> hx<span>-</span>select<span>=</span><span>&#34;#modal-box&#34;</span> hx<span>-</span>target<span>=</span><span>&#34;#modal&#34;</span>
        class<span>=</span><span>&#34;mx-auto md:ml-2 btn btn-primary btn-square border-none basis-14&#34;</span><span>&gt;</span>New
<span>&lt;</span><span>/</span>button<span>&gt;</span>

<span>&lt;</span><span>!</span><span>-</span><span>-</span> <span>&#39;Close&#39;</span> button on the top<span>-</span>right corner of the modal dialog <span>-</span><span>-</span><span>&gt;</span>
<span>&lt;</span>button <span>_</span><span>=</span><span>&#34;on click remove .modal-open from #modal&#34;</span>
        class<span>=</span><span>&#34;btn btn-sm btn-circle absolute right-2 top-2&#34;</span><span>&gt;</span>âœ•
<span>&lt;</span><span>/</span>button<span>&gt;</span>
</code></pre><p>Note the use of the <code>htmx:afterRequest</code> event on the &#39;New&#39; button, as opposed to the simple <code>click</code> event on the &#39;Close&#39; button. This is because we wait for the new, empty form to be returned from the back end at &#39;my-memberships&#39; before showing the form (otherwise a &#39;dirty&#39; version of the form with previous entries and validation errors might be shown before the &#39;clean&#39; form is returned from the server). Note also that we use the <code>hx-select</code> attribute to select only the <code>#modal-box</code> element from the response, and <code>hx-target</code> to place it in the <code>#modal</code> element (the response to the GET request otherwise contains the whole &#39;my-memberships&#39; page, which is not what we want in our modal!).</p>
<p>There&#39;s also the &#39;Save&#39; button on the form, which submits the form with a POST request to the &#39;my-memberships&#39; back end. hyperscript is used to disable the button until the response has been loaded, to prevent repeat submission.</p>
<pre><code><span>&lt;</span>button <span>type</span><span>=</span><span>&#34;submit&#34;</span> class<span>=</span><span>&#34;btn btn-primary border-none&#34;</span>
        <span>_</span><span>=</span><span>&#34;on click toggle @disabled until htmx:afterOnLoad&#34;</span><span>&gt;</span>Save
<span>&lt;</span><span>/</span>button<span>&gt;</span>
</code></pre><p>The class-based view associated with the &#39;my-memberships&#39; URL is as follows:</p>
<pre><code>class MembershipView(LoginRequiredMixin, TemplateView):
    template_name <span>=</span> <span>&#39;memberships.html&#39;</span>
    extra_context <span>=</span> {<span>&#39;form&#39;</span>: MembershipEditForm()}

    def post(<span>self</span>, request, <span>*</span>args, <span>*</span><span>*</span>kwargs):
        form <span>=</span> MembershipEditForm(request.POST)
        success <span>=</span> False
        <span>if</span> form.is_valid():
            membership <span>=</span> form.save(commit<span>=</span>False)
            <span>if</span> kwargs:
                <span>if</span> kwargs[<span>&#39;update&#39;</span>]:
                    membership.pk <span>=</span> kwargs[<span>&#39;pk&#39;</span>]
            membership.user <span>=</span> request.user
            membership.save()
            success <span>=</span> True
            <span>self</span>.request.path <span>=</span> reverse_lazy(<span>&#39;my-memberships&#39;</span>)
            form <span>=</span> MembershipEditForm()

        response <span>=</span> render(request, <span>&#39;partials/modal-form.html&#39;</span>, {<span>&#39;form&#39;</span>: form})
        <span>if</span> success:
            response[<span>&#39;HX-Trigger&#39;</span>] <span>=</span> <span>&#39;membershipsChanged&#39;</span>
        <span>return</span> response
</code></pre><p>There are two possible outcomes of form submission:</p>
<ol>
<li>the submitted form is returned with validation errors, in which case htmx will swap the existing modal dialog with the response and display the errors:<pre><code><span>&lt;</span>div id<span>=</span><span>&#34;modal-box&#34;</span> class<span>=</span><span>&#34;modal-box p-4 scrollbar-thin&#34;</span> hx<span>-</span>target<span>=</span><span>&#34;this&#34;</span> hx<span>-</span>swap<span>=</span><span>&#34;outerHTML&#34;</span><span>&gt;</span>
...
{<span>%</span> <span>if</span> form.non_field_errors <span>%</span>}
 <span>&lt;</span>div class<span>=</span><span>&#34;mt-2&#34;</span><span>&gt;</span>
   {{ form<span>|</span>as_crispy_errors }}
 <span>&lt;</span><span>/</span>div<span>&gt;</span>
{<span>%</span> <span>else</span> <span>%</span>}
 <span>&lt;</span>p class<span>=</span><span>&#34;pt-2 pb-4&#34;</span><span>&gt;</span>Enter the details of your subscription below<span>&lt;</span><span>/</span>p<span>&gt;</span>
{<span>%</span> endif <span>%</span>}
...
<span>&lt;</span><span>/</span>div<span>&gt;</span>
</code></pre></li>
<li>the new membership is saved to the database and a clean form is returned. In this case, we attach the &#39;HX-Trigger&#39; header to the response with the value <code>membershipsChanged</code>. This is the cue to our frontend to close the modal and update the table displaying the user&#39;s memberships:<pre><code><span>&lt;</span>table class<span>=</span><span>&#34;table table-fixed grow&#34;</span><span>&gt;</span>
<span>&lt;</span>thead class<span>=</span><span>&#34;w-auto&#34;</span><span>&gt;</span>
 ...
<span>&lt;</span><span>/</span>thead<span>&gt;</span>
<span>&lt;</span>tbody id<span>=</span><span>&#34;membership-table-body&#34;</span>
       hx<span>-</span>trigger<span>=</span><span>&#34;load, membershipsChanged from:body&#34;</span>
       hx<span>-</span>get<span>=</span><span>&#34;{% url &#39;update-memberships&#39; %}&#34;</span>
       hx<span>-</span>target<span>=</span><span>this</span>
       <span>_</span><span>=</span><span>&#34;on htmx:afterOnLoad add .hidden to #spinner&#34;</span><span>&gt;</span>
<span>&lt;</span><span>/</span>tbody<span>&gt;</span>
<span>&lt;</span><span>/</span>table<span>&gt;</span>
</code></pre>Of course we also load the memberships into the table when the <code>load</code> event occurs (on page load) and hide the &#39;loading&#39; spinner once htmx has loaded the response into the table. </li>
</ol>
<h3 id="heading-updating-the-memberships-table">Updating the memberships table</h3>
<p>If the <code>membershipsChanged</code> event is received, we know that the new membership has been saved successfully and we can update the form. I included a small (hyper)script on the &#39;my-memberships&#39; page which temporarily shows a success alert in this case:</p>
<pre><code>&lt;script <span>type</span>=&#34;text/hyperscript&#34;&gt;
  <span>on</span> membershipsChanged
    remove .modal-<span>open</span> <span>from</span> #modal
    <span>show</span> #alert-success
    wait <span>3</span>s
    hide #alert-success
  <span>end</span>
&lt;/script&gt;
</code></pre><p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1656670325927/6CS8tq0zL.png?auto=compress,format&amp;format=webp" alt="Memberships_table_screenshot.png"/>
The table display includes a column to allow reminders (of renewal, free trial expiry etc.) to be toggled on or off with a simple click. htmx is used to send a PATCH request to the server with the primary key of the relevant membership included in the URL.</p>
<pre><code><span>&lt;</span>input <span>type</span><span>=</span><span>&#34;checkbox&#34;</span>
       class<span>=</span><span>&#34;checkbox checkbox-primary border-gray-400 mt-1&#34;</span>
       {<span>%</span> <span>if</span> membership.reminder <span>%</span>}checked{<span>%</span> endif <span>%</span>}
       hx<span>-</span>patch<span>=</span><span>&#34;{% url &#39;toggle-reminders&#39; membership.pk %}&#34;</span>
       hx<span>-</span>swap<span>=</span><span>&#34;none&#34;</span><span>/</span><span>&gt;</span>
</code></pre><p>This is picked up on the back end by a simple function which toggles the reminder state of the given membership:</p>
<pre><code>@login_required()
def toggle_reminders(request, pk):
    <span>if</span> request.method <span>=</span><span>=</span> <span>&#39;PATCH&#39;</span>:
        membership <span>=</span> Membership.objects.get(pk<span>=</span>pk)
        <span>if</span> membership.user <span>=</span><span>=</span> request.user:
            membership.reminder <span>=</span> not membership.reminder
            membership.save()
</code></pre><p>There is no return value, and htmx does not expect any since we specified <code>hx-swap=&#34;none&#34;</code> (no content is swapped into the target in this case, even if such content is present in the body of the response). If we wanted to handle the possibility that the object is not found, we could use <code>get_object_or_404()</code> and send an &#39;HX-Redirect&#39; header in the response to prompt htmx to redirect to a 404 page.</p>
<p>We also have a dropdown menu accessible by clicking the name of each membership, which allows us to edit or delete this membership.</p>
<pre><code><span>&lt;</span>ul tabindex<span>=</span><span>&#34;0&#34;</span> class<span>=</span><span>&#34;dropdown-content menu p-2 shadow bg-base-100 rounded-box w-24&#34;</span><span>&gt;</span>
  <span>&lt;</span>li<span>&gt;</span>
    <span>&lt;</span>a hx<span>-</span>get<span>=</span><span>&#34;{% url &#39;edit-membership&#39; membership.pk %}&#34;</span> hx<span>-</span>target<span>=</span><span>&#34;#modal&#34;</span>
       <span>_</span><span>=</span><span>&#34;on htmx:afterRequest add .modal-open to modal&#34;</span><span>&gt;</span>Edit
    <span>&lt;</span><span>/</span>a<span>&gt;</span>
  <span>&lt;</span><span>/</span>li<span>&gt;</span>
  <span>&lt;</span>li<span>&gt;</span>
    <span>&lt;</span>a hx<span>-</span>post<span>=</span><span>&#34;{% url &#39;delete-membership&#39; membership.pk %}&#34;</span>
       hx<span>-</span>confirm<span>=</span><span>&#34;Are you sure you want to delete the membership &#39;{{ membership.membership_name }}&#39;?&#34;</span>
       hx<span>-</span>target<span>=</span><span>&#34;closest tr&#34;</span> hx<span>-</span>swap<span>=</span><span>&#34;delete&#34;</span><span>&gt;</span>Delete
    <span>&lt;</span><span>/</span>a<span>&gt;</span>
  <span>&lt;</span><span>/</span>li<span>&gt;</span>
<span>&lt;</span><span>/</span>ul<span>&gt;</span>
</code></pre><p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1656671790287/ID6wJHJ7t.png?auto=compress,format&amp;format=webp" alt="Table_entry_dropdown_screenshot.png"/>
Clicking &#39;Edit&#39; brings up the modal populated with the details of the existing membership; as a consequence of this request, the target URL on form submission is updated to a URL specific to this membership (although in the end the POST request is forwarded to the same function as for creation, just with the optional &#39;update&#39; keyword).</p>
<pre><code>class EditMembershipView(LoginRequiredMixin, UpdateView):
    model <span>=</span> Membership
    fields <span>=</span> <span>&#34;__all__&#34;</span>
    template_name <span>=</span> <span>&#39;partials/modal-form.html&#39;</span>

    def get(<span>self</span>, request, <span>*</span>args, <span>*</span><span>*</span>kwargs):
        <span>self</span>.object <span>=</span> <span>self</span>.get_object()
        <span>if</span> <span>self</span>.object.user <span>=</span><span>=</span> request.user:
            <span>return</span> <span>super</span>().get(request, <span>*</span>args, <span>*</span><span>*</span>kwargs)

    def post(<span>self</span>, request, <span>*</span>args, <span>*</span><span>*</span>kwargs):
        <span>self</span>.object <span>=</span> <span>self</span>.get_object()
        <span>if</span> <span>self</span>.object.user <span>=</span><span>=</span> request.user:
            <span>return</span> MembershipView.as_view()(request, update<span>=</span>True, pk<span>=</span><span>self</span>.object.pk)
</code></pre><p>Clicking &#39;Delete&#39; causes the page to prompt for confirmation and then POSTs the request to the back end (we are using POST rather than DELETE here because the view extends Django&#39;s &#39;DeleteView&#39;, which expects a POST request).</p>
<pre><code><span><span>class</span> <span>DeleteMembershipView</span>(<span>LoginRequiredMixin</span>, <span>DeleteView</span>):</span>
    model = Membership

    <span><span>def</span> <span>post</span><span>(<span>self</span>, request, *args, **kwargs)</span></span>:
        <span>self</span>.object = <span>self</span>.get_object()
        <span>if</span> <span>self</span>.object.user == <span>self</span>.request.<span>user:</span>
            <span>self</span>.object.delete()
            <span>return</span> HttpResponse()
            
        <span>return</span> redirect(<span>&#39;my-memberships&#39;</span>)
</code></pre><p>The response code in case of success is <code>200 - OK</code> rather than <code>204 - No Content</code> because otherwise htmx will not trigger a <code>delete</code> of the <code>closest tr</code> as requested by the <code>hx-swap</code> and <code>hx-target</code> attributes (we could always do this by triggering an event with an &#39;HX-Trigger&#39; header in the <code>204</code> response and using hyperscript, but this adds an extra step for no functional gain).</p>
<h3 id="heading-final-thoughts">Final thoughts</h3>
<p>So there you have it: a modal form and a table handled entirely with htmx and hyperscript, with no JavaScript or page reloads in sight. Once you get into the hypermedia mindset, it turns out to be a fairly intuitive and extremely powerful and flexible way of building responsive UIs. Occasionally the built-in htmx attributes don&#39;t quite have the desired behaviour (as in the case of the reaction to a <code>204</code> response when deleting), but the <a target="_blank" href="https://htmx.org/docs/#response-headers">available headers</a> allow us to trigger events and handle these cases on the front end. This makes the combination of htmx and hyperscript all the more powerful, and hyperscript&#39;s readability is second to none.</p>
<p>Both htmx and hyperscript are available through the public <em>unpkg</em> CDN, or as standalone .js or npm packages. It&#39;s really easy to get started by following a few tutorials, and I encourage anyone who wants to build a website without having to bundle React, Vue or Angular to give it a try. Next steps on a project like mine could include infinite scroll with pagination on the table, clicking column headers to sort results without page reload, or the addition of tabs to switch smoothly between table and calendar views.</p>
<p>I hope you enjoyed this post, and that you&#39;ll come back for the next one!</p>
</div></div></section></div></div>
  </body>
</html>
