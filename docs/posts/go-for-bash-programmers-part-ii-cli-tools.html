<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/go-monk/from-bash-to-go-part-ii">Original</a>
    <h1>Go for Bash Programmers â€“ Part II: CLI Tools</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">This is the second part of a series introducing Bash programmers to Go. This part is about basics of writing CLI tools in Go. See the <a href="https://github.com/go-monk/from-bash-to-go-part-i">first</a> part for the language building blocks.</p>

<p dir="auto">Bash is often used to write small CLI tools and automation. Let&#39;s start with an example CLI tool that prints &#34;hello&#34; to terminal. The Bash version is pretty simple:</p>

<p dir="auto">Now, let&#39;s implement a Go version. We start by creating a directory where the first version of our program will live. We also initialize a module in there:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ mkdir -p hello/1
$ cd hello/1
$ go mod init hello"><pre>$ mkdir -p hello/1
$ <span>cd</span> hello/1
$ go mod init hello</pre></div>
<p dir="auto">Since the program is not complex we don&#39;t have to think a lot about its design and can easily start with a test:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/1/hello_test.go
package hello_test

import (
	&#34;hello&#34;
	&#34;testing&#34;
)

func TestPrintExists(t *testing.T) {
	hello.Print()
}"><pre><span>// hello/1/hello_test.go</span>
<span>package</span> hello_test

<span>import</span> (
	<span>&#34;hello&#34;</span>
	<span>&#34;testing&#34;</span>
)

<span>func</span> <span>TestPrintExists</span>(<span>t</span> <span>*</span>testing.<span>T</span>) {
	<span>hello</span>.<span>Print</span>()
}</pre></div>
<p dir="auto">We named the package <code>hello_test</code> instead of <code>hello</code>. This is possible and it allows for writing tests that use only the public API (identifiers starting with a capital letter) of the tested package as a real user would. In this test we just call the <code>Print</code> function from the <code>hello</code> package. Let&#39;s try and run the test:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ go test
hello: no non-test Go files in ~/github.com/go-monk/from-bash-to-go-series/part-ii-cli-tools/hello/1
FAIL    hello [build failed]"><pre>$ go <span>test</span>
hello: no non-test Go files <span>in</span> <span>~</span>/github.com/go-monk/from-bash-to-go-series/part-ii-cli-tools/hello/1
FAIL    hello [build failed]</pre></div>
<p dir="auto">Yes, we have not yet written the code we want to test. So let&#39;s do it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/1/hello.go
package hello

func Print() {}"><pre><span>// hello/1/hello.go</span>
<span>package</span> hello

<span>func</span> <span>Print</span>() {}</pre></div>
<p dir="auto">If we re-run the test</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ go test
PASS
ok      hello   0.570s"><pre>$ go <span>test</span>
PASS
ok      hello   0.570s</pre></div>
<p dir="auto">we can see that all is good now. Or is it? Well, something must be wrong because an empty function that does nothing at all (except that it exists) passes the test. So the <em>test</em> is obviously wrong. Now we need to start thinking a bit. What should be actually tested?</p>

<p dir="auto">Okay, we want the function to print the string &#34;hello&#34; to terminal. How to test it except by looking at the terminal? In Bash the terminal is the standard output, i.e. the place where the stuff is written to by default. But we can redirect the standard output to a file or store it in a variable:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo hello &gt; /tmp/hello.txt
$ HELLO=$(echo hello)"><pre>$ <span>echo</span> hello <span>&gt;</span> /tmp/hello.txt
$ HELLO=<span><span>$(</span>echo hello<span>)</span></span></pre></div>
<p dir="auto">In Go you can achieve similar functionality by using the standard library interface called <a href="https://pkg.go.dev/io#Writer" rel="nofollow">io.Writer</a> (that is the <code>Writer</code> from the <code>io</code> package):</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/2/hello.go
func PrintTo(w io.Writer) {
	s := &#34;hello&#34;
	w.Write([]byte(s))
}"><pre><span>// hello/2/hello.go</span>
<span>func</span> <span>PrintTo</span>(<span>w</span> io.<span>Writer</span>) {
	<span>s</span> <span>:=</span> <span>&#34;hello&#34;</span>
	<span>w</span>.<span>Write</span>([]<span>byte</span>(<span>s</span>))
}</pre></div>
<p dir="auto">We write (print) the string &#34;hello&#34; to <code>w</code> supplied as the function&#39;s argument. And since the argument (parameter more precisely) is an interface it can be multiple kinds of things. Or more precisely it can be any type that implements the <code>io.Writer</code> interface, i.e. has a function with the <code>Write(p []byte) (int, error)</code> signature attached.</p>
<p dir="auto">There are many implementations of <code>io.Writer</code> in the standard library. Two of them are <code>bytes.Buffer</code> and <code>os.Stdout</code>. We can write to a bytes buffer in the test</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/2/hello_test.go
func TestPrintToPrintsHelloToWriter(t *testing.T) {
	buf := new(bytes.Buffer)
	hello.PrintTo(buf) // writing to buffer
	want := &#34;hello&#34;
	got := buf.String()
	if want != got {
		t.Errorf(&#34;want %q, got %q&#34;, want, got)
	}
}"><pre><span>// hello/2/hello_test.go</span>
<span>func</span> <span>TestPrintToPrintsHelloToWriter</span>(<span>t</span> <span>*</span>testing.<span>T</span>) {
	<span>buf</span> <span>:=</span> <span>new</span>(bytes.<span>Buffer</span>)
	<span>hello</span>.<span>PrintTo</span>(<span>buf</span>) <span>// writing to buffer</span>
	<span>want</span> <span>:=</span> <span>&#34;hello&#34;</span>
	<span>got</span> <span>:=</span> <span>buf</span>.<span>String</span>()
	<span>if</span> <span>want</span> <span>!=</span> <span>got</span> {
		<span>t</span>.<span>Errorf</span>(<span>&#34;want %q, got %q&#34;</span>, <span>want</span>, <span>got</span>)
	}
}</pre></div>
<p dir="auto">and to the standard output in the main function</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/2/cmd/hello/main.go
func main() {
	hello.PrintTo(os.Stdout) // writing to STDOUT
}"><pre><span>// hello/2/cmd/hello/main.go</span>
<span>func</span> <span>main</span>() {
	<span>hello</span>.<span>PrintTo</span>(<span>os</span>.<span>Stdout</span>) <span>// writing to STDOUT</span>
}</pre></div>
<p dir="auto">Now we have a real test that we can rely on:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ cd hello/2
$ go test
PASS
ok      hello   0.183s"><pre>$ <span>cd</span> hello/2
$ go <span>test</span>
PASS
ok      hello   0.183s</pre></div>
<p dir="auto">As an exercise try to break the test so it doesn&#39;t pass.</p>
<p dir="auto">We also added the <code>cmd</code> folder that holds the binary (command) to be used by the end user like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ go install ./cmd/hello
$ hello
hello"><pre>$ go install ./cmd/hello
$ hello
hello</pre></div>

<p dir="auto">Talking about the end user and looking at how the <code>PrintTo</code> function is called in <code>main</code></p>

<p dir="auto">we might think this is not ideal. Why should a user tell the function to print to standard output? Isn&#39;t it what most users want most of the time? Shouldn&#39;t it be the default behavior?</p>

<p dir="auto">But the <code>PrintTo</code> function <em>must</em> have an argument when called. So maybe we can use the approach that&#39;s used by the <code>http.ListenAndServe</code> standard library function; we use <code>nil</code> to indicate we want the default behaviour:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/3/hello.go
func PrintTo(w io.Writer) {
	if w == nil {
		w = os.Stdout
	}
	s := &#34;hello&#34;
	w.Write([]byte(s))
}"><pre><span>// hello/3/hello.go</span>
<span>func</span> <span>PrintTo</span>(<span>w</span> io.<span>Writer</span>) {
	<span>if</span> <span>w</span> <span>==</span> <span>nil</span> {
		<span>w</span> <span>=</span> <span>os</span>.<span>Stdout</span>
	}
	<span>s</span> <span>:=</span> <span>&#34;hello&#34;</span>
	<span>w</span>.<span>Write</span>([]<span>byte</span>(<span>s</span>))
}</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/3/cmd/hello/main.go
hello.PrintTo(nil)"><pre><span>// hello/3/cmd/hello/main.go</span>
<span>hello</span>.<span>PrintTo</span>(<span>nil</span>)</pre></div>
<p dir="auto">Hmm, this works but still seems unnecessary complex.</p>

<p dir="auto">We could remove the need for an argument altogether by using a global variable that would define where to write:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/4/hello.go
var Output io.Writer = os.Stdout"><pre><span>// hello/4/hello.go</span>
<span>var</span> <span>Output</span> io.<span>Writer</span> <span>=</span> <span>os</span>.<span>Stdout</span></pre></div>
<p dir="auto">To change the default, you change the global variable:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/4/hello_test.go
hello.Output = new(bytes.Buffer)
hello.Print()"><pre><span>// hello/4/hello_test.go</span>
<span>hello</span>.<span>Output</span> <span>=</span> <span>new</span>(bytes.<span>Buffer</span>)
<span>hello</span>.<span>Print</span>()</pre></div>
<p dir="auto">However, changing the state globally is always dangerous. For example, if we had multiple tests that would be running in parallel (using <code>testing.Parallel()</code> for example), changing the global variable from multiple functions at the same time could cause problems.</p>

<p dir="auto">A way to avoid the dangers of global variables is to create a custom variable type, usually based on a struct:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/5/hello.go
type Printer struct {
	Output io.Writer
}"><pre><span>// hello/5/hello.go</span>
<span>type</span> <span>Printer</span> <span>struct</span> {
	<span>Output</span> io.<span>Writer</span>
}</pre></div>
<p dir="auto">Now you can have multiple variables of this type that won&#39;t affect each other:</p>
<div dir="auto" data-snippet-clipboard-copy-content="p1 := hello.Printer{Output: os.Stdout}
p2 := hello.Printer{Output: os.Stderr}
p1.Print() // prints to standard output
p2.Print() // prints to standard error"><pre><span>p1</span> <span>:=</span> hello.<span>Printer</span>{<span>Output</span>: <span>os</span>.<span>Stdout</span>}
<span>p2</span> <span>:=</span> hello.<span>Printer</span>{<span>Output</span>: <span>os</span>.<span>Stderr</span>}
<span>p1</span>.<span>Print</span>() <span>// prints to standard output</span>
<span>p2</span>.<span>Print</span>() <span>// prints to standard error</span></pre></div>
<p dir="auto">But we re-introduced the problem of having to define the default writer. To fix this we create a function called <code>NewPrinter</code> that sets the output to the default value:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/6/hello.go
func NewPrinter() *Printer {
	return &amp;Printer{
		Output: os.Stdout,
	}
}"><pre><span>// hello/6/hello.go</span>
<span>func</span> <span>NewPrinter</span>() <span>*</span><span>Printer</span> {
	<span>return</span> <span>&amp;</span><span>Printer</span>{
		<span>Output</span>: <span>os</span>.<span>Stdout</span>,
	}
}</pre></div>
<p dir="auto">Note that now we use a <em>pointer</em> to <code>Printer</code>. This way we can change the default output by assigning to the <code>Output</code> field:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// hello/6/cmd/hello/main.go
p := hello.NewPrinter()
p.Output = os.Stderr
p.Print()"><pre><span>// hello/6/cmd/hello/main.go</span>
<span>p</span> <span>:=</span> <span>hello</span>.<span>NewPrinter</span>()
<span>p</span>.<span>Output</span> <span>=</span> <span>os</span>.<span>Stderr</span>
<span>p</span>.<span>Print</span>()</pre></div>

<p dir="auto">Having done the obligatory hello (world) example let&#39;s turn to something more practical. We&#39;ll write a CLI tool to count duplicate lines in input. To be able to change the input we create a type called <code>counter</code> with the <code>input</code> field of the <code>io.Reader</code> type</p>
<div dir="auto" data-snippet-clipboard-copy-content="// count/1/count.go
type counter struct {
	input io.Reader
}"><pre><span>// count/1/count.go</span>
<span>type</span> <span>counter</span> <span>struct</span> {
	<span>input</span> io.<span>Reader</span>
}</pre></div>
<p dir="auto">and attach a function (method) to it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="func (c *counter) Lines() (map[string]int, error) {
	counts := make(map[string]int)
	input := bufio.NewScanner(c.input)
	for input.Scan() {
		counts[input.Text()]++
	}
	return counts, input.Err()
}"><pre><span>func</span> (<span>c</span> <span>*</span><span>counter</span>) <span>Lines</span>() (<span>map</span>[<span>string</span>]<span>int</span>, <span>error</span>) {
	<span>counts</span> <span>:=</span> <span>make</span>(<span>map</span>[<span>string</span>]<span>int</span>)
	<span>input</span> <span>:=</span> <span>bufio</span>.<span>NewScanner</span>(<span>c</span>.<span>input</span>)
	<span>for</span> <span>input</span>.<span>Scan</span>() {
		<span>counts</span>[<span>input</span>.<span>Text</span>()]<span>++</span>
	}
	<span>return</span> <span>counts</span>, <span>input</span>.<span>Err</span>()
}</pre></div>
<p dir="auto">The Lines function counts duplicate lines by scanning the input line by line and keeping the count for each identical line in a map (of strings to integers).</p>

<p dir="auto">Here&#39;s another pattern for having both a default value and being able to change it if needed. It&#39;s based on a function type - yeah, in Go we can define a custom type that is a function.</p>
<p dir="auto">The <code>option</code> type below is a function with specific signature. And we define the <code>NewCounter</code> function to use the <code>option</code> type for its parameters. There can be zero or more of such parameters. This is called a variadic parameter and it&#39;s denoted by the <code>...</code> syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// count/1/count.go
type option func(*counter) error

func NewCounter(opts ...option) *counter {
	c := &amp;counter{input: os.Stdin}
	for _, opt := range opts {
		opt(c) // NOTE: we ignore the error for now
	}
	return c
}"><pre><span>// count/1/count.go</span>
<span>type</span> <span>option</span> <span>func</span>(<span>*</span><span>counter</span>) <span>error</span>

<span>func</span> <span>NewCounter</span>(<span>opts</span> <span>...</span><span>option</span>) <span>*</span><span>counter</span> {
	<span>c</span> <span>:=</span> <span>&amp;</span><span>counter</span>{<span>input</span>: <span>os</span>.<span>Stdin</span>}
	<span>for</span> <span>_</span>, <span>opt</span> <span>:=</span> <span>range</span> <span>opts</span> {
		<span>opt</span>(<span>c</span>) <span>// NOTE: we ignore the error for now</span>
	}
	<span>return</span> <span>c</span>
}</pre></div>
<p dir="auto">Now, let&#39;s define a function that returns an <code>option</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// count/1/count.go
func WithInput(input io.Reader) option {
	return func(c *counter) error {
		if input == nil {
			return errors.New(&#34;nil input reader&#34;)
		}
		c.input = input
		return nil
	}
}"><pre><span>// count/1/count.go</span>
<span>func</span> <span>WithInput</span>(<span>input</span> io.<span>Reader</span>) <span>option</span> {
	<span>return</span> <span>func</span>(<span>c</span> <span>*</span><span>counter</span>) <span>error</span> {
		<span>if</span> <span>input</span> <span>==</span> <span>nil</span> {
			<span>return</span> <span>errors</span>.<span>New</span>(<span>&#34;nil input reader&#34;</span>)
		}
		<span>c</span>.<span>input</span> <span>=</span> <span>input</span>
		<span>return</span> <span>nil</span>
	}
}</pre></div>

<p dir="auto">This <code>WithInput</code> function can be then used like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// count/1/cmd/count/main.go
// ...
if len(os.Args) &gt; 1 {
	// Input from file.
	file, err := os.Open(os.Args[1])
	// ...

	c := count.NewCounter(count.WithInput(file))
	counts, err = c.Lines()
} else {
	// Input from stdin.
	c := count.NewCounter()
	counts, err = c.Lines()
}
// ..."><pre><span>// count/1/cmd/count/main.go</span>
<span>// ...</span>
<span>if</span> <span>len</span>(<span>os</span>.<span>Args</span>) <span>&gt;</span> <span>1</span> {
	<span>// Input from file.</span>
	<span>file</span>, <span>err</span> <span>:=</span> <span>os</span>.<span>Open</span>(<span>os</span>.<span>Args</span>[<span>1</span>])
	<span>// ...</span>

	<span>c</span> <span>:=</span> <span>count</span>.<span>NewCounter</span>(<span>count</span>.<span>WithInput</span>(<span>file</span>))
	<span>counts</span>, <span>err</span> <span>=</span> <span>c</span>.<span>Lines</span>()
} <span>else</span> {
	<span>// Input from stdin.</span>
	<span>c</span> <span>:=</span> <span>count</span>.<span>NewCounter</span>()
	<span>counts</span>, <span>err</span> <span>=</span> <span>c</span>.<span>Lines</span>()
}
<span>// ...</span></pre></div>
<p dir="auto">To find out what&#39;s <code>os.Args</code> we consult the documentation, for example like this:</p>
<div data-snippet-clipboard-copy-content="$ go doc os.Args
package os // import &#34;os&#34;

var Args []string
    Args hold the command-line arguments, starting with the program name."><pre><code>$ go doc os.Args
package os // import &#34;os&#34;

var Args []string
    Args hold the command-line arguments, starting with the program name.
</code></pre></div>
<p dir="auto">But if look at the <code>main</code> fuction in <code>count/1/cmd/count/main.go</code> the part handling the CLI arguments is a bit ugly. Let&#39;s hide it (abstract way) inside another function returning an <code>option</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// count/2/count.go
func WithInputFromArgs(args []string) option {
	return func(c *counter) error {
		if len(args) &lt; 1 {
			return nil
		}
		f, err := os.Open(args[0])
		if err != nil {
			return err
		}
		c.input = f
		// NOTE: We are not closing the f and we take only the first
		// argument. See count/3/count.go for how to fix both these
		// shortcomings.
		return nil
	}
}"><pre><span>// count/2/count.go</span>
<span>func</span> <span>WithInputFromArgs</span>(<span>args</span> []<span>string</span>) <span>option</span> {
	<span>return</span> <span>func</span>(<span>c</span> <span>*</span><span>counter</span>) <span>error</span> {
		<span>if</span> <span>len</span>(<span>args</span>) <span>&lt;</span> <span>1</span> {
			<span>return</span> <span>nil</span>
		}
		<span>f</span>, <span>err</span> <span>:=</span> <span>os</span>.<span>Open</span>(<span>args</span>[<span>0</span>])
		<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
			<span>return</span> <span>err</span>
		}
		<span>c</span>.<span>input</span> <span>=</span> <span>f</span>
		<span>// NOTE: We are not closing the f and we take only the first</span>
		<span>// argument. See count/3/count.go for how to fix both these</span>
		<span>// shortcomings.</span>
		<span>return</span> <span>nil</span>
	}
}</pre></div>
<p dir="auto">Now the main function gets easier on the eyes:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// count/2/cmd/count/main.go
func main() {
	c, err := count.NewCounter(count.WithInputFromArgs(os.Args[1:]))
	if err != nil {
		log.Fatal(err)
	}
	counts, err := c.Lines()
	if err != nil {
		log.Fatal(err)
	}
	for line, n := range counts {
		fmt.Printf(&#34;%d\t%s\n&#34;, n, line)
	}
}"><pre><span>// count/2/cmd/count/main.go</span>
<span>func</span> <span>main</span>() {
	<span>c</span>, <span>err</span> <span>:=</span> <span>count</span>.<span>NewCounter</span>(<span>count</span>.<span>WithInputFromArgs</span>(<span>os</span>.<span>Args</span>[<span>1</span>:]))
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatal</span>(<span>err</span>)
	}
	<span>counts</span>, <span>err</span> <span>:=</span> <span>c</span>.<span>Lines</span>()
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatal</span>(<span>err</span>)
	}
	<span>for</span> <span>line</span>, <span>n</span> <span>:=</span> <span>range</span> <span>counts</span> {
		<span>fmt</span>.<span>Printf</span>(<span>&#34;%d<span>\t</span>%s<span>\n</span>&#34;</span>, <span>n</span>, <span>line</span>)
	}
}</pre></div>

<p dir="auto">We saw how to handle the command line arguments. What about flags (also called options)?</p>
<p dir="auto">This is the job of the <code>flag</code> standard library package that allows us to define usage message and one or more flags:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// count/3/cmd/count/main.go
const usage = `Counts words (or lines) from stdin (or files).

Usage: count [-lines] [file...]`

func main() {
	flag.Usage = func() {
		fmt.Println(usage)
		flag.PrintDefaults()
	}
	lines := flag.Bool(&#34;lines&#34;, false, &#34;count lines, not words&#34;)
	flag.Parse()
// ..."><pre><span>// count/3/cmd/count/main.go</span>
<span>const</span> <span>usage</span> <span>=</span> <span>`Counts words (or lines) from stdin (or files).</span>
<span></span>
<span>Usage: count [-lines] [file...]`</span>

<span>func</span> <span>main</span>() {
	<span>flag</span>.<span>Usage</span> <span>=</span> <span>func</span>() {
		<span>fmt</span>.<span>Println</span>(<span>usage</span>)
		<span>flag</span>.<span>PrintDefaults</span>()
	}
	<span>lines</span> <span>:=</span> <span>flag</span>.<span>Bool</span>(<span>&#34;lines&#34;</span>, <span>false</span>, <span>&#34;count lines, not words&#34;</span>)
	<span>flag</span>.<span>Parse</span>()
<span>// ...</span></pre></div>
<p dir="auto">In the code above we defined the tool&#39;s documentation and a boolean flag. It looks like this from the user&#39;s perspective:</p>
<div data-snippet-clipboard-copy-content="$ go run ./cmd/count -h
Counts words (or lines) from stdin (or files).

Usage: count [-lines] [file...]
  -lines
        count lines, not words"><pre><code>$ go run ./cmd/count -h
Counts words (or lines) from stdin (or files).

Usage: count [-lines] [file...]
  -lines
        count lines, not words
</code></pre></div>
<p dir="auto">Nice and simple. We give it a try:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ go run ./cmd/count -lines /etc/hosts /etc/networks | sort -n"><pre>$ go run ./cmd/count -lines /etc/hosts /etc/networks <span>|</span> sort -n</pre></div>
</article></div></div>
  </body>
</html>
