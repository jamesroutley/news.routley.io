<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://airbyte.com/blog/eltp-extending-elt-for-modern-ai-and-analytics">Original</a>
    <h1>ELTP: Extending ELT for Modern AI and Analytics</h1>
    
    <div id="readability-page-1" class="page"><div id="blog-content" fs-richtext-element="rich-text" fs-toc-element="contents-3" fs-toc-offsettop="6rem" fs-codehighlight-element="code" fs-codehighlight-theme="base16/harmonic16-dark"><p>Whether building data pipelines for AI, analytics, or data engineering, there are two very common design mistakes that almost everyone makes at least once. </p><p>The first common mistake comes from designing everything as a single “ETL” operation, running Extract, Transform, and Load as a single combined step. The second common mistake is to assume that the best place for processing data is also the best place to host it, omitting the important ‘publish’ step.</p><p>To address these challenges, I introduce the “ELTP” architecture: Extract, Load, Transform, and Publish. This simple and scalable model is crafted to prevent these common mistakes. Below, we&#39;ll delve into the nuances of ELTP and explore its broad applicability for AI, analytics, and big data.</p><h2>From ETL to ELT to ELTP - A brief Introduction</h2><p>In order to understand the benefits of the ELTP architecture, it’s important to first understand some basic context around ETL and ELT.</p><p>The original “ETL” approach to data movement combined business logic and data replication into a single operation. This was inherently fragile, because ETL processes would break whenever business logic changed, and any breakage would prevent source data from loading at all. Since many of the transforms required aggregating and joining across datasets, memory errors were frequent and new failure types could arise at any time, as data volumes grew.</p><p>To address these issues and others, modern data engineering best practices now advocate for an “ELT” or “EL+T” approach, where the replication (Extract and Load) is performed first, as a standalone process. Then, business logic and transformations are applied only after the raw data is safely landed in a database or data lake which we control. In this model, the Extract-Load Pair, or “EL Pair”, are executed as a single step in the process, with composable Extract and Load connectors working together to replicate data efficiently from source to destination.</p><p>While ELT architecture is more stable and more scalable than the ETL model, ELT is still lacking, in that it doesn’t specify a method for delivering data to downstream users and systems - what is sometimes called “Reverse ETL”. To address this gap, we introduce the &#39;Publish&#39; step, leading to the “EL+T+P” or “ELTP” model. In full, the ELTP model encompasses the following steps: </p><ul role="list"><li><strong>E</strong>xtract data from raw data sources.</li><li><strong>L</strong>oad data into durable storage, such as a data warehouse or data lake.</li><li><strong>T</strong>ransform raw data into new datasets.</li><li><strong>P</strong>ublish data to downstream users and business applications.</li></ul><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/65496746615990d5889f8af8_OmBI8dizfMLXEEFjbAD94MhFdbdvKOE2oM9NBIJIwp3w6rhEtB7lpxORQL7o8Y0NhjYY8gSjxldWy-auygCvP0Gxa2NtxjOMIKpTLJq5qHDQAzYzJ6jH1oZQ2WkNpjc38hSmYPtwP9gDhIMPyqiAkHA.png" alt=""/></p></figure><p>This design preserves the benefits of ELT while also giving a framework for ensuring that data is efficiently published to downstream consumers and applications.</p><h2>Meet the “Publish” Step</h2><p>The Publish framing is a simple way to describe how transformed data can be delivered to a variety of downstream destinations, including: external SaaS applications, file stores, CRM systems, AI vector stores, and even other databases. Publish steps implement the same protocols and paradigms of other Extract-Load pairs used for raw data collection, and therefore can benefit from the same advantages discussed above for EL pairs. </p><p>The biggest difference between the initial Extract-Load and the final Publish is that in the latter case, the EL process is extracting from our data platform and loading to an external system or external publish location.</p><p>Note that in this two-stage EL architecture, we can add any number of custom transformations between the initial EL step that loads the raw data and the second EL step that publishes transformed data to downstream applications.</p><h3>Why Publish?</h3><p>There are several reasons for adding a Publish step to one’s data architecture, namely: sending data files to external systems, decentralizing analytic queries, and publishing to downstream applications and indexes.</p><h4>Publish Data Files to External Systems</h4><p>The oldest example of a “publish” operation is to send data files to partner companies, vendors, or regulatory agencies. For example, a Marketing Agency might request a regular upload of your customer data file, which they in turn would process and provide back a new file with added market segmentation data. These publish operations often have externally-defined file formats and upload location requirements which are controlled by the third party. </p><p>Here is a simple example, where we publish one file to a partner via S3 and another file to a vendor using SFTP:</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/65496746a76744f8518a062d_wcxK76MrRMlgGQmB8zbRcnxaervrFHfqrF56Jq0_-Y1B5vCtBrGBTnsjQO001FDuCluok-cLl4Qrw16k-YvMm-0olP9wJqD2ovNv6kptY6i2Rekjgd01V0-5c5yEQt2s4qtRC3USUyzlYCVYC7kKIXE.png" alt=""/></p></figure><h4>Publish to Empower Analytics</h4><p>While I was at Amazon Video, I built and maintained systems that processed terabytes of data daily. To achieve that kind of scale, my team developed ELT pipelines on AWS Redshift, carefully right-sizing our clusters to efficiently execute all our transformations.</p><p>But when it came time to consume the data, we ran into problems. Our system couldn’t handle heavy query traffic, and one runaway query could cause significant performance issues for every other user. Our clusters optimized for heavy-duty processing tasks weren’t necessarily equipped for ad-hoc analysis or concurrency. </p><p>The solution was to add a final “publish” operation, where we could deliver data to our users exactly how and where they needed it. We wouldn’t bar users from querying the main cluster, but downstream consumers were incentivized to use Tableau and S3 datasets because those provide better performance and the ability for consumers to right-size their own analytics infrastructure according to their specific requirements. Meanwhile, the central database was better insulated from runaway queries that might otherwise lead to costly outages.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/65496746523b21ec47301f60_FC9VubEOls7hIgdkOjjZ2v7IMBOwiX-_sZFWHKs6sBLcfADbsgldpvIca_PIHQxC8SB8mWx7Ggdv1Nj9uzpvo9dr7kcCLM-8QUK0P0YmtlLLOIg1_-U5Qcu7AI1mHCDE4wclkh3t09UEYDab3QoZUvI.png" alt=""/></p></figure><h4>Publish to SaaS Applications </h4><p>A popular use case for Publish operations are the so-called “Reverse ETL” use cases, where transformed data is Published to one or more business applications or SaaS providers. Popular examples include Publishing data to Salesforce for business operations, Hubspot to keep customer CRM data up-to-date, and Active Directory to keep employee and organizational data up-to-date.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/65496746190907192380d2db_be2mc0dSNxGPGdbJIlXFpoFMY00vvip8tDq3EJFwohei2N7TaRugWhwz19h87c5jZiWY7Xl_V3_6Qeg5SSrVcsMQmS3atbyUTZmrcaKAPOstMrApUljnwyd_krLjZhjkIdOasi6cxFeAClws8xAZ444.png" alt=""/></p></figure><h4>Publish to Vector Stores as AI Long-Term Memory (RAG)</h4><p>A common method of building AI chatbots is to Publish text data to a specialized indexing system called a “vector store”, which can in turn be used by the chatbot in a process called “RAG” (or “retrieval-augmented generation”). With RAG, the chatbot dynamically retrieves relevant information from a vector store as if retrieving from its long-term “memory”. It uses this information to generate responses that are informed by the data it has retrieved, combining pre-existing knowledge with the context provided by the user&#39;s query.</p><p>To run this process using ELTP, we follow the same basic steps as before:</p><p>1. <strong>Extract</strong> text from our raw document sources,</p><p>2. <strong>Load</strong> the raw text data to long-term storage,</p><p>3. <strong>Transform</strong> the data by splitting large text into smaller chunks and calculating a numeric representation of each chunk (often called a “vector” or “embedding”)</p><p>4. <strong>Publish</strong> the text data to our vector store indexes, where the chatbot can then make use of this data when answering questions it wouldn’t otherwise be able to answer.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/654967463a3e2835a6014bc5_1XSJ-4FT5RY7hOxYXN7IdSyRfQwzh8cDJIoSsxFMts7ZKcKul7rcOOPS5Z-ukCDI7u7TEqN4adr0EbhcUGL0UbaOcfk-61TwZwe7Y9X61db-EQmV3MiSxy_r7wSPEAZ4leI6wqS7r4uerRO_SA0Tmvo.png" alt=""/></p></figure><h2>ELTP in Practice</h2><p>The ELTP framing offers a practical and holistic model for what otherwise might be expressed as “ELT + Reverse ETL” - while addressing additional use cases that traditionally would not be in scope for Reverse ETL. Here we’ll discuss a few advanced use cases and real world design and deployment considerations.</p><h3>Publish Destinations are more than Reverse ETL</h3><p>All Reverse ETL destinations are Publish-type destinations, but not all Publish destinations are Reverse ETL. The term “Reverse ETL” can still be useful when communicating the unique challenges of publishing to a SaaS system like Salesforce and Hubspot, but the term falls down when describing a publish flow to a partner’s SFTP site or to an external database. Whether publishing to Salesforce, SFTP, S3, or SharePoint, the Publish framing offers a more robust and holistic architectural model that is not tied to the “pickiness” of API-type destinations.</p><h3>Plan for ELTP, but Don’t Fear ETL</h3><p>Sometimes all that’s needed is a good proof of concept. For example, in AI and LLM applications, tutorials will often walk users through this now-classic data processing flow for RAG applications: <strong>Extract</strong> text from documents like PDFs or web sites, <strong>Transform</strong> into embedded document chunks, and directly <strong>Load</strong> to the vector store. Tutorials covering this approach can be found <a href="https://airbyte.com/tutorials/airbyte-and-llamaindex-elt-and-chat-with-your-data-warehouse-without-writing-sql">here</a> and <a href="https://airbyte.com/tutorials/chat-with-your-data-using-openai-pinecone-airbyte-and-langchain">here</a>, for instance. </p><p>As a tutorial or a proof of concept (POC) data flow, there’s nothing wrong with this ETL-like flow:</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/65496746d9dc177957eae582_j_ejRwlSPd8tEoOQYfzJ6QFExaFCl83VjPn8nbnSbGU3hJ8Bi9P0t-nkg1nWPDcT6eUh63IclWli4GSLaxSQMfACiZhrLRl00DZzfe1gZwvQcaKtgKIcy9hEAdU41n6pKE7bO4xnq-z8I63QQHTu1hw.png" alt=""/></p></figure><p>As shown in the diagram above, the decision to skip the database Load is very convenient and improves accessibility. The author has less surface area to maintain and doesn’t need to worry about introducing durable long-term storage into the architecture. This reduces the likelihood that someone following along will be blocked by not having access to the same or similar options for the long-term storage layer.</p><p>However, if and when our POC is successful, we will very soon want to migrate to the ELTP architecture, loading our raw data into long-term storage and then publishing to the vector store as a separate step. Here is a diagram of the same solution using ELTP:</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/6549674647456de29c33e8d0_dUpU5UVVU_3SdwaugOhbViQDDoV13U435CRpD0ILmLFzsn6JWoHt28bUdn-uMoB0ie-ERmjGBTu7hsIup_BBtURYv-dTFrx5rFQOvffcVDtfHwrB0Y-oFRdH--kEVxJ9Ui5KzVqPp8gCMKg3kcrpFDc.png" alt=""/></p></figure><p>‍</p><p>Adding a database for long-term storage decouples the Extract/Load step from the Publish operation, and gives us the ability to add any number of transformations in between the initial EL operation and the Publish operation - for instance dbt models or custom Python scripts to clean the data and to apply business logic.</p><p>Our speed of iteration is also greatly improved with this design. When we are ready to experiment with different embedding models and tune the chunking parameters, we already have the raw text extracted and ready to go. We can even run side-by-side experiments comparing different transformation and publication options, without re-extracting the raw data and without making any changes to the “production” data flow.</p><p>The ELTP model allows us to scale more effectively as well: from tens of documents to thousands or even millions of documents. Each step in the process can run on hardware specialized for that step, and all of the replication steps (EL and Publish) can operate incrementally: extracting only new or updated documents when sending data downstream. As business logic evolves and as bugs are identified, we can rerun or restate our transformations without needing to re-extract the text from the upstream data source.</p><p>The upshot of all these ELTP benefits is that ELTP allows more opportunities for iteration, while also providing scaling and performance benefits. While perhaps counter-intuitive, adding the durable storage layer actually <em>reduces</em> our total cost of ownership (TCO) versus running the ETL or “POC” model which performs Extract-Transform-Load all in one step.</p><h3>ELTP for AI Use Cases</h3><p>With the rapid growth in AI applications, many people now find themselves entering the world of data engineering for the first time, specifically for the purpose of building an AI application. The ELTP model provides these new data practitioners an opportunity to learn from data engineering mistakes of the past, while not having to reinvent the wheel.</p><h4>Vector Store Publish Destinations</h4><p>Airbyte is an open source data movement tool which can be used for both “EL” and “Publish” steps in the ELTP architecture. Airbyte currently supports several vector store destinations, including Pinecone, Milvus, Chroma, and Weaviate. These can be used to directly load data using an ETL or ELTP architecture - according to your own preferences and requirements. All of these vector store destinations provide access to inline text splitting and vector embeddings using a declarative, configuration-based approach.</p><h4>Text Document Source Connectors (New!)</h4><p>Whereas traditional data pipelines prioritized numeric and tabular data, AI and LLM data flows greatly benefit from text data in “unstructured” document formats like PDF, Word, Markdown, and Google Docs. </p><p>This week, Airbyte is also launching source connectors to extract “text-as-data” from those unstructured documents and others. Text documents are a powerful new class of data source for data pipelines, and the new text document connectors enable the same ELTP, ELT, and ETL architectures across <em>all</em> of your data, whether for AI or for analytics.</p><p>For more information, please see the companion blog post <a href="https://airbyte.com/blog/airbyte-now-supports-extracting-text-from-documents">announcement</a>.</p><h2>Simplifying ELTP Best Practices with Open Source</h2><p>Modern data movement tools such as <a href="http://www.airbyte.io">Airbyte</a> allow you to implement robust ELTP data pipelines easily and quickly. Airbyte offers a low-code UI, an <a href="https://docs.airbyte.com/api-documentation">API</a> and a <a href="https://airbyte.com/blog/terraform-provider-launched-for-airbyte-cloud">Terraform provider</a> for those who prefer to build pipelines programmatically. Airbyte being an open source tool carries the additional benefit of letting users build and modify connectors if the source or destination they want to reach is not yet officially supported.</p><p>With the ability to create your own open source connectors when needed, the same tooling and design techniques can be applied to almost any imaginable data pipeline</p><p>Airbyte aims to provide data teams with an open-source standard in data movement. We’re currently investing heavily in Publish connectors for AI and LLM use cases. In 2024, we will expand to cover additional Reverse ETL and ELTP workflows and use cases, to simplify and commoditize data movement in any direction.</p><h2>In Closing</h2><p>While the ELT model is a great improvement over ETL, it doesn’t solve for the last mile of data delivery. ELTP is a model that handles the heavy lifting while also providing a real solution for product delivery.</p><p>Whether you are building the next great AI application or a more traditional data analytics stack, you can set yourself up for success by understanding the ELTP model and designing your architecture with these best practices in mind.</p><p>Interested in more data content? Join us for the <a href="https://airbyte.com/session/airbyte-monthly-ai-demo">upcoming ELTP webinar for AI</a> or check out <a href="https://airbyte.com/blog">our blog</a>, where we publish articles in-house and from the community on data engineering, databases, AI infrastructure and more.</p></div></div>
  </body>
</html>
