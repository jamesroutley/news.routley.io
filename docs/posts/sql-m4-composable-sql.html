<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emiruz.com/post/2022-12-28-composable-sql/">Original</a>
    <h1>SQL &#43; M4 = Composable SQL</h1>
    
    <div id="readability-page-1" class="page"><div>
      


<div id="introduction">

<p>I often work with client who have large “data lakes” or big star schema style
enterprise databases with fact and dimension tables as far as the eye can see.
Invariably said clients end up with a substantial SQL codebase composed of hundreds
of independent queries with lots of overlap between them. I want to be able to
treat SQL repositories like I’d treat other codebases. That is, I’d like to
create libraries, share code, test blocks independently, and so on. The
trouble is that aside from views, table valued functions and a couple of other
bits, SQL is mostly not composable.</p>
<p>I found <a href="https://logica.dev">Logica</a>: datalog + aggregation which compiles
to SQL. It is composable and readable, but BigQuery specific – and having
spent a weekend with it – still beta software. Besides Logica, there seemed to
be nothing else out there so I started to think about the shortest path to
writing something useful to me on my own. I reasoned about it but writing down
a gnarly query and then writing down a version of it in an idealised SQL dialect
which allows me to abstract all the common parts away into a shared library.</p>
<p>Below is a cut down version of a gnarly SQL query. For full effect imagine the
following additional complications:</p>
<ul>
<li>Individually complicated CTEs.</li>
<li>Complex where clause.</li>
<li>Messy “case when” statements.</li>
<li>Window functions.</li>
<li>etc.</li>
</ul>
<pre><code>with 

tender as (
  select day, store, till, transaction, tender_type, amount
  from tender_table),

item_desc as (
  select item_id, item_category
  from item_desc_table),

sales as (
  select day, store, till, transaction, cashier, total,
  from sales_table),

sales_items as (
  select day, store, till, transaction, line_number,
         s.item_id, price, discount, is_return
  from sales_items_table s)

select  
  s.day,
  d.item_category,
  count(distinct 
    s.store, 
    s.till,
    s.transaction) as transactions,
  sum(case when t.tender_type = &#39;CARD&#39;
        then s.total
        else 0 end) as card_total,
  sum (s.total) as total
from sales s
join sales_items i on (
  s.day = i.day AND
  s.store = i.store AND
  s.till = i.till AND
  s.transaction = i.transaction)
join tender t on (
  s.day = t.day AND
  s.store = t.store AND
  s.till = t.till AND
  s.transaction = t.transaction)
join item_desc d on (d.item_id = i.item_id))
group by 1,2</code></pre>
<p>I’d like to abstract away all the code in the above query which frequently
repeats in the codebase into a shared library and then refer to it. Ideally it
would look like this:</p>
<pre><code>with 

T as ($tender_query),
I as ($item_desc_query),
S as ($sales_query),
L as ($sales_item_query)

select  
  S.day,
  I.item_category,
  count(distinct $trans_fields(S)) as transactions,
  $sum_if(T.tender_type=&#39;CARD&#39;, S.amount) as card_total,
  sum(s.total) as total
from S
$join_on_trans(inner, S, L)
$join_on_trans(inner, S, T)
join I on (L.item_id = I.item_id))
group by 1,2</code></pre>
<p>The list below describes the new elements added and their intended purpose:</p>
<ul>
<li><p>$tender_query, $item_desc_query, $sales_query, $sales_item_query – These are
simple literals which replace their occurrence with an underlying SELECT query.
they could also be parameterised to customise their underlying query.</p></li>
<li><p>$trans_fields(…) – Returns the list of transaction fields. In my real queries
these are often included in the output or as part of DISTINCT queries.</p></li>
<li><p>$sum_if(…) – Avoid having to write CASE WHEN ELSE END statements. These can
be numerous.</p></li>
<li><p>$join_on_trans(…) – Express a whole join based on the join type and
transactional keys. Join clauses in the codebases I work in can often be large
and involved.</p></li>
</ul>
</div>
<div id="enter-the-m4-macro-pre-processor">

<p>The idealised query above made me realise that I could get there using just a
generic macro pre-processor such as <a href="https://en.wikipedia.org/wiki/M4_(computer_language)">M4</a>.
If you’re unfamiliar with M4 it is a text pre-processor. You define (potentially
parameterised) macros which describes how their occurrences should be replaced
by text. So instead of having a set of SQL files in source control, you’d have a
set of .m4 files – some of which are shared libraries – which are run to
generate the SQL output. Below is how the common definitions for the query above
could be implemented with M4. <a href="https://mbreen.com/m4.html">Michael Breen’s notes on M4</a>
was very useful for getting to grips with M4’s idiosyncrasies quickly.</p>
<p><strong>common.m4</strong>:</p>
<pre><code>divert(-1)

changequote(&#34;|,|&#34;)

define(
&#34;|M_tender_query|&#34;,
&#34;|select day, store, till, transaction, tender_type, amount
from tender_table|&#34;)

define(
&#34;|M_item_desc_query|&#34;,
&#34;|select item_id, item_category from item_desc_table|&#34;)

define(
&#34;|M_sales_query|&#34;,
&#34;|select day, store, till, transaction, cashier, total,
from sales_table|&#34;)

define(&#34;|M_sales_item_query|&#34;,
&#34;|select day, store, till, transaction, line_number,
       s.item_id, price, discount, is_return
from sales_items_table s|&#34;)

define(
&#34;|M_trans_fields|&#34;,
&#34;|$1.day,$1.store,$1.till,$1.transaction|&#34;)

define(
&#34;|M_sum_if|&#34;,
&#34;|case when $1 then $2 else 0 end|&#34;)

define(
&#34;|M_join_on_trans|&#34;,
&#34;|$1 join on ($2.day = $3.day and
$2.store = $3.store and
$2.till = $3.till and
$2.transaction = $3.transaction)|&#34;)

divert(0)dnl</code></pre>
<p>Note that M4 doesn’t support non-ASCII characters in definitions so my ideal
macros had to lose their $ prefixes. E.g. $sum_if had to become M_sum_if (could
have also been just sum_if). The default escape characters are ` and ’ which
conflict with SQL so I re-defined these to “| and |”. Definitions cause newlines
to be emitted so everything is wrapped in the <em>divert</em> statements to prevent
excessive white space.</p>
<p>With the common parts abstracted away, the marginal query becomes as follows:</p>
<pre><code>include(common.m4)

with 

T as (M_tender_query),
I as (M_item_desc_query),
S as (M_sales_query),
L as (M_sales_item_query)

select  
  S.day,
  I.item_category,
  count(distinct M_trans_fields(S)) as transactions,
  M_sum_if(T.tender_type=&#39;CARD&#39;, S.amount) as card_total,
  sum(s.total) as total
from S
M_join_on_trans(inner, S, L)
M_join_on_trans(inner, S, T)
join I on (L.item_id = I.item_id))
group by 1,2</code></pre>
<p>This is very close to what I had hoped for.</p>
</div>
<div id="some-conclusions">

<p>Here are the main benefits I see with this approach:</p>
<ul>
<li><p>The establishment of domain knowledge about how to query the data. Macro
libraries can be separated into functional areas and separately documented.</p></li>
<li><p>Shorter and more understandable queries via a SQL-like domain specific language.</p></li>
<li><p>Individually testable macros. All the additions above could be tested and
verified independently.</p></li>
</ul>
<p>M4 is a rich macro definition language which also supports features like
parameterising .m4 files, loops and recursive/conditional queries, so this rabbit
hole goes fairly deep. However, this is not a typed extension to SQL and the
scope for misuse is extensive. Example 1, the macros are not context
sensitive, they can be used anywhere and the user has to pay attention. Example
2, you can’t fix the number of types of parameters, so users could easily provide
the wrong input or not provide an input at all. However, I think where used with
appropriate restraint, a macro pre-processor has the potential to drastically
change both the workflow and maintainability of SQL codebases.</p>
</div>

    </div></div>
  </body>
</html>
