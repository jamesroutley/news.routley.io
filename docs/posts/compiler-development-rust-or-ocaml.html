<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hirrolot.github.io/posts/compiler-development-rust-or-ocaml.html">Original</a>
    <h1>Compiler Development: Rust or OCaml?</h1>
    
    <div id="readability-page-1" class="page"><p>The question of which language suits best for compiler development is
a frequent one amongst language enthusiasts (e.g., see discussions <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/k3zgjy/which_language_to_write_a_compiler_in/">here</a>,
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/13eztdp/good_languages_for_writing_compilers_in/">here</a>,
and <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/15gz8rb/how_good_is_go_for_writing_a_compiler/">here</a>).
Sadly, most of the commenters either 1) just answer with their language
of choice without any explanation, or 2) provide a vague explanation
without any specific examples to prove their point of view. Both types
of answers serve little to no purpose for the person asking the
question. In this essay, I will try to provide a more detailed
perspective on the topic by comparing two languages: Rust and OCaml.</p><div><a href="#cps-conversion"><h2 id="cps-conversion">CPS conversion</h2></a><p>Before presenting my actual argument, I will show two analogous
implementations of <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a>
conversion <a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> for a very simple language, without
making any conclusions. The general approach is borrowed from <a href="https://www.amazon.com/Compiling-Continuations-Andrew-W-Appel/dp/052103311X">“Compiling
with Continuations”</a> by Andrew W. Appel. No worries if you are not
familiar with the idea; the only thing to focus your attention on is
<em>how</em> the idea is implemented in both Rust and OCaml.</p><p>Here is CPS conversion written in Rust:</p><div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a><span>use</span> <span>std::cell::</span>RefCell<span>;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span>use</span> <span>std::ops::</span><span>Deref</span><span>;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span>use</span> <span>std::rc::</span>Rc<span>;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span>// A variable identifier of the lambda language `Term`.</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span>type</span> Var <span>=</span> <span>String</span><span>;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span>// The lambda language; direct style.</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span>type</span> Term <span>=</span> Rc<span>&lt;</span>TermTree<span>&gt;;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span>enum</span> TermTree <span>{</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    Var(Var)<span>,</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    Fix(<span>Vec</span><span>&lt;</span>(Var<span>,</span> <span>Vec</span><span>&lt;</span>Var<span>&gt;,</span> Term)<span>&gt;,</span> Term)<span>,</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>    Appl(Term<span>,</span> <span>Vec</span><span>&lt;</span>Term<span>&gt;</span>)<span>,</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    Record(<span>Vec</span><span>&lt;</span>Term<span>&gt;</span>)<span>,</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    Select(Term<span>,</span> <span>u32</span>)<span>,</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span>}</span></span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span>use</span> <span>TermTree::</span><span>*;</span></span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span>#[</span>derive<span>(</span><span>Clone</span><span>)]</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span>enum</span> CpsVar <span>{</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span>// Taken from the lambda term during CPS conversion.</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>    CLamVar(Var)<span>,</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span>// Generated uniquely during CPS conversion.</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>    CGenVar(<span>u32</span>)<span>,</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span>}</span></span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a><span>use</span> <span>CpsVar::</span><span>*;</span></span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a><span>// The resulting CPS term.</span></span>
<span id="cb1-32"><a href="#cb1-32"></a><span>enum</span> CpsTerm <span>{</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>    CFix(<span>Vec</span><span>&lt;</span>(CpsVar<span>,</span> <span>Vec</span><span>&lt;</span>CpsVar<span>&gt;,</span> CpsTerm)<span>&gt;,</span> <span>Box</span><span>&lt;</span>CpsTerm<span>&gt;</span>)<span>,</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>    CAppl(CpsVar<span>,</span> <span>Vec</span><span>&lt;</span>CpsVar<span>&gt;</span>)<span>,</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    CRecord(<span>Vec</span><span>&lt;</span>CpsVar<span>&gt;,</span> Binder)<span>,</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    CSelect(CpsVar<span>,</span> <span>u32</span><span>,</span> Binder)<span>,</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    CHalt(CpsVar)<span>,</span></span>
<span id="cb1-38"><a href="#cb1-38"></a><span>}</span></span>
<span id="cb1-39"><a href="#cb1-39"></a></span>
<span id="cb1-40"><a href="#cb1-40"></a><span>use</span> <span>CpsTerm::</span><span>*;</span></span>
<span id="cb1-41"><a href="#cb1-41"></a></span>
<span id="cb1-42"><a href="#cb1-42"></a><span>// Binds a unique `CpsVar` within `CpsTerm`.</span></span>
<span id="cb1-43"><a href="#cb1-43"></a><span>type</span> Binder <span>=</span> (CpsVar<span>,</span> <span>Box</span><span>&lt;</span>CpsTerm<span>&gt;</span>)<span>;</span></span>
<span id="cb1-44"><a href="#cb1-44"></a></span>
<span id="cb1-45"><a href="#cb1-45"></a><span>// Generates a unique CPS variable given the current `i`.</span></span>
<span id="cb1-46"><a href="#cb1-46"></a><span>fn</span> gensym(i<span>:</span> RefCell<span>&lt;</span><span>u32</span><span>&gt;</span>) <span>-&gt;</span> CpsVar <span>{</span></span>
<span id="cb1-47"><a href="#cb1-47"></a>    <span>let</span> x <span>=</span> CGenVar(i<span>.</span>clone()<span>.</span>into_inner())<span>;</span></span>
<span id="cb1-48"><a href="#cb1-48"></a>    i<span>.</span>replace_with(<span>|&amp;</span><span>mut</span> i<span>|</span> i <span>+</span> <span>1</span>)<span>;</span></span>
<span id="cb1-49"><a href="#cb1-49"></a>    x</span>
<span id="cb1-50"><a href="#cb1-50"></a><span>}</span></span>
<span id="cb1-51"><a href="#cb1-51"></a></span>
<span id="cb1-52"><a href="#cb1-52"></a><span>// Converts `Term` to `CpsTerm`, applying `finish` to the resulting</span></span>
<span id="cb1-53"><a href="#cb1-53"></a><span>// CPS variable.</span></span>
<span id="cb1-54"><a href="#cb1-54"></a><span>fn</span> convert(gen<span>:</span> RefCell<span>&lt;</span><span>u32</span><span>&gt;,</span> finish<span>:</span> <span>impl</span> <span>FnOnce</span>(CpsVar) <span>-&gt;</span> CpsTerm<span>,</span> term<span>:</span> Term) <span>-&gt;</span> CpsTerm <span>{</span></span>
<span id="cb1-55"><a href="#cb1-55"></a>    <span>match</span> term<span>.</span>deref() <span>{</span></span>
<span id="cb1-56"><a href="#cb1-56"></a>        Var(x) <span>=&gt;</span> finish(CLamVar(x<span>.</span>to_string()))<span>,</span></span>
<span id="cb1-57"><a href="#cb1-57"></a>        Fix(defs<span>,</span> m) <span>=&gt;</span> CFix(</span>
<span id="cb1-58"><a href="#cb1-58"></a>            defs<span>.</span>iter()</span>
<span id="cb1-59"><a href="#cb1-59"></a>                <span>.</span>map(<span>|</span>def<span>|</span> convert_def(gen<span>.</span>clone()<span>,</span> def<span>.</span>clone()))</span>
<span id="cb1-60"><a href="#cb1-60"></a>                <span>.</span>collect()<span>,</span></span>
<span id="cb1-61"><a href="#cb1-61"></a>            <span>Box</span><span>::</span>new(convert(gen<span>,</span> finish<span>,</span> m<span>.</span>clone()))<span>,</span></span>
<span id="cb1-62"><a href="#cb1-62"></a>        )<span>,</span></span>
<span id="cb1-63"><a href="#cb1-63"></a>        Appl(f<span>,</span> args) <span>=&gt;</span> <span>{</span></span>
<span id="cb1-64"><a href="#cb1-64"></a>            <span>let</span> ret_k <span>=</span> gensym(gen<span>.</span>clone())<span>;</span></span>
<span id="cb1-65"><a href="#cb1-65"></a>            <span>let</span> ret_k_x <span>=</span> gensym(gen<span>.</span>clone())<span>;</span></span>
<span id="cb1-66"><a href="#cb1-66"></a>            CFix(</span>
<span id="cb1-67"><a href="#cb1-67"></a>                <span>vec!</span>[(ret_k<span>.</span>clone()<span>,</span> <span>vec!</span>[ret_k_x<span>.</span>clone()]<span>,</span> finish(ret_k_x))]<span>,</span></span>
<span id="cb1-68"><a href="#cb1-68"></a>                <span>Box</span><span>::</span>new(convert(</span>
<span id="cb1-69"><a href="#cb1-69"></a>                    gen<span>.</span>clone()<span>,</span></span>
<span id="cb1-70"><a href="#cb1-70"></a>                    <span>|</span>f_cps<span>|</span> <span>{</span></span>
<span id="cb1-71"><a href="#cb1-71"></a>                        convert_list(</span>
<span id="cb1-72"><a href="#cb1-72"></a>                            gen<span>,</span></span>
<span id="cb1-73"><a href="#cb1-73"></a>                            <span>|</span>args_cps<span>|</span> <span>{</span></span>
<span id="cb1-74"><a href="#cb1-74"></a>                                CAppl(f_cps<span>,</span> args_cps<span>.</span>into_iter()<span>.</span>chain(<span>vec!</span>[ret_k])<span>.</span>collect())</span>
<span id="cb1-75"><a href="#cb1-75"></a>                            <span>},</span></span>
<span id="cb1-76"><a href="#cb1-76"></a>                            args<span>,</span></span>
<span id="cb1-77"><a href="#cb1-77"></a>                        )</span>
<span id="cb1-78"><a href="#cb1-78"></a>                    <span>},</span></span>
<span id="cb1-79"><a href="#cb1-79"></a>                    f<span>.</span>clone()<span>,</span></span>
<span id="cb1-80"><a href="#cb1-80"></a>                ))<span>,</span></span>
<span id="cb1-81"><a href="#cb1-81"></a>            )</span>
<span id="cb1-82"><a href="#cb1-82"></a>        <span>}</span></span>
<span id="cb1-83"><a href="#cb1-83"></a>        Record(fields) <span>=&gt;</span> convert_list(</span>
<span id="cb1-84"><a href="#cb1-84"></a>            gen<span>.</span>clone()<span>,</span></span>
<span id="cb1-85"><a href="#cb1-85"></a>            <span>|</span>fields_cps<span>|</span> <span>{</span></span>
<span id="cb1-86"><a href="#cb1-86"></a>                <span>let</span> x <span>=</span> gensym(gen)<span>;</span></span>
<span id="cb1-87"><a href="#cb1-87"></a>                CRecord(fields_cps<span>,</span> (x<span>.</span>clone()<span>,</span> <span>Box</span><span>::</span>new(finish(x))))</span>
<span id="cb1-88"><a href="#cb1-88"></a>            <span>},</span></span>
<span id="cb1-89"><a href="#cb1-89"></a>            fields<span>,</span></span>
<span id="cb1-90"><a href="#cb1-90"></a>        )<span>,</span></span>
<span id="cb1-91"><a href="#cb1-91"></a>        Select(m<span>,</span> i) <span>=&gt;</span> convert(</span>
<span id="cb1-92"><a href="#cb1-92"></a>            gen<span>.</span>clone()<span>,</span></span>
<span id="cb1-93"><a href="#cb1-93"></a>            <span>|</span>m_cps<span>|</span> <span>{</span></span>
<span id="cb1-94"><a href="#cb1-94"></a>                <span>let</span> x <span>=</span> gensym(gen)<span>;</span></span>
<span id="cb1-95"><a href="#cb1-95"></a>                CSelect(m_cps<span>,</span> <span>*</span>i<span>,</span> (x<span>.</span>clone()<span>,</span> <span>Box</span><span>::</span>new(finish(x))))</span>
<span id="cb1-96"><a href="#cb1-96"></a>            <span>},</span></span>
<span id="cb1-97"><a href="#cb1-97"></a>            m<span>.</span>clone()<span>,</span></span>
<span id="cb1-98"><a href="#cb1-98"></a>        )<span>,</span></span>
<span id="cb1-99"><a href="#cb1-99"></a>    <span>}</span></span>
<span id="cb1-100"><a href="#cb1-100"></a><span>}</span></span>
<span id="cb1-101"><a href="#cb1-101"></a></span>
<span id="cb1-102"><a href="#cb1-102"></a><span>// Converts `Vec&lt;Term&gt;` to `Vec&lt;CpsVar&gt;` and applies `finish` to it.</span></span>
<span id="cb1-103"><a href="#cb1-103"></a><span>fn</span> convert_list(</span>
<span id="cb1-104"><a href="#cb1-104"></a>    gen<span>:</span> RefCell<span>&lt;</span><span>u32</span><span>&gt;,</span></span>
<span id="cb1-105"><a href="#cb1-105"></a>    finish<span>:</span> <span>impl</span> <span>FnOnce</span>(<span>Vec</span><span>&lt;</span>CpsVar<span>&gt;</span>) <span>-&gt;</span> CpsTerm<span>,</span></span>
<span id="cb1-106"><a href="#cb1-106"></a>    terms<span>:</span> <span>&amp;</span>[Term]<span>,</span></span>
<span id="cb1-107"><a href="#cb1-107"></a>) <span>-&gt;</span> CpsTerm <span>{</span></span>
<span id="cb1-108"><a href="#cb1-108"></a>    <span>fn</span> go(</span>
<span id="cb1-109"><a href="#cb1-109"></a>        gen<span>:</span> RefCell<span>&lt;</span><span>u32</span><span>&gt;,</span></span>
<span id="cb1-110"><a href="#cb1-110"></a>        finish<span>:</span> <span>impl</span> <span>FnOnce</span>(<span>Vec</span><span>&lt;</span>CpsVar<span>&gt;</span>) <span>-&gt;</span> CpsTerm<span>,</span></span>
<span id="cb1-111"><a href="#cb1-111"></a>        <span>mut</span> acc<span>:</span> <span>Vec</span><span>&lt;</span>CpsVar<span>&gt;,</span></span>
<span id="cb1-112"><a href="#cb1-112"></a>        terms<span>:</span> <span>&amp;</span>[Term]<span>,</span></span>
<span id="cb1-113"><a href="#cb1-113"></a>    ) <span>-&gt;</span> CpsTerm <span>{</span></span>
<span id="cb1-114"><a href="#cb1-114"></a>        <span>match</span> terms<span>.</span>split_first() <span>{</span></span>
<span id="cb1-115"><a href="#cb1-115"></a>            <span>None</span> <span>=&gt;</span> finish(acc)<span>,</span></span>
<span id="cb1-116"><a href="#cb1-116"></a>            <span>Some</span>((x<span>,</span> xs)) <span>=&gt;</span> convert(</span>
<span id="cb1-117"><a href="#cb1-117"></a>                gen<span>.</span>clone()<span>,</span></span>
<span id="cb1-118"><a href="#cb1-118"></a>                <span>|</span>x_cps<span>|</span> <span>{</span></span>
<span id="cb1-119"><a href="#cb1-119"></a>                    acc<span>.</span>push(x_cps)<span>;</span></span>
<span id="cb1-120"><a href="#cb1-120"></a>                    go(gen<span>,</span> finish<span>,</span> acc<span>,</span> xs)</span>
<span id="cb1-121"><a href="#cb1-121"></a>                <span>},</span></span>
<span id="cb1-122"><a href="#cb1-122"></a>                x<span>.</span>clone()<span>,</span></span>
<span id="cb1-123"><a href="#cb1-123"></a>            )<span>,</span></span>
<span id="cb1-124"><a href="#cb1-124"></a>        <span>}</span></span>
<span id="cb1-125"><a href="#cb1-125"></a>    <span>}</span></span>
<span id="cb1-126"><a href="#cb1-126"></a>    <span>let</span> acc <span>=</span> <span>Vec</span><span>::</span>with_capacity(terms<span>.</span>len())<span>;</span></span>
<span id="cb1-127"><a href="#cb1-127"></a>    go(gen<span>,</span> finish<span>,</span> acc<span>,</span> terms)</span>
<span id="cb1-128"><a href="#cb1-128"></a><span>}</span></span>
<span id="cb1-129"><a href="#cb1-129"></a></span>
<span id="cb1-130"><a href="#cb1-130"></a><span>// Converts a single function definition to its CPS form.</span></span>
<span id="cb1-131"><a href="#cb1-131"></a><span>fn</span> convert_def(</span>
<span id="cb1-132"><a href="#cb1-132"></a>    gen<span>:</span> RefCell<span>&lt;</span><span>u32</span><span>&gt;,</span></span>
<span id="cb1-133"><a href="#cb1-133"></a>    (f<span>,</span> params<span>,</span> m)<span>:</span> (Var<span>,</span> <span>Vec</span><span>&lt;</span>Var<span>&gt;,</span> Term)<span>,</span></span>
<span id="cb1-134"><a href="#cb1-134"></a>) <span>-&gt;</span> (CpsVar<span>,</span> <span>Vec</span><span>&lt;</span>CpsVar<span>&gt;,</span> CpsTerm) <span>{</span></span>
<span id="cb1-135"><a href="#cb1-135"></a>    <span>let</span> k <span>=</span> gensym(gen<span>.</span>clone())<span>;</span></span>
<span id="cb1-136"><a href="#cb1-136"></a>    (</span>
<span id="cb1-137"><a href="#cb1-137"></a>        CLamVar(f)<span>,</span></span>
<span id="cb1-138"><a href="#cb1-138"></a>        params</span>
<span id="cb1-139"><a href="#cb1-139"></a>            <span>.</span>into_iter()</span>
<span id="cb1-140"><a href="#cb1-140"></a>            <span>.</span>map(CLamVar)</span>
<span id="cb1-141"><a href="#cb1-141"></a>            <span>.</span>chain(<span>std::iter::</span>once(k<span>.</span>clone()))</span>
<span id="cb1-142"><a href="#cb1-142"></a>            <span>.</span>collect()<span>,</span></span>
<span id="cb1-143"><a href="#cb1-143"></a>        convert(gen<span>,</span> <span>|</span>m_cps<span>|</span> CAppl(k<span>,</span> <span>vec!</span>[m_cps])<span>,</span> m)<span>,</span></span>
<span id="cb1-144"><a href="#cb1-144"></a>    )</span>
<span id="cb1-145"><a href="#cb1-145"></a><span>}</span></span></code></pre></div><p>The code is 145 lines long, including comments and blank lines.</p><p>The same algorithm in idiomatic OCaml <a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p><div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1"></a><span>(* A variable identifier of the lambda language [term]. *)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span>type</span> var = <span>string</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span>(* The lambda language; direct style. *)</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span>type</span> term =</span>
<span id="cb2-6"><a href="#cb2-6"></a>  | Var <span>of</span> var</span>
<span id="cb2-7"><a href="#cb2-7"></a>  | Fix <span>of</span> (var * var <span>list</span> * term) <span>list</span> * term</span>
<span id="cb2-8"><a href="#cb2-8"></a>  | Appl <span>of</span> term * term <span>list</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>  | Record <span>of</span> term <span>list</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  | Select <span>of</span> term * <span>int</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span>type</span> cps_var =</span>
<span id="cb2-13"><a href="#cb2-13"></a>  <span>(* Taken from the lambda term during CPS conversion. *)</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>  | CLamVar <span>of</span> var</span>
<span id="cb2-15"><a href="#cb2-15"></a>  <span>(* Generated uniquely during CPS conversion. *)</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  | CGenVar <span>of</span> <span>int</span></span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a><span>(* The resulting CPS term. *)</span></span>
<span id="cb2-19"><a href="#cb2-19"></a><span>type</span> cps_term =</span>
<span id="cb2-20"><a href="#cb2-20"></a>  | CFix <span>of</span> (cps_var * cps_var <span>list</span> * cps_term) <span>list</span> * cps_term</span>
<span id="cb2-21"><a href="#cb2-21"></a>  | CAppl <span>of</span> cps_var * cps_var <span>list</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>  | CRecord <span>of</span> cps_var <span>list</span> * binder</span>
<span id="cb2-23"><a href="#cb2-23"></a>  | CSelect <span>of</span> cps_var * <span>int</span> * binder</span>
<span id="cb2-24"><a href="#cb2-24"></a>  | CHalt <span>of</span> cps_var</span>
<span id="cb2-25"><a href="#cb2-25"></a></span>
<span id="cb2-26"><a href="#cb2-26"></a><span>(* Binds a unique [cps_var] within [cps_term]. *)</span></span>
<span id="cb2-27"><a href="#cb2-27"></a><span>and</span> binder = cps_var * cps_term</span>
<span id="cb2-28"><a href="#cb2-28"></a></span>
<span id="cb2-29"><a href="#cb2-29"></a><span>(* Generates a unique CPS variable given the current [i]. *)</span></span>
<span id="cb2-30"><a href="#cb2-30"></a><span>let</span> gensym i =</span>
<span id="cb2-31"><a href="#cb2-31"></a>  <span>let</span> x = CGenVar !i <span>in</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>  i := !i + <span>1</span>;</span>
<span id="cb2-33"><a href="#cb2-33"></a>  x</span>
<span id="cb2-34"><a href="#cb2-34"></a></span>
<span id="cb2-35"><a href="#cb2-35"></a><span>(* Converts [term] to [cps_term], applying [finish] to the resulting</span></span>
<span id="cb2-36"><a href="#cb2-36"></a><span>   CPS variable. *)</span></span>
<span id="cb2-37"><a href="#cb2-37"></a><span>let</span> <span>rec</span> convert gen finish = <span>function</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>  | Var x -&gt; finish (CLamVar x)</span>
<span id="cb2-39"><a href="#cb2-39"></a>  | Fix (defs, m) -&gt; CFix (<span>List</span>.map (convert_def gen) defs, convert gen finish m)</span>
<span id="cb2-40"><a href="#cb2-40"></a>  | Appl (f, args) -&gt;</span>
<span id="cb2-41"><a href="#cb2-41"></a>      <span>let</span> ret_k = gensym gen <span>in</span></span>
<span id="cb2-42"><a href="#cb2-42"></a>      <span>let</span> ret_k_x = gensym gen <span>in</span></span>
<span id="cb2-43"><a href="#cb2-43"></a>      CFix</span>
<span id="cb2-44"><a href="#cb2-44"></a>        ( [ (ret_k, [ ret_k_x ], finish ret_k_x) ],</span>
<span id="cb2-45"><a href="#cb2-45"></a>          f</span>
<span id="cb2-46"><a href="#cb2-46"></a>          |&gt; convert gen (<span>fun</span> f_cps -&gt;</span>
<span id="cb2-47"><a href="#cb2-47"></a>                 args</span>
<span id="cb2-48"><a href="#cb2-48"></a>                 |&gt; convert_list gen (<span>fun</span> args_cps -&gt;</span>
<span id="cb2-49"><a href="#cb2-49"></a>                        CAppl (f_cps, args_cps @ [ ret_k ]))) )</span>
<span id="cb2-50"><a href="#cb2-50"></a>  | Record fields -&gt;</span>
<span id="cb2-51"><a href="#cb2-51"></a>      fields</span>
<span id="cb2-52"><a href="#cb2-52"></a>      |&gt; convert_list gen (<span>fun</span> fields_cps -&gt;</span>
<span id="cb2-53"><a href="#cb2-53"></a>             <span>let</span> x = gensym gen <span>in</span></span>
<span id="cb2-54"><a href="#cb2-54"></a>             CRecord (fields_cps, (x, finish x)))</span>
<span id="cb2-55"><a href="#cb2-55"></a>  | Select (m, i) -&gt;</span>
<span id="cb2-56"><a href="#cb2-56"></a>      m</span>
<span id="cb2-57"><a href="#cb2-57"></a>      |&gt; convert gen (<span>fun</span> m_cps -&gt;</span>
<span id="cb2-58"><a href="#cb2-58"></a>             <span>let</span> x = gensym gen <span>in</span></span>
<span id="cb2-59"><a href="#cb2-59"></a>             CSelect (m_cps, i, (x, finish x)))</span>
<span id="cb2-60"><a href="#cb2-60"></a></span>
<span id="cb2-61"><a href="#cb2-61"></a><span>(* Converts [term list] to [cps_var list] and applies [finish] to it. *)</span></span>
<span id="cb2-62"><a href="#cb2-62"></a><span>and</span> convert_list gen finish =</span>
<span id="cb2-63"><a href="#cb2-63"></a>  <span>let</span> <span>rec</span> go acc = <span>function</span></span>
<span id="cb2-64"><a href="#cb2-64"></a>    | [] -&gt; finish (<span>List</span>.rev acc)</span>
<span id="cb2-65"><a href="#cb2-65"></a>    | x :: xs -&gt; x |&gt; convert gen (<span>fun</span> x_cps -&gt; go (x_cps :: acc) xs)</span>
<span id="cb2-66"><a href="#cb2-66"></a>  <span>in</span></span>
<span id="cb2-67"><a href="#cb2-67"></a>  go []</span>
<span id="cb2-68"><a href="#cb2-68"></a></span>
<span id="cb2-69"><a href="#cb2-69"></a><span>(* Converts a single function definition to its CPS form. *)</span></span>
<span id="cb2-70"><a href="#cb2-70"></a><span>and</span> convert_def gen (f, params, m) =</span>
<span id="cb2-71"><a href="#cb2-71"></a>  <span>let</span> k = gensym gen <span>in</span></span>
<span id="cb2-72"><a href="#cb2-72"></a>  ( CLamVar f,</span>
<span id="cb2-73"><a href="#cb2-73"></a>    <span>List</span>.map (<span>fun</span> x -&gt; CLamVar x) params @ [ k ],</span>
<span id="cb2-74"><a href="#cb2-74"></a>    m |&gt; convert gen (<span>fun</span> m_cps -&gt; CAppl (k, [ m_cps ])) )</span></code></pre></div><p>The code is 74 lines long, including comments and blank lines. This
is ~2.0 times shorter than the Rust version.</p><a href="#comparing-the-two-implementations"><h2 id="comparing-the-two-implementations">Comparing the two
implementations</h2></a><p>Compiler development is characterized by:</p><ol type="1">
<li>a lot of recursively defined data structured,</li>
<li>a lot of complex data transformation.</li>
</ol><p>How do Rust and OCaml handle these two aspects? Below is a brief
summary:</p><ol type="1">
<li>Recursive data structures:
<ol type="1">
<li><strong>OCaml</strong>: recursive data structures are supported
natively.</li>
<li><strong>Rust</strong>: we need to imitate data recursion by wrapping
recursive occurences of <code>TermTree</code> and <code>CpsTerm</code>
into <code>Rc</code>s <a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> and <code>Box</code>es.</li>
</ol></li>
<li>Complex data transformation:
<ol type="1">
<li><strong>OCaml</strong>:
<ul>
<li>Recursion is a common practice. OCaml has tail-call optimization and
<a href="https://v2.ocaml.org/manual/tail_mod_cons.html">“Tail Modulo
Constructor (TMC)”</a> optimization.</li>
<li>Pattern matching is made very ergonomic. With <code>function</code>,
we can pattern-match the “last parameter” <a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> of
a function without introducing any extra indentation.
(<code>function</code> also lets us omit the last parameter with
oftentimes a dummy name like <code>term</code>; if you think the
parameter name is useful, you can write it in the signature.) Lists can
be matched as simply as <code>| [] -&gt; ...</code> and
<code>| x :: xs -&gt; ...</code> without further hussle.</li>
<li>The majority of standard data structures are immutable. This makes
it easy to reason about the code.</li>
</ul></li>
<li><strong>Rust</strong>:
<ul>
<li>Recursion is uncommon. TCO is <a href="https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust">not
guaranteed</a> (compare it with OCaml’s <a href="https://stackoverflow.com/questions/23186717/verify-that-an-ocaml-function-is-tail-recursive"><code>[@tailcall]</code></a>
and <a href="https://v2.ocaml.org/manual/tail_mod_cons.html"><code>[@tail_mod_cons]</code></a>
annotations).</li>
<li>Pattern matching requires extra indentation and the need to
explicate the matched parameter. There are several ways to “match”
vectors, but they all are more verbose than OCaml’s built-in
syntax.</li>
<li>The majority of standard data structures are mutable, which inclines
us towards the imperative style instead of the applicative style.
Iterators provide us with a hatch to write code in the pipelined
fashion, but first we need to
<code>.iter()</code>/<code>.iter_mut()</code>/<code>.into_iter()</code>
the data structure, perform the work, and then
<code>.collect()</code>.</li>
</ul></li>
</ol></li>
</ol><p>In addition to being syntactically more verbose than OCaml, Rust is a
language without garbage collection. This forces us to make certain
explicit choices about memory management: you can observe the plentitude
of plumbing with boxes, references (both <code>&amp;</code> and
<code>Rc</code>), cloning, etc. Although it provides us with a greater
sense of <em>how</em> the code is executing, it brings very little value
to the algorithm itself.</p><p>Even mutation can be more challenging in Rust:</p><div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1"></a><span>fn</span> gensym(i<span>:</span> RefCell<span>&lt;</span><span>u32</span><span>&gt;</span>) <span>-&gt;</span> CpsVar <span>{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span>let</span> x <span>=</span> CGenVar(i<span>.</span>clone()<span>.</span>into_inner())<span>;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    i<span>.</span>replace_with(<span>|&amp;</span><span>mut</span> i<span>|</span> i <span>+</span> <span>1</span>)<span>;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    x</span>
<span id="cb3-5"><a href="#cb3-5"></a><span>}</span></span></code></pre></div><p>In OCaml, it is just:</p><div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1"></a><span>let</span> gensym i =</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span>let</span> x = CGenVar !i <span>in</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  i := !i + <span>1</span>;</span>
<span id="cb4-4"><a href="#cb4-4"></a>  x</span></code></pre></div><p>Why <code>RefCell&lt;u32&gt;</code> instead of
<code>&amp;mut u32</code>? Because Rust requires us to have a single
mutable reference to a value at any given time. This is a very
reasonable requirement in multithreaded code, but we do not use more
than one thread in our algorithm. We need <code>RefCell</code> just to
circumvent this superfluous limitation.</p><p>The last thing to note is the implementation of
<code>convert_list</code> in Rust. Since <code>fn</code>s are inherently
no more than code pointers, we need to pass <code>gen</code> and
<code>finish</code> explicitly on each call to <code>go</code> <a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>. In turn, this leads us to
duplicating the types of these variables in the signature of
<code>go</code> (in Rust, there is no type inference of function
parameters). In contrast, OCaml captures <code>gen</code> and
<code>finish</code> automatically.</p><p>While the algorithm presented here is not very complex, it does
already demonstrate the convenience of programming in a language from
the ML family. However, let us see some more examples concerning type
systems of both languages.</p><a href="#type-safety-gadts"><h2 id="type-safety-gadts">Type safety: GADTs</h2></a><p>Resource management aside, OCaml’s type system is generally more
expressive than that of Rust. For example, OCaml supports <a href="https://v2.ocaml.org/manual/gadts-tutorial.html">Generalized
Algebraic Data Types (GADTs)</a> to enforce certain invariants on the
structure of data. Let us imagine an object language of booleans,
integers, and operations upon them:</p><div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a><span>enum</span> Term <span>{</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>    Bool(<span>bool</span>)<span>,</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span>Not</span>(<span>Box</span><span>&lt;</span>Term<span>&gt;</span>)<span>,</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    And(<span>Box</span><span>&lt;</span>Term<span>&gt;,</span> <span>Box</span><span>&lt;</span>Term<span>&gt;</span>)<span>,</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    Int(<span>i32</span>)<span>,</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span>Neg</span>(<span>Box</span><span>&lt;</span>Term<span>&gt;</span>)<span>,</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span>Add</span>(<span>Box</span><span>&lt;</span>Term<span>&gt;,</span> <span>Box</span><span>&lt;</span>Term<span>&gt;</span>)<span>,</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span>}</span></span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span>enum</span> Value <span>{</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    Bool(<span>bool</span>)<span>,</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>    Int(<span>i32</span>)<span>,</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span>}</span></span></code></pre></div><p>How do we write an evaluator for it? Here is a possible solution:</p><div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1"></a><span>fn</span> eval(term<span>:</span> <span>&amp;</span>Term) <span>-&gt;</span> Value <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span>use</span> <span>Term::</span><span>*;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span>match</span> term <span>{</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>        Bool(b) <span>=&gt;</span> <span>Value::</span>Bool(<span>*</span>b)<span>,</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>        <span>Not</span>(m) <span>=&gt;</span> <span>match</span> eval(m) <span>{</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>            <span>Value::</span>Bool(b) <span>=&gt;</span> <span>Value::</span>Bool(<span>!</span>b)<span>,</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>            _ <span>=&gt;</span> <span>panic!</span>(<span>&#34;`Not` on a non-boolean value&#34;</span>)<span>,</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>        <span>},</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>        And(m<span>,</span> n) <span>=&gt;</span> <span>match</span> (eval(m)<span>,</span> eval(n)) <span>{</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>            (<span>Value::</span>Bool(b1)<span>,</span> <span>Value::</span>Bool(b2)) <span>=&gt;</span> <span>Value::</span>Bool(b1 <span>&amp;&amp;</span> b2)<span>,</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>            _ <span>=&gt;</span> <span>panic!</span>(<span>&#34;`And` on non-boolean values&#34;</span>)<span>,</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>        <span>},</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>        Int(i) <span>=&gt;</span> <span>Value::</span>Int(<span>*</span>i)<span>,</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span>Neg</span>(m) <span>=&gt;</span> <span>match</span> eval(m) <span>{</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>            <span>Value::</span>Int(i) <span>=&gt;</span> <span>Value::</span>Int(<span>-</span>i)<span>,</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>            _ <span>=&gt;</span> <span>panic!</span>(<span>&#34;`Neg` on a non-integer value&#34;</span>)<span>,</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>        <span>},</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>        <span>Add</span>(m<span>,</span> n) <span>=&gt;</span> <span>match</span> (eval(m)<span>,</span> eval(n)) <span>{</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>            (<span>Value::</span>Int(i1)<span>,</span> <span>Value::</span>Int(i2)) <span>=&gt;</span> <span>Value::</span>Int(i1 <span>+</span> i2)<span>,</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>            _ <span>=&gt;</span> <span>panic!</span>(<span>&#34;`Add` on non-integer values&#34;</span>)<span>,</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>        <span>},</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span>}</span></span>
<span id="cb6-24"><a href="#cb6-24"></a><span>}</span></span></code></pre></div><p>The solution is simple enough; however, it is not very robust. What
happens if an input to <code>eval</code> is ill-typed? Take the
following example:</p><div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1"></a><span>fn</span> main() <span>{</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span>use</span> <span>Term::</span><span>*;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span>let</span> term <span>=</span> <span>Not</span>(<span>Box</span><span>::</span>new(And(<span>Box</span><span>::</span>new(Bool(<span>true</span>))<span>,</span> <span>Box</span><span>::</span>new(Int(<span>42</span>)))))<span>;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span>dbg!</span>(eval(<span>&amp;</span>term))<span>;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span>}</span></span></code></pre></div><p>The program panics with “<code>And</code> on non-boolean values”,
because the second operand of <code>And</code> must necessarily be a
boolean, not an integer.</p><p>To prevent this kind of errors, we can use GADTs in OCaml:</p><div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1"></a><span>type</span> _ term =</span>
<span id="cb8-2"><a href="#cb8-2"></a>  | Bool : <span>bool</span> -&gt; <span>bool</span> term</span>
<span id="cb8-3"><a href="#cb8-3"></a>  | Not : <span>bool</span> term -&gt; <span>bool</span> term</span>
<span id="cb8-4"><a href="#cb8-4"></a>  | And : <span>bool</span> term * <span>bool</span> term -&gt; <span>bool</span> term</span>
<span id="cb8-5"><a href="#cb8-5"></a>  | Int : <span>int</span> -&gt; <span>int</span> term</span>
<span id="cb8-6"><a href="#cb8-6"></a>  | Neg : <span>int</span> term -&gt; <span>int</span> term</span>
<span id="cb8-7"><a href="#cb8-7"></a>  | Add : <span>int</span> term * <span>int</span> term -&gt; <span>int</span> term</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span>let</span> <span>rec</span> eval : <span>type</span> a. a term -&gt; a = <span>function</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>  | Bool b -&gt; b</span>
<span id="cb8-11"><a href="#cb8-11"></a>  | Not m -&gt; <span>not</span> (eval m)</span>
<span id="cb8-12"><a href="#cb8-12"></a>  | And (m, n) -&gt;</span>
<span id="cb8-13"><a href="#cb8-13"></a>      <span>let</span> b1, b2 = (eval m, eval n) <span>in</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>      b1 &amp;&amp; b2</span>
<span id="cb8-15"><a href="#cb8-15"></a>  | Int i -&gt; i</span>
<span id="cb8-16"><a href="#cb8-16"></a>  | Neg m -&gt; -eval m</span>
<span id="cb8-17"><a href="#cb8-17"></a>  | Add (m, n) -&gt;</span>
<span id="cb8-18"><a href="#cb8-18"></a>      <span>let</span> i1, i2 = (eval m, eval n) <span>in</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>      i1 + i2</span></code></pre></div><p>Now what happens if we construct an ill-typed term?:</p><div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1"></a><span>let</span> () =</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span>let</span> _term = Not (And (Bool <span>true</span>, Int <span>42</span>)) <span>in</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  ()</span></code></pre></div><p>It just will not type-check!:</p><div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1"></a>File &#34;bin/main.ml&#34;, line 22, characters 35-41:</span>
<span id="cb10-2"><a href="#cb10-2"></a>22 |   let _term = Not (And (Bool true, Int 42)) in</span>
<span id="cb10-3"><a href="#cb10-3"></a>                                        ^^^^^^</span>
<span id="cb10-4"><a href="#cb10-4"></a>Error: This expression has type int term</span>
<span id="cb10-5"><a href="#cb10-5"></a>       but an expression was expected of type bool term</span>
<span id="cb10-6"><a href="#cb10-6"></a>       Type int is not compatible with type bool</span></code></pre></div><p>This is possible because we essentially encoded the object language
type system in the definition of <code>term</code>. OCaml knows that
<code>And</code> accepts boolean-typed terms, not integer-typed ones. In
a real-world scenario, we can have an unrestricted <code>term</code>
akin to Rust’s <code>Term</code>, which is produced by parsing and
elaborated further into a proper GADT-style <code>term</code>. The
latter can be handled by <code>eval</code> (or <code>compile</code>,
whatever).</p><a href="#type-flexibility-first-class-modules"><h2 id="type-flexibility-first-class-modules">Type flexibility:
First-class modules</h2></a><p>Another neat feature of OCaml not present in Rust is <a href="https://dev.realworldocaml.org/first-class-modules.html">first-class
modules</a>. Can you imagine a module that is stored in a variable,
passed as a parameter, or returned from a regular function? This is what
first-class modules are about. Suppose that your object language
includes various fixed-size integers, such as
<code>i8</code>/<code>u8</code>, <code>i16</code>/<code>u16</code>, and
so on. With OCaml, you can represent them via (regular) modules:</p><p>
<code>fixed_ints.mli</code>
</p><div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1"></a><span>(* [u8], [u16], etc. are defined by us. *)</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span>module</span> <span>type</span> S = <span>sig</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span>type</span> t</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>  <span>val</span> add : t -&gt; t -&gt; t</span>
<span id="cb11-7"><a href="#cb11-7"></a>  <span>val</span> sub : t -&gt; t -&gt; t</span>
<span id="cb11-8"><a href="#cb11-8"></a>  <span>val</span> mul : t -&gt; t -&gt; t</span>
<span id="cb11-9"><a href="#cb11-9"></a>  <span>val</span> div : t -&gt; t -&gt; t</span>
<span id="cb11-10"><a href="#cb11-10"></a>  <span>val</span> rem : t -&gt; t -&gt; t</span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>  <span>(* Some more operations here. *)</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span>end</span></span>
<span id="cb11-14"><a href="#cb11-14"></a></span>
<span id="cb11-15"><a href="#cb11-15"></a><span>module</span> U8 : S <span>with</span> <span>type</span> t = u8</span>
<span id="cb11-16"><a href="#cb11-16"></a><span>module</span> U16 : S <span>with</span> <span>type</span> t = u16</span>
<span id="cb11-17"><a href="#cb11-17"></a><span>module</span> U32 : S <span>with</span> <span>type</span> t = u32</span>
<span id="cb11-18"><a href="#cb11-18"></a><span>module</span> U64 : S <span>with</span> <span>type</span> t = u64</span>
<span id="cb11-19"><a href="#cb11-19"></a><span>module</span> U128 : S <span>with</span> <span>type</span> t = u128</span>
<span id="cb11-20"><a href="#cb11-20"></a><span>module</span> I8 : S <span>with</span> <span>type</span> t = i8</span>
<span id="cb11-21"><a href="#cb11-21"></a><span>module</span> I16 : S <span>with</span> <span>type</span> t = i16</span>
<span id="cb11-22"><a href="#cb11-22"></a><span>module</span> I32 : S <span>with</span> <span>type</span> t = i32</span>
<span id="cb11-23"><a href="#cb11-23"></a><span>module</span> I64 : S <span>with</span> <span>type</span> t = i64</span>
<span id="cb11-24"><a href="#cb11-24"></a><span>module</span> I128 : S <span>with</span> <span>type</span> t = i128</span></code></pre></div><p>In the AST, we can represent integer values as follows:</p><div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1"></a><span>type</span> generic =</span>
<span id="cb12-2"><a href="#cb12-2"></a>  | U8 <span>of</span> u8</span>
<span id="cb12-3"><a href="#cb12-3"></a>  | U16 <span>of</span> u16</span>
<span id="cb12-4"><a href="#cb12-4"></a>  | U32 <span>of</span> u32</span>
<span id="cb12-5"><a href="#cb12-5"></a>  | U64 <span>of</span> u64</span>
<span id="cb12-6"><a href="#cb12-6"></a>  | U128 <span>of</span> u128</span>
<span id="cb12-7"><a href="#cb12-7"></a>  | I8 <span>of</span> i8</span>
<span id="cb12-8"><a href="#cb12-8"></a>  | I16 <span>of</span> i16</span>
<span id="cb12-9"><a href="#cb12-9"></a>  | I32 <span>of</span> i32</span>
<span id="cb12-10"><a href="#cb12-10"></a>  | I64 <span>of</span> i64</span>
<span id="cb12-11"><a href="#cb12-11"></a>  | I128 <span>of</span> i128</span></code></pre></div><p>Having so many possible combinations of arithmetical operators
<code>add</code>/<code>sub</code>/<code>mul</code>/<code>div</code>/<code>rem</code>
and variously typed operands, how to implement evaluation sanely?</p><p>Here is an idea:</p><ol type="1">
<li>Define a function <code>pair_exn</code> that maps two
<code>generic</code>s into a first-class module <code>Pair</code>.</li>
<li>Define a module <code>Pair</code> that implements <code>S</code> for
a given pair of integers.</li>
<li>Define a function <code>do_int_bin_op</code> that accepts
<code>Pair</code> as a parameter and performs an operation
<code>op</code> on the pair of integers.</li>
<li>Call <code>do_int_bin_op</code> from <code>eval</code>.</li>
</ol><p>In OCaml:</p><p>
<code>fixed_ints.mli</code>
</p><div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1"></a><span>module</span> <span>type</span> Pair = <span>sig</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span>type</span> t</span>
<span id="cb13-3"><a href="#cb13-3"></a></span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span>include</span> S <span>with</span> <span>type</span> t := t</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span>val</span> pair : t * t</span>
<span id="cb13-7"><a href="#cb13-7"></a><span>end</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span>val</span> pair_exn : generic * generic -&gt; (<span>module</span> Pair)</span></code></pre></div><p>The implementation of <code>pair</code> would be:</p><p>
<code>fixed_ints.ml</code>
</p><div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1"></a><span>let</span> pair_exn =</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span>let</span> make (<span>type</span> a) (<span>module</span> S : S <span>with</span> <span>type</span> t = a) (x, y) =</span>
<span id="cb14-3"><a href="#cb14-3"></a>    (<span>module</span> <span>struct</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>      <span>include</span> S</span>
<span id="cb14-5"><a href="#cb14-5"></a></span>
<span id="cb14-6"><a href="#cb14-6"></a>      <span>let</span> pair = x, y</span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span>end</span> : Pair)</span>
<span id="cb14-8"><a href="#cb14-8"></a>  <span>in</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>  <span>function</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>  | U8 x, U8 y -&gt; make (<span>module</span> U8) (x, y)</span>
<span id="cb14-11"><a href="#cb14-11"></a>  | U16 x, U16 y -&gt; make (<span>module</span> U16) (x, y)</span>
<span id="cb14-12"><a href="#cb14-12"></a>  | U32 x, U32 y -&gt; make (<span>module</span> U32) (x, y)</span>
<span id="cb14-13"><a href="#cb14-13"></a>  | U64 x, U64 y -&gt; make (<span>module</span> U64) (x, y)</span>
<span id="cb14-14"><a href="#cb14-14"></a>  | U128 x, U128 y -&gt; make (<span>module</span> U128) (x, y)</span>
<span id="cb14-15"><a href="#cb14-15"></a>  | I8 x, I8 y -&gt; make (<span>module</span> I8) (x, y)</span>
<span id="cb14-16"><a href="#cb14-16"></a>  | I16 x, I16 y -&gt; make (<span>module</span> I16) (x, y)</span>
<span id="cb14-17"><a href="#cb14-17"></a>  | I32 x, I32 y -&gt; make (<span>module</span> I32) (x, y)</span>
<span id="cb14-18"><a href="#cb14-18"></a>  | I64 x, I64 y -&gt; make (<span>module</span> I64) (x, y)</span>
<span id="cb14-19"><a href="#cb14-19"></a>  | I128 x, I128 y -&gt; make (<span>module</span> I128) (x, y)</span>
<span id="cb14-20"><a href="#cb14-20"></a>  | _, _ -&gt; <span>raise</span> (<span>invalid_arg</span> <span>&#34;Fixed_ints.pair_exn&#34;</span>)</span>
<span id="cb14-21"><a href="#cb14-21"></a>;;</span></code></pre></div><p>Now we can write <code>eval</code> as follows:</p><div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1"></a><span>(* Somewhere within the definition of [eval]. *)</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>| IntBinOp (op, ty, m, n) -&gt;</span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span>let</span> x = extract_int_exn (eval m) <span>in</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span>let</span> y = extract_int_exn (eval n) <span>in</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  <span>let</span> (<span>module</span> Pair) = Fixed_ints.pair_exn (x, y) <span>in</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>  do_int_bin_op op (<span>module</span> Pair)</span></code></pre></div><p><code>extract_int_exn</code> takes a value and extracts an integer
<code>generic</code>, raising an exception if the value is not an
integer.</p><p>Finally, <code>do_int_bin_op</code> is defined as follows:</p><div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1"></a><span>let</span> do_int_bin_op op (<span>module</span> S : Fixed_ints.Pair) =</span>
<span id="cb16-2"><a href="#cb16-2"></a>  <span>let</span> x, y = S.pair <span>in</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span>match</span> op <span>with</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>  | Add -&gt; S.add x y |&gt; S.to_value</span>
<span id="cb16-5"><a href="#cb16-5"></a>  | Sub -&gt; S.sub x y |&gt; S.to_value</span>
<span id="cb16-6"><a href="#cb16-6"></a>  | Mul -&gt; S.mul x y |&gt; S.to_value</span>
<span id="cb16-7"><a href="#cb16-7"></a>  | Div -&gt; S.div x y |&gt; S.to_value</span>
<span id="cb16-8"><a href="#cb16-8"></a>  | Rem -&gt; S.rem x y |&gt; S.to_value</span>
<span id="cb16-9"><a href="#cb16-9"></a>;;</span></code></pre></div><p><code>S.to_value</code> converts a typed integer back to a value
holding <code>generic</code>.</p><p>With the aid of first-class modules, we were able to implement
evaluation of fixed-size integers without much boilerplate. The best you
could do in Rust is to resort to <code>macro_rules!</code>, which are
notorious for their hard-to-decipher syntax, shallow integration with
the rest of the language, and poor IDE support.</p><a href="#final-words"><h2 id="final-words">Final words</h2></a><p>While Rust excels at resource management, OCaml turns out to be a
more suitable choice for compiler development. We have not covered many
other interesting features of it, such as <a href="https://v2.ocaml.org/releases/4.14/htmlman/polyvariant.html">polymorphic
variants</a>, <a href="https://v2.ocaml.org/manual/bindingops.html">custom binding
operators</a>, and <a href="https://v2.ocaml.org/manual/effects.html">effect handlers</a>. Due
to its completely static and flexible type system, OCaml has been
historically used as a host language for many projects, including the <a href="https://frama-c.com/">Frama-C toolchain</a>, the <a href="https://coq.inria.fr/">Coq theorem prover</a>, and early versions
of the Rust compiler itself.</p><p>OCaml is not without its flaws, though. The standard library and the
overall ecosystem is clearly inferior to that of Rust. The full set of
fixed-size integers found in Rust is not directly available in OCaml,
although it can be implemented with a combination of native OCaml
integers, the <code>Int32</code> and <code>Int64</code> modules from the
standard library, and C FFI. (Pro tip: do not use <a href="https://github.com/andrenth/ocaml-stdint"><code>ocaml-stdint</code></a>,
it is unmaintained and is very buggy as of Aug 6, 2023. <a href="https://github.com/yallop/ocaml-integers"><code>ocaml-integers</code></a>
is a more robust alternative but it lacks support for <code>Int8</code>,
<code>Int16</code>, and 128-bit integers and has problems with
documentation.)</p><p>As Rust is gaining more and more popularity, more and more desperate
developers from GitHub will start their compiler projects in it. I
believe this can be a good decision either if 1) you are trying to learn
Rust by writing “too many compilers” in it, or 2) you do really know
what you are doing. If your intention is in compiler development itself,
OCaml will save you a lot of time and undamaged nerves.</p><p>Other alternatives to consider is Haskell and various Lisp dialects.
If you have already “tamed” Haskell (my congratulations and
condolences), probably learning OCaml just for writing a compiler is not
going to be worth it; if you have not, OCaml is a much more approachable
language. Lisps can be very flexible, but they usually lack static type
safety, opening a wide and horrible door to run-time errors.</p><a href="#appendix-getting-started-with-ocaml"><h2 id="appendix-getting-started-with-ocaml">Appendix: Getting started
with OCaml</h2></a><p>Here is an easy way to get started with OCaml:</p><ol type="1">
<li><a href="https://ocaml.org/install">Install OCaml on Linux, macOS,
*BSD, or Windows &gt;&gt;</a></li>
<li>Install the <a href="https://dune.readthedocs.io/en/stable/overview.html">Dune build
system</a>: <code>opam install dune</code>.</li>
<li>Create a new project:
<code>dune init project my_compiler</code>.</li>
</ol><p>The directory <code>my_compiler</code> will look like this:</p><div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1"></a>my_compiler/</span>
<span id="cb17-2"><a href="#cb17-2"></a>├── bin</span>
<span id="cb17-3"><a href="#cb17-3"></a>│   ├── dune</span>
<span id="cb17-4"><a href="#cb17-4"></a>│   └── main.ml</span>
<span id="cb17-5"><a href="#cb17-5"></a>├── _build</span>
<span id="cb17-6"><a href="#cb17-6"></a>│   └── log</span>
<span id="cb17-7"><a href="#cb17-7"></a>├── dune-project</span>
<span id="cb17-8"><a href="#cb17-8"></a>├── lib</span>
<span id="cb17-9"><a href="#cb17-9"></a>│   └── dune</span>
<span id="cb17-10"><a href="#cb17-10"></a>├── my_compiler.opam</span>
<span id="cb17-11"><a href="#cb17-11"></a>└── test</span>
<span id="cb17-12"><a href="#cb17-12"></a>    ├── dune</span>
<span id="cb17-13"><a href="#cb17-13"></a>    └── my_compiler.ml</span></code></pre></div><ol type="1">
<li><code>bin/</code> is for setup code and CLI.</li>
<li><code>lib/</code> is where most of the code lives.</li>
<li><code>test/</code> is for tests.</li>
</ol><p>I recommend <a href="https://github.com/mirage/alcotest"><code>alcotest</code></a> for
unit tests and <a href="https://github.com/ocaml-ppx/ppx_deriving"><code>ppx_deriving</code></a>
for the deriving functionality (akin to <code>#[derive(...)]</code> from
Rust). Install them as follows:</p><div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1"></a>$ opam install alcotest</span>
<span id="cb18-2"><a href="#cb18-2"></a>$ opam install ppx_deriving</span></code></pre></div><p>Edit <code>my_compiler/lib/dune</code> as follows:</p><div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1"></a>(library</span>
<span id="cb19-2"><a href="#cb19-2"></a> (name my_compiler)</span>
<span id="cb19-3"><a href="#cb19-3"></a> (preprocess</span>
<span id="cb19-4"><a href="#cb19-4"></a>  (pps ppx_deriving.show ppx_deriving.eq)))</span></code></pre></div><p>And <code>my_compiler/test/dune</code> as follows:</p><div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1"></a>(test</span>
<span id="cb20-2"><a href="#cb20-2"></a> (name my_compiler)</span>
<span id="cb20-3"><a href="#cb20-3"></a> (libraries my_compiler alcotest))</span></code></pre></div><ol type="1">
<li>Type <code>dune build</code> to build the project.</li>
<li>Type <code>dune test</code> to run the tests.</li>
<li>Type <code>dune exec my_compiler</code> to execute the binary.</li>
</ol><p>You can now create a file <code>foo.ml</code> with a corresponding
<code>foo.mli</code> in <code>my_compiler/lib</code> and access it as
<code>My_compiler.Foo</code> from <code>bin/</code> and
<code>lib/</code>.</p><p>For test coverage, consider using <a href="https://github.com/aantron/bisect_ppx"><code>bisect_ppx</code></a>.</p><p>If you know Rust, you will find OCaml very familiar. I recommend the
following resources for learning the language:</p><ul>
<li><a href="https://cs3110.github.io/textbook/cover.html">OCaml
Programming: Correct + Efficient + Beautiful</a></li>
<li><a href="https://dev.realworldocaml.org/">Real World OCaml</a></li>
<li><a href="https://v2.ocaml.org/manual/coreexamples.html">The official
tutorial</a> (can be read in an evening!)</li>
</ul><a href="#references"><h2 id="references">References</h2></a></div></div>
  </body>
</html>
