<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lupyuen.codeberg.page/articles/tcc.html">Original</a>
    <h1>TCC RISC-V Compiler Runs in the Web Browser (Thanks to Zig Compiler)</h1>
    
    <div id="readability-page-1" class="page">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    
    
    
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    
    <nav id="TOC"><ul>
<li><a href="#tcc-in-the-web-browser">1 TCC in the Web Browser</a><ul></ul></li>
<li><a href="#zig-compiles-tcc-to-webassembly">2 Zig compiles TCC to WebAssembly</a><ul></ul></li>
<li><a href="#posix-for-webassembly">3 POSIX for WebAssembly</a><ul></ul></li>
<li><a href="#file-input-and-output">4 File Input and Output</a><ul></ul></li>
<li><a href="#fearsome-fprintf-and-friends">5 Fearsome fprintf and Friends</a><ul></ul></li>
<li><a href="#test-with-apache-nuttx-rtos">6 Test with Apache NuttX RTOS</a><ul></ul></li>
<li><a href="#hello-nuttx">7 Hello NuttX!</a><ul></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-compile-tcc-with-zig">9 Appendix: Compile TCC with Zig</a><ul></ul></li>
<li><a href="#appendix-javascript-calls-tcc">10 Appendix: JavaScript calls TCC</a><ul></ul></li>
<li><a href="#appendix-pattern-matching">11 Appendix: Pattern Matching</a><ul></ul></li>
<li><a href="#appendix-nuttx-system-call">12 Appendix: NuttX System Call</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-qemu">13 Appendix: Build NuttX for QEMU</a><ul></ul></li>
<li><a href="#appendix-missing-functions">14 Appendix: Missing Functions</a><ul></ul></li></ul></nav><p>üìù <em>4 Feb 2024</em></p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-title.png" alt="TCC RISC-V Compiler runs in the Web Browser (thanks to Zig Compiler)"/></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/">(Try the <strong>Online Demo</strong>)</a></p>
<p><a href="https://youtu.be/DJMDYq52Iv8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><em>TCC is a Tiny C Compiler for 64-bit RISC-V (and other platforms)‚Ä¶</em></p>
<p><em>Can we run TCC Compiler in a Web Browser?</em></p>
<p>Let‚Äôs do it! We‚Äôll compile <a href="https://github.com/sellicott/tcc-riscv32"><strong>TCC (Tiny C Compiler)</strong></a> from C to WebAssembly with <a href="https://ziglang.org/"><strong>Zig Compiler</strong></a>.</p>
<p>In this article, we talk about the tricky bits of our <strong>TCC ported to WebAssembly</strong>‚Ä¶</p>
<ul>
<li>
<p>We compiled <strong>TCC to WebAssembly</strong> with one tiny fix</p>
</li>
<li>
<p>But we hit some <strong>Missing POSIX Functions</strong></p>
</li>
<li>
<p>So we built minimal <strong>File Input and Output</strong> </p>
</li>
<li>
<p>Hacked up a simple workaround for <strong>fprintf and friends</strong></p>
</li>
<li>
<p>And TCC produces a <strong>RISC-V Binary</strong> that runs OK</p>
<p>(After some fiddling and meddling in RISC-V Assembly)</p>
</li>
</ul>
<p><em>Why are we doing this?</em></p>
<p>Today we‚Äôre running <a href="https://lupyuen.codeberg.page/articles/tinyemu2"><strong>Apache NuttX RTOS</strong></a> inside a Web Browser, with WebAssembly + Emscripten + 64-bit RISC-V.</p>
<p>(<strong>Real-Time Operating System</strong> in a Web Browser on a General-Purpose Operating System!)</p>
<p>What if we could <strong>Build and Test NuttX Apps</strong> in the Web Browser‚Ä¶</p>
<ol>
<li>
<p>We type a <strong>C Program</strong> into our Web Browser (pic below)</p>
</li>
<li>
<p>Compile it into an <strong>ELF Executable</strong> with TCC</p>
</li>
<li>
<p>Copy the ELF Executable to the <strong>NuttX Filesystem</strong></p>
</li>
<li>
<p>And <strong>NuttX Emulator</strong> runs our ELF Executable inside the Web Browser</p>
</li>
</ol>
<p>Learning NuttX becomes so cool! This is how we made it happen‚Ä¶</p>
<p><a href="https://youtu.be/DJMDYq52Iv8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://research.cs.queensu.ca/home/cordy/pub/downloads/tplus/Turing_Plus_Report.pdf">(Not to be confused with <strong>TTC Compiler</strong>)</a></p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-web.png" alt="Online Demo of TCC Compiler in WebAssembly"/></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><em>Online Demo of TCC Compiler in WebAssembly</em></a></p>

<p>Click this link to try <strong>TCC Compiler in our Web Browser</strong> (pic above)</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><strong>TCC RISC-V Compiler in WebAssembly</strong></a></p>
<p><a href="https://youtu.be/DJMDYq52Iv8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
</li>
</ul>
<p>This <strong>C Program</strong> appears‚Ä¶</p>
<div><pre><code>// Demo Program for TCC Compiler
int main(int argc, char *argv[]) {
  printf(&#34;Hello, World!!\n&#34;);
  return 0;
}
</code></pre></div>
<p>Click the ‚Äú<strong>Compile</strong>‚Äù button. Our Web Browser calls TCC to compile the above program‚Ä¶</p>
<div><pre><code>## Compile to RISC-V ELF
tcc -c hello.c
</code></pre></div>
<p>And it downloads the compiled <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>RISC-V ELF <code>a.out</code></strong></a>. We inspect the Compiled Output‚Ä¶</p>
<div><pre><code>## Dump the RISC-V Disassembly
## of TCC Output
$ riscv64-unknown-elf-objdump \
    --syms --source --reloc --demangle \
    --line-numbers --wide  --debugging \
    a.out

main():
   ## Prepare the Stack
   0: fe010113  addi   sp, sp, -32
   4: 00113c23  sd     ra, 24(sp)
   8: 00813823  sd     s0, 16(sp)
   c: 02010413  addi   s0, sp, 32
  10: 00000013  nop

   ## Load to Register A0: &#34;Hello World&#34;
  14: fea43423  sd     a0, -24(s0)
  18: feb43023  sd     a1, -32(s0)
  1c: 00000517  auipc  a0, 0x0
  1c: R_RISCV_PCREL_HI20 L.0
  20: 00050513  mv     a0, a0
  20: R_RISCV_PCREL_LO12_I .text

   ## Call printf()
  24: 00000097  auipc  ra, 0x0
  24: R_RISCV_CALL_PLT printf
  28: 000080e7  jalr   ra  ## 24 &lt;main+0x24&gt;

   ## Clean up the Stack and
   ## return 0 to Caller
  2c: 0000051b  sext.w a0, zero
  30: 01813083  ld     ra, 24(sp)
  34: 01013403  ld     s0, 16(sp)
  38: 02010113  addi   sp, sp, 32
  3c: 00008067  ret
</code></pre></div>
<p>Yep the <strong>64-bit RISC-V Code</strong> looks legit! Very similar to our <a href="https://lupyuen.codeberg.page/articles/app#inside-a-nuttx-app"><strong>NuttX App</strong></a>. (So it will probably run on NuttX)</p>
<p>What just happened? We go behind the scenes‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/ab8febefa9c649ad7c242ee3f7aaf974">(See the <strong>Entire Disassembly</strong>)</a></p>
<p><a href="https://lupyuen.codeberg.page/articles/app#inside-a-nuttx-app">(About the <strong>RISC-V Instructions</strong>)</a></p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-zig.jpg" alt="Zig Compiler compiles TCC Compiler to WebAssembly"/></p>

<p><em>Will Zig Compiler happily compile TCC to WebAssembly?</em></p>
<p>Amazingly, yes! (Pic above)</p>
<div><pre><code>## Zig Compiler compiles TCC Compiler
## from C to WebAssembly. Produces `tcc.o`
zig cc \
  -c \
  -target wasm32-freestanding \
  -dynamic \
  -rdynamic \
  -lc \
  -DTCC_TARGET_RISCV64 \
  -DCONFIG_TCC_CROSSPREFIX=&#34;\&#34;riscv64-\&#34;&#34;  \
  -DCONFIG_TCC_CRTPREFIX=&#34;\&#34;/usr/riscv64-linux-gnu/lib\&#34;&#34; \
  -DCONFIG_TCC_LIBPATHS=&#34;\&#34;{B}:/usr/riscv64-linux-gnu/lib\&#34;&#34; \
  -DCONFIG_TCC_SYSINCLUDEPATHS=&#34;\&#34;{B}/include:/usr/riscv64-linux-gnu/include\&#34;&#34;   \
  -DTCC_GITHASH=&#34;\&#34;main:b3d10a35\&#34;&#34; \
  -Wall \
  -O2 \
  -Wdeclaration-after-statement \
  -fno-strict-aliasing \
  -Wno-pointer-sign \
  -Wno-sign-compare \
  -Wno-unused-result \
  -Wno-format-truncation \
  -Wno-stringop-truncation \
  -I. \
  tcc.c
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/tcc.c">(See the <strong>TCC Source Code</strong>)</a></p>
<p><a href="https://lupyuen.codeberg.page/articles/tcc#appendix-compile-tcc-with-zig">(About the <strong>Zig Compiler Options</strong>)</a></p>
<p>We link the TCC WebAssembly with our <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig"><strong>Zig Wrapper</strong></a> (that exports the TCC Compiler to JavaScript)‚Ä¶</p>
<div><pre><code>## Compile our Zig Wrapper `tcc-wasm.zig` for WebAssembly
## and link it with TCC compiled for WebAssembly `tcc.o`
## Generates `tcc-wasm.wasm`
zig build-exe \
  -target wasm32-freestanding \
  -rdynamic \
  -lc \
  -fno-entry \
  -freference-trace \
  --verbose-cimport \
  --export=compile_program \
  zig/tcc-wasm.zig \
  tcc.o

## Test everything with Web Browser
## or Node.js
node zig/test.js
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig">(See the <strong>Zig Wrapper tcc-wasm.zig</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test.js">(See the <strong>Test JavaScript test.js</strong>)</a></p>
<p><em>What‚Äôs inside our Zig Wrapper?</em></p>
<p>Our Zig Wrapper will‚Ä¶</p>
<ol>
<li>
<p>Receive the <strong>C Program</strong> from JavaScript</p>
</li>
<li>
<p>Receive the <strong>TCC Compiler Options</strong> from JavaScript</p>
</li>
<li>
<p>Call TCC Compiler to <strong>compile our program</strong></p>
</li>
<li>
<p>Return the compiled <strong>RISC-V ELF</strong> to JavaScript</p>
</li>
</ol>
<p>Like so: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L11-L76">tcc-wasm.zig</a></p>
<div><pre><code>/// Call TCC Compiler to compile a
/// C Program to RISC-V ELF
pub export fn compile_program(
  options_ptr: [*:0]const u8, // Options for TCC Compiler (Pointer to JSON Array:  [&#34;-c&#34;, &#34;hello.c&#34;])
  code_ptr:    [*:0]const u8, // C Program to be compiled (Pointer to String)
) [*]const u8 { // Returns a pointer to the `a.out` Compiled Code (Size in first 4 bytes)

  // Receive the C Program from
  // JavaScript and set our Read Buffer
  // https://blog.battlefy.com/zig-made-it-easy-to-pass-strings-back-and-forth-with-webassembly
  const code: []const u8 = std.mem.span(code_ptr);
  read_buf = code;

  // Omitted: Receive the TCC Compiler
  // Options from JavaScript
  // (JSON containing String Array: [&#34;-c&#34;, &#34;hello.c&#34;])
  ...

  // Call the TCC Compiler
  _ = main(@intCast(argc), &amp;args_ptrs);

  // Return pointer of `a.out` to
  // JavaScript. First 4 bytes: Size of
  // `a.out`. Followed by `a.out` data.
  const slice = std.heap.page_allocator.alloc(u8, write_buflen + 4)   
    catch @panic(&#34;Failed to allocate memory&#34;);
  const size_ptr: *u32 = @alignCast(@ptrCast(slice.ptr));
  size_ptr.* = write_buflen;
  @memcpy(slice[4 .. write_buflen + 4], write_buf[0..write_buflen]);
  return slice.ptr; // TODO: Deallocate this memory
}
</code></pre></div>
<p>Plus a couple of Magical Bits that we‚Äôll cover in the next section.</p>
<p><a href="https://lupyuen.codeberg.page/articles/tcc#appendix-javascript-calls-tcc">(How JavaScript calls our <strong>Zig Wrapper</strong>)</a></p>
<p><em>Zig Compiler compiles TCC without any code changes?</em></p>
<p>Inside TCC, we stubbed out the <a href="https://github.com/lupyuen/tcc-riscv32-wasm/commit/e30454a0eb9916f820d58a7c3e104eeda67988d8"><strong>setjmp / longjmp</strong></a> to make it compile with Zig Compiler.</p>
<p>Everything else compiles OK!</p>
<p><em>Is it really OK to stub them out?</em></p>
<p><a href="https://en.wikipedia.org/wiki/Setjmp.h"><strong>setjmp / longjmp</strong></a> are called to <strong>Handle Errors</strong> during TCC Compilation. Assuming everything goes hunky dory, we won‚Äôt need them.</p>
<p>Later we‚Äôll find a better way to express our outrage. (Instead of jumping around)</p>
<p>We probe the Magical Bits inside our Zig Wrapper‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-posix.jpg" alt="TCC Compiler in WebAssembly needs POSIX Functions"/></p>

<p><em>What‚Äôs this POSIX?</em></p>
<p>TCC Compiler was created as a <strong>Command-Line App</strong>. So it calls the typical <a href="https://en.wikipedia.org/wiki/POSIX"><strong>POSIX Functions</strong></a> like <strong>fopen, fprintf, strncpy, malloc,</strong> ‚Ä¶</p>
<p>But WebAssembly running in a Web Browser ain‚Äôt <strong>No Command Line</strong>! (Pic above)</p>
<p><a href="https://en.wikipedia.org/wiki/C_standard_library">(WebAssembly doesn‚Äôt have a <strong>C Standard Library libc</strong>)</a></p>
<p><em>Is POSIX a problem for WebAssembly?</em></p>
<p>We counted <a href="https://lupyuen.codeberg.page/articles/tcc#appendix-missing-functions"><strong>72 POSIX Functions</strong></a> needed by TCC Compiler, but missing from WebAssembly.</p>
<p>Thus we fill in the <a href="https://lupyuen.codeberg.page/articles/tcc#appendix-missing-functions"><strong>Missing Functions</strong></a> ourselves.</p>
<p><a href="https://lupyuen.codeberg.page/articles/tcc#appendix-missing-functions">(About the <strong>Missing POSIX Functions</strong>)</a></p>
<p><em>Surely other Zig Devs will have the same problem?</em></p>
<p>Thankfully we can borrow the POSIX Code from other <strong>Zig Libraries</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/marler8997/ziglibc"><strong>ziglibc</strong></a>: Zig implementation of libc</p>
</li>
<li>
<p><a href="https://github.com/ZigEmbeddedGroup/foundation-libc"><strong>foundation-libc</strong></a>: Freestanding implementation of libc</p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/articles/lvgl3#appendix-lvgl-memory-allocation"><strong>PinePhone Simulator</strong></a>: For malloc</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L447-L774">(See the <strong>Borrowed Code</strong>)</a></p>
</li>
</ul>
<p><em>72 POSIX Functions? Sounds like a lot of work‚Ä¶</em></p>
<p>We might not need all 72 POSIX Functions. We stubbed out <strong>many of the functions</strong> to identify the ones that are called: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L776-L855">tcc-wasm.zig</a></p>
<div><pre><code>// Stub Out the Missing POSIX
// Functions. If TCC calls them, 
// we&#39;ll see a Zig Panic. Then we 
// implement them. The Types don&#39;t
// matter because we&#39;ll halt anyway.

pub export fn atoi(_: c_int) c_int {
  @panic(&#34;TODO: atoi&#34;);
}
pub export fn exit(_: c_int) c_int {
  @panic(&#34;TODO: exit&#34;);
}
pub export fn fopen(_: c_int) c_int {
  @panic(&#34;TODO: fopen&#34;);
}

// And many more functions...
</code></pre></div>
<p>Some of these functions are especially troubling for WebAssembly‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.codeberg.page/images/tcc-posix2.jpg" alt="File Input and Output are especially troubling for WebAssembly"/></p>
</blockquote>

<p><em>Why no #include in TCC for WebAssembly? And no C Libraries?</em></p>
<p>WebAssembly runs in a Secure Sandbox. <strong>No File Access</strong> allowed, sorry! (Like for Header and Library Files)</p>
<p>That‚Äôs why our Zig Wrapper <strong>Emulates File Access</strong> for the bare minimum 2 files‚Ä¶</p>
<ul>
<li>
<p>Read the <strong>C Program</strong>: <strong><code>hello.c</code></strong></p>
</li>
<li>
<p>Write the <strong>RISC-V ELF</strong>: <strong><code>a.out</code></strong></p>
</li>
</ul>
<p><strong>Reading a Source File <code>hello.c</code></strong> is extremely simplistic: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L104-L118">tcc-wasm.zig</a></p>
<div><pre><code>/// Emulate the POSIX Function `read()`
/// We copy from One Single Read Buffer
/// that contains our C Program
export fn read(fd0: c_int, buf: [*:0]u8, nbyte: size_t) isize {

  // TODO: Support more than one file
  const len = read_buf.len;
  assert(len &lt; nbyte);
  @memcpy(buf[0..len], read_buf[0..len]);
  buf[len] = 0;
  read_buf.len = 0;
  return @intCast(len);
}

/// Read Buffer for read
var read_buf: []const u8 = undefined;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L26-L32">(<strong>read_buf</strong> is populated at startup)</a></p>
<p><strong>Writing the Compiled Output <code>a.out</code></strong> is just as barebones: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L128-L140">tcc-wasm.zig</a></p>
<div><pre><code>/// Emulate the POSIX Function `write()`
/// We write to One Single Memory
/// Buffer that will be returned to 
/// JavaScript as `a.out`
export fn fwrite(ptr: [*:0]const u8, size: usize, nmemb: usize, stream: *FILE) usize {

  // TODO: Support more than one `stream`
  const len = size * nmemb;
  @memcpy(write_buf[write_buflen .. write_buflen + len], ptr[0..]);
  write_buflen += len;
  return nmemb;
}

/// Write Buffer for fputc and fwrite
var write_buf = std.mem.zeroes([8192]u8);
var write_buflen: usize = 0;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L62-L78">(<strong>write_buf</strong> will be returned to JavaScript)</a></p>
<p><em>Can we handle Multiple Files?</em></p>
<p>Right now we‚Äôre trying to embed the simple <a href="https://github.com/lupyuen/tcc-riscv32-wasm#rom-fs-filesystem-for-tcc-webassembly"><strong>ROM FS Filesystem</strong></a> into our Zig Wrapper.</p>
<p>The ROM FS Filesystem will be preloaded with the Header and Library Files needed by TCC.</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#rom-fs-filesystem-for-tcc-webassembly">(See the updates for <strong>ROM FS Filesystem</strong>)</a></p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-format.jpg" alt="Our Zig Wrapper uses Pattern Matching to match the C Formats and substitute the Zig Equivalent"/></p>

<p><em>Why is fprintf particularly problematic?</em></p>
<p>Here‚Äôs the fearsome thing about <strong>fprintf</strong> and friends: <strong>sprintf, snprintf, vsnprintf</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>C Format Strings</strong> are difficult to parse</p>
</li>
<li>
<p><strong>Variable Number of Untyped Arguments</strong> might create Bad Pointers</p>
</li>
</ul>
<p>Hence we hacked up an implementation of <strong>String Formatting</strong> that‚Äôs safer, simpler and so-barebones-you-can-make-<em>soup-tulang</em>.</p>
<p><em>Soup tulang? Tell me more‚Ä¶</em></p>
<p>Our Zig Wrapper uses <a href="https://lupyuen.codeberg.page/articles/tcc#appendix-pattern-matching"><strong>Pattern Matching</strong></a> to match the <strong>C Formats</strong> and substitute the <strong>Zig Equivalent</strong> (pic above): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L189-L207">tcc-wasm.zig</a></p>
<div><pre><code>// Format a Single `%d`
// like `#define __TINYC__ %d`
FormatPattern{

  // If the C Format String contains this...
  .c_spec = &#34;%d&#34;,
  
  // Then we apply this Zig Format...
  .zig_spec = &#34;{}&#34;,
  
  // And extract these Argument Types
  // from the Varargs...
  .type0 = c_int,
  .type1 = null
}
</code></pre></div>
<p>This works OK (for now) because TCC Compiler only uses <strong>5 Patterns for C Format Strings</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L189-L207">tcc-wasm.zig</a></p>
<div><pre><code>/// Pattern Matching for C String Formatting:
/// We&#39;ll match these patterns when
/// formatting strings
const format_patterns = [_]FormatPattern{

  // Format a Single `%d`, like `#define __TINYC__ %d`
  FormatPattern{
    .c_spec = &#34;%d&#34;,  .zig_spec = &#34;{}&#34;, 
    .type0  = c_int, .type1 = null
  },

  // Format a Single `%u`, like `L.%u`
  FormatPattern{ 
    .c_spec = &#34;%u&#34;,  .zig_spec = &#34;{}&#34;, 
    .type0  = c_int, .type1 = null 
  },

  // Format a Single `%s`, like `.rela%s`
  // Or `#define __BASE_FILE__ &#34;%s&#34;`
  FormatPattern{
    .c_spec = &#34;%s&#34;, .zig_spec = &#34;{s}&#34;,
    .type0  = [*:0]const u8, .type1 = null
  },

  // Format Two `%s`, like `#define %s%s\n`
  FormatPattern{
    .c_spec = &#34;%s%s&#34;, .zig_spec = &#34;{s}{s}&#34;,
    .type0  = [*:0]const u8, .type1 = [*:0]const u8
  },

  // Format `%s:%d`, like `%s:%d: `
  // (File Name and Line Number)
  FormatPattern{
    .c_spec = &#34;%s:%d&#34;, .zig_spec = &#34;{s}:{}&#34;,
    .type0  = [*:0]const u8, .type1 = c_int
  },
};
</code></pre></div>
<p>That‚Äôs our quick hack for <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L209-L447"><strong>fprintf and friends</strong></a>!</p>
<p><a href="https://lupyuen.codeberg.page/articles/tcc#appendix-pattern-matching">(How we do <strong>Pattern Matching</strong>)</a></p>
<p><em>So simple? Unbelievable!</em></p>
<p>Actually we‚Äôll hit more Format Patterns as TCC Compiler emits various <strong>Error and Warning Messages</strong>. But it‚Äôs a good start!</p>
<p>Later our Zig Wrapper shall cautiously and meticulously parse all kinds of C Format Strings. Or we do the <a href="https://github.com/marler8997/ziglibc/blob/main/src/printf.c#L32-L191"><strong>parsing in C</strong></a>, compiled to WebAssembly. (160 lines of C!)</p>
<p>(Funny how <strong>printf</strong> is the first thing we learn about C. Yet it‚Äôs incredibly difficult to implement!)</p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-nuttx.jpg" alt="Compile and Run NuttX Apps in the Web Browser"/></p>

<p><em>TCC in WebAssembly has compiled our C Program to RISC-V ELF‚Ä¶</em></p>
<p><em>Will the ELF run on NuttX?</em></p>
<p><a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> is a tiny operating system for 64-bit RISC-V that runs on <a href="https://www.qemu.org/docs/master/system/target-riscv.html"><strong>QEMU Emulator</strong></a>. (And many other devices)</p>
<p>We build <a href="https://lupyuen.codeberg.page/articles/tcc#appendix-build-nuttx-for-qemu"><strong>NuttX for QEMU</strong></a> and copy our <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>RISC-V ELF <code>a.out</code></strong></a> to the <a href="https://lupyuen.codeberg.page/articles/semihost#nuttx-apps-filesystem"><strong>NuttX Apps Filesystem</strong></a> (pic above)‚Ä¶</p>
<div><pre><code>## Copy RISC-V ELF `a.out`
## to NuttX Apps Filesystem
cp a.out apps/bin/
chmod +x apps/bin/a.out
</code></pre></div>
<p><a href="https://lupyuen.codeberg.page/articles/tcc#appendix-build-nuttx-for-qemu">(How we build <strong>NuttX for QEMU</strong>)</a></p>
<p>Then we boot NuttX and run <strong><code>a.out</code></strong>‚Ä¶</p>
<div><pre><code>## Boot NuttX on QEMU 64-bit RISC-V
$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run `a.out` in NuttX Shell
NuttShell (NSH) NuttX-12.4.0
nsh&gt; a.out
Loading /system/bin/a.out
Exported symbol &#34;printf&#34; not found
Failed to load program &#39;a.out&#39;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#test-tcc-output-with-nuttx">(See the <strong>Complete Log</strong>)</a></p>
<p>NuttX politely accepts the RISC-V ELF (produced by TCC). And says that <strong>printf</strong> is missing.</p>
<p>Which makes sense: We haven‚Äôt linked our C Program with the <a href="https://github.com/lupyuen/tcc-riscv32-wasm#how-nuttx-build-links-a-nuttx-app"><strong>C Library</strong></a>!</p>
<p><a href="https://gist.github.com/lupyuen/847f7adee50499cac5212f2b95d19cd3#file-nuttx-elf-loader-log-L882-L1212">(Loading a <strong>RISC-V ELF</strong> should look like this)</a></p>
<p><em>How else can we print something in NuttX?</em></p>
<p>To print something, we can make a <a href="https://lupyuen.codeberg.page/articles/app#nuttx-app-calls-nuttx-kernel"><strong>System Call (ECALL)</strong></a> directly to NuttX Kernel (bypassing the POSIX Functions)‚Ä¶</p>
<div><pre><code>// NuttX System Call that prints
// something. System Call Number
// is 61 (SYS_write). Works exactly
// like POSIX `write()`
ssize_t write(
  int fd,           // File Descriptor (1 for Standard Output)
  const char *buf,  // Buffer to be printed
  size_t buflen     // Buffer Length
);

// Which makes an ECALL with these Parameters...
// Register A0 is 61 (SYS_write)
// Register A1 is the File Descriptor (1 for Standard Output)
// Register A2 points to the String Buffer to be printed
// Register A3 is the Buffer Length
</code></pre></div>
<p>That‚Äôs the same NuttX System Call that <strong>printf</strong> executes internally.</p>
<p>Final chance to say hello to NuttX‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-ecall.png" alt="TCC WebAssembly compiles a NuttX System Call"/></p>

<p><em>We‚Äôre making a System Call (ECALL) to NuttX Kernel to print something‚Ä¶</em></p>
<p><em>How will we code this in C?</em></p>
<p>We execute the <a href="https://lupyuen.codeberg.page/articles/app#nuttx-app-calls-nuttx-kernel"><strong>ECALL in RISC-V Assembly</strong></a> like this: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test-nuttx.js#L52-L105">test-nuttx.js</a></p>
<div><pre><code>int main(int argc, char *argv[]) {

  // Make NuttX System Call
  // to write(fd, buf, buflen)
  const unsigned int nbr = 61; // SYS_write
  const void *parm1 = 1;       // File Descriptor (stdout)
  const void *parm2 = &#34;Hello, World!!\n&#34;; // Buffer
  const void *parm3 = 15; // Buffer Length

  // Load the Parameters into
  // Registers A0 to A3
  // Note: This doesn&#39;t work with TCC,
  // so we load again below
  register long r0 asm(&#34;a0&#34;) = (long)(nbr);
  register long r1 asm(&#34;a1&#34;) = (long)(parm1);
  register long r2 asm(&#34;a2&#34;) = (long)(parm2);
  register long r3 asm(&#34;a3&#34;) = (long)(parm3);

  // Execute ECALL for System Call
  // to NuttX Kernel. Again: Load the
  // Parameters into Registers A0 to A3
  asm volatile (

    // Load 61 to Register A0 (SYS_write)
    &#34;addi a0, zero, 61 \n&#34;
    
    // Load 1 to Register A1 (File Descriptor)
    &#34;addi a1, zero, 1 \n&#34;
    
    // Load 0xc0101000 to Register A2 (Buffer)
    &#34;lui   a2, 0xc0 \n&#34;
    &#34;addiw a2, a2, 257 \n&#34;
    &#34;slli  a2, a2, 0xc \n&#34;
    
    // Load 15 to Register A3 (Buffer Length)
    &#34;addi a3, zero, 15 \n&#34;
    
    // ECALL for System Call to NuttX Kernel
    &#34;ecall \n&#34;
    
    // NuttX needs NOP after ECALL
    &#34;.word 0x0001 \n&#34;

    // Input+Output Registers: None
    // Input-Only Registers: A0 to A3
    // Clobbers the Memory
    :
    : &#34;r&#34;(r0), &#34;r&#34;(r1), &#34;r&#34;(r2), &#34;r&#34;(r3)
    : &#34;memory&#34;
  );

  // Loop Forever
  for(;;) {}
  return 0;
}
</code></pre></div>
<p>We copy this into our Web Browser and compile it. (Pic above)</p>
<p><a href="https://lupyuen.codeberg.page/articles/tcc#appendix-nuttx-system-call">(Why so complicated? <strong>Explained here</strong>)</a></p>
<p><a href="https://lupyuen.codeberg.page/articles/app#nuttx-kernel-handles-system-call">(Caution: <strong>SYS_write 61</strong> may change)</a></p>
<p><em>Does it work?</em></p>
<p>TCC in WebAssembly compiles the code above to <strong>RISC-V ELF <code>a.out</code></strong>. When we copy it to NuttX and run it‚Ä¶</p>
<div><pre><code>NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; a.out
...
## NuttX System Call for SYS_write (61)
riscv_swint:
  cmd: 61
  A0:  3d  ## SYS_write (61)
  A1:  01  ## File Descriptor (Standard Output)
  A2:  c0101000  ## Buffer
  A3:  0f        ## Buffer Length
...
## NuttX Kernel says hello
Hello, World!!
</code></pre></div>
<p>NuttX Kernel prints <strong>‚ÄúHello World‚Äù</strong> yay!</p>
<p>Indeed we‚Äôve created a C Compiler in a Web Browser, that <strong>produces proper NuttX Apps</strong>!</p>
<p><em>OK so we can build NuttX Apps in a Web Browser‚Ä¶ But can we run them in a Web Browser?</em></p>
<p>Yep, a NuttX App built in the Web Browser‚Ä¶ Now runs OK with <strong>NuttX Emulator in the Web Browser</strong>! üéâ (Pic below)</p>
<ul>
<li>
<p><a href="https://youtu.be/DJMDYq52Iv8">Watch the <strong>Demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#nuttx-app-runs-in-a-web-browser">Find out <strong>How It Works</strong></a></p>
</li>
</ul>
<p><strong>TLDR:</strong> We called <a href="https://github.com/lupyuen/tcc-riscv32-wasm#nuttx-app-runs-in-a-web-browser"><strong>JavaScript Local Storage</strong></a>
to copy the RISC-V ELF <code>a.out</code> from TCC WebAssembly to NuttX Emulator‚Ä¶ Then we patched <code>a.out</code> into the <a href="https://github.com/lupyuen/tcc-riscv32-wasm#nuttx-app-runs-in-a-web-browser"><strong>ROM FS Filesystem</strong></a> for NuttX Emulator. Nifty!</p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-emu2.png" alt="NuttX App built in a Web Browser‚Ä¶ Runs inside the Web Browser!"/></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#nuttx-app-runs-in-a-web-browser"><em>NuttX App built in a Web Browser‚Ä¶ Runs inside the Web Browser!</em></a></p>

<p>Thanks to the <a href="https://github.com/sellicott/tcc-riscv32"><strong>TCC Team</strong></a>, we have a <strong>64-bit RISC-V Compiler</strong> that runs in the Web Browser‚Ä¶</p>
<ul>
<li>
<p><strong>Zig Compiler</strong> compiles TCC to WebAssembly with one tiny fix</p>
</li>
<li>
<p>But <strong>POSIX Functions</strong> are missing in WebAssembly</p>
</li>
<li>
<p>So we did the bare minimum for <strong>File Input and Output</strong> </p>
</li>
<li>
<p>And cooked up the simplest workaround for <strong>fprintf and friends</strong></p>
</li>
<li>
<p>Finally TCC produces a <strong>RISC-V Binary</strong> that runs OK on Apache NuttX RTOS</p>
</li>
<li>
<p>Now we can <strong>Build and Test NuttX Apps</strong> all within a Web Browser!</p>
</li>
</ul>
<p>How will you use <strong>TCC in a Web Browser</strong>? Please lemme know üôè</p>
<p><em>(Build and run RISC-V Apps on iPhone?)</em></p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX and Zig Communities) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=39245664"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tcc.md"><strong>lupyuen.github.io/src/tcc.md</strong></a></p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-web.png" alt="Online Demo of TCC Compiler in WebAssembly"/></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><em>Online Demo of TCC Compiler in WebAssembly</em></a></p>

<p>This is how we run <strong>Zig Compiler to compile TCC Compiler</strong> from C to WebAssembly (pic below)‚Ä¶</p>
<div><pre><code>## Download the (slightly) Modified TCC Source Code.
## Configure the build for 64-bit RISC-V.

git clone https://github.com/lupyuen/tcc-riscv32-wasm
cd tcc-riscv32-wasm
./configure
make cross-riscv64

## Call Zig Compiler to compile TCC Compiler
## from C to WebAssembly. Produces `tcc.o`

## Omitted: Run the `zig cc` command from earlier...
## https://lupyuen.codeberg.page/articles/tcc#zig-compiles-tcc-to-webassembly
zig cc ...

## Compile our Zig Wrapper `tcc-wasm.zig` for WebAssembly
## and link it with TCC compiled for WebAssembly `tcc.o`
## Generates `tcc-wasm.wasm`

## Omitted: Run the `zig build-exe` command from earlier...
## https://lupyuen.codeberg.page/articles/tcc#zig-compiles-tcc-to-webassembly
zig build-exe ...
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/build.sh">(See the <strong>Build Script</strong>)</a></p>
<p><em>How did we figure out the ‚Äú<code>zig</code> <code>cc</code>‚Äù options?</em></p>
<p>Earlier we saw a long list of <a href="https://lupyuen.codeberg.page/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Compiler Options</strong></a>‚Ä¶</p>
<div><pre><code>## Zig Compiler Options for TCC Compiler
zig cc \
  tcc.c \
  -DTCC_TARGET_RISCV64 \
  -DCONFIG_TCC_CROSSPREFIX=&#34;\&#34;riscv64-\&#34;&#34;  \
  -DCONFIG_TCC_CRTPREFIX=&#34;\&#34;/usr/riscv64-linux-gnu/lib\&#34;&#34; \
  -DCONFIG_TCC_LIBPATHS=&#34;\&#34;{B}:/usr/riscv64-linux-gnu/lib\&#34;&#34; \
  -DCONFIG_TCC_SYSINCLUDEPATHS=&#34;\&#34;{B}/include:/usr/riscv64-linux-gnu/include\&#34;&#34;   \
  ...
</code></pre></div>
<p>We got them from ‚Äú<strong><code>make</code> <code>--trace</code></strong>‚Äù, which reveals the <strong>GCC Compiler Options</strong>‚Ä¶</p>
<div><pre><code>## Show the GCC Options for compiling TCC
$ make --trace cross-riscv64

gcc \
  -o riscv64-tcc.o \
  -c \
  tcc.c \
  -DTCC_TARGET_RISCV64 \
  -DCONFIG_TCC_CROSSPREFIX=&#34;\&#34;riscv64-\&#34;&#34;  \
  -DCONFIG_TCC_CRTPREFIX=&#34;\&#34;/usr/riscv64-linux-gnu/lib\&#34;&#34; \
  -DCONFIG_TCC_LIBPATHS=&#34;\&#34;{B}:/usr/riscv64-linux-gnu/lib\&#34;&#34; \
  -DCONFIG_TCC_SYSINCLUDEPATHS=&#34;\&#34;{B}/include:/usr/riscv64-linux-gnu/include\&#34;&#34;   \
  -DTCC_GITHASH=&#34;\&#34;main:b3d10a35\&#34;&#34; \
  -Wall \
  -O2 \
  -Wdeclaration-after-statement \
  -fno-strict-aliasing \
  -Wno-pointer-sign \
  -Wno-sign-compare \
  -Wno-unused-result \
  -Wno-format-truncation \
  -Wno-stringop-truncation \
  -I. 
</code></pre></div>
<p>And we copied above GCC Options to become our <a href="https://lupyuen.codeberg.page/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Compiler Options</strong></a>.</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/build.sh">(See the <strong>Build Script</strong>)</a></p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-zig.jpg" alt="Zig Compiler compiles TCC Compiler to WebAssembly"/></p>

<p>Previously we saw some <strong>JavaScript (Web Browser and Node.js)</strong> calling our TCC Compiler in WebAssembly (pic above)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><strong>TCC WebAssembly in Web Browser</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>TCC WebAssembly in Node.js</strong></a></p>
</li>
</ul>
<p>This is how we test the TCC WebAssembly in a Web Browser with a <strong>Local Web Server</strong>‚Ä¶</p>
<div><pre><code>## Download the (slightly) Modified TCC Source Code
git clone https://github.com/lupyuen/tcc-riscv32-wasm
cd tcc-riscv32-wasm

## Start the Web Server
cargo install simple-http-server
simple-http-server ./docs &amp;

## Whenever we rebuild TCC WebAssembly...
## Copy it to the Web Server
cp tcc-wasm.wasm docs/
</code></pre></div>
<p>Browse to this URL and our TCC WebAssembly will appear‚Ä¶</p>
<div><pre><code>## Test TCC WebAssembly with Web Browser
http://localhost:8000/index.html
</code></pre></div>
<p>Check the <strong>JavaScript Console</strong> for Debug Messages.</p>
<p><a href="https://gist.github.com/lupyuen/5f8191d5c63b7dba030582cbe7481572">(See the <strong>JavaScript Log</strong>)</a></p>
<p><em>How does it work?</em></p>
<p>On clicking the <strong>Compile Button</strong>, our JavaScript loads the TCC WebAssembly: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L174-L191">tcc.js</a></p>
<div><pre><code>// Load the WebAssembly Module and start the Main Function.
// Called by the Compile Button.
async function bootstrap() {

  // Load the WebAssembly Module `tcc-wasm.wasm`
  // https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming
  const result = await WebAssembly.instantiateStreaming(
    fetch(&#34;tcc-wasm.wasm&#34;),
    importObject
  );

  // Store references to WebAssembly Functions
  // and Memory exported by Zig
  wasm.init(result);

  // Start the Main Function
  window.requestAnimationFrame(main);
}        
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L25-L48">(<strong>importObject</strong> exports our <strong>JavaScript Logger</strong> to Zig)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L6-L25">(<strong>wasm</strong> is our <strong>WebAssembly Helper</strong>)</a></p>
<p>Which triggers the <strong>Main Function</strong> and calls our Zig Function <strong>compile_program</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L48-L90">tcc.js</a></p>
<div><pre><code>// Main Function
function main() {
  // Allocate a String for passing the Compiler Options to Zig
  // `options` is a JSON Array: [&#34;-c&#34;, &#34;hello.c&#34;]
  const options = read_options();
  const options_ptr = allocateString(JSON.stringify(options));
  
  // Allocate a String for passing the Program Code to Zig
  const code = document.getElementById(&#34;code&#34;).value;
  const code_ptr = allocateString(code);

  // Call TCC to compile the program
  const ptr = wasm.instance.exports
    .compile_program(options_ptr, code_ptr);

  // Get the `a.out` size from first 4 bytes returned
  const memory = wasm.instance.exports.memory;
  const data_len = new Uint8Array(memory.buffer, ptr, 4);
  const len = data_len[0] | data_len[1] &lt;&lt; 8 | data_len[2] &lt;&lt; 16 | data_len[3] &lt;&lt; 24;
  if (len &lt;= 0) { return; }

  // Encode the `a.out` data from the rest of the bytes returned
  // `encoded_data` looks like %7f%45%4c%46...
  const data = new Uint8Array(memory.buffer, ptr + 4, len);
  let encoded_data = &#34;&#34;;
  for (const i in data) {
    const hex = Number(data[i]).toString(16).padStart(2, &#34;0&#34;);
    encoded_data += `%${hex}`;
  }

  // Download the `a.out` data into the Web Browser
  download(&#34;a.out&#34;, encoded_data);

  // Save the ELF Data to Local Storage for loading by NuttX Emulator
  localStorage.setItem(&#34;elf_data&#34;, encoded_data);
};
</code></pre></div>
<p>Our Main Function then downloads the <strong><code>a.out</code></strong> file returned by our Zig Function.</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L90-L112">(<strong>allocateString</strong> allocates a String from Zig Memory)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L162-L174">(<strong>download</strong> is here)</a></p>
<p><em>What about Node.js calling TCC WebAssembly?</em></p>
<div><pre><code>## Test TCC WebAssembly with Node.js
node zig/test.js
</code></pre></div>
<p><strong>For Easier Testing</strong> (via Command-Line): We copied the JavaScript above into a Node.js Script: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test.js#L46-L78">test.js</a></p>
<div><pre><code>// Allocate a String for passing the Compiler Options to Zig
const options = [&#34;-c&#34;, &#34;hello.c&#34;];
const options_ptr = allocateString(JSON.stringify(options));

// Allocate a String for passing Program Code to Zig
const code_ptr = allocateString(`
  int main(int argc, char *argv[]) {
    printf(&#34;Hello, World!!\\n&#34;);
    return 0;
  }
`);

// Call TCC to compile a program
const ptr = wasm.instance.exports
  .compile_program(options_ptr, code_ptr);
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/795327506cad9b1ee82206e614c399cd">(See the <strong>Node.js Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test-nuttx.js">(Test Script for NuttX QEMU: <strong>test-nuttx.js</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/55a4d4cae26994aa673e6d8451716b27">(Test Log for NuttX QEMU: <strong>test-nuttx.log</strong>)</a></p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-format.jpg" alt="Our Zig Wrapper doing Pattern Matching for Formatting C Strings"/></p>

<p>A while back we saw our Zig Wrapper doing <strong>Pattern Matching</strong> for Formatting C Strings‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.codeberg.page/articles/tcc#fearsome-fprintf-and-friends"><strong>‚ÄúFearsome fprintf and Friends‚Äù</strong></a></li>
</ul>
<p>How It Works: We search for <strong>Format Patterns</strong> in the C Format Strings and substitute the <strong>Zig Equivalent</strong> (pic above): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L189-L207">tcc-wasm.zig</a></p>
<div><pre><code>// Format a Single `%d`
// like `#define __TINYC__ %d`
FormatPattern{

  // If the C Format String contains this...
  .c_spec = &#34;%d&#34;,
  
  // Then we apply this Zig Format...
  .zig_spec = &#34;{}&#34;,
  
  // And extract these Argument Types
  // from the Varargs...
  .type0 = c_int,
  .type1 = null
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L438-L446">(<strong>FormatPattern</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L191-L209">(See the <strong>Format Patterns</strong>)</a></p>
<p>To implement this, we call <strong>comptime Functions</strong> in Zig: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L276-L327">tcc-wasm.zig</a></p>
<div><pre><code>/// CompTime Function to format a string by Pattern Matching.
/// Format a Single Specifier, like `#define __TINYC__ %d\n`
/// If the Spec matches the Format: Return the number of bytes written to `str`, excluding terminating null.
/// Else return 0.
fn format_string1(
  ap: *std.builtin.VaList,  // Varargs passed from C
  str:    [*]u8,            // Buffer for returning Formatted String
  size:   size_t,           // Buffer Size
  format: []const u8,       // C Format String, like `#define __TINYC__ %d\n`
  comptime c_spec:   []const u8,  // C Format Pattern, like `%d`
  comptime zig_spec: []const u8,  // Zig Equivalent, like `{}`
  comptime T0:       type,        // Type of First Vararg, like `c_int`
) usize {  // Return the number of bytes written to `str`, excluding terminating null

  // Count the Format Specifiers: `%`
  const spec_cnt   = std.mem.count(u8, c_spec, &#34;%&#34;);
  const format_cnt = std.mem.count(u8, format, &#34;%&#34;);

  // Check the Format Specifiers: `%`
  // Quit if the number of specifiers are different
  // Or if the specifiers are not found
  if (format_cnt != spec_cnt or
      !std.mem.containsAtLeast(u8, format, 1, c_spec)) {
    return 0;
  }

  // Fetch the First Argument from the C Varargs
  const a = @cVaArg(ap, T0);

  // Format the Argument
  var buf: [512]u8 = undefined;
  const buf_slice = std.fmt.bufPrint(&amp;buf, zig_spec, .{a}) catch {
    @panic(&#34;format_string1 error: buf too small&#34;);
  };

  // Replace the C Format Pattern by the Zig Equivalent
  var buf2 = std.mem.zeroes([512]u8);
  _ = std.mem.replace(u8, format, c_spec, buf_slice, &amp;buf2);

  // Return the Formatted String and Length
  const len = std.mem.indexOfScalar(u8, &amp;buf2, 0).?;
  assert(len &lt; size);
  @memcpy(str[0..len], buf2[0..len]);
  str[len] = 0;
  return len;
}

// Omitted: Function `format_string2` looks similar,
// but for 2 Varargs (instead of 1)
</code></pre></div>
<p>The function above is called by a <strong>comptime Inline Loop</strong> that applies all the <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L191-L209"><strong>Format Patterns</strong></a> that we saw earlier: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L207-L251">tcc-wasm.zig</a></p>
<div><pre><code>/// Runtime Function to format a string by Pattern Matching.
/// Return the number of bytes written to `str`, excluding terminating null.
fn format_string(
  ap: *std.builtin.VaList,  // Varargs passed from C
  str:    [*]u8,            // Buffer for returning Formatted String
  size:   size_t,           // Buffer Size
  format: []const u8,       // C Format String, like `#define __TINYC__ %d\n`
) usize {  // Return the number of bytes written to `str`, excluding terminating null

  // If no Format Specifiers: Return the Format, like `warning: `
  const len = format_string0(str, size, format);
  if (len &gt; 0) { return len; }

  // For every Format Pattern...
  inline for (format_patterns) |pattern| {

    // Try formatting the string with the pattern...
    const len2 =
      if (pattern.type1) |t1|
      // Pattern has 2 parameters
      format_string2(ap, str, size, format, // Output String and Format String
        pattern.c_spec, pattern.zig_spec,   // Format Specifiers for C and Zig
        pattern.type0, t1 // Types of the Parameters
      )
    else
      // Pattern has 1 parameter
      format_string1(ap, str, size, format, // Output String and Format String
        pattern.c_spec, pattern.zig_spec,   // Format Specifiers for C and Zig
        pattern.type0 // Type of the Parameter
      );

    // Loop until we find a match pattern
    if (len2 &gt; 0) { return len2; }
  }

  // Format String doesn&#39;t match any Format Pattern.
  // We return the Format String and Length.
  const len3 = format.len;
  assert(len3 &lt; size);
  @memcpy(str[0..len3], format[0..len3]);
  str[len3] = 0;
  return len3;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L327-L382">(<strong>format_string2</strong> is here)</a></p>
<p>And the above function is called by <strong>fprintf and friends</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L382-L438">tcc-wasm.zig</a></p>
<div><pre><code>/// Implement the POSIX Function `fprintf`
export fn fprintf(stream: *FILE, format: [*:0]const u8, ...) c_int {

  // Prepare the varargs
  var ap = @cVaStart();
  defer @cVaEnd(&amp;ap);

  // Format the string
  var buf = std.mem.zeroes([512]u8);
  const format_slice = std.mem.span(format);
  const len = format_string(&amp;ap, &amp;buf, buf.len, format_slice);

  // TODO: Print to other File Streams.
  // Right now we assume it&#39;s stderr (File Descriptor 2)
  return @intCast(len);
}

// Do the same for sprintf, snprintf, vsnprintf
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/3e650bd6ad72b2e8ee8596858bc94f36">(See the <strong>Formatting Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#fix-the-varargs-functions">(Without <strong>comptime</strong>: Our code gets <strong>super tedious</strong>)</a></p>
<p><img src="https://lupyuen.codeberg.page/images/app-syscall.jpg" alt="NuttX Apps make a System Call to print to the console"/></p>

<p>Just now we saw a huge chunk of C Code that makes a <strong>NuttX System Call</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.codeberg.page/articles/tcc#hello-nuttx"><strong>‚ÄúHello NuttX!‚Äù</strong></a></li>
</ul>
<p><em>Why so complicated?</em></p>
<p>We refer to the Sample Code for <a href="https://lupyuen.codeberg.page/articles/app#nuttx-app-calls-nuttx-kernel"><strong>NuttX System Calls (ECALL)</strong></a>. Rightfully this <strong>shorter version</strong> should work‚Ä¶</p>
<div><pre><code>// Make NuttX System Call to write(fd, buf, buflen)
const unsigned int nbr = 61; // SYS_write
const void *parm1 = 1;       // File Descriptor (stdout)
const void *parm2 = &#34;Hello, World!!\n&#34;; // Buffer
const void *parm3 = 15; // Buffer Length

// Execute ECALL for System Call to NuttX Kernel
register long r0 asm(&#34;a0&#34;) = (long)(nbr);
register long r1 asm(&#34;a1&#34;) = (long)(parm1);
register long r2 asm(&#34;a2&#34;) = (long)(parm2);
register long r3 asm(&#34;a3&#34;) = (long)(parm3);

asm volatile (
  // ECALL for System Call to NuttX Kernel
  &#34;ecall \n&#34;

  // NuttX needs NOP after ECALL
  &#34;.word 0x0001 \n&#34;

  // Input+Output Registers: None
  // Input-Only Registers: A0 to A3
  // Clobbers the Memory
  :
  : &#34;r&#34;(r0), &#34;r&#34;(r1), &#34;r&#34;(r2), &#34;r&#34;(r3)
  : &#34;memory&#34;
);
</code></pre></div>
<p>Strangely TCC generates <a href="https://github.com/lupyuen/tcc-riscv32-wasm#ecall-for-nuttx-system-call"><strong>mysterious RISC-V Machine Code</strong></a> that mashes up the RISC-V Registers‚Ä¶</p>
<div><pre><code>main():
// Prepare the Stack
   0:  fc010113  add     sp, sp, -64
   4:  02113c23  sd      ra, 56(sp)
   8:  02813823  sd      s0, 48(sp)
   c:  04010413  add     s0, sp, 64
  10:  00000013  nop
  14:  fea43423  sd      a0, -24(s0)
  18:  feb43023  sd      a1, -32(s0)

// Correct: Load Register A0 with 61 (SYS_write)
  1c:  03d0051b  addw    a0, zero, 61
  20:  fca43c23  sd      a0, -40(s0)

// Nope: Load Register A0 with 1?
// Mixed up with Register A1! (Value 1)
  24:  0010051b  addw    a0, zero, 1
  28:  fca43823  sd      a0, -48(s0)

// Nope: Load Register A0 with &#34;Hello World&#34;?
// Mixed up with Register A2!
  2c:  00000517  auipc   a0,0x0  2c: R_RISCV_PCREL_HI20  L.0
  30:  00050513  mv      a0,a0   30: R_RISCV_PCREL_LO12_I        .text
  34:  fca43423  sd      a0, -56(s0)

// Nope: Load Register A0 with 15?
// Mixed up with Register A3! (Value 15)
  38:  00f0051b  addw    a0, zero, 15
  3c:  fca43023  sd      a0, -64(s0)

// Execute ECALL with Register A0 set to 15.
// Nope: A0 should be 61!
  40:  00000073  ecall
  44:  0001      nop
</code></pre></div>
<p>Thus we <a href="https://github.com/lupyuen/tcc-riscv32-wasm#ecall-for-nuttx-system-call"><strong>hardcode Registers A0 to A3</strong></a> in RISC-V Assembly: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test-nuttx.js#L55-L97">test-nuttx.js</a></p>
<div><pre><code>// Load 61 to Register A0 (SYS_write)
addi  a0, zero, 61

// Load 1 to Register A1 (File Descriptor)
addi  a1, zero, 1

// Load 0xc0101000 to Register A2 (Buffer)
lui   a2, 0xc0
addiw a2, a2, 257
slli  a2, a2, 0xc

// Load 15 to Register A3 (Buffer Length)
addi  a3, zero, 15

// ECALL for System Call to NuttX Kernel
ecall

// NuttX needs NOP after ECALL
.word 0x0001
</code></pre></div>
<p>And it prints ‚ÄúHello World‚Äù!</p>
<p><strong>TODO:</strong> Is there a workaround? Do we paste the ECALL Assembly Code ourselves? <a href="https://github.com/lupyuen/tcc-riscv32-wasm#fix-missing-printf-in-nuttx-app"><strong>NuttX Libraries</strong></a> won‚Äôt link with TCC</p>
<p><a href="https://gist.github.com/lupyuen/55a4d4cae26994aa673e6d8451716b27">(See the <strong>TCC WebAssembly Log</strong>)</a></p>
<p><em>What‚Äôs with the <code>addi</code> and <code>nop</code>?</em></p>
<p>TCC won‚Äôt assemble the ‚Äú<strong><code>li</code></strong>‚Äù and ‚Äú<strong><code>nop</code></strong>‚Äù instructions.</p>
<p>So we used this <a href="https://riscvasm.lucasteske.dev/#"><strong>RISC-V Online Assembler</strong></a> to assemble the code above.</p>
<p>‚Äú<strong><code>addi</code></strong>‚Äù above is the longer form of ‚Äú<strong><code>li</code></strong>‚Äù, which TCC won‚Äôt assemble‚Ä¶</p>
<div><pre><code>// Load 61 to Register A0 (SYS_write)
// But TCC won&#39;t assemble `li a0, 61`
// So we do this...

// Add 0 to 61 and save to Register A0
addi a0, zero, 61
</code></pre></div>
<p>‚Äú<strong><code>lui / addiw / slli</code></strong>‚Äù above is our expansion of ‚Äú<strong><code>li a2, 0xc0101000</code></strong>‚Äù, which TCC won‚Äôt assemble‚Ä¶</p>
<div><pre><code>// Load 0xC010_1000 to Register A2 (Buffer)
// But TCC won&#39;t assemble `li a2, 0xc0101000`
// So we do this...

// Load 0xC0 &lt;&lt; 12 into Register A2 (0xC0000)
lui   a2, 0xc0

// Add 257 to Register A2 (0xC0101)
addiw a2, a2, 257

// Shift Left by 12 Bits (0xC010_1000)
slli  a2, a2, 0xc
</code></pre></div>
<p><em>How did we figure out that the buffer is at 0xC010_1000?</em></p>
<p>We saw this in our <a href="https://gist.github.com/lupyuen/a715e4e77c011d610d0b418e97f8bf5d#file-nuttx-tcc-app-log-L32-L42"><strong>ELF Loader Log</strong></a>‚Ä¶</p>
<div><pre><code>NuttShell (NSH) NuttX-12.4.0
nsh&gt; a.out
...
Read 576 bytes from offset 512
Read 154 bytes from offset 64
1. 00000000-&gt;c0000000
Read 0 bytes from offset 224
2. 00000000-&gt;c0101000
Read 16 bytes from offset 224
3. 00000000-&gt;c0101000
4. 00000000-&gt;c0101010
</code></pre></div>
<p>Which says that the NuttX ELF Loader copied 16 bytes from our NuttX App Data Section (<strong><code>.data.ro</code></strong>) to <strong><code>0xC010_1000</code></strong>.</p>
<p>That‚Äôs all 15 bytes of <em>‚ÄúHello, World!!\n‚Äù</em>, including the terminating null.</p>
<p>Thus our buffer in NuttX QEMU should be at <strong><code>0xC010_1000</code></strong>.</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#nuttx-app-runs-in-a-web-browser">(<strong>NuttX WebAssembly Emulator</strong> uses <strong><code>0x8010_1000</code></strong> instead)</a></p>
<p><a href="https://lupyuen.codeberg.page/articles/app#kernel-starts-a-nuttx-app">(More about the <strong>NuttX ELF Loader</strong>)</a></p>
<p><em>Why do we Loop Forever?</em></p>
<div><pre><code>// Omitted: Execute ECALL for System Call to NuttX Kernel
asm volatile ( ... );

// Loop Forever
for(;;) {}
</code></pre></div>
<p>That‚Äôs because NuttX Apps are not supposed to <a href="https://github.com/lupyuen/tcc-riscv32-wasm#fix-missing-printf-in-nuttx-app"><strong>Return to NuttX Kernel</strong></a>.</p>
<p>We should call the NuttX System Call <strong><code>__exit</code></strong> to terminate peacefully.</p>
<p><img src="https://lupyuen.codeberg.page/images/tcc-demo.png" alt="Online Demo of Apache NuttX RTOS"/></p>
<p><a href="https://nuttx.apache.org/demo/"><em>Online Demo of Apache NuttX RTOS</em></a></p>

<p>Here are the steps to build and run <strong>NuttX for QEMU 64-bit RISC-V</strong> (Kernel Mode)</p>
<ol>
<li>
<p>Install the Build Prerequisites, skip the RISC-V Toolchain‚Ä¶</p>
<p><a href="https://lupyuen.codeberg.page/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the RISC-V Toolchain for <strong>riscv64-unknown-elf</strong>‚Ä¶</p>
<p><a href="https://lupyuen.codeberg.page/articles/riscv#appendix-download-toolchain-for-64-bit-risc-v"><strong>‚ÄúDownload Toolchain for 64-bit RISC-V‚Äù</strong></a></p>
</li>
<li>
<p>Download and configure NuttX‚Ä¶</p>
<div><pre><code>## Download NuttX Source Code
mkdir nuttx
cd nuttx
git clone https://github.com/apache/nuttx nuttx
git clone https://github.com/apache/nuttx-apps apps

## Configure NuttX for QEMU RISC-V 64-bit (Kernel Mode)
cd nuttx
tools/configure.sh rv-virt:knsh64
make menuconfig
</code></pre></div>
<p>We use <a href="https://lupyuen.codeberg.page/articles/semihost#nuttx-apps-filesystem"><strong>Kernel Mode</strong></a> because it allows loading of NuttX Apps as ELF Files.</p>
<p>(Instead of Statically Linking the NuttX Apps into NuttX Kernel)</p>
</li>
<li>
<p>(Optional) To enable <strong>ELF Loader Logging</strong>, select‚Ä¶</p>
<p>Build Setup &gt; Debug Options &gt; Binary Loader Debug Features:</p>
<ul>
<li>Enable ‚ÄúBinary Loader Error, Warnings and Info‚Äù</li>
</ul>
</li>
<li>
<p>(Optional) To enable <strong>System Call Logging</strong>, select‚Ä¶</p>
<p>Build Setup &gt; Debug Options &gt; SYSCALL  Debug Features:</p>
<ul>
<li>Enable ‚ÄúSYSCALL Error, Warnings and Info‚Äù</li>
</ul>
</li>
<li>
<p>Save and exit <strong>menuconfig</strong>.</p>
</li>
<li>
<p>Build the <strong>NuttX Kernel and NuttX Apps</strong>‚Ä¶</p>
<div><pre><code>## Build NuttX Kernel
make -j 8

## Build NuttX Apps
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd
</code></pre></div></li>
</ol>
<p>This produces the NuttX ELF Image <strong><code>nuttx</code></strong> that we may boot on QEMU RISC-V Emulator‚Ä¶</p>
<div><pre><code>## For macOS: Install QEMU
brew install qemu

## For Debian and Ubuntu: Install QEMU
sudo apt install qemu-system-riscv64

## Boot NuttX on QEMU 64-bit RISC-V
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p>NuttX Apps are located in <strong><code>apps/bin</code></strong>.</p>
<p>We may copy our <strong>RISC-V ELF <code>a.out</code></strong> to that folder and run it‚Ä¶</p>
<div><pre><code>NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; a.out
Hello, World!!
</code></pre></div>
<p><img src="https://lupyuen.codeberg.page/images/tcc-posix.jpg" alt="POSIX Functions aren‚Äôt supported for TCC in WebAssembly"/></p>

<p>Remember we said that POSIX Functions aren‚Äôt supported in WebAssembly? (Pic above)</p>
<ul>
<li><a href="https://lupyuen.codeberg.page/articles/tcc#posix-for-webassembly"><strong>‚ÄúPOSIX for WebAssembly‚Äù</strong></a></li>
</ul>
<p>We dump the <strong>Compiled WebAssembly</strong> of TCC Compiler, and we discover that it calls <strong>72 POSIX Functions</strong>‚Ä¶</p>
<div><pre><code>## Dump the Compiled WebAssembly
## for TCC Compiler `tcc.o`
$ sudo apt install wabt
$ wasm-objdump -x tcc.o

Import:
 - func[0] sig=1  &lt;env.strcmp&gt; &lt;- env.strcmp
 - func[1] sig=12 &lt;env.memset&gt; &lt;- env.memset
 - func[2] sig=1  &lt;env.getcwd&gt; &lt;- env.getcwd
 ...
 - func[69] sig=2  &lt;env.localtime&gt; &lt;- env.localtime
 - func[70] sig=13 &lt;env.qsort&gt;     &lt;- env.qsort
 - func[71] sig=19 &lt;env.strtoll&gt;   &lt;- env.strtoll
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#missing-functions-in-tcc-webassembly">(See the <strong>Complete List</strong>)</a></p>
<p>Do we need all 72 POSIX Functions? We scrutinise the list‚Ä¶</p>
<hr/>
<p><strong>Filesystem Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L87-L166"><em>(Implemented here)</em></a></p>
<p>We‚Äôll simulate these functions for WebAssembly, by embedding the simple <a href="https://github.com/lupyuen/tcc-riscv32-wasm#rom-fs-filesystem-for-tcc-webassembly"><strong>ROM FS Filesystem</strong></a> into our Zig Wrapper‚Ä¶</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#rom-fs-filesystem-for-tcc-webassembly">(See the updates for <strong>ROM FS Filesystem</strong>)</a></p>
<hr/>
<p><strong>Varargs Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L186-L445"><em>(Implemented here)</em></a></p>
<p>As discussed earlier, Varargs will be <a href="https://lupyuen.codeberg.page/articles/tcc#fearsome-fprintf-and-friends"><strong>tricky to implement</strong></a> in Zig. Probably we should do it in C.</p>
<p><a href="https://github.com/marler8997/ziglibc/blob/main/src/printf.c#L32-L191">(Similar to <strong>ziglibc</strong>)</a></p>
<p>Right now we‚Äôre doing simple <a href="https://lupyuen.codeberg.page/articles/tcc#appendix-pattern-matching"><strong>Pattern Matching</strong></a>. But it might not be sufficient when TCC compiles Real Programs‚Ä¶</p>
<hr/>
<p><strong>String Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L541-L776"><em>(Implemented here)</em></a></p>
<p>We‚Äôll borrow the String Functions from <a href="https://github.com/marler8997/ziglibc/blob/main/src/cstd.zig"><strong>ziglibc</strong></a>‚Ä¶</p>
<hr/>
<p><strong>Semaphore Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L166-L186"><em>(Implemented here)</em></a></p>
<p>Not sure why TCC uses Semaphores? Maybe we‚Äôll understand when we support <strong><code>#include</code></strong> files.</p>
<p>(Where can we borrow the Semaphore Functions?)</p>
<hr/>
<p><strong>Standard Library</strong></p>
<p><strong>qsort</strong> isn‚Äôt used right now. Maybe for the Linker later?</p>
<p>(Borrow <strong>qsort</strong> from where? We can probably implement <strong>exit</strong>)</p>
<hr/>
<p><strong>Time and Math Functions</strong></p>
<p>Not used right now, maybe later.</p>
<p>(Anyone can lend us <strong>ldexp</strong>? How will we do the Time Functions? Call out to JavaScript to <a href="https://lupyuen.codeberg.page/articles/lvgl4#appendix-handle-lvgl-timer"><strong>fetch the time</strong></a>?)</p>
<hr/>
<p><strong>Outstanding Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L776-L855"><em>(Implemented here)</em></a></p>
<p>We have implemented (fully or partially) <strong>48 POSIX Functions</strong> from above.</p>
<p>The ones that we haven‚Äôt implemented? These <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L776-L855"><strong>24 POSIX Functions will Halt</strong></a> when TCC WebAssembly calls them‚Ä¶</p>

    


</div>
  </body>
</html>
