<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/preactjs/signals">Original</a>
    <h1>Preact Signals</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Signals is a performant state management library with two primary goals:</p>
<ol dir="auto">
<li>Make it as easy as possible to write business logic for small up to complex apps. No matter how complex your logic is, your app updates should stay fast without you needing to think about it. Signals automatically optimize state updates behind the scenes to trigger the fewest updates necessary. They are lazy by default and automatically skip signals that no one listens to.</li>
<li>Integrate into frameworks as if they were native built-in primitives. You don&#39;t need any selectors, wrapper functions, or anything else. Signals can be accessed directly and your component will automatically re-render when the signal&#39;s value changes.</li>
</ol>
<p dir="auto">Read the <a href="https://preactjs.com/blog/introducing-signals/" rel="nofollow">announcement post</a> to learn more about which problems signals solve and how it came to be.</p>
<h2 dir="auto"><a id="user-content-installation" aria-hidden="true" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation:</h2>
<div dir="auto" data-snippet-clipboard-copy-content="# Just the core library
npm install @preact/signals-core
# If you&#39;re using Preact
npm install @preact/signals
# If you&#39;re using React
npm install @preact/signals-react"><pre><span><span>#</span> Just the core library</span>
npm install @preact/signals-core
<span><span>#</span> If you&#39;re using Preact</span>
npm install @preact/signals
<span><span>#</span> If you&#39;re using React</span>
npm install @preact/signals-react</pre></div>
<ul dir="auto">
<li><a href="#guide--api">Guide / API</a>
<ul dir="auto">
<li><a href="#signalinitialvalue"><code>signal(initialValue)</code></a>
<ul dir="auto">
<li><a href="#signalpeek"><code>signal.peek()</code></a></li>
</ul>
</li>
<li><a href="#computedfn"><code>computed(fn)</code></a></li>
<li><a href="#effectfn"><code>effect(fn)</code></a></li>
<li><a href="#batchfn"><code>batch(fn)</code></a></li>
</ul>
</li>
<li><a href="#preact-integration">Preact Integration</a>
<ul dir="auto">
<li><a href="#hooks">Hooks</a></li>
<li><a href="#rendering-optimizations">Rendering optimizations</a>
<ul dir="auto">
<li><a href="#attribute-optimization-experimental">Attribute optimization (experimental)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#react-integration">React Integration</a>
<ul dir="auto">
<li><a href="#hooks-1">Hooks</a></li>
</ul>
</li>
<li><a href="#license">License</a></li>
</ul>
<h2 dir="auto"><a id="user-content-guide--api" aria-hidden="true" href="#guide--api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Guide / API</h2>
<p dir="auto">The signals library exposes four functions which are the building blocks to model any business logic you can think of.</p>
<h3 dir="auto"><a id="user-content-signalinitialvalue" aria-hidden="true" href="#signalinitialvalue"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>signal(initialValue)</code></h3>
<p dir="auto">The <code>signal</code> function creates a new signal. A signal is a container for a value that can change over time. You can read a signal&#39;s value or subscribe to value updates by accessing the its <code>.value</code> property.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal } from &#34;@preact/signals-core&#34;;

const counter = signal(0);

// Read value from signal, logs: 0
console.log(counter.value);

// Write to a signal
counter.value = 1;"><pre><span>import</span> <span>{</span> <span>signal</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-core&#34;</span><span>;</span>

<span>const</span> <span>counter</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>

<span>// Read value from signal, logs: 0</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>counter</span><span>.</span><span>value</span><span>)</span><span>;</span>

<span>// Write to a signal</span>
<span>counter</span><span>.</span><span>value</span> <span>=</span> <span>1</span><span>;</span></pre></div>
<p dir="auto">Writing to a signal is done by setting its <code>.value</code> property. Changing a signal&#39;s value synchronously updates every <a href="#computed">computed</a> and <a href="#effect">effect</a> that depends on that signal, ensuring your app state is always consistent.</p>
<h4 dir="auto"><a id="user-content-signalpeek" aria-hidden="true" href="#signalpeek"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>signal.peek()</code></h4>
<p dir="auto">In the rare instance that you have an effect that should write to another signal based on the previous value, but you <em>don&#39;t</em> want the effect to be subscribed to that signal, you can read a signals&#39;s previous value via <code>signal.peek()</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const counter = signal(0);
const effectCount = signal(0);

effect(() =&gt; {
	console.log(counter.value);

	// Whenever this effect is triggered, increase `effectCount`.
	// But we don&#39;t want this signal to react to `effectCount`
	effectCount.value = effectCount.peek() + 1;
});"><pre><span>const</span> <span>counter</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>const</span> <span>effectCount</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>

<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>console</span><span>.</span><span>log</span><span>(</span><span>counter</span><span>.</span><span>value</span><span>)</span><span>;</span>

	<span>// Whenever this effect is triggered, increase `effectCount`.</span>
	<span>// But we don&#39;t want this signal to react to `effectCount`</span>
	<span>effectCount</span><span>.</span><span>value</span> <span>=</span> <span>effectCount</span><span>.</span><span>peek</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
<span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Note that you should only use <code>signal.peek()</code> if you really need it. Reading a signal&#39;s value via <code>signal.value</code> is the preferred way in most scenarios.</p>
<h3 dir="auto"><a id="user-content-computedfn" aria-hidden="true" href="#computedfn"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>computed(fn)</code></h3>
<p dir="auto">Data is often derived from other pieces of existing data. The <code>computed</code> function lets you combine the values of multiple signals into a new signal that can be reacted to, or even used by additional computeds. When the signals accessed from within a computed callback change, the computed callback is re-executed and its new return value becomes the computed signal&#39;s value.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal, computed } from &#34;@preact/signals-core&#34;;

const name = signal(&#34;Jane&#34;);
const surname = signal(&#34;Doe&#34;);

const fullName = computed(() =&gt; name.value + &#34; &#34; + surname.value);

// Logs: &#34;Jane Doe&#34;
console.log(fullName.value);

// Updates flow through computed, but only if someone
// subscribes to it. More on that later.
name.value = &#34;John&#34;;
// Logs: &#34;John Doe&#34;
console.log(fullName.value);"><pre><span>import</span> <span>{</span> <span>signal</span><span>,</span> <span>computed</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-core&#34;</span><span>;</span>

<span>const</span> <span>name</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Jane&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>surname</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Doe&#34;</span><span>)</span><span>;</span>

<span>const</span> <span>fullName</span> <span>=</span> <span>computed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>name</span><span>.</span><span>value</span> <span>+</span> <span>&#34; &#34;</span> <span>+</span> <span>surname</span><span>.</span><span>value</span><span>)</span><span>;</span>

<span>// Logs: &#34;Jane Doe&#34;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>fullName</span><span>.</span><span>value</span><span>)</span><span>;</span>

<span>// Updates flow through computed, but only if someone</span>
<span>// subscribes to it. More on that later.</span>
<span>name</span><span>.</span><span>value</span> <span>=</span> <span>&#34;John&#34;</span><span>;</span>
<span>// Logs: &#34;John Doe&#34;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>fullName</span><span>.</span><span>value</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Any signal that is accessed inside the <code>computed</code>&#39;s callback function will be automatically subscribed to and tracked as a dependency of the computed signal.</p>
<h3 dir="auto"><a id="user-content-effectfn" aria-hidden="true" href="#effectfn"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>effect(fn)</code></h3>
<p dir="auto">The <code>effect</code> function is the last piece that makes everything reactive. When you access a signal inside its callback function, that signal and every dependency of said signal will be activated and subscribed to. In that regard it is very similar to <a href="#computedfn"><code>computed(fn)</code></a>. By default all updates are lazy, so nothing will update until you access a signal inside <code>effect</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal, computed, effect } from &#34;@preact/signals-core&#34;;

const name = signal(&#34;Jane&#34;);
const surname = signal(&#34;Doe&#34;);
const fullName = computed(() =&gt; name.value + &#34; &#34; + surname.value);

// Logs: &#34;Jane Doe&#34;
effect(() =&gt; console.log(fullName.value));

// Updating one of its dependenies will automatically trigger
// the effect above, and will print &#34;John Doe&#34; to the console.
name.value = &#34;John&#34;;"><pre><span>import</span> <span>{</span> <span>signal</span><span>,</span> <span>computed</span><span>,</span> <span>effect</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-core&#34;</span><span>;</span>

<span>const</span> <span>name</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Jane&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>surname</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Doe&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>fullName</span> <span>=</span> <span>computed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>name</span><span>.</span><span>value</span> <span>+</span> <span>&#34; &#34;</span> <span>+</span> <span>surname</span><span>.</span><span>value</span><span>)</span><span>;</span>

<span>// Logs: &#34;Jane Doe&#34;</span>
<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>fullName</span><span>.</span><span>value</span><span>)</span><span>)</span><span>;</span>

<span>// Updating one of its dependenies will automatically trigger</span>
<span>// the effect above, and will print &#34;John Doe&#34; to the console.</span>
<span>name</span><span>.</span><span>value</span> <span>=</span> <span>&#34;John&#34;</span><span>;</span></pre></div>
<p dir="auto">You can destroy an effect and unsubscribe from all signals it was subscribed to, by calling the returned function.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal, effect } from &#34;@preact/signals-core&#34;;

const name = signal(&#34;Jane&#34;);
const surname = signal(&#34;Doe&#34;);
const fullName = computed(() =&gt; name.value + &#34; &#34; + surname.value);

// Logs: &#34;Jane Doe&#34;
const dispose = effect(() =&gt; console.log(fullName.value));

// Destroy effect and subscriptions
dispose();

// Update does nothing, because no one is subscribed anymore.
// Even the computed `fullName` signal won&#39;t change, because it knows
// that no one listens to it.
surname.value = &#34;Doe 2&#34;;"><pre><span>import</span> <span>{</span> <span>signal</span><span>,</span> <span>effect</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-core&#34;</span><span>;</span>

<span>const</span> <span>name</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Jane&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>surname</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Doe&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>fullName</span> <span>=</span> <span>computed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>name</span><span>.</span><span>value</span> <span>+</span> <span>&#34; &#34;</span> <span>+</span> <span>surname</span><span>.</span><span>value</span><span>)</span><span>;</span>

<span>// Logs: &#34;Jane Doe&#34;</span>
<span>const</span> <span>dispose</span> <span>=</span> <span>effect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>fullName</span><span>.</span><span>value</span><span>)</span><span>)</span><span>;</span>

<span>// Destroy effect and subscriptions</span>
<span>dispose</span><span>(</span><span>)</span><span>;</span>

<span>// Update does nothing, because no one is subscribed anymore.</span>
<span>// Even the computed `fullName` signal won&#39;t change, because it knows</span>
<span>// that no one listens to it.</span>
<span>surname</span><span>.</span><span>value</span> <span>=</span> <span>&#34;Doe 2&#34;</span><span>;</span></pre></div>
<h3 dir="auto"><a id="user-content-batchfn" aria-hidden="true" href="#batchfn"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>batch(fn)</code></h3>
<p dir="auto">The <code>batch</code> function allows you to combine multiple signal writes into one single update that is triggered at the end when the callback completes.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal, computed, effect, batch } from &#34;@preact/signals-core&#34;;

const name = signal(&#34;Jane&#34;);
const surname = signal(&#34;Doe&#34;);
const fullName = computed(() =&gt; name.value + &#34; &#34; + surname.value);

// Logs: &#34;Jane Doe&#34;
effect(() =&gt; console.log(fullName.value));

// Combines both signal writes into one update. Once the callback
// returns the `effect` will trigger and we&#39;ll log &#34;Foo Bar&#34;
batch(() =&gt; {
	name.value = &#34;Foo&#34;;
	surname.value = &#34;Bar&#34;;
});"><pre><span>import</span> <span>{</span> <span>signal</span><span>,</span> <span>computed</span><span>,</span> <span>effect</span><span>,</span> <span>batch</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-core&#34;</span><span>;</span>

<span>const</span> <span>name</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Jane&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>surname</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;Doe&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>fullName</span> <span>=</span> <span>computed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>name</span><span>.</span><span>value</span> <span>+</span> <span>&#34; &#34;</span> <span>+</span> <span>surname</span><span>.</span><span>value</span><span>)</span><span>;</span>

<span>// Logs: &#34;Jane Doe&#34;</span>
<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>fullName</span><span>.</span><span>value</span><span>)</span><span>)</span><span>;</span>

<span>// Combines both signal writes into one update. Once the callback</span>
<span>// returns the `effect` will trigger and we&#39;ll log &#34;Foo Bar&#34;</span>
<span>batch</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>name</span><span>.</span><span>value</span> <span>=</span> <span>&#34;Foo&#34;</span><span>;</span>
	<span>surname</span><span>.</span><span>value</span> <span>=</span> <span>&#34;Bar&#34;</span><span>;</span>
<span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto">When you access a signal that you wrote to earlier inside the callback, or access a computed signal that was invalidated by another signal, we&#39;ll only update the necessary dependencies to get the current value for the signal you read from. All other invalidated signals will update at the end of the callback function.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal, computed, effect, batch } from &#34;@preact/signals-core&#34;;

const counter = signal(0);
const double = computed(() =&gt; counter.value * 2);
const tripple = computed(() =&gt; counter.value * 3);

effect(() =&gt; console.log(double.value, tripple.value));

batch(() =&gt; {
	counter.value = 1;
	// Logs: 2, despite being inside batch, but `tripple`
	// will only update once the callback is complete
	console.log(counter.double);
});
// Now we reached the end of the batch and call the effect"><pre><span>import</span> <span>{</span> <span>signal</span><span>,</span> <span>computed</span><span>,</span> <span>effect</span><span>,</span> <span>batch</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-core&#34;</span><span>;</span>

<span>const</span> <span>counter</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>const</span> <span>double</span> <span>=</span> <span>computed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>counter</span><span>.</span><span>value</span> <span>*</span> <span>2</span><span>)</span><span>;</span>
<span>const</span> <span>tripple</span> <span>=</span> <span>computed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>counter</span><span>.</span><span>value</span> <span>*</span> <span>3</span><span>)</span><span>;</span>

<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>double</span><span>.</span><span>value</span><span>,</span> <span>tripple</span><span>.</span><span>value</span><span>)</span><span>)</span><span>;</span>

<span>batch</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>counter</span><span>.</span><span>value</span> <span>=</span> <span>1</span><span>;</span>
	<span>// Logs: 2, despite being inside batch, but `tripple`</span>
	<span>// will only update once the callback is complete</span>
	<span>console</span><span>.</span><span>log</span><span>(</span><span>counter</span><span>.</span><span>double</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>// Now we reached the end of the batch and call the effect</span></pre></div>
<p dir="auto">Batches can be nested and updates will be flushed when the outermost batch call completes.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal, computed, effect, batch } from &#34;@preact/signals-core&#34;;

const counter = signal(0);
effect(() =&gt; console.log(counter.value));

batch(() =&gt; {
	batch(() =&gt; {
		// Signal is invalidated, but update is not flushed because
		// we&#39;re still inside another batch
		counter.value = 1;
	});

	// Still not updated...
});
// Now the callback completed and we&#39;ll trigger the effect."><pre><span>import</span> <span>{</span> <span>signal</span><span>,</span> <span>computed</span><span>,</span> <span>effect</span><span>,</span> <span>batch</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-core&#34;</span><span>;</span>

<span>const</span> <span>counter</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>counter</span><span>.</span><span>value</span><span>)</span><span>)</span><span>;</span>

<span>batch</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>batch</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
		<span>// Signal is invalidated, but update is not flushed because</span>
		<span>// we&#39;re still inside another batch</span>
		<span>counter</span><span>.</span><span>value</span> <span>=</span> <span>1</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	<span>// Still not updated...</span>
<span>}</span><span>)</span><span>;</span>
<span>// Now the callback completed and we&#39;ll trigger the effect.</span></pre></div>
<h2 dir="auto"><a id="user-content-preact-integration" aria-hidden="true" href="#preact-integration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Preact Integration</h2>
<p dir="auto">The Preact integration can be installed via:</p>
<div dir="auto" data-snippet-clipboard-copy-content="npm install @preact/signals"><pre>npm install @preact/signals</pre></div>
<p dir="auto">It allows you to access signals as if they were native to Preact. Whenever you read a signal inside a component we&#39;ll automatically subscribe the component to that. When you update the signal we&#39;ll know that this component needs to be updated and will do that for you.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// The Preact adapter re-exports the core library
import { signal } from &#34;@preact/signals&#34;;

const count = signal(0);

function CounterValue() {
	// Whenver the `count` signal is updated, we&#39;ll
	// re-render this component automatically for you
	return &lt;p&gt;Value: {count.value}&lt;/p&gt;;
}"><pre><span>// The Preact adapter re-exports the core library</span>
<span>import</span> <span>{</span> <span>signal</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals&#34;</span><span>;</span>

<span>const</span> <span>count</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>

<span>function</span> <span>CounterValue</span><span>(</span><span>)</span> <span>{</span>
	<span>// Whenver the `count` signal is updated, we&#39;ll</span>
	<span>// re-render this component automatically for you</span>
	<span>return</span> <span>&lt;</span><span>p</span><span>&gt;</span>Value: <span>{</span><span>count</span><span>.</span><span>value</span><span>}</span><span>&lt;</span><span>/</span><span>p</span><span>&gt;</span><span>;</span>
<span>}</span></pre></div>
<h3 dir="auto"><a id="user-content-hooks" aria-hidden="true" href="#hooks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hooks</h3>
<p dir="auto">If you need to instantiate new signals inside your components, you can use the <code>useSignal</code> or <code>useComputed</code> hook.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { useSignal, useComputed } from &#34;@preact/signals&#34;;

function Counter() {
	const count = useSignal(0);
	const double = useComputed(() =&gt; count.value * 2);

	return (
		&lt;button onClick={() =&gt; count.value++}&gt;
			Value: {count.value}, value x 2 = {double.value}
		&lt;/button&gt;
	);
}"><pre><span>import</span> <span>{</span> <span>useSignal</span><span>,</span> <span>useComputed</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals&#34;</span><span>;</span>

<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
	<span>const</span> <span>count</span> <span>=</span> <span>useSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>
	<span>const</span> <span>double</span> <span>=</span> <span>useComputed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>count</span><span>.</span><span>value</span> <span>*</span> <span>2</span><span>)</span><span>;</span>

	<span>return</span> <span>(</span>
		<span>&lt;</span><span>button</span> <span>onClick</span><span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>count</span><span>.</span><span>value</span><span>++</span><span>}</span><span>&gt;</span>
			Value: <span>{</span><span>count</span><span>.</span><span>value</span><span>}</span>, value x 2 = <span>{</span><span>double</span><span>.</span><span>value</span><span>}</span>
		<span>&lt;</span><span>/</span><span>button</span><span>&gt;</span>
	<span>)</span><span>;</span>
<span>}</span></pre></div>
<h3 dir="auto"><a id="user-content-rendering-optimizations" aria-hidden="true" href="#rendering-optimizations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Rendering optimizations</h3>
<p dir="auto">The Preact adapter ships with several optimizations it can apply out of the box to skip virtual-dom rendering entirely. If you pass a signal directly into JSX, it will bind directly to the DOM <code>Text</code> node that is created and update that whenever the signal changes.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal } from &#34;@preact/signals&#34;;

const count = signal(0);

// Unoptimized: Will trigger the surrounding
// component to re-render
function Counter() {
	return &lt;p&gt;Value: {count.value}&lt;/p&gt;;
}

// Optimized: Will update the text node directly
function Counter() {
	return &lt;p&gt;Value: {count}&lt;/p&gt;;
}"><pre><span>import</span> <span>{</span> <span>signal</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals&#34;</span><span>;</span>

<span>const</span> <span>count</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>

<span>// Unoptimized: Will trigger the surrounding</span>
<span>// component to re-render</span>
<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
	<span>return</span> <span>&lt;</span><span>p</span><span>&gt;</span>Value: <span>{</span><span>count</span><span>.</span><span>value</span><span>}</span><span>&lt;</span><span>/</span><span>p</span><span>&gt;</span><span>;</span>
<span>}</span>

<span>// Optimized: Will update the text node directly</span>
<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
	<span>return</span> <span>&lt;</span><span>p</span><span>&gt;</span>Value: <span>{</span><span>count</span><span>}</span><span>&lt;</span><span>/</span><span>p</span><span>&gt;</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">To opt into this optimization, simply pass the signal directly instead of accessing the <code>.value</code> property.</p>
<h4 dir="auto"><a id="user-content-attribute-optimization-experimental" aria-hidden="true" href="#attribute-optimization-experimental"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Attribute optimization (experimental)</h4>
<p dir="auto">We can also pass signals directly as an attribute to an HTML element node.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal } from &#34;@preact/signals&#34;;

const inputValue = signal(&#34;foobar&#34;);

function Person() {
	return &lt;input value={inputValue} /&gt;;
}"><pre><span>import</span> <span>{</span> <span>signal</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals&#34;</span><span>;</span>

<span>const</span> <span>inputValue</span> <span>=</span> <span>signal</span><span>(</span><span>&#34;foobar&#34;</span><span>)</span><span>;</span>

<span>function</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>
	<span>return</span> <span>&lt;</span><span>input</span> <span>value</span><span>=</span><span>{</span><span>inputValue</span><span>}</span> <span>/</span><span>&gt;</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">This way we&#39;ll bypass checking the virtual-dom and update the DOM property directly.</p>
<h2 dir="auto"><a id="user-content-react-integration" aria-hidden="true" href="#react-integration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>React Integration</h2>
<p dir="auto">The React integration can be installed via:</p>
<div dir="auto" data-snippet-clipboard-copy-content="npm install @preact/signals-react"><pre>npm install @preact/signals-react</pre></div>
<p dir="auto">Similar to the Preact integration, the React adapter allows you to access signals directly inside your components and will automatically subscribe to them.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { signal } from &#34;@preact/signals-react&#34;;

const count = signal(0);

function CounterValue() {
	// Whenver the `count` signal is updated, we&#39;ll
	// re-render this component automatically for you
	return &lt;p&gt;Value: {count.value}&lt;/p&gt;;
}"><pre><span>import</span> <span>{</span> <span>signal</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-react&#34;</span><span>;</span>

<span>const</span> <span>count</span> <span>=</span> <span>signal</span><span>(</span><span>0</span><span>)</span><span>;</span>

<span>function</span> <span>CounterValue</span><span>(</span><span>)</span> <span>{</span>
	<span>// Whenver the `count` signal is updated, we&#39;ll</span>
	<span>// re-render this component automatically for you</span>
	<span>return</span> <span>&lt;</span><span>p</span><span>&gt;</span>Value: <span>{</span><span>count</span><span>.</span><span>value</span><span>}</span><span>&lt;</span><span>/</span><span>p</span><span>&gt;</span><span>;</span>
<span>}</span></pre></div>
<h3 dir="auto"><a id="user-content-hooks-1" aria-hidden="true" href="#hooks-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hooks</h3>
<p dir="auto">If you need to instantiate new signals inside your components, you can use the <code>useSignal</code> or <code>useComputed</code> hook.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { useSignal, useComputed } from &#34;@preact/signals-react&#34;;

function Counter() {
	const count = useSignal(0);
	const double = useComputed(() =&gt; count.value * 2);

	return (
		&lt;button onClick={() =&gt; count.value++}&gt;
			Value: {count.value}, value x 2 = {double.value}
		&lt;/button&gt;
	);
}"><pre><span>import</span> <span>{</span> <span>useSignal</span><span>,</span> <span>useComputed</span> <span>}</span> <span>from</span> <span>&#34;@preact/signals-react&#34;</span><span>;</span>

<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
	<span>const</span> <span>count</span> <span>=</span> <span>useSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>
	<span>const</span> <span>double</span> <span>=</span> <span>useComputed</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>count</span><span>.</span><span>value</span> <span>*</span> <span>2</span><span>)</span><span>;</span>

	<span>return</span> <span>(</span>
		<span>&lt;</span><span>button</span> <span>onClick</span><span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>count</span><span>.</span><span>value</span><span>++</span><span>}</span><span>&gt;</span>
			Value: <span>{</span><span>count</span><span>.</span><span>value</span><span>}</span>, value x 2 = <span>{</span><span>double</span><span>.</span><span>value</span><span>}</span>
		<span>&lt;</span><span>/</span><span>button</span><span>&gt;</span>
	<span>)</span><span>;</span>
<span>}</span></pre></div>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto"><code>MIT</code>, see the <a href="https://medium.com/preactjs/signals/blob/main/LICENSE">LICENSE</a> file.</p>
</article>
          </div></div>
  </body>
</html>
