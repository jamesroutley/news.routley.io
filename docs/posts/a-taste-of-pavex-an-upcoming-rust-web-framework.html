<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lpalmieri.com/posts/a-taste-of-pavex-rust-web-framework/">Original</a>
    <h1>A taste of pavex, an upcoming Rust web framework</h1>
    
    <div id="readability-page-1" class="page"><section>
  <article>
    
      
      
<ul id="frontmatter">
    <li>
        <time datetime="2022-12-24T08:08:10.47Z">December 24, 2022</time>
    </li>
    <span></span>
    <li> 2606 words </li>
    <span></span>
    <li> 14 min </li>
</ul>

      
<p>Earlier this year, I started working on a new web framework for Rust: <a href="https://github.com/LukeMathWalker/pavex"><code>pavex</code></a>.</p>
<p>The goal is simple: <strong>great ergonomics</strong> and <strong>high performance</strong> - no sacrifices.</p>
<p>I&#39;ve been working on it for a few months now, enough to prove feasibility. It is not yet ready for user testing, 
but the design has solidified enough to start talking about it.</p>
<h2 id="the-state-of-rust-for-the-web">The state of Rust for the web</h2>
<p><code>actix-web</code>, <code>rocket</code>, <code>axum</code>, <code>tide</code>, <code>warp</code> - we have plenty of web frameworks in the Rust ecosystem, even
limiting the list to the most popular ones. Some would say we have <strong>too</strong> many - and here I am, working on making that 
list even longer.</p>
<p>Why <code>pavex</code>? Why would you go and build yet another web framework?</p>
<p>To broaden the design space!</p>
<p>The current generation of Rust web frameworks is trying to walk a tight rope.</p>
<p>There is tension between those two objectives.</p>
<p>Let&#39;s look at <code>axum</code>&#39;s &#34;Hello world&#34; example as a case study:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>axum::{response::Html, routing::get, Router};
</span><span>use </span><span>std::net::SocketAddr;
</span><span>
</span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span><span>async </span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> app = Router::new().</span><span>route</span><span>(&#34;</span><span>/</span><span>&#34;, </span><span>get</span><span>(handler));
</span><span>    axum::Server::bind(&amp;SocketAddr::from(([</span><span>127</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span><span>], </span><span>3000</span><span>)))
</span><span>        .</span><span>serve</span><span>(app.</span><span>into_make_service</span><span>())
</span><span>        .await
</span><span>        .</span><span>unwrap</span><span>();
</span><span>}
</span><span>
</span><span>async </span><span>fn </span><span>handler</span><span>() -&gt; Html&lt;&amp;</span><span>&#39;static str</span><span>&gt; {
</span><span>    Html(&#34;</span><span>&lt;h1&gt;Hello, World!&lt;/h1&gt;</span><span>&#34;)
</span><span>}
</span></code></pre>
<p><code>axum</code> requires all handler functions to be asynchronous. What happens if you forget?</p>
<pre data-lang="rust"><code data-lang="rust"><span>// [...]
</span><span>// No longer `async`!
</span><span>fn </span><span>handler</span><span>() -&gt; Html&lt;&amp;</span><span>&#39;static str</span><span>&gt; { </span><span>/* */ </span><span>}
</span></code></pre>
<p>The compiler greets us with this error message:</p>
<pre data-lang="text"><code data-lang="text"><span>error[E0277]: the trait bound `fn() -&gt; Html&lt;&amp;&#39;static str&gt; {handler}: Handler&lt;_, _, _&gt;` is not satisfied
</span><span>   --&gt; hello-world/src/main.rs:12:44
</span><span>    |
</span><span>12  |     let app = Router::new().route(&#34;/&#34;, get(handler));
</span><span>    |                                        --- ^^^^^^^ 
</span><span>                                             |   the trait `Handler&lt;_, _, _&gt;` is not implemented 
</span><span>                                             |   for `fn() -&gt; Html&lt;&amp;&#39;static str&gt; {handler}`
</span><span>    |                                        |
</span><span>    |                                        required by a bound introduced by this call
</span><span>    |
</span><span>    = help: the trait `Handler&lt;T, S, B&gt;` is implemented for `Layered&lt;L, H, T, S, B&gt;`
</span><span>note: required by a bound in `axum::routing::get`
</span><span>   --&gt; /Users/luca/code/axum/axum/src/routing/method_routing.rs:400:1
</span><span>    |
</span><span>400 | top_level_handler_fn!(get, GET);
</span><span>    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `axum::routing::get`
</span><span>    = note: this error originates in the macro `top_level_handler_fn`
</span></code></pre>
<p>Good luck figuring that out!</p>
<p>Is the situation helpless? Are we forced to choose between performance, compile-time safety and ergonomics?</p>
<p>No, we are not.</p>
<p>At the same time, crate authors are trying to step in with the tools currently available in Rust&#39;s latest stable
release: metaprogramming.</p>
<p>Let&#39;s use the &#34;Hello world&#34; example again to try it out:</p>
<pre data-lang="rust"><code data-lang="rust"><span>// [...]
</span><span>// Now annotated with #[debug_handler], same sync signature otherwise
</span><span>#[</span><span>axum</span><span>::</span><span>debug_handler</span><span>]
</span><span>fn </span><span>handler</span><span>() -&gt; Html&lt;&amp;</span><span>&#39;static str</span><span>&gt; { </span><span>/* */ </span><span>}
</span></code></pre>
<p>The error message is now <strong>much</strong> better:</p>
<pre data-lang="text"><code data-lang="text"><span>error: handlers must be async functions
</span><span>  --&gt; main.rs:xx:1
</span><span>   |
</span><span>xx | fn handler() -&gt; &amp;&#39;static str {
</span><span>   | ^^
</span></code></pre>
<p>This is <strong>amazing</strong>, because it is speaking <strong>at the right level of abstraction</strong>.</p>
<p>This is where the idea for <code>pavex</code> comes from.</p>
<p>You might be wondering - is it even feasible? You&#39;d be right to doubt!</p>
<h2 id="an-overview-of-pavex">An overview of <code>pavex</code></h2>
<p>Before diving into the technical details, let&#39;s get a feeling for the type of API that <code>pavex</code> will expose.</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>pavex_builder::{f, AppBlueprint, Lifecycle};
</span><span>
</span><span>/// Return the blueprint for our application.
</span><span>pub fn </span><span>blueprint</span><span>() -&gt; AppBlueprint {
</span><span>    </span><span>let mut</span><span> bp = AppBlueprint::new();
</span><span>    
</span><span>    bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::http_client), Lifecycle::Singleton);
</span><span>    bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::extract_path), Lifecycle::RequestScoped);
</span><span>    bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::logger), Lifecycle::Transient);
</span><span>    
</span><span>    </span><span>let</span><span> vault = bp.</span><span>route</span><span>(&#34;</span><span>/vault</span><span>&#34;);
</span><span>    vault.</span><span>get</span><span>(f!(</span><span>crate</span><span>::stream_file));
</span><span>    
</span><span>    bp
</span><span>}
</span></code></pre>
<p>What is going on here?</p>
<h3 id="appblueprint-the-compile-time-representation"><code>AppBlueprint</code>, the compile-time representation</h3>
<p>We have an HTTP router, which should look familiar:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> vault = bp.</span><span>route</span><span>(&#34;</span><span>/vault</span><span>&#34;);
</span><span>// Use `stream_file` to handle `GET` requests to `/vault`.
</span><span>vault.</span><span>get</span><span>(f!(</span><span>crate</span><span>::stream_file));
</span></code></pre>
<p>We are also registering <strong>constructors</strong>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::http_client), Lifecycle::Singleton);
</span><span>bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::extract_path), Lifecycle::RequestScoped);
</span><span>bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::logger), Lifecycle::Transient);
</span></code></pre>
<p>This pattern is not very common in the Rust ecosystem, therefore it might not be as familiar: <code>pavex</code> performs 
<strong>(compile-time) dependency injection</strong>.</p>
<p>Our example has a single request handler, <code>stream_file</code>. This is its signature:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub</span><span> async </span><span>fn </span><span>stream_file</span><span>(
</span><span>    </span><span>request</span><span>: Request&lt;Body&gt;, 
</span><span>    </span><span>filepath</span><span>: PathBuf, 
</span><span>    </span><span>logger</span><span>: Logger, 
</span><span>    </span><span>http_client</span><span>: HttpClient
</span><span>) -&gt; Response { 
</span><span>    </span><span>/* */ 
</span><span>}
</span></code></pre>
<p>Whenever a <code>GET /vault</code> request is received, the framework must invoke <code>stream_file</code>.</p>
<p><code>Request&lt;Body&gt;</code> is the incoming HTTP request, it will be injected by <code>pavex</code>. For the other three dependencies, <code>pavex</code> 
looks for their constructors:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub</span><span> async </span><span>fn </span><span>extract_path</span><span>(</span><span>request</span><span>: &amp;Request&lt;Body&gt;, </span><span>logger</span><span>: Logger) -&gt; PathBuf { </span><span>/* */ </span><span>}
</span><span>
</span><span>pub fn </span><span>logger</span><span>() -&gt; Logger { </span><span>/* */ </span><span>}
</span><span>
</span><span>pub fn </span><span>http_client</span><span>(</span><span>configuration</span><span>: Config) -&gt; HttpClient { </span><span>/* */ </span><span>}
</span></code></pre>
<p>Constructors themselves can have dependencies, which are resolved in the same way.</p>
<table><thead><tr><th>Lifecycle</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>Singleton</code></td><td>The instance is created once, when the application starts. It is then reused for all incoming requests. Singletons are your application state.</td><td>Database connection pools, HTTP connection pools, configuration.</td></tr>
<tr><td><code>RequestScoped</code></td><td>The instance is created once per request. It is then reused for all processing within the same request.</td><td>Path parameters, auth information, parsed request body.</td></tr>
<tr><td><code>Transient</code></td><td>The instance is created every time it is needed.</td><td>Database connections, logger instances.</td></tr>
</tbody></table>
<p>Routes, constructors and their lifecycles are combined into a single <code>AppBlueprint</code> instance: this is a full 
specification of your application.</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>main</span><span>() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span>    </span><span>// The blueprint we defined above.
</span><span>    </span><span>let</span><span> bp = </span><span>blueprint</span><span>();
</span><span>    pavex_cli::generate(bp)
</span><span>        </span><span>// The folder where the generated crate will live.
</span><span>        .</span><span>output_path</span><span>(&#34;</span><span>runtime</span><span>&#34;)
</span><span>        .</span><span>execute</span><span>()?;
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<h3 id="the-runtime-code">The runtime code</h3>
<h4 id="the-entrypoint">The entrypoint</h4>
<p>The main entrypoint of the generated crate is the <code>run</code> function:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub</span><span> async </span><span>fn </span><span>run</span><span>(
</span><span>    </span><span>server_builder</span><span>: hyper::server::Builder&lt;AddrIncoming&gt;,
</span><span>    </span><span>application_state</span><span>: ApplicationState,
</span><span>) -&gt; Result&lt;(), pavex_runtime::Error&gt; { </span><span>/* */ </span><span>}
</span></code></pre>
<p><code>run</code> launches the web server so that you can start accepting requests. It takes as input the HTTP server configuration
(<code>hyper::server::Builder</code>) and an instance of the application state.</p>
<h4 id="application-state">Application state</h4>
<pre data-lang="rust"><code data-lang="rust"><span>pub struct </span><span>ApplicationState {
</span><span>    </span><span>s0</span><span>: app::HttpClient,
</span><span>}
</span><span>
</span><span>impl </span><span>ApplicationState {
</span><span>    </span><span>pub fn </span><span>new</span><span>(</span><span>v0</span><span>: app::Config) -&gt; ApplicationState {
</span><span>        </span><span>let</span><span> v1 = app::http_client(v0);
</span><span>        ApplicationState { s0: v1 }
</span><span>    }
</span><span>}
</span></code></pre>
<p>You can build an instance of <code>ApplicationState</code> by calling <code>ApplicationState::new</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>http_client</span><span>(</span><span>configuration</span><span>: Config) -&gt; HttpClient { </span><span>/* */ </span><span>}
</span></code></pre>
<p>It wants a <code>Config</code> instance as input, but we didn&#39;t register any constructor for <code>Config</code> in our blueprint. Therefore 
<code>pavex</code> generates an <code>ApplicationState::new</code> function that takes <code>Config</code> as input and builds the rest of the
state for us.</p>
<h4 id="request-handlers">Request handlers</h4>
<p><code>pavex</code> generates a function for each request handler in our blueprint.</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub</span><span> async </span><span>fn </span><span>get_vault</span><span>(</span><span>v0</span><span>: app::HttpClient, </span><span>v1</span><span>: Request&lt;Body&gt;) -&gt; Response {
</span><span>    </span><span>let</span><span> v3 = app::extract_path(&amp;v1, app::logger()).await;
</span><span>    app::stream_file(v1, v3, app::logger(), v0).await
</span><span>}
</span></code></pre>
<p>The handler takes as input the <code>HttpClient</code> singleton (out of <code>ApplicationState</code>) and the incoming HTTP request.</p>
<ul>
<li><code>HttpClient</code> is a singleton, therefore it comes from the <code>ApplicationState</code> and it is passed as input to the handler;</li>
<li><code>Request&lt;Body&gt;</code> is request-scoped, the same instance is passed to both <code>extract_path</code> (as a reference) and <code>stream_file</code> (by value);</li>
<li><code>Logger</code> is transient, a new instance is created every time it is needed as input.</li>
</ul>
<h3 id="a-zero-cost-abstraction">A zero-cost abstraction</h3>
<p>The generated code contains no indirection - no runtime reflection (as it&#39;s often the case for dependency injection 
frameworks other languages), no dynamic dispatch, no type-maps.</p>
<p>That&#39;s the whole value proposition of <code>pavex</code>: ergonomics <strong>and</strong> performance.</p>
<h3 id="the-unhappy-path">The unhappy path</h3>
<p>I&#39;ve mostly shown you the happy path - you throw a valid <code>AppBlueprint</code> at <code>pavex</code> and you get back a runnable web server.</p>
<p>This is, perhaps surprisingly, the aspect of <code>pavex</code> that I&#39;m most excited about: it&#39;s a compiler operating at a higher
level of abstraction that <code>rustc</code>, therefore we can provide <strong>better error messages</strong> for our target usecase.</p>
<p>Let&#39;s see what happens if try to register a singleton that is not <code>Send</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>// Definitely not `Send`, given that it contains an `Rc`.
</span><span>pub struct </span><span>NonSendSingleton(Rc&lt;()&gt;);
</span><span>
</span><span>pub fn </span><span>blueprint</span><span>() -&gt; AppBlueprint {
</span><span>    </span><span>let mut</span><span> bp = AppBlueprint::new();
</span><span>    bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::NonSendSingleton::new), Lifecycle::Singleton);
</span><span>    </span><span>// [...]
</span><span>}
</span></code></pre>
<p><code>pavex_cli</code> returns an error when trying to generate the runtime code:</p>
<pre data-lang="text"><code data-lang="text"><span>Error: 
</span><span>  × `app::NonSendSingleton` does not implement the `core::marker::Send` trait.
</span><span>    ╭─[src/lib.rs:24:1]
</span><span> 24 │     let mut bp = AppBlueprint::new();
</span><span> 25 │     bp.constructor(f!(crate::NonSendSingleton::new), Lifecycle::Singleton);
</span><span>    ·                    ────────────────┬───────────────
</span><span>    ·                                    ╰── The constructor was registered here
</span><span> 26 │     
</span><span>    ╰────
</span><span>  help: All singletons must implement the `Send` trait.
</span><span>        `pavex` runs on a multi-threaded HTTP server and singletons must be
</span><span>        shared across all worker threads.
</span></code></pre>
<p>The error message, going back to the beginning of the post, is <strong>at the right level of abstraction</strong>. It speaks 
of singletons and HTTP servers, the concepts that we are working with.</p>
<p>At the same time, there is more work to be done: the error message does not explain why <code>NonSendSingleton</code> does not
implement <code>Send</code>. I&#39;m currently exploring how to leverage <code>rustc</code> to <strong>combine</strong> both sources of information for an
optimal experience.</p>
<h2 id="a-peek-under-the-hood">A peek under the hood</h2>
<p>You might be wondering, at this point: how does <code>pavex</code> actually work? </p>
<p>Dependency-injection frameworks are usually implemented via runtime reflection: you can go to the language runtime
with a function pointer and introspect it - input types, output type, asyncness, etc.</p>
<p>Well, no <strong>runtime</strong> reflection API.</p>
<pre data-lang="bash"><code data-lang="bash"><span>cargo</span><span> +nightly rustdoc</span><span> -p </span><span>{crate_name}</span><span> --lib</span><span> -- -Zunstable-options -wjson
</span></code></pre>
<p>You get as output a JSON file with a <a href="https://crates.io/crates/rustdoc-types">structured representation</a> 
of all the types in your crate.</p>
<p>You might have noticed the <code>f!</code> macro in the examples above:</p>
<pre data-lang="rust"><code data-lang="rust"><span>bp.</span><span>constructor</span><span>(f!(</span><span>crate</span><span>::http_client), Lifecycle::Singleton);
</span></code></pre>
<p><code>f!(crate::http_client)</code> desugars to </p>
<pre data-lang="rust"><code data-lang="rust"><span>pavex_builder::RawCallable {
</span><span>    import_path: &#34;</span><span>crate::http_client</span><span>&#34;,
</span><span>    callable: </span><span>crate</span><span>::http_client,
</span><span>}
</span></code></pre>
<p>which is further transformed by the <code>AppBlueprint</code> into a <code>pavex_builder::RawCallableIdentifiers</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pavex_builder::RawCallableIdentifiers {
</span><span>    </span><span>// Name of the crate where `blueprint.constructor(..)` was called
</span><span>    registered_at: &#34;</span><span>app</span><span>&#34;,
</span><span>    </span><span>// Stringified fully-qualified path to the function
</span><span>    import_path: &#34;</span><span>crate::http_client</span><span>&#34;,
</span><span>}
</span></code></pre>
<p>This is the information fed to <code>pavex</code> as input, via <code>AppBlueprint</code>.</p>
<p>For each identifier, <code>pavex</code> looks at the <code>Cargo.lock</code> for the current workspace, finds the <code>registered_at</code> crate, determines its 
dependencies and generates the documentation for the crate where the callable is defined (in the example above,
<code>app</code> itself, since <code>import_path</code> begins with <code>crate</code>).</p>
<p>All this information is assembled in a series of <strong>call graphs</strong>, one for each registered route handler and one for 
the application state.</p>
<figure>
    <img src="https://scott.mn/image/a-taste-of-pavex/get_vault_graph.svg" alt="The call graph for `GET /vault`"/>
    <figcaption><i>The call graph for `GET /vault`, the route in our example.</i></figcaption>
</figure>
<p>The call graphs are then used to drive the code generation.</p>
<h2 id="the-future">The future</h2>
<p>I hope I showed you enough to be intrigued.</p>
<p>Back to reality though: <code>pavex</code> is still in its early days, not yet ready for user testing. I have intentionally
avoided publishing the crates on crates.io, the API is too experimental and it would be detrimental 
to encourage its usage at this stage.</p>
<p>There is a lot to work on! Error handling, middleware(s), robust diagnostics, examples, project funding, etc.</p>
<p>In the meantime, you can follow the development on the <a href="https://github.com/LukeMathWalker/pavex">GitHub repository</a>.</p>

      
  </article>
</section></div>
  </body>
</html>
