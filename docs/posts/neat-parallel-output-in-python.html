<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/python-parallel-output/">Original</a>
    <h1>Neat Parallel Output in Python</h1>
    
    <div id="readability-page-1" class="page"><div>
        

        
        
        <p><i>February 22, 2024</i></p>
        
        
        <div>
            <p>Say you have a program that does some processing of a list (loosely based on a
work-in-progress project):</p>

<div><div><pre><code><span>#!/usr/bin/env python3
</span>
<span>def</span> <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>*</span><span>args</span><span>):</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>repo_name</span><span>}</span><span>:&#34;</span><span>,</span> <span>*</span><span>args</span><span>)</span>

<span>def</span> <span>randsleep</span><span>():</span>
    <span>import</span> <span>random</span>
    <span>import</span> <span>time</span>
    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>1</span><span>,</span> <span>5</span><span>))</span>

<span>def</span> <span>func</span><span>(</span><span>repo_name</span><span>):</span>
    <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>&#34;Starting&#34;</span><span>)</span>
    <span>randsleep</span><span>()</span>  <span># Can be substituted for actual work
</span>    <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>&#34;Installing&#34;</span><span>)</span>
    <span>randsleep</span><span>()</span>
    <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>&#34;Building&#34;</span><span>)</span>
    <span>randsleep</span><span>()</span>
    <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>&#34;Instrumenting&#34;</span><span>)</span>
    <span>randsleep</span><span>()</span>
    <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>&#34;Running tests&#34;</span><span>)</span>
    <span>randsleep</span><span>()</span>
    <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>f</span><span>&#34;Result in </span><span>{</span><span>repo_name</span><span>}</span><span>.json&#34;</span><span>)</span>

<span>repos</span> <span>=</span> <span>[</span><span>&#34;repoA&#34;</span><span>,</span> <span>&#34;repoB&#34;</span><span>,</span> <span>&#34;repoC&#34;</span><span>,</span> <span>&#34;repoD&#34;</span><span>]</span>
<span>for</span> <span>repo</span> <span>in</span> <span>repos</span><span>:</span>
    <span>func</span><span>(</span><span>repo</span><span>)</span>
</code></pre></div></div>

<p>This is fine. It works. It’s a little noisy, but it works. But then you
discover something great: your problem is data parallel. That is, you can
process as many repos as your system allows in parallel. Hoorah! You rewrite
using <code>multiprocessing</code>:</p>

<div><div><pre><code><span>import</span> <span>multiprocessing</span>

<span># ...
</span>
<span>with</span> <span>multiprocessing</span><span>.</span><span>Pool</span><span>()</span> <span>as</span> <span>pool</span><span>:</span>
    <span>pool</span><span>.</span><span>map</span><span>(</span><span>func</span><span>,</span> <span>repos</span><span>,</span> <span>chunksize</span><span>=</span><span>1</span><span>)</span>
</code></pre></div></div>

<p>Unfortunately, the output is a little unwieldy. While each line is still nicely
attributed to a repo, it’s spewing lines left and right and the lines are
intermingled. Don’t you miss all the beautiful parallel output from tools such
as Buck and Bazel and Cargo?</p>

<p>Fortunately, StackOverflow user <a href="https://stackoverflow.com/questions/6840420/rewrite-multiple-lines-in-the-console/59147732#59147732">Leedehai</a> is a terminal pro user and
knows how to rewrite multiple lines at a time in the console. We can adapt that
answer for our needs:</p>

<div><div><pre><code><span>def</span> <span>fill_output</span><span>():</span>
    <span>to_fill</span> <span>=</span> <span>num_lines</span> <span>-</span> <span>len</span><span>(</span><span>last_output_per_process</span><span>)</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>to_fill</span><span>):</span>
        <span>print</span><span>()</span>

<span>def</span> <span>clean_up</span><span>():</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>num_lines</span><span>):</span>
        <span>print</span><span>(</span><span>&#34;</span><span>\x1b</span><span>[1A</span><span>\x1b</span><span>[2K&#34;</span><span>,</span> <span>end</span><span>=</span><span>&#34;&#34;</span><span>)</span>  <span># move up cursor and delete whole line
</span>
<span>def</span> <span>log</span><span>(</span><span>repo_name</span><span>,</span> <span>*</span><span>args</span><span>):</span>
    <span>with</span> <span>terminal_lock</span><span>:</span>
        <span>last_output_per_process</span><span>[</span><span>repo_name</span><span>]</span> <span>=</span> <span>&#34; &#34;</span><span>.</span><span>join</span><span>(</span><span>str</span><span>(</span><span>arg</span><span>)</span> <span>for</span> <span>arg</span> <span>in</span> <span>args</span><span>)</span>
        <span>clean_up</span><span>()</span>
        <span>sorted_lines</span> <span>=</span> <span>last_output_per_process</span><span>.</span><span>items</span><span>()</span>
        <span>for</span> <span>repo_name</span><span>,</span> <span>last_line</span> <span>in</span> <span>sorted_lines</span><span>:</span>
            <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>repo_name</span><span>}</span><span>: </span><span>{</span><span>last_line</span><span>}</span><span>&#34;</span><span>)</span>
        <span>fill_output</span><span>()</span>

<span>def</span> <span>func</span><span>(</span><span>repo_name</span><span>):</span>
    <span># ...
</span>    <span>with</span> <span>terminal_lock</span><span>:</span>
        <span>del</span> <span>last_output_per_process</span><span>[</span><span>repo_name</span><span>]</span>

<span># ...
</span>
<span>repos</span> <span>=</span> <span>[</span><span>&#34;repoA&#34;</span><span>,</span> <span>&#34;repoB&#34;</span><span>,</span> <span>&#34;repoC&#34;</span><span>,</span> <span>&#34;repoD&#34;</span><span>]</span>
<span>num_procs</span> <span>=</span> <span>multiprocessing</span><span>.</span><span>cpu_count</span><span>()</span>
<span>num_lines</span> <span>=</span> <span>min</span><span>(</span><span>len</span><span>(</span><span>repos</span><span>),</span> <span>num_procs</span><span>)</span>
<span>with</span> <span>multiprocessing</span><span>.</span><span>Manager</span><span>()</span> <span>as</span> <span>manager</span><span>:</span>
    <span>last_output_per_process</span> <span>=</span> <span>manager</span><span>.</span><span>dict</span><span>()</span>
    <span>terminal_lock</span> <span>=</span> <span>manager</span><span>.</span><span>Lock</span><span>()</span>
    <span>fill_output</span><span>()</span>
    <span>with</span> <span>multiprocessing</span><span>.</span><span>Pool</span><span>()</span> <span>as</span> <span>pool</span><span>:</span>
        <span>pool</span><span>.</span><span>map</span><span>(</span><span>func</span><span>,</span> <span>repos</span><span>,</span> <span>chunksize</span><span>=</span><span>1</span><span>)</span>
    <span>clean_up</span><span>()</span>
</code></pre></div></div>

<p>This will print each item’s status, one line at a time, to the terminal. It
will print in the order that the item is added to <code>last_output_per_process</code>,
but you can change that by (for example), sorting alphanumerically:
<code>sorted(last_output_per_process.items())</code>.</p>

<p>Note that we have to lock both the data structure and the terminal output to
avoid things getting mangled; they are shared (pickled, via <code>Manager</code>) between
processes.</p>

<p>I’m not sure what this does if the log output is multiple lines long or if
someone else is mucking with <code>stdout</code>/<code>stderr</code> (a stray <code>print</code>, perhaps).
Please write in if you find out or have neat solutions.</p>

<p>This technique is probably fairly portable to any programming language that has
threads and locks. The key difference is those implementations should use
threads instead of processes; I did processes because it’s Python.</p>

<p>Check out the expanded version <a href="https://gist.github.com/tekknolagi/4bee494a6e4483e4d849559ba53d067b">in this
Gist</a>.</p>

<h2 id="a-demo-for-you">A demo for you</h2>

<p>Since you read this far, here is a demo of the program:</p>



<p>Enjoy your newfound fun output!</p>

        </div>
            
    <!-- Workaround for FB MITM -->
    <!-- Google tag (gtag.js) -->







    </div></div>
  </body>
</html>
