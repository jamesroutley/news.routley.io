<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/sizetricks/">Original</a>
    <h1>Size Optimization Tricks (2022)</h1>
    
    <div id="readability-page-1" class="page">

<p>
June 10<sup>th</sup>, 2022 @ <a href="https://brian.abelson.live/log/2025/01/index.html">justine&#39;s web page</a>

</p>

<p>
This blog post will cover some of the tricks I&#39;ve used in the past to
make c / c++ / python binaries smaller using x86 assembly. Much of it
will revolve around the
<a href="https://github.com/jart/cosmopolitan">Cosmopolitan</a>
codebase, since I recently received feedback from
the <a href="http://elks.sourceforge.net/">ELKS project</a> that they
love the code and want to hear more about how the tricks cosmo uses can
potentially improve projects as intriguing as a i8086 Linux port. In
many ways I feel a kinship with the ELKS project, since the first thing
I had to do, to build Cosmopolitan, was write an i8086 bootloader
called <a href="https://brian.abelson.live/log/2025/01/ape.html">Actually Portable Executable</a>. Plus it
pleased me to hear that people who&#39;ve been focusing on the problem a lot
longer than I have are pleased with what they&#39;ve read in Cosmopolitan so
far. So I figured it&#39;d be nice to share with a broader audience.

</p><p>
<a href="https://brian.abelson.live/log/2025/01/04/shinmyoumaru-ltr.png"><img width="496" height="425" alt="[Shinmyoumaru Sukuna]" src="https://worker.jart.workers.dev/sizetricks/shinmyoumaru-ltr.png"/></a>

</p><h2 class="page" id="toc">
  <a href="#toc">
    Table of Contents
  </a>
</h2>

<ol>
  <li><a href="#why">Why It Matters</a>
  </li><li><a href="#look">Look at the Binary</a>
  </li><li><a href="#arrange">Field Arrangement</a>
  </li><li><a href="#rle">Run Length Encoding</a>
  </li><li><a href="#decentralized-sections">Decentralized Sections</a>
  </li><li><a href="#dce">Dead Code Elimination</a>
  </li><li><a href="#dzd">δzd Encoding</a>
  </li><li><a href="#overlapping">Overlapping Functions</a>
  </li><li><a href="#printf">Optimizing Printf</a>
  </li><li><a href="#elf">Tiny Portable ELF</a>
  </li><li><a href="#funding">Funding</a>
  </li><li><a href="#see">See Also</a>
</li></ol>

<h2 class="page" id="why">
  <a href="#why">
    Why It Matters
  </a>
</h2>

I like the UNIX philosphy of having lots of small programs. I like it so
much, that the Cosmopolitan repository builds hundreds of them.

<pre><span>$</span> git clone https://github.com/jart/cosmopolitan
<span>$</span> cd cosmopolitan
<span>$</span> make -j16 MODE=tiny
<span>$</span> find o/tiny -name \*.com | wc -l
741
</pre>

<p>
The whole repository takes about fifty seconds to build from scratch on
my PC. Out of those 741 executables, 403 are test executables. It&#39;s nice
to have each set of tests be in a separate executable, to reduce the
chance of a bad test messing up the global state, and leading to hard to
diagnose unrelated failures somewhere else. It also means htop can serve
as a test status free dashboard. Each dot com file is a static binary
which behaves sort of like a Docker container, since they&#39;re usually zip
files too which vendor assets (e.g. tzinfo data). Did I mention each
executable also runs on seven operating systems?

</p><pre><span># testing process</span>
<span>for</span> f <span>in</span> $(find o/tiny/test -name \*_test.com); <span>do</span>
  <span>for</span> os <span>in</span> freebsd openbsd netbsd rhel7 rhel5 win7 win10 xnu; <span>do</span>
    scp $f $os:
    ssh $os ./<span>${f##*/}</span>
  <span>done</span>
<span>done</span>
</pre>

<p>
So all I have to do to test all 400 programs on all 8 supported systems
(3,200 tests total!) is simply <code>scp</code> them onto each host and
run them. That takes about 15 seconds thanks
to <a href="https://github.com/jart/cosmopolitan/blob/ecc8962555c342e0d4ac3edb10bd2f5602e65f4b/tool/build/runit.c#L68">runit</a>
and <a href="https://github.com/jart/cosmopolitan/blob/ecc8962555c342e0d4ac3edb10bd2f5602e65f4b/tool/build/runitd.c#L62">runitd</a>.
It&#39;s been a big productivity boost and enables test-driven development
(also known as TDD) with rapid feedback.

</p>


<p>
What makes this workflow manageable in that <strong>binaries are
small</strong>. The tinier something is, the more instances we can have
of it at scale. So it really isn&#39;t just about running on old computers.
It&#39;s not necessarily about code golfing. It&#39;s about having infinitely
more of a good thing on the cheap with a pleasant coding lifestyle.
Here&#39;s some concrete examples of how small
<a href="https://brian.abelson.live/log/2025/01/ape.html">actually portable executables</a> built with
Cosmopolitan Libc can be:

</p><pre> 16K o/tiny/examples/hello2.com             # calls write  (links syscall)
 20K o/tiny/examples/hello.com              # calls fputs  (links stdio)
 24K o/tiny/examples/hello3.com             # calls printf (links fmt+stdio)
100K o/tiny/test/libc/calls/access_test.com # links test library
216K o/tiny/tool/net/redbean-original.com   # http/1.1 server
1.8M o/tiny/examples/pyapp/pyapp.com        # statically linked python app
</pre>

<p>
Would my isolated hermetic testing workflow have been possible if I was
using a language that needs at minimum 3mb to build a binary? My LAN
only has gigabit ethernet. I don&#39;t need to work at a big company with
industrial fabric switches to transfer these ~100kb test binaries over
the wire. Let&#39;s do some back of the envelope calculations:

</p><pre><span># theoretic minimum seconds transferring cosmo test binaries w/ 1gbps lan uncompressed</span>
&gt;&gt;: (400*8 * 16*1000) / (1024*1024*1024/8)
0.3814697265625

<span># theoretic minimum seconds transferring go test binaries w/ 1gbps lan uncompressed</span>
&gt;&gt;: (400*8 * 3*1000*1000) / (1024*1024*1024/8)
71.52557373046875 
</pre>

<p>
That&#39;s a lot of time to be spending transfering files. Tiny isn&#39;t just
about scale, but surviving long enough to scale. Cosmopolitan is a
scrappy operation. The repo right now only has about 1.5 million lines
of code. What I&#39;m thinking about is how we&#39;re going to host the next
billion lines of code, while everyone else is drowning in technical
debt. Tiny is about the efficient use of resources. Big things must have
small beginnings, because no one wants to build an empire of code on a
tooling foundation that ravages their budget with cloud provider fees.
Altavista ran an entire search engine on a single computer, and now
you&#39;re telling me we need to plug our Full Story Elecron IDEs into a
Kubernetes cluster to compile a C++ app that does math. How does that
add up?

</p><p>
  <a href="https://brian.abelson.live/log/2025/01/04/AlwaysBeCoding.jpg"><img width="600" height="330" alt="[ABC - Always Be Coding]" src="https://worker.jart.workers.dev/sizetricks/AlwaysBeCoding.jpg"/></a>

</p><p>
Losers always whine about how their bloat is a calculated tradeoff. The
important thing to consider is that there is no tradeoff. Just engineers
who&#39;ve been victimized by the accidental complexity of modern software,
chose to stop caring, and yearn for another break while their code
compiles—like Dennis from Jurassic Park. Bloat is like the fake
jobs version of scalability, in the sense that bloat offers hungry devs
the thrill of complexity without the advantages. I used to operate a
storage system with exabytes of data, and it honestly didn&#39;t feel that
different from what I&#39;m doing now, working on the tiniest software in
the world. It&#39;s the stuff in the middle I just don&#39;t find as appealing.

</p><p>
In any case, as an avid reader of codebases, bloat is unpleasant. I
think codebases have been lacking in a woman&#39;s touch for decades; and
that especially applies to open source, which has never really had a
woman&#39;s touch at all. We can fix that, but overall, the best way to
improve software development is to make it more fun. There&#39;s few things
more fun than size coding.

</p><h2 class="page" id="look">
  <a href="#look">
    Look at the Binary
  </a>
</h2>

<p>
I think the biggest disadvantage of anyone looking to size optimize
systemically is the difficulty of intuitive thinking. Especially for
guys who use traditional hex editors. Here&#39;s what run-length encoded
data looks like:

</p><pre>0002d0b0  01 00 01 03 01 06 01 09  01 0c 01 0f 01 12 14 1e  |................|
0002d0c0  01 15 04 1e 01 18 17 1e  01 1e 1c 1e 01 1b 00 00  |................|
0002d0d0  21 01 01 00 02 01 01 00  01 01 09 00 01 01 0a 00  |!...............|
0002d0e0  01 01 01 00 01 01 01 00  03 01 1a 00 04 01 01 00  |................|
0002d0f0  01 01 1a 00 03 01 01 00  81 01 00 00 00 00 00 00  |................|
0002d100  21 01 01 00 02 01 01 00  01 01 16 00 01 01 01 00  |!...............|
0002d110  01 01 1c 00 04 01 01 00  01 01 1a 00 03 01 01 00  |................|
0002d120  81 01 00 00 00 00 00 00  21 01 01 00 02 01 01 00  |........!.......|
0002d130  01 01 09 00 01 01 0c 00  01 01 01 00 03 01 1a 00  |................|
</pre>

<p>
Hex editors are a really good tool when you&#39;re looking for a specific
thing and need a specific answer, but they reveal little visually about
the shape and form of a binary. You&#39;re not actually looking. You&#39;re just
studying empirical data with a razor sharp focus that can easily become
tunnel-vision. <a href="https://brian.abelson.live/log/2025/01/blinkenlights/">Blinkenlights</a> solves this
problem by using IBM Code Page 437. If we use it to visualize the same
run-length encoded data above, and it&#39;s able to give us a better glance.

</p><p>
  <a href="https://brian.abelson.live/log/2025/01/04/rle.png"><img width="618" height="437" alt="[run-length encoded data in blinkenlights]" src="https://worker.jart.workers.dev/sizetricks/rle.png"/></a>

</p><p>
Please keep in mind, this is a <em>purely intuitive</em> display. It&#39;s
going to look like gobbledygook to anyone who&#39;s unfamiliar with CP437,
but surely anyone can agree it&#39;s better than a wall of period marks, in
terms of the richness and complexity of the information it succinctly
conveys. CP437 can be thought of as an alphabet with 256 letters. You
can scroll through pages and pages of this stuff and your mind will
magically spot and identify patterns. For example, you&#39;ll gain an
intuition for what data does. For example, here&#39;s an indirect jump
table:

</p><p>
<a href="https://brian.abelson.live/log/2025/01/04/jumptab.png"><img width="711" height="310" alt="[jumptab.png]" src="https://worker.jart.workers.dev/sizetricks/jumptab.png"/></a>

</p><p>
Here&#39;s what a <code>struct</code> looks like when it&#39;s compiled
with <code><span>__attribute__</span>((<span>__packed__</span>))</code>:

</p><p>
<a href="https://brian.abelson.live/log/2025/01/04/packed.png"><img width="642" height="563" alt="[packed.png]" src="https://worker.jart.workers.dev/sizetricks/packed.png"/></a>

</p><p>
Here&#39;s what x86-64 code looks like:

</p><p>
<a href="https://brian.abelson.live/log/2025/01/04/x86-64-code.png"><img width="709" height="280" alt="[x86-64-code.png]" src="https://worker.jart.workers.dev/sizetricks/x86-64-code.png"/></a>

</p><p>
Here&#39;s what <code>/dev/urandom</code> looks like:

</p><p>
<a href="https://brian.abelson.live/log/2025/01/04/urandom.png"><img width="708" height="271" alt="[urandom.png]" src="https://worker.jart.workers.dev/sizetricks/urandom.png"/></a>

</p><p>
And here&#39;s what binaries built with UBSAN (Undefined Behavior Sanitizer)
look like. As we can see, it&#39;s got plenty of room for improvement, and
obviously explains why UBSAN binaries are so enormous. It&#39;s poor struct
packing.

</p><p>
<a href="https://brian.abelson.live/log/2025/01/04/ubsan-bing.png"><img width="719" height="460" alt="[ubsan-bing.png]" src="https://worker.jart.workers.dev/sizetricks/ubsan-bing.png"/></a>

</p><p>
Cosmopolitan is an ex nihilo codebase. I started this project with an
empty file and an assembler. Pretty much every byte that&#39;s gone into APE
binaries since then, I&#39;ve had some role in either creating and/or
monitoring. As such, the two very first tools I wrote with Cosmopolitan
Libc were intended to help me do just that.

</p><pre>-rwxr-xr-x 1 501 jart 52K Jun  9 09:08 <a href="https://brian.abelson.live/log/2025/01/04/bing.com">bing.com</a> (see <a href="https://github.com/jart/cosmopolitan/blob/master/tool/viz/bing.c">bing.c</a>)
-rwxr-xr-x 1 501 jart 32K Jun  9 09:08 <a href="https://brian.abelson.live/log/2025/01/04/fold.com">fold.com</a> (see <a href="https://github.com/jart/cosmopolitan/blob/master/tool/viz/fold.c">fold.c</a>)
</pre>

<p>
I use them with the following shell script wrapper
named <code>~/bin/bf</code>.

</p><pre><span>#!/bin/sh</span>
bing.com &lt;<span>&#34;$1&#34;</span> |
  fold.com |
  exec less
</pre>

<p>
So whenever I want to take a peek inside a file, I just type a command
like:

</p><pre>bf o//examples/hello.com
</pre>

<p>
I&#39;ve written a few other scripts that come in handy. For instance,
here&#39;s <code>~/bin/bloat</code> which shows which symbols in a .com.dbg
file are the biggest.

</p><pre><span>#!/bin/sh</span>
nm -C --size <span>&#34;$<span>@</span>&#34;</span> |
  sort -r |
  grep <span>&#39; [bBtTRr] &#39;</span> |
  <span>exec</span> less
</pre>

<h2 class="page" id="arrange">
  <a href="#arrange">
    Field Arrangement
  </a>
</h2>

<p>
Struct packing is a nice wholesome size optimization that&#39;s not the
least bit controversial. One good example is something I once noticed
about Python 3.6 when viewing it through bing | fold. A core Python
parser struct has suboptimal field arrangement.

</p><pre><span>typedef</span> <span>struct</span> {
    <span>int</span>		 s_narcs;
    <span>arc</span>		*s_arc;
    <span>int</span>		 s_lower;
    <span>int</span>		 s_upper;
    <span>int</span>		*s_accel;
    <span>int</span>		 s_accept;
} <span>state</span>;
</pre>

<p>
I wouldn&#39;t have noticed this if I was reading the code, since sometimes
the stuff underneath the iceberg isn&#39;t always clear. That struct above,
is actually equivalent to the following at the binary level:

</p><pre><span>typedef</span> <span>struct</span> {
    <span>int</span>		 s_narcs;
    <strong><span>int</span>		 __pad1;   <span>// four wasted bytes</span></strong>
    <span>arc</span>		*s_arc;
    <span>int</span>		 s_lower;
    <span>int</span>		 s_upper;
    <span>int</span>		*s_accel;
    <span>int</span>		 s_accept;
    <strong><span>int</span>		 __pad2;   <span>// four wasted bytes</span></strong>
} <span>state</span>;
</pre>

<p>
So I moved the <code>s_accept</code> field to a different line, and it
shaved 4kb off every Python binary.

</p><pre><span>typedef</span> <span>struct</span> {
    <span>int</span>		 s_narcs;
    <strong><span>int</span>		 s_accept;</strong>
    <span>arc</span>		*s_arc;
    <span>int</span>		 s_lower;
    <span>int</span>		 s_upper;
    <span>int</span>		*s_accel;
} <span>state</span>;
</pre>

<p>
Everything counts in small amounts. I also imagine there&#39;s some
corporate styleguides at various companies where the latter code would
be preferred, strictly for policy reasons. Since it&#39;s not great from a
readability standpoint to have people scratching their heads wondering
where the gaps are in your data structures, if they need assurances at
the application binary interface level. So we&#39;re not only saving space
but leading to better code hygeine too.

</p><h2 class="page" id="rle">
  <a href="#rle">
    Run Length Encoding
  </a>
</h2>

<p>
There are so many outstanding compression algorithms in the news, based
on machine learning and even classical algorithms, that I imagine many
self-taught programmers might not be familiar with the really simple
primitive ones that, in certain cases, get the job done. One such
example is run-length encoding. The way it works, is if you have a
sequence such as:

</p><pre>1,1,1,1,1,1,1,1,2,2,2,3
</pre>

<p>
Then you&#39;d encode it as sequence of {count, thing} tuples with a {0,0}
terminator.

</p><pre>8,1, 3,2, 1,3, 0,0
</pre>

<p>
What I love about run-length encoding is (1) it&#39;s so simple that the
compressed data stream can be edited by hand; and (2) its decompressor
only requires 14 bytes of code.

</p><pre><span>/	Fourteen byte decompressor.</span>
<span>/</span>
<span>/	<span>@param</span>	<span>di</span> points to output buffer</span>
<span>/	<span>@param</span>	<span>si</span> points to uint8_t {len₁,byte₁}, ..., {0,0}</span>
<span>/	<span>@arch</span>	x86-64,i386,i8086</span>
<span>/	<span>@see</span>	<a href="https://github.com/jart/cosmopolitan/blob/master/libc/nexgen32e/rldecode.S">libc/nexgen32e/rldecode.S</a></span>
<span>rldecode</span>:
<span>31 c9</span>	<span>xor</span>	<span>%ecx</span>,<span>%ecx</span>
<span>ac</span><span>0</span>:	<abbr title="load byte at address SI into AL"><span>lodsb</span></abbr>
<span>86 c1</span>	<abbr title="Exchange"><span>xchg</span></abbr>	<span>%al</span>,<span>%cl</span>
<span>ac</span>	<abbr title="Load byte at address SI into AL"><span>lodsb</span></abbr>
<span>e3 05</span>	<abbr title="Jump short if CX register is 0"><span>jrcxz</span></abbr>	2<span>f</span>
<span>aa</span><span>1</span>:	<abbr title="Store AL at address DI."><span>stosb</span></abbr>
<span>e2 fd</span>	<abbr title="Decrement count; jump short if count ≠ 0."><span>loop</span></abbr>	1<span>b</span>
<span>eb f5</span>	<span>jmp</span>	0<span>b</span>
<span>c3</span><span>2</span>:	<span>ret</span>
	<span>.type</span>	rldecode,<span>@function</span>
	<span>.size</span>	rldecode,.-rldecode
	<span>.globl</span>	rldecode
</pre>



<p>
That particular example is beautiful, since it&#39;s binary compatible with
i8086, i386, and x86-64. However assembly doesn&#39;t always mean fast. For
better explainability and performance, the following C code should do
the trick:

</p><pre><span>struct</span> <span>RlDecode</span> {
  <span>uint8_t</span> repititions;
  <span>uint8_t</span> byte;
};

<span>void</span> <span>rldecode2</span>(<span>uint8_t</span> *p, <span>const</span> <span>struct</span> <span>RlDecode</span> *r) {
  <span>for</span> (; r-&gt;repititions; ++r) {
    memset(p, r-&gt;byte, r-&gt;repititions);
    p += r-&gt;repititions;
  }
}
</pre>

<p>
Run-length encoding is only appropriate for compressing sparse data. For
denser data, RLE, will double its size! However it just so happens that,
when we&#39;re making binaries smaller, there&#39;s usually many sparse data
structures that can be efficiently run-length encoded.

</p><p>
One such example are the character translation tables used by the
redbean web server, when parsing URIs and HTTP messages. One thing most
C/C++ developers figure out eventually is that it&#39;s really efficient to
perform a character lookup in a table with 256 entries. Why? Because
your C compiler will turn C code like <code>rdi[al &amp; 255]</code> into
assembly that looks like this:

</p><pre>	<span>movzbl</span>	<span>%al</span>,<span>%eax</span>
	<span>mov</span>	(<span>%rdi</span>,<span>%rax</span>),<span>%al</span>
</pre>

<p>
That&#39;s super fast, and memory safe too. Hardware engineers would call it
a LookUp Table or LUT for short. It&#39;s quite integral to the workings of
microprocessors. The x86 architecture even has a deprecated instruction
called <a href="https://www.felixcloutier.com/x86/xlat:xlatb">XLAT</a>
that&#39;s dedicated to this very thing. With HTTP, the most important use
case for LUTs is to check if characters are legal. For example, many of
the components of an HTTP message are required to be &#34;tokens&#34;
quoth <a href="https://brian.abelson.live/log/2025/01/04/rfc2616.txt">RFC2616</a>:

</p><pre>CHAR           = &lt;any US-ASCII character (octets 0 - 127)&gt;
SP             = &lt;US-ASCII SP, space (32)&gt;
HT             = &lt;US-ASCII HT, horizontal-tab (9)&gt;
CTL            = &lt;any US-ASCII control character
                 (octets 0 - 31) and DEL (127)&gt;
token          = 1*&lt;any CHAR except CTLs or separators&gt;
separators     = &#34;(&#34; | &#34;)&#34; | &#34;&lt;&#34; | &#34;&gt;&#34; | &#34;@&#34;
               | &#34;,&#34; | &#34;;&#34; | &#34;:&#34; | &#34;\&#34; | &lt;&#34;&gt;
               | &#34;/&#34; | &#34;[&#34; | &#34;]&#34; | &#34;?&#34; | &#34;=&#34;
               | &#34;{&#34; | &#34;}&#34; | SP | HT
</pre>

<p>
As plain C code, we could write our token LUT as follows:

</p><pre><span>const</span> <span>char</span> kHttpToken[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0x00</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0x10</span>
   0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, <span>// 0x20  ! #$%&amp;‘  *+ -. </span>
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, <span>// 0x30 0123456789      </span>
   0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, <span>// 0x40  ABCDEFGHIJKLMNO</span>
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, <span>// 0x50 PQRSTUVWXYZ   ^_</span>
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, <span>// 0x60 `abcdefghijklmno</span>
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, <span>// 0x70 pqrstuvwxyz | ~ </span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0x80</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0x90</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0xa0</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0xb0</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0xc0</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0xd0</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0xe0</span>
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <span>// 0xf0</span>
};
</pre>

<p>
That way we can just say <code>kHttpToken[c &amp; 255]</code> to check if a
character is valid in a token. But if we wanted to save 200 bytes of
binary size, we could use run-length encoding.

</p><pre>	<span>.globl</span>	kHttpToken
	<span>.section</span> .bss.sort.100.kHttpToken,<span>&#34;aw&#34;</span>,<span>@nobits</span>
<span>/	<span>@see</span>	<a href="https://github.com/jart/cosmopolitan/blob/master/net/http/khttptoken.S">net/http/khttptoken.S</a></span>
<span>kHttpToken</span>:
	<span>.zero</span>	256
	<span>.section</span> .rodata.sort.100.kHttpToken,<span>&#34;a&#34;</span>,<span>@progbits</span>
	<span>.byte</span>	 33,0                   <span># 00-20 ∅-␠</span>
	<span>.byte</span>	  1,1                   <span># 21-21 !-!</span>
	<span>.byte</span>	  1,0                   <span># 22-22 “-“</span>
	<span>.byte</span>	  5,1                   <span># 23-27 #-‘</span>
	<span>.byte</span>	  2,0                   <span># 28-29 (-)</span>
	<span>.byte</span>	  2,1                   <span># 2a-2b *-+</span>
	<span>.byte</span>	  1,0                   <span># 2c-2c ,-,</span>
	<span>.byte</span>	  2,1                   <span># 2d-2e --.</span>
	<span>.byte</span>	  1,0                   <span># 2f-2f /-/</span>
	<span>.byte</span>	 10,1                   <span># 30-39 0-9</span>
	<span>.byte</span>	  7,0                   <span># 3a-40 :-@</span>
	<span>.byte</span>	 26,1                   <span># 41-5a A-Z</span>
	<span>.byte</span>	  3,0                   <span># 5b-5d [-]</span>
	<span>.byte</span>	 29,1                   <span># 5e-7a ^-z</span>
	<span>.byte</span>	  1,0                   <span># 7b-7b {-{</span>
	<span>.byte</span>	  1,1                   <span># 7c-7c |-|</span>
	<span>.byte</span>	  1,0                   <span># 7d-7d }-}</span>
	<span>.byte</span>	  1,1                   <span># 7e-7e ~-~</span>
	<span>.byte</span>	129,0                   <span># 7f-ff ⌂-λ</span>
	<span>.byte</span>	0,0                     <span># terminator</span>
	<span>.section</span> .init.sort.100.kHttpToken,<span>&#34;a&#34;</span>,<span>@progbits</span>
	<span>call</span>	rldecode
</pre>

<p>
There&#39;s a tool in the Cosmopolitan codebase for automatically generating
these assembly files.

</p><pre>o//tool/build/<a href="https://brian.abelson.live/log/2025/01/04/xlat.com">xlat.com</a> -TiC <span>&#39; ()&lt;&gt;@,;:\&#34;/[]?={}&#39;</span> -iskHttpToken
</pre>

<h2 class="page" id="decentralized-sections">
  <a href="#decentralized-sections">
    Decentralized Sections
  </a>
</h2>

<p>
The assembly code in the previous section that&#39;s generated by xlat.com
might seem a bit strange, even for experienced x86 assembly programmers.
It&#39;s a technique somewhat uniquely resurrected for Cosmopolitan, based
on a reading of old code from the 70&#39;s and 80&#39;s. We&#39;ll call it
&#34;decentralized sections&#34;.

</p><p>
Decentralized sections are a way by which we can write a single function
whose code spans multiple files. The canonical example of this, is the
classic UNIX <code>_init()</code> function, which you&#39;ll find empty in
nearly every modern codebase, because <code>_init()</code> is somewhat
of a lost art intended to be assembled by the linker script.

</p><p>
The way this works is your libc defines the stubs for the prologue and
epilogue of the <code>_init()</code> function. Here&#39;s how Cosmopolitan
Libc defines it (with some slight edits to reduce macro usage in order
to improve copy/pastability):

</p><pre>	<span>.section</span> .init_prologue,<span>&#34;ax&#34;</span>,<span>@progbits</span>
	<span>.globl</span>	_init
<span>/	<span>@param</span>	r12 is argc (still callee saved)</span>
<span>/	<span>@param</span>	r13 is argv (still callee saved)</span>
<span>/	<span>@param</span>	r14 is envp (still callee saved)</span>
<span>/	<span>@param</span>	r15 is envp (still callee saved)</span>
<span>/	<span>@note</span>	rdi is __init_bss_start (callee monotonic lockstep)</span>
<span>/	<span>@note</span>	rsi is __init_rodata_start (callee monotonic lockstep)</span>
<span>/	<span>@see</span>	<a href="https://github.com/jart/cosmopolitan/blob/master/libc/runtime/init.S">libc/runtime/init.S</a></span>
<span>_init</span>:	<span>push</span>	<span>%rbp</span>
	<span>mov</span>	<span>%rsp</span>,<span>%rbp</span>
	<span>lea</span>	__init_bss_start(<span>%rip</span>),<span>%rdi</span>
	<span>lea</span>	__init_rodata_start(<span>%rip</span>),<span>%rsi</span>
	<span>.previous</span><span>/*
	...
	decentralized content
	...
	*/</span><span>.section</span> .init_epilogue,<span>&#34;ax&#34;</span>,<span>@progbits</span>
<span>_woot</span>:	<span>leave</span>
	<span>ret</span>
	<span>.previous</span>
</pre>

<p>
Your libc also needs to declare stubs for the data sections. These
technically could be declared in the linker script, but it&#39;s nicer to
write them in a .S file so the symbols don&#39;t get defined unless they&#39;re
being linked.

</p><pre>	<span>.section</span> .init_rodata_prologue,<span>&#34;a&#34;</span>,<span>@progbits</span>
	<span>.globl</span>	__init_rodata_start,__init_rodata_end
	<span>.align</span>	<span>__SIZEOF_POINTER__</span>
<span>__init_rodata_start</span>:
	<span>.previous</span><span>/*
	...
	decentralized content
	...
	*/</span><span>.section</span> .init_rodata_epilogue,<span>&#34;a&#34;</span>,<span>@progbits</span>
<span>__init_rodata_end</span>:
	<span>.byte</span>	0x90
	<span>.previous</span>

	<span>.section</span> .init_bss_prologue,<span>&#34;aw&#34;</span>,<span>@nobits</span>
	<span>.globl</span>	__init_bss_start,__init_bss_end
	<span>.align</span>	<span>__SIZEOF_POINTER__</span>
<span>__init_bss_start</span>:
	<span>.previous</span><span>/*
	...
	decentralized content
	...
	*/</span><span>.section</span> .init_bss_epilogue,<span>&#34;aw&#34;</span>,<span>@nobits</span>
<span>__init_bss_end</span>:
	<span>.byte</span>	0
	<span>.previous</span>

</pre>

<p>
We then configure our linker script as follows:

</p><pre><span>/* see <a href="https://github.com/jart/cosmopolitan/blob/master/ape/ape.lds">ape/ape.lds</a> */</span>
<span>SECTIONS</span> {
  .text . : {
    <span>KEEP</span>(*(.init_prologue))
    <span>KEEP</span>(*(<span>SORT_BY_NAME</span>(.init.sort.*)))
    <span>KEEP</span>(*(.init))
    <span>KEEP</span>(*(.init_epilogue))
    *(.text .text.*)
    <span>KEEP</span>(*(<span>SORT_BY_NAME</span>(.rodata.sort.*)))
    *(.rodata .rodata.*)
  }
  .bss . : {
    <span>KEEP</span>(*(<span>SORT_BY_NAME</span>(.bss.sort.*)))
    *(<span>SORT_BY_ALIGNMENT</span>(.bss))
    *(<span>SORT_BY_ALIGNMENT</span>(.bss.*))
    *(<span>COMMON</span>)
  }
}
</pre>

<p>
It&#39;s now possible to write assembly files that insert content into
the <code>_init()</code> function, along with the
concomitant <code>__init_rodata_start</code>
and <code>__init_bss_start</code> data structures. Both the read-only
data and the uninitialized data (BSS) sections are optional. The only
thing that&#39;s mandatory is that, unlike the normal System V Application
Binary Interface, our _init() code isn&#39;t allowed to clobber RDI and RSI.
Because they store lockstep pointers to the rodata and bss.

</p><p>
Here&#39;s an example than of how it can be used, that&#39;s simpler than the
kHttpToken example above. Let&#39;s say I need to support the AMD K8 aand
Barcelona microarchitectures, but I want to take advantage of SSSE3
(which is the best SSE). The industry practice here is to perform a
CPUID check behind a double-checked <code>pthread_once()</code> guard,
because the CPUID instruction takes 50 nanoseconds each time, whereas
the once guard averages out over many calls to cost half a nanosecond.
However the <code>_init()</code> function provides a better solution,
since it obfuscates the need for synchronization libraries, due to
how <code>_init()</code> is called before all other constructors,
thereby making it highly unlikely that any threads to have been created.

</p><pre>	<span>.section</span> .bss.sort.100.kCpuid1,<span>&#34;aw&#34;</span>,<span>@nobits</span>
<span>/	uint32_t kCpuid1[4];</span>
<span>/	<span>@see</span>	<a href="https://github.com/jart/cosmopolitan/blob/master/libc/nexgen32e/kcpuids.S">libc/nexgen32e/kcpuids.S</a></span>
<span>kCpuid1</span>:<span>.long</span>	0,0,0,0
	<span>.globl</span>	kCpuid1
	<span>.type</span>	kCpuid1,<span>@object</span>
	<span>.size</span>	kCpuid1,.-kCpuid1

	<span>.section</span> .init.sort.100.kCpuid1,<span>&#34;a&#34;</span>,<span>@progbits</span>
<span>53</span>	<span>push</span>	<span>%rbx</span>
<span>6a 01</span>	<span>push</span>	<span>$1</span>
<span>58</span>	<span><abbr title="eax = 1 (Asks CPUID for &#39;Processor Info and Feature Bits&#39;)">pop</abbr></span>	<span>%rax</span>
<span>0f a2</span>	<span><abbr title="stores result into eax,ebx,ecx,edx">cpuid</abbr></span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>93</span>	<span><abbr title="eax = ebx">xchg</abbr></span>	<span>%eax</span>,<span>%ebx</span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>91</span>	<span><abbr title="eax = ecx">xchg</abbr></span>	<span>%eax</span>,<span>%ecx</span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>92</span>	<span><abbr title="eax = edx">xchg</abbr></span>	<span>%eax</span>,<span>%edx</span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>5b</span>	<span>pop</span>	<span>%rbx</span>
</pre>



<p>
The code above only adds 14 bytes of content to the binary. It scales in
terms of development model; any number of libraries throughout your
codebase can follow this process without stepping on each others toes.
As a model, decentralized sections really gives us a sweet spot that
caters to the gigantic codebases big companies respect, while creating
the tiny binaries indie developers adore. It&#39;s also much lighter weight
than needing to pull in a dependency on -lpthread. Now, when I want to
check if SSSE3 is available, all I have to do is check if the 9th bit of
the ECX we stored earlier is set:

</p><pre><span>if</span> (kCpuid1[2][1&lt;&lt;9]) {
  <span>// we have ssse3!</span>
} else {
  <span>// it&#39;s k8 or barcelona</span>
}
</pre>

<p>
If you&#39;re using a different libc from cosmo (e.g. musl, glibc) then you
can still use this same technique, today, with some slight alteration.

</p><pre>	<span>.bss</span>
<span>kCpuid1</span>:<span>.long</span>	0,0,0,0
	<span>.globl</span>	kCpuid1
	<span>.type</span>	kCpuid1,<span>@object</span>
	<span>.size</span>	kCpuid1,.-kCpuid1

	<span>.section</span> .init,<span>&#34;a&#34;</span>,<span>@progbits</span>
<span>53</span>	<span>push</span>	<span>%rbx</span>
<span>48 8d 3d 00 00 00 00</span>	<span><abbr title="load address of kCpuid1 into RDI">lea</abbr></span>	kCpuid1(<span>%rip</span>),<span>%rdi</span>
<span>6a 01</span>	<span>push</span>	<span>$1</span>
<span>58</span>	<span><abbr title="eax = 1 (Asks CPUID for &#39;Processor Info and Feature Bits&#39;)">pop</abbr></span>	<span>%rax</span>
<span>0f a2</span>	<span><abbr title="stores result into eax,ebx,ecx,edx">cpuid</abbr></span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>93</span>	<span><abbr title="eax = ebx">xchg</abbr></span>	<span>%eax</span>,<span>%ebx</span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>91</span>	<span><abbr title="eax = ecx">xchg</abbr></span>	<span>%eax</span>,<span>%ecx</span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>92</span>	<span><abbr title="eax = edx">xchg</abbr></span>	<span>%eax</span>,<span>%edx</span>
<span>ab</span>	<span><abbr title="*((int *)rdi)++ = eax">stosl</abbr></span>
<span>5b</span>	<span>pop</span>	<span>%rbx</span>
</pre>

<p>
Here we need to pay for 7 additional bytes (21 bytes total), because the
lockstep cooperation between <code>_init()</code> / rodata / bss is
unique to Cosmo and not implemented by other C libraries. But in either
case, both assembly solutions are a clear win over the C/C++ equivalent,
which needs 42 bytes.

</p><pre><span>uint32_t</span> kCpuid1[4];

<span>__attribute__</span>((<span>__constructor__</span>)) <span>static</span> <span>void</span> <span>kCpuid1Init</span>() {
  <span>uint32_t</span> ax, bx, cx, dx;
  <span>asm</span>(<span>&#34;cpuid&#34;</span> : <span>&#34;=a&#34;</span>(ax), <span>&#34;=b&#34;</span>(bx), <span>&#34;=c&#34;</span>(cx), <span>&#34;=d&#34;</span>(dx) : <span>&#34;0&#34;</span>(1));
  kCpuid1[0] = ax;
  kCpuid1[1] = bx;
  kCpuid1[2] = cx;
  kCpuid1[3] = dx;
}
</pre>



<p>
If there&#39;s one thing I&#39;ve learned working on Cosmopolitan, it&#39;s that
with the right finesse, the C compiler can produce really tiny code if
we&#39;re willing to write assembly inside string literals. The following
code shows how to get GCC and Clang to do it in 30 bytes. Whether or not
it&#39;s worth it versus just writing assembly is up to the reader.

</p><pre><span>uint32_t</span> kCpuid1[4];

<span>__attribute__</span>((<span>__constructor__</span>)) <span>static</span> <span>void</span> <span>kCpuid1Init</span>() {
  <span>uint32_t</span> ax, *di;
  <span>asm</span> <span>volatile</span>(<span>&#34;cpuid\r\n&#34;
               &#34;stosl\r\n&#34;
               &#34;xchg\t%%ebx,%%eax\r\n&#34;
               &#34;stosl\r\n&#34;
               &#34;xchg\t%%ecx,%%eax\r\n&#34;
               &#34;stosl\r\n&#34;
               &#34;xchg\t%%edx,%%eax\r\n&#34;
               &#34;stosl&#34;</span>
               : <span>&#34;=a&#34;</span>(ax), <span>&#34;=D&#34;</span>(di)
               : <span>&#34;0&#34;</span>(1), <span>&#34;1&#34;</span>(kCpuid1)
               : <span>&#34;rbx&#34;</span>, <span>&#34;rcx&#34;</span>, <span>&#34;rdx&#34;</span>, <span>&#34;memory&#34;</span>);
}
</pre>

<p>
The main thing that makes the C code clunkier is it needs to generate an
8 byte function pointer in a <code>.ctors</code> section which needs to
be added to the linker script separately. Your C library will normally
call ctors after _init() is finished. There really aren&#39;t any acceptable
solutions for getting a modern C compiler to generate &#34;decentralized
section&#34; style code. The closest we can get is the following, using GCC
(but certainly not Clang, which claims dominion over all registers).

</p><pre><span>register</span> <span>long</span> di <span>asm</span>(<span>&#34;rdi&#34;</span>);
<span>register</span> <span>long</span> si <span>asm</span>(<span>&#34;rsi&#34;</span>);

<span>__attribute__</span>((<span>__section__</span>(<span>&#34;.bss.sort.100.kCpuid1,\&#34;aw\&#34;,@nobits #&#34;</span>)))
<span>uint32_t</span> kCpuid1[4];

<span>__attribute__</span>((<span>__used__</span>,
               <span>__section__</span>(<span>&#34;.init.sort.100.kCpuid1,\&#34;a\&#34;,@progbits #&#34;</span>)))
<span>static</span> <span>void</span> <span>kCpuid1Init</span>(void) {
  <span>uint32_t</span> ax;
  <span>asm</span> <span>volatile</span>(<span>&#34;push\t%%rbx\r\n&#34;
               &#34;cpuid\r\n&#34;
               &#34;stosl\r\n&#34;
               &#34;xchg\t%%ebx,%%eax\r\n&#34;
               &#34;stosl\r\n&#34;
               &#34;xchg\t%%ecx,%%eax\r\n&#34;
               &#34;stosl\r\n&#34;
               &#34;xchg\t%%edx,%%eax\r\n&#34;
               &#34;stosl\r\n&#34;
               &#34;push\t%%rbx&#34;</span>
               : <span>&#34;=a&#34;</span>(ax), <span>&#34;+D&#34;</span>(di)
               : <span>&#34;0&#34;</span>(1)
               : <span>&#34;rcx&#34;</span>, <span>&#34;rdx&#34;</span>, <span>&#34;memory&#34;</span>);
  <span>__builtin_unreachable</span>();  <span>// prevent generation of RET instruction</span>
}
</pre>

<p>
The problem with the above code is it&#39;s brittle. You need to pass
compiler flags like <code>-ffixed-rdi -ffixed-rsi -fomit-frame-pointer
-O -fno-sanitize=all</code> for it to work properly. The value of a C
compiler is being able to bloat our code with debugging tools (like
ASAN) when we want them. So with code like this, where that can&#39;t
happen, it&#39;s usually best to just write assembly.

</p><h2 class="page" id="dce">
  <a href="#dce">
    Dead Code Elimination
  </a>
</h2>

<p>
Naturally, if you&#39;re a Cosmopolitan Libc user, all the stuff in the
CPUID examples above would would be taken care of for you, and you need
to say is this:

</p><pre><span>// see <a href="https://github.com/jart/cosmopolitan/blob/master/libc/nexgen32e/x86feature.h">libc/nexgen32e/x86feature.h</a></span>
<span>if</span> (X86_HAVE(SSSE3)) {
  <span>// we have ssse3!</span>
} else {
  <span>// it&#39;s k8 or barcelona</span>
}
</pre>

<p>
It&#39;s worth taking a look at its implementation in
<a href="https://github.com/jart/cosmopolitan/blob/master/libc/nexgen32e/x86feature.h">x86feature.h</a>
since it&#39;s quite possibly the most beautiful abstraction created with
the C preprocessor you&#39;re likely to find in the entire codebase. It also
embodies one of the most important patterns of Cosmopolitan macros,
which is the hybridization of compile-time and runtime checking. It&#39;s
needed by Actually Portable Executable (which relies heavily on runtime
dispatch) while still granting all the traditional compile-time define
flag tuning that developers love. For example, the #ifdef model could be
implemented here as follows:

</p><pre><span>#if</span> X86_REQUIRE(SSSE3)
  <span>// we have ssse3!</span>
<span>#else</span>
  <span>// it&#39;s k8 or barcelona</span>
<span>#endif</span>
</pre>

<p>
In that case, your program can only support SSSE3 if the user passes
the <code>-mssse3</code> flag to the compiler. It&#39;s better to use
the <code>X86_HAVE()</code> macro because it does the same thing
as <code>X86_REQUIRE(SSSE3)</code> except it has a runtime check too. By
default, if you pass no microarchitecture flags to GCC or Clang, both
branches get included in the binary.

</p><pre><span>if</span> (X86_HAVE(SSSE3)) {
  <span>// do some wild ssse3 assembly hacks</span>
} else {
  <span>// fallback to slow ansi c code</span>
}
</pre>

<p>
But if the user chooses to pass the <code>-mssse3</code> flag, then the
fallback bloat for supporting old CPU models gets removed by a compiler
optimization pass, along with the runtime check itself.

</p><pre><del><span>if</span> (X86_HAVE(SSSE3)) {</del>
  <span>// do some wild ssse3 assembly hacks</span>
<del>} else {
  <span>// fallback to slow ansi c code</span>
}</del>
</pre>

<p>
This is what MODE=opt does with the Makefile build config by default. It
passes the <code>-march=native</code> flag to the compiler, which asks
it to figure out what features the CPU in your host machine has, and
then Cosmopolitan and GCC work together to produce a binary that&#39;s just
right and optimally fast your machine. The tradeoff is you won&#39;t be able
to distribute any such binaries, since they might not run on other x86
CPU models.

</p><p>
The basic idea behind how the hybrid model to dead code elimination and
runtime branching works, is most simply and elegantly expressed in
<a href="https://github.com/jart/cosmopolitan/blob/master/ape/loader.c">ape/loader.c</a>
and <a href="https://github.com/jart/cosmopolitan/blob/master/libc/dce.c">libc/dce.c</a>.

</p><pre><span>#define</span> LINUX   1
<span>#define</span> METAL   2
<span>#define</span> WINDOWS 4
<span>#define</span> XNU     8
<span>#define</span> OPENBSD 16
<span>#define</span> FREEBSD 32
<span>#define</span> NETBSD  64

<span>#define</span> <span>SupportsLinux</span>()   (SUPPORT_VECTOR &amp; LINUX)
<span>#define</span> <span>SupportsXnu</span>()     (SUPPORT_VECTOR &amp; XNU)
<span>#define</span> <span>SupportsFreebsd</span>() (SUPPORT_VECTOR &amp; FREEBSD)
<span>#define</span> <span>SupportsOpenbsd</span>() (SUPPORT_VECTOR &amp; OPENBSD)
<span>#define</span> <span>SupportsNetbsd</span>()  (SUPPORT_VECTOR &amp; NETBSD)

<span>#define</span> <span>IsLinux</span>()   (SupportsLinux() &amp;&amp; os == LINUX)
<span>#define</span> <span>IsXnu</span>()     (SupportsXnu() &amp;&amp; os == XNU)
<span>#define</span> <span>IsFreebsd</span>() (SupportsFreebsd() &amp;&amp; os == FREEBSD)
<span>#define</span> <span>IsOpenbsd</span>() (SupportsOpenbsd() &amp;&amp; os == OPENBSD)
<span>#define</span> <span>IsNetbsd</span>()  (SupportsNetbsd() &amp;&amp; os == NETBSD)
</pre>

<p>
So one of the flexibilities of APE is the build can be tuned like this:

</p><pre>make MODE=tiny CPPFLAGS+=-DSUPPORT_VECTOR=0b00000001
</pre>

<p>
If you want a 4kb hello world binary that only runs on Linux, and leaves
out that hefty 12kb of bloat that&#39;s normally included to support
Windows, MacOS, FreeBSD, NetBSD, OpenBSD, and booting from BIOS on bare
metal. One sweet spot is to only target the ELF operating systems.
Simply set the appropriate bits for Linux + BSD.

</p><pre>make MODE=tiny CPPFLAGS+=-DSUPPORT_VECTOR=0b01110001
</pre>

<h2 class="page" id="dzd">
  <a href="#dzd">
    δzd Encoding
  </a>
</h2>

<p>
One of the most size optimized pieces of code in the Cosmopolitan
codebase is Python. This is where we really had to go beyond code
golfing and pull out the artillery when it comes to size coding. One of
the greatest weapons in our arsenal (which helped us get statically
linked Python binaries down to 2mb in size) is what we call the Delta
Zig-Zag Deflate compression scheme, or δzd for short.

</p><p>
This isn&#39;t a generalized compression algorithm like DEFLATE, which
employs Huffman coding (along with an RLE very similar to LZ4). It&#39;s
only profitable on certain kinds of executable content and while
programming we need to use our best judgement to figure out which
technique is most appropriate. But δzd in particular has produced some
considerable gains.

</p><p>
Consider the following dilemma. The Chinese, Korean, and Japanese
languages are enormous. They don&#39;t even all agree on UTF-8 yet, and have
a variety of one-off character sets, all of which are supported by
Python. The UNICODE standard and its information tables also need to be
enormous too, in order to support CJK. Most people outside those three
countries don&#39;t need this information in their binaries, but we like to
keep it there anyway, in the interest of inclusiveness and enabling
languages like Python to erect a big tent that welcomes everyone.

</p><p>
By using δzd packing, we can make these lookup tables significantly
tinier, thereby ensuring that the user only needs to pay for the
features they actually use. One of the many symbols in the Python
codebase that needed this treatment is
<code>_PyUnicode_PhrasebookOffset2</code> which was originally 178kb in
size, but apply delta encoding, zig-zag encoding, and then finally
DEFLATE, we got it down to 12kb. That&#39;s a nearly 10x advantage over
DEFLATE&#39;s Huffman encoding alone, and BZIP2&#39;s Burrows-Wheeler transform!

</p><pre>_PyUnicode_PhrasebookOffset2: size         is      178,176 bytes
_PyUnicode_PhrasebookOffset2: packed size  is      100,224 bytes
_PyUnicode_PhrasebookOffset2: rle size     is      282,216 bytes
_PyUnicode_PhrasebookOffset2: deflate size is       52,200 bytes
_PyUnicode_PhrasebookOffset2: bz2 size     is       76,876 bytes
_PyUnicode_PhrasebookOffset2: δleb size    is       47,198 bytes
_PyUnicode_PhrasebookOffset2: δzd size     is       12,748 bytes
</pre>

<p>
In <a href="https://github.com/jart/cosmopolitan/blob/master/third_party/python/Tools/unicode/makeunicodedata.py">third_party/python/Tools/unicode/makeunicodedata.py</a>
you can read more about how we regenerated these tables. The Python
implementation for Delta-ZigZag-DEFLATE encoding is also as follows:

</p><pre><span>def</span> uleb(a, x):
    <span>while</span> <span>True:</span>
        b = x &amp; 127
        x &gt;&gt;= 7
        <span>if</span> x:
            a.append(b | 128)
        <span>else:</span>
            a.append(b)
            <span>break</span>

<span>def</span> zig(x):
    m = (2 &lt;&lt; x.bit_length()) - 1
    <span>return</span> ((x &amp; (m &gt;&gt; 1)) &lt;&lt; 1) ^ (m if x &lt; 0 else 0)

<span>def</span> zleb(a, x):
    <span>return</span> uleb(a, zig(x))

<span>def</span> δzd(data):
    n = 0;
    i = 0
    p = 0
    a = <span>bytearray</span>()
    <span>for</span> x <span>in</span> data:
        zleb(a, x - p)
        p = x
    <span>return</span> deflate(a), len(a)
</pre>


<p>
You can read the C code that unpacks the Python compressed data in
<a href="https://github.com/jart/cosmopolitan/blob/master/libc/x/xloadzd.c">libc/x/xloadzd.c</a>,
<a href="https://github.com/jart/cosmopolitan/blob/master/libc/fmt/unzleb64.c">libc/fmt/unzleb64.c</a>,
<a href="https://github.com/jart/cosmopolitan/blob/master/libc/runtime/inflate.c">libc/runtime/inflate.c</a>, and
<a href="https://github.com/jart/cosmopolitan/blob/master/third_party/zlib/puff.c">third_party/zlib/puff.c</a>.
Puff is particularly nice. It&#39;s a size optimized (but slower) version of
zlib that Mark Adler wrote that only does DEFLATE decompression, and it
has a binary footprint of 2kb. One thing Cosmopolitan Libc core
libraries do quite frequently (since they can&#39;t depend on things like
malloc) whenever the need arises for proper DEFLATE decompression, is
strongly link Puff, and weakly link zlib (which is more on the order of
60kb in size) so that Puff is used by default, unless the faster zlib
library is strongly linked by something else.

</p><h2 class="page" id="overlapping">
  <a href="#overlapping">
    Overlapping Functions
  </a>
</h2>

<p>
If high-level programming languages like C are the Ice Hotel and
assembly is the tip of the iceberg, then the hidden dimension of
complexity lurking beneath would be Intel&#39;s variable length encoding.
This is where boot sectors get esoteric real fast, since tools can&#39;t
easily visualize it. for example, consider the following:

</p><table>
<tbody><tr><td>
<pre><span>/	%ip is 0</span>
	<span><abbr title="ax = (ax &amp; 0xff00) | 244">mov</abbr></span>	<span>$0xf4</span>,<span>%al</span>
	<span><abbr title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</abbr></span>
</pre>
</td><td>
<pre><span>/	%ip is 1</span>
	<span>.byte</span>	0xb0
<span>wut</span>:	<span><abbr title="man 2 pause">hlt</abbr></span> <span># and catch fire</span>
	<span><abbr title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</abbr></span>
</pre>
</td></tr></tbody></table>

<p>
Similar to how a Chess game may unfold very differently if a piece is
moved to an unintended adjacent square, an x86 program can take on an
entirely different meaning if the instruction pointer becomes off by
one. We were able to use this to our advantage, since that lets us code
functions in such a way that they overlap with one another.

</p><table>
<tbody><tr><td>
<pre><span>/	SectorLISP code.</span>
<span>89 D6</span> <span>Assoc</span>:	<span><abbr title="si = dx">mov</abbr></span>	<span>%dx</span>,<span>%si</span>
<span>8B 3C</span> <span>1</span>:	<span><abbr title="di = *(si+ds*16)">mov</abbr></span>	(<span>%si</span>),<span>%di</span>
<span>8B 30</span> 	<span><abbr title="si = *(bx+si+ds*16)">mov</abbr></span>	(<span>%bx</span>,<span>%si</span>),<span>%si</span>
<span>AF   </span> 	<span><abbr title="zf = (ax == *(di+es*16)) and di += 2">scasw</abbr></span>
<span>75 F9</span> 	<span><abbr title="jump back to label 1 if zf==0">jne</abbr></span>	1<span>b</span>
<span>F6   </span> 	<span>.byte</span>	0xF6
<span>8B 39</span> <span>Cadr</span>:	<span><abbr title="di = *(bx+di+ds*16)">mov</abbr></span>	(<span>%bx</span>,<span>%di</span>),<span>%di</span>
<span>3C   </span> 	<span>.byte</span>	0x3C
<span>AF   </span> <span>Cdr</span>:	<span><abbr title="di += 2">scasw</abbr></span>
<span>8B 05</span> <span>Car</span>:	<span><abbr title="mov">mov</abbr></span>	(<span>%di</span>),<span>%ax</span>
<span>C3   </span> 	<span><abbr title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</abbr></span>
</pre>
</td><td>
<pre><span>89 D6         </span> <span>Assoc</span>:	<span><abbr title="si = dx">mov</abbr></span>	<span>%dx</span>,<span>%si</span>
<span>8B 3C         </span> <span>1</span>:	<span><abbr title="di = si">mov</abbr></span>	(<span>%si</span>),<span>%di</span>
<span>8B 30         </span> 	<span><abbr title="si = *(bx+si+ds*16)">mov</abbr></span>	(<span>%bx</span>,<span>%si</span>),<span>%si</span>
<span>AF            </span> 	<span><abbr title="zf = (ax == *(di+es*16)) and di += 2">scasw</abbr></span>
<span>75 F9         </span> 	<span><abbr title="jump back to label 1 if zf==0">jne</abbr></span>	1<span>b</span>
<span>F6 8B 39 3C AF</span> 	<span><abbr title="nop">testw</abbr></span>	<span>$0xaf</span>,0x3c39(<span>%bp</span>,<span>%di</span>)
<span>8B 05         </span> 	<span><abbr title="ax = *(short *)(di+ds*16)">mov</abbr></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><abbr title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</abbr></span>

<span>8B 39         </span> <span>Cadr</span>:	<span><abbr title="di = *(bx+di+ds*16)">mov</abbr></span>	(<span>%bx</span>,<span>%di</span>),<span>%di</span>
<span>3C AF         </span> 	<span><abbr title="nop">cmp</abbr></span>	<span>$0xaf</span>,<span>%al</span>
<span>8B 05         </span> 	<span><abbr title="ax = *(short *)(di+ds*16)">mov</abbr></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><abbr title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</abbr></span>

<span>AF            </span> <span>Cdr</span>:	<span><abbr title="di += 2">scasw</abbr></span>
<span>8B 05         </span> 	<span><abbr title="ax = *(short *)(di+ds*16)">mov</abbr></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><abbr title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</abbr></span>

<span>8B 05         </span> <span>Car</span>:	<span><abbr title="ax = *(short *)(di+ds*16)">mov</abbr></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><abbr title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</abbr></span>
</pre>
</td></tr></tbody></table>

<h2 class="page" id="printf">
  <a href="#printf">
    Optimizing Printf
  </a>
</h2>

<p>
One of the issues with printf() from a size coding perspective, is it
pulls in a lot of heavy-weight dependencies:

</p><ul>
<li>gdtoa is needed to format double and long double
    via <code>%f</code>, <code>%g</code>, etc. There&#39;s so much depth
    (and potentially memory allocation) when it comes to formatting
    floating point. As such, linking gdtoa adds about 32kb to the binary
    size.
</li><li>In order to format width-aligned strings (via <code>%*s</code> etc.)
    in a way that supports UNICODE, we need the CJK wides table, which
    lets us know if a character in the terminal takes up two cells. Some
    such examples of variable width monospace would be Emoji and
    Chinese.
</li><li>Formatting the GNU <code>%m</code> directive
    for <code>strerror()</code> is a little more costly with
    Cosmopolitan, because we use symbols rather than defines for system
    magic numbers. Therefore <code>strerror()</code> needs to yoink all
    the errnos at once. It also needs to embed a bunch of error string
    and tools for obtaining them via the WIN32 API. It adds about ~8k to
    the binary size.
</li></ul>

<p>
Yet somehow, despite all the bloat in <code>printf()</code>, binaries
that casually link it
(e.g. <a href="https://github.com/jart/cosmopolitan/blob/master/examples/hello3.c">examples/hello3.c</a>)
can be as small as 24kb in size. This is thanks to
the <code>PFLINK()</code> macro.

</p><pre>/* see <a href="https://github.com/jart/cosmopolitan/blob/master/libc/fmt/pflink.h">libc/fmt/pflink.h</a> */
/* see <a href="https://github.com/jart/cosmopolitan/blob/master/libc/stdio/stdio.h">libc/stdio/stdio.h</a> */
<span>#define</span> <span>printf</span>(FMT, ...) (printf)(PFLINK(FMT), <span>##__VA_ARGS__</span>)
<span>#define</span> <span>PFLINK</span>(...) _PFLINK(<span>__VA_ARGS__</span>)
<span>#define</span> <span>_PFLINK</span>(FMT, ...)                                             \
  ({                                                                  \
    <span>if</span> (___PFLINK(FMT, strpbrk, <span>&#34;faAeg&#34;</span>)) <span>STATIC_YOINK</span>(<span>&#34;__fmt_dtoa&#34;</span>); \
    <span>if</span> (___PFLINK(FMT, strpbrk, <span>&#34;cmrqs&#34;</span>)) {                           \
      <span>if</span> (___PFLINK(FMT, strstr, <span>&#34;%m&#34;</span>)) <span>STATIC_YOINK</span>(<span>&#34;strerror&#34;</span>);     \
      <span>if</span> (!IsTiny() &amp;&amp; (___PFLINK(FMT, strstr, <span>&#34;%*&#34;</span>) ||               \
                        ___PFLINK(FMT, strpbrk, <span>&#34;0123456789&#34;</span>))) {     \
        <span>STATIC_YOINK</span>(<span>&#34;strnwidth&#34;</span>);                                    \
        <span>STATIC_YOINK</span>(<span>&#34;strnwidth16&#34;</span>);                                  \
        <span>STATIC_YOINK</span>(<span>&#34;wcsnwidth&#34;</span>);                                    \
      }                                                               \
    }                                                                 \
    FMT;                                                              \
  })
<span>#define</span> <span>___PFLINK</span>(FMT, FN, C) \
  !<span>__builtin_constant_p</span>(FMT) || ((FMT) &amp;&amp; <span>__builtin_##FN</span>(FMT, C) != NULL)
</pre>

<p>
This only works with GCC and not Clang. It works because the first
argument to printf() is almost always a string literal, and GCC is smart
enough to run functions like <code>__builtin_strstr()</code> at compile
time, sort of like a C++ <code>constexpr</code>. Once GCC has identified
that we need a heavyweight feature, it then does what we call &#34;yoinking&#34;
the appropriate symbol.

</p><p>
Here&#39;s how yoinking works. There&#39;s a trick with ELF binaries called weak
linking. The printf() implementation has code like this:

</p><pre>      <span>case</span> <span>&#39;m&#39;</span>:
        p = <span>weaken</span>(strerror) ? <span>weaken</span>(strerror)(lasterr) : <span>&#34;?&#34;</span>;
        signbit = 0;
        <span>goto</span> FormatString;
</pre>

<p>
When a function is weakened, then it won&#39;t get pulled into the final
binary unless some other module references it the strong or normal way.
Yoinking is one way to do that. However yoinking is intended for the
special situation where don&#39;t have any code that actually uses the
symbol, but we still want to pull it into the binary.

</p><pre>	<span>.section</span> .yoink
	<span>nopl</span>	symbol
	<span>.previous</span>
</pre>

<p>
So what we do with the yoink macro is is generate a reference inside a
section that&#39;s explicitly discarded by the linker script.

</p><pre>  <span>/DISCARD/</span> : {
    *(.yoink)
  }
</pre>

<p>
So even though that reference is ultimately discarded, it&#39;s still enough
to cause ld.bfd to pull the referenced module into the final binary.

</p><p>
This isn&#39;t a perfect technique, even though it&#39;s a worthwhile one. Large
programs will implicitly yoink everything on a long enough timeline. So
for big programs, this isn&#39;t a problem. But it&#39;s sometimes necessary for
tiny programs to help the linker out explicitly. For example, you may be
committing the security sin of using non-literal format strings. In that
case the macro magic will cause everything to be yoinked, since it has
no visibility into the string at compile time. If you still want to stay
on the tinier side, then you can disable the magic by
calling <code>printf()</code> as such:

</p><pre>(printf)(<span>&#34;last error is %m\n&#34;</span>);
</pre>

Then, any features you need which are listed in
the <code>PFLINK()</code> macro can be yoinked explicitly by
your <code>main()</code> module.

<pre><span>STATIC_YOINK</span>(<span>&#34;strerror&#34;</span>);
</pre>

<h2 class="page" id="elf">
  <a href="#elf">
    Tiny Portable ELF
  </a>
</h2>

<p>
Please take a look at the <a href="https://brian.abelson.live/log/2025/01/cosmopolitan/howfat.html">How Fat
Does a Fat Binary Need To Be?</a> page which lets you interactively
build online Cosmopolitan Actually Portable Executable binaries. As we
can see, features like <code>SUPPORT_VECTOR</code> provide all the power
and configurability any user should need, to make their programs as tiny
as they want them to be.

</p><p>
But let&#39;s say for a moment you only cared about ELF targets like Linux,
FreeBSD, NetBSD, and OpenBSD. Let&#39;s furthermore imagine that you wanted
to build a binary that runs on all four of these operating systems, from
scratch, without the assistance of APE and Cosmo. It turns out that&#39;s
relatively easy to do, and this section will show you how it works.
What&#39;s also cool is that it&#39;s only 386 bytes in size, using an idiomatic
best practices approach.

</p><p>
Throughout the history of computing, it&#39;s been convention that each
operating systems should provide its own tools that let you build
software for the platform. This made sense in the past, since operating
systems were usually built by the same companies that designed the
microprocessors on which they operated. Things changed in recent
decades. As of August 2022, 485 out of the Top 500 supercomputers run
x86-64. The x86 architecture also represents the lion&#39;s share of
personal computers and backend servers. Yet, due to tradition,
programmers still believe that if we want to release an app for four
different operating systems, we need to build four separate binaries.
That doesn&#39;t make sense anymore, because all four binaries share the
same architecture.

</p><p>
For example, let&#39;s say you build the following function:

</p><pre><span>int</span> add(<span>int</span> x, <span>int</span> y) {
  <span>return</span> x + y;
}
</pre>

<p>
The output of your compiler should be the same, regardless of whether
you&#39;re running on Linux, FreeBSD, NetBSD, or OpenBSD:

</p><pre><span>add</span>:	<span>lea</span>	(<span>%rdi</span>,<span>%rsi</span>,1),<span>%eax</span>
	<span>ret</span>
</pre>

<p>
So why doesn&#39;t something like a Linux binary run out of the box on other
systems like OpenBSD? There are a few reasons. First, the ELF format
itself requires us to specify the OS ABI (convention for how functions
interact at a binary/register level). Fortunately we can get around this
by just setting it to the FreeBSD ABI. This is because FreeBSD is the
only UNIX operating system that checks this field. It turned out that
NetBSD and OpenBSD check for binary compatibility using a separate ELF
PT_NOTE data structure instead. As for Linux, it just doesn&#39;t care. So
it turns out, if we say it&#39;s a FreeBSD binary, and we put the NetBSD and
OpenBSD notes in there too, then our binary will run on all four.

</p><p>
There&#39;s a few other minor differences in how the operating systems
interpret ELF fields. For example, <code>PT_LOAD</code> is used to tell
the operating system which parts of the executable file should be loaded
into memory, and at which addresses they should reside.
These <code>PT_LOAD</code> segments are allowed to have a size of zero,
in terms of the file. That&#39;s basically equivelent to allocating zero&#39;d
memory. However if the size in memory is zero too, then OpenBSD will
refuse to run the progarm, whereas the other kernels just don&#39;t care.

</p><p>
The executable header incantations below are designed to walk the narrow
path that meets the intersection of requirements for all four operating
systems. They&#39;ll then load our identical x86 code into memory, and run
it.

</p><pre><span>/* reallytiny-elf.S */</span>
<span>#define</span> ELFCLASS64 2
<span>#define</span> ELFDATA2LSB 1
<span>#define</span> ELFOSABI_FREEBSD 9
<span>#define</span> ET_EXEC 2
<span>#define</span> EM_NEXGEN32E 62
<span>#define</span> PT_LOAD 1
<span>#define</span> PT_NOTE 4
<span>#define</span> PF_X 1
<span>#define</span> PF_W 2
<span>#define</span> PF_R 4

	<span>.align</span>	8
<span>ehdr</span>:	<span>.ascii</span>	<span>&#34;\177ELF&#34;</span>
	<span>.byte</span>	ELFCLASS64
	<span>.byte</span>	ELFDATA2LSB
	<span>.byte</span>	1
	<span>.byte</span>	ELFOSABI_FREEBSD
	<span>.quad</span>	0
	<span>.word</span>	ET_EXEC			<span># e_type</span>
	<span>.word</span>	EM_NEXGEN32E		<span># e_machine</span>
	<span>.long</span>	1			<span># e_version</span>
	<span>.quad</span>	_start			<span># e_entry</span>
	<span>.quad</span>	phdrs - ehdr		<span># e_phoff</span>
	<span>.quad</span>	0			<span># e_shoff</span>
	<span>.long</span>	0			<span># e_flags</span>
	<span>.word</span>	64			<span># e_ehsize</span>
	<span>.word</span>	56			<span># e_phentsize</span>
	<span>.word</span>	2			<span># e_phnum</span>
	<span>.word</span>	0			<span># e_shentsize</span>
	<span>.word</span>	0			<span># e_shnum</span>
	<span>.word</span>	0			<span># e_shstrndx</span>
	<span>.globl</span>	ehdr

	<span>.align</span>	8
<span>phdrs</span>:	<span>.long</span>	PT_LOAD			<span># p_type</span>
	<span>.long</span>	PF_R|PF_X		<span># p_flags</span>
	<span>.quad</span>	0			<span># p_offset</span>
	<span>.quad</span>	ehdr			<span># p_vaddr</span>
	<span>.quad</span>	ehdr			<span># p_paddr</span>
	<span>.quad</span>	filesz			<span># p_filesz</span>
	<span>.quad</span>	filesz			<span># p_memsz</span>
	<span>.quad</span>	64			<span># p_align</span>

<span>#if</span> 0  <span>// will break openbsd unless we actually use bss</span>
	<span>.long</span>	PT_LOAD			<span># p_type</span>
	<span>.long</span>	PF_R|PF_W		<span># p_flags</span>
	<span>.quad</span>	0			<span># p_offset</span>
	<span>.quad</span>	bss			<span># p_vaddr</span>
	<span>.quad</span>	bss			<span># p_paddr</span>
	<span>.quad</span>	0			<span># p_filesz</span>
	<span>.quad</span>	bsssize			<span># p_memsz</span>
	<span>.quad</span>	64			<span># p_align</span>
<span>#endif</span>

	<span>.long</span>	PT_NOTE			<span># p_type</span>
	<span>.long</span>	PF_R			<span># p_flags</span>
	<span>.quad</span>	note - ehdr		<span># p_offset</span>
	<span>.quad</span>	note			<span># p_vaddr</span>
	<span>.quad</span>	note			<span># p_paddr</span>
	<span>.quad</span>	notesize		<span># p_filesz</span>
	<span>.quad</span>	notesize		<span># p_memsz</span>
	<span>.quad</span>	8			<span># p_align</span>

<span>note</span>:	<span>.long</span>	2f-1f
	<span>.long</span>	4f-3f
	<span>.long</span>	1
1:	<span>.asciz</span>	<span>&#34;OpenBSD&#34;</span>
2:	<span>.align</span>	4
3:	<span>.long</span>	0
4:	<span>.long</span>	2f-1f
	<span>.long</span>	4f-3f
	<span>.long</span>	1
1:	<span>.asciz</span>	<span>&#34;NetBSD&#34;</span>
2:	<span>.align</span>	4
3:	<span>.long</span>	901000000
4:	notesize = . - note

_start:	<span>mov</span>	%rsp,%rsi
	<span>jmp</span>	Start
	<span>.globl</span>	_start

</pre>

<p>
At that point we can just put our code in the <code>Start()</code>
function and it&#39;ll work! But a second issue occurs when we actually want
to print the result.

</p><p>
To print a string on UNIX systems, we must invoke the
<code>int write(fd, data, size)</code> system call,
where <code>fd</code> is normally specified as <code>1</code>, which
means standard output. Once again, due to the similarities of the
post-shakeout operating system landscape, all four systems happen to
implement the exact same function. However, in order to actually call
it, there&#39;s another number we must specify that exists beneath the
iceberg of what we see in terms of C code. That number is the system
call magic number, or &#34;magnum&#34;, and it&#39;s part of what&#39;s known as the
Application Binary Interface (ABI). Unfortunately, operating systems
don&#39;t agree on magnums. For example, on Linux write() is 1, but on the
BSDs it&#39;s 4. So if we ran Linux&#39;s <code>write()</code> on BSD, it would
actually call <code>exit()</code> – not what we want!

</p><table>
<tbody><tr><th colspan="5">UNIX SYSCALL Magnums (x86-64)
</th></tr><tr><th>Function			</th><th>Linux	</th><th>FreeBSD		</th><th>OpenBSD		</th><th>NetBSD
</th></tr><tr><td>exit				</td><td>60		</td><td>1			</td><td>1			</td><td>1
</td></tr><tr><td>fork				</td><td>57		</td><td>2			</td><td>2			</td><td>2
</td></tr><tr><td>read				</td><td>0		</td><td>3			</td><td>3			</td><td>3
</td></tr><tr><td>write				</td><td>1		</td><td>4			</td><td>4			</td><td>4
</td></tr><tr><td>open				</td><td>2		</td><td>5			</td><td>5			</td><td>5
</td></tr><tr><td>close				</td><td>3		</td><td>6			</td><td>6			</td><td>6
</td></tr><tr><td>stat				</td><td>4		</td><td>n/a			</td><td>38			</td><td>439
</td></tr><tr><td>fstat				</td><td>5		</td><td>551			</td><td>53			</td><td>440
</td></tr><tr><td>poll				</td><td>7		</td><td>209			</td><td>252			</td><td>209
</td></tr></tbody></table>

<p>
You&#39;ll notice there&#39;s a subset of numbers on which all systems agree,
particularly among the BSDs. Those tend to be the really old functions
that were designed for the original UNIX operating system written at
Bell Labs. In fact, numbers such as 1 for <code>exit()</code> were
copied straight out of the Bell System Five codebase. That&#39;s why we call
it the System V Application Binary Interface. There even used to be more
consensus if we look at past editions.

</p><table>
<tbody><tr><th colspan="5">UNIX SYSCALL Magnums (i386)
</th></tr><tr><th>Function			</th><th>Linux	</th><th>FreeBSD		</th><th>OpenBSD		</th><th>NetBSD
</th></tr><tr><td>exit				</td><td>1		</td><td>1			</td><td>1			</td><td>1
</td></tr><tr><td>fork				</td><td>2		</td><td>2			</td><td>2			</td><td>2
</td></tr><tr><td>read				</td><td>3		</td><td>3			</td><td>3			</td><td>3
</td></tr><tr><td>write				</td><td>4		</td><td>4			</td><td>4			</td><td>4
</td></tr><tr><td>open				</td><td>5		</td><td>5			</td><td>5			</td><td>5
</td></tr><tr><td>close				</td><td>6		</td><td>6			</td><td>6			</td><td>6
</td></tr><tr><td>stat				</td><td>18		</td><td>n/a			</td><td>38			</td><td>439
</td></tr><tr><td>fstat				</td><td>108		</td><td>551			</td><td>53			</td><td>440
</td></tr><tr><td>poll				</td><td>168		</td><td>209			</td><td>252			</td><td>209
</td></tr></tbody></table>

<p>
So in order to know which magnum to use, we need some way of detecting
the x86-64 OS at runtime. There&#39;s many ways of doing this. For example,
we could search for a magnum where we pass invalid parameters and then
tell the systems apart by the returned error code. However system calls
are costly, taking upwards of a microsecond to execute, rather than
nanoseconds like ordinary functions. So we&#39;ll be showing a different
technique below, which detects the operating system based entirely on
values that&#39;ve already been passed to us by the operating system when it
loaded our executable.

</p><pre><span>/* reallytiny.c */</span>
<span>#define</span> LINUX   1
<span>#define</span> OPENBSD 16
<span>#define</span> FREEBSD 32
<span>#define</span> NETBSD  64

<span>#ifndef</span> SUPPORT_VECTOR
<span>#define</span> SUPPORT_VECTOR (LINUX | FREEBSD | NETBSD | OPENBSD)
<span>#endif</span>

<span>#define</span> SupportsLinux()   (SUPPORT_VECTOR &amp; LINUX)
<span>#define</span> SupportsFreebsd() (SUPPORT_VECTOR &amp; FREEBSD)
<span>#define</span> SupportsOpenbsd() (SUPPORT_VECTOR &amp; OPENBSD)
<span>#define</span> SupportsNetbsd()  (SUPPORT_VECTOR &amp; NETBSD)

<span>#define</span> IsLinux()   (SupportsLinux() &amp;&amp; os == LINUX)
<span>#define</span> IsFreebsd() (SupportsFreebsd() &amp;&amp; os == FREEBSD)
<span>#define</span> IsOpenbsd() (SupportsOpenbsd() &amp;&amp; os == OPENBSD)
<span>#define</span> IsNetbsd()  (SupportsNetbsd() &amp;&amp; os == NETBSD)

<span>__attribute__</span>((<span>__noreturn__</span>)) <span>static void</span> Exit(int rc, int os) {
  <span>asm volatile</span>(<span>&#34;syscall&#34;</span>
               : <span>/* no outputs */</span>
               : <span>&#34;a&#34;</span>(IsLinux() ? 60 : 1), <span>&#34;D&#34;</span>(rc)
               : <span>&#34;memory&#34;</span>);
  <span>__builtin_unreachable</span>();
}

<span>static</span> <span>int</span> Write(<span>int</span> fd, <span>const</span> <span>void</span> *data, <span>int</span> size, <span>int</span> os) {
  <span>char</span> cf;
  <span>int</span> ax, dx;
  <span>asm volatile</span>(<span>&#34;clc\n\t&#34;</span>
               <span>&#34;syscall&#34;</span>
               : <span>&#34;=a&#34;</span>(ax), <span>&#34;=d&#34;</span>(dx), <span>&#34;=@ccc&#34;</span>(cf)
               : <span>&#34;0&#34;</span>(IsLinux() ? 1 : 4), <span>&#34;D&#34;</span>(fd), <span>&#34;S&#34;</span>(data), <span>&#34;1&#34;</span>(size)
               : <span>&#34;rcx&#34;</span>, <span>&#34;r11&#34;</span>, <span>&#34;r8&#34;</span>, <span>&#34;r9&#34;</span>, <span>&#34;r10&#34;</span>, <span>&#34;memory&#34;</span>, <span>&#34;cc&#34;</span>);
  <span>if</span> (cf) ax = -ax;
  <span>return</span> ax;
}

<span>static</span> <span>int</span> <span>Main</span>(<span>int</span> argc, <span>char</span> **argv, <span>char</span> **envp, <span>long</span> *auxv, <span>int</span> os) {
  Write(1, <span>&#34;hello world\n&#34;</span>, 12, os);
  <span>return</span> 0;
}

<span>__attribute__</span>((<span>__noreturn__</span>)) <span>void</span> <span>Start</span>(<span>long</span> di, <span>long</span> *sp) {
  <span>long</span> *auxv;
  <span>int</span> i, os, argc;
  <span>char</span> **argv, **envp, *page;

  <span>// detect freebsd</span>
  <span>if</span> (SupportsFreebsd() &amp;&amp; di) {
    os = FREEBSD;
    sp = (<span>long</span> *)di;
  } <span>else</span> {
    os = 0;
  }

  <span>// extract arguments</span>
  argc = *sp;
  argv = (<span>char</span> **)(sp + 1);
  envp = (<span>char</span> **)(sp + 1 + argc + 1);
  auxv = (<span>long</span> *)(sp + 1 + argc + 1);
  <span>for</span> (;;) {
    <span>if</span> (!*auxv++) {
      <span>break</span>;
    }
  }

  <span>// detect openbsd</span>
  <span>if</span> (SupportsOpenbsd() &amp;&amp; !os &amp;&amp; !auxv[0]) {
    os = OPENBSD;
  }

  <span>// detect netbsd</span>
  <span>if</span> (SupportsNetbsd() &amp;&amp; !os) {
    <span>for</span> (; auxv[0]; auxv += 2) {
      <span>if</span> (auxv[0] == 2014 /* AT_EXECFN */) {
        os = NETBSD;
        break;
      }
    }
  }

  <span>// default operating system</span>
  <span>if</span> (!os) {
    os = LINUX;
  }

  Exit(Main(argc, argv, envp, auxv, os), os);
}
</pre>

<p>
FreeBSD likes to have %RDI (which means first parameter in System V ABI)
be the same as %RSP on initialization. That&#39;s because they prefer C
code, and don&#39;t want to require that people write the assembly thunk we
did earlier, that moves the %RSP register and jumps to the real
entrypoint. On the other operating systems, %RDI is always zero.

</p><p>
We then have to scrape the real parameters to our function off the
stack. That&#39;s because x86-64 <code>_start()</code> is a weird function
that still follows the old i386 ABI, which passed parameters on the
stack (rather than in registers). Now we have argc, argv, and environ.

</p><p>
However there&#39;s a little known fourth parameter to C programs, called
auxv, which is short for auxiliary values. OpenBSD never implemented
this feature, so if they&#39;re not there, then we know it&#39;s OpenBSD. As for
NetBSD, we know it always passes auxiliary values with much larger
magnums than any other system, so by testing the values, we can tell
NetBSD apart from Linux. Then we&#39;re done! We can now issues SYSCALLs.

</p><p>
But there&#39;s one more minor problem. BSDs don&#39;t conform to the System V
ABI documentation, which says that error numbers should be returned by
the kernel as a negative number. BSDs instead follow the the 386BSD
convention of using the carry flag to indicate that RAX contains an
error code instead of a result. Since we know that Linux always saves
and restores the EFLAGS register during SYSCALL, all we have to do is
use <code>CLC</code> to clear the carry flag before using
<code>SYSCALL</code>. Then we know for certain that if the carry flag is
set afterwards, that it&#39;s BSD and the SYSCALL failed, in which case we
just flip the sign to make the result conform to System V.

</p><p>
There&#39;s some other quirks too. In our inline asm notation, we tell GCC
that the the RDX register may be clobbered. This can only happen on XNU
and NetBSD, but never on Linux, and highly unlikely on the other ones.
FreeBSD usually clobbers R8, R9, and R10. It&#39;s generally best to assume
with BSDs that they want you to wrap SYSCALL with a function call, so
the call-clobbered register rule applies, i.e. RAX, RCX, RDX, RDI, RSI,
R8, R9, R10, and R11 are volatile. BSDs system calls in some cases might
even accept parameters on the stack, whereas Linux <em>never</em> uses
more than six parameters, all of which go in the registers RDI, RSI,
RDX, R10, R8, and R9.

</p><p>
Now that we&#39;ve written all our code, we need a linker script to glue our
C and assembly code together into a simple binary file, that doesn&#39;t
have any of the platform-specific boilerplate.

</p><pre><span>/* reallytiny.lds */</span>
<span>ENTRY</span>(_start)

<span>SECTIONS</span> {
  . = 0x400000;
  .text : {
    *(.text)
    *(.rodata .rodata.*)
  }
  filesz = . - ehdr;
  textsz = . - _start;
  .bss <span>ALIGN</span>(4096) : {
    bss = .;
    *(.bss)
    . = <span>ALIGN</span>(4096);
  }
  memsz = . - ehdr;
  <span>/DISCARD/</span> : {
    *(.*)
  }
}

bsssize = <span>SIZEOF</span>(.bss);
textoff = _start - ehdr;
</pre>

<p>
You can then build your program as such:

</p><pre>gcc -static -no-pie -g -Os \
  -o reallytiny.elf.dbg \
  -Wl,-T,reallytiny.lds \
  reallytiny-elf.S \
  reallytiny.c
objcopy -S -O binary \
  reallytiny.elf.dbg \
  reallytiny.elf
</pre>

<p>
Here&#39;s your binary visualized:

</p><p>
  <a href="https://brian.abelson.live/log/2025/01/04/reallytinyelf.png"><img width="717" height="188" alt="[reallytinyelf.png]" src="https://worker.jart.workers.dev/sizetricks/reallytinyelf.png"/></a>

</p><p>
Here&#39;s what happens when you run it:

</p><pre>linux$ ./reallytiny.elf
hello world
freebsd$ ./reallytiny.elf
hello world
netbsd$ ./reallytiny.elf
hello world
openbsd$ ./reallytiny.elf
hello world
</pre>

<p>
Four operating systems is under 400 bytes is pretty good!

</p><p>
You may also download the examples above in the following files:

</p><ul>
<li><a href="https://brian.abelson.live/log/2025/01/04/reallytiny-elf.S">reallytiny-elf.S</a>
</li><li><a href="https://brian.abelson.live/log/2025/01/04/reallytiny.c">reallytiny.c</a>
</li><li><a href="https://brian.abelson.live/log/2025/01/04/reallytiny.lds">reallytiny.lds</a>
</li></ul>

<h2 class="page" id="funding">
  <a href="#funding">
    Funding
  </a>
</h2>

<p>
  <a href="https://justine.lol/lemuria.png">
    <picture>
      <source srcset="//worker.jart.workers.dev/sectorlisp2/lemuria.webp" type="image/webp"/>
      <img src="https://worker.jart.workers.dev/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/>
    </picture>
  </a>

</p><p>
Funding for this blog post was crowdsourced from Justine Tunney&#39;s
<a href="https://github.com/sponsors/jart">GitHub sponsors</a>
and <a href="https://www.patreon.com/jart">Patreon subscribers</a>. Your
support is what makes projects like Cosmopolitan Libc possible. Thank
you.

</p><h2 class="page" id="see">
  <a href="#see">
    See Also
  </a>
</h2>

<ul>
<li><a href="https://brian.abelson.live/cosmopolitan/">cosmopolitan libc</a></li>
<li><a href="https://brian.abelson.live/">justine&#39;s web page</a></li>
</ul>


<img src="https://ipv4.games/claim?name=jart"/>
</div>
  </body>
</html>
