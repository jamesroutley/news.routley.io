<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/axilla-io/ax">Original</a>
    <h1>Show HN: Axilla – Open-source TypeScript framework for LLM apps</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>Today I was thinking about – what happens when you run a simple “Hello World”
Python program on Linux, like this one?</p>

<pre><code>print(&#34;hello world&#34;)
</code></pre>

<p>Here’s what it looks like at the command line:</p>

<pre><code>$ python3 hello.py
hello world
</code></pre>

<p>But behind the scenes, there’s a lot more going on. I’ll
describe some of what happens, and (much much more importantly!) explain some tools you can use to
see what’s going on behind the scenes yourself. We’ll use <code>readelf</code>, <code>strace</code>,
<code>ldd</code>, <code>debugfs</code>, <code>/proc</code>, <code>ltrace</code>, <code>dd</code>, and <code>stat</code>. I won’t talk about the Python-specific parts at all – just what happens when you run any dynamically linked executable.</p>

<p>Here’s a table of contents:</p>

<ol>
<li><a href="#1-the-shell-parses-the-string-python3-hello-py-into-a-command-to-run-and-a-list-of-arguments-python3-and-hello-py">parse “python3 hello.py”</a></li>
<li><a href="#2-the-shell-figures-out-the-full-path-to-python3">figure out the full path to python3</a></li>
<li><a href="#3-stat-under-the-hood">stat, under the hood</a></li>
<li><a href="#4-time-to-fork">time to fork</a></li>
<li><a href="#5-the-shell-calls-execve">the shell calls execve</a></li>
<li><a href="#6-get-the-binary-s-contents">get the binary’s contents</a></li>
<li><a href="#7-find-the-interpreter">find the interpreter</a></li>
<li><a href="#8-dynamic-linking">dynamic linking</a></li>
<li><a href="#9-go-to-start">go to _start</a></li>
<li><a href="#10-write-a-string">write a string</a></li>
</ol>

<h3 id="before-execve">before <code>execve</code></h3>

<p>Before we even start the Python interpreter, there are a lot of things that
have to happen. What executable are we even running? Where is it?</p>

<h4 id="1-the-shell-parses-the-string-python3-hello-py-into-a-command-to-run-and-a-list-of-arguments-python3-and-hello-py">1: The shell parses the string <code>python3 hello.py</code> into a command to run and a list of arguments: <code>python3</code>, and <code>[&#39;hello.py&#39;]</code></h4>

<p>A bunch of things like glob expansion could happen here. For example if you run <code>python3 *.py</code>, the shell will expand that into <code>python3 hello.py</code></p>

<h4 id="2-the-shell-figures-out-the-full-path-to-python3">2: The shell figures out the full path to <code>python3</code></h4>

<p>Now we know we need to run <code>python3</code>. But what’s the full path to that binary? The way this works is that there’s a special environment variable named <code>PATH</code>.</p>

<p><strong>See for yourself</strong>: Run <code>echo $PATH</code> in your shell. For me it looks like this.</p>

<pre><code>$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>

<p>When you run a command, the shell will search every directory in that list (in order) to try to find a match.</p>

<p>In <code>fish</code> (my shell), you can see the <a href="https://github.com/fish-shell/fish-shell/blob/900a0487443f10caa6539634ca8c49fb6e3ce5ba/src/path.cpp#L31-L45">path resolution logic here</a>.
It uses the <code>stat</code> system call to check if files exist.</p>

<p><strong>See for yourself</strong>: Run <code>strace -e stat bash</code>, and then run a command like <code>python3</code>. You should see output like this:</p>

<pre><code>stat(&#34;/usr/local/sbin/python3&#34;, 0x7ffcdd871f40) = -1 ENOENT (No such file or directory)
stat(&#34;/usr/local/bin/python3&#34;, 0x7ffcdd871f40) = -1 ENOENT (No such file or directory)
stat(&#34;/usr/sbin/python3&#34;, 0x7ffcdd871f40) = -1 ENOENT (No such file or directory)
stat(&#34;/usr/bin/python3&#34;, {st_mode=S_IFREG|0755, st_size=5479736, ...}) = 0
</code></pre>

<p>You can see that it finds the binary at <code>/usr/bin/python3</code> and stops: it
doesn’t continue searching <code>/sbin</code> or <code>/bin</code>.</p>

<h4 id="2-1-a-note-on-execvp">2.1: A note on <code>execvp</code></h4>

<p>If you want to run the same PATH searching logic as the shell does without
reimplementing it yourself, you can use the libc function <code>execvp</code> (or one of
the other <code>exec*</code> functions with  <code>p</code> in the name).</p>

<h4 id="3-stat-under-the-hood">3: <code>stat</code>, under the hood</h4>

<p>Now you might be wondering – Julia, what is <code>stat</code> doing? Well, when your OS opens a file, it’s split into 2 steps.</p>

<ol>
<li>It maps the <strong>filename</strong> to an <strong>inode</strong>, which contains metadata about the file</li>
<li>It uses the <strong>inode</strong> to get the file’s contents</li>
</ol>

<p>The <code>stat</code> system call just returns the contents of the file’s inodes – it
doesn’t read the contents at all. The advantage of this is that it’s a lot
faster. Let’s go on a short adventure into inodes. (<a href="https://www.cyberdemon.org/2023/07/19/bunch-of-bits.html">this great post “A disk is a bunch of bits” by Dmitry Mazin</a> has more details)</p>

<pre><code>$ stat /usr/bin/python3
  File: /usr/bin/python3 -&gt; python3.9
  Size: 9         	Blocks: 0          IO Block: 4096   symbolic link
Device: fe01h/65025d	Inode: 6206        Links: 1
Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2023-08-03 14:17:28.890364214 +0000
Modify: 2021-04-05 12:00:48.000000000 +0000
Change: 2021-06-22 04:22:50.936969560 +0000
 Birth: 2021-06-22 04:22:50.924969237 +0000
</code></pre>

<p><strong>See for yourself</strong>: Let’s go see where exactly that inode is on our hard drive.</p>

<p>First, we have to find our hard drive’s device name</p>

<pre><code>$ df
...
tmpfs             100016      604     99412   1% /run
/dev/vda1       25630792 14488736  10062712  60% /
...
</code></pre>

<p>Looks like it’s <code>/dev/vda1</code>. Next, let’s find out where the inode for <code>/usr/bin/python3</code> is on our hard drive:</p>

<pre><code>$ sudo debugfs /dev/vda1
debugfs 1.46.2 (28-Feb-2021)
debugfs:  imap /usr/bin/python3
Inode 6206 is part of block group 0
	located at block 658, offset 0x0d00
</code></pre>

<p>I have no idea how <code>debugfs</code> is figuring out the location of the inode for that filename, but we’re going to leave that alone.</p>

<p>Now, we need to calculate how many bytes into our hard drive “block 658, offset 0x0d00” is on the big array of bytes that is your hard drive. Each block is 4096 bytes, so we need to go <code>4096 * 658 + 0x0d00</code> bytes. A calculator tells me that’s <code>2698496</code></p>

<pre><code>$ sudo dd if=/dev/vda1 bs=1 skip=2698496 count=256 2&gt;/dev/null | hexdump -C
00000000  ff a1 00 00 09 00 00 00  f8 b6 cb 64 9a 65 d1 60  |...........d.e.`|
00000010  f0 fb 6a 60 00 00 00 00  00 00 01 00 00 00 00 00  |..j`............|
00000020  00 00 00 00 01 00 00 00  70 79 74 68 6f 6e 33 2e  |........python3.|
00000030  39 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |9...............|
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000060  00 00 00 00 12 4a 95 8c  00 00 00 00 00 00 00 00  |.....J..........|
00000070  00 00 00 00 00 00 00 00  00 00 00 00 2d cb 00 00  |............-...|
00000080  20 00 bd e7 60 15 64 df  00 00 00 00 d8 84 47 d4  | ...`.d.......G.|
00000090  9a 65 d1 60 54 a4 87 dc  00 00 00 00 00 00 00 00  |.e.`T...........|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre>

<p>Neat! There’s our inode! You can see it says <code>python3</code> in it, which is a really
good sign. We’re not going to go through all of this, but the <a href="https://github.com/torvalds/linux/blob/fdf0eaf11452d72945af31804e2a1048ee1b574c/fs/ext4/ext4.h#L769">ext4 inode struct from the Linux kernel</a>
says that the first 16 bits are the “mode”, or permissions. So let’s work that out how <code>ffa1</code> corresponds to file permissions.</p>

<ul>
<li>The bytes <code>ffa1</code> correspond to the number <code>0xa1ff</code>, or 41471 (because x86 is little endian)</li>
<li>41471 in octal is <code>0120777</code></li>
<li>This is a bit weird – that file’s permissions could definitely be <code>777</code>, but what
are the first 3 digits? I’m not used to seeing those! You can find out what
the <code>012</code> means in <a href="https://man7.org/linux/man-pages/man7/inode.7.html">man inode</a> (scroll down to “The file type and mode”).
There’s a little table that says <code>012</code> means “symbolic link”.</li>
</ul>

<p>Let’s list the file and see if it is in fact a symbolic link with permissions <code>777</code>:</p>

<pre><code>$ ls -l /usr/bin/python3
lrwxrwxrwx 1 root root 9 Apr  5  2021 /usr/bin/python3 -&gt; python3.9
</code></pre>

<p>It is! Hooray, we decoded it correctly.</p>

<h4 id="4-time-to-fork">4: Time to fork</h4>

<p>We’re still not ready to start <code>python3</code>. First, the shell needs to create a
new child process to run. The way new processes start on Unix is a little weird
– first the process clones itself, and then runs <code>execve</code>, which replaces the
cloned process with a new process.</p>

<p>*<strong>See for yourself:</strong> Run <code>strace -e clone bash</code>, then run <code>python3</code>. You should see something like this:</p>

<pre><code>clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f03788f1a10) = 3708100
</code></pre>

<p><code>3708100</code> is the PID of the new process, which is a child of the shell process.</p>

<p>Some more tools to look at what’s going on with processes:</p>

<ul>
<li><code>pstree</code> will show you a tree of all the processes on your system</li>
<li><code>cat /proc/PID/stat</code> shows you some information about the process. The contents of that file are documented in <code>man proc</code>. For example the 4th field is the parent PID.</li>
</ul>

<h4 id="4-1-what-the-new-process-inherits">4.1: What the new process inherits.</h4>

<p>The new process (which will become <code>python3</code>) has inherited a bunch of from the shell. For example, it’s inherited:</p>

<ol>
<li><strong>environment variables</strong>: you can look at them with <code>cat /proc/PID/environ | tr &#39;\0&#39; &#39;\n&#39;</code></li>
<li><strong>file descriptors</strong> for stdout and stderr: look at them with <code>ls -l /proc/PID/fd</code></li>
<li>a <strong>working directory</strong> (whatever the current directory is)</li>
<li><strong>namespaces and cgroups</strong> (if it’s in a container)</li>
<li>the <strong>user</strong> and <strong>group</strong> that’s running it</li>
<li>probably more things I’m not thinking of right now</li>
</ol>

<h4 id="5-the-shell-calls-execve">5: The shell calls <code>execve</code></h4>

<p>Now we’re ready to start the Python interpreter!</p>

<p><strong>See for yourself</strong>: Run <code>strace -f -e execve bash</code>, then run <code>python3</code>. The <code>-f</code> is important because we want to follow any forked child subprocesses. You should see something like this:</p>

<pre><code>[pid 3708381] execve(&#34;/usr/bin/python3&#34;, [&#34;python3&#34;], 0x560397748300 /* 21 vars */) = 0
</code></pre>

<p>The first argument is the binary, and the second argument is the list of
command line arguments. The command line arguments get placed in a special
location in the program’s memory so that it can access them when it runs.</p>

<p>Now, what’s going on inside <code>execve</code>?</p>

<h4 id="6-get-the-binary-s-contents">6: get the binary’s contents</h4>

<p>The first thing that has to happen is that we need to open the <code>python3</code>
binary file and read its contents. So far we’ve only used the <code>stat</code> system call to access its metadata,
but now we need its contents.</p>

<p>Let’s look at the output of <code>stat</code> again:</p>

<pre><code>$ stat /usr/bin/python3
  File: /usr/bin/python3 -&gt; python3.9
  Size: 9         	Blocks: 0          IO Block: 4096   symbolic link
Device: fe01h/65025d	Inode: 6206        Links: 1
...
</code></pre>

<p>This takes up 0 blocks of space on the disk. This is because the contents of
the symbolic link (<code>python3.9</code>) are actually in the inode itself: you can see
them here (from the binary contents of the inode above, it’s split across 2
lines in the hexdump output):</p>

<pre><code>00000020  00 00 00 00 01 00 00 00  70 79 74 68 6f 6e 33 2e  |........python3.|
00000030  39 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |9...............|
</code></pre>

<p>So we’ll need to open <code>/usr/bin/python3.9</code> instead. All of this is happening
inside the kernel so you won’t see it another system call for that.</p>

<p>Every file is made up of a bunch of <strong>blocks</strong> on the hard drive. I think each of these
blocks on my system is 4096 bytes, so the minimum size of a file is 4096 bytes
– even if the file is only 5 bytes, it still takes up 4KB on disk.</p>

<p><strong>See for yourself</strong>: We can find the block numbers using <code>debugfs</code> like this: (again, I got these instructions from <a href="https://www.cyberdemon.org/2023/07/19/bunch-of-bits.html">dmitry mazin’s “A disk is a bunch of bits” post</a>)</p>

<pre><code>$ debugfs /dev/vda1
debugfs:  blocks /usr/bin/python3.9
145408 145409 145410 145411 145412 145413 145414 145415 145416 145417 145418 145419 145420 145421 145422 145423 145424 145425 145426 145427 145428 145429 145430 145431 145432 145433 145434 145435 145436 145437
</code></pre>

<p>Now we can use <code>dd</code> to read the first block of the file. We’ll set the block size to 4096 bytes, skip <code>145408</code> blocks, and read 1 block.</p>

<pre><code>$ dd if=/dev/vda1 bs=4096 skip=145408 count=1 2&gt;/dev/null | hexdump -C | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  c0 a5 5e 00 00 00 00 00  |..&gt;.......^.....|
00000020  40 00 00 00 00 00 00 00  b8 95 53 00 00 00 00 00  |@.........S.....|
00000030  00 00 00 00 40 00 38 00  0b 00 40 00 1e 00 1d 00  |....@.8...@.....|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|
00000060  68 02 00 00 00 00 00 00  68 02 00 00 00 00 00 00  |h.......h.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  a8 02 00 00 00 00 00 00  a8 02 40 00 00 00 00 00  |..........@.....|
00000090  a8 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |..@.............|
</code></pre>

<p>You can see that we get the exact same output as if we read the file with <code>cat</code>, like this:</p>

<pre><code>$ cat /usr/bin/python3.9 | hexdump -C | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  c0 a5 5e 00 00 00 00 00  |..&gt;.......^.....|
00000020  40 00 00 00 00 00 00 00  b8 95 53 00 00 00 00 00  |@.........S.....|
00000030  00 00 00 00 40 00 38 00  0b 00 40 00 1e 00 1d 00  |....@.8...@.....|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|
00000060  68 02 00 00 00 00 00 00  68 02 00 00 00 00 00 00  |h.......h.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  a8 02 00 00 00 00 00 00  a8 02 40 00 00 00 00 00  |..........@.....|
00000090  a8 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |..@.............|
</code></pre>

<h4 id="an-aside-on-magic-numbers">an aside on magic numbers</h4>

<p>This file starts with <code>ELF</code>, which is a “magic number”, or a byte sequence that
tells us that this is an ELF file. ELF is the binary file format on Linux.</p>

<p>Different file formats have different magic numbers, for example the magic
number for gzip is <code>1f8b</code>. The magic number at the beginning is how <code>file blah.gz</code> knows that it’s a gzip file.</p>

<p>I think <code>file</code> has a variety of heuristics for figuring out the file type of a
file, not just magic numbers, but the magic number is an important one.</p>

<h4 id="7-find-the-interpreter">7: find the interpreter</h4>

<p>Let’s parse the ELF file to see what’s in there.</p>

<p><strong>See for yourself:</strong> Run <code>readelf -a /usr/bin/python3.9</code>. Here’s what I get (though I’ve redacted a LOT of stuff):</p>

<pre><code>$ readelf -a /usr/bin/python3.9
ELF Header:
    Class:                             ELF64
    Machine:                           Advanced Micro Devices X86-64
...
-&gt;  Entry point address:               0x5ea5c0
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
  INTERP         0x00000000000002a8 0x00000000004002a8 0x00000000004002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
-&gt;      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
        ...
-&gt;        1238: 00000000005ea5c0    43 FUNC    GLOBAL DEFAULT   13 _start
</code></pre>

<p>Here’s what I understand of what’s going on here:</p>

<ol>
<li>it’s telling the kernel to run <code>/lib64/ld-linux-x86-64.so.2</code> to start this program. This is called the <strong>dynamic linker</strong> and we’ll talk about it next</li>
<li>it’s specifying an entry point (at <code>0x5ea5c0</code>, which is where this program’s code starts)</li>
</ol>

<p>Now let’s talk about the dynamic linker.</p>

<h4 id="8-dynamic-linking">8: dynamic linking</h4>

<p>Okay! We’ve read the bytes from disk and we’ve started this “interpreter” thing. What next? Well, if you run <code>strace -o out.strace python3</code>, you’ll see a bunch of stuff like this right after the <code>execve</code> system call:</p>

<pre><code>execve(&#34;/usr/bin/python3&#34;, [&#34;python3&#34;], 0x560af13472f0 /* 21 vars */) = 0
brk(NULL)                       = 0xfcc000
access(&#34;/etc/ld.so.preload&#34;, R_OK) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &#34;/etc/ld.so.cache&#34;, O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=32091, ...}) = 0
mmap(NULL, 32091, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f718a1e3000
close(3)                        = 0
openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libpthread.so.0&#34;, O_RDONLY|O_CLOEXEC) = 3
read(3, &#34;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 l\0\0\0\0\0\0&#34;..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=149520, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f718a1e1000
...
close(3)                        = 0
openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libdl.so.2&#34;, O_RDONLY|O_CLOEXEC) = 3
</code></pre>

<p>This all looks a bit intimidating at first, but the part I want you to pay
attention to is <code>openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libpthread.so.0&#34;</code>.
This is opening a C threading library called <code>pthread</code> that the Python
interpreter needs to run.</p>

<p><strong>See for yourself:</strong> If you want to know which libraries a binary needs to load at runtime, you can use <code>ldd</code>. Here’s what that looks like for me:</p>

<pre><code>$ ldd /usr/bin/python3.9
	linux-vdso.so.1 (0x00007ffc2aad7000)
	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f2fd6554000)
	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f2fd654e000)
	libutil.so.1 =&gt; /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f2fd6549000)
	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2fd6405000)
	libexpat.so.1 =&gt; /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f2fd63d6000)
	libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f2fd63b9000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2fd61e3000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f2fd6580000)
</code></pre>

<p>You can see that the first library listed is <code>/lib/x86_64-linux-gnu/libpthread.so.0</code>, which is why it was loaded first.</p>

<h4 id="on-ld-library-path">on LD_LIBRARY_PATH</h4>

<p>I’m honestly still a little confused about dynamic linking. Some things I know:</p>

<ul>
<li>Dynamic linking happens in userspace and the dynamic linker on my system is at <code>/lib64/ld-linux-x86-64.so.2</code>. If you’re missing the dynamic linker, you can end up with weird bugs like this <a href="https://jvns.ca/blog/2021/11/17/debugging-a-weird--file-not-found--error/">weird “file not found” error</a></li>
<li>The dynamic linker uses the <code>LD_LIBRARY_PATH</code> environment variable to find libraries</li>
<li>The dynamic linker will also use the <code>LD_PRELOAD</code> environment to override any dynamically linked function you want (you can use this for <a href="https://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/">fun hacks</a>, or to replace your default memory allocator with an alternative one like jemalloc)</li>
<li>there are some <code>mprotect</code>s in the strace output which are marking the library code as read-only, for security reasons</li>
<li>on Mac, it’s <code>DYLD_LIBRARY_PATH</code> instead of <code>LD_LIBRARY_PATH</code></li>
</ul>

<p>You might be wondering – if dynamic linking happens in userspace, why don’t we
see a bunch of <code>stat</code> system calls where it’s searching through
<code>LD_LIBRARY_PATH</code> for the libraries, the way we did when bash was searching the
<code>PATH</code>?</p>

<p>That’s because <code>ld</code> has a cache in <code>/etc/ld.so.cache</code>, and all of those
libraries have already been found in the past. You can see it opening the cache
in the strace output – <code>openat(AT_FDCWD, &#34;/etc/ld.so.cache&#34;, O_RDONLY|O_CLOEXEC) = 3</code>.</p>

<p>There are still a bunch of system calls after dynamic linking in the <a href="https://gist.github.com/jvns/4254251bea219568df9f43a2efd8d0f5">full strace output</a> that I
still don’t really understand (what’s <code>prlimit64</code> doing? where does the locale
stuff come in? what’s <code>gconv-modules.cache</code>? what’s <code>rt_sigaction</code> doing?
what’s <code>arch_prctl</code>? what’s <code>set_tid_address</code> and <code>set_robust_list</code>?). But this feels like a good start.</p>

<h4 id="aside-ldd-is-actually-a-simple-shell-script">aside: ldd is actually a simple shell script!</h4>

<p>Someone on mastodon <a href="https://octodon.social/@lkundrak/110832640058459399">pointed out</a> that <code>ldd</code> is actually a shell script
that just sets the <code>LD_TRACE_LOADED_OBJECTS=1</code> environment variable and
starts the program. So you can do exactly the same thing like this:</p>

<pre><code>$ LD_TRACE_LOADED_OBJECTS=1 python3
	linux-vdso.so.1 (0x00007ffe13b0a000)
	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f01a5a47000)
	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f01a5a41000)
	libutil.so.1 =&gt; /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f2fd6549000)
	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2fd6405000)
	libexpat.so.1 =&gt; /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f2fd63d6000)
	libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f2fd63b9000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2fd61e3000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f2fd6580000)
</code></pre>

<p>Apparently <code>ld</code> is also a binary you can just run, so <code>/lib64/ld-linux-x86-64.so.2 --list /usr/bin/python3.9</code> also does the the same thing.</p>

<h4 id="on-init-and-fini">on <code>init</code> and <code>fini</code></h4>

<p>Let’s talk about this line in the <code>strace</code> output:</p>

<pre><code>set_tid_address(0x7f58880dca10)         = 3709103
</code></pre>

<p>This seems to have something to do with threading, and I think this might be
happening because the <code>pthread</code> library (and every other dynamically loaded)
gets to run initialization code when it’s loaded. The code that runs when the
library is loaded is in the <code>init</code> section (or maybe also the <code>.ctors</code> section).</p>

<p><strong>See for yourself:</strong> Let’s take a look at that using readelf:</p>

<pre><code>$ readelf -a /lib/x86_64-linux-gnu/libpthread.so.0
...
  [10] .rela.plt         RELA             00000000000051f0  000051f0
       00000000000007f8  0000000000000018  AI       4    26     8
  [11] .init             PROGBITS         0000000000006000  00006000
       000000000000000e  0000000000000000  AX       0     0     4
  [12] .plt              PROGBITS         0000000000006010  00006010
       0000000000000560  0000000000000010  AX       0     0     16
...
</code></pre>

<p>This library doesn’t have a <code>.ctors</code> section, just an <code>.init</code>. But what’s in
that <code>.init</code> section? We can use <code>objdump</code> to disassemble the code:</p>

<pre><code>$ objdump -d /lib/x86_64-linux-gnu/libpthread.so.0
Disassembly of section .init:

0000000000006000 &lt;_init&gt;:
    6000:       48 83 ec 08             sub    $0x8,%rsp
    6004:       e8 57 08 00 00          callq  6860 &lt;__pthread_initialize_minimal&gt;
    6009:       48 83 c4 08             add    $0x8,%rsp
    600d:       c3
</code></pre>

<p>So it’s calling <code>__pthread_initialize_minimal</code>.  I found the <a href="https://github.com/bminor/glibc/blob/a78e5979a92c7985eadad7246740f3874271303f/nptl/nptl-init.c#L100">code for that function in glibc</a>,
though I had to find an older version of glibc because it looks like in more
recent versions <a href="https://developers.redhat.com/articles/2021/12/17/why-glibc-234-removed-libpthread">libpthread is no longer a separate library</a>.</p>

<p>I’m not sure whether this <code>set_tid_address</code> system call actually comes from
<code>__pthread_initialize_minimal</code>, but at least we’ve learned that libraries can
run code on startup through the <code>.init</code> section.</p>

<p>Here’s a note from <code>man elf</code> on the <code>.init</code> section:</p>

<pre><code>$ man elf
 .init  This section holds executable instructions that contribute to the process initialization code.  When a program starts to run
              the system arranges to execute the code in this section before calling the main program entry point.
</code></pre>

<p>There’s also a <code>.fini</code> section in the ELF file that runs at the end, and
<code>.ctors</code> / <code>.dtors</code> (constructors and destructors) are other sections that
could exist.</p>

<p>Okay, that’s enough about dynamic linking.</p>

<h4 id="9-go-to-start">9: go to <code>_start</code></h4>

<p>After dynamic linking is done, we go to <code>_start</code> in the Python interpreter.
Then it does all the normal Python interpreter things you’d expect.</p>

<p>I’m not going to talk about this because here I’m interested in general
facts about how binaries are run on Linux, not the Python interpreter
specifically.</p>

<h4 id="10-write-a-string">10: write a string</h4>

<p>We still need to print out “hello world” though. Under the hood, the Python <code>print</code> function calls some function from libc. But which one? Let’s find out!</p>

<p><strong>See for yourself</strong>: Run <code>ltrace -o out python3 hello.py</code>.</p>

<pre><code>$ ltrace -o out python3 hello.py
$ grep hello out
write(1, &#34;hello world\n&#34;, 12) = 12
</code></pre>

<p>So it looks like it’s calling <code>write</code></p>

<p>I honestly am always a little suspicious of ltrace – unlike strace (which I
would trust with my life), I’m never totally sure that ltrace is actually
reporting library calls accurately. But in this case it seems to be working. And
if we look at the <a href="https://github.com/python/cpython/blob/400835ea1626c8c6dcd967c7eabe0dad4a923182/Python/fileutils.c#L1955">cpython source code</a>, it does seem to be calling <code>write()</code> in some places. So I’m willing to believe that.</p>

<h4 id="what-s-libc">what’s libc?</h4>

<p>We just said that Python calls the <code>write</code> function from libc. What’s libc?
It’s the C standard library, and it’s responsible for a lot of basic things
like:</p>

<ul>
<li>allocating memory with <code>malloc</code></li>
<li>file I/O (opening/closing/</li>
<li>executing programs (with <code>execvp</code>, like we mentioned before)</li>
<li>looking up DNS records with <code>getaddrinfo</code></li>
<li>managing threads with <code>pthread</code></li>
</ul>

<p>Programs don’t <em>have</em> to use libc (on Linux, Go famously doesn’t use it and
calls Linux system calls directly instead), but most other programming
languages I use (node, Python, Ruby, Rust) all use libc. I’m not sure about Java.</p>

<p>You can find out if you’re using libc by running <code>ldd</code> on your binary: if you
see something like <code>libc.so.6</code>, that’s libc.</p>

<h4 id="why-does-libc-matter">why does libc matter?</h4>

<p>You might be wondering – why does it matter that Python calls the libc <code>write</code>
and then libc calls the <code>write</code> system call? Why am I making a point of saying
that <code>libc</code> is in the middle?</p>

<p>I think in this case it doesn’t really matter (AFAIK the <code>write</code> libc function
maps pretty directly to the <code>write</code> system call)</p>

<p>But there are different libc implementations, and sometimes they behave
differently. The two main ones are glibc (GNU libc) and musl libc.</p>

<p>For example, until recently <a href="https://www.openwall.com/lists/musl/2023/05/02/1">musl’s <code>getaddrinfo</code> didn’t support TCP DNS</a>, <a href="https://christoph.luppri.ch/fixing-dns-resolution-for-ruby-on-alpine-linux">here’s a blog post talking about a bug that that caused</a>.</p>

<h4 id="a-little-detour-into-stdout-and-terminals">a little detour into stdout and terminals</h4>

<p>In this program, stdout (the <code>1</code> file descriptor) is a terminal. And you can do
funny things with terminals! Here’s one:</p>

<ol>
<li>In a terminal, run <code>ls -l /proc/self/fd/1</code>. I get <code>/dev/pts/2</code></li>
<li>In another terminal window, write <code>echo hello &gt; /dev/pts/2</code></li>
<li>Go back to the original terminal window. You should see <code>hello</code> printed there!</li>
</ol>

<h4 id="that-s-all-for-now">that’s all for now!</h4>

<p>Hopefully you have a better idea of how <code>hello world</code> gets printed! I’m going to stop
adding more details for now because this is already pretty long, but obviously there’s
more to say and I might add more if folks chip in with extra details. I’d
especially love suggestions for other tools you could use to inspect parts of
the process that I haven’t explained here.</p>

<p>Thanks to everyone who suggested corrections / additions – I’ve edited this blog post a lot to incorporate more things :)</p>

<p>Some things I’d like to add if I can figure out how to spy on them:</p>

<ul>
<li>the kernel loader and ASLR (I haven’t figured out yet how to use bpftrace + kprobes to trace the kernel loader’s actions)</li>
<li>TTYs (I haven’t figured out how to trace the way <code>write(1, &#34;hello world&#34;, 11)</code> gets sent to the TTY that I’m looking at)</li>
</ul>

<h3 id="i-d-love-to-see-a-mac-version-of-this">I’d love to see a Mac version of this</h3>

<p>One of my frustrations with Mac OS is that I don’t know how to introspect my
system on this level – when I print <code>hello world</code>, I can’t figure out how to
spy on what’s going on behind the scenes the way I can on Linux. I’d love to
see a really in depth explainer.</p>

<p>Some Mac equivalents I know about:</p>

<ul>
<li><code>ldd</code> -&gt; <code>otool -L</code></li>
<li><code>readelf</code> -&gt; <code>otool</code></li>
<li>supposedly you can use <code>dtruss</code> or <code>dtrace</code> on mac instead of strace but I’ve never been brave enough to turn off system integrity protection to get it to work</li>
<li><code>strace</code> -&gt; <code>sc_usage</code> seems to be able to collect stats about syscall usage, and <code>fs_usage</code> about file usage</li>
</ul>

<h3 id="more-reading">more reading</h3>

<p>Some more links:</p>

<ul>
<li><a href="https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux</a></li>
<li><a href="https://people.freebsd.org/~brooks/talks/asiabsdcon2017-helloworld/helloworld.pdf">an exploration of “hello world” on FreeBSD</a></li>
<li><a href="https://gynvael.coldwind.pl/?lang=en&amp;id=754">hello world under the microscope</a> for Windows</li>
<li>From LWN: <a href="https://lwn.net/Articles/630727/">how programs get run</a> (<a href="https://lwn.net/Articles/631631/">and part two</a>) have a bunch more details on the internals of <code>execve</code></li>
<li><a href="https://cpu.land/how-to-run-a-program">how to run a program</a></li>
</ul>

</div></div>
  </body>
</html>
