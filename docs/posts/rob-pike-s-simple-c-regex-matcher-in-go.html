<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://benhoyt.com/writings/rob-pike-regex/">Original</a>
    <h1>Rob Pike&#39;s simple C regex matcher in Go</h1>
    
    <div id="readability-page-1" class="page"><div id="container">



<div id="content">

<p>August 2022</p>

<p>Back in 1998, Rob Pike – of Go and Plan 9 fame – wrote a simple regular expression matcher in C for <em>The Practice of Programming</em>, a book he wrote with fellow Unix hacker Brian Kernighan. If you haven’t read Kernighan’s <a href="https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html">“exegesis”</a> of this code, it’s definitely worth the 30-minute time investment it takes to go through that slowly.</p>

<p>With Go’s C heritage (and Pike’s influence on the Go language), I thought I’d see how well the C code would translate to Go, and whether it was still elegant.</p>

<h2 id="original-c-version">Original C version</h2>

<p>First let’s look at Pike’s original matching code. It handles only a small number of regex metacharacters, namely <code>.</code>, <code>*</code>, <code>^</code>, and <code>$</code>, but it’s a well-chosen subset that Kernighan says “easily accounts for 95 percent of all instances” of his day-to-day usage.</p>

<p>I just grepped my <code>.bash_history</code> for <code>grep</code> usage (how meta!) and my percentage is similar, though I also use escaped metacharacters (usually <code>\.</code>) in about 10% of uses.</p>

<p>Here is the original 35-line C matcher:</p>

<div><div><pre><code><span>/* match: search for regexp anywhere in text */</span>
<span>int</span> <span>match</span><span>(</span><span>char</span> <span>*</span><span>regexp</span><span>,</span> <span>char</span> <span>*</span><span>text</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>regexp</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;^&#39;</span><span>)</span>
        <span>return</span> <span>matchhere</span><span>(</span><span>regexp</span><span>+</span><span>1</span><span>,</span> <span>text</span><span>);</span>
    <span>do</span> <span>{</span>    <span>/* must look even if string is empty */</span>
        <span>if</span> <span>(</span><span>matchhere</span><span>(</span><span>regexp</span><span>,</span> <span>text</span><span>))</span>
            <span>return</span> <span>1</span><span>;</span>
    <span>}</span> <span>while</span> <span>(</span><span>*</span><span>text</span><span>++</span> <span>!=</span> <span>&#39;\0&#39;</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>/* matchhere: search for regexp at beginning of text */</span>
<span>int</span> <span>matchhere</span><span>(</span><span>char</span> <span>*</span><span>regexp</span><span>,</span> <span>char</span> <span>*</span><span>text</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>regexp</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;\0&#39;</span><span>)</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>regexp</span><span>[</span><span>1</span><span>]</span> <span>==</span> <span>&#39;*&#39;</span><span>)</span>
        <span>return</span> <span>matchstar</span><span>(</span><span>regexp</span><span>[</span><span>0</span><span>],</span> <span>regexp</span><span>+</span><span>2</span><span>,</span> <span>text</span><span>);</span>
    <span>if</span> <span>(</span><span>regexp</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;$&#39;</span> <span>&amp;&amp;</span> <span>regexp</span><span>[</span><span>1</span><span>]</span> <span>==</span> <span>&#39;\0&#39;</span><span>)</span>
        <span>return</span> <span>*</span><span>text</span> <span>==</span> <span>&#39;\0&#39;</span><span>;</span>
    <span>if</span> <span>(</span><span>*</span><span>text</span><span>!=</span><span>&#39;\0&#39;</span> <span>&amp;&amp;</span> <span>(</span><span>regexp</span><span>[</span><span>0</span><span>]</span><span>==</span><span>&#39;.&#39;</span> <span>||</span> <span>regexp</span><span>[</span><span>0</span><span>]</span><span>==*</span><span>text</span><span>))</span>
        <span>return</span> <span>matchhere</span><span>(</span><span>regexp</span><span>+</span><span>1</span><span>,</span> <span>text</span><span>+</span><span>1</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>/* matchstar: search for c*regexp at beginning of text */</span>
<span>int</span> <span>matchstar</span><span>(</span><span>int</span> <span>c</span><span>,</span> <span>char</span> <span>*</span><span>regexp</span><span>,</span> <span>char</span> <span>*</span><span>text</span><span>)</span>
<span>{</span>
    <span>do</span> <span>{</span>    <span>/* a * matches zero or more instances */</span>
        <span>if</span> <span>(</span><span>matchhere</span><span>(</span><span>regexp</span><span>,</span> <span>text</span><span>))</span>
            <span>return</span> <span>1</span><span>;</span>
    <span>}</span> <span>while</span> <span>(</span><span>*</span><span>text</span> <span>!=</span> <span>&#39;\0&#39;</span> <span>&amp;&amp;</span> <span>(</span><span>*</span><span>text</span><span>++</span> <span>==</span> <span>c</span> <span>||</span> <span>c</span> <span>==</span> <span>&#39;.&#39;</span><span>));</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Beautiful, right? I won’t explain this code here; Kernighan does a far better job of it than I could in his <a href="https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html">“A Regular Expression Matcher”</a> article.</p>

<h2 id="translation-to-go">Translation to Go</h2>

<p>Strings in Go don’t use <code>char*</code> pointers, of course, but string indexing and string slice operations such as <code>text[1:]</code> are a close match (so to speak).</p>

<p>As Kernighan points out, <code>do</code>-<code>while</code> is fairly rare in C, but it’s necessary here. Probably for the better, Go doesn’t have <code>do</code>-<code>while</code>, so I use an <code>if</code> statement inside the loop and return early instead. Besides, <code>do</code>-<code>while</code> wouldn’t help us here because we still couldn’t use fetch-and-increment expressions like <code>*text++</code>.</p>

<p>A number of things take more lines in Go, partly because of the lack of <code>do</code>-<code>while</code>, but also because you can’t do one-line <code>if</code> statements without braces. However, I have converted the run of <code>if</code> statements in <code>matchHere</code> to a bare <code>switch</code>, which makes that function almost as terse as the C version.</p>

<p>A few things are simpler thanks to Go’s strings, for example <code>regexp[0] == &#39;$&#39; &amp;&amp; regexp[1] == &#39;\0&#39;</code> becomes just <code>regexp == &#34;$&#34;</code>.</p>

<p>So without further ado, here’s my Go version:</p>

<div><div><pre><code><span>// Match reports whether regexp matches anywhere in text.</span>
<span>func</span> <span>Match</span><span>(</span><span>regexp</span><span>,</span> <span>text</span> <span>string</span><span>)</span> <span>bool</span> <span>{</span>
    <span>if</span> <span>regexp</span> <span>!=</span> <span>&#34;&#34;</span> <span>&amp;&amp;</span> <span>regexp</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;^&#39;</span> <span>{</span>
        <span>return</span> <span>matchHere</span><span>(</span><span>regexp</span><span>[</span><span>1</span><span>:</span><span>],</span> <span>text</span><span>)</span>
    <span>}</span>
    <span>for</span> <span>{</span>
        <span>if</span> <span>matchHere</span><span>(</span><span>regexp</span><span>,</span> <span>text</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span>
        <span>}</span>
        <span>if</span> <span>text</span> <span>==</span> <span>&#34;&#34;</span> <span>{</span>
            <span>return</span> <span>false</span>
        <span>}</span>
        <span>text</span> <span>=</span> <span>text</span><span>[</span><span>1</span><span>:</span><span>]</span>
    <span>}</span>
<span>}</span>

<span>// matchHere reports whether regexp matches at beginning of text.</span>
<span>func</span> <span>matchHere</span><span>(</span><span>regexp</span><span>,</span> <span>text</span> <span>string</span><span>)</span> <span>bool</span> <span>{</span>
    <span>switch</span> <span>{</span>
    <span>case</span> <span>regexp</span> <span>==</span> <span>&#34;&#34;</span><span>:</span>
        <span>return</span> <span>true</span>
    <span>case</span> <span>regexp</span> <span>==</span> <span>&#34;$&#34;</span><span>:</span>
        <span>return</span> <span>text</span> <span>==</span> <span>&#34;&#34;</span>
    <span>case</span> <span>len</span><span>(</span><span>regexp</span><span>)</span> <span>&gt;=</span> <span>2</span> <span>&amp;&amp;</span> <span>regexp</span><span>[</span><span>1</span><span>]</span> <span>==</span> <span>&#39;*&#39;</span><span>:</span>
        <span>return</span> <span>matchStar</span><span>(</span><span>regexp</span><span>[</span><span>0</span><span>],</span> <span>regexp</span><span>[</span><span>2</span><span>:</span><span>],</span> <span>text</span><span>)</span>
    <span>case</span> <span>text</span> <span>!=</span> <span>&#34;&#34;</span> <span>&amp;&amp;</span> <span>(</span><span>regexp</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;.&#39;</span> <span>||</span> <span>regexp</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>text</span><span>[</span><span>0</span><span>])</span><span>:</span>
        <span>return</span> <span>matchHere</span><span>(</span><span>regexp</span><span>[</span><span>1</span><span>:</span><span>],</span> <span>text</span><span>[</span><span>1</span><span>:</span><span>])</span>
    <span>}</span>
    <span>return</span> <span>false</span>
<span>}</span>

<span>// matchStar reports whether c*regexp matches at beginning of text.</span>
<span>func</span> <span>matchStar</span><span>(</span><span>c</span> <span>byte</span><span>,</span> <span>regexp</span><span>,</span> <span>text</span> <span>string</span><span>)</span> <span>bool</span> <span>{</span>
    <span>for</span> <span>{</span>
        <span>if</span> <span>matchHere</span><span>(</span><span>regexp</span><span>,</span> <span>text</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span>
        <span>}</span>
        <span>if</span> <span>text</span> <span>==</span> <span>&#34;&#34;</span> <span>||</span> <span>(</span><span>text</span><span>[</span><span>0</span><span>]</span> <span>!=</span> <span>c</span> <span>&amp;&amp;</span> <span>c</span> <span>!=</span> <span>&#39;.&#39;</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span>
        <span>}</span>
        <span>text</span> <span>=</span> <span>text</span><span>[</span><span>1</span><span>:</span><span>]</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>It’s 43 lines compared to 35. Thanks partly to Pike’s influence on the language, I think the Go version still captures much of the elegance of his original C.</p>

<p>My first version was very slightly different (and 4 lines longer): I <a href="https://github.com/benhoyt/repike/commit/45c498067faa47c28553c219f6dcfa1cb86fcc4a">simplified</a> a few things, including replacing the run of <code>if</code>s in <code>matchHere</code> with the <code>switch</code>. If you have any suggestions for how to make the Go code simpler or more elegant, let me know.</p>

<h2 id="testing">Testing</h2>

<p>To ensure my Go version was correct, I added a bunch of table-driven <a href="https://github.com/benhoyt/repike/blob/master/repike_test.go">tests</a> that (I believe) test the various edge cases. I run each test on my Go version as well as using Go’s <a href="https://pkg.go.dev/regexp"><code>regexp</code></a> package. I also use <a href="https://pkg.go.dev/os/exec"><code>os/exec</code></a> to run each test against the original C version, and ensure the results are identical.</p>

<p>I use Go’s sub-tests to do this; the <code>t.Run</code> calls set up a sub-test. To demonstrate this in action, I’m including the majority of the test code below:</p>

<div><div><pre><code><span>type</span> <span>test</span> <span>struct</span> <span>{</span>
    <span>name</span>    <span>string</span>
    <span>re</span>      <span>string</span>
    <span>text</span>    <span>string</span>
    <span>matched</span> <span>bool</span>
<span>}</span>

<span>var</span> <span>tests</span> <span>=</span> <span>[]</span><span>test</span><span>{</span>
    <span>{</span><span>&#34;EmptyBoth&#34;</span><span>,</span> <span>&#34;&#34;</span><span>,</span> <span>&#34;&#34;</span><span>,</span> <span>true</span><span>},</span>
    <span>{</span><span>&#34;EmptyRegex&#34;</span><span>,</span> <span>&#34;&#34;</span><span>,</span> <span>&#34;foo&#34;</span><span>,</span> <span>true</span><span>},</span>
    <span>{</span><span>&#34;EmptyText&#34;</span><span>,</span> <span>&#34;foo&#34;</span><span>,</span> <span>&#34;&#34;</span><span>,</span> <span>false</span><span>},</span>
    <span>// ... snipped for brevity ...</span>
<span>}</span>

<span>func</span> <span>TestMatch</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
    <span>_</span><span>,</span> <span>err</span> <span>:=</span> <span>os</span><span>.</span><span>Stat</span><span>(</span><span>&#34;./matchc&#34;</span><span>)</span>
    <span>haveC</span> <span>:=</span> <span>err</span> <span>==</span> <span>nil</span> <span>// does the compiled C version exist?</span>

    <span>for</span> <span>_</span><span>,</span> <span>test</span> <span>:=</span> <span>range</span> <span>tests</span> <span>{</span>
        <span>// Ensure Go matcher passes.</span>
        <span>t</span><span>.</span><span>Run</span><span>(</span><span>test</span><span>.</span><span>name</span><span>+</span><span>&#34;/repike&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
            <span>matched</span> <span>:=</span> <span>repike</span><span>.</span><span>Match</span><span>(</span><span>test</span><span>.</span><span>re</span><span>,</span> <span>test</span><span>.</span><span>text</span><span>)</span>
            <span>if</span> <span>matched</span> <span>!=</span> <span>test</span><span>.</span><span>matched</span> <span>{</span>
                <span>t</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;got %v, want %v&#34;</span><span>,</span> <span>matched</span><span>,</span> <span>test</span><span>.</span><span>matched</span><span>)</span>
            <span>}</span>
        <span>})</span>

        <span>// Ensure test passes using Go&#39;s regexp package.</span>
        <span>t</span><span>.</span><span>Run</span><span>(</span><span>test</span><span>.</span><span>name</span><span>+</span><span>&#34;/regexp&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
            <span>matched</span><span>,</span> <span>err</span> <span>:=</span> <span>regexp</span><span>.</span><span>MatchString</span><span>(</span><span>test</span><span>.</span><span>re</span><span>,</span> <span>test</span><span>.</span><span>text</span><span>)</span>
            <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
                <span>t</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;compile error: %v&#34;</span><span>,</span> <span>err</span><span>)</span>
            <span>}</span>
            <span>if</span> <span>matched</span> <span>!=</span> <span>test</span><span>.</span><span>matched</span> <span>{</span>
                <span>t</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;got %v, want %v&#34;</span><span>,</span> <span>matched</span><span>,</span> <span>test</span><span>.</span><span>matched</span><span>)</span>
            <span>}</span>
        <span>})</span>

        <span>// Ensure test passes using original C matcher.</span>
        <span>if</span> <span>haveC</span> <span>{</span>
            <span>t</span><span>.</span><span>Run</span><span>(</span><span>test</span><span>.</span><span>name</span><span>+</span><span>&#34;/matchc&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
                <span>cmd</span> <span>:=</span> <span>exec</span><span>.</span><span>Command</span><span>(</span><span>&#34;./matchc&#34;</span><span>,</span> <span>test</span><span>.</span><span>re</span><span>)</span>
                <span>cmd</span><span>.</span><span>Stdin</span> <span>=</span> <span>strings</span><span>.</span><span>NewReader</span><span>(</span><span>test</span><span>.</span><span>text</span> <span>+</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>)</span>
                <span>err</span> <span>:=</span> <span>cmd</span><span>.</span><span>Run</span><span>()</span>
                <span>// ... snipped for brevity ...</span>
            <span>})</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<h2 id="benchmarks">Benchmarks</h2>

<p>I ran <a href="https://github.com/benhoyt/repike/blob/master/benchmark.sh">benchmarks</a> of a grep-like matching program using each of the matchers (as well as <code>grep</code>), matching the regex <code>Ben.*H</code> over 100 concatenated repeats of the <a href="https://www.gutenberg.org/ebooks/10">King James Bible</a>.</p>

<p>I was pleasantly surprised to see that the Go translation is about the same speed as the original C version (compiled with <code>gcc -O2</code>). I guess the recursive structure of it means the generated code is fairly similar between the two.</p>

<p>Go’s <code>regexp</code> package is <a href="https://github.com/golang/go/issues/26623">known</a> to be slow, and it also handles Unicode correctly, so I had assumed it’d be at least as slow as the simple matchers. However, it’s almost twice as fast. I’ll leave it as an exercise for the reader why; my guess is that it’s not recursive for this case, and recursive function calls are relatively slow.</p>

<p>Of course, GNU Grep is about three times as fast. For more on why GNU Grep is so fast, read <a href="https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">this classic FreeBSD mailing list post</a>.</p>

<p>Here is a table of the results (best of five) on my laptop, from fastest to slowest:</p>

<table>
  <thead>
    <tr>
      <th>Version</th>
      <th>Time (s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GNU grep</td>
      <td>0.671</td>
    </tr>
    <tr>
      <td>Go regexp</td>
      <td>1.170</td>
    </tr>
    <tr>
      <td>Go matcher</td>
      <td>2.180</td>
    </tr>
    <tr>
      <td>C matcher</td>
      <td>2.243</td>
    </tr>
  </tbody>
</table>

<p>For the record, I’m using GCC version 11.2, Go version 1.18.1, and GNU Grep 3.7. My system is 64-bit Linux running a 2.6GHz i7-6700HQ CPU.</p>

<h2 id="bonus-glob-matcher">Bonus: glob matcher</h2>

<p>While getting distracted with this stuff, I also wrote a simple, 28-line glob matcher in Go that does <code>?</code> and <code>*</code> wildcard-style matching. It uses a similar implementation that loops through the pattern and text at the same time, with recursion for the <code>*</code> case.</p>

<p>Source code is below (also a <a href="https://gist.github.com/benhoyt/c3462407af4ab9591d59b79015c02d31">gist</a>):</p>

<div><div><pre><code><span>func</span> <span>match</span><span>(</span><span>pattern</span><span>,</span> <span>name</span> <span>string</span><span>)</span> <span>bool</span> <span>{</span>
    <span>for</span> <span>pattern</span> <span>!=</span> <span>&#34;&#34;</span> <span>{</span>
        <span>p</span> <span>:=</span> <span>pattern</span><span>[</span><span>0</span><span>]</span>
        <span>pattern</span> <span>=</span> <span>pattern</span><span>[</span><span>1</span><span>:</span><span>]</span>
        <span>switch</span> <span>p</span> <span>{</span>
        <span>case</span> <span>&#39;*&#39;</span><span>:</span>
            <span>for</span> <span>pattern</span> <span>!=</span> <span>&#34;&#34;</span> <span>&amp;&amp;</span> <span>pattern</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;*&#39;</span> <span>{</span>
                <span>pattern</span> <span>=</span> <span>pattern</span><span>[</span><span>1</span><span>:</span><span>]</span>
            <span>}</span>
            <span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>len</span><span>(</span><span>name</span><span>);</span> <span>i</span><span>++</span> <span>{</span>
                <span>if</span> <span>match</span><span>(</span><span>pattern</span><span>,</span> <span>name</span><span>[</span><span>i</span><span>:</span><span>])</span> <span>{</span>
                    <span>return</span> <span>true</span>
                <span>}</span>
            <span>}</span>
            <span>return</span> <span>false</span>
        <span>case</span> <span>&#39;?&#39;</span><span>:</span>
            <span>if</span> <span>name</span> <span>==</span> <span>&#34;&#34;</span> <span>{</span>
                <span>return</span> <span>false</span>
            <span>}</span>
        <span>default</span><span>:</span>
            <span>if</span> <span>name</span> <span>==</span> <span>&#34;&#34;</span> <span>||</span> <span>p</span> <span>!=</span> <span>name</span><span>[</span><span>0</span><span>]</span> <span>{</span>
                <span>return</span> <span>false</span>
            <span>}</span>
        <span>}</span>
        <span>name</span> <span>=</span> <span>name</span><span>[</span><span>1</span><span>:</span><span>]</span>
    <span>}</span>
    <span>return</span> <span>name</span> <span>==</span> <span>&#34;&#34;</span>
<span>}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>I think Pike’s code is useful, instructive, and beautiful. I certainly had fun reading Kernighan’s article, porting the code, and writing this up, so I hope you enjoy it too.</p>

<p>Note that neither the C nor the Go version handles Unicode properly. It will work on UTF-8 input, but <code>.</code> and <code>c*</code> won’t match multi-byte characters correctly (though in many cases that won’t matter). The simplest way to fix this in the Go version would be to convert the <code>regexp</code> and <code>text</code> strings to slices of runes (<code>[]rune</code>) before beginning, and then use the same algorithm from there.</p>

<p>Of course, there are better ways to implement regex matching that don’t have horrible run times on craftily-constructed regexes like <code>a.*a.*a.*a.a</code>, but you’ll have to read Russ Cox’s article <a href="https://swtch.com/~rsc/regexp/regexp1.html">“Regular Expression Matching Can Be Simple And Fast”</a> for more on that.</p>

<p>Thanks for reading!</p>

<p>I’d love it if you <a href="https://github.com/sponsors/benhoyt/">sponsored me on GitHub</a> – it will motivate me to work on my open source projects and write more good content. Thanks!</p>


</div>

</div></div>
  </body>
</html>
