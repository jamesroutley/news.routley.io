<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jingnanshi.com/blog/groebner_basis.html">Original</a>
    <h1>Use Gröbner bases to solve polynomial equations</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
I’ve seen Gröbner bases in many research papers <sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup> <sup>, </sup><sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup>.
As an excuse to learn more about them, I write this article down to serve both as a note for me as well as a tutorial for interested readers to get a brief glimpse of the power of Gröbner bases.
</p>

<p>
To fully explore Gröbner bases and related, we need to involve a multitude of different topics in algebraic geometry; and to be frank, I am not currently capable of doing so.
Hence, I will exclusively focus on the topic of using Gröbner Bases to solve polynomial equations, which is interesting and useful to many.
I will accompany the discussions with short code snippets in Python using the SymPy package.
You can also find code snippets used in this post in my code repo <a href="https://github.com/jingnanshi/code-for-blog">here</a>.
</p>

<p>
This article relies heavily in terms of examples and definitions on the fantastic textbook <i>Ideals, Varieties and Algorithms: An Introduction to Computational Algebraic Geometry and Commutative Algebra</i> by David A. Cox, John Little and Donal O’Shea<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup>.
Interested readers should refer to it for more detailed exposition on this topic.
In addition, lecture handouts by Judy Holdener at CMU are very helpful<sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup>.
I list additional references at the end of this post.
</p>

<div id="outline-container-org5f0f16b">
<h2 id="org5f0f16b">A Motivational Problem</h2>
<div id="text-org5f0f16b">
<p>
First, let’s motivate the study of Gröbner bases through an example of solving a system of linear equations.
Consider the following set of linear equations
</p><p>
\begin{align}
2x_{1} + 3 x_{2} - x_{3} &amp;= 0 \\
x_{1} + x_{2} - 1 &amp;= 0 \\
x_{1} + x_{3} - 3 &amp;= 0
\end{align}
</p><p>
which can be written in the matrix form
</p><p>
\begin{align}
\begin{pmatrix}
2 &amp; 3 &amp; -1 &amp; 0 \\
1 &amp; 1 &amp; 0  &amp; 1 \\
1 &amp; 0 &amp; 1  &amp; 3
\end{pmatrix}.
\end{align}
</p><p>
By performing Gaussian Elimination, we arrive at the reduced row echelon form
</p><p>
\begin{align}
\begin{pmatrix}
1 &amp; 0 &amp; 1 &amp; 3 \\
0 &amp; 1 &amp; -1 &amp; -2 \\
0 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}.
\end{align}
</p><p>
You can check this yourself by running the following Python code using SymPy:
</p>
<div>
<pre><span>import</span> sympy <span>as</span> sp
<span>def</span> <span>gaussian_elimination</span>(M):
    <span>return</span> M.rref()[<span>0</span>]

gaussian_elimination(sp.Matrix([[<span>2</span>, <span>3</span>, <span>-</span><span>1</span>, <span>0</span>],
                                [<span>1</span>, <span>1</span>, <span>0</span>, <span>1</span>],
                                [<span>1</span>, <span>0</span>, <span>1</span>, <span>3</span>]]))
</pre>
</div>

<p>
The results should look like this:
</p>
<pre>Matrix([[1, 0, 1, 3], [0, 1, -1, -2], [0, 0, 0, 0]])
</pre>


<p>
From the above, we can see that the solution to the system is
</p><p>
\begin{align}
x_{1} = -t + 3, \\
x_{2} = t - 2, \\
x_{3} = t.
\end{align}
</p><p>
which is equivalent to a line in \(\mathbb{R}^{3}\).
</p>

<p>
Now, can we do something similar to a system of polynomial equations?
In other words, we want to develop a method to determine the solution to
</p><p>
\begin{align}
f_{1}(x_{1}, x_{2}, \ldots, x_{n}) =  f_{2}(x_{1}, x_{2}, \ldots, x_{n}) = \cdots = f_{s}(x_{1}, x_{2}, \ldots, x_{n}) = 0.
\end{align}
</p><p>
The method of Gröbner bases allows us to do so.
</p>
</div>
</div>

<div id="outline-container-org5ff4440">
<h2 id="org5ff4440">A Taste of Gröbner Bases</h2>
<div id="text-org5ff4440">
<p>
I will start with a concrete example of using Gröbner Bases to solve a system of polynomial equations.
Words and phrases in bold are new concepts which I will define later.
</p>

<p>
Consider the following system of equations:
</p><p>
\begin{align}
x^{2} + y + z = 1, \\
x + y^{2} + z = 1, \\
x + y + z^{2} = 1.
\end{align}


</p><div id="org5d923c6">
<p><img src="https://jingnanshi.com/img/articles/6_groebner/implicit_system.png" alt="implicit_system.png"/>
</p>
<p><span>Figure 1: </span>Visualization of the system of polynomial equations above. The three equations are represent as the three surfaces, and the solutions are represented as spheres. The four visible spheres represent \((1,0,0)\), \((0,1,0)\), \((0,0,1)\) and \((-1+\sqrt{2},-1+\sqrt{2},-1+\sqrt{2})\). There is one more occluded solution at the back, corresponding to \((-1 - \sqrt{2}, -1 - \sqrt{2}, -1 - \sqrt{2})\).</p>
</div>

<p>
We first define the <b><b>ideal</b></b>
</p><p>
\begin{align}
I = \langle x^{2} + y + z - 1, x + y^{2} + z - 1, x + y + z^{2} - 1 \rangle.
\end{align}
</p><p>
where the angle brackets represent a set of polynomials following
</p><p>
\begin{align}
\left\langle f_1, \ldots, f_s\right\rangle=\left\{\sum_{i=1}^s h_i f_i \mid h_1, \ldots, h_s \in k\left[x_1, \ldots, x_n\right]\right\}.
\end{align}
</p><p>
Right now treat this ideal roughly as the set of polynomials of which the solutions to \(x\), \(y\) and \(z\) satisfies the original polynomial system.
The <b><b>Gröbner bases</b></b> for this ideal \(I\) with respect to <b><b>lex order</b></b> is the following:
</p><p>
\begin{align}
g_{1} = x + y + z^{2} - 1, \\
g_{2} = y^{2} - y - z^{2} + z, \\
g_{3} = 2yz^{2} + z^{4} - z^{2}, \\
g_{4} = z^{6} - 4z^{4} + 4z^{3} - z^{2}. \\
\end{align}
</p><p>
Note that \(g(4)\) contains only \(z\), and
</p><p>
\begin{align}
g(4) = z^{6} - 4z^{4} + 4z^{3} - z^{2} = z^{2} (z - 1)^{2} (z^{2} + 2z - 1),
\end{align}
</p><p>
which becomes zero when \(z = 0, 1, -1 + \sqrt{2}, -1 - \sqrt{2}\).
Substituting them back to \(g_{2} = 0\) and \(g_{3} = 0\), we can determine \(y = 1, 0, -1 + \sqrt{2}, -1 - \sqrt{2}\).
Then using \(g_{1}\), we can get the corresponding values for \(x\), which leads to the following five possible solutions to the original system:
</p><p>
\begin{align}
(1, 0, 0), \\
(0, 1, 0), \\
(0, 0, 1), \\
(-1+\sqrt{2},-1+\sqrt{2},-1+\sqrt{2}), \\
(-1-\sqrt{2},-1-\sqrt{2},-1-\sqrt{2}), \\
\end{align}

</p><p>
Notice how the existence of \(g(4)\), a polynomial with only one variable \(z\), enables us to solve for all variables through back-substitution.
To understand how this process works, we need to answer the following two questions:
</p>
<ol>
<li><a id="org95962f3"></a> What is the relationship of the ideal with respect to the original system of equations?</li>
<li><a id="org5e8854b"></a> What are Gröbner bases?</li>
<li><a id="orgca084be"></a> How do Gröbner bases help us solve polynomial systems?</li>
</ol>
<p>
Now we will make an attempt to answer these three questions.
</p>
</div>
</div>

<div id="outline-container-orga290c2a">
<h2 id="orga290c2a">Background</h2>
<p>
Unfortunately we need to go over a few definitions so that we have a common ground for discussing Gröbner bases.
Concepts like polynomials should be familiar, but we need some more definitions in order to discuss them in a precise manner.
We will see relevant SymPy code as well to play around with some of the concepts.
</p>

<div id="outline-container-org63563b9">
<h3 id="org63563b9">Some Concepts from Abstract Algebra</h3>
<div id="text-org63563b9">
<p>
A <b><b>field</b></b> is a set \(k\) with two operations defined: \(+\) and \(\cdot\), with the following properties:
</p>
<ul>
<li>Associativity: \((a+ b) + c = a + (b + c)\) and \((a \cdot b) \cdot c = a \cdot (b \cdot c)\),</li>
<li>Commutativity: \(a + b = b + a\) and \(a \cdot b = b \cdot a\),</li>
<li>Distributivity: \(a \cdot (b + c) = a \cdot b + a \cdot c\),</li>
<li>Identities: there exist \(0\) and \(1\) in \(k\) such that \(a + 0 = 1 \cdot a = a\),</li>
<li>Additive Inverses: for each \(a\), there exists \(b\) such that \(a + b = 0\),</li>
<li>Multiplicative Inverses: for each \(a \neq 0\), a \(c\) exists in \(k\) such that \(a \cdot c = 1\).</li>
</ul>
<p>
Examples of fields include \(\mathbb{Q}\), \(\mathbb{R}\) and \(\mathbb{C}\).
</p>
</div>
</div>

<div id="outline-container-org3bb2321">
<h3 id="org3bb2321">Monomials and Polynomials</h3>
<div id="text-org3bb2321">
<p>
Assume \(x_{1}, \ldots, x_{n}\) are variables.
A <b><b>monomial</b></b> in \(x_{1}, \ldots, x_{n}\) is a product of the form \(x^{\alpha_{1}}_{1} \cdot x^{\alpha_{2}}_{2} \cdots x^{\alpha_{3}}_{3}\).
The total degree of a monomial is \(\sum_{1}^{n} \alpha_{i}\).
Alternatively, we can use a vector notation, with \(\alpha = (\alpha_{1}, \ldots, \alpha{n})\) and
</p><p>
\begin{align}
x^{\alpha} =x^{\alpha_{1}}_{1} \cdot x^{\alpha_{2}}_{2} \cdots x^{\alpha_{3}}_{3}.
\end{align}

</p><p>
A <b><b>polynomial</b></b> \(f\) is a finite collection of monomials with coefficients in field \(k\), in the form of
</p><p>
\begin{align}
f = \sum_{\alpha \in \mathcal{A}} a_{\alpha} x^{\alpha}
\end{align}
</p><p>
where \(\mathcal{A}\) is a finite set containing n-tuples, \(a_{\alpha}\) is the coefficient of the monomial term \(x^{\alpha}\).
\(a_{\alpha} x^{\alpha}\) is a term of the polynomial if \(a_{\alpha} \neq 0\).
Denote the set of all polynomials in \(x_{1}, \ldots, x_{n}\) with coefficients in field \(k\) as \(k[x_{1}, \ldots, x_{n}]\).
The <b><b>total degree</b></b> of a polynomial is the maximum \(\| \alpha \|\) of all terms in the polynomial.
</p>

<p>
In SymPy, polynomials are created by constructing expressions using predefined symbols:
</p>
<div>
<pre><span>from</span> sympy <span>import</span> poly
<span>from</span> sympy.abc <span>import</span> x, y, z


<span>A</span> <span>=</span> poly(x<span>**</span><span>2</span> <span>+</span> <span>2</span><span>*</span>x <span>+</span> <span>1</span>)


<span>B</span> <span>=</span> poly(x<span>**</span><span>2</span> <span>+</span> y <span>+</span> z)
</pre>
</div>

<p>
<code>A</code> and <code>B</code> should be <code>Poly(x**2 + 2*x + 1, x, domain=&#39;ZZ&#39;)</code> and <code>Poly(x**2 + y + z, x, y, z, domain=&#39;ZZ&#39;)</code> respectively.
The parameter <code>domain</code> represents the domain in which coefficients of the polynomial reside, in this case integers (<code>ZZ</code>).
</p>
</div>
</div>

<div id="outline-container-org6b9d720">
<h3 id="org6b9d720">Monomial Ordering</h3>
<div id="text-org6b9d720">
<p>
An important concept regarding polynomials is that of ordering.
Let’s observe the Gaussian elimination process.
During row reduction, we are working systematically to reduce the leftmost entry to zero for each row,
with the first nonzero entry in the row as the leading term.
For polynomials, <b><b>monomial ordering</b></b> formalizes this concept.
A monomial ordering \(&gt;\) on the polynomial \(k[x_{1}, \ldots, x_{n}]\) is a relation on \(\mathbb{Z}^{n}_{\geq 0}\)
(the set of exponents of the monomials as n-tuples) such that
</p>
<ul>
<li>for every pair of \(x^{\alpha}\) and \(x^{\beta}\), exactly one of the three statements is true: \(\alpha &gt; \beta\), \(\alpha = \beta\) or \(\beta &gt; \alpha\),</li>
<li>if \(\alpha &gt; \beta\), and \(\gamma \in \mathbb{Z}^{n}_{\geq 0}\), then \(\alpha + \gamma &gt; \beta + \gamma\),</li>
<li>\(&gt;\) is a well-ordering on \(\mathbb{Z}^{n}_{\geq 0}\) (equivalent to saying every non-empty subset of \(\mathbb{Z}^{n}_{\geq 0}\) has a smallest element under \(&gt;\)).</li>
</ul>
<p>
We say \(x^{\alpha} &gt; x^{\beta}\) if \(\alpha &gt; \beta\).
</p>

<p>
The simplest example of monomial ordering is the <b><b>lexicographic order</b></b> \(&gt;_{lex}\). In this order, \(\alpha &gt;_{lex} \beta\) if the leftmost non-zero entry of \(\alpha - \beta\) is positive.
So \(x_{1} &gt;_{lex} x_{2} &gt;_{lex} x_{3} \cdots &gt;_{lex} x_{n}\). You can prove that this order is a proper monomial ordering.
Note that given a set of \(n\) variables, there are actually \(n!\) lexicographic orders. However by convention we adopt \(x_{1} &gt;_{lex} x_{2} &gt;_{lex} x_{3} \cdots &gt;_{lex} x_{n}\).
If we are using \(x\), \(y\), and \(z\) as varialbes, we assume \(x &gt; y &gt; z\).
</p>

<p>
Here are some examples of comparing monomials using lexicographic orders:
</p>
<ul>
<li>\(x^{3} &gt;_{lex} x^{2}y^{4}\)</li>
<li>\(x^{2}yz &gt;_{lex} xyz\)</li>
<li>\(xy^{2}z &gt;_{lex} z^{2}\)</li>
</ul>

<p>
Another potential monomial ordering is the <b><b>graded lexicographic order</b></b> \(&gt;_{grlex}\). By graded, it means we need to consider the total degrees of the monomial terms.
Let \(\alpha, \beta \in \mathbb{Z}^{n}_{\geq 0}\). \(\alpha &gt;_{grlex} \beta\) if
</p><p>
\begin{align}
\| \alpha \| &gt; \| \beta \|, \quad \text{or} \quad \| \alpha \| = \| \beta \| and \alpha &gt;_{lex} \beta
\end{align}

</p><p>
Here are the same examples of comparisons using graded lexicographic order:
</p>
<ul>
<li>\(x^{2}y^{4} &gt;_{grlex} x^{3}\)</li>
<li>\(x^{2}yz &gt;_{grlex} xyz\)</li>
<li>\(xy^{2}z &gt;_{grlex} z^{2}\)</li>
</ul>

<p>
Given a monomial order \(&gt;\) and a polynomial \(f = \sum_{\alpha} a_{\alpha} x^{\alpha}\) in \(k[x_{1}, \ldots, x_{n}]\), we define the following:
</p>
<ul>
<li><p>
The <b><b>multidegree</b></b> of f is:
</p>
\begin{align}
  \text{multideg}(f) = \max(\alpha \in \mathbb{Z}^{n}_{\geq 0} \mid a_{\alpha} \neq 0)
\end{align}</li>
<li><p>
The <b><b>leading coefficient</b></b> of f is
</p>
\begin{align}
  \text{LC}(f) = a_{\text{multideg}(f)} \in k
\end{align}</li>
<li><p>
The <b><b>leading monomial</b></b> of f is
</p>
\begin{align}
  \text{LM}(f) = x^{\text{multideg}(f)}
\end{align}</li>
<li><p>
The <b><b>leading term</b></b> of f is
</p>
\begin{align}
  \text{LT}(f) = \text{LC} \cdot \text{LM} (f)
\end{align}</li>
</ul>
<p>
Note that since the \(\max\) function depends on the monomial order \(&gt;\) we use, all definitions above depends on the choice of the monomial order.
</p>

<p>
In SymPy, we have a few handy functions to get these properties of polynomials:
</p>
<div>
<pre><span>from</span> sympy <span>import</span> poly, LC, LM, LT
<span>from</span> sympy.abc <span>import</span> x, y, z


<span>f</span> <span>=</span> poly(<span>4</span><span>*</span>x<span>**</span><span>2</span><span>*</span>y <span>+</span> <span>2</span><span>*</span>x<span>*</span>y<span>*</span>z <span>+</span> z<span>**</span><span>2</span>)




<span>print</span>(f<span>&#34;LC(f): </span>{LC(f, x, y, z)}<span>&#34;</span>)


<span>print</span>(f<span>&#34;LM(f): </span>{LM(f, x, y, z)}<span>&#34;</span>)


<span>print</span>(f<span>&#34;LT(f): </span>{LT(f, x, y, z)}<span>&#34;</span>)
</pre>
</div>

<p>
Running the above should give you:
</p>
<pre>LC(f): 4
LM(f): x**2*y
LT(f): 4*x**2*y
</pre>


<p>
With the definitions, we are now geared up to dive deeper into the topics of Gröbner bases and polynomials.
</p>
</div>
</div>
</div>

<div id="outline-container-org4e8473c">
<h2 id="org4e8473c">Ideals and Solutions to Systems of Polynomials</h2>
<p>
We now try to answer <a href="#org95962f3">Question 1</a> we proposed at the end of Section <a href="#org5ff4440">A Taste of Gröbner Bases</a>.
In particular, we define what exactly are the solutions to a system of polynomials, and how ideals relate to them.
</p>

<div id="outline-container-org464326b">
<h3 id="org464326b">Affine Varieties</h3>
<div id="text-org464326b">

<div id="org0f442d0">
<p><img src="https://jingnanshi.com/img/articles/6_groebner/clebsch_cubic.png" alt="clebsch_cubic.png"/>
</p>
<p><span>Figure 2: </span>Visualization of the Clebsch surface. Refer to <a href="https://blogs.ams.org/visualinsight/2016/03/01/clebsch-surface/">here</a> for more information about this unique cubic surface.</p>
</div>

<p>
An <b><b>affine variety</b></b> is the set of all solutions to a system of polynomials. Specifically,
</p><p>
\begin{align}
\mathbf{V}(f_{1}, \ldots, f_{s}) = \{ (a_{1}, \ldots, a_{n}) \in k^{n} \mid f_{i} (a_{1}, \ldots, a_{n}) = 0, 1 \leq i \leq s \},
\end{align}
</p><p>
where \(f_{1}, \ldots, f_{s}\) are polynomials in \(k[x_{1}, \ldots, x_{n}]\).
</p>

<p>
An example visualization of a variety, called the Clebsch surface, is shown in Fig. <a href="#org0f442d0">2</a>, where the variety is
</p><p>
\begin{gather}
\mathbf{V}(81 (x^3 + y^3 + z^3) – 189 (x^2 y + x^2 z + x y^2 + x z^2 + y^2 z + y z^2) \\
+ 54 xyz + 26(xy + xz + yz) – 9(x^2 + y^2 + z^2) – 9(x + y + z) + 1).
\end{gather}
</p></div>
</div>

<div id="outline-container-org28d5ee8">
<h3 id="org28d5ee8">Ideals</h3>
<div id="text-org28d5ee8">
<p>
An <b><b>ideal</b></b> is a subset of polynomials \(I \subset k[x_{1}, \ldots, x_{n}]\) if
</p>
<ul>
<li>\(0 \in I\),</li>
<li>If \(f, g \in I\), then \(f + g \in I\),</li>
<li>If \(f \in I\), and \(h \in k[x_{1}, \ldots, x_{n}]\) then \(hf \in I\).</li>
</ul>

<p>
Ideal is a very natural concept for polynomials. Consider
</p><p>
\begin{align}
\langle f_{1}, \ldots, f_{s} \rangle = \left\{ \sum_{i=1}^{s} h_{i} f_{i} \mid h_{1}, \ldots, h_{s} \in k[x_{1}, \ldots, x_{n}] \right\}
\end{align}
</p><p>
which is a set of polynomials formed by a finite set of polynomials \(f_{1}\) to \(f_{s}\) multiplying with other polynomials \(h_{i}\).
This set \(\langle f_{1}, \ldots, f_{s} \rangle\) is actually an ideal, which you can show easily by testing out the three conditions.
In addition, if an ideal can be expressed in the form of \(\langle f_{1}, \ldots, f_{s} \rangle\), we say this ideal is <b><b>finitely generated</b></b>,
and that the set \(f_{1}, \dots, f_{s}\) is a <b><b>basis</b></b> of ideal.
</p>

<p>
It turns out that every ideal of \(k\left[ x_{1}, \ldots, x_{n} \right]\) is finitely generated:
</p>
<p>
<b><b>Theorem 1 (Hilbert Basis Theorem):</b></b> Every ideal \(I \subseteq k\left[ x_{1}, \ldots, x_{n} \right]\) has a finite generating set \(g_{1}, \ldots, g_{t} \in I\) such that \(I = \langle g_{1}, \ldots, g_{t} \rangle\).
</p>
<p>
The proof of Theorem <a href="#orge4b0695">1</a> requires the usage of the division algorithm, which will complicate the narrative quite a bit.
Interested readers can refer to Section 5, Chapter 2 of <sup><a id="fnr.3.100" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<p>
Ideals relate closely to systems of polynomial equations. Consider the system
</p><p>
\begin{align}
f_{1} = f_{2} = \ldots = f_{s} = 0.
\end{align}
</p><p>
It’s easy to see that
</p><p>
\begin{align}
h_{1} f_{1} + h_{2} f_{2} + \ldots + h_{s} f_{s} = 0
\end{align}
</p><p>
for polynomials \(h_{i}\). And by definition, \(h_{1} f_{1} + h_{2} f_{2} + \ldots + h_{s} f_{s}\) is a member of the ideal \(\langle f_{1}, \ldots, f_{s} \rangle\).
Naturally, We can define the affine variety induced by an ideal \(I\) as:
</p><p>
\begin{align}
\mathbf{V}(I)=\left\{\left(a_1, \ldots, a_n\right) \in k^n \mid f\left(a_1, \ldots, a_n\right)=0 \text { for all } f \in I\right\}
\end{align}

</p><p>
A crucial fact that hints the relationship between ideals and solutions to polynomials (varieties) is that
a variety only depends on the ideal generated by the system of polynomial equations.
In particular, if \(f_{1}, \ldots, f_{s}\) and \(g_{1}, \ldots, g_{t}\) are bases of the same ideal, then \(\mathbb{V}(f_{1}, \ldots, f_{s}) = \mathbb{V}(g_{1}, \ldots, g_{t})\):
</p>
<p>
<b><b>Proposition 2:</b></b> If \(f_{1}, \ldots, f_{s}\) and \(g_{1}, \ldots, g_{t}\) are bases of the same ideal, so that \(\langle f_{1}, \ldots, f_{s} \rangle = \langle g_{1}, \ldots, g_{t} \rangle\), then we have \(\mathbf{V} (f_{1}, \ldots, f_{s}) = \mathbf{V} (g_{1}, \ldots, g_{t})\).
</p>

<p>
Here I provide a proof sketch for <a href="#org916f730">Proposition 2</a>.
Given a polynomial \(p \in \langle f_{1}, \ldots, f_{s} \rangle = \langle g_{1}, \ldots, g_{t} \rangle\),  for any \((a_{1}, \ldots, a_{n}) \in \mathbf{V}(f_{1}, \ldots, f_{s})\), \(p(a_{1}, \ldots, a_{n})=0\) by definition.
Because \(p(a_{1}, \ldots, a_{n})\) is also in \(\langle g_{1}, \ldots, g_{t} \rangle\), it can be expressed as linear combinations of products of \(g_{i}\) and some polynomials.
and it follows that \(g_{i}(a_{1}, \ldots, a_{n}) = 0\). Hence \(\mathbf{V}(f_{1}, \ldots, f_{s}) \subset \mathbf{V}(g_{1}, \ldots, g_{t})\). The reverse can also be shown following similar logic.
</p>

<p>
<a href="#org916f730">Proposition 2</a> allows us to switch the basis without affecting ideals, which is important for solving a polynomial system as we want to use a basis that simplifies the process.
</p>

<p>
A stronger version of <a href="#org916f730">Proposition 2</a> can be obtained based on the <a href="#orge4b0695">Hilbert Basis Theorem</a>:
</p>
<p>
<b><b>Proposition 3:</b></b> \(\mathbf{V}\) is an affine variety. In particular, if \(I = \langle f_{1}, \ldots, f_{s} \rangle\), then \(\mathbf{V}(I) = \mathbf{V}(f_{1}, \ldots, f_{s})\).
</p>
<p>
To prove this, we need to show \(\mathbf{V}(I) \subseteq \mathbf{V}(f_{1}, \ldots, f_{s})\) and \(\mathbf{V}(f_{1}, \ldots, f_{s}) \subseteq \mathbf{V}(I)\).
To show the former, note that for any \((a_{1}, \ldots, a_{n}) \in \mathbf{V}(I)\), \(f(a_{1}, \ldots, a_{n}) = 0\) for all \(f \in I\).
Hence \(f_{i}(a_{1}, \ldots, a_{n}) = 0\) because \(f_{i}\) is in \(I\).
To show the latter, let \((a_{1}, \ldots, a_{n}) \in \mathbf{V} (f_{1}, \ldots, f_{s})\). For \(f \in I\), \(f\) can be written as \(\sum_{i=1}^{s} h_{i} f_{i}\) for some \(h_i\).
It follows that
</p><p>
\begin{align}
f(a_{1}, \ldots, a_{n}) &amp;= \sum_{i=1}^{s} h_{i} (a_{1}, \ldots, a_{n}) f_{i}(a_{1}, \ldots, a_{n}) \\
 &amp;= \sum_{i=1}^{s} h_{i} (a_{1}, \ldots, a_{n}) 0 \\
 &amp;= 0
\end{align}
</p><p>
Hence \(\mathbf{V}(f_{1}, \ldots, f_{s}) \subseteq \mathbf{V}(I)\).
</p>

<p>
<a href="#org777032e">Proposition 3</a> allows us to go from varieties of polynomials to varieties of ideals (and vice versa), which is important for the purpose of understanding and solving system of polynomial equations.
Consider again the system of equations we discussed at the beginning.
</p><p>
\begin{align}
x^{2} + y + z = 1, \\
x + y^{2} + z = 1, \\
x + y + z^{2} = 1.
\end{align}
</p><p>
To find the solution set to these polynomials, we are looking for \(\mathbf{V}(x^{2} + y + z, x + y^{2} + z, x + y + z^{2})\).
<a href="#org916f730">Proposition 3</a> tells us that \(\mathbf{V}(x^{2} + y + z, x + y^{2} + z, x + y + z^{2}) = \mathbf{V}(I)\), where
\(I = \langle x^{2} + y + z, x + y^{2} + z, x + y + z^{2} \rangle\).
It may seem a bit counterintuitive that we need to use an ideal, a seemingly more complex concept, to solve the original system of polynomial equations.
However, the reason behind this, as we shall see later,
is to find another basis called the Gröbner basis such that we can more easily solve to recover the solutions to the original system.
After we have the Gröbner basis and find its variety (which is easy to do), we can apply <a href="#org916f730">Proposition 3</a>
again twice to go back to the variety of the ideal and the variety of the original polynomial system.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc90054e">
<h2 id="orgc90054e">Gröbner Bases</h2>
<div id="text-orgc90054e">
<p>
Gröbner bases, introduced by <a href="https://en.wikipedia.org/wiki/Bruno_Buchberger">B. Buchberger</a>, are the tools we need. In <i>A Theoretical Basis For the Reduction Of Polynomials To Canonical Forms</i> (1976)<sup><a id="fnr.5" href="#fn.5" role="doc-backlink">5</a></sup>, Buchberger says the following regarding Gröbner bases:
</p>
<blockquote>
<p>
Our algorithm proceeds by constructing a new basis for a given ideal from which the answer to the computability and decidability problems may be easily read off.
</p>
</blockquote>
<p>
We now discuss the Gröbner bases in brief (answering <a href="#org5e8854b">Question 2</a>), and learn how they connect to solving systems of polynomial equations.
</p>

<p>
The definition of Gröbner bases is the following:
given a monomial order for a polynomial ring \(k[x_{1}, \ldots, x_{n}]\), a finite non-zero subset \(G\) of the ideal \(I \subseteq k[x_{1}, \ldots, x_{n}]\) is a Gröbner basis if
</p><p>
\begin{align}
\langle \text{LT}(g_{1}), \ldots, \text{LT}(g_{t}) \rangle = \langle \text{LT}(I) \rangle
\end{align}
</p><p>
where \(\text{LT}(I)\) is the set of leading terms of nonzero elements in \(I\) and defined as
</p><p>
\begin{align}
\text{LT}(I)=\left\{c x^\alpha \mid \text { there exists } f \in I \backslash\{0\} \text { with } \text{LT}(f)=c x^\alpha\right\}
\end{align}

</p><p>
To check whether a set is a Gröbner basis, one way is to see whether the definition above holds.
Consider the ideal \(J = \langle x+z, y-z \rangle\) with bases \(x+z\) and \(y-z\).
We claim that \(x+z\) and \(y-z\) constitute a Gröbner basis using lex order.
Then \(\langle \text{LT}(x+z), \text{LT}(y-z) \rangle = \langle x, y \rangle\).
</p>

<p>
We now need to show leading terms of all nonzero elements of \(\langle x+z, y-z \rangle\) lie within \(\langle x, y \rangle\), which is equivalent to showing they are all divisible by either \(x\) or \(y\).
We can prove this by contradiction. Assume we have an \(f = A(x+z) + B(y-z) \in J\), and that \(f\) is nonzero and \(\text{LT}(f)\) is divisible by neither \(x\) nor \(y\).
Hence \(f\) is a polynomial in \(z\) only.
Since \(f \in J\), \(f\) is zero on all points in \(\mathbf{V}(x+z, y-z)\).
Note that \((-t, t, t)\) is in \(\mathbf{V}(x+z, y-z)\), and \(f\), a polynomial in \(z\) alone, has to be the zero polynomial, which is a contradiction.
Hence \(x+z\) and \(y-z\) form a Gröbner basis for \(J\).
</p>

<p>
The “proper” and more mechanical way to check whether a set of polynomials is a Gröbner basis (which also forms the basis of the algorithm to construct Gröbner basis) is to use the so-called Buchberger’s Criterion:
</p>
<p>
<b><b>Theorem 4 (Buchberger’s Criterion):</b></b> Let I be a polynomial ideal. Then a basis \(G = \{ g_{1}, \ldots, g_{t} \}\) of \(I\) is a Gröbner basis of \(I\) if and only if for all pairs \(i \neq j\), the remainder on division of \(S(g_{i} , g_{j})\) by \(G\) (listed in some order) is zero.
</p>

<p>
There are two concepts in this definition that we haven’t discussed yet.
The first one is the division of a polynomial by \(G\).
The actual algorithm<sup><a id="fnr.3.100" href="#fn.3" role="doc-backlink">3</a></sup> matters less in this case; we only need to know that
there exists an algorithm that can rewritten a polynomial \(f\) in \(k[x_{1}, \ldots, x_{n}]\) as
</p><p>
\begin{align}
q_{1} g_{1} + \cdots + q_{s} g_{s} + r
\end{align}
</p><p>
where \((g_{1}, \ldots, g_{s})\) is an ordered set of polynomials, \(q_i \in k[x_{1}, \ldots, x_{n}]\), and either \(r = 0\)
or \(r\) is a polynomial which has no monomial that is divisible by any of \(\text{LT}(g_{1}), \ldots, \text{LT}(g_{s})\).
</p>

<p>
\(S(f, g)\) refers to <b><b>S-polynomials</b></b>, which is defined as
</p><p>
\begin{align}
S(f, g)=\frac{x^\gamma}{\text{LT}(f)} \cdot f-\frac{x^\gamma}{\operatorname{LT}(g)} \cdot g
\end{align}
</p><p>
where \(x^{\gamma}\) is the least common multiple of \(\text{LM}(f)\) and \(\text{LM}(g)\) (a monomial with power of each variable equal to the largest power of the corresponding variable in \(\text{LM}(f)\) and \(\text{LM}(g)\)).
We can define <code>s_poly(f, g)</code> using SymPy to calculate S-polynomials:
</p>
<div>
<pre><span>import</span> sympy <span>as</span> sp

<span>def</span> <span>s_poly</span>(f, g, <span>*</span>gens):
    <span>&#34;&#34;&#34;Calculate the S-polynomial for f and g.</span>
<span>    Note that this uses the default lex order.</span>
<span>    &#34;&#34;&#34;</span>
    <span>lcm</span> <span>=</span> sp.lcm(sp.LM(f, <span>*</span>gens), sp.LM(g, <span>*</span>gens))
    <span>s</span> <span>=</span> sp.simplify(lcm <span>*</span> (f <span>/</span> sp.LT(f, <span>*</span>gens) <span>-</span> g <span>/</span> sp.LT(g, <span>*</span>gens)))
    <span>return</span> s
</pre>
</div>

<p>
The definition of S-polynomials may seem arbitrary.
One intuition behind it is that S-polynomials cancel out the leading terms.
Take \(\{ xy + 2x - z, x^{2} + 2y - z\}\) as an example.
In this case, \(x^{\gamma} = x^{2} y\), and we have
</p><p>
\begin{align}
S( xy + 2x - z, x^{2} + 2y - z ) &amp;= \frac{x^{2} y }{ xy } * (xy + 2x - z) + \frac{x^{2} y}{x^{2}} * (x^{2} + 2y - z) \\
&amp;=2x^{2} - xz - 2y^{2} + yz
\end{align}
</p><p>
Notice how the leading terms of \(xy + 2x - z\) and \(x^{2} + 2y - z\) got canceled out.
The precise way to describe such cancellation is that \(\text{multideg}(S(f, g)) \leq \gamma\) (where \(\gamma\) follows the definition in <a href="#orgd466580">Theorem 4</a>.)
</p>

<p>
Now we can test out the <a href="#orgd466580">Buchberger’s Criterion</a>.
Again use \(\{ xy + 2x - z, x^{2} + 2y - z\}\) as an example.
We have \(S( xy + 2x - z, x^{2} + 2y - z ) = 2x^{2} - xz - 2y^{2} + yz\).
We can then check the remainder of \(2x^{2} - xz - 2y^{2} + yz\) with division by \(\{ xy + 2x - z, x^{2} + 2y - z \}\), which is \(-x*z - 2*y**2 + y*z - 4*y + 2*z\), hence the two polynomials do not form a Gröbner basis.
</p>

<p>
Buchberger’s Criterion leads nicely to the algorithm that we can use to actually construct Gröbner bases.
Given a list of polynomials \(f_{1}, \ldots, f_{s}\) and let \(I = \langle f_{1}, \ldots, f_{s} \rangle\),
the Buchberger’s Algorithm constructs a Gröbner basis \(G = (g_{1}, \ldots, g_{t})\) for \(I\).
Below is a crude implementation in Python.
</p>
<div>
<pre><span>import</span> copy
<span>import</span> itertools

<span>def</span> <span>buchberger</span>(F, <span>*</span>gens):
    <span>&#34;&#34;&#34;Buchberger&#39;s Algorithm</span>
<span>    Note that this is slightly different from the pesudocode</span>
<span>    provided in Cox et. al. 2015.</span>
<span>    &#34;&#34;&#34;</span>
    <span>G</span> <span>=</span> copy.deepcopy(F)
    <span>pqs</span> <span>=</span> <span>set</span>(itertools.combinations(G, <span>2</span>))
    <span>while</span> pqs:
        <span>p</span>, <span>q</span> <span>=</span> pqs.pop()
        <span>s</span> <span>=</span> s_poly(p, q, <span>*</span>gens)
        <span>_</span>, <span>h</span> <span>=</span> sp.reduced(s, G, <span>*</span>gens)
        <span>if</span> h <span>!=</span> <span>0</span>:
            <span>for</span> g <span>in</span> G:
                pqs.add((g, h))
            G.append(h)
    <span>return</span> G
</pre>
</div>

<p>
The <code>s_poly</code> function is used to generate S-polynomials.
Intuitively, we are extending the original basis repeatedly with the nonzero remainders.
For a complete proof of this algorithm, please refer to Chapter 2 of <i>Ideals, Varieties, and Algorithms</i> <sup><a id="fnr.3.100" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<p>
We can check this implementation against Sympy:
</p>
<div>
<pre><span>f1</span> <span>=</span> x<span>**</span><span>3</span> <span>-</span> <span>2</span><span>*</span>x<span>*</span>y
<span>f2</span> <span>=</span> x<span>**</span><span>2</span><span>*</span>y <span>-</span> <span>2</span><span>*</span>y<span>**</span><span>2</span> <span>+</span>x
<span>G</span> <span>=</span> [f1, f2]

<span>S</span> <span>=</span> s_poly(f1, f2)
<span>print</span>(f<span>&#34;S Poly: = </span>{S}<span>&#34;</span>)

<span>a</span>, <span>r</span> <span>=</span> sp.reduced(s, G)
<span>print</span>(f<span>&#34;Remainder: </span>{r}<span>&#34;</span>)


<span>G_basis</span> <span>=</span> buchberger(G)
<span>print</span>(f<span>&#34;Groebner basis: </span>{G_basis}<span>&#34;</span>)

<span>G_basis_sympy</span> <span>=</span> sp.groebner(G, x, y, z, order<span>=</span><span>&#39;lex&#39;</span>)
<span>print</span>(f<span>&#34;Groebner basis (SymPy): </span>{G_basis_sympy}<span>&#34;</span>)
</pre>
</div>

<p>
Running this we will see something like this:
</p>
<pre>S Poly: = x**3*y*(-(x**2*y + x - 2*y**2)/(x**2*y) + (x**3 - 2*x*y)/x**3)
Remainder: -x**2
Groebner&#39;s basis:
[x**3 - 2*x*y,
 x**2*y + x - 2*y**2,
 -x**2,
 x - 2*y**2,
 -4*y**3]
Groebner&#39;s basis (SymPy):
GroebnerBasis(
[x - 2*y**2,
 y**3], x, y, z, domain=&#39;ZZ&#39;, order=&#39;lex&#39;)
</pre>

<p>
It seems like the basis returned by SymPy is a subset of our basis (with a factor of \(-4\) in front of \(y^3\)).
It turns out that the <code>groebner(G)</code> function in SymPy is implemented so that it returns the <b><b>reduced</b></b> Gröbner basis,
whereas our implementation only returns one Gröbner basis.
For a nonzero polynomial ideal, the reduced Gröbner basis is unique, but there might be infinitely many Gröbner bases.
We define reduced Gröbner bases as the following:
</p>
<p>
<b><b>Definition 5 (Reduced Gröbner Basis):</b></b> A Gröbner basis \(G\) for ideal \(I\) is a reduced Gröbner basis if
(1) \(\text{LC} = 1\) for all \(p \in G\), and
(2) for all \(p \in G\), no monomial of \(p\) lies in \(\langle \text{LT}(G \ \{p\}) \rangle\).
</p>

<p>
A common way to obtain a reduced Gröbner basis is to (1) obtain a minimal basis by ensuring leading monomials of the elements do not divide each other and (2) replace each element in the basis with the remainder of its reduction by other elements in the basis,
and then divide each element by the coefficient of its leading term.
One may also define the reduced Gröbner basis without the condition on its leading coefficient, and the uniqueness of the basis is therefore up to a multiplicative factor.
Here’s the final function that we can use to compute a reduced Gröbner basis:
</p>
<div>
<pre><span>def</span> <span>groebner</span>(F, <span>*</span>gens):
    <span>&#34;&#34;&#34;Calculate a reduced Groebner basis for F.</span>
<span>    Use the default lex order.</span>
<span>    &#34;&#34;&#34;</span>
    <span>F_polys</span>, <span>opt</span> <span>=</span> sp.parallel_poly_from_expr(F, <span>*</span>gens)
    <span>domain</span> <span>=</span> sp.EX
    <span>ring</span> <span>=</span> sp.polys.rings.PolyRing(gens, domain<span>=</span>domain)

    
    <span>G</span> <span>=</span> buchberger(F_polys, <span>*</span>gens)

    
    <span>temp</span> <span>=</span> copy.deepcopy(G)
    <span>G_minimal</span> <span>=</span> []
    <span>while</span> temp:
        <span>f0</span> <span>=</span> temp.pop()
        <span>if</span> <span>not</span> <span>any</span>(sp.polys.monomials.monomial_divides(f.LM(), f0.LM()) <span>for</span> f <span>in</span> temp <span>+</span> G_minimal):
            G_minimal.append(f0)

    
    <span>G_reduced</span> <span>=</span> []
    <span>for</span> i, g <span>in</span> <span>enumerate</span>(G_minimal):
        <span>_</span>, <span>remainder</span> <span>=</span> sp.reduced(g, G_reduced[:i] <span>+</span> G_minimal[i<span>+</span><span>1</span>:])
        <span>if</span> remainder <span>!=</span> <span>0</span>:
            G_reduced.append(remainder)

    
    
    <span>polys</span>, <span>opt</span> <span>=</span> sp.parallel_poly_from_expr(G_reduced, <span>*</span>gens)
    <span>polys</span> <span>=</span> [ring.from_dict(poly.rep.to_dict()) <span>for</span> poly <span>in</span> polys <span>if</span> poly]
    <span>G_reduced</span> <span>=</span> <span>sorted</span>(polys, key<span>=</span><span>lambda</span> f: f.LM, reverse<span>=</span><span>True</span>)
    <span>return</span> sp.parallel_poly_from_expr([x.monic().as_expr() <span>for</span> x <span>in</span> G_reduced], <span>*</span>gens)[<span>0</span>]
</pre>
</div>

<p>
Let’s test it out against our previous example.
</p>
<div>
<pre><span>G_basis_reduced</span> <span>=</span> groebner(G, x, y, z)
<span>print</span>(f<span>&#34;Reduced Groebner basis: </span>{G_basis_reduced}<span>&#34;</span>)
</pre>
</div>

<p>
You should see outputs similar to this:
</p>
<pre>Reduced Groebner basis: [Poly(x - 2*y**2, x, y, z, domain=&#39;ZZ&#39;),
                         Poly(y**3, x, y, z, domain=&#39;ZZ&#39;)]
</pre>

<p>
Now we have a reduced Gröbner basis!
Notice how there is an element in the basis that has only \(y\).
It turns out this property of Gröbner bases will pave the way for us to solve systems of polynomial equations.
</p>
</div>
</div>

<div id="outline-container-orgdd74baf">
<h2 id="orgdd74baf">Solving Polynomial Systems Through Elimination</h2>
<div id="text-orgdd74baf">
<p>
We are now ready to answer <a href="#orgca084be">Question 3</a>.
We have learned about Gröbner basis, and understands that a reduced Gröbner basis uniquely determines an ideal.
We have established that solutions of a polynomial system correspond to variety of the ideal generated by the system (<a href="#org777032e">Proposition 3</a>).
In this section, we discuss the <b><b>elimination property</b></b> of Gröbner basis, and use it to solve systems of polynomial equations.
</p>

<p>
Let’s go back to the original system at the <a href="#org5ff4440">beginning</a>,
</p><p>
\begin{align}
x^{2} + y + z = 1, \\
x + y^{2} + z = 1, \\
x + y + z^{2} = 1.
\end{align}
</p><p>
We can find its reduced Gröbner basis using the tools we have developed.
</p>
<div>
<pre><span>F</span> <span>=</span> [x<span>**</span><span>2</span> <span>+</span> y <span>+</span> z <span>-</span> <span>1</span>, x <span>+</span> y<span>**</span><span>2</span> <span>+</span> z <span>-</span> <span>1</span>, x <span>+</span> y <span>+</span> z<span>**</span><span>2</span> <span>-</span> <span>1</span>]
<span>G</span> <span>=</span> groebner(F, x, y, z)
<span>print</span>(f<span>&#34;Reduced Groebner basis: </span>{G}<span>&#34;</span>)
</pre>
</div>

<p>
You should see outputs like the ones listed below:
</p>
<pre>Reduced Groebner basis:
[Poly(x + y + z**2 - 1, x, y, z, domain=&#39;QQ&#39;),
 Poly(y**2 - y - z**2 + z, x, y, z, domain=&#39;QQ&#39;),
 Poly(y*z**2 + 1/2*z**4 - 1/2*z**2, x, y, z, domain=&#39;QQ&#39;),
 Poly(z**6 - 4*z**4 + 4*z**3 - z**2, x, y, z, domain=&#39;QQ&#39;)]
</pre>


<p>
The last element of the reduced Gröbner basis is \(z^{6} - z^{4} + 4z^{3} - 2z^{2} + 4z\), which is in \(z\) only.
In <a href="#org5ff4440">A Taste of Gröbner Bases</a>, we then proceed to solve for \(z\) and back substitute the value of \(z\) to solve for \(x\) and \(y\).
</p>

<p>
Roughly, we can divide this process into three steps:
</p>
<ol>
<li>Find the reduced Gröbner basis, locate the element that has only one variable and solve for that variable.</li>
<li>Substitute that variable into the rest of the basis.</li>
<li>Repeat the previous two steps with the new basis.</li>
</ol>

<p>
It turns out that this elimination of variables under lex order is a property of Gröbner bases.
This result is the so-called <b><b>Elimination Theorem</b></b>:
</p>
<p>
<b><b>Theorem 6 (The Elimination Theorem):</b></b> Let \(I \subseteq k\left[x_1, \ldots, x_n\right]\) be an ideal and let \(G\) be a Gröbner basis of \(I\) with respect to the lex order where \(x_{1} &gt; x_{2} &gt; \cdots &gt; x_{n}\). Then, for every \(0 \leq l \leq n\), the set \(G_l=G \cap k\left[x_{l+1}, \ldots, x_n\right]\) is a Gröbner basis of the l-th elimination ideal \(I_l\).
</p>
<p>
\(I_l\) is defined as \(I \cap k\left[x_{l+1}, \ldots, x_n\right]\).
The use of \(\cap k\left[x_{l+1}, \ldots, x_n\right]\) (intersection) may seem a bit confusing, but it is essentially a formal way to say that we have eliminated \(x_{1}, \ldots, x_{l}\).
This theorem essentially allows us to recursively eliminates variables one by one.
</p>

<p>
The final piece that we need is the <b><b>Extension Theorem</b></b>, which gives us a way to understand when can we successfully extend a partial solution to a full solution.
</p>
<p>
<b><b>Theorem 7 (The Extension Theorem):</b></b> Let \(I = \langle f_{1}, \ldots, f_{s} \rangle \subseteq \mathbb{C}\left[x_1, \ldots, x_n\right]\)
and let \(I_1\) be the first elimination ideal of \(I\).
For each \(1 \leq i \leq s\), write \(f_i\) in the form \(f_i = c_i (x_2, \ldots, x_n) x_1^{N_i}+\text{ terms in which } x_1 \text{ has degree } &lt; N_i\) where \(N_i &gt; 0\) and \(c_i \in \mathbb{C}\left[x_2, \ldots, x_n\right]\) is nonzero.
Suppose that we have a partial solution \(\left(a_2, \ldots, a_n\right) \in \mathbf{V}\left(I_1\right)\) .
If \(\left(a_2, \ldots, a_n\right) \notin \mathbf{V}\left(c_1, \ldots, c_s\right)\)
then there exists \(a_1 \in \mathbb{C}\) such that \(\left(a_1, a_2, \ldots, a_n\right) \in \mathbf{V}(I)\).
</p>
<p>
The part about \(\left(a_2, \ldots, a_n\right) \notin \mathbf{V}\left(c_1, \ldots, c_s\right)\) essentially states that
a partial solution can be extended if it does not cause the leading coefficients (\(c_{i}\)) go to zero.
Proofs for <a href="#org3982f4c">Theorem 6</a> and <a href="#orgac91fa6">Theorem 7</a> can be found in Chapter 3 of Cox et. al<sup><a id="fnr.3.100" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<p>
We are now ready to implement a solver for system of polynomials.
First, we define two helper functions (<code>is_univariate</code> and <code>subs_root</code>) that determines whether a polynomial is in one variable only, and substitute in a solution for a variable.
</p>
<div>
<pre><span>def</span> <span>is_univariate</span>(f):
    <span>&#34;&#34;&#34;Returns True if &#39;f&#39; is univariate in its last variable.</span>
<span>    Based on SymPy solve_generic</span>
<span>    SymPy License: https://github.com/sympy/sympy/blob/master/LICENSE</span>
<span>    &#34;&#34;&#34;</span>
    <span>for</span> monom <span>in</span> f.monoms():
        <span>if</span> <span>any</span>(monom[:<span>-</span><span>1</span>]):
            <span>return</span> <span>False</span>
    <span>return</span> <span>True</span>

<span>def</span> <span>subs_root</span>(f, gen, zero):
    <span>&#34;&#34;&#34; Substitute in a solution for a generator</span>
<span>    Based on SymPy solve_generic</span>
<span>    SymPy License: https://github.com/sympy/sympy/blob/master/LICENSE</span>
<span>    &#34;&#34;&#34;</span>
    <span>p</span> <span>=</span> f.as_expr({gen: zero})

    <span>if</span> f.degree(gen) <span>&gt;=</span> <span>2</span>:
        <span>p</span> <span>=</span> p.expand(deep<span>=</span><span>False</span>)

    <span>return</span> p
</pre>
</div>

<p>
Then we can implement the solver that recursively eliminates variable and extends solution.
</p>
<div>
<pre><span>def</span> <span>solve_poly_system_recursive</span>(F, gens, entry<span>=</span><span>False</span>):
    <span>&#34;&#34;&#34; Recursive helper function</span>
<span>    Based on SymPy solve_generic</span>
<span>    SymPy License: https://github.com/sympy/sympy/blob/master/LICENSE</span>
<span>    &#34;&#34;&#34;</span>
    <span>basis</span> <span>=</span> groebner(F, <span>*</span>gens)

    <span>if</span> <span>len</span>(basis) <span>==</span> <span>1</span> <span>and</span> basis[<span>0</span>].is_ground:
        <span>if</span> <span>not</span> entry:
            <span>return</span> []
        <span>else</span>:
            <span>return</span> <span>None</span>

    <span>if</span> <span>len</span>(basis) <span>&lt;</span> <span>len</span>(gens):
        <span>raise</span> <span>ValueError</span>(<span>&#34;System not zero-dimensional.&#34;</span>)

    <span>univar</span> <span>=</span> [x <span>for</span> x <span>in</span> basis <span>if</span> is_univariate(x)]

    <span>if</span> <span>len</span>(univar) <span>==</span> <span>1</span>:
        <span>f</span> <span>=</span> univar.pop()
    <span>else</span>:
        <span>raise</span> <span>ValueError</span>(<span>&#34;System not zero-dimensional.&#34;</span>)

    
    <span>gens</span> <span>=</span> f.gens
    <span>gen</span> <span>=</span> gens[<span>-</span><span>1</span>]

    <span>zeros</span> <span>=</span> <span>list</span>(sp.roots(f.ltrim(gen)).keys())

    <span>if</span> <span>not</span> zeros:
        
        <span>return</span> []

    
    <span>if</span> <span>len</span>(basis) <span>==</span> <span>1</span>:
        <span>return</span> [(zero,) <span>for</span> zero <span>in</span> zeros]

    
    <span>solutions</span> <span>=</span> []
    <span>for</span> zero <span>in</span> zeros:
        <span>new_system</span> <span>=</span> []
        <span>new_gens</span> <span>=</span> gens[:<span>-</span><span>1</span>]

        
        <span>for</span> b <span>in</span> basis[:<span>-</span><span>1</span>]:
            <span>eq</span> <span>=</span> subs_root(b, gen, zero)

            <span>if</span> eq <span>is</span> <span>not</span> sp.core.S.Zero:
                new_system.append(eq)

        <span>new_system</span> <span>=</span> sp.parallel_poly_from_expr(new_system, <span>*</span>new_gens)[<span>0</span>]
        <span>for</span> solution <span>in</span> solve_poly_system_recursive(new_system, new_gens):
            solutions.append(solution <span>+</span> (zero,))

    <span>if</span> solutions <span>and</span> <span>len</span>(solutions[<span>0</span>]) <span>!=</span> <span>len</span>(gens):
        <span>raise</span> <span>ValueError</span>(<span>&#34;System not zero-dimensional.&#34;</span>)

    <span>return</span> solutions


<span>def</span> <span>solve_poly_system</span>(F, <span>*</span>gens):
    <span>&#34;&#34;&#34; Solve a system of polynomials with Groebner basis</span>
<span>    Based on SymPy solve_generic</span>
<span>    SymPy License: https://github.com/sympy/sympy/blob/master/LICENSE</span>
<span>    &#34;&#34;&#34;</span>
    <span>result</span> <span>=</span> solve_poly_system_recursive(F, gens, entry<span>=</span><span>True</span>)
    <span>return</span> <span>sorted</span>(result , key<span>=</span>sp.default_sort_key)
</pre>
</div>

<p>
The few <code>ValueError(&#34;System not zero-dimensional.&#34;)</code> represent various edge cases where the system has potentially infinite number of solutions.
Please refer to Theorem 6, Chapter 5 of Cox et. al.<sup><a id="fnr.3.100" href="#fn.3" role="doc-backlink">3</a></sup> for more details.
</p>

<p>
Let’s check our implementation against the official SymPy one:
</p>
<div>
<pre><span>F</span> <span>=</span> [x<span>**</span><span>2</span> <span>+</span> y <span>+</span> z <span>-</span> <span>1</span>, x <span>+</span> y<span>**</span><span>2</span> <span>+</span> z <span>-</span> <span>1</span>, x <span>+</span> y <span>+</span> z<span>**</span><span>2</span> <span>-</span> <span>1</span>]
<span>F</span> <span>=</span> <span>list</span>(<span>map</span>(<span>lambda</span> x : sp.Poly(x), F))

<span>solution_sympy</span> <span>=</span> sp.solve_poly_system(F, x, y, z)
<span>print</span>(f<span>&#34;Poly Sols (SymPy): </span>{solution_sympy}<span>&#34;</span>)

<span>solution</span> <span>=</span> solve_poly_system(F, x, y, z)
<span>print</span>(f<span>&#34;Poly Sols: </span>{solution}<span>&#34;</span>)
</pre>
</div>

<p>
You should see outputs like these:
</p>
<pre>Poly Sols (SymPy): [(0, 0, 1),
(0, 1, 0), (1, 0, 0),
(-1 + sqrt(2), -1 + sqrt(2), -1 + sqrt(2)),
(-sqrt(2) - 1, -sqrt(2) - 1, -sqrt(2) - 1)]
Poly Sols: [(0, 0, 1),
(0, 1, 0), (1, 0, 0),
(-1 + sqrt(2), -1 + sqrt(2), -1 + sqrt(2)),
(-sqrt(2) - 1, -sqrt(2) - 1, -sqrt(2) - 1)]
</pre>

<p>
Looks like we have the correct solutions!
</p>
</div>
</div>

<div id="outline-container-org115347b">
<h2 id="org115347b">Conclusion and Other Resources</h2>
<div id="text-org115347b">
<p>
In this post, we have focused on using Gröbner bases to solve polynomial systems.
I hope you have learned something out of this long article.
</p>

<p>
Here are some additional resources if you want to dive deeper:
</p>
<ul>
<li>You can use techniques related to Gröbner bases to prove geometric theorems automatically. See Chapter 6 of Cox et. al<sup><a id="fnr.3.100" href="#fn.3" role="doc-backlink">3</a></sup>.</li>
<li>For a fast Gröbner basis library, you can use <a href="https://www-polsys.lip6.fr/~jcf/FGb/index.html">FGb</a>.</li>
<li>You can use <a href="https://github.com/sumiya11/Groebner.jl">Groebner.jl</a> for calculating Gröbner bases in Julia.</li>
<li>You can read about using reinforcement learning to select pairs of polynomials to compute S-polynomials in Buchberger’s algorithm <a href="https://arxiv.org/pdf/2005.01917.pdf">here</a>.</li>
<li>You can read about strategies for selecting bases to speed up minimal solvers for computer vision <a href="https://arxiv.org/pdf/1803.04360.pdf">here</a>.</li>
</ul>
</div>
</div>
</div></div>
  </body>
</html>
