<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chrissardegna.com/blog/reverse-engineering-apples-typedstream-format/">Original</a>
    <h1>Reverse Engineering Apple&#39;s typedstream Format</h1>
    
    <div id="readability-page-1" class="page">
    
    <time>Jan 31, 2025</time>
    <title>Inside imessage-exporter: Reverse Engineering Apple&#39;s typedstream Format</title>
    

    <details>
        <summary>Table of Contents</summary>

        
    </details>



<p><a href="https://github.com/ReagentX/imessage-exporter"><code>imessage-exporter</code></a>’s goal is to provide the most comprehensive representation of iMessage data available. Message data is stored in a <a href="https://developer.apple.com/documentation/foundation/nsarchiver">legacy</a> format that appears to be a stream that represents objects.</p>

<p>Originally, <code>imessage-exporter</code> used a <a href="https://github.com/ReagentX/imessage-exporter/blob/8ccf7321ab3a432fa6acea613571d359e0b284e4/imessage-database/src/util/streamtyped.rs#L11-L71">naive algorithm</a> to extract text data from this blob and inferred other context from the surrounding table data. However, as Apple introduced new iMessage features<sup><a href="#fn1-12689" id="fnr1-12689" title="see footnote">1</a></sup>, additional information was stored only in this blob.</p>

<p>Since <code>typedstream</code> contains critical message content, <code>imessage-exporter</code> must understand the format in a platform-agnostic way. This post explores the reverse engineering process, revealing the structure and logic behind this proprietary binary serialization protocol.</p>

<h2 id="identifying-the-message-storage-format">Identifying the Message Storage Format</h2>

<p>In the iMessage database, message body data is stored in a <code>BLOB</code> column called <code>attributedBody</code> that appears to describe an instance of a <a href="https://developer.apple.com/documentation/foundation/nsmutableattributedstring"><code>NSMutableAttributedString</code></a>.</p>

<p>If we save a blob into a file called <code>sample</code> and inspect it with the <code>file</code> program, it emits:</p>

<pre><code>❯ file sample
sample: NeXT/Apple typedstream data, little endian, version 4, system 1000
</code></pre>

<p>The system recognizes this blob, so let’s examine its contents.</p>

<h2 id="typedstream-origins"><code>typedstream</code> Origins</h2>

<p>The <code>typedstream</code> format is a binary serialization protocol designed for <code>C</code> and <code>Objective-C</code> data structures. It is primarily used by Apple’s <code>Foundation</code> framework, <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Archiving/Articles/archives.html#//apple_ref/doc/uid/20000946-BAJDBJAI">specifically</a> within their internal implementation of <code>NSArchiver</code> and <code>NSUnarchiver</code>. While those classes are the public APIs, <code>typedstream</code> is the underlying implementation detail.</p>

<p>The format itself is not part of the official <code>Foundation</code> specification, meaning other implementations use <a href="https://github.com/gnustep/libs-base/blob/master/Source/NSArchiver.m">different approaches</a>. This also means Apple’s <code>typedstream</code> remains largely undocumented: it was never intended to be a cross-platform standard, rather it is Apple’s internal solution for object serialization. In fact, archived documentation makes <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Archiving/Archiving.html#//apple_ref/doc/uid/10000047-SW1">no reference</a> to the <code>typedstream</code> format or its implementation.</p>



<p>An example of a simple iMessage <code>attributedBody</code> looks like:</p>

<pre><code>00000000  04 0b 73 74 72 65 61 6d  74 79 70 65 64 81 e8 03  |..streamtyped...|
00000010  84 01 40 84 84 84 19 4e  53 4d 75 74 61 62 6c 65  |<a href="https://chrissardegna.com/cdn-cgi/l/email-protection" data-cfemail="173939573939393959445a626376757b72">[email protected]</a>|
00000020  41 74 74 72 69 62 75 74  65 64 53 74 72 69 6e 67  |AttributedString|
00000030  00 84 84 12 4e 53 41 74  74 72 69 62 75 74 65 64  |....NSAttributed|
00000040  53 74 72 69 6e 67 00 84  84 08 4e 53 4f 62 6a 65  |String....NSObje|
00000050  63 74 00 85 92 84 84 84  0f 4e 53 4d 75 74 61 62  |ct.......NSMutab|
00000060  6c 65 53 74 72 69 6e 67  01 84 84 08 4e 53 53 74  |leString....NSSt|
00000070  72 69 6e 67 01 95 84 01  2b 0a 4e 6f 74 65 72 20  |ring....+.Noter |
00000080  74 65 73 74 86 84 02 69  49 01 0a 92 84 84 84 0c  |test...iI.......|
00000090  4e 53 44 69 63 74 69 6f  6e 61 72 79 00 95 84 01  |NSDictionary....|
000000a0  69 01 92 84 98 98 1d 5f  5f 6b 49 4d 4d 65 73 73  |i......__kIMMess|
000000b0  61 67 65 50 61 72 74 41  74 74 72 69 62 75 74 65  |agePartAttribute|
000000c0  4e 61 6d 65 86 92 84 84  84 08 4e 53 4e 75 6d 62  |Name......NSNumb|
000000d0  65 72 00 84 84 07 4e 53  56 61 6c 75 65 00 95 84  |er....NSValue...|
000000e0  01 2a 84 9b 9b 00 86 86  86                       |.*.......       |
</code></pre>

<p>After extracting several samples, we can start to infer some patterns from this data.</p>



<p>The first 16 bytes are always identical and appear to be some sort of header describing the data structure:</p>
<pre>00000000  <pk>04</pk> <yl>0b</yl> <gr>73 74 72 65 61 6d  74 79 70 65 64</gr> 81 <yl>e8 03</yl>  |<pk>.</pk><yl>.</yl><gr>streamtyped</gr>.<yl>..</yl>|
</pre>

<p>Breaking this down, we see 2 bytes <code>04 0b</code>, 11 bytes representing the text <code>streamtyped</code>, and 3 bytes <code>81 e8 03</code>. Interestingly, <code>0x0b</code> is 11, which suggests that it describes the length of the data that follows it, leaving us with two unknowns to investigate: the first <code>0x04</code>, and the final <code>81 e8 03</code>.</p>

<p>Let’s re-examine the output of the <code>file</code> command:</p>

<pre><code>NeXT/Apple typedstream data, little endian, version 4, system 1000
</code></pre>

<p>The first header byte, <code>0x04</code>, matches the version emitted by <code>file</code>, and the last two bytes <code>e8 03</code> form <code>1000</code> as <code>u16</code>, leaving <code>0x81</code> to solve for<sup><a href="#fn2-12689" id="fnr2-12689" title="see footnote">2</a></sup>.</p>

<h2 id="visible-patterns">Visible Patterns</h2>

<p>Each legible text segment in the <code>typedstream</code> is preceded by a byte sequence like <code>84 xx</code>, where <code>xx</code> varies depending on the data. Strings sometimes end in <code>0x00</code>, suggesting null-termination<sup><a href="#fn3-12689" id="fnr3-12689" title="see footnote">3</a></sup>. For example:</p>
<pre>00000010  <s>84 01 40 84 84</s> <pk>84</pk> <yl>19</yl> <gr>4e  53 4d 75 74 61 62 6c 65</gr>  |<s>..@..</s><pk>.</pk><yl>.</yl><gr>NSMutable</gr>|
00000020  <gr>41 74 74 72 69 62 75 74  65 64 53 74 72 69 6e 67</gr>  |<gr>AttributedString</gr>|
00000030  00 <s>84</s> <pk>84</pk> <yl>12</yl> <gr>4e 53 41 74  74 72 69 62 75 74 65 64</gr>  |.<s>.</s><pk>.</pk><yl>.</yl><gr>NSAttributed</gr>|
00000040  <gr>53 74 72 69 6e 67</gr> 00                              |<gr>String</gr>.         |
</pre>

<p>Before <code>NSMutableAttributedString</code>, we see <code>84 19</code>, where <code>0x19</code> is 25, the length of the string. Similarly, <code>NSAttributedString</code> is prepended by <code>84 12</code>, where again <code>0x12</code> matches the length of the data. </p>

<p>This pattern suggests that <code>0x84</code> signals the beginning of a new data block, and the subsequent byte represents how much data that block contains. Given these are class names, it appears to be some metadata block describing classes, but not the data that the classes contain.</p>

<h3 id="embedded-data">Embedded Data</h3>

<p>Objects contain more than just class names; they also have fields that contain data owned by the object. The first class name we encounter–<code>NSMutableAttributedString</code>–is documented by Apple, and includes a field that <a href="https://developer.apple.com/documentation/foundation/nsmutableattributedstring/1416955-mutablestring">contains</a> the string data.</p>

<p>Following the pattern we saw above, let’s find the first <code>0x84</code> before the message’s text:</p>

<pre><code>00000070                    84 01  2b 0a 4e 6f 74 65 72 20  |      ..+.Noter |
00000080  74 65 73 74 86                                    |test.           |
</code></pre>

<p><code>0x84</code> denotes some type of new data, but the next byte <code>0x01</code> suggests we only need to read one more byte of data: <code>0x2b</code>, which happens to be the char <code>+</code>. However, the subsequent byte <code>0a</code> matches the length of the message text: <code>&#34;Noter test &#34;</code><sup><a href="#fn4-12689" id="fnr4-12689" title="see footnote">4</a></sup>. The final byte, <code>0x86</code>, is also repeated at the very end of the stream, suggesting it may indicate the end of some data.</p>

<h3 id="another-pattern-emerges">Another Pattern Emerges</h3>

<p>Continuing from our prior assumptions, we see this short blob:</p>

<pre><code>00000080                 84 02 69  49 01 0A                 |     ..iI..     |
</code></pre>

<p>The <code>84 02</code> suggests we need to read two bytes, <code>0x69</code> and <code>0x49</code>, which happen to be <code>i</code> and <code>I</code>. Twice now the stream has a pattern where <code>0x84</code> seems to denote some data type, so let’s take a look at the <code>NSMutableAttributedString</code> <a href="https://developer.apple.com/documentation/foundation/nsmutableattributedstring">documentation</a> and see if there are any clues:</p>

<blockquote>
<p>The primitive <code>setAttributes(_:range:)</code> method sets attributes and values for a given range of characters, replacing any previous attributes and values for that range.</p>
</blockquote>

<p>Under the <a href="https://developer.apple.com/documentation/foundation/nsmutableattributedstring#1653959">changing attributes</a> section, many of the methods receive a parameter like <code>range: NSRange</code>. Per the <a href="https://developer.apple.com/documentation/foundation/nsrange">documentation</a>, <code>NSRange</code> encodes a <code>location</code> integer and a <code>length</code> integer.</p>

<p>The <code>i</code> in integer stands out now, because the new data <code>iI</code> in the stream seems to indicate that we are meant to read a pair of integers. The bytes <code>01 0A</code> follow, where <code>0A</code> matches the message length and <code>01</code> appears to represent the starting character index, suggesting this sequence defines an <code>NSRange</code> spanning the complete message.</p>

<p>The fields for these range objects aren&#39;t documented, indicating they&#39;re likely private class members. The <code>typedstream</code> format’s deterministic packing ensures <code>NSRange</code>s consistently store their <code>location</code> and <code>length</code> values in sequence, probably as different integer types.</p>

<h3 id="solving-the-mystery">Solving the <code>+</code> Mystery</h3>

<p>Let’s translate the stream of bytes into plain language given our current assumptions:</p>
<pre>00000080                 <pk>84</pk> <yl>02</yl> <gr>69  49</gr> <bl>01 0A</bl>                 |     <pk>.</pk><yl>.</yl><gr>iI</gr><bl>..</bl>     |
</pre>

<p>We can read this as “a new data type of two bytes, <code>iI</code>, followed by the packed field data of <code>1</code> and <code>10</code>”. The data appears to be stored as <code>u8</code> since it is only one byte, but that leaves an open question as to how the stream can store larger values<sup><a href="#fn5-12689" id="fnr5-12689" title="see footnote">5</a></sup>.</p>

<p>Ignoring that caveat for now, let’s apply that logic to the message text field:</p>
<pre>00000070                    <pk>84</pk> <yl>01</yl>  <gr>2b</gr> <yl>0a</yl> <gr>4e 6f 74 65 72 20</gr>  |      <pk>.</pk><yl>.</yl><gr>+</gr><yl>.</yl><gr>Noter </gr>|
00000080  <gr>74 65 73 74</gr> 86                                    |<gr>test</gr>.           |
</pre>

<p>We can read this as “new data type of 1 byte, <code>+</code>, followed by the field data for a string of <code>0x0a</code> length.”</p>

<p>There is one other instance of this pattern early on, right before the class names appear:</p>
<pre>00000010  <pk>84</pk> <yl>01</yl> <gr>40</gr> <s>84 84 84 19 4e  53 4d 75 74 61 62 6c 65</s>  |<pk>.</pk><yl>.</yl><gr>@</gr><s>....NSMutable</s>|
</pre>

<p>Since the data following this initial <code>0x84</code> appears to describe the class names, the 1 byte <code>0x40</code> (<code>@</code>) may indicate the start of a new object instance.</p>

<h2 id="assumptions-so-far">Assumptions so Far</h2>

<ul>
<li><code>0x84</code> indicates the start of some data blob</li>
<li><code>0x86</code> indicates the end of some data blob</li>
<li><code>0x81</code> indicates something that we don’t know yet</li>
<li>The byte following <code>0x84</code> denotes the length of the data blob</li>
<li>Sometimes, there are bytes that describe packed field data:

<ul>
<li><code>i</code> and <code>I</code> seem to indicate an integer value <code>u8</code></li>
<li><code>+</code> seems to indicate a string</li>
<li><code>@</code> seems to indicate a new object instance</li>
</ul></li>
<li>Class names are null-terminated</li>
<li>Class field data is packed in order at the end of the definition</li>
</ul>

<p>Given these assumptions, let us mark the bytes in the stream for which we can make a reasonable guess at their meaning:</p>
<pre>00000000  <s>04 0b 73 74 72 65 61 6d</s>  <s>74 79 70 65 64</s> 81 <s>e8 03</s>  |<s>..streamtyped</s>.<s>..</s>|
00000010  <s>84 01 40</s> 84 84 <s>84 19 4e</s>  <s>53 4d 75 74 61 62 6c 65</s>  |..@..<s>..NSMutable</s>|
00000020  <s>41 74 74 72 69 62 75 74</s>  <s>65 64 53 74 72 69 6e 67</s>  |<s>AttributedString</s>|
00000030  <s>00</s> 84 <s>84 12 4e 53 41 74</s>  <s>74 72 69 62 75 74 65 64</s>  |<s>.</s>.<s>..NSAttributed</s>|
00000040  <s>53 74 72 69 6e 67 00</s> 84  <s>84 08 4e 53 4f 62 6a 65</s>  |<s>String.</s>.<s>..NSObje</s>|
00000050  <s>63 74 00</s> 85 92 84 84 <s>84</s>  <s>0f 4e 53 4d 75 74 61 62</s>  |<s>ct.</s>....<s>..NSMutab</s>|
00000060  <s>6c 65 53 74 72 69 6e 67</s>  01 84 <s>84 08 4e 53 53 74</s>  |<s>leString</s>..<s>..NSSt</s>|
00000070  <s>72 69 6e 67</s> 01 95 <s>84 01</s>  <s>2b 0a 4e 6f 74 65 72 20</s>  |<s>ring</s>..<s>..+.Noter </s>|
00000080  <s>74 65 73 74 86 84 02 69</s>  <s>49 01 0a</s> 92 84 84 <s>84 0c</s>  |<s>test...iI..</s>...<s>..</s>|
00000090  <s>4e 53 44 69 63 74 69 6f</s>  <s>6e 61 72 79 00</s> 95 <s>84 01</s>  |<s>NSDictionary.</s>.<s>..</s>|
000000a0  <s>69 01</s> 92 84 98 98 <s>1d 5f</s>  <s>5f 6b 49 4d 4d 65 73 73</s>  |<s>i.</s>....<s>.__kIMMess</s>|
000000b0  <s>61 67 65 50 61 72 74 41</s>  <s>74 74 72 69 62 75 74 65</s>  |<s>agePartAttribute</s>|
000000c0  <s>4e 61 6d 65 86</s> 92 84 84  <s>84 08 4e 53 4e 75 6d 62</s>  |<s>Name.</s>...<s>..NSNumb</s>|
000000d0  <s>65 72 00</s> 84 <s>84 07 4e 53</s>  <s>56 61 6c 75 65 00</s> 95 <s>84</s>  |<s>er.</s>.<s>..NSValue.</s>.<s>.</s>|
000000e0  <s>01</s> 2a 84 9b 9b 00 86 86  <s>86</s>                       |<s>.*</s>......<s>.</s>       |
</pre>

<p>That’s a lot! Let’s focus in on these unknown sections.</p>

<h2 id="inheritance">Inheritance</h2>

<p>There are several places where multiple <code>0x84</code>s bytes appear together, possibly indicating a nested structure. Let’s isolate the first major block that appears to define the <code>NSMutableAttributedString</code>:</p>

<pre><code>00000010  84 01 40 84 84 84 19 4e  53 4d 75 74 61 62 6c 65  |<a href="https://chrissardegna.com/cdn-cgi/l/email-protection" data-cfemail="c6e8e886e8e8e8e888958bb3b2a7a4aaa3">[email protected]</a>|
00000020  41 74 74 72 69 62 75 74  65 64 53 74 72 69 6e 67  |AttributedString|
00000030  00 84 84 12 4e 53 41 74  74 72 69 62 75 74 65 64  |....NSAttributed|
00000040  53 74 72 69 6e 67 00 84  84 08 4e 53 4f 62 6a 65  |String....NSObje|
00000050  63 74 00 85 92 84 84 84  0f 4e 53 4d 75 74 61 62  |ct.......NSMutab|
00000060  6c 65 53 74 72 69 6e 67  01 84 84 08 4e 53 53 74  |leString....NSSt|
00000070  72 69 6e 67 01 95 84 01  2b 0a 4e 6f 74 65 72 20  |ring....+.Noter |
00000080  74 65 73 74 86                                    |test.           |
</code></pre>

<p>Operating under the assumption that the first 3 bytes tell us we are looking at a new object instance, we see 3 <code>0x84</code>s proceeding 3 strings that look like class names: <code>NSMutableAttributedString</code>, <code>NSAttributedString</code>, and <code>NSObject</code>. Continuing further, we see 3 more <code>0x84</code>s followed by 2 more class names, <code>NSMutableString</code> and <code>NSString</code>, and the interior string data.</p>

<p>These two blocks are separated by an <code>0x85</code>. Given we assume <code>0x84</code> is a start byte and <code>0x86</code> is an end byte, it is likely that <code>0x85</code> has some special meaning. Checking the <code>NSMutableAttributedString</code> <a href="https://developer.apple.com/documentation/foundation/nsmutableattributedstring">docs</a> again, we see that <code>NSMutableAttributedString</code> inherits from <code>NSAttributedString</code>, and its only field contains a <code>NSMutableString</code>, which <a href="https://developer.apple.com/documentation/foundation/nsmutablestring">inherits</a> from <code>NSString</code>.</p>

<p>We can infer that <code>0x85</code> serves as an end token, perhaps a terminator or something similar, as it seems to separate the class hierarchy from its field data. Let&#39;s add some color to denote the possible nested ranges of this block:</p>
<pre>00000010  <pk>84</pk> <yl>01</yl> <gr>40</gr> <pk>84 84 84</pk> <yl>19</yl> <gr>4e  53 4d 75 74 61 62 6c 65</gr>  |<pk>.</pk><yl>.</yl><gr>.</gr><pk>...</pk><yl>.</yl><gr>NSMutable</gr>|
00000020  <gr>41 74 74 72 69 62 75 74  65 64 53 74 72 69 6e 67</gr>  |<gr>AttributedString</gr>|
00000030  00 <pk>84 84</pk> <yl>12</yl> <gr>4e 53 41 74  74 72 69 62 75 74 65 64</gr>  |.<pk>..</pk><yl>.</yl><gr>NSAttributed</gr>|
00000040  <gr>53 74 72 69 6e 67</gr> 00 <pk>84  84</pk> <yl>08</yl> <gr>4e 53 4f 62 6a 65 </gr> |<gr>String</gr>.<pk>..</pk><yl>.</yl><gr>NSObje</gr>|
00000050  <gr>63 74</gr> 00 <u>85</u> 92 <pk>84 84 84</pk>  <yl>0f</yl> <gr>4e 53 4d 75 74 61 62</gr>  |<gr>ct</gr>...<pk>...</pk><yl>.</yl><gr>NSMutab</gr>|
00000060  <gr>6c 65 53 74 72 69 6e 67</gr>  01 <pk>84 84</pk> <yl>08</yl> <gr>4e 53 53 74</gr>  |<gr>leString</gr>.<pk>..</pk><yl>.</yl><gr>NSSt</gr>|
00000070  <gr>72 69 6e 67</gr> 01 95 <s>84 01  2b 0a 4e 6f 74 65 72 20</s>  |<gr>ring</gr>..<s>..+.Noter </s>|
00000080  <s>74 65 73 74</s> <pk>86</pk>                                    |<s>test</s><pk>.</pk>           |
</pre>

<h3 id="assembling-nested-data">Assembling Nested Data</h3>

<p>This leaves us with a few bits of missing data. Class names end with a single byte, here <code>0x01</code> or <code>0x00</code>. Previously, the assumption was that names were null terminated, but perhaps this is class data or some type of version number. Immediately after the <code>0x85</code>, there is a <code>0x92</code> that we are ignoring for now. Further, there is a <code>0x95</code> that seems to take the place of what should be a third part to the second class hierarchy:</p>

<pre><code>└── NSMutableAttributedString (v0)
    ├── Superclass Chain
    │   └── NSAttributedString (v0)
    │       └── NSObject (v0)
    │           └── 0x85
    │
    └── Fields
        └── NSMutableString (v1)
            ├── Superclass Chain
            │   └── NSString (v1)
            │       └── 0x95
            │
            └── Fields
                └── &#34;Noter test &#34;
</code></pre>

<p>We know that <code>NSString</code> <a href="https://developer.apple.com/documentation/foundation/nsstring?language=objc">extends</a> <code>NSObject</code>, so even though no bytes explicitly indicate this relationship, it must be represented somehow. But how can we confirm that?</p>

<h2 id="stumbling-across-the-type-cache">Stumbling Across the Type Cache</h2>

<p>The <code>0x92</code> and <code>0x95</code> must mean something. They are only 3 values apart, and they appear in places where we would expect something else to occur: The first time we saw <code>84 84 84</code>, it was prepended by <code>84 01 40</code> (<code>@</code>), which we are assuming represents the start of a new object instance. However, the second time we saw that same pattern, it was prepended by <code>0x92</code>. We also know that <code>NSString</code> <a href="https://developer.apple.com/documentation/foundation/nsstring">inherits</a> from <code>NSObject</code>, but instead the stream contains <code>0x95</code>.</p>

<p>There has to be a pattern here, so let’s look at the data every time we see a new <code>0x84</code> in the stream to see if we can discern anything. Beginning after the header and ending before the known encoded message content, we have the following:</p>

<table>
<colgroup>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Index</th>
	<th>Item</th>
</tr>
</thead>

<tbody>
<tr>
	<td>1</td>
	<td><code>@</code></td>
</tr>
<tr>
	<td>2</td>
	<td><code>NSMutableAttributedString</code></td>
</tr>
<tr>
	<td>3</td>
	<td><code>NSAttributedString</code></td>
</tr>
<tr>
	<td>4</td>
	<td><code>NSObject</code></td>
</tr>
<tr>
	<td>5</td>
	<td><code>NSMutableString</code></td>
</tr>
<tr>
	<td>6</td>
	<td><code>NSString</code></td>
</tr>
</tbody>
</table>

<h3 id="assembling-the-cache">Assembling the Cache</h3>

<p>Our intuition tells us that where we see <code>0x92</code>, we should be <code>84 01 40</code> (the start of a a new object), and where we see <code>0x95</code>, we should see the <code>NSObject</code> bytes. Just as <code>0x92</code> and <code>0x95</code> are 3 values apart, so are <code>@</code> and <code>NSObject</code> in the order of streamed data. Could these bytes represent an index?</p>

<p>If we assume that <code>0x92</code> is the first index, we get the following:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Index</th>
	<th>Predicted Offset</th>
	<th>Item</th>
</tr>
</thead>

<tbody>
<tr>
	<td>1</td>
	<td><code>0x92</code></td>
	<td><code>@</code></td>
</tr>
<tr>
	<td>2</td>
	<td><code>0x93</code></td>
	<td><code>NSMutableAttributedString</code></td>
</tr>
<tr>
	<td>3</td>
	<td><code>0x94</code></td>
	<td><code>NSAttributedString</code></td>
</tr>
<tr>
	<td>4</td>
	<td><code>0x95</code></td>
	<td><code>NSObject</code></td>
</tr>
<tr>
	<td>5</td>
	<td><code>0x96</code></td>
	<td><code>NSMutableString</code></td>
</tr>
<tr>
	<td>6</td>
	<td><code>0x97</code></td>
	<td><code>NSString</code></td>
</tr>
</tbody>
</table>

<p>The indexes <code>0x92</code> and <code>0x95</code> appear to point to our missing data! Let’s reassemble our object with this in mind:</p>

<pre><code>└── NSMutableAttributedString (v0)
    ├── Superclass Chain
    │   └── NSAttributedString (v0)
    │       └── NSObject (v0)
    │           └── 0x85
    │
    └── Fields
        └── NSMutableString (v1)
            ├── Superclass Chain
            │   └── NSString (v1)
            │       └── NSObject (v0)
            │           └── 0x85
            │
            └── Fields
                └── &#34;Noter test &#34;
</code></pre>

<p>This indicates that <code>0x92</code> and larger values indicate the index in a cache of previously-seen data.</p>

<h2 id="updating-our-assumptions">Updating our Assumptions</h2>

<ul>
<li><code>0x84</code> indicates the start of a data blob

<ul>
<li>The byte following <code>0x84</code> denotes the length of the data blob</li>
</ul></li>
<li><code>0x85</code> indicates the end of a class inheritance chain</li>
<li><code>0x86</code> indicates the end of a data blob</li>
<li><code>0x81</code> indicates something that we don’t know yet, but seems to be related to integers</li>
<li>In order of appearance, new blobs are stored in a cache

<ul>
<li>The first index is <code>0x92</code>, and references are stored in the stream directly</li>
</ul></li>
<li>Sometimes, there are bytes that describe packed field data:

<ul>
<li><code>i</code> and <code>I</code> seem to indicate an integer value <code>u8</code></li>
<li><code>+</code> seems to indicate a string</li>
<li><code>@</code> seems to indicate a new object instance</li>
<li><code>*</code> seems to indicate some unknown data type</li>
</ul></li>
<li>Class names are followed by some <code>u8</code> version information</li>
<li>Class field data is packed in order at the end of the definition</li>
</ul>

<p>Apart from the header, these assumptions account for all remaining bytes in the stream. Let’s follow the logic, placing references where we expect them:</p>
<pre>00000000  <s>04 0b 73 74 72 65 61 6d  74 79 70 65 64 81 e8 03</s>  |<s>..streamtyped...</s>|
00000010  <pk>84 01 40</pk> <s>84 84 84 19 4e  53 4d 75 74 61 62 6c 65</s>  |<pk>..@</pk><s>....NSMutable</s>|
00000020  <s>41 74 74 72 69 62 75 74  65 64 53 74 72 69 6e 67</s>  |<s>AttributedString</s>|
00000030  <s>00 84 84 12 4e 53 41 74  74 72 69 62 75 74 65 64</s>  |<s>....NSAttributed</s>|
00000040  <s>53 74 72 69 6e 67 00 84 </s> <gr>84 08 4e 53 4f 62 6a 65</gr>  |<s>String..</s><gr>..NSObje</gr>|
00000050  <gr>63 74 00</gr> <s>85</s> <pk>92</pk> <s>84 84 84  0f 4e 53 4d 75 74 61 62 </s> |<gr>ct.</gr><s>.</s><pk>.</pk><s>....NSMutab</s>|
00000060  <s>6c 65 53 74 72 69 6e 67  01 84 84 08 4e 53 53 74</s>  |<s>leString....NSSt</s>|
00000070  <s>72 69 6e 67 01 95</s> <bl>84 01  2b</bl><s> 0a 4e 6f 74 65 72 20 </s> |<s>ring..</s><bl>..+</bl><s>.Noter</s> |
00000080  <s>74 65 73 74 86 84 02 69  49 01 0a</s> <pk>92</pk><s> 84 84 84 0c</s>  |<s>test...iI..</s><pk>.</pk><s>....</s>|
00000090  <s>4e 53 44 69 63 74 69 6f  6e 61 72 79 00</s> <gr>95</gr> <yl>84 01</yl>  |<s>NSDictionary..</s><yl>..</yl>|
000000a0  <yl>69</yl> <s>01</s> <pk>92</pk> <s>84</s> <bl>98 98</bl> <s>1d 5f  5f 6b 49 4d 4d 65 73 73</s>  |<yl>i</yl><s>.</s><pk>.</pk><s>.</s><bl>..</bl><s>.__kIMMess</s>|
000000b0  <s>61 67 65 50 61 72 74 41  74 74 72 69 62 75 74 65</s>  |<s>agePartAttribute</s>|
000000c0  <s>4e 61 6d 65 86</s> <pk>92</pk> <s>84 84  84 08 4e 53 4e 75 6d 62</s>  |<s>Name.</s><pk>.</pk><s>....NSNumb</s>|
000000d0  <s>65 72 00 84 84 07 4e 53  56 61 6c 75 65 00 95 84</s>  |<s>er....NSValue...</s>|
000000e0  <s>01 2a 84</s> <yl>9b 9b</yl> <s>00 86 86  86</s>                       |<s>.*.</s><yl>..</yl><s>....</s>       |
</pre>

<p>In this structure, the referenced data is:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Reference Index</th>
	<th>Description</th>
	<th>Symbol</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>0x92</code></td>
	<td>Type of data indicating a new object instance</td>
	<td><code>0x40</code> / <code>&#34;@&#34;</code></td>
</tr>
<tr>
	<td><code>0x95</code></td>
	<td><code>NSObject</code> class name</td>
	<td><code>&#34;NSObject&#34;</code></td>
</tr>
<tr>
	<td><code>0x98</code></td>
	<td>Type of data indicating a string</td>
	<td><code>0x2b</code> / <code>&#34;+&#34;</code></td>
</tr>
<tr>
	<td><code>0x9b</code></td>
	<td>Type of data indicating a single integer</td>
	<td><code>0x69</code> / <code>&#34;i&#34;</code></td>
</tr>
</tbody>
</table>

<p>This gets us a little further, but there are two curiosities that violate this pattern. In two places, we see <code>0x84</code> followed by two references, not just one: at <code>0xa4</code> we see <code>84 98 98</code>, and at <code>0xe3</code> we see <code>84 9b 9b</code>. Putting those aside, let’s try and assemble what we can from the stream<sup><a href="#fn6-12689" id="fnr6-12689" title="see footnote">6</a></sup>.</p>

<h3 id="defining-terms">Defining Terms</h3>

<p>Leveraging our assumptions, we can define a few concepts:</p>

<ol>
<li><strong>Type Tags</strong>: Bytes like <code>+</code>, <code>@</code>, and the like seem to define primitive types like integers and strings. Since these define data that is packed together, let’s think of them as a group like <code>Vec&lt;Type&gt;</code>.

<ul>
<li>For example, the earlier <code>iI</code> would be a type tag like <code>[Int, Int]</code>.</li>
<li>We can reference these type tags by index in order of appearance, so we can enclose that type tag as a larger vector like <code>Vec&lt;Vec&lt;Type&gt;&gt;</code>.</li>
</ul></li>
<li><strong>Indicators</strong>: Bytes like <code>0x81</code> and <code>0x84..0x86</code> seem to have specific meanings, indicating that we are meant to read the subsequent data in a specific way.</li>
<li><strong>Archivable Objects</strong>: As we read the stream, we find class inheritance hierarchies that pertain to specific object instances</li>
</ol>

<h3 id="testing-the-theory">Testing the Theory</h3>

<p>In order to validate that our logic works, let’s apply it to the initial sample stream up to <code>0xa4</code>, where our assumptions are violated. In order of appearance, the type tags thus far are:</p>

<table>
<colgroup>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Index</th>
	<th>Type Tag</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>0x92</code></td>
	<td><code>[@]</code></td>
</tr>
<tr>
	<td><code>0x93</code></td>
	<td><code>[String(&#34;NSMutableAttributedString&#34;)]</code></td>
</tr>
<tr>
	<td><code>0x94</code></td>
	<td><code>[String(&#34;NSAttributedString&#34;)]</code></td>
</tr>
<tr>
	<td><code>0x95</code></td>
	<td><code>[String(&#34;NSObject&#34;)]</code></td>
</tr>
<tr>
	<td><code>0x96</code></td>
	<td><code>[String(&#34;NSMutableString&#34;)]</code></td>
</tr>
<tr>
	<td><code>0x97</code></td>
	<td><code>[String(&#34;NSString&#34;)]</code></td>
</tr>
<tr>
	<td><code>0x98</code></td>
	<td><code>[+]</code></td>
</tr>
<tr>
	<td><code>0x99</code></td>
	<td><code>[i, I]</code></td>
</tr>
<tr>
	<td><code>0x9a</code></td>
	<td><code>[String(&#34;NSDictionary&#34;)]</code></td>
</tr>
<tr>
	<td><code>0x9b</code></td>
	<td><code>[i]</code></td>
</tr>
</tbody>
</table>

<p>And the archivable objects stored in the stream:</p>

<table>
<colgroup>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Order</th>
	<th>Data</th>
</tr>
</thead>

<tbody>
<tr>
	<td>1</td>
	<td>Top-level object container</td>
</tr>
<tr>
	<td>2</td>
	<td><code>Class { name: &#34;NSMutableAttributedString&#34;, version: 0, ... }</code></td>
</tr>
<tr>
	<td>3</td>
	<td><code>Class { name: &#34;NSAttributedString&#34;, version: 0, ... }</code></td>
</tr>
<tr>
	<td>4</td>
	<td><code>Class { name: &#34;NSObject&#34;, version: 0}</code></td>
</tr>
<tr>
	<td>5</td>
	<td><code>Object(Class { name: &#34;NSMutableString&#34;, version: 1, ... }, [String(&#34;Noter test&#34;)])</code></td>
</tr>
<tr>
	<td>6</td>
	<td><code>Class { name: &#34;NSMutableString&#34;, version: 1, ... }</code></td>
</tr>
<tr>
	<td>7</td>
	<td><code>Class { name: &#34;NSString&#34;, version: 1, ... }</code></td>
</tr>
<tr>
	<td>8</td>
	<td><code>Object(Class { name: &#34;NSDictionary&#34;, version: 0, ... }, [SignedInteger(1)])</code></td>
</tr>
<tr>
	<td>9</td>
	<td><code>Class { name: &#34;NSDictionary&#34;, version: 0, ... }</code></td>
</tr>
</tbody>
</table>

<h2 id="discovering-a-second-cache">Discovering a Second Cache</h2>

<p>One thing that stands out later in the stream are these bytes:</p>
<pre>000000a0  <s>69 01</s> <bl>92</bl> <pk>84</pk> <gr>98 98</gr> <s>1d 5f  5f 6b 49 4d 4d 65 73 73</s>  |<s>i.</s><bl>.</bl><pk>.</pk><gr>..</gr><s>.__kIMMess</s>|
</pre>

<p>Given our assumptions, we can read the first half of this slice:</p>

<ul>
<li><code>0x92</code> refers to <code>@</code> in the type tags table, indicating a new object</li>
<li><code>0x84</code> indicates we want to start a new blob of data</li>
</ul>

<p>The remaining two <code>0x98</code> are pointers, but to what? In the type tag table, <code>0x98</code> points to <code>+</code>, but it wouldn’t make sense to have two type tags referenced together, as a type tag can already have multiple types within it<sup><a href="#fn7-12689" id="fnr7-12689" title="see footnote">7</a></sup>.</p>

<h3 id="building-the-archivable-object-cache">Building the Archivable Object Cache</h3>

<p>So far, we have some readable object instances and some class hierarchies defined in inheritance order. One thing that stands out is that <code>0x98</code>, what we previously thought was a type tag reference, also aligns with an entry in the archivable objects table. If we instead number the output starting at <code>0x92</code>, we get:</p>

<table>
<colgroup>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Index</th>
	<th>Predicted Data</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>0x92</code></td>
	<td>Top-level object container</td>
</tr>
<tr>
	<td><code>0x93</code></td>
	<td><code>Class { name: &#34;NSMutableAttributedString&#34;, version: 0, ... }</code></td>
</tr>
<tr>
	<td><code>0x94</code></td>
	<td><code>Class { name: &#34;NSAttributedString&#34;, version: 0, ... }</code></td>
</tr>
<tr>
	<td><code>0x95</code></td>
	<td><code>Class { name: &#34;NSObject&#34;, version: 0}</code></td>
</tr>
<tr>
	<td><code>0x96</code></td>
	<td><code>Object(Class { name: &#34;NSMutableString&#34;, version: 1 }, [String(&#34;Noter test&#34;)])</code></td>
</tr>
<tr>
	<td><code>0x97</code></td>
	<td><code>Class { name: &#34;NSMutableString&#34;, version: 1, ... }</code></td>
</tr>
<tr>
	<td><code>0x98</code></td>
	<td><code>Class { name: &#34;NSString&#34;, version: 1, ... }</code></td>
</tr>
<tr>
	<td><code>0x99</code></td>
	<td><code>Object(Class { name: &#34;NSDictionary&#34;, version: 0, ... }, [SignedInteger(1)])</code></td>
</tr>
<tr>
	<td><code>0x9a</code></td>
	<td><code>Class { name: &#34;NSDictionary&#34;, version: 0, ... }</code></td>
</tr>
</tbody>
</table>

<p>This makes a lot more sense: the first <code>0x98</code> isn’t referencing the type tag <code>[+]</code>, rather it is referencing the <code>NSString</code> class at <code>0x98</code>. The subsequent <code>0x98</code>, then, denotes the data associated with that class instance. Further, our <code>0x95</code> from earlier is not simply referencing the string <code>&#34;NSObject&#34;</code>, rather it is referencing the specific <code>NSObject</code> class that contains <code>0x85</code> as its parent.</p>

<h3 id="using-the-archivable-object-cache">Using the Archivable Object Cache</h3>

<p>With this new assumption, we can now read the rest of the data in the slice:</p>

<ul>
<li><code>0x92</code> refers to <code>@</code> in the type tags table, indicating a new object</li>
<li><code>0x84</code> indicates we want to start a new blob of data</li>
<li><code>0x98</code> refers to the <code>NSString</code> class</li>
<li><code>0x98</code> refers to <code>+</code>, indicating we should read the next data as a string</li>
</ul>

<p>Thus, we can read this slice as “new <code>NSString</code> object, whose field data is encoded as <code>+</code>.”</p>

<p>This logic also follows the pattern we see with string length bytes. Just as with the text after the first <code>+</code>, the bytes after the referenced <code>+</code> start with a byte that tells us the length of the string (here, <code>0x1d</code>, or <code>29</code>):</p>
<pre>000000a0  <s>69 01</s> 92 <pk>84</pk> <bl>98 98</bl> <yl>1d</yl> <gr>5f  5f 6b 49 4d 4d 65 73 73</gr>  |<s>i.</s>.<pk>.</pk><bl>..</bl><yl>.</yl><gr>__kIMMess</gr>|
000000b0  <gr>61 67 65 50 61 72 74 41  74 74 72 69 62 75 74 65</gr>  |<gr>agePartAttribute</gr>|
000000c0  <gr>4e 61 6d 65</gr> 86 <s>92 84 84  84 08 4e 53 4e 75 6d 62</s>  |<gr>Name</gr>.<s>.....NSNumb</s>|
</pre>

<p>Let’s assemble this object:</p>

<pre><code>└── NSString (v1)
    ├── Superclass Chain
    │   └── NSObject (v0)
    │       └── 0x85
    │
    └── Fields
        └── &#34;__kIMMessagePartAttributeName&#34;
</code></pre>

<p>The class comes from the data referenced by <code>0x98</code> in the archivable objects table. The string <code>__kIMMessagePartAttributeName</code> is the data owned by this instance of <code>NSString</code>, encoded in the stream as <code>+</code>.</p>

<h2 id="putting-it-all-together">Putting it All Together</h2>

<p>Let’s isolate the last part of the stream that appears to define a <code>NSDictionary</code> object to see if our assumptions hold:</p>
<pre>00000080  <s>74 65 73 74 86 84 02 69  49 01 0a</s> <pk>92</pk> 84 84 84 0c  |<s>test...iI..</s><pk>.</pk>....|
00000090  4e 53 44 69 63 74 69 6f  6e 61 72 79 00 95 84 01  |NSDictionary....|
000000a0  69 01 <pk>92</pk> 84 98 98 1d 5f  5f 6b 49 4d 4d 65 73 73  |i.<pk>.</pk>....__kIMMess|
000000b0  61 67 65 50 61 72 74 41  74 74 72 69 62 75 74 65  |agePartAttribute|
000000c0  4e 61 6d 65 86 <pk>92</pk> 84 84  84 08 4e 53 4e 75 6d 62  |Name.<pk>.</pk>....NSNumb|
000000d0  65 72 00 84 84 07 4e 53  56 61 6c 75 65 00 95 84  |er....NSValue...|
000000e0  01 2a 84 9b 9b 00 86 86  86                       |.*.......       |
</pre>

<h3 id="translating-the-stream">Translating the Stream</h3>

<p>The three <code>0x92</code> bytes indicate that there should be three objects stored here. Given the provided class names, we can intuit that this slice probably stores a dictionary that looks like:</p>

<pre><code>{
    &#34;__kIMMessagePartAttributeName&#34;: NSNumber(?)
}
</code></pre>

<p>Let’s try and translate the stream manually.</p>

<h4 id="object-1">Object 1</h4>

<p>Here is the first new object definition: </p>
<pre>00000080  <s>74 65 73 74 86 84 02 69  49 01 0a</s> 92 <pk>84 84 84</pk> <yl>0c</yl>  |<s>test...iI...</s><pk>...</pk><yl>.</yl>|
00000090  <gr>4e 53 44 69 63 74 69 6f  6e 61 72 79</gr> 00 95 <pk>84</pk> <yl>01</yl>  |<gr>NSDictionary</gr><pk>.</pk>.<pk>.</pk><yl>.</yl>|
000000a0  <gr>69</gr> 01 <s>92 84 98 98 1d 5f  5f 6b 49 4d 4d 65 73 73</s>  |<gr>i</gr>.<s>.....__kIMMess</s>|
</pre>

<p>And here is how our assumptions apply to that slice:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Byte(s)</th>
	<th>Component</th>
	<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>0x84</code></td>
	<td>Blob Indicator</td>
	<td>Signals the start of a new data block</td>
</tr>
<tr>
	<td><code>0x0c</code></td>
	<td>Length Byte</td>
	<td>Indicates the next 12 bytes contain relevant data</td>
</tr>
<tr>
	<td><code>NSDictionary</code></td>
	<td>Class Name</td>
	<td>The 12 bytes encoding the class name</td>
</tr>
<tr>
	<td><code>0x00</code></td>
	<td>Version Tag</td>
	<td>Previously thought to be a null terminator</td>
</tr>
<tr>
	<td><code>0x95</code></td>
	<td>Class</td>
	<td>References <code>NSObject</code> in the archivable objects table</td>
</tr>
<tr>
	<td><code>0x84</code></td>
	<td>Blob Indicator</td>
	<td>Signals the start of a new data block</td>
</tr>
<tr>
	<td><code>0x01</code></td>
	<td>Length Byte</td>
	<td>Indicates the next byte contains relevant data</td>
</tr>
<tr>
	<td><code>0x69</code></td>
	<td>Type Tag</td>
	<td>Represents <code>i</code> (likely <code>u8</code>)</td>
</tr>
<tr>
	<td><code>0x01</code></td>
	<td>Dictionary Size</td>
	<td>Indicates a single key/value pair</td>
</tr>
</tbody>
</table>

<p>The final <code>0x01</code> may represent something else, but given we can look at the stream and see only a single key/value pair, for now let’s assume it represents the length field. Let’s visualize what we have so far:</p>

<pre><code>└── NSDictionary (v0)
    ├── Superclass Chain
    │   └── NSObject (v0)
    │       └── 0x85
    │
    └── Fields
        └── 0x01
</code></pre>

<h4 id="object-2">Object 2</h4>

<p>This is the <code>NSString</code> we parsed earlier:</p>

<pre><code>└── NSString (v1)
    ├── Superclass Chain
    │   └── NSObject (v0)
    │       └── 0x85
    │
    └── Fields
        └── String(&#34;__kIMMessagePartAttributeName&#34;)
</code></pre>

<p>Given its location in the stream and its prefix of <code>__k</code>, let’s assume this is the first key in the dictionary and add it to the overall object:</p>

<pre><code>└── NSDictionary (v0)
    ├── Superclass Chain
    │   └── NSObject (v0)
    │       └── 0x85
    │
    └── Fields
        ├── 0x01
        └── NSString (v1)
            ├── Superclass Chain
            │   └── NSObject (v0)
            │       └── 0x85
            │
            └── Fields:
                └── String(&#34;__kIMMessagePartAttributeName&#34;)
</code></pre>

<h4 id="object-3">Object 3</h4>

<p>Finally, let’s isolate the last slice of bytes we need to translate:</p>
<pre>000000c0  <s>4e 61 6d 65 86</s> 92 <s>84 84</s>  <pk>84</pk> <yl>08</yl> <gr>4e 53 4e 75 6d 62</gr>  |<s>Name....</s><pk>.</pk><yl>.</yl><gr>NSNumb</gr>|
000000d0  <gr>65 72</gr> 00 <s>84</s> <pk>84</pk> <yl>07</yl> <gr>4e 53  56 61 6c 75 65</gr> 00 95 <pk>84</pk>  |<gr>er</gr>.<s>.</s><pk>.</pk><yl>.</yl><gr>NSValue</gr>..<pk>.</pk>|
000000e0  <yl>01</yl> <gr>2a</gr> <u>84 9b 9b 00</u> 86 <s>86  86</s>                       |<yl>.</yl><gr>*</gr><u>....</u>.<s>..</s>       |
</pre>

<p>Most of this we have already seen: until address <code>0xdf</code>, the stream encodes the inheritance hierarchy for <code>NSNumber</code>:</p>

<pre><code>└── NSNumber (v0)
    ├── Superclass Chain
    │   └── NSValue (v0)
    │       └── NSObject (v0)
    │           └── 0x85
    │
    └── Fields
        └── ?
</code></pre>

<p>However, where we expect the field data, we see a byte pattern indicating a new type tag <code>*</code>. Checking the <code>NSNumber</code> <a href="https://developer.apple.com/documentation/foundation/nsnumber?language=objc#1776615">documentation</a>, we can start to chase these type tags down. The docs make an offhand mention of these tags:</p>

<blockquote>
<ol>
<li>Your implementation of <a href="https://developer.apple.com/documentation/foundation/nsvalue/1412365-objctype?language=objc"><code>objCType</code></a> must return one of “c”, “C”, “s”, “S”, “i”, “I”, “l”, “L”, “q”, “Q”, “f”, and “d”. This is required for the other methods of <code>NSNumber</code> to behave correctly.</li>
<li>Your subclass must override the accessor method that corresponds to the declared type—for example, if your implementation of <code>objCType</code> returns “i”, you must override <code>intValue</code>.</li>
</ol>
</blockquote>

<p>This confirms our prior hypothesis that <code>i</code> (and probably <code>I</code>) tell the stream that the following data is an integer! However, the documentation for <a href="https://developer.apple.com/documentation/foundation/nsvalue/1412365-objctype?language=objc"><code>objCType</code></a> doesn’t have much information about what these characters mean. <a href="https://kagi.com/search?q=site%3Aapple.com++%22%40encode%22&amp;r=us&amp;sh=niRuA-WBujycClDVm26K8g">Searching</a> for <code>site:apple.com  &#34;@encode&#34;</code>, we find <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html">this</a> archived documentation pointing to a book called <em>The Objective-C Programming Language</em>.</p>

<p>In that book, we land upon a <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">table</a> of enumerated type encodings. That table confirms that <code>i</code> and <code>I</code> do represent integers, signed and unsigned, respectively. It also tells us that this mystery <code>*</code> refers to “A character string <code>(char *)</code>”.</p>

<p>So far, we know that <code>NSNumber</code> extends <code>NSValue</code>, specifically dealing with numeric variants. We also know that <code>NSValue</code> uses <code>objCType</code> to represent the type it encapsulates internally. The <code>objCType</code> documentation states that it is:</p>

<blockquote>
<p>A <code>C</code> string containing the <code>Objective-C</code> type of the data contained in the value object.</p>
</blockquote>

<p>Thus, it seems like the data that follows <code>*</code> should be read as a type tag describing the data that follows. Let’s isolate just that block:</p>
<pre>000000d0  <s>65 72 00 84 84 07 4e 53  56 61 6c 75 65 00 95</s> <pk>84</pk>  |<s>er....NSValue..</s><pk>.</pk>|
000000e0  <yl>01</yl> <gr>2a</gr> <pk>84</pk> <bl>9b 9b</bl> 00 86 <s>86  86</s>                       |<yl>.</yl><gr>*</gr><bl>..</bl>...<s>..</s>       |
</pre>

<p>Translating this following our assumptions, we get the following result:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Byte(s)</th>
	<th>Component</th>
	<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>0x84</code></td>
	<td>Blob Indicator</td>
	<td>Signals the start of a new data block</td>
</tr>
<tr>
	<td><code>0x01</code></td>
	<td>Type Tag</td>
	<td><code>*</code></td>
</tr>
<tr>
	<td><code>0x84</code></td>
	<td>Blob Indicator</td>
	<td>Signals the start of a new data block</td>
</tr>
<tr>
	<td><code>0x9b</code></td>
	<td>Type Tag Reference</td>
	<td><code>i</code></td>
</tr>
<tr>
	<td><code>0x9b</code></td>
	<td>Type Tag Reference</td>
	<td><code>i</code></td>
</tr>
<tr>
	<td><code>0x00</code></td>
	<td>Signed Integer</td>
	<td><code>0</code></td>
</tr>
<tr>
	<td><code>0x86</code></td>
	<td>End of Object Indicator</td>
	<td>Signals the end of the new object</td>
</tr>
</tbody>
</table>

<p>This sequence represents an <code>NSNumber</code> object containing an integer value. Like other object instances in the stream, the object’s data follows its class definition. Here, the first <code>0x9b</code> represents the <code>objCType</code> of the <code>NSValue</code> instance. Because it is larger than <code>0x92</code>, we look it up in the type tags table. This means our <code>NSValue</code> represents the <code>objCType</code> of <code>i</code>, or a signed integer.</p>

<p>The second <code>0x9b</code> references a type tag in the type tags table, indicating that the next byte (<code>0x00</code>) should be read as a signed integer. Both of these values refer to the same type tag, <code>i</code>, but they use that type tag in different ways: the first one tells us what type of data the <code>NSValue</code> instance owns, and the second tells us how to read the next byte from the stream.</p>

<p>The object structure can be represented as:</p>

<pre><code>└── NSNumber (v0)
    ├── Superclass Chain
    │   └── NSValue (v0)
    │       └── NSObject (v0)
    │           └── 0x85
    │
    └── Fields
        └── SignedInteger(0x00)
</code></pre>

<h4 id="the-whole-dictionary">The Whole Dictionary</h4>

<p>Combining all of what we have translated, the resultant dictionary looks like this:</p>

<pre><code>└── NSDictionary (v0)
    ├── Superclass Chain
    │   └── NSObject (v0)
    │       └── 0x85
    │
    └── Fields
        ├── SignedInteger(0x01)
        ├── NSString (v1)
        │   ├── Superclass Chain
        │   │   └── NSObject (v0)
        │   │       └── 0x85
        │   │
        │   └── Fields:
        │       └── &#34;__kIMMessagePartAttributeName&#34;
        └── NSNumber (v0)
            ├── Superclass Chain
            │   └── NSValue (v0)
            │       └── NSObject (v0)
            │           └── 0x85
            │
            └── Fields
                └── SignedInteger(0x00)
</code></pre>

<p>This confirms that the stream encodes a dictionary with a single key-value pair, as expected.</p>

<h2 id="format-specification-summary">Format Specification Summary</h2>

<p>Through systematic analysis and validation of our assumptions against the data samples, we can now attempt to describe the <code>typedstream</code> specification’s core structure and behavior.</p>

<h3 id="updating-assumptions-again">Updating Assumptions Again</h3>

<p>First, let’s update our assumptions based on what we have learned:</p>

<ul>
<li>Type Tags

<ul>
<li>Primitive types in the stream are prefixed by a type tag or a reference to a type tag, as <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">defined</a> in the <em>Objective-C Runtime Programming Guide</em></li>
<li>As we find them, distinct type tags are cached in a table and referenced by index</li>
</ul></li>
<li>Indicators

<ul>
<li><code>0x84</code> indicates the start of a data blob

<ul>
<li>The byte following <code>0x84</code> denotes the length of the data blob</li>
<li>If the byte is <code>0x92</code> or larger, it indicates a reference to a type tag stored in the type tags table</li>
</ul></li>
<li><code>0x85</code> indicates the end of a class inheritance chain</li>
<li><code>0x86</code> indicates the end of a data blob</li>
<li><code>0x81</code> indicates something related to integers</li>
<li>There are probably more indicators, likely in the range <code>0x81..0x86</code></li>
</ul></li>
<li>Archivable Objects

<ul>
<li>In order of inheritance, new objects and classes are stored in a cache of archivable objects

<ul>
<li>Similar to type tags, the first index is <code>0x92</code>, and references are stored in the stream directly</li>
</ul></li>
<li>Class names are followed by some <code>u8</code> version information</li>
<li>Class field data is packed in order at the end of the definition</li>
</ul></li>
</ul>

<h4 id="discovering-more-indicators">Discovering more Indicators</h4>

<p>By collecting a large amount of <code>attributedBody</code> data, we can search for specific bytes. Since we predicted that indicators lie in the range <code>0x81..0x86</code>, let’s search for the missing bytes to see what we find.</p>

<h5 id="indicator-0x81">Indicator <code>0x81</code></h5>

<p>Aside from the header, this byte showed up in several very long iMessages<sup><a href="#fn8-12689" id="fnr8-12689" title="see footnote">8</a></sup>:</p>
<pre>00000070  <s>72 69 6e 67 01 95 84 01  2b</s> 81 <bl>37 09</bl> <s>53 65 64 20</s>  |<s>ring....+</s>.<bl>7.</bl><s>Sed</s> |
</pre>

<p>This sample contained a message with <code>2359</code> characters. The bytes following <code>0x81</code> are <code>0x37 0x09</code>, which represent that value as a 16-bit integer. This also matches our header, which we know ends with the bytes for <code>1000</code>, confirming that <code>0x81</code> indicates a 16-bit integer follows.</p>
<pre>00000000  <s>04 0b 73 74 72 65 61 6d  74 79 70 65 64</s> 81 <bl>e8 03</bl>  |<s>..streamtyped</s>.<bl>..</bl>|
</pre>

<h5 id="inferring-other-indicators">Inferring Other Indicators</h5>

<p><code>0x82</code> and <code>0x83</code> were not in any samples, but continuing from the pattern, we can infer that since <code>0x81</code> represents a 2-byte (<code>u16</code>/<code>i16</code>) integer, <code>0x82</code> and <code>0x83</code> also refer to different width numbers. Going back to the <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">table</a> defined in the <em>Objective-C Runtime Programming Guide</em>, we can use the type tags to infer the meaning of these indicators:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Type Tag</th>
	<th>Meaning</th>
	<th>Inferred Indicator Byte</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>i</code></td>
	<td>An <code>int</code></td>
	<td>None</td>
</tr>
<tr>
	<td><code>s</code></td>
	<td>A <code>short</code></td>
	<td><code>0x81</code></td>
</tr>
<tr>
	<td><code>l</code></td>
	<td>A <code>long``l</code> is treated as a 32-bit quantity on 64-bit programs.</td>
	<td><code>0x82</code></td>
</tr>
<tr>
	<td><code>q</code></td>
	<td>A <code>long long</code></td>
	<td><code>0x83</code></td>
</tr>
</tbody>
</table>

<p>The type tag determines whether the integer is signed or unsigned, while the presence and value of the indicator byte determines the integer’s width in the stream. We can use this to predict the byte representation we might see:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Byte Sequence</th>
	<th>Inferred Meaning</th>
	<th>Expected Result</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>0x69 0x00</code></td>
	<td>Integer, single byte width</td>
	<td><code>0</code> as <code>i8</code></td>
</tr>
<tr>
	<td><code>0x69 0x81 0x37 0x09</code></td>
	<td>Integer, two-byte width</td>
	<td><code>2359</code> as <code>i16</code></td>
</tr>
<tr>
	<td><code>0x49 0x81 0x37 0x09</code></td>
	<td>Unsigned Integer, two-byte width</td>
	<td><code>2359</code> as <code>u16</code></td>
</tr>
<tr>
	<td><code>0x49 0x81 0xe8 0x03</code></td>
	<td>Unsigned Integer, two-byte width</td>
	<td><code>1000</code> as <code>u16</code></td>
</tr>
</tbody>
</table>

<p>In order to confirm this, we would need more sample data that included values of these sizes.</p>

<h3 id="defining-format-rules">Defining Format Rules</h3>

<p>Given this information, we can write a simple set of steps as a baseline for reading this format:</p>

<ol>
<li>Validate the header</li>
<li><code>0x84</code> indicates we are creating a new piece of archivable data

<ul>
<li>If the subsequent byte is <code>0x92</code> or greater, we have a reference to a previously-seen object or class</li>
<li>If the subsequent byte less than <code>0x92</code>, it describes the length of the object or class data</li>
</ul></li>
<li>Objects are stored in the following order:

<ul>
<li>The class hierarchy, including inheritance</li>
<li>The field data owned by the class</li>
<li>Field names are not stored, but their data is always stored in the same order</li>
</ul></li>
<li>As we encounter new objects, add them to a table of archivable objects</li>
<li>As we encounter new type tags, add them to a table of type tags</li>
</ol>



<p>Now that we understand how to read a <code>typedstream</code>, we need to think about how to use and represent it in <code>imessage-exporter</code>.</p>

<p>Since the stream encodes <code>Objective-C</code> data structures, specifically instances of classes and the data they own, we can use these rules to yield objects out of the stream. <code>imessage-exporter</code> does this, then reads the objects as they are yielded to build a message’s <a href="https://docs.rs/imessage-database/latest/imessage_database/tables/messages/models/enum.BubbleComponent.html">components</a>.</p>

<h2 id="data-representations">Data Representations</h2>

<p>Since non-Apple platforms do not natively support <code>Foundation</code> data structures, we must define an alternative representation.</p>

<h3 id="type-tags">Type Tags</h3>

<p>We can define an enum to represent the known type tags. Given the legacy documentation and our own observations, this definition should distill it to a single data structure<sup><a href="#fn9-12689" id="fnr9-12689" title="see footnote">9</a></sup>:</p>

<pre><code>fn from_byte(byte: &amp;u8) -&gt; Self {
    match byte {
        0x40 =&gt; Self::Object,
        0x2B =&gt; Self::Utf8String,
        0x2A =&gt; Self::EmbeddedData,
        0x66 =&gt; Self::Float,
        0x64 =&gt; Self::Double,
        0x63 | 0x69 | 0x6c | 0x71 | 0x73 =&gt; Self::SignedInt,
        0x43 | 0x49 | 0x4c | 0x51 | 0x53 =&gt; Self::UnsignedInt,
        other =&gt; Self::Unknown(*other),
    }
}
</code></pre>

<p>Note that <code>0x2B</code>, or <code>+</code>, is not mentioned in the legacy documentation, but we can infer what the type tag represents based on the context in the collected <code>typedstream</code> samples.</p>

<p>This data structure allows us to leverage Rust’s pattern matching to dispatch data as we encounter it in the stream. It also implies we need a separate data structure to represent the data stored after these type tags:</p>

<pre><code>pub enum OutputData {
    String(String),
    SignedInteger(i64),
    UnsignedInteger(u64),
    Float(f32),
    Double(f64),
    Byte(u8),
    Array(Vec&lt;u8&gt;),
    Class(Class),
}
</code></pre>

<p>By combining these structures, we can implement the serialization logic in Rust as follows:</p>

<pre><code>fn extract(data_type: Type) -&gt; OutputData {
    match data_type {
        Type::SignedInt =&gt; OutputData::SignedInteger(read_signed_int()),
        Type::UnsignedInt =&gt; OutputData::UnsignedInteger(read_unsigned_int()),
        Type::Float =&gt; OutputData::Float(read_float()),
        _ =&gt; ...
    }
}
</code></pre>

<h3 id="classes">Classes</h3>

<p>We can define a simple structure that represents the class data stored in the stream<sup><a href="#fn10-12689" id="fnr10-12689" title="see footnote">10</a></sup>:</p>

<pre><code>pub struct Class {
    pub name: String,
    pub version: u64,
}
</code></pre>

<p>The only data stored in the stream is the class name and the class version. We can pattern match against these names to build any arbitrary structures later, if necessary.</p>

<h3 id="archivable-objects">Archivable Objects</h3>

<p>We also need to encapsulate the data to store in the archivable object cache. This can be a class, an object, or an object’s field data<sup><a href="#fn11-12689" id="fnr11-12689" title="see footnote">11</a></sup>.</p>

<pre><code>pub enum Archivable {
    Object(Class, Vec&lt;OutputData&gt;),
    Data(Vec&lt;OutputData&gt;),
    Class(Class),
    Type(Vec&lt;Type&gt;),
}
</code></pre>

<p>An object, for example, contains a specific class, followed by a vector of field data owned by that class’s instance. An example of this looks like:</p>

<pre><code>Archivable::Object(
    Class {
        name: &#34;NSDictionary&#34;.to_string(),
        version: 0,
    },
    vec![OutputData::SignedInteger(2)],
)
</code></pre>

<p>Given what we learned about <code>NSDictionary</code>, the <code>OutputData</code> here refers to the number of key-value pairs in the dictionary, indicating the next 4 objects yielded from the stream are alternating key-value pairs belonging to this <code>NSDictionary</code>.</p>

<h2 id="using-the-data">Using the Data</h2>

<p><code>imessage-exporter</code> provides a deserialization <a href="https://docs.rs/imessage-database/latest/imessage_database/util/typedstream/parser/struct.TypedStreamReader.html">struct</a> that yields objects and their data from a <code>typedstream</code>. The rest of the parsing logic is focussed on specifically representing iMessage data, but could be adapted for arbitrary <code>typedstream</code> data.</p>

<p><code>imessage-exporter</code> <a href="https://docs.rs/imessage-database/latest/imessage_database/util/typedstream/models/index.html">documents</a> leverages the foregoing data models to represent attributes of the message body in a data structure called <a href="https://docs.rs/imessage-database/latest/imessage_database/tables/messages/models/enum.BubbleComponent.html"><code>BubbleComponent</code></a><sup><a href="#fn12-12689" id="fnr12-12689" title="see footnote">12</a></sup>.</p>



<p>Reverse engineering of Apple’s <code>typedstream</code> format reveals a sophisticated and elegantly designed binary serialization protocol. Through careful analysis of patterns, documentation fragments, and sample data, we&#39;ve uncovered a format that efficiently encodes complex object hierarchies.</p>

<p>The resulting implementation in <code>imessage-exporter</code> demonstrates how this legacy format can be deserialized, enabling platform-agnostic access to iMessage data that was previously locked within Apple’s ecosystem. This work not only enables practical applications like message export and analysis but also serves as a case study in reverse engineering binary formats through pattern recognition and hypothesis testing.</p>




    


</div>
  </body>
</html>
