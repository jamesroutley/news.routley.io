<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://masteringemacs.org/article/fuzzy-finding-emacs-instead-of-fzf">Original</a>
    <h1>Fuzzy Finding with Emacs Instead of Fzf</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>
        
        
        
            
        
        
            
        
        
            
                
            
            <img src="https://masteringemacs.org/static/img/fleuron2.gif"/>
            
<p>Filtering long lists of output on the command line usually involves taking the list of items – maybe the output of <code>ls</code>, <code>git</code> or <code>find</code> – and doing something with it. If you’re lucky you can mechanically filter the list with pipes and <code>grep</code>. If you’re unlucky and you can’t think of a heuristic, you’ll have to sift through the output with a pager like <code>less</code> and remember the items you want to keep.</p><figure>
   <img src="https://masteringemacs.org/static/uploads/fzf.png" alt="fzf filtering output from apt-cache search intended for apt-get"/>
<figcaption><code>fzf</code> filtering output from <code>apt-cache search</code> intended for <code>apt-get</code></figcaption>
</figure><p>Typically you do this because you want to cherry pick a subset of the items and feed them into another command, like <code>rm</code>, <code>cat</code> or <code>apt-get</code> as the picture above illustrates.</p><p>But the manual way is tedious and slow. And that’s the problem <a href="https://github.com/junegunn/fzf">fzf</a> tries to solve. The premise is simple: you feed it (via stdin) a list of items, and it displays a curses-like window where you can “fuzzy find” and select the items you care about. It’s designed to slot into command substitutions and pipes — like an interactive <code>grep</code>.</p><p>So that got me thinking. There’s no reason why you can’t use Emacs to do this instead of <code>fzf</code>! Emacs has better fuzzy finding and it’s the text editor you’re already using, so why not use Emacs?</p><p>Another reason to ditch <code>fzf</code> is that you might be using <a href="https://masteringemacs.org/article/running-shells-in-emacs-overview">a shell and not a terminal emulator in Emacs</a>. It’s not impossible to run curses apps in <code>shell-mode</code>, but it is harder.</p><h2 id="ezf-emacs-fuzzy-finder">EZF: Emacs Fuzzy Finder</h2><figure>
   <img src="https://masteringemacs.org/static/uploads/ezf-example-optimised.gif" alt="Fuzzy matching with Helm"/>
<figcaption><code>ezf</code> filtering output from <code>apt-cache</code> before passing it back to the shell</figcaption>
</figure><p>So the game plan is simple:</p><dl><dt>Build a shell script</dt><dd><p>This is the shell-facing part that we feed into pipes and command substitution sub-shells.</p><p>It must talk to <code>emacsclient</code>, the client in the Emacs client-server duo. That way it’ll run in your existing Emacs instance and it won’t interrupt your workflow if you also use – as you well should! – Emacs as your shell or terminal emulator.</p></dd><dt>Write some Elisp glue code</dt><dd><p>We’ll need a few functions capable of letting you filter and select the match candidates you like. Luckily this is generally very easy.</p></dd><dt>Return the picked candidates</dt><dd><p>After matching and selecting the candidates we want to keep, we must return them from whence they came. We’ll need to be mindful of annoying bagatelles like proper quoting.</p></dd><dt>Easy to Extend</dt><dd><p>It should be easy to extend or modify to suit individual tastes.</p><p>We’ll add a few command switches to <code>ezf</code> to make it extensible.</p></dd></dl><h3 id="sending-to-emacss-standard-input">Sending to Emacs’s standard input</h3><p>Let’s start with the shell script. I’ve done it in <code>bash</code>. There’s a number of little gotchas and workarounds required for this to work well. So the script’s freighted with one or two annoying hacks.</p><p>Chiefly, it’s not possible to ask <code>emacsclient</code> or even <code>emacs</code> to read directly from a file descriptor device. So process substitution with <code>&lt;(ls ...)</code> is out. I don’t know why, as Emacs is absolutely 100% capable of <em>doing</em> it inside Emacs. So I’m chalking it up to oversight.</p><p>That means we have to work around that problem with real files. I’m using <code>mktemp</code> to <code>cat</code> standard input to a temporary file. To avoid clobbering your <code>tmpfs</code> with junk files, there’s a <code>trap</code> to clean up when the script exits.</p><p>Now all we need to do is add a little command argument parsing: I want <code>-c</code> to let us choose the completion tool to invoke in Emacs; and <code>-f</code> is there to pick the field offset to return. The latter is particularly useful if you have a line of text and you want just the first word, for example.</p><p>After that, there’s a little bit of house keeping in case you exit out of the selection process without picking anything. Oh, when you tell <code>emacsclient</code> to evaluate elisp it’ll use <code>prin1</code> to emit the representation of the Lisp object to standard output, and that forces quote symbols around strings, even if we don’t really want that. Sieving the output from Emacs through a pipe to <code>xargs</code> cunningly strips the quotes.</p><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> <span>-o</span> nounset -o errexit -o pipefail

<span>field=</span>nil
<span># the elisp function to use for completing read</span>
<span>candidate_fn=</span>ezf-default
<span>while</span> <span>getopts</span> c:f: OPT<span>;</span> <span>do</span>
    <span>case</span> <span>$OPT</span><span> in</span>
        c<span>)</span>
            <span>candidate_fn=$OPTARG</span>
            <span>;;</span>
        f<span>)</span>
            <span>field=$OPTARG</span>
            <span>;;</span>
        *<span>)</span>
            <span>echo</span> <span>&#34;usage: </span><span>${0##</span>*/<span>}</span><span> [-f field] [-c candidate-fn]&#34;</span>
            <span>exit</span> 2
    <span>esac</span>
<span>done</span>
<span>shift</span> <span>$((</span> OPTIND - 1 <span>))</span>
<span>OPTIND=</span>1

<span>ezftmp=</span><span>&#34;</span><span>$(</span><span>mktemp</span><span>)</span><span>&#34;</span>
<span>trap</span> <span>&#39;rm -f -- &#34;$ezftmp&#34;&#39;</span> EXIT
<span>&gt;</span> <span>&#34;</span><span>$ezftmp</span><span>&#34;</span> <span>cat</span> -
<span># xargs is there to strip the &#34;&#34; from the beginning and end of the output from Emacs.</span>
<span>selection=$(</span><span>emacsclient</span> -e <span>&#34;(ezf </span><span>\&#34;</span><span>$ezftmp</span><span>\&#34;</span><span> </span><span>$field</span><span> #&#39;</span><span>$candidate_fn</span><span>)&#34;</span> <span>|</span> <span>xargs</span><span>)</span>
<span>if [[</span> <span>&#34;</span><span>$selection</span><span>&#34;</span> <span>==</span> <span>&#34;nil&#34;</span><span> ]]</span>; <span>then</span>
    <span>exit</span> 1
<span>else</span>
   <span>echo</span> <span>&#34;</span><span>$selection</span><span>&#34;</span>
<span>fi</span></code></pre><p>I’ve named it <code>ezf.sh</code> (symlinked to <code>ezf</code>) so all you need to do is put it somewhere on your <code>PATH</code>.</p><h3 id="filtering-in-emacs">Filtering in Emacs</h3><p>Completion in Emacs is a complex subject matter and one soused in bike shedding and personal opinion. So I’ve kept things open and made it work with <code>completing-read</code> – well, specifically <code>completing-read-multiple</code> so you can pick multiple items.</p><p>If you’re unsure how that fits into <em>your</em> completion framework, then my article on <a href="https://masteringemacs.org/article/understanding-minibuffer-completion">understanding Minibuffer Completion</a> is a good place to start. If you want IDO to work with it, you’ll have to tweak the code yourself. Luckily I have <a href="https://masteringemacs.org/article/find-files-faster-recent-files-package">an example here</a> to get you started.</p><p>I’ve also made it work out of the box with Helm which, as we all know, is awesome. Helm in particular is perfect for this as it comes with great fuzzy matching, multiple selection <em>and</em> it’s easy to add custom actions like returning matches to the shell <em>and</em> opening them as files in Emacs, for example.</p><p>There’s three parts: two completion mechanisms and a generic wrapper that turns lists of candidates into usable output.</p><pre><code>(<span>defun</span><span> ezf-default </span>(filename)
  <span>&#34;EZF completion with your default completion system.&#34;</span>
  (completing-read-multiple
   <span>&#34;Pick a Candidate: &#34;</span>
   (with-temp-buffer
     (insert-file-contents-literally filename <span>nil</span>)
     (string-lines (buffer-string) <span>t</span>))))</code></pre><p><code>completing-read-multiple</code> takes a prompt and a list of strings. And that’s all you need to get Emacs’s completion system to work. I create a temporary buffer to hold the file contents before it’s split up into lines. If you want NULL-separated output, this is the place to change it.</p><p>If you’re wondering why I’m using a buffer, you should read my article <a href="https://masteringemacs.org/article/why-emacs-has-buffers">Why Emacs has Buffers</a>.</p><pre><code>(<span>defun</span><span> ezf-helm </span>(filename)
  <span>&#34;EZF completion with `helm&#39;.&#34;</span>
  <span>;; Uncomment if you want Helm to full screen.</span>
  <span>;; (helm-set-local-variable &#39;helm-full-frame t)</span>
  (helm :sources
        (helm-build-in-file-source <span>&#34;EZF Completion&#34;</span> filename
          :action (<span>lambda</span> (_) (helm-marked-candidates)))))</code></pre><p>For Helm the solution is similar. I’m using Helm’s ability to build candidates directly from a file. If you want to add more than one action then I recommend you use <code>helm-make-actions</code> to build the alist.</p><p>Now for the generic wrapper. Its job is to take a list of strings you picked from a candidate function and turn it into something the shell can properly read. If you specified <code>-f</code> to <code>ezf</code> then it’ll also split the string and only use the field index you chose.</p><pre><code><span>;; If you start Emacs&#39;s server some other way, you can remove this.</span>
(server-start)

(<span>defvar</span><span> ezf-separators </span><span>&#34; &#34;</span>
  <span>&#34;Regexp of separators `ezf&#39; should use to split a line.&#34;</span>)

(<span>defun</span><span> ezf </span>(filename &amp;optional field completing-fn)
  <span>&#34;Wrapper that calls COMPLETION-FN with FILENAME.</span>

<span>Optionally split each line of string by `ezf-separators&#39; if FIELD</span>
<span>is non-nil and return FIELD.</span>

<span>If COMPLETING-FN is nil default to `ezf-default&#39;.&#34;</span>
  (when-let (candidates (<span>funcall</span> (<span>or</span> completing-fn &#39;ezf-default) filename))
    (mapconcat (<span>lambda</span> (candidate)
                 (shell-quote-argument
                  (<span>if</span> field
                      (<span>nth</span> (<span>1-</span> field) (split-string candidate ezf-separators <span>t</span> <span>&#34; &#34;</span>))
                    candidate)))
               candidates
               <span>&#34; &#34;</span>)))</code></pre><p>Here the goal is simply to take a <code>filename</code> containing our candidates; an optional <code>completing-fn</code>, as set by passing <code>-c</code> to <code>ezf</code>; and an optional <code>field</code> index.</p><p><code>ezf-separators</code> is a regular expression to split each line by. So if you want NULL-delimited support then you can easily add that and a switch to go along with it.</p><p>Because we’re taking unsanitized candidates and passing them through our completion system, it’s good form to ensure the filtered candidates are properly escaped when we hand them back to the shell. That’s what <code>shell-quote-argument</code> does. <code>mapconcat</code> merely ensures the quoted candidates are space-separated as that’s what shells expect. (And if you want NULL separation you should change this also.)</p><p>Because the last value is by convention the value that is returned from a function in Lisp, we know that the output of <code>emacsclient</code> is the result of the <code>mapconcat</code> form if we selected any matches, and <code>nil</code> otherwise.</p><p>With all this in place it’s time to test it:</p><figure>
   <img src="https://masteringemacs.org/static/uploads/ezf-default.svg" alt="fuzzy matching with ezf, the Emacs fuzzy finder"/>
<figcaption>Fuzzy matching dictionary words with Emacs and <code>ezf</code></figcaption>
</figure><p>Yep. Looks good.</p><p>This tool is able to do most of the things you’d use <code>fzf</code> for, and all from within the comfort of your Emacs. It’ll work just fine in Eshell also if you don’t push it too hard. Eshell’s support for pipes and redirection is not as good as regular shells, but with a little bit of work it could be made to work there too, with or without the bash script. And of course you can use it from Terminals also: the ones you run from inside Emacs, and external ones also.</p><h2 id="next-steps">Next Steps</h2><p>I think this is a pretty good example of how you can combine the power of Emacs and a little bit of gnarly shell script magic. And this is really just the beginning. You can take the shell script and hook it up to all manner of crazy Emacs stuff: <code>M-x dired</code>; sending stuff to a buffer for editing; and more.</p><p>You can also find it on Github here: <a href="https://github.com/mickeynp/ezf">EZF</a>.</p>

        
        
    </article>
      </div></div>
  </body>
</html>
