<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://entropicthoughts.com/advent-of-code-on-z-machine">Original</a>
    <h1>Advent of Code on the Z-Machine</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
Fantasy consoles like the Pico-8 are a great idea. A fantasy console provides a
standardised and portable environment in which developers can explore ideas
within creative constraints. The <i>Z-machine</i>, developed by Infocom in 1979,
is the earliest fantasy console I know, although this is probably the first time
it’s been called that.
</p>


<p><img src="https://entropicthoughts.com/image/aoci6_01.jpg" alt="aoci6_01.jpg"/>
</p>

<p>
Infocom faced the problem of porting their text adventures to the multitude of
platforms that existed at the time. Since they came out of the academic
environment at <abbr>mit</abbr>, they applied a brand-spanking new solution to the problem:
they built a virtual machine, the <i>Z-machine</i>, and made a compiler that produced
bytecode for it. This meant that once they had made a new game, the new game
could instantly be played on all platforms which had the Z-machine<span><sup>1</sup> With a
caveat. The Z-machine exists in multiple versions. For a long time, version 3
was the default for new games, and it was widely supported. Some games exceeded
the capabilities of version 3 and were made for higher versions – they weren’t
quite as portable, so the designer had to show that they could do good enough
things with the more capable machines that the tradeoff would be worth it.</span>, and
if they ported the Z-machine to a new platform, users of that platform could
instantly play all games developed for the Z-machine. Today, when Flash, Java,
<abbr>ecma</abbr>Script and others have showed us how successful this approach is, we take
it for granted, but at the time that was just not how you did things.
</p>
<section id="outline-container-the-z-machine-is-still-alive">

<div id="text-org43e25b6">
<p>
The observant reader has noticed that I use the present tense when mentioning
the Z-machine. That’s because it still exists, and it’s still used. Granted,
many text adventures today are written for <a href="https://www.eblong.com/zarf/glulx/">the more capable Glulx virtual
machine</a> – a spiritual successor to the Z-machine – but then again, many text
adventures are also written for the Z-machine.
</p>

<p>
Let’s say we want to learn to program the Z-machine. How do we get started?
</p>

<p>
We <a href="https://inform-fiction.org/zmachine/standards/z1point1/sect14.html">could emit bytecode directly</a>. That would probably be a cool learning
experience. It would also be kind of annoying, so we’ll ignore that alternative.
</p>

<p>
The next step up on the abstraction staircase is <abbr>zil</abbr>, that weird, low-level
Lisp-looking thing that’s not at all Lisp.
</p>

<p><label>In[1]:</label></p><div>
<pre>&lt;ROUTINE WABE-F (&#34;OPTIONAL&#34; (CONTEXT &lt;&gt;))
  &lt;COND
    (&lt;EQUAL? .CONTEXT ,M-LOOK&gt;
      &lt;TELL
         &#34;This grassy &#34; D ,CLEARING &#34; is only twenty &#34;
         &#34;feet across, and perfectly circular. Paths &#34;
         &#34;wander off in many &#34; D ,INTDIR &#34;s through &#34;
         &#34;the surrounding &#34; D ,THICKET ,PERIOD&gt;
      &lt;RTRUE&gt;)
    (&lt;AND &lt;EQUAL? .CONTEXT ,M-EXIT&gt; &lt;MISSED-MEEP?&gt;&gt;
      &lt;CRLF&gt; &lt;RTRUE&gt;)
    (T
      &lt;RFALSE&gt;)&gt;&gt;
</pre>
</div>

<p>
There is <a href="https://zilf.io/">a modern compiler for <abbr>zil</abbr></a>, which can be used to build the source code
from the original games, or indeed write new games. It’s tempting! But in the
end, there are two reasons I opted not to write <abbr>zil</abbr>:
</p>

<ul>
<li>First off, it is really low level. From what I understand, not even the people
at Infocom wrote raw <abbr>zil</abbr>. Instead, they used Lisp macros that generated
<abbr>zil</abbr>.<span><sup>2</sup> They probably also had a <abbr>zil</abbr> interpreter in Lisp, meaning they
could tweak parsing, move items, change location properties, etc. with the
game running. It must have been a very productive way to iterate.</span></li>

<li>Although there are plenty of examples of <abbr>zil</abbr> code (all of the Infocom games,
for one thing!) there’s relatively little documentation.</li>
</ul>

<p>
Inform 6 is another language that compiles to Z-machine bytecode. From a birds
eye view, it similar to <abbr>zil</abbr> because they are both similar to Z-machine
bytecode. Inform 6 was created before the <abbr>zil</abbr> source code for the Infocom
classics was released; Inform was designed by reverse-engineering the original
Z-machines. The Inform 6 compiler comes as <a href="https://github.com/DavidKinder/Inform6">a set of stand-alone C source files</a>
that are built with the command
</p>

<p><label>In[2]:</label></p>

<p>
So refreshing. Once we have that compiler, we can give it a source file of
Inform 6 code and it produces bytecode for the Z-machine. Here’s
<code>hello.inf</code>.
</p>

<p><label>In[3]:</label></p><div>
<pre>[Main;
    <span>print</span> <span>&#34;hello, world!^&#34;</span>;
];
</pre>
</div>

<p>
This looks strange, but it’s not very. Subroutines are declared with square
brackets. The entrypoint of an Inform 6 program is called <code>Main</code>. Names are not
case-sensitive, but subroutines conventionally use Pascal_Case. Carets in
strings become newlines.
</p>

<p>
We compile this to Z-machine bytecode with
</p>

<p><label>In[4]:</label></p>

<p>
and then we have a file called <code>hello.z5</code> which is bytecode that runs on the
Z-machine, version 5. The compiler defaults to version 5 because it is most
popular today, but when Infocom developed games, they defaulted to the less
capable version 3, because it had lower system requirements. We can ask the
Inform 6 compiler for version 3 bytecode as long as our code is compatible with it.
</p>

<p><label>In[5]:</label></p>

<p>
Now we get a <code>hello.z3</code> file with bytecode which should run on any Z-machine. I
happen to have <code>bocfel</code> lying around.
</p>

<pre id="orgc8550a2">$ bocfel hello.z3
Bocfel 2.1.2
Using the Cheap Glk Implementation, library version 1.0.6.



hello, world!
$
</pre>

<p>
Great! Now what’s that way everyone goes about learning a new language? Riiight,
<a href="https://adventofcode.com/">Advent of Code</a>. Before committing to doing it in Inform 6 this year, maybe we
should try the first couple of days of the previous year as a warm-up exercise.
Let’s see, <a href="https://adventofcode.com/2024/day/1">here’s day one</a>. Okay, some numbers, a little sorting, shouldn’t be
too hard.
</p>
</div>
</section>
<section id="outline-container-a-machine-for-olden-times-has-olden-integers">

<div id="text-org2f529c1">
<p>
Except … look at the full puzzle input. The first number is something
like 76309. Now guess the bit depth of integers in the Z-machine. Yup, it uses
16-bit integers, the highest of which is 65535. We cannot even <i>represent</i> the
puzzle input natively on the Z-machine. Smarter people would close the tab and
move on to other things, but I wrote the 160 lines of Inform 6 to do the
required long integer maths using arrays of four bytes for storage.
</p>

<p>
It contains functions such as this one, which adds <code>left</code> and <code>right</code>, storing
the result in <code>sum</code>.<span><sup>3</sup> Why not update one of the addends in place? That would
have been a valid design decision. Maybe that’s the way these things usually are
done. The current method signature is just the first thing that came to mind.</span>
</p>

<p><label>In[6]:</label></p><div>
<pre>[long_plus left right sum _i _carry _temp;
    <span>for</span> (_i = 3 : _i &gt;= 0 : _i--) {
        _temp = left-&gt;_i + right-&gt;_i + _carry;
        sum-&gt;_i = _temp &amp; $ff;
        @log_shift _temp (-8) -&gt; _carry;
    }
];
</pre>
</div>

<p>
There are a few things to note in this code:
</p>

<ul>
<li>Inform 6 only has one type of local variable: subroutine parameter. But all
parameters are optional as far as the compiler cares, so to get local
variables we declare the local variables we need as parameters and then the
caller doesn’t supply values for them. Conventionally, these parameters are
prefixed with an underscore.</li>

<li>You didn’t read the <code>for</code> loop wrong. It actually uses colons to separate the
parts of the loop head. Odd.</li>

<li>The byte-wise addition is greatly simplified by having 16-bit integers in the
Z-machine, since we just store the output of each half-adder in <code>_temp</code> and it
holds both result and carry.</li>

<li>The right arrow mostly indicates byte array indexing, such as in <code>left-&gt;_i</code>.</li>

<li>When Inform 6 doesn’t have a high-level keyword, it is possible to embed
Z-machine instructions directly in the Inform 6 source code, by prefixing the
opcode with <code>@</code>. This embedded assembly syntax uses the right arrow to
indicate the destination of operations.</li>

<li>The <code>_carry</code> variable isn’t explicitly initialised before it is read for the
first time. Is it valid Inform 6 to not do that? I don’t know. I’m just an
amateur who was handed a hammer with no instruction on how to use it. It seems
that <code>bocfel</code> reliably fills my non-initialised local variables with zeroes,
but I don’t know if that’s a guarantee. There are surely many other such
errors that you wouldn’t find in professional code.<span><sup>4</sup> I have been informed
that Inform 6 guarantees parameters are initialised to zero unless they are
given a value by the caller. But my point still stands! I could be missing
other things.</span></li>
</ul>

<p>
Most of the other methods are fairly natural, if we have implemented long
integer maths before. We will want to assign regular integers into long
integers:
</p>

<p><label>In[7]:</label></p><div>
<pre>[long_set source target _temp;
    bzero(target, 4);
    target-&gt;3 = source &amp; $ff;
    @log_shift source (-8) -&gt; _temp;
    target-&gt;2 = _temp &amp; $ff;
];
</pre>
</div>

<p>
We need methods to store and fetch these long integers from arrays:
</p>

<p><label>In[8]:</label></p><div>
<pre>[long_arrfetch source target offset _i;
    <span>for</span> (_i = 0 : _i &lt; 4 : _i++)
        target-&gt;_i = source-&gt;(4*offset+_i) &amp; $ff;
];

[long_arrstore source target offset _i;
    <span>for</span> (_i = 0 : _i &lt; 4 : _i++)
        target-&gt;(4*offset+_i) = source-&gt;_i &amp; $ff;
];
</pre>
</div>

<p>
We can use <code>arrstore</code> to copy from one long integer to another.
</p>

<p><label>In[9]:</label></p><div>
<pre>[long_copy source target; long_arrfetch(source, target, 0); ];
</pre>
</div>

<p>
We can read a series of bytes into a long integer:
</p>

<p><label>In[10]:</label></p><div>
<pre>[long_read buffer offset target _i _j _temp;
    long_set(0, target);
    <span>! </span><span>Walking the  length of the buffer.</span>
    <span>for</span> (_i = offset : _i &lt; buffer-&gt;0 : _i++) {
        <span>! </span><span>If we have a digit...</span>
        <span>if</span> (buffer-&gt;_i &gt;= 48 &amp;&amp; buffer-&gt;_i &lt;= 57) {
            <span>! </span><span>Take its numeric value.</span>
            _temp = buffer-&gt;_i - 48;
            <span>! </span><span>Add it as the new least significant</span>
            <span>! </span><span>decimal digit of the long integer.</span>
            <span>for</span> (_j = 3 : _j &gt;= 0 : _j--) {
                _temp = _temp + target-&gt;_j * 10;
                target-&gt;_j = _temp &amp; $ff;
                @log_shift _temp (-8) -&gt; _temp;
            }
        } <span>else</span> {
            <span>! </span><span>Return the position of the first non-digit.</span>
            <span>return</span> _i;
        }

    }
];
</pre>
</div>

<p>
We can also convert a long integer into a series of digits:
</p>

<p><label>In[11]:</label></p><div>
<pre>[long_print value _i _count _temp;
    <span>! </span><span>We&#39;re destructively extracting digits from the</span>
    <span>! </span><span>value, so better create a local copy of it</span>
    <span>! </span><span>before proceeding.</span>
    long_copy(value, _qx);
    <span>while</span> (true) {
        _temp = 0;
        <span>! </span><span>Divide out the least significant digit.</span>
        <span>for</span> (_i = 0 : _i &lt; 4 : _i++) {
            @log_shift _temp 8 -&gt; _temp;
            _temp = _temp + _qx-&gt;_i;
            _qx-&gt;_i = _temp / 10;
            _temp = _temp % 10;
        }
        <span>! </span><span>Convert it to a character and store.</span>
        _fbuf-&gt;_count = 48 + _temp;
        <span>! </span><span>We should never see more than 10 digits.</span>
        <span>if</span> (++_count &gt; 10) <span>break</span>;
        <span>! </span><span>When we have divided out all digits, we</span>
        <span>! </span><span>exit. (We always run one iteration to</span>
        <span>! </span><span>make sure we print 0 when it is 0.)</span>
        <span>if</span> (long_iszero(_qx)) <span>break</span>;
    }

    <span>! </span><span>We&#39;ll get the digits least significant first</span>
    <span>! </span><span>so we print the buffer backwards. (Although</span>
    <span>! </span><span>I&#39;d argue we made a mistake when we copied</span>
    <span>! </span><span>the order Arabs write their numbers and</span>
    <span>! </span><span>transplanted it into a left-to-right language.</span>
    <span>! </span><span>Clearly, the Arabs meant their numbers to be</span>
    <span>! </span><span>least significant digit first in the direction</span>
    <span>! </span><span>the language is written.)</span>
    <span>for</span> (_i = _count - 1 : _i &gt;= 0 : _i--) {
        <span>print</span> (char) _fbuf-&gt;_i;
    }
];
</pre>
</div>

<p>
In this code we see our first print directive, <code>(char)</code>. Normally the <code>print</code>
instruction would print the numeric value of the character, but we can instruct
it to interpret the next value as a character by giving it such a directive.
Although it looks like a type cast, it is not. It is part of the <code>print</code>
statement syntax of Inform 6.
</p>

<p>
Although almost all long integer methods that need temporary storage use the two
registers <code>_rx</code> and <code>_tx</code>, the print method specifically uses <code>_qx</code> and it is
the only method that uses that register. It makes debugging a lot simpler to be
able to call print inside another subroutine without having the printing method
clobber the temporary storage of the other subroutine! Pro tip.
</p>

<p>
We need a size comparison too.
</p>

<p><label>In[12]:</label></p><div>
<pre>[long_lessthan left right _i;
    <span>for</span> (_i = 0 : _i &lt; 4 : _i++) {
        <span>if</span> (left-&gt;_i &lt; right-&gt;_i) <span>return</span> true;
        <span>if</span> (left-&gt;_i &gt; right-&gt;_i) <span>return</span> false;
    }
    <span>! </span><span>If it gets here, they are equal, which means</span>
    <span>! </span><span>left is not less than right.</span>
    <span>return</span> false;
];
</pre>
</div>

<p>
I’m not sure why I show you all this. It’s all fairly standard long integer
maths implementation, and nothing relevant to the Z-machine at all. I hope you
didn’t fall asleep. Sorry.
</p>

<p>
One thing that turned out much simpler than I thought it would be was the
subroutine to sort arrays of these things. Granted, it’s only simple because of
the other subroutines supporting it, but still!
</p>

<p><label>In[13]:</label></p><div>
<pre>[long_sort arr n _i _j;
    <span>for</span> (_i = 1 : _i &lt; n : _i++) {
        long_arrfetch(arr, _rx, _i);
        <span>for</span> (_j = _i-1 : _j &gt;= -1 : _j--) {
            long_arrfetch(arr, _tx, _j);
            <span>if</span> (_j &gt;= 0 &amp;&amp; long_lessthan(_rx, _tx)) {
                long_arrstore(_tx, arr, _j+1);
            } <span>else</span> {
                long_arrstore(_rx, arr, _j+1);
                <span>break</span>;
            }
        }
    }
];
</pre>
</div>

<p>
Here, <code>_rx</code> and <code>_tx</code> are global temporary registers for use within this module.
The Z-machine is designed to not do any dynamic allocation outside of parameters
on the stack, so any arrays (e.g. to hold long integers) need to be allocated
statically.<span><sup>5</sup> There are Inform games that rely on dynamic allocation and they
twist the Z-machine in awkward ways to achieve that, from what I understand.
Andrew Plotkin’s <i>Lists and Lists</i> comes to mind.</span>
</p>
</div>
</section>
<section id="outline-container-solving-the-first-day-s-problems">

<div id="text-orge58fb6c">
<p>
With that little nightmare of implementing long integer maths out of the way, we
can start to figure out the Z-machine again. There seems to be a few ways to
read input from the user, but the main one is the instruction with opcode
<code>@aread</code> in version 5.<span><sup>6</sup> The corresponding opcode in version 3 is <code>@sread</code>,
but I never got it to work after a quick test. I’m sure I could with more
tinkering, but that would be a distraction.</span>
</p>

<p>
Here’s a method that uses it to read a line of user input into a buffer.
</p>

<p><label>In[14]:</label></p><div>
<pre><span>! </span><span>Read a line into buf, returning the index of the</span>
<span>! </span><span>first read character.</span>
[read_line buf l _discard;
    <span>! </span><span>Zero out the buffer while keeping the initial</span>
    <span>! </span><span>element which indicates buffer size.</span>
    l = buf-&gt;0; bzero(buf, l); buf-&gt;0 = l;
    @aread buf -&gt; _discard;
    <span>return</span> 2;
];
</pre>
</div>

<p>
The <code>@aread</code> instruction stores the number of read characters in the second
location of the array, and returns the final character of the input. We’ll
ignore both of those, because we’ll read the input until the first <abbr>nul</abbr>
character to figure out where it ends.
</p>

<p>
We will also have a function that skips past non-digits in a character buffer to
advance to the next number in the input.
</p>

<p><label>In[15]:</label></p><div>
<pre>[skip_nodig buf offset;
    <span>while</span> (offset &lt; buf-&gt;0 &amp;&amp; (buf-&gt;offset &lt; 48 || buf-&gt;offset &gt; 57)) offset++;
    <span>return</span> offset;
];
</pre>
</div>

<p>
That’s most of the preparation. Using this code, we can solve the first half of
the first day of Advent of Code 2024. Note that we do <i>not</i> use the Inform 6
standard library <i>at all</i>. The compiler only sees the code we have written and
the Z-machine only executes instructions compiled from our code. Why this
matters will be explained later.
</p>

<p><label>In[16]:</label></p><div>
<pre><span>Include</span> <span>&#34;util.h&#34;</span>;
<span>Include</span> <span>&#34;long.h&#34;</span>;

<span>Constant</span> <span>MAX_INPUT</span> = 20;
<span>Constant</span> <span>MAX_LINES</span> = 1000;

<span>! </span><span>Read buffer, used to accept user input.</span>
<span>Array</span> <span>rbuf</span>-&gt;(MAX_INPUT);

<span>! </span><span>Temporary storage locations for long integers.</span>
<span>Array</span> <span>ax</span>-&gt;4;
<span>Array</span> <span>bx</span>-&gt;4;
<span>Array</span> <span>cx</span>-&gt;4;
<span>Array</span> <span>dx</span>-&gt;4;

<span>! </span><span>We will need four bytes for each number in the two</span>
<span>! </span><span>columns of full input.</span>
<span>Array</span> <span>as</span> -&gt;(MAX_LINES*4);
<span>Array</span> <span>bs</span> -&gt;(MAX_LINES*4);

[Main _next _n _i;
    <span>! </span><span>Set the buffer size in the buffer.</span>
    rbuf-&gt;0 = MAX_INPUT-1;

    <span>while</span> (_n &lt; MAX_LINES) {
        <span>! </span><span>Try to read another line of input.</span>
        _next = read_line(rbuf);
        <span>if</span> (rbuf-&gt;_next == 0) <span>break</span>;

        <span>! </span><span>Extract the two numbers from the input.</span>
        _next = long_read(rbuf, _next, ax);
        _next = skip_nodig(rbuf, _next);
        _next = long_read(rbuf, _next, bx);

        <span>! </span><span>Push the numbers into their arrays.</span>
        long_arrstore(ax, as, _n);
        long_arrstore(bx, bs, _n);
        _n++;
    }

    <span>! </span><span>Sort each array.</span>
    long_sort(as, _n);
    long_sort(bs, _n);

    <span>! </span><span>Accumulate distances into dx.</span>
    long_set(0, dx);
    <span>! </span><span>Compute the distances between parallel values.</span>
    <span>for</span> (_i = 0 : _i &lt; _n : _i++) {
        long_arrfetch(as, ax, _i);
        long_arrfetch(bs, bx, _i);
        long_minus(ax, bx, cx);
        long_plus(dx, cx, dx);
    }

    <span>print</span> <span>&#34;Cumulative distances: &#34;</span>;
    long_print(dx);
    <span>print</span> <span>&#34;^&#34;</span>;
];
</pre>
</div>

<p>
For the full input, this takes four seconds to run in <code>bocfel</code> on my machine,
but it produces the correct answer! To solve the second half of the day, we can
tack on another loop at the end.
</p>

<p><label>In[17]:</label></p><div>
<pre>long_set(0, dx);
<span>! </span><span>Step through both arrays somewhat cleverly to</span>
<span>! </span><span>find matches more cheaply than in square time.</span>
<span>! </span><span>Well, it would have been more cheaply than</span>
<span>! </span><span>square time if we didn&#39;t choose a square time</span>
<span>! </span><span>algorithm for sorting both inputs...</span>
<span>for</span> (_i = 0, _j = 0 : _i &lt; _n : _i++) {
    long_arrfetch(as, ax, _i);
    long_arrfetch(bs, bx, _j);
    <span>! </span><span>If a is greater than b, then we need to</span>
    <span>! </span><span>advance j until they match.</span>
    <span>while</span> (_j &lt; _n &amp;&amp; long_lessthan(bx, ax)) {
        _j++;
        long_arrfetch(bs, bx, _j);
    }
    _firstmatch = _j;
    <span>! </span><span>If a is equal to b, it contributes and we</span>
    <span>! </span><span>advance j.</span>
    <span>while</span> (_j &lt; _n &amp;&amp; ~~long_lessthan(ax, bx)) {
        long_plus(dx, ax, dx);
        _j++;
        long_arrfetch(bs, bx, _j);
    }
    <span>! </span><span>Now a is less than b, so we need to advance i.</span>
    <span>! </span><span>But first we rewind b so that other equal</span>
    <span>! </span><span>elements of a have a chance of counting their</span>
    <span>! </span><span>contributions too!</span>
    _j = _firstmatch;
}

<span>print</span> <span>&#34;Similarity score: &#34;</span>;
long_print(dx);
<span>print</span> <span>&#34;^&#34;</span>;
</pre>
</div>
</div>
</section>
<section id="outline-container-using-objects-to-solve-the-second-day">

<div id="text-orgf673213">
<p>
So far, we have only seen procedural code, but Inform 6 is also somewhat
object-oriented<span><sup>7</sup> Sometimes the Z-machine is described as one of the first
widely-installed object-oriented systems, but there is very little support for
object-orientation in the Z-machine itself. Also <abbr>zil</abbr> does not support what we
would today recognise as object-oriented code. It has things called objects, but
they are closer to C <code>struct</code>s.</span>, with the idea being that messages being passed
between objects is a useful way to simulate interactions in the world. It still
won’t allocate objects dynamically, so for the most part it is used with
singleton objects.<span><sup>8</sup> It is possible to create objects during run-time, but
then they come from a statically allocated fixed-size pool.</span>
</p>

<p>
Inform 6 supports dual object hierarchies: it encodes is-a relationships through
inheritance, and has-a relationships through an object tree indicating
containment. We can use the first half of the second day’s puzzle to illustrate
both.
</p>

<p>
To model the second day’s problem, we begin by defining an attribute indicating
that a report is safe. An attribute is a boolean flag (in fact, they are called
<i>flags</i> in <abbr>zil</abbr>) that all objects start out not having, but it can be set on
any of them.
</p>

<p><label>In[18]:</label></p>

<p>
Then we create a class for the generic report approver.
</p>

<p><label>In[19]:</label></p><div>
<pre><span>Class</span> <span>Report_Approver</span>
with
    <span>! </span><span>Store the previous value for range calculations.</span>
    _prev nothing,
    <span>! </span><span>Method that decides whether to accept a new value.</span>
    _accept,
    <span>! </span><span>Default reject method that accepts the first value,</span>
    <span>! </span><span>rejects any changes that are too large, and otherwise</span>
    <span>! </span><span>defers to the accept method.</span>
    _reject [next;
        <span>if</span> (self._prev == nothing) <span>return</span> false;
        <span>if</span> (abs(next - self._prev) &gt; 3) <span>return</span> true;
        <span>return</span> ~~self._accept(next);
    ],
    <span>! </span><span>When appending a number, if it is rejected, remove</span>
    <span>! </span><span>the valid attribute from this approver.</span>
    append [next;
        <span>if</span> (self._reject(next)) <span>give</span> self ~valid;
        self._prev = next;
    ],
    <span>! </span><span>To reset an approver, remove the previous value</span>
    <span>! </span><span>and default back to a valid report again.</span>
    reset [;
        self._prev = nothing;
        <span>give</span> self valid;
    ],
<span>has</span>
    valid;
</pre>
</div>

<p>
Here we can see some new features. Properties are like attributes except instead
of booleans, they store values. Importantly, they can store anonymous
subroutines, which are declared like normal subroutines except without a name,
and inside them we have access to the implicit variable <code>self</code>. The keyword
<code>give</code> sets and unsets flags on objects (sorry, I mean “assigns attributes to”
objects, and “removes attributes from” objects).
</p>

<p>
As before, properties/methods that are not meant to be public are conventionally
named with a leading underscore.
</p>

<p>
Next we define an aggregate approver that judges the validity of a report by
consulting multiple sub-approvers. It will accept a report as long as any of the
sub-approvers accept it. We inherit from the <code>Report_Approver</code> class to do it,
and we override both public methods <code>append</code> and <code>reset</code>.
</p>

<p><label>In[20]:</label></p><div>
<pre>Report_Approver multi_approver
with
    append [next _sub _anyvalid;
        <span>! </span><span>Append to all sub-approvers.</span>
        <span>objectloop</span> (_sub <span>in</span> self) {
            _sub.append(next);
            <span>! </span><span>As long as any of them are valid...</span>
            <span>if</span> (_sub <span>has</span> valid)
                _anyvalid = true;
        }
        <span>! </span><span>...then the aggregate is also valid.</span>
        <span>if</span> (~~_anyvalid) <span>give</span> self ~valid;
    ],
    reset [_sub;
        <span>! </span><span>Reset all sub-approvers</span>
        <span>objectloop</span> (_sub <span>in</span> self) _sub.reset();
        <span>! </span><span>Then perform the same reset as</span>
        <span>! </span><span>the parent class.</span>
        self.Report_Approver::reset();
    ];
</pre>
</div>

<p>
The <code>reset</code> method on this object calls the <code>reset</code> method of its superclass.
There are a few ways this can be done<span><sup>9</sup> In some instances we can define
properties as additive and the full inheritance chain is consulted
automatically.</span> but this seemed easiest here.
</p>

<p>
We also see the <code>objectloop</code> Inform 6 keyword, which starts a special kind of
loop that iterates through the direct descendants of an object in the object
tree.<span><sup>10</sup> We could iterate through the children using object relationship
methods like <code>parent</code>, <code>child</code>, and <code>sibling</code>, but the <code>objectloop</code> is more
convenient and easier to read.</span> As a reminder, the object tree is not the same
thing as the inheritance tree; the object tree is about which objects contain
each other (has-a, rather than is-a).
</p>

<p>
So far, we have not seen which objects are contained by the <code>multi_approver</code>,
but that happens next!
</p>

<p><label>In[21]:</label></p><div>
<pre>Report_Approver -&gt; decremental_reports
with
    _accept [next;
        <span>return</span> next - self._prev &lt; 0;
    ];

Report_Approver -&gt; incremental_reports
with
    _accept [next;
        <span>return</span> next - self._prev &gt; 0;
    ];
</pre>
</div>

<p>
This is another way the right arrow is used in Inform 6. When we define objects
with a right arrow, they are automatically inserted as children into the object
defined just before. This means both <code>decremental_reports</code> and
<code>incremental_reports</code> become children of <code>multi_approver</code>.<span><sup>11</sup> There are also
functions to move objects around in the object tree, if they need to move during
runtime, for example.</span>
</p>

<p>
Finally, we use this by reading in numbers and pushing them into the aggregate
approver, counting the number of approved plans in the local variable <code>_i</code>.
</p>

<p><label>In[22]:</label></p><div>
<pre><span>while</span> (_n &lt; 1000) {
    <span>! </span><span>Try to read another line of input.</span>
    <span>! </span><span>Stop if there is no more input.</span>
    _next = read_line(rbuf);
    <span>if</span> (rbuf-&gt;_next == 0) <span>break</span>;

    <span>while</span> (rbuf-&gt;_next &gt; 0) {
        <span>! </span><span>Extract a number from the input.</span>
        _next = long_read(rbuf, _next, ax);
        _next = skip_nodig(rbuf, _next);

        <span>! </span><span>Truncate long integer into short integer</span>
        <span>! </span><span>and send it to the aggregate approver.</span>
        multi_approver.append(long_trunc(ax));

    }

    <span>! </span><span>If the reports are still safe now,</span>
    <span>! </span><span>increment count and then reset.</span>
    <span>if</span> (multi_approver <span>has</span> valid) _i++;
    multi_approver.reset();
}
</pre>
</div>

<p>
The puzzle input for this day fits comfortably in the Z-machine short integers,
but since we already had a method for parsing numbers that happens to produce a
long integer, we might as well use it and then truncate it to a short integer.
</p>

<p>
The next half of that day’s puzzle sounds like it would need expensive
backtracking unless done cleverly, and I’m all out of clever for this article,
so I’ll stop here. At this point, I feel fairly done with Inform 6 for Advent of
Code problems. I’ve toyed with the system and gotten a much better understanding
of it. I’m reminded of why I don’t do more low-level programming: it’s a fun
challenge, to be sure, but when I write code I do it mainly for the result, not
for the challenge. If I want a mental challenge, I’d much rather play the game
of go or something.
</p>
</div>
</section>
<section id="outline-container-why-learn-inform-6">

<div id="text-org5e9bd50">
<p>
Now why, if I don’t like low-level programming, would I do this in the first
place? Great question!
</p>

<p>
A little while ago <a href="https://entropicthoughts.com/lessons-from-creating-first-text-adventure.html">I learned Inform 7</a>, which I’m not entirely happy with. I like
the rule-based approach, but I strongly dislike the syntax. I started looking
into Inform 6 as an alternative. While Inform 7 comes as one, relatively opaque
package, Inform 6 is split into two parts:
</p>

<ul>
<li>The Inform 6 language, which compiles down to Z-machine bytecode and looks
relatively sensible, as we have seen in this article; and</li>

<li>The Inform 6 standard library, which acts as text adventure engine framework,
providing basic interactions and world model.</li>
</ul>

<p>
This means we can learn the Inform 6 language in isolation, separate from its
standard library!
</p>

<p>
If there’s anything I’ve learned about learning new systems, it’s that it’s
useful to pull them apart and see exactly where the boundaries between their
parts go. Exactly where does the Z-machine stop, and Inform 6 take over? Exactly
where does Inform 6 stop, and the standard library take over? Incredibly useful
to be able to answer those questions, but it’s hard if we try to learn the
entire system as one unit. This article, then, was pulling the Inform 6 language
apart from its standard library, and learning the where the boundaries go.
</p>

<p>
Something else that’s cool about this separation is that instead of including
the standard library, we can include <i>any other</i> library to provide our basic
interactions and world model. I, for example, have been eyeing <a href="https://github.com/johanberntsson/PunyInform/">PunyInform</a>, which
is compatible with version 3 of the Z-machine. That seems like a useful creative
constraint. Version 3 only supports a maximum of 255 objects. If I can’t make a
good game with 255 objects, it is <i>not</i> going to help to give myself more
objects to hang myself with.
</p>

<p>
Wouldn’t this mean low-level programming? Not quite. With the addition of a
standard library (either the one that used to ship with Inform 6, or an
alternative like PunyInform), the Inform 6 language becomes much higher level –
at least when trying to make text adventures.
</p>

<p>
Well, we’ll see. There’s a PunyInform competition starting soon and ending in
November. If I can produce a game in time for that, I’ll let you know. If you
hear nothing, I didn’t.
</p>
</div>
</section>
<section id="outline-container-acknowledgements">

<p>
Many thanks to the members of <a href="https://intfiction.org/">the IntFiction forums</a> for pointing out errors in a
draft of this article.
</p>
</section>

            </div></div>
  </body>
</html>
