<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jiby.tech/project/literate_wordle/wordle.html">Original</a>
    <h1>Wordle in Python using literate programming</h1>
    
    <div id="readability-page-1" class="page"><div role="main" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="literate-programming-wordle">

<p>Rendering the <code><span>wordle.org</span></code> file as webpage and including in the docs as-is,
because the Sphinx documentation generator doesn’t understand org-mode files, so
we couldn’t render this page directly from Sphinx the usual way.</p>

<!--?xml version="1.0" encoding="utf-8"?-->



<!-- 2022-05-08 Sun 02:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wordle</title>
<meta name="author" content="Jb Doyon"/>
<meta name="generator" content="Org Mode"/>



<div id="content">


<p>
I’ve recently written <a href="https://jiby.tech/post/gherkin-features-user-requirements/">a series of blog posts about Gherkin</a>, the <a href="https://jiby.tech/post/bdd-dreams-cucumber-and-gherkin/">Behaviour-driven
development movement,</a> and how Cucumber (the BDD tool of choice) failed to
perform to expectations.
</p>

<p>
I wanted to showcase the BDD-inspired low-tech solution I came up with via a
toy project, demonstrating a small but significant programming task, broken down
as series of design-implementation cycles.
</p>

<p>
Wordle is a perfect target: it’s a small codebase, with a half dozen features to
string together into a useable game.
</p>

<p>
In order to document the process, the code is written via literate programming.
</p>

<blockquote>
<p>
Literate programming is the art of writing code as if it was a novel (or blogpost), writing down what’s needed, explaining the reasoning, and weaving in code snippets that add up to the codebase as we grow in understanding. The result is a “story” which can be read, but also “tangled” back into a proper codebase that works normally.
</p>
</blockquote>

<p>
For more context on the code repository (how to use, etc), please read the project
readme.
</p>

<p>
See also the online, pretty rendered version of this document on my personal
website: <a href="https://jiby.tech/project/literate_wordle/wordle.html">https://jiby.tech/project/literate_wordle/wordle.html</a>
</p>

<div id="outline-container-org9dd13b7">
<h2 id="org9dd13b7"><span>1.</span> Mise en bouche: picking an answer</h2>
<div id="text-1">
<p>
To get us started, let’s cover the very first behaviour Wordle has to do: pick a
word that will become our secret answer.
</p>

<p>
As the first iteration in a test-driven project, it’s important that we set up
all the components we’ll need going forwards.
</p>

<p>
First, let’s formalise a little our first requirement, using Gherkin Features.
For context as to why/how we’re doing this, read <a href="https://jiby.tech/post/gherkin-features-user-requirements/">my post on gathering
requirements via Gherkin.</a>
</p>

<div>
<p><label><span>Listing 1: </span>Our first requirement. Tangled (exported) to <code>features/pick_answer_word.feature</code></label></p><pre id="orgc0c22fc"><span>Feature:</span><span> Pick an answer word</span>
  As a Wordle game
  I need to pick a random 5 letter word
  In order to let players guess it
</pre>
</div>

<p>
Right. That’s fairly straightforward, but the secret word can’t just be random
characters, it needs to be a proper word. So we need to find a dictionary to
pick from.
</p>
</div>

<div id="outline-container-org1e8636e">
<h3 id="org1e8636e"><span>1.1.</span> TDD for picking word functionality</h3>
<div id="text-1-1">
<p>
We want to write a test that validates that we can indeed pick a random word. But “Random” and “test” together should make anybody wince at the idea of
non-deterministic testing.
</p>

<p>
We <i>could</i> write a test that picks a word, then confirm the word came
from the dictionary file, but writing test would mean re-implementing the entirety of the
feature we’re testing, as well as rely on the internals of the implementation
being correct. That’s very wrong.
</p>

<p>
A good alternative would be to pin down the randomness (making the test
deterministic) by anchoring the randomness seed to known value, allowing
repeatable testing. But this is just the first test in a new project, so we want a
simple check to start with, so we compromise by making the assertion “is the
random word picked of five letter length”?
</p>

<p>
So we write down a new test file, under <code>tests/</code> folder, starting with a
file-level docstring that references the Gherkin feature this enforces.
</p>

<div>
<p><label><span>Listing 2: </span>Test driving the first feature. Note the <code>pick_answer_word()</code> function doesn’t exist yet, we’re dreaming it up!</label></p><pre><span>&#34;&#34;&#34;Validates the Gherkin file features/pick_answer_word.feature:</span>

<span>Feature: Pick an answer word</span>
<span>  As a Wordle game</span>
<span>  I need to pick a random 5 letter word</span>
<span>  In order to let players guess it</span>
<span>&#34;&#34;&#34;</span>

<span>from</span> literate_wordle.words <span>import</span> pick_answer_word


<span>def</span> <span>test_pick_word_ok_length</span><span>()</span>:
    <span>&#34;&#34;&#34;Confirm a wordle solution is of right size&#34;&#34;&#34;</span>
    <span>assert</span> <span>len</span><span>(</span>pick_answer_word<span>()</span><span>)</span> == <span>5</span>, <span>&#34;Picked wordle solution is wrong size!&#34;</span>
</pre>
</div>

<p>
Of course, since that feature isn’t implemented (not even the module’s
skeleton), running tests right now would crash as import errors, rather than
give a red light.
</p>

<p>
So let’s implement the barest hint of the <code>pick_answer_word</code> function that
returns the wrong thing, to make the test run and fail:
</p>

<div>
<p><label><span>Listing 3: </span>First, the docstring for a new python module <code>words.py</code>, under the <code>literate_wordle</code> package.</label></p><pre><span>&#34;&#34;&#34;Dictionary features to back wordle solutions&#34;&#34;&#34;</span>
</pre>
</div>

<p>
In that module, let’s add the skeleton for our <code>pick_answer_word</code> function, but
return an invalid result, to make test explicitly fail:
</p>

<div>
<pre><span>def</span> <span>pick_answer_word</span><span>()</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Pick a Wordle solution/answer from wordle dictionary&#34;&#34;&#34;</span>
    <span>return</span> <span>&#34;&#34;</span>  <span># </span><span>Incorrect solution to get RED test</span>
</pre>
</div>

<p>
With our test ready, and a dummy function in place, let’s see the tests go red:
</p>

<div>
<p><label><span>Listing 4: </span>Running the tests.</label></p><pre><span>make</span> test
</pre>
</div>

<pre id="org08294e1">poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, datadir-1.3.1, clarity-1.0.1
collecting ... collected 2 items

tests/test_pick_word.py::test_pick_word_ok_length FAILED                 [ 50%]
tests/test_version.py::test_version PASSED                               [100%]

=================================== FAILURES ===================================
___________________________ test_pick_word_ok_length ___________________________

    def test_pick_word_ok_length():
        &#34;&#34;&#34;Confirm a wordle solution is of right size&#34;&#34;&#34;
&gt;       assert len(pick_answer_word()) == 5, &#34;Picked wordle solution is wrong size!&#34;
E       AssertionError: Picked wordle solution is wrong size!
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         0
E         5
E

tests/test_pick_word.py:13: AssertionError
- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -
=========================== short test summary info ============================
FAILED tests/test_pick_word.py::test_pick_word_ok_length - AssertionError: Pi...
========================= 1 failed, 1 passed in 0.07s ==========================
make: *** [Makefile:16: test] Error 1
</pre>

<p>
As pytest mentions, we should see a wordle solution of 5 letters, not zero.
So the test indeed failed as expected, we can now make it pass by implementing
the feature.
</p>

<p>
Taking a quick step back, think of how conveniently TDD lets us “dream up an
API”, by describing functions and files that don’t need to exist yet.
</p>
</div>
</div>

<div id="outline-container-orgc56ad81">
<h3 id="orgc56ad81"><span>1.2.</span> Solutions dictionary file</h3>
<div id="text-1-2">
<p>
Since we’re trying to match the Wordle website’s implementation, let’s reuse
Wordle’s own dictionary. Someone <a href="https://raw.githubusercontent.com/AllValley/WordleDictionary/main/wordle_solutions_alphabetized.txt">helpfully uploaded it</a>. Let’s download it:
</p>

<div>
<pre>wget <span>\</span>
    --output-document <span>&#34;wordle_answers_dict.txt&#34;</span> <span>\</span>
    <span>&#34;https://raw.githubusercontent.com/AllValley/WordleDictionary/6f14d2f03d01c36fe66e3ccc0929394251ab139d/wordle_solutions_alphabetized.txt&#34;</span>
</pre>
</div>

<p>
Except an alphabetically sorted text file takes space for no good reason. Let’s
compress it preventively.
</p>

<p>
While this can legitimately be seen as a premature optimization, we can see this
as trying to “flatten” a static text file into a binary “asset” that can be
packaged into the project’s package, like icons are part of webapps.
</p>

<div>
<pre><span>ANSWERS_FILE</span>=<span>&#34;wordle_answers_dict.txt&#34;</span>
<span># </span><span>Get raw file size in kilobytes</span>
du -k <span>&#34;</span><span>$</span><span>{ANSWERS_FILE}</span><span>&#34;</span>
<span># </span><span>Compress the file (removes original)</span>
gzip <span>&#34;</span><span>$</span><span>ANSWERS_FILE</span><span>&#34;</span>
<span># </span><span>Check size after compression</span>
du -k <span>&#34;</span><span>$</span><span>{ANSWERS_FILE}</span><span>.gz&#34;</span>
</pre>
</div>

<pre>16	wordle_answers_dict.txt
8	wordle_answers_dict.txt.gz
</pre>


<p>
Sweet, we have cut down the filesize by half.
</p>
</div>
</div>

<div id="outline-container-orgbb4d6ed">
<h3 id="orgbb4d6ed"><span>1.3.</span> Importing dictionary: static/packaged asset file read</h3>
<div id="text-1-3">
<p>
At first glance, the implementation of the function we want is simple, it looks
roughly like this:
</p>

<div>
<pre><span>with</span> <span>open</span><span>(</span><span>&#34;my_dictionary.txt&#34;</span>, <span>&#34;r&#34;</span><span>)</span> <span>as</span> fd:
    <span>my_text</span> = fd.read<span>()</span>
</pre>
</div>

<p>
One just needs to find the right file path to open, just add sprinkles to deal
with compression. Sure enough, that is fairly easy.
</p>

<p>
The issue is that we’re trying to write a python package here, which means it could
be downloaded via <code>pip install</code> and installed in an arbitary location on
someone’s computer. Our code needs to refer to the file as “the file XYZ inside
the assets folder of our package”. We need to look up how to express that.
</p>

<p>
From <a href="https://stackoverflow.com/a/20885799">Stackoverflow on reading static files from inside Python package</a>, we can
use the <code>importlib.resources</code> module, since our project requires <code>Python  3.9</code> onwards.
</p>

<p>
So we’ll move our dictionary zip file into a new module (folder) called
<code>assets</code>, which will be a proper python module that can be imported from:
</p>

<div>
<p><label><span>Listing 5: </span>Moving our dictionary to the new <code>assets</code> sub-module.</label></p><pre><span>mkdir</span> -p src/literate_wordle/assets/
<span># </span><span>A proper python module means an __init__.py: Give it a docstring</span>
<span>echo</span> <span>&#39;&#34;&#34;&#34;Static binary assets (dictionaries) required to perform Wordle&#34;&#34;&#34;&#39;</span> &gt; src/literate_wordle/assets/__init__.py
<span>mv</span> wordle_answers_dict.txt.gz src/literate_wordle/
</pre>
</div>

<p>
With the file in correct position, let’s redefine the <code>words</code> module we left empty, to provide the <code>pick_answer_word</code> function.
</p>

<div>
<p><label><span>Listing 6: </span>Defining new python module under <code>src/literate_wordle/words.py</code>, starting with docstrings.</label></p><pre id="org67cf411"><span>&#34;&#34;&#34;Dictionary features to back wordle solutions&#34;&#34;&#34;</span>
</pre>
</div>

<div>
<p><label><span>Listing 7: </span>Necessary imports from the standard library.</label></p><pre id="orgc83adf5"><span>import</span> gzip
<span>import</span> importlib.resources <span>as</span> pkg_resources
</pre>
</div>

<div>
<p><label><span>Listing 8: </span>Local import of new <code>assets/</code> folder</label></p><pre id="org921a353"><span>from</span> . <span>import</span> assets  <span># </span><span>Relative import of the assets/ folder</span>
</pre>
</div>

<p>
We need a convenience function to load the zip file into a list of strings.
</p>



<div>
<p><label><span>Listing 9: </span>Actual function to unzip dictionary. Note newline-delimited words now lowercased into a list-of-word strings with no trailing whitespace</label></p><pre id="orgb8ef945"><span>def</span> <span>get_words_list</span><span>()</span> -&gt; <span>list</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Decompress the wordle dictionary&#34;&#34;&#34;</span>
    <span>dict_compressed_bytes</span> = pkg_resources.read_binary<span>(</span>
        assets, <span>&#34;wordle_answers_dict.txt.gz&#34;</span>
    <span>)</span>
    <span>dict_string</span> = gzip.decompress<span>(</span>dict_compressed_bytes<span>)</span>.decode<span>(</span><span>&#34;ascii&#34;</span><span>)</span>
    <span>answer_word_list</span> = <span>[</span>word.strip<span>()</span>.lower<span>()</span>.strip<span>()</span> <span>for</span> word <span>in</span> dict_string.split<span>(</span><span>&#34;\n&#34;</span><span>)</span><span>]</span>
    <span>return</span> answer_word_list
</pre>
</div>

<p>
Ideally we would make a test dedicated for proving this function, but our
already-failing acceptance test is pretty much covering this entire feature, so
it’s not worth it just now. This is one of those tradeoffs we make between toy
projects and long-term maintainability of code as a team.
</p>

<p>
With the word list in hand, writing out the pick function is trivial:
</p>

<div>
<p><label><span>Listing 10: </span>Import from standard library for randomness</label></p><pre id="orgd2ed21d"><span>from</span> random <span>import</span> choice
</pre>
</div>

<div>
<p><label><span>Listing 11: </span>Pick-a-word! Pretty simple, with all the legwork we did already.</label></p><pre id="org031965d"><span>def</span> <span>pick_answer_word</span><span>()</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Pick a single word out of the dictionary of answers&#34;&#34;&#34;</span>
    <span>return</span> choice<span>(</span>get_words_list<span>()</span><span>)</span>
</pre>
</div>

<p>
With the function implemented, we can try it out in a Python REPL (Read Eval
Print Loop, also known as an interactive interpreter):
</p>

<div>
<p><label><span>Listing 12: </span>Open an interactive python session, ask for a random word twice.</label></p><pre>poetry run python3
&gt;&gt; from literate_wordle import words
&gt;&gt; print<span>(</span>words.pick_answer_word<span>()</span><span>)</span>
stink
&gt;&gt; print<span>(</span>words.pick_answer_word<span>()</span><span>)</span>
blank
</pre>
</div>

<p>
Perfect! So the test should now pass, right?
</p>



<pre id="orgf2cd48b">poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, datadir-1.3.1, clarity-1.0.1
collecting ... collected 2 items

tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [ 50%]
tests/test_version.py::test_version PASSED                               [100%]

- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -
============================== 2 passed in 0.03s ===============================
</pre>

<p>
Acceptance tests pass, and linters are happy (not pictured, use <code>make</code> to
check).
</p>

<p>
Because the acceptance test pass, that means the feature is ready to ship!
That’s the BDD guarantee.
</p>

<p>
Of course, keen readers will notice sub-optimal code, like how we’re unzipping
the entire solutions file on each requested answer. Because “picking a solution
word” is something done on the order of <i>once</i> over the <i>entire runtime</i> of a
Wordle session, we choose to leave this performance wart be.
</p>
</div>
</div>

<div id="outline-container-org3136e0c">
<h3 id="org3136e0c"><span>1.4.</span> Debriefing on the method</h3>
<div id="text-1-4">
<p>
We just completed our first loop: determine a small component that needs
implemented to build towards the Wordle goal, spell it out with Gherkin features,
explicit the feature via acceptance test, and iterate on the new RED test until it becomes
green, then ship the feature.
</p>

<p>
Common TDD workflow adds a refactor or “blue” component to the cycle, which is
indeed necessary for production code, as it lends maintainability (the first
draft of a codebase is usually taking big shortcuts). But this project is
meant as entertainment material, and proper refactoring would mean refactoring the <code>wordle.org</code>
source file, which would drown out the nice narrative we’re building here, so
let’s leave it here.
</p>

<p>
Along the way, the code blocks spelled out in this narrative-oriented file is
tangled out into proper code paths, so that the <code>Makefile</code> can pick it up and
validate the proper package-ness. We’ll see as we implement the next feature how
such a weaving of code snippets works.
</p>
</div>
</div>
</div>


<div id="outline-container-orgc225357">
<h2 id="orgc225357"><span>2.</span> Confirming guess is a valid word</h2>
<div id="text-2">
<p>
Now that we can pick secret words, we need to start processing guesses. The very
first thing we need is validating guesses are proper words, and of the right
size. This feature will give us a familiar context (dictionaries), while slowly
ramping up the details of the Gherkin features:
</p>

<div>
<p><label><span>Listing 13: </span>New Gherkin feature file <code>features/checking_guess_valid_word.feature</code></label></p><pre id="org11b4540"><span>Feature:</span><span> Checking a guess is a valid word</span>
  As a Wordle game
  I need to confirm each guessed word is valid
  So that I only accept real words, no kwyjibo
</pre>
</div>

<p>
In practice, this means multiple things:
</p>

<div>
<p><label><span>Listing 14: </span>Scenarios to describe the feature in details</label></p><pre id="org390c27b"><span>Scenario:</span><span> Reject long words</span>
<span>  When</span> guessing <span>&#34;affable&#34;</span>
<span>  Then</span> the guess is rejected
<span>  And</span> reason for rejection is <span>&#34;Guess too long&#34;</span>

<span>Scenario:</span><span> Reject short words</span>
<span>  When</span> guessing <span>&#34;baby&#34;</span>
<span>  Then</span> the guess is rejected
<span>  And</span> reason for rejection is <span>&#34;Guess too short&#34;</span>

<span>Scenario:</span><span> Reject fake words via dictionary</span>
<span>  When</span> guessing <span>&#34;vbpdj&#34;</span>
<span>  Then</span> the guess is rejected
<span>  And</span> reason for rejection is <span>&#34;Not a word from the dictionary&#34;</span>

<span>Scenario:</span><span> Accept five letter dictionary words</span>
<span>  When</span> guessing <span>&#34;crane&#34;</span>
<span>  Then</span> the guess is accepted
</pre>
</div>

<p>
So, with a feature covering these scenarios, we can start laying out acceptance
tests.
</p>

<p>
Since I quite like to use the Gherkin feature file inside the
docstrings of Python tests, I’m going to take advantage of having already
written the feature above, to reference it, so I can template it out in code snippets:
</p>

<div>
<p><label><span>Listing 15: </span>New test file’s module-level docstring, using (invisible during rendering) templating to fill in the gherkin feature from Listing <a href="#org11b4540">13</a></label></p><pre id="orga4a1f6c"><span>&#34;&#34;&#34;Validates the Gherkin file features/checking_guess_valid_word.feature:</span>

<span>Feature: Checking a guess is a valid word</span>
<span>  As a Wordle game</span>
<span>  I need to confirm each guessed word is valid</span>
<span>  So that I only accept real words, no kwyjibo</span>
<span>&#34;&#34;&#34;</span>
</pre>
</div>

<p>
Just this once, I’ll show how the templating happens behind the scene:
</p>

<div>
<p><label><span>Listing 16: </span>Same code block as Listing <a href="#orga4a1f6c">15</a>, but without the magic templating enabled: each block with two chevrons around references a code block from above.</label></p><pre id="org1f5e487"><span>&#34;&#34;&#34;Validates the Gherkin file features/checking_guess_valid_word.feature:</span>

<span>&lt;&lt;feature-check-valid-guess&gt;&gt;</span>

<span>&lt;&lt;scenario-check-valid-guess&gt;&gt;</span>
<span>&#34;&#34;&#34;</span>
</pre>
</div>
</div>
<div id="outline-container-org33bf3fb">
<h3 id="org33bf3fb"><span>2.1.</span> Test setup</h3>
<div id="text-2-1">
<p>
With the feature described, let’s import our hypothetical test code
</p>

<div>
<p><label><span>Listing 17: </span>Import a new function we’ll be defining</label></p><pre id="org72bac6f"><span>from</span> literate_wordle.words <span>import</span> check_valid_word
</pre>
</div>

<div>
<p><label><span>Listing 18: </span>A simple test using the first scenario</label></p><pre id="org0eb7818"><span>def</span> <span>test_reject_long_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Reject long words&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;affable&#34;</span>
    <span>guess</span> = <span>&#34;affable&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is rejected</span>
    <span>assert</span> <span>not</span> is_valid, <span>&#34;Overly long guess should have been rejected&#34;</span>
    <span># </span><span>And reason for rejection is &#34;Guess too long&#34;</span>
    <span>assert</span> reject_reason == <span>&#34;Guess too long&#34;</span>
</pre>
</div>

<p>
Notice the pattern of referencing the Gherkin Scenario as comments inside the
test. This practice is something I came up with on my own after being a bit
disappointed with Cucumber. You can read more about it in <a href="https://jiby.tech/post/low-tech-cucumber-replacement/">my post on low-tech
cucumber replacement</a>.
</p>

<div>
<p><label><span>Listing 19: </span>The opposite test, text too short</label></p><pre id="org9bd02b6"><span>def</span> <span>test_reject_overly_short_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Reject short words&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;baby&#34;</span>
    <span>guess</span> = <span>&#34;baby&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is rejected</span>
    <span>assert</span> <span>not</span> is_valid, <span>&#34;Overly short guess should have been rejected&#34;</span>
    <span># </span><span>And reason for rejection is &#34;Guess too short&#34;</span>
    <span>assert</span> reject_reason == <span>&#34;Guess too short&#34;</span>
</pre>
</div>

<p>
And finally, the dictionary checks:
</p>

<div>
<p><label><span>Listing 20: </span>Non-dictionary words test</label></p><pre id="orgd2878f2"><span>def</span> <span>test_reject_nondict_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Reject fake words via dictionary&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;vbpdj&#34;</span>
    <span>guess</span> = <span>&#34;vbpdj&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is rejected</span>
    <span>assert</span> <span>not</span> is_valid, <span>&#34;Word not in dictionary should have been rejected&#34;</span>
    <span># </span><span>And reason for rejection is &#34;Not a word from the dictionary&#34;</span>
    <span>assert</span> reject_reason == <span>&#34;Not a word from the dictionary&#34;</span>
</pre>
</div>


<div>
<p><label><span>Listing 21: </span>Dictionary words test</label></p><pre id="orged1cc3b"><span>def</span> <span>test_accept_dict_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Accept five letter dictionary words&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;crane&#34;</span>
    <span>guess</span> = <span>&#34;crane&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is accepted</span>
    <span>assert</span> is_valid, <span>&#34;Correct length word in dictionary should have been accepted&#34;</span>
</pre>
</div>

<p>
One tiny detail regarding this last example, which highlights why separating
Gherkin from actual code is important: We describe in the positive scenario the
need to accept a correct word in terms of “not rejecting”, which in code maps to
the <code>is_valid</code> boolean. That’s suffficient to validate the originalGherkin
scenario, which is what we think of when designing the software.
</p>

<p>
But as we see in the implementation, there’s also the matter of the
<code>reject_reason</code> component, which we should check for emptiness. That emptiness is an
implementation detail, which has no reason to be laid out in the original
scenario, but is still valid to make assertions on as part of the
implementation’s check. So we add the following line to the test:
</p>

<div>
<p><label><span>Listing 22: </span>Appended line to Listing <a href="#orged1cc3b">21</a>. Doesn’t map back to Gherkin, because it is an implementation detail, not part of the feature’s requirement itself. Still worth checking, in practice.</label></p><pre id="orgf84786c">    <span>assert</span> reject_reason <span>is</span> <span>None</span>, <span>&#34;Accepted word should have no reason to be rejected&#34;</span>
</pre>
</div>

<p>
With all these (high level) tests in hand, let’s write up some small
implementation to get RED tests instead of a crash.
</p>

<p>
First up is defining the function’s signature: Simple enough, we take a string guess
in, and return a boolean and a string for justification. Except sometimes (as
seen in Listing <a href="#orgf84786c">22</a>) the reason is <code>None</code>, so that’s more of an
<code>Optional</code> string, which we’ll need to import.
</p>

<div>
<p><label><span>Listing 23: </span>Import type hints for function type definition</label></p><pre id="org6f2d9f0"><span>from</span> typing <span>import</span> Optional
</pre>
</div>

<div>
<p><label><span>Listing 24: </span>Function signature without its content</label></p><pre id="org025dc96"><span>def</span> <span>check_valid_word</span><span>(</span>guess: <span>str</span><span>)</span> -&gt; <span>tuple</span><span>[</span><span>bool</span>, Optional<span>[</span><span>str</span><span>]</span><span>]</span>:
</pre>
</div>


<div>
<p><label><span>Listing 25: </span>Fill the function, to give valid-but-nonsensical output</label></p><pre id="orge9bb86f">    <span>&#34;&#34;&#34;Pretends to check if guess is a valid word&#34;&#34;&#34;</span>
    <span>return</span> <span>False</span>, <span>&#34;Not implemented&#34;</span>
</pre>
</div>

<p>
All right, so we have tests, let’s see them fail!
</p>

<div>
<p><label><span>Listing 26: </span>Run the tests. The <code>2&gt;&amp;1 || true</code> part is to ensure any failed test’s output goes to stdout (in this document) and bad exit codes don’t get marked as failures of the code block’s execution.</label></p><pre id="org99d8d22"><span>make</span> test <span>2</span>&gt;&amp;<span>1</span> || true
</pre>
</div>

<pre id="orgd3985d1">poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 5 items

tests/test_checking_guess_valid_word.py::test_reject_long_words FAILED   [ 20%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words FAILED [ 40%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words FAILED [ 60%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words FAILED   [ 80%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [100%]

=================================== FAILURES ===================================
____________________________ test_reject_long_words ____________________________

    def test_reject_long_words():
        &#34;&#34;&#34;Scenario: Reject long words&#34;&#34;&#34;
        # When guessing &#34;affable&#34;
        guess = &#34;affable&#34;
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
        assert not is_valid, &#34;Overly long guess should have been rejected&#34;
        # And reason for rejection is &#34;Guess too long&#34;
&gt;       assert reject_reason == &#34;Guess too long&#34;
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         Not implemented
E         Guess too long
E

tests/test_checking_guess_valid_word.py:39: AssertionError
________________________ test_reject_overly_short_words ________________________

    def test_reject_overly_short_words():
        &#34;&#34;&#34;Scenario: Reject short words&#34;&#34;&#34;
        # When guessing &#34;baby&#34;
        guess = &#34;baby&#34;
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
        assert not is_valid, &#34;Overly short guess should have been rejected&#34;
        # And reason for rejection is &#34;Guess too short&#34;
&gt;       assert reject_reason == &#34;Guess too short&#34;
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         Not implemented
E         Guess too short
E

tests/test_checking_guess_valid_word.py:50: AssertionError
__________________________ test_reject_nondict_words ___________________________

    def test_reject_nondict_words():
        &#34;&#34;&#34;Scenario: Reject fake words via dictionary&#34;&#34;&#34;
        # When guessing &#34;vbpdj&#34;
        guess = &#34;vbpdj&#34;
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
        assert not is_valid, &#34;Word not in dictionary should have been rejected&#34;
        # And reason for rejection is &#34;Not a word from the dictionary&#34;
&gt;       assert reject_reason == &#34;Not a word from the dictionary&#34;
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         Not implemented
E         Not a word from the dictionary
E

tests/test_checking_guess_valid_word.py:61: AssertionError
____________________________ test_accept_dict_words ____________________________

    def test_accept_dict_words():
        &#34;&#34;&#34;Scenario: Accept five letter dictionary words&#34;&#34;&#34;
        # When guessing &#34;crane&#34;
        guess = &#34;crane&#34;
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is accepted
&gt;       assert is_valid, &#34;Correct length word in dictionary should have been accepted&#34;
E       AssertionError: Correct length word in dictionary should have been accepted
E       assert False

tests/test_checking_guess_valid_word.py:70: AssertionError
- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/words.py                14      0   100%
------------------------------------------------------------
TOTAL                                       15      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

=========================== short test summary info ============================
FAILED tests/test_checking_guess_valid_word.py::test_reject_long_words - asse...
FAILED tests/test_checking_guess_valid_word.py::test_reject_overly_short_words
FAILED tests/test_checking_guess_valid_word.py::test_reject_nondict_words - a...
FAILED tests/test_checking_guess_valid_word.py::test_accept_dict_words - Asse...
========================= 4 failed, 1 passed in 0.13s ==========================
make: *** [Makefile:16: test] Error 1
</pre>

<p>
Test failure as expected, and enjoy that 100% coverage!<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>
</p>
</div>
</div>

<div id="outline-container-orgecfd415">
<h3 id="orgecfd415"><span>2.2.</span> Implementing the feature, one test at a time</h3>
<div id="text-2-2">
<p>
Let’s implement the proper feature. First of all, we replace the function stub’s
body to do only guess-length checks, run tests against it. Since we implement
half the feature (by Scenarios), we should be seeing half as many tests fail as before.
</p>

<div>
<pre id="org8110185"><span>&#34;&#34;&#34;Check wordle guess length only, no dict checks&#34;&#34;&#34;</span>
<span>answer_length</span> = <span>5</span>
<span>guess_length</span> = <span>len</span><span>(</span>guess<span>)</span>
<span>if</span> guess_length &lt; answer_length:
    <span>return</span> <span>False</span>, <span>&#34;Guess too short&#34;</span>
<span>if</span> guess_length &gt; answer_length:
    <span>return</span> <span>False</span>, <span>&#34;Guess too long&#34;</span>
<span>return</span> <span>True</span>, <span>None</span>  <span># </span><span>No dictionary check</span>
</pre>
</div>


<div>
<p><label><span>Listing 27: </span>Similarly to Listing <a href="#org99d8d22">26</a>, run test without exiting on failure</label></p><pre id="org18f9a01"><span>make</span> test <span>2</span>&gt;&amp;<span>1</span> || true
</pre>
</div>

<pre id="orge8b6f2f">poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 5 items

tests/test_checking_guess_valid_word.py::test_reject_long_words PASSED   [ 20%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words PASSED [ 40%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words FAILED [ 60%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words PASSED   [ 80%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [100%]

=================================== FAILURES ===================================
__________________________ test_reject_nondict_words ___________________________

    def test_reject_nondict_words():
        &#34;&#34;&#34;Scenario: Reject fake words via dictionary&#34;&#34;&#34;
        # When guessing &#34;vbpdj&#34;
        guess = &#34;vbpdj&#34;
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
&gt;       assert not is_valid, &#34;Word not in dictionary should have been rejected&#34;
E       AssertionError: Word not in dictionary should have been rejected
E       assert not True

tests/test_checking_guess_valid_word.py:59: AssertionError
- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/words.py                19      0   100%
------------------------------------------------------------
TOTAL                                       20      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

=========================== short test summary info ============================
FAILED tests/test_checking_guess_valid_word.py::test_reject_nondict_words - A...
========================= 1 failed, 4 passed in 0.11s ==========================
make: *** [Makefile:16: test] Error 1
</pre>

<p>
Progress! Four of five tests pass<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup>, so we now need the dictionary.
</p>


<p>
Note that in Wordle’s original implementation, the list of possible solutions is
a subset of the word dictionary used for guess validation. We previously loaded
the answers, now we need the larger set of accepted words. While it does mean
there will be duplicate entries, we’re talking single-digit kilobytes, we can
afford that.
</p>

<p>
We fetch the dictionary like before:
</p>

<div>
<pre>wget <span>\</span>
    --output-document <span>&#34;src/literate_wordle/assets/wordle_accepted_words_dict.txt&#34;</span> <span>\</span>
    <span>&#34;https://raw.githubusercontent.com/AllValley/WordleDictionary/6f14d2f03d01c36fe66e3ccc0929394251ab139d/wordle_complete_dictionary.txt&#34;</span>
</pre>
</div>

<p>
And compress it too
</p>

<div>
<pre><span>ANSWERS_FILE</span>=<span>&#34;src/literate_wordle/assets/wordle_accepted_words_dict.txt&#34;</span>
du -k <span>&#34;</span><span>$</span><span>{ANSWERS_FILE}</span><span>&#34;</span>
gzip <span>&#34;</span><span>$</span><span>ANSWERS_FILE</span><span>&#34;</span>
du -k <span>&#34;</span><span>$</span><span>{ANSWERS_FILE}</span><span>.gz&#34;</span>
</pre>
</div>

<pre>92	src/literate_wordle/assets/wordle_accepted_words_dict.txt
36	src/literate_wordle/assets/wordle_accepted_words_dict.txt.gz
</pre>


<p>
This time is more like two thirds shaved off, sweet.
</p>

<p>
We reach to add a function for decompressing, but realize we wrote all this
before, except for a different filename. So let’s edit the zip extraction code
to be more generic.
</p>

<p>
One way this can be more generic is returning a <code>set</code> of strings, instead of the
previous <code>list</code>. This means we assume no ordering and use hash addressing,
rather than strict string ordering. After all, we will not iterate through the
list, as much as we want to randomly access entries, so the <code>set</code> will provide
benefits down the line.
</p>

<div>
<p><label><span>Listing 28: </span>Generic “unzip asset” function</label></p><pre id="orge3a3cdd"><span>def</span> <span>get_asset_zip_as_set</span><span>(</span>asset_filename: <span>str</span><span>)</span> -&gt; <span>set</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Decompress a file in assets module into a set of words, separated by newline&#34;&#34;&#34;</span>
    <span>compressed_bytes</span> = pkg_resources.read_binary<span>(</span>assets, asset_filename<span>)</span>
    <span>string</span> = gzip.decompress<span>(</span>compressed_bytes<span>)</span>.decode<span>(</span><span>&#34;ascii&#34;</span><span>)</span>
    <span>string_list</span> = <span>[</span>word.strip<span>()</span>.lower<span>()</span>.strip<span>()</span> <span>for</span> word <span>in</span> string.split<span>(</span><span>&#34;\n&#34;</span><span>)</span><span>]</span>
    <span>return</span> <span>set</span><span>(</span>string_list<span>)</span>
</pre>
</div>

<p>
In order to avoid hardcoded filenames, we yank out the file names and fetching
of files:
</p>
<div>
<p><label><span>Listing 29: </span>Magic strings defined as module-level constants</label></p><pre id="orgda433ae"><span>ANSWERS_FILENAME</span> = <span>&#34;wordle_answers_dict.txt.gz&#34;</span>
<span>ACCEPTED_FILENAME</span> = <span>&#34;wordle_accepted_words_dict.txt.gz&#34;</span>
</pre>
</div>

<div>
<p><label><span>Listing 30: </span>Wrappers to the specific files to grab</label></p><pre id="orgb6abed0"><span>def</span> <span>get_answers</span><span>()</span> -&gt; <span>set</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Grab the Wordle answers as a set of string words&#34;&#34;&#34;</span>
    <span>return</span> get_asset_zip_as_set<span>(</span>ANSWERS_FILENAME<span>)</span>


<span>def</span> <span>get_accepted_words</span><span>()</span> -&gt; <span>set</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Grab the Wordle accepted words dictionary as a set of string words&#34;&#34;&#34;</span>
    <span>return</span> get_asset_zip_as_set<span>(</span>ACCEPTED_FILENAME<span>)</span>
</pre>
</div>


<p>
And now we can use the dictionary as a set in our <code>check_valid_word</code> function:
</p>

<div>
<p><label><span>Listing 31: </span>Use the dictionary as a set to check <code>if guess in dictionary</code></label></p><pre id="orga285541"><span>&#34;&#34;&#34;Check a wordle guess is valid: length and in dictionary&#34;&#34;&#34;</span>
<span>answer_length</span> = <span>5</span>
<span>guess_length</span> = <span>len</span><span>(</span>guess<span>)</span>
<span>if</span> guess_length &lt; answer_length:
    <span>return</span> <span>False</span>, <span>&#34;Guess too short&#34;</span>
<span>if</span> guess_length &gt; answer_length:
    <span>return</span> <span>False</span>, <span>&#34;Guess too long&#34;</span>
<span>valid_words_dict</span> = get_accepted_words<span>()</span>
<span>if</span> guess <span>in</span> valid_words_dict:
    <span>return</span> <span>True</span>, <span>None</span>
<span>return</span> <span>False</span>, <span>&#34;Not a word from the dictionary&#34;</span>
</pre>
</div>

<p>
Small performance note: Having a <code>set</code> of strings means <code>guess in answers_set</code> comparison is
<code>O(1)</code> (instead of <code>O(n)</code> on dictionary size for <code>list</code>), because the
hash-addressing of <code>set</code> is a <code>O(1)</code> operation. On very very long list of words,
iterating through it could be expensive, hence using <code>set</code> for lookup if we
don’t need sequential access.
</p>


<p>
We changes the invocation of <code>pick_answer_word</code> to use the new functions too
</p>

<div>
<p><label><span>Listing 32: </span>Pick-a-word, revisited to use generic asset unzipping function. Note that <code>choice</code> needs an iterable object, hence convert back to list</label></p><pre id="org2c17513"><span>def</span> <span>pick_answer_word</span><span>()</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Pick a single word out of the dictionary of answers&#34;&#34;&#34;</span>
    <span>return</span> choice<span>(</span><span>list</span><span>(</span>get_answers<span>()</span><span>)</span><span>)</span>
</pre>
</div>

<p>
And we’re done! Let’s run our system through <code>make</code> again, to spot test failures
but also to get linters:
</p>



<pre id="org8a90ef9">poetry install
Installing dependencies from lock file

No dependencies to install or update

Installing the current project: literate_wordle (0.1.0)
pre-commit run --all --all-files
Emacs export org-mode file to static HTML................................Passed
Trim Trailing Whitespace.................................................Passed
Fix End of Files.........................................................Passed
Check for added large files..............................................Passed
Check that executables have shebangs.................(no files to check)Skipped
Check for case conflicts.................................................Passed
Check vcs permalinks.....................................................Passed
Forbid new submodules....................................................Passed
Mixed line ending........................................................Passed
Check for merge conflicts................................................Passed
Detect Private Key.......................................................Passed
Check Toml...............................................................Passed
Check Yaml...............................................................Passed
Check JSON...........................................(no files to check)Skipped
black....................................................................Passed
isort (python)...........................................................Passed
mypy.....................................................................Passed
flake8...................................................................Passed
cd docs &amp;&amp; make html
make[1]: Entering directory &#39;/home/jiby/dev/ws/short/literate_wordle/docs&#39;
Running Sphinx v4.4.0
Read in collections ...
  wordle_html_export_filecopy: Initialised
  gherkin_features_foldercopy: Initialised
  gherkin_features_jinja: Initialised
Clean collections ...
  gherkin_features_foldercopy: (CopyFolderDriver) Folder deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_features/
  gherkin_features_jinja: (JinjaDriver) Cleaning 1 jinja Based file/s ...
Executing collections ...
  wordle_html_export_filecopy: (CopyFileDriver) Copy file...
  gherkin_features_foldercopy: (CopyFolderDriver) Copy folder...
  gherkin_features_jinja: (JinjaDriver) Creating 1 file/s from Jinja template...
loading pickled environment... done
[autosummary] generating autosummary for: _collections/gherkin_feature.md, index.rst, readme.md, wordle.md, wordle_sources.md
[AutoAPI] Reading files... [ 33%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/__init__.py
[AutoAPI] Reading files... [ 66%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/words.py
[AutoAPI] Reading files... [100%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/assets/__init__.py

[AutoAPI] Mapping Data... [ 33%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/__init__.py
[AutoAPI] Mapping Data... [ 66%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/words.py
[AutoAPI] Mapping Data... [100%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/assets/__init__.py

[AutoAPI] Rendering Data... [ 33%] literate_wordle
[AutoAPI] Rendering Data... [ 66%] literate_wordle.words
[AutoAPI] Rendering Data... [100%] literate_wordle.assets

myst v0.15.2: MdParserConfig(renderer=&#39;sphinx&#39;, commonmark_only=False, enable_extensions=[&#39;dollarmath&#39;], dmath_allow_labels=True, dmath_allow_space=True, dmath_allow_digits=True, dmath_double_inline=False, update_mathjax=True, mathjax_classes=&#39;tex2jax_process|mathjax_process|math|output_area&#39;, disable_syntax=[], url_schemes=[&#39;http&#39;, &#39;https&#39;, &#39;mailto&#39;, &#39;ftp&#39;], heading_anchors=2, heading_slug_func=None, html_meta=[], footnote_transition=True, substitutions=[], sub_delimiters=[&#39;{&#39;, &#39;}&#39;], words_per_minute=200)
building [mo]: targets for 0 po files that are out of date
building [html]: targets for 5 source files that are out of date
updating environment: 0 added, 7 changed, 0 removed
reading sources... [ 14%] _collections/gherkin_feature
reading sources... [ 28%] autoapi/index
reading sources... [ 42%] autoapi/literate_wordle/assets/index
reading sources... [ 57%] autoapi/literate_wordle/index
reading sources... [ 71%] autoapi/literate_wordle/words/index
reading sources... [ 85%] wordle
reading sources... [100%] wordle_sources

Copying static files for sphinx-needs datatables support.../home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables_loader.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/sphinx_needs_collapse.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/JSZip-2.5.0/jszip.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.print.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.flash.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.html5.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.colVis.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/dataTables.buttons.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.html5.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/common.scss /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/mixins.scss /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/buttons.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/swf/flashExport.swf /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/js/jquery.dataTables.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/css/jquery.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_asc.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_desc_disabled.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_asc_disabled.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_both.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_desc.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/ColReorder-1.4.1/js/dataTables.colReorder.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/ColReorder-1.4.1/css/colReorder.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedColumns-3.2.4/js/dataTables.fixedColumns.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedColumns-3.2.4/css/fixedColumns.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Scroller-1.4.4/js/dataTables.scroller.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Scroller-1.4.4/css/scroller.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedHeader-3.1.3/js/dataTables.fixedHeader.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedHeader-3.1.3/css/fixedHeader.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Responsive-2.2.1/js/dataTables.responsive.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Responsive-2.2.1/css/responsive.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/pdfmake-0.1.32/pdfmake.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/pdfmake-0.1.32/vfs_fonts.js
Copying static files for sphinx-needs custom style support...[ 25%] common.css
Copying static files for sphinx-needs custom style support...[ 50%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/layouts.css
Copying static files for sphinx-needs custom style support...[ 75%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/styles.css
Copying static files for sphinx-needs custom style support...[100%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/modern.css

looking for now-outdated files... none found
pickling environment... done
checking consistency... /home/jiby/dev/ws/short/literate_wordle/docs/source/autoapi/index.rst: WARNING: document isn&#39;t included in any toctree
done
preparing documents... done
writing output... [ 12%] _collections/gherkin_feature
writing output... [ 25%] autoapi/index
writing output... [ 37%] autoapi/literate_wordle/assets/index
writing output... [ 50%] autoapi/literate_wordle/index
writing output... [ 62%] autoapi/literate_wordle/words/index
writing output... [ 75%] index
writing output... [ 87%] wordle
writing output... [100%] wordle_sources

/home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_feature.md:34: WARNING: Any IDs not assigned for table node
generating indices... genindex py-modindex done
highlighting module code... [ 50%] literate_wordle
highlighting module code... [100%] literate_wordle.words

writing additional pages... search done
copying images... [ 50%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/images/feather_svg/arrow-down-circle.svg
copying images... [100%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/images/feather_svg/arrow-right-circle.svg

copying static files... done
copying extra files... done
dumping search index in English (code: en)... done
dumping object inventory... done
build succeeded, 2 warnings.

The HTML pages are in build/html.
Final clean of collections ...
  wordle_html_export_filecopy: (CopyFileDriver) File deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/_static/wordle.html
  gherkin_features_foldercopy: (CopyFolderDriver) Folder deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_features/
  gherkin_features_jinja: (JinjaDriver) Cleaning 1 jinja Based file/s ...
  gherkin_features_jinja: (JinjaDriver)   File deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_feature.md

Checking sphinx-needs warnings
make[1]: Leaving directory &#39;/home/jiby/dev/ws/short/literate_wordle/docs&#39;
poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 5 items

tests/test_checking_guess_valid_word.py::test_reject_long_words PASSED   [ 20%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words PASSED [ 40%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words PASSED [ 60%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words PASSED   [ 80%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [100%]

- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/words.py                23      0   100%
------------------------------------------------------------
TOTAL                                       24      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

============================== 5 passed in 0.09s ===============================
poetry build
Building literate_wordle (0.1.0)
  - Building sdist
  - Built literate_wordle-0.1.0.tar.gz
  - Building wheel
  - Built literate_wordle-0.1.0-py3-none-any.whl
</pre>

<p>
Tests pass, coverage stays strong, and linters are quiet, this is great!
</p>
</div>
</div>

<div id="outline-container-org22e205e">
<h3 id="org22e205e"><span>2.3.</span> Performance trick</h3>
<div id="text-2-3">
<p>
We mentioned before that the whole dictionary would get unzipped on every
request for assets. Now we’re validating guessed words, we may want to be
processing guesses quite often, certainly quicker than one would pick secret
words!
</p>

<p>
What we want to make all this fast, is to cache the unzipped dictionary,
so that repeated calls to the function <code>get_asset_zip_as_set</code> don’t bother with
file open and unzip, just serve the few hundred kilobytes content from memory again. There’s a handy python decorator that does the trick! Let’s
add <code>functools.cache</code> on top of our slow function:
</p>


<div>
<p><label><span>Listing 33: </span>Import the cache function</label></p><pre id="org8f4fd5a"><span>from</span> functools <span>import</span> cache
</pre>
</div>



<div>
<p><label><span>Listing 34: </span>Decorator to make a function use cache</label></p><pre id="orgfc28427"><span>@cache</span>
</pre>
</div>

<p>
After rerunning our tests, we now have a (theoretically) faster function, yey!
</p>

<p>
Remember that we committed a couple of performance/optimization sins just then,
by both: optimizing prematurely (with no proof of slowness), and by doing
optimization without using profiling information to optimize, we very likely
just optimized something that isn’t our bottleneck. I’m fine with that, I just
wanted to showcase this cool decorator, which functions like an unbounded
memoizer. Let’s see quick performance numbers of before/after:
</p>

<div>
<p><label><span>Listing 35: </span>Before cacheing, running 5 batches of a thousand double-dict-unzip</label></p><pre id="orgecf0619">poetry run python3 -m timeit -v -n <span>1000</span> --setup <span>&#34;from literate_wordle.words import pick_answer_word, check_valid_word&#34;</span> <span>&#34;check_valid_word(pick_answer_word())&#34;</span>
</pre>
</div>

<pre>raw times: 2.75 sec, 2.72 sec, 2.73 sec, 2.73 sec, 2.72 sec

1000 loops, best of 5: 2.72 msec per loop
</pre>


<p>
And after cacheing:
</p>

<pre>raw times: 17.1 msec, 12.8 msec, 12.6 msec, 12.8 msec, 12.4 msec

1000 loops, best of 5: 12.4 usec per loop
</pre>


<p>
That’s a two orders of magnitude gain for a single line of code changed. Sweet.
</p>
</div>
</div>

<div id="outline-container-org93951c5">
<h3 id="org93951c5"><span>2.4.</span> Bug!</h3>
<div id="text-2-4">
<p>
Doing some exploration of the accepted/answer word sets, I noticed an issue:
</p>

<div>
<p><label><span>Listing 36: </span>Count word size in each dictionary</label></p><pre><span>from</span> literate_wordle.words <span>import</span> get_answers, get_accepted_words

<span>answer_lengths</span> = <span>[</span><span>len</span><span>(</span>word<span>)</span> <span>for</span> word <span>in</span> <span>list</span><span>(</span>get_answers<span>()</span><span>)</span><span>]</span>
<span>accepted_lengths</span> = <span>[</span><span>len</span><span>(</span>word<span>)</span> <span>for</span> word <span>in</span> <span>list</span><span>(</span>get_accepted_words<span>()</span><span>)</span><span>]</span>

<span>print</span><span>(</span><span>set</span><span>(</span>answer_lengths<span>)</span><span>)</span>
<span>print</span><span>(</span><span>set</span><span>(</span>accepted_lengths<span>)</span><span>)</span>
</pre>
</div>

<pre>{0, 5}
{0, 5}
</pre>


<p>
Each have a 0-length words, in other word, the empty string.
</p>

<p>
This is likely a classic issue due to DOS line endings, the last line of the
file is only a carriage return, which is technically whitespace, and the call to
<code>strip()</code> removes it, leaving an empty space item in the list.
</p>

<p>
If this was a proper production issue we just discovered, we would first turn
the above snippet into a proper test case (asserting no 0 length word exist,
seeing it be red), commit that, raise it as bug, and work on a fix. But this
code hasn’t reached production yet, and the bug itself is minor enough to not
warrant that during our exploration phase.
</p>

<p>
We can fix this multiple ways. We <i>could</i> make the <code>get_accepted_words</code> and
<code>get_answers</code> functions change their behaviours (either via set operations to
remove the empty item from the set, returning <code>set(words) - set([&#34;&#34;])</code>, or more
likely removing empty entries during iteration), but that wouldn’t prevent
future users of the buggy function <code>get_asset_zip_as_set</code> to get the same issue.
</p>

<p>
So let’s fix it at the root, the <code>get_asset_zip_as_set</code> function:
</p>

<div>
<p><label><span>Listing 37: </span>Generic “unzip asset” function, filtering the whitespace-only words</label></p><pre id="org16a05cf"><span>def</span> <span>get_asset_zip_as_set</span><span>(</span>asset_filename: <span>str</span><span>)</span> -&gt; <span>set</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Decompress a file in assets module into a set of words, separated by newline&#34;&#34;&#34;</span>
    <span>compressed_bytes</span> = pkg_resources.read_binary<span>(</span>assets, asset_filename<span>)</span>
    <span>string</span> = gzip.decompress<span>(</span>compressed_bytes<span>)</span>.decode<span>(</span><span>&#34;ascii&#34;</span><span>)</span>
    <span>string_list</span> = <span>[</span>word.strip<span>()</span>.lower<span>()</span>.strip<span>()</span> <span>for</span> word <span>in</span> string.split<span>(</span><span>&#34;\n&#34;</span><span>)</span><span>]</span>
    <span># </span><span>Protect against whitespace-only lines during file-read causing empty stripped word</span>
    <span>non_empty_words</span> = <span>[</span>word <span>for</span> word <span>in</span> string_list <span>if</span> <span>len</span><span>(</span>word<span>)</span> != <span>0</span><span>]</span>
    <span>return</span> <span>set</span><span>(</span>non_empty_words<span>)</span>
</pre>
</div>

<p>
This was a good opportunity to play with List Comprehensions with filters, yey.
</p>
</div>
</div>

<div id="outline-container-orge7bc56a">
<h3 id="orge7bc56a"><span>2.5.</span> Tangle out all the code</h3>
<div id="text-2-5">
<p>
The last section of each heading of this document is used for internal purposes.
The Code snippets defined above are usually out of order, especially the
imports, or functions defined once as stubs, then re-defined with proper
implementation.
</p>

<p>
To avoid having nonsense python file ordering, with import-feature-import-feature
sequences, which formatters would go crazy over, we define below the reordered
code blocks as they should be output, using the <code>noweb</code> feature of org-mode.
This lets us reference code blocks above by name, tangle out into the
proper files with proper ordering and spacing as one would expect a real
codebase to look like.
</p>

<p>
This means we need to manually weave the code blocks, instead of pointing them
all to the same file and rely on code snippet’s top-to-bottom order, we now have
an explicit code block where we template out “add this bit, now 2 lines below
add that snippet, and then…”. This isn’t super pretty, but it gives complete
control over layout like number of lines jumped between functions, which was
blocking adoption of the formatter “black” in this repository.
</p>

<p>
First, fix <code>words.py</code> imports being out of order in our narrative by tangling
them via noweb to weave the part 1 imports with the part 2. This means <code>isort</code>
(import sorter<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup>) is now happy and won’t thrash these python files.
Also insert the cache decorator before the assets function, and substitute the
<code>check_valid_word</code> function body with the real implementation instead of the
dummy function defined initially.
</p>

<div>
<p><label><span>Listing 38: </span>The final version of <code>words.py</code>. Note that behind the scene this code block has 0 code, just references to other code block named above.</label></p><pre id="org3399360"><span>&#34;&#34;&#34;Dictionary features to back wordle solutions&#34;&#34;&#34;</span>

<span>import</span> gzip
<span>import</span> importlib.resources <span>as</span> pkg_resources
<span>from</span> functools <span>import</span> cache
<span>from</span> random <span>import</span> choice
<span>from</span> typing <span>import</span> Optional

<span>from</span> . <span>import</span> assets  <span># </span><span>Relative import of the assets/ folder</span>

<span>ANSWERS_FILENAME</span> = <span>&#34;wordle_answers_dict.txt.gz&#34;</span>
<span>ACCEPTED_FILENAME</span> = <span>&#34;wordle_accepted_words_dict.txt.gz&#34;</span>


<span>def</span> <span>get_answers</span><span>()</span> -&gt; <span>set</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Grab the Wordle answers as a set of string words&#34;&#34;&#34;</span>
    <span>return</span> get_asset_zip_as_set<span>(</span>ANSWERS_FILENAME<span>)</span>


<span>def</span> <span>get_accepted_words</span><span>()</span> -&gt; <span>set</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Grab the Wordle accepted words dictionary as a set of string words&#34;&#34;&#34;</span>
    <span>return</span> get_asset_zip_as_set<span>(</span>ACCEPTED_FILENAME<span>)</span>


<span>@cache</span>
<span>def</span> <span>get_asset_zip_as_set</span><span>(</span>asset_filename: <span>str</span><span>)</span> -&gt; <span>set</span><span>[</span><span>str</span><span>]</span>:
    <span>&#34;&#34;&#34;Decompress a file in assets module into a set of words, separated by newline&#34;&#34;&#34;</span>
    <span>compressed_bytes</span> = pkg_resources.read_binary<span>(</span>assets, asset_filename<span>)</span>
    <span>string</span> = gzip.decompress<span>(</span>compressed_bytes<span>)</span>.decode<span>(</span><span>&#34;ascii&#34;</span><span>)</span>
    <span>string_list</span> = <span>[</span>word.strip<span>()</span>.lower<span>()</span>.strip<span>()</span> <span>for</span> word <span>in</span> string.split<span>(</span><span>&#34;\n&#34;</span><span>)</span><span>]</span>
    <span># </span><span>Protect against whitespace-only lines during file-read causing empty stripped word</span>
    <span>non_empty_words</span> = <span>[</span>word <span>for</span> word <span>in</span> string_list <span>if</span> <span>len</span><span>(</span>word<span>)</span> != <span>0</span><span>]</span>
    <span>return</span> <span>set</span><span>(</span>non_empty_words<span>)</span>


<span>def</span> <span>pick_answer_word</span><span>()</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Pick a single word out of the dictionary of answers&#34;&#34;&#34;</span>
    <span>return</span> choice<span>(</span><span>list</span><span>(</span>get_answers<span>()</span><span>)</span><span>)</span>


<span>def</span> <span>check_valid_word</span><span>(</span>guess: <span>str</span><span>)</span> -&gt; <span>tuple</span><span>[</span><span>bool</span>, Optional<span>[</span><span>str</span><span>]</span><span>]</span>:
    <span>&#34;&#34;&#34;Check a wordle guess is valid: length and in dictionary&#34;&#34;&#34;</span>
    <span>answer_length</span> = <span>5</span>
    <span>guess_length</span> = <span>len</span><span>(</span>guess<span>)</span>
    <span>if</span> guess_length &lt; answer_length:
        <span>return</span> <span>False</span>, <span>&#34;Guess too short&#34;</span>
    <span>if</span> guess_length &gt; answer_length:
        <span>return</span> <span>False</span>, <span>&#34;Guess too long&#34;</span>
    <span>valid_words_dict</span> = get_accepted_words<span>()</span>
    <span>if</span> guess <span>in</span> valid_words_dict:
        <span>return</span> <span>True</span>, <span>None</span>
    <span>return</span> <span>False</span>, <span>&#34;Not a word from the dictionary&#34;</span>
</pre>
</div>

<p>
Now the same thing with the tests file, which indeed <i>is</i> in proper order
already, but would benefit from two-lines-between-tests to guarantee formatting:
</p>

<div>
<p><label><span>Listing 39: </span>Final version of <code>tests/test_checking_guess_valid_word.py</code></label></p><pre id="org717f6ae"><span>from</span> literate_wordle.words <span>import</span> check_valid_word


<span>def</span> <span>test_reject_long_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Reject long words&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;affable&#34;</span>
    <span>guess</span> = <span>&#34;affable&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is rejected</span>
    <span>assert</span> <span>not</span> is_valid, <span>&#34;Overly long guess should have been rejected&#34;</span>
    <span># </span><span>And reason for rejection is &#34;Guess too long&#34;</span>
    <span>assert</span> reject_reason == <span>&#34;Guess too long&#34;</span>


<span>def</span> <span>test_reject_overly_short_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Reject short words&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;baby&#34;</span>
    <span>guess</span> = <span>&#34;baby&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is rejected</span>
    <span>assert</span> <span>not</span> is_valid, <span>&#34;Overly short guess should have been rejected&#34;</span>
    <span># </span><span>And reason for rejection is &#34;Guess too short&#34;</span>
    <span>assert</span> reject_reason == <span>&#34;Guess too short&#34;</span>


<span>def</span> <span>test_reject_nondict_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Reject fake words via dictionary&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;vbpdj&#34;</span>
    <span>guess</span> = <span>&#34;vbpdj&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is rejected</span>
    <span>assert</span> <span>not</span> is_valid, <span>&#34;Word not in dictionary should have been rejected&#34;</span>
    <span># </span><span>And reason for rejection is &#34;Not a word from the dictionary&#34;</span>
    <span>assert</span> reject_reason == <span>&#34;Not a word from the dictionary&#34;</span>


<span>def</span> <span>test_accept_dict_words</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Accept five letter dictionary words&#34;&#34;&#34;</span>
    <span># </span><span>When guessing &#34;crane&#34;</span>
    <span>guess</span> = <span>&#34;crane&#34;</span>
    <span>is_valid</span>, <span>reject_reason</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span># </span><span>Then the guess is accepted</span>
    <span>assert</span> is_valid, <span>&#34;Correct length word in dictionary should have been accepted&#34;</span>
    <span>assert</span> reject_reason <span>is</span> <span>None</span>, <span>&#34;Accepted word should have no reason to be rejected&#34;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org82079c4">
<h2 id="org82079c4"><span>3.</span> Calculating guessed word’s score</h2>
<div id="text-3">
<p>
We can pick answer words, and we can check if a guess is a valid word, now we
have everything we need to score the guess! Let’s first define the overall
feature:
</p>

<div>
<pre id="orgfaf9832"><span>Feature:</span><span> Scoring guesses</span>
  As a Wordle game
  I need to tell the player how good their guess is
  In order to help them find the proper answer
</pre>
</div>

<p>
This sounds simple, but implementing this feature is tricky, because of edge
cases like multiple identical character in the answer, which need colored
appropriately (What’s the proper way to do that? No clue yet, but we need to pin
it down in requirements!). So again we’ll define Gherkin Scenarios for that
Feature, to give examples of how the feature works in practice. So we write out:
</p>

<div>
<p><label><span>Listing 40: </span>The winning guess scenario. The green blocks are Unicode characters, may render differently on your device.</label></p><pre id="orgbca24b6"><span>Scenario:</span><span> Perfect guess gives perfect score</span>
<span>  Given</span> a wordle answer <span>&#34;crane&#34;</span>
<span>  When</span> scoring the guess <span>&#34;crane&#34;</span>
<span>  Then</span> score should be <span>&#34;🟩🟩🟩🟩🟩&#34;</span>
</pre>
</div>

<p>
This seems easy enough, but we should notice that we’re assuming the
guess is a valid word! We may want to just add another <code>Given</code>, like:
</p>

<div>
<pre><span>Given</span> a guess that&#39;s a valid dictionary word
</pre>
</div>

<p>
But this isn’t just a hypothesis from the current scenario, it’s valid for all
scenarios of this feature: every scoring of a guess requires the guess to be a
valid word. To avoid the tedious copying of that assumption in each Scenario, we
can use a Gherkin Background for the feature:
</p>

<div>
<p><label><span>Listing 41: </span>Pre-condition that applies to all the scenarios of this feature file</label></p><pre id="org375b22e"><span>Background:</span>
<span>  Given</span> a guess that&#39;s a valid dictionary word
</pre>
</div>

<p>
Perfect, so now we’re assuming the guess is a valid word, which means a
dependency on having implemented the previous feature, but we’re not specifying
the guess word itself, which can still be scenario specific. This makes our
initial “perfect guess” scenario valid again, so we can use it
</p>

<p>
If we’ve got the perfect answer, let’s have the opposite:
</p>

<div>
<p><label><span>Listing 42: </span>Flunking out scenario</label></p><pre id="orge2c565a"><span>Scenario:</span><span> No character in common</span>
<span>  Given</span> a wordle answer <span>&#34;brave&#34;</span>
<span>  When</span> scoring the guess <span>&#34;skill&#34;</span>
<span>  Then</span> score should be <span>&#34;⬜⬜⬜⬜⬜&#34;</span>
</pre>
</div>

<p>
Note that these scenarios doesn’t make assumption of how many attempts at Wordle
we’re at, or the fact of winning or losing. This is purely a hypothetical
example, disjoint from the actual playing of a Wordle game. We can deal with the
win/lose consequences later, once we have a proper scoring of guesses implemented.
</p>
</div>


<div id="outline-container-org0d9e38d">
<h3 id="org0d9e38d"><span>3.1.</span> Can we start coding yet?</h3>
<div id="text-3-1">
<p>
At this point, we <i>can</i> conceivably start the implementation work: “let’s go, we
have work to do!” And we can add the “🟨” scenario later once we have code that
works.
</p>

<p>
The problem of “what to do now” is interesting, because we can continue thinking
up scenarios in Gherkin for a while, or we could make a start writing test code
to match these claims, fix the red tests, implement towards green tests, and add
scenarios as we realize that our implementation is lacking compared to the
original intent of the game. That can certainly be done!
</p>

<p>
But while it’s tempting to jump into code first, I strongly believe we as
developers should instead fully scope out the problem-space first. Pin down the
exact requirements (in that case via Gherkin features and scenarios), before
starting to touch any code. My reasoning is that <a href="https://jiby.tech/post/gherkin-features-user-requirements/">it’s very easy to get tunnel
vision when writing code, getting excited about the programming problems, losing
track of what the “user” wants. We should instead write down the exact user
needs first</a>, and have a proper “ritual” for switching our “User” hat to a
“Developer” hat.
</p>
</div>
</div>


<div id="outline-container-org116453b">
<h3 id="org116453b"><span>3.2.</span> Finalizing the scoring scenarios</h3>
<div id="text-3-2">
<p>
So, back to our gherkin scenarios, let’s add the yellow marker one:
</p>

<div>
<p><label><span>Listing 43: </span>Character in the wrong place score</label></p><pre id="org85975c5"><span>Scenario:</span><span> Character in wrong place</span>
<span>  Given</span> a wordle answer <span>&#34;rebus&#34;</span>
<span>  When</span> scoring the guess <span>&#34;skull&#34;</span>
<span>  Then</span> score should be <span>&#34;🟨⬜🟨⬜⬜&#34;</span>
</pre>
</div>

<p>
And just for having a good sample of tests with which to test, let’s use a table
of examples to confirm scoring works out in more cases:
</p>

<div>
<p><label><span>Listing 44: </span>Many examples via Gherkin Scenario Outlines and Examples</label></p><pre id="orgd7f736a"><span>Scenario Outline:</span><span> Scoring guesses</span>
<span>  Given</span> a wordle <span>&lt;answer&gt;</span>
<span>  When</span> scoring <span>&lt;guess&gt;</span>
<span>  Then</span> score should be <span>&lt;score&gt;</span>

<span># Emoji (Unicode) character rendering is hard:</span>
<span># Please forgive the table column alignment issues!</span>
<span>  Examples:</span> A few guesses and their score
<span>    | answer  | guess   | score     |</span>
<span>    | adage   | adobe   | 🟩🟩⬜⬜🟩 |</span>
<span>    | serif   | quiet   | ⬜⬜🟨🟨⬜ |</span>
<span>    | raise   | radix   | 🟩🟩⬜🟨⬜ |</span>
</pre>
</div>

<p>
Note how the “outline” system maps really well to the idea of “parametrized
tests”. We can write the test case <i>once</i>, and have a decorator deal with the
multiple instantiations with different data.
</p>

<p>
All right, that’s a few, moving on. But here is the most difficult to implement
corner case, written out as examples of the previous scenario:
</p>

<div>
<p><label><span>Listing 45: </span>Edge case: duplicate character in answer or guess</label></p><pre id="orgf878108"><span>  Examples:</span> Multiple occurences of same character
<span>    | answer | guess    | score     |</span>
<span>    | abbey  | kebab    | ⬜🟨🟩🟨🟨 |</span>
<span>    | abbey  | babes    | 🟨🟨🟩🟩⬜ |</span>
<span>    | abbey  | abyss    | 🟩🟩🟨⬜⬜ |</span>
<span>    | abbey  | algae    | 🟩⬜⬜⬜🟨 |</span>
<span>    | abbey  | keeps    | ⬜🟨⬜⬜⬜ |</span>
<span>    | abbey  | abate    | 🟩🟩⬜⬜🟨 |</span>
</pre>
</div>

<p>
Because this edge case was worrisome for accuracy, these sample answers and
scores were <a href="https://nerdschalk.com/wordle-same-letter-twice-rules-explained-how-does-it-work/">taken from online example screenshots</a> of the original Wordle
website, thus considered accurate references.
</p>

<p>
Thinking about it, with “abbey” as reference, the “kebab” answer seems logical,
with first “b” occurence matching as green, and the second being in the wrong
place. The surprise comes from “keeps” where the first “e” counts, but the
second doesn’t have an equivalent in the answer, hence flagged as “no such
character”. That makes sense, but that’s not how a naive implementation of the
game would do it! Hence why it’s worth thinking about the full problem before
rushing the implementation.
</p>


<p>
Out of curiosity, I wonder if there’s any wordle answers that contain three
identical characters? Let’s see!
</p>

<div>
<p><label><span>Listing 46: </span>Regular-expression search for 3 repeated characters in the dictionary of answers</label></p><pre>zgrep -i -E <span>&#34;([a-z]).*\1.*\1&#34;</span> <span>\</span>
    src/literate_wordle/assets/wordle_answers_dict.txt.gz <span>\</span>
    | wc -l
</pre>
</div>

<pre>20
</pre>


<p>
Really? 20? That’s harsh … show me one?
</p>

<div>
<p><label><span>Listing 47: </span>Reval the first answer with 3 identical letters</label></p><pre>zgrep -i -E <span>&#34;([a-z]).*\1.*\1&#34;</span> <span>\</span>
    src/literate_wordle/assets/wordle_answers_dict.txt.gz <span>\</span>
    | head -n <span>1</span> <span>\</span>
    | sed <span>&#39;s/\r//&#39;</span>  <span># </span><span>gets rid of CR characters in CRLF (DOS line endings)</span>
</pre>
</div>

<pre>bobby
</pre>


<p>
Interesting. That must be hard to solve I imagine.
</p>
</div>
</div>
<div id="outline-container-org8a87934">
<h3 id="org8a87934"><span>3.3.</span> Writing up acceptance tests</h3>
<div id="text-3-3">
<p>
With no more obvious pathological cases to cover in requirements, it’s time to
switch to our developer hat, and write some (acceptance) tests!
</p>

<div>
<p><label><span>Listing 48: </span>First acceptance test using “Perfect guess” scenario</label></p><pre id="org65eff90"><span>def</span> <span>test_perfect_guess</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Perfect guess gives perfect score&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer &#34;crane&#34;</span>
    <span>answer</span> = <span>&#34;crane&#34;</span>
    <span># </span><span>When scoring the guess &#34;crane&#34;</span>
    <span>our_guess</span> = <span>&#34;crane&#34;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &#34;🟩🟩🟩🟩🟩&#34;</span>
    <span>assert</span> score == <span>&#34;🟩🟩🟩🟩🟩&#34;</span>, <span>&#34;Perfect answer should give Perfect Score&#34;</span>
</pre>
</div>

<p>
A <code>score_guess</code> function? sounds reasonable. We’ll need to import it from a module…
</p>

<div>
<p><label><span>Listing 49: </span>Importing the newly thought-up function inside the test of Listing <a href="#org65eff90">48</a></label></p><pre id="org45c567f"><span>from</span> literate_wordle.guess <span>import</span> score_guess
</pre>
</div>

<p>
This means we now need to create such a module.
</p>

<div>
<p><label><span>Listing 50: </span>New <code>guess.py</code> module, starting with docstring</label></p><pre id="org564b82c"><span>&#34;&#34;&#34;Score guesses of Wordle game&#34;&#34;&#34;</span>
</pre>
</div>

<p>
We already defined most of the function (name, module, output), so let’s just
write a stub that will make tests go red.
</p>

<div>
<p><label><span>Listing 51: </span><code>score_guess</code> stub to see the tests go red</label></p><pre id="orgcdfe154"><span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess&#34;&#34;&#34;</span>
    <span>return</span> <span>&#34;⬜&#34;</span>
</pre>
</div>


<p>
Now the test should fail appropriately, let’s add a twist: we’ll mark the test
function as expected to fail, because for now it’s not been implemented. This
allows the test runner to mark all tests as OK despite known failures, and
is perfect for known bugs being worked on, or new features being built.
Imagine if every time we built new features via TDD, the commit that adds the
test first makes CI go red! No, we would rather have a nice “excuse” for this
new test to fail, and have the build stay green, “with an expected failure”.
</p>


<div>
<p><label><span>Listing 52: </span>Decorator marking a test as expected to fail, “excusing” assertion failures</label></p><pre id="org61a7430"><span>@pytest.mark.xfail</span><span>(</span>reason=<span>&#34;Not implemented yet&#34;</span><span>)</span>
</pre>
</div>

<p>
In the case of a known bug, the <code>reason</code> field would very likely be a bug
identifier in the organisation’s bug tracker.
</p>

<div>
<p><label><span>Listing 53: </span>Importing the pytest module to get the <code>pytest.mark.xfail</code> decorator</label></p><pre id="org04a4500"><span>import</span> pytest
</pre>
</div>

<p>
Confirm these tests work, marked as xfail (“eXpected FAILure”):
</p>



<pre id="orgfa08a14">poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 6 items

tests/test_checking_guess_valid_word.py::test_reject_long_words PASSED   [ 16%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words PASSED [ 33%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words PASSED [ 50%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words PASSED   [ 66%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [ 83%]
tests/test_scoring_guess.py::test_perfect_guess XFAIL (Not implement...) [100%]

- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/guess.py                 2      0   100%
src/literate_wordle/words.py                25      0   100%
------------------------------------------------------------
TOTAL                                       28      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

========================= 5 passed, 1 xfailed in 0.10s =========================
</pre>

<p>
Note that we now have regular tests that pass, and this one test that fails as expected, and
<code>pytest</code>, expecting it, doesn’t shout about the failure. Really handy.
</p>

<p>
Remember that “disabling” (marking as <code>pytest.mark.skip</code>) is different from
marking as <code>xfail</code>, because skipping a test avoids running it, while <code>xfail</code>
tests do run, the assertion failure is just not marked as critical. There’s even
a flag to make <code>xpass</code> (expected test failures that ended up being green) become
an actual fatal testing error, for the cases where it’s important to track the
failure itself.
</p>
</div>
</div>

<div id="outline-container-org670b008">
<h3 id="org670b008"><span>3.4.</span> More tests</h3>
<div id="text-3-4">
<p>
Let’s implement the rest of the failing tests, so we can make it all red, then
fix the implementation:
</p>

<div>
<p><label><span>Listing 54: </span>Second acceptance test using “no character in common” scenario</label></p><pre id="orgb24767c"><span>def</span> <span>test_no_common_character</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: No character in common&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer &#34;brave&#34;</span>
    <span>answer</span> = <span>&#34;brave&#34;</span>
    <span># </span><span>When scoring the guess &#34;skill&#34;</span>
    <span>our_guess</span> = <span>&#34;skill&#34;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &#34;⬜⬜⬜⬜⬜&#34;</span>
    <span>assert</span> score == <span>&#34;⬜⬜⬜⬜⬜&#34;</span>, <span>&#34;No character in common with answer should give 0 score&#34;</span>
</pre>
</div>


<div>
<p><label><span>Listing 55: </span>Third acceptance test using “Characters in wrong place” scenario</label></p><pre id="org26b3ab9"><span>def</span> <span>test_wrong_place</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Character in wrong place&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer &#34;rebus&#34;</span>
    <span>answer</span> = <span>&#34;rebus&#34;</span>
    <span># </span><span>When scoring the guess &#34;skull&#34;</span>
    <span>our_guess</span> = <span>&#34;skull&#34;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &#34;🟨⬜🟨⬜⬜&#34;</span>
    <span>assert</span> score == <span>&#34;🟨⬜🟨⬜⬜&#34;</span>, <span>&#34;Characters are in the wrong place&#34;</span>
</pre>
</div>

<p>
That covers the first three scenarios.
</p>

<p>
For the Scenario Outline, it’s interesting to notice that a pattern emerged,
which allows the same test skeleton to be reused with different data. In Pytest,
this can be done by “parametrizing” the test with multiple data entries.
</p>

<p>
This is a decorator to flag data, but since
we’re trying to group some of those tests as part of different groups, we will
use the <code>pytest.param.id</code> flag.
</p>

<div>
<p><label><span>Listing 56: </span>Generic acceptance test, without any data attached</label></p><pre id="org428b89e"><span>def</span> <span>test_generic_score</span><span>(</span>answer, our_guess, expected_score<span>)</span>:
    <span>&#34;&#34;&#34;Scenario Outline: Scoring guesses&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle &lt;answer&gt;</span>
    <span># </span><span>When scoring &lt;guess&gt;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &lt;score&gt;</span>
    <span>assert</span> score == expected_score
</pre>
</div>

<p>
Just need to fill in the parameters:
</p>
<div>
<p><label><span>Listing 57: </span>Parameters for generic test. Notice how <code>id</code> is used to cluster test data source, making <code>multi_occur</code> tests look separate to <code>normal_guess</code> ones.</label></p><pre id="org892ac55"><span>@pytest.mark.parametrize</span><span>(</span>
    <span>&#34;answer,our_guess,expected_score&#34;</span>,
    <span>[</span>
        pytest.param<span>(</span><span>&#34;adage&#34;</span>, <span>&#34;adobe&#34;</span>, <span>&#34;🟩🟩⬜⬜🟩&#34;</span>, <span>id</span>=<span>&#34;normal_guess1&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;serif&#34;</span>, <span>&#34;quiet&#34;</span>, <span>&#34;⬜⬜🟨🟨⬜&#34;</span>, <span>id</span>=<span>&#34;normal_guess2&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;raise&#34;</span>, <span>&#34;radix&#34;</span>, <span>&#34;🟩🟩⬜🟨⬜&#34;</span>, <span>id</span>=<span>&#34;normal_guess3&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;kebab&#34;</span>, <span>&#34;⬜🟨🟩🟨🟨&#34;</span>, <span>id</span>=<span>&#34;multi_occur1&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;babes&#34;</span>, <span>&#34;🟨🟨🟩🟩⬜&#34;</span>, <span>id</span>=<span>&#34;multi_occur2&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;abyss&#34;</span>, <span>&#34;🟩🟩🟨⬜⬜&#34;</span>, <span>id</span>=<span>&#34;multi_occur3&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;algae&#34;</span>, <span>&#34;🟩⬜⬜⬜🟨&#34;</span>, <span>id</span>=<span>&#34;multi_occur4&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;keeps&#34;</span>, <span>&#34;⬜🟨⬜⬜⬜&#34;</span>, <span>id</span>=<span>&#34;multi_occur5&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;abate&#34;</span>, <span>&#34;🟩🟩⬜⬜🟨&#34;</span>, <span>id</span>=<span>&#34;multi_occur6&#34;</span><span>)</span>,
    <span>]</span>,
<span>)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org66c56cb">
<h3 id="org66c56cb"><span>3.5.</span> Implementing the feature</h3>
<div id="text-3-5">
<p>
With the strong test harness we have, this scoring function can be done
conveniently.
</p>

<p>
Let’s experiment with the solution, iterating over naive solution and seeing how
close they get to implementing the feature, by number of tests failed. This
isn’t required, we have already identified edge cases that make naive solutions
break, but this is the fun experimenting part.
</p>

<p>
Before any actual code change, first we remove the “xfail” marker, so that test
failures actually notify us as failures, as we’re actually implementing things now.
</p>

<div>
<p><label><span>Listing 58: </span>A simple string matching by iterating over both lists at once</label></p><pre id="org4718395"><span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess naively&#34;&#34;&#34;</span>
    <span>NO</span> = <span>&#34;⬜&#34;</span>
    <span>OK</span> = <span>&#34;🟩&#34;</span>
    <span>response</span> = <span>&#34;&#34;</span>
    <span>for</span> answer_char, guess_char <span>in</span> <span>zip</span><span>(</span>answer, guess<span>)</span>:
        <span>if</span> answer_char == guess_char:
            <span>response</span> += OK
        <span>else</span>:
            <span>response</span> += NO
    <span>return</span> response
</pre>
</div>

<p>
That only passes 3 tests of the 12 we just defined, obviously because we don’t
deal with incorrect characters at all. So let’s add keeping track of characters
in the wrong places:
</p>

<div>
<p><label><span>Listing 59: </span>Keep track of all answer characters while iterating through both list</label></p><pre id="org20f8c6b"><span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess a little less naively&#34;&#34;&#34;</span>
    <span>NO</span> = <span>&#34;⬜&#34;</span>
    <span>OK</span> = <span>&#34;🟩&#34;</span>
    <span>WRONG_PLACE</span> = <span>&#34;🟨&#34;</span>
    <span>answer_chars_set</span> = <span>set</span><span>(</span><span>list</span><span>(</span>answer<span>)</span><span>)</span>
    <span>response</span> = <span>&#34;&#34;</span>
    <span>for</span> answer_char, guess_char <span>in</span> <span>zip</span><span>(</span>answer, guess<span>)</span>:
        <span>if</span> answer_char == guess_char:
            <span>response</span> += OK
        <span>elif</span> guess_char <span>in</span> answer_chars_set:
            <span>response</span> += WRONG_PLACE
        <span>else</span>:
            <span>response</span> += NO
    <span>return</span> response
</pre>
</div>

<p>
That version now passes 8 of 12 tests, with the issue being the multiple
occurence of the same character in the answer being treated wrong, clearly an
edge case we were fortunate to identify early.
</p>

<p>
Looking at the examples, it seems that our scoring function needs to keep track of how
many occurences of each characters of the answer exists overall, and grade only the
first occurence of such characters as “wrong place”, reducing the counter.
</p>

<p>
Fortunately, Python implements a good Counter function which we can import:
</p>

<div>
<p><label><span>Listing 60: </span>Import the <code>Counter</code> class, which generates a dictionary of <code>item</code> to <code>count</code> on whatever it’s given</label></p><pre id="org283c7ad"><span>from</span> collections <span>import</span> Counter
</pre>
</div>

<p>
We want something like this:
</p>

<div>
<pre><span>if</span> guess_char <span>in</span> answer_chars <span>and</span> answer_chars<span>[</span>guess_char<span>]</span> &gt; <span>0</span>:
    <span>response</span> += WRONG_PLACE
    <span># </span><span>Reduce occurence since we &#34;used&#34; this one</span>
    <span>answer_chars</span><span>[</span>guess_char<span>]</span> -= <span>1</span>
    <span># </span><span>No more hits = pretend character isn&#39;t even seen (remove from dict)</span>
    <span>if</span> answer_chars<span>[</span>guess_char<span>]</span> == <span>0</span>:
        <span>del</span> answer_chars<span>[</span>guess_char<span>]</span>
</pre>
</div>

<p>
So we try the Counter way
</p>

<div>
<p><label><span>Listing 61: </span>Use a <code>Counter</code> for character multiple occurences</label></p><pre id="org256e5b8"><span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess with Counter&#34;&#34;&#34;</span>
    <span>NO</span> = <span>&#34;⬜&#34;</span>
    <span>OK</span> = <span>&#34;🟩&#34;</span>
    <span>WRONG_PLACE</span> = <span>&#34;🟨&#34;</span>
    <span># </span><span>Counter(&#34;abbey&#34;) = Counter({&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;e&#39;: 1, &#39;y&#39;: 1})</span>
    <span>answer_chars</span> = Counter<span>(</span>answer<span>)</span>
    <span>response</span> = <span>&#34;&#34;</span>
    <span>for</span> answer_char, guess_char <span>in</span> <span>zip</span><span>(</span>answer, guess<span>)</span>:
        <span>if</span> answer_char == guess_char:
            <span>response</span> += OK
        <span>elif</span> guess_char <span>in</span> answer_chars <span>and</span> answer_chars<span>[</span>guess_char<span>]</span> &gt; <span>0</span>:
            <span>response</span> += WRONG_PLACE
            <span># </span><span>Reduce occurence since we &#34;used&#34; this one</span>
            <span>answer_chars</span><span>[</span>guess_char<span>]</span> -= <span>1</span>
            <span># </span><span>No more hits = pretend character isn&#39;t even seen (remove from dict)</span>
            <span>if</span> answer_chars<span>[</span>guess_char<span>]</span> == <span>0</span>:
                <span>del</span> answer_chars<span>[</span>guess_char<span>]</span>
        <span>else</span>:
            <span>response</span> += NO
    <span>return</span> response
</pre>
</div>

<p>
But while this improves the score, we are still 3 tests from success! Turns out
we only did the reduction of counter for yellow, not also greens. This needs a
bit of reshuffling:
</p>

<div>
<p><label><span>Listing 62: </span>Use a Counter, keeping track of both Green and Yellow</label></p><pre id="org0a5361b"><span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess with Counter&#34;&#34;&#34;</span>
    <span>NO</span> = <span>&#34;⬜&#34;</span>
    <span>OK</span> = <span>&#34;🟩&#34;</span>
    <span>WRONG_PLACE</span> = <span>&#34;🟨&#34;</span>
    <span># </span><span>Counter(&#34;abbey&#34;) = Counter({&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;e&#39;: 1, &#39;y&#39;: 1})</span>
    <span>answer_chars</span> = Counter<span>(</span>answer<span>)</span>
    <span>response</span> = <span>&#34;&#34;</span>
    <span>for</span> guess_char, answer_char <span>in</span> <span>zip</span><span>(</span>guess, answer<span>)</span>:
        <span>if</span> guess_char <span>not</span> <span>in</span> answer_chars:
            <span>response</span> += NO
            <span>continue</span>  <span># </span><span>Early exit for this character, skip to next</span>
        <span># </span><span>From here on, we MUST have a char in common, regardless of place</span>
        <span>if</span> answer_char == guess_char:
            <span>response</span> += OK
        <span>elif</span> answer_chars<span>[</span>guess_char<span>]</span> &gt; <span>0</span>:
            <span>response</span> += WRONG_PLACE
        <span># </span><span>Either way, reduce occurence counter since we &#34;used&#34; this occurence</span>
        <span>answer_chars</span><span>[</span>guess_char<span>]</span> -= <span>1</span>
        <span># </span><span>No more hits = pretend character isn&#39;t even seen (remove from dict)</span>
        <span>if</span> answer_chars<span>[</span>guess_char<span>]</span> == <span>0</span>:
            <span>del</span> answer_chars<span>[</span>guess_char<span>]</span>
    <span>return</span> response
</pre>
</div>


<p>
Now that we’re happy with this, we can refactor out the ugly hardcoded glyphs:
</p>

<div>
<p><label><span>Listing 63: </span>No more hardcoded glyphs</label></p><pre id="org8104a83"><span>class</span> <span>CharacterScore</span><span>(</span><span>str</span>, Enum<span>)</span>:
    <span>&#34;&#34;&#34;A single character&#39;s score&#34;&#34;&#34;</span>

    <span>OK</span> = <span>&#34;🟩&#34;</span>
    <span>NO</span> = <span>&#34;⬜&#34;</span>
    <span>WRONG_PLACE</span> = <span>&#34;🟨&#34;</span>
</pre>
</div>

<div>
<p><label><span>Listing 64: </span>Imports for the Enum</label></p><pre id="org413435b"><span>from</span> enum <span>import</span> Enum
</pre>
</div>

<p>
And to use it as part of our scoring function:
</p>

<div>
<p><label><span>Listing 65: </span>Refactored function to avoid magic glyphs</label></p><pre id="org8d5a966"><span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess with Counter&#34;&#34;&#34;</span>
    <span># </span><span>Counter(&#34;abbey&#34;) = Counter({&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;e&#39;: 1, &#39;y&#39;: 1})</span>
    <span>answer_chars</span> = Counter<span>(</span>answer<span>)</span>
    <span>response</span> = <span>&#34;&#34;</span>
    <span>for</span> guess_char, answer_char <span>in</span> <span>zip</span><span>(</span>guess, answer<span>)</span>:
        <span>if</span> guess_char <span>not</span> <span>in</span> answer_chars:
            <span>response</span> += CharacterScore.NO
            <span>continue</span>  <span># </span><span>Early exit for this character, skip to next</span>
        <span># </span><span>From here on, we MUST have a char in common, regardless of place</span>
        <span>if</span> answer_char == guess_char:
            <span>response</span> += CharacterScore.OK
        <span>elif</span> answer_chars<span>[</span>guess_char<span>]</span> &gt; <span>0</span>:
            <span>response</span> += CharacterScore.WRONG_PLACE
        <span># </span><span>Either way, reduce occurence counter since we &#34;used&#34; this occurence</span>
        <span>answer_chars</span><span>[</span>guess_char<span>]</span> -= <span>1</span>
        <span># </span><span>No more hits = pretend character isn&#39;t even seen (remove from dict)</span>
        <span>if</span> answer_chars<span>[</span>guess_char<span>]</span> == <span>0</span>:
            <span>del</span> answer_chars<span>[</span>guess_char<span>]</span>
    <span>return</span> response
</pre>
</div>
</div>
</div>



<div id="outline-container-orgdfc1f36">
<h3 id="orgdfc1f36"><span>3.6.</span> Tangle it all out</h3>
<div id="text-3-6">
<p>
As before, we reorder the blocks from snippets above to export code in a way
that keeps proper formatting.
</p>
<div>
<p><label><span>Listing 66: </span>Final <code>guess.py</code></label></p><pre id="org53f55be"><span>&#34;&#34;&#34;Score guesses of Wordle game&#34;&#34;&#34;</span>


<span>from</span> collections <span>import</span> Counter
<span>from</span> enum <span>import</span> Enum


<span>class</span> <span>CharacterScore</span><span>(</span><span>str</span>, Enum<span>)</span>:
    <span>&#34;&#34;&#34;A single character&#39;s score&#34;&#34;&#34;</span>

    <span>OK</span> = <span>&#34;🟩&#34;</span>
    <span>NO</span> = <span>&#34;⬜&#34;</span>
    <span>WRONG_PLACE</span> = <span>&#34;🟨&#34;</span>


<span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess with Counter&#34;&#34;&#34;</span>
    <span># </span><span>Counter(&#34;abbey&#34;) = Counter({&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;e&#39;: 1, &#39;y&#39;: 1})</span>
    <span>answer_chars</span> = Counter<span>(</span>answer<span>)</span>
    <span>response</span> = <span>&#34;&#34;</span>
    <span>for</span> guess_char, answer_char <span>in</span> <span>zip</span><span>(</span>guess, answer<span>)</span>:
        <span>if</span> guess_char <span>not</span> <span>in</span> answer_chars:
            <span>response</span> += CharacterScore.NO
            <span>continue</span>  <span># </span><span>Early exit for this character, skip to next</span>
        <span># </span><span>From here on, we MUST have a char in common, regardless of place</span>
        <span>if</span> answer_char == guess_char:
            <span>response</span> += CharacterScore.OK
        <span>elif</span> answer_chars<span>[</span>guess_char<span>]</span> &gt; <span>0</span>:
            <span>response</span> += CharacterScore.WRONG_PLACE
        <span># </span><span>Either way, reduce occurence counter since we &#34;used&#34; this occurence</span>
        <span>answer_chars</span><span>[</span>guess_char<span>]</span> -= <span>1</span>
        <span># </span><span>No more hits = pretend character isn&#39;t even seen (remove from dict)</span>
        <span>if</span> answer_chars<span>[</span>guess_char<span>]</span> == <span>0</span>:
            <span>del</span> answer_chars<span>[</span>guess_char<span>]</span>
    <span>return</span> response
</pre>
</div>

<div>
<p><label><span>Listing 67: </span>Final <code>tests/test_scoring_guess.py</code></label></p><pre id="org08882dc"><span>&#34;&#34;&#34;Validates the Gherkin file features/scoring_guess.feature:</span>

<span>Feature: Scoring guesses</span>
<span>  As a Wordle game</span>
<span>  I need to tell the player how good their guess is</span>
<span>  In order to help them find the proper answer</span>
<span>&#34;&#34;&#34;</span>

<span>import</span> pytest

<span>from</span> literate_wordle.guess <span>import</span> score_guess


<span>def</span> <span>test_perfect_guess</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Perfect guess gives perfect score&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer &#34;crane&#34;</span>
    <span>answer</span> = <span>&#34;crane&#34;</span>
    <span># </span><span>When scoring the guess &#34;crane&#34;</span>
    <span>our_guess</span> = <span>&#34;crane&#34;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &#34;🟩🟩🟩🟩🟩&#34;</span>
    <span>assert</span> score == <span>&#34;🟩🟩🟩🟩🟩&#34;</span>, <span>&#34;Perfect answer should give Perfect Score&#34;</span>


<span>def</span> <span>test_no_common_character</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: No character in common&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer &#34;brave&#34;</span>
    <span>answer</span> = <span>&#34;brave&#34;</span>
    <span># </span><span>When scoring the guess &#34;skill&#34;</span>
    <span>our_guess</span> = <span>&#34;skill&#34;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &#34;⬜⬜⬜⬜⬜&#34;</span>
    <span>assert</span> score == <span>&#34;⬜⬜⬜⬜⬜&#34;</span>, <span>&#34;No character in common with answer should give 0 score&#34;</span>


<span>def</span> <span>test_wrong_place</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Character in wrong place&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer &#34;rebus&#34;</span>
    <span>answer</span> = <span>&#34;rebus&#34;</span>
    <span># </span><span>When scoring the guess &#34;skull&#34;</span>
    <span>our_guess</span> = <span>&#34;skull&#34;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &#34;🟨⬜🟨⬜⬜&#34;</span>
    <span>assert</span> score == <span>&#34;🟨⬜🟨⬜⬜&#34;</span>, <span>&#34;Characters are in the wrong place&#34;</span>


<span>@pytest.mark.parametrize</span><span>(</span>
    <span>&#34;answer,our_guess,expected_score&#34;</span>,
    <span>[</span>
        pytest.param<span>(</span><span>&#34;adage&#34;</span>, <span>&#34;adobe&#34;</span>, <span>&#34;🟩🟩⬜⬜🟩&#34;</span>, <span>id</span>=<span>&#34;normal_guess1&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;serif&#34;</span>, <span>&#34;quiet&#34;</span>, <span>&#34;⬜⬜🟨🟨⬜&#34;</span>, <span>id</span>=<span>&#34;normal_guess2&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;raise&#34;</span>, <span>&#34;radix&#34;</span>, <span>&#34;🟩🟩⬜🟨⬜&#34;</span>, <span>id</span>=<span>&#34;normal_guess3&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;kebab&#34;</span>, <span>&#34;⬜🟨🟩🟨🟨&#34;</span>, <span>id</span>=<span>&#34;multi_occur1&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;babes&#34;</span>, <span>&#34;🟨🟨🟩🟩⬜&#34;</span>, <span>id</span>=<span>&#34;multi_occur2&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;abyss&#34;</span>, <span>&#34;🟩🟩🟨⬜⬜&#34;</span>, <span>id</span>=<span>&#34;multi_occur3&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;algae&#34;</span>, <span>&#34;🟩⬜⬜⬜🟨&#34;</span>, <span>id</span>=<span>&#34;multi_occur4&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;keeps&#34;</span>, <span>&#34;⬜🟨⬜⬜⬜&#34;</span>, <span>id</span>=<span>&#34;multi_occur5&#34;</span><span>)</span>,
        pytest.param<span>(</span><span>&#34;abbey&#34;</span>, <span>&#34;abate&#34;</span>, <span>&#34;🟩🟩⬜⬜🟨&#34;</span>, <span>id</span>=<span>&#34;multi_occur6&#34;</span><span>)</span>,
    <span>]</span>,
<span>)</span>
<span>def</span> <span>test_generic_score</span><span>(</span>answer, our_guess, expected_score<span>)</span>:
    <span>&#34;&#34;&#34;Scenario Outline: Scoring guesses&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle &lt;answer&gt;</span>
    <span># </span><span>When scoring &lt;guess&gt;</span>
    <span>score</span> = score_guess<span>(</span>our_guess, answer<span>)</span>
    <span># </span><span>Then score should be &lt;score&gt;</span>
    <span>assert</span> score == expected_score
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6e62444">
<h2 id="org6e62444"><span>4.</span> Playing a round of Wordle</h2>
<div id="text-4">
<p>
With all the subfeatures we have, we can now play a round of wordle, we’re
missing only the “state” of the game board, with the interactivity of the game.
</p>

<div>
<pre id="orgb1e8c8e"><span>Feature:</span><span> Track number of guesses</span>
  As a Wordle game
  I need to track how many guesses were already given
  In order to announce win or game over
</pre>
</div>

<p>
There are a few obvious cases we want to see:
</p>

<div>
<p><label><span>Listing 68: </span>Allow the first guess</label></p><pre id="org1f33a66"><span>Scenario:</span><span> First guess is allowed</span>
<span>  Given</span> a wordle answer
<span>  And</span> I didn&#39;t guess before
<span>  When</span> I guess the word
<span>  Then</span> my guess is scored
</pre>
</div>

<div>
<p><label><span>Listing 69: </span>Still allow the sixth guess (skipping 2 through 5)</label></p><pre id="orgd49d74f"><span>Scenario:</span><span> Sixth guess still allowed</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 5 times
<span>  When</span> I guess the word
<span>  Then</span> my guess is scored
</pre>
</div>

<div>
<p><label><span>Listing 70: </span>Sixth guess is last guess (fail on seventh)</label></p><pre id="org9641482"><span>Scenario:</span><span> Six failed guess is game over</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 6 times already
<span>  When</span> I guess the word
<span>  And</span> my guess isn&#39;t the answer
<span>  Then</span> my guess is scored
<span>  But</span> game shows <span>&#34;Game Over&#34;</span>
<span>  And</span> game shows the real answer
</pre>
</div>

<p>
This feature shows us all the state we need to manage to track a Wordle game:
</p>
<ul>
<li>an answer</li>
<li>the number of previous guesses</li>
<li>the previous guesses themselves? not needed after we print them</li>
<li>the previous guesses’ scores? not needed after we print it either</li>
</ul>

<p>
So a Wordle Game is the aggregate of “answer” + “number of guesses”, nothing
else.
</p>

<p>
Let’s write the test:
</p>

<div>
<p><label><span>Listing 71: </span>New <code>tests/test_track_guess_number.py</code> file with just feature’s docstring</label></p><pre id="orged88ca3"><span>&#34;&#34;&#34;Validates the Gherkin file features/track_guesses.feature</span>

<span>Feature: Playing a round</span>
<span>  As a Wordle game</span>
<span>  I need to track how many guesses were already given, stating wins/losses</span>
<span>  In order to play the game</span>
<span>&#34;&#34;&#34;</span>
</pre>
</div>

<div>
<p><label><span>Listing 72: </span>Test to track first guess</label></p><pre id="org1304f7c"><span>def</span> <span>test_first_guess_allowed</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: First guess is allowed&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I didn&#39;t guess before</span>
    <span>guess_number</span> = <span>0</span>
    <span>game</span> = WordleGame<span>(</span>answer=answer, guess_number=guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span>guess</span> = <span>&#34;kebab&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is scored</span>
    <span>OUTCOME_CONTINUE</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE
    <span>assert</span> result.outcome == OUTCOME_CONTINUE, <span>&#34;Game shouldn&#39;t be over yet&#34;</span>
    <span>assert</span> result.score <span>is</span> <span>not</span> <span>None</span>, <span>&#34;No score given as result&#34;</span>
    <span>assert</span> <span>len</span><span>(</span>result.score<span>)</span> == <span>5</span>, <span>&#34;Score of incorrect length&#34;</span>
    <span>ALLOWED_CHARS</span> = <span>[</span>score.value <span>for</span> score <span>in</span> Score<span>]</span>
    <span>assert</span> <span>all</span><span>(</span>
        char <span>in</span> ALLOWED_CHARS <span>for</span> char <span>in</span> <span>list</span><span>(</span>result.score<span>)</span>
    <span>)</span>, <span>&#34;Score doesn&#39;t match score&#39;s characters&#34;</span>
</pre>
</div>

<p>
In the test above, I’ve done quite a bit of world-building:
</p>
<ul>
<li>Used a new <code>WordleGame</code> structure keeping game state</li>
<li>Used a new <code>WordleMoveOutcome</code> enumeration to describe outcomes</li>
<li>Used a new <code>play_round</code> function that takes a game + guess</li>
<li>Implied in <code>result</code> variable at a structure for new Game state after a move</li>
</ul>

<div>
<p><label><span>Listing 73: </span>The other imports for the test of Listing <a href="#org1304f7c">72</a></label></p><pre id="orgebb0e26"><span>from</span> literate_wordle.game <span>import</span> WordleGame, WordleMoveOutcome, play_round
<span>from</span> literate_wordle.guess <span>import</span> CharacterScore <span>as</span> Score
</pre>
</div>


<p>
This practice of calling an API that doesn’t exist yet is the coolest part of
TDD, because the tests lend their power to help design what the software should
feel like, even if we have no idea how to create the backend to that API yet.
The focus on how the feature is <i>used</i> changes from the usual engineering
mindset of how we envision the backend, very valuable.
</p>

<p>
All right, so with that in mind, let’s start actually building these data
structures.
</p>

<div>
<p><label><span>Listing 74: </span>Enum for outcomes of a single move</label></p><pre id="org8283181"><span>class</span> <span>WordleMoveOutcome</span><span>(</span>Enum<span>)</span>:
    <span>&#34;&#34;&#34;Outcome of a single move&#34;&#34;&#34;</span>

    <span>GAME_OVER_LOST</span> = <span>1</span>
    <span>GAME_WON</span> = <span>2</span>
    <span>GUESS_SCORED_CONTINUE</span> = <span>3</span>
</pre>
</div>

<div>
<p><label><span>Listing 75: </span>Objects necessary to keep state of the game</label></p><pre id="org73411d5"><span>@dataclass</span>
<span>class</span> <span>WordleGame</span>:
    <span>&#34;&#34;&#34;A Wordle game&#39;s internal state, before a move is played&#34;&#34;&#34;</span>

    answer: <span>str</span>
    guess_number: <span>int</span>


<span>@dataclass</span>
<span>class</span> <span>WordleMove</span>:
    <span>&#34;&#34;&#34;A Wordle game state once a move is played&#34;&#34;&#34;</span>

    game: WordleGame
    outcome: WordleMoveOutcome
    message: <span>str</span>
    score: Optional<span>[</span><span>str</span><span>]</span>
</pre>
</div>

<div>
<p><label><span>Listing 76: </span>Imports for enumeration of state and data-holding classes of Listing <a href="#org8283181">74</a>,<a href="#org73411d5">75</a></label></p><pre id="orgcfe2cb1"><span>from</span> dataclasses <span>import</span> dataclass
<span>from</span> enum <span>import</span> Enum
<span>from</span> typing <span>import</span> Optional
</pre>
</div>

<p>
With the datastructures ready, we can define our function’s signature:
</p>

<div>
<pre id="org0014860"><span>def</span> <span>play_round</span><span>(</span>guess: <span>str</span>, game: WordleGame<span>)</span> -&gt; WordleMove:
    <span>&#34;&#34;&#34;Use guess on the given game, resulting in WordleMove&#34;&#34;&#34;</span>
</pre>
</div>


<p>
Before we finish implementing this function, let’s define the rest of the
acceptance tests we settled on in Gherkin:
</p>

<div>
<p><label><span>Listing 77: </span>Second test, for sixth guess still OK</label></p><pre id="org1a8c4fa"><span>def</span> <span>test_sixth_guess_allowed</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Fifth guess still allowed&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 5 times</span>
    <span>guess_number</span> = <span>6</span>
    <span>game</span> = WordleGame<span>(</span>answer=answer, guess_number=guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span>guess</span> = <span>&#34;kebab&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is scored</span>
    <span>OUTCOME_CONTINUE</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE
    <span>assert</span> result.outcome == OUTCOME_CONTINUE, <span>&#34;Game shouldn&#39;t be over yet&#34;</span>
    <span>assert</span> result.score <span>is</span> <span>not</span> <span>None</span>, <span>&#34;No score given as result&#34;</span>
    <span>assert</span> <span>len</span><span>(</span>result.score<span>)</span> == <span>5</span>, <span>&#34;Score of incorrect length&#34;</span>
    <span>OK_CHARS</span> = <span>[</span><span>&#34;🟩&#34;</span>, <span>&#34;🟨&#34;</span>, <span>&#34;⬜&#34;</span><span>]</span>
    <span>assert</span> <span>all</span><span>(</span>
        char <span>in</span> OK_CHARS <span>for</span> char <span>in</span> <span>list</span><span>(</span>result.score<span>)</span>
    <span>)</span>, <span>&#34;Score doesn&#39;t match score&#39;s characters&#34;</span>
</pre>
</div>

<div>
<p><label><span>Listing 78: </span>Actually denying a seventh guess</label></p><pre id="org7888658"><span>def</span> <span>test_seventh_guess_fails_game</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Sixth failed guess is game over&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 6 times already</span>
    <span># </span><span>Guessing 6 times BEFORE, using seventh now:</span>
    <span>guess_number</span> = <span>7</span>
    <span>game</span> = WordleGame<span>(</span>answer, guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span># </span><span>And my guess isn&#39;t the answer</span>
    <span>guess</span> = <span>&#34;kebab&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess isn&#39;t scored</span>
    <span>assert</span> result.outcome == WordleMoveOutcome.GAME_OVER_LOST, <span>&#34;Should have lost game&#34;</span>
    <span># </span><span>But game shows &#34;Game Over&#34;</span>
    <span>assert</span> <span>&#34;game over&#34;</span> <span>in</span> result.message.lower<span>()</span>, <span>&#34;Should show game over message&#34;</span>
    <span># </span><span>And game shows the real answer</span>
    <span>assert</span> answer <span>in</span> result.message
</pre>
</div>

<p>
As I write the test in Listing <a href="#org7888658">78</a>, I notice there’s one case of
the <code>enum</code> we haven’t covered(<code>WordleMoveOutcome.GAME_WON</code>), which means the
<code>play_round</code> scenarios aren’t correct yet. Let’s add the scenario for winning
the game!
</p>

<div>
<p><label><span>Listing 79: </span>Winning scenario</label></p><pre id="org64eb766"><span>Scenario:</span><span> Winning guess</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 3 times
<span>  When</span> I guess the word
<span>  And</span> my guess is the answer
<span>  Then</span> my guess is scored
<span>  And</span> score is perfect
<span>  And</span> game shows <span>&#34;Game Won&#34;</span>
</pre>
</div>

<p>
A little thought later, it seems we mixed up the requirements a little here (it
happens!). When designing the Gherkin Feature, we wrote about exhausting the
amounts of guesses, we weren’t thinking of win/lose conditions. But when writing
a <code>play_round</code> function, it’s indeed very relevant, especially since the
existing scenarios covered most of the cases already. Ideally, we could have
added a separate Feature describing winning and losing, and dealt with it
separately. In practice, here, it’s simpler to just expand the feature’s scope,
even if it means the scope has creeped out a little. This is what real
engineering is about, aiming for perfection, but making compromises to match our
imperfect world where deadlines and tired developers exist.
</p>

<p>
Let’s fill in our winning case test:
</p>

<div>
<p><label><span>Listing 80: </span>Winning test</label></p><pre id="org4af8209"><span>def</span> <span>test_winning_guess_wins</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Winning guess&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 3 times</span>
    <span>guess_number</span> = <span>3</span>
    <span>game</span> = WordleGame<span>(</span>answer, guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span># </span><span>And my guess is the answer</span>
    <span>guess</span> = answer
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is scored</span>
    <span>assert</span> result.score <span>is</span> <span>not</span> <span>None</span>, <span>&#34;Guess should be scored&#34;</span>
    <span># </span><span>And the score is perfect</span>
    <span>assert</span> result.score == <span>&#34;🟩🟩🟩🟩🟩&#34;</span>
    <span># </span><span>And game shows &#34;Game Won</span>
    <span>assert</span> result.outcome == WordleMoveOutcome.GAME_WON, <span>&#34;Should have won game&#34;</span>
    <span>assert</span> <span>&#34;game won&#34;</span> <span>in</span> result.message.lower<span>()</span>
</pre>
</div>


<p>
With all the tests ready, we cobble together a stub for <code>play_round</code> to execute
the tests and see them go red.
</p>

<div>
<p><label><span>Listing 81: </span>stub for <code>play_round</code>, returning failure, to make tests run red</label></p><pre id="org810019e"><span>result</span> = WordleMoveOutcome.GAME_OVER_LOST
<span>return</span> WordleMove<span>(</span>game=game, outcome=result, message=<span>&#34;You suck!&#34;</span>, score=<span>None</span><span>)</span>
</pre>
</div>

<p>
All right, the tests do fail, right?
</p>

<div>
<pre>poetry run pytest <span>2</span>&gt;&amp;<span>1</span> || true
</pre>
</div>

<pre id="orgcfafa00">============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 21 items

tests/test_checking_guess_valid_word.py::test_reject_long_words PASSED   [  4%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words PASSED [  9%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words PASSED [ 14%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words PASSED   [ 19%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [ 23%]
tests/test_scoring_guess.py::test_perfect_guess PASSED                   [ 28%]
tests/test_scoring_guess.py::test_no_common_character PASSED             [ 33%]
tests/test_scoring_guess.py::test_wrong_place PASSED                     [ 38%]
tests/test_scoring_guess.py::test_generic_score[normal_guess1] PASSED    [ 42%]
tests/test_scoring_guess.py::test_generic_score[normal_guess2] PASSED    [ 47%]
tests/test_scoring_guess.py::test_generic_score[normal_guess3] PASSED    [ 52%]
tests/test_scoring_guess.py::test_generic_score[multi_occur1] PASSED     [ 57%]
tests/test_scoring_guess.py::test_generic_score[multi_occur2] PASSED     [ 61%]
tests/test_scoring_guess.py::test_generic_score[multi_occur3] PASSED     [ 66%]
tests/test_scoring_guess.py::test_generic_score[multi_occur4] PASSED     [ 71%]
tests/test_scoring_guess.py::test_generic_score[multi_occur5] PASSED     [ 76%]
tests/test_scoring_guess.py::test_generic_score[multi_occur6] PASSED     [ 80%]
tests/test_track_guess_number.py::test_first_guess_allowed FAILED        [ 85%]
tests/test_track_guess_number.py::test_sixth_guess_allowed FAILED        [ 90%]
tests/test_track_guess_number.py::test_seventh_guess_fails_game FAILED     [ 95%]
tests/test_track_guess_number.py::test_winning_guess_wins FAILED         [100%]

=================================== FAILURES ===================================
___________________________ test_first_guess_allowed ___________________________

    def test_first_guess_allowed():
        &#34;&#34;&#34;Scenario: First guess is allowed&#34;&#34;&#34;
        # Given a wordle answer
        answer = &#34;orbit&#34;
        # And I didn&#39;t guess before
        guess_number = 0
        game = WordleGame(answer=answer, guess_number=guess_number)
        # When I guess the word
        guess = &#34;kebab&#34;
        result = play_round(guess, game)
        # Then my guess is scored
        OUTCOME_CONTINUE = WordleMoveOutcome.GUESS_SCORED_CONTINUE
&gt;       assert result.outcome == OUTCOME_CONTINUE, &#34;Game shouldn&#39;t be over yet&#34;
E       AssertionError: Game shouldn&#39;t be over yet
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         &lt;WordleMoveOutcome.GAME_OVER_LOST: 1&gt;
E         &lt;WordleMoveOutcome.GUESS_SCORED_CONTINUE: 3&gt;
E

tests/test_track_guess_number.py:25: AssertionError
___________________________ test_sixth_guess_allowed ___________________________

    def test_sixth_guess_allowed():
        &#34;&#34;&#34;Scenario: Sixth guess still allowed&#34;&#34;&#34;
        # Given a wordle answer
        answer = &#34;orbit&#34;
        # And I guessed 5 times
        guess_number = 6
        game = WordleGame(answer=answer, guess_number=guess_number)
        # When I guess the word
        guess = &#34;kebab&#34;
        result = play_round(guess, game)
        # Then my guess is scored
        OUTCOME_CONTINUE = WordleMoveOutcome.GUESS_SCORED_CONTINUE
&gt;       assert result.outcome == OUTCOME_CONTINUE, &#34;Game shouldn&#39;t be over yet&#34;
E       AssertionError: Game shouldn&#39;t be over yet
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         &lt;WordleMoveOutcome.GAME_OVER_LOST: 1&gt;
E         &lt;WordleMoveOutcome.GUESS_SCORED_CONTINUE: 3&gt;
E

tests/test_track_guess_number.py:46: AssertionError
_________________________ test_seventh_guess_fails_game _________________________

    def test_seventh_guess_fails_game():
        &#34;&#34;&#34;Scenario: Sixth failed guess is game over&#34;&#34;&#34;
        # Given a wordle answer
        answer = &#34;orbit&#34;
        # And I guessed 6 times already
        # Guessing 6 times BEFORE, using seventh now:
        guess_number = 7
        game = WordleGame(answer, guess_number)
        # When I guess the word
        # And my guess isn&#39;t the answer
        guess = &#34;kebab&#34;
        result = play_round(guess, game)
        # Then my guess isn&#39;t scored
        assert result.outcome == WordleMoveOutcome.GAME_OVER_LOST, &#34;Should have lost game&#34;
        # But game shows &#34;Game Over&#34;
&gt;       assert &#34;game over&#34; in result.message.lower(), &#34;Should show game over message&#34;
E       AssertionError: Should show game over message
E       assert in failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         game over
E         you suck!
E

tests/test_track_guess_number.py:69: AssertionError
___________________________ test_winning_guess_wins ____________________________

    def test_winning_guess_wins():
        &#34;&#34;&#34;Scenario: Winning guess&#34;&#34;&#34;
        # Given a wordle answer
        answer = &#34;orbit&#34;
        # And I guessed 3 times
        guess_number = 3
        game = WordleGame(answer, guess_number)
        # When I guess the word
        # And my guess is the answer
        guess = answer
        result = play_round(guess, game)
        # Then my guess is scored
&gt;       assert result.score is not None, &#34;Guess should be scored&#34;
E       AssertionError: Guess should be scored
E       assert is not failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         None
E

tests/test_track_guess_number.py:86: AssertionError
- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/game.py                 20      0   100%
src/literate_wordle/guess.py                19      0   100%
src/literate_wordle/words.py                25      0   100%
------------------------------------------------------------
TOTAL                                       65      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

=========================== short test summary info ============================
FAILED tests/test_track_guess_number.py::test_first_guess_allowed - Assertion...
FAILED tests/test_track_guess_number.py::test_sixth_guess_allowed - Assertion...
FAILED tests/test_track_guess_number.py::test_sixth_guess_fails_game - Assert...
FAILED tests/test_track_guess_number.py::test_winning_guess_wins - AssertionE...
========================= 4 failed, 17 passed in 0.18s =========================
</pre>

<p>
All right, let’s implement this.
</p>
</div>
<div id="outline-container-orgb2d1602">
<h3 id="orgb2d1602"><span>4.1.</span> Implementing the feature</h3>
<div id="text-4-1">
<p>
First, if we have too many guesses already (before this one), we return game
lost. This means we decide to fail not at the end of the failed sixth guess, but
beginning of the seventh.
</p>

<div>
<p><label><span>Listing 82: </span>Game over detection. Notice the early-exit pattern.</label></p><pre id="org27943d8"><span>if</span> game.guess_number &gt;= <span>7</span>:
    <span>message</span> = f<span>&#34;Too many guesses: Game Over. Answer was: {game.answer}&#34;</span>
    <span>outcome</span> = WordleMoveOutcome.GAME_OVER_LOST
    <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=message, score=<span>None</span><span>)</span>
</pre>
</div>

<p>
In order to count a guess, it needs to be a valid word. This means importing
some of our package’s functions.
</p>

<div>
<pre id="org0c25702"><span>from</span> literate_wordle.guess <span>import</span> score_guess
<span>from</span> literate_wordle.words <span>import</span> check_valid_word
</pre>
</div>

<p>
As we write the code to check if guess is valid word, we notice that if the word
isn’t valid, we can’t return <code>GUESS_SCORED_CONTINUE</code>, because an invalid-word
guess shouldn’t be counted against the player! So we again revise the
<code>WordleMoveOutcome</code> enum and because it’s a new enum case, we will need to add a
test for it to cover all grounds! Let’s put a pin in that, finish implementing
this first.
</p>

<div>
<p><label><span>Listing 83: </span>Fourth outcome: guess wasn’t valid, not counted</label></p><pre id="orgcdc4a36"><span>GUESS_NOTVALID_CONTINUE</span> = <span>4</span>
</pre>
</div>

<p>
To compensate for having this enum defined all out of order, we’ll use again the
<code>noweb</code> feature to weave code back in the enum, in the subsection below,
inserting this fourth possibility in the correct place, so the code looks like
it should.
</p>

<div>
<p><label><span>Listing 84: </span>Invalid word detection.</label></p><pre id="org1d70c82"><span>valid</span>, <span>validity_msg</span> = check_valid_word<span>(</span>guess<span>)</span>
<span>if</span> <span>not</span> valid <span>and</span> validity_msg <span>is</span> <span>not</span> <span>None</span>:
    <span>outcome</span> = WordleMoveOutcome.GUESS_NOTVALID_CONTINUE
    <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=validity_msg, score=<span>None</span><span>)</span>
</pre>
</div>

<p>
Now we’ve gotten rid of the cases where the guess was invalid.
</p>
<div>
<p><label><span>Listing 85: </span>Guess is now valid, count it</label></p><pre id="org788a9e1"><span># </span><span>Guess now guaranteed to be valid: count it</span>
<span>game.guess_number</span> += <span>1</span>
</pre>
</div>

<div>
<p><label><span>Listing 86: </span>The now-guaranteed-valid guess should be scored</label></p><pre id="org7338c65"><span>score</span> = score_guess<span>(</span>guess, game.answer<span>)</span>
</pre>
</div>


<div>
<p><label><span>Listing 87: </span>Knowing a valid guess, scored, is game won?</label></p><pre id="org7b210e1"><span>if</span> score == <span>&#34;🟩🟩🟩🟩🟩&#34;</span>:
    <span>outcome</span> = WordleMoveOutcome.GAME_WON
    <span>message</span> = f<span>&#34;Correct! Game won in {game.guess_number - 1} guesses&#34;</span>
    <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=message, score=score<span>)</span>
</pre>
</div>

<p>
Hmm, but wouldn’t it be nice to avoid this hardcoded blob?
Let’s extend the <code>CharacterScore</code> to give this.
</p>

<div>
<p><label><span>Listing 88: </span>A property of the class that returns The Perfect Score</label></p><pre id="orgde9e3e8">@<span>classmethod</span>
@<span>property</span>
<span>def</span> <span>perfect_score</span><span>(</span>cls<span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;All-good Wordle score for perfect guess&#34;&#34;&#34;</span>
    <span>return</span> <span>&#34;&#34;</span>.join<span>(</span><span>[</span>cls.OK<span>]</span> * <span>5</span><span>)</span>
</pre>
</div>

<div>
<p><label><span>Listing 89: </span>Knowing a valid guess, scored, is game won? (Without hardcoded string)</label></p><pre id="org5d3aba8"><span>if</span> score == CharacterScore.perfect_score:
    <span>outcome</span> = WordleMoveOutcome.GAME_WON
    <span>message</span> = f<span>&#34;Correct! Game won in {game.guess_number - 1} guesses&#34;</span>
    <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=message, score=score<span>)</span>
</pre>
</div>

<div>
<p><label><span>Listing 90: </span>Re-do the imports, because we needed CharacterScore too</label></p><pre id="org75d307a"><span>from</span> literate_wordle.guess <span>import</span> CharacterScore, score_guess
<span>from</span> literate_wordle.words <span>import</span> check_valid_word
</pre>
</div>


<div>
<p><label><span>Listing 91: </span>Last possibility remains: scored, not won/lost, try another guess</label></p><pre id="orgfeaeb62"><span># </span><span>Only case left is &#34;try another guess&#34;</span>
<span>outcome</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE
<span>message</span> = f<span>&#34;Try again! Guess number {game.guess_number - 1}. Score is: {score}&#34;</span>
<span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=message, score=score<span>)</span>
</pre>
</div>


<p>
Note that throughout this codebase, we made a lot of assumptions and
repetitions around the length of a Wordle answer/guess, and this translate to
repeated hardcoded-ness like above regarding emojis. These could have been
addressed right away during implementation, and indeed we did, but it’s
important to consider if the scope increase is worth it: generalized Wordle to
N characters isn’t super interesting to me, as it would require cutting new
dictionaries, etc, and I’m just not that into Wordle. This is the kind of
technical design decision we can do by having a firm grasp on project scope,
another advantage of deep understanding of project requirements.
</p>

<p>
Back to the implementation: tests should all pass now, <code>make</code> is happy, but
there’s an interesting issue:
</p>

<pre id="org0cb7d20">----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/game.py                 38      2    95%
src/literate_wordle/guess.py                19      0   100%
src/literate_wordle/words.py                25      0   100%
------------------------------------------------------------
TOTAL                                       83      2    98%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml
</pre>

<p>
We lowered coverage, nooo! Exploring the coverage HTML file in a browser, we see
that the lines in question that aren’t covered are:
</p>

<div>
<p><label><span>Listing 92: </span>Lines of code that weren’t hit in any test, as witnessed by test coverage library</label></p><pre><span>if</span> <span>not</span> valid <span>and</span> validity_msg <span>is</span> <span>not</span> <span>None</span>:
    <span>outcome</span> = WordleMoveOutcome.GUESS_NOTVALID_CONTINUE
    <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=validity_msg, score=<span>None</span><span>)</span>
</pre>
</div>

<p>
Oh! That’s the test case we put a pin in! Right, so we’re back to writing that
test. I wonder if we should write a whole scenario to back it up? It’s not
really obvious!
</p>

<p>
If this test case spins out of an edge case of our implementation, it’s not
really coming from a business requirement, so it’s probably not worth writing a
Gherkin Scenario alongside the other ones. If it is indeed an overlooked
requirement, then yes, add it to the requirements pile and write a feature.
</p>

<p>
Hmm, let’s write the test first, and see if the scenario that emerges is a
requirement.
</p>

<div>
<pre id="orgf36b75f"><span>def</span> <span>test_invalid_guess_not_counted</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Invalid guess isn&#39;t counted&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 3 times</span>
    <span>guess_number</span> = <span>3</span>
    <span>game</span> = WordleGame<span>(</span>answer=answer, guess_number=guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span># </span><span>But my guess isn&#39;t a dictionary word</span>
    <span>guess</span> = <span>&#34;xolfy&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is rejected as invalid word</span>
    <span>OUTCOME_BADWORD</span> = WordleMoveOutcome.GUESS_NOTVALID_CONTINUE
    <span>assert</span> result.outcome == OUTCOME_BADWORD, <span>&#34;Guess should have been rejected&#34;</span>
    <span># </span><span>And my guess is not scored</span>
    <span>assert</span> result.score <span>is</span> <span>None</span>, <span>&#34;No score should be given on bad word&#34;</span>
</pre>
</div>

<p>
Hmm, after some thought, it seems that the function we implemented, compared to
the feature being described in Gherkin, is indeed different!
</p>

<p>
As mentioned before, the Gherkin feature was about tracking specific number of
guesses, but we increased scope to consider the wider win scenario, using the
“play round” feature. Expanding the feature again to cover more cases than just
how many guesses, it needs to understand if the guess is correct word or not.
</p>

<p>
So for the specific purpose of tracking guesses as a feature, we’re already
covered by existing scenarios. But not only are we missing edge cases of
implementation, as we saw in coverage metrics, but this is the wider feature
that a <i>play a round</i> Feature would cover.
</p>

<p>
This game’s implementation being so very near completion, I am not interested
in creating another feature file, I’ll just expand a bit the original feature
to be about being able to play a whole round, wins and losses included, just to
keep this narrative barely on track.
</p>

<div>
<pre id="orgb24a7e6"><span>Feature:</span><span> Playing a round</span>
  As a Wordle game
  I need to track how many guesses were already given, stating wins/losses
  In order to play the game
</pre>
</div>


<div>
<p><label><span>Listing 93: </span>New scenario</label></p><pre id="org96da1c0"><span>Scenario:</span><span> Invalid guess isn&#39;t counted</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 3 times
<span>  When</span> I guess the word
<span>  But</span> my guess isn&#39;t a dictionary word
<span>  Then</span> my guess is rejected as invalid word
<span>  And</span> my guess is not scored
</pre>
</div>


<p>
And with this new test, we’re back to passing tests and 100% coverage!
</p>
</div>
</div>

<div id="outline-container-org3287dea">
<h3 id="org3287dea"><span>4.2.</span> Tangling out the whole thing</h3>
<div id="text-4-2">
<p>
The feature first:
</p>

<div>
<pre><span>Feature:</span><span> Playing a round</span>
  As a Wordle game
  I need to track how many guesses were already given, stating wins/losses
  In order to play the game

<span>Scenario:</span><span> First guess is allowed</span>
<span>  Given</span> a wordle answer
<span>  And</span> I didn&#39;t guess before
<span>  When</span> I guess the word
<span>  Then</span> my guess is scored

<span>Scenario:</span><span> Sixth guess still allowed</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 5 times
<span>  When</span> I guess the word
<span>  Then</span> my guess is scored

<span>Scenario:</span><span> Six failed guess is game over</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 6 times already
<span>  When</span> I guess the word
<span>  And</span> my guess isn&#39;t the answer
<span>  Then</span> my guess is scored
<span>  But</span> game shows <span>&#34;Game Over&#34;</span>
<span>  And</span> game shows the real answer

<span>Scenario:</span><span> Winning guess</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 3 times
<span>  When</span> I guess the word
<span>  And</span> my guess is the answer
<span>  Then</span> my guess is scored
<span>  And</span> score is perfect
<span>  And</span> game shows <span>&#34;Game Won&#34;</span>

<span>Scenario:</span><span> Invalid guess isn&#39;t counted</span>
<span>  Given</span> a wordle answer
<span>  And</span> I guessed 3 times
<span>  When</span> I guess the word
<span>  But</span> my guess isn&#39;t a dictionary word
<span>  Then</span> my guess is rejected as invalid word
<span>  And</span> my guess is not scored
</pre>
</div>

<p>
The tests:
</p>

<div>
<pre><span>&#34;&#34;&#34;Validates the Gherkin file features/track_guesses.feature</span>

<span>Feature: Playing a round</span>
<span>  As a Wordle game</span>
<span>  I need to track how many guesses were already given, stating wins/losses</span>
<span>  In order to play the game</span>
<span>&#34;&#34;&#34;</span>


<span>from</span> literate_wordle.game <span>import</span> WordleGame, WordleMoveOutcome, play_round
<span>from</span> literate_wordle.guess <span>import</span> CharacterScore <span>as</span> Score


<span>def</span> <span>test_first_guess_allowed</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: First guess is allowed&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I didn&#39;t guess before</span>
    <span>guess_number</span> = <span>0</span>
    <span>game</span> = WordleGame<span>(</span>answer=answer, guess_number=guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span>guess</span> = <span>&#34;kebab&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is scored</span>
    <span>OUTCOME_CONTINUE</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE
    <span>assert</span> result.outcome == OUTCOME_CONTINUE, <span>&#34;Game shouldn&#39;t be over yet&#34;</span>
    <span>assert</span> result.score <span>is</span> <span>not</span> <span>None</span>, <span>&#34;No score given as result&#34;</span>
    <span>assert</span> <span>len</span><span>(</span>result.score<span>)</span> == <span>5</span>, <span>&#34;Score of incorrect length&#34;</span>
    <span>ALLOWED_CHARS</span> = <span>[</span>score.value <span>for</span> score <span>in</span> Score<span>]</span>
    <span>assert</span> <span>all</span><span>(</span>
        char <span>in</span> ALLOWED_CHARS <span>for</span> char <span>in</span> <span>list</span><span>(</span>result.score<span>)</span>
    <span>)</span>, <span>&#34;Score doesn&#39;t match score&#39;s characters&#34;</span>


<span>def</span> <span>test_sixth_guess_allowed</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Fifth guess still allowed&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 5 times</span>
    <span>guess_number</span> = <span>6</span>
    <span>game</span> = WordleGame<span>(</span>answer=answer, guess_number=guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span>guess</span> = <span>&#34;kebab&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is scored</span>
    <span>OUTCOME_CONTINUE</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE
    <span>assert</span> result.outcome == OUTCOME_CONTINUE, <span>&#34;Game shouldn&#39;t be over yet&#34;</span>
    <span>assert</span> result.score <span>is</span> <span>not</span> <span>None</span>, <span>&#34;No score given as result&#34;</span>
    <span>assert</span> <span>len</span><span>(</span>result.score<span>)</span> == <span>5</span>, <span>&#34;Score of incorrect length&#34;</span>
    <span>OK_CHARS</span> = <span>[</span><span>&#34;🟩&#34;</span>, <span>&#34;🟨&#34;</span>, <span>&#34;⬜&#34;</span><span>]</span>
    <span>assert</span> <span>all</span><span>(</span>
        char <span>in</span> OK_CHARS <span>for</span> char <span>in</span> <span>list</span><span>(</span>result.score<span>)</span>
    <span>)</span>, <span>&#34;Score doesn&#39;t match score&#39;s characters&#34;</span>


<span>def</span> <span>test_seventh_guess_fails_game</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Sixth failed guess is game over&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 6 times already</span>
    <span># </span><span>Guessing 6 times BEFORE, using seventh now:</span>
    <span>guess_number</span> = <span>7</span>
    <span>game</span> = WordleGame<span>(</span>answer, guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span># </span><span>And my guess isn&#39;t the answer</span>
    <span>guess</span> = <span>&#34;kebab&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess isn&#39;t scored</span>
    <span>assert</span> result.outcome == WordleMoveOutcome.GAME_OVER_LOST, <span>&#34;Should have lost game&#34;</span>
    <span># </span><span>But game shows &#34;Game Over&#34;</span>
    <span>assert</span> <span>&#34;game over&#34;</span> <span>in</span> result.message.lower<span>()</span>, <span>&#34;Should show game over message&#34;</span>
    <span># </span><span>And game shows the real answer</span>
    <span>assert</span> answer <span>in</span> result.message


<span>def</span> <span>test_winning_guess_wins</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Winning guess&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 3 times</span>
    <span>guess_number</span> = <span>3</span>
    <span>game</span> = WordleGame<span>(</span>answer, guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span># </span><span>And my guess is the answer</span>
    <span>guess</span> = answer
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is scored</span>
    <span>assert</span> result.score <span>is</span> <span>not</span> <span>None</span>, <span>&#34;Guess should be scored&#34;</span>
    <span># </span><span>And the score is perfect</span>
    <span>assert</span> result.score == <span>&#34;🟩🟩🟩🟩🟩&#34;</span>
    <span># </span><span>And game shows &#34;Game Won</span>
    <span>assert</span> result.outcome == WordleMoveOutcome.GAME_WON, <span>&#34;Should have won game&#34;</span>
    <span>assert</span> <span>&#34;game won&#34;</span> <span>in</span> result.message.lower<span>()</span>


<span># </span><span>Case covered by existing gherkin feature:</span>
<span># </span><span>Intentional, see wordle.org for reasoning</span>
<span>def</span> <span>test_invalid_guess_not_counted</span><span>()</span>:
    <span>&#34;&#34;&#34;Scenario: Invalid guess isn&#39;t counted&#34;&#34;&#34;</span>
    <span># </span><span>Given a wordle answer</span>
    <span>answer</span> = <span>&#34;orbit&#34;</span>
    <span># </span><span>And I guessed 3 times</span>
    <span>guess_number</span> = <span>3</span>
    <span>game</span> = WordleGame<span>(</span>answer=answer, guess_number=guess_number<span>)</span>
    <span># </span><span>When I guess the word</span>
    <span># </span><span>But my guess isn&#39;t a dictionary word</span>
    <span>guess</span> = <span>&#34;xolfy&#34;</span>
    <span>result</span> = play_round<span>(</span>guess, game<span>)</span>
    <span># </span><span>Then my guess is rejected as invalid word</span>
    <span>OUTCOME_BADWORD</span> = WordleMoveOutcome.GUESS_NOTVALID_CONTINUE
    <span>assert</span> result.outcome == OUTCOME_BADWORD, <span>&#34;Guess should have been rejected&#34;</span>
    <span># </span><span>And my guess is not scored</span>
    <span>assert</span> result.score <span>is</span> <span>None</span>, <span>&#34;No score should be given on bad word&#34;</span>
</pre>
</div>

<div>
<pre><span>&#34;&#34;&#34;Wordle game&#39;s state and playing rounds&#34;&#34;&#34;</span>


<span>from</span> dataclasses <span>import</span> dataclass
<span>from</span> enum <span>import</span> Enum
<span>from</span> typing <span>import</span> Optional

<span>from</span> literate_wordle.guess <span>import</span> CharacterScore, score_guess
<span>from</span> literate_wordle.words <span>import</span> check_valid_word


<span>class</span> <span>WordleMoveOutcome</span><span>(</span>Enum<span>)</span>:
    <span>&#34;&#34;&#34;Outcome of a single move&#34;&#34;&#34;</span>

    <span>GAME_OVER_LOST</span> = <span>1</span>
    <span>GAME_WON</span> = <span>2</span>
    <span>GUESS_SCORED_CONTINUE</span> = <span>3</span>
    <span>GUESS_NOTVALID_CONTINUE</span> = <span>4</span>


<span>@dataclass</span>
<span>class</span> <span>WordleGame</span>:
    <span>&#34;&#34;&#34;A Wordle game&#39;s internal state, before a move is played&#34;&#34;&#34;</span>

    answer: <span>str</span>
    guess_number: <span>int</span>


<span>@dataclass</span>
<span>class</span> <span>WordleMove</span>:
    <span>&#34;&#34;&#34;A Wordle game state once a move is played&#34;&#34;&#34;</span>

    game: WordleGame
    outcome: WordleMoveOutcome
    message: <span>str</span>
    score: Optional<span>[</span><span>str</span><span>]</span>


<span>def</span> <span>play_round</span><span>(</span>guess: <span>str</span>, game: WordleGame<span>)</span> -&gt; WordleMove:
    <span>&#34;&#34;&#34;Use guess on the given game, resulting in WordleMove&#34;&#34;&#34;</span>
    <span>if</span> game.guess_number &gt;= <span>7</span>:
        <span>message</span> = f<span>&#34;Too many guesses: Game Over. Answer was: {game.answer}&#34;</span>
        <span>outcome</span> = WordleMoveOutcome.GAME_OVER_LOST
        <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=message, score=<span>None</span><span>)</span>
    <span>valid</span>, <span>validity_msg</span> = check_valid_word<span>(</span>guess<span>)</span>
    <span>if</span> <span>not</span> valid <span>and</span> validity_msg <span>is</span> <span>not</span> <span>None</span>:
        <span>outcome</span> = WordleMoveOutcome.GUESS_NOTVALID_CONTINUE
        <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=validity_msg, score=<span>None</span><span>)</span>
    <span># </span><span>Guess now guaranteed to be valid: count it</span>
    <span>game.guess_number</span> += <span>1</span>
    <span>score</span> = score_guess<span>(</span>guess, game.answer<span>)</span>
    <span>if</span> score == CharacterScore.perfect_score:
        <span>outcome</span> = WordleMoveOutcome.GAME_WON
        <span>message</span> = f<span>&#34;Correct! Game won in {game.guess_number - 1} guesses&#34;</span>
        <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=message, score=score<span>)</span>
    <span># </span><span>Only case left is &#34;try another guess&#34;</span>
    <span>outcome</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE
    <span>message</span> = f<span>&#34;Try again! Guess number {game.guess_number - 1}. Score is: {score}&#34;</span>
    <span>return</span> WordleMove<span>(</span>game=game, outcome=outcome, message=message, score=score<span>)</span>
</pre>
</div>

<p>
And remember that we had to expand the <code>CharacterScore</code>, so we need to re-tangle
it here:
</p>

<div>
<pre id="org47c4471"><span>&#34;&#34;&#34;Score guesses of Wordle game&#34;&#34;&#34;</span>


<span>from</span> collections <span>import</span> Counter
<span>from</span> enum <span>import</span> Enum


<span>class</span> <span>CharacterScore</span><span>(</span><span>str</span>, Enum<span>)</span>:
    <span>&#34;&#34;&#34;A single character&#39;s score&#34;&#34;&#34;</span>

    <span>OK</span> = <span>&#34;🟩&#34;</span>
    <span>NO</span> = <span>&#34;⬜&#34;</span>
    <span>WRONG_PLACE</span> = <span>&#34;🟨&#34;</span>

    @<span>classmethod</span>
    @<span>property</span>
    <span>def</span> <span>perfect_score</span><span>(</span>cls<span>)</span> -&gt; <span>str</span>:
        <span>&#34;&#34;&#34;All-good Wordle score for perfect guess&#34;&#34;&#34;</span>
        <span>return</span> <span>&#34;&#34;</span>.join<span>(</span><span>[</span>cls.OK<span>]</span> * <span>5</span><span>)</span>


<span>def</span> <span>score_guess</span><span>(</span>guess: <span>str</span>, answer: <span>str</span><span>)</span> -&gt; <span>str</span>:
    <span>&#34;&#34;&#34;Score an individual guess with Counter&#34;&#34;&#34;</span>
    <span># </span><span>Counter(&#34;abbey&#34;) = Counter({&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;e&#39;: 1, &#39;y&#39;: 1})</span>
    <span>answer_chars</span> = Counter<span>(</span>answer<span>)</span>
    <span>response</span> = <span>&#34;&#34;</span>
    <span>for</span> guess_char, answer_char <span>in</span> <span>zip</span><span>(</span>guess, answer<span>)</span>:
        <span>if</span> guess_char <span>not</span> <span>in</span> answer_chars:
            <span>response</span> += CharacterScore.NO
            <span>continue</span>  <span># </span><span>Early exit for this character, skip to next</span>
        <span># </span><span>From here on, we MUST have a char in common, regardless of place</span>
        <span>if</span> answer_char == guess_char:
            <span>response</span> += CharacterScore.OK
        <span>elif</span> answer_chars<span>[</span>guess_char<span>]</span> &gt; <span>0</span>:
            <span>response</span> += CharacterScore.WRONG_PLACE
        <span># </span><span>Either way, reduce occurence counter since we &#34;used&#34; this occurence</span>
        <span>answer_chars</span><span>[</span>guess_char<span>]</span> -= <span>1</span>
        <span># </span><span>No more hits = pretend character isn&#39;t even seen (remove from dict)</span>
        <span>if</span> answer_chars<span>[</span>guess_char<span>]</span> == <span>0</span>:
            <span>del</span> answer_chars<span>[</span>guess_char<span>]</span>
    <span>return</span> response
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org86fabf6">
<h2 id="org86fabf6"><span>5.</span> Final round: command line interface</h2>
<div id="text-5">
<p>
We have assembled lego bricks into an almost finished product, as we have enough to
play a single round. Let’s give this project a shell command to invoke, tying
together all the other disjointed features.
</p>

<div>
<p><label><span>Listing 94: </span>Final feature of our system: play the game!</label></p><pre><span>Feature:</span><span> Pywordle shell command</span>
  As a Wordle game
  I need a shell command to launch the game
  In order to give convenient entrypoint for players
</pre>
</div>

<p>
I don’t think it’s necessary to give specific scenarios, because we’ve
thoroughly tested the underlying implementation of the game, we just need to
assemble it into a shell command.
</p>

<p>
So let’s define an entrypoint for the game, generating a new one:
</p>

<div>
<p><label><span>Listing 95: </span>Create a new game (object)</label></p><pre id="org83cf09e"><span>def</span> <span>new_game</span><span>()</span> -&gt; WordleGame:
    <span>&#34;&#34;&#34;Generate a new WordleGame&#34;&#34;&#34;</span>
    <span>return</span> WordleGame<span>(</span>answer=pick_answer_word<span>()</span>, guess_number=<span>1</span><span>)</span>
</pre>
</div>

<p>
And how to play until we lose, printing to stdout as we go:
</p>

<div>
<p><label><span>Listing 96: </span>The main game loop. Notice the trick: dependency injection of all input and output as “callables”, which we can inject later to be <code>print</code> and <code>input</code>, or automate instead for testing.</label></p><pre id="org44f79e9"><span>def</span> <span>play_game</span><span>(</span>game: WordleGame, guess_fetcher: Callable, response_logger: Callable<span>)</span>:
    <span>&#34;&#34;&#34;Plays the given WordleGame until completion.</span>

<span>    Asks guess_fetcher for guess, and sends response to response_logger</span>
<span>    &#34;&#34;&#34;</span>
    <span>outcome</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE  <span># </span><span>Gotta start somehow</span>
    <span>while</span> outcome <span>not</span> <span>in</span> <span>{</span>WordleMoveOutcome.GAME_WON, WordleMoveOutcome.GAME_OVER_LOST<span>}</span>:
        <span>guess</span> = guess_fetcher<span>()</span>
        <span>result</span> = play_round<span>(</span>guess=guess, game=game<span>)</span>
        response_logger<span>(</span>result.message<span>)</span>
        <span>game</span> = result.game
        <span>outcome</span> = result.outcome
</pre>
</div>

<p>
Pepper in the few imports we need:
</p>

<div>
<p><label><span>Listing 97: </span>Callable is the type of anything that can be called (function but also classes with <code>__init__</code> methods…)</label></p><pre id="org379fb96"><span>from</span> typing <span>import</span> Callable
</pre>
</div>

<div>
<p><label><span>Listing 98: </span>Other functions we referenced</label></p><pre id="org7b86ce3"><span>from</span> literate_wordle.game <span>import</span> WordleGame, WordleMoveOutcome, play_round
<span>from</span> literate_wordle.words <span>import</span> pick_answer_word
</pre>
</div>

<p>
Now we can add command line argument parsing in a separate file:
</p>

<div>
<p><label><span>Listing 99: </span>An argument parser with no argument, to give us usage via <code>--help</code> flags. Notice the <code>raw_args</code>, if passed, is given, and defaults to <code>None</code>. This allows us to call this function ourselves to test it, but still use <code>None</code> to use <code>sys.argv</code> automatically.</label></p><pre id="orgc0130af"><span>def</span> <span>parse_args</span><span>(</span>raw_args: Optional<span>[</span>Sequence<span>[</span><span>str</span><span>]</span><span>]</span> = <span>None</span><span>)</span> -&gt; argparse.Namespace:
    <span>&#34;&#34;&#34;Parse given command line arguments&#34;&#34;&#34;</span>
    <span>description</span> = <span>&#34;Wordle implementation in Python, as literate programming&#34;</span>
    <span># </span><span>Bit overkill since there is no real argument to parse yet</span>
    <span>parser</span> = argparse.ArgumentParser<span>(</span>prog=<span>&#34;pywordle&#34;</span>, description=description<span>)</span>
    <span>return</span> parser.parse_args<span>(</span>raw_args<span>)</span>
</pre>
</div>

<div>
<p><label><span>Listing 100: </span>The Python arguments parsing library. <code>click</code> is fancier, but this is neat and self-contained.</label></p><pre id="org53713d4"><span>import</span> argparse
</pre>
</div>

<div>
<p><label><span>Listing 101: </span>Typing hints for our arguments. <code>Sequence</code> is a generalized version of List that is “anything we can iterate over”, so a linked list would match.</label></p><pre id="org8e9a73e"><span>from</span> typing <span>import</span> Optional, Sequence
</pre>
</div>

<div>
<p><label><span>Listing 102: </span>Inject the input and output functions to <code>play_game</code></label></p><pre id="org1369d41"><span>def</span> <span>play_game_args</span><span>(</span>raw_args: Optional<span>[</span>Sequence<span>[</span><span>str</span><span>]</span><span>]</span> = <span>None</span><span>)</span>:
    <span>&#34;&#34;&#34;Play a standard Wordle game from stdin to stdout, given args&#34;&#34;&#34;</span>
    <span>_</span> = parse_args<span>(</span>raw_args<span>)</span>
    <span>game</span> = new_game<span>()</span>
    play_game<span>(</span>game=game, guess_fetcher=<span>input</span>, response_logger=<span>print</span><span>)</span>
</pre>
</div>

<div>
<p><label><span>Listing 103: </span>Defining an explicit function for the python package to enter through</label></p><pre id="org32341fc"><span>def</span> <span>main</span><span>()</span>:
    <span>&#34;&#34;&#34;Pass sys.argv to the play_game_args function&#34;&#34;&#34;</span>
    play_game_args<span>(</span>sys.argv<span>[</span><span>1</span>:<span>]</span><span>)</span>
</pre>
</div>

<div>
<p><label><span>Listing 104: </span>More stdlib imports</label></p><pre id="org7009759"><span>import</span> sys
</pre>
</div>

<div>
<p><label><span>Listing 105: </span>More custom imports</label></p><pre id="orgc34b447"><span>from</span> literate_wordle.main <span>import</span> new_game, play_game
</pre>
</div>

<p>
Since both our main and cli are meant to be untestable, because it’s the
interactive entrypoint, it’s a bit unfair to compute coverage over it. Let’s
blacklist these two files, preventing them weighing down coverage metric.
</p>

<div>
<pre>[<span>run</span>]
<span>omit</span> =
    <span># </span><span>Don&#39;t compute coverage for these 2 manual invocation files</span>
    src/literate_wordle/main.py
    src/literate_wordle/cli.py
</pre>
</div>
</div>

<div id="outline-container-orge9bb89e">
<h3 id="orge9bb89e"><span>5.1.</span> Tangling it out</h3>
<div id="text-5-1">
<div>
<pre><span>&#34;&#34;&#34;Entrypoint for pywordle&#34;&#34;&#34;</span>


<span>from</span> typing <span>import</span> Callable

<span>from</span> literate_wordle.game <span>import</span> WordleGame, WordleMoveOutcome, play_round
<span>from</span> literate_wordle.words <span>import</span> pick_answer_word


<span>def</span> <span>new_game</span><span>()</span> -&gt; WordleGame:
    <span>&#34;&#34;&#34;Generate a new WordleGame&#34;&#34;&#34;</span>
    <span>return</span> WordleGame<span>(</span>answer=pick_answer_word<span>()</span>, guess_number=<span>1</span><span>)</span>


<span>def</span> <span>play_game</span><span>(</span>game: WordleGame, guess_fetcher: Callable, response_logger: Callable<span>)</span>:
    <span>&#34;&#34;&#34;Plays the given WordleGame until completion.</span>

<span>    Asks guess_fetcher for guess, and sends response to response_logger</span>
<span>    &#34;&#34;&#34;</span>
    <span>outcome</span> = WordleMoveOutcome.GUESS_SCORED_CONTINUE  <span># </span><span>Gotta start somehow</span>
    <span>while</span> outcome <span>not</span> <span>in</span> <span>{</span>WordleMoveOutcome.GAME_WON, WordleMoveOutcome.GAME_OVER_LOST<span>}</span>:
        <span>guess</span> = guess_fetcher<span>()</span>
        <span>result</span> = play_round<span>(</span>guess=guess, game=game<span>)</span>
        response_logger<span>(</span>result.message<span>)</span>
        <span>game</span> = result.game
        <span>outcome</span> = result.outcome



</pre>
</div>


<div>
<pre><span>&#34;&#34;&#34;Command line entrypoint for pywordle&#34;&#34;&#34;</span>


<span>import</span> argparse
<span>import</span> sys
<span>from</span> typing <span>import</span> Optional, Sequence

<span>from</span> literate_wordle.main <span>import</span> new_game, play_game


<span>def</span> <span>parse_args</span><span>(</span>raw_args: Optional<span>[</span>Sequence<span>[</span><span>str</span><span>]</span><span>]</span> = <span>None</span><span>)</span> -&gt; argparse.Namespace:
    <span>&#34;&#34;&#34;Parse given command line arguments&#34;&#34;&#34;</span>
    <span>description</span> = <span>&#34;Wordle implementation in Python, as literate programming&#34;</span>
    <span># </span><span>Bit overkill since there is no real argument to parse yet</span>
    <span>parser</span> = argparse.ArgumentParser<span>(</span>prog=<span>&#34;pywordle&#34;</span>, description=description<span>)</span>
    <span>return</span> parser.parse_args<span>(</span>raw_args<span>)</span>


<span>def</span> <span>play_game_args</span><span>(</span>raw_args: Optional<span>[</span>Sequence<span>[</span><span>str</span><span>]</span><span>]</span> = <span>None</span><span>)</span>:
    <span>&#34;&#34;&#34;Play a standard Wordle game from stdin to stdout, given args&#34;&#34;&#34;</span>
    <span>_</span> = parse_args<span>(</span>raw_args<span>)</span>
    <span>game</span> = new_game<span>()</span>
    play_game<span>(</span>game=game, guess_fetcher=<span>input</span>, response_logger=<span>print</span><span>)</span>


<span>def</span> <span>main</span><span>()</span>:
    <span>&#34;&#34;&#34;Pass sys.argv to the play_game_args function&#34;&#34;&#34;</span>
    play_game_args<span>(</span>sys.argv<span>[</span><span>1</span>:<span>]</span><span>)</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org7d6d904">
<h3 id="org7d6d904"><span>5.2.</span> Launching as CLI</h3>
<div id="text-5-2">
<p>
In Python, when using <a href="https://python-poetry.org/">Poetry</a> like we are, the package is defined in
<code>pyproject.toml</code>. To define a new command, this means using the
<code>tool.poetry.script</code> key:
</p>

<div>
<pre>[<span>tool.poetry.scripts</span>]
<span>pywordle</span> = <span>&#34;literate_wordle.cli:main&#34;</span>
</pre>
</div>

<p>
So we can now manually invoke this tool. And for the given argument parser, a
help message should be available:
</p>

<div>
<p><label><span>Listing 106: </span>Invoking the help menu. Note “poetry run” prefix to ensure we’re running inside virtualenv, where the package is installed</label></p><pre>poetry run pywordle --help
</pre>
</div>

<pre>usage: pywordle [-h]

Wordle implementation in Python, as literate programming

optional arguments:
  -h, --help  show this help message and exit
</pre>


<p>
And we can play a round!
</p>

<pre>$ poetry shell
$ pywordle
hello
Try again! Guess number 1. Score is: ⬜🟨🟨⬜🟨
lobes
Try again! Guess number 2. Score is: 🟨🟩⬜🟩⬜
cranes
Guess too long
crane
Try again! Guess number 3. Score is: ⬜⬜⬜🟨🟨
novel
Correct! Game won in 4 guesses
</pre>


<p>
Taking a step back, we’ve got command line launch of the game, and we can play
with it. We’re done here, especially for a short experimental project.
</p>

<p>
But if this codebase was to be maintained, extended, reused, the bar for
“acceptable” test coverage would be much higher.
</p>

<p>
For instance, we have no test overall on the game loop of guess input/output,
despite all the layers below being pretty well covered. So I’d want tests that
call the <code>play_game</code> function with scripted inputs and log the outputs, taking
advantage of the dependency injection we set up to make proper UI-oriented
tests. These would reveal, for instance, that when launching the game, there is
nothing greeting us, no prompt for a guess, which is a usability issue.
</p>

<p>
In our case, that’s an exercise left for the reader.
</p>

<p>
Remember that testing’s primary goal is to increase our trust in the system we
build.
</p>

<p>
In that vein, because we’ve got feature acceptance tests covered for every
layer, the biggest source of uncertainty in the system is the implementation
itself: we’re just not shaking out the code very much, beyond what a normal
usage would look like. This calls for exploring the edge cases that code may
have, regardless of intended features. Every string parameter should be tried
with empty string, uppercase vs lowercase, different encoding, etc.
</p>
</div>
</div>
</div>

<div id="outline-container-org97ab402">
<h2 id="org97ab402"><span>6.</span> Conclusion</h2>
<div id="text-6">
<p>
We just walked through building a simple wordle program from scratch, using
literate programming to weave a novel’s worth of explanations and reasoning,
with code blocks that export to the proper project code locations.
</p>

<p>
The project uses modern Python tooling (poetry, pytest) and uses formatters
(black, isort), linters (flake8 with plugins), type checkers (mypy), and the
project generates its own general documentation (including this page, if you’re
reading it in a browser) and API reference (Sphinx with myst_parser for Markdown
support), enforcing compliance of every tool via make and pre-commit.
</p>

<p>
The code was written in a Test-driven (TDD) way, as the tests always came before
the feature itself, guiding how the implementation looks like, all the way to
having 100% test coverage (whatever that means).
</p>

<p>
More importantly in my eyes, we only built what was strictly necessary, by using
Behaviour-driven development (BDD, also called acceptance-test-driven
development) to guide what subfeature to build next based on our needs. These
specifications were encoded as Gherkin Features, available in a dedicated
<code>features/</code> folder, and thanks to the magic of Sphinx documentation, each of
those are collected into a list of requirements in a dedicated Requirements
page of the docs.
</p>

<p>
Since all of the feature files have associated acceptance tests that match the
phrasing of the Gherkin features, future automation work could look at linking
the requirements in Sphinx to the associated test file, so as to finally get
full traceability from requirements, through specifications, to implementation
and finally acceptance tests that pass.
</p>

<p>
This project was my first foray into literate programming at this scale, an
attempt to bring together all the good ideas of TDD, modern Python development,
Gherkin usage for requirements traceability purposes (without overly zealous
extremes of Cucumber automation). All these ideas were until now scattered,
implemented each without the others in different places, and this project
fuses them into something I hope is more valuable than the sum of its parts.
</p>

<p>
If you like what you see here, have a look at my other writings, available on
my blog: <a href="https://jiby.tech">https://jiby.tech</a>.
</p>
</div>
</div>
</div>
<div id="postamble">

<p>Created: 2022-05-08 Sun 02:31</p>
</div>


</section>


           </div>
          </div></div>
  </body>
</html>
