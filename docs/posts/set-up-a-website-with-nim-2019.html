<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ttj.dk/blog/2019/01/20/setup-a-website-with-nim">Original</a>
    <h1>Set up a website with Nim (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="page">
  <div id="mainContainer">

<p>This small tutorial will help you create a website with Nim. We&#39;ll use libraries from the standard library and some externals from Nim-users.</p>
<p>The tutorial will not explain how procs, templates, etc. works - there are many other good Nim resources for that. See <a href="https://nim-lang.org/learn.html">https://nim-lang.org/learn.html</a> for that.</p>
<p>We&#39;ll create a small website with user management, which has a public page and page only visible for users logged in.</p>

<h3>Difficulty</h3>
<p>The tutorial is meant for programmers with little experience in Nim.</p>
<p>The first chapters are easy, but thereafter the difficulty will increase.</p>

<h3>Goal</h3>
<p>A website created in Nim. The result will be a simplified replica of <a href="https://nimwc.org">NimWC</a>. You can find NimWC at the <a href="https://github.com/ThomasTJdev/nim_websitecreator">NimWC Github repo</a>, if you want to add more details and functions to your code.</p>

<h3>Requirements</h3>
<p>Nim with a version higher or equal to 19.2 <i>(Nim is currently in stable: 1.x.x - use that!)</i></p>

<h3>The final code</h3>
<p>The final code is hosted here: <a href="https://github.com/ThomasTJdev/nim_tutorials">Tutorial code</a></p>


<hr/>


<h3>External libraries</h3>
<pre><code>nimble install jester
nimble install bcrypt
</code></pre>

<h3>Not used libraries</h3>
<p>There&#39;s a lot of helpful libraries, which we are <b>not</b> going to use. But you can enhance your code afterward with them.</p>
<p>Checkout <a href="https://nimble.directory">Nimble Directory</a> for libraries.</p>
<ul>
  <li>sqlbuilder (format your queries)</li>
  <li>recaptcha (Google&#39;s reCAPTCHA verification)</li>
</ul>

<h3>Code editor</h3>
<p>Visual Studio Code has a good integration of Nim. Download VSC and install the Nim extension.</p>


<hr/>


<p>Create the following folder structure. We will put files into the folders as we go through the tutorial.</p>
<pre><code>nimweb/
nimweb/config   &lt;-- Used to store our configuration
nimweb/data     &lt;-- For our SQLite database
nimweb/code     &lt;-- The code
nimweb/public   &lt;-- Containing CSS and JS files
nimweb/tmpl     &lt;-- The HTML-Nim files
</code></pre>


<hr/>


<p>The config files contains our <i>secret</i> information, such as database password.</p>

<p>Create the config file <kbd>nimweb/config/config.cfg</kbd></p>

<p>Insert the following data:</p>
<pre><code>[Database]
folder = &#34;data&#34;
host = &#34;data/website.db&#34;
name = &#34;website&#34;
user = &#34;user&#34;
pass = &#34;&#34;

[Server]
website = &#34;https://myurl.org&#34;
title = &#34;Nim Website&#34;
url = &#34;127.0.0.1&#34;
port = &#34;7000&#34;
</code></pre>


<hr/>


<p>This file is our main file. It is within this we&#39;ll import and include our files. Create a file <kbd>nimweb/main.nim</kbd></p>


<h3>Import required libraries</h3>
<p>Insert the following at the top of your new file.</p>

<pre><code>import db_sqlite # SQLite
import jester    # Our webserver
import logging   # Logging utils
import os        # Used to get arguments
import parsecfg  # Parse our config file
import strutils  # Basic functions
import times     # Time and date
import uri       # We need to encode urls: encodeUrl()
import code/database_utils # Utils used in the database
import code/password_utils # Our file with password utils
</code></pre>


<h3>Parse config.cfg</h3>
<p>We&#39;ll start by reading and parsing the <kbd>config.cfg</kbd> to get the database information.</p>

<pre><code># First we&#39;ll load config files
let dict = loadConfig(&#34;config/config.cfg&#34;)

# Now we get the values and assign them.
# We do not need to change them later, therefore
# we&#39;ll use `let`
let db_user   = dict.getSectionValue(&#34;Database&#34;, &#34;user&#34;)
let db_pass   = dict.getSectionValue(&#34;Database&#34;, &#34;pass&#34;)
let db_name   = dict.getSectionValue(&#34;Database&#34;, &#34;name&#34;)
let db_host   = dict.getSectionValue(&#34;Database&#34;, &#34;host&#34;)

let mainURL   = dict.getSectionValue(&#34;Server&#34;, &#34;url&#34;)
let mainPort  = parseInt dict.getSectionValue(&#34;Server&#34;, &#34;port&#34;)
let mainWebsite = dict.getSectionValue(&#34;Server&#34;, &#34;website&#34;)
</code></pre>


<h3>Database variable</h3>
<p>We are assigning <kbd>db</kbd> to our database connection. Each time we need to access the database, we can just use <kbd>db</kbd>. The assigning happens later on..</p>

<pre><code># Database var
var db: DbConn
</code></pre>



<h3>Setup our webserver</h3>
<p>We&#39;ll assign jester (our webserver) with the port and address. These values originate from our config.cfg file.</p>

<pre><code># Jester setting server settings
settings:
  port = Port(mainPort)
  bindAddr = mainURL
</code></pre>


<h3>User management</h3>
<p>In this tutorial we&#39;ll only add 1 user - the Admin</p>

<h4>User details</h4>
<p>When the admin user login, we&#39;ll assign values to user. These values &#34;follows&#34; the user around; that allows us to access them everywhere, e.g. the users email.</p>

<p>The user details are assigned to a <kbd>c</kbd>. This is passed around as <kbd>c: var TData</kbd></p>

<h4>Setup a type containing the user data</h4>
<pre><code># Setup user data
type
  TData* = ref object of RootObj
    loggedIn*: bool
    userid, username*, userpass*, email*: string
    req*: Request
</code></pre>

<p>The <kbd>init()</kbd> proc reset the user values to ensure, that the user is logged in, and that the values always correspond to the latest values stored in the database.</p>
<pre><code>proc init(c: var TData) =
  ## Empty out user session data
  c.userpass = &#34;&#34;
  c.username = &#34;&#34;
  c.userid   = &#34;&#34;
  c.loggedIn = false
</code></pre>

<h4>Check if the user is logged in</h4>
<p>Each time the user is requesting a new page, we have to check if the user is logged in. We do that by checking, if the user has a username assigned (we&#39;ll assign the username later).</p>

<pre><code>func loggedIn(c: TData): bool =
  ## Check if user is logged in by verifying that c.username exists
  c.username.len &gt; 0
</code></pre>

<h4>Full check: is the user logged in</h4>
<p>We create a proc to check our database table <kbd>session</kbd> to see, if their cookie and IP matches.</p>

<pre><code>proc checkLoggedIn(c: var TData) =
  ## Check if user is logged in

  # Get the users cookie named `sid`. If it does not exist, return
  if not c.req.cookies.hasKey(&#34;sid&#34;): return

  # Assign cookie to `let sid`
  let sid = c.req.cookies[&#34;sid&#34;]

  # Update the value <kbd>lastModified</kbd> for the user in the
  # table session where the sid and IP match. If there&#39;s
  # any results (above 0) assign values
  if execAffectedRows(db, sql(&#34;UPDATE session SET lastModified = &#34; &amp; $toInt(epochTime()) &amp; &#34; &#34; &amp; &#34;WHERE ip = ? AND key = ?&#34;), c.req.ip, sid) &gt; 0:

    # Get user data based on userID from session table
    # Assign values to user details - `c`
    c.userid = getValue(db, sql&#34;SELECT userid FROM session WHERE ip = ? AND key = ?&#34;, c.req.ip, sid)

    # Get user data based on userID from person table
    let row = getRow(db, sql&#34;SELECT name, email, status FROM person WHERE id = ?&#34;, c.userid)

    # Assign user data
    c.username  = row[0]
    c.email     = toLowerAscii(row[1])

    # Update our session table with info about activity
    discard tryExec(db, sql&#34;UPDATE person SET lastOnline = ? WHERE id = ?&#34;, toInt(epochTime()), c.userid)

  else:
    # If the user is not found in the session table
    c.loggedIn = false
</code></pre>

<h4>Login proc</h4>
<p>Next we create a proc used for login. This proc is only used when the user logs in.</p>

<pre><code>proc login(c: var TData, email, pass: string): tuple[b: bool, s: string] =
  ## User login

  # We have predefined query
  const query = sql&#34;SELECT id, name, password, email, salt, status FROM person WHERE email = ?&#34;

  # If the email or pass passed in the proc&#39;s parameters is empty, fail
  if email.len == 0 or pass.len == 0:
    return (false, &#34;Missing password or username&#34;)

  # We&#39;ll use fastRows for a quick query.
  # Notice that the email is set to lower ascii
  # to avoid problems if the user has any
  # capitalized letters.
  for row in fastRows(db, query, toLowerAscii(email)):

    # Now our password library is going to work. It&#39;ll
    # check the password against the hashed password
    # and salt.
    if row[2] == makePassword(pass, row[4], row[2]):
      # Assign the values
      c.userid   = row[0]
      c.username = row[1]
      c.userpass = row[2]
      c.email    = toLowerAscii(row[3])

      # Generate session key and save it
      let key = makeSessionKey()
      exec(db, sql&#34;INSERT INTO session (ip, key, userid) VALUES (?, ?, ?)&#34;, c.req.ip, key, row[0])

      info(&#34;Login successful&#34;)
      return (true, key)

  info(&#34;Login failed&#34;)
  return (false, &#34;Login failed&#34;)
</code></pre>

<h4>A logout proc</h4>
<p>The logout proc deletes the users instance in the session table. This results in, that the proc <kbd>checkLoggedIn()</kbd> cannot find any matching values to users sid and IP.</p>
<pre><code>proc logout(c: var TData) =
  ## Logout

  c.username = &#34;&#34;
  c.userpass = &#34;&#34;
  const query = sql&#34;DELETE FROM session WHERE ip = ? AND key = ?&#34;
  exec(db, query, c.req.ip, c.req.cookies[&#34;sid&#34;])
</code></pre>

<h4>Do the check inside our routes</h4>
<p>Template used in our routes. The template is &#34;injected&#34; into all of our URL routes, where it uses the proc&#39;s above to check if the user is logged in.</p>
<p>You&#39;ll see this template used in the routes-files.</p>

<pre><code>template createTFD() =
  ## Check if logged in and assign data to user

  # Assign the c to TDATA
  var c {.inject.}: TData
  # New instance of c
  new(c)
  # Set standard values
  init(c)
  # Get users request
  c.req = request
  # Check for cookies (we need the cookie named sid)
  if cookies(request).len &gt; 0:
    # Check if user is logged in
    checkLoggedIn(c)
  # Use the func()
  c.loggedIn = loggedIn(c)
</code></pre>



<h3>isMainModule</h3>
<p><kbd>when isMainModule:</kbd> is running when the file is the main module, which this is!</p>

<p>Insert the following:</p>

<pre><code>when isMainModule:
  echo &#34;Nim Web is now running: &#34; &amp; $now()

  # Generate DB if newdb is in the arguments
  # or if the database does not exists
  if &#34;newdb&#34; in commandLineParams() or not fileExists(db_host):
    generateDB()
    quit()

  # Connect to DB
  try:
    # We are using the values which we assigned earlier
    db = open(connection=db_host, user=db_user, password=db_pass, database=db_name)
    info(&#34;Connection to DB is established.&#34;)
  except:
    fatal(&#34;Connection to DB could not be established.&#34;)
    sleep(5_000)
    quit()

  # Add an admin user if newuser is in the args
  if &#34;newuser&#34; in commandLineParams():
    createAdminUser(db, commandLineParams())
    quit()
</code></pre>

<h4>Include template files</h4>

<p>The only thing we now are missing is our URL routes and HTML templates. We are going to include the HTML-Nim files which means, that they are inserted 1-1 into our code instead of being imported.</p>

<pre><code>include &#34;tmpl/main.tmpl&#34;
include &#34;tmpl/user.tmpl&#34;
</code></pre>

<h4>Setup routes (URL&#39;s)</h4>

<p>Routes is the name for our URL&#39;s.</p>

<pre><code>routes:
  get &#34;/&#34;:
    createTFD()
    resp genMain(c)

  get &#34;/secret&#34;:
    createTFD()
    if c.loggedIn:
      resp genSecret(c)

  get &#34;/login&#34;:
    createTFD()
    resp genLogin(c, @&#34;msg&#34;)

  post &#34;/dologin&#34;:
    createTFD()

    let (loginB, loginS) = login(c, replace(toLowerAscii(@&#34;email&#34;), &#34; &#34;, &#34;&#34;), replace(@&#34;password&#34;, &#34; &#34;, &#34;&#34;))
    if loginB:
      when defined(dev):
        jester.setCookie(&#34;sid&#34;, loginS, daysForward(7))
      else:
        jester.setCookie(&#34;sid&#34;, loginS, daysForward(7), samesite = Lax, secure = true, httpOnly = true)
      redirect(&#34;/secret&#34;)
    else:
      redirect(&#34;/login?msg=&#34; &amp; encodeUrl(loginS))

  get &#34;/logout&#34;:
    createTFD()
    logout(c)
    redirect(&#34;/&#34;)
</code></pre>


<hr/>


<p>Create the password file here <kbd>nimweb/code/password_utils.nim</kbd> and insert:</p>

<pre><code>import md5, bcrypt, math, random, os
randomize()

var urandom: File
let useUrandom = urandom.open(&#34;/dev/urandom&#34;)

proc makeSalt*(): string =
  ## Generate random salt. Uses cryptographically secure /dev/urandom
  ## on platforms where it is available, and Nim&#39;s random module in other cases.
  result = &#34;&#34;
  if useUrandom:
    var randomBytes: array[0..127, char]
    discard urandom.readBuffer(addr(randomBytes), 128)
    for ch in randomBytes:
      if ord(ch) in {32..126}:
        result.add(ch)
  else:
    for i in 0..127:
      result.add(chr(rand(94) + 32)) # Generate numbers from 32 to 94 + 32 = 126

proc makeSessionKey*(): string =
  ## Creates a random key to be used to authorize a session.
  let random = makeSalt()
  return bcrypt.hash(random, genSalt(8))


proc makePassword*(password, salt: string, comparingTo = &#34;&#34;): string =
  ## Creates an MD5 hash by combining password and salt
  let bcryptSalt = if comparingTo != &#34;&#34;: comparingTo else: genSalt(8)
  result = hash(getMD5(salt &amp; getMD5(password)), bcryptSalt)
</code></pre>


<hr/>


<p>Create the file <kbd>nimweb/code/database_utils</kbd></p>
<p>This file will contain 2 procs: 1 for generating the database and 1 for creating the admin user. Insert both of the proc&#39;s into the file.</p>

<h3>Generating database</h3>
<pre><code>import db_sqlite, os, parsecfg, strutils, logging
import ../code/password_utils

proc generateDB*() =
  echo &#34;Generating database&#34;

  # Load the connection details
  let
    dict = loadConfig(&#34;config/config.cfg&#34;)
    db_user = dict.getSectionValue(&#34;Database&#34;,&#34;user&#34;)
    db_pass = dict.getSectionValue(&#34;Database&#34;,&#34;pass&#34;)
    db_name = dict.getSectionValue(&#34;Database&#34;,&#34;name&#34;)
    db_host = dict.getSectionValue(&#34;Database&#34;,&#34;host&#34;)
    db_folder = dict.getSectionValue(&#34;Database&#34;,&#34;folder&#34;)
    dbexists = if fileExists(db_host): true else: false

  if dbexists:
    echo &#34; - Database already exists. Inserting tables if they do not exist.&#34;

  # Creating database folder if it doesn&#39;t exist
  discard existsOrCreateDir(db_folder)

  # Open DB
  echo &#34; - Opening database&#34;
  var db = open(connection=db_host, user=db_user, password=db_pass, database=db_name)

  # Person table contains information about the
  # registrered users
  if not db.tryExec(sql(&#34;&#34;&#34;
  create table if not exists person(
    id integer primary key,
    name varchar(60) not null,
    password varchar(300) not null,
    email varchar(254) not null,
    creation timestamp not null default (STRFTIME(&#39;%s&#39;, &#39;now&#39;)),
    modified timestamp not null default (STRFTIME(&#39;%s&#39;, &#39;now&#39;)),
    salt varbin(128) not null,
    status varchar(30) not null,
    timezone VARCHAR(100),
    secretUrl VARCHAR(250),
    lastOnline timestamp not null default (STRFTIME(&#39;%s&#39;, &#39;now&#39;))
  );&#34;&#34;&#34;)):
    echo &#34; - Database: person table already exists&#34;

  # Session table contains information about the users
  # cookie ID, IP and last visit
  if not db.tryExec(sql(&#34;&#34;&#34;
  create table if not exists session(
    id integer primary key,
    ip inet not null,
    key varchar(300) not null,
    userid integer not null,
    lastModified timestamp not null default (STRFTIME(&#39;%s&#39;, &#39;now&#39;)),
    foreign key (userid) references person(id)
  );&#34;&#34;&#34;)):
    echo &#34; - Database: session table already exists&#34;
</code></pre>

<h3>Generating admin user</h3>
<p>This proc generates the admin user using arguments passed when running the program. To generate the user, you have to provide the following arguments:</p>
<p><kbd>./main newuser u:UserName p:Password e:email@email.com</kbd></p><pre><code>
proc createAdminUser*(db: DbConn, args: seq[string]) =
  ## Create new admin user

  var iName = &#34;&#34;
  var iEmail = &#34;&#34;
  var iPwd = &#34;&#34;

  # Loop through all the arguments and get the args
  # containing the user information
  for arg in args:
    if arg.substr(0, 1) == &#34;u:&#34;:
      iName = arg.substr(2, arg.len())
    elif arg.substr(0, 1) == &#34;p:&#34;:
      iPwd = arg.substr(2, arg.len())
    elif arg.substr(0, 1) == &#34;e:&#34;:
      iEmail = arg.substr(2, arg.len())

  # If the name, password or emails does not exists
  # return error
  if iName == &#34;&#34; or iPwd == &#34;&#34; or iEmail == &#34;&#34;:
    error(&#34;Missing either name, password or email to create the Admin user.&#34;)

  # Generate the password using a salt and hashing.
  # Read more about hashing and salting here:
  #   - https://crackstation.net/hashing-security.htm
  #   - https://en.wikipedia.org/wiki/Salt_(cryptography)
  let salt = makeSalt()
  let password = makePassword(iPwd, salt)

  # Insert user into database
  if insertID(db, sql&#34;INSERT INTO person (name, email, password, salt, status) VALUES (?, ?, ?, ?, ?)&#34;, $iName, $iEmail, password, salt, &#34;Admin&#34;) &gt; 0:
    echo &#34;Admin user added&#34;
  else:
    error(&#34;Something went wrong&#34;)

  info(&#34;Admin added.&#34;)
</code></pre>

<hr/>


<p>The templates is a mix of HTML and Nim. The Nim code is identified with a hashtag in the files: #</p>

<h3>main.tmpl</h3>

<p>Create the file <kbd>nimweb/tmpl/main.tmpl</kbd></p>

<pre><code>#? stdtmpl | standard
#
#proc genMain(c: var TData): string =
# result = &#34;&#34;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/style.css&#34;&gt;
&lt;h1&gt;Hello World&lt;/h1&gt;
#end proc
#
#proc genSecret(c: var TData): string =
# result = &#34;&#34;
&lt;h1&gt;Welcome to the secret World&lt;/h1&gt;
#end proc
</code></pre>

<h3>user.tmpl</h3>

<p>Create the file <kbd>nimweb/tmpl/user.tmpl</kbd></p>

<pre><code>#? stdtmpl | standard
#
#proc genLogin(c: var TData, errorMsg = &#34;&#34;): string =
# result = &#34;&#34;
# if not c.loggedIn:
  &lt;div id=&#34;login&#34;&gt;
    &lt;form name=&#34;login&#34; action=&#34;/dologin&#34; method=&#34;POST&#34; class=&#34;box&#34;&gt;
      &lt;h3 style=&#34;line-height: 1.9rem;&#34;&gt;Login&lt;/h3&gt;

      # if errorMsg.len() != 0:
      &lt;div class=&#34;notification is-danger&#34; style=&#34;text-align: center;font-size: 1.2rem; line-height: 1.8rem;&#34;&gt;&lt;b&gt;${errorMsg}&lt;/b&gt;&lt;/div&gt;
      # end if

      &lt;div class=&#34;field form-group&#34;&gt;
        &lt;label class=&#34;label&#34;&gt;Email&lt;/label&gt;
        &lt;div class=&#34;control has-icons-left has-icons-right&#34;&gt;
          &lt;input type=&#34;email&#34; class=&#34;form-control input is-rounded&#34; name=&#34;email&#34; placeholder=&#34;Email&#34; minlength=&#34;5&#34; dir=&#34;auto&#34; required autofocus&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&#34;field form-group&#34;&gt;
        &lt;label class=&#34;label&#34;&gt;Password&lt;/label&gt;
        &lt;div class=&#34;control has-icons-left has-icons-right&#34;&gt;
          &lt;input type=&#34;password&#34; class=&#34;form-control input is-rounded&#34; name=&#34;password&#34; autocomplete=&#34;current-password&#34; minlength=&#34;4&#34; placeholder=&#34;Password&#34; dir=&#34;auto&#34; required&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;input href=&#34;#&#34; type=&#34;submit&#34; class=&#34;btn btn-custom btn-blue-secondary button is-primary is-fullwidth is-rounded&#34; value=&#34;Login&#34; /&gt;

    &lt;/form&gt;
  &lt;/div&gt;

  #else:
  &lt;div class=&#34;notification is-danger&#34; style=&#34;text-align: center&#34;&gt;
    &lt;h1&gt;You are already logged in!&lt;/h1&gt;
  &lt;/div&gt;
# end if
#end proc
</code></pre>

<hr/>


<p>Stylesheets (CSS) and Javascript files can be loaded from the public folder. Let&#39;s create CSS file.</p>

<p>Create the file <kbd>nimweb/public/style.css</kbd></p>

<pre><code>h1 { color: red; }
</code></pre>

<hr/>


<p>We are now ready to startup our little website. First we&#39;ll compile it, then we generate the database and then we add the admin user.</p>
<pre><code># Compile
nim c main.nim

# Generate database
./main newdb

# Add admin user
./main newuser u:Admin p:Pass e:email@email.com

# Run
./main

# Now access your website on 127.0.0.1:7000
# Login on 127.0.0.1:7000/login
</code></pre>

<hr/>
<hr/>


<h3>Webserver</h3>
<p>If you want to use your new program in production so other people can access it, you should setup a webserver in front of it, e.g. Nginx.</p>

<h3>SSL</h3>
<p>To activate SSL due to a SSL certificate or if you are loading HTTPS resources, you need to compile with <kbd>-d:ssl</kbd></p>












</div>
    
    
    
    
  </div>
  </div></div>
  </body>
</html>
