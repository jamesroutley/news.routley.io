<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rgoswami.me/posts/parameter-passing-nwchem-rtdb/">Original</a>
    <h1>Parameter passing in NWChem and the Runtime Database</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>This post is part of the <a href="https://rgoswami.me/series/simulation-software-patterns/">Simulation Software Patterns</a> series.</p></div><blockquote><p>Thoughts on parameter passing through the RTDB within NWChem.</p></blockquote><h2 id="background">Background</h2><p>Despite a plethora of publications (<a href="https://flak.tedunangst.com/posts/parameter-passing-nwchem-rtdb/#ref-apraNWChemPresentFuture2020">Aprà et al.
2020</a>; <a href="https://flak.tedunangst.com/posts/parameter-passing-nwchem-rtdb/#ref-mejia-rodriguezNWChemRecentOngoing2023">Mejia-Rodriguez et al.
2023</a>), NWChem has little
to nothing in terms of developer documentation <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. For better
integration over sockets with EON (described elsewhere), I ended up
having to add user defined parameters, from which this short note stems.</p><h2 id="inputs-in-nwchem">Inputs in NWChem</h2><p>The input file format in NWChem, like most codes of the era, consist of
a keyword driven, whitespace delimited, block structured set of
directives which are parsed once into a database and propagated across
other modules.</p><h2 id="fn:runtime-database--rtdb">Runtime Database (RTDB)</h2><p>The run time database, as noted in (<a href="https://flak.tedunangst.com/posts/parameter-passing-nwchem-rtdb/#ref-bernholdtParallelComputationalChemistry1995">Bernholdt et al.
1995</a>; <a href="https://flak.tedunangst.com/posts/parameter-passing-nwchem-rtdb/#ref-guestHighperformanceComputingChemistry1996">Guest et al.
1996</a>), is similar to
the GAMESS dump file or GAUSSIAN checkpoint file. Allegedly it is easier
and safer than both, and arrays of typed data are stored with ASCII
strings for keys. Though the GAMESS and GAUSSIAN notes are not an
immediately recognizable point of reference either, but it is
essentially a key value store which is used to circumvent having an
interoperable data-structure.</p><p>This centralized key-value approach decouples modules from the specifics
of the input file; a routine only needs to know the key for a parameter,
not how or where it was parsed. This contrasts with approaches where
configuration objects must be passed through long call stacks or where
multiple components parse the same configuration file independently.</p><h2 id="adding-parameters-to-nwchem-through-the-rtdb">Adding parameters to NWChem through the RTDB</h2><p>Here, we will only be interested in this section:</p><div><pre tabindex="0"><code data-lang="cfg"><span><span>1</span><span><span>driver</span>
</span></span><span><span>2</span><span>  <span>socket unix eon_nwchem</span>
</span></span><span><span>3</span><span><span>end</span>
</span></span></code></pre></div><p>Which can be abstracted into:</p><div><pre tabindex="0"><code data-lang="cfg"><span><span>1</span><span><span>driver</span>
</span></span><span><span>2</span><span>  <span>socket (unix || ipi_client) &lt;socketname&gt;</span>
</span></span><span><span>3</span><span><span>end</span>
</span></span></code></pre></div><p>Concretely, we will consider the case of adding optional parameters to
this so as to enable the following design:</p><div><pre tabindex="0"><code data-lang="cfg"><span><span>1</span><span><span>driver</span>
</span></span><span><span>2</span><span>  <span>socket (unix || ipi_client) &lt;socketname&gt; [retries &lt;int&gt;] [delay &lt;int&gt;]</span>
</span></span><span><span>3</span><span><span>end</span>
</span></span></code></pre></div><p>Conceptually this involves:</p><dl><dt>Parsing</dt><dd>To extract data from the input</dd><dt>Storing</dt><dd>Committing parsed values into the RTDB with <code>rtdb_put</code></dd><dt>Retrieving</dt><dd>Accessing the values from the RTDB with <code>rtdb_get</code></dd></dl><div><p><strong>Note</strong></p><p>The complete changeset required is enumerated in the <a href="https://github.com/nwchemgit/nwchem/pull/1145">pull
request</a> with a
documentation update to the wiki
<a href="https://github.com/nwchemgit/nwchem-wiki/pull/39">here</a>.</p></div><h3 id="parsing-optional-keyword-arguments">Parsing optional keyword arguments</h3><p>Naming follows a conventional scheme<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, so the
<code>src/driver/driver_input.F</code> is the first port of call. The
implementation involves setting defaults and then looping through
remaining fields on the line to check for overrides.</p><div><pre tabindex="0"><code data-lang="f90"><span><span> 1</span><span><span>! socket ipi_client ip:port [retries &lt;int&gt;] [delay &lt;int&gt;]
</span></span></span><span><span> 2</span><span><span></span><span>max_retries</span><span> </span><span>=</span><span> </span><span>30</span><span>
</span></span></span><span><span> 3</span><span><span></span><span>retry_delay</span><span> </span><span>=</span><span> </span><span>2</span><span>
</span></span></span><span><span> 4</span><span><span></span><span>do</span><span> </span><span>while</span><span> </span><span>(</span><span>inp_a</span><span>(</span><span>field</span><span>))</span><span>
</span></span></span><span><span> 5</span><span><span>   </span><span>if</span><span> </span><span>(</span><span>inp_compare</span><span>(.</span><span>false</span><span>.,</span><span> </span><span>&#39;retries&#39;</span><span>,</span><span> </span><span>field</span><span>))</span><span> </span><span>then</span><span>
</span></span></span><span><span> 6</span><span><span>      </span><span>if</span><span> </span><span>(.</span><span>not</span><span>.</span><span> </span><span>inp_i</span><span>(</span><span>max_retries</span><span>))</span><span>
</span></span></span><span><span> 7</span><span><span>      </span><span>call</span><span> </span><span>errquit</span><span>(</span><span>&#39;driver_input: expected integer for retries&#39;</span><span>,</span><span> </span><span>0</span><span>,</span><span>INPUT_ERR</span><span>)</span><span>
</span></span></span><span><span> 8</span><span><span>   </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>inp_compare</span><span>(.</span><span>false</span><span>.,</span><span> </span><span>&#39;delay&#39;</span><span>,</span><span> </span><span>field</span><span>))</span><span> </span><span>then</span><span>
</span></span></span><span><span> 9</span><span><span>      </span><span>if</span><span> </span><span>(.</span><span>not</span><span>.</span><span> </span><span>inp_i</span><span>(</span><span>retry_delay</span><span>))</span><span>
</span></span></span><span><span>10</span><span><span>      </span><span>call</span><span> </span><span>errquit</span><span>(</span><span>&#39;driver_input: expected int for delay&#39;</span><span>,</span><span>0</span><span>,</span><span>INPUT_ERR</span><span>)</span><span>
</span></span></span><span><span>11</span><span><span>   </span><span>end</span><span> </span><span>if</span><span>
</span></span></span><span><span>12</span><span><span></span><span>end</span><span> </span><span>do</span><span>
</span></span></span></code></pre></div><p>Where <code>inp_a</code> parses a keyword, <code>inp_compare</code> checks against an expected
value, and <code>inp_i</code> parses the value as an integer.</p><h3 id="comitting-values-to-the-rtdb">Comitting values to the RTDB</h3><p>Once stored in a local variable, the value is then committed to the RTDB
using <code>rtdb_put</code>, which is namespaced for modularity and to reduce key
conflicts.</p><div><pre tabindex="0"><code data-lang="f90"><span><span>1</span><span><span>if</span><span> </span><span>(</span><span>inp_compare</span><span>(.</span><span>false</span><span>.,</span><span>&#39;retries&#39;</span><span>,</span><span>field</span><span>))</span><span> </span><span>then</span><span>
</span></span></span><span><span>2</span><span><span>  </span><span>if</span><span> </span><span>(.</span><span>not</span><span>.</span><span> </span><span>inp_i</span><span>(</span><span>max_retries</span><span>))</span><span> </span><span>call</span><span> </span><span>errquit</span><span>(...)</span><span>
</span></span></span><span><span>3</span><span><span>    </span><span>if</span><span> </span><span>(.</span><span>not</span><span>.</span><span> </span><span>rtdb_put</span><span>(</span><span>rtdb</span><span>,</span><span>&#39;driver:socket_retries&#39;</span><span>,</span><span>mt_int</span><span>,</span><span>1</span><span>,</span><span>max_retries</span><span>))</span><span> </span><span>call</span><span> </span><span>errquit</span><span>(...)</span><span>
</span></span></span><span><span>4</span><span><span></span><span>end</span><span> </span><span>if</span><span>
</span></span></span></code></pre></div><p>Where the signature notes the number of elements (<code>1</code>) being stored
along with the type (<code>mt_int</code>).</p><h3 id="retrieval-and-usage">Retrieval and usage</h3><p>Where the values are to be retrieved, say, here in
<code>src/driver/socket_driver.F</code>, defaults are used if the key is missing.</p><div><pre tabindex="0"><code data-lang="f90"><span><span>1</span><span><span>if</span><span> </span><span>(.</span><span>not</span><span>.</span><span> </span><span>rtdb_get</span><span>(</span><span>rtdb</span><span>,</span><span> </span><span>&#39;driver:socket_retries&#39;</span><span>,</span><span> </span><span>mt_int</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>max_retries</span><span>))</span><span> </span><span>then</span><span>
</span></span></span><span><span>2</span><span><span>   </span><span>max_retries</span><span> </span><span>=</span><span> </span><span>30</span><span>
</span></span></span><span><span>3</span><span><span></span><span>end</span><span> </span><span>if</span><span>
</span></span></span></code></pre></div><p>Before being used as needed. The signature of <code>rtdb_get</code> conceptually
mimics that of <code>rtdb_put</code>. In practice, since these are FORTRAN 77 files
in <code>nwchem</code>, there are a few more continuation line characters and other
marginalia, but otherwise this is all that is necessary to expose user
parameters to modules in NWChem.</p><h2 id="conclusions">Conclusions</h2><p>Although not the design taken by more modern software, the RTDB is
pretty intuitive to work with, and probably better than GAMESS,
GAUSSIAN, or even the bring your own data into a simulation development
environment idea of NWChemEx (<a href="https://flak.tedunangst.com/posts/parameter-passing-nwchem-rtdb/#ref-richardDevelopingComputationalChemistry2019">Richard et al.
2019</a>). Better
documentation would probably stemmed the split. Modern tools (e.g. EON)
improve upon this by using more structured input files, e.g. using TOML
ensures typing which can then be independently read into C/C++/Fortran
etc. though the issue of consistency at runtime remains.</p><h2 id="references">References</h2><div id="refs" entry-spacing="0"><p>Aprà, E., E. J. Bylaska, W. A. De Jong, N. Govind, K. Kowalski, T. P.
Straatsma, M. Valiev, et al. 2020. “NWChem: Past, Present, and Future.”
<em>Journal of Chemical Physics</em> 152 (18): 184102.
<a href="https://doi.org/10.1063/5.0004997">https://doi.org/10.1063/5.0004997</a>.</p><p>Bernholdt, D. E., E. Apr, H. A. Frchtl, M. F. Guest, R. J. Harrison, R.
A. Kendall, R. A. Kutteh, et al. 1995. “Parallel Computational Chemistry
Made Easier: The Development of NWChem.” <em>International Journal of
Quantum Chemistry</em> 56 (S29): 475–83.
<a href="https://doi.org/10.1002/qua.560560851">https://doi.org/10.1002/qua.560560851</a>.</p><p>Guest, M. F., E. Apra, D. E. Bernholdt, H. A. Früchtl, R. J. Harrison,
R. A. Kendall, R. A. Kutteh, et al. 1996. “High-Performance Computing in
Chemistry: NW Chem.” <em>Future Generation Computer Systems</em> 12 (4):
273–89. <a href="https://doi.org/10.1016/S0167-739X%2897%2980002-E">https://doi.org/10.1016/S0167-739X(97)80002-E</a>.</p><p>Kowalski, Karol, Raymond Bair, Nicholas P. Bauman, Jeffery S. Boschen,
Eric J. Bylaska, Jeff Daily, Wibe A. De Jong, et al. 2021. “From NWChem
to NWChemEx: Evolving with the Computational Chemistry Landscape.”
<em>Chemical Reviews</em> 121 (8): 4962–98.
<a href="https://doi.org/10.1021/acs.chemrev.0c00998">https://doi.org/10.1021/acs.chemrev.0c00998</a>.</p><p>Mejia-Rodriguez, Daniel, Edoardo Aprà, Jochen Autschbach, Nicholas P.
Bauman, Eric J. Bylaska, Niranjan Govind, Jeff R. Hammond, et al. 2023.
“NWChem: Recent and Ongoing Developments.” <em>Journal of Chemical Theory
and Computation</em> 19 (20): 7077–96.
<a href="https://doi.org/10.1021/acs.jctc.3c00421">https://doi.org/10.1021/acs.jctc.3c00421</a>.</p><p>Richard, Ryan M., Colleen Bertoni, Jeffery S. Boschen, Kristopher
Keipert, Benjamin Pritchard, Edward F. Valeev, Robert J. Harrison, Wibe
A. De Jong, and Theresa L. Windus. 2019. “Developing a Computational
Chemistry Framework for the Exascale Era.” <em>Computing in Science &amp;
Engineering</em> 21 (2): 48–58.
<a href="https://doi.org/10.1109/MCSE.2018.2884921">https://doi.org/10.1109/MCSE.2018.2884921</a>.</p></div><hr/><div><h2>Series info</h2><h3>Simulation Software Patterns series</h3><ol><li><b>Parameter passing in NWChem and the Runtime Database</b> &lt;-- You are here!</li></ol></div></div></div>
  </body>
</html>
