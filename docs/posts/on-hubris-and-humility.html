<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cliffle.com/blog/on-hubris-and-humility/">Original</a>
    <h1>On Hubris and Humility</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  <header>
    
    
  </header>
  
  <p><span>2021-12-06</span></p><ul>
    
      <li><a href="http://cliffle.com/blog/on-hubris-and-humility/#intro">Intro</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/on-hubris-and-humility/#a-whirlwind-tour-of-hubris">A whirlwind tour of Hubris</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/on-hubris-and-humility/#synchronicity-it-s-nice">Synchronicity: it’s nice</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/on-hubris-and-humility/#types-they-re-good">Types: they’re good</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/on-hubris-and-humility/#application-debugger-co-design">Application-Debugger Co-Design</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/on-hubris-and-humility/#conclusion">Conclusion</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/on-hubris-and-humility/#epilogue">Epilogue</a>
        
        </li>
    
  </ul>
  
  
<p>Last week I gave a talk at the Open Source Firmware Conference about some of the
work I’m doing at Oxide Computer, entitled <em>On Hubris and Humility.</em> There is <a href="https://talks.osfc.io/osfc2021/talk/JTWYEH/">a
video of the talk</a> if you’d like to
watch it in video form. It came out pretty alright!</p>
<p>The conference version of the talk has a constantly animated background that
makes the video hard for some people to watch. OSFC doesn’t appear to be
bothering with either captions or transcripts, so my friends who don’t hear as
well as I do (or just don’t want to turn their speakers on!) are kind of out of
luck.</p>
<p>And so, here’s a transcript with my slides inlined. The words may not exactly
match the audio because this is written from my speaker’s notes. And, yes, my
slides are all character art. The browser rendering is imperfect.</p>
<p>I’ve also written an epilogue at the end after the initial response to the talk.</p>
<ul>
<li><a href="https://github.com/oxidecomputer/hubris">Hubris repo</a></li>
<li><a href="https://hubris.oxide.computer/reference/">Hubris reference manual</a> in case
you don’t feel like you’ve read enough of my writing today</li>
</ul>

<pre><code><span>    ▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏                                                
</span><span>▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏                                                
</span><span>▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏▏                                                        
</span><span>                                                                                
</span><span>                                                                                
</span><span>                       ▄▄         ▗  ▖    ▐        ▝                            
</span><span>                      ▗▘▝▖▗▗▖     ▐  ▌▗ ▗ ▐▄▖  ▖▄ ▗▄   ▄▖                       
</span><span>                      ▐  ▌▐▘▐     ▐▄▄▌▐ ▐ ▐▘▜  ▛ ▘ ▐  ▐ ▝                       
</span><span>                      ▐  ▌▐ ▐     ▐  ▌▐ ▐ ▐ ▐  ▌   ▐   ▀▚                       
</span><span>                       ▙▟ ▐ ▐     ▐  ▌▝▄▜ ▐▙▛  ▌  ▗▟▄ ▝▄▞                       
</span><span>                                                                                
</span><span>                 ▗▖       ▐     ▗  ▖         ▝  ▝▜   ▝   ▗                      
</span><span>                 ▐▌ ▗▗▖  ▄▟     ▐  ▌▗ ▗ ▗▄▄ ▗▄   ▐  ▗▄  ▗▟▄ ▗ ▗                 
</span><span>                 ▌▐ ▐▘▐ ▐▘▜     ▐▄▄▌▐ ▐ ▐▐▐  ▐   ▐   ▐   ▐  ▝▖▞                 
</span><span>                 ▙▟ ▐ ▐ ▐ ▐     ▐  ▌▐ ▐ ▐▐▐  ▐   ▐   ▐   ▐   ▙▌                 
</span><span>                ▐  ▌▐ ▐ ▝▙█     ▐  ▌▝▄▜ ▐▐▐ ▗▟▄  ▝▄ ▗▟▄  ▝▄  ▜                  
</span><span>                                                             ▞                  
</span><span>                                                            ▝▘                  
</span><span>                                                                                
</span><span>                   CLIFF L. BIFFLE ─── OXIDE COMPUTER COMPANY                   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                       ▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋      
</span><span>                                                ▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋
</span><span>                                                             ▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋▋
</span><span>
</span></code></pre>
<p>Hello. My name is Cliff, and I work at Oxide Computer Company. Today, I’ll be
talking about Hubris and Humility.</p>
<p>We at Oxide are building a new kind of server, and like many computers nowadays
it has a large central processor for running customer code, and several smaller
processors for housekeeping and management purposes. Unlike most manufacturers,
we’re writing the code that runs on all those processors ourselves.</p>
<p>To keep complexity down, we decided early on to go with microcontroller-class
processors for all the smaller supporting cores, such as the ARM Cortex-M series
or similar RISC-V CPUs. What these processors have in common is memory
protection hardware – <em>not</em>, importantly, memory mapping hardware or virtual
memory support. A typical implementation lets you apply protection attributes to
ranges of physical address space, which you can use to isolate programs from one
another. Or even just to catch null pointer dereferences, something a lot of
firmware environments don’t do.</p>
<p>Our goal is that our customers never have to think about or interact with these
processors unless they want to, which means that the software running on them
needs to be quite robust. We wanted to use the memory protection hardware to
support this goal.</p>
<p>If you’re looking for an operating system with memory protection support on this
class of processor, there are frankly not a lot of options. We evaluated
several, getting pretty far with one, but in each case we ran into serious
problems. And so in March 2020 we made the difficult decision to write our own,
at the same time that we were designing and building our first product.</p>
<p>This is <em>kind of</em> unreasonable, but not as unreasonable as it might sound.
We expected that the bulk of our time would go into writing drivers, and since
we were creating the hardware ourselves, no off-the-shelf choice would save us
time by providing canned drivers. In addition, by building the operating system
and the product at the same time, we could try to avoid speculative engineering
and build a system that covered our needs without excess generality. Even so, in
recognition of how the suggestion sounded, I named the project Hubris.</p>
<p>Today I’ll give a high-level overview of the system and how its parts fit
together, and then dive into the ways that our design goals, our use of Rust,
and our discoveries along the way have influenced the design process.</p>

<p>I’d like to start by taking you on a whirlwind tour of Hubris’s structure. I’ll
be touching on a lot of points here, but mostly superficially. Later in this
talk I’ll zoom in on some of them, and if you want to really dig in, there’s a
reference manual linked on the last slide.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                    SERVICE PROCESSOR APPLICATION COMPONENTS                    
</span><span>                                                                                
</span><span>                                                                                
</span><span>                          ┌────────────┐┌─────┐┌──────┐                         
</span><span>                          │ supervisor ││ rcc ││ gpio │                         
</span><span>                          └────────────┘└─────┘└──────┘                         
</span><span>                       ┌──────┐┌──────┐┌─────┐┌─────────┐                       
</span><span>                       │ spi2 ││ spi4 ││ i2c ││ spdprox │                       
</span><span>                       └──────┘└──────┘└─────┘└─────────┘                       
</span><span>                      ┌──────────┐┌─────────┐┌────────────┐                     
</span><span>                      │ spiflash ││ thermal ││ sequencing │                     
</span><span>                      └──────────┘└─────────┘└────────────┘                     
</span><span>                                ┌───────┐┌──────┐                               
</span><span>                                │ hiffy ││ idle │                               
</span><span>                                └───────┘└──────┘                               
</span><span>                                                                                
</span><span>                      ┌───────────────────────────────────┐                     
</span><span>                      │           hubris kernel           │                     
</span><span>                      └───────────────────────────────────┘                     
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>The best way to understand Hubris is to start with a worked example, and I’ve
chosen our most complex one, which is the Service Processor. Our Service
Processor is roughly analogous to the Baseboard Management Controller you might
find on a traditional server.</p>
<p>The Service Processor is one of the use cases that’s driving the development of
Hubris. We refer to a system like this, built with Hubris, as an <em>application</em>
of Hubris.</p>
<p>The service processor application, like most firmware, consists of a collection
of software pieces – represented by boxes here. Some of these are widely
reusable, such as utility code, or drivers for common devices, or the Hubris
kernel itself. Some are application-specific. Here we encounter the first thing
that makes Hubris unusual in its class: components such as these are separately
compiled and isolated from one another using the processor’s memory protection
hardware. We refer to these isolated components as <em>tasks.</em></p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                    SERVICE PROCESSOR APPLICATION COMPONENTS                    
</span><span>                                                                                
</span><span>                                                          ─┐                    
</span><span>                          ┌────────────┐┌─────┐┌──────┐    │                    
</span><span>                          │ supervisor ││ rcc ││ gpio │    │                    
</span><span>                          └────────────┘└─────┘└──────┘    │                    
</span><span>                       ┌──────┐┌──────┐┌─────┐┌─────────┐  │                    
</span><span>                       │ spi2 ││ spi4 ││ i2c ││ spdprox │  │ unprivileged,      
</span><span>                       └──────┘└──────┘└─────┘└─────────┘  │ isolated           
</span><span>                      ┌──────────┐┌─────────┐┌────────────┐│                    
</span><span>                      │ spiflash ││ thermal ││ sequencing ││                    
</span><span>                      └──────────┘└─────────┘└────────────┘│                    
</span><span>                                ┌───────┐┌──────┐          │                    
</span><span>                                │ hiffy ││ idle │          │                    
</span><span>                                └───────┘└──────┘          │                    
</span><span>                     ──────────────────────────────────────┤                    
</span><span>                      ┌───────────────────────────────────┐│                    
</span><span>                      │           hubris kernel           ││ privileged         
</span><span>                      └───────────────────────────────────┘│                    
</span><span>                                                          ─┘                    
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Tasks occupy separate areas of RAM and Flash, and cannot access one anothers’
memory directly. Separate compilation is important for making this robust: if a
library internally declares a global static variable, for instance, each task is
sure to get its own copy instead of trying to share.</p>
<p>But if every piece of the system were totally isolated from all the others, it
wouldn’t be a very useful system. Application tasks can communicate with one
another using a small set of inter-task interaction operations, which together
offer something that resembles a cross-task call operation. We informally refer
to tasks making these calls as <em>clients,</em> and the tasks handling them as
<em>servers,</em> though in a real system most tasks act as clients and servers
simultaneously, forming a hierarchy of task interaction.</p>
<p>Several of the tasks shown here are drivers, which
brings us to another unusual aspect of the system: drivers run in unprivileged
mode, outside the kernel, and are typically isolated in their own tasks. These
tasks get exclusive access to any memory mapped registers they require to do
their work, by way of the memory protection unit, and can claim hardware
interrupt signals, which the kernel will route to the task.</p>
<p>All this is assembled together into a cohesive image by the Hubris
build system, controlled by an application configuration file. And here we find
the third thing that makes Hubris unusual: Hubris is an aggressively static
system. The configuration file defines the full set of tasks that may ever be
running in the application. These tasks are assigned to sections of address
space by the build system, and they will forever occupy those sections.</p>
<p>Hubris has no operations for creating or destroying tasks at runtime. Task
resource requirements are determined during the build and are fixed once
deployed. This takes the kernel out of the resource allocation business.
Memories are the most visible resources we handle this way, but it applies to
all allocatable or routable resources, including hardware interrupts and
memory-mapped registers – all are explicitly wired up at compile time and
cannot be changed at runtime.</p>
<p>This notion of compile time configuration, static allocation, and specialization
of code extends up into application logic, as well. Tasks can be customized with
a tree of configuration data that is made available at compile time. It’s not
unusual for a single application such as the service processor to contain three
or four tasks all built from the same code with different configuration – for
instance, handling different SPI controllers. By transforming the configuration
data into constant expressions accessible by both the task and the compiler, we
can use generic code to generate compact, specialized binaries, <em>without</em>
littering the code with conditional compilation directives.</p>
<p>Now, you might be asking, if we can’t create or destroy tasks at runtime, how do
we deal with crashes or other software failures? The answer lies in the single
task control operation that Hubris <em>does</em> provide, which is in-place
reinitialization. When invoked, the reinitialization operation will, informally
speaking, stop the task, disconnect it from anything it was using, reset its
registers and stack to their default states, and then set it running.</p>
<p>The decision of <em>when</em> to reinitialize a task is left to the application, since
different applications may have different constraints. For instance, a driver
might require that other tasks be informed of its failure, or even restarted at
the same time. Applications choose a task to play the role of <em>supervisor.</em> When
any task in the application has a kernel visible fault, such as a memory access
violation, or an explicit call to <code>panic!</code>, the kernel records the fault and
delivers a notification to the supervisor task. The supervisor can then take any
action the application requires, such as restarting one or more tasks or
updating an event log.</p>
<p>With this plus some related mechanisms, we can implement recursive
component-level restarts in the service processor firmware. Our intent is for
the service processor itself to only reboot in truly catastrophic circumstances,
and we don’t consider a driver crash to be sufficiently catastrophic. Instead,
we restart the driver, and possibly some of its clients, and carry on.</p>
<p>Memory isolation is key to being able to restart components like this, by
limiting the “blast radius” of a malfunction. No matter how corrupt the state in
one task becomes, other tasks can expect their state to be okay.</p>
<p>Because of this, we don’t need to restrict how each task is written under the
hood. While most of Hubris itself and our application code is written in Rust’s
safe subset, which grants immunity from common classes of memory usage errors,
the <em>unsafe</em> subset of Rust is incredibly valuable, particularly when writing
fast drivers, or doing things like DMA. While code using unsafe Rust is still
significantly safer than C – for instance, array indexing is still checked and
integer overflows are still caught – it has access to operations that suppress
those checks, and so it has the ability to corrupt any memory it can reach if it
works hard enough. The combination of encouraging (but not requiring) safe Rust,
while using memory isolation as a backstop, gives us a lot more flexibility
without any loss of system-level safety.</p>
<p>Which is not to say things never go wrong – just that, when they do, it is not
typically a memory safety issue. It is <em>far</em> more likely to be a misread of a
component datasheet, a subtle interaction between two tasks, or a plain-old
logic error. In these cases, we break out Humility.</p>
<p>Humility is a Hubris-specific debugger, which we designed and implemented
concurrently with Hubris itself. It can connect to a live target system over
JTAG or SWD and provide live views of what’s going on inside – everything from
log output, to the state of all tasks, to individual task stack traces and
memory dumps. We expect that, despite our best efforts, we will ship products
containing bugs; unlike a lot of other companies, we <em>don’t</em> expect that our
servers will be allowed to “phone home” from a customer site. As a result, we’ve
also built out coredump support that can capture a complete snapshot of service
processor state into a file that can be loaded into Humility and debugged
off-site, should the customer elect to share it with us.</p>
<p>So – that’s the 10 kilometer view of Hubris and Humility. For the rest of my
time here, I’m going to zoom in on some particular areas of our experience that
I thought were particularly interesting or surprising.</p>

<p>The interaction between tasks and the Hubris kernel is fully synchronous. This
is somewhat unusual, and has some pleasant implications, some of which we saw
coming, and some of which surprised us.</p>
<p>First, I’ll unpack what I mean by “synchronous.”</p>
<p>As I’ve described, application code runs in isolated tasks, which communicate
with each other and with the kernel by making syscalls. These syscalls perform a
complete operation and then return. That might sound natural, but, a lot of
systems allow programs to queue up work to be performed by the kernel on their
behalf, perhaps receiving some kind of notification that the work is complete
later. </p>
<p>For systems like the ones we’re building, this has four problems.</p>
<p>First, it introduces a queueing problem into the kernel. Sizing such queues,
accounting for their resource usage, avoiding starvation, and producing proper
backpressure are difficult problems in real systems. How many asynchronous
operations can a given task have in flight? How will it behave if that limit is
reached? Will this condition occur when you’re testing the system, or will it
produce strange behaviors only at the worst time: when the system’s under heavy
load?</p>
<p>Second, it increases complexity of the system in the <em>last place</em> where you want
complexity: the kernel. Asynchronous systems need structures for keeping track
of in-flight operations, whether that’s kernel threads, in-kernel event
continuation and completion tables, or similar.</p>
<p>Third, asynchronous systems can be harder to reason about. Sometimes the events
will complete in the order of issuance, sometimes they won’t. Either the
programs running on the system themselves become fully asynchronous, or they
risk having their behavior depend on the order of completion. It’s also
significantly more difficult to display the state of an asynchronous program –
mechanisms familiar to developers, like stack traces, no longer make sense.</p>
<p>Fourth, asynchronous systems tend to be less efficient. There has been a
movement toward fully asynchronous systems interfaces in recent years, driven in
large part by increases in core count and complexity of desktop applications. A
well-designed asynchronous system interface, with aggressively concurrent
software written to support it, can produce higher average throughput if the
events it deals in really can complete in varying order. What it <em>cannot</em>
produce is lower latency. Synchronous call interfaces simply use fewer machine
instructions to complete the task of setting up and completing a call. As a
result, systems built on synchronous call interfaces tend to be smaller. On the
class of processor we’re targeting, with low core count, limited RAM and flash,
and real-time responsibilities, smaller systems with lower latency win.</p>
<h2 id="send">SEND</h2>
<p>Let’s make this concrete by looking at the most common synchronous syscall in
Hubris, <code>SEND</code>. Here is the signature of the syscall in Rust.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                  ┌──────────────────────────────────────────┐                  
</span><span>                  │1 pub fn sys_send(                        │                  
</span><span>                  │2     target: TaskId,                     │                  
</span><span>                  │3     operation: u16,                     │                  
</span><span>                  │4     outgoing: &amp;[u8],                    │                  
</span><span>                  │5     incoming: &amp;mut [u8],                │                  
</span><span>                  │6     leases: &amp;[Lease&lt;&#39;_&gt;],               │                  
</span><span>                  │7 ) -&gt; (u32, usize);                      │                  
</span><span>                  └──────────────────────────────────────────┘                  
</span><span>              Listing 3: the actual signature of the send syscall.              
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>This call sends a message to <code>target</code>, invoking a given <code>operation</code>, and
carrying some <code>outgoing</code> data. It then expects to get an <code>incoming</code> response
back. The syscall will return two values, a response code carrying
success/failure information, and a <code>usize</code> giving the size of message that was
received into the <code>incoming</code> buffer. This call directly reflects the kernel
syscall ABI, and in practice few programs call it <em>directly,</em> preferring to use
wrappers – but since we’re talking about the system architecture, wrappers
would be distracting.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                           A TYPICAL CROSS-TASK CALL                            
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                           Task A           Task B                              
</span><span>                             │                 ┆                                
</span><span>                             └─ SEND ─────────→┐                                
</span><span>                             ┆                 │                                
</span><span>                            not              doing                              
</span><span>                          running            stuff                              
</span><span>                             ┆                 │                                
</span><span>                             ┌←──────── REPLY ─┤                                
</span><span>                             │                RECV                              
</span><span>                           running             ┆                                
</span><span>                             │              (waiting)                           
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>When a task calls <code>SEND</code> it immediately loses the CPU. In the fast path, when
the <code>target</code> task is ready and waiting, the scheduler switches to the <code>target</code>
task immediately. If the target is <em>not</em> ready, the sender is blocked until it
becomes ready. Either way, something else runs.</p>
<p>Messages are always shuttled from task to task directly. They are never buffered
or queued in the kernel. In addition to the resource management problems that
queueing would introduce, this also removes a <code>memcpy</code> to the kernel by only
copying once, which can be a real boon in performance-sensitive applications.</p>
<p>There are two more subtle implications of this design.</p>
<p>One is that each task can have either zero or one outgoing messages at any given
time. Because a task loses the CPU until it receives a reply to its message, it
can’t simultaneously send <em>two</em> messages – nor can it queue up dozens of
outgoing messages to barrage its peers. This takes away a fault or attack
amplification vector that’s available in asynchronous systems.</p>
<p>Another is that a task that is sending a message is, by definition, not running.
Because a task sending a message or waiting for a reply is not schedulable, we
can immediately context switch away from the sending task – if possible,
directly into the target task. The target task can then assume that the sender
is waiting for a reply.</p>
<p>And, as it turns out, this interacts very nicely with Rust’s
opinions on memory aliasing.</p>
<h2 id="aliasing-and-leases">Aliasing and leases</h2>
<p>In Rust, references represent <em>borrowed</em> data, which comes from <em>somewhere
else,</em> possibly your caller’s stack. References are analyzed, at compile time,
by the compiler to check that code that operates on borrowed data will <em>stop</em>
operating on it before returning. In general, it’s legal to pass references to
borrowed data <em>down</em> into functions you call, and then operate on it after the
function has returned, because you can rely on the compiler to ensure that that
function hasn’t secretly hung onto a reference.</p>
<p>The Hubris lease mechanism extends this function-to-function borrowing mechanism
across task boundaries.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                           A TYPICAL CROSS-TASK CALL                            
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                           Task A           Task B                              
</span><span>                             │                 ┆                                
</span><span>                             └─ SEND ─────────→┐                                
</span><span>                             ┆                 │                                
</span><span>                             ┆   ←┄┄┄┄┄┄┄┄┄accessing                            
</span><span>                            not  ┄┄┄┄┄┄┄┄┄→borrowed                             
</span><span>                          running           memory                              
</span><span>                             ┆                 │                                
</span><span>                             ┆                 │                                
</span><span>                             ┌←──────── REPLY ─┤                                
</span><span>                             │                RECV                              
</span><span>                           running             ┆                                
</span><span>                             │              (waiting)                           
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>A function running in one task can construct leases referencing data in that
task, and attach them to a send to another task. The receiving task is then
treated as borrowing the leased data, and can access its contents whenever it
likes, until it resumes the first task by replying. Now, these sorts of dynamic
task interactions have to be checked at runtime, rather than at compile time
like Rust borrows, but otherwise the operation is pretty similar.</p>
<p>This is how drivers on Hubris implement operations like transmitting blocks of
data out a serial port: the task that wishes to transmit sends a message
indicating its intent, with a read-only lease attached. The driver then loads
data through the lease in whatever chunk size it wishes, until the transmission
is complete and the sender is resumed. While in this case you could package the
data into the message portion of the send call, that would require the kernel to
copy the data all in one go, which in turn means that the driver needs to have
already set aside a chunk of RAM large enough to receive any <em>potentially sent</em>
stream of bytes in one whack. Not only would this waste precious RAM most of the
time, it will inevitably lead to some arbitrary low limit on how many bytes can
be sent through a serial port in one call. Using leases, the sender doesn’t know
or care how large of a buffer the driver is keeping available, and the driver is
responsible for moving chunks of sent data out of the sender’s memory.</p>
<p>Cross-task borrows are only safe, from both an engineering reliability
perspective and a Rust memory model perspective, because of synchronous
messaging. The recipient accessing data through a lease can be confident that it
has exclusive access, if required, because the previous holder of exclusive
access is stopped.</p>
<p>When the borrowing task replies to the corresponding message, any leases that
came along with it are atomically revoked. This ensures that, from the lender’s
perspective, sharing memory across tasks works identically to passing references
into a function within the same task.</p>
<h2 id="as-a-programmer">As a programmer</h2>
<p>Now, let’s switch away from how the syscall behaves, and talk about how we, the
programmers, <em>think</em> it behaves.</p>
<p>Synchronous systems are easier to understand and build.</p>
<p>Most programming in an embedded system is basically explaining to a computer how
to perform a process described in a flow chart. There may or may not literally
be a flow chart the programmer is working from, I’m speaking conceptually. We
want to take a sequence of actions and checks and conditionals and loops and
turn it into something the computer can do. Doing this will usually involve
building a state machine.</p>
<p>Now, I’m using the term “state machine” in its broadest sense. A lot of embedded
software, or systems software in general, thinks of a “state machine” as a sort
of interpreter, either hand-written or generated by a tool, that under the hood
probably contains a state variable and a big <code>switch</code> statement or table. That’s
one kind of a state machine. And that kind of state machine can be very useful.</p>
<p>But we also have a programming language. Programming languages are tools for
expressing state machines, and they are quite good at it. When you instead use a
programming language to implement an interpreter for some other description of a
state machine, you’re introducing a layer of conceptual indirection. It takes a
reader a lot more effort to work out the behavior of an arbitrary nest of state
transition edges, than it does to read a <code>while</code> loop. Manually rolled state
machines deny their authors the advancements of our industry since the
introduction of structured programming, nearly 60 years ago. The result is
almost always more complex, and more code, than a naive expression of the same
process simply written in the programming language itself.</p>
<p>The decades of collective culture around writing, analyzing, and inspecting
programs written in programming languages not only makes things easier for the
reader, but it gets you better tool support. If a program is mysteriously not
making progress, I can use existing debug information produced by any compiler
to get a stack trace and display local variables. I would need to spend time
engineering this myself for a handwritten state machine.</p>
<p>And yet – despite all this – I’ve written my share of hand-rolled state
machines, some quite recently. Why do we do this? Some people feel that explicit
state machines or so-called “super-loop” architectures are easier to understand
than straight-line code or preemptive multitasking, but I just spent several
minutes explaining why I think that’s misguided. The real answer is almost
always asynchrony. Perhaps your driver needs to be nudged forward in small
increments from interrupt context. The way most processors implement interrupt
handlers, they don’t have an opportunity to maintain a stack from invocation to
invocation, more or less requiring them to be unrolled into an explicit state
machine. The main other reason in my case is resource limitations – perhaps
stacks are expensive, and so I need to multiplex them across several logical
processes. Each of these individual processes may itself be synchronous
internally, but the combination of processes may be <em>mutually</em> asynchronous,
with events coming at different and uncorrelated time. And so I’ve ended up with
asynchrony again.</p>
<p>Hubris approaches this problem pragmatically. We have attempted to provide a
platform where a motivated programmer can <em>entirely avoid</em> asynchrony.
Cross-task messaging is synchronous, as I’ve explained, but that’s only part of
the problem. The other thing that many operating systems make asynchronous is
events – signal handlers, interrupt handlers, and the like.</p>
<p>Since I’ve been talking about drivers, I’ll address interrupt handlers first.
Interrupts are, as their name implies, asynchronous on most processors. The
Hubris kernel provides “bottom-half” interrupt handler stubs that use
compile-time configuration to route interrupts to tasks in the application.
Tasks then see interrupts as synchronous events, delivered on request.
Specifically, any time a task checks for incoming messages, it can pass an
optional parameter specifying which, if any, of its interrupts it would <em>also</em>
like to hear about.</p>
<p>This has turned out to be unexpectedly pleasant. A lot of drivers in our
firmware are structured as server tasks, meaning that the core loop of the
driver resembles, in pseudo-Rust, the following:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                     ┌───────────────────────────────────┐                      
</span><span>                     │1 loop {                           │                      
</span><span>                     │2     let m = sys_recv();          │                      
</span><span>                     │3     match m.operation {          │                      
</span><span>                     │4         CONTROL_LASERS =&gt; { ... }│                      
</span><span>                     │5         EJECT_USER =&gt; { ... }    │                      
</span><span>                     │6     }                            │                      
</span><span>                     │7 }                                │                      
</span><span>                     └───────────────────────────────────┘                      
</span><span>                       Listing 4: a typical server loop.                        
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Each time through this loop, the driver receives an incoming message and
dispatches based on the operation that was requested. One message is handled at
any given time.</p>
<p>Altering this driver to support interrupts, say during the process of ejecting
the user, can be done two different ways. First, the fully synchronous method:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>             ┌────────────────────────────────────────────────────┐             
</span><span>             │ 1 loop {                                           │             
</span><span>             │ 2     let m = sys_recv();                          │             
</span><span>             │ 3     match m.operation {                          │             
</span><span>             │ 4         CONTROL_LASERS =&gt; { ... }                │             
</span><span>             │ 5         EJECT_USER =&gt; {                          │             
</span><span>             │ 6             start_rocket_motor();                │             
</span><span>             │ 7                                                  │             
</span><span>             │ 8             // not actual syntax, but not far off│             
</span><span>             │ 9             sys_recv(ROCKET_IRQ_ONLY);           │             
</span><span>             │10                                                  │             
</span><span>             │11             release_locking_clamp();             │             
</span><span>             │12                                                  │             
</span><span>             │13             sys_reply(m.caller, OK);             │             
</span><span>             │14         }                                        │             
</span><span>             │15     }                                            │             
</span><span>             │16 }                                                │             
</span><span>             └────────────────────────────────────────────────────┘             
</span><span>              Listing 5: server using synchronous interrupt wait.               
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Here the driver is waiting (line 9) for a specific interrupt, and will not honor
other messages until it arrives. A real driver dealing with real hardware might
include a timeout, but either way, this lets the driver author express a
sequence of operations that includes waiting for interrupts as straight line
code.</p>
<p>If the driver needs to process other requests while waiting for that interrupt,
there’s also the semi-asynchronous approach:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>              ┌─────────────────────────────────────────────────┐               
</span><span>              │ 1 loop {                                        │               
</span><span>              │ 2     let m = sys_recv_or_irq();                │               
</span><span>              │ 3     match m.operation {                       │               
</span><span>              │ 4         INTERRUPT =&gt; {                        │               
</span><span>              │ 5             // handle interrupts here         │               
</span><span>              │ 6         }                                     │               
</span><span>              │ 7         CONTROL_LASERS =&gt; { ... }             │               
</span><span>              │ 8         EJECT_USER =&gt; {                       │               
</span><span>              │ 9             // omitted: what if two of these  │               
</span><span>              │10             // requests arrive simultaneously?│               
</span><span>              │11             start_rocket_motor();             │               
</span><span>              │12                                               │               
</span><span>              │13             enable_irq();                     │               
</span><span>              │14         }                                     │               
</span><span>              │15     }                                         │               
</span><span>              │16 }                                             │               
</span><span>              └─────────────────────────────────────────────────┘               
</span><span>                Listing 6: interleaving interrupts and requests.                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>This is using the fact that interrupt notifications can be opted into on any
receive call. So, the main match statement processing incoming messages is now
evaluating both incoming messages <em>and</em> interrupts that have happened since the
last time it checked.</p>
<p>I say this approach is <em>semi-asynchronous</em> because, unlike a signal handler, it
never alters the control flow of the code you read on the page. This was an
explicit design goal of ours, and it makes writing and debugging interrupt
driven drivers <em>much</em> easier.</p>
<p>Hubris also does not provide Unix-style intrusive signal handlers. And so, by
combining thesepieces , we have the summary of the task execution model in
Hubris: code you write in a task executes as written or fails. Nothing in the
system will arbitrarily alter your program’s control flow from what appears on
the page, except potentially to stop and restart it from the top. When phrased
like that, it seems weird to have to say it out loud – like, don’t all
programmers pretty much assume that they code they write executes the way they
wrote it? To which I say, yes, we do, and that assumption is often wrong, and
leads to common classes of bugs, from simple data races on up. Hubris attempts
to provide a platform where that reasonable assumption is can be maintained.</p>

<p>For a systems programming language, Rust has an unusually powerful type system.
We’ve used this to great effect. Let’s look at two small examples.</p>
<h2 id="making-illegal-task-states-unrepresentable">Making illegal task states unrepresentable</h2>
<p>First, from the kernel internals, we have <code>TaskState</code>.</p>
<p>As the name implies, <code>TaskState</code> is a type describing the state of a task. While
Hubris doesn’t recognize all <em>that</em> many possible task states, there are still
several, some of which have associated data. I’ll focus on three potential
states today.</p>
<p>First, a task may be runnable.</p>
<p>Second, a task may be blocked trying to deliver a message to a peer.</p>
<p>Third, a task may have failed with a fault.</p>
<p>A task in each of these states needs to keep slightly different sets of
information around. The runnable state needs the least, just static properties
of the task such as its scheduling priority.</p>
<p>A task that is attempting to deliver a message, a state we call <code>InSend</code>, needs
to keep track of quite a bit more. Because the task has entered the <code>InSend</code>
state in the first place, we know it tried to send a message to a peer that was
not ready to receive. That’s a good start, but we also need to keep track of the
location of the message in the sender’s memory space, any leases that were
attached to the message, and of course the identity of the task that, we hope,
will eventually receive the message.</p>
<p>A task that has taken a fault, on the other hand, doesn’t need any of that, but
it <em>does</em> need information about the fault. We record a fault number from a
taxonomy of Hubris faults, and in some cases, we record additional metadata. For
instance, in the event of a memory access violation, we record whether the fault
was imprecise or precise, and, in the latter case, the offending address. For
various types of kernel-originated software faults, we record information about
why the kernel faulted the task. Finally, for any fault, we <em>also</em> record the
state the task was in just before the fault.</p>
<p>Now, what a lot of kernels do here is to work out the union of the information
required by all possible task states, and flatten it into a struct. In our case,
it might look something like</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                  ┌─────────────────────────────────────────┐                   
</span><span>                  │ 1 struct Task {                         │                   
</span><span>                  │ 2     // ... stuff omitted...           │                   
</span><span>                  │ 3                                       │                   
</span><span>                  │ 4     state: TaskState,                 │                   
</span><span>                  │ 5     previous_state: TaskState,        │                   
</span><span>                  │ 6     ipc_peer: TaskId,                 │                   
</span><span>                  │ 7     message: USlice&lt;u8&gt;,              │                   
</span><span>                  │ 8     fault_kind: FaultKind,            │                   
</span><span>                  │ 9     fault_address: u32,               │                   
</span><span>                  │10     extra_fault_info: u32,            │                   
</span><span>                  │11     // ... and so on.                 │                   
</span><span>                  │12 }                                     │                   
</span><span>                  │13                                       │                   
</span><span>                  │14 enum TaskState { Ready, Sending, ... }│                   
</span><span>                  └─────────────────────────────────────────┘                   
</span><span>              Listing 7: how we didn&#39;t implement the Task struct.               
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>This can work, but there are several problems with it. First, it isn’t at all
clear to a reader when each of these fields is valid, and when it may contain
garbage. Second, that lack of clarity can lead to security and robustness
problems. For instance, a task that has died with a fault should not be
scheduled. Any outgoing messages it was attempting to send at the time of the
fault should not be delivered. Similarly, we should not be able to receive a
message from a task that isn’t trying to send one. Yet all these mistakes can be
made quite easily with the flat state representation.</p>
<p>Finally, if we wanted to record task state before a fault, it’s not clear what
subset we would record, and it’s definitely not clear how to handle any field
that needs to be both saved and updated for the fault.</p>
<p>Having Rust enums available makes a big difference here. Enums in Rust can work
just like enums in C, but this is a sort of degenerate case; they can also
express arbitrarily complex tagged unions. Our top-level task state enum looks
like this:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                        ┌───────────────────────────┐                           
</span><span>                        │ 1 enum TaskState {        │                           
</span><span>                        │ 2     Healthy(SchedState),│                           
</span><span>                        │ 3     Faulted { ... },    │                           
</span><span>                        │ 4 }                       │                           
</span><span>                        │ 5                         │                           
</span><span>                        │ 6 enum SchedState {       │                           
</span><span>                        │ 7     Runnable,           │                           
</span><span>                        │ 8     InSend(TaskId),     │                           
</span><span>                        │ 9     // ... more         │                           
</span><span>                        │10 }                       │                           
</span><span>                        └───────────────────────────┘                           
</span><span>                     Listing 8: the actual task state enum.                     
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>TaskState distinguishes between healthy states and faulted states, and the
healthy states are separated into a nested enum, <code>SchedState</code>. I’ll come back to
the members of <code>Faulted</code> that are omitted there.</p>
<p>Runnable and <code>InSend</code> are both variants of <code>SchedState</code>. </p>
<p>The task ID designating the intended recipient of the message is only
accessible, and indeed <em>only exists as a member field,</em> when the state is
<code>InSend</code>. It is not possible to accidentally reference it if the task is in a
different state, nor is it possible to transition <em>into</em> <code>InSend</code> without
providing it.</p>
<p><code>SchedState</code> is broken out into a sub-enum because it means that code in the
kernel can be written such that it can’t even talk about fault states. For
instance, there is a <code>set_healthy_state</code> operation that is used in the
implementation of several syscalls to move tasks between states. This takes a
<code>SchedState</code> as a parameter, meaning the operation simply <em>cannot</em> put a task
into a faulted state – that is a different and less frequently used operation.
Similarly, the scheduler deals with tasks in terms of their <code>SchedState</code>, and
since a faulted task doesn’t <em>have one,</em> it cannot attempt to schedule a faulted
task.</p>
<p>Well, technically, it isn’t quite true that a faulted task doesn’t have a
<code>SchedState</code>. Remember that I mentioned we record the pre-fault state.
The actual definition of <code>Faulted</code> looks like this:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                    ┌─────────────────────────────────────┐                     
</span><span>                    │1 enum TaskState {                   │                     
</span><span>                    │2     Healthy(SchedState),           │                     
</span><span>                    │3     Faulted {                      │                     
</span><span>                    │4         fault: FaultInfo,          │                     
</span><span>                    │5         original_state: SchedState,│                     
</span><span>                    │6     }                              │                     
</span><span>                    │7 }                                  │                     
</span><span>                    └─────────────────────────────────────┘                     
</span><span>                    Listing 9: fields of the faulted state.                     
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>This is another useful benefit of breaking healthy states out into the
<code>SchedState</code> type: we can store the pre-fault healthy state here. We can’t embed
a <code>TaskState</code> within a <code>TaskState</code> because that would produce an infinitely
large data structure; but we <em>can</em> embed a <code>SchedState</code>. This gets us several
benefits. First, while the <code>SchedState</code> is present in both healthy and faulted
states, it is accessed in very different ways, syntactically, so they’re very
difficult to confuse. Second, I can guarantee you that the pre-fault
<code>original_state</code> does not, itself, describe a fault, because the <code>SchedState</code>
type cannot describe faults. Beyond making the code easier to use, being
rigorous about which enum variants can appear in which contexts eliminates a lot
of “default” or “don’t-care” branches in switch statements, which is good,
because these often accumulate bugs, particularly as enums are extended during
the life of the system.</p>
<h2 id="parsing-and-the-humble-slice">Parsing and the humble slice</h2>
<p>So, that’s one example of simplifying kernel book-keeping using Rust types. The
other example I’d like to discuss is a case of maintaining security properties
using types.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                  ┌──────────────────────────────────────────┐                  
</span><span>                  │1 pub fn sys_send(                        │                  
</span><span>                  │2     target: TaskId,                     │                  
</span><span>                  │3     operation: u16,                     │                  
</span><span>                  │4     outgoing: &amp;[u8],                    │                  
</span><span>                  │5     incoming: &amp;mut [u8],                │                  
</span><span>                  │6     leases: &amp;[Lease&lt;&#39;_&gt;],               │                  
</span><span>                  │7 ) -&gt; (u32, usize);                      │                  
</span><span>                  └──────────────────────────────────────────┘                  
</span><span>              Listing 3: the actual signature of the send syscall.              
</span><span>                                                                                
</span><span>                                    (again)                                     
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Consider the outgoing message argument to the <code>SEND</code> syscall I presented
earlier. From the task’s perspective, this argument is passed as a slice,
<code>&amp;[u8]</code>. This is a Rust standard type that consists of a pointer and a length.
This aspect of <code>SEND</code> is very much like the POSIX <code>write</code> call, which takes an
explicit pointer and a length. While the Rust signature of the syscall takes a
slice, the machine-level ABI just moves a pointer and length in two registers,
and it’s entirely possible for a misbehaving or malicious task to pass an
arbitrary pointer and length. This means the kernel has a validation problem:
given an address and size, which the caller <em>alleges</em> it can access, determine
whether the caller should be <em>allowed</em> to access it.</p>
<p>This problem is common to basically all kernels that have some form of memory
protection. It’s also a common source of bugs and vulnerabilities, for the
simple reason that it’s easy to forget to check, or even if you remember to
check, it’s easy to accidentally separate the address and size values.</p>
<p>In every case like this that I’ve studied, there are two things at play:</p>
<ol>
<li>The address/size pair after validation is indistinguishable from the same
pair before validation.</li>
<li>The address and size are not welded together into a unitary value, and
operations are inconsistent on whether they take both or just a base address.
(For instance, C pointer indirection only takes a base address.)</li>
</ol>
<p>It is surprisingly easy to solve both of these problems using types, and in
fact, we do this all the time in more pedestrian situations. Consider taking a
piece of text and trying to extract a base-ten number from it. You would
probably use a number-parsing routine that is capable of returning either a
number, or an error indicator if the string does not contain a base-ten number,
something like the top listing on this slide:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                  ┌──────────────────────────────────────────┐                  
</span><span>                  │1 if let Some(n) = some_text.parse_u32() {│                  
</span><span>                  │2     println!(&#34;we have a number!&#34;);      │                  
</span><span>                  │3     operate_on(n);                      │                  
</span><span>                  │4 } else {                                │                  
</span><span>                  │5     println!(&#34;not a number&#34;);           │                  
</span><span>                  │6 }                                       │                  
</span><span>                  └──────────────────────────────────────────┘                  
</span><span>               Listing 10: how one might parse and use a number.                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                     ┌────────────────────────────────────┐                     
</span><span>                     │1 if check_is_number(some_text) {   │                     
</span><span>                     │2     println!(&#34;we have a number!&#34;);│                     
</span><span>                     │3     operate_on(some_text);        │                     
</span><span>                     │4 } else {                          │                     
</span><span>                     │5     println!(&#34;not a number&#34;);     │                     
</span><span>                     │6 }                                 │                     
</span><span>                     └────────────────────────────────────┘                     
</span><span>                Listing 11: validating without using the result.                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>This isn’t the only way to do this; you could also write one routine for
inspecting the string and verifying that it contains a number, and then pass the
text around, assuring anyone who encounters it that it contains a decimal
number. That’s what the second listing does.</p>
<p>But this approach feels <em>weird,</em> and it’s worth asking why it feels weird. As
systems programmers, one likely objection is about performance: presumably we’re
going to need to parse a number out of that text <em>eventually,</em> so doing a
validation step that inspects the text, only to <em>later</em> do a parsing step, will
probably use more CPU time than a parsing operation that can indicate errors.
And that’s true, in practice!</p>
<p>But there’s another reason it feels weird. Consider the definition of the
<code>operate_on</code> function in each of these two cases.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                       ┌────────────────────────────────┐                       
</span><span>                       │1 // First case                 │                       
</span><span>                       │2 fn operate_on(n: u32) { ... } │                       
</span><span>                       │3                               │                       
</span><span>                       │4 // Second case                │                       
</span><span>                       │5 fn operate_on(n: &amp;str) { ... }│                       
</span><span>                       └────────────────────────────────┘                       
</span><span>                  Listing 12: operate_on gets different types,                  
</span><span>                  and thus different assurances, in each case.                  
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>In the first case, the code in the function can be assured that <code>n</code> is a valid
<code>u32</code>, because, well, it says right there. In the <em>second</em> case, the caller
could pass any arbitrary string. You could add a large block comment on the
function declaring that any string passed in might be a valid number, but, the
code will still need to deal with the possibility that it’s passed garbage. Or,
it could elect <em>not</em> to deal with that possibility and assume its callers have
done the right thing every time, which is often how we get kernel exploits.</p>
<p>So, I’d argue that the second approach feels weird for some <em>very good reasons,</em>
and that you should prefer the first approach. This is a specific case of a more
general principle, summarized by Alexis King as “Parse, Don’t Validate.” By
treating input validation as a parsing problem, we get two benefits:</p>
<ol>
<li>By parsing once and returning the result, we avoid accidentally wasting time
by validating/parsing repeatedly.</li>
<li>The fact that parsing or validation has occurred <em>is now reflected in the
types.</em></li>
</ol>
<p>And it’s that second point that I’m flogging here. Going back to our
<code>operate_on</code> cases, it is simply not possible for the user to call the <code>u32</code>
version with an un-validated string, because it doesn’t accept a string – it
accepts a <code>u32</code>, and even a 40-year-old C compiler will warn you if you confuse
those. This means that the implementation doesn’t need to decide between
re-checking the input or potentially being the cause of bugs and vulnerabilities
down the road. It and the caller are working together to move only valid data
around.</p>
<p>So why don’t we do the same thing with addresses from user code?</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                 ┌───────────────────────────────────────────┐                  
</span><span>                 │1 // Linux:                                │                  
</span><span>                 │2 access_ok(VERIFY_READ, pointer, length); │                  
</span><span>                 │3                                          │                  
</span><span>                 │4 // Windows:                              │                  
</span><span>                 │5 ProbeForRead(pointer, length, alignment);│                  
</span><span>                 │6                                          │                  
</span><span>                 │7 // it goes on                            │                  
</span><span>                 └───────────────────────────────────────────┘                  
</span><span>            Listing 12: pointers get validated, types don&#39;t change.             
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Here are typical pointer checks from the Linux and Windows kernels.</p>
<p>If we accept that the key distinction between a parsing operation, and a
validation operation, is that <em>parsing</em> produces an artifact that you didn’t
have before – a change in type, typically – then these are both validation
operations. We get no support from the compiler here; you can delete these calls
from a program and not get a compiler warning. It’s also not at all clear where
in the kernel these operations need to be called – each function must decide
whether to spend time and code validating pointer arguments, or potentially be
the source of bugs in the future when a caller fails to notice the block
comment.</p>
<p>Comments and conventions are great, but they are not machine-checkable, and they
are a poor substitute for types. Both Linux and Windows, to use the two examples
at hand, have shipped security vulnerabilities related to using these validation
operations incorrectly, in ways that would have been prevented by rephrasing
them as parsing.</p>
<p>The easiest way to see this is to consider what should happen if the length is
zero. Reading zero bytes from an address is probably fine, and on Windows at
least, <code>ProbeForRead</code> will OK it independent of address. However, it’s super
easy to do this by accident:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                  ┌─────────────────────────────────────────┐                   
</span><span>                  │1 const uint8_t * user_data = ...;       │                   
</span><span>                  │2 size_t len = 0;                        │                   
</span><span>                  │3                                        │                   
</span><span>                  │4 ProbeForRead(user_data, len, 1); // OK!│                   
</span><span>                  │5                                        │                   
</span><span>                  │6 *user_data // no error, no warning     │                   
</span><span>                  └─────────────────────────────────────────┘                   
</span><span>                  Listing 13: mere validation won&#39;t stop this.                  
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p><em>Any</em> dereference of the pointer is a bug, but nothing prevents someone from
making this mistake…except code review.</p>
<p>Now, consider this hypothetical replacement for <code>ProbeForRead</code>, written in Rust
syntax.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                           ┌────────────────────────┐                           
</span><span>                           │1 fn probe_for_read&lt;T&gt;( │                           
</span><span>                           │2     pointer: *const T,│                           
</span><span>                           │3     length: usize,    │                           
</span><span>                           │4     alignment: usize, │                           
</span><span>                           │5 ) -&gt; Option&lt;&amp;[T]&gt;;    │                           
</span><span>                           └────────────────────────┘                           
</span><span>                      Listing 14: recast using Rust types.                      
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>This takes the same three arguments, using the same types as C, but the return
type has changed. It now returns an option of slice of T, meaning the caller
will either get the value <code>None</code> if the check failed, or <code>Some</code> with a slice.</p>
<p>In this case, the slice represents the parse result. It uses the type system to
indicate that the memory is OK to access, contains a sequence of values of some
type <code>T</code>, and is correctly aligned. This also serves to bond the pointer and
length together, so that they can’t mistakenly be used separately or mixed up.</p>
<p>If a function needs a reference to <em>valid</em> user memory, it can require a slice.
If it’s willing to do the validation itself, it can take a pointer and a length.</p>
<p>This signature works particularly well in Rust because so-called raw pointers,
like the <code>*const T</code> you see here, are allowed to contain arbitrary invalid
values, but can’t be dereferenced in safe code. Meaning, the code can pass this
<code>pointer</code> value around whether or not it has been validated, without risk, since
it will not be unexpectedly dereferenced.</p>
<p>In practice, you may want to bond the pointer and length together <em>before</em>
validating, to make them easier to pass around and harder to accidentally
separate, and this is what we do in Hubris. Here’s the signature of the
equivalent Hubris operation:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                       ┌───────────────────────────────┐                        
</span><span>                       │1 fn try_read&lt;T&gt;(              │                        
</span><span>                       │2     task: &amp;Task,             │                        
</span><span>                       │3     slice: USlice&lt;T&gt;,        │                        
</span><span>                       │4 ) -&gt; Result&lt;&amp;[T], FaultInfo&gt;;│                        
</span><span>                       └───────────────────────────────┘                        
</span><span>                    Listing 15: Hubris equivalent operation.                    
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Similar, except that we pass the current <code>task</code> explicitly instead of getting it
from some per-thread context, we use a generic <code>USlice</code> type to capture an
unvalidated pointer-length pair received from user mode.</p>
<p>A <code>USlice</code> provides stronger guarantees than a raw pointer: it’s not a pointer,
and can’t be easily dereferenced even in <code>unsafe</code> code.</p>
<p>So, why don’t we see more of this? I think the reasons are complex, but part of
it is that we haven’t been talking about this in the systems programming
community – which is part of why I’m talking about it today.</p>
<p>But part of it is that you can’t really achieve this in C, and you can’t achieve
it robustly in C++, and those have been our only two practical options for a
very long time.</p>
<p>I’m not here to rag on C’s type system, so I’ll leave the reasons why this
doesn’t work for a future blog post. But implementing a new kernel from scratch
in Rust, you find a lot of opportunities like this for encoding your intended
integrity and security properties in the types themselves, so that the compiler
can assist you in detecting any violations of those properties.</p>
<p>Speaking of compiler assistance, there’s a subtle Rust thing in that function
signature. Because there’s a reference (ampersand) in both the arguments and
return type, without further instruction, the compiler connects the two
lifetimes. This means that if the <code>try_read</code> call succeeds, the compiler
considers the task “borrowed” until we dispose of the slice. Borrowing the task
with a shared reference like this prevents most mutation, and in particular,
this means it is not possible to change the task’s memory map in a way that
would invalidate <code>try_read</code>’s decision while retaining access to the memory. To
do that, you’d need to drop the slice, make the change, and then call <code>try_read</code>
again to get a new slice, which of course you wouldn’t because you just messed
up the memory map. This eliminates a potentially subtle class of bugs, and
conveniently happens to be the natural way to express it in Rust.</p>

<p>At Oxide we’re enthusiastic proponents of hardware-software co-design, treating
hardware and software together as an integrated product and making tradeoffs
across the two. Hubris’s design has been influenced by a different form of
co-design that I didn’t see coming: application-debugger co-design.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>   ┌────────────────────────────────────────────────────────────────────────┐   
</span><span>   │[cbiffle@gwydion]$ humility -d hubris.core.54 manifest                  │   
</span><span>   │humility:      version =&gt; hubris build archive v1.0.0                   │   
</span><span>   │humility:      git rev =&gt; a2e01755592189aea0c6cabf36fc5cc9257190b2-dirty│   
</span><span>   │humility:        board =&gt; stm32f4-discovery                             │   
</span><span>   │humility:       target =&gt; thumbv7em-none-eabihf                         │   
</span><span>   │humility:     features =&gt; itm, stm32f4                                  │   
</span><span>   │humility:   total size =&gt; 70K                                           │   
</span><span>   │humility:  kernel size =&gt; 18K                                           │   
</span><span>   │humility:        tasks =&gt; 8                                             │   
</span><span>   │humility:                 ID TASK                SIZE FEATURES          │   
</span><span>   │humility:                  0 jefe               10.6K itm               │   
</span><span>   │humility:                  1 rcc_driver          4.9K stm32f4           │   
</span><span>   │humility:                  2 usart_driver        6.3K stm32f4           │   
</span><span>   │humility:                  3 user_leds           5.7K stm32f4           │   
</span><span>   │humility:                  4 ping                5.5K uart              │   
</span><span>   │humility:                  5 pong                4.8K                   │   
</span><span>   │humility:                  6 hiffy              14.4K                   │   
</span><span>   │humility:                  7 idle                0.1K                   │   
</span><span>   └────────────────────────────────────────────────────────────────────────┘   
</span><span>             humility manifest showing the contents of a core dump              
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>We wrote the debugger alongside the kernel.</p>
<p>I want to talk about two aspects of Humility today: how it has changed the
operating system, and why more people don’t do this.</p>
<p>On the first point: you can get to most of the really deep changes that Humility
brought to Hubris by starting at console interfaces. Most embedded projects I’ve
worked on have had a console, usually over serial, sometimes over USB. It gets
used during development and test, is usually critical during bringup, and
sometimes survives into production. In many cases it’s the only way to verify
that all the system tasks are running and not being starved of CPU, for
instance.</p>
<p>Consoles seem simple, but I would argue that this appearance is deceptive as
their feature set grows. A typical human-readable console over a UART requires
printf-equivalent formatting code for strings and numbers. If your application
needs real numbers for sensor measurements, or if your printf simply complies
with the C standard, that means you’re also pulling along floating point
formatting code. This can burn many kilobytes of Flash space, and we haven’t
even gotten to input.</p>
<p>Implementing a console in the languages we’ve traditionally used is also a
difficult task, because it’s just so easy to get things <em>wrong.</em> Unless you’re
fuzzing your console interface – and you are, right? – it probably contains
buffer overflows, inadvertant acceptance of illegal data, format string
vulnerabilities, or potentially even stack smashing.</p>
<p>Our Hubris-based firmware applications don’t have console interfaces. They don’t
contain printf-level data formatting, and they cannot parse command lines. And
yet we’re not really missing any of the <em>functionality,</em> because we’ve split the
task between the application and the debugger.</p>
<p>We’ve established a set of interface patterns between the debugger and
application, which effectively form a user-extensible kernel-aware debugger
interface. I refer to this as the Debug Binary Interface or DBI. Like an ABI
explaining how to pass values and format data structures in an application, the
DBI defines how to declare variables and types such that the debugger will find
them and do … stuff. And we’re leaving that “stuff” deliberately ill-defined.</p>
<p>On the kernel end of things, we use this to print task status information:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>      ┌──────────────────────────────────────────────────────────────────┐      
</span><span>      │[cbiffle@gwydion]$ humility -d ~/Downloads/hubris.core.54 task    │      
</span><span>      │humility: attached to dump                                        │      
</span><span>      │system time = 166704                                              │      
</span><span>      │ID TASK                 GEN PRI STATE                             │      
</span><span>      │ 0 jefe                   0   0 recv, notif: bit0                 │      
</span><span>      │ 1 rcc_driver             0   1 recv                              │      
</span><span>      │ 2 usart_driver           0   2 recv, notif: bit0(irq38)          │      
</span><span>      │ 3 user_leds              0   2 recv                              │      
</span><span>      │ 4 ping                  59   4 FAULT: divide by zero (was: ready)│      
</span><span>      │ 5 pong                   0   3 recv, notif: bit0(T+296)          │      
</span><span>      │ 6 hiffy                  0   3 notif: bit0(T+203)                │      
</span><span>      │ 7 idle                   0   5 RUNNING                           │      
</span><span>      └──────────────────────────────────────────────────────────────────┘      
</span><span>               humility tasks showing task status in a core dump                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>As you can see here, task index 4, called <code>ping</code>, has failed with a
divide by zero error, and so it might be useful to pull its current stack trace:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>     ┌────────────────────────────────────────────────────────────────────┐     
</span><span>     │[cbiffle@gwydion]$ humility tasks -sl ping                          │     
</span><span>     │system time = 166704                                                │     
</span><span>     │ID TASK                 GEN PRI STATE                               │     
</span><span>     │ 4 ping                  59   4 FAULT: divide by zero (was: ready)  │     
</span><span>     │   |                                                                │     
</span><span>     │   +---&gt;  0x200025b0 0x0802405e task_ping::divzero                  │     
</span><span>     │                     @ /home/cbiffle/hubris/task-ping/src/main.rs:28│     
</span><span>     │          0x20002600 0x080240f2 userlib::sys_panic                  │     
</span><span>     │                     @ /home/cbiffle/hubris/userlib/src/lib.rs:642  │     
</span><span>     │          0x20002600 0x080240f2 main                                │     
</span><span>     │                     @ /home/cbiffle/hubris/task-ping/src/main.rs:39│     
</span><span>     └────────────────────────────────────────────────────────────────────┘     
</span><span>             humility tasks -s showing stack trace of a failed task             
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Outside the kernel, our supervisor implementation has a debugger interface that
lets us request that a particular crashing task be held for inspection, instead
of automatically restarted like it would be in production (SLIDE), by writing a
request into a reserved section of its RAM. And for more
general debug or bringup work, our firwmare images include a debug agent task
that can run small interpreted programs delivered directly into its RAM by the
debugger. We use this facility, called the Humility Interchange Format or HIF,
to request application-specific sequences of operations, for example, to check
and enumerate the tree of attached PMBus devices.</p>
<p>Data motion between the target system and the debugger relies on two mechanisms.
For target-to-debugger, we decode data structures directly out of target memory
using the DWARF debug information from the compiler. For debugger-to-target, for
anything more complex than “poke a 1 into this to activate,” we use Rust enums
encoded with serde into a compact binary format, deposited directly into
designated areas of target RAM. This means that, while we <em>do</em> have a parser
exposed, it is machine-generated, strict, and difficult to get to, which is an
improvement.</p>
<p>This neatly resolves a tension that I’ve dealt with my whole embedded career:
how much Flash should we waste on things that aren’t expected to happen in
production? Should the system include a manufacturing self test mode, or the
ability to take over devices from drivers at runtime? If so, what happens if
these modes <em>do</em> get activated in production? By moving this code out of the
firmware, we’ve answered that question: they won’t, unless someone has physical
access to the JTAG scan chain and has authenticated with the processor to open
the debug interface.</p>
<h2 id="if-writing-a-debugger-is-so-great-why-isn-t-everyone-doing-it">If writing a debugger is so great why isn’t everyone doing it</h2>
<p>Having debug tools that understand your operating system and application has
proven invaluable. So, why aren’t more people doing this?</p>
<p>I think it’s for three main reasons.</p>
<p>First: it’s a domain shift. If your job is to write firmware to make the product
go, writing a debugger seems like it might require a different set of skills. It
might even be in a totally different language.</p>
<p>Second: it’s a bunch of work, and it’s not immediately obvious how it helps you
get to your deadline faster, and that’s all a lot of people care about. One of
the shared beliefs that unites us at Oxide is that investing in tools early lets
us move faster in the long term, but that belief is unfortunately not universal
across all companies.</p>
<p>Third: if you wanted to make it less work to write a debugger by reusing
existing code, existing debuggers are typically not modular or designed for
reuse. You cannot, for instance, easily link OpenOCD’s SWD support into a new
tool, or borrow GDB’s stack trace reconstruction implementation. While you could
copy-paste the code out, it would be a significant amount of work to adapt it.</p>
<p>Finally: if you did decide to write your own debugger, the documentation in this
area can be truly arcane. DWARF in particular has a reputation for being
monstrously complex and hard to follow – a reputation that, in my opinion, is
only <em>partially</em> deserved. </p>
<p>The first two points, where writing a debugger is scary to either you or your
boss, I can’t really help with, except maybe by giving more talks. But on the
other two, where debuggers tend not to be reusable and debug information is
complex and hard to understand, I can hook you up. We’re in the process of
refactoring Humility to make its core generic and reusable for any program that
wants to parse and understand debug information and the contents of another
running program. Of course, we’re currently heads down trying to get our first
product out the door, so it may take us a few months, but it is coming.</p>

<p>I could not have pulled this off on my own, and I’m fortunate to work with a
wonderful group of folks here at Oxide:</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                   CORE TEAM                                    
</span><span>                                                                                
</span><span>                Laura Abbott     Rick Altherr   Cliff L. Biffle                 
</span><span>                Bryan Cantrill   Matt Keeter    Steve Klabnik                   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                   COMMITTERS                                   
</span><span>                                                                                
</span><span>                     Luqman Aden            Adam Leventhal                      
</span><span>                                                                                
</span><span>                     Dan Cross              David Pacheco                       
</span><span>                                                                                
</span><span>                     Nathanael Huffman      Ben Stoltz                          
</span><span>                                                                                
</span><span>                     Sean Klein                                                 
</span><span>                                                                                
</span><span>                                                                                
</span><span>                            WITH SPECIAL GUEST STAR                             
</span><span>                                                                                
</span><span>                   OZYMANDIAS, KING OF TRIVIAL CODE REFORMATS                   
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>I’d like to thank both the core
Hubris developers, and the seven or so folks who have taken time away from other
parts of our product to improve things in firmware land.</p>
<p>We’ve published the repos involved in Hubris development, as well as the draft
reference manual, so if you’re interested by anything I had to say today – or
infuriated by it – I’d encourage you to read more at the URLs on the final
slide.</p>
<p>Hubris and Humility are not <em>done</em> by any means, but they’ve become very useful
for our purposes, and maybe you’ll find them useful too.</p>
<p>Thanks.</p>
<pre><code><span>▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍                              ON HUBRIS AND HUMILITY   
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                     Code: github.com/oxidecomputer/hubris                      
</span><span>                                                                                
</span><span>                      Docs: oxidecomputer.github.io/hubris                      
</span><span>                                                                                
</span><span>                             Oxide: oxide.computer                              
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>                                                                                
</span><span>   CLIFF L. BIFFLE ── OXIDE COMPUTER COMPANY        ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
</span></code></pre>
<p>Clickable versions of those links for the web:</p>
<ul>
<li><a href="https://github.com/oxidecomputer/hubris">Hubris repo</a></li>
<li><a href="https://hubris.oxide.computer/reference/">Hubris reference manual</a></li>
<li><a href="https://oxide.computer">Oxide Computer</a></li>
</ul>

<p>It seems like a lot of folks appreciated the talk, which is great! I’ve
collected answers to the questions I’m getting most often into <a href="https://github.com/oxidecomputer/hubris/blob/master/FAQ.mkdn">a FAQ over in
the Hubris repo</a>.
Have a look if you’re curious.</p>
<p>If you have any questions not covered by the FAQ, or are interested in having me
come talk about something at your conference or meetup, please <a href="https://blog.vsinha.com/contact/">contact
me</a>.</p>
<p>The main objection I’ve been getting is that this feels like Rust evangelism to
some folks. I’m not sure I can help them with that – if they can show me
another systems language that supports all the features I touch on in this talk,
I’d be very excited to learn about it.</p>
<p>Many of the things we’ve done in Hubris cannot be done robustly in C/C++, in the
sense that they could be <em>approximated,</em> but their integrity would have to be
maintained through code review or convention rather than compile-time checks.
Believe me, I’ve tried in previous jobs. Folks asserting that I’m wrong on this,
point me to your repo.</p>

  
    <p><span>
      
        <a href="http://cliffle.com/tags/rust/">#rust</a>
      
        <a href="http://cliffle.com/tags/talks/">#talks</a>
      
    </span>
  
</p></div>

        </div></div>
  </body>
</html>
