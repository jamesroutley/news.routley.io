<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC32/">Original</a>
    <h1>RC32. Where the fear (of pointers) has gone there will be nothing.</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-06-28T00:00:00-07:00">June 28, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          5 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        

<p>I’m scared of pointers, okay?</p>

<!--more-->

<figure>
<img src="https://www.datadoodad.com/assets/images/RC32_evilpointer-1.png" alt="Evil Pointer"/>
<figcaption>Evil pointer</figcaption>
</figure>

<p>There, I said it!</p>

<p>I got into whole damned business by building websites and stuff – HTML, maybe some PHP, a little JavaScript, a relational database or two if I was lucky. Then more recently Python has been my daily driver. Python, okay? Understand? So now I’m looking at a bunch of C code filled with ampersands and asterisks, and I’m weighing the possibility that my computer might, I don’t know, melt or explode or something on compilation. I’m scared, I tell you!</p>

<p><img src="https://www.datadoodad.com/assets/images/RC32_winkies.gif" alt="Winkies" width="100%"/></p>

<p>Ah but as young Paul Atreides once said, “Fear is the mind-killer.”</p>

<p>Alright Muad’Dib, time to face the fear and permit it to pass over me and through me and all that.</p>



<p>The concept of a register having a particular address where it stores some value is actually familiar thanks to my time with nand2tetris these past 6 weeks. Nevertheless, it strikes me as a great deal of power to wield, having this kind of direct access to computer memory and the sacred knowledge of where, precisely, the very stuff of software resides. So, to ease into the whole thing I created my own version of a simple swap function while following K&amp;R.</p>

<figure>
<img src="https://www.datadoodad.com/assets/images/RC32_evilpointer-2.png" alt="Evil Pointer"/>
<figcaption>Another evil pointer</figcaption>
</figure>

<p>Here’s something that will not work.</p>

<div><div><pre><code><span>void</span> <span>swap</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>int</span> <span>b</span><span>)</span>
<span>{</span>
    <span>int</span> <span>tmp</span><span>;</span>

    <span>tmp</span> <span>=</span> <span>a</span><span>;</span>
    <span>a</span> <span>=</span> <span>b</span><span>;</span>
    <span>b</span> <span>=</span> <span>tmp</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>int</span> <span>x</span><span>,</span> <span>y</span><span>;</span>

    <span>x</span> <span>=</span> <span>3</span><span>;</span>
    <span>y</span> <span>=</span> <span>8</span><span>;</span>

    <span>printf</span><span>(</span><span>&#34;Before swap: x = %d, y = %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>);</span>
    <span>swap</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;After swap:  x = %d, y = %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>Before swap: x = 100, y = 200
After swap:  x = 100, y = 200
</code></pre></div></div>

<p>Here, I’ve created a <code>swap()</code> function that takes two integers, <code>a</code> and <code>b</code>, as arguments. After assigning the value at <code>a</code> to <code>tmp</code>, I assign the value of <code>b</code> to <code>a</code> and then <code>tmp</code> (the value formerly known as <code>a</code>) to <code>b</code>. Seems promising, but it doesn’t work, since calling <code>swap(x, y)</code> passes copies of the values, and not the values themselves, to the function. So <code>tmp</code>, <code>a</code>, and <code>b</code> indeed do their little dance together, but <code>x</code> and <code>y</code> are never affected.</p>

<p>As an alternative, we can pass not <em>values</em> to <code>swap</code> but the <em>addresses</em> where those values are stored, and from the body of <code>swap()</code> shuffle the things in these addresses around.</p>

<div><div><pre><code><span>void</span> <span>swap</span><span>(</span><span>int</span> <span>*</span><span>px</span><span>,</span> <span>int</span> <span>*</span><span>py</span><span>)</span>
<span>{</span>
    <span>int</span> <span>tmp</span><span>;</span>
    <span>tmp</span> <span>=</span> <span>*</span><span>px</span><span>;</span>
    <span>*</span><span>px</span> <span>=</span> <span>*</span><span>py</span><span>;</span>
    <span>*</span><span>py</span> <span>=</span> <span>tmp</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>int</span> <span>x</span><span>,</span> <span>y</span><span>;</span>

    <span>x</span> <span>=</span> <span>3</span><span>;</span>
    <span>y</span> <span>=</span> <span>8</span><span>;</span>

    <span>printf</span><span>(</span><span>&#34;Before swap: x = %d, y = %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>);</span>
    <span>swap</span><span>(</span><span>&amp;</span><span>x</span><span>,</span> <span>&amp;</span><span>y</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;After swap:  x = %d, y = %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>Before swap: x = 100, y = 200
After swap:  x = 200, y = 100
</code></pre></div></div>

<p>Here, <code>&amp;x</code> is saying “the address of the register where the integer ‘x’ is.” Same with <code>&amp;y</code>. This is called <em>referencing</em>, I suppose since we’re retrieving not the values assigned to <code>x</code> and <code>y</code> but their references.</p>

<p>Next, we’re passing these pointers to <code>swap()</code> as arguments <code>*px</code> and <code>*py</code> (‘p’ for pointer). <code>*px</code> and <code>*py</code> are just addresses that <em>point to</em> two places in memory.</p>

<p>In the body of the function, when we assign <code>*px</code> to a new integer variable called <code>tmp</code>, what we’re doing is saying “hey, get me the thing at this address <code>*px</code> and assign it to <code>tmp</code>, got it?” This is called <em>dereferencing</em>. We continue to deref stuff: “Hey, also, go ahead and assign the integer at address <code>*py</code> to address <code>*px</code>,” we say, “and while you’re at it do me a favor and put that integer <code>tmp</code> at address <code>*py</code>. Thanks!”</p>

<p>Now when we call <code>swap()</code>, we’re not manipulating copies of <code>x</code> and <code>y</code>; instead, we have direct access to their locations in memory, and we’re using that knowledge to move things from one box to another.</p>



<figure>
<img src="https://www.datadoodad.com/assets/images/RC32_evilpointer-3.png" alt="Evil Pointer"/>
<figcaption>Another!</figcaption>
</figure>

<p>Okay, so, here’s a simple diagram of what is happening here (I think).</p>

<p>Here’s my RAM.</p>



<p>It has 5 (!) memory registers, with addresses ranging from 0 to 4. I’ve assigned the integer value 3 to <code>x</code>, which the compiler stuck at address <code>@0</code>, which presumably was free, and I’ve assigned the integer value 8 to <code>y</code>, which the compiler stuck at the next available address, which in this case is <code>@1</code>. Great!</p>

<p>Next order of business: let’s pass the <em>addresses</em> for <code>x</code> and <code>y</code> to <code>swap()</code> like so: <code>swap(&amp;x, &amp;y)</code>. Once we’re inside swap, we’ll initialize a new integer, <code>tmp</code>, which the compiler conveniently puts at the next available place in RAM. (Note that there’s no value stored there yet.)</p>



<p>When we assigned <code>*px</code> to <code>tmp</code>, then, we’re saying we want to assign the value <code>@0</code> (where <code>*px</code> is pointing) to wherever <code>tmp</code> is:</p>



<p>Then we assign <code>*px = *py</code>, setting the register <code>@0</code> to whatever value is on the register <code>@1</code>.</p>

<table>
  <tbody><tr>
    <td>0</td>
    <td><strike>3</strike> 8</td>
    <td>x</td>
  </tr>
  <tr>
    <td>1</td>
    <td>8</td>
    <td>y</td>
  </tr>
  <tr>
    <td>2</td>
    <td>3</td>
    <td>tmp</td>
  </tr>
  <tr>
    <td>3</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>4</td>
    <td></td>
    <td></td>
  </tr>
</tbody></table>

<p>Finally, we assign <code>*py = tmp</code>, which sets register <code>@1</code> to whatever <code>tmp</code> is.</p>

<table>
  <tbody><tr>
    <td>0</td>
    <td>8</td>
    <td>x</td>
  </tr>
  <tr>
    <td>1</td>
    <td><strike>8</strike> 3</td>
    <td>y</td>
  </tr>
  <tr>
    <td>2</td>
    <td>3</td>
    <td>tmp</td>
  </tr>
  <tr>
    <td>3</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>4</td>
    <td></td>
    <td></td>
  </tr>
</tbody></table>

<p>Hopefully this is mostly accurate.</p>

<p>Anyway, what’s cool is that we can actually print out the addresses if we want, so</p>

<div><div><pre><code><span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>int</span> <span>x</span><span>,</span> <span>y</span><span>;</span>

    <span>x</span> <span>=</span> <span>3</span><span>;</span>
    <span>y</span> <span>=</span> <span>8</span>

    <span>printf</span><span>(</span><span>&#34;@x = %p</span><span>\n</span><span>&#34;</span><span>,</span> <span>&amp;</span><span>x</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;@y = %p</span><span>\n</span><span>&#34;</span><span>,</span> <span>&amp;</span><span>y</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>will yield</p>

<div><div><pre><code>@x = 0x7ff7bcc93918
@y = 0x7ff7bcc93914
</code></pre></div></div>

<p>And this is neat for another reason, too, since we can see that <code>x</code> and <code>y</code> are being stored 4 addresses away from one another – which makes total sense, since integer types take up, you guessed it, 4 bytes of space! So the compiler seems to be saying, “Cool, you’re declaring two integers here? Each needs four bytes of space, and I’m gonna store them right next to each other – at addresses 140,702,000,953,620 and 140,702,000,953,624 if you want to write it down.”</p>



<ul>
  <li>Finished implementing DNS in python with the Implement DNS in a Weekend crew. Spent a little time reimplementing it in C (which is what led me down this pointer hole in the first place), but, well, that might take a while. Definitely bumping into walls and learning a lot.</li>
  <li>Paired on some C stuff, such as the above, and felt like I’m having one of those tiny steps/giant leaps situations</li>
  <li>Group meeting and assembler code review for nand2tetris</li>
  <li>Fun pairing sesh with someone doing wacky unthinkables in P5.js</li>
</ul>


          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
