<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prdeving.wordpress.com/2023/09/29/mmo-architecture-source-of-truth-dataflows-i-o-bottlenecks-and-how-to-solve-them/">Original</a>
    <h1>MMO Architecture: Source of truth, Dataflows, I/O bottlenecks and how to solve</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>By certain absurdities of life that only someone whose hobby perfectly aligns with his job can understand, lately I’ve been involved in the design and architecture of an MMO game.</p>



<p>As much as it may seem that such an application fits perfectly in what we would unconsciously consider “<strong>distributed architectures</strong>“, the specific details (small and large) of this kind of solutions turn what, for any capable engineer would be a simple design process into a <strong>headache</strong> of biblical proportions.</p>



<hr/>



<p>Latencies, race conditions, synchrony and availability is something that every architect faces, practically every day, however, in practically all scenarios, the solution is a renegotiation of the functional and technical requirements (is it enough to have latency less than 10 seconds?) and rarely do we design complete solutions due to their complexity.</p>



<p>The world of multiplayer video games is<strong> kinda different</strong>, the spatial complexity goes to infinity, and we try to keep the temporal one to a minimum. We work with multiple strictly deterministic modules that we can easily maintain and deploy in parallel.</p>



<p>The main purpose of this post is to explore the limitations that we find at the <strong>data I/O level in the design of MMO systems</strong>, the interactions that the system makes with the data, its derived problems and how to solve them.</p>



<p>It is interesting to see<strong> how different the solutions are depending on the problem</strong> and the <strong>system requirements</strong>. The beauty of software architecture ❤</p>



<blockquote>
<p>the source of truth of your game world IS NOT the database.</p>
</blockquote>



<p>This is a complicated concept to accept for those of us who come from enterprise systems, but it is so.</p>



<p>In these cases, we consider the database a<strong> persistence medium</strong>, not a source of truth. Whereas the real source of truth of the virtual world we are concerned with always resides in memory.</p>



<p>Heresy! well, a little bit. let’s go deeper into this concept with MATH.</p>



<p>let’s say we have a MMORPG game like world of warcraft with 1000 players, its world is of course divided into zones, so that we can do sharding. what we are interested in here, however, is that all players live together in the same environment.</p>



<p>Let’s assume that these players just go around, happily killing boars. Let’s also assume that our game client, in order to make life easier for our infrastructure, sends the players’ actions to the server once per second.</p>



<p>And that’s <strong>only </strong>taking into consideration <strong>the position of the players</strong> in the world! Now you have to add experience gained, sword strokes, chat messages, etc.</p>



<p>Considering our database as the source of truth, it forces us to persist all this information, which, to put it mildly, is N writings per second.</p>



<figure><img data-attachment-id="3047" data-permalink="https://prdeving.wordpress.com/2023/09/29/mmo-architecture-source-of-truth-dataflows-i-o-bottlenecks-and-how-to-solve-them/image/" data-orig-file="https://prdeving.files.wordpress.com/2023/09/image.png" data-orig-size="503,299" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://prdeving.files.wordpress.com/2023/09/image.png?w=300" data-large-file="https://prdeving.files.wordpress.com/2023/09/image.png?w=503" width="503" height="299" src="https://prdeving.files.wordpress.com/2023/09/image.png?w=503" alt="" srcset="https://prdeving.files.wordpress.com/2023/09/image.png 503w, https://prdeving.files.wordpress.com/2023/09/image.png?w=150 150w, https://prdeving.files.wordpress.com/2023/09/image.png?w=300 300w" sizes="(max-width: 503px) 85vw, 503px"/></figure>



<p>Best of luck.</p>



<p>The solution to such a problem is relatively simple once we get rid of the idea of using the database as the source of truth.</p>



<blockquote>
<p>Cache, lots of cache</p>
</blockquote>



<p>When I said earlier that the source of truth of the game world state resides in memory I meant it, though not in the simplest sense.</p>



<p>In these cases our requirements are not too many, though complicated:</p>



<ul>
<li>we need <strong>direct and low latency </strong>connection between game services and world state.</li>



<li>we need the world state to be <strong>persisted</strong> in order to replicate or <strong>recover</strong> from errors or outages</li>



<li>we need it to be <strong>scalable</strong> for the future</li>



<li>we need to <strong>avoid race conditions</strong></li>
</ul>



<p>To meet these specifications, we usually use a <strong>data</strong> <strong>broker pattern</strong>.</p>



<figure><img data-attachment-id="3048" data-permalink="https://prdeving.wordpress.com/2023/09/29/mmo-architecture-source-of-truth-dataflows-i-o-bottlenecks-and-how-to-solve-them/image-1/" data-orig-file="https://prdeving.files.wordpress.com/2023/09/image-1.png" data-orig-size="721,297" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-1" data-image-description="" data-image-caption="" data-medium-file="https://prdeving.files.wordpress.com/2023/09/image-1.png?w=300" data-large-file="https://prdeving.files.wordpress.com/2023/09/image-1.png?w=721" width="721" height="297" src="https://prdeving.files.wordpress.com/2023/09/image-1.png?w=721" alt="" srcset="https://prdeving.files.wordpress.com/2023/09/image-1.png 721w, https://prdeving.files.wordpress.com/2023/09/image-1.png?w=150 150w, https://prdeving.files.wordpress.com/2023/09/image-1.png?w=300 300w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></figure>



<p>But how does this meet the requirements? Let’s go in parts</p>



<h2><strong>We need direct and low latency connection between game services and world state.</strong></h2>



<p>This is perhaps the simplest part, <strong>our game world services connect by RPC to the game state service and execute actions</strong>.</p>



<p>Here comes an important point that, although perhaps slightly out of the scope of this post, is worth mentioning.</p>



<p>grantPlayerExperience, playerChangingZone, etc.</p>



<p>This way, we <strong>keep our layers separate</strong>, we <strong>decouple</strong> the data API from the implementation and keep our game logic <strong>isolated</strong>.</p>



<h2><strong>We need the world state to be persisted in order to replicate or recover from errors or outages</strong></h2>



<p>Persist yes, but What and When? this is more of a philosophical and <strong>product design job</strong> than software architecture per se, but let’s see how we can dig into it a bit.</p>



<p>The first question is, how much is acceptable? sometimes we tend to think that even the smallest movement is likely to be saved for posterity, but often it is not.</p>



<p>Let’s take for example the game League of Legends, what would we save and when in this case?</p>



<p>If you ask me, I would save the <strong>final state of the game, once it is finished</strong> (we ignore replays, obeservability, etc for this example).</p>



<p>The reasons are simple, in a system of this type, we look for persistence to be able to recover from problems,<strong> not as a business definition</strong>.</p>



<p>Let’s suppose that we are saving EVERY change throughout the game and our instance explodes, goes offline or is sucked into the infinite void of space. Can we recover from that error? Can we restore the last saved state?</p>



<p><strong>No, we can’t.</strong></p>



<p>It is likely that, by the time we restore the state, half of the players will no longer be connected.</p>



<p>So what are we going to persist all the changes in the database for?</p>



<p>The tricky part here, as I said above, is <strong>what to save and when to save it.</strong></p>



<p>In the case of the example, what do we save? well, the player’s stats at the end of the game and little else. When? at the end of the game.</p>



<p>In a more complex case like World of warcraft, we could save, for example: the inventory when an item changes hands or is used, the player’s position every certain time (30 seconds maybe?), the zone every time the player changes, etc.</p>



<p>The trick is to <strong>minimize as much as possible the writes to persistence</strong> by writing only those things that are essential for recovery.</p>



<p>everything else, we <strong>keep it in memory</strong> in the game state service.</p>



<h2>We need it to be scalable for the future</h2>



<p>Here perhaps we touch on one of the tricky points.</p>



<p>A relatively simple solution may be to take advantage of the <strong>Redis pub/sub system</strong> to synchronize the state services.</p>



<p>Also, let’s think about it this way, if you have 100 game world services acting against a single state service, we are talking about 100 open sockets, it is not comparable with the amount of thousands of database commands that we would have if we ignore the broker, <strong>right?</strong></p>



<h2>We need to avoid race conditions</h2>



<p>This is perhaps the most trivial point, since, as long as we maintain a single-threaded architecture in our data service, it is practically <strong>guaranteed</strong> that we will not have significant race conditions.</p>



<p>However, when working with distributed data or in multi-threaded environments we have a great friend.</p>



<p><strong>CAS (<a href="https://en.wikipedia.org/wiki/Compare-and-swap">Compare-and-swap</a>)</strong></p>



<p>The thing is simple, you take a <strong>hash of the state </strong>(or a part of it) before starting the operation which we will call, <strong>version hash</strong>.</p>



<figure><img data-attachment-id="3051" data-permalink="https://prdeving.wordpress.com/2023/09/29/mmo-architecture-source-of-truth-dataflows-i-o-bottlenecks-and-how-to-solve-them/image-2/" data-orig-file="https://prdeving.files.wordpress.com/2023/09/image-2.png" data-orig-size="755,512" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://prdeving.files.wordpress.com/2023/09/image-2.png?w=300" data-large-file="https://prdeving.files.wordpress.com/2023/09/image-2.png?w=755" loading="lazy" width="755" height="512" src="https://prdeving.files.wordpress.com/2023/09/image-2.png?w=755" alt="" srcset="https://prdeving.files.wordpress.com/2023/09/image-2.png 755w, https://prdeving.files.wordpress.com/2023/09/image-2.png?w=150 150w, https://prdeving.files.wordpress.com/2023/09/image-2.png?w=300 300w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></figure>



<p>A simple version control system</p>



<p>and what happens if the CAS fails? <strong>retry</strong>, N times, as many as you think, and if it is not possible, <strong>return error</strong>.</p>



<hr/>



<blockquote>
<p>Understanding the state of our game world as ephemeral, and knowing how to identify the exact data amenable to persistence is perhaps more of a learned art than a teachable science.</p>
</blockquote>



<p>In summary, when working in high traffic distributed systems, with many agents constantly changing dynamic data, considering the database as the source of truth leads to bottlenecks and <strong>availability problems sooner rather than later</strong>.</p>



<p>Strategies, perhaps counter-intuitive or heretical to those of us who come from enterprise architectures, are usually the standard solution accepted by the industry.</p>



<p>A <strong>good planning</strong> of the update and persistence windows of our data and a <strong>thorough analysis</strong> of our system’s “use cases” and scenarios, together with a data broker pattern allows us to free the database from <strong>unnecessary writes</strong> and our wallets from bulging invoices.</p>



<p>Understanding the state of our game world as ephemeral, and knowing how to identify the exact data amenable to persistence is perhaps more of a learned art than a teachable science.</p>



<p>The beauty of software architecture.</p>

			
				</div></div>
  </body>
</html>
