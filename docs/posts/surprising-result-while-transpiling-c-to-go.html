<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.nobugware.com/post/2022/surprising-result-while-transpiling-go/">Original</a>
    <h1>Surprising result while transpiling C to Go</h1>
    
    <div id="readability-page-1" class="page"><article>
<header><hgroup id="brand">

<h5>
<time datetime="2022-06-20 04:00:00 +0000 UTC">Jun 20, 2022</time>
<span>
-
<a href="https://blog.nobugware.com/tags/go">go</a>
<a href="https://blog.nobugware.com/tags/geo">geo</a>
<a href="https://blog.nobugware.com/tags/golang">golang</a>
<a href="https://blog.nobugware.com/tags/h3">h3</a>
<span>
</span></span></h5>
</hgroup>
<hr/>
</header>
<p><a href="https://github.com/uber/h3/">H3</a> is a geospacial indexing library created by Uber. If you are familiar with this blog it’s similar to <a href="https://s2geometry.io/">S2</a>.</p>
<p>Uber is providing <a href="https://github.com/uber/h3-go">h3 for Go</a>. Unfortunately it’s a CGO version, a C to Go binding as you may know <a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go">CGO is not Go</a>.</p>
<p>Having a native Go library is easier to deal with but would mean a full rewrite.</p>
<h2 id="transpiling">Transpiling</h2>
<p>You may have heard about a recent effort to transpile C to Go using <a href="https://pkg.go.dev/modernc.org/ccgo/v3">ccgo</a> and the associated <a href="https://pkg.go.dev/modernc.org/libc">libc</a>.</p>
<p>Sqlite has been <a href="https://pkg.go.dev/modernc.org/sqlite#section-readme">transpiled using this technique</a> with great success; more recently <a href="https://www.reddit.com/r/golang/comments/v0sdn2/a_cgofree_port_of_the_pcre2_regular_expression/">PCRE2</a> as well.</p>
<p>The result library is often slower than pure C (~2x magnitude) but still having a native Go port could simplify some aspects of the workflow like testing.</p>
<p>I’m working on a side project where I need to index millions of coordinates using h3 indexation, so I gave ccgo a try, hoping for something working.</p>
<p>Not 100% of the libc is covered, some builtins are not defined I had to define <code>isFinite</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span>bool</span> <span>isXFinite</span>(<span>double</span> f) { <span>return</span> <span>!</span>isnan(f <span>-</span> f); }

<span>/**
</span><span> * Encodes a coordinate on the sphere to the H3 index of the containing cell at
</span><span> * the specified resolution.
</span><span> *
</span><span> * Returns 0 on invalid input.
</span><span> *
</span><span> * @param g The spherical coordinates to encode.
</span><span> * @param res The desired H3 resolution for the encoding.
</span><span> * @return The encoded H3Index (or H3_NULL on failure).
</span><span> */</span>
H3Index <span>H3_EXPORT</span>(geoToH3)(<span>const</span> GeoCoord<span>*</span> g, <span>int</span> res) {
    <span>if</span> (res <span>&lt;</span> <span>0</span> <span>||</span> res <span>&gt;</span> MAX_H3_RES) {
        <span>return</span> H3_NULL;
    }
    <span>if</span> (<span>!</span>isXFinite(g<span>-&gt;</span>lat) <span>||</span> <span>!</span>isXFinite(g<span>-&gt;</span>lon)) {
        <span>return</span> H3_NULL;
    }

    FaceIJK fijk;
    _geoToFaceIjk(g, res, <span>&amp;</span>fijk);
    <span>return</span> _faceIjkToH3(<span>&amp;</span>fijk, res);
}

</code></pre></div><p>The C tests are passing, let’s continue transpiling:</p>
<pre tabindex="0"><code>  CC=/usr/bin/gcc ccgo  -pkgname ch3  -trace-translation-units -export-externs X -export-defines D -export-fields F -export-structs S -export-typedefs T -Isrc/h3lib/include  -I../src/h3lib/include ../src/h3lib/lib/*.c
</code></pre><p>The generated code is visible on <a href="https://github.com/akhenakh/goh3/tree/main/ch3">my goh3 repo</a>, with some <a href="https://github.com/akhenakh/goh3/blob/main/h3.go">helper functions</a>, it can be used exactly like the original Uber library.</p>
<p>Note that for this experiment I’ve only created the helper functions for the indexation part.</p>
<p>It works!! But no surprise it’s slower, way slower…</p>
<p>1 millions coordinates to cell and back:</p>
<ul>
<li>In pure C (-O2): <strong>2.03s</strong></li>
<li>Using Uber CGO: <strong>2.25s</strong></li>
<li>Using the transpiled code: <strong>13.07s</strong></li>
</ul>
<h2 id="profiling">Profiling</h2>
<p>What is slow? Using the profiler it’s evident the cost to initialize the ccgo libc is too big:</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> <span>FromGeo</span>(<span>geo</span> <span>GeoCoord</span>, <span>res</span> <span>int</span>) <span>H3Index</span> {
	<span>tls</span> <span>:=</span> <span>libc</span>.<span>NewTLS</span>()
	<span>defer</span> <span>tls</span>.<span>Close</span>()

	<span>cgeo</span> <span>:=</span> <span>ch3</span>.<span>TGeoCoord</span>{
		<span>Flat</span>: <span>deg2rad</span> <span>*</span> <span>geo</span>.<span>Latitude</span>,
		<span>Flon</span>: <span>deg2rad</span> <span>*</span> <span>geo</span>.<span>Longitude</span>,
	}

	<span>return</span> <span>H3Index</span>(<span>ch3</span>.<span>XgeoToH3</span>(<span>tls</span>, uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>cgeo</span>)), int32(<span>res</span>)))
}
</code></pre></div><p>What if we could initialize then batch?</p>
<div><pre tabindex="0"><code data-lang="go"><span>func</span> <span>NewBatch</span>() <span>*</span><span>Batch</span> {
	<span>return</span> <span>&amp;</span><span>Batch</span>{<span>TLS</span>: <span>libc</span>.<span>NewTLS</span>()}
}

<span>func</span> (<span>c</span> <span>*</span><span>Batch</span>) <span>FromGeo</span>(<span>geo</span> <span>GeoCoord</span>, <span>res</span> <span>int</span>) <span>H3Index</span> {
	<span>cgeo</span> <span>:=</span> <span>ch3</span>.<span>TGeoCoord</span>{
		<span>Flat</span>: <span>deg2rad</span> <span>*</span> <span>geo</span>.<span>Latitude</span>,
		<span>Flon</span>: <span>deg2rad</span> <span>*</span> <span>geo</span>.<span>Longitude</span>,
	}

	<span>return</span> <span>H3Index</span>(<span>ch3</span>.<span>XgeoToH3</span>(<span>c</span>.<span>TLS</span>, uintptr(<span>unsafe</span>.<span>Pointer</span>(<span>&amp;</span><span>cgeo</span>)), int32(<span>res</span>)))
}
</code></pre></div><p>Batching 1 million again: <strong>1.82s</strong></p>
<p>It’s not only working it’s as fast and sometimes faster than the C code, probably due to Go runtime scaling on multiple cores.</p>
<p>I put <a href="https://github.com/akhenakh/h3-bench">some benchmarks comparing CGO &amp; CCGO</a>.</p>
<pre tabindex="0"><code>cpu: Intel(R) Core(TM) i7-6700K CPU @ 4.00GHz
BenchmarkToGeoCCGO-8    	32722182	       367.9 ns/op	       0 B/op	       0 allocs/op
BenchmarkToGeoCGO-8     	30941000	       389.8 ns/op	      16 B/op	       1 allocs/op
BenchmarkFromToCCGO-8   	 6580898	      1831 ns/op	       0 B/op	       0 allocs/op
BenchmarkFromToCGO-8    	 5373619	      2230 ns/op	      32 B/op	       2 allocs/op
</code></pre><p>Interestingly it’s faster on amd64 but a bit slower on arm64 M1.</p>
<h2 id="conclusion">Conclusion</h2>
<p>CCGO is an incredible piece of code with a bright future, it’s one more tool in the Go ecosystem that we can rely on.</p>
</article></div>
  </body>
</html>
