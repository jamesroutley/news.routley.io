<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://orlp.net/blog/magical-fibonacci-formulae/">Original</a>
    <h1>Magical Fibonacci Formulae</h1>
    
    <div id="readability-page-1" class="page"><article>

<time datetime="2023-02-06">2023-02-06</time>
<p>The following Python function computes the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci
sequence</a>, without loops,
recursion or floating point arithmetic:</p>
<pre data-lang="python"><code data-lang="python"><span>f=</span><span>lambda </span><span>n:(b:=</span><span>2</span><span>&lt;&lt;n)**n*b//(b*b-b-</span><span>1</span><span>)%b
</span></code></pre>
<p>It really does:</p>
<pre data-lang="python"><code data-lang="python"><span>&gt;&gt;&gt; [f(n) </span><span>for </span><span>n </span><span>in </span><span>range(</span><span>10</span><span>)]
</span><span>[</span><span>0</span><span>, </span><span>1</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>5</span><span>, </span><span>8</span><span>, </span><span>13</span><span>, </span><span>21</span><span>, </span><span>34</span><span>]
</span></code></pre>
<p>How does it work? As a teaser, look at the decimal expansions of $100 / 9899$
and $1000 / 998999$ and see if you notice anything:</p>
<p>$$\frac{100}{9899} = 0.0101020305081321345590463…$$
$$\frac{1000}{998999} = 0.001001002003005008013021034055089144233377610988…$$</p>
<h2 id="generating-functions"><a href="#generating-functions" aria-label="Anchor link for: generating-functions">Generating functions</a></h2>
<p>We define the Fibonacci sequence as 
\begin{align*}
f(0) &amp;= 0,\\
f(1) &amp;= 1,\\
f(n) &amp;= f(n - 1) + f(n - 2).
\end{align*}
However, we will also define a rather strange object known as a <a href="https://en.wikipedia.org/wiki/Generating_function">generating
function</a>. It is an
‘infinite polynomial’ (also known as a <a href="https://en.wikipedia.org/wiki/Power_series">power series</a>)
in variable $x$ whose <em>coefficients</em> correspond to our series of interest. This
gives us
$$F(x) = 0 + 1x + 1x^2 + 2x^3 + 3x^4 + 5x^5 + 8x^6 + \cdots,$$
$$F(x) = f(0)x^0 + f(1)x^1 + f(2)x^2 + \cdots = \sum_{n=0}^\infty f(n)x^n.$$</p>
<p>Does this function converge? Is this really allowed? All interesting questions
we are going to ignore here. Instead, let’s just start doing interesting things
with our new object, like taking out the first two terms from the sum:</p>

<p>$$F(x) = f(0)x^0 + f(1)x^1 + \sum_{n=2}^\infty f(n)x^n = x + \sum_{n=2}^\infty f(n)x^n.$$</p>
<p>We can also substitute $f(n) = f(n - 1) + f(n - 2)$ now, because our iteration
variable starts at $2$:</p>
<p>\begin{align*}
F(x) &amp;= x + \sum_{n=2}^\infty \Big(f(n-1) + f(n-2) \Big)x^n\\
&amp;= x + \sum_{n=2}^\infty f(n-1)x^n + \sum_{n=2}^\infty f(n-2)x^n.
\end{align*}
Now we can substitute the loop variables, re-insert the $f(0)$ term (which is just
zero) into the first sum, and factor out the extra $x$ terms:
\begin{align*}
F(x) &amp;= x + \sum_{n=1}^\infty f(n)x^{n+1} + \sum_{n=0}^\infty f(n)x^{n+2}\\
&amp;= x - f(0)x^{1} + \sum_{n=0}^\infty f(n)x^{n+1} + \sum_{n=0}^\infty f(n)x^{n+2}\\
&amp;= x + x\sum_{n=0}^\infty f(n)x^{n} + x^2\sum_{n=0}^\infty f(n)x^{n}.
\end{align*}</p>
<p>And now using the crucial observation that $F(x) = \sum_{n=0}^\infty f(n)x^{n}$:
\begin{align*}
F(x) &amp;= x + xF(x) + x^2F(x),\\
(1 - x - x^2)F(x) &amp;= x,\\
F(x) &amp;= \frac{x}{1 - x - x^2}.
\end{align*}
Wow. Somehow the simple expression $x / (1 - x - x^2)$ ‘contains’ the entire
Fibonacci sequence. If you substitute $x = 10^{-3}$ in $F(x)$ you will retrieve
our earlier value
$$\frac{1000}{998999} = 0.001001002003005008013021034055089144233377610988…$$</p>
<h2 id="an-interlude-by-binet"><a href="#an-interlude-by-binet" aria-label="Anchor link for: an-interlude-by-binet">An interlude by Binet</a></h2>
<p>Solving $1 - x - x^2 = 0$ with the <a href="https://en.wikipedia.org/wiki/Quadratic_formula">quadratic formula</a> gives us
roots $-(\sqrt{5} \pm 1)/2$, which one might recognize as
the (negative) <a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a> $\phi$ and its inverse
$\phi^{-1}$:
$$\phi = \frac{\sqrt{5} + 1}{2}, \quad \phi^{-1} = \frac{2}{\sqrt{5} + 1} = \frac{2\left(\sqrt{5} - 1\right)}{\left(\sqrt{5} + 1\right)\left(\sqrt{5} - 1\right)} = \frac{\sqrt{5} - 1}{2}.$$</p>
<p>This allows us to factor and
use  <a href="https://en.wikipedia.org/wiki/Partial_fraction_decomposition">partial fraction decomposition</a>
on $F(x)$:
$$\frac{x}{1 - x - x^2} = \frac{x}{(1 - \phi x)(1 + \phi^{-1} x)} = \frac{1}{\phi + \phi^{-1}}\left(\frac{1}{1 - \phi x} - \frac{1}{1 + \phi^{-1} x}\right).$$
This is a rather arduous (but strictly elementary) algebraic process so it is much easier
to verify by expanding that the identity holds than following along.
To verify use the fact that $\phi \cdot \phi^{-1} = \phi - \phi^{-1} = 1$.</p>
<p>If we recall the formula
for the <a href="https://en.wikipedia.org/wiki/Geometric_series">geometric series</a>,</p>
<p>$$\frac{1}{1 - r} = \sum_{n=0}^\infty r^n,$$</p>
<p>and apply it to our above expression (once
again completely ignoring convergence) while
noticing that $\phi + \phi^{-1} = \sqrt{5}$ we find</p>
<p>$$F(x) = \frac{1}{\sqrt{5}} \left( \sum_{n=0}^\infty \phi^n x^n - \sum_{n=0}^\infty {(-\phi})^{-n} x^n \right),$$
$$F(x) = \sum_{n=0}^\infty \frac{1}{\sqrt{5}} \left(  \phi^n - {(-\phi})^{-n} \right) x^n.$$</p>
<p>And now for the true magic, recall that we defined $F(x) = \sum_{n=0}^\infty f(n)x^n$, and thus we conclude
$$f(n) = \frac{1}{\sqrt{5}}\left(\phi^n - {(-\phi})^{-n} \right).$$</p>

<p>We have recovered <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Binet&#39;s_formula">Binet’s formula</a>
for the Fibonacci numbers, a closed form. Unfortunately evaluating it in
Python would eventually fail due to the use of floating-point numbers,
which is why this is only an interlude. But it is nevertheless cool:</p>
<pre data-lang="python"><code data-lang="python"><span>&gt;&gt;&gt; phi = (</span><span>1 </span><span>+ </span><span>5</span><span>**</span><span>0.5</span><span>) / </span><span>2
</span><span>&gt;&gt;&gt; [(phi**n - (-phi)**-n) / </span><span>5</span><span>**</span><span>0.5 </span><span>for </span><span>n </span><span>in </span><span>range(</span><span>10</span><span>)]
</span><span>[</span><span>0.0</span><span>, </span><span>1.0</span><span>, </span><span>1.0</span><span>, </span><span>2.0</span><span>, </span><span>3.0000000000000004</span><span>, </span><span>5.000000000000001</span><span>, </span><span>8.000000000000002</span><span>, </span><span>13.000000000000002</span><span>, </span><span>21.000000000000004</span><span>, </span><span>34.00000000000001</span><span>]
</span></code></pre>
<h2 id="evaluating-generating-functions"><a href="#evaluating-generating-functions" aria-label="Anchor link for: evaluating-generating-functions">Evaluating generating functions</a></h2>
<p>Take another look at $F(10^{-3})$:</p>
<p>$$\frac{1000}{998999} = 0.001001002003005008013021034055089144233377610988…$$</p>
<p>Each next integer in the series starts three places shifted back from the previous
one. This makes sense, because $F(10^{-3})$ is the sum of $f(n)10^{-3n}$
for all $n$.</p>
<p>This also means that eventually the method fails, when numbers outgrow
three digits and overflow into the previous one. If we ignore that for now,
we can study $10^{3n} F(10^{-3})$:</p>
<pre><code><span>n = 0                   0.001001002003005008013021034055...
</span><span>n = 1                   1.001002003005008013021034055089...
</span><span>n = 2                1001.002003005008013021034055089144...
</span><span>n = 3             1001002.003005008013021034055089144233...
</span><span>n = 4          1001002003.005008013021034055089144233377...
</span><span>n = 5       1001002003005.008013021034055089144233377610...
</span><span>n = 6    1001002003005008.013021034055089144233377610988...
</span><span>                      ^^^
</span></code></pre>
<p>If we could extract just the highlighted column we have our Fibonacci numbers.
Luckily, we can. By flooring we can remove the entire fractional part, and with
modulo $10^3$ we can ignore everything after the third digit.</p>
<p>We still have the overflowing issue however. But this is easily fixed by
choosing a number $k$ instead of $3$, large enough such that the next Fibonacci
number doesn’t overflow into our number of interest. For example the choice $k
= n$ works, as the $n$th Fibonacci number certainly won’t overflow $n$ decimal
digits, giving formula</p>
<p>$$f(n) = \lfloor 10^{n^2} \cdot F(10^{-n}) \rfloor \bmod 10^{n}.$$</p>
<p>We can generalize much more however. Our choice of $10^3$ and $10^n$ as bases
was rather arbitrary. You can use any base $b$, as long as $b$ is large enough. This gives:</p>

<p>$$f(n) = \left\lfloor b^n \cdot F(b^{-1}) \right\rfloor \bmod b,$$
$$f(n) = \left\lfloor b^n \cdot \frac{b^{-1}}{1 - b^{-1} - b^{-2}} \right\rfloor \bmod b,$$
$$f(n) = \left\lfloor \frac{b^{n+1}}{b^2 - b - 1} \right\rfloor \bmod b.$$</p>
<p>This is actually a closed form we can evaluate without the use of floating
point arithmetic, as it simply consists of the division of two integers.
I have experimentally found that choosing $b = 3^n$ suffices to not overflow
for computing $f(n)$, giving our magical formula:</p>
<pre data-lang="python"><code data-lang="python"><span>&gt;&gt;&gt; f = </span><span>lambda </span><span>n: </span><span>3</span><span>**(n*(n+</span><span>1</span><span>)) // (</span><span>3</span><span>**(</span><span>2</span><span>*n) - </span><span>3</span><span>**n - </span><span>1</span><span>) % </span><span>3</span><span>**n
</span><span>&gt;&gt;&gt; [f(n) </span><span>for </span><span>n </span><span>in </span><span>range(</span><span>10</span><span>)]
</span><span>[</span><span>0</span><span>, </span><span>1</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>5</span><span>, </span><span>8</span><span>, </span><span>13</span><span>, </span><span>21</span><span>, </span><span>34</span><span>]
</span></code></pre>

<p>We can <a href="https://en.wikipedia.org/wiki/Code_golf">golf</a> this quite a bit by using Python’s <a href="https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions">“walrus operator”</a>
(also called <em>assignment expression</em> by boring people) introduced in Python 3.8. If you write <code>(foo := bar)</code>
in an expression the parentheses take on value <code>bar</code> as well as storing <code>bar</code>
in a new variable <code>foo</code> available in the rest of the expression. Finally as a
bit of flair and efficiency, ${b = 2^{n+1}}$ also works, which can be computed as
<code>2 &lt;&lt; n</code>:</p>
<pre data-lang="python"><code data-lang="python"><span>&gt;&gt;&gt; f=</span><span>lambda </span><span>n:(b:=</span><span>2</span><span>&lt;&lt;n)**n*b//(b*b-b-</span><span>1</span><span>)%b
</span><span>&gt;&gt;&gt; [f(n) </span><span>for </span><span>n </span><span>in </span><span>range(</span><span>10</span><span>)]
</span><span>[</span><span>0</span><span>, </span><span>1</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>5</span><span>, </span><span>8</span><span>, </span><span>13</span><span>, </span><span>21</span><span>, </span><span>34</span><span>]
</span></code></pre>

</article></div>
  </body>
</html>
