<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/cnlohr/channel3">Original</a>
    <h1>ESP8266 Analog Broadcast Television Interface</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">ESP8266 Analog Broadcast Television Interface</p>
<p dir="auto">Hook an antenna up to GPIO3/RX, tune your analog TV to Channel 3.  Power the ESP on!</p>

<p dir="auto">This uses the I2S Bus in the same way the esp8266ws2812i2s project does.  Difference is it cranks the output baud to 80 MHz.  We set up DMA buffers and let the CPU fill them as they pass through one line at a time.  The DMA interrupt fills in the buffers one word at a time.  The I2S bus shifts those buffers out at 80 MHz!</p>
<p dir="auto">You may say &#34;But nyquist says you can&#39;t transmit or receive frequencies at more than 1/2 the sample rate (40 MHz in this case).  To a degree that is true.  Some people thought it may be overtones, but what happens in reality something stranger happens.  Everything you transmit is actually mirrored around 1/2 the sample rate (40 MHz).  So, transmitting 60 MHz on an 80 MHz bitclock creates a waveform both at 60 as well as 20.  This isn&#39;t perfect.  Some frequencies line up to the 80 MHz well, others do not.</p>
<p dir="auto">We store a bit pattern in the &#34;premodulated_table&#34; array.  This contains bitstreams for various signals, such as the &#34;sync&#34; level or &#34;colorbust&#34; level, or any of the visual colors.  This table&#39;s length of 1408 bits per color was chosen so that when sent out one bit at a time at 80 MHz, it works out to an even multiplier of the NTCS chroma frequency of 315.0/88.0 MHz, or 3.579545455 MHz.  You can calculate this by taking 1408/80MHz = 17.6us * 3.579545 MHz = 63 cycles, exactly.  Conveniently, it also works out to an even multiplier of 61.25 MHz, Channel 3&#39;s luma center.  17.6us * 61.25 MHz = 1078 cycles, exactly! When you modulate arbitrary frequencies, sometimes the cycles come out very uneven.</p>
<p dir="auto">In order to generate luma (the black and white portion) we modulate 61.25 MHz.  If we generate a strong signal, it is viewed as a very &#34;dark&#34;, and a weak signal is a very &#34;bright.&#34;  This means when we want to send out a sync pulse, we modulate it as loud as we can... when we want to modulate white, we put out barely any signal at all.  One thing you will notice is dot pour.  This is because the signal we are sending is so terrible.  The chroma signal is very dirty and has a repeating intensity pattern.  While the chroma lines up to the 1408 bit-wide repeating patten, the total number of pixels on the screen does not.  This causes the patterns created to roll down the screen.</p>
<p dir="auto">In order to generate color, we need to modulate in a chroma signal, 3.579MHz above the baseband.  The chroma is synchronized by a colorburst at the beginning of each line.  This also sets the level for the chroma.  Then, during the line, we can either choose a &#34;color&#34; that has a high coefficient at the chroma level, or a low one.  This determines how vivid the color is.  We can change phase to change the color&#39;s hue.</p>
<p dir="auto">This is basically a 1-bit dithering DAC, operating at a frequency below the nyquist, trying to encode luma and color at the same time.  Don&#39;t be surprised that the quality&#39;s terrible.</p>

<p dir="auto">Tables for handling the line-buffer state machine are (generated/stored?) in MayCbTables.h/c, and similar tables for creating the on-wire signal encoding are in synthtables.c.</p>
<p dir="auto">Functions to set up the DMA transfers, refill the buffers when they become empty, and change what kind of line should be sent based on the framebuffer contents are in video_broadcast.c. These functions handle all of the modulation.  This sets up the DMA, and an interrupt that is called when the DMA finishes a block (equal to one line).  Upon completion, it uses CbTable to decide what function to call to fill in the line.  The interrupt fills out the next line for DMA which keeps going.</p>
<p dir="auto">The framebuffer is updated by various demo screens located in user_main.c.</p>
<p dir="auto">custom_commands.c contain the custom commands used for the NTSC-specific aspects.  Using the common websockets interface there are two added commands.  These include &#34;CO&#34; and &#34;CV&#34; which set the operation mode (CO) and allow users to change the modulation table from a web interface (CV).</p>

<p dir="auto">The following demo screens are available.  They normally tick through one after another (except ones after 10), unless the user disables this in the web browser.</p>

<ol dir="auto">
<li>Basic intro screen, shows IP address if available.</li>
<li>ESP8266 Features</li>
<li>Intro to and completion of framebuffer copy test.  Beware, running this screen too long deliberately will cause a crash.</li>
<li>Draw a bunch of lines... IN COLOR!</li>
<li>Matrix-based 3D engine demo.</li>
<li>Dynamic 3D mesh demo.</li>
<li>Pitch for this project&#39;s github.</li>
<li>Color screen with 16 color balls.</li>
<li>4x4 color swatches, useful for when you&#39;re messing with colors in the web GUI.</li>
</ol>

<p dir="auto">The web interface is borrowing the web interface from esp8266ws2812i2s.  Power on the ESP, connect to it, then, point your web browser to <a href="http://192.168.4.1" rel="nofollow">http://192.168.4.1</a>.  It has a new button &#34;NTSC.&#34;  This gives you the option to allow demo to continue from screen to screen, or freeze at a specific screen.  You can specify the screen.  Additionally, for RF testing, you can jam a color.  Whenever the color jam is set to something 0 or above, it turns off all line drawing logic, and simply outputs that color continuously.  This will prevent TV sets from seeing it, however, you can see it on other RF equipment.</p>
<p dir="auto">It also has an interactive Javascript webworker system that lets you write code to make a new color!  You can create a new bitstream that will be transmitted when a specific color is hit.  You can edit the code and it is effective as you type.  It automatically re-starts the webworker every time you change it.</p>
<p dir="auto">You should only output -1 or +1 as that is all the ESP can output.  It will then run a DFT with a randomized window over a frequency area you choose.  Increase the DFT window, and it will increase your q (or precision).  Decrease, it decreases your q.  This is to help see how receivers like the TV really understand the signal and help illustrate how wacky this really is.</p>
<p dir="auto">You can try it in your own browser using this link: <a href="http://cnlohr.github.io/channel3/web/page/index.html" rel="nofollow">http://cnlohr.github.io/channel3/web/page/index.html</a>  Click NTSC and go to town.</p>

<p dir="auto">For all the 3D and text, I&#39;m using a new modified version of my &#34;rawdraw&#34; library ( <a href="http://github.com/cnlohr/rawdraw">http://github.com/cnlohr/rawdraw</a> ) for 3D I&#39;m using fixed point numbers, with 256 as the unit value, and the bottom 8 bits are the fractional component.</p>

<p dir="auto">To allow for PAL broadcasts, the timings in the video_broadcast-library (formerly ntsc_broadcast) were modified. Since I only wanted to use this with a black an white TV, and PAL colour is actually quite complicated to do digitally, I didn&#39;t modify the broadcast_tables (synthtables.c). So the library broadcasts a PAL compliant B/W-Signal with NTSC Colour information (kind of like NTSC50).</p>
<p dir="auto">To enable PAL broadcasting you need to enable <code>OPTS += -DPAL</code> in user.cfg.</p>

<p dir="auto">Here is the original youtube video on this project:</p>
<p dir="auto"><a href="http://www.youtube.com/watch?v=SSiRkpgwVKY" rel="nofollow"><img src="https://camo.githubusercontent.com/6ca5bef23f57fb1753a71914c355b48095a077861f80a0be02d8980efd4951bf/687474703a2f2f696d672e796f75747562652e636f6d2f76692f535369526b706777564b592f302e6a7067" alt="NTSC Video on the ESP8266" data-canonical-src="http://img.youtube.com/vi/SSiRkpgwVKY/0.jpg"/></a></p>
<p dir="auto">Here is the new video (with COLOR):</p>
<p dir="auto"><a href="http://www.youtube.com/watch?v=bcez5pcp55w" rel="nofollow"><img src="https://camo.githubusercontent.com/855520194c9983aa37d76337f1d16d103600704141d15cbc3d7ee961f2fbdf0e/687474703a2f2f696d672e796f75747562652e636f6d2f76692f6263657a357063703535772f302e6a7067" alt="Broadcasting COLOR Channel 3 on an ESP" data-canonical-src="http://img.youtube.com/vi/bcez5pcp55w/0.jpg"/></a></p>
</article></div></div>
  </body>
</html>
