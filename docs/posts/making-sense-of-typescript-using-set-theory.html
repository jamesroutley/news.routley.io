<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.thoughtspile.tech/2023/01/23/typescript-sets/">Original</a>
    <h1>Making sense of TypeScript using set theory</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><p>I&#39;ve been working with TypeScript for a long long time. I think I&#39;m not too bad at it. However, to my despair, some low-level behaviors still confuse me:</p><ul><li>Why does <code>0 | 1 extends 0 ? true : false</code> evaluate to <code>false</code>?</li><li>I&#39;m very ashamed, but I sometimes confuse &#34;subtype&#34; and &#34;supertype&#34;. Which is which?</li><li>While we&#39;re at it, what are type &#34;narrowing&#34; and &#34;widening&#34;, and how do they relate to sub/supertypes?</li><li>If you want an object that satisfies both <code>{ name: string }</code> and <code>{ age: number }</code>, do you <code>&amp;</code> or <code>|</code>? Both make some sense, since I want a <em>union</em> of the functionality in both interfaces, but I also want the object to satisfy left &amp; (and) right interfaces.</li><li>How is <code>any</code> different from <code>unknown</code>? All I get is imprecise mnemonics like &#34;Avoid Any, Use Unknown&#34;. Why?</li><li>What, exactly, is <code>never</code>? &#34;A value that <em>never</em> happens&#34; is very dramatic, but not too precise.</li><li>Why <code>whatever | never === whatever</code> and <code>whatever &amp; never === never</code>?</li><li>Why on earth is <code>const x: {} = true;</code> valid TS code? <code>true</code> is clearly not an empty object.</li></ul><p>I was doing some research on <code>never</code>, and stumbled upon Zhenghao He&#39;s <a href="https://www.zhenghao.io/posts/ts-never" target="_blank" rel="noopener">Complete Guide To TypeScript’s Never Type</a> (check out his blog, it&#39;s super cool!). It mentions that a type is just a set of values, and — boom — it clicked. I went back to the basics, re-formulating everything I know about TS into set-theoretic terms. Follow me as I:</p><ul><li>Refresh my knowledge of set theory,</li><li>Map TS concepts to their set counterparts,</li><li>Start simple with booelan, null and undefined types,</li><li>Extend to strings and numbers, finding some types that TS can not express,</li><li>Jump into objects, proving my assumptions about them wrong,</li><li>Finally gain confidence writing <code>extends</code> caluses,</li><li>And put <code>unknown</code> and <code>any</code> where they belong.</li></ul><p>In the end, I solve most of my questions, grow much cozier with TS, and come up with this brilliant map of TS types:</p><p><img src="https://blog.thoughtspile.tech/images/ts-sets/everything.png" alt=""/></p><h2>Set theory</h2><p>First up, a refresher on set theory. Feel free to skip if you&#39;re a pro, but my algebra skills are a bit rusty, so I could use a reminder of how it works.</p><p>Sets are unordered collections of objects. In kindergarten terms: say we have two apples aka <em>objects</em> (let&#39;s call them ivan and bob, shall we?), and some bags aka <em>sets</em> where we can put the apples. We can make, in total, 4 apple sets:</p><ol><li>A bag with apple ivan, <code>{ ivan }</code> — sets are written as curly brackets with the set items inside.</li><li>Similarly, you can have a bag with apple bob, <code>{ bob }</code>.</li><li>A bag with both apples, <code>{ ivan, bob }</code>. Hold onto your hats, this is called a <em>universe</em> because at the moment there&#39;s nothing in our world except these two apples.</li><li>An empty bag aka empty set, <code>{}</code>. This one gets a special symbol, ∅</li></ol><p>Sets are often drawn as &#34;venn diagrams&#34;, with each set represented as a circle:</p><p><img src="https://blog.thoughtspile.tech/images/ts-sets/apples.png" alt=""/></p><p>Apart from listing all the items, we can also build sets by <em>condition.</em> I can say &#34;R is a set of red apples&#34; to mean <code>{ ivan }</code>, considernig ivan is red and bob is green. So far, so good.</p><p>Set A is a <em>subset</em> of set B if every element from A is also in B. In our apple world, <code>{ ivan }</code> is a subset of <code>{ ivan, bob }</code>, but <code>{ bob }</code> is not a subset of <code>{ ivan }</code>. Obviously, any set is a subset of itself, and <code>{}</code> is a subset of any other set S, because not a single item from <code>{}</code> is missing from S.</p><p>There are a few useful operators defined on sets:</p><ul><li>Union <em>C = A ∪ B</em> contains all the elements that are in A or in B. Note that <em>A ∪ ∅ = A</em></li><li>Intersection <em>C = A ∩ B</em> contains all the elements that are in A <em>and</em> B. Note that <em>A ∩ ∅ = ∅</em></li><li>Difference <em>C = A \ B</em> contains all the elements that are in A, but not in B. Note that <em>A \ ∅ = A</em></li></ul><p>This should be enough! Let&#39;s see how it all maps to types.</p><h2>What does it have to do with types</h2><p>So, the big reveal: you can think of &#34;types&#34; as sets of JavaScript values. Then:</p><ol><li>Our <em>universe</em> is all the values a JS program can produce.</li><li>A type (not even a typescript type, just a type in general) is some set of JS values.</li><li>Some types can be represented in TS, while other can not — for example, &#34;non-zero numbers&#34;.</li><li><code>A extends B</code> as seen in <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" target="_blank" rel="noopener">conditional types</a> and <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints" target="_blank" rel="noopener">generic constraints</a> can be read as &#34;A is subset of B&#34;.</li><li>Type union, <code>|</code>, and intersection, <code>&amp;</code>, operators are just the union and intersection of two sets.</li><li><code>Exclude&lt;A, B&gt;</code> is as close as TS gets to a difference operator, except it <em>only</em> works when both <code>A</code> and <code>B</code> are union types.</li><li><code>never</code> is an empty set. Proof: <code>A &amp; never = never</code> and <code>A | never = A</code> for any type <code>A</code>, and <code>Exclude&lt;0, 0&gt; = never</code>.</li></ol><p>This change of view already yields some useful insights:</p><ul><li>Subtype of type A is a <em>subset</em> of type A. Supertype is a superset. Easy.</li><li><em>Widening</em> makes a type-set wider by allowing some extra values. <em>Narrowing</em> removes certain values. Makes geometrical sense.</li></ul><p>I know this all sounds like a lot, so let&#39;s proceed by example, starting with a simple case of boolean values.</p><h2>Boolean types</h2><p>For now, pretend JS only has boolean values. There are exaclty <em>two</em> — <code>true</code> and <code>false</code>. Recalling the apples, we can make a total of 4 types:</p><ul><li>Literal types <code>true</code> and <code>false</code>, each made up of a single value;</li><li><code>boolean</code>, which is <em>any</em> boolean value;</li><li>The empty set, <code>never</code>.</li></ul><p>The diagram of the &#34;boolean types&#34; is basically the one that we had for apples, just the names swapped:</p><p><img src="https://blog.thoughtspile.tech/images/ts-sets/bool.png" alt=""/></p><p>Let&#39;s try moving between type world and set world:</p><ul><li><code>boolean</code> can be written as <code>true | false</code> (in fact, that&#39;s exactly how TS impements it).</li><li><code>true</code> is a subset (aka sub-type) of <code>boolean</code></li><li><code>never</code> is an empty set, so <code>never</code> is a sub-set/type of <code>true</code>, <code>false</code>, and <code>boolean</code></li><li><code>&amp;</code> is an <em>intersection,</em> so <code>false &amp; true = never</code>, and <code>boolean &amp; true = (true | false) &amp; true = true</code> (the universe, <code>boolean</code>, doesn&#39;t affect intersections), and <code>true &amp; never = never</code>, etc.</li><li><code>|</code> is a <em>union,</em> so <code>true | never = true</code>, and <code>boolean | true = boolean</code> (the universe, <code>boolean</code>, &#34;swallows&#34; other intersection items because they&#39;re all subsets of universe).</li><li><code>Exclude</code> correctly computes set difference: <code>Exclude&lt;boolean, true&gt; -&gt; false</code></li></ul><p>Now, a little self-assessment of the tricky <code>extends</code> cases:</p><pre><code><span>type</span> <span><span>A</span></span> <span>=</span> <span>boolean</span> <span>extends</span> <span><span>never</span></span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>;</span></code></pre><p>If you recall that &#34;extends&#34; can be read as &#34;is subset of&#34;, the answer should be clear — A0,B1,C1,C1. We&#39;re making progress!</p><p><code>null</code> and <code>undefined</code> are just like <code>boolean</code>, except they only contain <em>one</em> value each. <code>never extends null</code> still holds, <code>null &amp; boolean</code> is <code>never</code> since no JS value can simultaneously be of 2 different JS types, and so on. Let&#39;s add these to our &#34;trivial types map&#34;:</p><p><img src="https://blog.thoughtspile.tech/images/ts-sets/finites.png" alt=""/></p><h2>Strings and other primitives</h2><p>With the simple ones out of the way, let&#39;s move on to string types. At first, it seems that nothing&#39;s changed — <code>string</code> is a type for &#34;all JS strings&#34;, and every string has a corresponding literal type: <code>const str: &#39;hi&#39; = &#39;hi&#39;;</code> However, there&#39;s one key difference — there are <em>infinitely many</em> possible string values.</p><blockquote><p>It might be a lie, because you can only represent so many strings in finite computer memory, but a) it&#39;s enough strings to make enumerating them all unpractical, and b) type systems <em>can</em> operate on pure abstrations without worrying about dirty real-life limitations.</p></blockquote><p>Just like sets, string types can be constructed in a few different ways:</p><ul><li><code>|</code> union lets you constuct any <em>finite</em> string set — e.g. <code>type Country = &#39;de&#39; | &#39;us&#39;;</code>. This won&#39;t work for <em>infinite</em> sets — say, all strings with length &gt; 2 — since you can&#39;t write an infinite list of value.</li><li>Funky <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html" target="_blank" rel="noopener">template literal types</a> let you construct <em>some</em> infinite sets — e.g. <code>type V = `v${string}`;</code> is a set of all strings that start with <code>v</code>.</li></ul><p>We can go a bit further by making unions and intersections of literal and template types. Fun time: when combining a <em>union</em> with a <em>template,</em> TS is smart enough to just filter the literals againts the template, so that <code>&#39;a&#39; | &#39;b&#39; &amp; `a${string}` = &#39;a&#39;</code>. Yet, TS is not <em>smart enough</em> to merge templates, so you get really fancy ways of saying <code>never</code>, such as <code>`a${string}` &amp; `b${string}`</code> (obviously, a string can&#39;t start with &#34;a&#34; and &#34;b&#34; at the same time).</p><p>However, some string types are <em>not</em> representable in TS at all. Try &#34;every string except &#39;a&#39;&#34;. You could <code>Exclude&lt;string, &#39;a&#39;&gt;</code>, but since TS doesn&#39;t <em>actually</em> model <code>string</code> as <em>union of all possible string literals,</em> this in fact evaluates back to <code>string</code>. The template grammar can not express this negative condition either. Bad luck!</p><p>The types for numbers, symbols and bigints work the same way, except they don&#39;t even get a &#34;template&#34; type, and are limited to finite sets. It&#39;s a pity, as I could really use some number subtypes — <em>integer, number between 0 and 1,</em> or <em>positive number.</em> Anyways, all together:</p><p><img src="https://blog.thoughtspile.tech/images/ts-sets/primitives.png" alt=""/></p><p>Phew, we&#39;ve covered all primitive, <em>non-intersecting</em> JS / TS types. We&#39;ve gotten comfortable moving between sets and types, and discovered that some types can&#39;t be defined in TS. Here comes the tricky part.</p><h2>Interfaces &amp; object types</h2><p>If you think <code>const x: {} = 9;</code> makes no sense, this section is for you. As it appears, our mental model of what TS object types / records / interfaces was built on the wrong assumptions.</p><p>First, you&#39;d probably expect types like <code>type Sum9 = { sum: 9 }</code> to act like &#34;literal types&#34; for objects — matching a single object value <code>{ sum: 9 }</code>, adjusted for referential equality. This is absolutely <em>not</em> how it works. Instead, <code>Sum9</code> is a &#34;<em>thing</em> on which you can access propery <code>sum</code> to get <code>9</code>&#34; — more like a condition / constraint. This lets us call <code>(data: Sum9) =&gt; number</code> with an object <code>obj = { sum: 9, date: &#39;2022-09-13&#39; }</code> without TS complaining about unknown <code>date</code> property. See, handy!</p><p>Then, <code>{}</code> type is not an &#34;empty object&#34; type corresponding to a <code>{}</code> JS literal, but a &#34;thing where I can access properties, but I don&#39;t care about any particular properties&#34;. Aha, now we can see what&#39;s going on in our initial mind-bender: if <code>x = 9</code>, you can safely <code>x[&#39;whatever&#39;]</code>, so it satisfies the unconstrained <code>{}</code> interface. In fact, we can even make bolder claims like <code>const x: { toString(): string } = 9;</code>, since we can <code>x.toString()</code> and actuallty get a string. More yet, <code>keyof number</code> gives us <code>&#34;toString&#34; | &#34;toFixed&#34; | &#34;toExponential&#34; | &#34;toPrecision&#34; | &#34;valueOf&#34; | &#34;toLocaleString&#34;</code>, meaning that TS secretly sees our primitive type as an object, which it is (thanks to <a href="https://javascript.plainenglish.io/javascript-boxing-wrappers-5b5ff9e5f6ab" target="_blank" rel="noopener">autoboxing</a>). <code>null</code> and <code>undefined</code> do not satisfy <code>{}</code>, because they throw if you try to read a property. Not super intuitive, but makes sense now.</p><p>Coming back to my little &#34;<code>|</code> or <code>&amp;</code>&#34; problem, <code>&amp;</code> and <code>|</code> operate on &#34;value sets&#34;, not on &#34;object shapes&#34;, so you need <code>{ name: string } &amp; { age: number }</code> to get objects with <em>both</em> <code>name</code> and (extra hint: and = <code>&amp;</code>) <code>age</code>.</p><p>Oh, and what about that odd <code>object</code> type? Since every property on an interface just adds a constraint to the &#34;thing&#34; we&#39;re typing, there&#39;s no way to declare an interface that filters out primitive values. It&#39;s why TS has a built-in <code>object</code> type that means specifically &#34;JS object, not a primitive&#34;. Yes, you can intersect with <code>object</code> to get only <em>non-primitive</em> values satisfying an interface: <code>const x: object &amp; { toString(): string } = 9</code> fails.</p><p>Let&#39;s add all of these to our type map:</p><p><img src="https://blog.thoughtspile.tech/images/ts-sets/everything.png" alt=""/></p><h2>extends</h2><p><code>extends</code> keyword in TS can be confusing. It comes from the object-oriented world where you <em>extend</em> a class in the sense of <em>adding functionality</em> to it, <em>but,</em> since TS uses <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">structural typing</a>, <code>extends</code> as used in <code>type Extends&lt;A, B&gt; = A extends B ? true : false</code> is <em>not</em> the same <code>extends</code> from <code>class X extends Y {}</code>.</p><p>Instead, <code>A extends B</code> can be read as <em>A is a sub-type of B</em> or, in set terms, <em>A is a subset of B.</em> If B is a union, every member of A must also be in B. If B is a &#34;constrained&#34; interface, A must not violate any of B&#39;s constraints. Good news: a usual OOP <code>class A extends B {}</code> fits <code>A extends B ? 1 : 0</code>. So does <code>&#39;a&#39; extends string</code>, meaning that (excuse the pun) TS <code>extends</code> extends <code>extends</code>.</p><p>This &#34;subset&#34; view is the best way to never mix up the order of <code>extends</code> operands:</p><ul><li><code>0 | 1 extends 0</code> is false, since a 2-element set <code>{0, 1}</code> is not a subset of the 1-element <code>{0}</code> (even though <code>{0,1}</code> does extend <code>{1}</code> in a geometrical sense).</li><li><code>never extends T</code> is always true, because <code>never</code>, the empty set, is a subset of any set.</li><li><code>T extends never</code> is only true if T is <code>never</code>, because an empty set has no subsets except itself.</li><li><code>T extends string</code> allows T to be a string, a literal, or a literal union, or a template, because all of these are subsets of <code>string</code>.</li><li><code>T extends string ? string extends T</code> makes sure that T is <em>exactly</em> <code>string</code>, because that&#39;s the only way it can be both a subset <em>and</em> a superset of string.</li></ul><h2>unknown and any</h2><p>Typescript has two types that can represent an arbitrary JS value — <code>unknown</code> and <code>any</code>. The normal one is <code>unknown</code> — the universe of JS values:</p><pre><code></code></pre><p>On a puzzling side, though:</p><ol><li><code>unknown</code> is <em>not</em> a union of all other base types, so you can&#39;t <code>Exclude&lt;unknown, string&gt;</code></li><li><code>unknown extends string | number | boolean | object | bigint | symbol | null | undefined</code> is false, meaning that some TS types are not listed. I suspect <code>enum</code>s.</li></ol><p>All in all, it&#39;s safe to think of <code>unknown</code> as &#34;the set of all possible JS values&#34;.</p><p><code>any</code> is the weird one:</p><ul><li><code>any extends string ? 1 : 0</code> evaluates to <code>0 | 1</code> which is basically a &#34;dunno&#34;.</li><li>Even <code>any extends never ? 1 : 0</code> evaluates to <code>0 | 1</code>, meaning that <code>any</code> <em>might</em> be empty.</li></ul><p>We should conclude that <code>any</code> is &#34;some set, but we&#39;re not sure which one&#34; — like a type <code>NaN</code>. However, upon further inspection, <code>string extends any</code>, <code>unknown extends any</code> and even <code>any extends any</code> are all true, none of which holds for &#34;some set&#34;. So, <code>any</code> is a <em>paradox</em> — every set is a subset of <code>any</code>, but <code>any</code> <em>might</em> be empty. The only good news I have is that <code>any extends unknown</code>, so <code>unknown</code> is still the universe, and <code>any</code> does not allow &#34;alien&#34; values.</p><p>So, to finish mapping our types, we wrap our entire diagram into <code>unknown</code> bubble:</p><p><img src="https://blog.thoughtspile.tech/images/ts-sets/all.png" alt=""/></p><hr/><p>Today, we&#39;ve learnt to that TS <em>types</em> are basically <em>sets</em> of JS values. Here&#39;s a little dictionary to go from type-world to set-world, and back:</p><ul><li>Our universe = all JS values = the type <code>unknown</code></li><li><code>never</code> is an empty set.</li><li>Subtype = narrowed type = subset, supertype = widened type = superset.</li><li><code>A extends B</code> can be read as &#34;A is subset of B&#34;.</li><li>Union and intersection types are, really, just set union and intersection.</li><li><code>Exclude</code> is an <em>approximation</em> of set difference that only works on union types.</li></ul><p>Going back my our initial questions:</p><ul><li><code>0 | 1 extends 0</code> is false because <em>{0,1}</em> is <em>not</em> a subset of <em>{0}</em></li><li><code>&amp;</code> and <code>|</code> work on sets, not on object shapes. <code>A &amp; B</code> is a set of things that satisfy both <code>A</code> and <code>B</code>.</li><li><code>unknown</code> is the set of all JS values. <code>any</code> is a paradoxical set that includes everything, but <em>might</em> also be empty.</li><li>Intersecting with <code>never</code> gives you <code>never</code> because it&#39;s an empty set. <code>never</code> has no effect in a union.</li><li><code>const x: {} = true;</code> works because TS interfaces work by <em>constraining</em> the property values, and we haven&#39;t constrained anything here, so <code>true</code> fits.</li></ul><p>We still have a lot of TS mysteries to solve, so stay tuned!</p></div></div>
  </body>
</html>
