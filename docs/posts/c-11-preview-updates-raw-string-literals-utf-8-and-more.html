<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/">Original</a>
    <h1>C# 11 Preview Updates – Raw string literals, UTF-8 and more</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            April 18th, 2022</p><!-- .entry-meta -->
        
<p>Features for C# 11 are coming along nicely! You can check these features out by downloading <a href="https://visualstudio.microsoft.com/vs/preview">Visual Studio 17.2 Preview 3</a> or <a href="https://dotnet.microsoft.com/download/dotnet/7.0">.NET 7 Preview 3</a> for other editors. You can find more about C# 11 features that appeared earlier in <a href="https://docs.microsoft.com/dotnet/csharp/whats-new/csharp-11">What’s new in C# 11</a> and <a href="https://devblogs.microsoft.com/dotnet/early-peek-at-csharp-11-features">Early peek at C# 11 features</a> and you can follow the progress of C# 11 on the <a href="https://github.com/dotnet/roslyn/blob/main/docs/Language%20Feature%20Status.md">Feature Status page</a>. You can find out about other <a href="https://devblogs.microsoft.com/dotnet/announcing-dotnet-7-preview-3">.NET 7 Preview 3 features in this .NET Blog post</a> and more about <a href="https://docs.microsoft.com/visualstudio/releases/2022/release-notes-preview">Visual Studio 17.2 in the release notes</a>.</p>
<p>We evolve C# to improve your development productivity, the resiliency of your applications in production, performance and support for new features. The C# team works on both the performance of your application in production, and how the compiler performance affects your development. Features in this post include:</p>
<ul>
<li><a href="#raw-string-literals">Raw string literals</a> to make you more productive and improve readability by avoiding escaping content inside strings.</li>
<li><a href="#utf-8-string-literals">UTF-8 String Literals</a> to make it easier and less error prone to create UTF-8 strings for better productivity, resiliency and performance.</li>
<li><a href="#checked-user-defined-operators">Checked user-defined operators</a> to allow user defined operators to respect the current arithmetic overflow check status for better resiliency.</li>
<li><a href="#auto-default-structs">Auto-default structs</a> to initialize struct values for better productivity.</li>
<li><a href="#pattern-matching-with-spans">Pattern matching with spans</a> adds to the set of patterns for better productivity.</li>
<li><a href="#use-a-cached-delegate-for-method-group-conversion">Use a cached delegate for method group conversion</a> for better performance.</li>
</ul>
<p>This post also explains why we <a href="#remove-parameter-null-checking-from-c-11">removed parameter null-checking from C# 11</a> and are adding a <a href="#warning-wave-warnings-on-lowercase-type-names">warning for lowercase type names</a>.</p>
<h2 id="raw-string-literals"><a href="https://github.com/dotnet/csharplang/issues/4304">Raw string literals</a></h2>
<p>If you work with strings literal that contain quotes or embedded language strings like JSON, XML, HTML, SQL, Regex and others, <em>raw literal strings</em> may be your favorite feature of C# 11. Previously if you copied a literal string with quotes into a C# literal, the string ended at the first double quote with compiler errors until you escaped each one. Similarly, if you copied text with curly braces into an interpolated string literal, each curly bracket was interpreted as the beginning of a nested code expression unless you escape it, generally by doubling the curly bracket.</p>
<p>Raw string literals have no escaping. For example, a backslash is output as a backslash, and <code>\t</code> is output as the backslash and a <code>t</code>, not as the tab character.</p>
<p>Raw string literals start and end with at least three double quotes (<code>&#34;&#34;&#34;...&#34;&#34;&#34;</code>). Within these double quotes, single <code>&#34;</code> are considered content and included in the string. Any number of double quotes less than the number that opened the raw string literal are treated as content. So, in the common case of three double quotes opening the raw string literals, two double quotes appearing together would just be content. If you need to output a sequence of three or more double quotes, just open and close the raw string literal with at least one more quote than that sequence.</p>
<p>Raw string literals can be interpolated by preceding them with a <code>$</code>. The number of <code>$</code> that prefixes the string is the number of curly brackets that are required to indicate a nested code expression. This means that a <code>$</code> behaves like the existing string interpolation – a single set of curly brackets indicate nested code. If a raw string literal is prefixed with <code>$$</code>, a single curly bracket is treated as content and it takes two curly brackets to indicate nested code. Just like with quotes, you can add more <code>$</code> to allow more curly brackets to be treated as content. For example:</p>
<p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2022/04/raw-string-literal.png" alt="JSON example of raw string literal"/></p>
<p>Raw string literals also have new behavior around automatically determining indentation of the content based on leading whitespace. To learn more about this and to see more examples on this feature, check out the <a href="https://docs.microsoft.com/dotnet/csharp/whats-new/csharp-11#raw-string-literals">docs article Raw String Literals</a>.</p>
<p>This feature will make it much easier to work with literals that contain certain characters. You can now copy code into or from a literal string without being hindered by adding or removing escape sequences.</p>
<p>Special thanks to <a href="https://github.com/jnm2">jnm2 (Joseph Musser) </a><span>for his work on the design and implementation of raw string literals.</span></p>
<h2 id="utf-8-string-literals"><a href="https://github.com/dotnet/csharplang/blob/main/proposals/utf8-string-literals.md">UTF-8 String Literals</a></h2>
<p>UTF-8 is used in many scenarios, particularly in web scenarios. Prior to C# 11, programmers had to either translate UTF-8 into hexadecimal – which led to verbose, unreadable, error prone code – or encode string literals at runtime.</p>
<p>C# 11 allows converting string literals containing only UTF-8 characters to their byte representation. This is done at compile-time, so the bytes are ready to use without additional runtime cost. So you can write code like:</p>
<pre><code>byte[] array = &#34;hello&#34;;             // new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f }
Span&lt;byte&gt; span = &#34;dog&#34;;            // new byte[] { 0x64, 0x6f, 0x67 }
ReadOnlySpan&lt;byte&gt; span = &#34;cat&#34;;    // new byte[] { 0x63, 0x61, 0x74 }</code></pre>
<p>There are ongoing discussions about details such as whether a type suffix is required and what natural type that would imply. If you expect to use UTF-8 string literals, we would really like your feedback and you can see the <a href="https://github.com/dotnet/csharplang/blob/main/proposals/utf8-string-literals.md">UTF-8 String Literal proposal</a> and the links contained in it for more information.</p>
<p>This feature brings a welcome simplification to everyone currently building byte arrays to represent UTF-8. If you are doing this, you will probably want to convert your code to use it after C# 11 releases. If you are not using UTF-8 string literals you can ignore this feature. For ASP.NET users, your response is encoding to UTF-8 from strings automatically, so you can ignore this feature.</p>
<h2 id="checked-user-defined-operators"><a href="https://github.com/dotnet/csharplang/blob/main/proposals/checked-user-defined-operators.md">Checked user-defined operators</a></h2>
<p>One of the major motivations for the <a href="https://docs.microsoft.com/dotnet/csharp/whats-new/tutorials/static-abstract-interface-methods">static abstract members in interfaces</a> feature of C# 11 is the ability to support generic math. .NET developers can write algorithms that rely on interfaces that include static abstract members as the generic constraint. One such interface is <code>INumber&lt;TSelf&gt;</code> which provides access to APIs such as <code>Max</code>, <code>Min</code>, <code>Parse</code>, and even operators such as <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, as well as user defined conversions.</p>
<p>User-defined operators respect the arithmetic overflow and underflow checking context of the calling code, controlled via the <code>&lt;CheckForOverflowUnderflow&gt;</code> project property or the <code>checked</code>/<code>unchecked</code> regions and operators. Check out the language reference for about <a href="https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/checked-and-unchecked">checked and unchecked behavior for arithmetic operators</a>. Prior to C# 11, a user-defined operator was unaware of the context in which it was used.</p>
<p>C# 11 adds the ability to declare certain operators as checked, identified with the <code>checked</code> modifier. Operators that do not have this modifier will be unchecked when paired with a checked operator. The compiler will select the right operator to use based on the context of the calling code. The operators that can support checked versions are the <code>++</code>, <code>--</code> and <code>-</code> unary operators and the <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> binary operators.</p>
<p>The distinction between checked and unchecked is the context in which they are used. There is no requirement that checked operators <em>throw</em> if the bounds of the type are exceeded or that unchecked operators <em>not throw</em>, but this is the behavior users expect. For example, for integer types MAX_VALUE+1 is MIN_VALUE in the unchecked context and throws an exception in the checked context. Some types, such as floating point numbers, do not overflow and therefore do not need separate checked and unchecked operators.</p>
<p>This feature is important to developers creating user-defined operators that operate on types where arithmetic overflow is a valid concept. It will allow new user-defined operators to respect the context in which the operator is used. We anticipate that only a small number of developers will use this feature directly, but the impact of their implementations will make the entire ecosystem more reliable and predictable.</p>
<h2 id="auto-default-structs"><a href="https://github.com/dotnet/csharplang/issues/5737">Auto-default structs</a></h2>
<p><em>Note: This feature is planned for 17.3, not 17.2. It was mistakenly included in this post. i am not removing it to avoid confusion about our intention regarding this feature. Look for it in a future preview!</em></p>
<p>In C# 10 and earlier, you needed to initialize all fields of a struct by initializing fields and auto-properties or setting them in the constructors. This can be awkward, particularly with the expected introduction of the <code>field</code> keyword and semi-auto properties in a later C# 11 preview. If you did not set these values, you received a compiler error. If we have sufficient information to provide the error, perhaps we should just set these values to <code>default</code> for you!</p>
<p>Starting with this preview, the compiler does exactly that. It initializes any fields and auto-properties that are not set based on definite assignment rules, and assigns the default value to them. If you do not want this behavior, there is a warning you can turn on.</p>
<p>This feature simplifies initialization for anyone using structs that include explicit constructors. This is likely to feel like the way structs with initializers always should have worked, and so you may take advantage of this feature without even thinking about it. If you are explicitly initializing fields to their default value in response to the previous compiler errors, you can remove that code.</p>
<h2 id="pattern-matching-with-spans"><a href="https://github.com/dotnet/csharplang/issues/1881">Pattern matching with spans</a></h2>
<p>Starting with this preview, you can pattern match a <code>Span&lt;char&gt;</code> or a <code>ReadonlySpan&lt;char&gt;</code> with a string literal. This code now works:</p>
<pre><code>static bool IsABC(Span&lt;char&gt; s)
{
    return s switch { 
        &#34;ABC&#34; =&gt; true, 
        _ =&gt; false };
}</code></pre>
<p>The input type must be statically known to be a <code>Span&lt;char&gt;</code> or a <code>ReadonlySpan&lt;char&gt;</code>. Also, the compiler reports an error if you match a <code>Span&lt;char&gt;</code> or a <code>ReadonlySpan&lt;char&gt;</code> to a <code>null</code> constant.</p>
<p>This feature will allow <code>Span&lt;char&gt;</code> or <code>ReadonlySpan&lt;char&gt;</code> to participate as patterns in switch statements and switch expressions for matching string literals. If you are not using <code>Span&lt;char&gt;</code> and <code>ReadonlySpan&lt;char&gt;</code> you can ignore this feature.</p>
<p>Special thanks to <a href="https://github.com/YairHalberstadt">YairHalberstadt</a> for implementing this feature.</p>
<h2 id="use-a-cached-delegate-for-method-group-conversion"><a href="https://github.com/dotnet/roslyn/issues/5835">Use a cached delegate for method group conversion</a></h2>
<p>This feature will improve runtime performance by caching static method groups, rather than creating fresh delegate instances. This is to improve your application’s performance, particularly for ASP.NET. You will get the benefit of this feature with no effort on your part.</p>
<p>Special thanks to <a href="https://github.com/pawchen">pawchen</a> for implementing this feature</p>
<h2 id="remove-parameter-null-checking-from-c-11"><a href="https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-13.md">Remove parameter null-checking from C# 11</a></h2>
<p>We previewed <a href="https://devblogs.microsoft.com/dotnet/early-peek-at-csharp-11-features/#c-11-preview-parameter-null-checking">parameter null-checking</a> as early as possible because we anticipated feedback. This feature allows <code>!!</code> on the end of a parameter name to provide parameter null checking before the method begins execution. We included this feature early in C# 11 to maximize feedback, which we gathered from GitHub comments, MVPs, social media, a conference audience, individual conversations with users, and the C# design team’s ongoing reflection. We received a wide range of feedback on this feature, and we appreciate all of it.</p>
<p>The feedback and the wide range of insight we gained from this feedback led us to reconsider this as a C# 11 feature. We do not have sufficient confidence that this is the right feature design for C# and are removing it from C# 11. We may return to this area again at a later date.</p>
<p>While there are several valid ways you can do null check on a single line, if you are using .NET 6 we recommend using <code>ArgumentNullException.ThrowIfNull</code> method:</p>
<pre><code>public static void M(string myString)
{
    ArgumentNullException.ThrowIfNull(myString);
    // method 
}</code></pre>
<p>One of the benefits of using the <code>ThrowIfNull</code> method is it uses CallerArgumentExpression to include the parameter name in the exception message automatically:</p>
<pre><code>System.ArgumentNullException: &#39;Value cannot be null. (Parameter &#39;myString&#39;)&#39;</code></pre>
<h2 id="warning-wave-warnings-on-lowercase-type-names">Warning wave: Warnings on lowercase type names</h2>
<p>C# 11 introduces a Warning Wave 7 that includes a warning for any type that is declared with all lowercase ASCII characters. This has been a common stylistic rule in the C# ecosystem for years. We are making it a warning because C# needs to occasionally introduce new keywords in order to evolve. These keywords will be lowercase and may conflict with your type’s name, if it is lowercase. We introduced this warning so you can avoid a possible future breaking change.</p>
<p>You can find out more about this change at <a href="https://blog.paranoidcoding.com/2022/04/11/lowercase-type-names.html">Warning on lowercase type names in C# 11</a>. <a href="https://docs.microsoft.com/dotnet/csharp/language-reference/compiler-options/errors-warnings#warninglevel">Warning waves</a> allow new warnings in C# in a manner that allows you to delay adoption if the warning causes issues you cannot currently resolve.</p>
<p>This warning is expected to affect very few people. But if you encounter it, we recommend updating your type name, or prefixing usages of it with <code>@</code>, such as <code>@lower</code>.</p>
<h2 id="closing">Closing</h2>
<p>Please download <a href="https://visualstudio.microsoft.com/vs/preview">Visual Studio 17.2 Preview 3</a> or <a href="https://dotnet.microsoft.com/download/dotnet/7.0">.NET 7 Preview 3</a>, try out the new features, and tell us what you think in the Discussions section of the <a href="https://github.com/dotnet/csharplang">CSharpLang repo</a>.</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
