<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://turbo.build/blog/turbopack-benchmarks">Original</a>
    <h1>Turbopack Performance Benchmarks</h1>
    
    <div id="readability-page-1" class="page"><div><article><main>
<p>Monday, October 31st, 2022</p>

<p>Summary</p>
<ul>
<li>We are thankful for the work of the entire OSS ecosystem and the incredible interest and reception from the <a href="https://vercel.com/blog/turbopack" target="_blank" rel="noreferrer">Turbopack release</a>. We look forward to continuing our collaboration with and integration into the broader Web ecosystem of tooling and frameworks.</li>
<li>In this article, you’ll find our methodology and documentation supporting the benchmarks that show <strong>Turbopack is up to <a href="https://turbo.build/blog/turbopack-benchmarks#bench">10x and 700x faster</a> than existing approaches.</strong></li>
<li><strong>Turbopack</strong> and <a href="https://github.com/vercel/next.js/releases/tag/v13.0.1" target="_blank" rel="noreferrer"><strong>Next.js 13.0.1</strong></a> are out addressing a regression that snuck in prior to public release and after the initial benchmarks were taken. We also fixed an incorrect rounding bug on our website (<code dir="ltr">0.01s</code> → <code dir="ltr">15ms</code>). We appreciate <a href="https://twitter.com/youyuxi" target="_blank" rel="noreferrer">Evan You</a>&#39;s work that helped us identify and correct this.</li>
<li>We’re excited to continue to evolve the incremental build architecture of Turbopack. We believe that there are still significant performance wins on the table.</li>
</ul>
<hr/>
<p>At <a href="https://nextjs.org" target="_blank" rel="noreferrer">Next.js Conf</a>, <a href="https://www.youtube.com/watch?v=NiknNI_0J48" target="_blank" rel="noreferrer">we announced</a> our latest open-source project: Turbopack, an incremental bundler and build system optimized for JavaScript and TypeScript, written in Rust.</p>
<p>The project began as an exploration to improve Webpack’s performance and create ways for it to more easily integrate with tooling moving forward. In doing so, the team realized that a greater effort was necessary. While we saw opportunities for better performance, the premise of a new architecture that could scale to the largest projects in the world was inspiring.</p>
<p>In this post, we’ll explore why Turbopack is so fast, how its incremental engine works, and benchmark it against existing approaches.</p>
<h2>Why is Turbopack <em>blazing</em> fast?<span id="why-is-turbopack-blazing-fast"></span><a href="#why-is-turbopack-blazing-fast"></a></h2>
<p>Turbopack’s speed comes from its incremental computation engine. Similar to trends we&#39;ve seen in frontend state libraries, computational work is split into reactive functions that enable Turbopack to apply updates to an existing compilation without going through a full graph recomputation and bundling lifecycle.</p>
<p>This does not work like traditional caching where you look up a result from a cache before an operation and then decide whether or not to use it. That would be too slow.</p>
<p>Instead, Turbopack skips work altogether for cached results and only recomputes affected parts of its internal dependency graph of functions. This makes updates independent of the size of the whole compilation, and eliminates the usual overhead of traditional caching.</p>
<h2>Benchmarking Turbopack, Webpack, and Vite<span id="benchmarking-turbopack-webpack-and-vite"></span><a href="#benchmarking-turbopack-webpack-and-vite"></a></h2>
<p>We created a test generator that makes an application with a variable amount of modules to benchmark cold startup and file updating tasks. This generated app includes entries for these tools:</p>
<ul>
<li>Next.js 11</li>
<li>Next.js 12</li>
<li>Next.js 13 with Turbopack</li>
<li>Vite</li>
</ul>
<p>As the current state of the art, we&#39;re including <a href="https://vitejs.dev/" target="_blank" rel="noreferrer">Vite</a> along with Webpack-based <a href="https://nextjs.org" target="_blank" rel="noreferrer">Next.js</a> solutions. All of these toolchains point to the same generated component tree, assembling a <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle" target="_blank" rel="noreferrer">Sierpiński triangle</a> in the browser, where every triangle is a separate module.</p>
<figure><div><p><img srcset="/_next/image?url=%2Fimages%2Fblog%2Fturbopack-benchmarks%2Ftriangle-light.png&amp;w=1200&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fturbopack-benchmarks%2Ftriangle-light.png&amp;w=3840&amp;q=75 2x" src="https://turbo.build/_next/image?url=%2Fimages%2Fblog%2Fturbopack-benchmarks%2Ftriangle-light.png&amp;w=3840&amp;q=75" width="1200" height="600" decoding="async" data-nimg="future" loading="lazy"/></p><p><img srcset="/_next/image?url=%2Fimages%2Fblog%2Fturbopack-benchmarks%2Ftriangle-dark.png&amp;w=1200&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fturbopack-benchmarks%2Ftriangle-dark.png&amp;w=3840&amp;q=75 2x" src="https://turbo.build/_next/image?url=%2Fimages%2Fblog%2Fturbopack-benchmarks%2Ftriangle-dark.png&amp;w=3840&amp;q=75" width="1200" height="600" decoding="async" data-nimg="future" loading="lazy"/></p></div><figcaption>This image is a screenshot of the test application we run our benchmarks on. It depicts a Sierpiński triangle where each single triangle is its own component, separated in its own file. In this example, there are 3,000 triangles being rendered to the screen.</figcaption></figure>
<h3>Cold startup time<span id="cold-startup-time"></span><a href="#cold-startup-time"></a></h3>
<p>This test measures how fast a local development server starts up on an application of various sizes. We measure this as the time from startup (without cache) until the app is rendered in the browser. We do not wait for the app to be interactive or hydrated in the browser for this dataset.</p>
<div><div><div><div><div><div><div><p><img alt="Turbopack" srcset="/images/docs/pack/turbo-benchmark-icon-light.svg 1x, /images/docs/pack/turbo-benchmark-icon-light.svg 2x" src="https://turbo.build/images/docs/pack/turbo-benchmark-icon-light.svg" width="32" height="32" decoding="async" data-nimg="future" loading="lazy"/><img alt="Turbopack" srcset="/images/docs/pack/turbo-benchmark-icon-dark.svg 1x, /images/docs/pack/turbo-benchmark-icon-dark.svg 2x" src="https://turbo.build/images/docs/pack/turbo-benchmark-icon-dark.svg" width="32" height="32" decoding="async" data-nimg="future" loading="lazy"/><span></span></p><p>1.1<!-- -->s</p></div></div></div></div></div></div></div>
<figure><div><p><img srcset="/images/blog/turbopack-benchmarks/bench_startup_all_light.svg 1x, /images/blog/turbopack-benchmarks/bench_startup_all_light.svg 2x" src="https://turbo.build/images/blog/turbopack-benchmarks/bench_startup_all_light.svg" width="1960" height="720" decoding="async" data-nimg="future" loading="lazy"/></p><p><img srcset="/images/blog/turbopack-benchmarks/bench_startup_all_dark.svg 1x, /images/blog/turbopack-benchmarks/bench_startup_all_dark.svg 2x" src="https://turbo.build/images/blog/turbopack-benchmarks/bench_startup_all_dark.svg" width="1960" height="720" decoding="async" data-nimg="future" loading="lazy"/></p></div><figcaption>Startup time by module count. Benchmark data generated from 14” MacBook Pro 2021, M1 Max, 64GB RAM, macOS 12.6 (21G115).</figcaption></figure>
<h4>Data<span id="data"></span><a href="#data"></a></h4>
<p>To run this benchmark yourself, clone <a href="https://github.com/vercel/turbo" target="_blank" rel="noreferrer"><code dir="ltr">vercel/turbo</code></a> and then use this command from the root:</p>
<div data-rehype-pretty-code-fragment=""><pre><code dir="ltr" data-language="sh" data-theme="default"><span><span>TURBOPACK_BENCH_COUNTS=1000,5000,10000,30000 TURBOPACK_BENCH_BUNDLERS=all cargo bench -p next-dev </span><span>&#34;startup/(Turbopack SSR|Next.js 12 SSR|Next.js 11 SSR|Vite CSR).&#34;</span></span></code></pre></div>
<p>Here are the numbers we were able to produce on a 14” MacBook Pro 2021, M1 Max, 64GB RAM, macOS 12.6 (21G115):</p>
<div data-rehype-pretty-code-fragment=""><pre><code dir="ltr" data-language="sh" data-theme="default"><span><span>bench_startup/Next.js 11 SSR/1000 modules              7.7±0.06s</span></span>
<span><span>bench_startup/Next.js 11 SSR/5000 modules             24.8±0.11s</span></span>
<span><span>bench_startup/Next.js 11 SSR/10000 modules            49.4±0.28s</span></span>
<span><span>bench_startup/Next.js 11 SSR/30000 modules           176.2±1.42s</span></span>
<span><span>bench_startup/Next.js 12 SSR/1000 modules              3.4±0.01s</span></span>
<span><span>bench_startup/Next.js 12 SSR/5000 modules             10.7±0.02s</span></span>
<span><span>bench_startup/Next.js 12 SSR/10000 modules            20.1±0.07s</span></span>
<span><span>bench_startup/Next.js 12 SSR/30000 modules            76.6±0.66s</span></span>
<span><span>bench_startup/Turbopack SSR/1000 modules          1125.3±44.54ms</span></span>
<span><span>bench_startup/Turbopack SSR/5000 modules               3.6±0.02s</span></span>
<span><span>bench_startup/Turbopack SSR/10000 modules              7.5±0.44s</span></span>
<span><span>bench_startup/Turbopack SSR/30000 modules             22.3±1.29s</span></span>
<span><span>bench_startup/Vite CSR/1000 modules                    4.8±0.02s</span></span>
<span><span>bench_startup/Vite CSR/5000 modules                   19.2±0.15s</span></span>
<span><span>bench_startup/Vite CSR/10000 modules                  37.2±0.29s</span></span>
<span><span>bench_startup/Vite CSR/30000 modules                 109.5±1.14s</span></span></code></pre></div>
<h3>File updates (HMR)<span id="file-updates-hmr"></span><a href="#file-updates-hmr"></a></h3>
<p>We also measure how quickly the development server works from when an update is applied to a source file to when we receive a custom browser event that the modified code was executed.</p>
<p>Note that executing modified code does not mean that the changes are visible to the user yet. When a React component changes, it still needs to be re-rendered by the browser. With this methodology, we are focusing <em>only</em> on the time the compiler takes to do its work and the time it takes for the browser to evaluate an updated module.</p>
<p>For Hot Module Reloading (HMR) benchmarks, we first start the dev server on a fresh installation with the test application. We then run five changes to warm up the tooling. This step is important as it prevents discrepancies that can arise with cold processes.</p>
<p>Once our tooling is warmed up, we measure the sixth file update. After repeating this 10 times, we use the average as our final number.</p>
<div><div><div><div><div><div><div><p><img alt="Turbopack" srcset="/images/docs/pack/turbo-benchmark-icon-light.svg 1x, /images/docs/pack/turbo-benchmark-icon-light.svg 2x" src="https://turbo.build/images/docs/pack/turbo-benchmark-icon-light.svg" width="32" height="32" decoding="async" data-nimg="future" loading="lazy"/><img alt="Turbopack" srcset="/images/docs/pack/turbo-benchmark-icon-dark.svg 1x, /images/docs/pack/turbo-benchmark-icon-dark.svg 2x" src="https://turbo.build/images/docs/pack/turbo-benchmark-icon-dark.svg" width="32" height="32" decoding="async" data-nimg="future" loading="lazy"/><span></span></p><p>15<!-- -->ms</p></div></div></div></div></div></div></div>
<figure><div><p><img srcset="/images/blog/turbopack-benchmarks/bench_hmr_to_eval_all_light.svg 1x, /images/blog/turbopack-benchmarks/bench_hmr_to_eval_all_light.svg 2x" src="https://turbo.build/images/blog/turbopack-benchmarks/bench_hmr_to_eval_all_light.svg" width="1960" height="720" decoding="async" data-nimg="future" loading="lazy"/></p><p><img srcset="/images/blog/turbopack-benchmarks/bench_hmr_to_eval_all_dark.svg 1x, /images/blog/turbopack-benchmarks/bench_hmr_to_eval_all_dark.svg 2x" src="https://turbo.build/images/blog/turbopack-benchmarks/bench_hmr_to_eval_all_dark.svg" width="1960" height="720" decoding="async" data-nimg="future" loading="lazy"/></p></div><figcaption>Turbopack vs. Next.js (Webpack) vs. Vite HMR by module count. Benchmark data generated from 14” MacBook Pro 2021, M1 Max, 64GB RAM, macOS 12.6 (21G115).</figcaption></figure>

<figure><div><p><img srcset="/images/blog/turbopack-benchmarks/bench_hmr_to_eval_vite_tp_light.svg 1x, /images/blog/turbopack-benchmarks/bench_hmr_to_eval_vite_tp_light.svg 2x" src="https://turbo.build/images/blog/turbopack-benchmarks/bench_hmr_to_eval_vite_tp_light.svg" width="1960" height="720" decoding="async" data-nimg="future" loading="lazy"/></p><p><img srcset="/images/blog/turbopack-benchmarks/bench_hmr_to_eval_vite_tp_dark.svg 1x, /images/blog/turbopack-benchmarks/bench_hmr_to_eval_vite_tp_dark.svg 2x" src="https://turbo.build/images/blog/turbopack-benchmarks/bench_hmr_to_eval_vite_tp_dark.svg" width="1960" height="720" decoding="async" data-nimg="future" loading="lazy"/></p></div><figcaption>Turbopack vs. Vite HMR by module count. Benchmark data generated from 14” MacBook Pro 2021, M1 Max, 64GB RAM, macOS 12.6 (21G115).</figcaption></figure>
<p>From our benchmarks, we find the following:</p>
<ul>
<li>Turbopack HMR is <strong>10x faster than Vite once the application scales above 30k modules</strong>. These marks continue to improve with more modules, showing 20x faster above 50k modules.</li>
<li>Turbopack HMR is <strong>700x faster than Webpack-based Next.js 11</strong> for large applications with over 50k modules.</li>
</ul>
<p>The takeaway: Turbopack performance is a function of <strong>the size of an update</strong>, not the size of an application.</p>
<p>For more info, visit the comparison docs for <a href="https://turbo.build/pack/docs/comparisons/turbopack-vs-vite">Vite</a> and <a href="https://turbo.build/pack/docs/comparisons/turbopack-vs-webpack">Webpack</a>.</p>
<h4>Data<span id="data-1"></span><a href="#data-1"></a></h4>
<p>To run this benchmark yourself, clone <a href="https://github.com/vercel/turbo" target="_blank" rel="noreferrer"><code dir="ltr">vercel/turbo</code></a> and then use this command from the root:</p>
<div data-rehype-pretty-code-fragment=""><pre><code dir="ltr" data-language="text" data-theme="default"><span><span>TURBOPACK_BENCH_COUNTS=10,100,200,500,1000,2000,3000,4000,5000,10000,20000,30000,50000 TURBOPACK_BENCH_BUNDLERS=all cargo bench -p next-dev &#34;hmr_to_eval/(Turbopack SSR|Next.js 12 SSR|Next.js 11 SSR|Vite CSR)&#34;</span></span></code></pre></div>
<p>Here are the numbers we were able to produce on a 14” MacBook Pro 2021, M1 Max, 64GB RAM, macOS 12.6 (21G115):</p>
<div data-rehype-pretty-code-fragment=""><pre><code dir="ltr" data-language="sh" data-theme="default"><span><span>bench_hmr_to_eval/Next.js 11 SSR/10 modules         77.9±21.03ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/100 modules        100.5±2.04ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/200 modules         98.7±4.48ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/500 modules       140.0±14.06ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/1000 modules      273.2±17.11ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/2000 modules      404.0±24.81ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/3000 modules      498.3±22.10ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/4000 modules      698.8±54.46ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/5000 modules      849.7±14.64ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/10000 modules    1713.9±32.96ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/20000 modules         5.0±0.12s</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/30000 modules         6.9±1.75s</span></span>
<span><span>bench_hmr_to_eval/Next.js 11 SSR/50000 modules        11.6±0.50s</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/10 modules          50.2±5.68ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/100 modules         45.7±2.99ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/200 modules         50.6±8.27ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/500 modules        93.9±19.93ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/1000 modules      133.9±12.69ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/2000 modules      147.4±24.38ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/3000 modules      210.7±33.00ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/4000 modules      295.0±21.65ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/5000 modules      386.2±84.54ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/10000 modules    1067.1±133.67ms</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/20000 modules         2.8±0.09s</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/30000 modules         5.4±0.50s</span></span>
<span><span>bench_hmr_to_eval/Next.js 12 SSR/50000 modules         8.5±0.32s</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/10 modules           13.3±0.49ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/100 modules          13.8±1.10ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/200 modules          14.5±2.18ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/500 modules          14.3±1.63ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/1000 modules         15.3±0.27ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/2000 modules         14.1±0.14ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/3000 modules         15.1±0.37ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/4000 modules         16.0±0.31ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/5000 modules         16.5±0.41ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/10000 modules        14.9±1.35ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/20000 modules        15.3±1.52ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/30000 modules        15.1±1.03ms</span></span>
<span><span>bench_hmr_to_eval/Turbopack SSR/50000 modules        16.7±3.73ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/10 modules                94.8±5.24ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/100 modules              102.4±2.32ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/200 modules              101.7±2.39ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/500 modules              100.1±4.24ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/1000 modules              86.5±9.13ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/2000 modules             111.6±3.76ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/3000 modules             105.0±2.51ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/4000 modules             99.0±12.26ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/5000 modules             92.5±22.77ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/10000 modules           110.4±32.82ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/20000 modules           204.4±61.72ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/30000 modules           256.2±67.72ms</span></span>
<span><span>bench_hmr_to_eval/Vite CSR/50000 modules          509.8±137.92ms</span></span></code></pre></div>
<p>Visit the <a href="https://turbo.build/pack/docs/benchmarks">Turbopack benchmark documentation</a> to run the benchmarks yourself. If you have questions about the benchmark, please open an <a href="https://github.com/vercel/turbo/issues" target="_blank" rel="noreferrer">issue on GitHub</a>.</p>
<h2>The future of the open-source Web<span id="the-future-of-the-open-source-web"></span><a href="#the-future-of-the-open-source-web"></a></h2>
<p>Our team has taken the lessons from 10 years of Webpack, combined with the innovations in incremental computation from <a href="https://turbo.build/repo">Turborepo</a> and Google&#39;s Bazel, and created an architecture ready to support the coming decades of computing.</p>
<p>Our goal is to create a system of open source tooling that helps to build the future of the Web—powered by Turbopack. We&#39;re creating a reusable piece of architecture that will make both development and warm production builds faster for everyone.</p>
<p>For Turbopack&#39;s alpha, we are including it in Next.js 13. But, in time, <a href="https://twitter.com/youyuxi/status/1585040276447690752?s=20&amp;t=YV0ASkHl5twCWQvJF5jpwg" target="_blank" rel="noreferrer">we hope that Turbopack will power other frameworks and builders</a> as a seamless, low-level, incremental engine to build great developer experiences with.</p>
<p>We look forward to being a part of the community bringing developers better tooling so that they can continue to deliver better experiences to end users. If you’d like to learn more about Turbopack benchmarks, visit <a href="https://turbo.build/" target="_blank" rel="noreferrer">turbo.build</a>. To try out Turbopack in Next.js 13, visit <a href="https://nextjs.org/docs/advanced-features/turbopack" target="_blank" rel="noreferrer">nextjs.org</a>.</p><div><p>Last updated on</p><!-- --> <!-- --><p>November 1, 2022</p></div></main></article></div></div>
  </body>
</html>
