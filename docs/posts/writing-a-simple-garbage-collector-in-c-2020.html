<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://maplant.com/gc.html">Original</a>
    <h1>Writing a Simple Garbage Collector in C (2020)</h1>
    
    <div id="readability-page-1" class="page"><div id="text-2">
<p>
To begin, we need to write a memory allocator, or as we will be calling it,
a malloc function. The simplest malloc implementations maintain a linked-list of
free blocks of memory that can be partitioned and given out as needed. When a
user requests a chunk of memory, a block of the right size is removed from the
free list and returned. If no blocks of the right size exist, either a block of
a larger size is partitioned into smaller blocks or more memory is requested
from the kernel. Freeing a chunk of memory simply adds it back to the free list.
</p>

<p>
Each chunk of memory in the free list begins with a header describing the
block. Our header will contain two fields, one indicating the size of the chunk
and the second pointing to the next free block of memory:
</p>

<div>
<pre><span>typedef</span> <span>struct</span> <span>header</span> {
    <span>unsigned</span> <span>int</span>    <span>size</span>;
    <span>struct</span> <span>header</span>   *<span>next</span>;
} <span>header_t</span>;
</pre>
</div>

<p>
Using headers that are embedded in the memory we allocate is really the only
sensible way of doing this, but it has the added benefit of automatically
word-aligning the chunks, which is important.
</p>

<p>
Because we will need to keep track of the blocks of memory currently in use
as well as the blocks that are not, we will have a used list in addition to a
free list. Items will be added to the used list when they are removed from the
free list, and vice-versa.
</p>

<p>
We are almost ready to complete the first step and write our malloc
implementation. Before we do that, we first need to understand how to request
memory from the kernel.
</p>

<p>
Dynamically allocated memory resides in the so-called heap, a section memory
between the stack and the BSS (uninitialized data segment - all your global
variables that have the default value of zero). The heap starts at a low address
bordering the BSS and ends at the program break, which resides somewhere between
the BSS and the stack. Attempting to access any memory between the stack and the
break will cause an access violation (unless you access within the amount the
stack can be extended by, but that&#39;s a whole separate conversation). In order to
obtain more memory from the kernel, we simply extend the break, thus allowing us
to access more memory. To do this, we call the Unix sbrk system call, which
extends the break by its argument and returns the address of the previous break
on success, thus giving the program more memory. On failure, sbrk returns -1
casted to a void pointer, which is a terrible convention that no one likes.
</p>

<p>
We can use this knowledge to create two functions: <code>morecore</code> and
<code>add_to_free_list</code>. In the case that we are out of blocks in the free list, we 
will call <code>morecore</code> to request more memory. Since requesting the kernel for more
memory is expensive, we will do it in page-size chunks. Knowing what a page is
is not important right now, but a terse explanation is that it is the smallest
unit of virtual memory that can be mapped to any particular location in physical
memory. We will use the function <code>add_to_free_list</code> to do exactly what it sounds
like.
</p>

<div>
<pre><span>static</span> <span>header_t</span> <span>base</span>;           <span>/* </span><span>Zero sized block to get us started. </span><span>*/</span>
<span>static</span> <span>header_t</span> *<span>freep</span> = &amp;base; <span>/* </span><span>Points to first free block of memory. </span><span>*/</span>
<span>static</span> <span>header_t</span> *<span>usedp</span>;         <span>/* </span><span>Points to first used block of memory. </span><span>*/</span>

<span>/*</span>
<span> * Scan the free list and look for a place to put the block. Basically, we&#39;re </span>
<span> * looking for any block that the to-be-freed block might have been partitioned from.</span>
<span> </span><span>*/</span>
<span>static</span> <span>void</span>
<span>add_to_free_list</span>(<span>header_t</span> *<span>bp</span>)
{
    <span>header_t</span> *<span>p</span>;

    <span>for</span> (p = freep; <span>!</span>(bp &gt; p &amp;&amp; bp &lt; p-&gt;next); p = p-&gt;next)
        <span>if</span> (p &gt;= p-&gt;next &amp;&amp; (bp &gt; p || bp &lt; p-&gt;next))
            <span>break</span>;

    <span>if</span> (bp + bp-&gt;size == p-&gt;next) {
        bp-&gt;size += p-&gt;next-&gt;size;
        bp-&gt;next = p-&gt;next-&gt;next;
    } <span>else</span>
        bp-&gt;next = p-&gt;next;

    <span>if</span> (p + p-&gt;size == bp) {
        p-&gt;size += bp-&gt;size;
        p-&gt;next = bp-&gt;next;
    } <span>else</span>
        p-&gt;next = bp;

    freep = p;
}

<span>#define</span> <span>MIN_ALLOC_SIZE</span> 4096 <span>/* </span><span>We allocate blocks in page sized chunks. </span><span>*/</span>

<span>/*</span>
<span> * Request more memory from the kernel.</span>
<span> </span><span>*/</span>
<span>static</span> <span>header_t</span> *
<span>morecore</span>(<span>size_t</span> <span>num_units</span>)
{
    <span>void</span> *<span>vp</span>;
    <span>header_t</span> *<span>up</span>;

    <span>if</span> (num_units &gt; MIN_ALLOC_SIZE)
        num_units = MIN_ALLOC_SIZE / <span>sizeof</span>(header_t);

    <span>if</span> ((vp = sbrk(<span>num_units</span> * <span>sizeof</span>(header_t))) == (<span>void</span> *) -1)
        <span>return</span> <span>NULL</span>;

    up = (<span>header_t</span> *) vp;
    up-&gt;size = num_units;
    add_to_free_list (up);
    <span>return</span> freep;
}
</pre>
</div>

<p>
Now that we have our two helper functions, writing our malloc function is
pretty straight forward. We simply scan the free list and use the first block
that is at least as big as the chunk we&#39;re trying to find. Because we use the 
first block we find instead of trying to find a &#34;better&#34; block, this algorithm
is known as first fit.
</p>

<p>
A quick note to clarify: the size field in the header struct is measured in
header-sized blocks, and not bytes.
</p>

<div>
<pre><span>/*</span>
<span> * Find a chunk from the free list and put it in the used list.</span>
<span> </span><span>*/</span>
<span>void</span> *
<span>GC_malloc</span>(<span>size_t</span> <span>alloc_size</span>)
{
    <span>size_t</span> <span>num_units</span>;
    <span>header_t</span> *<span>p</span>, *<span>prevp</span>;

    num_units = (alloc_size + <span>sizeof</span>(header_t) - 1) / <span>sizeof</span>(header_t) + 1;  
    prevp = freep;

    <span>for</span> (p = prevp-&gt;next;; prevp = p, p = p-&gt;next) {
        <span>if</span> (p-&gt;size &gt;= num_units) { <span>/* </span><span>Big enough. </span><span>*/</span>
            <span>if</span> (p-&gt;size == num_units) <span>/* </span><span>Exact size. </span><span>*/</span>
                prevp-&gt;next = p-&gt;next;
            <span>else</span> {
                p-&gt;size -= num_units;
                p += p-&gt;size;
                p-&gt;size = num_units;
            }

            freep = prevp;

            <span>/* </span><span>Add to p to the used list. </span><span>*/</span>
            <span>if</span> (usedp == <span>NULL</span>)  
                usedp = p-&gt;next = p;
            <span>else</span> {
                p-&gt;next = usedp-&gt;next;
                usedp-&gt;next = p;
            }

            <span>return</span> (<span>void</span> *) (p + 1);
        }
        <span>if</span> (p == freep) { <span>/* </span><span>Not enough memory. </span><span>*/</span>
            p = morecore(num_units);
            <span>if</span> (p == <span>NULL</span>) <span>/* </span><span>Request for more memory failed. </span><span>*/</span>
                <span>return</span> <span>NULL</span>;
        }
    }
}
</pre>
</div>

<p>
Although this code isn&#39;t going to win any awards for low fragmentation, it&#39;ll
work. And if it works, that means we can finally get to the fun part - the
garbage collection!
</p>
</div></div>
  </body>
</html>
