<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.zombiezen.com/blog/2025/06/why-go-rocks-for-building-lua-interpreter/">Original</a>
    <h1>Why Go Rocks for Building a Lua Interpreter</h1>
    
    <div id="readability-page-1" class="page"><div><p>I <a href="https://www.zombiezen.com/blog/2025/06/zb-beta-release/">recently needed</a> to build a custom <a href="https://www.lua.org/">Lua</a> interpreter in <a href="https://go.dev/">Go</a>.
The exact reasons aren’t important for this blog post,
but neither the <a href="https://www.lua.org/download.html">reference implementation</a> —
which I will be referring to as “C Lua” throughout this article —
nor the other open source Go Lua intepreters I could find were a good fit for my needs.
Building a Lua interpreter ended up being a rather enjoyable months-long side quest.
I’ve had a number of folks ask me to write about the experience
since these sorts of projects
usually highlight interesting aspects of both the implementation language and the interpreted language.
So here we are!</p>
<h2 id="what-is-lua">What is Lua?</h2>
<p>First, let’s talk a little bit about the <a href="https://www.lua.org/">Lua language</a> from the perspective of an implementer.
Lua is a dynamically typed language, so any variable can hold any value.
Values in Lua can be one of a handful of types:</p>
<ul>
<li><code>nil</code>, the singleton <a href="https://en.wikipedia.org/wiki/Null_pointer">null value</a>.</li>
<li>Booleans: either <code>true</code> or <code>false</code>.</li>
<li>Numbers, which are generally <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">64-bit IEEE 754 floating-point numbers</a>.
<a href="https://www.lua.org/manual/5.3/readme.html#changes">Lua 5.2</a> introduced transparent representation of 64-bit signed integers,
so if a numeric literal does not contain a fractional part nor an exponent
and fits in a 64-bit signed integer (like <code>-345</code> or <code>0x100000000</code>),
then it will be stored as an integer.</li>
<li>Strings, which are immutable sequences of bytes.
By convention, strings are UTF-8 encoded.</li>
<li>Userdata, which are implementation-defined values.</li>
<li>Tables, which are <a href="https://en.wikipedia.org/wiki/Associative_array">maps</a> of values to other values.
Lua raises an error if <code>nil</code>
or NaN (the IEEE 754 sentinel value for undefined numeric results)
are used as keys.
Furthermore, table entries cannot use <code>nil</code> as a value:
assigning a <code>nil</code> value to an entry removes it from the table.</li>
<li>Functions.
Functions in Lua can take any number of arguments
and can return any number of values.
They may be <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a>,
which means they have references to variables from their containing function.
Lua calls such references “upvalues”.</li>
</ul>
<p>The <a href="https://www.lua.org/manual/5.4/manual.html#3">reference manual</a> describes the syntax of the Lua language in depth,
but most of these details don’t matter at a high level:
the syntax performs various operations on these data types.
What’s relevant for this blog post is that Lua files get parsed into functions.
Global variables accesses and assignments are transformed into operations
on an implicit upvalue table called <code>_ENV</code>.
This allows us to understand all of the Lua language solely in terms of these data types.
(Neat!)</p>
<h2 id="code-structure">Code Structure</h2>
<p>My Lua interpreter is split up into three Go packages:
<code>lualex</code>, <code>luacode</code>, and <code>lua</code>.
The packages form a pipeline that translate Lua source code into a running program.</p>
<p>The first I package wrote is <a href="https://pkg.go.dev/zb.256lights.llc/pkg@v0.1.0/internal/lualex"><code>lualex</code></a>.
It’s very small and I wrote it from scratch.
The main type in the package is <a href="https://pkg.go.dev/zb.256lights.llc/pkg@v0.1.0/internal/lualex#Scanner"><code>lualex.Scanner</code></a>,
which takes in a <a href="https://pkg.go.dev/io#ByteScanner"><code>io.ByteScanner</code></a> and splits the stream into tokens (words and symbols).
The scanner is a fairly direct implementation of
the <a href="https://www.lua.org/manual/5.4/manual.html#3.1">Lexical Conventions</a> section of the Lua Reference Manual.</p>
<p>After <code>lualex</code> was done,
I ported C Lua’s parser code into a package called <a href="https://pkg.go.dev/zb.256lights.llc/pkg@v0.1.0/internal/luacode"><code>luacode</code></a>.
I wanted to port C Lua’s parser directly for performance and compatibility reasons.
C Lua’s parser is notable for being geared for immediate execution.
A common approach for a programming language parser
is to create an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> that represents the source code.
C Lua’s parser does not take this approach.
Instead, it generates a list of instructions.
These instructions can be efficiently stored (they are encoded as 32-bit integers)
and executed.
This format also enables the parser to perform <a href="https://en.wikipedia.org/wiki/Peephole_optimization">peephole optimizations</a>.
The full data structure that the parser produces is <a href="https://pkg.go.dev/zb.256lights.llc/pkg@v0.1.0/internal/luacode#Prototype"><code>luacode.Prototype</code></a>:
a tree of functions.
<code>luacode.Prototype</code> can be serialized into a binary format,
called a <a href="https://www.lua.org/manual/5.4/manual.html#3.3.2">binary chunk</a>,
that can be stored for later use.
I intentionally preserved compatibility with C Lua’s binary format in <code>luacode</code>.
This ended up working out really well to spot correctness issues;
I’ll touch on the benefits in the “What Went Well” section.
After the Lua source code leaves <code>luacode</code>,
we have a <code>luacode.Prototype</code> that’s ready to run.</p>
<p>The <a href="https://github.com/256lights/zb/tree/v0.1.0/internal/lua"><code>lua</code> package</a> brings everything together
with the <a href="https://pkg.go.dev/zb.256lights.llc/pkg@v0.1.0/internal/lua#State"><code>lua.State</code> structure</a> that represents an intepreter.
<code>lua.State</code> can create Lua values and executes the instructions produced by <code>luacode</code>.
Each instruction is handled by a giant <a href="https://github.com/256lights/zb/blob/v0.1.0/internal/lua/vm.go#L201-L1375">switch statement</a> run in a loop.
Because the expressions have already been broken down into fine-grained instructions,
the interpreter does not have to be aware of operator precedence or lexical scopes.
Thus, the interpreter is largely concerned with performing operations on Lua data.
The <code>lua</code> package provides the same general API and stack-based execution model that C Lua has.
However, as we’ll see in the next section,
the data representation diverges quite a bit from the C Lua implementation
and thus is an independent implementation.</p>
<h2 id="data-representation">Data Representation</h2>
<p>Now that we have a high-level structure of the interpreter in the <code>lua</code> package,
let’s dive into the internal data representation.
As it turns out, a Go interface type is perfect for representing Lua values:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>lua</span>
</span></span><span><span>
</span></span><span><span><span>// value is the internal representation of a Lua value.
</span></span></span><span><span><span></span><span>type</span> <span>value</span> <span>interface</span> <span>{</span>
</span></span><span><span>  <span>valueType</span><span>()</span> <span>Type</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// Type is an enumeration of Lua data types.
</span></span></span><span><span><span></span><span>type</span> <span>Type</span> <span>int</span>
</span></span><span><span>
</span></span><span><span><span>// Value types.
</span></span></span><span><span><span></span><span>const</span> <span>(</span>
</span></span><span><span>	<span>TypeNil</span>           <span>Type</span> <span>=</span> <span>0</span>
</span></span><span><span>	<span>TypeBoolean</span>       <span>Type</span> <span>=</span> <span>1</span>
</span></span><span><span>	<span>TypeNumber</span>        <span>Type</span> <span>=</span> <span>3</span>
</span></span><span><span>	<span>TypeString</span>        <span>Type</span> <span>=</span> <span>4</span>
</span></span><span><span>	<span>TypeTable</span>         <span>Type</span> <span>=</span> <span>5</span>
</span></span><span><span>	<span>TypeFunction</span>      <span>Type</span> <span>=</span> <span>6</span>
</span></span><span><span>	<span>TypeUserdata</span>      <span>Type</span> <span>=</span> <span>7</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><p>I use a <code>value(nil)</code> as Lua <code>nil</code>.
I use <a href="https://medium.com/swlh/what-is-the-extension-interface-pattern-in-golang-ce852dcecaec">extension interfaces</a> to implement operations that have per-type implementations.
A prime example is the <code>numericValue</code> interface:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>lua</span>
</span></span><span><span>
</span></span><span><span><span>// numericValue is an optional interface for types that implement value
</span></span></span><span><span><span>// and can be coerced to a number.
</span></span></span><span><span><span></span><span>type</span> <span>numericValue</span> <span>interface</span> <span>{</span>
</span></span><span><span>  <span>value</span>
</span></span><span><span>  <span>toNumber</span><span>()</span> <span>(</span><span>_</span> <span>floatValue</span><span>,</span> <span>ok</span> <span>bool</span><span>)</span>
</span></span><span><span>  <span>toInteger</span><span>()</span> <span>(</span><span>_</span> <span>integerValue</span><span>,</span> <span>ok</span> <span>bool</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Then, I was able to create Go data types that map directly to Lua data types.
For example, here are the numeric types:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>lua</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>floatValue</span> <span>float64</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>v</span> <span>floatValue</span><span>)</span> <span>valueType</span><span>()</span> <span>Type</span>              <span>{</span> <span>return</span> <span>TypeNumber</span> <span>}</span>
</span></span><span><span><span>func</span> <span>(</span><span>v</span> <span>floatValue</span><span>)</span> <span>toNumber</span><span>()</span> <span>(</span><span>floatValue</span><span>,</span> <span>bool</span><span>)</span> <span>{</span> <span>return</span> <span>v</span><span>,</span> <span>true</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>v</span> <span>floatValue</span><span>)</span> <span>toInteger</span><span>()</span> <span>(</span><span>integerValue</span><span>,</span> <span>bool</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>f</span> <span>:=</span> <span>math</span><span>.</span><span>Floor</span><span>(</span><span>float64</span><span>(</span><span>v</span><span>))</span>
</span></span><span><span>  <span>if</span> <span>f</span> <span>!=</span> <span>float64</span><span>(</span><span>v</span><span>)</span> <span>||</span> <span>f</span> <span>&lt;</span> <span>math</span><span>.</span><span>MinInt64</span> <span>||</span> <span>f</span> <span>&gt;=</span> <span>-</span><span>math</span><span>.</span><span>MinInt64</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>0</span><span>,</span> <span>false</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>return</span> <span>f</span><span>,</span> <span>true</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>integerValue</span> <span>int64</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>v</span> <span>integerValue</span><span>)</span> <span>valueType</span><span>()</span> <span>Type</span>                 <span>{</span> <span>return</span> <span>TypeNumber</span> <span>}</span>
</span></span><span><span><span>func</span> <span>(</span><span>v</span> <span>integerValue</span><span>)</span> <span>toNumber</span><span>()</span> <span>(</span><span>floatValue</span><span>,</span> <span>bool</span><span>)</span>    <span>{</span> <span>return</span> <span>floatValue</span><span>(</span><span>v</span><span>),</span> <span>true</span> <span>}</span>
</span></span><span><span><span>func</span> <span>(</span><span>v</span> <span>integerValue</span><span>)</span> <span>toInteger</span><span>()</span> <span>(</span><span>integerValue</span><span>,</span> <span>bool</span><span>)</span> <span>{</span> <span>return</span> <span>v</span><span>,</span> <span>true</span> <span>}</span>
</span></span></code></pre></div><p>The table and userdata types are more involved, but not interesting enough to cover here.
The function type is more significant.
Functions written in Lua are a <code>*luacode.Prototype</code> plus their upvalues.
Built-in functions are implemented in Go
and follow a <a href="https://pkg.go.dev/zb.256lights.llc/pkg@v0.1.0/internal/lua#Function">signature</a> of:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>lua</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Function</span> <span>func</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>l</span> <span>*</span><span>State</span><span>)</span> <span>(</span><span>int</span><span>,</span> <span>error</span><span>)</span>
</span></span></code></pre></div><p>The <code>lua.State</code> argument is used to access function arguments,
push return values,
and access Lua upvalues.
C Lua passes around a pointer to implement stateful C functions,
but Go has first-class closures,
so we can use function values directly.
<code>lua.State</code> maintains a stack of Lua values (<code>[]value</code>) used as temporary function storage.</p>
<p>My Lua data types have a notable difference from C Lua:
an ability to be “frozen”.
Freezing is a <a href="https://github.com/bazelbuild/starlark/blob/6dd78ee3a66820a8b7571239946466cc702b209e/spec.md#freezing-a-value">concept I borrowed from Starlark</a>
where the interpreter prevents mutations on a value.
To implement this, I added flags to the table and userdata value types
as well as the internal upvalue representation.
When the flag is set, mutations raise an error.
Freezing prevents unintentional global state
and permits sharing Lua data values among concurrent <code>lua.State</code> interpreters without copying.
Data sharing is only possible because of Go’s process-wide garbage collector:
C Lua’s garbage collector is limited to individual <code>lua_State*</code> interpreters.</p>
<h2 id="bringing-it-together">Bringing it Together</h2>
<p>Now that we’ve talked about all the pieces,
let’s look at how some Lua code gets run.</p>
<p>We’ll start with a variable assignment:</p>
<p><code>lualex</code> and <code>luacode</code> parse the source,
into a <code>LOADI</code> (load immediate) instruction.
In <code>luac</code>’s listing/disassembly output, this looks like:</p>
<p>The 0 means to store the result into “register” 0.
When a Lua function starts, a number of nils are pushed onto the <code>lua.State</code> stack.
(The parser determines the exact number
by counting the maximum number of local variables that need to be available at once.)
These elements in the stack are called “registers”
as a nod to <a href="https://en.wikipedia.org/wiki/Processor_register">CPU registers</a>.
The case for <code>LOADI</code> in the big interpreter <code>switch</code> looks like this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>i</span> <span>:=</span> <span>currFunction</span><span>.</span><span>proto</span><span>.</span><span>Code</span><span>[</span><span>frame</span><span>.</span><span>pc</span><span>]</span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span><span>switch</span> <span>opCode</span> <span>:=</span> <span>i</span><span>.</span><span>OpCode</span><span>();</span> <span>opCode</span> <span>{</span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span><span>case</span> <span>luacode</span><span>.</span><span>OpLoadI</span><span>:</span>
</span></span><span><span>  <span>ra</span><span>,</span> <span>err</span> <span>:=</span> <span>register</span><span>(</span><span>registers</span><span>(),</span> <span>i</span><span>.</span><span>ArgA</span><span>())</span>
</span></span><span><span>  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>err</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>*</span><span>ra</span> <span>=</span> <span>integerValue</span><span>(</span><span>i</span><span>.</span><span>ArgBx</span><span>())</span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p><code>registers</code> is a local helper closure
that returns a slice of the <code>lua.State</code> stack for the current function’s registers.
<code>register</code> is a helper function that translates the register number
to a <code>*value</code> referencing the slice’s underlying array
after performing a bounds check.</p>
<p>Operators have a little bit more fanfare, but end up performing operations on registers.</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> <span>x</span> <span>=</span> <span>42</span>
</span></span><span><span><span>local</span> <span>y</span> <span>=</span> <span>x</span> <span>+</span> <span>3</span>
</span></span></code></pre></div><p>is parsed into:</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>LOADI  0 42
</span></span><span><span>ADDI   1 0 3
</span></span><span><span>MMBINI 0 3 6 0
</span></span></code></pre></div><ol>
<li>A <code>LOADI</code> instruction like before.</li>
<li>An <code>ADDI</code> (add immediate) instruction.
If the value in register 0 is numeric,
<code>ADDI</code> adds the integer 3 to the value in register 0,
stores the result in register 1,
then skips the next instruction.
Otherwise, <code>ADDI</code> is a no-op and the interpreter proceeds with the next instruction.</li>
<li>The <code>MMBINI</code> (binary metamethod with immediate) instruction
with the <code>__add</code> metamethod (value 6).
This is a quirk to handle operator overloading <a href="https://www.lua.org/manual/5.4/manual.html#2.4">metamethods</a>
in the case register 0 has a non-numeric value.
The first two arguments specify the arguments to the metamethod,
in this case the value in register zero and the integer 3.
The destination register is used from the previous instruction.</li>
</ol>
<p>The <code>switch</code> case that handles the <code>ADDI</code> instruction is:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>i</span> <span>:=</span> <span>currFunction</span><span>.</span><span>proto</span><span>.</span><span>Code</span><span>[</span><span>frame</span><span>.</span><span>pc</span><span>]</span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span><span>switch</span> <span>opCode</span> <span>:=</span> <span>i</span><span>.</span><span>OpCode</span><span>();</span> <span>opCode</span> <span>{</span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span><span>case</span> <span>luacode</span><span>.</span><span>OpAddI</span><span>,</span> <span>luacode</span><span>.</span><span>OpSHRI</span><span>:</span>
</span></span><span><span>  <span>r</span> <span>:=</span> <span>registers</span><span>()</span>
</span></span><span><span>  <span>ra</span><span>,</span> <span>err</span> <span>:=</span> <span>register</span><span>(</span><span>r</span><span>,</span> <span>i</span><span>.</span><span>ArgA</span><span>())</span>
</span></span><span><span>  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>err</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>rb</span><span>,</span> <span>err</span> <span>:=</span> <span>register</span><span>(</span><span>r</span><span>,</span> <span>i</span><span>.</span><span>ArgB</span><span>())</span>
</span></span><span><span>  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>err</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>c</span> <span>:=</span> <span>luacode</span><span>.</span><span>IntegerValue</span><span>(</span><span>int64</span><span>(</span><span>luacode</span><span>.</span><span>SignedArg</span><span>(</span><span>i</span><span>.</span><span>ArgC</span><span>())))</span>
</span></span><span><span>  <span>if</span> <span>kb</span><span>,</span> <span>isNumber</span> <span>:=</span> <span>exportNumericConstant</span><span>(</span><span>*</span><span>rb</span><span>);</span> <span>isNumber</span> <span>{</span>
</span></span><span><span>    <span>op</span><span>,</span> <span>ok</span> <span>:=</span> <span>opCode</span><span>.</span><span>ArithmeticOperator</span><span>()</span>
</span></span><span><span>    <span>if</span> <span>!</span><span>ok</span> <span>{</span>
</span></span><span><span>      <span>panic</span><span>(</span><span>&#34;operator should always be defined&#34;</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>result</span><span>,</span> <span>err</span> <span>:=</span> <span>luacode</span><span>.</span><span>Arithmetic</span><span>(</span><span>op</span><span>,</span> <span>kb</span><span>,</span> <span>c</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>      <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>*</span><span>ra</span> <span>=</span> <span>importConstant</span><span>(</span><span>result</span><span>)</span>
</span></span><span><span>    <span>// The next instruction is a fallback metamethod invocation.
</span></span></span><span><span><span></span>    <span>l</span><span>.</span><span>frame</span><span>().</span><span>pc</span><span>++</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p><code>exportNumericConstant</code> is a helper function defined as:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>// exportNumericConstant converts a floatValue or an integerValue
</span></span></span><span><span><span>// to a luacode.Value.
</span></span></span><span><span><span></span><span>func</span> <span>exportNumericConstant</span><span>(</span><span>v</span> <span>value</span><span>)</span> <span>(</span><span>_</span> <span>luacode</span><span>.</span><span>Value</span><span>,</span> <span>ok</span> <span>bool</span><span>)</span> <span>{</span>
</span></span><span><span>	<span>switch</span> <span>v</span> <span>:=</span> <span>v</span><span>.(</span><span>type</span><span>)</span> <span>{</span>
</span></span><span><span>	<span>case</span> <span>floatValue</span><span>:</span>
</span></span><span><span>		<span>return</span> <span>luacode</span><span>.</span><span>FloatValue</span><span>(</span><span>float64</span><span>(</span><span>v</span><span>)),</span> <span>true</span>
</span></span><span><span>	<span>case</span> <span>integerValue</span><span>:</span>
</span></span><span><span>		<span>return</span> <span>luacode</span><span>.</span><span>IntegerValue</span><span>(</span><span>int64</span><span>(</span><span>v</span><span>)),</span> <span>true</span>
</span></span><span><span>	<span>default</span><span>:</span>
</span></span><span><span>		<span>return</span> <span>luacode</span><span>.</span><span>Value</span><span>{},</span> <span>false</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>You’ll notice that the arithmetic function is defined in the <code>luacode</code> package,
not in the <code>lua</code> package.
This is because the parser performs <a href="https://en.wikipedia.org/wiki/Constant_folding">constant folding</a>,
and such arithmetic needs to be consistent with the interpreter.
Constant folding allows a script like:</p>
<p>to be parsed as:</p>
<p>instead of performing the arithmetic at runtime.
Such arithmetic needs to be consistent with the interpreter for correctness,
and thus the function is defined in the <code>luacode</code> package.
The parser does not attempt constant folding on variables.
However, <a href="https://www.lua.org/manual/5.4/manual.html#3.3.7"><code>&lt;const&gt;</code> variables</a> will be folded,
so the following Lua code will produce the same single <code>LOADI</code> instruction:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> <span>x</span> <span>&lt;</span><span>const</span><span>&gt;</span> <span>=</span> <span>42</span>
</span></span><span><span><span>local</span> <span>y</span> <span>=</span> <span>x</span> <span>+</span> <span>3</span>
</span></span></code></pre></div><p>As we can see, the bytecode approach results in fine-grained instructions
that the interpreter can process one-at-a-time
with short snippets of Go that operate on our <code>value</code> data types.
This approach also enables the parser to perform some on-the-fly optimizations
to reduce pressure on the interpreter.
The rest of the interpreter code follows the same general pattern
of reading values from registers, doing something with them,
and/or storing values into other registers.</p>
<h2 id="what-went-well">What Went Well</h2>
<p>This custom Lua interpreter was exactly what I needed for <a href="https://zb.256lights.llc/">zb</a>.
The highlights:</p>
<ul>
<li>Go’s built-in types, garbage collector, and standard library
made my interpreter simpler than the C Lua implementation.
One example I noted above was being able to separate the parser from the interpreter.
C Lua’s memory allocation is tied to the <code>lua_State*</code> type,
so it was tightly coupled,
but my interpreter could use Go’s built-in garbage-collected types
to structure the code differently.
There were similar small wins in other places
like deduping the constant table in the parser
and implementing <code>table.sort</code>.</li>
<li>As I mentioned before, my decision to port the parser as directly as I could
made it easy for me to spot correctness issues.
I created a test suite with Go’s <code>testing</code> package and <code>testdata</code> directory convention
where I could create a Lua file
and compare it to a golden <code>luac</code> output.
The <a href="https://pkg.go.dev/github.com/google/go-cmp/cmp"><code>go-cmp</code> package</a> surfaces the difference in instructions,
so I could quickly see failures.
The C Lua parser also has some nice optimization tricks like we saw above.</li>
<li>As we saw above, Go’s powerful interface types map nicely to Lua value types.
C Lua uses tagged C <code>union</code>s and other memory-unsafe tricks to make this work.</li>
<li>Go’s built-in testing tooling helped me spot-check lots of small parts along the way.
In C Lua, there are comments like “if you change this, change this other file”
to ensure that invariants hold.
In my interpreter, I ensured that the invariants hold by writing unit tests,
like for <a href="https://github.com/256lights/zb/blob/v0.1.0/internal/luacode/code_test.go#L11-L26"><code>ceilLog2</code></a>,
the <a href="https://github.com/256lights/zb/blob/v0.1.0/internal/luacode/operators_test.go#L80-L91">unary operator instruction translation</a>
and the <a href="https://github.com/256lights/zb/blob/v0.1.0/internal/luacode/operators_test.go#L233-L246">binary operator instruction translation</a>.</li>
<li>Go’s built-in benchmarking and support for pprof
helped me compare the performance of different approaches while I was developing.
This Lua interpreter is not highly optimized yet,
but I’m confident that between Go’s tooling
and control over memory layout,
I can solve most any performance issue.</li>
</ul>
<h2 id="challenges">Challenges</h2>
<p>This interpreter project, like any project of this scale, was not without its challenges.
Here were the most notable ones:</p>
<ul>
<li>
<p>I had to completely rethink how my interpreter handles errors compared to C Lua.
C Lua uses <a href="https://en.wikipedia.org/wiki/Setjmp.h"><code>longjmp</code></a> to pop the call stack and raise errors.
I could have used Go’s <code>panic</code> mechanism,
but this runs counter to the common Go error handling convention
of returning an <code>error</code> as the final return value,
and I didn’t want to mask runtime panics using this mechanism.
I ended up coming up with an approach where Lua <a href="https://www.lua.org/manual/5.4/manual.html#2.3">message handlers</a>
are stored in the Lua call stack.
If an error reaches the <code>lua</code> package,
the message handler is called as appropriate,
then the interpreter unwinds the stack.
This has the disadvantage that Go-implemented functions can drop errors,
but it also gives Go-implemented functions the flexibility to handle errors how they want.
In practice, being able to see at a glance which Lua API calls can produce errors
is convenient for maintenance,
much like in any Go application,
so the benefits outweighed the implementation complexity.</p>
</li>
<li>
<p>I found several Lua standard libraries to be annoying to port over.
I ended up <a href="https://github.com/256lights/zb/blob/v0.1.0/internal/lua/pattern.go">rewriting</a>
the <a href="https://www.lua.org/manual/5.4/manual.html#6.4.1">pattern matching</a> logic entirely
because C Lua has the exponential time complexity problem
described in <a href="https://swtch.com/~rsc/regexp/regexp1.html">Russ Cox’s essay “Regular Expression Matching Can Be Simple And Fast”</a>.
It’s one of the few places where I break compatibility with C Lua.
I was unable to reuse the Go <code>regexp</code> package because it operates on UTF-8 codepoints
whereas Lua depends on its patterns operating on bytes.
(Lua’s test suite has several cases which assert for byte-matching behavior.)
A much lesser (but vexingly pervasive) problem
is the availability of functions that surface a Lua value’s raw pointer address
(e.g. <code>string.format(&#34;%p&#34;)</code>).
Go provides no guarantees about the stability of its addresses,
so I ended up giving each object a unique 64-bit integer identifier on creation.
This solves the issue except for strings,
but I think it is a mistake to expose the pointer identity of strings anyway.</p>
</li>
<li>
<p>Lua’s standard library exposes access to its garbage collector.
I dropped this access entirely, because it would give scripts the ability to stall the host program.
The other unfortunate part is that Lua has finalizers
in the form of the <a href="https://www.lua.org/manual/5.4/manual.html#2.5.3"><code>__gc</code> metamethod</a>.
Finalizers in Go are not guaranteed to run
and technically neither are Lua finalizers,
so I “implement” finalizers by ignoring them entirely.
Similarly, I don’t implement <a href="https://www.lua.org/manual/5.4/manual.html#2.5.4">weak tables</a>
because of how they would interact with Go’s garbage collector.</p>
<p><strong>EDIT(2025-06-26):</strong> Folks have pointed out that Go 1.24 introduced weak pointers
in the form of the <a href="https://pkg.go.dev/weak"><code>weak</code> package</a>.
Go 1.24 had not been released when I made the decision to not support weak tables.
I haven’t studied Lua’s weak tables in depth yet,
but I’m not exactly sure how the semantics of table entry removal
would work with Go’s weak pointers.
I am also unsure how or if this should work with value freezing.
For now, weak tables are simpler to omit until there’s a strong use case.</p>
</li>
<li>
<p>A nit-pick: <a href="https://www.lua.org/tests/">Lua’s test suite</a> was hard to set up.
It is lovely to have it available and it covers many excellent edge cases,
but in many cases it depends on all the libraries being available.
I had to implement the <code>math</code> and <code>string</code> libraries simultaneously to test behaviors.</p>
</li>
</ul>
<p>Although these challenges added some development time,
I think the end result is better for the changes I made along the way.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The features that make Go productive in general —
a powerful standard library, garbage collection, and ubiquitous testing —
make writing an interpreter fun.
This interpreter is an <a href="https://github.com/256lights/zb/tree/v0.1.0/internal/lua">internal package</a> of my <a href="https://zb.256lights.llc/">zb</a> project
if you want to look at it for yourself.
I’m not planning on supporting it as a standalone package right now:
zb is already large enough.
However, the package is fairly self-contained and available under <a href="https://github.com/256lights/zb/v0.1.0/main/LICENSE">an MIT license</a>,
so you can fork it if you want scripting facilities in your Go application.</p>
<p>If this blog post seems interesting, check out <a href="https://zb.256lights.llc/">zb</a>!
I’ll probably write another blog post in the future
that dives deeper into my decision to use Lua for zb.</p>
<p><em>(Discussion on <a href="https://www.reddit.com/r/golang/comments/1lili7i/why_go_rocks_for_building_a_lua_interpreter/">Reddit</a>,
<a href="https://bsky.app/profile/zombiezen.com/post/3lsc2rovpyc2z">Bluesky</a>,
and <a href="https://lobste.rs/s/lot0ao/why_go_rocks_for_building_lua_interpreter">Lobsters</a>)</em></p></div></div>
  </body>
</html>
