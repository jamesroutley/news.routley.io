<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/insights-from-the-original-waterfall-paper/">Original</a>
    <h1>Insights and questions from the original waterfall paper</h1>
    
    <div id="readability-page-1" class="page"><div><p>The <a href="https://en.wikipedia.org/wiki/Waterfall_model">waterfall model</a> is probably the most reviled methodology in software engineering.
This methodology was first described in a <a href="https://dl.acm.org/doi/10.5555/41765.41801">1970 paper</a> by Dr. Winston Royce.
This paper didn&#39;t call it waterfall, nor did it <em>endorse</em> the technique, and the paper contains a lot of good insights and raises some interesting questions.
Let&#39;s take a look at some of those.</p>

<p>Royce says there are two essential steps in all programming: analysis and coding.
It&#39;s not defined what goes into analysis, but I think we can safely assume it includes thinking about the problem and how to solve it.
I think it&#39;s pretty clear that these steps are always involved.
For extremely small programs, maybe they&#39;re all you need, though you probably don&#39;t do them serially.</p>
<p>The other steps involved for larger programs are requirements, program design, testing, and operations.</p>
<p>One interesting thing here is that I think these are all done at <em>all</em> sizes of software, they&#39;re just not done explicitly and separately.
Let&#39;s say you write a small program, like a solution to an Advent of Code problem.
For this, you need to get the requirements from the problem description, do some analysis on it, design your program, write it up, test it, and then run it for the answer.
But these flow together, and code/test/operate get lumped together, and requirements/analysis/design get lumped together—with both of <em>those</em> groups getting intermingled as well.
They&#39;re not done serially one after another, but each is done at some point.</p>
<p>What are really the essential steps of software development?
I&#39;m not sure.
I think the breakdown of activities he mentions in this paper is interesting and a nice way to think about the activities we engage in, and I can&#39;t really go further than that at the moment.</p>

<p>One point that Royce makes is... interesting:</p>
<blockquote>
<p>The prime function of management is to sell these concepts [of testing, documentation, analysis, etc.] to both groups [developers and customers] and then enforce compliance on the part of development personnel.</p>
</blockquote>
<p>He continues this later on, too:</p>
<blockquote>
<p>The first rule of managing software development is ruthless enforcement of documentation requirements.</p>
</blockquote>
<p>And this quote is followed by saying that if documentation isn&#39;t good enough, then <em>replace management</em>.</p>
<p>So, this makes clear Royce&#39;s view on management&#39;s role: strictly enforcing rules and proper development practice.
If they don&#39;t <em>ruthlessly</em> enforce documentation processes, then they&#39;ll be fired.
And they need to make sure developers do their testing and analysis and design, too.</p>
<p>I mean... I don&#39;t know what it was like in the 70s, a couple of decades before my time.
So this could be the right take at the time.
In the present day, it seems <em>very</em> antithetical to what I&#39;ve experienced in the teams I work on.</p>
<p>On the teams I&#39;m on, what I&#39;ve generally seen is:</p>
<ul>
<li>Engineers advocate for testing, for requirements, for explicit design time</li>
<li>Management pushes for <em>less</em> of these in some instances</li>
</ul>
<p>This is the opposite of what he says happens!
I&#39;ll give him this, though: developers sure <em>do</em> like skipping documentation, and customers <em>do</em> want to avoid paying for these things.</p>
<p>For me, the role of management is not as ruthless enforcer but as facilitator.
Software engineering is more mature as a field than it was 53 years ago, and we have some established best practices.
As practitioners, we take pride in our work and we do push for testing, analysis, all the good stuff.
And the role of management is to make sure that everything hangs in balance between technical depth and business needs, and to make sure that the existing processes facilitate that balance.</p>
<p>But if things aren&#39;t happening, you don&#39;t step in as a ruthless enforcer
You look and figure out why, and work with the team <em>together</em> to shift processes to make those things happen.</p>

<p>He states early on that &#34;[Separate stages of development] must be planned and staffed differently for best utilization of program resources.&#34;
This describes a world where we have dedicated staff for gathering requirements, different staff for designing the program, yet more staff to write it, another team to test it, and some poor soul has to put our mess into production.</p>
<p>In contrast, most teams today take a much more multidisciplinary approach.
Some go to the extreme, and everyone does everything.
Most are somewhere in the middle: dedicated testing staff are present, but everyone does some testing; product managers are responsible for requirements, but everyone helps; architects do a lot of design, but each engineer does some architecture.</p>
<p>The key thing though is that last part: <em>&#34;for best utilization of program resources&#34;</em>.
Here, &#34;program&#34; refers to the project and its staffing, not to the software.
And that&#39;s the thing, he&#39;s optimizing for best utilizing each individual&#39;s time and saving money on personnel.</p>
<p>In contrast, modern software development prioritizes other things over direct resource utilization.
Time to market, quick validation, all the things to make sure we&#39;re going in the right direction.
We slow down a little and waste a little bit of each person&#39;s time, but we have a lot less backtracking to do.</p>
<p>I could see separate roles making sense in a situation where you do have much clearer requirements.
Does something like that exist?
Good question.
But if it does, separate roles might make sense (I&#39;m not fully convinced, but maybe).
For everything else, prioritizing figuring out what we&#39;re <em>doing</em> makes more sense than optimizing for full utilization of time.</p>

<p>One of the best pieces of advice in this paper (not that I&#39;m biased, having <a href="https://blog.computationalcomplexity.org/blog/throw-away-your-first-draft/">written something similar</a>) is to write it <em>twice</em>.
The first version should be a fast version to learn what we&#39;re doing and gain real-world insight.
Then the second version is the final draft that goes to the customer and should meet requirements.</p>
<p>This is great, because it highlights what we run into all the time: we don&#39;t know if our solutions work until we try them.
We don&#39;t really know <em>what the problem is</em> until we try to solve it.
Having multiple iterations is a fantastic way to try things, learn those hard lessons, and still have time in the schedule to fix everything.</p>
<p>The recommendation to do it twice, in full, I think is interesting and is something to aspire to.
It&#39;s easier to advocate for small iterations and small throw-away prototypes, and those are super valuable.
If you take nothing else away from this paper, go try doing a throw-away version first.</p>

<p>It&#39;s always a little bit of a shock going back and reading a paper from the 70s.
Every single pronoun is &#34;he&#34; or &#34;his,&#34; and that just really grates.
Not every person on a tech project is a boy, you know.</p>
<p>The norm in tech has pretty well shifted as far as I see.
There&#39;s still <em>plenty</em> of sexism to go around, but there&#39;s less blatant gendered language at least.
We&#39;ve got a long way to go, and sometimes reading papers from the past is nice to remind us of how the norms <em>have</em> changed.</p>
<p>Let&#39;s let this remind us that change is possible.
Collectively, we&#39;ve shifted away from default he/him pronouns for anonymous people.
We can continue to make a more equitable world.
It&#39;s going to take a while, it&#39;s going to hurt, and it&#39;s worth fighting for it ❤️.</p>
<hr/>
<p>As a historical artifact, Royce&#39;s paper gives a lot of interesting insights.
It&#39;s cool to see some of the things he discusses in here be fully realized, and to see other ways in which our field has transcended where it was in the 70s.</p>
<hr/>

</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://blog.computationalcomplexity.org/newsletter">newsletter</a> or use the <a href="https://blog.computationalcomplexity.org/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
