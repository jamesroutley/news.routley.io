<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/fks/">Original</a>
    <h1>Fly Kubernetes</h1>
    
    <div id="readability-page-1" class="page"><article>
         <dl>
             <dt>Author</dt>
             <dd>
                 <img alt="Senyo Simpson" src="https://ntietz.com/static/images/senyo.webp"/>
               <dl>
                 <dt>Name</dt>
                 <dd>
                   Senyo Simpson
                 </dd>
               </dl>
             </dd>
         </dl>

        <section>
            <figure>
                <img src="https://ntietz.com/blog/fks/assets/fks-cover.webp" alt="Frankie, or Linda (I can&#39;t tell who&#39;s who), the Fly.io hot-air balloon mascot, at the helm of a sailing ship. The ocean is rolling with waves, and two shark fins are visible in pursuit of the ship. There are some unreasonably happy-looking smaller fish leaping out of the water around the ship. Frankie or Linda looks pretty chill and content."/>
                <figcaption>
                  <span>Image by</span>
                  
<svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd">
  <g buffered-rendering="static">
    <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path>
  </g>
</svg>

                    <a href="https://annieruygtillustration.com/" target="_blank">
                      Annie Ruygt
                    </a>
                </figcaption>
            </figure>
          <p>We’re Fly.io, and if you’ve been following us awhile you probably just did a double-take. We’re building a new public cloud that runs containerized applications with virtual machine isolation on our own hardware around the world. And we’ve been doing it without any K8s. Until now!</p>
<p>We’ll own it: we’ve been snarky about Kubernetes. We are, at heart, old-school Unix nerds. We’re still scandalized by <code>systemd</code>.</p>

<p>To make matters more complicated, the problems we’re working on <a href="https://fly.io/blog/carving-the-scheduler-out-of-our-orchestrator/">have a lot of overlap with K8s</a>, but <a href="https://fly.io/blog/carving-the-scheduler-out-of-our-orchestrator/#numad">just enough impedance mismatch</a> that it (<a href="https://www.nomadproject.io/">or anything that looks like it</a>) is a bad fit for our own platform.</p>

<p>But, come on: you never took us too seriously about K8s, right? K8s is hard for us to use, but that doesn’t mean it’s not a great fit for what you’re building. We’ve been clear about that all along, right? Sure we have!</p>

<p>Well, good news, everybody! If K8s is important for your project, and that’s all that’s been holding you back from <a href="https://fly.io/docs/speedrun/">trying out Fly.io</a>, we’ve spent the past several months building something for you.</p>
<h2 id="fly-io-for-kubernetians"><a href="#fly-io-for-kubernetians" aria-label="Anchor"></a>Fly.io For Kubernetians</h2>
<p>Fly.io works by transmogrifying Docker containers into filesystems for <a href="https://firecracker-microvm.github.io/">lightweight hypervisors</a>, and running them on servers we rack in dozens of regions around the world.</p>

<p>You can build something like Fly.io with “standard” orchestration tools like K8s. In fact, that’s what we did to start, too. To keep things simple, we used Nomad, and instead of K8s CNIs, we built our own Rust-based TLS-terminating Anycast proxy (and designed a WireGuard/IPv6-based private network system <a href="https://fly.io/blog/bpf-xdp-packet-filters-and-udp/">based on eBPF</a>). But the ideas are the same.</p>

<p>The way we look at it, the signature feature of a “standard” orchestrator is the global scheduler: the global eye in the sky that keeps track of vacancies on servers and optimized placement of new workloads. That’s the problem we ran into. We’re running over 200,000 applications, and we’re doing so on every continent except Antarctica. The speed of light (and a globally distributed network of backhoes) has something to say about keeping a perfectly consistent global picture of hundreds of thousands of applications, and it’s not pleasant.</p>

<p>The other problem we ran into is that our Nomad scheduler kept trying to outsmart us, and, worse, our customers. It turns out that our users have pretty firm ideas of where they’d like their apps to run. If they ask for São Paulo, they want São Paulo, not Rio. But global schedulers have other priorities, like optimally bin-packing resources, and sometimes <code>GIG</code> looks just as good as <code>GRU</code> to them.</p>

<p>To escape the scaling and DX problems we were hitting, we rethought orchestration. Where orchestrators like K8s tend to work through distributed consensus, we keep state local to workers. Each racked server in our fleet is a source of truth about the apps running on it, and provide an API to a market-style “scheduler” that bids on resources in regions. <a href="https://fly.io/blog/carving-the-scheduler-out-of-our-orchestrator/#numad">You can read more about here, if you’re interested.</a> We call this system the <a href="https://fly.io/docs/machines/">Fly Machines API.</a></p>

<p>An important detail to grok about how this all works – a reason we haven’t, like, beaten the CAP theorem by doing this – is that Fly Machines API calls can fail. If Nomad or K8s tries to place a workload on some server, only to find out that it’s filled up or thrown a rod, it will go hunt around for some other place to put it, like a good little robot. The Machines API won’t do this. It’ll just fail the request. In fact, it goes out of its way to fail the request quickly, to deliver feedback; if we can’t schedule work in <code>JNB</code> right now, you might want instead to quickly deploy to <code>BOM</code>.</p>
<h2 id="pluggable-orchestration-and-fks"><a href="#pluggable-orchestration-and-fks" aria-label="Anchor"></a>Pluggable Orchestration and FKS</h2>
<p>In a real sense what we’ve done here is extract a chunk of the scheduling problem out of our orchestrator, and handed it off to other components. For most of our users, that component is <a href="https://github.com/superfly/flyctl"><code>flyctl</code>, our intrepid CLI</a>.</p>

<p>But <a href="https://fly.io/docs/machines/working-with-machines/">Fly Machines is an API</a>, and anything can drive it. A lot of our users want quick answers to requests to schedule apps in specific regions, and <code>flyctl</code> does a fine job of that. But it’s totally reasonable to want something that works more like the good little robots inside of K8s.</p>

<p>You can build your own orchestrator with our API, but if what you’re looking for is literally Kubernetes, we’ve saved you the trouble. It’s called Fly Kubernetes, or FKS for short.</p>

<p>FKS is an implementation of Kubernetes that runs on top of Fly.io. You start it up using <code>flyctl</code>, by running <code>flyctl ext k8s create</code>.</p>

<p>Under the hood, FKS is a straightforward combination of two well-known Kubernetes projects: <a href="https://k3s.io/">K3s, the lightweight CNCF-certified K8s distro</a>, and <a href="https://virtual-kubelet.io/">Virtual Kubelet</a>.</p>

<p>Virtual Kubelet is interesting. In K8s-land, a <code>kubelet</code> is a host agent; it’s the thing that runs on every server in your fleet that knows how to run a K8s Pod. Virtual Kubelet isn’t a host agent; it’s a software component that pretends to be a host, registering itself with K8s as if it was one, but then sneakily proxying the Kubelet API elsewhere.</p>

<p>In FKS, “elsewhere” is <a href="https://fly.io/docs/machines/">Fly Machines</a>. All we have to do is satisfy various APIs that virtual kubelet exposes. For example, the API for the lifecycle of a pod:</p>
<div>
  <pre><code>type PodLifecycleHandler interface {
    CreatePod(ctx context.Context, pod *corev1.Pod) error
    UpdatePod(ctx context.Context, pod *corev1.Pod) error
    DeletePod(ctx context.Context, pod *corev1.Pod) error
    GetPod(ctx context.Context, namespace, name string) (*corev1.Pod, error)
    GetPodStatus(ctx context.Context, namespace, name string) (*corev1.PodStatus, error)
    GetPods(context.Context) ([]*corev1.Pod, error)
}
</code></pre>
</div>

<p>This interface is easy to map to the Fly Machines API. For example:</p>
<div>
  <pre><code>CreatePod -&gt; POST /apps/{app_name}/machines
UpdatePod -&gt; POST /apps/{app_name}/machines/{machine_id}
</code></pre>
</div>

<p>K3s, meanwhile, is a stripped-down implementation of all of K8s that fits into a single binary. K3s does a bunch of clever things to be as streamlined as it is, but the most notable of them is <a href="https://github.com/k3s-io/kine">kine, an API shim that switches <code>etcd</code> out with databases like SQLite</a>. Because of <code>kine</code>, K3s can manage multiple servers, but also gracefully runs on a single server, without distributed state.</p>

<p>So that’s what we do. When you create a cluster, we run K3s and the Virtual Kubelet on a single Fly Machine. We compile a <a href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a>, with which you can talk to your K3s via <code>kubectl</code>. We set the whole thing up to run Pods on individual Fly Machines, so your cluster scales out directly using our platform, but with K8s tooling.</p>

<p>One thing we like about this design is how much of the lifting is already done for us by the underlying platform. If you’re a K8s person, take a second to think of all the different components you’re dealing with: <a href="https://etcd.io/">etcd</a>, specifically provisioned nodes, the <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a>, <a href="https://github.com/flannel-io/flannel">a CNI </a>binary and configuration and its integration with the host network, containerd, registries. But Fly.io already does most of those things. So this project was mostly chipping away components until we found the bare minumum: CoreDNS, SQLite persistence, and Virtual Kubelet.</p>

<p>We ended up with something significantly simpler than K3s, which is saying something.</p>

<p>Fly Kubernetes has some advantages over plain <code>flyctl</code> and <code>fly.toml</code>:</p>

<ul>
<li>Your deployment is more declarative than it is with the <code>fly.toml</code> file. You declare the exact state of everything down to replica counts, autoscaling rules, volume definitions, and more.
</li><li>When you deploy with Fly Kubernetes, Kubernetes will automatically make your definitions match the state of the world. Machines go down? Kubernetes will whack them back online.
</li></ul>

<p>This is a different way to do orchestration and scheduling on Fly.io. It’s not what everyone is going to want. But if you want it, you really want it, and we’re psyched to give it to you: Fly.io’s platform features, with Kubernetes handling configuration and driving your system to its desired state.</p>

<p>We’ve kept things simple to start with. There are K8s use cases we’re a strong fit for today, and others we’ll get better at in the near future, as K8s users drive the underlying platform (and particularly our proxy) forward.</p>

<p><strong>Interested in getting early access? Email us at <a href="mailto:sales@fly.io">sales@fly.io</a> and we’ll hook you up.</strong></p>
<figure>
  <figcaption>
    
    <p>Nothing has to change for you! You can deploy apps on Fly.io today, in a matter of minutes, without talking to Sales.</p>
      <a href="https://fly.io/docs/speedrun/">
        Deploy an app in minutes.<span>→</span>
      </a>
  </figcaption>
  <p><img src="https://ntietz.com/static/images/cta-turtle.webp" srcset="/static/images/cta-turtle@2x.webp 2x" alt=""/>
  </p>
</figure>

<div><p>
          <iframe width="100%" height="100%" src="https://www.youtube.com/embed/A3vFfZvUiwo" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">
          </iframe>
        </p>
</div>

<h2 id="what-it-all-means"><a href="#what-it-all-means" aria-label="Anchor"></a>What It All Means</h2>
<p>One obvious thing it means is that you’ve got an investment in Kubernetes tooling, you can keep it while running things on top of Fly.io. So that’s pretty neat. Buy our cereal!</p>

<p>But the computer science story is interesting, too. We placed a bet on an idiosyncratic strategy for doing global orchestration. We replaced global consensus, which is how Borg, Kubernetes, and Nomad all work, with a market-based system. That system was faster and, importantly, dumber than the consensus system it replaced.</p>

<p>This had costs! Nomad’s global consensus would do truly heroic amounts of work to make sure Fly Apps got scheduled somewhere, anywhere. Like a good capitalist, Fly Machines will tell you in no uncertain terms how much work it’s willing to do for you (“less than a Nomad”).</p>

<p>But that doesn’t mean you’re stuck with the answers Fly Machines gives by itself. Because Fly Machines is so simple, and tries so hard to be predictable, we hoped you’d be able to build more sophisticated scheduling and orchestration schemes on top of it. And here you go: Kubernetes scheduling, as a plugin to the platform.</p>

<p>More to come! We’re itching to see just how many different ways this bet might pay off. Or: we’ll perish in flames! Either way, it’ll be fun to watch.</p>

          
        </section>
        <dl>
            <dt>
              Previous post  ↓
            </dt>
            <dd>
              <a href="https://ntietz.com/blog/fly-io-has-gpus-now/">
                Fly.io has GPUs now
              </a>
            </dd>
        </dl>
      </article></div>
  </body>
</html>
