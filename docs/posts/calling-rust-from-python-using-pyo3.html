<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/">Original</a>
    <h1>Calling Rust from Python using PyO3</h1>
    
    <div id="readability-page-1" class="page"><article role="main">
        <p>Calling Rust code from Python is made easy by <a href="https://github.com/PyO3/pyo3">PyO3</a>. You can write a Rust library and rely on the combination of PyO3 and <code>maturin</code>, a supporting tool from the <code>PyO3</code> ecosystem, to compile the Rust library and have it installed directly as a Python module. Among others, PyO3 can translate types between Python and Rust as well as make it easy to export Rust functions to Python through a set of macros.</p>

<p>In this blog post, I will give a short introduction to PyO3. After that, I will discuss several example functions, written in Rust and called from Python. These examples include:</p>
<ul>
  <li>calculate the n-th Fibonacci in Python as well as in Rust</li>
  <li>having Python use a variety of types in Rust functions</li>
  <li>using a Rust struct in Python code</li>
  <li>using Python to send JSON to Rust and serialize that JSON as a struct</li>
  <li>allow Rust to use the logger from the Python runtime</li>
  <li>generating an Error in Rust and catching it as an exception in Python</li>
</ul>

<h2 id="introduction-to-pyo3">Introduction to PyO3</h2>

<p><img src="https://marinhero.com/learn/img/pyo3_small.png" alt="PyO3 logo" title="PyO3 logo" height="40%" width="40%"/></p>

<p>PyO3 offers some ergonomics for people wanting to glue Rust and Python code together. It helps you calling Python code from Rust as well as calling Rust code from Python. Since I have been using it only to call Rust code from Python, that is the only thing I will write about here.</p>

<p>So what does PyO3 give you?</p>

<p>For starters, there is <a href="https://github.com/PyO3/maturin">maturin</a>. This tool will compile the Rust code for you and install the compiled code as a Python module in your virtual environment. After this, you can import this module in your Python code and use it. After you <b>pip install maturin</b>, you only have to run 1 command (<b>maturin develop</b>) to use the Rust code in Python.</p>

<p>Apart from <code>maturin</code>, there is of course PyO3 itself. PyO3 offers Rust bindings to the Python interpreter. This makes it so that you do not really have to bother that much with the interaction between Python and Rust. For instance, you will not have to worry about how to translate a Python string to something in C, and then something else again in Rust. The same goes for integers, floats, lists, dictionaries, etc.  And to make things convenient, PyO3 comes with a lot of macros that prevent you from having to write too much boilerplate code. To expose Rust functions to Python, you annotate them with a macro. After this, PyO3 will take care of the rest. The same applies in case you want to export a struct or methods.</p>

<h2 id="calling-a-rust-function-from-python">Calling a Rust function from Python</h2>

<p>In this first example, we‚Äôll call a Rust multiplication function from Python. Normally, we could write something like this:</p>

<div><div><pre><code><span>fn</span> <span>multiply</span><span>(</span><span>a</span><span>:</span> <span>isize</span><span>,</span> <span>b</span><span>:</span> <span>isize</span><span>)</span> <span>-&gt;</span> <span>isize</span> <span>{</span>
    <span>a</span> <span>*</span> <span>b</span>
<span>}</span>
</code></pre></div></div>

<p>Without adding too many things, we can make this function callable from Python. For starters, we need to:</p>
<ul>
  <li>bring in the <code>pyo3</code> prelude</li>
  <li>annotate the function with <code>#[pyfunction]</code> to turn it into a PyCFunction</li>
  <li>wrap the result in a <code>PyResult</code></li>
  <li>add the function to the <code>#[pymodule]</code></li>
</ul>

<p>The following code follows illustrates the above steps in the same order:</p>

<div><div><pre><code><span>use</span> <span>pyo3</span><span>::</span><span>prelude</span><span>::</span><span>*</span><span>;</span>

<span>#[pyfunction]</span>
<span>fn</span> <span>multiply</span><span>(</span><span>a</span><span>:</span> <span>isize</span><span>,</span> <span>b</span><span>:</span> <span>isize</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>isize</span><span>&gt;</span> <span>{</span>
    <span>Ok</span><span>(</span><span>a</span> <span>*</span> <span>b</span><span>)</span>
<span>}</span>

<span>#[pymodule]</span>
<span>fn</span> <span>rust</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>m</span><span>.add_function</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>multiply</span><span>,</span> <span>m</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>
    <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div></div>

<p>The above will expose the multiply function in a Python module called <code>rust</code> (after the name of the last function). We also need to put in place the proper <a href="https://github.com/saidvandeklundert/pyo3/blob/main/multiply/Cargo.toml">Cargo.toml</a> file.</p>

<p>To make things easy, make sure that the name of the library in Cargo.toml matches the name of the function that was annotated with <code>#[pymodule]</code>. In my example, I put the following in my <code>Cargo.toml</code>:</p>

<pre>[lib]
name = &#34;rust&#34;
</pre>

<p>When these two names match, the <code>maturin</code> build tool will install the Rust library as a Python module using that name.</p>

<p>So, in this case, having chosen <code>rust</code> as the name of the package, we can write the following Python to call the multiply function:</p>
<div><div><pre><code><span>import</span> <span>rust</span>

<span>result</span> <span>=</span> <span>rust</span><span>.</span><span>multiply</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span>
<span>print</span><span>(</span><span>result</span><span>)</span>
</code></pre></div></div>

<p>To be able to run this code, we need to compile the Rust code and install it as a Python library. This is where <code>maturin</code> comes in:</p>

<pre>root@rust:/# <b>git clone https://github.com/saidvandeklundert/pyo3.git</b>
Cloning into &#39;pyo3&#39;...
remote: Enumerating objects: 36, done.
    ...
Resolving deltas: 100% (9/9), done.
root@rust:/# cd pyo3/multiply/
root@rust:/pyo3/multiply# python3 -m venv .env
root@rust:/pyo3/multiply# source .env/bin/activate
(.env) root@rust:/pyo3/multiply# <b>pip install maturin</b>
Collecting maturin
    ...
Installing collected packages: toml, maturin
Successfully installed maturin-0.11.5 toml-0.10.2
(.env) root@rust:/pyo3/multiply# <b>maturin develop</b>
üîó Found pyo3 bindings
üêç Found CPython 3.9 at python
   Compiling proc-macro2 v1.0.32
    ...
   Compiling multiply v0.1.0 (/pyo3/multiply)
    Finished dev [unoptimized + debuginfo] target(s) in 23.48s
(.env) root@rust:/pyo3/multiply# <b>python3 multiply.py</b>
6
</pre>

<p>That was it!</p>

<p>Now I can run <a href="https://github.com/saidvandeklundert/pyo3/blob/main/multiply/multiply.py">this</a> script:</p>

<pre>(.env) root@rust: multiply# python3 multiply.py
6
</pre>

<h2 id="calculating-the-n-th-fibonacci-number-in-python-and-in-rust">Calculating the n-th Fibonacci number in Python and in Rust</h2>

<p>To calculate the n-th Fibonacci number, I will use a Python and Rust function that are very similar to each other. The following is the Python function:</p>

<div><div><pre><code><span>def</span> <span>get_fibonacci</span><span>(</span><span>number</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
    <span>&#34;&#34;&#34;Get the nth Fibonacci number.&#34;&#34;&#34;</span>
    <span>if</span> <span>number</span> <span>==</span> <span>1</span><span>:</span>
        <span>return</span> <span>1</span>
    <span>elif</span> <span>number</span> <span>==</span> <span>2</span><span>:</span>
        <span>return</span> <span>2</span>

    <span>total</span> <span>=</span> <span>0</span>
    <span>last</span> <span>=</span> <span>0</span>
    <span>current</span> <span>=</span> <span>1</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>number</span><span>):</span>
        <span>total</span> <span>=</span> <span>last</span> <span>+</span> <span>current</span>
        <span>last</span> <span>=</span> <span>current</span>
        <span>current</span> <span>=</span> <span>total</span>
    <span>return</span> <span>total</span>
</code></pre></div></div>

<p>To add the Rust equivalent, we need to do the following:</p>
<ul>
  <li>create the function in our <code>lib.rs</code></li>
  <li>annotate the function with <code>#[pyfunction]</code></li>
  <li>add the function to the module</li>
</ul>

<p>This is illustrated in the following code snippet:</p>

<div><div><pre><code><span>#[pyfunction]</span>
<span>fn</span> <span>get_fibonacci</span><span>(</span><span>number</span><span>:</span> <span>isize</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>u128</span><span>&gt;</span> <span>{</span>
    <span>if</span> <span>number</span> <span>==</span> <span>1</span> <span>{</span>
        <span>return</span> <span>Ok</span><span>(</span><span>1</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>number</span> <span>==</span> <span>2</span> <span>{</span>
        <span>return</span> <span>Ok</span><span>(</span><span>2</span><span>);</span>
    <span>}</span>

    <span>let</span> <span>mut</span> <span>sum</span> <span>=</span> <span>0</span><span>;</span>
    <span>let</span> <span>mut</span> <span>last</span> <span>=</span> <span>0</span><span>;</span>
    <span>let</span> <span>mut</span> <span>curr</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>_</span> <span>in</span> <span>1</span><span>..</span><span>number</span> <span>{</span>
        <span>sum</span> <span>=</span> <span>last</span> <span>+</span> <span>curr</span><span>;</span>
        <span>last</span> <span>=</span> <span>curr</span><span>;</span>
        <span>curr</span> <span>=</span> <span>sum</span><span>;</span>
    <span>}</span>
    <span>Ok</span><span>(</span><span>sum</span><span>)</span>
<span>}</span>

<span>#[pymodule]</span>
<span>fn</span> <span>rust</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>m</span><span>.add_function</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>get_fibonacci</span><span>,</span> <span>m</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>
    <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div></div>

<p>After pulling in the new code, we can use maturin to build and install the module and do a comparison:</p>

<pre>(.env) root@rust:/pyo3/pyo3# <b>maturin develop</b>
(.env) root@rust:/pyo3/pyo3# <b>python -i</b>
Python 3.9.2 (default, Feb 28 2021, 17:03:44) 
[GCC 10.2.1 20210110] on linux
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.    
&gt;&gt;&gt; <b>import timeit</b>
&gt;&gt;&gt;
&gt;&gt;&gt; <b>timeit.timeit(&#34;get_fibonacci(5)&#34;, setup=&#34;from fib import get_fibonacci&#34;)</b>
0.49461510000401177
&gt;&gt;&gt;
&gt;&gt;&gt; <b>timeit.timeit(&#34;get_fibonacci(5)&#34;, setup=&#34;from rust import get_fibonacci&#34;)</b>
1.1281064000068
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; <b>timeit.timeit(&#34;get_fibonacci(150)&#34;, setup=&#34;from fib import get_fibonacci&#34;)</b>
9.057604000001447
&gt;&gt;&gt; <b>timeit.timeit(&#34;get_fibonacci(150)&#34;, setup=&#34;from rust import get_fibonacci&#34;)</b>
3.5204217999998946
</pre>

<p>The above tells us that when we call the function to calculate the 5-th Fibonacci number, Python is faster. But when we look for the 150th Fibonacci number, Rust is almost three times faster.</p>

<p>But it gets better.</p>

<p>We can also do a release build by adding <code>--release</code> as an argument to maturin:</p>

<pre>(.env) root@rust:/pyo3/pyo3# <b>python -i</b>
Python 3.9.2 (default, Feb 28 2021, 17:03:44) 
[GCC 10.2.1 20210110] on linux
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.    
&gt;&gt;&gt; <b>import timeit</b>
&gt;&gt;&gt; timeit.timeit(&#34;get_fibonacci(5)&#34;, setup=&#34;from fib import get_fibonacci&#34;)
0.4583319000012125
&gt;&gt;&gt; timeit.timeit(&#34;get_fibonacci(5)&#34;, setup=&#34;from rust import get_fibonacci&#34;)
0.11867309999797726
&gt;&gt;&gt; timeit.timeit(&#34;get_fibonacci(150)&#34;, setup=&#34;from fib import get_fibonacci&#34;)
8.990601400000742
&gt;&gt;&gt; timeit.timeit(&#34;get_fibonacci(150)&#34;, setup=&#34;from rust import get_fibonacci&#34;)
0.15236040000309004
&gt;&gt;&gt;
</pre>

<p>With the release build, the Rust function is a lot faster in both cases.</p>

<p>I have also compared a lot of other functions. Scanning a text for a substring, manipulating texts, summing up numbers and a variety of other things. I have found that this type of performance increase is not that typical. Getting things to speed up 2x or 3x is usually not that hard.</p>

<h2 id="working-with-different-types">Working with different types</h2>

<p>When calling Rust function, PyO3 will convert the Python type you pass as function arguments to Rust types for you. It also converts the Rust types that Rust functions return to types that are usable in Python. The PyO3 user guide describes the way the <a href="https://pyo3.rs/main/conversions/tables.html">mapping</a> between the Python types and the Rust types is done. Having PyO3 do this automatically for you makes it easy to work with function arguments of different types. Next up are a few examples to illustrate this.</p>

<h3 id="returning-the-sum-of-the-numbers-in-a-list">returning the sum of the numbers in a list:</h3>

<p>The following function will sum the numbers in a vector and return the result:</p>

<div><div><pre><code><span>#[pyfunction]</span>
<span>fn</span> <span>list_sum</span><span>(</span><span>a</span><span>:</span> <span>Vec</span><span>&lt;</span><span>isize</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>isize</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>mut</span> <span>sum</span><span>:</span> <span>isize</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>i</span> <span>in</span> <span>a</span> <span>{</span>
        <span>sum</span> <span>+=</span> <span>i</span><span>;</span>
    <span>}</span>
    <span>Ok</span><span>(</span><span>sum</span><span>)</span>
<span>}</span>

<span>#[pymodule]</span>
<span>fn</span> <span>rust</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>m</span><span>.add_function</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>list_sum</span><span>,</span> <span>m</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>
    <span>Ok</span><span>(())</span>
<span>}</span>    
</code></pre></div></div>

<p>When we call this function in Python, we can pass in a list of integers and we get a Python integer in return:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>list_sum</span><span>([</span><span>10</span><span>,</span> <span>10</span><span>,</span> <span>10</span><span>,</span> <span>10</span><span>,</span> <span>10</span><span>])</span>
<span>50</span>
</code></pre></div></div>

<p>Let‚Äôs do one last performance comparison. In this case, we can see that it only makes sense to try and speed things up if the function has to perform a lot of computations. The following example shows the difference in performance with a small input to the function:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>timeit</span><span>.</span><span>timeit</span><span>(</span><span>&#34;rust.list_sum(a_list)&#34;</span><span>,</span> <span>setup</span><span>=</span><span>&#34;&#34;&#34;
... import rust
... a_list = [x for x in range(1,10)]
... &#34;&#34;&#34;</span><span>)</span>
<span>0.42956949999643257</span>
<span>&gt;&gt;&gt;</span>
<span>&gt;&gt;&gt;</span> <span>timeit</span><span>.</span><span>timeit</span><span>(</span><span>&#34;sum_list(a_list)&#34;</span><span>,</span> <span>setup</span><span>=</span><span>&#34;&#34;&#34;
... from __main__ import sum_list
... a_list = [x for x in range(1,10)]
... &#34;&#34;&#34;</span><span>)</span>
<span>0.4579178999993019</span>
</code></pre></div></div>

<p>Hardly any difference. Now, when we increase the function input to 3.000 numbers, we can start seeing some real advantage over using the Rust function:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>timeit</span><span>.</span><span>timeit</span><span>(</span><span>&#34;sum_list(a_list)&#34;</span><span>,</span> <span>setup</span><span>=</span><span>&#34;&#34;&#34;
... from __main__ import sum_list
... a_list = [x for x in range(1,3000)]
... &#34;&#34;&#34;</span><span>)</span>
<span>168.12326449999819</span>
<span>&gt;&gt;&gt;</span> <span>timeit</span><span>.</span><span>timeit</span><span>(</span><span>&#34;rust.list_sum(a_list)&#34;</span><span>,</span> <span>setup</span><span>=</span><span>&#34;&#34;&#34;
... import rust
... a_list = [x for x in range(1,3000)]
... &#34;&#34;&#34;</span><span>)</span>
<span>95.2027356000035</span>
<span>&gt;&gt;&gt;</span>
</code></pre></div></div>

<p>Key takeaway is that how much you‚Äôll be able to speed things up really depends on what part of the code you outsource from Python to Rust. I‚Äôll skip any further comparisons between Rust and Python and focus on a few more scenario‚Äôs that I think are worthwhile.</p>
<h3 id="printing-the-values-of-a-dict">printing the values of a dict:</h3>

<p>The next function will print the key and the values of a HashMap:</p>

<div><div><pre><code><span>use</span> <span>std</span><span>::</span><span>collections</span><span>::</span><span>HashMap</span><span>;</span>

<span>#[pyfunction]</span>
<span>fn</span> <span>dict_printer</span><span>(</span><span>hm</span><span>:</span> <span>HashMap</span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>key</span><span>,</span> <span>value</span><span>)</span> <span>in</span> <span>hm</span> <span>{</span>
        <span>println!</span><span>(</span><span>&#34;{} {}&#34;</span><span>,</span> <span>key</span><span>,</span> <span>value</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>#[pymodule]</span>
<span>fn</span> <span>rust</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>m</span><span>.add_function</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>dict_printer</span><span>,</span> <span>m</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>

    <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div></div>

<p>We can now call this function from Python, passing in a dictionary that is working with the same types:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>a_dict</span> <span>=</span> <span>{</span>
<span>...</span>     <span>&#34;key 1&#34;</span><span>:</span> <span>&#34;value 1&#34;</span><span>,</span>
<span>...</span>     <span>&#34;key 2&#34;</span><span>:</span> <span>&#34;value 2&#34;</span><span>,</span>
<span>...</span>     <span>&#34;key 3&#34;</span><span>:</span> <span>&#34;value 3&#34;</span><span>,</span>
<span>...</span>     <span>&#34;key 4&#34;</span><span>:</span> <span>&#34;value 4&#34;</span><span>,</span>
<span>...</span> <span>}</span>
<span>&gt;&gt;&gt;</span>
<span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>dict_printer</span><span>(</span><span>a_dict</span><span>)</span>
<span>key</span> <span>2</span> <span>value</span> <span>2</span>
<span>key</span> <span>1</span> <span>value</span> <span>1</span>
<span>key</span> <span>3</span> <span>value</span> <span>3</span>
<span>key</span> <span>4</span> <span>value</span> <span>4</span>
</code></pre></div></div>

<p>Note that the HashMap in Rust is different from a Python dictionary. Since we defined the Rust HashMap to use Strings for both key as well as value, we have to do the same thing in our Python code. If we use any other type as key or value, the function call will fail. Rust will try and coerce a type into another:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>try</span><span>:</span>
<span>...</span>     <span>rust</span><span>.</span><span>dict_printer</span><span>({</span><span>&#34;a&#34;</span><span>:</span> <span>1</span><span>,</span> <span>&#34;b&#34;</span><span>:</span> <span>2</span><span>})</span>
<span>...</span> <span>except</span> <span>TypeError</span> <span>as</span> <span>e</span><span>:</span>
<span>...</span>     <span>print</span><span>(</span><span>f</span><span>&#34;Caught a type error: </span><span>{</span><span>e</span><span>}</span><span>&#34;</span><span>)</span>
<span>...</span>
<span>Caught</span> <span>a</span> <span>type</span> <span>error</span><span>:</span> <span>argument</span> <span>&#39;hm&#39;</span><span>:</span> <span>&#39;int&#39;</span> <span>object</span> <span>cannot</span> <span>be</span> <span>converted</span> <span>to</span> <span>&#39;PyString&#39;</span>
<span>&gt;&gt;&gt;</span>
</code></pre></div></div>

<h3 id="printing-a-word-n-times">printing a word n times</h3>

<p>The following function will print a word several times. Additionally, it can also print the word in reverse and/or in uppercase:</p>

<div><div><pre><code><span>#[pyfunction]</span>
<span>fn</span> <span>word_printer</span><span>(</span><span>mut</span> <span>word</span><span>:</span> <span>String</span><span>,</span> <span>n</span><span>:</span> <span>isize</span><span>,</span> <span>reverse</span><span>:</span> <span>bool</span><span>,</span> <span>uppercase</span><span>:</span> <span>bool</span><span>)</span> <span>{</span>
    <span>if</span> <span>reverse</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>reversed_word</span> <span>=</span> <span>String</span><span>::</span><span>new</span><span>();</span>
        <span>for</span> <span>c</span> <span>in</span> <span>word</span><span>.chars</span><span>()</span><span>.rev</span><span>()</span> <span>{</span>
            <span>reversed_word</span><span>.push</span><span>(</span><span>c</span><span>);</span>
        <span>}</span>
        <span>word</span> <span>=</span> <span>reversed_word</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>uppercase</span> <span>{</span>
        <span>word</span> <span>=</span> <span>word</span><span>.to_uppercase</span><span>();</span>
    <span>}</span>
    <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>n</span> <span>{</span>
        <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>word</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The example is a bit lame, but it shows that writing functions that take in a variety of types as arguments is not too difficult:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>word_printer</span><span>(</span><span>&#34;hello&#34;</span><span>,</span> <span>3</span><span>,</span> <span>False</span><span>,</span> <span>True</span><span>)</span>
<span>HELLO</span>
<span>HELLO</span>
<span>HELLO</span>
<span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>word_printer</span><span>(</span><span>&#34;eyb&#34;</span><span>,</span> <span>2</span><span>,</span> <span>True</span><span>,</span> <span>False</span><span>)</span>        
<span>bye</span>
<span>bye</span>
</code></pre></div></div>

<h2 id="using-a-rust-struct-in-python">Using a Rust struct in Python</h2>

<p>Much to my surprise, PyO3 also makes it increadibly easy to use a Rust struct in Python. Though I have not exhausted or tested all possibilities and corner-cases, using a struct with several methods is also pretty straightforward. I made the following example:</p>

<div><div><pre><code><span>#[pyclass]</span>
<span>pub</span> <span>struct</span> <span>RustStruct</span> <span>{</span>
    <span>#[pyo3(get,</span> <span>set)]</span>
    <span>pub</span> <span>data</span><span>:</span> <span>String</span><span>,</span>
    <span>#[pyo3(get,</span> <span>set)]</span>
    <span>pub</span> <span>vector</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
<span>}</span>
<span>#[pymethods]</span>
<span>impl</span> <span>RustStruct</span> <span>{</span>
    <span>#[new]</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span><span>data</span><span>:</span> <span>String</span><span>,</span> <span>vector</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>RustStruct</span> <span>{</span>
        <span>RustStruct</span> <span>{</span> <span>data</span><span>,</span> <span>vector</span> <span>}</span>
    <span>}</span>
    <span>pub</span> <span>fn</span> <span>printer</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>{</span>
        <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>self</span><span>.data</span><span>);</span>
        <span>for</span> <span>i</span> <span>in</span> <span>&amp;</span><span>self</span><span>.vector</span> <span>{</span>
            <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>i</span><span>);</span>
        <span>}</span>
    <span>}</span>
    <span>pub</span> <span>fn</span> <span>extend_vector</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>extension</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>)</span> <span>{</span>
        <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>self</span><span>.data</span><span>);</span>
        <span>for</span> <span>i</span> <span>in</span> <span>extension</span> <span>{</span>
            <span>self</span><span>.vector</span><span>.push</span><span>(</span><span>i</span><span>);</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
<span>#[pymodule]</span>
<span>fn</span> <span>rust</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>m</span><span>.add_class</span><span>::</span><span>&lt;</span><span>RustStruct</span><span>&gt;</span><span>()</span><span>?</span><span>;</span>

    <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div></div>

<p>Notice the use of 4 new annotations:</p>
<ul>
  <li><code>#[pyclass]</code>: above the struct definition, used to expose the class in Python.</li>
  <li><code>#[pymethods]</code>: above the <code>impl</code> block, used to expose the struct methods in Python as class methods.</li>
  <li><code>#[pyo3(get, set)]</code>: use these macros in case you want to be able to get or set the struct fields in Python.</li>
  <li><code>#[new]</code>: above the constructor, this is to be able to contstruct the struct as a class in Python.</li>
</ul>

<p>Additionally, we add the struct to the module in a slightly different way. Instead if using the following:</p>

<div><div><pre><code><span>m</span><span>.add_function</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>xxx</span><span>,</span> <span>m</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>
</code></pre></div></div>

<p>We now used the following:</p>

<div><div><pre><code><span>m</span><span>.add_class</span><span>::</span><span>&lt;</span><span>RustStruct</span><span>&gt;</span><span>()</span><span>?</span><span>;</span> <span>// inserted the name of the struct that is to be exported here</span>
</code></pre></div></div>

<p>After running <code>maturin develop</code> again, we are ready to use the struct in our Python. We can use the struct as though it is a Python class:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>rust_struct</span> <span>=</span> <span>rust</span><span>.</span><span>RustStruct</span><span>(</span><span>data</span><span>=</span><span>&#34;some data&#34;</span><span>,</span> <span>vector</span><span>=</span><span>[</span><span>255</span><span>,</span> <span>255</span><span>,</span> <span>255</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>rust_struct</span><span>.</span><span>extend_vector</span><span>([</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>])</span>
<span>Extending</span> <span>the</span> <span>vector</span><span>.</span>
<span>&gt;&gt;&gt;</span> <span>rust_struct</span><span>.</span><span>printer</span><span>()</span>
<span>some</span> <span>data</span>
<span>255</span>
<span>255</span>
<span>255</span>
<span>1</span>
<span>1</span>
<span>1</span>
<span>1</span>
<span>&gt;&gt;&gt;</span> <span>type</span><span>(</span><span>rust_struct</span><span>)</span>
<span>&lt;</span><span>class</span> <span>&#39;</span><span>builtins</span><span>.</span><span>RustStruct</span><span>&#39;&gt;
&gt;&gt;&gt; rust_struct.data
&#39;</span><span>some</span> <span>data</span><span>&#39;
&gt;&gt;&gt; rust_struct.data = &#34;some other data&#34;
&gt;&gt;&gt; rust_struct.data
&#39;</span><span>some</span> <span>other</span> <span>data</span><span>&#39;
</span></code></pre></div></div>

<h2 id="sending-json-over-to-rust">Sending Json over to Rust</h2>

<p>One way to send over complex data structures could be by using JSON. The following example marshals a JSON-string into a Rust struct:</p>

<div><div><pre><code><span>extern</span> <span>crate</span> <span>serde</span><span>;</span>
<span>extern</span> <span>crate</span> <span>serde_json</span><span>;</span>
<span>use</span> <span>serde</span><span>::{</span><span>Deserialize</span><span>,</span> <span>Serialize</span><span>};</span>

<span>#[pyfunction]</span>
<span>fn</span> <span>human_says_hi</span><span>(</span><span>human_data</span><span>:</span> <span>String</span><span>)</span> <span>{</span>
    <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>human_data</span><span>);</span>
    <span>let</span> <span>human</span><span>:</span> <span>Human</span> <span>=</span> <span>serde_json</span><span>::</span><span>from_str</span><span>(</span><span>&amp;</span><span>human_data</span><span>)</span><span>.unwrap</span><span>();</span>

    <span>println!</span><span>(</span>
        <span>&#34;Now we can work with the struct:</span><span>\n</span><span> {:#?}.</span><span>\n</span><span> {} is {} years old.&#34;</span><span>,</span>
        <span>human</span><span>,</span> <span>human</span><span>.name</span><span>,</span> <span>human</span><span>.age</span><span>,</span>
    <span>)</span>
<span>}</span>

<span>#[derive(Debug,</span> <span>Serialize,</span> <span>Deserialize)]</span>
<span>struct</span> <span>Human</span> <span>{</span>
    <span>name</span><span>:</span> <span>String</span><span>,</span>
    <span>age</span><span>:</span> <span>u8</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>On the Python side, I will use Pydantic to send over some Json:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span>
<span>&gt;&gt;&gt;</span> 
<span>&gt;&gt;&gt;</span> <span>class</span> <span>Human</span><span>(</span><span>BaseModel</span><span>):</span>
<span>...</span>     <span>name</span><span>:</span> <span>str</span>
<span>...</span>     <span>age</span><span>:</span> <span>int</span>
<span>...</span>
<span>&gt;&gt;&gt;</span> 
<span>&gt;&gt;&gt;</span> <span>jan</span> <span>=</span> <span>Human</span><span>(</span><span>name</span><span>=</span><span>&#34;Jan&#34;</span><span>,</span> <span>age</span><span>=</span><span>6</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>print</span><span>(</span><span>jan</span><span>.</span><span>json</span><span>())</span>
<span>{</span><span>&#34;name&#34;</span><span>:</span> <span>&#34;Jan&#34;</span><span>,</span> <span>&#34;age&#34;</span><span>:</span> <span>6</span><span>}</span>
<span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>human_says_hi</span><span>(</span><span>jan</span><span>.</span><span>json</span><span>())</span>
<span>{</span><span>&#34;name&#34;</span><span>:</span> <span>&#34;Jan&#34;</span><span>,</span> <span>&#34;age&#34;</span><span>:</span> <span>6</span><span>}</span>
<span>Now</span> <span>we</span> <span>can</span> <span>work</span> <span>with</span> <span>the</span> <span>struct</span><span>:</span>
 <span>Human</span> <span>{</span>
    <span>name</span><span>:</span> <span>&#34;Jan&#34;</span><span>,</span>
    <span>age</span><span>:</span> <span>6</span><span>,</span>
<span>}.</span>
 <span>Jan</span> <span>is</span> <span>6</span> <span>years</span> <span>old</span><span>.</span>
</code></pre></div></div>

<p>This might be abn approach to map a large struct to a datastructure that is similar on the Python side. I used <code>pydantic</code> because it is one of my favourite Python packages. The <code>.json()</code> method I used here convert the class to a JSON string.</p>

<h2 id="have-rust-use-a-logger-from-the-python-runtime">Have Rust use a logger from the Python runtime</h2>

<p>Rust can be made to log using the logger we define in Python. This is possible using <code>pyo3-log</code>. We start off by adding the following to the Cargo.toml`:</p>

<pre>[dependencies]
pyo3-log = &#34;0.5.0&#34;
log = &#34;0.4.14&#34;
</pre>

<p>Next, we create 2 example functions that will log a message:</p>

<div><div><pre><code><span>use</span> <span>log</span><span>::{</span><span>debug</span><span>,</span> <span>error</span><span>,</span> <span>info</span><span>,</span> <span>warn</span><span>};</span>
<span>use</span> <span>pyo3_log</span><span>;</span>

<span>#[pyfunction]</span>
<span>fn</span> <span>log_different_levels</span><span>()</span> <span>{</span>
    <span>error!</span><span>(</span><span>&#34;logging an error&#34;</span><span>);</span>
    <span>warn!</span><span>(</span><span>&#34;logging a warning&#34;</span><span>);</span>
    <span>info!</span><span>(</span><span>&#34;logging an info message&#34;</span><span>);</span>
    <span>debug!</span><span>(</span><span>&#34;logging a debug message&#34;</span><span>);</span>
<span>}</span>

<span>#[pyfunction]</span>
<span>fn</span> <span>log_example</span><span>()</span> <span>{</span>
    <span>info!</span><span>(</span><span>&#34;A log message from {}!&#34;</span><span>,</span> <span>&#34;Rust&#34;</span><span>);</span>
<span>}</span>
<span>#[pymodule]</span>
<span>fn</span> <span>rust</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>pyo3_log</span><span>::</span><span>init</span><span>();</span>

    <span>m</span><span>.add_wrapped</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>log_example</span><span>))</span><span>?</span><span>;</span>
    <span>m</span><span>.add_wrapped</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>log_different_levels</span><span>))</span><span>?</span><span>;</span>

    <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div></div>

<p>Then, after we define a logger in Python, we can use it in Rust:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>import</span> <span>logging</span>
<span>&gt;&gt;&gt;</span> <span>FORMAT</span> <span>=</span> <span>&#34;%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s&#34;</span>
<span>&gt;&gt;&gt;</span> <span>logging</span><span>.</span><span>basicConfig</span><span>(</span><span>format</span><span>=</span><span>FORMAT</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>logging</span><span>.</span><span>getLogger</span><span>().</span><span>setLevel</span><span>(</span><span>logging</span><span>.</span><span>DEBUG</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>logging</span><span>.</span><span>info</span><span>(</span><span>&#34;Logging from the Python code&#34;</span><span>)</span>
<span>INFO</span> <span>root</span> <span>2021</span><span>-</span><span>11</span><span>-</span><span>15</span> <span>20</span><span>:</span><span>24</span><span>:</span><span>46</span><span>,</span><span>979</span> <span>&lt;</span><span>stdin</span><span>&gt;</span><span>:</span><span>1</span> <span>Logging</span> <span>from</span> <span>the</span> <span>Python</span> <span>code</span><span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>log_example</span><span>()</span>
<span>INFO</span> <span>rust</span> <span>2021</span><span>-</span><span>11</span><span>-</span><span>15</span> <span>20</span><span>:</span><span>24</span><span>:</span><span>51</span><span>,</span><span>336</span> <span>lib</span><span>.</span><span>rs</span><span>:</span><span>118</span> <span>A</span> <span>log</span> <span>message</span> <span>from</span> <span>Rust</span><span>!</span>
<span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>log_different_levels</span><span>()</span>
<span>ERROR</span> <span>rust</span> <span>2021</span><span>-</span><span>11</span><span>-</span><span>15</span> <span>20</span><span>:</span><span>24</span><span>:</span><span>55</span><span>,</span><span>212</span> <span>lib</span><span>.</span><span>rs</span><span>:</span><span>110</span> <span>logging</span> <span>an</span> <span>error</span>
<span>WARNING</span> <span>rust</span> <span>2021</span><span>-</span><span>11</span><span>-</span><span>15</span> <span>20</span><span>:</span><span>24</span><span>:</span><span>55</span><span>,</span><span>212</span> <span>lib</span><span>.</span><span>rs</span><span>:</span><span>111</span> <span>logging</span> <span>a</span> <span>warning</span>       
<span>INFO</span> <span>rust</span> <span>2021</span><span>-</span><span>11</span><span>-</span><span>15</span> <span>20</span><span>:</span><span>24</span><span>:</span><span>55</span><span>,</span><span>213</span> <span>lib</span><span>.</span><span>rs</span><span>:</span><span>112</span> <span>logging</span> <span>an</span> <span>info</span> <span>message</span>    
<span>DEBUG</span> <span>rust</span> <span>2021</span><span>-</span><span>11</span><span>-</span><span>15</span> <span>20</span><span>:</span><span>24</span><span>:</span><span>55</span><span>,</span><span>213</span> <span>lib</span><span>.</span><span>rs</span><span>:</span><span>113</span> <span>logging</span> <span>a</span> <span>debug</span> <span>message</span>   
<span>&gt;&gt;&gt;</span>
</code></pre></div></div>

<h2 id="catch-an-exception">Catch an exception</h2>

<p>In this last example, we will raise an error in Rust and catch that as an exception in Python. This part is quite involved, the steps I took are shown after the code snippet:</p>

<div><div><pre><code><span>use</span> <span>std</span><span>::</span><span>fmt</span><span>;</span>

<span>// 1</span>
<span>#[derive(Debug)]</span>
<span>struct</span> <span>MyError</span> <span>{</span>
    <span>pub</span> <span>msg</span><span>:</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>,</span>
<span>}</span>

<span>// 2</span>
<span>impl</span> <span>std</span><span>::</span><span>error</span><span>::</span><span>Error</span> <span>for</span> <span>MyError</span> <span>{}</span>

<span>// 3</span>
<span>impl</span> <span>fmt</span><span>::</span><span>Display</span> <span>for</span> <span>MyError</span> <span>{</span>
    <span>fn</span> <span>fmt</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>f</span><span>:</span> <span>&amp;</span><span>mut</span> <span>fmt</span><span>::</span><span>Formatter</span><span>)</span> <span>-&gt;</span> <span>fmt</span><span>::</span><span>Result</span> <span>{</span>
        <span>write!</span><span>(</span><span>f</span><span>,</span> <span>&#34;Error from Rust: {}&#34;</span><span>,</span> <span>self</span><span>.msg</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>// 4</span>
<span>impl</span> <span>std</span><span>::</span><span>convert</span><span>::</span><span>From</span><span>&lt;</span><span>MyError</span><span>&gt;</span> <span>for</span> <span>PyErr</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span><span>err</span><span>:</span> <span>MyError</span><span>)</span> <span>-&gt;</span> <span>PyErr</span> <span>{</span>
        <span>PyOSError</span><span>::</span><span>new_err</span><span>(</span><span>err</span><span>.to_string</span><span>())</span>
    <span>}</span>
<span>}</span>

<span>#[pyfunction]</span>
<span>// 5</span>
<span>fn</span> <span>greater_than_2</span><span>(</span><span>number</span><span>:</span> <span>isize</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>isize</span><span>,</span> <span>MyError</span><span>&gt;</span> <span>{</span>
    <span>if</span> <span>number</span> <span>&lt;=</span> <span>2</span> <span>{</span>
        <span>return</span> <span>Err</span><span>(</span><span>MyError</span> <span>{</span>
            <span>msg</span><span>:</span> <span>&#34;number is less than or equal to 2&#34;</span><span>,</span>
        <span>});</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>Ok</span><span>(</span><span>number</span><span>);</span>
    <span>}</span>
<span>}</span>

<span>#[pymodule]</span>
<span>fn</span> <span>rust</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>// 6</span>
    <span>m</span><span>.add_function</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>greater_than_2</span><span>,</span> <span>m</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>    

    <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div></div>

<p>1: We define ‚ÄòMyError‚Äô as a custom Error. The struct has a field that is used to be able to send a custom message.
2: The ‚ÄòError‚Äô trait is implemented for ‚ÄòMyError‚Äô.
3: We implement the ‚ÄòDisplay‚Äô trait for ‚ÄòMyError‚Äô and have it display the message from the ‚Äòmsg‚Äô field in the ‚ÄòMyError‚Äô struct.
4: The ‚ÄòFrom‚Äô trait is implemented for ‚ÄòMyError‚Äô. This trait is used to do value-to-value conversions while consuming the input value.
5: We create a function called ‚Äògreater_than_2‚Äô. This function will raise the error/exception in case the input value is 2 or less.
6: We add the function to the Python module in the ‚Äòregular‚Äô way.</p>

<p>Now we move to the Python side and run the function, triggering the exception:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>greater_than_2</span><span>(</span><span>1</span><span>)</span>
<span>Traceback</span> <span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>...</span>
<span>OSError</span><span>:</span> <span>Error</span> <span>from</span> <span>Rust</span><span>:</span> <span>number</span> <span>is</span> <span>less</span> <span>than</span> <span>or</span> <span>equal</span> <span>to</span> <span>2</span>
<span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>greater_than_2</span><span>(</span><span>3</span><span>)</span>
<span>3</span>
<span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>greater_than_2</span><span>(</span><span>11</span><span>)</span>
<span>11</span>
<span>&gt;&gt;&gt;</span> <span>rust</span><span>.</span><span>greater_than_2</span><span>(</span><span>-</span><span>11</span><span>)</span>
<span>Traceback</span> <span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>...</span>
<span>OSError</span><span>:</span> <span>Error</span> <span>from</span> <span>Rust</span><span>:</span> <span>number</span> <span>is</span> <span>less</span> <span>than</span> <span>or</span> <span>equal</span> <span>to</span> <span>2</span>
</code></pre></div></div>

<p>It took quite a bit of code to put that in! Still not too hard in my opinion.</p>

<h2 id="closing-thoughts">Closing thoughts.</h2>

<p>Working with PyO3 and using it to call Rust from Python is a very pleasant experience. I find that the ergonomics that have been put in place make everything a lot easier when compared to relying on <code>ffi</code> or <code>libc</code>. The macros offer a lot of convenience and having PyO3 translate the types between Rust and Python brings a lot of ease to the development process. And then there is the build tool <code>maturin</code>. This is an absolute joy to work with.</p>

<p>The repo is actively maintained, and the documentation is great. After learning about PyO3, I am excited about using Rust in my Python.</p>

<p>The code samples from this blog can be found <a href="https://github.com/saidvandeklundert/pyo3">here</a>. There is also a Docker build file there in case you want to run the code yourself.</p>

<p>Some other worthwhile links in the context of PyO3:</p>
<ul>
  <li><a href="https://github.com/PyO3/pyo3">PyO3 repo</a></li>
  <li><a href="https://pyo3.rs/main/">PyO3 user guide</a></li>
  <li><a href="https://github.com/PyO3/pyo3/blob/main/Architecture.md">PyO3 architecture guide</a></li>
  <li><a href="https://github.com/PyO3/maturin">Maturin repo</a></li>
</ul>


      </article></div>
  </body>
</html>
