<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2024/02/07/production-engineering/simple-precision-time-protocol-sptp-meta/">Original</a>
    <h1>Simple Precision Time Protocol at Meta</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><span>While deploying Precision Time Protocol (PTP) at Meta, we’ve developed a simplified version of the protocol (Simple Precision Time Protocol – SPTP), that can offer the same level of clock synchronization as unicast PTPv2 more reliably and with fewer resources.</span></li>
<li aria-level="1"><span>In our own tests, SPTP boasts comparable performance to PTP, but with significant improvements in CPU, memory, and network utilization.</span></li>
<li aria-level="1"><span>We’ve made the source code for the SPTP client and server available on</span><a href="https://github.com/facebook/time"> <span>GitHub</span></a><span>.</span></li>
</ul>
<p><span>We’ve previously spoken in great detail about</span><a href="https://engineering.fb.com/2022/11/21/production-engineering/precision-time-protocol-at-meta/"> <span>how Precision Time Protocol is being deployed at Meta</span></a><span>, including </span><span>the protocol itself and Meta’s precision time architecture.</span></p>
<p><span>As we deployed PTP into one of our data centers, we were also evaluating and testing alternative PTP clients. In doing so, we soon realized that we could eliminate a lot of complexity in the PTP protocol itself that we experienced during data center deployments while still maintaining complete hardware compatibility with our existing equipment.</span></p>
<p><span>This is how the idea of Simple Precision Time Protocol (SPTP) was born. </span></p>
<p><span>But before we dive under the hood of SPTP we should explore why the IEEE 1588</span><a href="https://www.itu.int/rec/T-REC-G.8265.1/en"> <span>G8265.1</span></a><span> and</span><a href="https://www.itu.int/rec/T-REC-G.8275.2/en"> <span>G8275.2</span></a><span> unicast profiles (here, we just call them PTP) weren’t a perfect fit for our data center deployment.</span></p>
<h2><span>PTP and its limitations</span></h2>
<h3><span>Excessive network communication</span></h3>
<p><span>A typical IEEE 1588-2019 two-step PTPv2 unicast UDP flow consists of the following exchange:</span></p>
<figure id="attachment_20920" aria-describedby="caption-attachment-20920"><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_Image1.png?w=1024" alt="" width="1024" height="562" srcset="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_Image1.png 1024w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_Image1.png?resize=916,503 916w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_Image1.png?resize=768,422 768w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_Image1.png?resize=96,53 96w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_Image1.png?resize=192,105 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-20920">Figure 1: Typical two-step PTPv2 exchange.</figcaption></figure>
<p><span>This sequence repeats either in full or in part depending on the negotiation result. The exchange shown is one of many possible combinations. It may involve additional steps such as grant cancellation, grand cancellation acknowledgements, and so on.</span></p>
<p><span>The frequency of these messages may vary depending on the implementation and configuration. After completing negotiation, the frequency of some messages can change dynamically.</span></p>
<p><span>This design allows for a lot of flexibility, especially for less powerful equipment where resources are limited. In combination with multicast, it allows us to support a relatively large number of clients using either very old or embedded devices. For example, a PTP server can reject the request or confirm a less frequent exchange if the resources are exhausted.</span></p>
<p><span>This design, however, leads to excessive network communication, which is particularly visible on a</span><a href="https://engineering.fb.com/2021/08/11/open-source/time-appliance/"> <span>time appliance</span></a><span> serving a large number of clients.</span></p>
<h3><span>State machine</span></h3>
<p><span>Due to the “subscription” model, both the PTP client and the server have to keep the state in memory. This approach comes with the tradeoffs such as:</span><span><br/>
</span></p>
<ul>
<li aria-level="1"><span>Excessive usage of resources such as memory and CPU.</span></li>
<li aria-level="1"><span>Strict capacity limits that mean multicast support is required for large numbers of clients.</span></li>
<li aria-level="1"><span>Code complexity.</span></li>
<li aria-level="1"><span>Fragile state transitions.</span></li>
</ul>
<p><span>These issues can manifest, for example, in so-called abandoned syncs – situations where the work of a PTP client is interrupted (either forcefully stopped or crashed). Because the PTP server didn’t receive a cancellation signaling message it will keep sending sync and followup packets until the subscription expires (which may take hours). This leads to additional complexity and fragility in the system. </span></p>
<p><span> </span><span>There are additional protocol design side effects such as:</span><span><br/>
</span></p>
<ul>
<li aria-level="1"><span>An almost infinite Denial of Service Attack (DoS) amplification factor.</span></li>
<li aria-level="1"><span>Server-driven communication with little control by the client.</span></li>
<li aria-level="1"><span>Complete trust in the validity of server timestamps.</span></li>
<li aria-level="1"><span>Asynchronous path delay calculations.</span></li>
</ul>
<p><span>In data centers, where communication is typically driven by hundreds of thousands of clients and multicast is not supported, these tradeoffs are very limiting. </span></p>
<h2><span>SPTP</span></h2>
<p><span>True to its name, SPTP significantly reduces the number of exchanges between a server and client, allowing for much more efficient network communication.</span></p>
<h3><span>Exchange</span></h3>
<figure id="attachment_20921" aria-describedby="caption-attachment-20921"><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image2.jpg?w=1024" alt="" width="1024" height="1024" srcset="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image2.jpg 1080w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image2.jpg?resize=916,916 916w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image2.jpg?resize=768,768 768w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image2.jpg?resize=1024,1024 1024w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image2.jpg?resize=96,96 96w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image2.jpg?resize=192,192 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-20921">Figure 2: Typical SPTP exchange.</figcaption></figure>
<p><span>In a typical SPTP exchange:</span><span><br/>
</span></p>
<ol>
<li aria-level="1"><span>The client sends a delay request.</span></li>
<li aria-level="1"><span>The server responds with a sync.</span></li>
<li aria-level="1"><span>The server sends a followup/announce.</span></li>
</ol>
<p><span>The number of network exchanges is drastically reduced. Instead of 11 different network exchanges as shown on Figure 1 and the requirement for client and server state machines for the duration of the subscription, there are only three packets exchanged and no state needs to be preserved on either side. In the simplified exchange, every packet has an important role:</span></p>
<h4><span>Delay request</span></h4>
<p><span>A delay request initiates the SPTP exchange. It’s interpreted by a server not only as a standard delay request containing the correction field (CF1) of the transparent clock, but also as a signal to respond with sync and followup packets. Just like in a two-step PTPv2 exchange, it generates T3 upon departure from the client side and T4 upon arrival on the server side.</span></p>
<p><span>To distinguish between a PTPv2 delay request and a SPTP delay request, the PTP profile Specific 1 flag must be set by the client.</span></p>
<h4><span>Sync</span></h4>
<p><span>In response to a delay request, a sync packet would be sent containing the T4 generated at an earlier stage. Just like in a regular two-step PTPv2 exchange, a sync packet will generate a T1 upon departure from the server side. While in transit, the correction field of the packet (CF2) is populated by the network equipment.</span></p>
<h4><span>Followup/announce</span></h4>
<p><span>Following the sync packet, an announce packet is immediately sent containing T1 generated at a previous stage. In addition, the correction filed from the Delay Request field is populated by the CF1 value collected at an earlier stage.  </span></p>
<p><span>The announce packet also contains typical PTPv2 information such as clock class, clock accuracy, and so on. On the client side, the arrival of the packet generates the T2 timestamp.</span></p>
<p><span>After a successful SPTP exchange, default two-step PTPv2 formulas for mean path delay and clock offset must be applied:</span></p>
<p><em><span>mean_path_delay = ((T4 – T3) + (T2-T1) – CF1 -CF2)/2</span></em></p>
<p><em><span>clock_offset = T2 – T1 – mean_path_delay</span></em></p>
<p><span>After every exchange the client has access to the announce message attributes such as time source, clock quality, etc., as well as the path delay and a calculated clock offset after every exchange with every server. And, because the exchange is client-driven, the offsets could be calculated at the exact same time. This avoids a situation where a client is following a faulty server and has no chance of detecting it.</span></p>
<figure id="attachment_20922" aria-describedby="caption-attachment-20922"><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image3.png?w=1024" alt="" width="1024" height="553" srcset="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image3.png 1408w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image3.png?resize=916,494 916w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image3.png?resize=768,415 768w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image3.png?resize=1024,553 1024w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image3.png?resize=96,52 96w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image3.png?resize=192,104 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-20922">Figure 3: Client following faulty Time Server 2 based on announce.</figcaption></figure>
<h3><span>Reliability</span></h3>
<p><span>We can also provide stronger reliability guarantees by using multi-clock reliance.</span></p>
<p><span>In our implementation for precision time synchronization, we provide time as well as a window of uncertainty (WOU) to the consumer application via the fbclock API. As we described in a previous blog post on</span><a href="https://engineering.fb.com/2022/11/21/production-engineering/precision-time-protocol-at-meta/"> <span>how PTP is being deployed at Meta</span></a><span> the WOU is based on the observation of time sync errors for the minimum duration to have stationarity of the state of the system. </span></p>
<p><span>In addition, we’ve established a method based on a collection of clocks that each client can access for timing information that we call a </span><i><span>clock ensemble</span></i><span>. The clock ensemble operates in two modes, steady state and transient; where steady state is during normal operation and transient is in the case of holdover.</span></p>
<p><span>However, with a pool of N clocks, C, forming the clock ensemble, the question becomes which clocks to select for determining robustness and accurate timing information. Clocks that are not accurate are rejected (C_reject) and, thus, our ensemble size falls to N = C_total –  C_reject. We employ two stages, one that is based on each individual clock, and the second that acts on the collection of valid clocks in the ensemble. </span></p>
<p><span>The first stage observes the previous measurements of each individual clock, where the main criteria is to reject outliers in the previous states of the clock. Once this criterion threshold is exceeded, the entire clock is rejected from the valid clock ensemble pool. This is based off</span><a href="https://www.statisticshowto.com/chauvenets-criterion/"> <span>Chauvenet’s criterion</span></a><span>, where the criterion is a probability band that is centered on the mean of the clock outputs (assuming a normal distribution during steady state). Based on the stationarity tests, we use a sample size of 400 previous clock outputs and calculate a maximum allowable deviation. </span></p>
<p><span>For example:</span></p>
<p><span><img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20D_%7Bmax%7D%5Cge%20%5Cfrac%7B%7CC%20-%20%5Cbar%7BC%7D%7C%7D%7BS_%7Bc%7D%7D"/>, where <img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20C"/> is the current clock output, <img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20%5Coverline%20C"/> </span><span>is the clock sample mean, and <img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20S_%7Bc%7D"/> </span><span>is the clock set standard deviation.</span></p>
<p><span>We find the probability that the current clock output is in disagreement with the previous 400 samples:</span></p>
<p><img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20%7BP_%7Bz%7D%20%3D%201%20-%20%5Cfrac%7B1%7D%7B4%28400%29%7D%20%5Capprox%200.9993%7D"/></p>
<p><span>Based on a window size of 400 previous samples, the maximum allowed deviation is:</span></p>
<p><img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20D_%7Bmax%7D%20%3D%203.2272"/></p>
<p><span>Now, the clock outputs are tested against this value. If they exceed the <img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20D_%7Bmax%7D"/> </span><span>they are rejected, an alert is raised, and a threshold counter is incremented. Once the rejection threshold is reached for an individual clock, this clock is entirely rejected.</span></p>
<p><span>Now, we enter the second stage of verifying the clock ensemble composed of the valid clocks. The second stage forms a weighted average of the non-rejected clocks in the valid clock ensemble, where each clock in the ensemble is reported as its sample size, mean, and variance. The average of the clocks’ means is the weighted average, where the weights are inversely proportional to the mean absolute deviations reported by each clock after applying Chauvenet’s criterion. </span></p>
<p><span>Now we can report the mean and variance of the clock ensemble, ensuring the clocks contained therewith are valid and not providing erroneous values. The confidence interval is scaled with the number of good clocks in the ensemble, where the higher the number of valid clocks out of the total clocks provides greater reliability.</span></p>
<p><span>For a number of hosts, we show that the distribution of clocks falls within the following heatmap:</span></p>
<figure id="attachment_20923" aria-describedby="caption-attachment-20923"><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image4.png?w=640" alt="" width="640" height="480" srcset="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image4.png 640w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image4.png?resize=96,72 96w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image4.png?resize=192,144 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-20923">Figure 4: Offset distribution overlay of multiple clocks.</figcaption></figure>
<p><span>We calculate the variance, <img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20v_%7Bk%7D"/></span><span>, of each individual clock’s observations, then we calculate a weighted mean, <img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20w_%7Bk%7D"/></span><span>, taking into consideration the reciprocal of each clock’s variance as the weight.</span></p>
<p><img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20w_%7Bk%7D%20%3D%20%5Cfrac%7BC%7D%7B%5Csqrt%7B%5Cfrac%7Bv%7D%7Bk%7D%7D%7D%2C%20C%20%3D%20%5B%5Cfrac%7B1%7D%7Bk%7D%5Csum%20%5Cfrac%7B1%7D%7Bv_%7Bk%7D%7D%5D%5E%7B-1%7D"/></p>
<p><span>Due to independence of clocks, the variance of the weighted sum, <img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20w_%7Bk%7D"/></span><span>, is:</span></p>
<p><img decoding="async" src="https://latex.codecogs.com/png.latex?%5Cfn_cm%20%5Cfrac%7B1%7D%7Bk%7D%5Csum_%7B%7D%5E%7B%7D%5Cmathrm%7BW%7D_%7Bk%7D%5E%7B2%7Dv_%7Bk%7D%20%3D%20%5Csum_%7B%7D%5E%7B%7DC%5E%7B2%7D%20%3D%20N_%7Bw%7DC%5E%7B2%7D"/></p>
<p><span>In summary, we collect samples from a number of clock sources that form our clock ensemble. The overall precision and reliability of the provided data by SPTP is a function of the number of reliable and in distribution clocks forming the clock ensemble.</span></p>
<p><span>A future post will focus on this specifically. </span></p>
<h2><span>SPTP’s performance</span></h2>
<p><span>Let’s explore performance of the SPTP versus PTP.</span></p>
<p><span>Initial deployments to a single client confirmed no regression in the precision of the synchronization:</span></p>
<figure id="attachment_20970" aria-describedby="caption-attachment-20970"><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP-Figure-5-updated.png?w=1024" alt="" width="1024" height="403" srcset="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP-Figure-5-updated.png 1520w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP-Figure-5-updated.png?resize=916,360 916w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP-Figure-5-updated.png?resize=768,302 768w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP-Figure-5-updated.png?resize=1024,403 1024w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP-Figure-5-updated.png?resize=96,38 96w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP-Figure-5-updated.png?resize=192,76 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-20970">Figure 5: Clock offset after switching from ptp4l and SPTP.</figcaption></figure>
<p><span>Repeating the same measurement after migration to SPTP produces a very similar result, only marginally different due to a statistical error:</span></p>
<figure id="attachment_20925" aria-describedby="caption-attachment-20925"><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?w=1024" alt="" width="1024" height="574" srcset="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png 1999w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?resize=580,326 580w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?resize=916,514 916w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?resize=768,431 768w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?resize=1024,574 1024w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?resize=1536,861 1536w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?resize=96,54 96w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image6.png?resize=192,108 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-20925">Figure 6: P99.99 offset collected from over 100000 SPTP clients.</figcaption></figure>
<p><span>With large-scale deployment of our implementations, we can confirm resource utilization improvements.</span></p>
<p><span>We noticed that due to the difference in multi-server support, the performance gains vary significantly depending on the number of tracked time servers.</span></p>
<p><span>For example, with just a single time appliance serving the entire network there are significant improvements across the board. Most notably over 40 percent CPU, 70 percent memory, and 50 percent network utilization improvements:</span></p>
<figure id="attachment_20926" aria-describedby="caption-attachment-20926"><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png?w=1024" alt="" width="1024" height="574" srcset="https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png 1234w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png?resize=580,326 580w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png?resize=916,514 916w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png?resize=768,431 768w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png?resize=1024,574 1024w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png?resize=96,54 96w, https://engineering.fb.com/wp-content/uploads/2024/02/SPTP_image7.png?resize=192,108 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-20926">Figure 7: Packets per second with ptp4l (green) vs SPTP (blue).</figcaption></figure>
<h2><span>The next steps for SPTP at Meta</span></h2>
<p><span>Since SPTP can offer the exact same level of synchronization with a lot fewer resources consumed, we think it’s a reasonable alternative to the existing unicast PTP profiles.</span></p>
<p><span>In a large-scale data center deployment, it can help to combat frequently changing network paths and create savings in terms of network traffic, memory usage, and number of CPU cycles.</span></p>
<p><span>It will also eliminate a lot of complexity inherited from multicast PTP profiles, which is not necessarily useful in the trusted networks of the modern data centers.</span></p>
<p><span>It should be noted that SPTP may not be suitable for systems that still require subscription and authentication. But this could be solved by using PTP TLVs (type-length-value). </span></p>
<p><span>Additionally, by removing the need for subscriptions, it’s possible to observe multiple clocks – which allows us to provide higher reliability by comparing the time sync from multiple sources at the end node.</span></p>
<p><span>SPTP can offer significantly simpler, faster, and more reliable synchronization. Similar to G.8265.1 and G.8275.2 it provides excellent synchronization quality using a different set of parameters. Simplification comes with certain tradeoffs, such as missing signaling messages, that users need to be aware of and decide which profile is the best for them.</span></p>
<p><span>Having it standardized and assigned a unicast profile identifier will encourage wider support, adoption, and popularization of PTP as a default precise time synchronization protocol.</span></p>
<p><span>The source code for the SPTP client and the server can be accessed on our</span><a href="https://github.com/facebook/time"> <span>GitHub page</span></a><span>.</span></p>
<h2><i><span>Acknowledgements</span></i></h2>
<p><em>We would like to thank Alexander Bulimov, Vadim Fedorenko, and Mike Lambeta for their help implementing the code and the math for this article.</em></p>

		
	</div></div>
  </body>
</html>
