<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-4/">Original</a>
    <h1>Building view-trees: Async Data Fetching [Part 4]</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        

        

        

        <section>
            <p>Previously: <a href="http://www.midieditor.org/writes/building-view-trees-in-go-part-1">intro</a>, <a href="http://www.midieditor.org/writes/building-view-trees-in-go-part-2">the basics</a>, and <a href="http://www.midieditor.org/writes/building-view-trees-in-go-part-3">error handling</a>.</p>
<hr/>
<p>There are cases where we&#39;ll fetch data for something up front, and pass
it down the view tree, meaning the views are basically &#34;pure functions&#34;,
all done; and there are times when a view will request data for itself,
meaning a view constructor could be waiting and blocking.</p>
<p>The below example is of a view constructor kicking off a simulated fetch
in a goroutine, based on how its configured the view either fails or
succeeds.</p>
<p><code>ExpensiveViewData</code> is a placeholder for something that could
have come from some JSON API.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>ExpensiveViewData </span><span>struct </span><span>{
</span><span>    Title </span><span>string </span><span>`json:&#34;title&#34;`
</span><span>}
</span></code></pre>
<p>The view holds data for success or error and <code>Renderable</code> checks for
which channel gets data first (this will block), either getting data,
or an error, and then completing the <code>Renderable</code> interface with which
ever.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>ExpensiveView </span><span>struct </span><span>{
</span><span>    Data </span><span>chan ExpensiveViewData
</span><span>    Err  </span><span>chan </span><span>error
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>*ExpensiveView</span><span>) </span><span>Renderable</span><span>() (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>select </span><span>{
</span><span>    </span><span>case </span><span>err </span><span>:= &lt;-</span><span>v.Err:
</span><span>        </span><span>return </span><span>nil</span><span>, err
</span><span>    </span><span>case </span><span>data </span><span>:= &lt;-</span><span>v.Data:
</span><span>        </span><span>return </span><span>View{</span><span>/*  */</span><span>}, </span><span>nil
</span><span>    }
</span><span>}
</span></code></pre>
<p>The constructor (function) for our view, because we&#39;re simulating
work, is parameterized by <code>shouldErr</code>  and we kick off a goroutine
that waits for 1 second and then sends the message.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>NewExpensiveView</span><span>(shouldErr </span><span>bool</span><span>) </span><span>*ExpensiveView </span><span>{
</span><span>    errCh </span><span>:= </span><span>make</span><span>(</span><span>chan err</span><span>)
</span><span>    dataCh </span><span>:= </span><span>make</span><span>(</span><span>chan ExpensiveViewData</span><span>)
</span><span>
</span><span>    </span><span>go func</span><span>() {
</span><span>        </span><span>defer </span><span>close</span><span>(errCh)
</span><span>        </span><span>defer </span><span>close</span><span>(dataCh)
</span><span>
</span><span>        </span><span>// do data fetching and either write to one thing or the other
</span><span>        time.Sleep(</span><span>1 </span><span>* </span><span>time.Second)
</span><span>        </span><span>if </span><span>shouldErr {
</span><span>            errCh </span><span>&lt;- </span><span>fmt.Errorf(</span><span>&#34;fetch failed&#34;</span><span>)
</span><span>        } </span><span>else </span><span>{
</span><span>            dataCh </span><span>&lt;- </span><span>ExpensiveViewData{Title: </span><span>&#34;hi&#34;</span><span>}
</span><span>        }
</span><span>    }()
</span><span>
</span><span>    </span><span>return &amp;</span><span>ExpensiveView{Data: dataCh, Err:  errCh}
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      initial channel data fetch test
      <a href="https://github.com/stanistan/veun/commit/3b46e0cb31b7fe767ab7c1c7ab3ede30f5568aae">(source: 3b46e0cb)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/render_with_data_fetch_test.go b/render_with_data_fetch_test.go
</span><span>new file mode 100644
</span><span>index 0000000..963242e
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/render_with_data_fetch_test.go
</span><span>@@ -0,0 +1,68 @@
</span><span>+</span><span>package veun_test
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;fmt&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>	&#34;testing&#34;
</span><span>+</span><span>	&#34;time&#34;
</span><span>+
</span><span>+</span><span>	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>+
</span><span>+</span><span>	. &#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type ExpensiveViewData struct {
</span><span>+</span><span>	Title string `json:&#34;title&#34;`
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>var expensiveViewTpl = MustParseTemplate(&#34;expensiveView&#34;, `{{ .Title }} success`)
</span><span>+
</span><span>+</span><span>type ExpensiveView struct {
</span><span>+</span><span>	Data chan ExpensiveViewData
</span><span>+</span><span>	Err  chan error
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func NewExpensiveView(shouldErr bool) *ExpensiveView {
</span><span>+</span><span>	errCh := make(chan error)
</span><span>+</span><span>	dataCh := make(chan ExpensiveViewData)
</span><span>+
</span><span>+</span><span>	go func() {
</span><span>+</span><span>		defer func() {
</span><span>+</span><span>			close(errCh)
</span><span>+</span><span>			close(dataCh)
</span><span>+</span><span>		}()
</span><span>+
</span><span>+</span><span>		// do data fetching and either write to
</span><span>+</span><span>		// one thing or the other
</span><span>+</span><span>		time.Sleep(1 * time.Millisecond)
</span><span>+</span><span>		if shouldErr {
</span><span>+</span><span>			errCh &lt;- fmt.Errorf(&#34;fetch failed&#34;)
</span><span>+</span><span>		} else {
</span><span>+</span><span>			dataCh &lt;- ExpensiveViewData{Title: &#34;hi&#34;}
</span><span>+</span><span>		}
</span><span>+</span><span>	}()
</span><span>+
</span><span>+</span><span>	return &amp;ExpensiveView{Data: dataCh, Err: errCh}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v *ExpensiveView) Renderable() (Renderable, error) {
</span><span>+</span><span>	select {
</span><span>+</span><span>	case err := &lt;-v.Err:
</span><span>+</span><span>		return nil, err
</span><span>+</span><span>	case data := &lt;-v.Data:
</span><span>+</span><span>		return View{Tpl: expensiveViewTpl, Data: data}, nil
</span><span>+</span><span>	}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func TestViewWithChannels(t *testing.T) {
</span><span>+</span><span>	t.Run(&#34;successful&#34;, func(t *testing.T) {
</span><span>+</span><span>		html, err := Render(NewExpensiveView(false))
</span><span>+</span><span>		assert.NoError(t, err)
</span><span>+</span><span>		assert.Equal(t, template.HTML(`hi success`), html)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;failed&#34;, func(t *testing.T) {
</span><span>+</span><span>		_, err := Render(NewExpensiveView(true))
</span><span>+</span><span>		assert.Error(t, err)
</span><span>+</span><span>	})
</span><span>+</span><span>}
</span><span>
</span></code></pre>


  </details>
</div>
<p>This works just fine, but what if we don&#39;t want this to be waiting for a second,
what if we have 10ms to do the work?</p>
<h2 id="context-and-cancellation">Context and Cancellation</h2>
<p>We need something that could do cancellation in case of a timeout.
We&#39;re missing <a rel="nofollow noreferrer" href="https://pkg.go.dev/context"><code>context.Context</code></a>.</p>
<p>Where this is mostly going to be used, in the span of an HTTP request,
we can grab this from the request itself, but our API has no method of
propagating it down through construction, render, and data fetching.</p>
<p>What we want is for our <code>select</code> to look like this:</p>
<pre data-lang="go"><code data-lang="go"><span>select </span><span>{
</span><span>case &lt;-</span><span>ctx.Done():
</span><span>    </span><span>return </span><span>nil</span><span>, ctx.Err()
</span><span>case </span><span>err </span><span>:= &lt;-</span><span>v.Err:
</span><span>    </span><span>return </span><span>nil</span><span>, err
</span><span>case </span><span>data </span><span>:= &lt;-</span><span>v.Data:
</span><span>    </span><span>return </span><span>View{</span><span>/*  */</span><span>}, </span><span>nil
</span><span>}
</span></code></pre>
<p>And eventually, our API to look like this:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>(v </span><span>*ExpensiveView</span><span>) </span><span>Renderable</span><span>(ctx context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>// ...
</span><span>}
</span></code></pre>
<p>So we have some changes to make.</p>
<table><thead><tr><th>Before</th><th>After</th></tr></thead><tbody>
<tr><td><code>Renderable()</code></td><td><code>Renderable(Context)</code></td></tr>
<tr><td><code>Template()</code></td><td><code>Template(Context)</code></td></tr>
<tr><td><code>TemplateData()</code></td><td><code>TemplateData(Context)</code></td></tr>
<tr><td><code>Render(AsRenderable)</code></td><td><code>Render(Context, AsRenderable)</code></td></tr>
</tbody></table>










<div>
  <details>
    <summary>
      Adding context.Context to all interface methods
      <a href="https://github.com/stanistan/veun/commit/81d7c2ded337aacda74d66120e3fd0668fd364d7">(source: 81d7c2de)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/error_renderable.go b/error_renderable.go
</span><span>index 63159e8..0dcab6c 100644
</span><span>---</span><span> a/error_renderable.go
</span><span>+++</span><span> b/error_renderable.go
</span><span>@@ -1,6 +1,9 @@
</span><span> package veun
</span><span> 
</span><span>-import &#34;html/template&#34;
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>)
</span><span> 
</span><span> type ErrorRenderable interface {
</span><span> 	// ErrorRenderable can return bubble the error
</span><span>@@ -11,10 +14,10 @@ type ErrorRenderable interface {
</span><span> 	// which will ignore the error entirely.
</span><span> 	//
</span><span> 	// Otherwise we will attempt to render next one.
</span><span>-	ErrorRenderable(err error) (AsRenderable, error)
</span><span>+</span><span>	ErrorRenderable(ctx context.Context, err error) (AsRenderable, error)
</span><span> }
</span><span> 
</span><span>-func handleRenderError(err error, with any) (template.HTML, error) {
</span><span>+</span><span>func handleRenderError(ctx context.Context, err error, with any) (template.HTML, error) {
</span><span> 	var empty template.HTML
</span><span> 
</span><span> 	if with == nil {
</span><span>@@ -26,7 +29,7 @@ func handleRenderError(err error, with any) (template.HTML, error) {
</span><span> 		return empty, err
</span><span> 	}
</span><span> 
</span><span>-	r, err := errRenderable.ErrorRenderable(err)
</span><span>+</span><span>	r, err := errRenderable.ErrorRenderable(ctx, err)
</span><span> 	if err != nil {
</span><span> 		return empty, err
</span><span> 	}
</span><span>@@ -35,5 +38,5 @@ func handleRenderError(err error, with any) (template.HTML, error) {
</span><span> 		return empty, nil
</span><span> 	}
</span><span> 
</span><span>-	return Render(r)
</span><span>+</span><span>	return Render(ctx, r)
</span><span> }
</span><span>diff --git a/render_container_as_view_test.go b/render_container_as_view_test.go
</span><span>index 9af1ad0..b83ff1a 100644
</span><span>---</span><span> a/render_container_as_view_test.go
</span><span>+++</span><span> b/render_container_as_view_test.go
</span><span>@@ -1,6 +1,7 @@
</span><span> package veun_test
</span><span> 
</span><span> import (
</span><span>+</span><span>	&#34;context&#34;
</span><span> 	&#34;html/template&#34;
</span><span> 	&#34;testing&#34;
</span><span> 
</span><span>@@ -14,7 +15,7 @@ type ContainerView2 struct {
</span><span> 	Body    AsRenderable
</span><span> }
</span><span> 
</span><span>-func (v ContainerView2) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v ContainerView2) Renderable(ctx context.Context) (Renderable, error) {
</span><span> 	return View{
</span><span> 		Tpl:   containerViewTpl,
</span><span> 		Slots: Slots{&#34;heading&#34;: v.Heading, &#34;body&#34;: v.Body},
</span><span>@@ -22,7 +23,7 @@ func (v ContainerView2) Renderable() (Renderable, error) {
</span><span> }
</span><span> 
</span><span> func TestRenderContainerAsView(t *testing.T) {
</span><span>-	html, err := Render(ContainerView2{
</span><span>+</span><span>	html, err := Render(context.Background(), ContainerView2{
</span><span> 		Heading: ChildView1{},
</span><span> 		Body:    ChildView2{},
</span><span> 	})
</span><span>diff --git a/render_container_error_test.go b/render_container_error_test.go
</span><span>index 8052a8d..abedcca 100644
</span><span>---</span><span> a/render_container_error_test.go
</span><span>+++</span><span> b/render_container_error_test.go
</span><span>@@ -1,6 +1,7 @@
</span><span> package veun_test
</span><span> 
</span><span> import (
</span><span>+</span><span>	&#34;context&#34;
</span><span> 	&#34;errors&#34;
</span><span> 	&#34;fmt&#34;
</span><span> 	&#34;html/template&#34;
</span><span>@@ -15,7 +16,7 @@ type FailingView struct {
</span><span> 	Err error
</span><span> }
</span><span> 
</span><span>-func (v FailingView) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v FailingView) Renderable(_ context.Context) (Renderable, error) {
</span><span> 	return nil, fmt.Errorf(&#34;FailingView.Renderable(): %w&#34;, v.Err)
</span><span> }
</span><span> 
</span><span>@@ -24,11 +25,11 @@ type FallibleView struct {
</span><span> 	Child       AsRenderable
</span><span> }
</span><span> 
</span><span>-func (v FallibleView) Renderable() (Renderable, error) {
</span><span>-	return v.Child.Renderable()
</span><span>+</span><span>func (v FallibleView) Renderable(ctx context.Context) (Renderable, error) {
</span><span>+</span><span>	return v.Child.Renderable(ctx)
</span><span> }
</span><span> 
</span><span>-func (v FallibleView) ErrorRenderable(err error) (AsRenderable, error) {
</span><span>+</span><span>func (v FallibleView) ErrorRenderable(ctx context.Context, err error) (AsRenderable, error) {
</span><span> 	if v.CapturesErr == nil {
</span><span> 		return nil, err
</span><span> 	}
</span><span>@@ -41,7 +42,7 @@ func (v FallibleView) ErrorRenderable(err error) (AsRenderable, error) {
</span><span> }
</span><span> 
</span><span> func TestRenderContainerWithFailingView(t *testing.T) {
</span><span>-	_, err := Render(ContainerView2{
</span><span>+</span><span>	_, err := Render(context.Background(), ContainerView2{
</span><span> 		Heading: ChildView1{},
</span><span> 		Body: FailingView{
</span><span> 			Err: fmt.Errorf(&#34;construction: %w&#34;, errSomethingFailed),
</span><span>@@ -52,7 +53,7 @@ func TestRenderContainerWithFailingView(t *testing.T) {
</span><span> 
</span><span> func TestRenderContainerWithCapturedError(t *testing.T) {
</span><span> 	t.Run(&#34;errors_bubble_out&#34;, func(t *testing.T) {
</span><span>-		_, err := Render(ContainerView2{
</span><span>+</span><span>		_, err := Render(context.Background(), ContainerView2{
</span><span> 			Heading: ChildView1{},
</span><span> 			Body: FallibleView{
</span><span> 				Child: FailingView{Err: errSomethingFailed},
</span><span>@@ -62,7 +63,7 @@ func TestRenderContainerWithCapturedError(t *testing.T) {
</span><span> 	})
</span><span> 
</span><span> 	t.Run(&#34;errors_can_push_replacement_views&#34;, func(t *testing.T) {
</span><span>-		html, err := Render(ContainerView2{
</span><span>+</span><span>		html, err := Render(context.Background(), ContainerView2{
</span><span> 			Heading: ChildView1{},
</span><span> 			Body: FallibleView{
</span><span> 				Child:       FailingView{Err: errSomethingFailed},
</span><span>@@ -77,7 +78,7 @@ func TestRenderContainerWithCapturedError(t *testing.T) {
</span><span> 	})
</span><span> 
</span><span> 	t.Run(&#34;errors_can_return_nil_views&#34;, func(t *testing.T) {
</span><span>-		html, err := Render(ContainerView2{
</span><span>+</span><span>		html, err := Render(context.Background(), ContainerView2{
</span><span> 			Heading: ChildView1{},
</span><span> 			Body: FallibleView{
</span><span> 				Child:       FailingView{Err: errors.New(&#34;hi&#34;)},
</span><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>index 162f0d2..aef4e68 100644
</span><span>---</span><span> a/render_container_test.go
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -1,6 +1,7 @@
</span><span> package veun_test
</span><span> 
</span><span> import (
</span><span>+</span><span>	&#34;context&#34;
</span><span> 	&#34;html/template&#34;
</span><span> 	&#34;testing&#34;
</span><span> 
</span><span>@@ -19,30 +20,30 @@ var containerViewTpl = MustParseTemplate(&#34;containerView&#34;, `&lt;div&gt;
</span><span> 	&lt;div class=&#34;body&#34;&gt;{{ slot &#34;body&#34; }}&lt;/div&gt;
</span><span> &lt;/div&gt;`)
</span><span> 
</span><span>-func tplWithRealSlotFunc(tpl *template.Template, slots map[string]AsRenderable) *template.Template {
</span><span>+</span><span>func tplWithRealSlotFunc(ctx context.Context, tpl *template.Template, slots map[string]AsRenderable) *template.Template {
</span><span> 	return tpl.Funcs(template.FuncMap{
</span><span> 		&#34;slot&#34;: func(name string) (template.HTML, error) {
</span><span> 			slot, ok := slots[name]
</span><span> 			if ok {
</span><span>-				return Render(slot)
</span><span>+</span><span>				return Render(ctx, slot)
</span><span> 			}
</span><span> 			return template.HTML(&#34;&#34;), nil
</span><span> 		},
</span><span> 	})
</span><span> }
</span><span> 
</span><span>-func (v ContainerView) Template() (*template.Template, error) {
</span><span>-	return tplWithRealSlotFunc(containerViewTpl, map[string]AsRenderable{
</span><span>+</span><span>func (v ContainerView) Template(ctx context.Context) (*template.Template, error) {
</span><span>+</span><span>	return tplWithRealSlotFunc(ctx, containerViewTpl, map[string]AsRenderable{
</span><span> 		&#34;heading&#34;: v.Heading,
</span><span> 		&#34;body&#34;:    v.Body,
</span><span> 	}), nil
</span><span> }
</span><span> 
</span><span>-func (v ContainerView) TemplateData() (any, error) {
</span><span>+</span><span>func (v ContainerView) TemplateData(_ context.Context) (any, error) {
</span><span> 	return nil, nil
</span><span> }
</span><span> 
</span><span>-func (v ContainerView) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v ContainerView) Renderable(_ context.Context) (Renderable, error) {
</span><span> 	return v, nil
</span><span> }
</span><span> 
</span><span>@@ -52,18 +53,18 @@ var childViewTemplate = template.Must(
</span><span> 
</span><span> type ChildView1 struct{}
</span><span> 
</span><span>-func (v ChildView1) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v ChildView1) Renderable(_ context.Context) (Renderable, error) {
</span><span> 	return View{Tpl: childViewTemplate, Data: &#34;HEADING&#34;}, nil
</span><span> }
</span><span> 
</span><span> type ChildView2 struct{}
</span><span> 
</span><span>-func (v ChildView2) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v ChildView2) Renderable(_ context.Context) (Renderable, error) {
</span><span> 	return View{Tpl: childViewTemplate, Data: &#34;BODY&#34;}, nil
</span><span> }
</span><span> 
</span><span> func TestRenderContainer(t *testing.T) {
</span><span>-	html, err := Render(&amp;ContainerView{
</span><span>+</span><span>	html, err := Render(context.Background(), &amp;ContainerView{
</span><span> 		Heading: ChildView1{},
</span><span> 		Body:    ChildView2{},
</span><span> 	})
</span><span>diff --git a/render_person_test.go b/render_person_test.go
</span><span>index e2a99de..5de4182 100644
</span><span>---</span><span> a/render_person_test.go
</span><span>+++</span><span> b/render_person_test.go
</span><span>@@ -1,6 +1,7 @@
</span><span> package veun_test
</span><span> 
</span><span> import (
</span><span>+</span><span>	&#34;context&#34;
</span><span> 	&#34;html/template&#34;
</span><span> 	&#34;testing&#34;
</span><span> 
</span><span>@@ -24,12 +25,12 @@ var personViewTpl = template.Must(
</span><span> 	template.New(&#34;PersonView&#34;).Parse(`&lt;div&gt;Hi, {{ .Name }}.&lt;/div&gt;`),
</span><span> )
</span><span> 
</span><span>-func (v *personView) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v *personView) Renderable(_ context.Context) (Renderable, error) {
</span><span> 	return View{Tpl: personViewTpl, Data: v.Person}, nil
</span><span> }
</span><span> 
</span><span> func TestRenderPerson(t *testing.T) {
</span><span>-	html, err := Render(PersonView(Person{Name: &#34;Stan&#34;}))
</span><span>+</span><span>	html, err := Render(context.Background(), PersonView(Person{Name: &#34;Stan&#34;}))
</span><span> 	assert.NoError(t, err)
</span><span> 	assert.Equal(t, html, template.HTML(`&lt;div&gt;Hi, Stan.&lt;/div&gt;`))
</span><span> }
</span><span>diff --git a/render_with_data_fetch_test.go b/render_with_data_fetch_test.go
</span><span>index 963242e..e6166ed 100644
</span><span>---</span><span> a/render_with_data_fetch_test.go
</span><span>+++</span><span> b/render_with_data_fetch_test.go
</span><span>@@ -1,6 +1,7 @@
</span><span> package veun_test
</span><span> 
</span><span> import (
</span><span>+</span><span>	&#34;context&#34;
</span><span> 	&#34;fmt&#34;
</span><span> 	&#34;html/template&#34;
</span><span> 	&#34;testing&#34;
</span><span>@@ -45,7 +46,7 @@ func NewExpensiveView(shouldErr bool) *ExpensiveView {
</span><span> 	return &amp;ExpensiveView{Data: dataCh, Err: errCh}
</span><span> }
</span><span> 
</span><span>-func (v *ExpensiveView) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v *ExpensiveView) Renderable(_ context.Context) (Renderable, error) {
</span><span> 	select {
</span><span> 	case err := &lt;-v.Err:
</span><span> 		return nil, err
</span><span>@@ -56,13 +57,13 @@ func (v *ExpensiveView) Renderable() (Renderable, error) {
</span><span> 
</span><span> func TestViewWithChannels(t *testing.T) {
</span><span> 	t.Run(&#34;successful&#34;, func(t *testing.T) {
</span><span>-		html, err := Render(NewExpensiveView(false))
</span><span>+</span><span>		html, err := Render(context.Background(), NewExpensiveView(false))
</span><span> 		assert.NoError(t, err)
</span><span> 		assert.Equal(t, template.HTML(`hi success`), html)
</span><span> 	})
</span><span> 
</span><span> 	t.Run(&#34;failed&#34;, func(t *testing.T) {
</span><span>-		_, err := Render(NewExpensiveView(true))
</span><span>+</span><span>		_, err := Render(context.Background(), NewExpensiveView(true))
</span><span> 		assert.Error(t, err)
</span><span> 	})
</span><span> }
</span><span>diff --git a/renderer.go b/renderer.go
</span><span>index 27d3abc..33af885 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -2,37 +2,38 @@ package veun
</span><span> 
</span><span> import (
</span><span> 	&#34;bytes&#34;
</span><span>+</span><span>	&#34;context&#34;
</span><span> 	&#34;fmt&#34;
</span><span> 	&#34;html/template&#34;
</span><span> )
</span><span> 
</span><span> type Renderable interface {
</span><span>-	Template() (*template.Template, error)
</span><span>-	TemplateData() (any, error)
</span><span>+</span><span>	Template(ctx context.Context) (*template.Template, error)
</span><span>+</span><span>	TemplateData(ctx context.Context) (any, error)
</span><span> }
</span><span> 
</span><span> type AsRenderable interface {
</span><span>-	Renderable() (Renderable, error)
</span><span>+</span><span>	Renderable(ctx context.Context) (Renderable, error)
</span><span> }
</span><span> 
</span><span>-func Render(r AsRenderable) (template.HTML, error) {
</span><span>-	renderable, err := r.Renderable()
</span><span>+</span><span>func Render(ctx context.Context, r AsRenderable) (template.HTML, error) {
</span><span>+</span><span>	renderable, err := r.Renderable(ctx)
</span><span> 	if err != nil {
</span><span>-		return handleRenderError(err, r)
</span><span>+</span><span>		return handleRenderError(ctx, err, r)
</span><span> 	}
</span><span> 
</span><span>-	out, err := render(renderable)
</span><span>+</span><span>	out, err := render(ctx, renderable)
</span><span> 	if err != nil {
</span><span>-		return handleRenderError(err, r)
</span><span>+</span><span>		return handleRenderError(ctx, err, r)
</span><span> 	}
</span><span> 
</span><span> 	return out, nil
</span><span> }
</span><span> 
</span><span>-func render(r Renderable) (template.HTML, error) {
</span><span>+</span><span>func render(ctx context.Context, r Renderable) (template.HTML, error) {
</span><span> 	var empty template.HTML
</span><span> 
</span><span>-	tpl, err := r.Template()
</span><span>+</span><span>	tpl, err := r.Template(ctx)
</span><span> 	if err != nil {
</span><span> 		return empty, err
</span><span> 	}
</span><span>@@ -41,7 +42,7 @@ func render(r Renderable) (template.HTML, error) {
</span><span> 		return empty, fmt.Errorf(&#34;missing template&#34;)
</span><span> 	}
</span><span> 
</span><span>-	data, err := r.TemplateData()
</span><span>+</span><span>	data, err := r.TemplateData(ctx)
</span><span> 	if err != nil {
</span><span> 		return empty, err
</span><span> 	}
</span><span>diff --git a/slots.go b/slots.go
</span><span>index ef55359..61f7fb4 100644
</span><span>---</span><span> a/slots.go
</span><span>+++</span><span> b/slots.go
</span><span>@@ -1,19 +1,24 @@
</span><span> package veun
</span><span> 
</span><span>-import &#34;html/template&#34;
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>)
</span><span> 
</span><span> type Slots map[string]AsRenderable
</span><span> 
</span><span>-func (s Slots) renderSlot(name string) (template.HTML, error) {
</span><span>-	slot, ok := s[name]
</span><span>-	if ok {
</span><span>-		return Render(slot)
</span><span>-	}
</span><span>+</span><span>func (s Slots) renderSlot(ctx context.Context) func(string) (template.HTML, error) {
</span><span>+</span><span>	return func(name string) (template.HTML, error) {
</span><span>+</span><span>		slot, ok := s[name]
</span><span>+</span><span>		if ok {
</span><span>+</span><span>			return Render(ctx, slot)
</span><span>+</span><span>		}
</span><span> 
</span><span>-	var empty template.HTML
</span><span>-	return empty, nil
</span><span>+</span><span>		var empty template.HTML
</span><span>+</span><span>		return empty, nil
</span><span>+</span><span>	}
</span><span> }
</span><span> 
</span><span>-func (s Slots) addToTemplate(t *template.Template) *template.Template {
</span><span>-	return t.Funcs(template.FuncMap{&#34;slot&#34;: s.renderSlot})
</span><span>+</span><span>func (s Slots) addToTemplate(ctx context.Context, t *template.Template) *template.Template {
</span><span>+</span><span>	return t.Funcs(template.FuncMap{&#34;slot&#34;: s.renderSlot(ctx)})
</span><span> }
</span><span>diff --git a/view.go b/view.go
</span><span>index 2bfc217..97f02f5 100644
</span><span>---</span><span> a/view.go
</span><span>+++</span><span> b/view.go
</span><span>@@ -1,6 +1,9 @@
</span><span> package veun
</span><span> 
</span><span>-import &#34;html/template&#34;
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>)
</span><span> 
</span><span> type View struct {
</span><span> 	Tpl   *template.Template
</span><span>@@ -8,15 +11,15 @@ type View struct {
</span><span> 	Data  any
</span><span> }
</span><span> 
</span><span>-func (v View) Template() (*template.Template, error) {
</span><span>-	return v.Slots.addToTemplate(v.Tpl), nil
</span><span>+</span><span>func (v View) Template(ctx context.Context) (*template.Template, error) {
</span><span>+</span><span>	return v.Slots.addToTemplate(ctx, v.Tpl), nil
</span><span> }
</span><span> 
</span><span>-func (v View) TemplateData() (any, error) {
</span><span>+</span><span>func (v View) TemplateData(_ context.Context) (any, error) {
</span><span> 	return v.Data, nil
</span><span> }
</span><span> 
</span><span>-func (v View) Renderable() (Renderable, error) {
</span><span>+</span><span>func (v View) Renderable(_ context.Context) (Renderable, error) {
</span><span> 	return v, nil
</span><span> }
</span><span> 
</span><span>
</span></code></pre>


  </details>
</div>










<div>
  <details>
    <summary>
      testing for cancelled context
      <a href="https://github.com/stanistan/veun/commit/a6a523ee86aea28ad776b835edfe581354292cd7">(source: a6a523ee)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/render_with_data_fetch_test.go b/render_with_data_fetch_test.go
</span><span>index e6166ed..4d93650 100644
</span><span>---</span><span> a/render_with_data_fetch_test.go
</span><span>+++</span><span> b/render_with_data_fetch_test.go
</span><span>@@ -23,7 +23,7 @@ type ExpensiveView struct {
</span><span> 	Err  chan error
</span><span> }
</span><span> 
</span><span>-func NewExpensiveView(shouldErr bool) *ExpensiveView {
</span><span>+</span><span>func NewExpensiveView(shouldErr bool, sleepFor time.Duration) *ExpensiveView {
</span><span> 	errCh := make(chan error)
</span><span> 	dataCh := make(chan ExpensiveViewData)
</span><span> 
</span><span>@@ -35,7 +35,7 @@ func NewExpensiveView(shouldErr bool) *ExpensiveView {
</span><span> 
</span><span> 		// do data fetching and either write to
</span><span> 		// one thing or the other
</span><span>-		time.Sleep(1 * time.Millisecond)
</span><span>+</span><span>		time.Sleep(sleepFor)
</span><span> 		if shouldErr {
</span><span> 			errCh &lt;- fmt.Errorf(&#34;fetch failed&#34;)
</span><span> 		} else {
</span><span>@@ -46,8 +46,10 @@ func NewExpensiveView(shouldErr bool) *ExpensiveView {
</span><span> 	return &amp;ExpensiveView{Data: dataCh, Err: errCh}
</span><span> }
</span><span> 
</span><span>-func (v *ExpensiveView) Renderable(_ context.Context) (Renderable, error) {
</span><span>+</span><span>func (v *ExpensiveView) Renderable(ctx context.Context) (Renderable, error) {
</span><span> 	select {
</span><span>+</span><span>	case &lt;-ctx.Done():
</span><span>+</span><span>		return nil, ctx.Err()
</span><span> 	case err := &lt;-v.Err:
</span><span> 		return nil, err
</span><span> 	case data := &lt;-v.Data:
</span><span>@@ -57,13 +59,25 @@ func (v *ExpensiveView) Renderable(_ context.Context) (Renderable, error) {
</span><span> 
</span><span> func TestViewWithChannels(t *testing.T) {
</span><span> 	t.Run(&#34;successful&#34;, func(t *testing.T) {
</span><span>-		html, err := Render(context.Background(), NewExpensiveView(false))
</span><span>+</span><span>		html, err := Render(context.Background(), NewExpensiveView(false, 1*time.Millisecond))
</span><span> 		assert.NoError(t, err)
</span><span> 		assert.Equal(t, template.HTML(`hi success`), html)
</span><span> 	})
</span><span> 
</span><span> 	t.Run(&#34;failed&#34;, func(t *testing.T) {
</span><span>-		_, err := Render(context.Background(), NewExpensiveView(true))
</span><span>+</span><span>		_, err := Render(context.Background(), NewExpensiveView(true, 1*time.Millisecond))
</span><span> 		assert.Error(t, err)
</span><span> 	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;context timed out&#34;, func(t *testing.T) {
</span><span>+</span><span>		ctx, _ := context.WithTimeout(context.Background(), 1*time.Millisecond)
</span><span>+</span><span>		_, err := Render(ctx, NewExpensiveView(false, 2*time.Millisecond))
</span><span>+</span><span>		assert.Error(t, err)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;context timeout not reached&#34;, func(t *testing.T) {
</span><span>+</span><span>		ctx, _ := context.WithTimeout(context.Background(), 5*time.Millisecond)
</span><span>+</span><span>		_, err := Render(ctx, NewExpensiveView(false, 2*time.Millisecond))
</span><span>+</span><span>		assert.NoError(t, err)
</span><span>+</span><span>	})
</span><span> }
</span><span>
</span></code></pre>


  </details>
</div>
<h2 id="fallible-and-withtimeout">Fallible and WithTimeout</h2>
<p>Because we can do call delegation in our views and render, we can
force a situation where a subtree always stops rendering by
creating a view which explicitly cancels a subcontext and passes
it to the its subview.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>ViewWithTimeout </span><span>struct </span><span>{
</span><span>    Delegate </span><span>AsRenderable
</span><span>    Timeout time.</span><span>Duration
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>ViewWithTimeout</span><span>) </span><span>Renderable</span><span>(ctx context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    ctx, _ </span><span>= </span><span>context.WithTimeout(ctx, v.Timeout)
</span><span>    </span><span>return </span><span>v.Delegate.Renderable(ctx)
</span><span>}
</span></code></pre>
<p>And using the <code>FallibleView</code> from part-2 we can make sure that something
fetches and renders within a given time frame.</p>
<pre data-lang="go"><code data-lang="go"><span>view </span><span>:= </span><span>FallibleView{
</span><span>    Contents: ViewWithTimeout{
</span><span>        Delegate: expensiveView(),
</span><span>        Timeout: </span><span>100 </span><span>* </span><span>time.Millisecond,
</span><span>    },
</span><span>    ErrorRenderable: </span><span>func</span><span>(_ context.</span><span>Context</span><span>, err </span><span>error</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>        </span><span>return </span><span>View{</span><span>/* */</span><span>}, </span><span>nil
</span><span>    },
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      testing context and timeouts and fallbacks
      <a href="https://github.com/stanistan/veun/commit/6f95e9bb8e9fafc03b8a464cc1080e6e0f784f0e">(source: 6f95e9bb)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/render_with_data_fetch_test.go b/render_with_data_fetch_test.go
</span><span>index 4d93650..593784c 100644
</span><span>---</span><span> a/render_with_data_fetch_test.go
</span><span>+++</span><span> b/render_with_data_fetch_test.go
</span><span>@@ -57,6 +57,16 @@ func (v *ExpensiveView) Renderable(ctx context.Context) (Renderable, error) {
</span><span> 	}
</span><span> }
</span><span> 
</span><span>+</span><span>type ViewWithTimeout struct {
</span><span>+</span><span>	Delegate AsRenderable
</span><span>+</span><span>	Timeout  time.Duration
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v ViewWithTimeout) Renderable(ctx context.Context) (Renderable, error) {
</span><span>+</span><span>	ctx, _ = context.WithTimeout(ctx, v.Timeout)
</span><span>+</span><span>	return v.Delegate.Renderable(ctx)
</span><span>+</span><span>}
</span><span>+
</span><span> func TestViewWithChannels(t *testing.T) {
</span><span> 	t.Run(&#34;successful&#34;, func(t *testing.T) {
</span><span> 		html, err := Render(context.Background(), NewExpensiveView(false, 1*time.Millisecond))
</span><span>@@ -80,4 +90,16 @@ func TestViewWithChannels(t *testing.T) {
</span><span> 		_, err := Render(ctx, NewExpensiveView(false, 2*time.Millisecond))
</span><span> 		assert.NoError(t, err)
</span><span> 	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;with timeout and fallible&#34;, func(t *testing.T) {
</span><span>+</span><span>		html, err := Render(context.Background(), FallibleView{
</span><span>+</span><span>			Child: ViewWithTimeout{
</span><span>+</span><span>				Delegate: NewExpensiveView(false, 10*time.Millisecond),
</span><span>+</span><span>				Timeout:  2 * time.Millisecond,
</span><span>+</span><span>			},
</span><span>+</span><span>			CapturesErr: context.DeadlineExceeded,
</span><span>+</span><span>		})
</span><span>+</span><span>		assert.NoError(t, err)
</span><span>+</span><span>		assert.Equal(t, template.HTML(`HEADING`), html)
</span><span>+</span><span>	})
</span><span> }
</span><span>
</span></code></pre>


  </details>
</div>
<h3 id="cleaning-up-and-examples-of-context-composition">Cleaning up, and examples of Context composition</h3>
<p>We can make our own very similar <code>WithTimeout</code> function.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>WithTimeout</span><span>(r </span><span>AsRenderable</span><span>, timeout time.</span><span>Duration</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>// ...
</span><span>}
</span></code></pre>
<p>This is just a function signature, but seeing this immediately makes me think
of ways that something can be extracted into a different kind of pattern.</p>
<p>HTTP middleware has the signature: <code>func(http.Handler) http.Handler</code>.</p>
<p>We can update our function to look like this:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>WithTimeout</span><span>(timeout time.</span><span>Duration</span><span>) </span><span>func</span><span>(</span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>return func</span><span>(r </span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>Is this actually useful? How would this be used in practice?</p>
<p>Probably <em>not</em> by doing: <code>WithTimeout(timeout)(view)</code>, but if we had some way
of applying these, like: <code>Compose(view, WithTimeout(timeout))</code>, this might be ok.</p>
<p>Let&#39;s just save this idea for later...</p>
<h3 id="a-renderable-function">A Renderable function</h3>
<p>Something that <em>is</em> interesting here though is the part we gloss
over, (<code>// ...</code>). Sometimes we don&#39;t need a full struct, sometimes
we only need a closure, and the resulting code can be clearer and
simpler to reason about.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>RenderableFunc </span><span>func</span><span>(context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>)
</span><span>
</span><span>func </span><span>(f </span><span>RenderableFunc</span><span>) </span><span>Renderable</span><span>(ctx context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>f(ctx)
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      moving renderable to renderable.go, adding RenderableFunc
      <a href="https://github.com/stanistan/veun/commit/8c05c6653563aa8b19879b46e59cd5addebf7131">(source: 8c05c665)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/renderable.go b/renderable.go
</span><span>new file mode 100644
</span><span>index 0000000..57f3791
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/renderable.go
</span><span>@@ -0,0 +1,21 @@
</span><span>+</span><span>package veun
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type Renderable interface {
</span><span>+</span><span>	Template(ctx context.Context) (*template.Template, error)
</span><span>+</span><span>	TemplateData(ctx context.Context) (any, error)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>type AsRenderable interface {
</span><span>+</span><span>	Renderable(ctx context.Context) (Renderable, error)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>type RenderableFunc func(context.Context) (Renderable, error)
</span><span>+
</span><span>+</span><span>func (f RenderableFunc) Renderable(ctx context.Context) (Renderable, error) {
</span><span>+</span><span>	return f(ctx)
</span><span>+</span><span>}
</span><span>diff --git a/renderer.go b/renderer.go
</span><span>index 33af885..ebbddef 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -7,15 +7,6 @@ import (
</span><span> 	&#34;html/template&#34;
</span><span> )
</span><span> 
</span><span>-type Renderable interface {
</span><span>-	Template(ctx context.Context) (*template.Template, error)
</span><span>-	TemplateData(ctx context.Context) (any, error)
</span><span>-}
</span><span>-
</span><span>-type AsRenderable interface {
</span><span>-	Renderable(ctx context.Context) (Renderable, error)
</span><span>-}
</span><span>-
</span><span> func Render(ctx context.Context, r AsRenderable) (template.HTML, error) {
</span><span> 	renderable, err := r.Renderable(ctx)
</span><span> 	if err != nil {
</span><span>
</span></code></pre>


  </details>
</div>
<p>And now to use it:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>WithTimeout</span><span>(timeout time.</span><span>Duration</span><span>) </span><span>func</span><span>(</span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>return func</span><span>(r </span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>        </span><span>return </span><span>RenderableFunc(</span><span>func</span><span>(ctx context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>            ctx, _ </span><span>= </span><span>context.WithTimeout(timeout)
</span><span>            </span><span>return </span><span>r.Renderable(ctx)
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<p><em>N.B.</em> Because go contexts are copies, cancelling subtree renders
<strong>MUST BE</strong> done through delegating.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>WithErrorHandler</span><span>(eh </span><span>ErrorRenderable</span><span>) </span><span>func</span><span>(</span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>return func</span><span>(r </span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>        </span><span>return </span><span>FallibleView{Contents: r, ErrorRenderable: eh}
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="can-we-put-it-together">Can we put it together?</h2>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>Compose</span><span>(r </span><span>AsRenderable</span><span>, fs </span><span>...func</span><span>(</span><span>AsRenderable</span><span>) </span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>for </span><span>_, f </span><span>:= range </span><span>fs {
</span><span>        r </span><span>= </span><span>f(r)
</span><span>    }
</span><span>    </span><span>return </span><span>r
</span><span>}
</span><span>
</span><span>r </span><span>:= </span><span>Compose(r, WithTimeout(timeout), WithErrorHandler(eh))
</span><span>html, err </span><span>:= </span><span>Render(ctx, r)
</span></code></pre>
<p>Except for writing <code>AsRenderable</code> over and over and over again, that&#39;s not so bad,
and the usage is nice.</p>

        </section>

        

    </article></div>
  </body>
</html>
