<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://404wolf.com/posts/valtowneditor/">Original</a>
    <h1>Fullstack Language Servers</h1>
    
    <div id="readability-page-1" class="page"><div><p><span>Fullstack Language Servers</span><span></span></p></div><div><astro-slot> <div>  <p><strong>Note: This is a cross-post from my original post at
<a href="https://blog.val.town/vt-cli">https://blog.val.town/vt-cli</a></strong></p>

<p>Here‚Äôs a live demo of Val Town‚Äôs new open source ‚Äúfullstack‚Äù LSP implementation,
running on a Cloudflare container, on a simple vite/Cloudflare worker frontend,
with our react/codemirror ls library. To use it, press the ‚Äúconnect‚Äù button,
and then start editing the code!</p>

<p>(or watch a short demo here:)</p>

<p>Val Town makes it easy to ship TypeScript automations and applications to the
internet via an integrated web editor experience. We strive to offer a magical
tight feedback loop, with 100ms deploys on save.</p>
<p>That online editor experience should be great: we should support high-quality
highlighting, autocompletion, information for when you hover over bits of code.
But unfortunately it hasn‚Äôt been so: our previous editor has been buggy and slow
to give useful TypeScript feedback.</p>
<p>But now, we‚Äôve rewritten our editor‚Äôs TypeScript integration from scratch. It‚Äôs
available to all Val Town users, is fast and accurate, and
<a href="https://github.com/val-town/vtlsp">the code is open source</a>.</p>
<h2 id="our-old-system-running-typescript-in-a-web-worker">Our old system: running TypeScript in a Web Worker</h2>
<p>Our previous language integration was entirely client-side. We ran a TypeScript
<a href="https://github.com/microsoft/TypeScript-wiki/blob/main/Using-the-Language-Service-API.md">Language Service Host</a>
in a Web Worker, to isolate it from the top frame‚Äôs thread, and communicated
between the Web Worker and top frame using
<a href="https://github.com/GoogleChromeLabs/comlink">Comlink</a>.</p>
<p>The system looked like this:</p>
<p><img src="https://imagedelivery.net/iHX6Ovru0O7AjmyT5yZRoA/476d273a-ca88-4e66-f31d-58317844fa00/public" alt="codemirror-ts system diagram"/></p>
<p>And we bundled it into
<a href="https://github.com/val-town/codemirror-ts/">codemirror-ts</a>, a
<a href="https://codemirror.net/">CodeMirror</a> extension, and
<a href="https://github.com/val-town/deno-ata">Deno-ATA</a>, an incomplete implementation
of Deno‚Äôs import resolution logic grafted onto TypeScript‚Äôs capabilities.</p>
<p>This solution worked great in the simplest cases, but stumbled when importing
certain NPM packages, and required more and more workarounds. The main two
issues we were facing were these:</p>
<ol>
<li><strong>TypeScript isn‚Äôt written for Deno.</strong> At Val Town, we run Deno, a modern
JavaScript runtime that differs from standard TypeScript. Deno supports URL
imports, provides server-side APIs through the Deno global (like environment
variables), and introduces its own quirks. Sometimes we‚Äôve been able to work
around these differences. For example, we could use Deno type definitions.
But in other cases, like handling URL imports, it requires us to interpret
files differently. Deno is distinct enough that it ships its own language
server, built in Rust and wrapping tsserver.</li>
<li><strong>NPM modules can be gigantic and installing dependencies is no joke.</strong> Huge
import trees for NPM modules are nothing new, but at least when you‚Äôre
installing NPM modules locally, you have the brilliant minds of the package
manager implementers to do module resolution: to install the minimal number
of packages by comparing semver ranges. We didn‚Äôt have that luxury, and often
referencing an NPM module would trigger an avalanche of HTTP requests and
bytes downloaded, which would overload the Web Worker and make the editor‚Äôs
language tools unresponsive.</li>
</ol>
<h2 id="bringing-denols-to-val-town">Bringing DenoLS to Val Town</h2>
<p>So, we redesigned our editor‚Äôs TypeScript handling. Instead of running TSserver
in a Web Worker, we now run the official Deno Language Server remotely in cloud
containers.</p>
<p>We no longer suffer writing our own workarounds to the mismatch between
TypeScript and Deno, because the Deno project‚Äôs
<a href="https://github.com/denoland/deno/tree/main/cli/lsp">Rust code that wraps around a TypeScript instance</a>
solves all those problems. Your browser doesn‚Äôt struggle to download huge NPM
dependency trees because a beefy server does that for you, from a faster
connection.</p>
<p>Now, when you visit our editor, we launch a containerized server that exposes a
WebSocket and speaks the LSP protocol. The architecture was partially inspired
<a href="https://hjr265.me/blog/codemirror-lsp/#language-server-over-websocket">Mahmud Ridwan‚Äôs great writeup of connecting CodeMirror &amp; an LSP</a>,
with the main difference being that we directly map stdio to the WebSocket
rather than serializing messages, because
<a href="https://www.npmjs.com/package/vscode-jsonrpc">vscode-jsonrpc can do that for us!</a>.</p>
<h2 id="our-open-source-implementation">Our open source implementation</h2>
<p>To tweak the language server for our unique purpose, while keeping the
Codemirror extensions LSP-generic, we also took inspiration from the official
<a href="https://www.npmjs.com/package/vscode-languageclient">VS Code LSP client library</a>,
which we couldn‚Äôt use directly because of its reliance on VS Code globals. Their
client provides a way to use
<a href="https://github.com/microsoft/vscode-languageserver-node/blob/3412a17149850f445bf35b4ad71148cfe5f8411e/client/src/common/client.ts#L347">middleware and URI transforms</a>
so that you can easily tweak the language server at the client level when
writing VS Code plugins. Transforming URIs makes it easy to spawn the language
server from a temp directory but map file paths as if they were relative to the
root, and middleware modify the language server for our unique use case, like
automatically downloading dependencies when the server sends the client a red
squiggle saying a package isn‚Äôt installed. We built a similar style system as a
<a href="https://www.npmjs.com/package/@valtown/ls-ws-server">Language Server proxy server library</a>.
It acts as a language server of its own, but can arbitrarily modify messages
passing through it.</p>
<p>To actually host the LSP as a WebSocket server, there are various subtleties
that were important for our use case. We want to keep connections persisted even
when the editor leaves, and allow multiple clients to connect to the same
language server instance (to support multi tab, or even multi-browser/device
editing). <a href="https://github.com/val-town/vtlsp">Our implementation</a> uses a stream
WebSocket wrapper and pipes stdio directly, and manages multicasting connections
so many clients can talk to the same process at once.</p>
<h3 id="bringing-it-to-the-browser">Bringing it to the Browser</h3>
<video src="https://github.com/user-attachments/assets/5abbc5a3-b397-40fb-beed-f9595021f7a3" width="640" height="360" controls="" autoplay="" loop=""></video>
<p>Once we had a language server <em>server</em> in place, we needed a client. This will
be querying for hover information on symbol hovers, displaying red squiggles,
and all of the rest of the language-specific tooling. The
<a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/">LSP specification</a>
is quite sprawling ‚Äì there are many fun features to support, like code actions
(buttons such as ‚Äúinfer return type‚Äù) and method suggestions (that pop up as you
call functions). Meanwhile we need the client to keep documents synced with the
language server, and send document update events.</p>
<p>There are
<a href="https://discuss.codemirror.net/t/codemirror-lsp-client/9309">some existing</a>
CodeMirror language server
<a href="https://discuss.codemirror.net/t/state-of-lsps-in-codemirror-reference/8601">client implementations</a>,
which we pulled from when building
<a href="https://www.npmjs.com/package/@valtown/codemirror-ls">our own</a>. We wrote our
own so that we could support more arbitrary transports, in our case WebSockets
with message chunking, external renderers for language server UIs (like to be
able to use libraries like react, highlight.js, or remark), and take external
callback inputs (so that you can implement things like going to definition on an
external document).</p>
<h2 id="shipping-on-cloudflare-containers">Shipping on Cloudflare Containers</h2>
<p>For deploying our language servers, it was important that we kept user workloads
isolated because code is private. Even though we are running language server
processes in temporary directories, you can still infer types of libraries in
other directories by importing upwards ‚Äù../../‚Äù, and possibly even hop to their
definition.</p>
<p>We also wanted servers to live for as long as the user‚Äôs session. Someone might
be editing code for two hours, so a solution like traditional AWS Lambda would
be a tough fit. Finally, we wanted to restrict users to using a limited amount
of language server resources at a time.</p>
<p>Initially, <a href="https://fly.io">fly</a> seemed like a great option. We could spin up
containers on the fly (ü•Å) and shut them down when not needed. The issues we saw
with fly were that we‚Äôd need to manually manage the lifecycles of our
containers, routing individual users to unique containers, and make sure
containers shut down after some amount of time not sending heartbeats from the
client.</p>
<p>When Cloudflare announced
<a href="https://developers.cloudflare.com/containers/">Cloudflare containers</a>, they
immediately seemed like a perfect choice. Cloudflare containers fit within their
worker/durable object ecosystem and are tenants of durable objects. This means
that they are routable by an arbitrary ID, and that the durable object layer (a
persistent, serverless, JavaScript class instance) can internally manage
container lifecycles. In our case, we‚Äôre routing users to a durable object with
the ID that is their literal user ID, and then using their
<a href="https://www.npmjs.com/package/@cloudflare/containers">container library</a> to
shut containers down after inactivity.</p>
<p>This means that we didn‚Äôt actually need to implement any stateful routing layer
ourselves. When you want to connect to a Val Town language server, you simply
hit our Cloudflare worker with a signed cookie containing your user ID, which
routes you directly to a already-running, or brand-new durable object/container
that boots your LSP. In the future, it will also be easy to hook into
Cloudflare‚Äôs built in worker sqlite db to internally manage utilization too.</p>
<p>All together, the architecture ends up looking like this:</p>
<p><img src="https://imagedelivery.net/iHX6Ovru0O7AjmyT5yZRoA/057b670d-412d-467e-a7bf-7d9743fdd400/public" alt="VTLSP after"/></p>
<p>A server replaced the WebWorker, and instead of communicating by postMessage
(via Comlink, to a WebWorker), we now use a WebSocket. But the biggest win here
is using the Deno Language Server and an isolated server for running language
tooling: this lets us piggy-back on the stock implementation of module
resolution and keep those huge NPM dependency trees out of the browser‚Äôs
responsibilities.</p>
<h2 id="try-it-out-1">Try it out</h2>
<p>The easiest way to see this all in action is to
<a href="https://www.val.town/auth/signup">sign up for Val Town</a> and write some code!
While we‚Äôll continue striving for perfection, it‚Äôs nice to know that we‚Äôve
gotten a lot closer to it this summer.</p>
<p>Out is the editor that was slow, buggy, and required a lot of custom
workarounds. Now every user has the full, luxurious Deno language server
experience.</p>
<p>Now that our editor is in production, it will only continue to improve. We have
plans to add more Val Town specific language server functionality, like
suggesting Val Town standard library function imports, giving useful diagnostics
about aspects of Deno that behave differently on our platform, and adding more
language server features.</p>
<p>We‚Äôve also open-sourced everything you need to ship your own cloud container
WebSocket language server as <a href="https://github.com/val-town/vtlsp">vtlsp</a>. This
repo includes the client, server, and proxy, which you can see in the demo
below.</p>
<p><img alt="Open Source Demo" src="https://camo.githubusercontent.com/3939b36c2739eff6a75954445a74f69424e1aacf64cfe0a7e4c68e93867cb235/68747470733a2f2f66696c6564756d707468696e672e76616c2e72756e2f626c6f622f626c6f625f66696c655f313735353132363236343733345f6f75747075742e676966"/>  </p></div> </astro-slot></div></div>
  </body>
</html>
