<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unplannedobsolescence.com/blog/prolog-basics-pokemon/">Original</a>
    <h1>Prolog Basics Explained with Pokémon</h1>
    
    <div id="readability-page-1" class="page"><header>
  
  <nav>
  <ul>
    <li><a href="https://www.nprillinois.org/">Home</a>
    </li><li><a href="https://www.nprillinois.org/blog">Blog</a>
    </li><li><a href="https://www.nprillinois.org/talks">Talks</a>
    </li><li><a href="https://www.nprillinois.org/about">About</a>
    </li><li><a href="https://www.nprillinois.org/atom.xml">RSS</a>
  </li></ul>
  </nav>
</header>
<hr/>




<p>January 05, 2026</p>


<p>The project that inspired this post is a little silly—I am about to describe the mechanics of a children’s video game in great detail—but this particular problem is what finally made Prolog click for me, an epiphany I’ve been hunting for ever since reading Bruce Tate’s “Seven Languages in Seven Weeks.”</p>
<p>This exercise has taught me a lot about the kinds of interfaces I’m trying to build in <a href="https://alexanderpetros.com/triptych/">somewhat more practical domains</a>.
For certain kinds of relationships, logic programming is by far the most concise and expressive programming system I’ve ever used.</p>
<p>To understand why, let’s talk about Pokémon.</p>
<h2 id="pokemon-basics"><a href="#pokemon-basics" aria-label="Anchor link for: pokemon-basics">Pokémon basics</a></h2>
<p>Pokémon is a video game series/multimedia franchise/lifestyle brand set in a world where humans live alongside a menagerie of colorful animal characters.</p>
<p>“Pokémon” is both the name of the franchise and the generic term for the animal characters themselves, which all have their own individual species names.
There are over a thousand distinct species of Pokémon, from Bulbasaur (<a href="https://bulbapedia.bulbagarden.net/wiki/Bulbasaur_(Pok%C3%A9mon)">#1</a>) to Pecharunt (<a href="https://bulbapedia.bulbagarden.net/wiki/Pecharunt_(game)">#1025</a>).</p>
<figure>
  <p><img src="https://www.nprillinois.org/illinois/2026-01-06/images/pikachu.png" height="100" width="100" alt="the pokemon pikachu, an electric mouse"/>
    <img src="https://www.nprillinois.org/illinois/2026-01-06/images/archeops.png" height="100" width="100" alt="the pokemon archeops, a colorfully-feathered rock bird"/>
    <img src="https://www.nprillinois.org/illinois/2026-01-06/images/dipplin.png" height="100," width="100" alt="the pokemon dipplin, which kind of looks like a candy apple that fell on the ground"/>
  </p>
  <figcaption>
    Popular Pokémon include (from left to right):</figcaption>
</figure>

<p>There are all sorts of Pokémon games now, but the main series has always been about catching and battling them.
During a battle, your team of six Pokémon faces off against another team.
Each Pokémon is equipped with four moves that it can choose to (usually) do damage to their opponent.
You need to reduce the HP (Hit Points) of all your opponent’s Pokémon to zero before they are able to do so to you.</p>
<p>Each Pokémon has unique traits that affects how it battles.
They have a set of base stats, a large pool of possible moves, a handful of abilities, and a typing.
As you will see in a moment, the immense number of combinations here is the motivation for trying to track this with software.</p>
<figure>
  <img src="https://www.nprillinois.org/illinois/2026-01-06/images/scizor-stats.png" alt="A screenshot showing Scizor&#39;s abilities, typing, and stats"/>
  <figcaption>Scizor is a Bug/Steel type with high Attack and low Speed (via <a href="https://www.smogon.com/dex/bw/pokemon/scizor/">Smogon</a>)</figcaption>
</figure>

<p>Typing is especially important.
Moves have a type, like Fire or Rock, and Pokémon can have up to two types.
A move with a type that is Super Effective against the opposing Pokémon will do double damage; a move that is Not Very Effective will do half damage.</p>
<p>It’s a little more intuitive with examples.
The Fire-type move <span>Flamethrower</span> will do 2x to Grass-type Pokémon, because Grass is weak to Fire, but the Water-type move <span>Surf</span> will only do ½ damage to them, because Grass resists Water.</p>
<figure>
    <img src="https://www.nprillinois.org/illinois/2026-01-06/images/surf.png" alt="Miltoic using Surf against a Lunatone in a Generation 3 Pokémon game."/>
  <figcaption>
    <a href="https://bulbapedia.bulbagarden.net/wiki/Lunatone_(Pok%C3%A9mon)">Lunatone</a> is a Rock/Psychic Type. Rock is weak to Water, and Psychic is neutral to it, so <span>Surf</span> will do 2x damage.
  </figcaption>
</figure>
<p>Type modifiers can stack.
<a href="https://bulbapedia.bulbagarden.net/wiki/Scizor_(Pok%C3%A9mon)">Scizor</a> is a Bug/Steel type, and <em>both</em> Bug and Steel are weak to Fire, so Fire moves will do 4x damage to Scizor.
Electric is weak to Water, but Ground is immune, so if you use an Electric type move against Water/Ground <a href="https://bulbapedia.bulbagarden.net/wiki/Swampert_(Pok%C3%A9mon)">Swampert</a>, you’ll do zero damage, since 0×2 is still 0.</p>
<p>Naturally, there is a chart to help you keep track.</p>
<figure>
<img src="https://www.nprillinois.org/illinois/2026-01-06/images/type-chart.svg" alt="The Pokémon type chart."/>
<figcaption>
  Pokémon Type Chart (via <a href="https://commons.wikimedia.org/wiki/File:Pokemon_Type_Chart.svg">Wikimedia</a>)
</figcaption>
</figure>
<p>Those are effectively the mechanics of the Pokémon video games as I understood them when I was 8.
Click moves to do damage, try to click moves with good type matchups.
These games are for children and, at the surface level, they’re not very hard.</p>
<h2 id="prolog-basics"><a href="#prolog-basics" aria-label="Anchor link for: prolog-basics">Prolog basics</a></h2>
<p>Before I explain how wonky the Pokémon mechanics can get under the hood, I first need to explain how logic programming works.
Pokémon is a great fit for logic programming because Pokémon battles are essentially an extremely intricate rules engine.</p>
<p>Let’s start by creating a file with a bunch of facts.</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>pokemon(bulbasaur).
</span><span>pokemon(ivysaur).
</span><span>pokemon(venusaur).
</span><span>pokemon(charmander).
</span><span>pokemon(charmeleon).
</span><span>pokemon(charizard).
</span><span>pokemon(squirtle).
</span><span>pokemon(wartortle).
</span><span>pokemon(blastoise).
</span></code></pre>
<p>In Prolog, we declare “predicates.”
Predicates define relationships: <code>bulbasaur</code> is a <code>pokemon</code>, <code>charmander</code> is a <code>pokemon</code>, and so on.
We refer to this predicate as <code>pokemon/1</code>, because the name of the predicate is <code>pokemon</code> and it has one argument.</p>
<p>These facts are loaded into an interactive prompt called the “top-level.”
You query the top-level by typing a statement into the prompt;
Prolog tries to find all the ways to make that statement true.
When there’s more than one possible solution, the top-level displays the first solution and then awaits user input.
You can then have it display one more solution, all the solutions, or stop entirely.</p>
<p>In this first example, we type <code>pokemon(squirtle).</code> and hit Enter.
The top-level replies <code>true.</code>
<a href="https://bulbapedia.bulbagarden.net/wiki/Squirtle_(Pok%C3%A9mon)">Squirtle</a> is, in fact, a Pokémon.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- pokemon(squirtle).
</span><span>   true.
</span></code></pre>

<p>Not all things are Pokémon.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- pokemon(alex).
</span><span>   false.
</span></code></pre>
<p>Let’s add Pokémon types in there, as the predicate <code>type/2</code>.</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>type(bulbasaur, grass).
</span><span>type(bulbasaur, poison).
</span><span>type(ivysaur, grass).
</span><span>type(ivysaur, poison).
</span><span>type(venusaur, grass).
</span><span>type(venusaur, poison).
</span><span>type(charmander, fire).
</span><span>type(charmeleon, fire).
</span><span>type(charizard, fire).
</span><span>type(charizard, flying).
</span><span>type(squirtle, water).
</span><span>type(wartortle, water).
</span><span>type(blastoise, water).
</span></code></pre>

<p>Recall that some Pokémon have just one type while others have two.
In the latter case, that’s modeled with two <code>type</code> facts.
<a href="https://bulbapedia.bulbagarden.net/wiki/Bulbasaur_(Pok%C3%A9mon)">Bulbasaur</a> is a Grass type, and Bulbasaur is a Poison type; both are true.
The paradigm is similar to a One-To-Many relation in a SQL database.</p>
<p>Interactively, we can confirm whether Squirtle is a water type.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- type(squirtle, water).
</span><span>   true.
</span></code></pre>
<p>Can we state that Squirtle is a Grass type?</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- type(squirtle, grass).
</span><span>   false.
</span></code></pre>
<p>No, because Squirtle is a Water type.</p>
<p>Suppose we didn’t know what type Squirtle was.
We can ask!</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- type(squirtle, Type).
</span><span>   Type = water.
</span></code></pre>
<p>In Prolog, names that start with an upper-case letter are variables.
Prolog tries to “unify” the predicate with all possible matches for the variable.
There’s only one way to make this particular predicate true though: <code>Type</code> has to be <code>water</code>, because Squirtle’s only type is Water.</p>
<p>For Pokémon with two types, the predicate unifies twice.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- type(venusaur, Type).
</span><span>   Type = grass
</span><span>;  Type = poison.
</span></code></pre>
<p>Semantically, that leading semicolon on the third line means “or.”
<code>type(venusaur, Type)</code> is true when <code>Type = grass</code> or when <code>Type = poison</code>.</p>
<p>Any of the terms can be be a variable, which means we can ask questions in any direction.
What are all the Grass types?
Just make the first argument the variable, and set the second argument to <code>grass</code>.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- type(Pokemon, grass).
</span><span>   Pokemon = bulbasaur
</span><span>;  Pokemon = ivysaur
</span><span>;  Pokemon = venusaur
</span><span>;  Pokemon = oddish
</span><span>;  Pokemon = gloom
</span><span>;  Pokemon = vileplume
</span><span>;  Pokemon = paras
</span><span>;  Pokemon = parasect
</span><span>;  Pokemon = bellsprout
</span><span>;  ... .
</span></code></pre>

<p>I cut it off, but the prompt would happily would list all 164 of them.</p>
<p>Commas can be used to list multiple predicates—Prolog will unify the variables such that all of them are true.
Listing all the Water/Ice types is just a matter of asking what Pokémon exist that unify with both the Water and Ice types.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- type(Pokemon, water), type(Pokemon, ice).
</span><span>   Pokemon = dewgong
</span><span>;  Pokemon = cloyster
</span><span>;  Pokemon = lapras
</span><span>;  Pokemon = laprasgmax
</span><span>;  Pokemon = spheal
</span><span>;  Pokemon = sealeo
</span><span>;  Pokemon = walrein
</span><span>;  Pokemon = arctovish
</span><span>;  Pokemon = ironbundle
</span><span>;  false.
</span></code></pre>

<p>Even though <code>Pokemon</code> is a variable, in the context of the query, both instances of it have to be the same (just like in algebra).
The query only unifies for values of <code>Pokemon</code> where both those predicates hold.
For instance, the Water/Ice type <a href="https://bulbapedia.bulbagarden.net/wiki/Dewgong_(Pok%C3%A9mon)">Dewgong</a> is a solution because our program contains the following two facts:</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>type(dewgong, water).
</span><span>type(dewgong, ice).
</span></code></pre>
<p>Therefore, subbing in  <code>dewgong</code> for the <code>Pokemon</code> variable satisfies the query.
Squirtle, by contrast, is just a Water type: <code>pokemon(squirtle, water)</code> exists, but not <code>pokemon(squirtle, ice)</code>.
The query requires both to unify, so <code>squirtle</code> is not a possible value for <code>Pokemon</code>.</p>
<p>Pokémon have lots of data that you can play around with.
<a href="https://bulbapedia.bulbagarden.net/wiki/Iron_Bundle_(Pok%C3%A9mon)">Iron Bundle</a> is a strong Water/Ice-type Pokémon with high Special Attack.
How high exactly?</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- pokemon_spa(ironbundle, SpA).
</span><span>   SpA = 124.
</span></code></pre>
<p>With Special Attack that high, we want to make use of strong Special moves.
What Special moves does Iron Bundle know?</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- learns(ironbundle, Move), move_category(Move, special).
</span><span>   Move = aircutter
</span><span>;  Move = blizzard
</span><span>;  Move = chillingwater
</span><span>;  Move = freezedry
</span><span>;  Move = hydropump
</span><span>;  Move = hyperbeam
</span><span>;  Move = icebeam
</span><span>;  Move = icywind
</span><span>;  Move = powdersnow
</span><span>;  Move = swift
</span><span>;  Move = terablast
</span><span>;  Move = waterpulse
</span><span>;  Move = whirlpool.
</span></code></pre>
<p><span>Freeze-Dry</span> is a particularly good Special move.
Here’s a query for all Ice-type Pokémon with Special Attack greater than 120 that learn <span>Freeze-Dry</span>.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- pokemon_spa(Pokemon, SpA), SpA #&gt; 120, learns(Pokemon, freezedry), type(Pokemon, ice).
</span><span>   Pokemon = glaceon, SpA = 130
</span><span>;  Pokemon = kyurem, SpA = 130
</span><span>;  Pokemon = kyuremwhite, SpA = 170
</span><span>;  Pokemon = ironbundle, SpA = 124
</span><span>;  false.
</span></code></pre>
<p>One last concept before we move on: Rules.
Rules have a head and a body, and they unify if the body is true.</p>
<p>A move is considered a damaging move if it’s either a Physical Move or a Special Move.
The <code>damaging_move/2</code> predicate defines all the moves that do direct damage.</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>damaging_move(Move) :-
</span><span>  move_category(Move, physical)
</span><span>; move_category(Move, special).
</span></code></pre>
<p>This will unify with any moves that do direct damage.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- damaging_move(tackle).
</span><span>   true.
</span><span>?- damaging_move(rest).
</span><span>   false.
</span></code></pre>
<h2 id="sql-comparison"><a href="#sql-comparison" aria-label="Anchor link for: sql-comparison">SQL comparison</a></h2>
<p>Nothing I’ve shown so far is, logically speaking, very ambitious—just “and” and “or” statements about various facts.
It’s essentially a glorified lookup table.
Still, take a moment to appreciate how much nicer it is to query this database than a plausible alternative, like SQL.</p>
<p>For the facts we’ve seen so far, I would probably set up SQL tables like this:</p>
<pre data-lang="sql"><code data-lang="sql"><span>-- Omitting the other stats to be concise
</span><span>CREATE TABLE </span><span>pokemon</span><span> (pokemon_name </span><span>TEXT</span><span>, special_attack </span><span>INTEGER</span><span>);
</span><span>CREATE TABLE </span><span>pokemon_types</span><span>(pokemon_name </span><span>TEXT</span><span>, type </span><span>TEXT</span><span>);
</span><span>CREATE TABLE </span><span>pokemon_moves</span><span>(pokemon_name </span><span>TEXT</span><span>, move </span><span>TEXT</span><span>, category </span><span>TEXT</span><span>);
</span></code></pre>

<p>Then query it like so:</p>
<pre data-lang="sql"><code data-lang="sql"><span>SELECT DISTINCT</span><span> pokmeon, special_attack
</span><span>FROM</span><span> pokemon as p
</span><span>WHERE
</span><span>  </span><span>p</span><span>.</span><span>special_attack </span><span>&gt; </span><span>120
</span><span>  AND EXISTS (
</span><span>    </span><span>SELECT </span><span>1
</span><span>    </span><span>FROM</span><span> pokemon_moves as pm
</span><span>    </span><span>WHERE </span><span>p</span><span>.</span><span>pokemon_name </span><span>= </span><span>pm</span><span>.</span><span>pokemon_name </span><span>AND move = &#39;</span><span>freezedry</span><span>&#39;
</span><span>  )
</span><span>  AND EXISTS (
</span><span>    </span><span>SELECT </span><span>1
</span><span>    </span><span>FROM</span><span> pokemon_types as pt
</span><span>    </span><span>WHERE </span><span>p</span><span>.</span><span>pokemon_name </span><span>= </span><span>pt</span><span>.</span><span>pokemon_name </span><span>AND type = &#39;</span><span>ice</span><span>&#39;
</span><span>  );
</span></code></pre>
<p>For comparison, here’s the equivalent Prolog query again:</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- pokemon_spa(Pokemon, SpA),
</span><span>SpA #&gt; 120,
</span><span>learns(Pokemon, freezedry),
</span><span>type(Pokemon, ice).
</span></code></pre>
<p>I’m not ripping on SQL—I love SQL—but that’s the best declarative query language most people interact with.
It’s amazing to me how much simpler and more flexible the Prolog version is.
The SQL query would become unmanageably complex if we continued to add clauses, while the Prolog query remains easy to read and edit (once you get the hang of how variables work).</p>
<h2 id="level-up"><a href="#level-up" aria-label="Anchor link for: level-up">Level up</a></h2>
<p>With the basics established, here’s some context on the project I’m working on.</p>
<p>Pokémon battles have an outrageous number of mechanics that all interact in complex and probabilistic ways.
Part of the appeal of these games is the futile attempt to keep them all in your head better than your opponent, using that information to out-predict and out-maneuver their plans.
It’s a sort of like very silly Poker.</p>
<details>
<summary>A small subset of game mechanics I have not yet mentioned</summary>
<ul>
  <li> Some moves miss a certain percentage of the time, doing no damage.
  </li><li> Some moves raise or lower a Pokémon&#39;s stats.
  </li><li> Pokémon can hold items that have various effects.
  </li><li> Damage calculations aren&#39;t constant; moves do normally-distributed damage within the calculated range.
  </li><li> Pokémon can get frozen, burned, paralyzed, poisoned, or fall asleep; these all have various adverse effects.
  </li><li> There are a variety of field effects (like weather, terrain, Trick Room) which alter move damage, turn order, and other things.
  </li><li> Pokémon each have an ability that has various effects i.e Levitate makes you immune to ground moves, Drizzle turns the weather to Rain when the Pokemon switches in, Sheer Force disables a move&#39;s side effects but multiplies its damage by 1.3x.
  </li><li> Players have points they (invisibly) allocate to each Pokémon before the game, to boost chosen stats. Depending on they built the team, each Pokemon might do more damage or take hits better than you were expecting.
</li></ul>
</details>
<p>The challenge, if you want to build software for this game, is to model all that complexity without losing your mind.
Prolog is stunningly good at this, for two main reasons:</p>

<ol>
<li>The query model excels at describing ad-hoc combinations.</li>
<li>The data model is perfectly suited to layering rules in a consistent way.</li>
</ol>

<p>To illustrate that, here’s how I implemented priority moves for my Pokémon draft league.</p>
<p>Pokémon draft is pretty much what it sounds like.
Pokémon are given a point value based on how good they are, each player is given a certain amount of points to spend, and you draft until every player has spent their points.
Your team ends up with about 8-11 Pokémon and each week you go head to head against another person in the league.
My friend and <a href="https://wemakeinter.net/">WMI</a> collaborator <a href="https://wttdotm.com/">Morry</a> invited me to his a couple years ago and I’ve been hooked on the format ever since.</p>
<p>The games are 6v6, so a big part of the battle is preparing for all the possible combinations of six your opponent could bring, and putting together six of your own that can handle all of them.</p>
<p>Naturally, you can only build teams with the Pokémon you drafted.
I just made that predicate my name: <code>alex/1</code>.</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>alex(meowscarada).
</span><span>alex(weezinggalar).
</span><span>alex(swampertmega).
</span><span>alex(latios).
</span><span>alex(volcarona).
</span><span>alex(tornadus).
</span><span>alex(politoed).
</span><span>alex(archaludon).
</span><span>alex(beartic).
</span><span>alex(dusclops).
</span></code></pre>

<p>What Pokémon do I have that learn <span>Freeze-Dry</span>?</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- alex(Pokemon), learns(Pokemon, freezedry).
</span><span>   false.
</span></code></pre>
<p>None. Rats.</p>
<p>One very important type of move is priority moves.
Earlier I mentioned that the Speed stat controls which Pokémon moves first.
Some nuance: the Pokémon that used the move with the highest priority goes first, and if they both selected a move of the same priority, then the one with the higher Speed goes first.</p>
<p>Most moves have a priority of zero.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- move_priority(Move, P).
</span><span>   Move = &#39;10000000voltthunderbolt&#39;, P = 0
</span><span>;  Move = absorb, P = 0
</span><span>;  Move = accelerock, P = 1
</span><span>;  Move = acid, P = 0
</span><span>;  Move = acidarmor, P = 0
</span><span>;  Move = aciddownpour, P = 0
</span><span>;  Move = acidspray, P = 0
</span><span>;  Move = acrobatics, P = 0
</span><span>;  Move = acupressure, P = 0
</span><span>;  Move = aerialace, P = 0
</span><span>;  Move = aeroblast, P = 0
</span></code></pre>
<p>Ah, but not all! <span>Accelerock</span> has a priority of 1.
A Pokémon that uses <span>Accelerock</span> will move before
any Pokémon that uses a move with priority 0 (or less), even if the latter Pokémon has a higher Speed stat.</p>
<p>I define a <code>learns_priority/3</code> predicate that unifies with a Pokémon, the priority move it learns, and what priority that move is.</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>learns_priority(Pokemon, Move, P) :-
</span><span>  learns(Pokemon, Move),
</span><span>  move_priority(Move, P),
</span><span>  move_priority #&gt; 0.
</span></code></pre>
<p>A simple query that asks “what priority moves does my team learn” returns a <em>lot</em> of answers.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- alex(Pokemon), learns_priority(Pokemon, Move, Priority).
</span><span>   Pokemon = meowscarada, Move = endure, Priority = 4
</span><span>;  Pokemon = meowscarada, Move = helpinghand, Priority = 5
</span><span>;  Pokemon = meowscarada, Move = protect, Priority = 4
</span><span>;  Pokemon = meowscarada, Move = quickattack, Priority = 1
</span><span>;  Pokemon = meowscarada, Move = allyswitch, Priority = 2
</span><span>;  Pokemon = meowscarada, Move = suckerpunch, Priority = 1
</span><span>;  Pokemon = weezinggalar, Move = endure, Priority = 4
</span><span>;  Pokemon = weezinggalar, Move = protect, Priority = 4
</span><span>;  Pokemon = swampertmega, Move = bide, Priority = 1
</span><span>;  Pokemon = swampertmega, Move = endure, Priority = 4
</span><span>;  Pokemon = swampertmega, Move = helpinghand, Priority = 5
</span><span>;  Pokemon = swampertmega, Move = protect, Priority = 4
</span><span>;  Pokemon = swampertmega, Move = wideguard, Priority = 3
</span><span>;  Pokemon = latios, Move = allyswitch, Priority = 2
</span><span>;  Pokemon = latios, Move = endure, Priority = 4
</span><span>;  Pokemon = latios, Move = helpinghand, Priority = 5
</span><span>;  Pokemon = latios, Move = magiccoat, Priority = 4
</span><span>;  Pokemon = latios, Move = protect, Priority = 4
</span><span>;  Pokemon = volcarona, Move = endure, Priority = 4
</span><span>;  Pokemon = volcarona, Move = protect, Priority = 4
</span><span>;  Pokemon = volcarona, Move = ragepowder, Priority = 2
</span><span>;  Pokemon = tornadus, Move = endure, Priority = 4
</span><span>;  Pokemon = tornadus, Move = protect, Priority = 4
</span><span>;  Pokemon = politoed, Move = detect, Priority = 4
</span><span>;  Pokemon = politoed, Move = endure, Priority = 4
</span><span>;  Pokemon = politoed, Move = helpinghand, Priority = 5
</span><span>;  Pokemon = politoed, Move = protect, Priority = 4
</span><span>;  Pokemon = politoed, Move = bide, Priority = 1
</span><span>;  Pokemon = archaludon, Move = endure, Priority = 4
</span><span>;  Pokemon = archaludon, Move = protect, Priority = 4
</span><span>;  Pokemon = beartic, Move = aquajet, Priority = 1
</span><span>;  Pokemon = beartic, Move = bide, Priority = 1
</span><span>;  Pokemon = beartic, Move = endure, Priority = 4
</span><span>;  Pokemon = beartic, Move = protect, Priority = 4
</span><span>;  Pokemon = dusclops, Move = allyswitch, Priority = 2
</span><span>;  Pokemon = dusclops, Move = endure, Priority = 4
</span><span>;  Pokemon = dusclops, Move = helpinghand, Priority = 5
</span><span>;  Pokemon = dusclops, Move = protect, Priority = 4
</span><span>;  Pokemon = dusclops, Move = shadowsneak, Priority = 1
</span><span>;  Pokemon = dusclops, Move = snatch, Priority = 4
</span><span>;  Pokemon = dusclops, Move = suckerpunch, Priority = 1
</span><span>;  false.
</span></code></pre>
<p>Although this is technically correct (the best kind), most of these answers are not actually useful.
<span>Helping Hand</span> and <span>Ally Switch</span> have very high priority, but they only have a purpose in Double Battles, which isn’t the format I’m playing.</p>
<p>To fix this, I define all the Double Battle moves and exclude them.
I’m going to exclude the move <span>Bide</span> too, which is functionally useless. The <code>\+/1</code> predicate means “true if this goal fails”, and <code>dif/2</code> means “these two terms are different.”</p>
<pre><code><span>learns_priority(Mon, Move, Priority) :-
</span><span>  learns(Mon, Move),
</span><span>  \+ doubles_move(Move),
</span><span>  dif(Move, bide),
</span><span>  move_priority(Move, Priority),
</span><span>  Priority #&gt; 0.
</span><span>
</span><span>doubles_move(helpinghand).
</span><span>doubles_move(afteryou).
</span><span>doubles_move(quash).
</span><span>doubles_move(allyswitch).
</span><span>doubles_move(followme).
</span><span>doubles_move(ragepowder).
</span><span>doubles_move(aromaticmist).
</span><span>doubles_move(holdhands).
</span><span>doubles_move(spotlight).
</span></code></pre>
<p>We get the following results:</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- alex(Pokemon), learns_priority(Pokemon, Move, Priority).
</span><span>   Pokemon = meowscarada, Move = endure, Priority = 4
</span><span>;  Pokemon = meowscarada, Move = protect, Priority = 4
</span><span>;  Pokemon = meowscarada, Move = quickattack, Priority = 1
</span><span>;  Pokemon = meowscarada, Move = suckerpunch, Priority = 1
</span><span>;  Pokemon = weezinggalar, Move = endure, Priority = 4
</span><span>;  Pokemon = weezinggalar, Move = protect, Priority = 4
</span><span>;  Pokemon = swampertmega, Move = endure, Priority = 4
</span><span>;  Pokemon = swampertmega, Move = protect, Priority = 4
</span><span>;  Pokemon = latios, Move = endure, Priority = 4
</span><span>;  Pokemon = latios, Move = magiccoat, Priority = 4
</span><span>;  Pokemon = latios, Move = protect, Priority = 4
</span><span>;  Pokemon = volcarona, Move = endure, Priority = 4
</span><span>;  Pokemon = volcarona, Move = protect, Priority = 4
</span><span>;  Pokemon = tornadus, Move = endure, Priority = 4
</span><span>;  Pokemon = tornadus, Move = protect, Priority = 4
</span><span>;  Pokemon = politoed, Move = detect, Priority = 4
</span><span>;  Pokemon = politoed, Move = endure, Priority = 4
</span><span>;  Pokemon = politoed, Move = protect, Priority = 4
</span><span>;  Pokemon = archaludon, Move = endure, Priority = 4
</span><span>;  Pokemon = archaludon, Move = protect, Priority = 4
</span><span>;  Pokemon = beartic, Move = aquajet, Priority = 1
</span><span>;  Pokemon = beartic, Move = endure, Priority = 4
</span><span>;  Pokemon = beartic, Move = protect, Priority = 4
</span><span>;  Pokemon = dusclops, Move = endure, Priority = 4
</span><span>;  Pokemon = dusclops, Move = protect, Priority = 4
</span><span>;  Pokemon = dusclops, Move = shadowsneak, Priority = 1
</span><span>;  Pokemon = dusclops, Move = snatch, Priority = 4
</span><span>;  Pokemon = dusclops, Move = suckerpunch, Priority = 1
</span><span>;  false.
</span></code></pre>

<p>Much better, but there’s a handful of moves in there that go first because they
protect the user from damage or status, like <span>Detect</span>.
That’s not really what I mean by priority move—I’m interested in moves that will surprise my opponent with damage or an adverse side effect, like <span>Quick Attack</span> and <span>Sucker Punch</span>.</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>learns_priority(Mon, Move, Priority) :-
</span><span>  learns(Mon, Move),
</span><span>  \+ doubles_move(Move),
</span><span>  \+ protection_move(Move),
</span><span>  Move \= bide,
</span><span>  move_priority(Move, Priority),
</span><span>  Priority #&gt; 0.
</span><span>
</span><span>protection_move(detect).
</span><span>protection_move(protect).
</span><span>protection_move(kingsshield).
</span><span>protection_move(burningbulwark).
</span><span>protection_move(spikyshield).
</span><span>protection_move(banefulbunker).
</span><span>protection_move(endure).
</span><span>protection_move(magiccoat).
</span></code></pre>
<!-- <aside> -->
<!-- What is <code>Move \= bide</code> doing in there? -->
<!-- <span class="move">Bide</span> is technically a damage-dealing move but it's unusable in practice. -->
<!-- It's actually illegal in the current generation games but we're playing with the National Dex movesets. -->
<!-- </aside> -->
<p>With those rules in place, we arrive at a very useful answer!</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- alex(Pokemon), learns_priority(Pokemon, Move, Priority).
</span><span>   Pokemon = meowscarada, Move = quickattack, Priority = 1
</span><span>;  Pokemon = meowscarada, Move = suckerpunch, Priority = 1
</span><span>;  Pokemon = beartic, Move = aquajet, Priority = 1
</span><span>;  Pokemon = dusclops, Move = shadowsneak, Priority = 1
</span><span>;  Pokemon = dusclops, Move = snatch, Priority = 4
</span><span>;  Pokemon = dusclops, Move = suckerpunch, Priority = 1
</span><span>;  false.
</span></code></pre>

<p>It’s even more useful to look up what priority moves my <em>opponent</em> for the week has.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- morry(Pokemon), learns_priority(Pokemon, Move, Priority).
</span><span>   Pokemon = mawilemega, Move = snatch, Priority = 4
</span><span>;  Pokemon = mawilemega, Move = suckerpunch, Priority = 1
</span><span>;  Pokemon = walkingwake, Move = aquajet, Priority = 1
</span><span>;  Pokemon = ursaluna, Move = babydolleyes, Priority = 1
</span><span>;  Pokemon = lokix, Move = feint, Priority = 2
</span><span>;  Pokemon = lokix, Move = firstimpression, Priority = 2
</span><span>;  Pokemon = lokix, Move = suckerpunch, Priority = 1
</span><span>;  Pokemon = alakazam, Move = snatch, Priority = 4
</span><span>;  Pokemon = skarmory, Move = feint, Priority = 2
</span><span>;  Pokemon = froslass, Move = iceshard, Priority = 1
</span><span>;  Pokemon = froslass, Move = snatch, Priority = 4
</span><span>;  Pokemon = froslass, Move = suckerpunch, Priority = 1
</span><span>;  Pokemon = dipplin, Move = suckerpunch, Priority = 1.
</span></code></pre>
<p>At this point, I showed the program to Morry and he hit me with a challenge.
Pokémon with the Prankster ability get an additional +1 priority on their status moves.
Could the rule be extended to note that?</p>
<p>I happen to have one such Pokémon on my team.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- alex(Pokemon), pokemon_ability(Pokemon, prankster).
</span><span>   Pokemon = tornadus
</span><span>;  false.
</span></code></pre>
<p>This took me 3 minutes, using Prolog’s if/then construct, <code>-&gt;/2</code>.</p>
<pre data-lang="prolog"><code data-lang="prolog"><span>learns_priority(Mon, Move, Priority) :-
</span><span>  learns(Mon, Move),
</span><span>  \+ doubles_move(Move),
</span><span>  \+ protection_move(Move),
</span><span>  Move \= bide,
</span><span>  move_priority(Move, BasePriority),
</span><span>  (
</span><span>    pokemon_ability(Mon, prankster), move_category(Move, status) -&gt;
</span><span>      Priority #= BasePriority + 1
</span><span>    ; Priority #= BasePriority
</span><span>  ),
</span><span>  Priority #&gt; 0.
</span></code></pre>

<p>Now the same query includes all of Tornadus’ status moves, with their increased priority.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- alex(Pokemon), learns_priority(Pokemon, Move, P).
</span><span>   Pokemon = meowscarada, Move = quickattack, P = 1
</span><span>;  Pokemon = meowscarada, Move = suckerpunch, P = 1
</span><span>;  Pokemon = tornadus, Move = agility, P = 1
</span><span>;  Pokemon = tornadus, Move = attract, P = 1
</span><span>;  Pokemon = tornadus, Move = bulkup, P = 1
</span><span>;  Pokemon = tornadus, Move = confide, P = 1
</span><span>;  Pokemon = tornadus, Move = defog, P = 1
</span><span>;  Pokemon = tornadus, Move = doubleteam, P = 1
</span><span>;  Pokemon = tornadus, Move = embargo, P = 1
</span><span>;  Pokemon = tornadus, Move = leer, P = 1
</span><span>;  Pokemon = tornadus, Move = metronome, P = 1
</span><span>;  Pokemon = tornadus, Move = nastyplot, P = 1
</span><span>;  Pokemon = tornadus, Move = raindance, P = 1
</span><span>;  Pokemon = tornadus, Move = rest, P = 1
</span><span>;  Pokemon = tornadus, Move = roleplay, P = 1
</span><span>;  Pokemon = tornadus, Move = sandstorm, P = 1
</span><span>;  Pokemon = tornadus, Move = scaryface, P = 1
</span><span>;  Pokemon = tornadus, Move = sleeptalk, P = 1
</span><span>;  Pokemon = tornadus, Move = snowscape, P = 1
</span><span>;  Pokemon = tornadus, Move = substitute, P = 1
</span><span>;  Pokemon = tornadus, Move = sunnyday, P = 1
</span><span>;  Pokemon = tornadus, Move = swagger, P = 1
</span><span>;  Pokemon = tornadus, Move = tailwind, P = 1
</span><span>;  Pokemon = tornadus, Move = taunt, P = 1
</span><span>;  Pokemon = tornadus, Move = torment, P = 1
</span><span>;  Pokemon = tornadus, Move = toxic, P = 1
</span><span>;  Pokemon = beartic, Move = aquajet, P = 1
</span><span>;  Pokemon = dusclops, Move = shadowsneak, P = 1
</span><span>;  Pokemon = dusclops, Move = snatch, P = 4
</span><span>;  Pokemon = dusclops, Move = suckerpunch, P = 1
</span><span>;  false.
</span></code></pre>
<h2 id="there-s-something-about-spreadsheets"><a href="#there-s-something-about-spreadsheets" aria-label="Anchor link for: there-s-something-about-spreadsheets">There’s something about spreadsheets</a></h2>
<p>At the top, I said that this experience had taught me about the kinds of interfaces I want to build.
One of those lessons is fairly obvious: Prolog can be a little clunky, but it’s an elegant language for expressing and querying relations like the ones described here.
That has implications if you, like me, are interested in the <a href="https://alexanderpetros.com/triptych/">judicious use of declarative DSLs</a> for programming.</p>
<p>The other lesson is what kinds of tools work for <em>non</em>-programmers.</p>
<p>I’m not the first person to think “it would be nice to know what priority moves my opponent’s team has.”
The Pokémon community has resources like this, built in the best programming interface of all time: the humble spreadsheet.</p>
<figure>
  <img src="https://www.nprillinois.org/illinois/2026-01-06/images/matchup-sheet.png" alt="A screenshot of a spreadsheet listing Pokémon that know various useful moves."/>
  <figcaption>Much prettier to look at, too.</figcaption>
</figure>
<p>I use a copy of <a href="https://www.smogon.com/forums/threads/draft-league-resources.3716128/">“Techno’s Prep Doc”</a>, which is one of those spectacularly-advanced Google Sheets you come across in the wild sometimes.
You put in the teams and it generates tons of useful information about the matchup.
It has a great interface, support for a variety of formats, scannable visuals, and even auto-complete.</p>
<p>I was curious about the formula for finding priority moves.
It’s gnarly.</p>
<pre><code><span>={IFERROR(ARRAYFORMULA(VLOOKUP(FILTER(INDIRECT(Matchup!$S$3&amp;&#34;!$AV$4:$AV&#34;),INDIRECT(Matchup!$S$3&amp;&#34;!$AT$4:$AT&#34;)=&#34;X&#34;),{Backend!$L$2:$L,Backend!$F$2:$F},2,FALSE))),IFERROR(FILTER(INDIRECT(Matchup!$S$3&amp;&#34;!$AW$4:$AW&#34;),INDIRECT(Matchup!$S$3&amp;&#34;!$AT$4:$AT&#34;)=&#34;X&#34;))}
</span></code></pre>
<p>With a little bit of clicking around, I was basically able to figure out what this does.
There’s a “Backend” sheet that lists all the moves.
It’s effectively a hard-coded version of my Prolog query.</p>
<figure>
  <img src="https://www.nprillinois.org/illinois/2026-01-06/images/priority-backend-list.png" alt=""/>
</figure>
<p>The lookup formula does some filtering, VLOOKUP-ing, and kinda-metaprogramming (INDIRECT <a href="https://support.google.com/docs/answer/3093377?hl=en">returns a cell reference</a>) to find all the Pokémon on your team that are in that Backend list, and display them.</p>
<p>There are a number of reasons that I, personally, would prefer to work on a version of this database implemented in Prolog instead of one implemented with spreadsheet VLOOKUPs.
I plan to build webapps with this that do things the existing suite of Pokémon tooling can’t. (If I can ever <a href="https://github.com/mthom/scryer-prolog/issues/3196">get scryer-prolog to compile to WASM</a>, that is.)</p>
<p>Furthermore, the Prolog paradigm is clearly more extensible.
The spreadsheet backend is a hard-coded list of notable moves;
my database can look up <em>any</em> move.
I still can’t really believe this query, which finds all the Special moves that Tornadus learns which are super-effective against any member of Justin’s team.
Nothing like that exists in any tool that I know of—it’s the kind of thing I normally try to figure out by endlessly switching tabs.
With the grammar established by my program, I put this together in like 30 seconds.</p>
<pre data-name="top-level"><code data-name="top-level"><span>?- justin(Target), learns(tornadus, Move), super_effective_move(Move, Target), move_category(Move, special).
</span><span>   Target = charizardmegay, Move = chillingwater
</span><span>;  Target = terapagosterastal, Move = focusblast
</span><span>;  Target = alomomola, Move = grassknot
</span><span>;  Target = scizor, Move = heatwave
</span><span>;  Target = scizor, Move = incinerate
</span><span>;  Target = runerigus, Move = chillingwater
</span><span>;  Target = runerigus, Move = darkpulse
</span><span>;  Target = runerigus, Move = grassknot
</span><span>;  Target = runerigus, Move = icywind
</span><span>;  Target = screamtail, Move = sludgebomb
</span><span>;  Target = screamtail, Move = sludgewave
</span><span>;  Target = trapinch, Move = chillingwater
</span><span>;  Target = trapinch, Move = grassknot
</span><span>;  Target = trapinch, Move = icywind
</span><span>;  false.
</span><span>?-
</span></code></pre>

<p>I’m not interested in how structured programming is more extensible than spreadsheets, though.
I already know why I don’t do all my programming in spreadsheets.</p>
<pre><code><span>={IFERROR(ARRAYFORMULA(VLOOKUP(FILTER(INDIRECT(Matchup!$S$3&amp;&#34;!$AV$4:$AV&#34;),INDIRECT(Matchup!$S$3&amp;&#34;!$AT$4:$AT&#34;)=&#34;X&#34;),{Backend!$L$2:$L,Backend!$F$2:$F},2,FALSE))),IFERROR(FILTER(INDIRECT(Matchup!$S$3&amp;&#34;!$AW$4:$AW&#34;),INDIRECT(Matchup!$S$3&amp;&#34;!$AT$4:$AT&#34;)=&#34;X&#34;))}
</span></code></pre>
<p>A question I find very important is: What is it about this particular problem, and the kinds of people who were motivated to solve it, where the most well-maintained solution available is a spreadsheet?</p>

<p>I believe there are a great many problems like that in the world, and a lot of improvements on that programming paradigm yet to be properly realized.</p>
<p><em>Thanks to <a href="https://wttdotm.com">Morry Kolman</a> for reading a draft of this blog</em>.</p>

<ul>
<li>I joined the draft league in Season 3, lost in finals, then won Seasons 4 and 5. We just started Season 6. <a href="https://www.youtube.com/watch?v=jMkhsamX-2I">If you want it, you can have the crown</a>.</li>
<li>There are a number of coders in this draft league and I have gotten precisely zero of them to try out my Prolog program. That’s kind of the point though! It needs to be a website…</li>
<li>The Prolog implementation I’m using is <a href="https://www.scryer.pl/">Scryer Prolog</a>, a modern Prolog implementation that emphasizes standards and formal correctness. The creator, Markus Triska, has a terrific online book, <a href="https://www.metalevel.at/prolog">“The Power of Prolog,”</a> and accompanying <a href="https://www.youtube.com/@ThePowerOfProlog">YouTube channel</a> that has soundtracked my breakfast for weeks.</li>
<li>Scryer Prolog is also designed to encourage more constructs that <a href="https://www.youtube.com/watch?v=6G-3DqyJ_l8">preserve logical completeness and monotonicity</a>, which means I’m not really supposed to use the <code>\+/2</code> or <code>-&gt;/2</code> predicates. I couldn’t really figure out how to express what I wanted with the replacements offered, though. Happy to edit if anyone wants to help.</li>
<li>Also, <a href="https://www.metalevel.at/">on Markus’ website</a>: “My goal is to provide programs that work as intended, reliably and conveniently, with zero surprises. Programs that you can run for multiple decades without any issues such as crashes, resource leaks or other unexpected behaviour.” This guy and I have some <a href="https://unplannedobsolescence.com/talks/building-the-hundred-year-web-service/">similar interests!</a></li>
<li>I did <a href="https://github.com/alexpetros/prologdex/blob/6fd8d2ed1e7f9e35f36b76dd60bd2535f70f5164/scripts/generate-dex.js">some fun metaprogrogramming</a> to get all the data into Prolog predicates using the <a href="https://github.com/smogon/pokemon-showdown">Pokémon Showdown</a> NodeJS API.</li>
<li>Yes, putting the accent on the “e” everywhere but the code blocks was very annoying.</li>
</ul>



</div>
  </body>
</html>
