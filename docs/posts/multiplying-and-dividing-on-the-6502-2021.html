<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://llx.com/Neil/a2/mult.html">Original</a>
    <h1>Multiplying and Dividing on the 6502 (2021)</h1>
    
    <div id="readability-page-1" class="page">
  <p><a href="http://www.llx.com/">LLX</a> &gt;
   <a href="https://llx.com/~nparker/">Neil Parker</a> &gt;
   <a href="https://llx.com/Neil/a2/index.html">Apple II</a> &gt; Multiplying and Dividing on the
   6502</p>
  
  <h2>Introduction</h2>
  <p>One of the more common questions asked by new 6502 programmers
   seems to be, &#34;Hey...there&#39;s no multiply instruction!  How do I multiply
   on the 6502?&#34;  This article presents some answers to this question,
   and as a bonus, answers to the companion question, &#34;How do I divide on
   the 6502?&#34;</p>
  <p>Of course the methods shown below are not the only ways to multiply
   and divide, nor even the fastest.  They are, however, probably the
   easiest ways to understand.</p>
  <p>Most of the routines below are for unsigned integers, since these are
   the easiest kinds of numbers to work with.  Extending them to signed
   integers is discussed briefly near the end.  (The next logical step, numbers
   with fractional parts, would require a whole new article.)</p>
  <h2>The Easiest Way to Multiply</h2>
  <p>The easiest way to multiply on the 6502 is not to do it at all.</p>
  <p>Actually, that statement isn&#39;t nearly as useless as it seems.
   Sometimes the nature of the problem is such that with a little
   rewriting, the multiplication can be eliminated entirely.  This happens
   often in loops, if the loop index has to be multiplied by something.
   As an example, consider the following BASIC-like code fragment:</p>
  <blockquote>
   <pre>FOR I = 5 TO 100 STEP 5
  J = I*23
  Do something with J
NEXT I</pre>
  </blockquote>
  <p>This can be rewritten like this:</p>
  <blockquote>
   <pre>J = 115: REM 115 = 5*23
FOR I = 5 TO 100 STEP 5
  Do something with J
  J = J+115
NEXT I</pre>
  </blockquote>
  <p>This kind of rewriting is called <i>strength reduction</i>.
   Optimizing compilers will usually notice when this is possible, and
   automatically rewrite the code to take advantage of it.</p>
  <p>The problem with this, of course, is that many multiplications
   <em>can&#39;t</em> be eliminated by rewriting.  For these cases, the rule
   is, &#34;Don&#39;t work any harder than you have to.&#34;  If all you need is to
   multiply
   by a constant, the code for that will usually be much more efficient
   than a general routine to multiply any two arbitrary numbers.</p>
  <h2>Multiplying by a Constant</h2>
  <p>Skipping over the trivial cases of multiplying by zero or one, the
   easiest constant to multiply by is two, because all you need are the
   <code>ASL</code> and <code>ROL</code> instructions.  For a single-byte
   result:</p>
  <blockquote>
   <pre>        ASL NUM</pre>
  </blockquote>
  <p>Or for a two-byte result:</p>
  <blockquote>
   <pre>        ASL NUM
        ROL NUM+1</pre>
  </blockquote>
  <p>Extending this to wider numbers should be obvious.</p>
  <p>Multiplying by 4, 8, 16, or higher powers of two is simply a matter
   of multiplying by two enough times to get the result.  For example, to
   multiply a one-bye number by four:</p>
  <blockquote>
   <pre>        ASL NUM
        ASL NUM</pre>
  </blockquote>
  <p>Or for two-byte numbers:</p>
  <blockquote>
   <pre>        ASL NUM
        ROL NUM+1
        ASL NUM
        ROL NUM+1</pre>
  </blockquote>
  <p>Multiplying by a constant other than a power of two is more
   difficult, but it can be done by adding up the results of several
   power-of-two multiplications.  This will generally require the use of
   temporary memory locations to hold intermediate results.</p>
  <p>For example, consider multiplication by 3.  To do this, we note that
   for any number <code>x</code>, <code>3x = 2x + x</code> - that is, we
   can multiply by three by multiplying by two, and adding the original
   number to the result.  Of course this means the original number has to
   be kept around somewhere so it will be available for the addition.  For
   two-byte numbers:</p>
  <blockquote>
   <pre>        LDA NUM       ;Start with RESULT = 2*NUM
        ASL A
        STA RESULT
        LDA NUM+1
        ROL A
        STA RESULT+1
        CLC
        LDA NUM
        ADC RESULT
        STA RESULT
        LDA NUM+1
        ADC RESULT+1
        STA RESULT+1  ;RESULT = 3*NUM</pre>
  </blockquote>
  <p>Or we can multiply by 10 using the fact that <code>10x = 8x +
   2x</code> (or, factoring out a 2, <code>10x = 2(4x + x)</code>):</p>
  <blockquote>
   <pre>        LDA NUM       ;Start with RESULT = NUM
        STA RESULT
        LDA NUM+1
        STA RESULT+1
        ASL RESULT
        ROL RESULT+1  ;RESULT = 2*NUM
        ASL RESULT
        ROL RESULT+1  ;RESULT = 4*NUM
        CLC
        LDA NUM
        ADC RESULT
        STA RESULT
        LDA NUM+1
        ADC RESULT+1
        STA RESULT+1  ;RESULT = 5*NUM
        ASL RESULT
        ROL RESULT+1  ;RESULT = 10*NUM</pre>
  </blockquote>
  <p>So how do we figure out what powers of two we need to add to get the
   answer?  Easy:  Just write the binary equivalent of the constant, and
   look for the 1 bits.  The position of each 1 bit shows which powers of
   two need to be added to get the answer.  For example,</p>
  <blockquote>
   <pre>3 (decimal) = 11 (binary)
              |+--  1
              +--- +2
                   --
                    3, i.e. 1x + 2x = 3x

10 (decimal) = 1010 (binary)
               | +--  2
               +---- +8
                     --
                     10, i.e. 2x + 8x = 10x

25 (decimal) = 11001 (binary)
               ||  +--   1
               |+-----   8
               +------ +16
                       ---
                        25, i.e. x + 8x + 16x = 25x.</pre>
  </blockquote>
  <p>But what if you need to multiply two numbers, and you don&#39;t know what
   either one is in advance?  In this case, you need a general
   multiply-anything-by-anything routine.</p>
  <h2>Multplying Arbitrary Numbers</h2>
  <p>A reasonable way to multiply arbitrary numbers is to do it the way
   you learned in school, with pencil and paper.  Consider an example:</p>
  <blockquote>
   <pre>   654
 x 321
 -----
   654
 1308
1962
------
209934</pre>
  </blockquote>
  <p>If the steps are written out as an algorithm, it goes something like
   this:</p>
  <ul>
   <li>Set the answer to 0.</li>
   <li>Repeat as many times as there are digits in the bottom number:
    <ul>
     <li>Remove the rightmost digit of the bottom number.</li>
     <li>Multiply the top number by the digit just removed.</li>
     <li>Add the result to the answer, shifted one more place to the left
      each time.</li>
    </ul></li>
  </ul>
  <p> The secret of binary multiplication is that <em>it works exactly like
   decimal multiplication</em>, as long as you use the addition and
   multiplication tables for binary digits:</p>
  <blockquote>
   <pre> +| 0  1      x| 0 1
--+-----     --+----
 0| 0  1      0| 0 0
 1| 1 10      1| 0 1</pre>
  </blockquote>
  <p>The algorithm in the binary case is slightly simpler than the decimal
   algorithm:</p>
  <ul>
   <li>Set the answer to 0.</li>
   <li>Repeat as many times as there are bits in the bottom number:
    <ul>
     <li>Remove the rightmost bit of the bottom number.</li>
     <li>If the bit removed was 1, add the top number to the answer,
      shifted one more place to the left each time.</li>
    </ul></li>
  </ul>
  <p>Here&#39;s an example:</p>
  <blockquote>
   <pre>  110
x 101
-----
  110
110
-----
11110</pre>
  </blockquote>
  <p>This is quite easy to turn into machine language - the only tricky
   thing in the code below is that instead of shifting the added number to
   the left, it shifts the answer one place to the right each time,
   catching the lost bit in a memory location.  Here it is for one-byte
   numbers:</p>
  <blockquote>
   <pre><a name="mul1">Â </a>       LDA #0       ;Initialize RESULT to 0
        LDX #8       ;There are 8 bits in NUM2
L1      LSR NUM2     ;Get low bit of NUM2
        BCC L2       ;0 or 1?
        CLC          ;If 1, add NUM1
        ADC NUM1
L2      ROR A        ;&#34;Stairstep&#34; shift (catching carry from add)
        ROR RESULT
        DEX
        BNE L1
        STA RESULT+1</pre>
  </blockquote>
  <p>Note that though we were multiplying one-byte numbers, the result
   requires two bytes.  The general rule for multiplication is that the
   number of bytes in the result will be equal to the number of bytes in
   the first number, plus the number of bytes in the second number.</p>
  <p>The method is easily extendable to wider numbers.  Here&#39;s a routine
   for multiplying two-byte numbers, giving a four-byte result:</p>
  <blockquote>
   <pre>        LDA #0       ;Initialize RESULT to 0
        STA RESULT+2
        LDX #16      ;There are 16 bits in NUM2
L1      LSR NUM2+1   ;Get low bit of NUM2
        ROR NUM2
        BCC L2       ;0 or 1?
        TAY          ;If 1, add NUM1 (hi byte of RESULT is in A)
        CLC
        LDA NUM1
        ADC RESULT+2
        STA RESULT+2
        TYA
        ADC NUM1+1
L2      ROR A        ;&#34;Stairstep&#34; shift
        ROR RESULT+2
        ROR RESULT+1
        ROR RESULT
        DEX
        BNE L1
        STA RESULT+3</pre>
  </blockquote>
  <p>At this point it seems to be common for people to ask for additional
   routines to multiply even wider numbers.  Rather than bloat this article
   with even more routines for numbers of various sizes, I encourage readers
   to look back over the algorithm just described and the examples that
   implement it - once these are understood, writing additional routines is
   straightforward.</p>
  <h2>Division</h2>
  <p>Passing over the trivial case of dividing by 1, the easiest number to
   divide by is 2:</p>
  <blockquote>
   <pre>        LSR NUM</pre>
  </blockquote>
  <p>Or, for two-byte numbers:</p>
  <blockquote>
   <pre>        LSR NUMHI
        ROR NUMLO</pre>
  </blockquote>
  <p>This replaces the original number with the result, and leaves the
   remainder in the carry flag.</p>
  <p>As with multiplication, dividing by higher powers of two is simply a
   matter of repeating the above.  The remainder can be found by saving
   the bits shifted off into the carry flag - the first bit shifted out is
   the lowest bit of the remainder, the second bit shifted is the
   next-to-lowest bit of the remainder, and so on.</p>
  <p>Unfortunately, dividing by constants that are not powers of two is
   harder than multiplying by them - hard enough that it&#39;s often easiest
   just to go for the general divide-anything-by-anything routine,
   especially if you need the remainder.</p>
  <h2>Dividing Arbitrary Numbers</h2>
  <p>As with multiplication, a reasonable division algorithm can be found
   by looking at the way you would write out a long division with pencil
   and paper.  Consider the following example, written in the manner
   traditionally taught in U.S. schools:</p>
  <blockquote>
   <pre>       184
   _______
67 ) 12345
     -67
     ---
      564
     -536
     ----
       285
      -268
      ----
        17</pre>
  </blockquote>
  <p>Here we divided a <i>dividend</i>, 12345, by a <i>divisor</i>, 67,
   and got <i>quotient</i> of 184, with a remainder of 17.  Note the
   procedure...at each step, we find the largest multiple of the divisor
   that is less than the leftmost remaining digits of the dividend, and
   subtract.  Then we bring down the next digit of the dividend, and repeat
   until no more digits are left.</p>
  <p>Binary division works exactly the same way, as long as you use the
   rules for binary digits instead of decimal digits.  For example:</p>
  <blockquote>
   <pre>        10101
    _________
101 ) 1101101
     -101
     ----
        11
        -0
        --
        111
       -101
       ----
         100
          -0
         ---
         1001
         -101
         ----
          100</pre>
  </blockquote>
  <p>Note how much easier this is than the decimal version, mostly because
   there are only two possible numbers to subtract:  0 or the divisor.</p>
  <p>Again, writing code to do this isn&#39;t very hard.  We will shift the
   bits of the the dividend, one at a time, into a work area, and then try
   subtracting the divisor from the work area.  If the subtraction
   succeeded, we replace the work area with the result of the subtraction
   and record a 1 bit in the quotient.  If the subtraction failed, we discard
   its result and record a 0 bit in the quotient.  The process is repeated
   until all bits of the dividend are used up.</p>
  <p>Here&#39;s an example that divides the two-byte number NUM1 by the
   two-byte number NUM2, leaving the quotient in NUM1 and the remainder in
   REM:</p>
  <blockquote>
   <pre>        LDA #0      ;Initialize REM to 0
        STA REM
        STA REM+1
        LDX #16     ;There are 16 bits in NUM1
L1      ASL NUM1    ;Shift hi bit of NUM1 into REM
        ROL NUM1+1  ;(vacating the lo bit, which will be used for the quotient)
        ROL REM
        ROL REM+1
        LDA REM
        SEC         ;Trial subtraction
        SBC NUM2
        TAY
        LDA REM+1
        SBC NUM2+1
        BCC L2      ;Did subtraction succeed?
        STA REM+1   ;If yes, save it
        STY REM
        INC NUM1    ;and record a 1 in the quotient
L2      DEX
        BNE L1</pre>
  </blockquote>
  <p>Beware!  Since multiplying two one-byte numbers gives you a two-byte
   result, the knee-jerk expectation is that dividing a two-byte number by
   a one-byte number should give you a one-byte quotient.  This turns out not
   to be true!  When dividing two numbers, the quotient must be as wide as
   the dividend (consider dividing by 1, in which case the quotient <em>is</em>
   the dividend), and the remainder must be as wide as the divisor (because it
   can be as large as divisor-1).</p>
  <p>Again, I&#39;m not going to bloat this article by showing division
   routines for different sizes of numbers.  Once the method is
   understood, writing additional routines is straightforward.</p>
  <h2>I feel the NEED for SPEED!</h2>
  <p>The routines shown above are reasonably compact, but not the speediest.
   With a little bit of trickery, we can squeeze a few cycles out of some of
   the above routines...for example, here&#39;s the one-byte multiplication again,
   using the carry flag instead of the Y register for the loop counter, which
   takes the <code>DEY</code> instruction out of the loop:</p>
  <blockquote>
   <pre>        LDA #$80     ;Preload sentinel bit into RESULT
        STA RESULT
        ASL A        ;Initialize RESULT hi byte to 0
L1      LSR NUM2     ;Get low bit of NUM2
        BCC L2       ;0 or 1?
        CLC          ;If 1, add NUM1
        ADC NUM1
L2      ROR A        ;&#34;Stairstep&#34; shift (catching carry from add)
        ROR RESULT
        BCC L1       ;When sentinel falls off into carry, we&#39;re done
        STA RESULT+1</pre>
  </blockquote>
  <p>Assuming <code>RESULT</code> is in page 0, this saves 14 cycles.  As an
   added bonus, the Y register is no longer trashed.</p>
  <p>A little more trickery can get the <code>CLC</code> out of the loop,
   saving 2 cycles per 1-bit in <code>NUM2</code>:</p>
  <blockquote>
   <pre>        LDA #$80     ;Preload sentinel bit into RESULT
        STA RESULT
        ASL A        ;Initialize RESULT hi byte to 0
	DEC NUM1
L1      LSR NUM2     ;Get low bit of NUM2
        BCC L2       ;0 or 1?
        ADC NUM1     ;If 1, add (NUM1-1)+1
L2      ROR A        ;&#34;Stairstep&#34; shift (catching carry from add)
        ROR RESULT
        BCC L1       ;When sentinel falls off into carry, we&#39;re done
        STA RESULT+1</pre>
  </blockquote>
  <p>Since the initial <code>DEC NUM1</code> costs 5 cycles (if
   <code>NUM1</code> is in page 0), this is a win if <code>NUM2</code> has
   at least three 1-bits.</p>
  <p>But even the fastest of those routines, under the best possible
   circumstances (all variables in page 0, no page crossings, and NUM2 = 0),
   takes 151 cycles.  If you need to do much better than that, different
   techniques must be used.  The best way to get fast multiplication or
   division on the 6502 is table lookup - i.e., the programmer precomputes the
   answers to the multiplication or division problems and stores them in
   a table, and when the program needs to multiply or divide, it looks up the
   answer in the table.</p>
  <p>Of course this means there&#39;s a tradeoff between speed and code size.
   Table lookup works best when the numbers to be multiplied or divided
   fall in a limited range, otherwise the tables quickly grow to
   unmanageable sizes - for example, a multiplication table for
   multiplying two arbitrary one-byte numbers requires more memory than the
   6502 can directly access.</p>
  <p>Fortunately, with a little bit of algebra, the multiplcation table can
   be made much smaller, at the cost of a little extra execution time.
   Consider these two ways of writing the binomial equation:</p>
  <blockquote>
   <pre>(a + b)^2 = a^2 + 2*a*b + b^2,
(a - b)^2 = a^2 - 2*a*b + b^2.</pre>
  </blockquote>
  <p>If the bottom equation is subtracted from the top, we get</p>
  <blockquote>
   <pre>(a + b)^2 - (a - b)^2 = 4*a*b,</pre>
  </blockquote>
  <p>Or, rearranging,</p>
  <blockquote>
   <pre>a*b = ((a + b)^2 - (a - b)^2)/4
    = (a + b)^2/4 - (a - b)^2/4.</pre>
  </blockquote>
  <p>Thus we can do a multiplication with an addition, two subtractions,
   a couple of right shifts, and a couple of lookups in a table of squares.
   And if we&#39;re clever about the coding, we can make most of that work
   trivial - Here are the tricks to make it work:</p>
  <ul>
   <li>Instead of storing a table of <code>x^2</code>, the table will
    store <code>x^2/4</code>.  This means each table entry needs only two
    bytes intstead of three.  The two low-order bits of each entry are
    lost, but that&#39;s OK, since <code>(a+b)^2</code> and
    <code>(a-b)^2</code> are guaranteed to lose <em>exactly the same
    bits</em>, so the subtraction cancels the lost bits.</li>
   <li>We&#39;ll actually store the table twice, once to look up
    <code>(a+b)^2/4</code>, and once to look up <code>(a-b)^2/4</code>.
    The total memory cost is 2048 bytes (2K).</li>
   <li>The <code>(a-b)^2/4</code> table is offset by one.  This is so we
    can store <code>b</code> in the accumulator, and negate it with
    <code>EORÂ #$FF</code> without having to add 1.</li>
   <li>The tables are page-aligned.  This greatly streamlines the
    indexing.</li>
  </ul>
  <p>A brief setup routine is needed to set up four pointers in page 0:</p>
  <blockquote>
   <pre>        LDA #SSQLO/256
        STA PSLO+1
        LDA #SSQHI/256
        STA PSHI+1
        LDA #DSQLO/256
        STA PDLO+1
        LDA #DSQHI/256
        STA PDHI+1</pre>
  </blockquote>
  <p>With that done, we can multiply two bytes by putting one in the
   accumulator and the other in the Y register, and calling this
   routine:</p>
  <blockquote>
   <pre>        STA PSLO     ;Index into sum table by A
        STA PSHI
        EOR #$FF
        STA PDLO     ;Index into diff table by -A-1
        STA PDHI
        LDA (PSLO),Y ;Get (a+y)^2/4 (lo byte)
        SEC
        SBC (PDLO),Y ;Subtract (-a+y)^2/4 (lo byte)
        TAX          ;Save it
        LDA (PSHI),Y ;Get (a+y)^2/4 (hi byte)
        SBC (PDHI),Y ;Subtract (-a+y)^2/4 (hi byte)</pre>
  </blockquote>
  <p>This leaves the product in the accumulator (high byte) and the X
   register (low byte).  Worst-case time (all indexing crosses a page
   boundary): 38 cycles.</p>
  <p>The tables necessary to make this work are too long to show here, so
   I&#39;ve provided them in <a href="https://llx.com/Neil/a2/mult.txt">a separate text file</a>.
   Remember, the tables have to be page-aligned, or the above code won&#39;t
   work.</p>
  <p>(The above routine is based on some code I found on a
   Commodore-64-related web page, which, unfortunately, I haven&#39;t been able
   locate again.  The method doesn&#39;t seem to have been widely known among
   Apple II programmers.)</p>
  <h2>But what about negative numbers?</h2>
  <p>Up to this point, all the code presented in this article has been
   designed to work with unsigned (positive) numbers.  The simple
   multiply-by-constant routines will also work with negative numbers,
   but none of the others will.  Generally, if you see a <code>LSR</code>
   or <code>ROR</code> instruction in one of the above routines, it will
   give wrong results for negative numbers.</p>
  <p>The problem is that the 6502&#39;s <code>LSR</code> and <code>ROR</code>
   instructions are not sign-preserving.  They could be replaced by calls
   to subroutines that perform the shift in a sign-preserving manner,
   but that&#39;s probably not the best way to solve the problem.</p>
  <p>The usual way to multiply signed numbers on the 6502 is to compute the
   sign of the result first, then make both numbers positive, multiply
   them, and apply the proper sign to the result.</p>
  <p>Computing the sign of the result is very easy:  If the two original
   numbers have the same sign, the result is positive, and if they have
   different signs, the result is negative.  Assuming the usual
   two&#39;s-complement representation of negative numbers, the sign of the
   result can be found by <code>EOR</code>ing the high bytes of the two
   numbers, which leaves the sign of the result in the high bit of the
   accumulator and in the <code>N</code> flag.</p>
  <p>To make a number positive, first examine its high bit.  If the high
   bit is 0, no action is necessary, otherwise the number will have to
   negated.  The best way to do this depends on where the number is stored
   - if it&#39;s in the accumulator, the quickest way is this:</p>
  <blockquote>
   <pre>        EOR #$FF
        CLC
        ADC #1</pre>
  </blockquote>
  <p>If the number to be negated is in a memory location, the quickest way
   to negate it is to subtract it from 0.  For example, to negate a
   two-byte number:</p>
  <blockquote>
   <pre>        LDA #0
        SEC
        SBC NUM
        STA NUM
        LDA #0
        SBC NUM+1
        STA NUM+1</pre>
  </blockquote>
  <p>Putting it all together, here&#39;s a routine that multiplies two signed
   one-byte numbers, using the one-byte multiply routine from <a href="#mul1">above</a>:</p>
  <blockquote>
   <pre>        LDA NUM1     ;Compute sign of result
        EOR NUM2
        PHP          ;Save it on the stack
        LDA NUM1     ;Is NUM1 negative?
        BPL T1
        EOR #$FF     ;If so, make it positive
        CLC
        ADC #1
        STA NUM1
T1      LDA NUM2     ;Is NUM2 negative?
        BPL T2
        EOR #$FF     ;If so, make it positive
        CLC
        ADC #1
        STA NUM2
T2      JSR <a href="#mul1">MUL1BYTE</a> ;Do the unsigned multiplication
        PLP          ;Get sign of result
        BPL T3
        LDA #0       ;If negative, negate result
        SEC
        SBC RESULT
        STA RESULT
        LDA #0
        SBC RESULT+1
        STA RESULT+1
T3      ...</pre>
  </blockquote>
  <p>Doing signed division is a bit trickier.  The trick is to preserve the
   following relation:</p>
  <blockquote>
   <pre>dividend = divisor * quotient + remainder</pre>
  </blockquote>
  <p>In the unsigned case there&#39;s only one way to arrange this:  The quotient
   is always less than or equal to the true mathematical quotient (which may
   have a fractional part), and the remainder is always positive.</p>
  <p>In the signed case, the ability to have signed remainders makes the issue
   murkier.  There are two conventions in common use:</p>
  <ol>
   <li><em>Floored division:</em>  If the true mathematical quotient has a
    fractional part, the same choices are made as in the unsigned case:
    the quotient is always less than (more negative) or equal to the
    mathematical quotient, and the remainder is always positive.</li>
   <li><em>Toward-zero division:</em>  If the true mathematical quotient
    has a fractional part, the fractional part is truncated (i.e. the
    quotient is rounded toward zero), and the remainder has the sign of the
    dividend.</li>
  </ol>
  <p>Signed division is implemented with a wrapper around an unsigned
   routine, as with signed multiplication, but the wrapper varies depending
   on which convention you choose.  In either case, first compute the sign
   of the quotient the same way you would compute the sign of the result of
   a multiplication, and then make both numbers positive, and call the
   unsigned division routine.  What happens next depends on which
   convention you choose.</p>
  <ul>
   <li><em>Floored division:</em>  If the quotient should be negative,
    negate it.  Leave the remainder unchanged.</li>
   <li><em>Toward-zero division:</em>  If the quotient should be negative,
    negate it, and then add one to it.  If the quotient should be negative
    <em>and</em> the original dividend was negative, negate the
    remainder.</li>
  </ul>
  <p>The code is analogous to the signed multiplication example above.</p>
  <p><a href="http://www.llx.com/">LLX</a> &gt;
   <a href="https://llx.com/~nparker/">Neil Parker</a> &gt;
   <a href="https://llx.com/Neil/a2/index.html">Apple II</a> &gt; Multiplying and Dividing on the
   6502</p>
  <p><small>Original:  August 31, 2005</small></p>
 


</div>
  </body>
</html>
