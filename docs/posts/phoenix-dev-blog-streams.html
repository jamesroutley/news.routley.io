<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/phoenix-files/phoenix-dev-blog-streams/">Original</a>
    <h1>Phoenix Dev Blog – Streams</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/chris-m.jpg" alt="Chris McCord" srcset=""/> <dl> <dt>Name</dt> <dd> Chris McCord </dd> <dt>Social Media</dt> <dd> <a href="https://twitter.com/chris_mccord" target="_blank" rel="noopener noreferrer"> <span aria-hidden="true">@chris_mccord</span> <span>View Twitter Profile</span> </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/phoenix-files/2023-02-27/streams-cover.jpg" alt="Phoenix dev blog cover illustration"/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com/" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p> This dev blog introduces LiveView&#39;s new Streams feature. It lets us elegantly work with large collections of items without keeping them all in memory on the server. Fly.io is a great place to run a Phoenix application! Check out how to <a href="https://fly.io/docs/elixir/">get started</a>!</p><p>This is the first installment of the Phoenix development blog where we&#39;ll talk about in progress features or day-to-day development updates in between major releases and milestones.</p> <h2 id="what-s-the-problem"><a href="#what-s-the-problem" aria-label="Anchor"></a>What&#39;s the Problem?</h2><p>For at least a few years, the Phoenix team has wanted a solution that elegantly addresses large collections of items without requiring the collection to live in memory on the server. We&#39;ve had a hack in place by allowing a container to be marked with <code>phx-update=&#34;append&#34;</code> or <code>phx-update=&#34;prepend&#34;</code> . It worked for some use cases, but it sucked even when it worked. Let&#39;s see why.</p> <p>Today it works by marking an assign as &#34;temporary&#34;, which means the server throws it away after rendering it. Then to append a new item, we allow the developer to render only the new items, and the client would automagically leave the old ones in place instead of removing them. In practice it looked like this:</p> <div><pre><code><span>def</span> <span>render</span><span>(</span><span>assigns</span><span>)</span> <span>do</span>
  <span>~H&#34;&#34;</span><span>&#34;
  &lt;div id=&#34;</span><span>users</span><span>&#34; phx-update=&#34;</span><span>append</span><span>&#34;&gt;
    &lt;div :for={user &lt;- @users} id={&#34;</span><span>user</span><span>-</span><span>#{user.id}&#34;}&gt;</span>
      <span>&lt;%=</span> <span>user</span><span>.</span><span>name</span> <span>%</span><span>&gt;</span>
    <span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&#34;&#34;&#34;
end

def mount(_, _, socket) do
  users = Accounts.list_users()
  {:ok, assign(socket, users: users), temporary_assigns: [users: []]
end

def handle_info({:user_added, new_user}) do
  {:noreply, assign(socket, users: [new_user])}
end
</span></code></pre></div><p>The append/prepend trick allowed developers to start with a &#34;naive&#34; in-memory store of the collection, then optimize it without changing much of their code. They render the collection in <code>render/1</code> with a regular <code>for</code> comprehension, and assign it in the callbacks with regular <code>assign</code>.</p> <p>The trick can be seen on line 17, where we re-assign the empty users collection to a single element list with only our new users. When Phoenix LiveView goes to patch the DOM, it will see the parent container is marked with <code>phx-update=&#34;append&#34;</code> and leave the existing children alone, while adding the new ones.</p> <p>Great! Everyone is happy, except this approach sucked for a number of reasons.</p> <p>First, deletions were not supported. You&#39;d need to write some JavaScript yourself to remove the DOM elements, and in the case of components you could easily break our own component tracking. Next, the containers only supported two modes of operation: append or prepend. It was not easy to swap the behaviors such as appending a list of posts in a timeline while also prepending new posts on top. Sorting was also not possible. Finally, the internal implementation was expensive and brittle. Before each DOM patch, we had to &#34;fake&#34; the DOM tree to make it look like newly patched items were present in the new tree to ensure <a href="https://github.com/patrick-steele-idem/morphdom">morphdom</a> would leave our existing items intact rather than considering them removed.</p> <h2 id="enter-streams"><a href="#enter-streams" aria-label="Anchor"></a>Enter Streams</h2><p>We are introducing a new &#34;streams&#34; feature to solve the issues above. New Phoenix 1.7 applications will use streams out of the box for the <code>phx.gen.live</code> LiveView generators.</p> <p>Streams bring a new <code>stream</code> interface while also carrying over the ease of gradual optimization we had before. Streams support dynamic ordering, which makes appending, prepending, or reordering trivial for the developer. Deletes are also just as trivial. Let&#39;s refactor our original example to see how:</p> <div><pre><code><span>def render(assigns) do
</span>  ~H&#34;&#34;&#34;
  &lt;div id=&#34;users&#34; phx-update=&#34;stream&#34;&gt;
<span>-   &lt;div :for={user &lt;- @users} id={&#34;user-#{user.id}&#34;}&gt;
</span><span>+   &lt;div :for={{id, user} &lt;- @streams.users} id={id}&gt;
</span>      &lt;%= user.name %&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
<span>end
</span><span>
</span><span>def mount(_, _, socket) do
</span>  users = Accounts.list_users()
<span>- {:ok, assign(socket, users: users), temporary_assigns: [users: []]
</span><span>+ {:ok, stream(socket, :users, users)}
</span><span>end
</span><span>
</span><span>def handle_info({:user_added, new_user}) do
</span><span>- {:noreply, assign(socket, users: [new_user])}
</span><span>+ {:noreply, stream_insert(socket, :users, new_user)}
</span><span>end
</span></code></pre></div><p>In <code>mount/3</code>, we define a stream with <code>stream/3</code>. Streams clean up after themselves, so there is no need to mess with temporary assigns yourself. Like before, streams identify their items by DOM id. By default, it will use the item <code>:id</code> field if the item is a map or struct with such a field. The following two lines are equivalent:</p> <div><pre><code><span>stream</span><span>(</span><span>socket</span><span>,</span> <span>:users</span><span>,</span> <span>users</span><span>)</span>
<span>stream</span><span>(</span><span>socket</span><span>,</span> <span>:users</span><span>,</span> <span>users</span><span>,</span> <span>dom_id:</span> <span>&amp;</span><span>&#34;users-</span><span>#{</span><span>&amp;1</span><span>.</span><span>id</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div><p>Next, in the template in <code>render/1</code>, we mark the container as <code>phx-update=&#34;stream&#34;</code>, then we use a regular <code>for</code> comprehension, but with two changes. Streams are placed under a <code>@streams</code> assign, and when you enumerate a stream you get the computed DOM id along with each item. We then render the DOM id and content as before.</p> <p>Finally, in <code>handle_info/2</code> we see the stream interface in action. <code>stream_insert</code> allows inserting or updating items in the stream. By default, items will be appended on the client, but you can programmatically place them with the <code>:at</code> option, which mimics the behavior of Elixir&#39;s <code>List.insert_at</code>. The following two lines are equivalent:</p> <div><pre><code><span>stream_insert</span><span>(</span><span>socket</span><span>,</span> <span>:users</span><span>,</span> <span>new_user</span><span>)</span>
<span>stream_insert</span><span>(</span><span>socket</span><span>,</span> <span>:users</span><span>,</span> <span>new_user</span><span>,</span> <span>at:</span> <span>-</span><span>1</span><span>)</span>
</code></pre></div><p>To prepend the new user in the UI instead:</p> <div><pre><code><span>stream_insert</span><span>(</span><span>socket</span><span>,</span> <span>:users</span><span>,</span> <span>new_user</span><span>,</span> <span>at:</span> <span>0</span><span>)</span>
</code></pre></div><p>You can also place the user at an arbitrary index, which makes reordering items in the UI a breeze.</p> <p>For deletes, <code>stream_delete</code> works as you&#39;d expect:</p> <div><pre><code><span>stream_delete</span><span>(</span><span>socket</span><span>,</span> <span>:users</span><span>,</span> <span>user</span><span>)</span>
</code></pre></div><p>Here&#39;s a fully realized example of what streams unlock for LiveView developers. We updated our flagship <a href="https://fly.io/blog/livebeats/">LiveBeats</a> example app to use streams for its playlist, with drag and drop re-ordering, deletion, and more:</p>  <h2 id="should-streams-be-used-by-default-now-for-lists-of-items"><a href="#should-streams-be-used-by-default-now-for-lists-of-items" aria-label="Anchor"></a>Should streams Be Used by Default Now for Lists of Items?</h2><p>Streams by default for any kind of collection is a good intuition to have. You should use streams any time you don’t want to hold the list of items in memory – which is most times. Streams are also a goto when you want to efficiently update a single list item without refactoring to a layer of LiveComponents for the items.</p> <h2 id="streams-retrospective"><a href="#streams-retrospective" aria-label="Anchor"></a>Streams Retrospective</h2><p>There&#39;s something really satisfying about implementing a long-term feature, then shedding all that knowledge by being a <em>user</em> of the feature<em>.</em> LiveView features continue to do this kind of thing to me. I wrote it all – and it still feels like magic when using it!</p> <p>After playing with the top-level stream API as a user, I am also struck by how simple it is. I constantly wonder “how did it take this long to do this?”, but then you look at the PR. It touched every layer of the LiveView stack – it required features/additions to the HTML engine at the parser level, the diffing engine, the client diff merging, and patches to morphdom.</p> <p>The best thing about streams is the internal implementation is optimized for both the server and the client. We introduced new features in morphdom to drop all the fake DOM tree hacks from the previous approach.</p> <p>I&#39;m excited to finally offer a comprehensive solution to an area I was never really satisfied with before. I can&#39;t wait to see what folks ship with this!</p> <p>Happy hacking!</p> <p>–Chris</p> <figure> <figcaption> <p> Fly.io is a great way to run your Phoenix LiveView app close to your users. It&#39;s really easy to get started. You can be running in minutes.</p><p><a href="https://fly.io/docs/elixir/"> Deploy a Phoenix app today!  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/static/images/cta-turtle.jpg" srcset="/static/images/cta-turtle@2x.jpg 2x" alt=""/></p></figure>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/phoenix-files/phoenix-liveview-and-sqlite-autocomplete/"> Phoenix LiveView and SQLite Autocomplete </a> </dd> </dl> </article></div>
  </body>
</html>
