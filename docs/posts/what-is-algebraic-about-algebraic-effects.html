<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/what-is-algebraic-about-algebraic-effects/">Original</a>
    <h1>What is Algebraic about Algebraic Effects?</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

                <a href="https://interjectedfuture.com/tag/essays/">Essays</a>
            

            <div>
                <p><a href="https://kguttag.com/author/wil/">
                                <img src="https://www.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d?s=250&amp;d=mm&amp;r=x" alt="Wil Chung"/>
                            </a>
                </p>
                <div>
                    
                    <p><time datetime="2025-09-15">15 Sep 2025</time>
                            <span><span>‚Äî</span> 8 min read</span>
                    </p>
                </div>
            </div>

                <figure>
        <img srcset="/content/images/size/w320/2025/09/ChatGPT-Image-Sep-13--2025--01_24_26-PM.png 320w,
                    /content/images/size/w600/2025/09/ChatGPT-Image-Sep-13--2025--01_24_26-PM.png 600w,
                    /content/images/size/w960/2025/09/ChatGPT-Image-Sep-13--2025--01_24_26-PM.png 960w,
                    /content/images/size/w1200/2025/09/ChatGPT-Image-Sep-13--2025--01_24_26-PM.png 1200w,
                    /content/images/size/w2000/2025/09/ChatGPT-Image-Sep-13--2025--01_24_26-PM.png 2000w" sizes="(max-width: 1200px) 100vw, 1120px" src="https://kguttag.com/content/images/size/w1200/2025/09/ChatGPT-Image-Sep-13--2025--01_24_26-PM.png" alt="What is Algebraic about Algebraic Effects?"/>
    </figure>

        </header>

        <section>
            <blockquote>what does the word &#34;algebraic&#34; mean when used in the context of programming langs?</blockquote><p>I&#39;d wondered the same thing about &#34;Algebraic Effects&#34;, and was excited to find a talk on YouTube titled <a href="https://www.youtube.com/watch?v=atYp386EGo8&amp;ref=interjectedfuture.com" rel="noreferrer">What&#39;s Algebraic About Algebraic Effects and Handlers?</a> Unfortunately, I&#39;m not the target audience. As an engineer that doesn&#39;t shy away from math, it was still out of my depth. </p><p>I found some time this past spring looking into Algebraic Effects, and I think I have a decent answer to the question. </p><h3 id="algebra-in-the-context-of-programming">Algebra in the context of programming</h3><p>My view of &#34;Algebra&#34; in the context of programming is a particular kind of compositionality, where there&#39;s a structure. </p><p>In contrast, mainstream developers often talk about compositionality as just two obj/function that can interoperate due to the same interface, but not much more can be inferred about properties of the interop between the two obj/functions.</p><p>So often times, we get some collection of objects/functions that go together in an arbitrary way according to the taste of the developer that wrote it. If they&#39;re any good, it feels intuitive. But more often than not, it feels arbitrary. The effect is magnified if you look into the codebase. To a newcomer, it feels like a mess, in the same way that a house built by piling stones high feels like a mess: there&#39;s no apparent or easily recognizable structure. </p><h3 id="a-tangential-detour-into-abstract-algebra">A tangential detour into abstract algebra</h3><p>In abstract algebra, structure is often where you take some math object ùõÇ (like an int, or matrix), and you pair it with an operation, (like + or *), and you say: integers can be composed with op `+`, but we can ALSO infer properties in these combos--or laws.</p><p>So a common one we know is: integer (‚Ñ§) with addition (+) has implied properties that always hold. And the elements (‚Ñ§), the op (+), and the properties together constrain outcomes, and this is what gives us structure. A house with structure feels like it&#39;s built with arches,</p><p>rather than a pile of rocks. What are the properties of (‚Ñ§) and (+)? Due to how ‚Ñ§ and + are defined, we get these properties: </p><p>1. <strong>Closure</strong>: ‚Ñ§ + ‚Ñ§ always gives you another ‚Ñ§. </p><p>Sometimes devs write code that doesn&#39;t give you back the same thing.</p><p>2. <strong>Associativity</strong>: (a + b) + c = a + (b + c) where a, b, c are in ‚Ñ§. </p><p>This familiar, as they were drilled in grade school. But often devs don&#39;t write code that fulfill this property.</p><p>The last two are: </p><p>3. <strong>identity</strong>: ‚Ñ§ has an element that doesn&#39;t change when we use +. </p><p>4. <strong>inverse</strong>: every ‚Ñ§ has a matching ‚Ñ§ that give us the identity when we use + on it: a + (-a) = 0, where a and -a are in ‚Ñ§.</p><p>Taken together, math peeps gave this kind of structure a name: Groups. So if someone says [a struct] and [an op] together form a group, I can automatically can assume those properties. It&#39;s a shorthand.</p><p>If you add even more constraints/properties to how ‚Ñ§ and + behave together, you get another algebraic structure. There&#39;s a whole host and families of these. So if we add another constraint, we get an Abelian Group: </p><p>5. Commutativity: a+b = b+a, where a, b are in ‚Ñ§</p>
<!--kg-card-begin: html-->

<!--kg-card-end: html-->
<h3 id="surmounting-the-network-with-algebra">Surmounting the network with algebra</h3><p>Why write constraining data structure and op pairings? It&#39;s quite useful if you want to guarantee specific properties of your system. For example, it&#39;s well known that syncing is hard, because of the Eight Fallacies of Distributed Systems.</p><ol><li>The network is reliable; </li><li>Latency is zero; </li><li>Bandwidth is infinite; </li><li>The network is secure; </li><li>Topology doesn&#39;t change; </li><li>There is one administrator; </li><li>Transport cost is zero; </li><li>The network is homogeneous.</li></ol><p>That means your data, when sent over the network will likely arrive out of order. Worse, clocks can be out of sync, so it can look like data arrived from the future. How can we tame the underlying unreliable system? By constraining our data and operations to have properties.</p><p><a href="https://interjectedfuture.com/trade-offs-between-different-crdts/" rel="noreferrer">CRDTs</a> are nowadays used to enforce eventually consistent syncs. It achieves this by pairing a data structure with a merge operation, which together form an algebraic structure called a semi-lattice. The properties of a semi-lattice are:</p><ul><li><strong>Closure</strong>: For all a, b in the set S, the result of a ‚àò b is also in S. </li><li><strong>Associativity</strong>: a ‚àò (b ‚àò c)=(a ‚àò b) ‚àò c for all a, b, c ‚àà S. </li><li><strong>Commutativity</strong>: a ‚àò b = b ‚àò a for all a, b ‚àà S. </li><li><strong>Idempotence</strong>: a ‚àò a = a for all a ‚àà S. </li></ul><div><p>üí°</p><p>`‚àò` means `merge op` and `‚àà` means `is an element of set`</p></div><p>Together, this is enough to counteract the network mixing up your data when sending it over the network. I wrote about that here:</p><figure><a href="https://interjectedfuture.com/a-simple-way-to-understand-crdts/"><div><p>A simple way to understand CRDTs</p><p>üî∞If CRDTs (Conflict-free Replicated Data Types) are new to you, check out this previous post. There‚Äôs a simple way to understand CRDTs: It leverages algebra to unmix the inevitable mixing of data when syncing over an unreliable network. Why are networks unreliable? For one, it‚Äôd be really expensive to build</p><p><img src="https://interjectedfuture.com/content/images/icon/favicon-4.ico" alt=""/><span>Interjected Future</span><span>Wil Chung</span></p></div><p><img src="https://interjectedfuture.com/content/images/thumbnail/DALL-E-2024-11-15-09.49.25---An-illustrative-blog-post-header-for-the-theme--A-simple-way-to-understand-CRDTs-using-algebraic-operations---in-a-bright-pastel--flat-style.-Depict-a.jpeg" alt="" onerror="this.style.display = &#39;none&#39;"/></p></a></figure><p>So by constraining the power of what our code can do, we can ensure the system has specific desirable properties that achieve the goal of syncing data over an unreliable network. It&#39;s where we say: &#34;If we compose this kind of data structure in this constrained way with this kind of merge function, then we can guarantee these properties always hold. And with this structure, our data can survive sync over an unreliable network with other syncers.&#34;</p><h3 id="from-monads-to-algebraic-effects">From Monads to Algebraic Effects</h3><p>This is why people also like Monads. Monads are about how to compose code, but with specific properties (Monadic laws) so we can achieve some goal in how they compose. I won&#39;t go into it here, as this is already long, but that&#39;s the core idea.</p><p>However, not all types of Monads compose well together. Here&#39;s where I&#39;m out of my depth, but I&#39;ve read and I&#39;m told that this is why there are Monad Transformers, so you can fit different domain Monads together.</p><p>Hence, some people have started looking at Algebraic Effects, as a way to achieve the same compositional powers of monads, but in a different way. Most descriptions of Algebraic Effects actually ignore the `algebraic` part, because describing `effects` is already a big leap.</p><p>The effects part, is often explained as &#34;resumable exceptions&#34;. I wrote a short description of what algebraic effects are from that perspective, so I won&#39;t expound on that here.</p><figure><a href="https://interjectedfuture.com/elm-should-have-had-algebraic-effects/"><div><p>Elm should have had Algebraic Effects</p><p>If Elm had Algebraic Effects, it would have made it more adaptable to these multi-message processing.</p><p><img src="https://interjectedfuture.com/content/images/icon/favicon-5.ico" alt=""/><span>Interjected Future</span><span>Wil Chung</span></p></div><p><img src="https://interjectedfuture.com/content/images/thumbnail/Gemini_Generated_Image_6hdpqg6hdpqg6hdp.png" alt="" onerror="this.style.display = &#39;none&#39;"/></p></a></figure><p>But the algebraic part of algebraic effects is that the effects that you raise as a &#34;resumable exception&#34; can be composed together! Not just in any way: design them so when composed, they have *guaranteed properties* just like the stuff you saw above!</p><p>For example, if we had a key/value store that we interface with using <code>get</code> and <code>put</code>, we could express what we expect to happen through some algebraic properties.</p><ol><li><strong>Idempotence of consecutive reads (get-get)</strong>: get k; get k ‚â° get x</li></ol><p>This says, two consecutive <code>gets</code> is functionally equivalent to a single <code>get</code>. This guarantees that <code>get</code> is a <em>pure observation</em>: it doesn&#39;t consume or advance anything. If this law didn&#39;t hold, reading could &#34;drain&#34; or &#34;advance&#34; some hidden cursor. By making it a law, we make it an explicit behavior for our users, so they&#39;re not surprised by bugs down the line when their assumptions veer from this property.</p><ol start="2"><li><strong>Last write wins (put-put)</strong>: put k v1; put k v2 ‚â° put k v2</li></ol><p>Easy. The two <code>puts</code> together is the functional equivalent of only executing the last one. Hence, the last <code>put</code> is the value that&#39;s currently sitting in key <code>k</code>. This encodes <em>overwriting semantics</em>, and without it, <code>put</code> might append, merge, or accumulate. It wouldn&#39;t be what users would expect.</p><ol start="3"><li><strong>Read after write (put-get)</strong>: put k v; get k ‚â° put k v; return v</li></ol><p>Executing a <code>put</code> and then an immediate <code>get</code> is the functional equivalent of just executing the put, but then just returning the value <code>v</code> you already have in hand, instead of executing <code>get</code>. This is important to guarantee the <em>consistency</em> of reads right after writes. Without this, you could write <code>v</code> and then not see <code>v</code> immediately, which would break the intuitive model of state in a key/value store.</p><ol start="4"><li><strong>Write back same value (get-put)</strong>: get k &gt;&gt;= (Œªv. put k v) ‚â° return ()</li></ol><p>If you read the value of a key and then immediately write it back unchanged, that&#39;s functionally equivalent of doing nothing (returning unit). </p><div><p>üí°</p><div><p>You can think of <code spellcheck="false">&gt;&gt;=</code> as saying &#34;and then...&#34;. So rule 4 in javascript pseudocode might look like:</p></div></div><div><p>üí°</p><p>in <code spellcheck="false">return ()</code>, <code spellcheck="false">()</code> is called <code spellcheck="false">unit</code>, which is the way functional programmers denote &#34;no meaningful value&#34;, which is effectively what C programmers use <code spellcheck="false">void</code> for. They&#39;re <i><em>technically</em></i> different, but in practice, they&#39;re used for similar purposes.</p></div><ol start="5"><li><strong>Independence across keys</strong> For <code>k1 ‚â† k2</code>:</li></ol><pre><code>put k1 v1; put k2 v2  ‚â°  put k2 v2; put k1 v1
get k1; get k2        ‚â°  get k2; get k1
put k1 v; get k2      ‚â°  get k2; put k1 v
</code></pre><p>Operations on different keys commute, and the store treats each key as an independent cell. This is what makes it a key/value store, rather than some entangled data structure.</p><p>Hence, just because you are writing effects, doesn&#39;t automatically mean they&#39;re algebraic. You have to consciously design them to be so, in order to give properties or guarantees that you want your users to have. Most current programming languages have no way of enforcing these equational axioms, so even esoteric languages that feature algebraic effects don&#39;t even try to enforce them. </p><p>Languages which feature dependent types, such as Coq, Agda, Idris 2, and Lean are the only languages that can encode these equational axioms explicitly and be able to prove their veracity. Typically, these languages are used by mathematicians to do proofs in math. But interestingly, Lean has been getting a lot of momentum, and it can compile to C. It can be a practical in-road to using these in practice. </p><p>And, in my own words, that&#39;s what&#39;s algebraic about algebraic effects.</p><h3 id="epilogue">Epilogue</h3><p>Alan Kay was known to lament that 1 million lines in a code base is unconscionable. It&#39;s no more a skyscraper than a pile of rocks. That&#39;s because there&#39;s often no structure. Eventually we figured out arches: they&#39;re structure that give strength with less material.</p><p>Hence, we can build higher without using more material. By analogy, we&#39;re starting to discover what this structure looks like in software. And it looks like math. There&#39;s a lot of resistance to this, and will be for a long time.</p><p>And maybe with LLMs, it might not matter for a wide swath of applications. But still, there&#39;s ever progress moving forward in this direction, where these pure functional programming or math-y ideas filter down to more mainstream languages.</p>
        </section>

    </article>


</div></div>
  </body>
</html>
