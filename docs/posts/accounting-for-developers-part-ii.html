<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.moderntreasury.com/journal/accounting-for-developers-part-ii">Original</a>
    <h1>Accounting for Developers, Part II</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction">Introduction</h2><p>Welcome back to our <em>Accounting for Developers</em> series. Before diving into this post, you may want to read Part I <a tabindex="0" href="https://www.moderntreasury.com/journal/accounting-for-developers-part-i">here</a>.</p><p>In this tutorial, we will be designing the ledger for a Venmo clone—a simple digital wallet app. Throughout, we will show how to apply the <a tabindex="0" href="https://www.moderntreasury.com/journal/what-is-double-entry-accounting">double-entry accounting</a> principles we covered in Part I. We hope to publish guides about more complex use cases (lending, insurance, etc.) in the future.</p><p>If you’re curious about the API calls and system design considerations of designing a <a tabindex="0" href="https://www.moderntreasury.com/learn/digital-wallet">digital wallet</a> app, you can also check out our previous journal on <a tabindex="0" href="https://www.moderntreasury.com/journal/how-to-build-a-digital-wallet-product">how to build a digital wallet</a>.</p><p>To recap, for a system to gain the consistency benefits that accounting provides:</p><ol><li>It should be composed of accounts and transactions:<ol><li>Accounts should be classified as debit or credit normal;</li><li>Transactions should enforce double-entry upon creation. Each transaction needs to have <em>at least two entries, </em>which, in aggregate, must affect credit and debit sides in equal amounts.</li></ol></li><li>The aggregate balance of credit normal accounts and debit normal accounts should net out to zero (credits = debits).</li></ol><h2 id="building-a-venmo-clone">Building a Venmo clone</h2><h2 id="step-1-reviewing-the-use-case">Step 1: Reviewing the use case</h2><p>Let’s start with the product requirements of our Venmo clone, first from the user’s perspective:</p><ul><li>Each user will have an account balance, exposed via the app</li><li>Users can add to their balance by way of card payments</li><li>Users can send money to each other in the app</li><li>Users can withdraw their balance into a bank account via <a tabindex="0" href="https://www.moderntreasury.com/learn/what-is-ach">ACH</a> or a debit card</li><li>Users will pay a small fee when they make a withdrawal from the app, to be deducted from their wallet balance.</li></ul><p>From a product perspective:</p><ul><li>We want to discern between the account balances for each user and expose them to said users consistently;</li><li>We want to ensure cash in hand in our bank account is always equal to the total users deposited in the app;</li><li>We want to properly calculate and collect revenue from fees;</li><li>Each deposit will need to account for a 3% card transaction processing fee paid by us.</li></ul><h2 id="step-2-building-your-chart-of-accounts">Step 2: Building your chart of accounts</h2><p>With these requirements in mind, let’s map our <a tabindex="0" href="https://www.moderntreasury.com/learn/chart-of-accounts">chart of accounts</a> (COA). The COA is a simple depiction of the accounts we will need, their type, and normality:</p><div><figure><span><span></span><img alt="Sample Chart of Accounts - Venmo Clone" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive"/></span></figure></div><figcaption>Our Venmo Clone&#39;s Sample Chart of Accounts</figcaption><p>Let’s review this in detail:</p><p>A <strong>cash account</strong> represents the amount of money we are holding in our bank account in cash. Because it represents an <strong>asset</strong> or <strong>use</strong> of funds, we will treat it as a <strong>debit normal </strong>account. For more information on debit and credit normal accounts, refer to the “Dual Aspect” section of Part I of this series <a tabindex="0" href="https://www.moderntreasury.com/journal/accounting-for-developers-part-i">here</a>.</p><p>The user balance accounts represent funds we are holding on behalf of our users. Because users should be able to withdraw them at any time, they are funds we ‘owe’—or <strong>liabilities</strong>. Those funds are technically now available for our ‘use’ - and as such, they are <strong>sources</strong> of funds. Therefore, they should be <strong>credit normal </strong>accounts. Notice that we need one account for each customer that creates an account with us.</p><p>To track card fees, we will be using a debit normal account. This account’s balance will increase every time we pay off card processing fees. This is a debit normal account because it represents <strong>expenses</strong> or <strong>uses</strong> of funds.</p><p>Finally, the fees we collect in each transaction are to be treated as revenue. Given these are <strong>sources of funds</strong>, they are credit normal accounts.</p><h2 id="step-3-mapping-sample-transactions">Step 3: Mapping sample transactions</h2><p>After mapping our chart of accounts, we should consider the typical events that will affect the ledger. For the sake of this example, we will cover three transaction types:</p><ol><li><strong>Transfers</strong>: user sends money from their balance to another user.</li><li><strong>Deposits</strong>: user adds cash into their account balance. At the time of transfer, we need to account for the credit card processing fee. (Let’s assume, for the sake of this example, that credit card fees are paid by us.)</li><li><strong>Withdrawals</strong>: user withdraws from their account balance. We charge a fee when users withdraw from the app, deducted from their balance. At the time of<strong> </strong>transfer, we need to account for<strong> </strong>our own service fee as revenue.</li></ol><p>Let’s walk through the implementation for these transactions, starting with a transfer:</p><div><figure><span><span></span><img alt="Venmo Clone Transfer Map" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive"/></span></figure></div><figcaption>Mapped funds transfer of $100 from Art to Brittany</figcaption><p>This chart shows a typical transfer of $100 from Art to Brittany. In this case, the transaction amount is debited (deducted) from Art’s Wallet (who’s initiating the transfer) and credited (added) to Brittany’s Wallet (who’s the receiver).</p><p>Note that this logic can be used for any in-app transfer—we just have to designate which wallet is the sender vs receiver in each case. All wallets are represented as credit normal accounts. If Brittany was sending money to Art, then Brittany’s balance would be debited (decrease), and Art’s balance would be credited (increase).</p><p>Next, let&#39;s look at a deposit:</p><div><figure><span><span></span><img alt="Art&#39;s Deposit" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive"/></span></figure></div><figcaption>Art&#39;s Deposit of $300</figcaption><p>In this model, three accounts are involved: the Art&#39;s Wallet, Cash, and Card Processing Expenses. When Art deposits an amount into his wallet, he will see the balance increase by the same amount. Simultaneously this will increase  cash balance and the total paid in processing fees.</p><p>To further illustrate this, let’s say Art deposits $300 in his wallet balance using a credit card. Recall that for the sake of this example, our app is paying for card fees. To counterbalance the $300 credit (increase) on Art’s Wallet, we need two debit entries: one on the cash account (which increases it) and one on the card processing expenses account (which also increases it).</p><p>Our card processing expenses account increases by $6 (or 2% of the transaction). And given we are recording this expense as paid off to our credit card vendor, our cash balance increases by $294 ($300-$6).</p><p>The power of double-entry is recording this flow of money in a single event. Without double-entry, we would need a way for the system to recognize all of the deposit transactions and properly account for card fees. By recording all of the money movement in a single transaction with multiple entries, we make sure our system is consistent. As debits = credits, money in equals money out.</p><p>The same goes for a withdrawal:</p><div><figure><span><span></span><img alt="Brittany&#39;s Withdrawal" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive"/></span></figure></div><figcaption>Brittany&#39;s Withdrawal of $500</figcaption><p>A withdrawal is similar to a deposit, except that in this case, we are charging an extra fee from the user and recognizing it as revenue from fees. This transaction will decrease Brittany’s Wallet and Cash but will increase Revenue from Fees.</p><p>For example, let’s say Brittany is withdrawing $500 from her wallet balance. Brittany knows that she will pay a fee on that transfer amount. Let’s assume that the fee is 0.5% of the withdrawal amount, or $2.50. Her user wallet gets deducted for the entire $500 + $2.50, or $502.50. That is the debit entry (decrease) on her user wallet balance.</p><p>To represent this on the credits side, we will add a credit entry that deducts the cash account for $500, given this is actual money we wired out to Brittany. However, we owe $2.50 less to Brittany and can recognize the fees we charged from her as revenue by crediting (increasing) our revenue from fees account.</p><p>There are many different ways to model this. We could have chosen to have Brittany receive $497.50 ($500-$2.50), for example. In this case, we would add/credit the $2.50 we kept to revenue from fees similarly, but our cash would only decrease/credit by $497.50. The ledger would still balance. Thinking in terms of credit and debit normality gives you the flexibility to log transactions in the best way for your business.</p><h2 id="step-4-bringing-it-all-together">Step 4: Bringing it all together</h2><p>Let’s review the logical elements we would need to create to service this use case:</p><ul><li>One ledger object that represents the entire collection of accounts and transactions. All of our accounts and transactions should belong to a single ledger.</li><li>At least four types of account objects:<ul><li>User Wallets (one per user, credit normal)</li><li>Cash (single account, debit normal)</li><li>Revenue from Fees (single account, credit normal)</li><li>Card Processing Expenses (single account, debit normal)</li></ul></li><li>At least three modeled transactions<ul><li>User Transfer</li><li>Deposit</li><li>Withdrawal</li></ul></li></ul><p>If you are building a ledger using a relational database you’ll want to model accounts as belonging to a single ledger where transactions (or events) will be written into. Accounts should have constraints according to their type: credit or debit normal. Such constraints should dictate how debit or credit entries affect account balances according to the principles we covered on <a tabindex="0" href="https://www.moderntreasury.com/journal/accounting-for-developers-part-i">Part I</a>.</p><p>Similarly, transactions would have to be modeled in a way such that they are composed of at least two entries. Such entries would have a ‘direction’, one of debit or credit. Your system should enforce equality between the sum of amounts on debit entries and the sum of amounts on credit entries.</p><p>The double-entry treatment for each type of transaction we covered on step 3 can then be mapped into functions in your application code that dictate how you will write into the ledger database as transactions happen.</p><p>By setting up the ledger as a double-entry system, we ensure that our Venmo clone scales consistently. And as new product requirements come up or functionalities are rolled out, we can update our chart of accounts and the transaction models to represent them in the ledger appropriately.</p></div></div>
  </body>
</html>
