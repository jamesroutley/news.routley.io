<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mihaiolteanu.me/language-abstractions">Original</a>
    <h1>A Lisp adventure on the calm waters of the dead C (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="contents">
            
            
            <p>
                I will use a C-like language throughout, with substantial
                liberties in its syntax, and I will try to answer &#34;what if&#34; and
                &#34;how&#34; questions regarding the implementation of some new
                features that actually cannot be implemented in C due to its
                limitations. I will examine and highlight those limitations. The
                scope of this exercise is to better understand Lisp and the
                power of the abstractions it offers over and above what most
                languages have, even though there will be no line of Lisp
                anywhere. For the full experience, you are encouraged to come up
                with new examples, sketch some exercises with pen and paper and
                think hard about these problems on your daily walks.
            </p>

            <blockquote>
                <p>
                    Were there no advantages to be reaped from these studies, beyond the
                    gratification of an innocent curiosity, yet ought not even this to be despised;
                    as being one accession to those few safe and harmless pleasures, which are
                    bestowed on human race.
                </p>

                <p>
                    — David Hume - An Enquiry Concerning Human Understanding (1748)
                </p>
            </blockquote>

            <h2>The basic abstractions of any language, the standard function</h2>
            <p>
                The function, as an abstraction, is known to every developer. But what is,
                conceptually speaking, a function? Ignoring any implementation details like
                stacks and pointers and just taking a higher-level view of the concept of
                function, we can begin to understand its essence (example slightly adapted),
            </p>

            <blockquote>
                <p>
                    […] people who use the word &#39;function&#39; ordinarily have in mind expressions in
                    which a number is just indicated indefinitely by the letter <em>x</em>, e.g.
                </p>
                
                <em>
            2*x<sup>3</sup> + x
                </em>

                <p>
                    People call <em>x</em> the argument, and recognize the same function again in
                </p>

                <em>
            2*1<sup>3</sup> + 1,</em>

                <p>
                    only with different arguments, viz. <em>1</em>, <em>4</em>, and <em>5</em>. From this we may discern that
                    it is the common element of these expressions that contains the essential
                    peculiarity of a function; i.e. what is present in <em>2*x^3 + x</em> over and above the
                    letter <em>x</em>. We could write this somewhat as follows:
                </p>

                <em>
            2*( )<sup>3</sup> + ( )
                </em>

                <p>
                    I am concerned to show that the argument does not belong with a function, but
                    goes together with the function to make up a complete whole; for a function by
                    itself must be called incomplete, in need of supplementation, or unsaturated […].
                </p>

                <p>
                    Thus, e.g., we split up the sentence &#39;Caesar conquered Gaul&#39; into
                    &#39;Caesar&#39; and &#39;conquered Gaul&#39;. The second part is unsaturated - It contains an
                    empty place; only when this place is filled up with a proper name, or with an
                    expression that replaces a proper name, does a complete sense appear. Here too
                    I give the name &#39;function&#39; to the meaning of this unsaturated part. In this
                    case the argument is Caesar.
                </p>

                <p>
                    — Frege - <a href="http://fitelson.org/proseminar/frege_fac.pdf">Function and Concept</a> (1891)
                </p>
            </blockquote>

            <p>
                Bluntly, a function is a piece of code that is missing another piece of code to
                make it whole. To make it complete. We usually specify the missing pieces by
                giving them names (the arguments) so that we are not confused which is which
                when the time comes to replace them. We can translate the above example in C,
            </p>

            <pre>int f(int ___) {
    return 2 * cube(___) + ___;
}   </pre>

            <p>
                The essence of this function is the <em>cube</em>, the multiplication(<em>*</em>) and the
                addition (<em>+</em>). What is missing, the thing that we need to supplement it with, is a
                number on which to apply the <em>cube</em>, the multiplication and the addition
                operations.
            </p>

            <p>
                Usually we&#39;re defining such functions as,
            </p>

            <pre>int f(int x) {
    return 2 * cube(x) + x;
}    </pre>        

            <p>
                but notice that it does not matter what the name of the parameter is, which is
                nicely exemplified in our previous example, where we&#39;ve used <em>___</em> to highlight
                the fact that what we are doing is taking away some piece of code which we
                intend to put in later. Thus, <em>x</em> could be replaced throughout the function with
                <em>abc</em> or <em>my-new-parameter</em> and it would not matter a bit regarding the
                semantics of our intention. It would still be the same function.
            </p>

            <p>
                Let&#39;s use this function and analyze what happens during its call,
            </p>

            <pre>/* We can give this whatever name we want */
int a = 5;

/* Call the function (i.e. add the missing pieces) */
f(a);

/* Inspect the body of the function after the replacement. */
return 2 * cube(5) + 5;  </pre>

            <p>
                Notice there is no trace of <em>a</em> inside the body of the function after the
                replacement and before the call of the multiplication, the <em>cube</em> and the
                addition. Before the missing pieces are added, or before the function is
                supplemented, if you will, the parameter itself gets replaced as well. The call
                is <em>f(a);</em> but the result is not <em>return 2 * cube(a) + a;</em>. The C implementation
                knows that what we really want is the value of <em>a</em>, which is <em>5</em> and not <em>a</em>
                itself. This is the good news. The bad news is that it enforces this
                replacement without a right to appeal from our side. We will get to the
                limitation of this shortly.
            </p>

            <p>
                If all this seems a bit pedantic, fear not. It is important for what follows. As
                we will see, the kind of &#34;missing things&#34; (the <em>___</em>&#39;s) the we can extract and
                talk about in the process of creating (or defining) a function has a direct
                relation to the kind of abstractions we can create in a programming
                language. They put a high limit on the kind of functions we can define. Or, more
                directly, it directly relates to the power of the language.
            </p>

            <h2>Conditional evaluation of parameters</h2>
            <div>
                <blockquote>
                    <p>
                        Essences are those common and recurring qualities essential to all members of a
                        class, conceived of abstractly, that is, in abstraction from all particular
                        problems.
                    </p>

                    <p>
                        — Arthur F. Holmes - A History of Philosophy, <a href="https://www.youtube.com/watch?v=A_gTxt4slcE">John Locke&#39;s Theory of Ideas</a>
                    </p>
                </blockquote>

                <p>
                    These abstractions that we just saw, that involve a kind of &#39;replacing of
                    values&#39;, are what most programming languages offer, including C. We can define
                    any and how many functions we might like, but when it comes to defining
                    functions like or similar to <em>if</em> and <em>while</em>, among others, we reach the dead
                    C. These are all offered by the original designers of the language, specified in
                    a standard and enacted by all the complying C implementations. They are useful
                    to us but we cannot implement them, if we wanted to. Or, what it&#39;s more
                    important, we cannot implement anything similar to them for our own needs.
                </p>
            </div>

            <h3>The classic <em>if</em> statement</h3>
            <p>
                A simple example,
            </p>
            <pre>if (a &gt; b) {
    result = a-b;
} else
    result = a+b; </pre>

            <p>
                I&#39;ve said above that this is a function, even though in C terms it is a
                statement. Indeed, this statement is underneath nothing more than a void
                function with a special syntax approved by the standard. While the standard is
                untouchable, we can still imagine implementing an <em>if</em> function (<em>iff</em>) that
                behaves like the original one,
            </p>

            <pre>void iff(bool condition, ??? exp1, ??? exp2) {
    if (condition) 
        exp1;
    else
        exp2;
}  </pre>   

            <p>
                I can clearly imagine this being the C&#39;s way of doing things and it would
                subtract nothing from its usefulness,
            </p>

            <pre>iff(a &gt; b, result = a-b, result = a+b);</pre>
            
            <p>
                This is not valid C code, but its a skeleton on which we want to build. It is
                code under development, if you will. But the intention is clear: we want our
                function to decide if it should evaluate <em>result = a-b</em> or <em>result = a+b</em> based
                on the value of <em>a &gt; b</em>, but not both of them.
            </p>

            <p>
                I&#39;ve left out the type of the <em>iff</em>&#39;s parameters, since there is actually no C
                type that we can use to do what we want. We will come back to this in the next
                section when we will discuss in more detail what type those parameters should
                really be.
            </p>

            <p>
                This looks similar to our very first example, the <em>f</em> function. As we saw then,
                before replacing the missing code inside our function body, the C language
                evaluates the parameters to get their value. And it is the value of these
                parameters and not the parameters themselves that get passed inside our function
                body to replace the missing code. To supplement our function and make it
                whole. This is <a href="https://en.wikipedia.org/wiki/Evaluation_strategy">pass by value</a> and is used in C as well as in most other
                programming languages.
            </p>

            <p>
                To make the above clear, let us imagine the inside of our function right after it
                was called and check the value of the parameters,
            </p>

            <pre>/* Take some values for a and b */
int a=5;
int b=10;
int result;

/* Make the call. */
iff(a &gt; b, result = a-b, result = a+b);

/* Inspect the inside of the function after the call. */
if (false) 
    -5;
else
    15;  </pre>

            <p>
                To sum up, all the parameters to any function we might care to define are
                evaluated before we can even get a chance to inspect and decide what to do with
                them. This is the bad news from our previous section. In the above call, <em>a &gt;
b</em>, <em>result = a-b</em> and <em>result = a+b</em> are all evaluated before entering the
                <em>iff</em> body, in no particular order (the order of evaluation is not specified in
                the standard and it is left to each implementation to decide). We would have
                wanted the whole expression and we to be the ones that decide what expression is
                to be evaluated and when. The point to take is that we do not control the time
                of the evaluation nor the order of it, nor we can decide not to evaluate some of
                the parameters at all if we so choose.
            </p>

            <h3 id="orgc6ec414">Other useful, but impossible, conditionals</h3>
            <p>
                There is no reason enough to despair for not being able to implement the <em>iff</em>
                function. After all, our language already provides this conditional. The
                point of the exercise, though, is to extend the language to its breaking
                point so as to understand both it and more powerful languages
                better. And this, we did. Nonetheless, there are really useful
                conditionals out there which, owing to the same limitations that we&#39;ve
                already discovered, cannot really be implement and are not offered by
                the language standard either,
            </p>

            <pre>cond(a &gt; b,           &#34;a is greater than b&#34;,
     a &gt; c,           &#34;a is greater than c&#34;,
     weekday(FRIDAY), &#34;let&#39;s go home&#34;,
     else,            &#34;nothing matched&#34;);   </pre>

            <p>
                Known as <em>cond</em> in the lisp world, the generic conditional is similar in looks
                with the <em>switch</em> statement, but each case has a brand new condition. I could
                imagine a C implementation of a function with an even and variable number of
                arguments, where each pair of arguments specifies a condition and a result
                returned by the <em>cond</em> function if that condition is true. All conditions are
                evaluated in order until one evaluates to true; otherwise the last one is
                returned. Here again we need to control the order of evaluation of the
                parameters and choose not to evaluate some of them, if we so wish.
            </p>

            <p>
                Or, a small update to the standard <em>if</em> function would let it
                return the result of its last evaluation (an expression, that is), in
                which case we really do need to be able to implement the <em>if</em> function,
            </p>

            <pre>result = iffv(a &gt; b, a-b, a+b);</pre>

            <p>
                Or an extended <em>if</em> that catches any errors that might be thrown during the
                evaluation of its first argument and sends them to its last argument (I&#39;ve
                ignored the actual error here),
            </p>

            <pre>if_timeout(
    elevator_state(),
    printf(&#34;Elevator is running&#34;),
    printf(&#34;Elevator is stopped&#34;),           
    printf(&#34;Unknown elevator state, possibly due to bad sensor.&#34;)
); </pre>
            
            <p>
                Any such or other variants of conditionals specifically designed for our own
                problem domain would greatly enhance our expressiveness in the language. But all
                these depend on features we found lacking in our language, for the reasons we&#39;ve
                already seen.
            </p>

            <h2>Repeated evaluation of the same parameters</h2>
            <p>
                We have a similar story in the case of the <em>while</em> statement. The only
                difference is in the way we would like to handle the parameters to it. I will
                again assume that <em>while</em> is an implementable function, and just use it,
            </p>

            <div>
                <pre><span>while</span>(a &gt; 0, a--, add_to_list(a));
                </pre>
            </div>

            <p>
                What we want is to evaluate the first argument and if that is true it evaluate
                the second and third arguments in order, and terminate otherwise. Somewhat
                similar to the <em>if</em>, in that it selectively evaluates its arguments based on one
                of them. But unlike an <em>if</em>, a <em>while</em> continues this process over and over
                again until its first argument evaluates to false. That is, we would like to
                have the ability not only to selectively evaluate what parameters we like, but
                also the ability to evaluate some of them more than once. This, our language
                again does not offer. If we remember the bad news, any parameter is evaluated
                once before entering the function body, after which we only have access to the
                evaluation result and no way to repeat that evaluation again, if we so choose.
            </p>

            <p>
                We cannot have a function, for example, that evaluates an expression a given
                number of times (10) as long as it returns false, with a timeout (5000 ms)
                between the evaluations,
            </p>

            <pre>try_wait_ms(
    open_lock(),
    5000,
    10,
    error(&#34;cannot open lock&#34;)
);  </pre>
            
            <p>
                As above, similar abstractions in the same spirit as a <em>while</em> function
                are imaginable but not expressible with our meager tools.
            </p>

            <h2>Mixed evaluation of parameters</h2>
            <p>
                The <em>while</em> function evaluates all its parameters more than once until the first
                one returned false. This <em>for</em> function is a mixed bag,
            </p>

            <pre>for(a = 1; a &lt; 10; a++; add_to_list(a))</pre>        

            <p>
                The <em>for</em> function evaluates its first argument only once, expects the second
                argument to be an expression returning a boolean and evaluates the last two as
                long as the second expression returns true. Again, not possible for multiple
                reasons, one of them being the inability to control when, if and how many times
                we can evaluate the parameters given to a function.
            </p>

            <p>
                Can you think of other useful tools? After all, we&#39;re barely scratched
                the surface while trying, and failing, to implement some of the features
                our language already offers. Once you&#39;re thus liberated, you start
                imagining and implementing abstractions that were not possible
                before. And all that in the language you are already using. What usually
                happens if these abstraction are not available? A differet language or
                tools get implemented that takes care of current limitations. See <a href="https://www.defmacro.org/ramblings/lisp.html">The Nature of Lisp</a>
                for a very beautiful example from the Java world. Ok. I&#39;ll be of some
                help and offer you a few more impossible abstractions. But you&#39;ll have
                to start and think out some new ones yourself. Promise? Let&#39;s go!
            </p>

            <h2>The correct type that we&#39;re looking for is a <em>function</em></h2>
            <p>
                The previous kind of abstractions had to do with the evaluation strategy of the
                arguments passed to a function. At least, that&#39;s what we&#39;ve highlighted in our
                examples. We saw that some of the arguments can be evaluated multiple times
                (<em>while</em> and <em>for</em>) or not evaluated at all (<em>if</em>) and that this was decided
                based on the values of arguments or expressions that were also passed to those
                functions. We also saw how this was useful if nothing more than for the reason
                than these are abstractions that any C developer already uses.
            </p>

            <p>
                This section stresses a different kind of abstraction. This is already evident
                from the previous discussion but there we ignored it. This time, we will focus
                on what can actually pass as a function parameter. Let&#39;s take a closer look at
                what kind of code we <b>can</b> actually implement in C,
            </p>

            <pre>int iff(bool cond, int ___, int ______) {
    if (cond) 
        ___ * 10;
     else
        ______ + 5;
} </pre>

            <p>
                and the kind of code we can&#39;t,
            </p>

            <pre>int iff(bool cond, ??? ___, ??? ______) {
    if (cond) 
        ___;
    else
        ______;
}   </pre>

            <p>
                I am again using question marks for types the language does not quite offer and
                underscores to better reflect what we want to extract from our function to make
                it more general, more abstract. In the first case, the parameters are <em>int</em>&#39;s
                and what we are extracting from the function are just the places where those
                <em>int</em>&#39;s would go. In the second example, the parameters are expressions and what
                we are extracting from the function are whole expressions of the
                language. Expressions with which we want to supplement our function at a later
                date and evaluate them in their respective places. What is another name for one
                or more expressions evaluated in order? A function. So the correct type for
                these parameters, as well as in our <em>if</em>, <em>for</em> and <em>while</em> examples from above,
                are functions,
            </p>

            <pre>int iff(bool cond, fn exp1, fn exp2) {
    if (cond) 
        exp1();  /* Call the function parameter */
    else
        exp2();  /* Call the function parameter */
}  </pre>
            
            <p>
                While the type of the parameters are indeed <em>fn</em>, or function, notice that we&#39;re
                actually passing expressions. What this means is that we need an ability to say
                this to our language,
            </p>
            
            <pre>x + 1</pre>

            <p>
                and transmit the intention of creating and passing this function as a parameter, at
                run-time,
            </p>

            <pre>int random_name(int x) {
    return x + 1;
}   </pre>

            <p>
                Except that functions are not first-class citizens in C. There is no such type
                as <em>fn</em>. That is, we cannot build functions at runtime and pass them, as
                objects, to other functions for their use. What we can do, is define a function
                statically and pass a pointer to that function to our map function. That means
                that, even if we use a function just once, we still have to define it before we
                use it. More importantly, the kind of functions we can thus use are limited
                since we cannot use and catch variables (more on this below). In short, we&#39;ve
                uncovered another limitation in our language.
            </p>

            <h2>A different kind of abstraction: map</h2>
            <p>
                Thus far we&#39;ve only seen what a replacement of sequences of expressions would
                mean for our ability to define new type of functions. We&#39;ve correctly deduced
                that these expressions are nothing more than functions of zero parameters which
                we can just call at the right place. But what if we could define functions with
                parameters of type <em>function</em> that would themselves have parameters. Let&#39;s
                consider <em>map</em>,
            </p>

            <pre>int numbers[5] = [1, 2, 3, 4, 5];
int squared_numbers[5] = map(2 * x, numbers);
/* newlist == [2, 4, 6, 8, 10] */ </pre>

            <p>
                Map is a function that accepts two parameters, a function and an array (of ints,
                in our case). The result of calling this function is a new list where each
                element is replaced with the result of the function applied to the old
                element. <em>2 * x</em> is a function of one parameter <em>x</em>, that doubles the value of
                its parameter.
            </p>

            <p>
                We&#39;ve said above that using the C&#39;s &#34;function to pointer&#34; type is rather limited
                in its ability. Besides the fact that we would need endless functions defined
                before their use, what if we have code to double all the elements of our list
                using an extra local variable,
            </p>

            <pre>int d = 2;
int numbers[5] = [1, 2, 3, 4, 5];
int squared_numbers[5] = map(d * x, numbers);
/* newlist == [1, 4, 6, 8, 10] */ </pre>

            <p>
                But <em>d</em> would not be defined in our &#34;function pointer&#34; parameter and we cannot
                achieve what we want. What we want is a <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closure</a>, a much powerful construct
                directly related to the ability of building functions at run-time, which is
                again not offered by C.
            </p>

            <p>
                So the correct call to our <em>map</em> function would include creating a function at
                runtime, a function that would define what are its bound variables, that is, it
                would have to know what needs to be replaced where, and it would also need the
                ability to refer to variables around it, so to speak,
            </p>

            <pre>int d = 2;
int squared_numbers[5] = map(fn(x){d * x}, numbers); </pre>

            <p>
                This, again, is not valid C code, but we&#39;re just imagining what such a feature
                could look like.
            </p>

            <h2 id="org0a3f210">Stretching things even further</h2>
            <p>
                Even though we&#39;re so deep into Lisp territory already that we barely see the C
                waters now, let&#39;s have a mind stretch and think about other possibilities,
                maintaining, as much as we can, a semblance of C code.
            </p>

            <pre>int a = 10;

loop(start=1; stop=10,                  printf(&#34;looping..\n&#34;));
loop(start=1; stop=a*10,                printf(&#34;looping..\n&#34;))
loop(start=1; stop=10; step=2; index=i, printf(&#34;looping %d..\n&#34;, i)) </pre>

            <p>
                These are all looping constructs evaluating the second parameter a given number
                of times, based on the first parameter. The first parameter is an expression
                where we are allowing some keywords like <em>start</em>, <em>step</em>, etc. What is special
                here is that we would need the ability not only to add the missing pieces back
                into our &#34;unsaturated&#34; function, as we did initially, but we would also need the
                ability to parse those parameters, to extract relevant info from them and
                possibly to include part of them in other places (see <em>i</em>, for example). We&#39;ve
                seen this in the <em>for</em> example, where the first parameter contains an
                initialization of a variable that we need to use subsequently in the other
                parameters. What we need, in short, that we again don&#39;t posses? For the ability
                of the C language to parse itself.
            </p>

            <h2>Conclusion</h2>
            <p>
                So C lacks any means to actually handle and manipulate code within the C
                language itself, as we saw in the last example. Secondly, it does not have
                functions as objects in their own right that we can handle, manipulate, pass to
                functions, create and destroy at run-time. Thirdly, it does not offer a way of
                avoiding the passing by value of its parameters. That would help us, in special
                cases, to have a chance to take a look at those parameters, avoid evaluating
                some of them or evaluating others multiple times, transforming them, and come
                up, eventually, with new language constructs that the original language
                designers have not provided us or that are so specific to our use-case that
                nobody could have come up with such abstractions but us.
            </p>

            <p>
                All these dead-ends and design choices that do not play well with each another
                and limit the language extensibility add up. What we&#39;re left with are just some
                limited forms of abstractions. After a while, we hit a wall and we wished we
                could express something the language has no way of expressing.
            </p>

            <p>
                If you are thinking that you don&#39;t need this ability to implement new
                functionality, stop and think what the language already offers in the case of
                the <em>if</em> statement, for example. For a clearer view, consider it as a function,
                as we did above. What you are passing to this <em>if</em> function now are really
                expressions. Expressions that do not all of them get evaluated, meaning, the
                language you are using has a means of avoiding evaluation of the function call
                and selecting which expression to evaluate at a later time. But you do not have
                the power to create such a function. Why not? Better to take a walk in the fresh
                air.
            </p>

            <p>
                © Mihai Olteanu, 2021
            </p>
        </div></div>
  </body>
</html>
