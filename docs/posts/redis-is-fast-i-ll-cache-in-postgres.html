<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dizzy.zone/2025/09/24/Redis-is-fast-Ill-cache-in-Postgres/">Original</a>
    <h1>Redis is fast – I&#39;ll cache in Postgres</h1>
    
    <div id="readability-page-1" class="page"><div><p>There are <a href="https://www.manning.com/books/just-use-postgres">books</a> &amp; many articles online, like <a href="https://www.amazingcto.com/postgres-for-everything/">this one</a> arguing for using Postgres for everything. I thought I’d take a look at one use case - using Postgres instead of Redis for caching. I work with APIs quite a bit, so I’d build a super simple HTTP server that responds with data from that cache. I’d start from Redis as this is something I frequently encounter at work, switch it out to Postgres using unlogged tables and see if there’s a difference.</p>
<h2 id="the-setup">The setup</h2>
<p>I’ll run the experiment on my <a href="https://dizzy.zone/2025/03/10/State-of-my-Homelab-2025/">homelab’s</a> k8s cluster. The idea is to run Postgres or Redis on one node, limiting it to 2CPUs via k8s limits, as well as 8GiB of memory. On another node, I’ll run the web server itself and then spin a pod for the benchmark executed via <a href="https://k6.io/">k6</a> on the third.</p>
<p>Both postgres and redis are used with the out of the box settings for the following images:</p>
<ul>
<li>Postgres - <code>postgres:17.6</code></li>
<li>Redis - <code>redis:8.2</code></li>
</ul>
<p>I wrote a simple webserver, with 2 endpoints, a cache and a “Session” struct which we’ll store in the cache:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>ErrCacheMiss</span> = <span>errors</span>.<span>New</span>(<span>&#34;cache miss&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Cache</span> <span>interface</span> {
</span></span><span><span>	<span>Get</span>(<span>ctx</span> <span>context</span>.<span>Context</span>, <span>key</span> <span>string</span>) (<span>string</span>, <span>error</span>)
</span></span><span><span>	<span>Set</span>(<span>ctx</span> <span>context</span>.<span>Context</span>, <span>key</span> <span>string</span>, <span>value</span> <span>string</span>) <span>error</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Session</span> <span>struct</span> {
</span></span><span><span>	<span>ID</span> <span>string</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>serveHTTP</span>(<span>c</span> <span>Cache</span>) {
</span></span><span><span>	<span>http</span>.<span>HandleFunc</span>(<span>&#34;/get&#34;</span>, <span>getHandler</span>(<span>c</span>))
</span></span><span><span>	<span>http</span>.<span>HandleFunc</span>(<span>&#34;/set&#34;</span>, <span>setHandler</span>(<span>c</span>))
</span></span><span><span>
</span></span><span><span>	<span>port</span> <span>:=</span> <span>os</span>.<span>Getenv</span>(<span>&#34;PORT&#34;</span>)
</span></span><span><span>	<span>if</span> <span>port</span> <span>==</span> <span>&#34;&#34;</span> {
</span></span><span><span>		<span>port</span> = <span>&#34;8080&#34;</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>&#34;Server starting on http://0.0.0.0:&#34;</span> <span>+</span> <span>port</span>)
</span></span><span><span>
</span></span><span><span>	<span>server</span> <span>:=</span> <span>&amp;</span><span>http</span>.<span>Server</span>{<span>Addr</span>: <span>&#34;0.0.0.0:&#34;</span> <span>+</span> <span>port</span>}
</span></span><span><span>
</span></span><span><span>	<span>go</span> <span>func</span>() {
</span></span><span><span>		<span>if</span> <span>err</span> <span>:=</span> <span>server</span>.<span>ListenAndServe</span>(); <span>err</span> <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> <span>err</span> <span>!=</span> <span>http</span>.<span>ErrServerClosed</span> {
</span></span><span><span>			<span>fmt</span>.<span>Println</span>(<span>&#34;Error starting server:&#34;</span>, <span>err</span>)
</span></span><span><span>		}
</span></span><span><span>	}()
</span></span><span><span>
</span></span><span><span>	<span>quit</span> <span>:=</span> make(<span>chan</span> <span>os</span>.<span>Signal</span>, <span>1</span>)
</span></span><span><span>	<span>signal</span>.<span>Notify</span>(<span>quit</span>, <span>os</span>.<span>Interrupt</span>)
</span></span><span><span>	<span>&lt;-</span><span>quit</span>
</span></span><span><span>
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>&#34;Shutting down server...&#34;</span>)
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>:=</span> <span>server</span>.<span>Close</span>(); <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>fmt</span>.<span>Println</span>(<span>&#34;Error shutting down server:&#34;</span>, <span>err</span>)
</span></span><span><span>	}
</span></span><span><span>}</span></span></code></pre></div>
<p>For redis, I’ve implemented the cache using <code>github.com/redis/go-redis/v9</code> as follows:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>RedisCache</span> <span>struct</span> {
</span></span><span><span>	<span>client</span> <span>*</span><span>redis</span>.<span>Client</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>NewRedisCache</span>() <span>*</span><span>RedisCache</span> {
</span></span><span><span>	<span>redisURL</span> <span>:=</span> <span>os</span>.<span>Getenv</span>(<span>&#34;REDIS_URL&#34;</span>)
</span></span><span><span>	<span>if</span> <span>redisURL</span> <span>==</span> <span>&#34;&#34;</span> {
</span></span><span><span>		<span>redisURL</span> = <span>&#34;localhost:6379&#34;</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>&#34;Connecting to Redis at&#34;</span>, <span>redisURL</span>)
</span></span><span><span>
</span></span><span><span>	<span>client</span> <span>:=</span> <span>redis</span>.<span>NewClient</span>(<span>&amp;</span><span>redis</span>.<span>Options</span>{
</span></span><span><span>		<span>Addr</span>:     <span>redisURL</span>,
</span></span><span><span>		<span>Password</span>: <span>&#34;&#34;</span>,
</span></span><span><span>		<span>DB</span>:       <span>0</span>,
</span></span><span><span>	})
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>&amp;</span><span>RedisCache</span>{
</span></span><span><span>		<span>client</span>: <span>client</span>,
</span></span><span><span>	}
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>r</span> <span>*</span><span>RedisCache</span>) <span>Get</span>(<span>ctx</span> <span>context</span>.<span>Context</span>, <span>key</span> <span>string</span>) (<span>string</span>, <span>error</span>) {
</span></span><span><span>	<span>val</span>, <span>err</span> <span>:=</span> <span>r</span>.<span>client</span>.<span>Get</span>(<span>ctx</span>, <span>key</span>).<span>Result</span>()
</span></span><span><span>	<span>if</span> <span>err</span> <span>==</span> <span>redis</span>.<span>Nil</span> {
</span></span><span><span>		<span>return</span> <span>&#34;&#34;</span>, <span>ErrCacheMiss</span>
</span></span><span><span>	}
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> <span>&#34;&#34;</span>, <span>err</span>
</span></span><span><span>	}
</span></span><span><span>	<span>return</span> <span>val</span>, <span>nil</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>r</span> <span>*</span><span>RedisCache</span>) <span>Set</span>(<span>ctx</span> <span>context</span>.<span>Context</span>, <span>key</span> <span>string</span>, <span>value</span> <span>string</span>) <span>error</span> {
</span></span><span><span>	<span>return</span> <span>r</span>.<span>client</span>.<span>Set</span>(<span>ctx</span>, <span>key</span>, <span>value</span>, <span>0</span>).<span>Err</span>()
</span></span><span><span>}</span></span></code></pre></div>
<p>The postgres cache is implemented using the <code>github.com/jackc/pgx/v5</code> library:
</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>PostgresCache</span> <span>struct</span> {
</span></span><span><span>	<span>db</span> <span>*</span><span>pgxpool</span>.<span>Pool</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>NewPostgresCache</span>() (<span>*</span><span>PostgresCache</span>, <span>error</span>) {
</span></span><span><span>	<span>pgDSN</span> <span>:=</span> <span>os</span>.<span>Getenv</span>(<span>&#34;POSTGRES_DSN&#34;</span>)
</span></span><span><span>	<span>if</span> <span>pgDSN</span> <span>==</span> <span>&#34;&#34;</span> {
</span></span><span><span>		<span>pgDSN</span> = <span>&#34;postgres://user:password@localhost:5432/mydb&#34;</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>cfg</span>, <span>err</span> <span>:=</span> <span>pgxpool</span>.<span>ParseConfig</span>(<span>pgDSN</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> <span>nil</span>, <span>err</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>cfg</span>.<span>MaxConns</span> = <span>50</span>
</span></span><span><span>	<span>cfg</span>.<span>MinConns</span> = <span>10</span>
</span></span><span><span>
</span></span><span><span>	<span>pool</span>, <span>err</span> <span>:=</span> <span>pgxpool</span>.<span>NewWithConfig</span>(<span>context</span>.<span>Background</span>(), <span>cfg</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> <span>nil</span>, <span>err</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>_</span>, <span>err</span> = <span>pool</span>.<span>Exec</span>(<span>context</span>.<span>Background</span>(), <span>`
</span></span></span><span><span><span>		CREATE UNLOGGED TABLE IF NOT EXISTS cache (
</span></span></span><span><span><span>			key VARCHAR(255) PRIMARY KEY,
</span></span></span><span><span><span>			value TEXT
</span></span></span><span><span><span>		);
</span></span></span><span><span><span>	`</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> <span>nil</span>, <span>err</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>&amp;</span><span>PostgresCache</span>{
</span></span><span><span>		<span>db</span>: <span>pool</span>,
</span></span><span><span>	}, <span>nil</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>p</span> <span>*</span><span>PostgresCache</span>) <span>Get</span>(<span>ctx</span> <span>context</span>.<span>Context</span>, <span>key</span> <span>string</span>) (<span>string</span>, <span>error</span>) {
</span></span><span><span>	<span>var</span> <span>content</span> <span>string</span>
</span></span><span><span>	<span>err</span> <span>:=</span> <span>p</span>.<span>db</span>.<span>QueryRow</span>(<span>ctx</span>, <span>`SELECT value FROM cache WHERE key = $1`</span>, <span>key</span>).<span>Scan</span>(<span>&amp;</span><span>content</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>==</span> <span>pgx</span>.<span>ErrNoRows</span> {
</span></span><span><span>		<span>return</span> <span>&#34;&#34;</span>, <span>ErrCacheMiss</span>
</span></span><span><span>	}
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> <span>&#34;&#34;</span>, <span>err</span>
</span></span><span><span>	}
</span></span><span><span>	<span>return</span> <span>content</span>, <span>nil</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>p</span> <span>*</span><span>PostgresCache</span>) <span>Set</span>(<span>ctx</span> <span>context</span>.<span>Context</span>, <span>key</span> <span>string</span>, <span>value</span> <span>string</span>) <span>error</span> {
</span></span><span><span>	<span>_</span>, <span>err</span> <span>:=</span> <span>p</span>.<span>db</span>.<span>Exec</span>(<span>ctx</span>, <span>`INSERT INTO cache (key, value) VALUES ($1, $2) ON CONFLICT (key) DO UPDATE SET value = $2`</span>, <span>key</span>, <span>value</span>)
</span></span><span><span>	<span>return</span> <span>err</span>
</span></span><span><span>}</span></span></code></pre></div>
<p>I’ll seed the redis and postgres with 30 million entries each, keeping record of the inserted uuids. From there, I’ll generate a subset of existing uuids to use while benchmarking. This allows for simulating both hits and misses.</p>
<p>I’ll do a few runs of benchmarks for gets first, then sets and then a mixed run. Each run will execute for 2 minutes. I’ll look at the number of operations per second, latencies as well as memory and CPU usage during those times.</p>
<p>To simulate a somewhat real scenario where only a subset of keys exist in the cache the set benchmark will have a 10% chance to update an existing key, whereas the get will have an 80% chance of picking an existing key. The mixed workload will have a 20% chance to execute a set scenario and 80% for the get scenario.</p>
<h2 id="the-results">The results</h2>
<h3 id="getting-values-from-cache">Getting values from cache</h3>
















<p>
    
        Requests per second – higher is better
    
</p>






<p>Redis performed better than Postgres, which did not surprise me at all. The bottleneck was actually the HTTP server. The machine running the http server maxed out on CPU, with redis running comfortably with ~1280mCPU - short of the 2000mCPU limit imposed. Redis used ~3800MiB of RAM, which stayed flat across the runs.</p>
<p>For postgres, the bottleneck was the CPU on postgres side. It consistently maxed out the 2 cores dedicated to it, while also using ~5000MiB of RAM.</p>
<p>Redis also did better when it comes to latencies of the HTTP responses:</p>
















<p>
    
        Latency, milliseconds – lower is better
    
</p>






<h3 id="setting-values-in-cache">Setting values in cache</h3>
















<p>
    
        Requests per second – higher is better
    
</p>






<p>Once again Redis performed better. The CPU usage stayed roughly the same as in the case of the GET experiment, with the RAM usage growing to ~4300MiB due to the new keys being inserted. The bottleneck stayed on the HTTP server side, with Redis using ~1280mCPU once again.</p>
<p>Postgres once again was bottlenecked by the CPU, constantly using 100% of the 2 cores it was limited to. During the course of the run, the memory usage grew to ~5500MiB.</p>
<p>During the test, the endpoints with the Redis cache implementation also had better latencies:</p>
















<p>
    
        Latency, milliseconds – lower is better
    
</p>






<h3 id="readwrite-performance">Read/write performance</h3>
















<p>
    
        Requests per second – higher is better
    
</p>






<p>The mixed benchmark also returned the predictable result of Redis reigning superior. As has been the story so far, the CPU stayed put at ~1280mCPU, RAM usage grew a bit due to the new keys being inserted.</p>
<p>Postgres maxed out the two cores and reached around 6GiB of memory used.</p>
<p>Latencies once again were better when using redis:</p>
















<p>
    
        Latency, milliseconds – lower is better
    
</p>






<h3 id="unlogged-tables">Unlogged tables</h3>
<p>In the benchmark, I’ve used an unlogged table for postgres but this has not seemed to help, or has it? If I rerun the same benchmark with a normal(logged) table we can look at the numbers.</p>
















<p>
    
        Requests per second – higher is better
    
</p>






<p>The unlogged table makes a huge difference for the write benchmark and a somewhat smaller but still significant one for the mixed workload. This is because the unlogged tables skip the write ahead log making them a lot faster for writes. There’s very little difference for the read performance though and I expect more runs would show the two test cases converging.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Redis is faster than postgres when it comes to caching, there’s no doubt about it. It conveniently comes with a bunch of other useful functionality that one would expect from a cache, such as TTLs. It was also bottlenecked by the hardware, my service or a combination of both and could definitely show better numbers. Surely, we should all use Redis for our caching needs then, right? Well, I think I’ll still use postgres. Almost always, my projects need a database. Not having to add another dependency comes with its own benefits. If I need my keys to expire, I’ll add a column for it, and a cron job to remove those keys from the table. As far as speed goes - 7425 requests per second is still a lot. That’s more than half a billion requests per day. All on hardware that’s 10 years old and using laptop CPUs. Not many projects will reach this scale and if they do I can just upgrade the postgres instance or if need be spin up a redis then. Having an interface for your cache so you can easily switch out the underlying store is definitely something I’ll keep doing exactly for this purpose.</p>
<p>Thanks for reading!</p>


  </div></div>
  </body>
</html>
