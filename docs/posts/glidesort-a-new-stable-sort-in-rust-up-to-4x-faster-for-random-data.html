<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/orlp/glidesort">Original</a>
    <h1>Show HN: Glidesort, a new stable sort in Rust up to ~4x faster for random data</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Glidesort is a novel stable sorting algorithm that combines the best-case behavior
of Timsort-style merge sorts for pre-sorted data with the best-case behavior of
<a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> for data with many duplicates.
It is a comparison-based sort supporting arbitrary comparison operators,
and while exceptional on data with patterns it is also very fast for random data.</p>
<p dir="auto">For sorting <code>n</code> elements with <code>k</code> distinct values glidesort has the following
characteristics by default:</p>
<div data-snippet-clipboard-copy-content="Best    Average     Worst       Memory      Stable      Deterministic
n       n log k     n log n     n / 8       Yes         Yes"><pre><code>Best    Average     Worst       Memory      Stable      Deterministic
n       n log k     n log n     n / 8       Yes         Yes
</code></pre></div>
<p dir="auto">Glidesort can use as much (up to <code>n</code>) or as little extra memory as you want. If
given only <code>O(1)</code> memory the average and worst case become <code>O(n (log n)^2)</code>, however
in practice its performance is great for all but the most skewed data size /
auxiliary space ratios. The default is to allocate up to <code>n</code> elements worth of
data, unless this exceeds 1 MiB, in which case we scale this down to <code>n / 2</code>
elements worth of data up until 1 GiB after which glidesort uses <code>n / 8</code> memory.</p>

<p dir="auto">Performance varies a lot from machine to machine and dataset to dataset, so your
mileage will vary. Nevertheless, an example benchmark from a 2021 Apple M1
machine comparing against <code>[T]::sort</code> and <code>[T]::sort_unstable</code> for various input
distributions of <code>u64</code>:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e3c6b4d99e3330f4eeb274af9c37fe70a15d36a5fc26982b6e965a211672325a/68747470733a2f2f692e696d6775722e636f6d2f386649414371592e706e67"><img src="https://camo.githubusercontent.com/e3c6b4d99e3330f4eeb274af9c37fe70a15d36a5fc26982b6e965a211672325a/68747470733a2f2f692e696d6775722e636f6d2f386649414371592e706e67" alt="Performance graph" data-canonical-src="https://i.imgur.com/8fIACqY.png"/></a></p>
<p dir="auto">Compiled with <code>rustc 1.69.0-nightly (11d96b593)</code> using <code>--release --features unstable</code> and <code>lto = &#34;thin&#34;</code>.</p>

<p dir="auto">Use <code>cargo add glidesort</code> and replace <code>a.sort()</code> with <code>glidesort::sort(&amp;mut a)</code>.
A similar process works for <code>sort_by</code> and <code>sort_by_key</code>.</p>
<p dir="auto">Glidesort exposes two more families of sorting functions.
<code>glidesort::sort_with_buffer(&amp;mut a, buf)</code> asks you to pass a <code>&amp;mut [MaybeUninit&lt;T&gt;]</code> buffer which it will then (exclusively) use as auxiliary space
to sort the elements. <code>glidesort::sort_in_vec(&amp;mut v)</code> behaves like normal
glidesort but will allocate its auxiliary space at the end of the passed <code>Vec&lt;T&gt;</code>.
This allows future sorting calls to re-use the same space and reduce allocations.
Both these families also support the <code>_by</code> and <code>_by_key</code> interface.</p>

<p dir="auto">This visualization focuses on demonstrating the advanced merging techniques in glidesort:</p>
<details open="">
  <summary>
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M16 3.75a.75.75 0 00-1.136-.643L11 5.425V4.75A1.75 1.75 0 009.25 3h-7.5A1.75 1.75 0 000 4.75v6.5C0 12.216.784 13 1.75 13h7.5A1.75 1.75 0 0011 11.25v-.675l3.864 2.318A.75.75 0 0016 12.25v-8.5zm-5 5.075l3.5 2.1v-5.85l-3.5 2.1v1.65zM9.5 6.75v-2a.25.25 0 00-.25-.25h-7.5a.25.25 0 00-.25.25v6.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-4.5z"></path>
</svg>
    <span aria-label="Video description glidesort_merge_example.mp4">glidesort_merge_example.mp4</span>
    <span></span>
  </summary>

  <video src="https://user-images.githubusercontent.com/202547/216675278-e4c8f15c-e42d-4224-b8c7-fdc67fdc2bde.mp4" data-canonical-src="https://user-images.githubusercontent.com/202547/216675278-e4c8f15c-e42d-4224-b8c7-fdc67fdc2bde.mp4" controls="controls" muted="muted">

  </video>
</details>

<p dir="auto">This visualization shows how glidesort is adaptive to both pre-existing runs as well
as many duplicates together:</p>
<details open="">
  <summary>
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M16 3.75a.75.75 0 00-1.136-.643L11 5.425V4.75A1.75 1.75 0 009.25 3h-7.5A1.75 1.75 0 000 4.75v6.5C0 12.216.784 13 1.75 13h7.5A1.75 1.75 0 0011 11.25v-.675l3.864 2.318A.75.75 0 0016 12.25v-8.5zm-5 5.075l3.5 2.1v-5.85l-3.5 2.1v1.65zM9.5 6.75v-2a.25.25 0 00-.25-.25h-7.5a.25.25 0 00-.25.25v6.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-4.5z"></path>
</svg>
    <span aria-label="Video description glidesort_adaptiveness_example.mp4">glidesort_adaptiveness_example.mp4</span>
    <span></span>
  </summary>

  <video src="https://user-images.githubusercontent.com/202547/216675274-6e61689f-a120-4b7c-b1a7-9b5aa5fd013e.mp4" data-canonical-src="https://user-images.githubusercontent.com/202547/216675274-6e61689f-a120-4b7c-b1a7-9b5aa5fd013e.mp4" controls="controls" muted="muted">

  </video>
</details>

<p dir="auto">Note that both visualizations have different small sorting thresholds and
auxiliary memory parameters to show the techniques in action on a smaller scale.</p>

<p dir="auto">Glidesort uses a novel main loop based on powersort. Powersort is similar to
Timsort, using heuristics to find a good order of stably merging sorted runs.
Like powersort it does a linear scan over the input, recognizing any ascending
or strictly descending sequences. However, unlike powersort it does not eagerly
sort sequences that are considered unordered into small sorted blocks. Instead
it processes them as-is, unsorted. This process produces <em>logical runs</em>, which
may be sorted or unsorted.</p>
<p dir="auto">Glidesort repeatedly uses a <em>logical</em> merge operation on these logical runs, as
powersort would. In a logical merge unsorted runs are simply concatenated into
larger unsorted runs. Sorted runs are also concatenated into <em>double sorted</em>
runs. Only when merging a sorted and unsorted run finally the unsorted run is
sorted using stable quicksort, and when merging double sorted runs glidesort
uses interleaved ping-pong merges.</p>
<p dir="auto">Using this novel hybrid approach glidesort can take advantage of arbitrary
sorted runs in the data as well as process data with many duplicate items faster
similar to pattern-defeating quicksort.</p>

<p dir="auto">Glidesort merges multiple sorted runs at the same time, and interleaves their
merging loops for better memory-level parallelism and hiding data dependencies.
This also allows it to use ping-pong merging avoiding unnecessary <code>memcpy</code> calls
by using the implicit copy you get from an out-of-place merge. The merging loops
are completely branchless, making it fast for random data as well.</p>
<p dir="auto">Glidesort uses binary searches to split up large merge operations into smaller
merge operations that it performs at the same time using instruction-level
parallelism. This splitting procedure also allows glidesort to use arbitrarily
small amounts of memory, as it can choose to split a merge repeatedly until it
fits in our scratch space to process.</p>

<p dir="auto">Yes, stable quicksort. Wikipedia will outright tell you that quicksort is
unstable, or at least all efficient implementations are. That simply isn&#39;t true,
all it needs is auxiliary memory. Credit to Igor van den Hoven&#39;s
<a href="https://github.com/scandum/fluxsort">fluxsort</a> for demonstrating that stable
quicksort can be efficient in practice.</p>
<p dir="auto">Glidesort uses a novel bidirectional stable partitioning method that interleaves
a left-to-right partition scan with a right-to-left partition scan for greater
memory-level parallelism and hiding data dependencies. Partitioning is done
entirely branchlessly (if the comparison operator is), giving consistent
performance on all data.</p>

<p dir="auto">Glidesort is dual-licensed under the Apache License, Version 2.0 and the MIT license.</p>
</article>
          </div></div>
  </body>
</html>
