<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notes.eatonphil.com/2023-11-01-postgres-table-access-methods.html">Original</a>
    <h1>Writing a storage engine for Postgres: An in-memory table access method (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p>With <a href="https://www.postgresql.org/docs/release/12.0/">Postgres 12</a>,
released in 2019, it became possible to <a href="https://www.pgcon.org/2019/schedule/attachments/536_pgcon2019_pluggable_table_AM_V1.3.pdf">swap out Postgres&#39;s storage
engine</a>.</p>
<p>This is a feature MySQL has supported for a long time. There are at
least <a href="https://github.com/eatonphil/pgtam">8 different</a> <em>built-in</em>
engines you can pick from. <a href="https://myrocks.io/">MyRocks</a>, MySQL on
RocksDB, is another popular third-party distribution.</p>
<p>I assume there will be a renaissance of Postgres storage engines. To
date, the efforts are
nascent. <a href="https://github.com/orioledb/orioledb">OrioleDB</a> and <a href="https://github.com/citusdata/citus/blob/main/src/backend/columnar/README.md">Citus
Columnar</a>
are two promising third-party table access methods being actively
developed.</p>
<h3 id="why-alternative-storage-engines?">Why alternative storage engines?</h3><p>The ability to swap storage engines is useful because different
workloads sometimes benefit from different storage
approaches. Analytics workloads and columnar storage layouts <a href="https://docs.aws.amazon.com/redshift/latest/dg/c_columnar_storage_disk_mem_mgmnt.html">go well
together</a>. Write-heavy
workloads and LSM trees <a href="https://github.com/wiredtiger/wiredtiger/wiki/Btree-vs-LSM">go well
together</a>. And
some people like in-memory storage for running integration tests.</p>
<p>By swapping out only the storage engine, you get the benefit of the
rest of the Postgres or MySQL infrastructure. The query language, the
wire protocol, the ecosystem, etc.</p>
<h3 id="why-not-foreign-data-wrappers?">Why not foreign data wrappers?</h3><p>Very little has been written about the difference between foreign data
wrappers (FDWs) and table access methods. Table access methods seems
to be the lower-level layer where presumably you get better
performance and cleaner integration. But there is clearly overlap
between these two extension options.</p>
<p>For example there is a <a href="https://github.com/ildus/clickhouse_fdw">FDW for
ClickHouse</a> so when you
create tables and rows and query the tables you are really creating
and querying rows in a ClickHouse server. Similarly there&#39;s a <a href="https://github.com/vidardb/pgrocks-fdw">FDW for
RocksDB</a>. And Citus&#39;s columnar
engine works
<a href="https://www.citusdata.com/blog/2021/03/06/citus-10-columnar-compression-for-postgres/#:~:text=What%20About%20cstore_fdw%3F">either</a>
as a foreign data wrapper or a table access method.</p>
<p>The Citus page draws the clearest distinction between FDWs and table
access methods, but even that page is vague. Performance doesn&#39;t seem
to be the main difference. Closer integration, and thus the ability to
look more like vanilla Postgres from the outside, seems to be the
gist.</p>
<p>In any case, I wanted to explore the table access method API.</p>
<h3 id="digging-in">Digging in</h3><p>I haven&#39;t written Postgres extensions before and I&#39;ve never written C
professionally. If you&#39;re familiar with Postgres internals or C and
notice something funky, please <a href="mailto:me@eatonphil.com">let me know</a>!</p>
<p>It turns out that almost no one has written how to implement the
minimal table access methods for various storage engine operations. So
after quite a bit of stumbling to get the basics of an in-memory
storage engine working, I&#39;m going to walk you through my approach.</p>
<p>This is prototype-quality code which hopefully will be a useful base
for further exploration.</p>
<p>All code for this post is <a href="https://github.com/eatonphil/pgtam">available on
GitHub</a>.</p>
<h3 id="a-debug-postgres-build">A debug Postgres build</h3><p>First off, let&#39;s make a <a href="https://wiki.postgresql.org/wiki/Developer_FAQ#Compile-time">debug
build</a> of
Postgres.</p>
<div><pre><span></span><span>$</span><span> </span><span>git</span><span> </span><span>clone</span><span> </span><span>https</span><span>://</span><span>github</span><span>.</span><span>com</span><span>/</span><span>postgres</span><span>/</span><span>postgres</span>
<span>$</span><span> </span><span># An arbitrary commit from `master` after Postgres 16 I am on</span>
<span>$</span><span> </span><span>git</span><span> </span><span>checkout</span><span> </span><span>849172ff4883d44168f96f39d3fde96d0aa34c99</span>
<span>$</span><span> </span><span>cd</span><span> </span><span>postgres</span>
<span>$</span><span> </span><span>.</span><span>/</span><span>configure</span><span> </span><span>--</span><span>enable</span><span>-</span><span>cassert</span><span> </span><span>--</span><span>enable</span><span>-</span><span>debug</span><span> </span><span>CFLAGS</span><span>=</span><span>&#34;-ggdb -Og -g3 -fno-omit-frame-pointer&#34;</span>
<span>$</span><span> </span><span>make</span><span> </span><span>-</span><span>j8</span>
<span>$</span><span> </span><span>sudo</span><span> </span><span>make</span><span> </span><span>install</span>
</pre></div>
<p>This will install Postgres binaries (e.g. <code>psql</code>, <code>pg_ctl</code>, <code>initdb</code>,
<code>pg_config</code>) into <code>/usr/local/pgsql/bin</code>.</p>
<p>I&#39;m going to reference those absolute paths throughout this post
because you might have a system (package manager) install of Postgres
already.</p>
<p>Let&#39;s create a database and start up this debug build:</p>
<div><pre><span></span><span>$ </span>/usr/local/pgsql/bin/initdb<span> </span>test-db
<span>$ </span>/usr/local/pgsql/bin/pg_ctl<span> </span>-D<span> </span>test-db<span> </span>-l<span> </span>logfile<span> </span>start
</pre></div>
<h3 id="extension-infrastructure">Extension infrastructure</h3><p>Since we installed Postgres from scratch,
<code>/usr/local/pgsql/bin/pg_config</code> will supply all of the infrastructure
we need.</p>
<p>The &#34;infrastructure&#34; is basically just
<a href="https://www.postgresql.org/docs/current/extend-pgxs.html">PGXS</a>:
Postgres Makefile utilities.</p>
<p>It&#39;s convention-heavy. So in a new <code>Makefile</code> for this project we&#39;ll
specify:</p>
<ol>
<li><code>MODULES</code>: Any C sources to build, without the <code>.c</code> file extension</li>
<li><code>EXTENSION</code>: Extension metadata file, without the <code>.control</code> file extension</li>
<li><code>DATA</code>: A SQL file that is executed when the extension is loaded, this time with the <code>.sql</code> extension</li>
</ol>
<div><pre><span></span><span>MODULES</span><span> </span><span>=</span><span> </span>pgtam
<span>EXTENSION</span><span> </span><span>=</span><span> </span>pgtam
<span>DATA</span><span> </span><span>=</span><span> </span>pgtam--0.0.1.sql

<span>PG_CONFIG</span><span> </span><span>=</span><span> </span>/usr/local/pgsql/bin/pg_config
<span>PGXS</span><span> </span><span>:=</span><span> </span><span>$(</span>shell<span> </span><span>$(</span>PG_CONFIG<span>)</span><span> </span>--pgxs<span>)</span>
<span>include $(PGXS)</span>
</pre></div>
<p>The final three lines set up the PGXS Makefile library based on the
particular installed Postgres build we want to build the extension
against and install the extension to.</p>
<p>PGXS gives us a few important targets like <code>make distclean</code>, <code>make</code>,
and <code>make install</code> we&#39;ll use later on.</p>
<h4 id="&lt;code&gt;pgtam.c&lt;/code&gt;"><code>pgtam.c</code></h4><p>A minimal C file that registers a function capable of serving as a
table access method is:</p>
<div><pre><span></span><span>#include</span><span> </span><span>&#34;postgres.h&#34;</span>
<span>#include</span><span> </span><span>&#34;fmgr.h&#34;</span>
<span>#include</span><span> </span><span>&#34;access/tableam.h&#34;</span>

<span>PG_MODULE_MAGIC</span><span>;</span>

<span>const</span><span> </span><span>TableAmRoutine</span><span> </span><span>memam_methods</span><span> </span><span>=</span><span> </span><span>{</span>
<span>  </span><span>.</span><span>type</span><span> </span><span>=</span><span> </span><span>T_TableAmRoutine</span><span>,</span>
<span>};</span>

<span>PG_FUNCTION_INFO_V1</span><span>(</span><span>mem_tableam_handler</span><span>);</span>
<span>Datum</span><span> </span><span>mem_tableam_handler</span><span>(</span><span>PG_FUNCTION_ARGS</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>PG_RETURN_POINTER</span><span>(</span><span>&amp;</span><span>memam_methods</span><span>);</span>
<span>}</span>
</pre></div>
<p>
  If you want to read about extension basics without the complexity of
  table access methods, you can find a complete, minimal Postgres
  extension I wrote to validate the
  infrastructure <a href="https://github.com/eatonphil/pgext-101">here</a>. Or
  you can follow a
  <a href="https://github.com/IshaanAdarsh/Postgres-extension-tutorial/blob/main/SGML/intro_and_toc.md">larger
    tutorial</a>.
</p><p>The workflow for registering a table access method is to first run
<code>CREATE EXTENSION pgtam</code>. This assumes <code>pgtam</code> is an extension that
has a function that returns a <code>TableAmRoutine</code> struct instance, a
table of table access methods.</p>
<p>Then you must run <code>CREATE ACCESS METHOD mem TYPE TABLE HANDLER
mem_tableam_handler</code>. And finally you can use the access method when
creating a table with <code>USING mem</code>: <code>CREATE TABLE x(a INT) USING mem</code>.</p>
<h4 id="&lt;code&gt;pgtam.control&lt;/code&gt;"><code>pgtam.control</code></h4><p>This file contains extension metadata. At a minimum, the version of
the extension and the filename for the extension where it should be
installed.</p>
<div><pre><span></span>default_version = &#39;0.0.1&#39;
module_pathname = &#39;$libdir/pgtam&#39;
</pre></div>
<h4 id="&lt;code&gt;pgtam--0.0.1.sql&lt;/code&gt;"><code>pgtam--0.0.1.sql</code></h4><p>Finally, in <code>pgtam--0.0.1.sql</code> (which is executed when we call <code>CREATE
EXTENSION pgtam</code>), we register the handler function as a foreign
function, and then we register the function as an access method.</p>
<div><pre><span></span><span>CREATE</span><span> </span><span>OR</span><span> </span><span>REPLACE</span><span> </span><span>FUNCTION</span><span> </span><span>mem_tableam_handler</span><span>(</span><span>internal</span><span>)</span>
<span>RETURNS</span><span> </span><span>table_am_handler</span><span> </span><span>AS</span><span> </span><span>&#39;pgtam&#39;</span><span>,</span><span> </span><span>&#39;mem_tableam_handler&#39;</span>
<span>LANGUAGE</span><span> </span><span>C</span><span> </span><span>STRICT</span><span>;</span>

<span>CREATE</span><span> </span><span>ACCESS</span><span> </span><span>METHOD</span><span> </span><span>mem</span><span> </span><span>TYPE</span><span> </span><span>TABLE</span><span> </span><span>HANDLER</span><span> </span><span>mem_tableam_handler</span><span>;</span>
</pre></div>
<h4 id="build">Build</h4><p>Now that we&#39;ve got all the pieces in place, we can build and install
the extension.</p>
<div><pre><span></span>$<span> </span>make
$<span> </span>sudo<span> </span>make<span> </span>install
</pre></div>
<p>Let&#39;s add a <code>test.sql</code> script to exercise the extension:</p>
<div><pre><span></span><span>DROP</span><span> </span><span>EXTENSION</span><span> </span><span>IF</span><span> </span><span>EXISTS</span><span> </span><span>pgtam</span><span> </span><span>CASCADE</span><span>;</span>
<span>CREATE</span><span> </span><span>EXTENSION</span><span> </span><span>pgtam</span><span>;</span>
<span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>x</span><span>(</span><span>a</span><span> </span><span>INT</span><span>)</span><span> </span><span>USING</span><span> </span><span>mem</span><span>;</span>
</pre></div>
<p>And run it:</p>
<div><pre><span></span><span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>psql:test.sql:3: server closed the connection unexpectedly</span>
<span>        This probably means the server terminated abnormally</span>
<span>        before or while processing the request.</span>
<span>psql:test.sql:3: error: connection to server was lost</span>
</pre></div>
<p>Ok, so <code>psql</code> crashed! Let&#39;s look at the server logs. When we started
Postgres with <code>pg_ctl</code> we specified the log file as <code>logfile</code> in the
directory where we ran <code>pg_ctl</code>.</p>
<p>If we look through it we&#39;ll spot an assertion failure:</p>
<div><pre><span></span><span>$ </span>grep<span> </span>Assert<span> </span>logfile
<span>TRAP: failed Assert(&#34;routine-&gt;scan_begin != NULL&#34;), File: &#34;tableamapi.c&#34;, Line: 52, PID: 2906922</span>
</pre></div>
<p>That&#39;s a great sign! This is Postgres&#39;s debug infrastructure helping
to make sure the table access method is correctly implemented.</p>
<h3 id="table-access-method-stubs">Table access method stubs</h3><p>The next step is to add function stubs for all the non-optional
methods of the <a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/include/access/tableam.h#L282"><code>TableAmRoutine</code>
struct</a>.</p>
<p>I&#39;ve done all the work for you already so you can just copy this over
the existing <code>pgtam.c</code>. It&#39;s a big file, but don&#39;t worry. There&#39;s
nothing to explain. Just a bunch of blank functions returning default
values when required.</p>
<div><pre><span></span><span>#include</span><span> </span><span>&#34;postgres.h&#34;</span>
<span>#include</span><span> </span><span>&#34;fmgr.h&#34;</span>
<span>#include</span><span> </span><span>&#34;access/tableam.h&#34;</span>
<span>#include</span><span> </span><span>&#34;access/heapam.h&#34;</span>
<span>#include</span><span> </span><span>&#34;nodes/execnodes.h&#34;</span>
<span>#include</span><span> </span><span>&#34;catalog/index.h&#34;</span>
<span>#include</span><span> </span><span>&#34;commands/vacuum.h&#34;</span>
<span>#include</span><span> </span><span>&#34;utils/builtins.h&#34;</span>
<span>#include</span><span> </span><span>&#34;executor/tuptable.h&#34;</span>

<span>PG_MODULE_MAGIC</span><span>;</span>

<span>const</span><span> </span><span>TableAmRoutine</span><span> </span><span>memam_methods</span><span>;</span>

<span>static</span><span> </span><span>const</span><span> </span><span>TupleTableSlotOps</span><span>*</span><span> </span><span>memam_slot_callbacks</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>NULL</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>TableScanDesc</span><span> </span><span>memam_beginscan</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>int</span><span> </span><span>nkeys</span><span>,</span>
<span>  </span><span>struct</span><span> </span><span>ScanKeyData</span><span> </span><span>*</span><span>key</span><span>,</span>
<span>  </span><span>ParallelTableScanDesc</span><span> </span><span>parallel_scan</span><span>,</span>
<span>  </span><span>uint32</span><span> </span><span>flags</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>NULL</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_rescan</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>sscan</span><span>,</span>
<span>  </span><span>struct</span><span> </span><span>ScanKeyData</span><span> </span><span>*</span><span>key</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>set_params</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>allow_strat</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>allow_sync</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>allow_pagemode</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_endscan</span><span>(</span><span>TableScanDesc</span><span> </span><span>sscan</span><span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_getnextslot</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>sscan</span><span>,</span>
<span>  </span><span>ScanDirection</span><span> </span><span>direction</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>IndexFetchTableData</span><span>*</span><span> </span><span>memam_index_fetch_begin</span><span>(</span><span>Relation</span><span> </span><span>rel</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>NULL</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_index_fetch_reset</span><span>(</span><span>IndexFetchTableData</span><span> </span><span>*</span><span>scan</span><span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_index_fetch_end</span><span>(</span><span>IndexFetchTableData</span><span> </span><span>*</span><span>scan</span><span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_index_fetch_tuple</span><span>(</span>
<span>  </span><span>struct</span><span> </span><span>IndexFetchTableData</span><span> </span><span>*</span><span>scan</span><span>,</span>
<span>  </span><span>ItemPointer</span><span> </span><span>tid</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>*</span><span>call_again</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>*</span><span>all_dead</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_tuple_insert</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>CommandId</span><span> </span><span>cid</span><span>,</span>
<span>  </span><span>int</span><span> </span><span>options</span><span>,</span>
<span>  </span><span>BulkInsertState</span><span> </span><span>bistate</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_tuple_insert_speculative</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>CommandId</span><span> </span><span>cid</span><span>,</span>
<span>  </span><span>int</span><span> </span><span>options</span><span>,</span>
<span>  </span><span>BulkInsertState</span><span> </span><span>bistate</span><span>,</span>
<span>  </span><span>uint32</span><span> </span><span>specToken</span><span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_tuple_complete_speculative</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>uint32</span><span> </span><span>specToken</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>succeeded</span><span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_multi_insert</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>**</span><span>slots</span><span>,</span>
<span>  </span><span>int</span><span> </span><span>ntuples</span><span>,</span>
<span>  </span><span>CommandId</span><span> </span><span>cid</span><span>,</span>
<span>  </span><span>int</span><span> </span><span>options</span><span>,</span>
<span>  </span><span>BulkInsertState</span><span> </span><span>bistate</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>TM_Result</span><span> </span><span>memam_tuple_delete</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>ItemPointer</span><span> </span><span>tid</span><span>,</span>
<span>  </span><span>CommandId</span><span> </span><span>cid</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>crosscheck</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>wait</span><span>,</span>
<span>  </span><span>TM_FailureData</span><span> </span><span>*</span><span>tmfd</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>changingPart</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>TM_Result</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>{};</span>
<span>  </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>TM_Result</span><span> </span><span>memam_tuple_update</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>ItemPointer</span><span> </span><span>otid</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>CommandId</span><span> </span><span>cid</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>crosscheck</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>wait</span><span>,</span>
<span>  </span><span>TM_FailureData</span><span> </span><span>*</span><span>tmfd</span><span>,</span>
<span>  </span><span>LockTupleMode</span><span> </span><span>*</span><span>lockmode</span><span>,</span>
<span>  </span><span>TU_UpdateIndexes</span><span> </span><span>*</span><span>update_indexes</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>TM_Result</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>{};</span>
<span>  </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>TM_Result</span><span> </span><span>memam_tuple_lock</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>ItemPointer</span><span> </span><span>tid</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>CommandId</span><span> </span><span>cid</span><span>,</span>
<span>  </span><span>LockTupleMode</span><span> </span><span>mode</span><span>,</span>
<span>  </span><span>LockWaitPolicy</span><span> </span><span>wait_policy</span><span>,</span>
<span>  </span><span>uint8</span><span> </span><span>flags</span><span>,</span>
<span>  </span><span>TM_FailureData</span><span> </span><span>*</span><span>tmfd</span><span>)</span>
<span>{</span>
<span>  </span><span>TM_Result</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>{};</span>
<span>  </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_fetch_row_version</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>ItemPointer</span><span> </span><span>tid</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_get_latest_tid</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>sscan</span><span>,</span>
<span>  </span><span>ItemPointer</span><span> </span><span>tid</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_tuple_tid_valid</span><span>(</span><span>TableScanDesc</span><span> </span><span>scan</span><span>,</span><span> </span><span>ItemPointer</span><span> </span><span>tid</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_tuple_satisfies_snapshot</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>rel</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>TransactionId</span><span> </span><span>memam_index_delete_tuples</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>rel</span><span>,</span>
<span>  </span><span>TM_IndexDeleteOp</span><span> </span><span>*</span><span>delstate</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>TransactionId</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>{};</span>
<span>  </span><span>return</span><span> </span><span>id</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_relation_set_new_filelocator</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>rel</span><span>,</span>
<span>  </span><span>const</span><span> </span><span>RelFileLocator</span><span> </span><span>*</span><span>newrlocator</span><span>,</span>
<span>  </span><span>char</span><span> </span><span>persistence</span><span>,</span>
<span>  </span><span>TransactionId</span><span> </span><span>*</span><span>freezeXid</span><span>,</span>
<span>  </span><span>MultiXactId</span><span> </span><span>*</span><span>minmulti</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_relation_nontransactional_truncate</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>rel</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_relation_copy_data</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>rel</span><span>,</span>
<span>  </span><span>const</span><span> </span><span>RelFileLocator</span><span> </span><span>*</span><span>newrlocator</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_relation_copy_for_cluster</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>OldHeap</span><span>,</span>
<span>  </span><span>Relation</span><span> </span><span>NewHeap</span><span>,</span>
<span>  </span><span>Relation</span><span> </span><span>OldIndex</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>use_sort</span><span>,</span>
<span>  </span><span>TransactionId</span><span> </span><span>OldestXmin</span><span>,</span>
<span>  </span><span>TransactionId</span><span> </span><span>*</span><span>xid_cutoff</span><span>,</span>
<span>  </span><span>MultiXactId</span><span> </span><span>*</span><span>multi_cutoff</span><span>,</span>
<span>  </span><span>double</span><span> </span><span>*</span><span>num_tuples</span><span>,</span>
<span>  </span><span>double</span><span> </span><span>*</span><span>tups_vacuumed</span><span>,</span>
<span>  </span><span>double</span><span> </span><span>*</span><span>tups_recently_dead</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_vacuum_rel</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>rel</span><span>,</span>
<span>  </span><span>VacuumParams</span><span> </span><span>*</span><span>params</span><span>,</span>
<span>  </span><span>BufferAccessStrategy</span><span> </span><span>bstrategy</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_scan_analyze_next_block</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>scan</span><span>,</span>
<span>  </span><span>BlockNumber</span><span> </span><span>blockno</span><span>,</span>
<span>  </span><span>BufferAccessStrategy</span><span> </span><span>bstrategy</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_scan_analyze_next_tuple</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>scan</span><span>,</span>
<span>  </span><span>TransactionId</span><span> </span><span>OldestXmin</span><span>,</span>
<span>  </span><span>double</span><span> </span><span>*</span><span>liverows</span><span>,</span>
<span>  </span><span>double</span><span> </span><span>*</span><span>deadrows</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>double</span><span> </span><span>memam_index_build_range_scan</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>heapRelation</span><span>,</span>
<span>  </span><span>Relation</span><span> </span><span>indexRelation</span><span>,</span>
<span>  </span><span>IndexInfo</span><span> </span><span>*</span><span>indexInfo</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>allow_sync</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>anyvisible</span><span>,</span>
<span>  </span><span>bool</span><span> </span><span>progress</span><span>,</span>
<span>  </span><span>BlockNumber</span><span> </span><span>start_blockno</span><span>,</span>
<span>  </span><span>BlockNumber</span><span> </span><span>numblocks</span><span>,</span>
<span>  </span><span>IndexBuildCallback</span><span> </span><span>callback</span><span>,</span>
<span>  </span><span>void</span><span> </span><span>*</span><span>callback_state</span><span>,</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>scan</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_index_validate_scan</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>heapRelation</span><span>,</span>
<span>  </span><span>Relation</span><span> </span><span>indexRelation</span><span>,</span>
<span>  </span><span>IndexInfo</span><span> </span><span>*</span><span>indexInfo</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>ValidateIndexState</span><span> </span><span>*</span><span>state</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_relation_needs_toast_table</span><span>(</span><span>Relation</span><span> </span><span>rel</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>Oid</span><span> </span><span>memam_relation_toast_am</span><span>(</span><span>Relation</span><span> </span><span>rel</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>Oid</span><span> </span><span>oid</span><span> </span><span>=</span><span> </span><span>{};</span>
<span>  </span><span>return</span><span> </span><span>oid</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_fetch_toast_slice</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>toastrel</span><span>,</span>
<span>  </span><span>Oid</span><span> </span><span>valueid</span><span>,</span>
<span>  </span><span>int32</span><span> </span><span>attrsize</span><span>,</span>
<span>  </span><span>int32</span><span> </span><span>sliceoffset</span><span>,</span>
<span>  </span><span>int32</span><span> </span><span>slicelength</span><span>,</span>
<span>  </span><span>struct</span><span> </span><span>varlena</span><span> </span><span>*</span><span>result</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>memam_estimate_rel_size</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>rel</span><span>,</span>
<span>  </span><span>int32</span><span> </span><span>*</span><span>attr_widths</span><span>,</span>
<span>  </span><span>BlockNumber</span><span> </span><span>*</span><span>pages</span><span>,</span>
<span>  </span><span>double</span><span> </span><span>*</span><span>tuples</span><span>,</span>
<span>  </span><span>double</span><span> </span><span>*</span><span>allvisfrac</span>
<span>)</span><span> </span><span>{</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_scan_sample_next_block</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>scan</span><span>,</span><span> </span><span>SampleScanState</span><span> </span><span>*</span><span>scanstate</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>bool</span><span> </span><span>memam_scan_sample_next_tuple</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>scan</span><span>,</span>
<span>  </span><span>SampleScanState</span><span> </span><span>*</span><span>scanstate</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span>
<span>)</span><span> </span><span>{</span>
<span>  </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>}</span>

<span>const</span><span> </span><span>TableAmRoutine</span><span> </span><span>memam_methods</span><span> </span><span>=</span><span> </span><span>{</span>
<span>  </span><span>.</span><span>type</span><span> </span><span>=</span><span> </span><span>T_TableAmRoutine</span><span>,</span>

<span>  </span><span>.</span><span>slot_callbacks</span><span> </span><span>=</span><span> </span><span>memam_slot_callbacks</span><span>,</span>

<span>  </span><span>.</span><span>scan_begin</span><span> </span><span>=</span><span> </span><span>memam_beginscan</span><span>,</span>
<span>  </span><span>.</span><span>scan_end</span><span> </span><span>=</span><span> </span><span>memam_endscan</span><span>,</span>
<span>  </span><span>.</span><span>scan_rescan</span><span> </span><span>=</span><span> </span><span>memam_rescan</span><span>,</span>
<span>  </span><span>.</span><span>scan_getnextslot</span><span> </span><span>=</span><span> </span><span>memam_getnextslot</span><span>,</span>

<span>  </span><span>.</span><span>parallelscan_estimate</span><span> </span><span>=</span><span> </span><span>table_block_parallelscan_estimate</span><span>,</span>
<span>  </span><span>.</span><span>parallelscan_initialize</span><span> </span><span>=</span><span> </span><span>table_block_parallelscan_initialize</span><span>,</span>
<span>  </span><span>.</span><span>parallelscan_reinitialize</span><span> </span><span>=</span><span> </span><span>table_block_parallelscan_reinitialize</span><span>,</span>

<span>  </span><span>.</span><span>index_fetch_begin</span><span> </span><span>=</span><span> </span><span>memam_index_fetch_begin</span><span>,</span>
<span>  </span><span>.</span><span>index_fetch_reset</span><span> </span><span>=</span><span> </span><span>memam_index_fetch_reset</span><span>,</span>
<span>  </span><span>.</span><span>index_fetch_end</span><span> </span><span>=</span><span> </span><span>memam_index_fetch_end</span><span>,</span>
<span>  </span><span>.</span><span>index_fetch_tuple</span><span> </span><span>=</span><span> </span><span>memam_index_fetch_tuple</span><span>,</span>

<span>  </span><span>.</span><span>tuple_insert</span><span> </span><span>=</span><span> </span><span>memam_tuple_insert</span><span>,</span>
<span>  </span><span>.</span><span>tuple_insert_speculative</span><span> </span><span>=</span><span> </span><span>memam_tuple_insert_speculative</span><span>,</span>
<span>  </span><span>.</span><span>tuple_complete_speculative</span><span> </span><span>=</span><span> </span><span>memam_tuple_complete_speculative</span><span>,</span>
<span>  </span><span>.</span><span>multi_insert</span><span> </span><span>=</span><span> </span><span>memam_multi_insert</span><span>,</span>
<span>  </span><span>.</span><span>tuple_delete</span><span> </span><span>=</span><span> </span><span>memam_tuple_delete</span><span>,</span>
<span>  </span><span>.</span><span>tuple_update</span><span> </span><span>=</span><span> </span><span>memam_tuple_update</span><span>,</span>
<span>  </span><span>.</span><span>tuple_lock</span><span> </span><span>=</span><span> </span><span>memam_tuple_lock</span><span>,</span>

<span>  </span><span>.</span><span>tuple_fetch_row_version</span><span> </span><span>=</span><span> </span><span>memam_fetch_row_version</span><span>,</span>
<span>  </span><span>.</span><span>tuple_get_latest_tid</span><span> </span><span>=</span><span> </span><span>memam_get_latest_tid</span><span>,</span>
<span>  </span><span>.</span><span>tuple_tid_valid</span><span> </span><span>=</span><span> </span><span>memam_tuple_tid_valid</span><span>,</span>
<span>  </span><span>.</span><span>tuple_satisfies_snapshot</span><span> </span><span>=</span><span> </span><span>memam_tuple_satisfies_snapshot</span><span>,</span>
<span>  </span><span>.</span><span>index_delete_tuples</span><span> </span><span>=</span><span> </span><span>memam_index_delete_tuples</span><span>,</span>

<span>  </span><span>.</span><span>relation_set_new_filelocator</span><span> </span><span>=</span><span> </span><span>memam_relation_set_new_filelocator</span><span>,</span>
<span>  </span><span>.</span><span>relation_nontransactional_truncate</span><span> </span><span>=</span><span> </span><span>memam_relation_nontransactional_truncate</span><span>,</span>
<span>  </span><span>.</span><span>relation_copy_data</span><span> </span><span>=</span><span> </span><span>memam_relation_copy_data</span><span>,</span>
<span>  </span><span>.</span><span>relation_copy_for_cluster</span><span> </span><span>=</span><span> </span><span>memam_relation_copy_for_cluster</span><span>,</span>
<span>  </span><span>.</span><span>relation_vacuum</span><span> </span><span>=</span><span> </span><span>memam_vacuum_rel</span><span>,</span>
<span>  </span><span>.</span><span>scan_analyze_next_block</span><span> </span><span>=</span><span> </span><span>memam_scan_analyze_next_block</span><span>,</span>
<span>  </span><span>.</span><span>scan_analyze_next_tuple</span><span> </span><span>=</span><span> </span><span>memam_scan_analyze_next_tuple</span><span>,</span>
<span>  </span><span>.</span><span>index_build_range_scan</span><span> </span><span>=</span><span> </span><span>memam_index_build_range_scan</span><span>,</span>
<span>  </span><span>.</span><span>index_validate_scan</span><span> </span><span>=</span><span> </span><span>memam_index_validate_scan</span><span>,</span>

<span>  </span><span>.</span><span>relation_size</span><span> </span><span>=</span><span> </span><span>table_block_relation_size</span><span>,</span>
<span>  </span><span>.</span><span>relation_needs_toast_table</span><span> </span><span>=</span><span> </span><span>memam_relation_needs_toast_table</span><span>,</span>
<span>  </span><span>.</span><span>relation_toast_am</span><span> </span><span>=</span><span> </span><span>memam_relation_toast_am</span><span>,</span>
<span>  </span><span>.</span><span>relation_fetch_toast_slice</span><span> </span><span>=</span><span> </span><span>memam_fetch_toast_slice</span><span>,</span>

<span>  </span><span>.</span><span>relation_estimate_size</span><span> </span><span>=</span><span> </span><span>memam_estimate_rel_size</span><span>,</span>

<span>  </span><span>.</span><span>scan_sample_next_block</span><span> </span><span>=</span><span> </span><span>memam_scan_sample_next_block</span><span>,</span>
<span>  </span><span>.</span><span>scan_sample_next_tuple</span><span> </span><span>=</span><span> </span><span>memam_scan_sample_next_tuple</span>
<span>};</span>

<span>PG_FUNCTION_INFO_V1</span><span>(</span><span>mem_tableam_handler</span><span>);</span>

<span>Datum</span><span> </span><span>mem_tableam_handler</span><span>(</span><span>PG_FUNCTION_ARGS</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>PG_RETURN_POINTER</span><span>(</span><span>&amp;</span><span>memam_methods</span><span>);</span>
<span>}</span>
</pre></div>
<p>Let&#39;s build and test it!</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
</pre></div>
<p>Hey we&#39;re getting somewhere! It successfully created the table with
our custom table access method.</p>
<h3 id="querying-rows">Querying rows</h3><p>Next, let&#39;s try querying the table by adding a <code>SELECT a FROM x</code> to
<code>test.sql</code> and running it:</p>
<div><pre><span></span><span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>psql:test.sql:6: server closed the connection unexpectedly</span>
<span>        This probably means the server terminated abnormally</span>
<span>        before or while processing the request.</span>
<span>psql:test.sql:6: error: connection to server was lost</span>
</pre></div>
<p>This time there&#39;s nothing in <code>logfile</code> that helps:</p>
<div><pre><span></span><span>$ </span>tail<span> </span>-n15<span> </span>logfile
<span>2023-11-01 18:43:32.449 UTC [2906199] LOG:  database system is ready to accept connections</span>
<span>2023-11-01 18:58:32.572 UTC [2907997] LOG:  checkpoint starting: time</span>
<span>2023-11-01 18:58:35.305 UTC [2907997] LOG:  checkpoint complete: wrote 28 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=2.712 s, sync=0.015 s, total=2.733 s; sync files=23, longest=0.004 s, average=0.001 s; distance=128 kB, estimate=150 kB; lsn=0/15F88E0, redo lsn=0/15F8888</span>
<span>2023-11-01 19:08:14.485 UTC [2906199] LOG:  server process (PID 2908242) was terminated by signal 11: Segmentation fault</span>
<span>2023-11-01 19:08:14.485 UTC [2906199] DETAIL:  Failed process was running: SELECT a FROM x;</span>
<span>2023-11-01 19:08:14.485 UTC [2906199] LOG:  terminating any other active server processes</span>
<span>2023-11-01 19:08:14.486 UTC [2906199] LOG:  all server processes terminated; reinitializing</span>
<span>2023-11-01 19:08:14.508 UTC [2908253] LOG:  database system was interrupted; last known up at 2023-11-01 18:58:35 UTC</span>
<span>2023-11-01 19:08:14.518 UTC [2908253] LOG:  database system was not properly shut down; automatic recovery in progress</span>
<span>2023-11-01 19:08:14.519 UTC [2908253] LOG:  redo starts at 0/15F8888</span>
<span>2023-11-01 19:08:14.520 UTC [2908253] LOG:  invalid record length at 0/161DE70: expected at least 24, got 0</span>
<span>2023-11-01 19:08:14.520 UTC [2908253] LOG:  redo done at 0/161DE38 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</span>
<span>2023-11-01 19:08:14.521 UTC [2908254] LOG:  checkpoint starting: end-of-recovery immediate wait</span>
<span>2023-11-01 19:08:14.532 UTC [2908254] LOG:  checkpoint complete: wrote 35 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.010 s, total=0.012 s; sync files=27, longest=0.003 s, average=0.001 s; distance=149 kB, estimate=149 kB; lsn=0/161DE70, redo lsn=0/161DE70</span>
<span>2023-11-01 19:08:14.533 UTC [2906199] LOG:  database system is ready to accept connections</span>
</pre></div>
<p>This was the first place I got stuck. How on earth do I figure out
what methods to implement? I mean, it&#39;s clearly one or more of these
methods from the struct. But there are so many methods.</p>
<p>I tried setting a breakpoint in <code>gdb</code> on the process returned by
<code>SELECT pg_backend_pid()</code> for a <code>psql</code> session, but the breakpoint
never seemed to be hit for any of my methods.</p>
<p>So I did the low-tech solution and opened a file, <code>/tmp/pgtam.log</code>,
turned off buffering on it, and added a log to every method on the
<code>TableAmRoutine</code> struct:</p>
<div><pre><span></span><span>@@ -12,9 +12,13 @@</span>

<span> </span>const TableAmRoutine memam_methods;

<span>+FILE* fd;</span>
<span>+#define DEBUG_FUNC() fprintf(fd, &#34;in %s\n&#34;, __func__);</span>
<span>+</span>
<span> </span>static const TupleTableSlotOps* memam_slot_callbacks(
<span> </span>  Relation relation
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return NULL;
<span> </span>}

<span>@@ -26,6 +30,7 @@</span>
<span> </span>  ParallelTableScanDesc parallel_scan,
<span> </span>  uint32 flags
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return NULL;
<span> </span>}

<span>@@ -37,9 +42,11 @@</span>
<span> </span>  bool allow_sync,
<span> </span>  bool allow_pagemode
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_endscan(TableScanDesc sscan) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static bool memam_getnextslot(
<span>@@ -47,17 +54,21 @@</span>
<span> </span>  ScanDirection direction,
<span> </span>  TupleTableSlot *slot
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span> </span>static IndexFetchTableData* memam_index_fetch_begin(Relation rel) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return NULL;
<span> </span>}

<span> </span>static void memam_index_fetch_reset(IndexFetchTableData *scan) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_index_fetch_end(IndexFetchTableData *scan) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static bool memam_index_fetch_tuple(
<span>@@ -68,6 +79,7 @@</span>
<span> </span>  bool *call_again,
<span> </span>  bool *all_dead
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span>@@ -78,6 +90,7 @@</span>
<span> </span>  int options,
<span> </span>  BulkInsertState bistate
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_tuple_insert_speculative(
<span>@@ -87,6 +100,7 @@</span>
<span> </span>  int options,
<span> </span>  BulkInsertState bistate,
<span> </span>  uint32 specToken) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_tuple_complete_speculative(
<span>@@ -94,6 +108,7 @@</span>
<span> </span>  TupleTableSlot *slot,
<span> </span>  uint32 specToken,
<span> </span>  bool succeeded) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_multi_insert(
<span>@@ -104,6 +119,7 @@</span>
<span> </span>  int options,
<span> </span>  BulkInsertState bistate
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static TM_Result memam_tuple_delete(
<span>@@ -117,6 +133,7 @@</span>
<span> </span>  bool changingPart
<span> </span>) {
<span> </span>  TM_Result result = {};
<span>+  DEBUG_FUNC();</span>
<span> </span>  return result;
<span> </span>}

<span>@@ -133,6 +150,7 @@</span>
<span> </span>  TU_UpdateIndexes *update_indexes
<span> </span>) {
<span> </span>  TM_Result result = {};
<span>+  DEBUG_FUNC();</span>
<span> </span>  return result;
<span> </span>}

<span>@@ -148,6 +166,7 @@</span>
<span> </span>  TM_FailureData *tmfd)
<span> </span>{
<span> </span>  TM_Result result = {};
<span>+  DEBUG_FUNC();</span>
<span> </span>  return result;
<span> </span>}

<span>@@ -157,6 +176,7 @@</span>
<span> </span>  Snapshot snapshot,
<span> </span>  TupleTableSlot *slot
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span>@@ -164,9 +184,11 @@</span>
<span> </span>  TableScanDesc sscan,
<span> </span>  ItemPointer tid
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static bool memam_tuple_tid_valid(TableScanDesc scan, ItemPointer tid) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span>@@ -175,6 +197,7 @@</span>
<span> </span>  TupleTableSlot *slot,
<span> </span>  Snapshot snapshot
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span>@@ -183,6 +206,7 @@</span>
<span> </span>  TM_IndexDeleteOp *delstate
<span> </span>) {
<span> </span>  TransactionId id = {};
<span>+  DEBUG_FUNC();</span>
<span> </span>  return id;
<span> </span>}

<span>@@ -193,17 +217,20 @@</span>
<span> </span>  TransactionId *freezeXid,
<span> </span>  MultiXactId *minmulti
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_relation_nontransactional_truncate(
<span> </span>  Relation rel
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_relation_copy_data(
<span> </span>  Relation rel,
<span> </span>  const RelFileLocator *newrlocator
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_relation_copy_for_cluster(
<span>@@ -218,6 +245,7 @@</span>
<span> </span>  double *tups_vacuumed,
<span> </span>  double *tups_recently_dead
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_vacuum_rel(
<span>@@ -225,6 +253,7 @@</span>
<span> </span>  VacuumParams *params,
<span> </span>  BufferAccessStrategy bstrategy
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static bool memam_scan_analyze_next_block(
<span>@@ -232,6 +261,7 @@</span>
<span> </span>  BlockNumber blockno,
<span> </span>  BufferAccessStrategy bstrategy
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span>@@ -242,6 +272,7 @@</span>
<span> </span>  double *deadrows,
<span> </span>  TupleTableSlot *slot
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span>@@ -258,6 +289,7 @@</span>
<span> </span>  void *callback_state,
<span> </span>  TableScanDesc scan
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return 0;
<span> </span>}

<span>@@ -268,14 +300,17 @@</span>
<span> </span>  Snapshot snapshot,
<span> </span>  ValidateIndexState *state
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static bool memam_relation_needs_toast_table(Relation rel) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span> </span>static Oid memam_relation_toast_am(Relation rel) {
<span> </span>  Oid oid = {};
<span>+  DEBUG_FUNC();</span>
<span> </span>  return oid;
<span> </span>}

<span>@@ -287,6 +322,7 @@</span>
<span> </span>  int32 slicelength,
<span> </span>  struct varlena *result
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static void memam_estimate_rel_size(
<span>@@ -296,11 +332,13 @@</span>
<span> </span>  double *tuples,
<span> </span>  double *allvisfrac
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>}

<span> </span>static bool memam_scan_sample_next_block(
<span> </span>  TableScanDesc scan, SampleScanState *scanstate
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}

<span>@@ -309,6 +347,7 @@</span>
<span> </span>  SampleScanState *scanstate,
<span> </span>  TupleTableSlot *slot
<span> </span>) {
<span>+  DEBUG_FUNC();</span>
<span> </span>  return false;
<span> </span>}
</pre></div>
<p>And then in the entrypoint, initialize the file for logging.</p>
<div><pre><span></span><span>@@ -369,5 +408,9 @@</span>
<span> </span>PG_FUNCTION_INFO_V1(mem_tableam_handler);

<span> </span>Datum mem_tableam_handler(PG_FUNCTION_ARGS) {
<span>+  fd = fopen(&#34;/tmp/pgtam.log&#34;, &#34;a&#34;);</span>
<span>+  setvbuf(fd, NULL, _IONBF, 0); // Prevent buffering</span>
<span>+  fprintf(fd, &#34;\n\nmem_tableam handler loaded\n&#34;);</span>
<span>+</span>
<span> </span>  PG_RETURN_POINTER(&amp;memam_methods);
<span> </span>}
</pre></div>
<p>Let&#39;s give it a shot!</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>psql:test.sql:6: server closed the connection unexpectedly</span>
<span>        This probably means the server terminated abnormally</span>
<span>        before or while processing the request.</span>
<span>psql:test.sql:6: error: connection to server was lost</span>
</pre></div>
<p>And let&#39;s check our log file:</p>
<div><pre><span></span><span>$</span><span> </span><span>cat</span><span> </span><span>/</span><span>tmp</span><span>/</span><span>pgtam</span><span>.</span><span>log</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_relation_set_new_filelocator</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_relation_needs_toast_table</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_estimate_rel_size</span>
<span>in</span><span> </span><span>memam_slot_callbacks</span>
</pre></div>
<p>Now we&#39;re getting somewhere!</p>
<p>
  I later realized <code>elog()</code> is the way most people log
  within Postgres/within extensions. I didn&#39;t know that when I was
  getting started though. This separate logging was a simple way to
  get the info out.
</p><h4 id="&lt;code&gt;slot_callbacks&lt;/code&gt;"><code>slot_callbacks</code></h4><p>Since the request crashes and the last logged function is
<code>memam_slot_callbacks</code>, it seems like that is where we should
concentrate. The <a href="https://www.postgresql.org/docs/current/tableam.html">table access method
docs</a> suggest
looking at the default <code>heap</code> access method for inspiration.</p>
<p>Its
<a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/backend/access/heap/heapam_handler.c#L67">version</a>
of <code>slot_callbacks</code> returns <code>&amp;TTSOpsBufferHeapTuple</code>:</p>
<div><pre><span></span><span>static</span><span> </span><span>const</span><span> </span><span>TupleTableSlotOps</span><span> </span><span>*</span>
<span>heapam_slot_callbacks</span><span>(</span><span>Relation</span><span> </span><span>relation</span><span>)</span>
<span>{</span>
<span>    </span><span>return</span><span> </span><span>&amp;</span><span>TTSOpsBufferHeapTuple</span><span>;</span>
<span>}</span>
</pre></div>
<p>I have no idea what that means, but since it is defined in
<a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/backend/executor/execTuples.c#L1080"><code>src/backend/executor/execTuples.c</code></a>
it doesn&#39;t seem to be tied to the <code>heap</code> access method
implementation. Let&#39;s try it.</p>
<p>
  While it works initially, I noticed later on that
  <code>TTSOpsBufferHeapTuple</code> turns out not to be the right
  choice here. <code>TTSOpsVirtual</code> seems to be the right
  implementation.
</p><div><pre><span></span><span>@@ -19,7 +19,7 @@</span>
<span> </span>  Relation relation
<span> </span>) {
<span> </span>  DEBUG_FUNC();
<span>-  return NULL;</span>
<span>+  return &amp;TTSOpsVirtual;</span>
<span> </span>}

<span> </span>static TableScanDesc memam_beginscan(
</pre></div>
<p>Build and run:</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>psql:test.sql:6: server closed the connection unexpectedly</span>
<span>        This probably means the server terminated abnormally</span>
<span>        before or while processing the request.</span>
<span>psql:test.sql:6: error: connection to server was lost</span>
</pre></div>
<p>It still crashes. But this time in <code>/tmp/pgtam.log</code> we made it into a
new method!</p>
<div><pre><span></span><span>$</span><span> </span><span>cat</span><span> </span><span>/</span><span>tmp</span><span>/</span><span>pgtam</span><span>.</span><span>log</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_relation_set_new_filelocator</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_relation_needs_toast_table</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_estimate_rel_size</span>
<span>in</span><span> </span><span>memam_slot_callbacks</span>
<span>in</span><span> </span><span>memam_beginscan</span>
</pre></div>
<h4 id="&lt;code&gt;scan_begin&lt;/code&gt;"><code>scan_begin</code></h4><p>The function signature is:</p>
<div><pre><span></span><span>TableScanDesc</span><span> </span><span>heap_beginscan</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>Snapshot</span><span> </span><span>snapshot</span><span>,</span>
<span>  </span><span>int</span><span> </span><span>nkeys</span><span>,</span>
<span>  </span><span>ScanKey</span><span> </span><span>key</span><span>,</span>
<span>  </span><span>ParallelTableScanDesc</span><span> </span><span>parallel_scan</span><span>,</span>
<span>  </span><span>uint32</span><span> </span><span>flags</span>
<span>);</span>
</pre></div>
<p>Since we just implemented stub versions of all the methods, we&#39;ve been
returning <code>NULL</code>. Since we&#39;re failing in this function, maybe we
should try returning something that isn&#39;t <code>NULL</code>.</p>
<p>By looking at the definition of <code>TableScanDesc</code>, we can see it is a
pointer to the <code>TableScanDescData</code> struct defined in
<a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/include/access/relscan.h#L52"><code>src/include/access/relscan.h</code></a>.</p>
<p>Let&#39;s <code>malloc</code> a <code>TableScanDescData</code>, free it in <code>endscan</code>, and return
the <code>TableScanDescData</code> instance in <code>beginscan</code>:</p>
<div><pre><span></span><span>@@ -30,8 +30,12 @@</span>
<span> </span>  ParallelTableScanDesc parallel_scan,
<span> </span>  uint32 flags
<span> </span>) {
<span>+  TableScanDescData* scan = {};</span>
<span> </span>  DEBUG_FUNC();
<span>-  return NULL;</span>
<span>+</span>
<span>+  scan = (TableScanDescData*)malloc(sizeof(TableScanDescData));</span>
<span>+</span>
<span>+  return (TableScanDesc)scan;</span>
<span> </span>}

<span> </span>static void memam_rescan(
<span>@@ -87,6 +87,7 @@</span>

<span> </span>static void memam_endscan(TableScanDesc sscan) {
<span> </span>  DEBUG_FUNC();
<span>+  free(sscan);</span>
<span> </span>}
</pre></div>
<p>Build and run (you can do it on your own). No difference.</p>
<p>I got stuck for a while here too. Clearly something must be filled out
in this struct but it could be anything. Through trial and error I
realized the one field that must be filled out is <code>scan-&gt;rs_rd</code>.</p>
<div><pre><span></span><span>@@ -34,6 +34,7 @@</span>
<span> </span>  DEBUG_FUNC();

<span> </span>  scan = (TableScanDescData*)malloc(sizeof(TableScanDescData));
<span>+  scan-&gt;rs_rd = relation;</span>

<span> </span>  return (TableScanDesc)scan;
<span> </span>}
</pre></div>
<p>We build and run:</p>
<div><pre><span></span>$<span> </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
$<span> </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
psql:test.sql:1:<span> </span>NOTICE:<span>  </span>drop<span> </span>cascades<span> </span>to<span> </span>table<span> </span>x
DROP<span> </span>EXTENSION
CREATE<span> </span>EXTENSION
CREATE<span> </span>TABLE
<span> </span>a
---
<span>(</span><span>0</span><span> </span>rows<span>)</span>
</pre></div>
<p>And it works! It doesn&#39;t return anything but that&#39;s correct. There&#39;s
nothing to return.</p>
<p>So what if we actually want to return something? Let&#39;s check our logs
in <code>/tmp/pgtam.log</code>.</p>
<div><pre><span></span><span>$</span><span> </span><span>cat</span><span> </span><span>/</span><span>tmp</span><span>/</span><span>pgtam</span><span>.</span><span>log</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_relation_set_new_filelocator</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_relation_needs_toast_table</span>


<span>mem_tableam</span><span> </span><span>handler</span><span> </span><span>loaded</span>
<span>in</span><span> </span><span>memam_estimate_rel_size</span>
<span>in</span><span> </span><span>memam_slot_callbacks</span>
<span>in</span><span> </span><span>memam_beginscan</span>
<span>in</span><span> </span><span>memam_getnextslot</span>
<span>in</span><span> </span><span>memam_endscan</span>
</pre></div>
<p>Ok, I&#39;m getting the gist of the API. A full table scan (which this is,
because there are no indexes at play) starts with an initialization
for a slot, then the scan begins, then <code>getnextslot</code> is called for
each row, and then <code>endscan</code> is called to allow for cleanup.</p>
<p>So let&#39;s try returning a row in <code>getnextslot</code>.</p>
<h4 id="&lt;code&gt;getnextslot&lt;/code&gt;"><code>getnextslot</code></h4><p>The <code>getnextslot</code> signature is:</p>
<div><pre><span></span><span>bool</span><span> </span><span>memam_getnextslot</span><span>(</span>
<span>  </span><span>TableScanDesc</span><span> </span><span>sscan</span><span>,</span>
<span>  </span><span>ScanDirection</span><span> </span><span>direction</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span>
<span>);</span>
</pre></div>
<p>So the <code>sscan</code> should be what we returned from <code>beginscan</code> and the
<a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/include/access/tableam.h#L341">interface
docs</a>
say the current row gets stored in <code>slot</code>.</p>
<p>
  The return value seems to indicate whether or not we&#39;ve reached the
  end of the scan. However, the scan will still end even if you
  <code>return true</code> if the <code>slot</code> is not filled out correctly. If the
  <code>slot</code> is filled out correctly and you unconditionally <code>return
  true</code>, you will crash the process.
</p><p>Let&#39;s take a look at the
<a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/include/executor/tuptable.h#L114">definition</a>
of <code>TupleTableSlot</code>:</p>
<div><pre><span></span><span>typedef</span><span> </span><span>struct</span><span> </span><span>TupleTableSlot</span>
<span>{</span>
<span>    </span><span>NodeTag</span><span>     </span><span>type</span><span>;</span>
<span>#define FIELDNO_TUPLETABLESLOT_FLAGS 1</span>
<span>    </span><span>uint16</span><span>      </span><span>tts_flags</span><span>;</span><span>      </span><span>/* Boolean states */</span>
<span>#define FIELDNO_TUPLETABLESLOT_NVALID 2</span>
<span>    </span><span>AttrNumber</span><span>  </span><span>tts_nvalid</span><span>;</span><span>     </span><span>/* # of valid values in tts_values */</span>
<span>    </span><span>const</span><span> </span><span>TupleTableSlotOps</span><span> </span><span>*</span><span>const</span><span> </span><span>tts_ops</span><span>;</span><span> </span><span>/* implementation of slot */</span>
<span>#define FIELDNO_TUPLETABLESLOT_TUPLEDESCRIPTOR 4</span>
<span>    </span><span>TupleDesc</span><span>   </span><span>tts_tupleDescriptor</span><span>;</span><span>    </span><span>/* slot&#39;s tuple descriptor */</span>
<span>#define FIELDNO_TUPLETABLESLOT_VALUES 5</span>
<span>    </span><span>Datum</span><span>      </span><span>*</span><span>tts_values</span><span>;</span><span>     </span><span>/* current per-attribute values */</span>
<span>#define FIELDNO_TUPLETABLESLOT_ISNULL 6</span>
<span>    </span><span>bool</span><span>       </span><span>*</span><span>tts_isnull</span><span>;</span><span>     </span><span>/* current per-attribute isnull flags */</span>
<span>    </span><span>MemoryContext</span><span> </span><span>tts_mcxt</span><span>;</span><span>     </span><span>/* slot itself is in this context */</span>
<span>    </span><span>ItemPointerData</span><span> </span><span>tts_tid</span><span>;</span><span>    </span><span>/* stored tuple&#39;s tid */</span>
<span>    </span><span>Oid</span><span>         </span><span>tts_tableOid</span><span>;</span><span>   </span><span>/* table oid of tuple */</span>
<span>}</span><span> </span><span>TupleTableSlot</span><span>;</span>
</pre></div>
<p><code>tts_values</code> is an array of <code>Datum</code> (which is a Postgres value). So
that sounds like the actual values of the row. The <code>tts_isnull</code> field
also looks important since that seems to be whether each value in the
row is null or not. And <code>tts_nvalid</code> sounds important too since
presumably it&#39;s the length of the <code>tts_isnull</code> and <code>tts_values</code>
arrays.</p>
<p>The rest of it may or may not be important. Let&#39;s try filling out
these three fields though and see what happens.</p>
<h4 id="datum">Datum</h4><p>Back in the <a href="https://www.postgresql.org/docs/current/xfunc-c.html">Postgres C extension
documentation</a>,
we can see some simple examples of converting between C types and
Postgres&#39;s Datum type.</p>
<p>For example:</p>
<div><pre><span></span><span>Datum</span>
<span>add_one</span><span>(</span><span>PG_FUNCTION_ARGS</span><span>)</span>
<span>{</span>
<span>    </span><span>int32</span><span>   </span><span>arg</span><span> </span><span>=</span><span> </span><span>PG_GETARG_INT32</span><span>(</span><span>0</span><span>);</span>

<span>    </span><span>PG_RETURN_INT32</span><span>(</span><span>arg</span><span> </span><span>+</span><span> </span><span>1</span><span>);</span>
<span>}</span>
</pre></div>
<p>If we look at the definition of <code>PG_RETURN_INT32</code> in
<a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/include/fmgr.h#L354"><code>src/include/fmgr.h</code></a>,
we see:</p>
<div><pre><span></span><span>#define PG_RETURN_INT32(x)   return Int32GetDatum(x)</span>
</pre></div>
<p>So <code>Int32GetDatum()</code> is the function we&#39;ll use to set a <code>Datum</code> for a
cell in a row.</p>
<div><pre><span></span><span>@@ -54,13 +54,26 @@</span>
<span> </span>  DEBUG_FUNC();
<span> </span>}

<span>+static bool done = false;</span>
<span> </span>static bool memam_getnextslot(
<span> </span>  TableScanDesc sscan,
<span> </span>  ScanDirection direction,
<span> </span>  TupleTableSlot *slot
<span> </span>) {
<span> </span>  DEBUG_FUNC();
<span>-  return false;</span>
<span>+</span>
<span>+  if (done) {</span>
<span>+    return false;</span>
<span>+  }</span>
<span>+</span>
<span>+  slot-&gt;tts_nvalid = 1;</span>
<span>+  slot-&gt;tts_values = (Datum*)malloc(sizeof(Datum) * slot-&gt;tts_nvalid);</span>
<span>+  slot-&gt;tts_values[0] = Int32GetDatum(314 /* Some unique-looking value */);</span>
<span>+  slot-&gt;tts_isnull = (bool*)malloc(sizeof(bool) * slot-&gt;tts_nvalid);</span>
<span>+  slot-&gt;tts_isnull[0] = false;</span>
<span>+  done = true;</span>
<span>+</span>
<span>+  return true;</span>
<span> </span>}

<span> </span>static IndexFetchTableData* memam_index_fetch_begin(Relation rel) {
</pre></div>
<p>The goal is that we return a single row and then exit the scan. It
will have one 32-bit integer cell (remember we created the table
<code>CREATE TABLE x (a INT)</code>; <code>INT</code> is shorthand for <code>INT4</code> which is a
32-bit integer) that will have the value <code>314</code>.</p>
<p>But if we build and run this, we get no rows.</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span> a</span>
<span>---</span>
<span>(0 rows)</span>
</pre></div>
<p>I got stuck for a while here. Plugging my <code>getnextslot</code> code into
ChatGPT helped. One thing it gave me to try was calling
<code>ExecStoreVirtualTuple</code> on the <code>slot</code>. I noticed that the built-in
<code>heap</code> access method <a href="https://github.com/postgres/postgres/blob/849172ff4883d44168f96f39d3fde96d0aa34c99/src/backend/access/heap/heapam.c#L1159">also called a function like
this</a>
in <code>getnextslot</code>.</p>
<p>And I realized that <code>tts_nvalid</code> is already set up and the memory for
<code>tts_values</code> and <code>tts_isnull</code> is already allocated. So the code became
a little simpler.</p>
<div><pre><span></span><span>@@ -66,11 +66,9 @@</span>
<span> </span>    return false;
<span> </span>  }

<span>-  slot-&gt;tts_nvalid = 1;</span>
<span>-  slot-&gt;tts_values = (Datum*)malloc(sizeof(Datum) * slot-&gt;tts_nvalid);</span>
<span> </span>  slot-&gt;tts_values[0] = Int32GetDatum(314 /* Some unique-looking value */);
<span>-  slot-&gt;tts_isnull = (bool*)malloc(sizeof(bool) * slot-&gt;tts_nvalid);</span>
<span> </span>  slot-&gt;tts_isnull[0] = false;
<span>+  ExecStoreVirtualTuple(slot);</span>
<span> </span>  done = true;

<span> </span>  return true;
</pre></div>
<p>Build and run:</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>  a</span>
<span>-----</span>
<span> 314</span>
<span>(1 row)</span>
</pre></div>
<p>Fantastic!</p>
<h3 id="creating-a-table">Creating a table</h3><p>Now that we&#39;ve proven we can return random data, let&#39;s set up
infrastructure for storing tables in memory.</p>
<div><pre><span></span><span>@@ -15,6 +15,41 @@</span>
<span> </span>FILE* fd;
<span> </span>#define DEBUG_FUNC() fprintf(fd, &#34;in %s\n&#34;, __func__);

<span>+</span>
<span>+struct Column {</span>
<span>+  int value;</span>
<span>+};</span>
<span>+</span>
<span>+struct Row {</span>
<span>+  struct Column* columns;</span>
<span>+  size_t ncolumns;</span>
<span>+};</span>
<span>+</span>
<span>+#define MAX_ROWS 100</span>
<span>+struct Table {</span>
<span>+  char* name;</span>
<span>+  struct Row* rows;</span>
<span>+  size_t nrows;</span>
<span>+};</span>
<span>+</span>
<span>+#define MAX_TABLES 100</span>
<span>+struct Database {</span>
<span>+  struct Table* tables;</span>
<span>+  size_t ntables;</span>
<span>+};</span>
<span>+</span>
<span>+struct Database* database;</span>
<span>+</span>
<span>+static void get_table(struct Table** table, Relation relation) {</span>
<span>+  char* this_name = NameStr(relation-&gt;rd_rel-&gt;relname);</span>
<span>+  for (size_t i = 0; i &lt; database-&gt;ntables; i++) {</span>
<span>+    if (strcmp(database-&gt;tables[i].name, this_name) == 0) {</span>
<span>+      *table = &amp;database-&gt;tables[i];</span>
<span>+      return;</span>
<span>+    }</span>
<span>+  }</span>
<span>+}</span>
<span>+</span>
<span> </span>static const TupleTableSlotOps* memam_slot_callbacks(
<span> </span>  Relation relation
<span> </span>) {
</pre></div>
<p>Based on what we logged in <code>/tmp/pgtam.log</code> it seems like
<code>memam_relation_set_new_filelocator</code> is called when a new table is
created. So let&#39;s handle adding a new table there.</p>
<div><pre><span></span><span>@@ -233,7 +268,16 @@</span>
<span> </span>  TransactionId *freezeXid,
<span> </span>  MultiXactId *minmulti
<span> </span>) {
<span>+  struct Table table = {};</span>
<span> </span>  DEBUG_FUNC();
<span>+</span>
<span>+  table.name = strdup(NameStr(rel-&gt;rd_rel-&gt;relname));</span>
<span>+  fprintf(fd, &#34;Created table: [%s]\n&#34;, table.name);</span>
<span>+  table.rows = (struct Row*)malloc(sizeof(struct Row) * MAX_ROWS);</span>
<span>+  table.nrows = 0;</span>
<span>+</span>
<span>+  database-&gt;tables[database-&gt;ntables] = table;</span>
<span>+  database-&gt;ntables++;</span>
<span> </span>}

<span> </span>static void memam_relation_nontransactional_truncate(
</pre></div>
<p>Finally, we&#39;ll initialize the in-memory <code>Database*</code> when the handler is
loaded.</p>
<div><pre><span></span><span>@@ -428,5 +472,11 @@</span>
<span> </span>  setvbuf(fd, NULL, _IONBF, 0); // Prevent buffering
<span> </span>  fprintf(fd, &#34;\n\nmem_tableam handler loaded\n&#34;);

<span>+  if (database == NULL) {</span>
<span>+    database = (struct Database*)malloc(sizeof(struct Database));</span>
<span>+    database-&gt;ntables = 0;</span>
<span>+    database-&gt;tables = (struct Table*)malloc(sizeof(struct Table) * MAX_TABLES);</span>
<span>+  }</span>
<span>+</span>
<span> </span>  PG_RETURN_POINTER(&amp;memam_methods);
<span> </span>}
</pre></div>
<p>If we build and run, we won&#39;t notice anything new.</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>  a</span>
<span>-----</span>
<span> 314</span>
<span>(1 row)</span>
</pre></div>
<p>But we should see a message in <code>/tmp/pgtam.log</code> about the new table
being created.</p>
<div><pre><span></span><span>$ </span>cat<span> </span>/tmp/pgtam.log


<span>mem_tableam handler loaded</span>


<span>mem_tableam handler loaded</span>
<span>in memam_relation_set_new_filelocator</span>
<span>Created table: [x]</span>


<span>mem_tableam handler loaded</span>
<span>in memam_relation_needs_toast_table</span>


<span>mem_tableam handler loaded</span>
<span>in memam_estimate_rel_size</span>
<span>in memam_slot_callbacks</span>
<span>in memam_beginscan</span>
<span>in memam_getnextslot</span>
<span>in memam_getnextslot</span>
<span>in memam_endscan</span>
</pre></div>
<p>And there it is! Creation looks good.</p>
<h3 id="inserting-rows">Inserting rows</h3><p>Let&#39;s add <code>INSERT INTO x VALUES (23), (101);</code> to <code>test.sql</code> and run
the SQL script.</p>
<div><pre><span></span><span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>INSERT 0 2</span>
<span>  a</span>
<span>-----</span>
<span> 314</span>
<span>(1 row)</span>
</pre></div>
<p>And let&#39;s check the log to see what method is called when we try to
<code>INSERT</code>.</p>
<div><pre><span></span><span>$ </span>cat<span> </span>/tmp/pgtam.log


<span>mem_tableam handler loaded</span>


<span>mem_tableam handler loaded</span>
<span>in memam_relation_set_new_filelocator</span>
<span>Created table: [x]</span>


<span>mem_tableam handler loaded</span>
<span>in memam_relation_needs_toast_table</span>


<span>mem_tableam handler loaded</span>
<span>in memam_slot_callbacks</span>
<span>in memam_tuple_insert</span>
<span>in memam_tuple_insert</span>
<span>in memam_estimate_rel_size</span>
<span>in memam_slot_callbacks</span>
<span>in memam_beginscan</span>
<span>in memam_getnextslot</span>
<span>in memam_getnextslot</span>
<span>in memam_endscan</span>
</pre></div>
<p><code>tuple_insert</code> seems to be the method! Looks like it gets called once
for each row to insert. Perfect.</p>
<p>The signature for <code>tuple_insert</code> is:</p>
<div><pre><span></span><span>void</span><span> </span><span>memam_tuple_insert</span><span>(</span>
<span>  </span><span>Relation</span><span> </span><span>relation</span><span>,</span>
<span>  </span><span>TupleTableSlot</span><span> </span><span>*</span><span>slot</span><span>,</span>
<span>  </span><span>CommandId</span><span> </span><span>cid</span><span>,</span>
<span>  </span><span>int</span><span> </span><span>options</span><span>,</span>
<span>  </span><span>BulkInsertState</span><span> </span><span>bistate</span>
<span>);</span>
</pre></div>
<p>We can get the table name from <code>relation</code>, and instead of writing to
<code>slot</code> we can read from <code>slot-&gt;tts_values</code> instead.</p>
<div><pre><span></span><span>@@ -141,7 +141,38 @@</span>
<span> </span>  int options,
<span> </span>  BulkInsertState bistate
<span> </span>) {
<span>+  TupleDesc desc = RelationGetDescr(relation);</span>
<span>+  struct Table* table = NULL;</span>
<span>+  struct Column column = {};</span>
<span>+  struct Row row = {};</span>
<span>+</span>
<span> </span>  DEBUG_FUNC();
<span>+</span>
<span>+  get_table(&amp;table, relation);</span>
<span>+  if (table == NULL) {</span>
<span>+    elog(ERROR, &#34;table not found&#34;);</span>
<span>+    return;</span>
<span>+  }</span>
<span>+</span>
<span>+  if (table-&gt;nrows == MAX_ROWS) {</span>
<span>+    elog(ERROR, &#34;cannot insert more rows&#34;);</span>
<span>+    return;</span>
<span>+  }</span>
<span>+</span>
<span>+  row.ncolumns = desc-&gt;natts;</span>
<span>+  Assert(slot-&gt;tts_nvalid == row.ncolumns);</span>
<span>+  Assert(row.ncolumns &gt; 0);</span>
<span>+</span>
<span>+  row.columns = (struct Column*)malloc(sizeof(struct Column) * row.ncolumns);</span>
<span>+  for (size_t i = 0; i &lt; row.ncolumns; i++) {</span>
<span>+    Assert(desc-&gt;attrs[i].atttypid == INT4OID);</span>
<span>+    column.value = DatumGetInt32(slot-&gt;tts_values[i]);</span>
<span>+    row.columns[i] = column;</span>
<span>+    fprintf(fd, &#34;Got value: %d\n&#34;, column.value);</span>
<span>+  }</span>
<span>+</span>
<span>+  table-&gt;rows[table-&gt;nrows] = row;</span>
<span>+  table-&gt;nrows++;</span>
<span> </span>}

<span> </span>static void memam_tuple_insert_speculative(
</pre></div>
<p>Build and run and again we won&#39;t notice anything new.</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>INSERT 0 2</span>
<span>  a</span>
<span>-----</span>
<span> 314</span>
<span>(1 row)</span>
</pre></div>
<p>But if we check the logs, we should see the two column values we
inserted, one for each row.</p>
<div><pre><span></span><span>$ </span>cat<span> </span>/tmp/pgtam.log


<span>mem_tableam handler loaded</span>


<span>mem_tableam handler loaded</span>
<span>in memam_relation_set_new_filelocator</span>
<span>Created table: [x]</span>


<span>mem_tableam handler loaded</span>
<span>in memam_relation_needs_toast_table</span>


<span>mem_tableam handler loaded</span>
<span>in memam_slot_callbacks</span>
<span>in memam_tuple_insert</span>
<span>Got value: 23</span>
<span>in memam_tuple_insert</span>
<span>Got value: 101</span>
<span>in memam_estimate_rel_size</span>
<span>in memam_slot_callbacks</span>
<span>in memam_beginscan</span>
<span>in memam_getnextslot</span>
<span>in memam_getnextslot</span>
<span>in memam_endscan</span>
</pre></div>
<p>Woohoo!</p>
<h3 id="un-hardcoding-the-scan">Un-hardcoding the scan</h3><p>The final thing we need to do is drop the hardcoded <code>314</code> we returned
from <code>getnextslot</code> and instead we need to look up the current table
and return rows from it. This also means we need to keep track of
which row we&#39;re on. So <code>beginscan</code> will also need to change slightly.</p>
<div><pre><span></span><span>@@ -57,6 +56,14 @@</span>
<span> </span>  return &amp;TTSOpsVirtual;
<span> </span>}

<span>+</span>
<span>+struct MemScanDesc {</span>
<span>+  TableScanDescData rs_base; // Base class from access/relscan.h.</span>
<span>+</span>
<span>+  // Custom data.</span>
<span>+  uint32 cursor;</span>
<span>+};</span>
<span>+</span>
<span> </span>static TableScanDesc memam_beginscan(
<span> </span>  Relation relation,
<span> </span>  Snapshot snapshot,
<span>@@ -65,11 +72,13 @@</span>
<span> </span>  ParallelTableScanDesc parallel_scan,
<span> </span>  uint32 flags
<span> </span>) {
<span>-  TableScanDescData* scan = {};</span>
<span>-  DEBUG_FUNC();</span>
<span>+  struct MemScanDesc* scan;</span>

<span>-  scan = (TableScanDescData*)malloc(sizeof(TableScanDescData));</span>
<span>-  scan-&gt;rs_rd = relation;</span>
<span>+  DEBUG_FUNC();</span>
<span>+</span>
<span>+  scan = (struct MemScanDesc*)malloc(sizeof(struct MemScanDesc));</span>
<span>+  scan-&gt;rs_base.rs_rd = relation;</span>
<span>+  scan-&gt;cursor = 0;</span>

<span> </span>  return (TableScanDesc)scan;
<span> </span>}
<span>@@ -89,23 +97,26 @@</span>
<span> </span>  DEBUG_FUNC();
<span> </span>}

<span>-static bool done = false;</span>
<span> </span>static bool memam_getnextslot(
<span> </span>  TableScanDesc sscan,
<span> </span>  ScanDirection direction,
<span> </span>  TupleTableSlot *slot
<span> </span>) {
<span>+  struct MemScanDesc* mscan = (struct MemScanDesc*)sscan;</span>
<span>+  struct Table* table = NULL;</span>
<span> </span>  DEBUG_FUNC();

<span>-  if (done) {</span>
<span>+  ExecClearTuple(slot);</span>
<span>+</span>
<span>+  get_table(&amp;table, mscan-&gt;rs_base.rs_rd);</span>
<span>+  if (table == NULL || mscan-&gt;cursor == table-&gt;nrows) {</span>
<span> </span>    return false;
<span> </span>  }

<span>-  slot-&gt;tts_values[0] = Int32GetDatum(314 /* Some unique-looking value */);</span>
<span>+  slot-&gt;tts_values[0] = Int32GetDatum(table-&gt;rows[mscan-&gt;cursor].columns[0].value);</span>
<span> </span>  slot-&gt;tts_isnull[0] = false;
<span> </span>  ExecStoreVirtualTuple(slot);
<span>-  done = true;</span>
<span>-</span>
<span>+  mscan-&gt;cursor++;</span>
<span> </span>  return true;
<span> </span>}
</pre></div>
<p>Let&#39;s try it out.</p>
<div><pre><span></span><span>$ </span>make<span> </span><span>&amp;&amp;</span><span> </span>sudo<span> </span>make<span> </span>install
<span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to table x</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>INSERT 0 2</span>
<span>  a</span>
<span>-----</span>
<span>  23</span>
<span> 101</span>
<span>(2 rows)</span>
</pre></div>
<p>And there we have it. :)</p>
<h3 id="awesome-sql-power">Awesome SQL power</h3><p>So we tried one table and we tried a <code>SELECT</code> without anything else.</p>
<p>What happens if we use more of SQL? Let&#39;s create another table
and try some more complex queries. Edit <code>test.sql</code>:</p>
<div><pre><span></span><span>DROP</span><span> </span><span>EXTENSION</span><span> </span><span>IF</span><span> </span><span>EXISTS</span><span> </span><span>pgtam</span><span> </span><span>CASCADE</span><span>;</span>
<span>CREATE</span><span> </span><span>EXTENSION</span><span> </span><span>pgtam</span><span>;</span>
<span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>x</span><span>(</span><span>a</span><span> </span><span>INT</span><span>)</span><span> </span><span>USING</span><span> </span><span>mem</span><span>;</span>
<span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>y</span><span>(</span><span>b</span><span> </span><span>INT</span><span>)</span><span> </span><span>USING</span><span> </span><span>mem</span><span>;</span>
<span>INSERT</span><span> </span><span>INTO</span><span> </span><span>x</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>23</span><span>),</span><span> </span><span>(</span><span>101</span><span>);</span>
<span>SELECT</span><span> </span><span>a</span><span> </span><span>FROM</span><span> </span><span>x</span><span>;</span>
<span>SELECT</span><span> </span><span>a</span><span> </span><span>+</span><span> </span><span>100</span><span> </span><span>FROM</span><span> </span><span>x</span><span> </span><span>WHERE</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>23</span><span>;</span>
<span>SELECT</span><span> </span><span>a</span><span>,</span><span> </span><span>COUNT</span><span>(</span><span>1</span><span>)</span><span> </span><span>FROM</span><span> </span><span>x</span><span> </span><span>GROUP</span><span> </span><span>BY</span><span> </span><span>a</span><span> </span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>COUNT</span><span>(</span><span>1</span><span>)</span><span> </span><span>DESC</span><span>;</span>
<span>SELECT</span><span> </span><span>b</span><span> </span><span>FROM</span><span> </span><span>y</span><span>;</span>
</pre></div>
<p>Run it:</p>
<div><pre><span></span><span>$ </span>/usr/local/pgsql/bin/psql<span> </span>postgres<span> </span>-f<span> </span>test.sql
<span>psql:test.sql:1: NOTICE:  drop cascades to 2 other objects</span>
<span>DETAIL:  drop cascades to table x</span>
<span>drop cascades to table y</span>
<span>DROP EXTENSION</span>
<span>CREATE EXTENSION</span>
<span>CREATE TABLE</span>
<span>CREATE TABLE</span>
<span>INSERT 0 2</span>
<span>  a</span>
<span>-----</span>
<span>  23</span>
<span> 101</span>
<span>(2 rows)</span>

<span> ?column?</span>
<span>----------</span>
<span>      123</span>
<span>(1 row)</span>

<span>  a  | count</span>
<span>-----+-------</span>
<span>  23 |     1</span>
<span> 101 |     1</span>
<span>(2 rows)</span>

<span> b</span>
<span>---</span>
<span>(0 rows)</span>
</pre></div>
<p>Pretty sweet!</p>
<h3 id="next-steps">Next steps</h3><p>It would be neat to build a storage engine that reads from and writes
to a CSV a la MySQL&#39;s CSV storage engine. Or a storage engine that
uses RocksDB.</p>
<p>It would also be good to figure out how indexes work, how deletions
work, how updates and DDL beyond <code>CREATE</code> works.</p>
<p>And I should probably contribute some of this to the <a href="https://www.postgresql.org/docs/current/tableam.html">table access
method</a> docs
which are pretty sparse at the moment.</p>
<blockquote><p lang="en" dir="ltr">I&#39;ve been working this week to understand Postgres Table Access Methods for alternative storage engines.</p>— Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1719873793693221157?ref_src=twsrc%5Etfw">November 2, 2023</a></blockquote> 

	</div></div>
  </body>
</html>
