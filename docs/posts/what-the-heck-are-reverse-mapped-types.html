<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreasimonecosta.dev/posts/what-the-heck-are-reverse-mapped-types/">Original</a>
    <h1>What the heck are reverse mapped types?</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://andreasimonecosta.dev/images/reverse_mapped/copertina.jpeg" alt="Featured image"/></p><h2 id="introduction">Introduction
<a href="#introduction"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>Reverse mapped types are a powerful yet little-known feature of TypeScript that allow us to “run mapped types backward”. They are mainly a mechanism for inferring a function’s type parameters from values; however, the same inference steps can be performed at the type level using the <code>infer</code> keyword.</p><p>The purpose of this article is to serve as a comprehensive guide to reverse mapped types, explaining what they are and how they can be used to set interesting constraints on the values of a type and to provide useful context sensitive information. Various references to the compiler source code will be made in order to provide a deeper understanding of the topic.</p><h2 id="what-are-reverse-mapped-types">What are reverse mapped types?
<a href="#what-are-reverse-mapped-types"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>Let’s take a simple generic function like the following:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>function</span> foo&lt;<span>T</span>&gt;(a: <span>ReadonlyArray</span>&lt;<span>T</span>&gt;)<span>:</span> ReadonlyArray&lt;<span>T</span>&gt; {
</span></span><span><span>    <span>return</span> [...a]
</span></span><span><span>}
</span></span></code></pre></div><p>We are not surprised that TypeScript can infer the type <code>T</code> of the array elements from the argument passed to the function:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span>foo([<span>1</span>, <span>2</span>, <span>3</span>]); <span>// T = number
</span></span></span><span><span><span></span>
</span></span><span><span>foo([<span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>]); <span>// T = string
</span></span></span></code></pre></div><p>But what if we had a mapped type in place of <code>ReadonlyArray&lt;T&gt;</code>? Would TypeScript still be able to infer the type <code>T</code>? This is what we are referring to when we talk about inverting a mapped type.</p><h3 id="an-introductory-example">An introductory example
<a href="#an-introductory-example"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>Let’s kick things off with a simple example. Suppose we have the following type definitions:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>type</span> Box&lt;<span>T</span>&gt; <span>=</span> { 
</span></span><span><span>    value: <span>T</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>type</span> Unboxify&lt;<span>T</span> <span>extends</span> <span>Record</span>&lt;<span>string</span>, <span>Box</span>&lt;<span>any</span>&gt;<span>&gt;&gt;</span> <span>=</span> {
</span></span><span><span>    [K <span>in</span> <span>keyof</span> T]<span>:</span> T[K][<span>&#34;value&#34;</span>];
</span></span><span><span>}
</span></span></code></pre></div><p>Let’s write a function that takes a <code>Record&lt;string, Box&lt;any&gt;&gt;</code> and unwraps the <code>value</code> properties:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>function</span> unwrap&lt;<span>T</span> <span>extends</span> <span>Record</span>&lt;<span>string</span>, <span>Box</span>&lt;<span>any</span>&gt;<span>&gt;&gt;</span>(record: <span>T</span>)<span>:</span> Unboxify&lt;<span>T</span>&gt; {
</span></span><span><span>    <span>const</span> result <span>=</span> {} <span>as</span> Unboxify&lt;<span>T</span>&gt;
</span></span><span><span>    <span>for</span> (<span>const</span> key <span>in</span> record) {
</span></span><span><span>        result[key] <span>=</span> record[key].value
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> result
</span></span><span><span>}
</span></span></code></pre></div><p>What return type would we expect from the following function call?</p><div><pre tabindex="0"><code data-lang="typescript"><span><span>unwrap({
</span></span><span><span>    a<span>:</span> { value<span>:</span> <span>&#34;hi there&#34;</span> },
</span></span><span><span>    b<span>:</span> { value: <span>42</span> }
</span></span><span><span>})
</span></span></code></pre></div><p>We would expect <code>{ a: string, b: number }</code>, of course!</p><p>Reverse mapped types give us a different perspective on this kind of problems. We can simplify this situation by inverting the relationship between the return type and the parameter type: instead of manually deriving the return type from the parametric <code>record</code> type, we can work backward from the type of the actual parameter, letting the return type be the goal of the inference process.</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>type</span> Box&lt;<span>T</span>&gt; <span>=</span> { 
</span></span><span><span>    value: <span>T</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>type</span> BoxedRecord&lt;<span>T</span>&gt; <span>=</span> {
</span></span><span><span>    [K <span>in</span> <span>keyof</span> T]<span>:</span> Box&lt;<span>T</span>[<span>K</span>]&gt;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// note that the above mapped type is used in input position here
</span></span></span><span><span><span></span><span>function</span> unwrap&lt;<span>T</span>&gt;(record: <span>BoxedRecord</span>&lt;<span>T</span>&gt;)<span>:</span> T {
</span></span><span><span>    <span>const</span> result <span>=</span> {} <span>as</span> T
</span></span><span><span>    <span>for</span> (<span>const</span> key <span>in</span> record) {
</span></span><span><span>        result[key] <span>=</span> record[key].value
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> result
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>unwrap({
</span></span><span><span>    a<span>:</span> { value<span>:</span> <span>&#34;hi there&#34;</span> },
</span></span><span><span>    b<span>:</span> { value: <span>42</span> }
</span></span><span><span>})
</span></span></code></pre></div><p>The returned type is <code>{ a: string, b: number }</code> again because <a href="https://www.typescriptlang.org/play/?#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeUBQURUAbgIYA2ArhAFxQr4C+++oksiEAJgEoQBjOACduqDNhyFiAbQDSUAJYA7KAGsIIOADMGAXXrxkKeXrTNW2qsoHBFcVdYDuwsmHEAKYYJHdDXPh9RcQBKehRcaSIhZQBnYChvWKoKBMkmKDJYhiiobREoDxj49U0lVW8hURDI4jrEiGTUmQ0QPSwGqu4WzT0AOnJqCFyWOu9gKmEKxpTgC3xihKSO51cwDyk6sno8QZp6ACIAC0UoYCOIbwOoJgAaXIAjHdJKfagAFgAmG+YQ1iIkvgAPRAqAAPQA-NIgA" target="_blank" rel="noopener">TypeScript is able to infer the type <code>T</code> from the argument passed to the function</a>, but that’s not a given at all!</p><p>Why?</p><p>To do something like this, the compiler was able to answer the following question: for which type <code>T</code> do we have that <code>BoxedRecord&lt;T&gt;</code> is <code>{ a: { value: string }, b: { value: number } }</code>? We can mentally reverse the action of the mapped type: <code>a: { value: string }</code> implies that <code>T[K]</code> must be <code>string</code> when <code>K</code> is <code>&#39;a&#39;</code>, similarly <code>b: { value: number }</code> implies that <code>T[K]</code> must be <code>number</code> when <code>K</code> is <code>&#39;b&#39;</code>. The fact that TypeScript is able to achieve this too is simply amazing!</p><p>As I mentioned before <a href="https://www.typescriptlang.org/play/?ts=5.5.4#code/C4TwDgpgBAYg9nAPAFQHxQLxQN4CgoFQDaA0lAJYB2UA1hCHAGZTIC6AXDlAG4CGANgFcInZKVZQAvrmm5QkKACUI3CACcAzhHhI0mFlAgAPYBEoATDbASIqjdVACq6APxOonSivW454aKYawPrKqpraNthQvJxRfEIiUEFqVADmUgA0UABGsTwCwp6CALbZDpJSqLgA9NWEAHouQA" target="_blank" rel="noopener">this works at the type level too</a>, but the focus of this article is on the function’s type parameters inference. TypeScript is able to do this inversion for us in some cases, and in this article we will explore the potential, and the limits, of this feature.</p><h2 id="how-does-it-work">How does it work?
<a href="#how-does-it-work"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>The outline of the situation is more or less the following:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>type</span> MappedType&lt;<span>T</span>&gt; <span>=</span> {
</span></span><span><span>    [K <span>in</span> <span>keyof</span> T]<span>:</span> F&lt;<span>T</span>[<span>K</span>]&gt;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> foo&lt;<span>T</span> <span>extends</span> <span>C</span>&gt;(mt: <span>MappedType</span>&lt;<span>T</span>&gt;)<span>:</span> ...
</span></span><span><span>foo(x) <span>// T inferred from x
</span></span></span></code></pre></div><p>where the <strong>template</strong> <code>F&lt;T[K]&gt;</code> means that <code>T[K]</code> is used in some way there. This is very important because it’s gonna be used as inference site for the types of the keys while the compiler is trying to invert the action of the mapped type. In the template you can also use <code>K</code> alone to enforce particular constraints or to <a href="https://www.typescriptlang.org/play/?jsx=0&amp;exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/C4TwDgpgBAsgKgHjgPigXigbwLACgpQDaAClAJYB2UA1hCAPYBmUcAugFxQAUFAhgLYROxAJTpUAN3pkAJngC+Abjx4ZEAMYAbXgCdojAK4V1wMvSrAIAZ2DwkyLv2Cc7KEZzgrclm-C458KF4eAQgxTHkAGjwCAHpYqAA9AH4YqAAjEMFwqLT4pNTceREgA" target="_blank" rel="noopener">get context sensitive information</a>, but this is not enough to infer the types of the keys.</p><p>In broad terms, what happens is the following:</p><ol><li><p>If not already known, TypeScript infers the type of the argument <code>x</code> passed to the function <code>foo</code>. This type is internally named as <strong>source</strong>.</p></li><li><p>TypeScript does its best to invert the action of the <code>MappedType</code> mapped type starting from the source type to determine what <code>T</code> is. In particular, each key of <code>T</code> will be inferred independently from the others by exploiting the template <code>F&lt;T[K]&gt;</code>. Each standalone inference is not special in itself; for each key <code>K</code> of the source object, <code>T[K]</code> becomes the inference target, and its inference is scoped to that particular key. However, since the type inference for each key is separate from the others, it’s like having defined a variable length list of type parameters, one for each key of <code>T</code>. If the inference of a single key fails, the resulting type for that key will be <code>unknown</code>, while the other keys will not be affected by the failure.</p></li><li><p>TypeScript checks that the just inferred type <code>T</code> is indeed assignable to its constraint <code>C</code>. If that is not the case, <code>T</code> will become the constraint itself, discarding whatever was inferred before. This is the default behaviour of the <code>getInferredType</code> internal function and it applies to any function call, but it could lead to some unexpected results in this situation.</p></li><li><p>TypeScript now applies the mapped type <code>MappedType</code> to whatever <code>T</code> has become at this point, to determine the type of the formal parameter <code>mt</code>.</p></li><li><p>TypeScript checks if the type of the argument <code>x</code> is assignable to the type of the formal parameter <code>mt</code>, erroring if that is not the case.</p></li></ol><h2 id="the-sources-requirements">The source’s requirements
<a href="#the-sources-requirements"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>Which are the requirements that the source type must satisfy in order to be reverse mappable? A couple of comments in the TypeScript source code give us the answer:</p><blockquote><p>We consider a source type reverse mappable if it has a string index signature or if it has one or more properties and is of a <strong>partially inferable type</strong>.</p><p>We consider a type to be <strong>partially inferable</strong> if it isn’t marked non-inferable or if it is an object literal type with at least one property of an inferable type. For example, an object literal <code>{ a: 123, b: x =&gt; true }</code> is marked non-inferable because it contains a context sensitive arrow function, but is considered partially inferable because property <code>&#39;a&#39;</code> has an inferable type.</p></blockquote><p>The fact that partially inferable types are allowed is very important, because this means that reverse mapped types are able to provide context sensitive information back to the source type:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>type</span> ContextSensitive&lt;<span>T</span>&gt; <span>=</span> {
</span></span><span><span>    [K <span>in</span> <span>keyof</span> T]<span>:</span> { v: <span>T</span>[K], f<span>:</span> (_: <span>T</span>[K]) <span>=&gt;</span> <span>void</span> }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> useCS&lt;<span>T</span>&gt;(cs: <span>ContextSensitive</span>&lt;<span>T</span>&gt;)<span>:</span> <span>void</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>useCS({
</span></span><span><span>  num<span>:</span> { v: <span>42</span>, f<span>:</span> (n) <span>=&gt;</span> n <span>*</span> <span>10</span> },
</span></span><span><span>                 <span>// ^? n: number
</span></span></span><span><span><span></span>  str<span>:</span> { v<span>:</span> <span>&#34;hi there&#34;</span>, f<span>:</span> (s) <span>=&gt;</span> s.repeat(<span>3</span>) }
</span></span><span><span>                         <span>// ^? s: string
</span></span></span><span><span><span></span>})
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.5.4&amp;ssl=13&amp;ssc=3&amp;pln=1&amp;pc=1#code/C4TwDgpgBAwg9gO2BAHsAyhBBnAlsXANwgB4AVAPigF4oBvAKCmagG0BpKXBKAawhBwAZlDIBdAFz0ohKWQ5iANFCFSAFAH05CgJQ0qhOLgAmUAL4MLDYxADGAGwCGAJ2hCArglsFEUd9ggYdHIKNVtsKXgkVAwsPAJiEJ0pQxMGdP9A9DVGZgR3AFspOhkpABYAJmVVKDUEPWoqHgAqKABGAAZzRSYWPv6+gHpBqAA9AH5e7GBnYtKoACIAC1woYCWIVwXq9WwGqmwAOldIR2A1AGY9CwHbu6GRicsdIA" target="_blank" rel="noopener">Playground</a>.</p><p>In the example above we use <code>T[K]</code> both as type for the property <code>&#39;v&#39;</code> and as type for the parameter of the function <code>&#39;f&#39;</code>. TypeScript is able to infer that <code>T</code> is <code>{ num: number, str: string }</code> from the partially inferable argument passed to <code>useCS</code> by using the type of the property <code>&#39;v&#39;</code> only. When the fifth of the previous points comes into play, some context sensitive information is provided back from <code>ContextSensitive&lt;{ num: number, str: string }&gt;</code> to the source: the type of the parameters of the functions <code>&#39;f&#39;</code>.</p><h2 id="the-mapped-types-requirements">The mapped type’s requirements
<a href="#the-mapped-types-requirements"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>What about the requirements that the mapped type must satisfy? As for now, the <code>inferFromObjectTypes</code> internal function set an interesting one:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>if</span> (getObjectFlags(target) <span>&amp;</span> ObjectFlags.Mapped <span>&amp;&amp;</span> <span>!</span>(target <span>as</span> MappedType).declaration.nameType) {
</span></span><span><span>    <span>const</span> constraintType <span>=</span> getConstraintTypeFromMappedType(target <span>as</span> MappedType);
</span></span><span><span>    <span>if</span> (inferToMappedType(source, target <span>as</span> MappedType, constraintType)) {
</span></span><span><span>        <span>return</span>;
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>The point is that there should not be any <code>nameType</code>, and that means no <code>as</code> clause in the mapped type. This is a limitation that <a href="https://github.com/microsoft/TypeScript/pull/52972" target="_blank" rel="noopener">could be removed in the future</a>, but for now it is what it is.</p><p>Let’s dig into the <code>inferToMappedType</code> internal function now. From the code we see that TypeScript is able to reverse four kinds of mapped types:</p><ol><li>homomorphic mapped types like <code>{ [P in keyof T]: X }</code></li><li>mapped types like <code>{ [P in K]: X }</code>, where the <strong>constraint</strong> <code>K</code> is a type parameter</li><li>mapped types like <code>{ [P in A | B]: X }</code> where the constraint is an union, useful when the union contains a constraint similar to the one in <code>1</code> or <code>2</code></li><li>mapped types like <code>{ [P in A &amp; B]: X }</code> where the costraint is an intersection, useful when the intersection contains a constraint similar to the one in <code>1</code> or <code>2</code></li></ol><p>We will explore how the union constraint ensures the presence of certain properties, while the intersection constraint prevents the presence of additional properties.</p><p>Let’s dig into each of these cases.</p><h3 id="homomorphic-mapped-types">Homomorphic mapped types
<a href="#homomorphic-mapped-types"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>I wrote about homomorphic mapped types in a <a href="https://andreasimonecosta.dev/posts/what-the-heck-is-a-homomorphic-mapped-type/">previous article</a>, so take a look if you’re unfamiliar with them.</p><p>The source code says:</p><blockquote><p>We’re inferring from some source type <code>S</code> to a homomorphic mapped type <code>{ [P in keyof T]: X }</code>, where <code>T</code> is a type variable. Use <code>inferTypeForHomomorphicMappedType</code> to infer a suitable source type and then make a secondary inference from that type to <code>T</code>.</p></blockquote><p>The reason behind the double inference pass is related to the priority of some inferences, but I have to admit this is a bit obscure to me. Feel free to take a look at the source code if you’re interested in this and let me know what you find out! The main point, however, is that TypeScript should be able to reverse them, as long as there is no <code>as</code> clause. Pun not intended.</p><h3 id="mapped-type-with-a-type-parameter-as-constraint">Mapped type with a type parameter as constraint
<a href="#mapped-type-with-a-type-parameter-as-constraint"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>This is a very interesting case. Suppose we have the following mapped type:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>type</span> MappedType&lt;<span>K</span> <span>extends</span> <span>PropertyKey</span>&gt; <span>=</span> {
</span></span><span><span>    [P <span>in</span> K]<span>:</span> <span>number</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> useMT&lt;<span>K</span> <span>extends</span> <span>PropertyKey</span>&gt;(mt: <span>MappedType</span>&lt;<span>K</span>&gt;)<span>:</span> K
</span></span><span><span>
</span></span><span><span>foo({
</span></span><span><span>  a: <span>42</span>,
</span></span><span><span>  b: <span>1234</span>
</span></span><span><span>})
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/C4TwDgpgBAsghmSATAKuCAeA0lCAPYCAOyQGcoAFAJwHtIrQsIQA+KAXigG8BYAKCiCoAbQpQAlkShYAugC4oRAK4BbAEYQq-AL79+SCAGMANnCrQAZkqKHg4mlKWkIMFNlwFiZSrXqNmLAAUKsAK8IgQqOjYLACUClh6fIYOpMBQ5uScTi4ogbwCUHAKACwATAA0-IJqCgCMZQDMJTqxSYKZ-AD0XVAAegD8QA" target="_blank" rel="noopener">Playground</a>.</p><p>We have that <code>K</code> gets successfully inferred as <code>&#39;a&#39; | &#39;b&#39;</code>. How? The source code answers this question:</p><blockquote><p>We’re inferring from some source type <code>S</code> to a mapped type <code>{ [P in K]: X }</code>, where <code>K</code> is a type parameter. First infer from <code>keyof S</code> to <code>K</code>.</p></blockquote><p>That’s exactly what TypeScript did: it inferred from <code>keyof { a: number, b: number }</code>, that is <code>&#39;a&#39; | &#39;b&#39;</code>, to <code>K</code>.</p><p>But TypeScript’s capabilities don’t stop here. Suppose we have the following mapped type that resembles the <code>Pick</code> one:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>// a custom version of the built-in Pick type
</span></span></span><span><span><span></span><span>type</span> MyPick&lt;<span>T</span>, <span>K</span> <span>extends</span> <span>keyof</span> <span>T</span>&gt; <span>=</span> {
</span></span><span><span>  [P <span>in</span> K]<span>:</span> { value: <span>T</span>[P] };
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// a function that takes a MyPick&lt;T, K&gt; and returns a Pick&lt;T, SK&gt;
</span></span></span><span><span><span>// where SK is a subset of K
</span></span></span><span><span><span></span><span>declare</span> <span>function</span> unpick<span>&lt;</span>
</span></span><span><span>  T,
</span></span><span><span>  K <span>extends</span> <span>keyof</span> T,
</span></span><span><span>  SK <span>extends</span> K,
</span></span><span><span><span>&gt;</span>(t: <span>MyPick</span>&lt;<span>T</span>, <span>K</span>&gt;, keys: <span>SK</span>[])<span>:</span> Pick&lt;<span>T</span>, <span>SK</span>&gt;;
</span></span><span><span>
</span></span><span><span>unpick({
</span></span><span><span>  a<span>:</span> { value: <span>42</span> },
</span></span><span><span>  b<span>:</span> { value: <span>false</span> },
</span></span><span><span>}, [<span>&#34;a&#34;</span>]);
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/C4TwDgpgBAsiAKBLAxgawDwBUA0UDSUEAHsBAHYAmAzlKhCAPYBmUmAfFALxQDeAsACgoUANrwoiMvgC6ALl5QAbgEMANgFcI8zGOlQAvgG5B+wYIoRkq5QCdoTdWWTBEDKY7AoMg4Th-5CEnJqWnpmVmx-AGUCYlJKGjxIgTYACmB5OCQ0LFw8Nlw6ECp5GJFpAEp5bIwcKBi2YwFBZDcqYCg7Gm4PL1T+IShleR4lNU15ABYAJgNk4QAjEbGNLSgmNSpofWSd0QAiZX3Kpv8upoB6C6gAPQB+IA" target="_blank" rel="noopener">Playground</a>.</p><p>We have that <code>T</code> gets inferred as <code>{ a: number, b: boolean }</code> and <code>K</code> gets inferred as <code>&#39;a&#39; | &#39;b&#39;</code>. As before, <code>K</code> is inferred from <code>keyof { a: number, b: boolean }</code>, that is <code>&#39;a&#39; | &#39;b&#39;</code>. But what about <code>T</code>? Let’s again refer to the source code:</p><blockquote><p>If <code>K</code> (the one in <code>{ [P in K]: X }</code>) is constrained to a type <code>C</code>, also infer to <code>C</code>. Thus, for a mapped type <code>{ [P in K]: X }</code>, where <code>K</code> extends <code>keyof T</code>, we make the same inferences as for a homomorphic mapped type <code>{ [P in keyof T]: X }</code>.</p></blockquote><p>We see indeed that <code>inferToMappedType</code> is called recursively in this case:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>const</span> extendedConstraint <span>=</span> getConstraintOfType(constraintType);
</span></span><span><span><span>if</span> (extendedConstraint <span>&amp;&amp;</span> inferToMappedType(source, target, extendedConstraint)) {
</span></span><span><span>    <span>return</span> <span>true</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>If no inferences can be made to <code>K</code>’s constraint, TypeScript will infer from a union of the property types in the source to the template type <code>X</code>. The following example shows this:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>type</span> MappedType&lt;<span>K</span> <span>extends</span> <span>PropertyKey</span>, <span>X</span>&gt; <span>=</span> {
</span></span><span><span>    [P <span>in</span> K]<span>:</span> X
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> useMT&lt;<span>K</span> <span>extends</span> <span>PropertyKey</span>, <span>X</span>&gt;(mt: <span>MappedType</span>&lt;<span>K</span>, <span>X</span>&gt;)<span>:</span> [K, X]
</span></span><span><span>
</span></span><span><span>useMT({
</span></span><span><span>  a<span>:</span> [<span>&#34;a&#34;</span>, <span>&#34;a-prop&#34;</span>],
</span></span><span><span>  b: <span>false</span>
</span></span><span><span>})
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/C4TwDgpgBAsghmSATAKuCAeA0lCAPYCAOyQGcoAFAJwHtIrQsIQAaKADQD4oBeKAbwCwAKChioAbQpQAlkShYAugC4OIgL4iRSCAGMANnCrQAZgFciu4DJryzpCDBTZcBYmUq16jZmy4AKAFtgVXhECFR0bD9OAEpVCSw-RS1hXVtSYChjcj57RxR-IVEoOASAIjhytkqAWjAvcsUWETEAI1UTOH0HDVjUsRyRAHphqAA9AH4gA" target="_blank" rel="noopener">Playground</a>.</p><p>We have that <code>K</code> gets inferred as <code>&#39;a&#39; | &#39;b&#39;</code> as before, wherease <code>X</code> gets inferred as <code>boolean | string[]</code>.</p><h3 id="union-as-constraint">Union as constraint
<a href="#union-as-constraint"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>Let’s consider the following mapped type:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>type</span> MappedType&lt;<span>T</span>&gt; <span>=</span> {
</span></span><span><span>  [K <span>in</span> <span>keyof</span> T <span>|</span> <span>&#34;mustBePresent&#34;</span>]<span>:</span> {
</span></span><span><span>    <span>// cannot put just T[K] here, because K cannot be used to index T
</span></span></span><span><span><span></span>    <span>// i.e. there is no guarantee here that &#34;mustBePresent&#34; is a key of T
</span></span></span><span><span><span></span>    value: <span>K</span> <span>extends</span> <span>&#34;mustBePresent&#34;</span> <span>?</span> <span>unknown</span> <span>:</span> K <span>extends</span> <span>keyof</span> T <span>?</span> T[K] <span>:</span> <span>never</span>;
</span></span><span><span>  };
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> unmap&lt;<span>T</span>&gt;(t: <span>MappedType</span>&lt;<span>T</span>&gt;)<span>:</span> T;
</span></span><span><span>
</span></span><span><span><span>const</span> res <span>=</span> unmap({
</span></span><span><span>  a<span>:</span> { value<span>:</span> <span>&#34;andrea&#34;</span> },
</span></span><span><span>  b<span>:</span> { value<span>:</span> <span>&#34;simone&#34;</span> },
</span></span><span><span>  c<span>:</span> { value<span>:</span> <span>&#34;costa&#34;</span> },
</span></span><span><span>  mustBePresent<span>:</span> { value: <span>123</span> },
</span></span><span><span>});
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/C4TwDgpgBAsghmSATAKuCAeFA+KBeKAbwFgAoKKAbQGkoBLAOygGsIQB7AMyhSgB8oAIgC2AVwDOwAEIQACgCcI4iA2CCAugC4iZChQD0+qAGM4DBu2BQwoqwCsJVlDXVQAFhEUAaKACMIphLQtKbmln7QQUhQwOz0DEgQAB48unqG9AB0EJkxHor04lAWUADmonDyZsAQ0PnQwG5wViKOMgpKKmqFUHAsbFBcqeR6AG5wADaiENq0yTUJRa2S7YrKqoJQAPxQogzMFgDuTLNQ8ypIRawc3Lw7ztSu2gwQo54A3GkAvp+kP2RkRLGCaVaCcPbGYB0dhMPbCBBYbAACmA2ngiAgqHQiIAlNoUL8yMYYZIoGt8LsGPCwEiSCM4NpCFBxlMZkIzEhFHBNl8vGlfIzmZNptpBOI6MIYRAeXyRsZBSyRUJiZJuVBeWkxCs5GsugrhWyAIwAJgAzOrZV8cYSRmtfhkAHpbIA" target="_blank" rel="noopener">Playground</a>.</p><p>We have that <code>T</code> gets inferred as <code>{ a: string, c: string, c: string, mustBePresent: number }</code>. In few words, TypeScript loops through the union’s entries, finds the <code>keyof T</code> and reverses the whole source type as we saw before.</p><p>This example shows us that reverse mapped types could be useful not only because of their reversing capabilities, but also because they can enforce some properties in the source type. Had we omitted the <code>&#39;mustBePresent&#39;</code> field, TypeScript would have inferred <code>T</code> as <code>{ a: string, b: string, c: string }</code>, but when <code>MappedType</code> is applied to it to get the type of the formal parameter <code>t</code>, the resulting type would have been <code>{ a: { value: string }, c: { value: string }, x: { value: string }, mustBePresent: { value: unknown } }</code>. This would have caused an error, because the source type would not have been assignable to the formal parameter type: <em>Property ‘mustBePresent’ is missing in type ‘{ a: { value: string; }; b: { value: string; }; c: { value: string; }; }’ but required in type ‘MappedType&lt;{ a: string; b: string; c: string; }&gt;’</em>.</p><h3 id="intersection-as-constraint">Intersection as constraint
<a href="#intersection-as-constraint"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>From the version <code>5.4</code> of the compiler, TypeScript is able to reverse mapped types <a href="https://github.com/microsoft/TypeScript/pull/55811" target="_blank" rel="noopener">with an intersection constraint</a>. This is a very interesting feature, because it allows us to prevents the presence of additional properties while inferring a type. In other words, this provides us with the ability to enable EPC (Excess Property Checking) on type parameters inference sites.</p><p>Let’s consider the following example:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>interface</span> Foo {
</span></span><span><span>  bar: <span>number</span>;
</span></span><span><span>  baz: <span>string</span>;
</span></span><span><span>  record: <span>Record</span>&lt;<span>any</span>, <span>any</span>&gt;;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>type</span> MappedType&lt;<span>T</span>&gt; <span>=</span> {
</span></span><span><span>  <span>// the intersection constraint on K is keyof T &amp; keyof Foo
</span></span></span><span><span><span></span>  [K <span>in</span> <span>keyof</span> T <span>&amp;</span> <span>keyof</span> Foo]<span>:</span> T[K]
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> useFoo&lt;<span>T</span> <span>extends</span> <span>Foo</span>&gt;(foo: <span>MappedType</span>&lt;<span>T</span>&gt; )<span>:</span> T
</span></span><span><span>
</span></span><span><span>useFoo({ 
</span></span><span><span>  bar: <span>1</span>,
</span></span><span><span>  baz<span>:</span> <span>&#39;a&#39;</span>,
</span></span><span><span>  record<span>:</span> { a: <span>1</span>, b: <span>2</span> },
</span></span><span><span>  extra: <span>123</span>, <span>// &lt;-- EPC error
</span></span></span><span><span><span></span>})
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/JYOwLgpgTgZghgYwgAgGIHt3IN4FgBQyyARnFAFzIgCuAtsdANwFGkBelAzmFKAObNCyKBATooAE0oAlUeIkAeOCACeAGmTKVAPkEBfAgTAqADigCycE2YkAVUxAW3tyALw4WyAPRfkYABYooJBQnKJgwOggyGIg3FBwwchRyADSyMCcyADWECroMMi2yABkOXkFaJieANrpoOX5hcVluU1V6AC6lLZ1nQQG+AQSogA2ZCgw1CAIESnUYRjoTsgQAB6QIBJZS9oAFDCYlJbWEHYOTi4AlD2G+LHcwhBZ7gsQS3vYyJ6kFMgAjGofnAOMgAORwMFAoQiMSSShfOCUQEkSgAJmQemhRHWPCRALRAGYND5kAoALTk5AAUQACgBhVZQKDiAZXO5EEScQSkgB6AH4gA" target="_blank" rel="noopener">Playground</a>.</p><p>TypeScript loops through the intersection’s entries, finds the <code>keyof T</code> and reverses the whole source type as we saw before. The intersection constraint ensures that the source type has only the properties that are present in <code>Foo</code>, and this is why the presence of the <code>&#39;extra&#39;</code> property causes an excess property error. It’s worth noting that the <code>&#39;extra&#39;</code> property is stripped away from the inferred <code>T</code> because it wouldn’t survive the action of the mapped type anyway.</p><p>In this way you get both inference and EPC!</p><h2 id="arrays-and-tuples">Arrays and tuples
<a href="#arrays-and-tuples"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>We said that reverse mapping gets applied to the type of each property of an object type independently from the others. What if we have an array or a tuple? A comment inside the <code>createReverseMappedType</code> internal function says that:</p><blockquote><p>For arrays and tuples we infer new arrays and tuples where the reverse mapping has been applied to the element type(s).</p></blockquote><p>One example to rule them all:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>// just removes the &#39;on&#39; prefix from the event names
</span></span></span><span><span><span></span><span>type</span> PossibleEventType&lt;<span>K</span>&gt; <span>=</span> K <span>extends</span> <span>`on</span><span>${</span><span>infer</span> Type<span>}</span><span>`</span> <span>?</span> Type : <span>never</span>;
</span></span><span><span>
</span></span><span><span><span>type</span> TypeListener&lt;<span>T</span> <span>extends</span> <span>ReadonlyArray</span>&lt;<span>string</span>&gt;<span>&gt;</span> <span>=</span> {
</span></span><span><span>  [I <span>in</span> <span>keyof</span> T]<span>:</span> {
</span></span><span><span>    <span>type</span><span>:</span> T[I];
</span></span><span><span>    listener<span>:</span> (ev: <span>T</span>[I]) <span>=&gt;</span> <span>void</span>;
</span></span><span><span>  };
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> bindAll<span>&lt;</span>
</span></span><span><span>  T <span>extends</span> HTMLElement,
</span></span><span><span>  Types <span>extends</span> ReadonlyArray&lt;<span>PossibleEventType</span>&lt;<span>keyof</span> <span>T</span>&gt;<span>&gt;</span>
</span></span><span><span><span>&gt;</span>(target: <span>T</span>, listeners: <span>TypeListener</span>&lt;<span>Types</span>&gt;)<span>:</span> <span>void</span>;
</span></span><span><span>
</span></span><span><span><span>// {} as a fake HTMLInputElement
</span></span></span><span><span><span></span>bindAll({} <span>as</span> HTMLInputElement, [
</span></span><span><span>  {
</span></span><span><span>    <span>type</span><span>:</span> <span>&#34;blur&#34;</span>,
</span></span><span><span>    listener<span>:</span> (ev) <span>=&gt;</span> {
</span></span><span><span>            <span>// ^? ev: &#34;blur&#34;
</span></span></span><span><span><span></span>    }
</span></span><span><span>  },
</span></span><span><span>  {
</span></span><span><span>    <span>type</span><span>:</span> <span>&#34;click&#34;</span>,
</span></span><span><span>    listener<span>:</span> (ev) <span>=&gt;</span> {
</span></span><span><span>            <span>// ^? ev: &#34;click&#34;
</span></span></span><span><span><span></span>    }
</span></span><span><span>  },
</span></span><span><span>]);
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/C4TwDgpgBACg9gZwQSwEYBsIFEBuEB2wAKuBADwDSAfFALxQVQQAewBAJglAAZz4AkAb2T4AZhABOUEpAC+3KAH5ppKAC4o+CHgkBuALAAoI6EgrIAGWQI2WiWSJNWHLgCUIAQ3Z90IAIISEh4gZDYSIgDmVDT0gkZQUADaAJJQIlAA1hAgcKLSALoacYYJCaYQGkQp+QYlpejWtpIaABTaldUAlHQ0OHDI7LUJsrUjRkbsEADG6B4S0KIArvhTwMh8UKgi7H7o6GTx0k62nFAAEkQAshZYmAC2BMAANIcyEFwsJ26e3vi+AUEQvAkGhMLhHm8yFkcnkiNEjFQWsA5hEIMBKk8oA0bARJAhKqQrDi7A5SAgqJ0NH0BrUjAB6OlQQSyKBTOAPKCiETAOBMPCEOBGLb4HZ7FrMqAeLgXa7JfBgRbAW4QB6ETGJQ7FUpQcoaABEGEWEj1LzqCWxTQkrW03VoNC12sdCQZUAAeopDsNDrJTQkHWVSPqZsgphkTZ6sY1cVaoG0cLb7RGnc7Ge6I7Jvab8p1dEA" target="_blank" rel="noopener">Playground</a>.</p><p>Here we see that TypeScript is able to properly infer <code>Types</code> as the tuple type <code>[&#34;blur&#34;, &#34;click&#34;]</code> by reverting the type of the input array with respect to the <code>TypeListener</code> mapped type. TypeScript will then apply the <code>TypeListener</code> mapped type to it to determine the type of the formal parameter <code>listeners</code>, and that provides the partially inferable source type with the context sensitive information it needs to get the type of the <code>ev</code> parameters in the callbacks.</p><p>The inferred <code>Types</code> must satisfy its constraint too, i.e. it must be an array or a tuple of strings containing some event names belonging to the input <code>HTMLElement</code>, without the <code>&#39;on&#39;</code> prefix.</p><h2 id="enforcing-recursive-constraints-on-the-source-type">Enforcing recursive constraints on the source type
<a href="#enforcing-recursive-constraints-on-the-source-type"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>We saw that reverse mapped types can be used to enforce some constraints on the source type. The following example, borrowed from <a href="https://x.com/AndaristRake" target="_blank" rel="noopener">Mateusz Burzyński</a>, builds on this concept and shows that recursion may be allowed:</p><div><pre tabindex="0"><code data-lang="ts"><span><span><span>type</span> StateConfig&lt;<span>T</span>&gt; <span>=</span> {
</span></span><span><span>  initial?: <span>keyof</span> T;
</span></span><span><span>  states<span>?:</span> {
</span></span><span><span>    <span>// here is the mapped type
</span></span></span><span><span><span></span>    [K <span>in</span> <span>keyof</span> T]<span>:</span> StateConfig&lt;<span>T</span>[<span>K</span>]&gt; <span>&amp;</span> {
</span></span><span><span>      on?: <span>Record</span>&lt;<span>string</span>, <span>keyof</span> <span>T</span>&gt;;
</span></span><span><span>    };
</span></span><span><span>  };
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>declare</span> <span>function</span> createMachine&lt;<span>T</span>&gt;(config: <span>StateConfig</span>&lt;<span>T</span>&gt;)<span>:</span> T;
</span></span><span><span>
</span></span><span><span>createMachine({
</span></span><span><span>  initial<span>:</span> <span>&#34;a&#34;</span>,
</span></span><span><span>  states<span>:</span> {
</span></span><span><span>    <span>// try to get rid of &#34;a&#34;
</span></span></span><span><span><span></span>    a<span>:</span> {
</span></span><span><span>      on<span>:</span> {
</span></span><span><span>        <span>// try to change &#34;a&#34; to something else
</span></span></span><span><span><span></span>        NEXT<span>:</span> <span>&#34;a&#34;</span>,
</span></span><span><span>      },
</span></span><span><span>    },
</span></span><span><span>    b<span>:</span> {
</span></span><span><span>      initial<span>:</span> <span>&#34;nested&#34;</span>,
</span></span><span><span>      on<span>:</span> {
</span></span><span><span>        NEXT<span>:</span> <span>&#34;b&#34;</span>,
</span></span><span><span>      },
</span></span><span><span>      states<span>:</span> {
</span></span><span><span>        nested<span>:</span> {
</span></span><span><span>          on<span>:</span> {
</span></span><span><span>            TEST<span>:</span> <span>&#34;nested&#34;</span>,
</span></span><span><span>          },
</span></span><span><span>        },
</span></span><span><span>      },
</span></span><span><span>    },
</span></span><span><span>  },
</span></span><span><span>});
</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true&amp;ts=5.5.4#code/C4TwDgpgBAysCGwIGED2A7AZgSwOYB4AVAPigF4oBvAWACgopt1tht4AbAfgC4oBrCCFSYohANx0GAZwRIpPKpIZQA2gGlG6foOGiAurziIUGHAULq9pAGSL6yhhgUAlCAGNUAJwAm+GZ6ZcABptIRESCXsGAF9ImMjYujpvd3Z4T2hMAFd0N1YMKDcM4wBZeDcACyYIImIACg8sPENZEybzYgBKXnEk2kaZKAypckLipDLK6rqaeyYWNnZeACJ4ZaClGWMpXlmHAHp9qGBPEGPUKFwIYCHsbyhdVeWlBnhdl+UMd6iHKEPj07nQoVeDoK5QJ5AqSoAC21yqYKgEHYUggHwcADkAKIADUIKzWGx+MSJDmipOUACNvr9NAsOCt0BAZBBvOt0Q90DTaVBsXiVpT2cSoOSOVs5NzaUyWd5JTyvnYeb9CFiYPiIdKkGyKUrRcKSRy9WSKXrop1IkphnR-gA9ThAA" target="_blank" rel="noopener">Playground</a>.</p><p>The inferred <code>T</code> type is a little bit ugly but it’s correct: <code>{ a: unknown, b: { nested: unknown } }</code>. Why are there those <code>unknown</code>? When any of the sub-fields of an arbitrary nested <code>&#39;states&#39;</code> field does not contain a <code>StateConfig</code>, there will be no candidate for <code>T[K]</code> and so TypeScript will resort to <code>unknown</code> for that sub-field.</p><p>Which constraints are we enforcing on the source type? At any level, the <code>&#39;initial&#39;</code> field must be a key of the object present in the <code>&#39;states&#39;</code> field at the same level. Furthermore, we can jump from one state to another only if both are defined at the same level.</p><h2 id="further-limitations">Further limitations
<a href="#further-limitations"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>It follows a list of limitations, by no means complete, that you should be aware of when using reverse mapped types, which I’m not discussing in detail here:</p><ul><li><a href="https://github.com/microsoft/TypeScript/issues/48798" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/issues/48798</a></li><li><a href="https://github.com/microsoft/TypeScript/issues/51612" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/issues/51612</a></li><li><a href="https://github.com/microsoft/TypeScript/pull/54029" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/pull/54029</a></li><li><a href="https://github.com/microsoft/TypeScript/issues/56910" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/issues/56910</a></li><li><a href="https://github.com/microsoft/TypeScript/issues/57788" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/issues/57788</a></li></ul><h2 id="conclusion">Conclusion
<a href="#conclusion"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>The very first time I’ve heard about reverse mapped types was on Xitter a couple of years ago, thanks to the already mentioned <a href="https://x.com/AndaristRake" target="_blank" rel="noopener">Mateusz</a>, whom I thank for the countless insights he gave me on the topic and for his extensive review of this article. TypeScript has the bad habit of having a lot of super useful and super interesting but undocumented advanced features and this is one of them. It’s not a coincidence that my primary reference for writing this article has been the compiler’s source code itself.</p><p>The only other resource on the topic that I can suggest is a talk by Mateusz at TypeScript Congress 2023, titled <a href="https://gitnation.com/contents/infer-multiple-things-at-once-with-reverse-mapped-types" target="_blank" rel="noopener">Infer multiple things at once with reverse mapped types</a>.</p><p>I want to thank <a href="https://x.com/ssalbdivad" target="_blank" rel="noopener">David Blass</a> too, who took the time to review the article and gave me some very useful feedback to clarify some points.</p><p>I hope that this article has been useful to you and that you have learned something new. If you have any questions or comments, feel free to reach out to me on <a href="https://x.com/jfet97" target="_blank" rel="noopener">Xitter</a>.</p></div></div>
  </body>
</html>
