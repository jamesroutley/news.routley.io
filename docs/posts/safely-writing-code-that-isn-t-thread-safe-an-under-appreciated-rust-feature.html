<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cliffle.com/blog/not-thread-safe/">Original</a>
    <h1>Safely writing code that isn&#39;t thread-safe: An under-appreciated Rust feature</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  <header>
    
    <p>An under-appreciated Rust feature</p>
  </header>
  
  <p><span>2022-11-22</span></p><ul>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#the-bank-account-example">The bank account example</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#when-threads-attack">When threads attack!</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#when-locks-attack">When locks attack!</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#head-in-the-sand-concurrency">Head-in-the-sand concurrency</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#the-bank-account-example-in-rust">The bank account example, in Rust.</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#the-engineering-marvel-of-sync-and-send">The engineering marvel of Sync (and Send)</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#the-joys-of-not-being-thread-safe">The joys of not being thread-safe</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#explicitly-opting-out-of-sync">Explicitly opting out of Sync</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#the-other-concurrency-trait-send-and-when-to-avoid-it">The other concurrency trait: Send and when to avoid it</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#conclusion">Conclusion</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#appendix-the-relationship-between-sync-and-send">Appendix: the relationship between Sync and Send</a>
        
        </li>
    
      <li><a href="http://cliffle.com/blog/not-thread-safe/#appendix-opting-back-in">Appendix: opting back in</a>
        
        </li>
    
  </ul>
  
  <p>One of the nice things about <a href="https://www.rust-lang.org/">the Rust programming language</a> is that it
makes it easier to write correct concurrent (e.g. threaded) programs – to the
degree that Rust’s slogan has been, at times, “fearless concurrency.”</p>
<p>But I’d like to tell you about the <em>other</em> side of Rust, which I think is
under-appreciated. Rust enables you to write programs that are <em>not</em> concurrent.
This feature is missing from most other languages, and is a source of much
complexity and bugs.</p>
<p>“But wait,” you might be saying, “of <em>course</em> I can write code that isn’t
concurrent in Java or Python or C!”</p>
<p><em>Can you,</em> though? You can certainly write code that <em>ignores</em> concurrency, and
would malfunction if (say) used from multiple threads simultaneously. But that’s
not the same thing as writing code that <em>isn’t</em> concurrent – code that simply
can’t be used concurrently, by compiler guarantee.</p>
<p>In Rust, you <em>can.</em> Let’s look at why you can do it, and why it’s awesome.</p>

<p>Here’s a very common example of a data structure that trips people up in the
presence of threads. It’s a model of a bank account.</p>
<p>I’ve written this in C for reasons that will become apparent later. Please never
use a <code>float</code> variable to store an amount of money, this is just an example.</p>
<pre data-lang="c"><code data-lang="c"><span>
<span><span>struct</span> <span><span>bank_account</span></span></span><span> <span><span>{</span></span></span><span><span>
    
    <span>float</span> balance<span>;</span>
</span></span><span><span><span>}</span></span></span><span>;</span>


<span>float</span> <span><span>deposit</span></span><span><span><span>(</span></span></span><span><span><span>struct</span> bank_account <span>*</span><span>account</span><span>,</span> <span>float</span> <span>amt</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
    account<span>-&gt;</span>balance <span>+=</span> amt<span>;</span>
    <span>return</span> account<span>-&gt;</span>balance<span>;</span>
</span></span><span><span><span>}</span></span></span>


<span>bool</span> <span><span>withdraw</span></span><span><span><span>(</span></span></span><span><span><span>struct</span> bank_account <span>*</span><span>account</span><span>,</span> <span>float</span> <span>amt</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
    <span>if</span> <span><span>(</span>account<span>-&gt;</span>balance <span>&gt;=</span> amt<span>)</span></span> <span><span>{</span>
        account<span>-&gt;</span>balance <span>-=</span> amt<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span></span> <span>else</span> <span><span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span></span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>This is just about the simplest way you could write this in C – it would look
very similar in Java. Those of you with thread-related scars have probably
already noticed the issue: in the presence of concurrency, the bank account
update operations <code>deposit</code> and <code>withdraw</code> are not necessarily atomic.</p>
<p>This means that, if two threads are accessing the same account, you could end up
with the following interleaving of operations:</p>
<ul>
<li>Thread A: begins depositing <code>100</code>.</li>
<li>Thread B: begins withdrawing <code>100</code>.</li>
<li>Thread A: reads current account balance to increment it, let’s say it started out at <code>100</code>.</li>
<li>Thread B: also reads current account balance, and decrements it. Why did
Thread B get to do a larger chunk of work here? Who can say? Maybe the
computer is mad at you.</li>
<li>Thread A: stores the balance after the deposit: <code>200</code>.</li>
</ul>
<p>Thread B thinks it successfully withdrew <code>100</code> moneys, while Thread A thinks it
successfully deposited <code>100</code> moneys, which should leave the account balance
unchanged… but it actually increased by <code>100</code> moneys. This is certainly not
what the bank wants – and it’s also not what we, the programmers, intended!</p>

<p>The bank account code was not written to be used concurrently. If it had been,
it would have been written differently. But nothing <em>prevents</em> someone from
using that code in a larger program with threads. This means that the code can
be the victim of <em>nonconsensual concurrency.</em></p>
<p>Nonconsensual concurrency is when your code has concurrency forced upon it.
Nevermind that the code was not written with threads or other concurrency in
mind – you’re getting threads whether you like it or not!</p>
<p>This sounds unpleasant, but unfortunately it’s very common. In my experience,
it’s the main way programmers learn about data races and other
concurrency-related bugs in the first place: the hard way. By noticing (or,
worse, having someone else notice!) that their code is misbehaving. The past
several decades have been a story of one layer after another being used from
threads without being designed for it, getting bitten by the bugs, making the
repairs, and repeating – starting from the fundamental <code>libc</code> and friends and
working up.</p>
<p>The awful thing about nonconsensual concurrency – other than the part where it
removes your agency as programmer, of course – is that it tends to be fixed in
a hurry, after the fact. If you’ve got an existing chunk of code that <em>worked
fine</em> before those darned threads showed up, you’re not likely to sit down and
redesign all your data structures and algorithms from scratch to use fancy
lock-free high-concurrency alternatives. No, if you’re anything like most
programmers (myself included) you’re more likely to just slap some locks on
things and hope it starts working again.</p>
<p>And in a lot of ways, this is a reasonable response! We’ve all got deadlines and
other stuff to do, and it’s not like we <em>invited</em> that bozo over there to start
using threads in our code. We know “slap a big lock on it” will work because
it’s been done a gazillion times.</p>
<p>Right?</p>

<p>As attractive as “hit it with a lock” may be, there are some issues.</p>
<ol>
<li>
<p><strong>Scope.</strong> It’s very important to make sure that all fields being guarded by
a lock are <em>only</em> accessed with the lock held. If any accesses happen without
coordinating through the lock, then you haven’t fixed the bug, only made it
harder to find. This mistake is very easy to make when
<em>retrofitting</em> locks onto library code, like when defending against
nonconsensual concurrency.</p>
</li>
<li>
<p><strong>Granularity.</strong> Locking and unlocking are not free. For best performance
using locks, it’s important that the code do as much work as possible with
the lock held, rather than repeatedly locking and unlocking it. This also
means that nesting components that each have their own lock won’t be great
either, since you’ll have to lock a series of locks on the way in, and then
unlock them all on the way out.</p>
</li>
<li>
<p><strong>Liveness.</strong> While a lock is locked, no other thread can get to the chunks
of code/data it protects – that’s what it’s for. However, this can also
bottleneck a program. Imagine that we protect <em>all</em> accounts at the bank with
a single lock. Now, no matter how many CPUs you put in your fancy bank
computer, you’re only ever going to be processing one account operation at a
time, leaving most of those CPUs idle! (Does it sound like this is in direct
conflict with the Granularity point above? That’s because it is!)</p>
</li>
<li>
<p><strong>Built-in overhead.</strong> Because locks are not free, your code is going to
take some performance hit for using them. If your users <em>are not</em> using your
code from multiple threads, this is simply a waste.</p>
</li>
</ol>

<p>Those points hold across basically all mainstream programming languages, but
there’s another one that is more subtle: <em>assuming a concurrency scheme.</em></p>
<ul>
<li>
<p>Mutexes (a common option for the type of lock used here) tend to require
operating system support. Using an OS-specific version like <code>pthread_mutex</code>
will prevent your code from running on other operating systems. And using
<em>any</em> flavor will restrict your code to running on <em>an operating system that
provides mutexes</em> – meaning that your code likely can’t be used in embedded
contexts or inside the implementation of an OS kernel. (For our bank account
example, that may be less of a concern, unless you’re writing some kind of
BankOS I guess.)</p>
</li>
<li>
<p>It is entirely possible to have concurrency without threads. You might have
noticed that I’m using both of those terms in this article; threads are the
most common form of concurrency that programmers encounter these days, but
there are other options. Basically all languages except C(++) have an <code>async</code>
mode that transforms code into state machines that can be interleaved on a
single thread of execution. In <code>async</code> mode, you generally need to be using a
<em>different</em> kind of lock to keep from blocking execution of other <code>async</code>
routines on the same thread. If a lock is unavailable, you want to switch to a
different <code>async</code> routine, not stop and wait!</p>
</li>
<li>
<p>Finally, while rare nowadays, it’s possible that your user doesn’t have
threads, or the equipment that comes along with threads, like mutexes. This is
most common in bare-metal embedded contexts, but is also true when developing
on <a href="https://hubris.oxide.computer/">Hubris</a>, where each task is isolated and deliberately single-threaded. If
you use a mutex in your code, you’ve prevented your code from being used in
these contexts.</p>
</li>
</ul>

<p>There’s another option, of course. If we’re concerned about the performance cost
of managing locks or using atomic data types, we could just <em>not.</em></p>
<p>This approach is quite common, particularly (in my experience) in C code. The C
standard library has a bunch of examples of this pattern for historical reasons.
Some of these functions are not only unsafe to use from threads, they may not
even work if you call them at two levels in a nested <code>for</code> loop, which sure
stretches the definition of “concurrency!” (<code>strtok</code> is a good example of this.)</p>
<p>On the one hand, we might be tempted to scoff at such API as a relic of our
pre-thread past. But I think that’s being too quick to judge – there are often
very good reasons for writing API that isn’t thread safe, starting with
simplicity. Our bank account example is so simple that a reader can easily
convince themselves that it’s correct…in the absence of concurrency.</p>
<p>No, I would argue that the problem with non-reentrant code in C is not that it’s
not reentrant – it’s that there is no way to <em>prevent it from being misused,</em>
in a recursive function or concurrent program.</p>
<p>No way other than this, of course:</p>
<pre data-lang="c"><code data-lang="c"><span>
</span></code></pre>
<p>Because of course everyone will read this comment and remember it!</p>
<p>As I put it in my <a href="http://cliffle.com/blog/rust-mutexes/">article on the Rust mutex type</a>: <strong>comments
are not a concurrency strategy.</strong></p>
<p>If only there was a way to keep our code simple, but make it hard to misuse…</p>

<p>Let’s revisit that bank account example, but this time, let’s do it in Rust:</p>
<pre data-lang="rust"><code data-lang="rust"><span>
<span><span>struct</span> </span><span><span>BankAccount</span> </span><span><span><span>{</span>
        <span>balance</span><span>:</span> <span>f32</span>,
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>deposit</span></span><span><span><span>(</span><span>account</span><span>:</span> <span>&amp;</span><span>mut</span> BankAccount, <span>amt</span><span>:</span> <span>f32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>f32</span></span> </span><span><span><span>{</span>
    account<span>.</span>balance <span>+=</span> amt<span>;</span>
    account<span>.</span>balance
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>withdraw</span></span><span><span><span>(</span><span>account</span><span>:</span> <span>&amp;</span><span>mut</span> BankAccount, <span>amt</span><span>:</span> <span>f32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
    <span>if</span> account<span>.</span>balance <span>&gt;=</span> amt <span><span>{</span>
        account<span>.</span>balance <span>-=</span> amt<span>;</span>
        <span>true</span>
    </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
        <span>false</span>
    </span><span><span>}</span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>This is the exact same code with the syntax changed to appease a different
compiler. It sure looks like it has the same bugs as the C version, doesn’t it?
For instance, <code>withdraw</code> is checking <code>account.balance</code> and then decrementing it,
which seems like it has the potential for a race!</p>
<p>However, note that making any changes to the account (as in <code>deposit</code> or
<code>withdraw</code>) requires an exclusive reference (<code>&amp;mut BankAccount</code>). Exclusive
references are unique in Rust. This means that a <code>BankAccount</code> <em>can’t</em> be
altered by two concurrent routines, because they can’t both hold an exclusive
reference.</p>
<p>In other words, when written the simple way, the bank account example in Rust
<em>does not</em> have a concurrency bug.</p>
<p>But let’s say that we want account modifications through a shared reference
(<code>&amp;BankAccount</code>) to work. This can be useful even without concurrency – maybe
we’ve found ourselves in a case where we need to share <code>BankAccount</code>s between
different data structures. The easiest way to make this work is with a <code>Cell</code> to
enable mutation through a shared reference:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>std<span>::</span></span><span>cell<span>::</span></span>Cell<span>;</span>

<span><span>struct</span> </span><span><span>BankAccount</span> </span><span><span><span>{</span>
    <span>balance</span><span>:</span> <span>Cell<span>&lt;</span><span>f32</span><span>&gt;</span></span>,
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>deposit</span></span><span><span><span>(</span><span>account</span><span>:</span> <span>&amp;</span>BankAccount, <span>amt</span><span>:</span> <span>f32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>f32</span></span> </span><span><span><span>{</span>
    <span>let</span> new_balance <span>=</span> account<span>.</span>balance<span>.</span><span>get</span><span><span>(</span></span><span><span>)</span></span> <span>+</span> amt<span>;</span>
    account<span>.</span>balance<span>.</span><span>set</span><span><span>(</span>new_balance</span><span><span>)</span></span><span>;</span>
    new_balance
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>withdraw</span></span><span><span><span>(</span><span>account</span><span>:</span> <span>&amp;</span><span>mut</span> BankAccount, <span>amt</span><span>:</span> <span>f32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
    <span>let</span> bal <span>=</span> account<span>.</span>balance<span>.</span><span>get</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>if</span> bal <span>&gt;=</span> amt <span><span>{</span>
        account<span>.</span>balance<span>.</span><span>set</span><span><span>(</span>bal <span>-</span> amt</span><span><span>)</span></span><span>;</span>
        <span>true</span>
    </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
        <span>false</span>
    </span><span><span>}</span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>Okay, surely <em>this</em> has a concurrency bug, right? In a way, <code>Cell</code> makes it
<em>more obvious</em> that these operations are not atomic! Look at <code>deposit</code>, where we
<code>get()</code> the old balance, do some work, and then <code>set()</code> it – what if two
threads do this simultaneously? Bug, right?</p>
<p>Let’s see if we can demonstrate the problem by spinning up two threads that
fight over the account (using <code>scoped</code> threads to do this conveniently):</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>std<span>::</span></span>thread<span>;</span>

<span><span><span>fn</span> </span><span>demonstrate_race_condition</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
    <span>let</span> account <span>=</span> BankAccount <span><span>{</span> balance<span>:</span> <span>Cell<span>::</span></span>new<span><span>(</span><span>100.</span></span><span><span>)</span></span> </span><span><span>}</span></span><span>;</span>
    
            <span>thread<span>::</span></span>scope<span><span>(</span><span><span><span>|</span></span></span><span><span><span>s</span><span>|</span></span> </span><span><span><span>{</span>
        s<span>.</span><span>spawn</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>|</span></span> </span><span><span><span>{</span>
            <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>1000</span> <span><span>{</span>
                <span>deposit</span><span><span>(</span><span>&amp;</span>account<span>,</span> <span>100.</span></span><span><span>)</span></span><span>;</span>
                <span>withdraw</span><span><span>(</span><span>&amp;</span>account<span>,</span> <span>100.</span></span><span><span>)</span></span><span>;</span>
            </span><span><span>}</span></span>
        </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
        s<span>.</span><span>spawn</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>|</span></span> </span><span><span><span>{</span>
            <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>1000</span> <span><span>{</span>
                <span>deposit</span><span><span>(</span><span>&amp;</span>account<span>,</span> <span>100.</span></span><span><span>)</span></span><span>;</span>
                <span>withdraw</span><span><span>(</span><span>&amp;</span>account<span>,</span> <span>100.</span></span><span><span>)</span></span><span>;</span>
            </span><span><span>}</span></span>
        </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>final balance is: <span>{}</span><span>&#34;</span></span></span><span><span>,</span> account<span>.</span>balance<span>.</span><span>get</span><span><span>(</span></span><span><span>)</span></span><span>)</span></span><span>;</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>That ought to do it!  Now when we run it, we will…</p>
<p>…huh. We can’t actually run it, because the compiler is upset.</p>
<pre data-lang="txt"><code data-lang="txt"><span>error[E0277]: `Cell&lt;f32&gt;` cannot be shared between threads safely
  --&gt; src/lib.rs:33:11
   |
33 |         s.spawn(|_| {
   |           ^^^^^ `Cell&lt;f32&gt;` cannot be shared between
   |                  threads safely
   |
   = help: within `BankAccount`, the trait `Sync` is not implemented
     for `Cell&lt;f32&gt;`
     note: required because it appears within the type `BankAccount`

  --&gt; src/lib.rs:5:8
   |
5  | struct BankAccount {
   |        ^^^^^^^^^^^
   = note: required because of the requirements on the impl of `Send`
     for `&amp;BankAccount`
   = note: required because it appears within the type
     `[closure@src/lib.rs:33:17: 38:10]`
</span></code></pre>
<p>What the compiler is saying is that, while we have successfully altered
<code>deposit</code> and <code>withdraw</code> to operate on shared references, we still can’t
actually use the <code>BankAccount</code> type from multiple threads (<code>cannot be shared between threads safely</code>). It seems to be related to our use of <code>Cell</code>.</p>
<p>This is important. </p>

<p>This is the under-appreciated Rust feature I’ve been alluding to.</p>
<p>Unlike most programming languages, where any data structure is assumed to be
safe to share across threads by default, Rust makes this part of the <em>type
system.</em> A value is safe to share across threads only if its type implements the
<code>Sync</code> trait.</p>
<p><code>Sync</code> is a <em>marker trait,</em> meaning that unlike traits like <code>Clone</code>, it doesn’t
define any operations you can perform on the type. It’s empty. Its declaration
would resemble (simplified):</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>pub</span> <span>trait</span> <span>Sync</span> <span><span>{</span></span><span><span>}</span></span></span>
</span></code></pre>
<p>It exists to serve as a <em>marker</em> for types that can be shared across threads.
Any type that does not carry this marker can’t be shared across threads.</p>
<p>This seems like a small thing, but it has big implications. </p>
<p>Rust assumes that any data structure whose contents are entirely <code>Sync</code> is safe
to share across threads, and automatically implements <code>Sync</code> for the type. If
anything inside the data structure is <em>not</em> <code>Sync</code>, neither is its container.
(There is also a way to opt-out of this behavior which I’ll discuss below.)</p>
<p>The <code>Cell</code> type we used to implement the bank account above is not <code>Sync</code>, so it
cannot be shared across threads. The compiler will prevent us from sending a
reference to a <code>Cell</code> to a different thread, and will also stop us from stashing
one in a place where another thread might have implicit access to it, like a
<code>static</code> variable.</p>
<p>So while our code was “correct” in the absence of concurrency in both C and
Rust, the code is also <em>correct</em> (no caveats) in Rust, because we have written
it in a way that prevents it from being used in situations where race conditions
can happen.</p>

<p>By avoiding <code>Sync</code> we can write a whole family of related types that can’t be
shared across threads. This does <em>not</em> prevent them from being used in threaded
programs! It just prevents the concurrency from leaking into <em>our code.</em> Our
code can be read top-to-bottom as though threads don’t exist, which makes it
much easier to understand and check for mistakes. We can write simpler and more
concise code by using basic (but not thread-safe!) types like <code>u8</code> and <code>Vec</code>,
instead of <code>AtomicU8</code> and some kind of fancy concurrent vector with
lock-striping or something.</p>
<p>In addition to less complexity for the <em>reader</em> to deal with, we also create
less complexity for the <em>machine</em> to deal with. Atomic operations are almost
always more expensive (in terms of execution time and code space) than their
simpler non-atomic equivalents.</p>
<p>If we (or our clients) want to use this code in a concurrent program, that
<em>program</em> gets to choose our concurrency strategy, instead of dictating it from
our library code. It might use a big mutex on everything, or mutexes on each
account, or have threads own a subset of data and talk to each other over
messages on channels. It might even use concurrency without threads using
<code>async</code> – because our code does not <code>await</code>, we can be confident that each
<code>deposit</code> or <code>withdraw</code> operation will execute atomically to completion even in
an <code>async</code> environment.</p>
<p>Don’t get me wrong: there’s still a place for concurrent data structures,
particularly in highly parallel applications with unpredictable data access
patterns. But sometimes it’s nice to be able to write the simple code, and not
worry about threads ruining your day.</p>

<p>As I mentioned above, Rust automatically infers <code>Sync</code> for types whose contents
are entirely <code>Sync</code> themselves. This is often what you want, but it can also be
a bad thing, for two reasons:</p>
<ol>
<li>
<p><strong>It’s implicit.</strong> Someone reading the code cannot easily tell if a type is
inferred to be <code>Sync</code>. More importantly, they can’t tell if it’s inferred to
be <code>Sync</code> because the author <em>intended</em> it, or by accident! Why would it be
bad to infer <code>Sync</code> by accident? Because…</p>
</li>
<li>
<p><strong>A structure may consist of all <code>Sync</code> members, but not be thread-safe!</strong></p>
</li>
</ol>
<p>That second reason is rare, but it does happen. It’s usually because you have
several members in (for example) a <code>struct</code>, each of which is <em>individually</em>
<code>Sync</code>, but you want to be able to update them all without possibly exposing
intermediate states before the update is done.</p>
<p>In both of these cases, you can explicitly opt your trait out of <code>Sync</code>. There’s
a proposed syntax for making this really convenient called “negative impls,” but
as of right now (2022 November) <a href="https://doc.rust-lang.org/unstable-book/language-features/negative-impls.html">it is still considered
unstable</a>. So instead, we can use a trick:</p>
<p>We sneak a non-<code>Sync</code> type into our data structure. Any one will do. You could
simply stuff a <code>Cell</code> or a raw pointer in there. However, we’d really like to
not spend the extra space for the <code>Cell</code>. We want the <em>effect</em> of putting a
non-<code>Sync</code> member in our struct, say, but not the physical effects of doing
so… like it’s a phantom.</p>
<p>Sounds a lot like [<code>PhantomData</code>] from the standard library!</p>
<p>I have a type like this in my codebase that I use to opt types out of automatic
<code>Sync</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Debug<span>,</span> Default</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>NotSyncMarker</span></span><span><span><span>(</span><span>PhantomData<span>&lt;</span><span>Cell<span>&lt;</span><span>u8</span><span>&gt;</span></span><span>&gt;</span></span></span><span>)</span></span><span>;</span>
</span></code></pre>
<p>I can then stuff it into some structure like so:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>ThingThatShouldNotBeSync</span> </span><span><span><span>{</span>
    <span>first_data</span><span>:</span> AtomicU8,
    <span>second_data</span><span>:</span> AtomicU8,

    <span>_marker</span><span>:</span> NotSyncMarker,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>This makes my <code>struct</code> <em>act like</em> it contains a <code>Cell</code>, which (as we saw above)
is not <code>Sync</code>, but doesn’t spend any memory to actually store a <code>Cell</code> because
it’s a phantom.</p>
<p>I’m a little surprised that Rust doesn’t ship a zero-sized marker type
for this in <code>std::marker</code>, like they do for <code>PhantomPinned</code>, but fortunately
it’s straightforward to write your own if you need it.</p>


<p>I’ve focused on <code>Sync</code> above because <code>Sync</code> embodies most languages’ notion of
what “thread safe” means: data that can be accessed and updated from multiple
threads without corrupting things.</p>
<p>However, there’s <em>another</em> kind of safety in the presence of threads, a kind of
safety that is more subtle and less common, but critical in the rare cases where
you need it.</p>
<p>Consider this: many operating systems keep track of which thread (if any) has
locked a mutex. If the data guarded by the mutex is accessed by any other
thread, <em>even if it’s correctly locked throughout the access,</em> trouble can
occur. For instance, many operating systems use mutex ownership information to
implement thread priority management strategies to avoid <a href="https://en.wikipedia.org/wiki/Priority_inversion">priority inversion</a>,
or to keep track of which mutexes are locked to avoid <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a>. If you confuse
the operating system about which thread is responsible for accessing the data
guarded by the mutex, you defeat these mechanisms, and you’re headed to Bug
Town.</p>
<p>In Rust, you can only refer to the data guarded by a <code>Mutex</code> through the <em>mutex
guard</em> returned by the <code>Mutex::lock</code> operation. (If this is unfamiliar to you, I
recommend reading <a href="http://cliffle.com/blog/rust-mutexes/">my article on it</a>; this section will make
more sense.) This means that, to produce a program where one thread locks a
mutex, and then a <em>different</em> thread accesses the guarded data, we would need to
arrange for that thread to have access to the mutex guard. If we can do that, we
can produce programs that defeat those operating system protections I described
above, and bad things will happen.</p>
<p>Let’s make bad things happen, shall we?</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>std<span>::</span></span><span>sync<span>::</span></span><span><span>{</span>Mutex<span>,</span> <span>mpsc<span>::</span></span>channel</span><span><span>}</span></span><span>;</span>
<span>use</span> <span>std<span>::</span></span>thread<span>;</span>

<span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
        <span>let</span> mutex <span>=</span> <span>Mutex<span>::</span></span>new<span><span>(</span><span>0_</span><span>u32</span></span><span><span>)</span></span><span>;</span>
   
        <span>let</span> <span><span>(</span>guard_in<span>,</span> guard_out</span><span><span>)</span></span> <span>=</span> <span>channel</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

        <span>thread<span>::</span></span>scope<span><span>(</span><span><span><span>|</span></span></span><span><span><span>s</span><span>|</span></span> </span><span><span><span>{</span>
        s<span>.</span><span>spawn</span><span><span>(</span><span>move</span> <span>||</span> <span><span>{</span>
                                    <span>let</span> g <span>=</span> mutex<span>.</span><span>lock</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
                        guard_in<span>.</span><span>send</span><span><span>(</span>g</span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
        </span><span><span>}</span></span></span><span><span>)</span></span><span>;</span>
        s<span>.</span><span>spawn</span><span><span>(</span><span>move</span> <span>||</span> <span><span>{</span>
                                    <span>let</span> g <span>=</span> guard_out<span>.</span><span>recv</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
                        <span>*</span>g <span>=</span> <span>42</span><span>;</span>
                    </span><span><span>}</span></span></span><span><span>)</span></span><span>;</span>
    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>That should do it! Now, when we run this, we see…</p>
<p>…oh, the compiler is saying something:</p>
<pre><code><span>error[E0277]: `MutexGuard&lt;&#39;_, Foobar&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:12:17
   |
12 |           s.spawn(move || {
   |  ___________-----_^
   | |           |
   | |           required by a bound introduced by this call
13 | |             // On the first thread, we will become the owner of the mutex.
14 | |             let g = mutex.lock().unwrap();
15 | |             // Send it to our collaborator.
16 | |             guard_in.send(g).unwrap();
17 | |         });
   | |_________^ `MutexGuard&lt;&#39;_, Foobar&gt;` cannot be sent between threads safely
   |
   = help: the trait `Send` is not implemented for `MutexGuard&lt;&#39;_, Foobar&gt;`
</span></code></pre>
<p>That’s very similar to the warning we got before when we tried to share data
between threads, but the words are slightly different: instead of “cannot be
shared across threads safely,” it says “cannot be <em>sent between</em> threads
safely.”</p>
<p>We’ve hit the <em>other</em> concurrency-related trait in the Rust standard library:
<code>Send</code>. A type implements <code>Send</code> if values of that type are safe to send between
threads. It so happens that, for the reasons described above, mutex guards do
<em>not</em> implement <code>Send</code>, and so our bug is avoided.</p>
<p>Like <code>Sync</code>, <code>Send</code> is inferred automatically by the compiler. In my experience,
it is far less common to opt out of <code>Send</code> than to opt out of <code>Sync</code>. Here are
some cases where you might want to opt out:</p>
<ul>
<li>
<p>If you’re implementing mutexes.</p>
</li>
<li>
<p>If your type acts as a handle to some sort of thread-local data, which would
be meaningless if accessed from another thread.</p>
</li>
<li>
<p>If you’re doing some sort of logging or tracing that includes thread names,
and you’d like your trace spans to indicate consistent thread names.</p>
</li>
</ul>
<p>Rust does not ship a marker type for “not <code>Send</code>” in the standard library as of
this writing, so until <code>negative_impls</code> are stabilized, you can opt out of
<code>Send</code> explicitly the same way we opted out of <code>Sync</code>: by pretending to include
some basic type that is not <code>Send</code>.</p>
<p>Raw pointers happen to not implement <code>Send</code>, so we can do this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Debug<span>,</span> Default</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>NotSendMarker</span></span><span><span><span>(</span><span>PhantomData<span>&lt;</span><span>*mut</span> <span>u8</span><span>&gt;</span></span></span><span>)</span></span><span>;</span>
</span></code></pre>

<p>Rust is the only language where I regularly write <em>non-thread-safe</em> data
structures without caveats or fear. In cases where they apply, such data
structures can be simpler and often faster than concurrent thread-safe data
structures – with the drawback, of course, that you can’t use threads to speed
up operations on them.</p>
<p>If you’re coming to Rust from another language that emphasizes concurrency, such
as Java or Go or (increasingly) C, keep this in mind:</p>
<ul>
<li>You don’t necessarily need to make <em>every</em> data structure thread-safe, and </li>
<li>If you get it wrong, you’ll get a compiler error, not a weird runtime bug.</li>
</ul>

<p><code>Sync</code> and <code>Send</code> interact in ways that make things much more convenient for us
programmers. None of this is language magic – it’s just trait <code>impl</code>s in the
standard library.</p>
<ul>
<li>
<p>If <code>T</code> is <code>Sync</code>, then <code>&amp;T</code> is <code>Send</code>. This makes sense: to share a value
across threads, each thread needs a reference to it, so we need to be able to
send that reference.</p>
</li>
<li>
<p>If <code>T</code> is <code>Send</code>, then <code>&amp;mut T</code> is also <code>Send</code> – meaning if you can transfer
ownership across threads, you can also lend so long as you lose access for the
duration. (Most cases where this works will also require the reference to be
<code>&#39;static</code>.)</p>
</li>
</ul>

<p>If you’ve written a data structure that is carefully engineered to be thread
safe (in either the <code>Sync</code> or <code>Send</code> sense), it may still contain types that are
<em>themselves</em> not <code>Sync</code> or <code>Send</code>, and so the compiler will not automatically
infer an impl. This is somewhat rare, but can happen if you’re building a shared
mutex-like data structure using <code>std::cell::UnsafeCell</code>. In these cases you may
need to explicitly implement <code>Sync</code> and/or <code>Send</code>.</p>
<p>Because implementing these traits <em>incorrectly</em> would open up your program to
data races and ghosts, implementing them explicitly is <code>unsafe</code>. So, you would
do it like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>unsafe</span> <span><span>impl</span> </span><span>Sync <span>for</span></span><span> <span>MyType</span> </span><span><span><span>{</span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Think very carefully before doing this.</p>

  
    <p><span>
      
        <a href="http://cliffle.com/tags/api-design/">#api-design</a>
      
        <a href="http://cliffle.com/tags/concurrency/">#concurrency</a>
      
        <a href="http://cliffle.com/tags/rust/">#rust</a>
      
    </span>
  
</p></div>

        </div></div>
  </body>
</html>
