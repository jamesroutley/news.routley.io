<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.wesleyac.com/posts/snes-dev-2-background-graphics">Original</a>
    <h1>SNES Development Part 2: Background Graphics</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><em>This is part two of my series on SNES development. You may want to read the <a href="https://blog.wesleyac.com/posts/snes-dev-1-getting-started">previous post</a> first.</em></p>

<p>Now that we have a simple SNES ROM, let&#39;s add some graphics. In this post, we&#39;ll draw some graphics to the background. There are many explanations of the SNES background graphics architecture online, so I won&#39;t bother repeating those here — I recommend watching the Retro Game Mechanics Explained videos on <a href="https://www.youtube.com/watch?v=57ibhDU2SAI">Graphics &amp; Palettes</a>, <a href="https://www.youtube.com/watch?v=uRjf8ZP6rs8">Backgrounds &amp; Rendering</a>, and <a href="https://www.youtube.com/watch?v=5SBEAZIfDAg">Background Modes</a>. I don&#39;t usually recommend videos, but these are the best explanations I&#39;ve found of this topic, in any format. <a href="https://megacatstudios.com/blogs/retro-development/super-nintendo-graphics-read-in-the-voice-of-brendan">This blog post</a> is a reasonable general overview as well, but it has less information than the videos.</p>

<p>The general gist of things is that we&#39;re going to set up a palette, which will give us some colors we can use, just like we did in the previous part. Then, we&#39;ll load some images into the VRAM — these are what are colloquially called &#34;tiles&#34;, but the official SNES documentation refers to them as &#34;characters&#34;. Then, we&#39;ll write a &#34;tile map&#34; to the VRAM, which tells the SNES which characters to draw on the screen, and where. We also need to select which graphics mode we want to use — for this demo, it&#39;ll be Mode 0 with 8x8 tiles.</p>

<p>With that in mind, take a look at <a href="https://github.com/WesleyAC/snes-dev/tree/main/part2/src">the code</a> — especially the <a href="https://github.com/WesleyAC/snes-dev/compare/part2-base..part2">diff of the changes from part 1</a>. I&#39;d recommend reading through that with the above list in mind, and then coming back to read the rest of the explanation, once you have a overview of the code in your head.</p>

<p>Let&#39;s take a look at the changes in the main file first. The first thing we do is define some constants for locations in the VRAM. The SNES has 64k of VRAM, and we can lay it out however we like, although there are some alignment restrictions.</p>

<p>The next change is just adding three more colors to our palette. Mode 0 uses two-bit-per-pixel (2bpp) color, which means that there are four colors available, so I add four colors to the palette.</p>

<p>Once that&#39;s done, we set the graphics mode to Mode 0 by writing to the <code>BGMODE</code> register. This controls both the mode, and the tile size for each background layer, which can be either 8x8 or 16x16.</p>

<p>After that, we tell the SNES where to find the tile map and character map by writing to the <code>BG1SC</code> and <code>BG12NBA</code> registers. As the name implies, the second one controls the character set for both backgrounds one and two, using the two separate halves of the byte, but we don&#39;t need to worry about that for now, since we&#39;re only using BG1.</p>

<p>Then, we copy the character data from the ROM into VRAM. This is done with a loop, but in the future we&#39;ll replace that loop with <a href="https://sneslab.net/wiki/DMA">DMA</a>, which is much faster. For now, though, you don&#39;t need to worry about that.</p>

<p>It&#39;s useful to notice how to write to VRAM — we set <code>VMADDL</code> to the address we want to write to, and then we write to <code>VMDATAL</code> and <code>VMDATAH</code> to set the data we want to write. This is basically the same as how we wrote the palette data. One difference is that the auto-incrementing is more configurable — by setting the 7th bit of <code>VMAIN</code> (which means &#34;video memory auto-increment&#34;, not &#34;video main&#34;), we set it to auto-increment after we write to the <code>VMDATAH</code> register.</p>

<p>I&#39;m not going to go into detail here about the format of the character data, since other people have written about it at length — it&#39;s covered in the videos I linked at the start of the post, and a good textual description is available <a href="https://mrclick.zophar.net/TilEd/download/consolegfx.txt">here</a>. I personally found the explanations a bit confusing, and preferred to just experimentally twiddle the bits around by hand until I understood it — it&#39;s the sort of thing that can be confusing to read about, but obvious once you start playing with it.</p>

<p>With the character data written, we can render a character to the screen. We do this by writing two bytes to the BG1 tile map, using the same process to write to VRAM as above. The first byte controls the tile index, and the second byte controls which palette to use, the rendering priority, and whether to mirror the tile horizontally or vertically.</p>

<p>With all that setup out of the way, the last thing we have to do is enable rendering BG1 by setting its bit in the <code>TM</code> register, and voilà, a tile on the screen!</p>

<p>With that done, there&#39;s plenty you can experiment with:</p>

<ul>
<li>Change what the tile looks like, by editing the <code>charset.asm</code> file.</li>
<li>If you&#39;re running in Mesen-S, you&#39;ll notice that the tile is surrounded by garbage data. Zero out the tile map so that doesn&#39;t happen.</li>
<li>Add a couple more tiles, and render them at different spots on the screen.</li>
<li>Use a mode other than Mode 0 — Mode 1 is a super common and useful mode. This changes the number of bits per pixel, so you&#39;ll need to change the character set to match.</li>
<li>Experiment with building some sort of graphics editing pipeline to generate the character data. You could use something like YY-CHR, aesprite, or one of the many conversion tools available online, or write your own tools — whichever you prefer!</li>
</ul>

<p>Once you&#39;re done with all that, head to <a href="https://blog.wesleyac.com/posts/snes-dev-3-input">part three</a> for reading and responding to input!</p>

          </div></div>
  </body>
</html>
