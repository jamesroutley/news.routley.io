<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/antirez/picol">Original</a>
    <h1>picol: A Tcl interpreter in 500 lines of code</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">Picol is a Tcl-alike interpreter in 500 lines of code that I released 15th of March 2007. Recentely I looked at the source code and realized this was a better C programming example compared to what I recalled, so I&#39;m putting this on GitHub to archive it, together with the main points of the original article.</p>

<p dir="auto">When I built this code, I had some rule in mind:</p>
<ul dir="auto">
<li>I wanted to use more or less my normal C style. In Picol you&#39;ll find normal C spacing and even comments.</li>
<li>I wanted to write an interpreter with a design similar to a real one. One of the few useful things you can do with Picol is to learn how to write a Tcl interpreter if you are a newbie programmer, I guess, so the point was to write a simple to understand program, not just a <em>short</em> program.</li>
<li>The resulting interpreter should be able to run some kind of non trivial program: to just set few vars and print hello world was not an option.</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">The resulting interpreter: Picol</h2><a id="user-content-the-resulting-interpreter-picol" aria-label="Permalink: The resulting interpreter: Picol" href="#the-resulting-interpreter-picol"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The parser is very similar to the Tcl one, Picol supports interpolation as well, for example you can write:</p>
<div dir="auto" data-snippet-clipboard-copy-content="set a &#34;pu&#34;
set b {ts}
$a$b &#34;Hello World!&#34;"><pre><span>set</span> a <span><span>&#34;</span>pu<span>&#34;</span></span>
<span>set</span> b {ts}
<span>$a$b</span> <span><span>&#34;</span>Hello World!<span>&#34;</span></span></pre></div>
<p dir="auto">Note that Picol has an interactive shell! so just launch it without arguments to start to play (to compile the code use <code>gcc -O2 -Wall -o picol picol.c</code>).</p>
<p dir="auto">To run a program stored in a file, use: <code>picol filename.tcl</code>.</p>
<p dir="auto">Probably the parser could be rewritten in order to take less space, currently it takes almost 250 lines of code: this is too much and leaves little room for all the rest. On the other side, it&#39;s a decent example about writing parsers by hand.</p>
<p dir="auto">A Raw list of the supported features:</p>
<ul dir="auto">
<li>Interpolation, as seen above. You can also write <code>&#34;2+2 = [+ 2 2]&#34;</code> or <code>&#34;My name is: $foobar&#34;</code>.</li>
<li>Procedures, with return. Like Tcl if return is missing the result of the last command executed is returned.</li>
<li><code>If</code>, <code>if .. else ..</code>, <code>while</code> with <code>break</code> and <code>continue</code>.</li>
<li>Recursion.</li>
<li>Variables inside procedures are limited in scope like Tcl, i.e. there are real call frames in Picol.</li>
<li>The following other commands: <code>set</code> <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>==</code> <code>!=</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>puts</code>.</li>
</ul>
<p dir="auto">This is an example of programs Picol can run:</p>
<div dir="auto" data-snippet-clipboard-copy-content="proc fib {x} {
    if {== $x 0} {
        return 0
    }
    if {== $x 1} {
        return 1
    }
    return [+ [fib [- $x 1]] [fib [- $x 2]]]
}

puts [fib 20]
that of course will output fib(20). Another example:
proc square {x} {
    * $x $x
}"><pre><span>proc</span> <span>fib</span> {x} {
    <span>if</span> {== <span>$x</span> 0} {
        <span>return</span> 0
    }
    <span>if</span> {== <span>$x</span> 1} {
        <span>return</span> 1
    }
    <span>return</span> [+ [fib [- <span>$x</span> 1]] [fib [- <span>$x</span> 2]]]
}

<span>puts</span> [fib 20]
that of course will output fib(20). Another example:
<span>proc</span> <span>square</span> {x} {
    * <span>$x</span> <span>$x</span>
}</pre></div>
<p dir="auto">Or:</p>
<div data-snippet-clipboard-copy-content="set a 1
while {&lt;= $a 10} {
    if {== $a 5} {
        puts {Missing five!}
        set a [+ $a 1]
        continue
    }
    puts &#34;I can compute that $a*$a = [square $a]&#34;
    set a [+ $a 1]
}"><pre><code>set a 1
while {&lt;= $a 10} {
    if {== $a 5} {
        puts {Missing five!}
        set a [+ $a 1]
        continue
    }
    puts &#34;I can compute that $a*$a = [square $a]&#34;
    set a [+ $a 1]
}
</code></pre></div>

<ul dir="auto">
<li>It&#39;s pretty straightforward, the first important part you see in the source code is an hand written parser. The main function of the parser is <code>picolGetToken</code> that just calls functions able to parse the different parts of a Tcl program and return in the parsing structure the type of the token and start/end pointers in order to extract it.</li>
</ul>
<p dir="auto">This parsing function is in turn used by <code>picolEval</code> in order to execute the program. Every token is used either to form a new argument if a separator token was found before, or concatenated to the last argument (this is how interpolation is performed in Picol). Once an EOL (end of line) token is returned picolEval will call the command looking it up in a linked list of commands stored inside the interpreter structure.</p>
<p dir="auto">Variables and commands substitution is performed by <code>picolEval</code> itself. The parser is able to return variables and commands tokens already stripped by <code>$</code> and <code>[]</code>, so all it&#39;s required to do is to lookup the variable in the call frame and substitute the value with the token, or to recursively call <code>picolEval</code> if it&#39;s a command substitution, using the result instead of the original token.</p>
<p dir="auto">Commands are described by a name and a pointer to a C function implementing the command. In the command structure there is also a private data void pointer used in order to store data private to the command. This makes you able to implement multiple Picol commands using a single C function. User defined procedures are just like commands, but they are implemented by passing as private data the argument list and the body of the procedure, so a single C function is able to implement all the existing user defined procedures.</p>
<p dir="auto">Procedures call is trivial. The interpreter structure contains a call frame structure having more or less just a pointer to a liked list of variables (that are in turn structures with two fileds: name and value). When a procedure is called a new call frame is created and put at the top of the old one. When the procedure returns the top call frame is destroyed.</p>
<p dir="auto"><strong>Inside every large program there is a small program trying to get out -- Sir Tony Hoare.</strong></p>
</article></div></div>
  </body>
</html>
