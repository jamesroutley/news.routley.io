<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://sebmestre.blogspot.com/2023/11/en-writing-compiler-is-surprisingly.html">Original</a>
    <h1>Writing a Compiler is Surprisingly Easy (part 1)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-974883917963364008">


<p>
Ever since I was a teenager I wanted to create my own systems programming
language. Such a programming language would certainly
have to be compiled to native code, which meant I&#39;d have to write a compiler.
</p><p>
Even though I managed to write several half-working parsers, I&#39;d always
fail at the stage of generating assembly code, as the task turned too complex.
</p><p>
In this blog I intend to show my teenage self how writing a code generator is, in fact, not
complex at all, and it can be fully done in a couple of weekends. (As long as we
make some simplifying assumptions)
</p>
 <blockquote>I will that assume you already know that <a href="https://sebmestre.blogspot.com/2023/11/en-representing-programs-within.html">representing programs within a
   program is surprisingly easy</a>
</blockquote>
<h2>Where do we even start?</h2>
<p>
The goal today is to translate a high level language to x86-64 machine code. Our
high-level language will have integer literals, variables, negation, and
addition.
</p><p>
To make our job simpler, we will translate the high level code to x86-64
assembly code, and use a pre-existing assembler (like the one inside GCC) to
translate that to machine code.
</p><p>
Let&#39;s get started. Here is how we will represent integer literals:
</p>
<pre>struct int_literal {
	int value;
};
</pre>
<p>
Compiling them is straightforward:
</p>
<pre>void compile_int_literal(struct int_literal* e) {
	printf(&#34;mov $%d, %%rax\n&#34;, e-&gt;value);
}
</pre>

<blockquote><code>printf</code> uses the <code>%</code> character to denote formatting commands, so a double <code>%%</code> is used to print the character verbatim.</blockquote>
<p>
Here I used the x86-64 <code>mov</code> instruction. This instruction moves data from one
place to another. In the notation used in this blog, the flow of data is
  left-to-right (i.e. the instruction is works as <code>mov source, destination</code>)
</p><p>
In this case we are moving an immediate value (a numeric constant written
directly in the code, notated with a <code>$</code> preceding it) into the &#34;a&#34; register (a
little space of data that lives directly inside the CPU, written as <code>%rax</code>)
</p>
<p>
The x86-64 <code>mov</code> instruction can be used in several ways (&#34;addressing modes&#34;):
immediate-to-register (the one we just used), register-to-memory, memory-to-register,
register-to-register, etc. We will see some of these later on.
</p><p>
I want to note that, at this point, many design decisions have already been made.
Most notably:
</p>
<ul>
  <li>Our compiler will output AT&amp;T-style assembly code to <code>stdout</code>, using <code>printf</code></li>
<li>The result of compiling an expression will be assembly code that computes and
  stores the value of that expression in <code>%rax</code></li>
</ul>
<p>
The last point is in no small part responsible for making the compiler so
simple, but it also means that the code we&#39;ll generate is not very efficient.
</p><p>
For the initiated, some obvious things that we could add to mitigate this are a
peephole optimizer and a register allocator. But these would force us to
implement some intermediate representation and make our compiler a lot more
complicated, so we are not going to.
</p><p>
Let&#39;s move on.
</p>
<h2>How can we implement variables?</h2>
<p>
The way we will represent variables in our compiler is with an integer. Yes, not
with a string that corresponds to the name of the variable, but an index that
represents where that variable will live in memory. Indeed, all variables will
be stored in our computer&#39;s main memory. In particular, they will live in a
  place called <i>the stack</i>.
</p>

<p>
The stack is a wonderful mechanism that allows us to quickly store some values
in memory and safely discard them once we don&#39;t need them. In memory, it is
simply laid out like an array of 64 bit integers.
</p><p>
The way it works is extremely simple: the CPU has a register -- known as the
stack pointer <code>%rsp</code> -- that always tells us the first slot in the stack that is
available to be used. Every slot after will be free, and every slot before will
be occupied. As with everything low-level, this doesn&#39;t happen magically, and we
will be responsible for keeping that register up to date.
</p><p>
We are going to be a bit naughty and not update the stack pointer for now. This
is mostly okay as long as our code does not perform any function calls.
</p><p>
With this in mind, we can represent variables using an index that tells us how
many slots *after* the first available slot the variable is stored.
</p>

<pre>struct variable {
	int slot;
};
</pre>

<blockquote>In a more complete compiler there would be a previous step that takes care of
  assigning a stack slot to each declared variable, and translating variable names to stack
  slots. We wouldn&#39;t expect the language user to type in the slots by hand.</blockquote>
<p>
Compiling them is simple enough, but we do need to learn some more x86-64
assembly to fully grasp it.
</p>
<pre>void compile_variable(struct variable* e) {
	int slot = e-&gt;slot;
	printf(&#34;mov %d(%%rsp), %%rax\n&#34;, -8 * (slot + 1));
}
</pre>
<p>
Here we use a different version of the <code>mov</code> instruction. This one looks like
<code>mov number(register1), register2</code>, and it means &#34;take the value at address
<code>number+register1</code>, and store it in <code>register2</code>&#34;. (mem-to-reg mode)
</p><p>
This is how we implement access into the stack. The stack pointer holds the
address of the first free slot, and we add an offset to to access the slot that
holds the desired variable.
</p><p>
Besides that, there is a funny looking bit of math up there. There are two
things to know about the stack:
</p>
<ul>
<li>each slot holds a 64-bit value. This equals 8 bytes, which is why we multiply
  by 8</li>
<li>the stack grows downwards. This means that the occupied slots are at higher
  addresses than the free slots. This explains why the 8 is negative instead of
  positive</li>
<li>there is a +1 in there because I lied. The stack pointer actually points at the last
  occupied slot, instead of the first free slot.</li>
</ul>
<h2> Negation</h2>
<p>
The representation of negation is similarly straightforward, and should be
apparent to those who read the previous blog.
</p>
<pre>struct negation {
	struct expression* target;
};
</pre>

<blockquote>I will omit the definition of <code>struct expression</code> for now, as it would
distract from the main points of this section.</blockquote>
<p>
To compile negations we will take advantage of the fact that compiling an
expression will produce code that stores its result in <code>%rax</code>. This means that
if we emit some code that negates <code>%rax</code> right after the code that computes the
value to be negated, we will have succesfully computed the desired negation.
</p><p>
Luckily, x86-64 has an instruction that does just this.
</p>
<pre>void compile_negation(struct negation* e) {
	compile_expression(e-&gt;target);
	printf(&#34;neg %%rax\n&#34;);
}
</pre>
<p>
But just to get used to the kind of puzzles we have to solve to compile some
more complicated operations, let&#39;s avoid using <code>neg</code>. x86-64 has a <code>sub</code>
instruction that subtracts one operand from another. Let&#39;s try using that.
</p><p>
In particular, let&#39;s:
</p>
<ul>
  <li>compute the target expression (leaving the result in <code>%rax</code>)</li>
  <li>put a zero into <code>%rcx</code></li>
  <li>substract <code>%rax</code> from <code>%rcx</code> (leaving the negated result in <code>%rcx</code>)</li>
  <li>put the negated result in <code>%rax</code></li>
</ul>
<pre>void compile_negation(struct negation* e) {
	compile_expression(e-&gt;target);
	printf(&#34;mov $0, %%rcx\n&#34;);
	printf(&#34;sub %%rax, %%rcx\n&#34;);
	printf(&#34;mov %%rcx, %%rax\n&#34;);
}
</pre>
<p>
While not too complicated, this ilustrates the kind of hoops we will sometimes
have to jump through in order to compile more advanced operations. I don&#39;t think
this makes compiling hard, but it can get pretty tedious.
</p>
<blockquote>Also, note the use of the reg-to-reg addressing mode</blockquote>

<h2>Addition</h2>
<p>
Like in the previous blog, we will represent additions as follows:
</p>
<pre>struct addition {
	struct expression* left_term;
	struct expression* right_term;
};
</pre>
<p>
The general idea here will be to first compile the left term, then the right
term, then emit an <code>add</code> instruction that adds their results. The main problem
that arises is that the result of the the left term will be lost while we
compute the right term.
</p><p>
A simple fix might be to move the result to a different register, like this:
</p>
<pre>void compile_addition(struct addition* e) {
	compile_expression(e-&gt;left_term);
	printf(&#34;mov %%rax, %%rcx\n&#34;);
	compile_expression(e-&gt;right_term);
	printf(&#34;add %%%rcx, %%rax\n&#34;);
}
</pre>

<blockquote><p>
We use <code>%rcx</code> instead of <code>%rbx</code> because <code>%rbx</code> is a callee-saved register in
x86-64, meaning we are not allowed to use it without first storing its old
content in the stack, and later restoring its value. This is mandated by the x86-64 calling conventions.
</p><p>
This is too cumbersome, so we just use the nearest non-callee-saved register.
</p></blockquote>
  
<p>
Unfortunately, this will not work when the right term also stores something in
<code>%rcx</code> in an intermediate step. Instead, we will get some help from to our good
friend, the stack.
</p><p>
We will store that intermediate value in the stack, and read it back after the
right term is done computing. If we take care that the code we generate for the
right term doesn&#39;t write into the same stack slot, then we can be sure that the
value will be preserved.
</p><p>
The mechanism to prevent re-using the same stack slot is a simple counter. Since
we also store variables in the stack, its value must be greater than any slot
that&#39;s been assigned to a variable. For now let&#39;s just initialize it with some
large number, like 10.
</p>
<pre>int temp_counter = 10;
void compile_addition(struct addition* e) {
	compile_expression(e-&gt;left_term);
	int slot = temp_counter++; // allocate a new slot
	printf(&#34;mov %%rax, %d(%%rsp)\n&#34;, -8 * (slot + 1));
	compile_expression(e-&gt;right_term);
	printf(&#34;add %d(%%rsp), %%rax\n&#34;, -8 * (slot + 1));
	temp_counter--; // restore the counter
}
</pre>

<blockquote>Here we finally see a <code>mov</code> that uses reg-to-mem addressing mode. Also, note that <code>add</code>
can also use mem-to-reg mode.
</blockquote>
<h2>Putting it All Together</h2>
<p>
The final piece of the puzzle, for now, is the <code>struct expression</code> data type,
and its corresponding <code>compile_expression</code> function. These are pretty much
trivial given what we&#39;ve seen so far, but I&#39;ll type them out for completeness&#39;
sake.
</p>
<pre>enum expression_tag {
	EXPRESSION_INT_LITERAL,
	EXPRESSION_VARIABLE,
	EXPRESSION_NEGATION,
	EXPRESSION_ADDITION,
};
struct expression {
	enum expression_tag tag;
	union {
		struct int_literal as_int_literal;
		struct variable as_variable;
		struct negation as_negation;
		struct addition as_addition;
	};
};

void compile_expression(struct expression* e) {
	switch (e-&gt;tag) {
	case EXPRESSION_INT_LITERAL:
		compile_int_literal(&amp;e-&gt;as_int_literal);
		break;
	case EXPRESSION_VARIABLE:
		compile_variable(&amp;e-&gt;as_variable);
		break;
	case EXPRESSION_NEGATION:
		compile_negation(&amp;e-&gt;as_negation);
		break;
	case EXPRESSION_ADDITION:
		compile_addition(&amp;e-&gt;as_addition);
		break;
	}
}
</pre>

<h2>Testing it out</h2>
<p>
At this point, we are capable of compiling simple arithmetic expressions. To
test this out, we can write a small program like this one:
</p>
<pre>int main() {
	// var0 + (-var1 + 42)
	struct expression* e =
		addition(
			variable(0),
			addition(
				negation(variable(1)),
				int_literal(42)));
	compile_expression(e);
}
</pre>

<blockquote><code>int_literal</code>, <code>variable</code>, <code>negation</code> and <code>addition</code> are some helpers that
build up the corresponding expressions.</blockquote>
<p>
Which produces the following output:
</p>
<pre>mov -8(%rsp), %rax
mov %rax, -88(%rsp)
mov -16(%rsp), %rax
neg %rax
mov %rax, -96(%rsp)
mov $42, %rax
add -96(%rsp), %rax
add -88(%rsp), %rax
</pre>
</div></div>
  </body>
</html>
