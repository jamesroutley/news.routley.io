<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sirupsen.com/napkin/neural-net">Original</a>
    <h1>Neural network from scratch</h1>
    
    <div id="readability-page-1" class="page"><article><p><time datetime="2022-01-03">Jan 2022</time></p><nav><ol><li><a href="#mental-model-for-a-neural-net-building-one-from-scratch">Mental Model for a Neural Net: Building one from scratch</a></li><li><a href="#training-our-neural-network">Training our Neural Network</a><ol><li><a href="#updating-the-hidden-layer-with-gradient-descent">Updating the Hidden Layer with Gradient Descent</a></li></ol></li><li><a href="#finalizing-our-neural-network-from-scratch">Finalizing our Neural Network from scratch</a><ol><li><a href="#automagically-computing-the-slope-of-a-function-with-autograd">Automagically computing the slope of a function with autograd</a></li></ol></li><li><a href="#ok-so-you-just-implemented-the-most-complicated-average-function-ive-ever-seen">OK, so you just implemented the most complicated average function I&#39;ve ever seen...</a><ol><li><a href="#activation-functions">Activation Functions</a></li><li><a href="#matrices">Matrices</a></li></ol></li><li><a href="#next-steps-to-implement-your-own-neural-net-from-scratch">Next steps to implement your own neural net from scratch</a></li></ol></nav><p>In this edition of Napkin Math, we&#39;ll invoke the spirit of the Napkin Math
series to establish a mental model for how a neural network works by building
one from scratch. In a future issue we will do napkin math on performance, as
establishing the first-principle understanding is plenty of ground to cover for
today!</p><p>Neural nets are increasingly dominating the field of machine learning / artificial
intelligence: the most sophisticated models for computer vision (e.g. CLIP),
natural language processing (e.g. GPT-3), translation (e.g. Google Translate),
and more are based on neural nets. When these artificial neural nets reach some
arbitrary threshold of neurons, we call it <em>deep learning</em>.</p><p>A visceral example of Deep Learning&#39;s unreasonable effectiveness comes from
<a href="https://www.listennotes.com/podcasts/the-twiml-ai/systems-and-software-for-xolUkM23Gb0/">this interview</a> with Jeff Dean who leads AI at Google. He explains how
500 lines of Tensorflow outperformed the previous ~500,000 lines of code for
Google Translate&#39;s <em>extremely complicated</em> model. Blew my mind. <sup id="fnref-google"><a href="#fn-google">1</a></sup></p><p>As a software developer with a predominantly web-related skillset of Ruby,
databases, enough distributed systems knowledge to know to not get fancy, a bit
of hard-earned systems knowledge from debugging incidents, but only high school
level math: <em>neural networks mystify me</em>. How do they work? Why are they so
good? Why are they so slow? Why are GPUs/TPUs used to speed them up? Why do the
biggest models have more neurons than humans, yet still perform worse than the
human brain? <sup id="fnref-gpt3"><a href="#fn-gpt3">2</a></sup></p><p>In true napkin math fashion, the best course of action to answer those questions
is by implementing a simple neural net from scratch.</p><h2 id="mental-model-for-a-neural-net-building-one-from-scratch">Mental Model for a Neural Net: Building one from scratch</h2><p>The hardest part of napkin math isn&#39;t the calculation itself: it&#39;s acquiring the
conceptual understanding of a system to come up with an equation for its
performance. Presenting and testing mental models of common systems is the crux
of value from the napkin math series!</p><p>The simplest neural net we can draw might look something like this:</p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjg3IiBoZWlnaHQ9IjU5OCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></span><img alt="lol" srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fmental-model.jpg&amp;w=750&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fmental-model.jpg&amp;w=1920&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fmental-model.jpg&amp;w=1920&amp;q=75" decoding="async" data-nimg="intrinsic"/></span></figure><ul><li><strong>Input layer</strong>. This is a representation of the data that we want to feed to
the neural net. For example, the input layer for a 4x4 pixel grayscale image
that looks like this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[1, 1, 1, 0.2]</title><rect fill="#000000" x="0" y="0" width="1" height="1"></rect><rect fill="#000000" x="1" y="0" width="1" height="1"></rect><rect fill="#000000" x="0" y="1" width="1" height="1"></rect><rect fill="#E3E3E3" x="1" y="1" width="1" height="1"></rect></svg> could be <code>[1, 1, 1,
0.2]</code>. Meaning the first 3 pixels are darkest (1.0) and the last pixel is
lighter (0.2).</li><li><strong>Hidden Layer</strong>. This is the layer that does a bunch of math on the input
layer to convert it to our prediction. <em>Training</em> a model refers to changing the
math of the hidden layer(s) to more often create an output like the training
data. We will go into more detail with this layer in a moment. The values in the
hidden layer are called <em>weights</em>.</li><li><strong>Output Layer</strong>. This layer will contain our final prediction. For example,
if we feed it the rectangle from before <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[1, 1, 1, 0.2]</title><rect fill="#000000" x="0" y="0" width="1" height="1"></rect><rect fill="#000000" x="1" y="0" width="1" height="1"></rect><rect fill="#000000" x="0" y="1" width="1" height="1"></rect><rect fill="#E3E3E3" x="1" y="1" width="1" height="1"></rect></svg> we
might want the output layer to be a single number to represent how &#34;dark&#34; a
rectangle is, e.g.: <code>0.8</code>.</li></ul><p>For example for the image <code><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[0.8, 0.7, 1, 1]</title><rect fill="#4C4C4C" x="0" y="0" width="1" height="1"></rect><rect fill="#656565" x="1" y="0" width="1" height="1"></rect><rect fill="#000000" x="0" y="1" width="1" height="1"></rect><rect fill="#000000" x="1" y="1" width="1" height="1"></rect></svg> <!-- -->=<!-- --> <!-- -->[0.8, 0.7, 1, 1]</code> we&#39;d expect a value close to 1 (dark!).</p><p>In contrast, for <code><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[0.2, 0.5, 0.4, 0.7]</title><rect fill="#E3E3E3" x="0" y="0" width="1" height="1"></rect><rect fill="#989898" x="1" y="0" width="1" height="1"></rect><rect fill="#B1B1B1" x="0" y="1" width="1" height="1"></rect><rect fill="#656565" x="1" y="1" width="1" height="1"></rect></svg> <!-- -->=<!-- --> <!-- -->[0.2, 0.5, 0.4, 0.7]</code> we
expect something closer to 0 than to 1.</p><p>Let&#39;s implement a neural network from our simple mental model. The goal of this
neural network is to take a grayscale 2x2 image and tell us how &#34;dark&#34; it is
where 0 is completely white <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[0, 0, 0, 0]</title><rect fill="#FFFFFF" x="0" y="0" width="1" height="1"></rect><rect fill="#FFFFFF" x="1" y="0" width="1" height="1"></rect><rect fill="#FFFFFF" x="0" y="1" width="1" height="1"></rect><rect fill="#FFFFFF" x="1" y="1" width="1" height="1"></rect></svg>, and 1 is
completely black <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[1, 1, 1, 1]</title><rect fill="#000000" x="0" y="0" width="1" height="1"></rect><rect fill="#000000" x="1" y="0" width="1" height="1"></rect><rect fill="#000000" x="0" y="1" width="1" height="1"></rect><rect fill="#000000" x="1" y="1" width="1" height="1"></rect></svg>. We will initialize the
hidden layer with some random values at first, in Python:</p><pre><code>input_layer <span>=</span> <span>[</span><span>0.2</span><span>,</span> <span>0.5</span><span>,</span> <span>0.4</span><span>,</span> <span>0.7</span><span>]</span>



hidden_layer <span>=</span> <span>[</span><span>0.98</span><span>,</span> <span>0.4</span><span>,</span> <span>0.86</span><span>,</span> <span>-</span><span>0.08</span><span>]</span>

output_neuron <span>=</span> <span>0</span>




<span>for</span> index<span>,</span> input_neuron <span>in</span> <span>enumerate</span><span>(</span>input_layer<span>)</span><span>:</span>
    output_neuron <span>+=</span> input_neuron <span>*</span> hidden_layer<span>[</span>index<span>]</span>
<span>print</span><span>(</span>output_neuron<span>)</span>

</code></pre><p>Our neural network is giving us <code>model(<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[0.2, 0.5, 0.4, 0.7]</title><rect fill="#E3E3E3" x="0" y="0" width="1" height="1"></rect><rect fill="#989898" x="1" y="0" width="1" height="1"></rect><rect fill="#B1B1B1" x="0" y="1" width="1" height="1"></rect><rect fill="#656565" x="1" y="1" width="1" height="1"></rect></svg>) =<!-- --> <!-- -->0.7</code> which is closer to &#39;dark&#39; (1.0) than &#39;light&#39; (0.0). When looking
at this rectangle as a human, we judge it to be more bright than dark, so we
were expecting something below 0.5!</p><p>There&#39;s a <a href="https://colab.research.google.com/drive/1YRp9k_ORH4wZMqXLNkc3Ir5w4B5f-8Pa?usp=sharing">notebook</a> with the final code available. You can make a copy and execute it there. For early versions of the code, such as the above, you can create a new cell at the beginning of the notebook and build up from there!</p><p>The only real thing we can change in our neural network in its current form is
the hidden layer&#39;s values. How do we change the hidden layer values so that the
output neuron is close to 1 when the rectangle is dark, and close to 0 when it&#39;s
light?</p><p>We could abandon this approach and just take the average of all the pixels. That
would work well! However, that&#39;s not really the point of a neural net... We&#39;ll
hit an impasse if we one day expand our model to try to implement
<code>recognize_letters_from_picture(img)</code> or <code>is_cat(img)</code>.</p><p>Fundamentally, a neural network is just a way to approximate any function. It&#39;s
really hard to sit down and write <code>is_cat</code>, but the same technique we&#39;re using
to implement <code>average</code> through a neural network can be used to implement
<code>is_cat</code>. This is called the <a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem">universal approximation theorem</a>: an
artificial neural network can approximate <em>any</em> function!</p><p>So, let&#39;s try to teach our simple neural network to take the <code>average()</code> of the
pixels instead of explicitly telling it that that&#39;s what we want! The idea of
this walkthrough example is to understand a neural net with very few values and
low complexity, otherwise it&#39;s difficult to develop an intuition when we move to
1,000s of values and 10s of layers, as real neural networks have.</p><p>We can observe that if we <em>manually modify</em> all the hidden layer attributes to
<code>0.25</code>, our neural network is actually an average function!</p><pre><code>input_layer <span>=</span> <span>[</span><span>0.2</span><span>,</span> <span>0.5</span><span>,</span> <span>0.4</span><span>,</span> <span>0.7</span><span>]</span>
hidden_layer <span>=</span> <span>[</span><span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>]</span>

output_neuron <span>=</span> <span>0</span>
<span>for</span> index<span>,</span> input_neuron <span>in</span> <span>enumerate</span><span>(</span>input_layer<span>)</span><span>:</span>
    output_neuron <span>+=</span> input_neuron <span>*</span> hidden_layer<span>[</span>index<span>]</span>




<span>print</span><span>(</span>output_neuron<span>)</span>




<span>print</span><span>(</span><span>sum</span><span>(</span>input_layer<span>)</span> <span>/</span> <span>4</span><span>)</span>
</code></pre><code>model(<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[0.2, 0.5, 0.4, 0.7]</title><rect fill="#E3E3E3" x="0" y="0" width="1" height="1"></rect><rect fill="#989898" x="1" y="0" width="1" height="1"></rect><rect fill="#B1B1B1" x="0" y="1" width="1" height="1"></rect><rect fill="#656565" x="1" y="1" width="1" height="1"></rect></svg>) =<!-- --> <!-- -->0.45</code> sounds about right. The rectangle is a little lighter than it&#39;s dark.<p>But that was cheating! We only showed that we <em>can</em> implement <code>average()</code> by
simply changing the hidden layer&#39;s values. But that won&#39;t work if we try to implement
something more complicated. Let&#39;s go back to our original hidden layer
initialized with random values:</p><pre><code>hidden_layer <span>=</span> <span>[</span><span>0.98</span><span>,</span> <span>0.4</span><span>,</span> <span>0.86</span><span>,</span> <span>-</span><span>0.08</span><span>]</span>
</code></pre><p>How can we <em>teach</em> our neural network to implement <code>average</code>?</p><h2 id="training-our-neural-network">Training our Neural Network</h2><p>To teach our model, we need to create some training data. We&#39;ll create some
rectangles and calculate their average:</p><pre><code>rectangles <span>=</span> <span>[</span><span>]</span>
rectangle_average <span>=</span> <span>[</span><span>]</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>1000</span><span>)</span><span>:</span>
    
    rectangle <span>=</span> <span>[</span><span>round</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>,</span>
                 <span>round</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>,</span>
                 <span>round</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>,</span>
                 <span>round</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>]</span>
    rectangles<span>.</span>append<span>(</span>rectangle<span>)</span>
    
    rectangle_average<span>.</span>append<span>(</span><span>sum</span><span>(</span>rectangle<span>)</span> <span>/</span> <span>4</span><span>)</span>
</code></pre><p>Brilliant, so we can now feed these to our little neural network and get a
result! Next step is for our neural network to adjust the values in the hidden
layer based on how its output compares with the actual average in the training
data. This is called our <code>loss</code> function: large loss, very wrong model; small
loss, less wrong model. We can use a standard measure called <a href="https://en.wikipedia.org/wiki/Mean_squared_error"><em>mean squared
error</em></a>:</p><pre><code>


<span>def</span> <span>mean_squared_error</span><span>(</span>actual<span>,</span> expected<span>)</span><span>:</span>
    error_sum <span>=</span> <span>0</span>
    <span>for</span> a<span>,</span> b <span>in</span> <span>zip</span><span>(</span>actual<span>,</span> expected<span>)</span><span>:</span>
        error_sum <span>+=</span> <span>(</span>a <span>-</span> b<span>)</span> <span>**</span> <span>2</span>
    <span>return</span> error_sum <span>/</span> <span>len</span><span>(</span>actual<span>)</span>

<span>print</span><span>(</span>mean_squared_error<span>(</span><span>[</span><span>1</span><span>.</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>.</span><span>]</span><span>)</span><span>)</span>

<span>print</span><span>(</span>mean_squared_error<span>(</span><span>[</span><span>1</span><span>.</span><span>]</span><span>,</span> <span>[</span><span>3</span><span>.</span><span>]</span><span>)</span><span>)</span>

</code></pre><p>Now we can implement <code>train()</code>:</p><pre><code><span>def</span> <span>model</span><span>(</span>rectangle<span>,</span> hidden_layer<span>)</span><span>:</span>
    output_neuron <span>=</span> <span>0</span><span>.</span>
    <span>for</span> index<span>,</span> input_neuron <span>in</span> <span>enumerate</span><span>(</span>rectangle<span>)</span><span>:</span>
        output_neuron <span>+=</span> input_neuron <span>*</span> hidden_layer<span>[</span>index<span>]</span>
    <span>return</span> output_neuron

<span>def</span> <span>train</span><span>(</span>rectangles<span>,</span> hidden_layer<span>)</span><span>:</span>
  outputs <span>=</span> <span>[</span><span>]</span>
  <span>for</span> rectangle <span>in</span> rectangles<span>:</span>
      output <span>=</span> model<span>(</span>rectangle<span>,</span> hidden_layer<span>)</span>
      outputs<span>.</span>append<span>(</span>output<span>)</span>
  <span>return</span> outputs

hidden_layer <span>=</span> <span>[</span><span>0.98</span><span>,</span> <span>0.4</span><span>,</span> <span>0.86</span><span>,</span> <span>-</span><span>0.08</span><span>]</span>
outputs <span>=</span> train<span>(</span>rectangles<span>,</span> hidden_layer<span>)</span>

<span>print</span><span>(</span>outputs<span>[</span><span>0</span><span>:</span><span>10</span><span>]</span><span>)</span>

<span>print</span><span>(</span>rectangle_average<span>[</span><span>0</span><span>:</span><span>10</span><span>]</span><span>)</span>

mean_squared_error<span>(</span>outputs<span>,</span> rectangle_average<span>)</span>

</code></pre><p>A good mean squared error is close to 0. Our model isn&#39;t very good. But! We&#39;ve
got the skeleton of a feedback loop in place for updating the hidden layer.</p><h3 id="updating-the-hidden-layer-with-gradient-descent">Updating the Hidden Layer with Gradient Descent</h3><p>Now what we need is a way to update the hidden layer in response to the mean
squared error / loss. We need to <em>minimize</em> the value of this function:</p><pre><code>mean_squared_error<span>(</span>
  train<span>(</span>rectangles<span>,</span> hidden_layer<span>)</span><span>,</span>
  rectangle_average
<span>)</span>
</code></pre><p>As noted earlier, the only thing we can really change here are the weights in
the hidden layer. How can we possibly know which weights will minimize this
function?</p><p>We could randomize the weights, calculate the loss (how wrong the model is,
in our case, with mean squared error), and then save the best ones we see after
some period of time.</p><p>We could possibly speed this up. If we have good weights, we could try to add
some random numbers to those. See if loss improves. This could work, but it
sounds slow... and likely to get stuck in some local maxima and not give a very
good result. And it&#39;s trouble scaling this to 1,000s of weights...</p><p>Instead of embarking on this ad-hoc randomization mess, it turns out that
there&#39;s a method called <em>gradient descent</em> to minimize the value of a function!
Gradient descent builds on a bit of calculus that you may not have touched on
since high school. We won&#39;t go into depth here, but try to introduce <em>just</em>
enough that you understand the concept. <sup id="fnref-3blue1brown"><a href="#fn-3blue1brown">3</a></sup></p><p>Let&#39;s try to understand gradient descent. Consider some random function whose
graph might look like this:</p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzc1IiBoZWlnaHQ9IjQ4NSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></span><img alt="Graph of a random function with some irregular shapes" title="Graph of a function with an irregular curve with a local and global minimum." srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Ffunction.png&amp;w=828&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Ffunction.png&amp;w=1920&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Ffunction.png&amp;w=1920&amp;q=75" decoding="async" data-nimg="intrinsic"/></span><figcaption>Graph of a function with an irregular curve with a local and global minimum.</figcaption></figure><p>How do we write code to find the minimum, the deepest (second) valley, of this function?</p><p>Let&#39;s say that we&#39;re at <code>x=1</code> and we know the <em>slope</em> of the function at this
point. The slope is &#34;how fast the function grows at this very point.&#34; You may
remember this as <em>the derivative</em>. The slope at <code>x=1</code> might be <code>-1.5</code>. This
means that every time we increase <code>x += 1</code>, it results in <code>y -= 1.5</code>. We&#39;ll go
into how you figure out the slope in a bit, let&#39;s focus on the concept first.</p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkzNCIgaGVpZ2h0PSIxMjU2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></span><img alt="Graph function with some slope or derivative" srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Ffunction-with-slope.png&amp;w=2048&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Ffunction-with-slope.png&amp;w=3840&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Ffunction-with-slope.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic"/></span></figure><p>The idea of gradient descent is that since we know the value of our function,
<code>y</code>, is decreasing as we increase <code>x</code>, we can increase <code>x</code> proportionally to the
slope. In other words, if we increase <code>x</code> by the slope, we step towards the
valley by <code>1.5</code>.</p><p>Let&#39;s take that step of <code>x += 1.5</code>:</p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkzNCIgaGVpZ2h0PSIxMjU2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></span><img alt="Overshooting in gradient descent" srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fgradient-descent-overshoot.png&amp;w=2048&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fgradient-descent-overshoot.png&amp;w=3840&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fgradient-descent-overshoot.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic"/></span></figure><p>Ugh, turned out that we stepped <em>too</em> far, past this valley! If we repeat the
step, we&#39;ll land somewhere on the left side of the valley, to then bounce back
on the right side. We might <em>never</em> land in the bottom of the valley. Bummer.
Either way, this isn&#39;t the <em>global minimum</em> of the function. We return to that
in a moment!</p><p>We can fix the overstepping easily by taking smaller steps. Perhaps we should&#39;ve
stepped by just <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.1</mn><mo>∗</mo><mn>1.5</mn><mo>=</mo><mn>0.15</mn></mrow><annotation encoding="application/x-tex">0.1 * 1.5 = 0.15</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0.1</span><span></span><span>∗</span><span></span></span><span><span></span><span>1.5</span><span></span><span>=</span><span></span></span><span><span></span><span>0.15</span></span></span></span></span> instead. That would&#39;ve smoothly landed us at
the bottom of the valley. That multiplier, <code>0.1</code>, is called the <em>learning rate</em>
in gradient descent.</p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkzNCIgaGVpZ2h0PSIxMjU2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></span><img alt="Minimum of function with gradient descent" srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fminimum.png&amp;w=2048&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fminimum.png&amp;w=3840&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fminimum.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic"/></span></figure><p>But hang on, that&#39;s not actually the minimum of the function. See that valley to
the right? That&#39;s the <em>actual</em> global minimum. If our initial <code>x</code> value had been
e.g. 3, we might have found the global minimum instead of our local minimum.</p><p>Finding the global minimum of a function is <em>hard</em>. Gradient descent will give
us <em>a minimum</em>, but not <em>the minimum</em>. Unfortunately, it turns out it&#39;s the best
weapon we have at our disposal. Especially when we have big, complicated
functions (like a neural net with millions of neurons). Gradient descent will
not always find the global minimum, but something <em>pretty</em> good.</p><p>This method of using the slope/derivative generalizes. For example, consider
optimizing a function in three-dimensions. We can visualize the gradient descent
method here as <em>rolling a ball to the lowest point.</em> A big neural network is
1000s of dimensions, but gradient descent still works to minimize the loss!</p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzYwIiBoZWlnaHQ9IjYyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></span><img title="Depicts a 3-dimensional graph, if we do gradient descent on this we might imagine it as rolling a ball down the hill." srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fdescent-3d.png&amp;w=828&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fdescent-3d.png&amp;w=1920&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fdescent-3d.png&amp;w=1920&amp;q=75" decoding="async" data-nimg="intrinsic"/></span><figcaption>Depicts a 3-dimensional graph, if we do gradient descent on this we might imagine it as rolling a ball down the hill.</figcaption></figure><h2 id="finalizing-our-neural-network-from-scratch">Finalizing our Neural Network from scratch</h2><p>Let&#39;s summarize where we are:</p><ul><li>We can implement a simple neural net: <code>model()</code>.</li><li>Our neural net can figure out how <em>wrong</em> it is for a training set: <code>loss(train())</code>.</li><li>We have a method, <em>gradient descent</em>, for tuning our hidden layer&#39;s weights
for the minimum loss. I.e. we have a method to adjust those four random values
in our hidden layer to take a <em>better</em> average as we iterate through the
training data.</li></ul><p>Now, let&#39;s implement gradient descent and see if we can make our neural net
learn to take the average grayscale of our small rectangles:</p><pre><code><span>def</span> <span>model</span><span>(</span>rectangle<span>,</span> hidden_layer<span>)</span><span>:</span>
    output_neuron <span>=</span> <span>0</span><span>.</span>
    <span>for</span> index<span>,</span> input_neuron <span>in</span> <span>enumerate</span><span>(</span>rectangle<span>)</span><span>:</span>
        output_neuron <span>+=</span> input_neuron <span>*</span> hidden_layer<span>[</span>index<span>]</span>
    <span>return</span> output_neuron

<span>def</span> <span>train</span><span>(</span>rectangles<span>,</span> hidden_layer<span>)</span><span>:</span>
  outputs <span>=</span> <span>[</span><span>]</span>
  <span>for</span> rectangle <span>in</span> rectangles<span>:</span>
      output <span>=</span> model<span>(</span>rectangle<span>,</span> hidden_layer<span>)</span>
      outputs<span>.</span>append<span>(</span>output<span>)</span>

  mean_squared_error<span>(</span>outputs<span>,</span> rectangle_average<span>)</span>

  
  
  
  
  
  
  
  <span>for</span> index<span>,</span> _ <span>in</span> <span>enumerate</span><span>(</span>hidden_layer<span>)</span><span>:</span>
    learning_rate <span>=</span> <span>0.1</span>
    
    hidden_layer<span>[</span>index<span>]</span> <span>-=</span> learning_rate <span>*</span> hidden_layer<span>[</span>index<span>]</span><span>.</span>slope

  <span>return</span> outputs

hidden_layer <span>=</span> <span>[</span><span>0.98</span><span>,</span> <span>0.4</span><span>,</span> <span>0.86</span><span>,</span> <span>-</span><span>0.08</span><span>]</span>
train<span>(</span>rectangles<span>,</span> hidden_layer<span>)</span>
</code></pre><h3 id="automagically-computing-the-slope-of-a-function-with-autograd">Automagically computing the slope of a function with <code>autograd</code></h3><p>The missing piece here is to figure out the <code>slope()</code> after we&#39;ve gone through
our training set. Figuring out the slope/derivative at a certain point is
tricky. It involves a fair bit of math. I am not going to go into the math of
calculating derivatives. Instead, we&#39;ll do what all the machine learning
libraries do: automatically calculate it. <sup id="fnref-nielsen"><a href="#fn-nielsen">4</a></sup></p><p>Minimizing the loss of a function is absolutely fundamental to machine learning.
The functions (neural networks) are <em>so</em> complicated that manually sitting down
to figure out the derivative like you might&#39;ve done in high school is not
feasible. It&#39;s the mathematical equivalent of writing assembly to implement a
website.</p><p>Let&#39;s show one simple example of finding the derivative of a function, before we
let the computers do it all for us. If we have <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x) = x^2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span><span>(</span><span>x</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span></span>, then you might
remember from calculus classes that the derivative is <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">f&#39;(x) = 2x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>f</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>(</span><span>x</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span><span>x</span></span></span></span></span>. In other
words, <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span><span>(</span><span>x</span><span>)</span></span></span></span></span>&#39;s slope at any point is <code>2x</code>, telling us it&#39;s increasing
non-linearly. Well that&#39;s exactly how we understand <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span></span>, perfect! This means
that for <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x = 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span></span> the slope is <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>4</span></span></span></span></span>.</p><p>With the basics in order, we can use an <code>autograd</code> package to avoid the messy
business of computing our own derivatives. <code>autograd</code> is an <em>automatic
differentiation engine</em>. <em>grad</em> stands for <em>gradient</em>, which we can think of as the
derivative/slope of a function with more than one parameter.</p><p>It&#39;s best to show how it works by using our example from before:</p><pre><code><span>import</span> torch




x <span>=</span> torch<span>.</span>tensor<span>(</span><span>2</span><span>.</span><span>,</span> requires_grad<span>=</span><span>True</span><span>)</span>


y <span>=</span> x <span>**</span> <span>2</span>




y<span>.</span>backward<span>(</span><span>)</span>


<span>print</span><span>(</span>x<span>.</span>grad<span>)</span>

</code></pre><p><code>autograd</code> is the closest to magic we get. I could do the most ridiculous stuff
with this tensor, and it&#39;ll keep track of all the math operations applied and
have the ability to compute the derivative. We won&#39;t go into how. Partly because
I don&#39;t know how, and this post is long enough.</p><p>Just to convince you of this, we can be a little cheeky and do a bunch of random
stuff. I&#39;m trying to really hammer this home, because this is what confused me
the most when learning about neural networks. It wasn&#39;t obvious to me that a
neural network, including executing the loss function on the whole training set,
is <em>just</em> a function, and however complicated, we can still take the derivative
of it and use gradient descent. Even if it&#39;s so many dimensions that it can&#39;t be
neatly visualized as a ball rolling down a hill.</p><p><code>autograd</code> doesn&#39;t complain as we add complexity and will still calculate the
gradients. In this example we&#39;ll even use a matrix/tensor with a few more elements and
calculate an average (like our loss function <code>mean_squared_error</code>), which is the
kind of thing we&#39;ll calculate the gradients for in our neural network:</p><pre><code><span>import</span> random

x <span>=</span> torch<span>.</span>tensor<span>(</span><span>[</span><span>0.2</span><span>,</span><span>0.3</span><span>,</span><span>0.8</span><span>,</span><span>0.1</span><span>]</span><span>,</span> requires_grad<span>=</span><span>True</span><span>)</span>

<span>for</span> _i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    choice <span>=</span> random<span>.</span>randint<span>(</span><span>0</span><span>,</span> <span>3</span><span>)</span>
    <span>if</span> choice <span>==</span> <span>0</span><span>:</span>
        y <span>=</span> x <span>**</span> random<span>.</span>randint<span>(</span><span>0</span><span>,</span><span>10</span><span>)</span>
    <span>elif</span> choice <span>==</span> <span>1</span><span>:</span>
        y <span>=</span> x<span>.</span>sqrt<span>(</span><span>)</span>
    <span>elif</span> choice <span>==</span> <span>2</span><span>:</span>
        y <span>=</span> x<span>.</span>atanh<span>(</span><span>)</span>
    <span>elif</span> choice <span>==</span> <span>3</span><span>:</span>
        y <span>=</span> x<span>.</span>log<span>(</span><span>)</span>

y <span>=</span> y<span>.</span>mean<span>(</span><span>)</span>



y<span>.</span>backward<span>(</span><span>)</span>



<span>print</span><span>(</span>x<span>.</span>grad<span>)</span>

</code></pre><p>Let&#39;s use <code>autograd</code> for our neural net and then run it against our square from
earlier <code>model(<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[0.2, 0.5, 0.4, 0.7]</title><rect fill="#E3E3E3" x="0" y="0" width="1" height="1"></rect><rect fill="#989898" x="1" y="0" width="1" height="1"></rect><rect fill="#B1B1B1" x="0" y="1" width="1" height="1"></rect><rect fill="#656565" x="1" y="1" width="1" height="1"></rect></svg>) =<!-- --> <!-- -->0.45</code>:</p><pre><code><span>import</span> torch <span>as</span> torch

<span>def</span> <span>model</span><span>(</span>rectangle<span>,</span> hidden_layer<span>)</span><span>:</span>
    output_neuron <span>=</span> <span>0</span><span>.</span>
    <span>for</span> index<span>,</span> input_neuron <span>in</span> <span>enumerate</span><span>(</span>rectangle<span>)</span><span>:</span>
        output_neuron <span>+=</span> input_neuron <span>*</span> hidden_layer<span>[</span>index<span>]</span>
    <span>return</span> output_neuron

<span>def</span> <span>train</span><span>(</span>rectangles<span>,</span> hidden_layer<span>)</span><span>:</span>
  outputs <span>=</span> <span>[</span><span>]</span>
  <span>for</span> rectangle <span>in</span> rectangles<span>:</span>
      output <span>=</span> model<span>(</span>rectangle<span>,</span> hidden_layer<span>)</span>
      outputs<span>.</span>append<span>(</span>output<span>)</span>

  
  error <span>=</span> mean_squared_error<span>(</span>outputs<span>,</span> rectangle_average<span>)</span>

  
  
  
  error<span>.</span>backward<span>(</span><span>)</span>

  
  
  
  <span>for</span> index<span>,</span> _ <span>in</span> <span>enumerate</span><span>(</span>hidden_layer<span>)</span><span>:</span>
    learning_rate <span>=</span> <span>0.1</span>
    
    hidden_layer<span>.</span>data<span>[</span>index<span>]</span> <span>-=</span> learning_rate <span>*</span> hidden_layer<span>.</span>grad<span>.</span>data<span>[</span>index<span>]</span>

  
  
  hidden_layer<span>.</span>grad<span>.</span>zero_<span>(</span><span>)</span>
  <span>return</span> error



hidden_layer <span>=</span> torch<span>.</span>tensor<span>(</span><span>[</span><span>0.98</span><span>,</span> <span>0.4</span><span>,</span> <span>0.86</span><span>,</span> <span>-</span><span>0.08</span><span>]</span><span>,</span> requires_grad<span>=</span><span>True</span><span>)</span>

<span>print</span><span>(</span>model<span>(</span><span>[</span><span>0.2</span><span>,</span><span>0.5</span><span>,</span><span>0.4</span><span>,</span><span>0.7</span><span>]</span><span>,</span> hidden_layer<span>)</span><span>)</span>


train<span>(</span>rectangles<span>,</span> hidden_layer<span>)</span>



<span>print</span><span>(</span><span><span>f&#34;After: </span><span><span>{</span>model<span>(</span><span>[</span><span>0.2</span><span>,</span><span>0.5</span><span>,</span><span>0.4</span><span>,</span><span>0.7</span><span>]</span><span>,</span> hidden_layer<span>)</span><span>}</span></span><span>&#34;</span></span><span>)</span>


</code></pre><p>This blew my mind the first time I did this. Look at that. It&#39;s optimizing the
hidden layer for all weights in the right direction! We&#39;re expecting them all
to nudge towards <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.25</mn></mrow><annotation encoding="application/x-tex">0.25</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0.25</span></span></span></span></span> to implement <code>average()</code>. We haven&#39;t told it <em>anything</em>
about average, we&#39;ve just told it how wrong it is through the loss.</p><p><em>But</em>, the hidden layer isn&#39;t all <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.25</mn></mrow><annotation encoding="application/x-tex">0.25</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0.25</span></span></span></span></span> quite yet, as we expect for it to
implement <code>average</code>. So how do we get them to that? Well, let&#39;s try to repeat
the gradient descent process 100 times and see if we&#39;re getting even better!</p><pre><code>
<span>for</span> epoch <span>in</span> <span>range</span><span>(</span><span>100</span><span>)</span><span>:</span>
   error <span>=</span> train<span>(</span>rectangles<span>,</span> hidden_layer<span>)</span>
   <span>print</span><span>(</span><span><span>f&#34;Epoch: </span><span><span>{</span>epoch<span>}</span></span><span>, Error: </span><span><span>{</span>error<span>}</span></span><span>, Layer: </span><span><span>{</span>hidden_layer<span>.</span>data<span>}</span></span><span>\n\n&#34;</span></span><span>)</span>
   
   


<span>print</span><span>(</span>model<span>(</span><span>[</span><span>0.2</span><span>,</span><span>0.5</span><span>,</span><span>0.4</span><span>,</span><span>0.7</span><span>]</span><span>,</span> hidden_layer<span>)</span><span>.</span>item<span>(</span><span>)</span><span>)</span>

</code></pre><p>Pretty close, but not quite there. I ran it for <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>300</mn></mrow><annotation encoding="application/x-tex">300</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>300</span></span></span></span></span> times (an iteration over
the full training set is referred to as an epoch, so 300 epochs) instead, and
then I got:</p><pre><code><span>print</span><span>(</span>model<span>(</span><span>[</span><span>0.2</span><span>,</span><span>0.5</span><span>,</span><span>0.4</span><span>,</span><span>0.7</span><span>]</span><span>,</span> hidden_layer<span>)</span><span>.</span>item<span>(</span><span>)</span><span>)</span>


</code></pre><p>Boom! Our neural net has <em>almost</em> learned to take the average, off by just a
scanty <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.002</mn></mrow><annotation encoding="application/x-tex">0.002</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0.002</span></span></span></span></span>. If we fine-tuned the learning rate and number of epochs we could
probably get it there, but I&#39;m happy with this. <code>model(<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2" width="18" height="18" style="position:relative;top:3px"><title>[0.2, 0.5, 0.4, 0.7]</title><rect fill="#E3E3E3" x="0" y="0" width="1" height="1"></rect><rect fill="#989898" x="1" y="0" width="1" height="1"></rect><rect fill="#B1B1B1" x="0" y="1" width="1" height="1"></rect><rect fill="#656565" x="1" y="1" width="1" height="1"></rect></svg>) =<!-- --> <!-- -->0.448</code>:</p><p>That&#39;s it. That&#39;s your first neural net: </p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">model(rectangle) \approx avg(rectangle)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>m</span><span>o</span><span>d</span><span>e</span><span>l</span><span>(</span><span>rec</span><span>t</span><span>an</span><span>g</span><span>l</span><span>e</span><span>)</span><span></span><span>≈</span><span></span></span><span><span></span><span>a</span><span>vg</span><span>(</span><span>rec</span><span>t</span><span>an</span><span>g</span><span>l</span><span>e</span><span>)</span></span></span></span></span></p><h2 id="ok-so-you-just-implemented-the-most-complicated-average-function-ive-ever-seen">OK, so you just implemented the most complicated <code>average</code> function I&#39;ve ever seen...</h2><p>Sure did. The thing is, that if we adjusted it for looking for cats, it&#39;s the
least complicated <code>is_cat</code> you&#39;ll ever see. Because our neural network could
implement that too by changing the training data. Remember, a neural network
with enough neurons can approximate <em>any function</em>. You&#39;ve just learned all the
building blocks to do it. We just started with the simplest possible example.</p><p>If you give the hidden layer some more neurons, this neural net will be able to
recognize <a href="http://yann.lecun.com/exdb/mnist/">handwritten numbers</a> with decent accuracy (possible fun
exercise for you, see bottom of article), like this one:</p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></span><img title="An upscaled version of a handdrawn 3 from the 28x28 MNIST dataset." srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fmnist-sample.png&amp;w=256&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fmnist-sample.png&amp;w=640&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Fmnist-sample.png&amp;w=640&amp;q=75" decoding="async" data-nimg="intrinsic"/></span><figcaption>An upscaled version of a handdrawn 3 from the 28x28 MNIST dataset.</figcaption></figure><h3 id="activation-functions">Activation Functions</h3><p>To be truly powerful, there is one paramount modification we have to make to our
neural net. Above, we were implementing the <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">average</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span>v</span><span>er</span><span>a</span><span>g</span><span>e</span></span></span></span></span> function. However, were
our neural net to implement <code>which_digit(png)</code> or <code>is_cat(jpg)</code> then it wouldn&#39;t work.</p><p>Recognizing handwritten digits isn&#39;t a <em>linear</em> function, like <code>average()</code>. It&#39;s
non-linear. It&#39;s a crazy function, with a crazy shape (unlike a linear
function). To create crazy functions with crazy shapes, we have to introduce a
non-linear component to our neural network. This is called an <em>activation</em>
function. It can be e.g. <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>u</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReLu(x) = max(0, x)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>R</span><span>e</span><span>Lu</span><span>(</span><span>x</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>ma</span><span>x</span><span>(</span><span>0</span><span>,</span><span></span><span>x</span><span>)</span></span></span></span></span>. There are many kinds of
<a href="https://en.wikipedia.org/wiki/Activation_function">activation functions</a> that are good for different things.
<sup id="fnref-activation"><a href="#fn-activation">5</a></sup></p><figure><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMzMyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4="/></span><img srcset="/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Frelu.png&amp;w=640&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Frelu.png&amp;w=828&amp;q=75 2x" src="https://xcorr.net/_next/image?url=%2Fimages%2Fnapkin%2Fproblem-17-neural-nets%2Frelu.png&amp;w=828&amp;q=75" decoding="async" data-nimg="intrinsic"/></span></figure><p>We can apply this simple operation to our neural net:</p><pre><code><span>def</span> <span>model</span><span>(</span>rectangle<span>,</span> hidden_layer<span>)</span><span>:</span>
    output_neuron <span>=</span> <span>0</span><span>.</span>
    <span>for</span> index<span>,</span> input_neuron <span>in</span> <span>enumerate</span><span>(</span>rectangle<span>)</span><span>:</span>
        output_neuron <span>+=</span> input_neuron <span>*</span> hidden_layer<span>[</span>index<span>]</span>
    <span>return</span> <span>max</span><span>(</span><span>0</span><span>,</span> output_neuron<span>)</span>
</code></pre><p>Now, we only have a single neuron/weight... that isn&#39;t much. Good models have
100s, and the biggest models like GPT-3 have billions. So this won&#39;t recognize
many digits or cats, but you can easily add more weights!</p><h3 id="matrices">Matrices</h3><p>The core operation in our model, the for loop, is matrix multiplication. We could
rewrite it to use them instead, e.g. <code>rectangle @ hidden_layer</code>. PyTorch will
then do the exact same thing. Except, it&#39;ll now execute in C-land. And if you
have a GPU and pass some extra weights, it&#39;ll execute on a GPU, which is even
faster. When doing any kind of deep learning, you want to avoid writing any
Python loops. They&#39;re just too slow. If you ran the code above for the 300
epochs, you&#39;ll see that it takes minutes to complete. I left matrices out of it
to simplify the explanation as much as possible. There&#39;s plenty going on without
them.</p><h2 id="next-steps-to-implement-your-own-neural-net-from-scratch">Next steps to implement your own neural net from scratch</h2><p>Even if you&#39;ve carefully read through this article, you won&#39;t fully grasp it
yet until you&#39;ve had your own hands on it. Here are some suggestions on where to
go from here, if you&#39;d like to move beyond the basic understanding you have now:</p><ol><li>Get the <a href="https://colab.research.google.com/drive/1YRp9k_ORH4wZMqXLNkc3Ir5w4B5f-8Pa?usp=sharing">notebook</a> running and study the code</li><li>Change it to far larger rectangles, e.g. 100x100</li><li>Add biases in addition to the weights. A model doesn&#39;t just have
weights that are multiplied onto the inputs, but also biases that are added
(<code>+</code>) onto the inputs in each layer.</li><li>Rewrite the model to use <a href="https://pytorch.org/docs/stable/tensors.html">PyTorch tensors</a> for matrix operations, as
described in the previous section.</li><li>Add 1-2 more layers to the model. Try to have them have different sizes.</li><li>Change the tensors to run on GPU (see the <a href="https://pytorch.org/docs/stable/notes/cuda.html">PyTorch
documentation</a>) and see the
performance speed up! Increase the size of the training set and rectangles to
<em>really</em> be able to tell the difference. Make sure you change <code>Runtime &gt;
Change Runtime Type</code> in Collab to run on a GPU.</li><li>This is a difficult step that will likely take a while, but it&#39;ll be well
worth it: Adapt the code to recognize handwritten letters from the <a href="https://s3.amazonaws.com/fast-ai-imageclas/mnist_png.tgz">MNIST
dataset</a> dataset. You&#39;ll need to use <a href="https://pillow.readthedocs.io/en/stable/"><code>pillow</code></a> to turn
the pixels into a large 1-dimensional tensor as the input layer, as well as a
non-linear activation function like <code>Sigmoid</code> or <code>ReLU</code>. Use <a href="http://neuralnetworksanddeeplearning.com/">Nielsen&#39;s
book</a> as a reference if you get stuck, which does exactly this.</li></ol><p>I thoroughly hope you enjoyed this walkthrough of a neural net from scratch! In
a future issue we&#39;ll use the mental model we&#39;ve built up here to do some napkin
math on expected performance on training and using neural nets.</p><p><em>Thanks to <a href="https://www.vegardstikbakke.com/">Vegard Stikbakke</a>, <a href="https://www.flyingcroissant.ca/">Andrew Bugera</a> and <a href="https://thundergolfer.com/">Jonathan
Belotti</a> for providing valuable feedback on drafts of this article.</em></p></article></div>
  </body>
</html>
