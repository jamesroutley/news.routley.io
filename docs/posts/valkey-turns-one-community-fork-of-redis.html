<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gomomento.com/blog/valkey-turns-one-how-the-community-fork-left-redis-in-the-dust/">Original</a>
    <h1>Valkey Turns One: Community fork of Redis</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
  
  <article>
    <div>
      

      <div>
        
<p>A year ago, Redis Inc (formerly Garantia Data) made a controversial move that disrupted the open source ecosystem: it closed the source of Redis. <a href="https://www.gomomento.com/blog/rip-redis-how-garantia-data-pulled-off-the-biggest-heist-in-open-source-history/" target="_blank" rel="noreferrer noopener">As I wrote at the time</a>, it was a trust-breaking decision that could have shattered the community.</p>



<p>But instead of splintering, the community responded with purpose. Out of that disruption came <a href="https://valkey.io/" target="_blank" rel="noreferrer noopener">Valkey</a>, a fork that took a shot at keeping the community alive.</p>



<h2>A Return, A Reversal</h2>



<p>As part of efforts to rebuild trust with the community, Redis Inc <a href="https://redis.io/blog/welcome-back-to-redis-antirez/" target="_blank" rel="noreferrer noopener">brought back</a> Salvatore Sanfilippo (aka Antirez), the original creator of Redis. I am genuinely excited about his return because it is already impactful. He’s following through on his promise of contributing new features and performance optimizations to Redis. More profoundly, <a href="https://redis.io/blog/agplv3/" target="_blank" rel="noreferrer noopener">Redis 8.0 has been open-sourced again</a>.</p>



<p>Redis acknowledged that adopting <a href="https://en.wikipedia.org/wiki/Server_Side_Public_License" target="_blank" rel="noreferrer noopener">SSPL</a> strained their bond with the community, questioning contributions from others in the same breath.</p>



<blockquote>
<figure><blockquote><p>How do you keep innovating and investing in OSS projects when cloud providers reap the profits and control the infrastructure without proportional contributions back to the projects that they exploit?</p></blockquote></figure>
</blockquote>



<p>The disheartening move from Redis Inc catalyzed an unprecedented wave of collaboration and contributions. Valkey became the test of the community resolve to keep itself together. One year later, Valkey hasn’t just survived – <a href="https://www.linkedin.com/posts/kshams_valkey-rocks-the-most-remarkable-thing-about-activity-7318683448506793985-_qJE" target="_blank" rel="noreferrer noopener">it’s thriving</a>! The Async I/O Threading model <a href="https://github.com/valkey-io/valkey/pull/758" target="_blank" rel="noreferrer noopener">contribution</a> from AWS unlocked 3x+ throughput by fundamentally changing how I/O threads work inside Redis.</p>



<p>But how do these and other contributions compare to Redis 8? Can we hit 1M RPS out of an 8 VCPU instance (c8g.2xl) on either Valkey 8.1 or Redis 8.0 (with 1KB items, 3M items in the key space, and ~500 connections)? It’s time for a bake off!</p>



<h2>Valkey 8.1 vs Redis 8.0: Can the Fork Outrun the Source?</h2>



<p>The punchline: we could not sustain 1M RPS on an 8 VCPU instance with either Valkey or Redis 8.0, but we got really close!!</p>



<p>On a full-tuned c8g.2xl (8 VCPU), Valkey 8.1.1 pushed to 999.8K RPS on SETs with .8ms p99 latency. Redis 8.0 got as high as 729.4 RPS on SETs with .99ms p99 latencies. On each iteration, we tested 50M SETs followed by 50M GETs. We varied connection counts to optimize the maximum throughput for each system.</p>



<figure><blockquote><p><mark>Valkey achieved higher throughput and lower latency across both reads and writes (37% higher on SET and 16% higher on GET), alongside 30% faster p99 latencies for SET and 60%+ faster on GET.</mark></p></blockquote></figure>



<figure><img decoding="async" width="1024" height="512" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20512&#39;%3E%3C/svg%3E" alt="" data-lazy-srcset="https://www.gomomento.com/wp-content/uploads/2025/05/Valkey-vs-Redis-threads-graphic-1-1024x512.png 1024w, https://www.gomomento.com/wp-content/uploads/2025/05/Valkey-vs-Redis-threads-graphic-1-300x150.png 300w, https://www.gomomento.com/wp-content/uploads/2025/05/Valkey-vs-Redis-threads-graphic-1-768x384.png 768w, https://www.gomomento.com/wp-content/uploads/2025/05/Valkey-vs-Redis-threads-graphic-1-18x9.png 18w, https://www.gomomento.com/wp-content/uploads/2025/05/Valkey-vs-Redis-threads-graphic-1.png 1200w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.gomomento.com/wp-content/uploads/2025/05/Valkey-vs-Redis-threads-graphic-1-1024x512.png"/></figure>



<figure><img decoding="async" width="1024" height="341" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20341&#39;%3E%3C/svg%3E" alt="Valkey vs Redis table with SET and GET command" data-lazy-srcset="https://www.gomomento.com/wp-content/uploads/2025/05/Maximum-set-and-get-table_v2-1024x341.png 1024w, https://www.gomomento.com/wp-content/uploads/2025/05/Maximum-set-and-get-table_v2-300x100.png 300w, https://www.gomomento.com/wp-content/uploads/2025/05/Maximum-set-and-get-table_v2-768x256.png 768w, https://www.gomomento.com/wp-content/uploads/2025/05/Maximum-set-and-get-table_v2-18x6.png 18w, https://www.gomomento.com/wp-content/uploads/2025/05/Maximum-set-and-get-table_v2.png 1200w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.gomomento.com/wp-content/uploads/2025/05/Maximum-set-and-get-table_v2-1024x341.png"/></figure>



<h2>Threading the multi-threading needle</h2>



<p>If I had a penny for every time heard, “but Redis /Valkey is single threaded….”</p>



<p>Antirez’s emphasis on a shared nothing architecture has been foundational for Redis. Nevertheless, as early as 2020, Redis added support for I/O threads. Unfortunately, they did not offer drastic improvement until recently. If you have previously tried and discarded I/O threads, it is time to evaluate again!</p>



<p>On Valkey, we see SET throughput going from 239K RPS without I/O threads to 678K with 6 threads. Meanwhile, p99 latencies dropped from 1.68ms to 0.93ms <strong>despite doing nearly 3x the throughput</strong>! Similarly, Redis went from 235K RPS without I/O threads to 563K RPS with 6 I/O threads. P99s for Redis also dropped around 40% from 1.35ms to 0.84ms.</p>



<p>Two key takeaways emerged:</p>



<ol>
<li>With two threads, gains were modest (~20%). The impact only really surfaced at three threads and beyond.</li>



<li>Redis and Valkey were neck-and-neck until the fourth thread. After that, Valkey pulled away sharply.</li>
</ol>



<figure><img decoding="async" width="1024" height="512" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20512&#39;%3E%3C/svg%3E" alt="" data-lazy-srcset="https://www.gomomento.com/wp-content/uploads/2025/05/Set-performance-with-IO-threads_v2-1024x512.png 1024w, https://www.gomomento.com/wp-content/uploads/2025/05/Set-performance-with-IO-threads_v2-300x150.png 300w, https://www.gomomento.com/wp-content/uploads/2025/05/Set-performance-with-IO-threads_v2-768x384.png 768w, https://www.gomomento.com/wp-content/uploads/2025/05/Set-performance-with-IO-threads_v2-18x9.png 18w, https://www.gomomento.com/wp-content/uploads/2025/05/Set-performance-with-IO-threads_v2.png 1200w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.gomomento.com/wp-content/uploads/2025/05/Set-performance-with-IO-threads_v2-1024x512.png"/></figure>



<h3>SET Performance on Valkey with IO/Threads &amp; 256 Connections:</h3>



<figure><img decoding="async" width="700" height="500" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20700%20500&#39;%3E%3C/svg%3E" alt="" data-lazy-srcset="https://www.gomomento.com/wp-content/uploads/2025/05/SET-Performance-on-Valkey.png 700w, https://www.gomomento.com/wp-content/uploads/2025/05/SET-Performance-on-Valkey-300x214.png 300w, https://www.gomomento.com/wp-content/uploads/2025/05/SET-Performance-on-Valkey-18x12.png 18w" data-lazy-sizes="(max-width: 700px) 100vw, 700px" data-lazy-src="https://www.gomomento.com/wp-content/uploads/2025/05/SET-Performance-on-Valkey.png"/></figure>



<h3>SET Performance on Redis with IO/Threads &amp; 256 Connections:</h3>



<figure><img decoding="async" width="700" height="500" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20700%20500&#39;%3E%3C/svg%3E" alt="" data-lazy-srcset="https://www.gomomento.com/wp-content/uploads/2025/05/SET-performance-on-Redis.png 700w, https://www.gomomento.com/wp-content/uploads/2025/05/SET-performance-on-Redis-300x214.png 300w, https://www.gomomento.com/wp-content/uploads/2025/05/SET-performance-on-Redis-18x12.png 18w" data-lazy-sizes="(max-width: 700px) 100vw, 700px" data-lazy-src="https://www.gomomento.com/wp-content/uploads/2025/05/SET-performance-on-Redis.png"/></figure>



<h2>Pushing Valkey Throughput Further</h2>



<p>In the previous section, we saw that Valkey could hit 678K RPS on SETs with 6 threads and 256 connections. If we up the connections to 400, the throughput goes up to 832K RPS. How did we get the additional 167K RPS?</p>



<p>We used <a href="https://github.com/iopsystems/rezolus" target="_blank" rel="noreferrer noopener">Rezolus</a>, our favorite Linux performance telemetry agent, to get deep insights into the system under stress. You can see in the charts below that overall CPU utilization is around 80% and unevenly distributed across the 8 cores.</p>



<p>Diving deeper, this is driven by hardware interrupts from network queues across all 8 cores. Interrupts are bad because they disrupt a hard working Valkey thread to yield to handle network packets.</p>



<figure><img decoding="async" width="1024" height="835" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20835&#39;%3E%3C/svg%3E" alt="CPU Usage chart" data-lazy-srcset="https://www.gomomento.com/wp-content/uploads/2025/05/image-1-1024x835.png 1024w, https://www.gomomento.com/wp-content/uploads/2025/05/image-1-300x245.png 300w, https://www.gomomento.com/wp-content/uploads/2025/05/image-1-768x627.png 768w, https://www.gomomento.com/wp-content/uploads/2025/05/image-1-15x12.png 15w, https://www.gomomento.com/wp-content/uploads/2025/05/image-1.png 1445w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.gomomento.com/wp-content/uploads/2025/05/image-1-1024x835.png"/></figure>



<p>What if we could avoid the context switching on our <code><sup>c8g.2xl</sup></code> with 8 cores? Running close to a million RPS requires considerable packet processing horsepower. Luckily, since a lot of work happens at the Nitro level on EC2 instances, two allocated cores to IRQs is all you need (if you let them focus). Pinning the IRQs to two cores is pretty straightforward.</p>



<pre><code>sudo ethtool -L ens34 combined 2 # reduce to 2 IRQs
grep ens34 /proc/interrupts # ours were on 99 and 100
echo 1 | sudo tee /proc/irq/99/smp_affinity # pin 99 to core 1
echo 2 | sudo tee /proc/irq/100/smp_affinity # pin 100 to core 2</code></pre>



<p>But how do we let these threads focus? and how do we avoid Redis / Valkey threads contending for the same cores? We pin Redis/Valkey to cores 3-8, giving their IO-Threads better isolation while also allowing the IRQs to focus. We used the <code><sup>--cpuset-cpus</sup></code> Docker flag to set these CPU assignments, making sure that Redis and Valkey process stayed pinned to the intended cores throughout the test. This reduces cross-core contention and improves cache locality, <strong>both of which are critical for minimizing tail latencies at high throughput</strong>. Ideal core allocation can vary in multi-tenant environments or mixed workloads, but in this benchmark it provided clean isolation between system and application workloads.</p>



<p><strong>Redis:</strong></p>



<pre><code>docker run --network=&#34;host&#34; --rm \
  --cpuset-cpus=&#34;2-7&#34; redis:8.0 \
  --save &#34;&#34; --appendonly no \
  --io-threads 6  \
  --protected-mode no --maxmemory 10gb</code></pre>



<p><strong>Valkey:</strong></p>



<pre><code>docker run --network=&#34;host&#34; --rm \
  --cpuset-cpus=&#34;2-7&#34; valkey/valkey:8.1.1 \
  --save &#34;&#34; --appendonly no --io-threads 6 \
  --protected-mode no --maxmemory 10gb</code></pre>



<p>Let’s see what Rezolus has to say about the new setup with IRQs pinned to the first 2 cores and Valkey pinned to the remaining 6 cores. First, we observed meaningfully higher CPU Utilization. Second, looking at the bottom chart (SoftIRQ), we see that it is now limited to only the first two cores. Third, the Valkey cores are running red hot, whereas we previously saw a much more scattered distribution one usage across cores. <strong>While this setup is ideal for this benchmark, optimal IRQ tuning depends heavily on NIC architecture and the concurrency model of your application.</strong></p>



<figure><img decoding="async" width="720" height="603" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20720%20603&#39;%3E%3C/svg%3E" alt="CPU Chart 2" data-lazy-srcset="https://www.gomomento.com/wp-content/uploads/2025/05/image-2.png 720w, https://www.gomomento.com/wp-content/uploads/2025/05/image-2-300x251.png 300w, https://www.gomomento.com/wp-content/uploads/2025/05/image-2-14x12.png 14w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://www.gomomento.com/wp-content/uploads/2025/05/image-2.png"/></figure>



<p>The extra 20% CPU utilization is what buys us the extra 167K RPS (from 832K RPS to 999.8K RPS).</p>



<h2>Try it Yourself (And Know Before You Go)</h2>



<p>These benchmarks are hopefully a beginning and not the end. Our hope is that this sets up both Valkey and Redis communities to continue the performance improvement journey. We also recognize that many folks may want to reproduce the benchmark in their own environments, incorporating their workflow specifics. Below, we outline some key instructions that you can use to reproduce this in your own AWS account within an hour.</p>



<p><strong>Instance Types:</strong> We used AWS Graviton4-based <code><sup>c8g</sup></code> instances, launched in September 2024. The <sup><code>c8g.2xlarge</code></sup> server node provides 8 vCPUs (costing roughly $250/month in us-east-1), while the <code><sup>c8g.8xlarge</sup></code> load generator offers 32 vCPUs. This provided enough CPU headroom to cleanly isolate the benchmark workload, IRQ handling, and Redis/Valkey processing. The same c8g.2xl instance was used to run valkey and redis (one at a time). The same load gen node was run each time. Valkey and Redis were restarted right before each test to ensure fairness.</p>



<p><strong>Placement Groups:</strong> We used EC2 placement groups (cluster mode) to ensure minimal network jitter and low-latency communication between the client and server nodes. Placement groups offer extremely tight latencies by reducing the number of hops between your EC2 instances. This has the upside on higher throughput, fewer interruptions, and lower latencies – but it has some shared fate / blast radius implications that are worth considering before deploying them in your production environment.</p>



<p><strong>Core Pinning.</strong> To see the highest throughput and lowest latencies, consider core pinning and reducing the IRQs. See section above for specific instructions we used on our 8 core instance. It is also important to apply similar techniques on your test nodes.</p>



<p><strong>Vary the connections.</strong> Connection count is a surprisingly crucial variable for both Redis and Valkey. In fact, latencies rise steeply as you approach 1024 connections on both of them. For example, going from 400 to 1024 connections, Valkey’s SET throughput dropped from 999.9K RPS with to 969K RPS and p99 latencies doubled from .8ms to 1.6ms (at 2048 conns, p99 latencies triple). Going from 384 connections to 1024, Redis throughput drops from 729.4K RPS to 668K RPS, and p99 latencies more than double from .99ms to 2.5ms. Lower throughput with higher latencies? You get why connection count tuning is so crucial here.</p>



<p><strong>Key Space.</strong> If you want the best numbers, <a href="https://www.linkedin.com/posts/yaoyue-thinkingfish_my-performance-rant-of-the-day-if-you-are-activity-7326350824261980161-qB6h/?utm_source=share&amp;utm_medium=member_desktop&amp;rcm=ACoAAAANW9wBFDc3gQ3Jwp6YswZ_BARGfJvyJQQ" target="_blank" rel="noreferrer noopener">use smaller values and a really small key space</a> (<sup><code>-r 10000</code></sup>). This will help you get everything from L3 cache. To make this test slightly more real world, we used 1KB items (<code><sub><sup>-d 1024</sup></sub></code>) and a key space of 3Million (<code><sup>-r 3000000</sup></code>).</p>



<p><strong>Multi-Thread the Benchmark App.</strong> To get the maximum throughput out of valkey-benchmark, make sure to turn on multi-threading on the benchmark tool as well. The <code><sup>--threads 6</sup></code> flag tells valkey-benchmark to run in multi-threaded mode.</p>



<p><strong>Benchmark command:</strong></p>



<pre><code>docker run --network=&#34;host&#34; --rm --cpuset-cpus=&#34;2-7&#34; \
valkey/valkey:8.0.1 valkey-benchmark \
-h 172.31.4.92 -p 6379 -t SET,GET -n 100000000 -c 256 \
-r 3000000 --threads 6 -d 1024</code></pre>



<h2>A Final Caveat: Benchmarking is imprecise in nature</h2>



<p>We made every effort to make this benchmark resemble more real world workflows, but you can always do better. Valkey-bench is not perfect (nothing is). We have a wishlist of improvements (and so <a href="https://github.com/valkey-io/valkey/issues/900" target="_blank" rel="noreferrer noopener">does</a> the Valkey project).</p>



<p>First, today, it simply pushes as much load as the server is able to handle instead of targeting a particular TPS. The real world rarely modulates its throughput based on your latency. Second, once it can target specific load, it would become closer to real world if it could modulate the load to show spikes and troughs as opposed to running a consistent throughput profile. Lastly, it’s rare to see 100% GETs or 100% SETs in a Key Value cache workflow. We’d love to provide a SET:GET ratio to see how the system reacts.</p>



<p>At Momento, we typically do our testing using <a href="https://github.com/iopsystems/rpc-perf" target="_blank" rel="noreferrer noopener">rpc-perf</a>. It is written entirely in rust, handles more real world scenarios (like the three feature requests above), and pairs incredibly well with Rezolus. Regardless, even rpc-perf is a synthetic benchmark and even though it gives you more degrees of freedom to simulate production workflows, the results should not be interpreted as generally applicable to every workflow. Small variables make huge differences – and simulations are no match for production.</p>



<h2>Final Thoughts: Performance Is a Practice</h2>



<p>Valkey has not only kept pace – it’s setting it. Meanwhile, the performance ceiling keeps rising. But getting there isn’t automatic. It requires expertise across systems, infrastructure, and workload behavior.</p>



<p>At Momento, we help teams achieve this kind of performance every day. Whether you’re running Valkey, Redis, or evaluating your options – we’re here to help you scale with confidence.</p>



<p><strong>Want help tuning your real-time infrastructure? <a href="https://gomomento.com/contact-us" target="_blank" rel="noreferrer noopener">Let’s talk.</a></strong></p>







<hr/>



<p><strong>Special thanks to Yao and Brian from <a href="https://iop.systems/" target="_blank" rel="noreferrer noopener">IOP Systems</a> for providing the tools, including rpc-perf and rezolus, as well as insights for this benchmark.</strong></p>




        
      </div>
      
    </div>

  </article>
  


</div></div>
  </body>
</html>
