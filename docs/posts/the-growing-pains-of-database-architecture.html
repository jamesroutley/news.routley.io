<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.figma.com/blog/how-figma-scaled-to-multiple-databases/">Original</a>
    <h1>The growing pains of database architecture</h1>
    
    <div id="readability-page-1" class="page"><div><p>In 2020, Figma’s infrastructure hit some growing pains due to a combination of new features, preparing to launch a second product, and more users (database traffic grows approximately 3x annually). We knew that the infrastructure that supported Figma in the early years wouldn’t be able to scale to meet our demands. We were still using a single, large Amazon <a href="https://aws.amazon.com/rds/" _key="af02d26dfa8b" _type="link">RDS</a> database to persist most of our metadata—like permissions, file information, and comments—and while it seamlessly handled many of our core collaborative features, one machine has its limits. Most visibly, we observed upwards of 65% CPU utilization during peak traffic due to the volume of queries serviced by one database. Database latencies become increasingly unpredictable as usage edges closer to the limit, affecting core user experiences.</p><p>If our database became completely saturated, Figma would stop working.</p><p>We were far from that, but as an infrastructure team, our goal is to identify and fix scalability issues proactively before they come close to being imminent threats. We needed to devise a solution that would reduce potential instability and pave the way for future scale. Plus, performance and reliability would continue to be top of mind as we implemented that solution; our team aims to build a sustainable platform that allows engineers to rapidly iterate on Figma’s products without impacting the user experience. If Figma’s infrastructure is a series of roads, we can’t just shut down the highways while we work on them.</p><p>We started with a few tactical fixes to secure an additional year of runway, while we set the foundation for a more comprehensive approach:</p><ol><li>Upgrade our database to the largest instance available (from <a href="https://aws.amazon.com/rds/instance-types/" _key="eef60288ab08" _type="link">r5.12xlarge to r5.24xlarge</a>) to maximize CPU utilization runway</li><li>Create multiple <a href="https://aws.amazon.com/rds/features/read-replicas/" _key="0aae931da3c4" _type="link">read replicas</a> to scale read traffic</li><li>Establish new databases for new use cases to limit growth on original database</li><li>Add <a href="https://www.pgbouncer.org/" _key="6f54aef46fdd" _type="link">PgBouncer</a> as a connection pooler to limit the impact of a growing number of connections (which were in the thousands)</li></ol><figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACHElEQVQokW2S20tUURSHB3rpIecaopmWGXRRwRi6EVKIWIh5SWfOGSYLa0QqjChIikoqkaggkhxLa3R0zjn7eBlhUBOiizHSBaRIjIJ0ovf6F744R2dKmIePtffam9/67bWXxSYkrLqM1YhCImMFayqfBl1Ki03IWJKL9bqfvNEmCqLN5EcDZI2cwCkkssUx8vVatug15Op1uIQXh3acTCVAVqSFTOU0Ds1vahhapqBdkykeOUPg1QPaPw5x+f0zKqavU6B5qVQPcGW8mJuxQk5F91AoqskLX8DdG6T0sYq77xEbB89j13z/BB2qTEW0DXVumi+Jb8wufuZSvI/dkQauRbbyaWodiy/WIiY2UC4OU/S0k5rudzR2LVEdjLOjv8N0mRJ0KjJVY1eZmHvDr6WffE1858ZsmP3hejoHcknE1vDnuYWpmItKtZySvvtI3Qs0d/3GG5ynuP+e2Yb/HEocGr5IMD7K64UPxOZnaHn5kJLBelpD25gctjMTzaBrZBOlyhF2hjo4+iSOv+cHVb1v2T5wa7VDmyaRrzVRPt6Gd+o2tZPt7Iq2kqN4cIfLqB3ah0fZS5lykM1qHTmRcxT138Ud6qFw4A7ZkbPYRKqHMsbo2IWMU/PhMhA+HGI579C8uFQPLrUBp+bBbt714VQbcaknzWjsjV+26TKW1BymnS0jn47kuTfdHC47MSusVDFZcZie5PlqjCf/BXlqwEaEJfKnAAAAAElFTkSuQmCC" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with an arrow pointing to the right. The arrow points to a yellow square with the text &#34;PgBouncer.&#34; That square points to a blue cylinder with text that reads &#34;RDS.&#34;" data-lqip="true"/><img data-loading="true" src="https://cdn.sanity.io/images/599r6htc/localized/6009b96aade521e354dde68c1adf68a18915cec9-1600x820.png?rect=0,1,1600,819&amp;w=670&amp;h=343&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/6009b96aade521e354dde68c1adf68a18915cec9-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 335w,https://cdn.sanity.io/images/599r6htc/localized/6009b96aade521e354dde68c1adf68a18915cec9-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 503w,https://cdn.sanity.io/images/599r6htc/localized/6009b96aade521e354dde68c1adf68a18915cec9-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format 670w,https://cdn.sanity.io/images/599r6htc/localized/6009b96aade521e354dde68c1adf68a18915cec9-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1005w,https://cdn.sanity.io/images/599r6htc/localized/6009b96aade521e354dde68c1adf68a18915cec9-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1340w" loading="lazy" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with an arrow pointing to the right. The arrow points to a yellow square with the text &#34;PgBouncer.&#34; That square points to a blue cylinder with text that reads &#34;RDS.&#34;"/></p><figcaption>We added PgBouncer as a connection manager</figcaption></figure><p>While these fixes moved the needle, they had limitations. By analyzing our database traffic, we learned that writes— like gathering, updating, or deleting data—contributed to a significant portion of database utilization. Additionally, not all reads or data fetching could be moved to replicas due to application sensitivity to replication lag. So, from both a read and write perspective, we still needed to offload more work from our original database. It was time to move away from incremental changes and look for a longer-term solution.</p><h2 id="exploring-our-options"><a href="#exploring-our-options">Exploring our options</a></h2><p>We first explored options for horizontally scaling our database. Many popular managed solutions are not natively compatible with <a href="https://www.postgresql.org/" _key="4a9032cde230" _type="link">Postgres</a>, the database management system we use at Figma. If we decided on a horizontally scalable database, we would either have to find a Postgres-compatible managed solution, or self-host.</p><p>Migrating to <a href="https://www.mongodb.com/nosql-explained" _key="df6addcdf8c9" _type="link">NoSQL databases</a> or <a href="https://vitess.io/" _key="8a444e741253" _type="link">Vitess</a> (MySQL) would require a complex double read and write migration, and NoSQL in particular would also warrant significant application-side changes. For Postgres-compatible <a href="https://blogs.451research.com/information_management/2011/04/06/what-we-talk-about-when-we-talk-about-newsql/" _key="c1ac1a4cbf04" _type="link">NewSQL</a>, we would’ve had one of the largest single-cluster footprints for cloud-managed distributed Postgres. We didn’t want to bear the burden of being the first customer to hit certain scaling issues; we have little control over managed solutions, so relying on them without a stress test at our level of scale would expose us to more risk. If not a managed solution, our other option was self-hosting. But since we had relied on managed solutions to date, there would be significant upfront work to acquire the training, knowledge, and skills our team would need to support self-hosting. It would mean a large operational cost, which would take away from our focus on scalability—a more existential problem.</p><p>After deciding against both paths forward for horizontally sharding, we had to pivot. Rather than horizontally shard, we decided to <a href="https://towardsdatascience.com/database-terminologies-partitioning-f91683901716" _key="cd702e83683f" _type="link">vertically partition</a> the database by table(s). Instead of splitting each table across many databases, we would move <em>groups of tables</em> onto their own databases. This proved to have both short- and long-term benefits: Vertical partitioning relieves our original database now, while providing a path forward for horizontally sharding subsets of our tables in the future.</p><h3 id="our-approach-to-partitioning"><a href="#our-approach-to-partitioning">Our approach to partitioning</a></h3><p>Before we could begin the process, however, we first had to identify tables to partition into their own database. There were two important factors:</p><ol><li>Impact: Moving the tables should move a significant portion of workload</li><li>Isolation: The tables should not be strongly connected to other tables </li></ol><p>To measure impact, we looked at average active sessions (AAS) for queries, which describes the average number of active threads dedicated to a given query at a certain point in time. We calculated this information by querying <a href="https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW" _key="491aca665efc" _type="link"><code>pg_stat_activity</code></a> in 10 millisecond intervals to identify CPU waits associated with a query, and then aggregated the information by table name.</p><p>Each table’s degree of “isolation” proved core to whether it would be easy to partition. When we move tables into a different database, we lose important functionality such as <a href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)" _key="5ae37112c1d3" _type="link">atomic transactions</a> between tables, foreign key validations, and joins. As a result, moving tables can have a high cost with respect to how much of the Figma application has to be rewritten by developers. We had to be strategic by focusing on identifying query patterns and tables that were easy to partition.</p><p>This proved to be difficult with our backend tech stack. We use <a href="https://www.fastruby.io/monolith" _key="61e714b9edae" _type="link">Ruby</a> for the application backend, which services the majority of our web requests. Those, in turn, generate most of our database queries. Our developers use <a href="https://guides.rubyonrails.org/active_record_basics.html#what-is-active-record-questionmark" _key="e20eac01902a" _type="link">ActiveRecord</a> to write these queries. Due to the dynamic nature of Ruby and ActiveRecord, it’s hard to determine which physical tables are affected by ActiveRecord queries with static code analysis alone. As a first step, we created runtime validators that hooked into ActiveRecord. These validators sent production query and transaction information (such as caller location and tables involved) into <a href="https://www.snowflake.com/en/" _key="81f40d4d35ed" _type="link">Snowflake</a>, our data warehouse in the cloud. We used this information to look for queries and transactions that consistently referenced the same group of tables. If these workloads turned out to be costly, those tables would be identified as prime candidates for vertical partitioning.</p><h2 id="managing-migration"><a href="#managing-migration">Managing migration</a></h2><p>Once we identified which tables to partition, we had to come up with a plan for migrating them between databases. While this is simple when performed offline, going offline isn’t an option for Figma—Figma needs to be up and performant at all times to support users’ real-time collaboration. We needed to coordinate the data movement across thousands of application backend instances, so they could route queries to the new database at the correct moment. This would allow us to partition the database without using maintenance windows, or downtime, for each operation, which would be disruptive for our users (and also require off-hour work from engineers!). We wanted a solution that met the following goals:</p><ol><li>Limit potential availability impact to &lt;1 minute</li><li>Automate the procedure so it is easily repeatable</li><li>Have the ability to undo a recent partition</li></ol><p>We couldn’t find a pre-built solution that met our requirements, and we also wanted the flexibility to adapt the solution for future use cases. There was only one option: build our own.</p><h3 id="our-bespoke-solution"><a href="#our-bespoke-solution">Our bespoke solution</a></h3><p>At a high level, we implemented the following operation (steps 3–6 complete within seconds for minimal downtime):</p><ol><li>Prepare client applications to query from multiple database partitions</li><li>Replicate tables from original database to a new database until replication lag is near 0</li><li>Pause activity on original database</li><li>Wait for databases to synchronize</li><li>Reroute query traffic to the new database</li><li>Resume activity</li></ol><p>Preparing client applications correctly was a significant concern, and the complex nature of our application backends made us anxious. What if we missed an edge case that broke after partitioning? To de-risk the operation, we leveraged the PgBouncer layer to gain runtime visibility and confidence that our applications were configured correctly. After partnering with product teams to make the application compatible with partitioned databases, we created separate PgBouncer services to virtually split traffic. <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-security-groups.html" _key="3d6d7e3899de" _type="link">Security groups</a> ensured that only PgBouncers could directly access the database, meaning client applications were always connected via PgBouncer. Partitioning the PgBouncer layer first would give clients leeway to route queries incorrectly. We’d be able to detect the routing mismatch, but since both PgBouncers have the same target database, the client would still successfully query data.</p><figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACGUlEQVQokW2S7UuTURiHB33pQ+41RDMtM5CaIjEqoaIQyYrUmW57hllYE+mVKOg9pCyICqKxZi6Zzu150/FIo/VCVIxWVFCCIgjRij4H/QlXPI9uJezDxX3OfQ6/+3fuc5ssig+zKmDWo+KjZBFzIV8E1VcUiyJgyi9Wqt1UJXup0fqo1gKUTR7CrvgoVw5QrbpZp7ZTqXbgULzY5IOUigHKEv2Uikexyd2Ghq5lCFplgfrkMQJv7jPwOc75jyPsfn6VGsnLPmkbl6bquZ5yckTbglNpoyp2BlckzI5hCdfjEKvHT2OV/f8EbZJAi3YR6ctLZn7M8/77NOeyETYnurgcX890egW5V8uRn66iWW7BOXKL9tAHeoI52h5m2RAdNFwWBO2iQKt2hfTXDL9yP5nLzXMtO0ZjrJPB0UpyT5bx54WJdMrBXrGZhsg9vKFZ+oK/8YRnqBu9a7ThP4c+dk2cJZxN8nbuE6nZDP2vH9Aw3snJaC3pCSsZrYTg5Bq2i3vYGL1J66N3dA99Y/9whtqxG0sdWmQf1XIvzVMX8D4bxJ0eYJN2igrRgyvWhDveiCexlSZxJ2ulDioSJ6gbvYMrOoRz7DblieNYlEIPBfTRsSoCdtmPQ0fxY1MW8jbZi0Py4JC6sMserMZdP3apB4d02Ij6Xv9liypgKsxh0dnS88XIn3uLzeGCE6PCYhWDRYfFyZ8vRX/yXzLWwB1Xe5/MAAAAAElFTkSuQmCC" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with an arrow pointing to the right. The arrow points to a yellow square with the text &#34;PgBouncer-1.&#34; That square points to a blue cylinder with text that reads &#34;RDS-1.&#34;" data-lqip="true"/><img data-loading="true" src="https://cdn.sanity.io/images/599r6htc/localized/a902e0953db9d66a2ecf1d4b3370ee9ccb42daa3-1600x820.png?rect=0,1,1600,819&amp;w=670&amp;h=343&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/a902e0953db9d66a2ecf1d4b3370ee9ccb42daa3-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 335w,https://cdn.sanity.io/images/599r6htc/localized/a902e0953db9d66a2ecf1d4b3370ee9ccb42daa3-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 503w,https://cdn.sanity.io/images/599r6htc/localized/a902e0953db9d66a2ecf1d4b3370ee9ccb42daa3-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format 670w,https://cdn.sanity.io/images/599r6htc/localized/a902e0953db9d66a2ecf1d4b3370ee9ccb42daa3-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1005w,https://cdn.sanity.io/images/599r6htc/localized/a902e0953db9d66a2ecf1d4b3370ee9ccb42daa3-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1340w" loading="lazy" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with an arrow pointing to the right. The arrow points to a yellow square with the text &#34;PgBouncer-1.&#34; That square points to a blue cylinder with text that reads &#34;RDS-1.&#34;"/></p><figcaption>Our start state</figcaption></figure><figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACVklEQVQokW2S60uTYRjGRxFIoZvzyGKCh0AtM5x9ycLyEK1MrdS9ZqPTpINEfugAUlgmxT4UIZpn907f7X2nzrmlpH5ZeCAqEtKiwhLra9G/8Iu91krpw8V983A91309z31ptIqFKI+FqFBVLET+U5Olo1x0Z6MEDPjHE2n2pZM7eIjwnXXQKgKaP02sp4ak4XOkjtSSMmIjwWMlXTTTNJDCu7EIvk5twhMwsN9TiN5dQ7zLRqJ0gXjXeaLlU6pGSEsV1MkC2cOXqQ0+pvHVANdfdFM41sCuviM8EI188W/k+4SGUX8cha4CjI4rmLra2NfpxtTdhtF5FZ1c/VdQ7xY47GtAmZ9iYfkjM0vz1D9vxyQep74njanBKGa9W2jxJJHnPEhmVxOlrbNYW5Ypa5sjs+++6jIsGOMWKPfd5tn8NN+WV1j8/IGG6V5ynBXYejNxeRLwDsVyR05jt2gmq9NOZetbbC0/qHqyyE7HQ/Syda3DgqFrdMx5Cb5/yehCENvkI0yOMm71p/Dm6RY+TUTgHN1KvlRMRs9dSjqmOdm+REnnDBli81qHOtlCqnyWYt9NqsbvUT7WSPZQHVm9ZuyikZXABn5Oagj44yhyH8DQf4ntDju5fe3scNgxSHVolfAfCmoMdIqAXq4mJgSlGq0skCaauSFuI+iN5HVgMx3eJPYoReoS9W4rMe7TatWF+IqA1iOgWc3U6srXQLGQKB0jT8ynZsDEGSkHs7SXZLkUbZhX9b8crjpUJ/yeoiLUyxZ0rkqipQr00gmiXZXqWZi7DqEn/wKi4sYu16VQ+AAAAABJRU5ErkJggg==" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with two arrows pointing to two yellow squares stacked on top of each other. One says &#34;PgBouncer-1,&#34; and the other says &#34;PgBouncer-2.&#34; Both of these squares lead to blue cylinder on the right that says &#34;RDS-1.&#34;" data-lqip="true"/><img data-loading="true" src="https://cdn.sanity.io/images/599r6htc/localized/20bfdabd39df8bea00daa0fc3327254aa6ee3d9d-1600x820.png?rect=0,1,1600,819&amp;w=670&amp;h=343&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/20bfdabd39df8bea00daa0fc3327254aa6ee3d9d-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 335w,https://cdn.sanity.io/images/599r6htc/localized/20bfdabd39df8bea00daa0fc3327254aa6ee3d9d-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 503w,https://cdn.sanity.io/images/599r6htc/localized/20bfdabd39df8bea00daa0fc3327254aa6ee3d9d-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format 670w,https://cdn.sanity.io/images/599r6htc/localized/20bfdabd39df8bea00daa0fc3327254aa6ee3d9d-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1005w,https://cdn.sanity.io/images/599r6htc/localized/20bfdabd39df8bea00daa0fc3327254aa6ee3d9d-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1340w" loading="lazy" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with two arrows pointing to two yellow squares stacked on top of each other. One says &#34;PgBouncer-1,&#34; and the other says &#34;PgBouncer-2.&#34; Both of these squares lead to blue cylinder on the right that says &#34;RDS-1.&#34;"/></p><figcaption>The state of the database after partitioning PgBouncer</figcaption></figure><p>Once we verified that applications are prepared with separate connections for each PgBouncer (and sending traffic appropriately), we’d proceed.</p><figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQklEQVQokXWS20uTYRzHdxGERtrcMg+z8kBh4aF5SKWDURlBkDXdnFZTsbSDYheRBoFEF+VNhaLTHXTu3d697nUtbdPCQAWzgkqiQr3YTbdBf8In3oWFhy6+fHh+PHyeH18eVZzPRLxUg0Il26M0Rqn1VlHhPkrP2F4mQrtwjO+h2l9GmqeWdGcnubZuspz30HosrHpUqzK1ZCbFbyEj0ERmoIlUuYEUoQrjUAFTcjw/prbwfjKOm3I++1yNlPQPU9kzzxGrh1T3rY3C3VI9leEuOhec3P/govZNNzmihVp7PjPSNn6GVXwJxdIu55I9fI3y/iB1vSuctoZIc7evE4omDo4283DGxbvlRT5HvmP9NM5xuZVzg0W4hJ3Mj8USkLVc8RWSLljIczzjxGAAvaOXJE/zWuF20UiudJ2nsyJLy0tEIhE8i685OdbOKVspTwQdz/0aBkd1GMRSdEqHQx3k2B6T6exEs1mH+8Um7r7qI7w4x/TXBR699VImtWBwFDAuJ7AyuZXZkJpmWU/WSD36gT4qel9SNDBAsrtlozBJvMRhfxsXJ7qoDj3gWPAOWW4zdfY85kZj+TWl4ls4htv+HLKHrlLeF6Su538dKgdfDWqxBo1ojkbtM5MoGDjvLEYUtXx8EUMoqKFBKiTT3Uih3cZZ6zQldifJwo1/wr//UDKti/JANQdcZ7jgKqZBOIRRKEbvrSDRW0uKu5WMkQ507jYSxMubb7gmkkIT8V4jaqGKBMEQ5Q7R+Ge+7r6yhMLfPIrHPPQ4jooAAAAASUVORK5CYII=" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with two arrows pointing to two yellow squares stacked on top of each other. One says &#34;PgBouncer-1,&#34; and the other says &#34;PgBouncer-2.&#34; Both of these squares lead to two blue cylinders. One says &#34;RDS-1,&#34; and the other says &#34;RDS-2.&#34;" data-lqip="true"/><img data-loading="true" src="https://cdn.sanity.io/images/599r6htc/localized/a9b59b09d7d8cc2892a48c67e6411aa40f113453-1600x820.png?rect=0,1,1600,819&amp;w=670&amp;h=343&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/a9b59b09d7d8cc2892a48c67e6411aa40f113453-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 335w,https://cdn.sanity.io/images/599r6htc/localized/a9b59b09d7d8cc2892a48c67e6411aa40f113453-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 503w,https://cdn.sanity.io/images/599r6htc/localized/a9b59b09d7d8cc2892a48c67e6411aa40f113453-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format 670w,https://cdn.sanity.io/images/599r6htc/localized/a9b59b09d7d8cc2892a48c67e6411aa40f113453-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1005w,https://cdn.sanity.io/images/599r6htc/localized/a9b59b09d7d8cc2892a48c67e6411aa40f113453-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1340w" loading="lazy" alt="A digram on a green background. The diagram starts with a white square titled &#34;Application backend&#34; with two arrows pointing to two yellow squares stacked on top of each other. One says &#34;PgBouncer-1,&#34; and the other says &#34;PgBouncer-2.&#34; Both of these squares lead to two blue cylinders. One says &#34;RDS-1,&#34; and the other says &#34;RDS-2.&#34;"/></p><figcaption>The state of the database after partitioning data</figcaption></figure><h3 id="the-logical-choice"><a href="#the-logical-choice">The “logical” choice</a></h3><p>In Postgres, there are two ways to replicate data: <a href="https://www.postgresql.org/docs/current/protocol-replication.html" _key="2214fe15d978" _type="link">streaming replication</a> or <a href="https://www.postgresql.org/docs/current/logical-replication.html" _key="6647f2bc8091" _type="link">logical replication</a>. We chose logical replication because it allows us to:</p><ol><li><strong>Port over a subset of tables</strong>, so we can start with a much smaller storage footprint in the destination database (reduced storage hardware footprint can increase reliability).</li><li><strong>Replicate to a database</strong>, which is running a different Postgres major version, meaning we can perform minimal-downtime major version upgrades with this tooling. AWS has blue/green deployment for major version upgrades, but the feature is not yet available for RDS Postgres.</li><li><strong>Set up reverse replication</strong>, which allows us to roll back the operation.</li></ol><p>The main issue with using logical replication is that we’re working with <em>terabytes</em> of production data, so the initial data copy could require days, if not weeks, to complete. We wanted to avoid this to not only minimize the window for replication failure, but also the cost of restarting. We considered carefully coordinating a <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_RestoreFromSnapshot.html" _key="4292804fbead" _type="link">snapshot restore</a> and starting replication at the correct point, but a restore eliminated the possibility of having a smaller storage footprint. Instead we decided to investigate <em>why</em> logical replication’s performance is so sluggish. We discovered that the slow copy is a result of how Postgres maintains indexes in the destination database. While logical replication copies rows in bulk, it inefficiently updates <a href="https://github.com/postgres/postgres/blob/205f958406cc85f8f73e151906ecd281ff05d80a/src/backend/commands/copy.c#L2985" _key="3c95473940e7" _type="link">indexes one row at a time</a>. By removing indexes in the destination database and rebuilding the indexes after the initial copying of data, we reduced the copy time to a matter of hours.</p><p>Via logical replication, we were able to build a reverse replication stream from the newly partitioned database and back to the original. This replication stream was activated <em>just after</em> the original database stopped receiving traffic (more on this below). Modifications to the new database would be replicated back to the old database, and the old database would have these updates in the event we rolled back. </p><h3 id="the-critical-steps"><a href="#the-critical-steps">The critical steps</a></h3><p>With replication solved, we found ourselves at the crucial steps of coordinating query rerouting. Every day, thousands of client services query the database at any given time. Coordinating across this many client nodes is prone to failure. By performing our sharding operation in two phases (partitioning PgBouncers, then data), the critical operation of partitioning data would only require coordination across a handful of PgBouncer nodes serving the partitioned tables.</p><p>Here’s an overview of the ongoing operation: We coordinate across nodes to stop all relevant database traffic only briefly in order for logical replication to synchronize the new database. (PgBouncer conveniently supports pausing new connections and rerouting.) While PgBouncer pauses new connections, we revoke clients’ query privileges on the partitioned tables in the original database. After a brief grace period, we cancel any remaining in flight queries. Since our application mostly issues short duration queries, we typically cancel a little under 10 queries. At this point, with traffic paused, we then need to verify our databases are the same.</p><p>Ensuring that two databases are the same before rerouting clients is a fundamental requirement for preventing data loss. We used <a href="https://www.postgresql.org/docs/current/wal-internals.html" _key="8265ac7b3d5c" _type="link">LSNs</a> to determine if two databases were synchronized. If we sample an LSN from our original database once we’re confident that there are no new writes, we can then wait for the replica to replay past this LSN. At this point, the data is identical in both the original and the replica.</p><figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9klEQVQokZVTa2/SUBju/3RxtKW3wVYmmKhxbN+8DEahBXp6iv/ERYduiWYfxjRxKCiyUS6bbEz042POARbIGqMfnvS8p+/7vLfnCAb9jXno3q8F+28I8xUMyi4XwRx1bwydzIHZszv+PxyC7rFMi9DIGFHnAlI+gGh1IBV6UIoXkO0BpHwXSmnIycOqFmL0CibtYt1v3yDhtRCzP0LNHEJ8XkMk04RkdSDutLC8/YUnUstXHFFnkogl1NxrCCbt4VHlCJuVt0j7VWzQvQm8V3hQrmLNqUGz21CcPhQ7gFI4nZxLQ8iFPu5uN3HnyScsZ75CKf6AEKdD3PNbSLofYNrvsWodwCy8Q9I9RspvwKQB4t45VrwhDDLi0Mk1r4aRSvkuxNwp5EIPank0I/yO9fIx4rkDrGSriOf2kSgeIUU/436lgZTfxBoNoJMRNPKTfxmxOiVk44g659AIa9nv8pbTPmtzF4/JS2yQXaT919h68QablSoekn2sFk+gOAMeqNoBVLsDMdfG0rM6lp6eILLT5jMVYvQSCb+DJGv7Fr4h4dZhWDXI2TpfBquGLSmSaSCSbUG0zni7bH6s+hDZzDQ1OSulSy4dFhi1B5DtPsTc2XRufWju6EbgXIdhwja4w5SYjPkCWCCrgGPOviXs/3lW//IM/wAgA7tPb0fbywAAAABJRU5ErkJggg==" alt="" data-lqip="true"/><img data-loading="true" src="https://cdn.sanity.io/images/599r6htc/localized/c67bfcc07d06ea18d3835acc3e9941c0bd9f797e-1600x932.png?rect=0,1,1600,931&amp;w=670&amp;h=390&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/c67bfcc07d06ea18d3835acc3e9941c0bd9f797e-1600x932.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 335w,https://cdn.sanity.io/images/599r6htc/localized/c67bfcc07d06ea18d3835acc3e9941c0bd9f797e-1600x932.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 503w,https://cdn.sanity.io/images/599r6htc/localized/c67bfcc07d06ea18d3835acc3e9941c0bd9f797e-1600x932.png?w=670&amp;q=75&amp;fit=max&amp;auto=format 670w,https://cdn.sanity.io/images/599r6htc/localized/c67bfcc07d06ea18d3835acc3e9941c0bd9f797e-1600x932.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1005w,https://cdn.sanity.io/images/599r6htc/localized/c67bfcc07d06ea18d3835acc3e9941c0bd9f797e-1600x932.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1340w" loading="lazy" alt=""/></p><figcaption>A visualization of our synchronization mechanism</figcaption></figure><p>After we’ve checked that the replica is synchronized, we stop replication and promote the replica to a new database. Reverse replication is set up as previously mentioned. Then, we resume traffic in PgBouncer, but now the queries are routed to the new database.</p><figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACSUlEQVQokXWR7UtTYRiH9xfMLTVr5gpty9C0F/eeBUGm7oOr3Nlsc1OJkNR8qUw3pagPZRBkuKnT3I47zzlHBSUpy/rjrthxfqjowwX387svftzwmMxbESx6FJuIYxcJqkUf5mKYqs0I9mIcmxLDokhYimFsIoZdLTtKmColil30Y1PjWPUopS6TWY9Qo8fp/JIi8WOB1t0RKkSE5u1hEgfvCH6d55Tez0k1Rtd+muThe1p2RzALiaadYfq/HzmntxOUuozCWi1OeP8lEz8X8ew9wapKtO08ZvzwI30HbzizVboiRmT/FZO/FnHvjf3pfHuN/biwUuvlmugmovWQ1CW6tG5c4jZdooukHiaq3yWg3iEgOoioPQwYTpA20UGnWna0EC4tSLXei8mmhHggXMwLBzNFJ9NKI4+UFl6IC6QUJynFwahoZlRpJq04mFWcPBeNPFRamRaNhlPK+/U27HoIU424R0fxBkMFN8kNLzHZTUgOkCj4GdzwMZj3IcntSIV2hmQ/A7KfxOZ1QvJNEnKAQdnPUMFHULmFTbuPyaJL1CoSl3NjuDOzODcGcOQHcS/P4l1K482mubo6beDLzuFdmcO9mqY19xTPcsrYl/JL61NUiRim0lefUJNcXHtLW3aVuvwkdYUpY/YsrePJrHNl+ZOBZ+kz7sw6rmyOlpUPuDI53EtrRt6UW6BSDBwVWvUYdcVx6uUZapSHBvWFGRryswbnCs8MzudTxru0OytP0lB2Srl9cwKrVr6wQo+W6ftrPuZ/2b/Ob/OyupK+3wFlAAAAAElFTkSuQmCC" alt="A digram on a green background showing four phases: prepare, replicate, pause, reroute. Under each phase, there&#39;s a white square that says &#34;Application backend,&#34; which leads to two yellow squares that say &#34;PgBouncer-1&#34; and &#34;Pgbouncer 2.&#34; These then lead to blue cylinder(s) that say &#34;Original,&#34; &#34;Replica,&#34; or &#34;Promoted.&#34;" data-lqip="true"/><img data-loading="true" src="https://cdn.sanity.io/images/599r6htc/localized/04b69070d25ab954c8adafaf010ff82d0de0ed4f-1600x820.png?rect=0,1,1600,819&amp;w=670&amp;h=343&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/04b69070d25ab954c8adafaf010ff82d0de0ed4f-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 335w,https://cdn.sanity.io/images/599r6htc/localized/04b69070d25ab954c8adafaf010ff82d0de0ed4f-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 503w,https://cdn.sanity.io/images/599r6htc/localized/04b69070d25ab954c8adafaf010ff82d0de0ed4f-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format 670w,https://cdn.sanity.io/images/599r6htc/localized/04b69070d25ab954c8adafaf010ff82d0de0ed4f-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1005w,https://cdn.sanity.io/images/599r6htc/localized/04b69070d25ab954c8adafaf010ff82d0de0ed4f-1600x820.png?w=670&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1340w" loading="lazy" alt="A digram on a green background showing four phases: prepare, replicate, pause, reroute. Under each phase, there&#39;s a white square that says &#34;Application backend,&#34; which leads to two yellow squares that say &#34;PgBouncer-1&#34; and &#34;Pgbouncer 2.&#34; These then lead to blue cylinder(s) that say &#34;Original,&#34; &#34;Replica,&#34; or &#34;Promoted.&#34;"/></p><figcaption>A summary of the procedure</figcaption></figure><h2 id="planning-for-our-horizontal-future"><a href="#planning-for-our-horizontal-future">Planning for our horizontal future</a></h2><p>We’ve since successfully performed the partitioning operation many times in production, and each time, we met our initial objective: address scalability without impacting reliability. Our first operation involved moving two high-traffic tables, while our final operation in October 2022 involved 50. During each operation, we observed a ~30 second period of partial availability impact (~2% of requests dropped). Today, each database partition is operating with greatly increased headroom. Our largest partition has CPU utilization hovering ~10%, and we’ve decreased the resources allocated to some of the lower traffic partitions.</p><p>And yet, our work here is not done. Now with many databases, client applications have to maintain knowledge of each one, and the routing complexity scales multiplicatively as we add more databases and clients. We’ve since introduced a new query routing service which will centralize and simplify routing logic as we scale to more partitions. Some of our tables have high write traffic or billions of rows and terabytes of disk footprint, and these tables will hit disk utilization, CPU, and I/O bottlenecks individually. We always knew that if we <em>only</em> relied on vertical partitioning, we’d eventually reach scaling limits. Going back to our aim of maximizing leverage, the tooling we created for vertical partitioning will make us better equipped to horizontally shard tables with high write traffic. It has provided us with enough runway to tackle our current projects and keep Figma’s “highways” open, while also seeing around the bend.</p><svg xmlns="http://www.w3.org/2000/svg" width="93" height="13" fill="none" _key="bd3d8ff6a2a2" _type="horizontalRule"><circle cx="6.5" cy="6.5" r="6.5" fill="#6A6A6A"></circle><path fill="#6A6A6A" d="M39.834 0h13v13h-13zM86.5 0L93 13H80l6.5-13z"></path></svg><p>Stay tuned for more details on these projects. Scaling our database architecture is both a complex and exciting task that is essential for Figma’s success. If you’re interested in working on projects like this, <a _key="ebd4347d38e7" _type="link" href="https://www.figma.com/careers/">we’re hiring</a>!</p><p><em>Nothing great is made alone, and the following database team members were instrumental in bringing this workstream to life: David Harju, Dylan Visher, Erica Kong, Gordon Yoon, Josh Bancroft, Kevin Lin, Langston Dziko, Ping-Min Lin, Rafael Chacon Vivas, Roman Hernandez, Sammy Steele, and Yiming Li.</em></p><p><em>I&#39;d also like to thank all of our cross-functional partner teams, and especially the following individuals: Jared Wong, Josh Tabak, Karl Jiang, Kevin Stewart, Kyle Hardgrave, Michael Harris, Ricky Zein, Shloak Jain, Tommy MacWillliam, William Li.</em></p></div></div>
  </body>
</html>
