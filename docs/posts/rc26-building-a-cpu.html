<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC26/">Original</a>
    <h1>RC26. Building a CPU</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-06-20T00:00:00-07:00">June 20, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        

<p>The main thing I worked on today was building (okay “building,” in .hdl) the CPU for my simulated nand2tetris machine using components previously featured here, such as a <a href="https://www.datadoodad.com/recurse%20center/RC16/">program counter</a>, some big arrays of <a href="https://www.datadoodad.com/recurse%20center/RC15/">RAM</a>, and an <a href="https://www.datadoodad.com/recurse%20center/RC12/">ALU</a>, among other things.</p>

<p>Building the CPU was a particularly rewarding exercise, since it meant thinking through the logic that enabled us to do what we did last week, namely writing a few simple programs in assembly language.</p>



<p>This was something that I sort of skated over last week but had to contend with this time around. Our CPU needs to handle two kinds of instructions: A instructions (A for address, although the instruction need not always refer to a memory address) and C instructions (C for … computation?). Both are 16-bits of information, but they work in very different ways and do very different things.</p>



<table>
  <tbody><tr>
    <td>0</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<p>An A instruction is identified as such by <span>the most significant bit</span> being <code>0</code>. The remaining 15 bits comprise a 15-bit address – anything from 0 to 32,767. When writing assembly, an address instruction looks like this:</p>

<div><div><pre><code>@4        =&gt; 0000 0000 0000 0100
</code></pre></div></div>
<p>or</p>

<div><div><pre><code>@1528     =&gt; 0000 0101 1111 1000
</code></pre></div></div>
<p>or even</p>
<div><div><pre><code>@SCREEN   =&gt; 0100 0000 0000 0000 (16,384)
</code></pre></div></div>
<p>since, in this version of assembly, there are a few symbolic constants such as <code>SCREEN</code>, which just refer to a number (in this case, 16,384).</p>



<table>
  <tbody><tr>
    <td>1</td>
    <td>x</td>
    <td>x</td>
    <td>a</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>d</td>
    <td>d</td>
    <td>d</td>
    <td>j</td>
    <td>j</td>
    <td>j</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<p>If A instructions are identified by the most significant bit being 0, C instructions are are identified by <span>the most significant bit</span> being 1. After that, though, the commonalities end. C instructions are a bit more complicated since they encode a variety of different pieces of information.</p>
<ul>
  <li><span>the <b>a</b> bit</span> (bit 12) dictates whether the ALU should accept its <code>y</code> input from the A Register or from somewhere in Memory</li>
  <li><span>the 6 <b>c</b> bits</span> (bits 6-11) specify the ALU function and are fed into its 6 function inputs <code>zx</code>, <code>nx</code>, <code>zy</code>, <code>ny</code>, <code>f</code>, and <code>no</code>.</li>
  <li><span>the 3 <b>d</b> bits</span> (bits 3-5) specify the destination for the ALU’s output, either <code>M</code> (memory), <code>A</code> (A register), or <code>D</code> (D register), or some combination of the three.</li>
  <li><span>the 3 <b>j</b> bits</span> (bits 0-2) specify any jump command based on whether the ALU’s output is <code>&lt; 0</code>, <code>&lt;= 0</code>, <code>== 0</code>, <code>&gt;= 0</code>, or <code>&gt; 0</code>.</li>
</ul>

<p>I’ve already written about <a href="https://www.datadoodad.com/recurse%20center/RC12/">the various computations the ALU is capable of doing based on its 6 inputs</a>, but let’s take a closer look at the destination and jump logic.</p>

<p><strong>DESTINATION</strong></p>

<table>
  <tbody><tr>
    <th>d<sub>5</sub></th>
    <th>d<sub>4</sub></th>
    <th>d<sub>3</sub></th>
    <th>Mnemonic</th>
    <th>Destination</th>
  </tr>
  <tr>
    <th>0</th>
    <th>0</th>
    <th>0</th>
    <th>null</th>
    <th>Don&#39;t store anywhere</th>
  </tr>
  <tr>
    <th>0</th>
    <th>0</th>
    <th>1</th>
    <th>M</th>
    <th>Memory[A]</th>
  </tr>
  <tr>
    <th>0</th>
    <th>1</th>
    <th>0</th>
    <th>D</th>
    <th>D Register</th>
  </tr>
  <tr>
    <th>0</th>
    <th>1</th>
    <th>1</th>
    <th>MD</th>
    <th>Memory[A], D Register</th>
  </tr>
  <tr>
    <th>1</th>
    <th>0</th>
    <th>0</th>
    <th>A</th>
    <th>A Register</th>
  </tr>
  <tr>
    <th>1</th>
    <th>0</th>
    <th>1</th>
    <th>AM</th>
    <th>A Register, Memory[A]</th>
  </tr>
  <tr>
    <th>1</th>
    <th>1</th>
    <th>0</th>
    <th>AD</th>
    <th>A Register, D Register</th>
  </tr>
  <tr>
    <th>1</th>
    <th>1</th>
    <th>1</th>
    <th>AMD</th>
    <th>A Register, Memory[A], D Register</th>
  </tr>
</tbody></table>

<p>After looking closely at this, it makes a lot of sense:</p>
<ul>
  <li>if <span>d<sub>3</sub></span> is high, we want to store the ALU’s output in memory (<code>M</code>) at the address currently being output by the A register</li>
  <li>if <span>d<sub>4</sub></span> is high, we want to store the ALU’s output in the D register (<code>D</code>)</li>
  <li>if <span>d<sub>5</sub></span> is high, we want to store the ALU’s output in the <code>A</code> register</li>
</ul>

<p>By combining these bits, we can send the ALU output to multiple places at once.</p>

<p><strong>JUMP</strong></p>

<table>
  <tbody><tr>
    <th>j<sub>2</sub></th>
    <th>j<sub>1</sub></th>
    <th>j<sub>0</sub></th>
    <th>Mnemonic</th>
    <th>Jump Command</th>
  </tr>
  <tr>
    <th>0</th>
    <th>0</th>
    <th>0</th>
    <th>null</th>
    <th>No jump</th>
  </tr>
  <tr>
    <th>0</th>
    <th>0</th>
    <th>1</th>
    <th>JGT</th>
    <th>Jump if <i>out</i> &gt; 0</th>
  </tr>
  <tr>
    <th>0</th>
    <th>1</th>
    <th>0</th>
    <th>JEQ</th>
    <th>Jump if <i>out</i> = 0</th>
  </tr>
  <tr>
    <th>0</th>
    <th>1</th>
    <th>1</th>
    <th>JGE</th>
    <th>Jump if <i>out</i> &gt;= 0</th>
  </tr>
  <tr>
    <th>1</th>
    <th>0</th>
    <th>0</th>
    <th>JLT</th>
    <th>Jump if <i>out</i> &lt; 0</th>
  </tr>
  <tr>
    <th>1</th>
    <th>0</th>
    <th>1</th>
    <th>JNE</th>
    <th>Jump if <i>out</i> != 0</th>
  </tr>
  <tr>
    <th>1</th>
    <th>1</th>
    <th>0</th>
    <th>JLE</th>
    <th>Jump if <i>out</i> &lt;= 0</th>
  </tr>
  <tr>
    <th>1</th>
    <th>1</th>
    <th>1</th>
    <th>JMP</th>
    <th>Jump</th>
  </tr>
</tbody></table>

<p>The logic table for the three jump bits works similarly:</p>
<ul>
  <li>if <span>j<sub>0</sub></span> is high, we want to jump if the ALU output is &gt; 0</li>
  <li>if <span>j<sub>1</sub></span> is high, we want to jump if the ALU output == 0</li>
  <li>if <span>j<sub>2</sub></span> is high, we want to jump if the ALU output &lt; 0</li>
</ul>

<p>Here, too, we can combine these bits to create other jump conditions: if <em>out</em> &lt;= 0 or &gt;= 0 or != 0, etc.</p>



<p>Let’s look at a few C-instructions, then, and try to intpret them:</p>

<div><div><pre><code>M=D+1 =&gt; 1xx0 0111 1100 1000
</code></pre></div></div>
<table>
  <tbody><tr>
    <td>1</td>
    <td>x</td>
    <td>x</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<p>Here, we’re taking the value in the D register and adding 1, then we’re storing the value to Memory using whatever address is currently in the A Register. (Normally c-instructions outputting to memory will follow an a-instruction that sets the A Register for this very reason).</p>
<ul>
  <li><span>instruction type</span>[15]: 1 =&gt; C-instruction</li>
  <li><span>A/M flag</span>[12]: 0 =&gt; use A Register</li>
  <li><span>function</span>[6..11]: 011111 =&gt; compute <code>D + 1</code></li>
  <li><span>destination</span>[3..5]: 001 =&gt; send ALU out to <code>M</code> (at whatever address currently in A Register)</li>
  <li><span>jump</span>[0..2]: 000 =&gt; no jump</li>
</ul>



<p>Here’s a more complex example that involves an a-instruction/c-instruction pair:</p>

<div><div><pre><code>@1523 =&gt; 0000 0101 1111 1100
D;JLE =&gt; 1xx0 0011 0000 0110
</code></pre></div></div>
<table>
  <tbody><tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<table>
  <tbody><tr>
    <td>1</td>
    <td>x</td>
    <td>x</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<p>First, we’re setting the A Register to carry a value of 1523. This value can then be input directly into an ALU compuation or, as we’re doing here, it can be be used as an address. Whether we do one versus the other is a function of the c-instruction that follows.</p>

<p>Next, we follow the c-instruction, which is saying to jump to the instruction number specified on the A Register (we just set this to 1523 – evidently this is a lengthy piece of assembly code!) <em>but only if</em> the value at the D register is less than or equal to 0.</p>
<ul>
  <li><span>instruction type</span>[15]: 1 =&gt; C-instruction</li>
  <li><span>A/M flag</span>[12]: 0 =&gt; use A Register</li>
  <li><span>function</span>[6..11]: 001100 =&gt; compute <code>D</code> (i.e., output whatever’s on the D register)</li>
  <li><span>destination</span>[3..5]: 000 =&gt; no destination here, since we’re not storing the ALU’s output anywhere</li>
  <li><span>jump</span>[0..2]: 110 =&gt; Jump to instruction 1523 if the value coming out of the ALU (in this case, whatever’s on the D register) is less than or equal to 0.</li>
</ul>

<p>In a nutshell, that’s how this all works.</p>

<p>When it comes to the CPU, then, generally what’s going to happen is this:</p>
<ul>
  <li>If we see an A-instruction, we’ll need to stick it in the A register so that we can potentially do something with it later.</li>
  <li>If we see a C instruction, we break out its various <code>a</code>, <code>c</code>, <code>d</code>, and <code>j</code> bits and make use of them to do CPU-y things.</li>
</ul>



<p>Here’s a summary of the A- and C-instructions:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC26_instructions.jpg" alt="A-instructions and c-instructions"/></p>

<p>And here’s what the CPU logic looks like that behaves according to the A- and C-instructions coming in:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC26_cpu.jpg" alt="CPU diagram"/></p>

<p>There’s a lot going on here, which is why I color-coded each of the C-instruction <code>a</code>, <code>c</code>, <code>d</code>, and <code>j</code> bits – that way we can see how the C-instructions are being decomposed and their component parts utilized.</p>

<p>For instance, with the D Register at the top: it takes as its input the value output from the ALU, however it only <em>loads</em> that value when the <span>instruction bit [15]</span> is 1 (meaning this is a C instruction) <code>AND</code> that the <span>destination bit [4]</span> is 1 (meaning that the D register is a destination that we want for the ALU’s output).</p>

<p>As another example, consider the program counter: its input is the value on the A Register – that way we can jump to whatever instruction number is specified on the A Register <em>if</em> we get a valid jump command. Otherwise, the program counter will just keep on incrementing. That’s a big <em>if</em>, however. First we check to see if the ALU’s output is negative (<code>ng</code>) <code>AND</code> <span>jump bit [2]</span> is high (meaning we want to jumpt if the output is negative). We also want to simultaneously check if the ALU’s output is zero (<code>zr</code>) <code>AND</code> <span>jump bit [1]</span> is high (meaning we want to jump if the output is equal to 0). And lastly we want to check for the case that the output is greater than zero, which means we want to confirm that <span>jump bit [0]</span> is high (meaning we want to jump if the output is greater than 0) <code>AND</code> that neither <code>ng</code> nor <code>zr</code> is true (i.e., the ALU isn’t outputting 0 or a negative number). If any of these three jump conditions is met, then we jump – <em>if</em> we’re also reading a C-instruction (<span>instruction bit [15]</span> is high).</p>

<p>Here’s an annotated version. It helped me, maybe it’ll help you too.</p>

<p><img src="https://www.datadoodad.com/assets/images/RC26_cpu_annotated.jpg" alt="CPU diagram, annotated"/></p>



<p>Earlier I mentioned the nand2tetris authors’ decision to build a bunch of components like the ALU and program counter, <em>then</em> turn to writing some code in assembly language, and then <em>returning</em> to logic and chips in building the components that do stuff with that assembly language. It’s little structural decisions like this that convince me that nand2tetris is maybe the best and most effective pedagical model I’ve seen.</p>

<p>In my experience, project-based tutorials and books tend to skew hand-hold-y and, at at worst, can encourage lazy learning. At least for me. Usually what happens is this: I follow the steps, dutifully writing my own code, which is really just a copy of the example code, and pat myself on the back while deluding  myself into thinking that I did it myself. The reality is that most of the material will have passed through me, since all of the thinking and problem-solving was done for me.</p>

<p>Nand2tetris is not like this. To the contrary, it gives you some context and background and orientation, allows you to indulge the fantasy that you totally get it and how hard could it be, and then tosses your delusional ass into the deep end and leaves you to figure it out. The bits and pieces of information you need in order not to drown are lurking in there somewhere – sometimes in the form of a diagram you skipped or a paragraph you “definitely read” but didn’t or a previous chapter – but they’re never handed to you. The result is that you really do have to do the deep thinking and heavy lifting yourself, and when you finish you can actually savor the satisfaction of having done tthe thing yourself. When I really think about it, every week I read the chapter, think to myself that it’ll be a cinch, and then stare at the project brief and think it’s actually not possible. And yet every week, I get my act together and figure it out. And that, my friends, is an excellent feeling.</p>


<ul>
  <li>Excellent coffee chats. Generally it’s been cool meeting and catching up with folks who come from professional backgrounds in art and music who still maintain their practices.</li>
  <li>Paired a little on the above CPU to squash a few bugs and figure out jump logic</li>
  <li>Finished the Computer chip for nand2tetris (much simpler than the CPU)</li>
  <li>Did Part I of <a href="https://implement-dns.wizardzines.com/">Implement DNS in a Weekend</a> with two other recursers. This is the sort of tutorial that could have taken, I don’t know, 30 minutes if I’d done it alone. But we went through in a thorough and deliberate way, explaining concepts to one another as we went, so the experience was that much deeper and more effective.</li>
</ul>


          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
