<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/dylanaraps/pure-bash-bible">Original</a>
    <h1>Pure Bash Bible (2018)</h1>
    
    <div id="readability-page-1" class="page"><section id="An-Unlinked-Adventure">

<p>I’ve been working on my new tool <a href="https://github.com/erikareads/maru"><code>maru</code></a>, to get it polished for release. To that end, I decided to look at <a href="https://opensource.axo.dev/cargo-dist/"><code>cargo-dist</code></a> a tool that aims to help with release engineering for Rust projects.
Since <code>maru</code> is a Rust CLI, it seemed like a great fit.</p>
<p>This is the story of how the interaction between cross-compilation and NixOS led to a rabbit hole of dynamic linking on linux.<label for="fn1"></label>

<span><span>Thank you to Jeff for pairing with me as we ventured into this rabbit hole.</span>
</span>
</p>
<section id="cargo-dist">
<h2><code>cargo-dist</code></h2>
<p><code>cargo dist init</code> will generate a github action to handle automatic release creation on Github when tags update. For <code>maru</code>, I was missing <code>repository = ...</code> in my <code>Cargo.toml</code>, which <code>cargo-dist</code> noticed and prompted me to fix.</p>
<p>After adding:</p>
<pre><code>repository = &#34;https://github.com/erikareads/maru&#34;
</code></pre>
<p>to my <code>Cargo.toml</code>, <code>cargo dist init</code> helpfully generated a github action workflow and updated the <code>Cargo.toml</code> with configuration metadata. I chose to use the <code>shell</code> installer, to see how it worked for <code>maru</code>.</p>
<p>Previously, I had run</p>
<pre><code>cargo install --git &#34;https://github.com/erikareads/maru&#34;
</code></pre>
<p>which compiled <code>maru</code> locally, which worked on my NixOS machine.</p>
<p>After generating the Github action yaml with <code>cargo-dist</code>, I committed the changes and pushed a tag.
To my delight, the Github action automatically compiled <code>maru</code> for three different architectures and generated a release.</p>
<p>However, when I downloaded the <code>maru-x86_64-unknown-linux-gnu.tar.xz</code>, unpacked it, and ran <code>./maru</code> I got this error:</p>
<pre><code>$ ./maru
bash: ./maru: cannot execute: required file not found
</code></pre>
<p>Uh oh, what required file isn’t working? This is where the linking adventure really began.</p>
</section>
<section id="The-adventure-begins-strings">
<h2>The adventure begins - <code>strings</code></h2>
<p>Jeff suggested using <code>strings</code> to see the difference between my working locally compiled version and the broken downloaded version.</p>
<pre><code>diff &lt;(strings ~/.cargo/bin/maru) &lt;(strings ~/Downloads/maru-x86_64-unknown-linux-gnu/maru ) | less
</code></pre>
<p>From which we found:</p>
<pre><code>&lt; /nix/store/yaz7pyf0ah88g2v505l38n0f3wg2vzdj-glibc-2.37-8/lib/ld-linux-x86-64.so.2
---
&gt; /lib64/ld-linux-x86-64.so.2
&gt; libgcc_s.so.1
...
</code></pre>
<p>Oh, non-standard NixOS strikes again. I don’t yet understand what that difference means, but it’s clear that it’s at the heart of what’s breaking the binary.</p>
<p>Now that we know that an interaction with NixOS is probably the source of the issue. A search<label for="fn2"></label>

<span><span>I used Duck Duck Go for my searches during this adventure.</span>
</span>
 of</p>
<pre><code>nixos rust cannot execute: required file not found
</code></pre>
<p>Led to a <a href="https://matklad.github.io/2022/03/14/rpath-or-why-lld-doesnt-work-on-nixos.html">matklad article about <code>ld</code> on NixOS</a>. There he suggests <code>readelf</code> as a path forward:</p>
<pre><code>$ readelf -d ~/Downloads/maru-x86_64-unknown-linux-gnu/maru
Dynamic section at offset 0x16b560 contains 29 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libgcc_s.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 ...
</code></pre>
<p>Comparing that with the locally built working version:</p>
<pre><code>$ readelf -d ~/.cargo/bin/maru
Dynamic section at offset 0x175ea8 contains 32 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libgcc_s.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libm.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-x86-64.so.2]
 0x000000000000001d (RUNPATH)            Library runpath: [/nix/store/...]
 ...
</code></pre>
<p>The locally built one has an extra shared library -&gt; the <code>ld</code> linker that we found different in the <code>strings</code> output.
In addition, NixOS sets a <code>RUNPATH</code> that allows the binary to find the shared libraries on NixOS.</p>
<p>Knowing that <code>ld</code> is the problem on NixOS, I searched:</p>
<pre><code>compiled binary doesn&#39;t work on nixos ld
</code></pre>
<p>Which led to <a href="https://blog.thalheim.io/2022/12/31/nix-ld-a-clean-solution-for-issues-with-pre-compiled-executables-on-nixos/">an article on nix-ld</a>. Binaries assume the <code>ld</code> is a fixed location for <code>glibc</code>, but NixOS breaks that convention. <code>nix-ld</code> addresses the problem by overriding the <code>RUNPATH</code> that was set when we compiled locally, even on binaries that where we can’t recompile them ourselves.</p>
<p>Which is great, but I <strong>have</strong> the source code available, <code>maru</code> is my project! Is there a way that I can compile <code>maru</code> such that this linking path problem isn’t an issue?</p>
</section>
<section id="How-does-ripgrep-do-it">
<h2>How does ripgrep do it?</h2>
<p>My first thought was to look at <code>ripgrep</code>, a known well-distributed Rust CLI. I installed <code>ripgrep</code> using NixOS, so maybe that handled this issue for me, but I wanted to check. Looking in <code>ripgrep</code>’s <a href="https://github.com/BurntSushi/ripgrep/releases">releases</a>, I see that it <strong>doesn’t</strong> compile for <code>unknown-linux-gnu</code>, but instead for <code>unknown-linux-musl</code>.</p>
<p>Downloading this binary of <code>ripgrep</code>, the invocation works without issue.</p>
</section>
<section id="musl">
<h2>musl?</h2>
<p>This led me to search for:</p>
<pre><code>rust compile without dynamic linking
</code></pre>
<p>Which led to this <a href="https://stackoverflow.com/questions/31770604/how-to-generate-statically-linked-executables">stack overflow</a> question which led me to this answer:</p>
<blockquote>
<p>Rust statically links everything but glibc (and libgcc, iirc) by default.</p>
<p>If you want to get a 100% statically linked binary, you can use MUSL with 1.1. <a href="https://github.com/rust-lang/rust/pull/24777">https://github.com/rust-lang/rust/pull/24777</a> is the initial support, we hope to make it much easier to use in the future.</p>
<p>EDIT: It’s distributed via <code>rustup</code> now, so you can add <code>x86_64-unknown-linux-musl</code> as a target : <code>rustup target add x86_64-unknown-linux-musl</code></p>
<p>And then build to this target : <code>cargo build --target=x86_64-unknown-linux-musl</code></p>
</blockquote>
<p>Linking against <code>musl</code> will allow <code>maru</code> to be statically compiled, which should avoid the dynamic linking problem on NixOS.</p>
<p>After running the relevant <code>rustup</code> and <code>cargo build</code> commands, I confirmed that a locally <code>musl</code> compiled binary worked on my NixOS machine.</p>
</section>
<section id="Patching-the-generated-github-actions">
<h2>Patching the generated github actions</h2>
<p>Now, I don’t want to locally compile every binary of <code>maru</code> for my project, so I needed to update the Github actions in order to do the <code>musl</code> compile.</p>
<p>An initial test, just switching out the build target failed, because it didn’t have the target environment installed via <code>rustup</code>.</p>
<p>The fix was to add a conditional to my Github action workflow:</p>
<pre><code>- name: Maybe install target
  if: ${{ contains(matrix.dist-args, &#39;musl&#39;) }}
  run: rustup target add x86_64-unknown-linux-musl
</code></pre>
<p>The Github actions API exposes a function <code>contains</code>, which allows us to only run this command on the <code>musl</code> compilation in the matrix of operating systems. <code>rustup</code> was already being used to install Rust in the Continuous Integration, so we expected that the <code>rustup target</code> would work.</p>
<p>After a few minutes of eagerly waiting for the new version to compile, we confirmed that the <code>musl</code> binary worked both on NixOS and on Debian.</p>
<p>This was great, but the <code>shell</code> installer provided by <code>cargo-dist</code> no longer worked, since it was looking for the <code>gnu</code> binary.<label for="fn3"></label>

<span><span>Turns out this was a <a href="https://opensource.axo.dev/cargo-dist/book/installers.html#shell">known problem</a> and was mentioned in the limitations/caveats in the documentation. Check out <a href="https://github.com/axodotdev/cargo-dist/issues/75">this issue</a> for discussion on the problem.</span>
</span>
 The shell installer checks to see whether <code>glibc</code> exists on the installing system, which isn’t sufficient for NixOS to avoid the problem, but it doesn’t switch to <code>musl</code> if the <code>gnu</code> binary isn’t found in the release.</p>
</section>
<section id="Results">
<h2>Results</h2>
<p>Thanks to this adventure, <code>maru</code> is now statically linked for linux systems, and runs without issues straight after download on both NixOS and Debian.</p>
<p>Jeff and I learned about excellent debugging tools such as <code>readelf</code>.<label for="fn4"></label>

<span><span>Also <code>strace</code> and <code>file</code> which I didn’t mention in the story, since <code>readelf</code> provided the correct information. <code>file</code> did share: <code>interpreter /lib64/ld-linux-x86-64.so.2</code>, which succinctly showed the path.</span>
</span>
</p>
</section>
</section></div>
  </body>
</html>
