<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thepragmaticcto.com/p/lines-of-code-are-back-and-its-worse">Original</a>
    <h1>Lines of Code Are Back (and It&#39;s Worse Than Before)</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><article><div><div><div dir="auto"><p>The software industry doesn&#39;t agree on much. Tabs versus spaces, monoliths versus microservices, whether stand-ups are useful or performance art—pick a topic and you&#39;ll find engineers ready to die on both hills. But for about forty years, we had one consensus: lines of code is a terrible metric.</p><p><a href="https://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html" rel="">Dijkstra</a><span> called it &#34;a very costly measuring unit because it encourages the writing of insipid code.&#34; Lines are spent, not produced. Bill Gates compared measuring programming progress by lines of code to measuring aircraft building progress by weight. Ken Thompson said one of his most productive days was throwing away a thousand lines.</span></p><p><span>In 2009, </span><a href="https://www.infoq.com/news/2009/08/demarco-software-engineering-/" rel="">Tom DeMarco</a><span>—the man who wrote &#34;you can&#39;t control what you can&#39;t measure&#34;—formally retracted the statement. Software projects, he concluded, are fundamentally experimental; the important goal is transformation, not control. By 2023, Kent Beck was calling LOC </span><a href="https://shiftmag.dev/mckinsey-measure-developer-productivity-1166/" rel="">&#34;an input metric&#34;</a><span>—the worst category. &#34;Only use it if you have nothing else to measure success with.&#34;</span></p><p>That was the consensus. Settled. Done.</p><p>Then AI showed up, and we brought it back.</p><p>Every major tech CEO is now competing on what percentage of their code is written by AI. Watch the progression.</p><p><a href="https://fortune.com/2024/10/30/googles-code-ai-sundar-pichai/" rel="">Sundar Pichai</a><span> told investors in October 2024 that 25% of Google&#39;s new code was AI-generated. By mid-2025, that number climbed past 30%. </span><a href="https://www.cnbc.com/2025/04/29/satya-nadella-says-as-much-as-30percent-of-microsoft-code-is-written-by-ai.html" rel="">Satya Nadella</a><span> said &#34;maybe 20%, 30%&#34; of Microsoft&#39;s code is now written by software. </span><a href="https://www.engadget.com/ai/mark-zuckerberg-predicts-ai-will-write-most-of-metas-code-within-12-to-18-months-213851646.html" rel="">Mark Zuckerberg</a><span> predicted AI would handle half of Meta&#39;s development within a year. And </span><a href="https://finance.yahoo.com/news/anthropic-ceo-says-ai-could-193020957.html" rel="">Dario Amodei</a><span> predicted 90% of code would be AI-written within six months; when the deadline passed, he </span><a href="https://www.itpro.com/technology/artificial-intelligence/anthropic-ceo-dario-amodei-ai-generated-code" rel="">revised the claim</a><span> to &#34;70, 80, 90% of the code written at Anthropic is written by Claude.&#34;</span></p><p>Twenty-five percent. Thirty percent. Fifty percent. Ninety percent. The numbers only go up, and they&#39;re presented as achievements—on earnings calls, in press releases, at conferences. Nobody is reporting &#34;percentage of bugs introduced by AI-generated code&#34; or &#34;percentage of AI code that survived review unchanged.&#34; Nobody is mentioning how much of that generated code was thrown away, reworked, or never deployed. The headline metric is volume. LOC by another name.</p><p><span>The tooling reinforces it. </span><a href="https://resources.github.com/learn/pathways/copilot/essentials/measuring-the-impact-of-github-copilot/" rel="">GitHub Copilot&#39;s dashboard</a><span> shows &#34;Total Lines Suggested&#34; and &#34;Total Lines Accepted&#34; as primary metrics. </span><a href="https://devgraphiq.com/cursor-statistics/" rel="">Cursor</a><span> tracks lines added per user, reporting a 28.6% increase following adoption. The industry generated </span><a href="https://www.elitebrains.com/blog/aI-generated-code-statistics-2025" rel="">256 billion lines of AI-written code</a><span> in 2024 alone. That number is treated as progress.</span></p><p><span>And it&#39;s not just executives. The LOC obsession has filtered into social media culture. A </span><a href="https://x.com/chatgpt21/status/2019496520425292220" rel="">viral tweet</a><span> last week—1.6 million views—celebrated Anthropic&#39;s AI agents building a C compiler: &#34;100k lines, compiles the Linux kernel, $20k, 2 weeks.&#34; A Community Note corrected the framing; GCC took about two years to build from conception, not thirty-seven. But the correction didn&#39;t go viral. The line count did.</span></p><p><span>One developer </span><a href="https://x.com/StephenReed_AGI/status/2019821561537052721" rel="">compared</a><span> his AI agents&#39; output—3.2 million lines of code in three months—to his lifetime achievement of 700,000 lines across sixty years. Then he used Grok to generate an argument for why LOC is a valid metric. Using AI to justify the metric that AI makes meaningless. You can&#39;t make this up.</span></p><p><span>I </span><a href="https://x.com/allanmacgregor" rel="">asked</a><span> a simple question on X last week: &#34;Why are people in the AI space so obsessed with lines of code?&#34; The question got 10,000 views. This article is my answer.</span></p><p><span>You know </span><a href="https://en.wikipedia.org/wiki/Goodhart&#39;s_law" rel="">Goodhart&#39;s Law</a><span>: when a measure becomes a target, it ceases to be a good measure. LOC was a textbook case of this before AI entered the picture. Developers rewarded for adding lines wrote verbose code; teams measured by output shipped bloat instead of solutions. The industry recognized the problem, and for the most part, we stopped using LOC as a productivity metric.</span></p><p>AI didn&#39;t just repeat the mistake. It broke the mistake open.</p><p>Think about it in three layers.</p><p><strong>Layer one: LOC failed as a human metric because it was gameable.</strong><span> Developers rewarded for adding lines could write verbose code to hit targets. Managers knew this. The industry spent decades documenting the problem. We moved on.</span></p><p><strong>Layer two: AI makes the metric infinitely gameable.</strong><span> When a human developer games LOC, there&#39;s friction. Writing unnecessary code takes effort; the gaming has a natural ceiling because a person can only type so fast and only tolerate so much tedium. Remove those limits. An AI can produce ten thousand lines in the time a developer writes fifty. The cost of generating a line of code is now functionally zero. If LOC was misleading when it cost effort to produce, it is meaningless when it costs nothing.</span></p><p><strong>Layer three: we are applying Goodhart&#39;s Law to Goodhart&#39;s Law.</strong><span> The metric that was already broken is now the target for a system with infinite capacity to game it. The constraint that kept a bad metric merely bad has been eliminated; what&#39;s left is a metric that measures nothing at all. We&#39;re not repeating a forty-year-old mistake. We&#39;re running it with the guardrails removed.</span></p><p><span>Andrej Karpathy </span><a href="https://x.com/karpathy/status/1886192184808149383" rel="">coined the term</a><span> &#34;vibe coding&#34; in February 2025—&#34;forget that the code even exists.&#34; When code generation requires zero comprehension, measuring code volume measures zero comprehension. </span><a href="https://www.greptile.com/state-of-ai-coding-2025" rel="">Greptile&#39;s data</a><span> shows lines per developer grew 76%, from 4,450 to 7,839. More output. Not more understanding.</span></p><p>The question every CTO should be asking: if the cost of generating code is zero, what does the volume of generated code tell you? The answer is nothing. It tells you nothing.</p><p>The data on what happens when you optimize for volume is already in. The numbers are not encouraging.</p><p><a href="https://www.gitclear.com/ai_assistant_code_quality_2025_research" rel="">GitClear analyzed 211 million lines of code</a><span> across private repos and 25 major open-source projects from 2020 to 2024. Copy-pasted code rose from 8.3% to 12.3%. Code blocks with five or more duplicated lines increased eightfold during 2024. Refactoring collapsed—the percentage of moved, restructured lines dropped from 24.1% in 2020 to 9.5% in 2024. A 60% decline. And </span><a href="https://www.gitclear.com/coding_on_copilot_data_shows_ais_downward_pressure_on_code_quality" rel="">code churn doubled</a><span>: new code revised within two weeks of commit grew from 3.1% to 5.7%.</span></p><p>Read that again: 2024 was the first year in GitClear&#39;s dataset where copy-pasted lines exceeded moved lines. The industry crossed a threshold. We are now generating more duplicate code than we are refactoring existing code. That is the cost of optimizing for volume.</p><p><span>The productivity numbers are worse than the quality numbers. </span><a href="https://metr.org/blog/2025-07-10-early-2025-ai-experienced-os-dev-study/" rel="">METR ran a randomized controlled trial</a><span>—sixteen experienced open-source developers, 246 tasks on well-known repositories. Developers using AI tools took 19% longer to complete their work. But they believed they were 20% faster. A </span><a href="https://arxiv.org/abs/2507.09089" rel="">40-point perception gap</a><span> between what developers think AI does for them and what it measurably does.</span></p><p><span>The </span><a href="https://stackoverflow.blog/2025/12/29/developers-remain-willing-but-reluctant-to-use-ai-the-2025-developer-survey-results-are-here/" rel="">Stack Overflow 2025 Developer Survey</a><span> reinforces this. Trust in AI accuracy fell from 40% to 29% year over year. More developers actively distrust AI tools (46%) than trust them (33%). And 66% say they spend more time fixing &#34;almost-right&#34; AI-generated code than they save in the initial writing phase.</span></p><p><span>On the security side, </span><a href="https://www.lawfaremedia.org/article/when-the-vibe-are-off--the-security-risks-of-ai-generated-code" rel="">45% of AI-generated code contains security flaws</a><span> according to Veracode&#39;s 2025 report. Vibe-coded applications are already failing in production; one high-profile exercise saw AI </span><a href="https://thenewstack.io/vibe-coding-could-cause-catastrophic-explosions-in-2026/" rel="">ignore a code freeze, fabricate data, and delete a production database</a><span>. A Swedish vibe-coding platform shipped 170 apps with exploitable vulnerabilities out of 1,645 tested.</span></p><p>More code. Worse code. Less understood code. And we&#39;re measuring the &#34;more&#34; as if it were a feature.</p><p>The industry recognized that raw LOC was indefensible, so it found a replacement: acceptance rate. The percentage of AI-suggested code that developers accept. This is the metric on most engineering leaders&#39; dashboards today.</p><p>It suffers from every flaw LOC had, plus new ones.</p><p><a href="https://leaddev.com/reporting/the-rise-and-looming-fall-of-acceptance-rate" rel="">Accepting code doesn&#39;t mean it&#39;s good code</a><span>. A developer might accept a suggestion because it&#39;s close enough, because they&#39;re tired of rejecting and rewriting, because the context-switching cost of evaluating each suggestion exceeds the cost of just taking it. Acceptance rate conflates &#34;not rejected&#34; with &#34;valuable&#34;—and those are not the same thing.</span></p><p><span>As </span><a href="https://www.coderabbit.ai/blog/measuring-what-matters-in-the-age-of-ai-assisted-development" rel="">CodeRabbit put it</a><span>: &#34;Most tooling gives you vanity metrics like lines of code generated and number of AI completions accepted, which tell you nothing about what happens after the AI writes code.&#34; The metric ends at the moment of acceptance. It says nothing about whether the code worked, whether it introduced bugs, whether someone understood it, whether it survived the next refactor.</span></p><p><span>The pattern keeps repeating. Lines of code, function points, story points, velocity, acceptance rate—each generation of metric gets critiqued by its own advocates, discarded, and replaced with something that measures the same wrong thing in a new wrapper. We keep looking for a number that captures developer productivity in a single figure, and we keep finding that no such number exists. </span><a href="https://leaddev.com/reporting/the-rise-and-looming-fall-of-acceptance-rate" rel="">Sixty percent of engineering leaders</a><span> cite a lack of clear metrics as their biggest AI challenge. They know the current metrics are broken. They just don&#39;t know what to replace them with.</span></p><p>LOC is not always meaningless. Stating otherwise would be dishonest.</p><p><span>As a rough sizing metric—not a productivity metric—lines of code can help estimate project scope. Tracking codebase growth over time can signal maintainability concerns before they become crises. At the aggregate level, LOC trends reveal how work is changing across the industry; </span><a href="https://www.greptile.com/state-of-ai-coding-2025" rel="">Greptile&#39;s reports</a><span> use LOC data to show real patterns in how developers interact with AI tools. And as an adoption metric—how much AI-generated code is entering your codebase—LOC indicates tool usage levels, even if it says nothing about value delivered.</span></p><p><span>AI coding tools are also not the problem. The problem is how we measure them. Salvatore Sanfilippo—</span><a href="https://antirez.com/news/158" rel="">antirez</a><span>, the creator of Redis—makes a compelling case that AI genuinely enables building things faster when you know what to build. He created a pure C library for BERT-like embedding models in five minutes: 700 lines of code with output comparable to PyTorch. The value was in his decades of knowing what to build; the AI handled the typing. That&#39;s a legitimate productivity gain.</span></p><p><a href="https://www.technologyreview.com/2026/01/12/1130027/generative-coding-ai-software-2026-breakthrough-technology" rel="">MIT Technology Review</a><span> named generative coding one of ten Breakthrough Technologies for 2026. The recognition is deserved. These tools are useful for boilerplate, for exploring unfamiliar APIs, for rubber-ducking problems, for rapid prototyping. I use them. Most CTOs I know use them.</span></p><p>The argument is not that AI coding tools are bad. The argument is that measuring their value by counting the code they produce is like measuring a surgeon&#39;s skill by how many incisions they make. More incisions is not better surgery. More code is not better software. The metric rewards the wrong thing.</p><p>If LOC and acceptance rate are broken, the obvious question is: what should replace them?</p><p>The answer requires a fundamental shift in what you&#39;re looking at. Stop measuring inputs—lines generated, suggestions accepted, percentage of code from AI. Start measuring outcomes—what happened to the software and the team after the code was written. This is harder. It requires more instrumentation, more judgment, more patience. It also measures something worth knowing.</p><p>Four metrics survive Goodhart&#39;s Law because they&#39;re hard to game and they measure what matters.</p><p><strong>Time-to-value.</strong><span> Not &#34;how fast did we write code&#34; but &#34;how long from identified need to working feature in production?&#34; AI should compress this timeline. If it doesn&#39;t, the code volume is noise. This is the metric your board cares about even if they don&#39;t know the name for it; it maps directly to customer impact and revenue. When a CEO asks &#34;what is AI doing for us,&#34; the answer should be a time-to-value number, not a line count.</span></p><p><strong>Code half-life.</strong><span> How long does new code survive before it needs revision? GitClear&#39;s churn data shows AI code gets revised faster—new code rewritten within two weeks nearly doubled from 2020 to 2024. Healthy code has a long half-life. Code that gets rewritten in fourteen days was never finished. Track this by origin; if AI-generated code has a shorter half-life than human-written code, that tells you something LOC never will.</span></p><p><strong>Defect origin rate.</strong><span> What percentage of production defects trace back to AI-generated code versus human-written code? Not as a blame metric—as a calibration metric. If AI-generated code introduces defects at a higher rate, you need more review, not less AI. Track the ratio; adjust your process accordingly.</span></p><p><strong>Comprehension coverage.</strong><span> Can someone on the team explain how every critical path in the system works? This is the metric nobody tracks and everybody should. If the answer is &#34;the AI wrote that and nobody reviewed the logic,&#34; you have a time bomb. Vibe coding makes this worse by design; Karpathy&#39;s own framing was to &#34;forget that the code even exists.&#34; Code that nobody understands is code that nobody can debug, extend, or secure.</span></p><p><span>The meta-principle: good metrics measure what happened </span><em>after</em><span> the code was written. Bad metrics measure what happened </span><em>during</em><span> writing. LOC, acceptance rate, lines suggested—all measure the act of creation. Time-to-value, code half-life, defect origin, comprehension coverage—all measure the result. The act of writing code has never been the bottleneck; understanding, design, and judgment are the bottleneck. Measure accordingly.</span></p><p>Currently, I&#39;m doing what I have always done at Demac, at Humi and now at LiORA; we are tracking time to value, customer impact and customer trust. We are not measuring the volume of code we are generating, it is not a meaningful signal.</p><p>Building the right things, at the right pace, with the right quality, is the key to success; of any startup, or any business.</p><p>This metrics are harder to measure than counting lines; that&#39;s the point. If a metric is easy to collect, it probably measures inputs. The useful metrics require you to follow the code past the point of creation and into production.</p><p>We use AI tools throughout the engineering org, mostly to assist reviewing code rather than writing it, helping increase our time to value.</p><p>I might be wrong about some of this. Maybe the industry will figure out how to make volume a meaningful signal. But I&#39;d rather measure the hard things poorly than measure the easy things precisely; at least the hard things point in the right direction. And I&#39;d rather explain to my board why our metrics are nuanced than explain why we shipped code nobody understands.</p><p>When your board asks what percentage of code is AI-generated, what are they asking? And is the answer you&#39;re giving them what they need to hear?</p><p>If your AI tools disappeared tomorrow, would your team ship slower—or just write less code?</p><p>What percentage of your codebase can someone on your team explain from memory? Is that number going up or down?</p><p>The bottleneck in software was never typing speed. It was understanding, design, and judgment. LOC measured the wrong thing when humans wrote code. It measures even less now that machines do. The question for every CTO is not &#34;how much code are we generating?&#34; It is &#34;how much of that code should exist at all?&#34;</p></div></div></div></article></div></div></div><div><div id="discussion"><div><h4>Discussion about this post</h4></div></div></div></div>
  </body>
</html>
