<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.python.org/3.15/library/profiling.sampling.html">Original</a>
    <h1>Tachyon: High frequency statistical sampling profiler</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>
          <div role="main">
            
  <section id="module-profiling.sampling">
<span id="profiling-sampling-statistical-profiler"></span><span id="profiling-sampling"></span>
<p><span>Added in version 3.15.</span></p>
<p><strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/main/Lib/profiling/sampling/">Lib/profiling/sampling/</a></p>
<hr/>
<a href="https://docs.python.org/3.15/_images/tachyon-logo.png"><img alt="Tachyon logo" src="https://docs.python.org/3.15/_images/tachyon-logo.png"/>
</a>
<p>The <a href="#module-profiling.sampling" title="profiling.sampling: Statistical sampling profiler for Python processes."><code><span>profiling.sampling</span></code></a> module, named <strong>Tachyon</strong>, provides statistical
profiling of Python programs through periodic stack sampling. Tachyon can
run scripts directly or attach to any running Python process without requiring
code changes or restarts. Because sampling occurs externally to the target
process, overhead is virtually zero, making Tachyon suitable for both
development and production environments.</p>
<section id="what-is-statistical-profiling">
<h2>What is statistical profiling?<a href="#what-is-statistical-profiling" title="Link to this heading">¶</a></h2>
<p>Statistical profiling builds a picture of program behavior by periodically
capturing snapshots of the call stack. Rather than instrumenting every function
call and return as deterministic profilers do, Tachyon reads the call stack at
regular intervals to record what code is currently running.</p>
<p>This approach rests on a simple principle: functions that consume significant
CPU time will appear frequently in the collected samples. By gathering thousands
of samples over a profiling session, Tachyon constructs an accurate statistical
estimate of where time is spent. The more samples collected, the
more precise this estimate becomes.</p>
<section id="how-time-is-estimated">
<h3>How time is estimated<a href="#how-time-is-estimated" title="Link to this heading">¶</a></h3>
<p>The time values shown in Tachyon’s output are <strong>estimates derived from sample
counts</strong>, not direct measurements. Tachyon counts how many times each function
appears in the collected samples, then multiplies by the sampling interval to
estimate time.</p>
<p>For example, with a 10 kHz sampling rate over a 10-second profile,
Tachyon collects approximately 100,000 samples. If a function appears in 5,000
samples (5% of total), Tachyon estimates it consumed 5% of the 10-second
duration, or about 500 milliseconds. This is a statistical estimate, not a
precise measurement.</p>
<p>The accuracy of these estimates depends on sample count. With 100,000 samples,
a function showing 5% has a margin of error of roughly ±0.5%. With only 1,000
samples, the same 5% measurement could actually represent anywhere from 3% to
7% of real time.</p>
<p>This is why longer profiling durations and shorter sampling intervals produce
more reliable results—they collect more samples. For most performance
analysis, the default settings provide sufficient accuracy to identify
bottlenecks and guide optimization efforts.</p>
<p>Because sampling is statistical, results will vary slightly between runs. A
function showing 12% in one run might show 11% or 13% in the next. This is
normal and expected. Focus on the overall pattern rather than exact percentages,
and don’t worry about small variations between runs.</p>
</section>
<section id="when-to-use-a-different-approach">
<h3>When to use a different approach<a href="#when-to-use-a-different-approach" title="Link to this heading">¶</a></h3>
<p>Statistical sampling is not ideal for every situation.</p>
<p>For very short scripts that complete in under one second, the profiler may not
collect enough samples for reliable results. Use <a href="https://docs.python.org/3.15/library/profiling.tracing.html#module-profiling.tracing" title="profiling.tracing: Deterministic tracing profiler for Python programs."><code><span>profiling.tracing</span></code></a>
instead, or run the script in a loop to extend profiling time.</p>
<p>When you need exact call counts, sampling cannot provide them. Sampling
estimates frequency from snapshots, so if you need to know precisely how many
times a function was called, use <a href="https://docs.python.org/3.15/library/profiling.tracing.html#module-profiling.tracing" title="profiling.tracing: Deterministic tracing profiler for Python programs."><code><span>profiling.tracing</span></code></a>.</p>
<p>When comparing two implementations where the difference might be only 1-2%,
sampling noise can obscure real differences. Use <a href="https://docs.python.org/3.15/library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code><span>timeit</span></code></a> for
micro-benchmarks or <a href="https://docs.python.org/3.15/library/profiling.tracing.html#module-profiling.tracing" title="profiling.tracing: Deterministic tracing profiler for Python programs."><code><span>profiling.tracing</span></code></a> for precise measurements.</p>
<p>The key difference from <a href="https://docs.python.org/3.15/library/profiling.tracing.html#module-profiling.tracing" title="profiling.tracing: Deterministic tracing profiler for Python programs."><code><span>profiling.tracing</span></code></a> is how measurement happens.
A tracing profiler instruments your code, recording every function call and
return. This provides exact call counts and precise timing but adds overhead
to every function call. A sampling profiler, by contrast, observes the program
from outside at fixed intervals without modifying its execution. Think of the
difference like this: tracing is like having someone follow you and write down
every step you take, while sampling is like taking photographs every second
and inferring your path from those snapshots.</p>
<p>This external observation model is what makes sampling profiling practical for
production use. The profiled program runs at full speed because there is no
instrumentation code running inside it, and the target process is never stopped
or paused during sampling—Tachyon reads the call stack directly from the
process’s memory while it continues to run. You can attach to a live server,
collect data, and detach without the application ever knowing it was observed.
The trade-off is that very short-lived functions may be missed if they happen
to complete between samples.</p>
<p>Statistical profiling excels at answering the question, “Where is my program
spending time?” It reveals hotspots and bottlenecks in production code where
deterministic profiling overhead would be unacceptable. For exact call counts
and complete call graphs, use <a href="https://docs.python.org/3.15/library/profiling.tracing.html#module-profiling.tracing" title="profiling.tracing: Deterministic tracing profiler for Python programs."><code><span>profiling.tracing</span></code></a> instead.</p>
</section>
</section>
<section id="quick-examples">
<h2>Quick examples<a href="#quick-examples" title="Link to this heading">¶</a></h2>
<p>Profile a script and see the results immediately:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run script.py</span>
</pre></div>
</div>
<p>Profile a module with arguments:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run -m mypackage.module arg1 arg2</span>
</pre></div>
</div>
<p>Generate an interactive flame graph:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --flamegraph -o profile.html script.py</span>
</pre></div>
</div>
<p>Attach to a running process by PID:</p>
<div><div><pre><span></span><span>python -m profiling.sampling attach 12345</span>
</pre></div>
</div>
<p>Use live mode for real-time monitoring (press <code><span>q</span></code> to quit):</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --live script.py</span>
</pre></div>
</div>
<p>Profile for 60 seconds with a faster sampling rate:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run -d 60 -r 20khz script.py</span>
</pre></div>
</div>
<p>Generate a line-by-line heatmap:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --heatmap script.py</span>
</pre></div>
</div>
<p>Enable opcode-level profiling to see which bytecode instructions are executing:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --opcodes --flamegraph script.py</span>
</pre></div>
</div>
</section>
<section id="commands">
<h2>Commands<a href="#commands" title="Link to this heading">¶</a></h2>
<p>Tachyon operates through two subcommands that determine how to obtain the
target process.</p>
<section id="the-run-command">
<h3>The <code><span>run</span></code> command<a href="#the-run-command" title="Link to this heading">¶</a></h3>
<p>The <code><span>run</span></code> command launches a Python script or module and profiles it from
startup:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run script.py</span>
<span>python -m profiling.sampling run -m mypackage.module</span>
</pre></div>
</div>
<p>When profiling a script, the profiler starts the target in a subprocess, waits
for it to initialize, then begins collecting samples. The <code><span>-m</span></code> flag
indicates that the target should be run as a module (equivalent to
<code><span>python</span> <span>-m</span></code>). Arguments after the target are passed through to the
profiled program:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run script.py --config settings.yaml</span>
</pre></div>
</div>
</section>
<section id="the-attach-command">
<h3>The <code><span>attach</span></code> command<a href="#the-attach-command" title="Link to this heading">¶</a></h3>
<p>The <code><span>attach</span></code> command connects to an already-running Python process by its
process ID:</p>
<div><div><pre><span></span><span>python -m profiling.sampling attach 12345</span>
</pre></div>
</div>
<p>This command is particularly valuable for investigating performance issues in
production systems. The target process requires no modification and need not
be restarted. The profiler attaches, collects samples for the specified
duration, then detaches and produces output.</p>
<div><div><pre><span></span><span>python -m profiling.sampling attach --live 12345</span>
<span>python -m profiling.sampling attach --flamegraph -d 30 -o profile.html 12345</span>
</pre></div>
</div>
<p>On most systems, attaching to another process requires appropriate permissions.
See <a href="#profiling-permissions"><span>Platform requirements</span></a> for platform-specific requirements.</p>
</section>
<section id="the-replay-command">
<span id="replay-command"></span><h3>The <code><span>replay</span></code> command<a href="#the-replay-command" title="Link to this heading">¶</a></h3>
<p>The <code><span>replay</span></code> command converts binary profile files to other output formats:</p>
<div><div><pre><span></span><span>python -m profiling.sampling replay profile.bin</span>
<span>python -m profiling.sampling replay --flamegraph -o profile.html profile.bin</span>
</pre></div>
</div>
<p>This command is useful when you have captured profiling data in binary format
and want to analyze it later or convert it to a visualization format. Binary
profiles can be replayed multiple times to different formats without
re-profiling.</p>
<div><div><pre><span></span><span># </span>Convert<span> </span>binary<span> </span>to<span> </span>pstats<span> </span><span>(</span>default,<span> </span>prints<span> </span>to<span> </span>stdout<span>)</span>
<span>python -m profiling.sampling replay profile.bin</span>

<span># </span>Convert<span> </span>binary<span> </span>to<span> </span>flame<span> </span>graph
<span>python -m profiling.sampling replay --flamegraph -o output.html profile.bin</span>

<span># </span>Convert<span> </span>binary<span> </span>to<span> </span>gecko<span> </span>format<span> </span><span>for</span><span> </span>Firefox<span> </span>Profiler
<span>python -m profiling.sampling replay --gecko -o profile.json profile.bin</span>

<span># </span>Convert<span> </span>binary<span> </span>to<span> </span>heatmap
<span>python -m profiling.sampling replay --heatmap -o my_heatmap profile.bin</span>
</pre></div>
</div>
</section>
<section id="profiling-in-production">
<h3>Profiling in production<a href="#profiling-in-production" title="Link to this heading">¶</a></h3>
<p>The sampling profiler is designed for production use. It imposes no measurable
overhead on the target process because it reads memory externally rather than
instrumenting code. The target application continues running at full speed and
is unaware it is being profiled.</p>
<p>When profiling production systems, keep these guidelines in mind:</p>
<p>Start with shorter durations (10-30 seconds) to get quick results, then extend
if you need more statistical accuracy. By default, profiling runs until the
target process completes, which is usually sufficient to identify major hotspots.</p>
<p>If possible, profile during representative load rather than peak traffic.
Profiles collected during normal operation are easier to interpret than those
collected during unusual spikes.</p>
<p>The profiler itself consumes some CPU on the machine where it runs (not on the
target process). On the same machine, this is typically negligible. When
profiling remote processes, network latency does not affect the target.</p>
<p>Results from production may differ from development due to different data
sizes, concurrent load, or caching effects. This is expected and is often
exactly what you want to capture.</p>
</section>
<section id="platform-requirements">
<span id="profiling-permissions"></span><h3>Platform requirements<a href="#platform-requirements" title="Link to this heading">¶</a></h3>
<p>The profiler reads the target process’s memory to capture stack traces. This
requires elevated permissions on most operating systems.</p>
<p><strong>Linux</strong></p>
<p>On Linux, the profiler uses <code><span>ptrace</span></code> or <code><span>process_vm_readv</span></code> to read the
target process’s memory. This typically requires one of:</p>
<ul>
<li><p>Running as root</p></li>
<li><p>Having the <code><span>CAP_SYS_PTRACE</span></code> capability</p></li>
<li><p>Adjusting the Yama ptrace scope: <code><span>/proc/sys/kernel/yama/ptrace_scope</span></code></p></li>
</ul>
<p>The default ptrace_scope of 1 restricts ptrace to parent processes only. To
allow attaching to any process owned by the same user, set it to 0:</p>
<div><div><pre><span></span><span>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span>
</pre></div>
</div>
<p><strong>macOS</strong></p>
<p>On macOS, the profiler uses <code><span>task_for_pid()</span></code> to access the target process.
This requires one of:</p>
<ul>
<li><p>Running as root</p></li>
<li><p>The profiler binary having the <code><span>com.apple.security.cs.debugger</span></code> entitlement</p></li>
<li><p>System Integrity Protection (SIP) being disabled (not recommended)</p></li>
</ul>
<p><strong>Windows</strong></p>
<p>On Windows, the profiler requires administrative privileges or the
<code><span>SeDebugPrivilege</span></code> privilege to read another process’s memory.</p>
</section>
<section id="version-compatibility">
<h3>Version compatibility<a href="#version-compatibility" title="Link to this heading">¶</a></h3>
<p>The profiler and target process must run the same Python minor version (for
example, both Python 3.15). Attaching from Python 3.14 to a Python 3.15 process
is not supported.</p>
<p>Additional restrictions apply to pre-release Python versions: if either the
profiler or target is running a pre-release (alpha, beta, or release candidate),
both must run the exact same version.</p>
<p>On free-threaded Python builds, the profiler cannot attach from a free-threaded
build to a standard build, or vice versa.</p>
</section>
</section>
<section id="sampling-configuration">
<h2>Sampling configuration<a href="#sampling-configuration" title="Link to this heading">¶</a></h2>
<p>Before exploring the various output formats and visualization options, it is
important to understand how to configure the sampling process itself. The
profiler offers several options that control how frequently samples are
collected, how long profiling runs, which threads are observed, and what
additional context is captured in each sample.</p>
<p>The default configuration works well for most use cases:</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th><p>Option</p></th>
<th><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>Default for <code><span>--sampling-rate</span></code> / <code><span>-r</span></code></p></td>
<td><p>1 kHz</p></td>
</tr>
<tr><td><p>Default for <code><span>--duration</span></code> / <code><span>-d</span></code></p></td>
<td><p>Run to completion</p></td>
</tr>
<tr><td><p>Default for <code><span>--all-threads</span></code> / <code><span>-a</span></code></p></td>
<td><p>Main thread only</p></td>
</tr>
<tr><td><p>Default for <code><span>--native</span></code></p></td>
<td><p>No <code><span>&lt;native&gt;</span></code> frames (C code time attributed to caller)</p></td>
</tr>
<tr><td><p>Default for <code><span>--no-gc</span></code></p></td>
<td><p><code><span>&lt;GC&gt;</span></code> frames included when garbage collection is active</p></td>
</tr>
<tr><td><p>Default for <code><span>--mode</span></code></p></td>
<td><p>Wall-clock mode (all samples recorded)</p></td>
</tr>
<tr><td><p>Default for <code><span>--realtime-stats</span></code></p></td>
<td><p>Disabled</p></td>
</tr>
<tr><td><p>Default for <code><span>--subprocesses</span></code></p></td>
<td><p>Disabled</p></td>
</tr>
<tr><td><p>Default for <code><span>--blocking</span></code></p></td>
<td><p>Disabled (non-blocking sampling)</p></td>
</tr>
</tbody>
</table>
<section id="sampling-rate-and-duration">
<h3>Sampling rate and duration<a href="#sampling-rate-and-duration" title="Link to this heading">¶</a></h3>
<p>The two most fundamental parameters are the sampling rate and duration.
Together, these determine how many samples will be collected during a profiling
session.</p>
<p>The <a href="#cmdoption-profiling.sampling-r"><code><span>--sampling-rate</span></code></a> option (<a href="#cmdoption-profiling.sampling-r"><code><span>-r</span></code></a>) sets how frequently samples
are collected. The default is 1 kHz (10,000 samples per second):</p>
<div><div><pre><span></span><span>python -m profiling.sampling run -r 20khz script.py</span>
</pre></div>
</div>
<p>Higher rates capture more samples and provide finer-grained data at the
cost of slightly higher profiler CPU usage. Lower rates reduce profiler
overhead but may miss short-lived functions. For most applications, the
default rate provides a good balance between accuracy and overhead.</p>
<p>The <a href="#cmdoption-profiling.sampling-d"><code><span>--duration</span></code></a> option (<a href="#cmdoption-profiling.sampling-d"><code><span>-d</span></code></a>) sets how long to profile in seconds. By
default, profiling continues until the target process exits or is interrupted:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run -d 60 script.py</span>
</pre></div>
</div>
<p>Specifying a duration is useful when attaching to long-running processes or when
you want to limit profiling to a specific time window. When profiling a script,
the default behavior of running to completion is usually what you want.</p>
</section>
<section id="thread-selection">
<h3>Thread selection<a href="#thread-selection" title="Link to this heading">¶</a></h3>
<p>Python programs often use multiple threads, whether explicitly through the
<a href="https://docs.python.org/3.15/library/threading.html#module-threading" title="threading: Thread-based parallelism."><code><span>threading</span></code></a> module or implicitly through libraries that manage thread
pools.</p>
<p>By default, the profiler samples only the main thread. The <a href="#cmdoption-profiling.sampling-a"><code><span>--all-threads</span></code></a>
option (<a href="#cmdoption-profiling.sampling-a"><code><span>-a</span></code></a>) enables sampling of all threads in the process:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run -a script.py</span>
</pre></div>
</div>
<p>Multi-thread profiling reveals how work is distributed across threads and can
identify threads that are blocked or starved. Each thread’s samples are
combined in the output, with the ability to filter by thread in some formats.
This option is particularly useful when investigating concurrency issues or
when work is distributed across a thread pool.</p>
</section>
<section id="blocking-mode">
<span id="id1"></span><h3>Blocking mode<a href="#blocking-mode" title="Link to this heading">¶</a></h3>
<p>By default, Tachyon reads the target process’s memory without stopping it.
This non-blocking approach is ideal for most profiling scenarios because it
imposes virtually zero overhead on the target application: the profiled
program runs at full speed and is unaware it is being observed.</p>
<p>However, non-blocking sampling can occasionally produce incomplete or
inconsistent stack traces in applications with many generators or coroutines
that rapidly switch between yield points, or in programs with very fast-changing
call stacks where functions enter and exit between the start and end of a single
stack read, resulting in reconstructed stacks that mix frames from different
execution states or that never actually existed.</p>
<p>For these cases, the <a href="#cmdoption-profiling.sampling-blocking"><code><span>--blocking</span></code></a> option stops the target process during
each sample:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --blocking script.py</span>
<span>python -m profiling.sampling attach --blocking 12345</span>
</pre></div>
</div>
<p>When blocking mode is enabled, the profiler suspends the target process,
reads its stack, then resumes it. This guarantees that each captured stack
represents a real, consistent snapshot of what the process was doing at that
instant. The trade-off is that the target process runs slower because it is
repeatedly paused.</p>
<div>
<p>Warning</p>
<p>Do not use very high sample rates (low <code><span>--interval</span></code> values) with blocking
mode. Suspending and resuming a process takes time, and if the sampling
interval is too short, the target will spend more time stopped than running.
For blocking mode, intervals of 1000 microseconds (1 millisecond) or higher
are recommended. The default 100 microsecond interval may cause noticeable
slowdown in the target application.</p>
</div>
<p>Use blocking mode only when you observe inconsistent stacks in your profiles,
particularly with generator-heavy or coroutine-heavy code. For most
applications, the default non-blocking mode provides accurate results with
zero impact on the target process.</p>
</section>
<section id="special-frames">
<h3>Special frames<a href="#special-frames" title="Link to this heading">¶</a></h3>
<p>The profiler can inject artificial frames into the captured stacks to provide
additional context about what the interpreter is doing at the moment each
sample is taken. These synthetic frames help distinguish different types of
execution that would otherwise be invisible.</p>
<p>The <a href="#cmdoption-profiling.sampling-native"><code><span>--native</span></code></a> option adds <code><span>&lt;native&gt;</span></code> frames to indicate when Python has
called into C code (extension modules, built-in functions, or the interpreter
itself):</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --native script.py</span>
</pre></div>
</div>
<p>These frames help distinguish time spent in Python code versus time spent in
native libraries. Without this option, native code execution appears as time
in the Python function that made the call. This is useful when optimizing
code that makes heavy use of C extensions like NumPy or database drivers.</p>
<p>By default, the profiler includes <code><span>&lt;GC&gt;</span></code> frames when garbage collection is
active. The <a href="#cmdoption-profiling.sampling-no-gc"><code><span>--no-gc</span></code></a> option suppresses these frames:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --no-gc script.py</span>
</pre></div>
</div>
<p>GC frames help identify programs where garbage collection consumes significant
time, which may indicate memory allocation patterns worth optimizing. If you
see substantial time in <code><span>&lt;GC&gt;</span></code> frames, consider investigating object
allocation rates or using object pooling.</p>
</section>
<section id="opcode-aware-profiling">
<h3>Opcode-aware profiling<a href="#opcode-aware-profiling" title="Link to this heading">¶</a></h3>
<p>The <a href="#cmdoption-profiling.sampling-opcodes"><code><span>--opcodes</span></code></a> option enables instruction-level profiling that captures
which Python bytecode instructions are executing at each sample:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --opcodes --flamegraph script.py</span>
</pre></div>
</div>
<p>This feature provides visibility into Python’s bytecode execution, including
adaptive specialization optimizations. When a generic instruction like
<code><span>LOAD_ATTR</span></code> is specialized at runtime into a more efficient variant like
<code><span>LOAD_ATTR_INSTANCE_VALUE</span></code>, the profiler shows both the specialized name
and the base instruction.</p>
<p>Opcode information appears in several output formats:</p>
<ul>
<li><p><strong>Flame graphs</strong>: Hovering over a frame displays a tooltip with a bytecode
instruction breakdown, showing which opcodes consumed time in that function</p></li>
<li><p><strong>Heatmap</strong>: Expandable bytecode panels per source line show instruction
breakdown with specialization percentages</p></li>
<li><p><strong>Live mode</strong>: An opcode panel shows instruction-level statistics for the
selected function, accessible via keyboard navigation</p></li>
<li><p><strong>Gecko format</strong>: Opcode transitions are emitted as interval markers in the
Firefox Profiler timeline</p></li>
</ul>
<p>This level of detail is particularly useful for:</p>
<ul>
<li><p>Understanding the performance impact of Python’s adaptive specialization</p></li>
<li><p>Identifying hot bytecode instructions that might benefit from optimization</p></li>
<li><p>Analyzing the effectiveness of different code patterns at the instruction level</p></li>
<li><p>Debugging performance issues that occur at the bytecode level</p></li>
</ul>
<p>The <a href="#cmdoption-profiling.sampling-opcodes"><code><span>--opcodes</span></code></a> option is compatible with <a href="#cmdoption-profiling.sampling-live"><code><span>--live</span></code></a>, <a href="#cmdoption-profiling.sampling-flamegraph"><code><span>--flamegraph</span></code></a>,
<a href="#cmdoption-profiling.sampling-heatmap"><code><span>--heatmap</span></code></a>, and <a href="#cmdoption-profiling.sampling-gecko"><code><span>--gecko</span></code></a> formats. It requires additional memory to store
opcode information and may slightly reduce sampling performance, but provides
unprecedented visibility into Python’s execution model.</p>
</section>
<section id="real-time-statistics">
<h3>Real-time statistics<a href="#real-time-statistics" title="Link to this heading">¶</a></h3>
<p>The <a href="#cmdoption-profiling.sampling-realtime-stats"><code><span>--realtime-stats</span></code></a> option displays sampling rate statistics during
profiling:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --realtime-stats script.py</span>
</pre></div>
</div>
<p>This shows the actual achieved sampling rate, which may be lower than requested
if the profiler cannot keep up. The statistics help verify that profiling is
working correctly and that sufficient samples are being collected. See
<a href="#sampling-efficiency"><span>Sampling efficiency</span></a> for details on interpreting these metrics.</p>
</section>
<section id="subprocess-profiling">
<h3>Subprocess profiling<a href="#subprocess-profiling" title="Link to this heading">¶</a></h3>
<p>The <a href="#cmdoption-profiling.sampling-subprocesses"><code><span>--subprocesses</span></code></a> option enables automatic profiling of subprocesses
spawned by the target:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --subprocesses script.py</span>
<span>python -m profiling.sampling attach --subprocesses 12345</span>
</pre></div>
</div>
<p>When enabled, the profiler monitors the target process for child process
creation. When a new Python child process is detected, a separate profiler
instance is automatically spawned to profile it. This is useful for
applications that use <a href="https://docs.python.org/3.15/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code><span>multiprocessing</span></code></a>, <a href="https://docs.python.org/3.15/library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code><span>subprocess</span></code></a>,
<a href="https://docs.python.org/3.15/library/concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code><span>concurrent.futures</span></code></a> with <a href="https://docs.python.org/3.15/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code><span>ProcessPoolExecutor</span></code></a>,
or other process spawning mechanisms.</p>
<div id="id3">
<p><span>worker_pool.py</span><a href="#id3" title="Link to this code">¶</a></p>
<div><div><pre><span></span><span>from</span><span> </span><span>concurrent.futures</span><span> </span><span>import</span> <span>ProcessPoolExecutor</span>
<span>import</span><span> </span><span>math</span>

<span>def</span><span> </span><span>compute_factorial</span><span>(</span><span>n</span><span>):</span>
    <span>total</span> <span>=</span> <span>0</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>50</span><span>):</span>
        <span>total</span> <span>+=</span> <span>math</span><span>.</span><span>factorial</span><span>(</span><span>n</span><span>)</span>
    <span>return</span> <span>total</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>numbers</span> <span>=</span> <span>[</span><span>5000</span> <span>+</span> <span>i</span> <span>*</span> <span>100</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>50</span><span>)]</span>
    <span>with</span> <span>ProcessPoolExecutor</span><span>(</span><span>max_workers</span><span>=</span><span>4</span><span>)</span> <span>as</span> <span>executor</span><span>:</span>
        <span>results</span> <span>=</span> <span>list</span><span>(</span><span>executor</span><span>.</span><span>map</span><span>(</span><span>compute_factorial</span><span>,</span> <span>numbers</span><span>))</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;Computed </span><span>{</span><span>len</span><span>(</span><span>results</span><span>)</span><span>}</span><span> factorials&#34;</span><span>)</span>
</pre></div>
</div>
</div>
<div><div><pre><span></span><span>python -m profiling.sampling run --subprocesses --flamegraph worker_pool.py</span>
</pre></div>
</div>
<p>This produces separate flame graphs for the main process and each worker
process: <code><span>flamegraph_&lt;main_pid&gt;.html</span></code>, <code><span>flamegraph_&lt;worker1_pid&gt;.html</span></code>,
and so on.</p>
<p>Each subprocess receives its own output file. The filename is derived from
the specified output path (or the default) with the subprocess’s process ID
appended:</p>
<ul>
<li><p>If you specify <code><span>-o</span> <span>profile.html</span></code>, subprocesses produce <code><span>profile_12345.html</span></code>,
<code><span>profile_12346.html</span></code>, and so on</p></li>
<li><p>With default output, subprocesses produce files like <code><span>flamegraph_12345.html</span></code>
or directories like <code><span>heatmap_12345</span></code></p></li>
<li><p>For pstats format (which defaults to stdout), subprocesses produce files like
<code><span>profile_12345.pstats</span></code></p></li>
</ul>
<p>The subprocess profilers inherit most sampling options from the parent (sampling
rate, duration, thread selection, native frames, GC frames, async-aware mode,
and output format). All Python descendant processes are profiled recursively,
including grandchildren and further descendants.</p>
<p>Subprocess detection works by periodically scanning for new descendants of
the target process and checking whether each new process is a Python process
by probing the process memory for Python runtime structures. Non-Python
subprocesses (such as shell commands or external tools) are ignored.</p>
<p>There is a limit of 100 concurrent subprocess profilers to prevent resource
exhaustion in programs that spawn many processes. If this limit is reached,
additional subprocesses are not profiled and a warning is printed.</p>
<p>The <a href="#cmdoption-profiling.sampling-subprocesses"><code><span>--subprocesses</span></code></a> option is incompatible with <a href="#cmdoption-profiling.sampling-live"><code><span>--live</span></code></a> mode
because live mode uses an interactive terminal interface that cannot
accommodate multiple concurrent profiler displays.</p>
</section>
<section id="sampling-efficiency">
<span id="id2"></span><h3>Sampling efficiency<a href="#sampling-efficiency" title="Link to this heading">¶</a></h3>
<p>Sampling efficiency metrics help assess the quality of the collected data.
These metrics appear in the profiler’s terminal output and in the flame graph
sidebar.</p>
<p><strong>Sampling efficiency</strong> is the percentage of sample attempts that succeeded.
Each sample attempt reads the target process’s call stack from memory. An
attempt can fail if the process is in an inconsistent state at the moment of
reading, such as during a context switch or while the interpreter is updating
its internal structures. A low efficiency may indicate that the profiler could
not keep up with the requested sampling rate, often due to system load or an
overly aggressive interval setting.</p>
<p><strong>Missed samples</strong> is the percentage of expected samples that were not
collected. Based on the configured interval and duration, the profiler expects
to collect a certain number of samples. Some samples may be missed if the
profiler falls behind schedule, for example when the system is under heavy
load. A small percentage of missed samples is normal and does not significantly
affect the statistical accuracy of the profile.</p>
<p>Both metrics are informational. Even with some failed attempts or missed
samples, the profile remains statistically valid as long as enough samples
were collected. The profiler reports the actual number of samples captured,
which you can use to judge whether the data is sufficient for your analysis.</p>
</section>
</section>
<section id="profiling-modes">
<h2>Profiling modes<a href="#profiling-modes" title="Link to this heading">¶</a></h2>
<p>The sampling profiler supports four modes that control which samples are
recorded. The mode determines what the profile measures: total elapsed time,
CPU execution time, time spent holding the global interpreter lock, or
exception handling.</p>
<section id="wall-clock-mode">
<h3>Wall-clock mode<a href="#wall-clock-mode" title="Link to this heading">¶</a></h3>
<p>Wall-clock mode (<a href="#cmdoption-profiling.sampling-mode"><code><span>--mode</span></code></a><code><span>=wall</span></code>) captures all samples regardless of what the
thread is doing. This is the default mode and provides a complete picture of
where time passes during program execution:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --mode=wall script.py</span>
</pre></div>
</div>
<p>In wall-clock mode, samples are recorded whether the thread is actively
executing Python code, waiting for I/O, blocked on a lock, or sleeping.
This makes wall-clock profiling ideal for understanding the overall time
distribution in your program, including time spent waiting.</p>
<p>If your program spends significant time in I/O operations, network calls, or
sleep, wall-clock mode will show these waits as time attributed to the calling
function. This is often exactly what you want when optimizing end-to-end
latency.</p>
</section>
<section id="cpu-mode">
<h3>CPU mode<a href="#cpu-mode" title="Link to this heading">¶</a></h3>
<p>CPU mode (<a href="#cmdoption-profiling.sampling-mode"><code><span>--mode</span></code></a><code><span>=cpu</span></code>) records samples only when the thread is actually
executing on a CPU core:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --mode=cpu script.py</span>
</pre></div>
</div>
<p>Samples taken while the thread is sleeping, blocked on I/O, or waiting for
a lock are discarded. The resulting profile shows where CPU cycles are consumed,
filtering out idle time.</p>
<p>CPU mode is useful when you want to focus on computational hotspots without
being distracted by I/O waits. If your program alternates between computation
and network calls, CPU mode reveals which computational sections are most
expensive.</p>
</section>
<section id="comparing-wall-clock-and-cpu-profiles">
<h3>Comparing wall-clock and CPU profiles<a href="#comparing-wall-clock-and-cpu-profiles" title="Link to this heading">¶</a></h3>
<p>Running both wall-clock and CPU mode profiles can reveal whether a function’s
time is spent computing or waiting.</p>
<p>If a function appears prominently in both profiles, it is a true computational
hotspot—actively using the CPU. Optimization should focus on algorithmic
improvements or more efficient code.</p>
<p>If a function is high in wall-clock mode but low or absent in CPU mode, it is
I/O-bound or waiting. The function spends most of its time waiting for network,
disk, locks, or sleep. CPU optimization won’t help here; consider async I/O,
connection pooling, or reducing wait time instead.</p>
<div><div><pre><span></span><span>import</span><span> </span><span>time</span>

<span>def</span><span> </span><span>do_sleep</span><span>():</span>
    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>2</span><span>)</span>

<span>def</span><span> </span><span>do_compute</span><span>():</span>
    <span>sum</span><span>(</span><span>i</span><span>**</span><span>2</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>1000000</span><span>))</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>do_sleep</span><span>()</span>
    <span>do_compute</span><span>()</span>
</pre></div>
</div>
<div><div><pre><span></span><span>python -m profiling.sampling run --mode=wall script.py  # do_sleep ~98%, do_compute ~1%</span>
<span>python -m profiling.sampling run --mode=cpu script.py   # do_sleep absent, do_compute dominates</span>
</pre></div>
</div>
</section>
<section id="gil-mode">
<h3>GIL mode<a href="#gil-mode" title="Link to this heading">¶</a></h3>
<p>GIL mode (<a href="#cmdoption-profiling.sampling-mode"><code><span>--mode</span></code></a><code><span>=gil</span></code>) records samples only when the thread holds Python’s
global interpreter lock:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --mode=gil script.py</span>
</pre></div>
</div>
<p>The GIL is held only while executing Python bytecode. When Python calls into
C extensions, performs I/O operations, or executes native code, the GIL is
typically released. This means GIL mode effectively measures time spent
running Python code specifically, filtering out time in native libraries.</p>
<p>In multi-threaded programs, GIL mode reveals which code is preventing other
threads from running Python bytecode. Since only one thread can hold the GIL
at a time, functions that appear frequently in GIL mode profiles are
monopolizing the interpreter.</p>
<p>GIL mode helps answer questions like “which functions are monopolizing the
GIL?” and “why are my other threads starving?” It can also be useful in
single-threaded programs to distinguish Python execution time from time spent
in C extensions or I/O.</p>
<div><div><pre><span></span><span>import</span><span> </span><span>hashlib</span>

<span>def</span><span> </span><span>hash_work</span><span>():</span>
    <span># C extension - releases GIL during computation</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>200</span><span>):</span>
        <span>hashlib</span><span>.</span><span>sha256</span><span>(</span><span>b</span><span>&#34;data&#34;</span> <span>*</span> <span>250000</span><span>)</span><span>.</span><span>hexdigest</span><span>()</span>

<span>def</span><span> </span><span>python_work</span><span>():</span>
    <span># Pure Python - holds GIL during computation</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>3</span><span>):</span>
        <span>sum</span><span>(</span><span>i</span><span>**</span><span>2</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>1000000</span><span>))</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>hash_work</span><span>()</span>
    <span>python_work</span><span>()</span>
</pre></div>
</div>
<div><div><pre><span></span><span>python -m profiling.sampling run --mode=cpu script.py  # hash_work ~42%, python_work ~38%</span>
<span>python -m profiling.sampling run --mode=gil script.py  # hash_work ~5%, python_work ~60%</span>
</pre></div>
</div>
</section>
<section id="exception-mode">
<h3>Exception mode<a href="#exception-mode" title="Link to this heading">¶</a></h3>
<p>Exception mode (<code><span>--mode=exception</span></code>) records samples only when a thread has
an active exception:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --mode=exception script.py</span>
</pre></div>
</div>
<p>Samples are recorded in two situations: when an exception is being propagated
up the call stack (after <code><span>raise</span></code> but before being caught), or when code is
executing inside an <code><span>except</span></code> block where exception information is still
present in the thread state.</p>
<p>The following example illustrates which code regions are captured:</p>
<div><div><pre><span></span><span>def</span><span> </span><span>example</span><span>():</span>
    <span>try</span><span>:</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;error&#34;</span><span>)</span>    <span># Captured: exception being raised</span>
    <span>except</span> <span>ValueError</span><span>:</span>
        <span>process_error</span><span>()</span>              <span># Captured: inside except block</span>
    <span>finally</span><span>:</span>
        <span>cleanup</span><span>()</span>                    <span># NOT captured: exception already handled</span>

<span>def</span><span> </span><span>example_propagating</span><span>():</span>
    <span>try</span><span>:</span>
        <span>try</span><span>:</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;error&#34;</span><span>)</span>
        <span>finally</span><span>:</span>
            <span>cleanup</span><span>()</span>                <span># Captured: exception propagating through</span>
    <span>except</span> <span>ValueError</span><span>:</span>
        <span>pass</span>

<span>def</span><span> </span><span>example_no_exception</span><span>():</span>
    <span>try</span><span>:</span>
        <span>do_work</span><span>()</span>
    <span>finally</span><span>:</span>
        <span>cleanup</span><span>()</span>                    <span># NOT captured: no exception involved</span>
</pre></div>
</div>
<p>Note that <code><span>finally</span></code> blocks are only captured when an exception is actively
propagating through them. Once an <code><span>except</span></code> block finishes executing, Python
clears the exception information before running any subsequent <code><span>finally</span></code>
block. Similarly, <code><span>finally</span></code> blocks that run during normal execution (when no
exception was raised) are not captured because no exception state is present.</p>
<p>This mode is useful for understanding where your program spends time handling
errors. Exception handling can be a significant source of overhead in code
that uses exceptions for flow control (such as <code><span>StopIteration</span></code> in iterators)
or in applications that process many error conditions (such as network servers
handling connection failures).</p>
<p>Exception mode helps answer questions like “how much time is spent handling
exceptions?” and “which exception handlers are the most expensive?” It can
reveal hidden performance costs in code that catches and processes many
exceptions, even when those exceptions are handled gracefully. For example,
if a parsing library uses exceptions internally to signal format errors, this
mode will capture time spent in those handlers even if the calling code never
sees the exceptions.</p>
</section>
</section>
<section id="output-formats">
<h2>Output formats<a href="#output-formats" title="Link to this heading">¶</a></h2>
<p>The profiler produces output in several formats, each suited to different
analysis workflows. The format is selected with a command-line flag, and
output goes to stdout, a file, or a directory depending on the format.</p>
<section id="pstats-format">
<h3>pstats format<a href="#pstats-format" title="Link to this heading">¶</a></h3>
<p>The pstats format (<a href="#cmdoption-profiling.sampling-pstats"><code><span>--pstats</span></code></a>) produces a text table similar to what
deterministic profilers generate. This is the default output format:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run script.py</span>
<span>python -m profiling.sampling run --pstats script.py</span>
</pre></div>
</div>
<figure id="id4">
<a href="https://docs.python.org/3.15/_images/tachyon-pstats.png"><img alt="Tachyon pstats terminal output" src="https://docs.python.org/3.15/_images/tachyon-pstats.png"/>
</a>
<figcaption>
<p><span>The pstats format displays profiling results in a color-coded table showing
function hotspots, sample counts, and timing estimates.</span><a href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Output appears on stdout by default:</p>
<div><div><pre><span></span><span>Profile Stats (Mode: wall):</span>
<span>     nsamples  sample%    tottime (ms)  cumul%   cumtime (ms)  filename:lineno(function)</span>
<span>       234/892    11.7%       234.00     44.6%       892.00    server.py:145(handle_request)</span>
<span>       156/156     7.8%       156.00      7.8%       156.00    &lt;built-in&gt;:0(socket.recv)</span>
<span>        98/421     4.9%        98.00     21.1%       421.00    parser.py:67(parse_message)</span>
</pre></div>
</div>
<p>The columns show sampling counts and estimated times:</p>
<ul>
<li><p><strong>nsamples</strong>: Displayed as <code><span>direct/cumulative</span></code> (for example, <code><span>10/50</span></code>).
Direct samples are when the function was at the top of the stack, actively
executing. Cumulative samples are when the function appeared anywhere on the
stack, including when it was waiting for functions it called. If a function
shows <code><span>10/50</span></code>, it was directly executing in 10 samples and was on the call
stack in 50 samples total.</p></li>
<li><p><strong>sample%</strong> and <strong>cumul%</strong>: Percentages of total samples for direct and
cumulative counts respectively.</p></li>
<li><p><strong>tottime</strong> and <strong>cumtime</strong>: Estimated wall-clock time based on sample counts
and the profiling duration. Time units are selected automatically based on
the magnitude: seconds for large values, milliseconds for moderate values,
or microseconds for small values.</p></li>
</ul>
<p>The output includes a legend explaining each column and a summary of
interesting functions that highlights:</p>
<ul>
<li><p><strong>Hot spots</strong>: Functions with high direct/cumulative sample ratio (ratio
close to 1.0). These functions spend most of their time executing their own
code rather than waiting for callees. High ratios indicate where CPU time
is actually consumed.</p></li>
<li><p><strong>Indirect calls</strong>: Functions with large differences between cumulative and
direct samples. These are orchestration functions that delegate work to
other functions. They appear frequently on the stack but rarely at the top.</p></li>
<li><p><strong>Call magnification</strong>: Functions where cumulative samples far exceed direct
samples (high cumulative/direct multiplier). These are frequently-nested
functions that appear deep in many call chains.</p></li>
</ul>
<p>Use <a href="#cmdoption-profiling.sampling-no-summary"><code><span>--no-summary</span></code></a> to suppress both the legend and summary sections.</p>
<p>To save pstats output to a file instead of stdout:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run -o profile.txt script.py</span>
</pre></div>
</div>
<p>The pstats format supports several options for controlling the display.
The <a href="#cmdoption-profiling.sampling-sort"><code><span>--sort</span></code></a> option determines the column used for ordering results:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --sort=tottime script.py</span>
<span>python -m profiling.sampling run --sort=cumtime script.py</span>
<span>python -m profiling.sampling run --sort=nsamples script.py</span>
</pre></div>
</div>
<p>The <a href="#cmdoption-profiling.sampling-l"><code><span>--limit</span></code></a> option restricts output to the top N entries:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --limit=30 script.py</span>
</pre></div>
</div>
<p>The <a href="#cmdoption-profiling.sampling-no-summary"><code><span>--no-summary</span></code></a> option suppresses the header summary that precedes the
statistics table.</p>
</section>
<section id="collapsed-stacks-format">
<h3>Collapsed stacks format<a href="#collapsed-stacks-format" title="Link to this heading">¶</a></h3>
<p>Collapsed stacks format (<a href="#cmdoption-profiling.sampling-collapsed"><code><span>--collapsed</span></code></a>) produces one line per unique call
stack, with a count of how many times that stack was sampled:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --collapsed script.py</span>
</pre></div>
</div>
<p>The output looks like:</p>
<div><div><pre><span></span>main;process_data;parse_json;decode_utf8 42
main;process_data;parse_json 156
main;handle_request;send_response 89
</pre></div>
</div>
<p>Each line contains semicolon-separated function names representing the call
stack from bottom to top, followed by a space and the sample count. This
format is designed for compatibility with external flame graph tools,
particularly Brendan Gregg’s <code><span>flamegraph.pl</span></code> script.</p>
<p>To generate a flame graph from collapsed stacks:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --collapsed script.py &gt; stacks.txt</span>
<span>flamegraph.pl stacks.txt &gt; profile.svg</span>
</pre></div>
</div>
<p>The resulting SVG can be viewed in any web browser and provides an interactive
visualization where you can click to zoom into specific call paths.</p>
</section>
<section id="flame-graph-format">
<h3>Flame graph format<a href="#flame-graph-format" title="Link to this heading">¶</a></h3>
<p>Flame graph format (<a href="#cmdoption-profiling.sampling-flamegraph"><code><span>--flamegraph</span></code></a>) produces a self-contained HTML file with
an interactive flame graph visualization:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --flamegraph script.py</span>
<span>python -m profiling.sampling run --flamegraph -o profile.html script.py</span>
</pre></div>
</div>
<figure id="id5">
<a href="https://docs.python.org/3.15/_images/tachyon-flamegraph.png"><img alt="Tachyon interactive flame graph" src="https://docs.python.org/3.15/_images/tachyon-flamegraph.png"/>
</a>
<figcaption>
<p><span>The flame graph visualization shows call stacks as nested rectangles, with
width proportional to time spent. The sidebar displays runtime statistics,
GIL metrics, and hotspot functions.</span><a href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><a href="https://docs.python.org/3.15/_static/tachyon-example-flamegraph.html">Try the interactive example</a>!</p>
<p>If no output file is specified, the profiler generates a filename based on
the process ID (for example, <code><span>flamegraph.12345.html</span></code>).</p>
<p>The generated HTML file requires no external dependencies and can be opened
directly in a web browser. The visualization displays call stacks as nested
rectangles, with width proportional to time spent. Hovering over a rectangle
shows details about that function including source code context, and clicking
zooms into that portion of the call tree.</p>
<p>The flame graph interface includes:</p>
<ul>
<li><p>A sidebar showing profile summary, thread statistics, sampling efficiency
metrics (see <a href="#sampling-efficiency"><span>Sampling efficiency</span></a>), and top hotspot functions</p></li>
<li><p>Search functionality supporting both function name matching and
<code><span>file.py:42</span></code> line patterns</p></li>
<li><p>Per-thread filtering via dropdown</p></li>
<li><p>Dark/light theme toggle (preference saved across sessions)</p></li>
<li><p>SVG export for saving the current view</p></li>
</ul>
<p>The thread statistics section shows runtime behavior metrics:</p>
<ul>
<li><p><strong>GIL Held</strong>: percentage of samples where a thread held the global interpreter
lock (actively running Python code)</p></li>
<li><p><strong>GIL Released</strong>: percentage of samples where no thread held the GIL</p></li>
<li><p><strong>Waiting GIL</strong>: percentage of samples where a thread was waiting to acquire
the GIL</p></li>
<li><p><strong>GC</strong>: percentage of samples during garbage collection</p></li>
</ul>
<p>These statistics help identify GIL contention and understand how time is
distributed between Python execution, native code, and waiting.</p>
<p>Flame graphs are particularly effective for identifying deep call stacks and
understanding the hierarchical structure of time consumption. Wide rectangles
at the top indicate functions that consume significant time either directly
or through their callees.</p>
</section>
<section id="gecko-format">
<h3>Gecko format<a href="#gecko-format" title="Link to this heading">¶</a></h3>
<p>Gecko format (<a href="#cmdoption-profiling.sampling-gecko"><code><span>--gecko</span></code></a>) produces JSON output compatible with the Firefox
Profiler:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --gecko script.py</span>
<span>python -m profiling.sampling run --gecko -o profile.json script.py</span>
</pre></div>
</div>
<p>The <a href="https://profiler.firefox.com">Firefox Profiler</a> is a sophisticated
web-based tool originally built for profiling Firefox itself. It provides
features beyond basic flame graphs, including a timeline view, call tree
exploration, and marker visualization. See the
<a href="https://profiler.firefox.com/docs/#/">Firefox Profiler documentation</a> for
detailed usage instructions.</p>
<p>To use the output, open the Firefox Profiler in your browser and load the
JSON file. The profiler runs entirely client-side, so your profiling data
never leaves your machine.</p>
<p>Gecko format automatically collects additional metadata about GIL state and
CPU activity, enabling analysis features specific to Python’s threading model.
The profiler emits interval markers that appear as colored bands in the
Firefox Profiler timeline:</p>
<ul>
<li><p><strong>GIL markers</strong>: show when threads hold or release the global interpreter lock</p></li>
<li><p><strong>CPU markers</strong>: show when threads are executing on CPU versus idle</p></li>
<li><p><strong>Code type markers</strong>: distinguish Python code from native (C extension) code</p></li>
<li><p><strong>GC markers</strong>: indicate garbage collection activity</p></li>
</ul>
<p>For this reason, the <a href="#cmdoption-profiling.sampling-mode"><code><span>--mode</span></code></a> option is not available with Gecko format;
all relevant data is captured automatically.</p>
<figure id="id6">
<a href="https://docs.python.org/3.15/_images/tachyon-gecko-calltree.png"><img alt="Firefox Profiler Call Tree view" src="https://docs.python.org/3.15/_images/tachyon-gecko-calltree.png"/>
</a>
<figcaption>
<p><span>The Call Tree view shows the complete call hierarchy with sample counts
and percentages. The sidebar displays detailed statistics for the
selected function including running time and sample distribution.</span><a href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure id="id7">
<a href="https://docs.python.org/3.15/_images/tachyon-gecko-flamegraph.png"><img alt="Firefox Profiler Flame Graph view" src="https://docs.python.org/3.15/_images/tachyon-gecko-flamegraph.png"/>
</a>
<figcaption>
<p><span>The Flame Graph visualization shows call stacks as nested rectangles.
Functions names are visible in the call hierarchy.</span><a href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure id="id8">
<a href="https://docs.python.org/3.15/_images/tachyon-gecko-opcodes.png"><img alt="Firefox Profiler Marker Chart with opcodes" src="https://docs.python.org/3.15/_images/tachyon-gecko-opcodes.png"/>
</a>
<figcaption>
<p><span>The Marker Chart displays interval markers including CPU state, GIL
status, and opcodes. With <code><span>--opcodes</span></code> enabled, bytecode instructions
like <code><span>BINARY_OP_ADD_FLOAT</span></code>, <code><span>CALL_PY_EXACT_ARGS</span></code>, and
<code><span>CALL_LIST_APPEND</span></code> appear as markers showing execution over time.</span><a href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="heatmap-format">
<h3>Heatmap format<a href="#heatmap-format" title="Link to this heading">¶</a></h3>
<p>Heatmap format (<a href="#cmdoption-profiling.sampling-heatmap"><code><span>--heatmap</span></code></a>) generates an interactive HTML visualization
showing sample counts at the source line level:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --heatmap script.py</span>
<span>python -m profiling.sampling run --heatmap -o my_heatmap script.py</span>
</pre></div>
</div>
<figure id="id9">
<a href="https://docs.python.org/3.15/_images/tachyon-heatmap.png"><img alt="Tachyon heatmap visualization" src="https://docs.python.org/3.15/_images/tachyon-heatmap.png"/>
</a>
<figcaption>
<p><span>The heatmap overlays sample counts directly on your source code. Lines are
color-coded from cool (few samples) to hot (many samples). Navigation
buttons (▲▼) let you jump between callers and callees.</span><a href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Unlike other formats that produce a single file, heatmap output creates a
directory containing HTML files for each profiled source file. If no output
path is specified, the directory is named <code><span>heatmap_PID</span></code>.</p>
<p>The heatmap visualization displays your source code with a color gradient
indicating how many samples were collected at each line. Hot lines (many
samples) appear in warm colors, while cold lines (few or no samples) appear
in cool colors. This view helps pinpoint exactly which lines of code are
responsible for time consumption.</p>
<p>The heatmap interface provides several interactive features:</p>
<ul>
<li><p><strong>Coloring modes</strong>: toggle between “Self Time” (direct execution) and
“Total Time” (cumulative, including time in called functions)</p></li>
<li><p><strong>Cold code filtering</strong>: show all lines or only lines with samples</p></li>
<li><p><strong>Call graph navigation</strong>: each line shows navigation buttons (▲ for callers,
▼ for callees) that let you trace execution paths through your code. When
multiple functions called or were called from a line, a menu appears showing
all options with their sample counts.</p></li>
<li><p><strong>Scroll minimap</strong>: a vertical overview showing the heat distribution across
the entire file</p></li>
<li><p><strong>Hierarchical index</strong>: files organized by type (stdlib, site-packages,
project) with aggregate sample counts per folder</p></li>
<li><p><strong>Dark/light theme</strong>: toggle with preference saved across sessions</p></li>
<li><p><strong>Line linking</strong>: click line numbers to create shareable URLs</p></li>
</ul>
<p>When opcode-level profiling is enabled with <a href="#cmdoption-profiling.sampling-opcodes"><code><span>--opcodes</span></code></a>, each hot line
can be expanded to show which bytecode instructions consumed time:</p>
<figure id="id10">
<a href="https://docs.python.org/3.15/_images/tachyon-heatmap-with-opcodes.png"><img alt="Heatmap with expanded bytecode panel" src="https://docs.python.org/3.15/_images/tachyon-heatmap-with-opcodes.png"/>
</a>
<figcaption>
<p><span>Expanding a hot line reveals the bytecode instructions executed, including
specialized variants. The panel shows sample counts per instruction and the
overall specialization percentage for the line.</span><a href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><a href="https://docs.python.org/3.15/_static/tachyon-example-heatmap.html">Try the interactive example</a>!</p>
<p>Heatmaps are especially useful when you know which file contains a performance
issue but need to identify the specific lines. Many developers prefer this
format because it maps directly to their source code, making it easy to read
and navigate. For smaller scripts and focused analysis, heatmaps provide an
intuitive view that shows exactly where time is spent without requiring
interpretation of hierarchical visualizations.</p>
</section>
<section id="binary-format">
<h3>Binary format<a href="#binary-format" title="Link to this heading">¶</a></h3>
<p>Binary format (<a href="#cmdoption-profiling.sampling-binary"><code><span>--binary</span></code></a>) produces a compact binary file for efficient
storage of profiling data:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --binary -o profile.bin script.py</span>
<span>python -m profiling.sampling attach --binary -o profile.bin 12345</span>
</pre></div>
</div>
<p>The <a href="#cmdoption-profiling.sampling-compression"><code><span>--compression</span></code></a> option controls data compression:</p>
<ul>
<li><p><code><span>auto</span></code> (default): Use zstd compression if available, otherwise no
compression</p></li>
<li><p><code><span>zstd</span></code>: Force zstd compression (requires <a href="https://docs.python.org/3.15/library/compression.zstd.html#module-compression.zstd" title="compression.zstd: Low-level interface to compression and decompression routines in the zstd library."><code><span>compression.zstd</span></code></a> support)</p></li>
<li><p><code><span>none</span></code>: Disable compression</p></li>
</ul>
<div><div><pre><span></span><span>python -m profiling.sampling run --binary --compression=zstd -o profile.bin script.py</span>
</pre></div>
</div>
<p>To analyze binary profiles, use the <a href="#replay-command"><span>The replay command</span></a> to convert them to
other formats like flame graphs or pstats output.</p>
</section>
</section>
<section id="record-and-replay-workflow">
<h2>Record and replay workflow<a href="#record-and-replay-workflow" title="Link to this heading">¶</a></h2>
<p>The binary format combined with the replay command enables a record-and-replay
workflow that separates data capture from analysis. Rather than generating
visualizations during profiling, you capture raw data to a compact binary file
and convert it to different formats later.</p>
<p>This approach has three main benefits:</p>
<ul>
<li><p>Sampling runs faster because the work of building data structures for
visualization is deferred until replay.</p></li>
<li><p>A single binary capture can be converted to multiple output formats
without re-profiling: pstats for a quick overview, flame graph for visual
exploration, heatmap for line-level detail.</p></li>
<li><p>Binary files are compact and easy to share with colleagues who can convert
them to their preferred format.</p></li>
</ul>
<p>A typical workflow:</p>
<div><div><pre><span></span><span># </span>Capture<span> </span>profile<span> </span><span>in</span><span> </span>production<span> </span>or<span> </span>during<span> </span>tests
<span>python -m profiling.sampling attach --binary -o profile.bin 12345</span>

<span># </span>Later,<span> </span>analyze<span> </span>with<span> </span>different<span> </span>formats
<span>python -m profiling.sampling replay profile.bin</span>
<span>python -m profiling.sampling replay --flamegraph -o profile.html profile.bin</span>
<span>python -m profiling.sampling replay --heatmap -o heatmap profile.bin</span>
</pre></div>
</div>
</section>
<section id="live-mode">
<h2>Live mode<a href="#live-mode" title="Link to this heading">¶</a></h2>
<p>Live mode (<a href="#cmdoption-profiling.sampling-live"><code><span>--live</span></code></a>) provides a terminal-based real-time view of profiling
data, similar to the <code><span>top</span></code> command for system processes:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --live script.py</span>
<span>python -m profiling.sampling attach --live 12345</span>
</pre></div>
</div>
<figure id="id11">
<a href="https://docs.python.org/3.15/_images/tachyon-live-mode-2.gif"><img alt="Tachyon live mode showing all threads" src="https://docs.python.org/3.15/_images/tachyon-live-mode-2.gif"/>
</a>
<figcaption>
<p><span>Live mode displays real-time profiling statistics, showing combined
data from multiple threads in a multi-threaded application.</span><a href="#id11" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The display updates continuously as new samples arrive, showing the current
hottest functions. This mode requires the <a href="https://docs.python.org/3.15/library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code><span>curses</span></code></a> module, which is
available on Unix-like systems but not on Windows. The terminal must be at
least 60 columns wide and 12 lines tall; larger terminals display more columns.</p>
<p>The header displays the top 3 hottest functions, sampling efficiency metrics,
and thread status statistics (GIL held percentage, CPU usage, GC time). The
main table shows function statistics with the currently sorted column indicated
by an arrow (▼).</p>
<p>When <a href="#cmdoption-profiling.sampling-opcodes"><code><span>--opcodes</span></code></a> is enabled, an additional opcode panel appears below the
main table, showing instruction-level statistics for the currently selected
function. This panel displays which bytecode instructions are executing most
frequently, including specialized variants and their base opcodes.</p>
<figure id="id12">
<a href="https://docs.python.org/3.15/_images/tachyon-live-mode-1.gif"><img alt="Tachyon live mode with opcode panel" src="https://docs.python.org/3.15/_images/tachyon-live-mode-1.gif"/>
</a>
<figcaption>
<p><span>Live mode with <code><span>--opcodes</span></code> enabled shows an opcode panel with a bytecode
instruction breakdown for the selected function.</span><a href="#id12" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="keyboard-commands">
<h3>Keyboard commands<a href="#keyboard-commands" title="Link to this heading">¶</a></h3>
<p>Within live mode, keyboard commands control the display:</p>
<dl>
<dt><kbd>q</kbd></dt><dd><p>Quit the profiler and return to the shell.</p>
</dd>
<dt><kbd>s</kbd> / <kbd>S</kbd></dt><dd><p>Cycle through sort orders forward/backward (sample count, percentage,
total time, cumulative percentage, cumulative time).</p>
</dd>
<dt><kbd>p</kbd></dt><dd><p>Pause or resume display updates. Sampling continues in the background
while the display is paused, so you can freeze the view to examine results
without stopping data collection.</p>
</dd>
<dt><kbd>r</kbd></dt><dd><p>Reset all statistics and start fresh. This is disabled after profiling
finishes to prevent accidental data loss.</p>
</dd>
<dt><kbd>/</kbd></dt><dd><p>Enter filter mode to search for functions by name. The filter uses
case-insensitive substring matching against the filename and function name.
Type a pattern and press Enter to apply, or Escape to cancel. Glob patterns
and regular expressions are not supported.</p>
</dd>
<dt><kbd>c</kbd></dt><dd><p>Clear the current filter and show all functions again.</p>
</dd>
<dt><kbd>t</kbd></dt><dd><p>Toggle between viewing all threads combined or per-thread statistics.
In per-thread mode, a thread counter (for example, <code><span>1/4</span></code>) appears showing
your position among the available threads.</p>
</dd>
<dt><kbd>←</kbd> <kbd>→</kbd> or <kbd>↑</kbd> <kbd>↓</kbd></dt><dd><p>In per-thread view, navigate between threads. Navigation wraps around
from the last thread to the first and vice versa.</p>
</dd>
<dt><kbd>+</kbd> / <kbd>-</kbd></dt><dd><p>Increase or decrease the display refresh rate. The range is 0.05 seconds
(20 Hz, very responsive) to 1.0 second (1 Hz, lower overhead). Faster refresh
rates use more CPU. The default is 0.1 seconds (10 Hz).</p>
</dd>
<dt><kbd>x</kbd></dt><dd><p>Toggle trend indicators that show whether functions are becoming hotter
or cooler over time. When enabled, increasing metrics appear in green and
decreasing metrics appear in red, comparing each update to the previous one.</p>
</dd>
<dt><kbd>h</kbd> or <kbd>?</kbd></dt><dd><p>Show the help screen with all available commands.</p>
</dd>
<dt><kbd>j</kbd> / <kbd>k</kbd> (or <kbd>Up</kbd> / <kbd>Down</kbd>)</dt><dd><p>Navigate through opcode entries in the opcode panel (when <code><span>--opcodes</span></code> is
enabled). These keys scroll through the instruction-level statistics for the
currently selected function.</p>
</dd>
</dl>
<p>When profiling finishes (duration expires or target process exits), the display
shows a “PROFILING COMPLETE” banner and freezes the final results. You can
still navigate, sort, and filter the results before pressing <kbd>q</kbd> to exit.</p>
<p>Live mode is incompatible with output format options (<a href="#cmdoption-profiling.sampling-collapsed"><code><span>--collapsed</span></code></a>,
<a href="#cmdoption-profiling.sampling-flamegraph"><code><span>--flamegraph</span></code></a>, and so on) because it uses an interactive terminal
interface rather than producing file output.</p>
</section>
</section>
<section id="async-aware-profiling">
<h2>Async-aware profiling<a href="#async-aware-profiling" title="Link to this heading">¶</a></h2>
<p>For programs using <a href="https://docs.python.org/3.15/library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code><span>asyncio</span></code></a>, the profiler offers async-aware mode
(<a href="#cmdoption-profiling.sampling-async-aware"><code><span>--async-aware</span></code></a>) that reconstructs call stacks based on the task structure
rather than the raw Python frames:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --async-aware async_script.py</span>
</pre></div>
</div>
<p>Standard profiling of async code can be confusing because the physical call
stack often shows event loop internals rather than the logical flow of your
coroutines. Async-aware mode addresses this by tracking which task is running
and presenting stacks that reflect the <code><span>await</span></code> chain.</p>
<div><div><pre><span></span><span>import</span><span> </span><span>asyncio</span>

<span>async</span> <span>def</span><span> </span><span>fetch</span><span>(</span><span>url</span><span>):</span>
    <span>await</span> <span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.1</span><span>)</span>
    <span>return</span> <span>url</span>

<span>async</span> <span>def</span><span> </span><span>main</span><span>():</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>50</span><span>):</span>
        <span>await</span> <span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>fetch</span><span>(</span><span>&#34;a&#34;</span><span>),</span> <span>fetch</span><span>(</span><span>&#34;b&#34;</span><span>),</span> <span>fetch</span><span>(</span><span>&#34;c&#34;</span><span>))</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>())</span>
</pre></div>
</div>
<div><div><pre><span></span><span>python -m profiling.sampling run --async-aware --flamegraph -o out.html script.py</span>
</pre></div>
</div>
<div>
<p>Note</p>
<p>Async-aware profiling requires the target process to have the <a href="https://docs.python.org/3.15/library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code><span>asyncio</span></code></a>
module loaded. If you profile a script before it imports asyncio, async-aware
mode will not be able to capture task information.</p>
</div>
<section id="async-modes">
<h3>Async modes<a href="#async-modes" title="Link to this heading">¶</a></h3>
<p>The <a href="#cmdoption-profiling.sampling-async-mode"><code><span>--async-mode</span></code></a> option controls which tasks appear in the profile:</p>
<div><div><pre><span></span><span>python -m profiling.sampling run --async-aware --async-mode=running async_script.py</span>
<span>python -m profiling.sampling run --async-aware --async-mode=all async_script.py</span>
</pre></div>
</div>
<p>With <a href="#cmdoption-profiling.sampling-async-mode"><code><span>--async-mode</span></code></a><code><span>=running</span></code> (the default), only the task currently executing
on the CPU is profiled. This shows where your program is actively spending time
and is the typical choice for performance analysis.</p>
<p>With <a href="#cmdoption-profiling.sampling-async-mode"><code><span>--async-mode</span></code></a><code><span>=all</span></code>, tasks that are suspended (awaiting I/O, locks, or
other tasks) are also included. This mode is useful for understanding what your
program is waiting on, but produces larger profiles since every suspended task
appears in each sample.</p>
</section>
<section id="task-markers-and-stack-reconstruction">
<h3>Task markers and stack reconstruction<a href="#task-markers-and-stack-reconstruction" title="Link to this heading">¶</a></h3>
<p>In async-aware profiles, you will see <code><span>&lt;task&gt;</span></code> frames that mark boundaries
between asyncio tasks. These are synthetic frames inserted by the profiler to
show the task structure. The task name appears as the function name in these
frames.</p>
<p>When a task awaits another task, the profiler reconstructs the logical call
chain by following the <code><span>await</span></code> relationships. Only “leaf” tasks (tasks that
no other task is currently awaiting) generate their own stack entries. Tasks
being awaited by other tasks appear as part of their awaiter’s stack instead.</p>
<p>If a task has multiple awaiters (a diamond pattern in the task graph), the
profiler deterministically selects one parent and annotates the task marker
with the number of parents, for example <code><span>MyTask</span> <span>(2</span> <span>parents)</span></code>. This indicates
that alternate execution paths exist but are not shown in this particular stack.</p>
</section>
<section id="option-restrictions">
<h3>Option restrictions<a href="#option-restrictions" title="Link to this heading">¶</a></h3>
<p>Async-aware mode uses a different stack reconstruction mechanism and is
incompatible with: <a href="#cmdoption-profiling.sampling-native"><code><span>--native</span></code></a>, <a href="#cmdoption-profiling.sampling-no-gc"><code><span>--no-gc</span></code></a>, <a href="#cmdoption-profiling.sampling-a"><code><span>--all-threads</span></code></a>, and
<a href="#cmdoption-profiling.sampling-mode"><code><span>--mode</span></code></a><code><span>=cpu</span></code> or <a href="#cmdoption-profiling.sampling-mode"><code><span>--mode</span></code></a><code><span>=gil</span></code>.</p>
</section>
</section>
<section id="command-line-interface">
<h2>Command-line interface<a href="#command-line-interface" title="Link to this heading">¶</a></h2>
<p>The complete command-line interface for reference.</p>
<section id="global-options">
<h3>Global options<a href="#global-options" title="Link to this heading">¶</a></h3>
<dl>
<dt id="cmdoption-profiling.sampling-arg-run">
<span><span>run</span></span><span></span><a href="#cmdoption-profiling.sampling-arg-run" title="Link to this definition">¶</a></dt>
<dd><p>Run and profile a Python script or module.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-arg-attach">
<span><span>attach</span></span><span></span><a href="#cmdoption-profiling.sampling-arg-attach" title="Link to this definition">¶</a></dt>
<dd><p>Attach to and profile a running process by PID.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-arg-replay">
<span><span>replay</span></span><span></span><a href="#cmdoption-profiling.sampling-arg-replay" title="Link to this definition">¶</a></dt>
<dd><p>Convert a binary profile file to another output format.</p>
</dd></dl>

</section>
<section id="sampling-options">
<h3>Sampling options<a href="#sampling-options" title="Link to this heading">¶</a></h3>
<dl>
<dt id="cmdoption-profiling.sampling-r">
<span id="cmdoption-profiling.sampling-sampling-rate"></span><span><span>-r</span></span><span> <span>&lt;rate&gt;</span></span><span><span>,</span> </span><span><span>--sampling-rate</span></span><span> <span>&lt;rate&gt;</span></span><a href="#cmdoption-profiling.sampling-r" title="Link to this definition">¶</a></dt>
<dd><p>Sampling rate (for example, <code><span>10000</span></code>, <code><span>10khz</span></code>, <code><span>10k</span></code>). Default: <code><span>1khz</span></code>.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-d">
<span id="cmdoption-profiling.sampling-duration"></span><span><span>-d</span></span><span> <span>&lt;seconds&gt;</span></span><span><span>,</span> </span><span><span>--duration</span></span><span> <span>&lt;seconds&gt;</span></span><a href="#cmdoption-profiling.sampling-d" title="Link to this definition">¶</a></dt>
<dd><p>Profiling duration in seconds. Default: run to completion.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-a">
<span id="cmdoption-profiling.sampling-all-threads"></span><span><span>-a</span></span><span></span><span><span>,</span> </span><span><span>--all-threads</span></span><span></span><a href="#cmdoption-profiling.sampling-a" title="Link to this definition">¶</a></dt>
<dd><p>Sample all threads, not just the main thread.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-realtime-stats">
<span><span>--realtime-stats</span></span><span></span><a href="#cmdoption-profiling.sampling-realtime-stats" title="Link to this definition">¶</a></dt>
<dd><p>Display sampling statistics during profiling.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-native">
<span><span>--native</span></span><span></span><a href="#cmdoption-profiling.sampling-native" title="Link to this definition">¶</a></dt>
<dd><p>Include <code><span>&lt;native&gt;</span></code> frames for non-Python code.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-no-gc">
<span><span>--no-gc</span></span><span></span><a href="#cmdoption-profiling.sampling-no-gc" title="Link to this definition">¶</a></dt>
<dd><p>Exclude <code><span>&lt;GC&gt;</span></code> frames for garbage collection.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-async-aware">
<span><span>--async-aware</span></span><span></span><a href="#cmdoption-profiling.sampling-async-aware" title="Link to this definition">¶</a></dt>
<dd><p>Enable async-aware profiling for asyncio programs.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-opcodes">
<span><span>--opcodes</span></span><span></span><a href="#cmdoption-profiling.sampling-opcodes" title="Link to this definition">¶</a></dt>
<dd><p>Gather bytecode opcode information for instruction-level profiling. Shows
which bytecode instructions are executing, including specializations.
Compatible with <code><span>--live</span></code>, <code><span>--flamegraph</span></code>, <code><span>--heatmap</span></code>, and <code><span>--gecko</span></code>
formats only.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-subprocesses">
<span><span>--subprocesses</span></span><span></span><a href="#cmdoption-profiling.sampling-subprocesses" title="Link to this definition">¶</a></dt>
<dd><p>Also profile subprocesses. Each subprocess gets its own profiler
instance and output file. Incompatible with <code><span>--live</span></code>.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-blocking">
<span><span>--blocking</span></span><span></span><a href="#cmdoption-profiling.sampling-blocking" title="Link to this definition">¶</a></dt>
<dd><p>Pause the target process during each sample. This ensures consistent
stack traces at the cost of slowing down the target. Use with longer
intervals (1000 µs or higher) to minimize impact. See <a href="#blocking-mode"><span>Blocking mode</span></a>
for details.</p>
</dd></dl>

</section>
<section id="mode-options">
<h3>Mode options<a href="#mode-options" title="Link to this heading">¶</a></h3>
<dl>
<dt id="cmdoption-profiling.sampling-mode">
<span><span>--mode</span></span><span> <span>&lt;mode&gt;</span></span><a href="#cmdoption-profiling.sampling-mode" title="Link to this definition">¶</a></dt>
<dd><p>Sampling mode: <code><span>wall</span></code> (default), <code><span>cpu</span></code>, <code><span>gil</span></code>, or <code><span>exception</span></code>.
The <code><span>cpu</span></code>, <code><span>gil</span></code>, and <code><span>exception</span></code> modes are incompatible with
<code><span>--async-aware</span></code>.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-async-mode">
<span><span>--async-mode</span></span><span> <span>&lt;mode&gt;</span></span><a href="#cmdoption-profiling.sampling-async-mode" title="Link to this definition">¶</a></dt>
<dd><p>Async profiling mode: <code><span>running</span></code> (default) or <code><span>all</span></code>.
Requires <code><span>--async-aware</span></code>.</p>
</dd></dl>

</section>
<section id="output-options">
<h3>Output options<a href="#output-options" title="Link to this heading">¶</a></h3>
<dl>
<dt id="cmdoption-profiling.sampling-pstats">
<span><span>--pstats</span></span><span></span><a href="#cmdoption-profiling.sampling-pstats" title="Link to this definition">¶</a></dt>
<dd><p>Generate text statistics output. This is the default.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-collapsed">
<span><span>--collapsed</span></span><span></span><a href="#cmdoption-profiling.sampling-collapsed" title="Link to this definition">¶</a></dt>
<dd><p>Generate collapsed stack format for external flame graph tools.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-flamegraph">
<span><span>--flamegraph</span></span><span></span><a href="#cmdoption-profiling.sampling-flamegraph" title="Link to this definition">¶</a></dt>
<dd><p>Generate self-contained HTML flame graph.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-gecko">
<span><span>--gecko</span></span><span></span><a href="#cmdoption-profiling.sampling-gecko" title="Link to this definition">¶</a></dt>
<dd><p>Generate Gecko JSON format for Firefox Profiler.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-heatmap">
<span><span>--heatmap</span></span><span></span><a href="#cmdoption-profiling.sampling-heatmap" title="Link to this definition">¶</a></dt>
<dd><p>Generate HTML heatmap with line-level sample counts.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-binary">
<span><span>--binary</span></span><span></span><a href="#cmdoption-profiling.sampling-binary" title="Link to this definition">¶</a></dt>
<dd><p>Generate high-performance binary format for later conversion with the
<code><span>replay</span></code> command.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-compression">
<span><span>--compression</span></span><span> <span>&lt;type&gt;</span></span><a href="#cmdoption-profiling.sampling-compression" title="Link to this definition">¶</a></dt>
<dd><p>Compression for binary format: <code><span>auto</span></code> (use zstd if available, default),
<code><span>zstd</span></code>, or <code><span>none</span></code>.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-o">
<span id="cmdoption-profiling.sampling-output"></span><span><span>-o</span></span><span> <span>&lt;path&gt;</span></span><span><span>,</span> </span><span><span>--output</span></span><span> <span>&lt;path&gt;</span></span><a href="#cmdoption-profiling.sampling-o" title="Link to this definition">¶</a></dt>
<dd><p>Output file or directory path. Default behavior varies by format:
<a href="#cmdoption-profiling.sampling-pstats"><code><span>--pstats</span></code></a> writes to stdout, while other formats generate a file
named <code><span>&lt;format&gt;_&lt;PID&gt;.&lt;ext&gt;</span></code> (for example, <code><span>flamegraph_12345.html</span></code>).
<a href="#cmdoption-profiling.sampling-heatmap"><code><span>--heatmap</span></code></a> creates a directory named <code><span>heatmap_&lt;PID&gt;</span></code>.</p>
</dd></dl>

</section>
<section id="pstats-display-options">
<h3>pstats display options<a href="#pstats-display-options" title="Link to this heading">¶</a></h3>
<p>These options apply only to pstats format output.</p>
<dl>
<dt id="cmdoption-profiling.sampling-sort">
<span><span>--sort</span></span><span> <span>&lt;key&gt;</span></span><a href="#cmdoption-profiling.sampling-sort" title="Link to this definition">¶</a></dt>
<dd><p>Sort order: <code><span>nsamples</span></code>, <code><span>tottime</span></code>, <code><span>cumtime</span></code>, <code><span>sample-pct</span></code>,
<code><span>cumul-pct</span></code>, <code><span>nsamples-cumul</span></code>, or <code><span>name</span></code>. Default: <code><span>nsamples</span></code>.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-l">
<span id="cmdoption-profiling.sampling-limit"></span><span><span>-l</span></span><span> <span>&lt;count&gt;</span></span><span><span>,</span> </span><span><span>--limit</span></span><span> <span>&lt;count&gt;</span></span><a href="#cmdoption-profiling.sampling-l" title="Link to this definition">¶</a></dt>
<dd><p>Maximum number of entries to display. Default: 15.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-no-summary">
<span><span>--no-summary</span></span><span></span><a href="#cmdoption-profiling.sampling-no-summary" title="Link to this definition">¶</a></dt>
<dd><p>Omit the Legend and Summary of Interesting Functions sections from output.</p>
</dd></dl>

</section>
<section id="run-command-options">
<h3>Run command options<a href="#run-command-options" title="Link to this heading">¶</a></h3>
<dl>
<dt id="cmdoption-profiling.sampling-m">
<span id="cmdoption-profiling.sampling-module"></span><span><span>-m</span></span><span></span><span><span>,</span> </span><span><span>--module</span></span><span></span><a href="#cmdoption-profiling.sampling-m" title="Link to this definition">¶</a></dt>
<dd><p>Treat the target as a module name rather than a script path.</p>
</dd></dl>

<dl>
<dt id="cmdoption-profiling.sampling-live">
<span><span>--live</span></span><span></span><a href="#cmdoption-profiling.sampling-live" title="Link to this definition">¶</a></dt>
<dd><p>Start interactive terminal interface instead of batch profiling.</p>
</dd></dl>

<div>
<p>See also</p>
<dl>
<dt><a href="https://docs.python.org/3.15/library/profiling.html#module-profiling" title="profiling: Python profiling tools for performance analysis."><code><span>profiling</span></code></a></dt><dd><p>Overview of Python profiling tools and guidance on choosing a profiler.</p>
</dd>
<dt><a href="https://docs.python.org/3.15/library/profiling.tracing.html#module-profiling.tracing" title="profiling.tracing: Deterministic tracing profiler for Python programs."><code><span>profiling.tracing</span></code></a></dt><dd><p>Deterministic tracing profiler for exact call counts and timing.</p>
</dd>
<dt><a href="https://docs.python.org/3.15/library/pstats.html#module-pstats" title="pstats: Statistics object for analyzing profiler output."><code><span>pstats</span></code></a></dt><dd><p>Statistics analysis for profile data.</p>
</dd>
<dt><a href="https://profiler.firefox.com">Firefox Profiler</a></dt><dd><p>Web-based profiler that accepts Gecko format output. See the
<a href="https://profiler.firefox.com/docs/#/">documentation</a> for usage details.</p>
</dd>
<dt><a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a></dt><dd><p>Tools for generating flame graphs from collapsed stack format.</p>
</dd>
</dl>
</div>
</section>
</section>
</section>


            
          </div>
        </div>
      </div>
      
      
    </div></div>
  </body>
</html>
