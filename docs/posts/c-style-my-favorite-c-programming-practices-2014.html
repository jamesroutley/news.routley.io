<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mcinglis/c-style">Original</a>
    <h1>C Style: My favorite C programming practices (2014)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">These are my favorite C programming practices. Some rules are as trivial as style, while others are more intricate. I follow a few rules religiously, and others I use as a guideline. I prioritize correctness, readability, simplicity and maintainability over speed because <a href="http://c2.com/cgi/wiki?PrematureOptimization" rel="nofollow">premature optimization is the root of all evil</a>.</p>
<p dir="auto"><strong>Write correct, readable, simple and maintainable software, and tune it when you&#39;re done</strong>, with benchmarks to identify the choke points. Also, modern compilers <em>will</em> change computational complexities. Simplicity can often lead you to the best solution anyway: it&#39;s easier to write a linked list than it is to get an array to grow, but it&#39;s harder to index a list than it is to index an array.</p>
<p dir="auto">Backwards compatibility (e.g. ANSI C) is rarely important to me. In my opinion, backwards compatibility holds everyone back. I think we should use new technologies and new techniques if we can, to move everyone forward, if only a bit.</p>
<p dir="auto">If you don&#39;t agree with something here, that&#39;s perfectly fine. Pick and choose what you like, and what works for your own situation. These rules aren&#39;t intended to be universal admonitions about quality: they&#39;re just my preferences, and work well for what I do, and what I care about.</p>
<p dir="auto">Writing this guide has made me deeply consider, and reconsider, best C programming practices. I&#39;ve changed my opinion multiple times on many of the rules in this document.</p>
<p dir="auto">So, I&#39;m certain I&#39;m wrong on even more points. This is a constant work-in-progress; issues and pull-requests are very welcome. This guide is licensed under the <a href="https://github.com/mcinglis/c-style/blob/master/license.md">Creative Commons Attribution-ShareAlike</a>, so I&#39;m not liable for anything you do with this, etc.</p>
<hr/>
<div dir="auto"><h4 tabindex="-1" dir="auto">Always develop and compile with all warnings (and more) on</h4><a id="user-content-always-develop-and-compile-with-all-warnings-and-more-on" aria-label="Permalink: Always develop and compile with all warnings (and more) on" href="#always-develop-and-compile-with-all-warnings-and-more-on"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">No excuses here. Always develop and compile with warnings on. It turns out, though, that <code>-Wall</code> and <code>-Wextra</code> actually don&#39;t enable &#34;all&#34; warnings. There are a few others that can be really helpful:</p>
<div dir="auto" data-snippet-clipboard-copy-content="CFLAGS += -Wall -Wextra -Wpedantic \
          -Wformat=2 -Wno-unused-parameter -Wshadow \
          -Wwrite-strings -Wstrict-prototypes -Wold-style-definition \
          -Wredundant-decls -Wnested-externs -Wmissing-include-dirs

# GCC warnings that Clang doesn&#39;t provide:
ifeq ($(CC),gcc)
    CFLAGS += -Wjump-misses-init -Wlogical-op
endif"><pre><span>CFLAGS</span> += -Wall -Wextra -Wpedantic <span>\</span>
          -Wformat=2 -Wno-unused-parameter -Wshadow <span>\</span>
          -Wwrite-strings -Wstrict-prototypes -Wold-style-definition <span>\</span>
          -Wredundant-decls -Wnested-externs -Wmissing-include-dirs

<span><span>#</span> GCC warnings that Clang doesn&#39;t provide:</span>
<span>ifeq</span> (<span>$(<span>CC</span>)</span>,gcc)
    <span>CFLAGS</span> += -Wjump-misses-init -Wlogical-op
<span>endif</span></pre></div>
<p dir="auto">Compiling with optimizations on can also help to detect errors:</p>

<div dir="auto"><h4 tabindex="-1" dir="auto">Use GCC&#39;s and Clang&#39;s <code>-M</code> to automatically generate object file dependencies</h4><a id="user-content-use-gccs-and-clangs--m-to-automatically-generate-object-file-dependencies" aria-label="Permalink: Use GCC&#39;s and Clang&#39;s -M to automatically generate object file dependencies" href="#use-gccs-and-clangs--m-to-automatically-generate-object-file-dependencies"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The GNU Make Manual <a href="https://www.gnu.org/software/make/manual/make.html#Automatic-Prerequisites" rel="nofollow">touches</a> on how to automatically generate the dependencies of your object files from the source file&#39;s <code>#include</code>s. The example rule given in the manual is a bit complicated. Here&#39;s the rules I use:</p>
<div dir="auto" data-snippet-clipboard-copy-content="depfiles = $(objects:.o=.d)

# Have the compiler output dependency files with make targets for each
# of the object files. The `MT` option specifies the dependency file
# itself as a target, so that it&#39;s regenerated when it should be.
%.dep.mk: %.c
	$(CC) -M -MP -MT &#39;$(&lt;:.c=.o) $@&#39; $(CPPFLAGS) $&lt; &gt; $@

# Include each of those dependency files; Make will run the rule above
# to generate each dependency file (if it needs to).
-include $(depfiles)"><pre><span>depfiles</span> = <span>$(<span>objects:.o=.d</span>)</span>

<span><span>#</span> Have the compiler output dependency files with make targets for each</span>
<span><span>#</span> of the object files. The `MT` option specifies the dependency file</span>
<span><span>#</span> itself as a target, so that it&#39;s regenerated when it should be.</span>
<span><span>%</span>.dep.mk</span>: <span>%</span>.c
	<span>$(<span>CC</span>)</span> -M -MP -MT <span><span>&#39;</span>$(&lt;:.c=.o) $@<span>&#39;</span></span> <span>$(<span>CPPFLAGS</span>)</span> <span>$&lt;</span> <span>&gt;</span> <span>$@</span>

<span><span>#</span> Include each of those dependency files; Make will run the rule above</span>
<span><span>#</span> to generate each dependency file (if it needs to).</span>
<span>-include</span> <span>$(<span>depfiles</span>)</span></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Write to the most modern standard you can</h4><a id="user-content-write-to-the-most-modern-standard-you-can" aria-label="Permalink: Write to the most modern standard you can" href="#write-to-the-most-modern-standard-you-can"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">C11 is better than C99, which is (far) better than C89. C11 support is still coming along in GCC and Clang, but many features are there. If you need to support other compilers in the medium-term, write to C99.</p>
<p dir="auto">Always write to a <em>standard</em>, as in <code>-std=c11</code>. Don&#39;t write to a dialect, like <code>gnu11</code>. Try to make do without non-standard language extensions: you&#39;ll thank yourself later.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">We can&#39;t get tabs right, so use spaces everywhere</h4><a id="user-content-we-cant-get-tabs-right-so-use-spaces-everywhere" aria-label="Permalink: We can&#39;t get tabs right, so use spaces everywhere" href="#we-cant-get-tabs-right-so-use-spaces-everywhere"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The idea of tabs was that we&#39;d use tabs for indentation levels, and spaces for alignment. This lets people choose an indentation width to their liking, without breaking alignment of columns.</p>
<div dir="auto" data-snippet-clipboard-copy-content="int main( void ) {
|tab   |if ( pigs_can_fly() == true ) {
|tab   ||tab   |developers_can_use_tabs( &#34;and align columns &#34;
|tab   ||tab   |                         &#34;with spaces!&#34; );
|tab   |}
}"><pre><span>int</span> <span>main</span>( <span>void</span> ) {
|<span>tab</span>   |<span>if</span> ( <span>pigs_can_fly</span>() <span>==</span> true ) {
|<span>tab</span>   <span>||</span><span>tab</span>   |<span>developers_can_use_tabs</span>( <span>&#34;and align columns &#34;</span>
|<span>tab</span>   <span>||</span><span>tab</span>   |                         <span>&#34;with spaces!&#34;</span> );
|<span>tab</span>   |}
}</pre></div>
<p dir="auto">But, alas, we (and our editors) rarely get it right. There are four main problems posed by using tabs and spaces:</p>
<ul dir="auto">
<li>Tabs for indentation lead to inconsistencies between opinions on line lengths. Someone who uses a tab width of 8 will hit 80 characters much sooner than someone who uses a tab width of 2. The only way to avoid this is to require a tab-width, which eliminates the benefit of tabs.</li>
<li>It&#39;s much harder to configure your editor to correctly handle tabs and spaces for each project, than it is to just handle spaces. See also: <a href="http://www.jwz.org/doc/tabs-vs-spaces.html" rel="nofollow">Tabs vs Spaces: An Eternal Holy War</a></li>
<li>It&#39;s harder to align things using only the space bar. It&#39;s much easier to hit tab twice than to hold the space bar for eight characters. A developer on your project <em>will</em> make this mistake eventually. If you use spaces for indentation and alignment, you can hit the tab key in either situation, which is quick, easy and not prone to errors.</li>
<li>It&#39;s easier to prevent tab/space errors on projects that use only spaces, because all they need to do is detect for any tabs at all. To prevent against tabs used for alignment on a project that uses tabs, you&#39;ll need to come up with a regular expression.</li>
</ul>
<p dir="auto">Cut the complexity, and use spaces everywhere. You may have to adjust to someone else&#39;s indent width every now and then. Tough luck!</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Never have more than 79 characters per line</h4><a id="user-content-never-have-more-than-79-characters-per-line" aria-label="Permalink: Never have more than 79 characters per line" href="#never-have-more-than-79-characters-per-line"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Never write lines longer than 79 characters.</p>
<p dir="auto">80-characters-per-line is a de-facto standard for viewing code. Readers of your code who rely on that standard, and have their terminal or editor sized to 80 characters wide, can fit more on the screen by placing windows side-by-side.</p>
<p dir="auto">You should stick to a maximum of 79 characters so that there&#39;s always a space in the last column. This makes it more obvious the line doesn&#39;t continue onto the next line. It also provides a right-hand margin.</p>
<p dir="auto">If you go over 80 characters, you&#39;re making your code significantly harder to read for people who try to rely on the 80-columns standard. Either your line will wrap, which is hard to read, or your readers will have to scroll the window to the right to get the last few characters. Either of these results in code that&#39;s harder to read than if you had just worked out a line-break yourself.</p>
<p dir="auto">It&#39;s harder to read long lines because your eyes have to travel further to get to the start of the next line, and the further they have to go, the more likely you&#39;ll have to visually readjust. 100-wide and 120-wide styles are easier to write, but harder to read.</p>
<p dir="auto">It can be very tempting to let a line here or there go over 79 characters, but your readers will pay the price every time they have to read such a line. Treat 79 characters as a hard limit - no ifs or buts. Work out how best to break long lines, and your readers will thank you.</p>
<p dir="auto">Do what everyone else is doing, and write for 80-column views, and we&#39;ll all be better off.</p>
<ul dir="auto">
<li><a href="http://www.emacswiki.org/emacs/EightyColumnRule" rel="nofollow">Emacs Wiki: Eighty Column Rule</a></li>
<li><a href="http://programmers.stackexchange.com/questions/604/is-the-80-character-limit-still-relevant-in-times-of-widescreen-monitors" rel="nofollow">Programmers&#39; Stack Exchange: Is the 80 character limit still relevant?</a></li>
</ul>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use <code>//</code> comments everywhere, never <code>/* ... */</code></h4><a id="user-content-use--comments-everywhere-never---" aria-label="Permalink: Use // comments everywhere, never /* ... */" href="#use--comments-everywhere-never---"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Stick to single-line comments, and cut the complexity. Compared to single-line comments, multi-line comments:</p>
<ul dir="auto">
<li>are rarely used with a blank margin, so they&#39;re just as character-heavy</li>
<li>have a style, which has to be specified and adhered to</li>
<li>often have <code>*/</code> on its own line, so they&#39;re more line-expensive</li>
<li>have weird rules about embedded <code>/*</code> and <code>*/</code></li>
<li>are harder/impossible to block-edit, and to extend</li>
<li>are more visually-cluttering than <code>//</code></li>
</ul>
<p dir="auto">You have to use <code>/* ... */</code> for inline comments in multi-line <code>#define</code>s, though:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define MAGIC( x ) \
    /* Voodoo magic happens here. */ \
    ..."><pre><span>#define</span> <span>MAGIC</span>( <span>x</span> )<span> \</span>
<span>    /* Voodoo magic happens here. */</span> \
    ...</pre></div>
<p dir="auto">But I often prefer to just add <code>//</code> comments after the macro body describing the tricky bits. I think this makes the macro body easier to read, but still provides the (much-needed) documentation.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Program in American English</h4><a id="user-content-program-in-american-english" aria-label="Permalink: Program in American English" href="#program-in-american-english"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Developing in the same language, using the same spelling and vocabulary, is important. This is especially true in free-software projects with contributors from around the world. You should use the same language consistently for your project, in code, comments and documentation.</p>
<p dir="auto">So, for American English, write <code>color</code>, <code>flavor</code>, <code>center</code>, <code>meter</code>, <code>neighbor</code>, <code>defense</code>, <code>routing</code>, <code>sizable</code>, <code>burned</code>, and so on (<a href="https://en.wikipedia.org/wiki/American_and_British_English_spelling_differences" rel="nofollow">see more</a>). I&#39;m Australian, but I appreciate that most programmers will be learning and using American English. Also, American English spelling is consistently more phonetic and consistent than British English. British English tends to evolve towards American English for this reason, I think.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Comment non-standard-library <code>#include</code>s to say what symbols you use from them</h4><a id="user-content-comment-non-standard-library-includes-to-say-what-symbols-you-use-from-them" aria-label="Permalink: Comment non-standard-library #includes to say what symbols you use from them" href="#comment-non-standard-library-includes-to-say-what-symbols-you-use-from-them"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Namespaces are one of the great advances of software development. Unfortunately, C missed out (scopes aren&#39;t namespaces). But, because namespaces are so fantastic, we should try to simulate them with comments.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;test.c/test.h&gt; // Test, tests_run
#include &#34;trie.h&#34; // Trie, Trie_*"><pre><span>#include</span> <span>&lt;test.c/test.h&gt;</span> <span>// Test, tests_run</span>
<span>#include</span> <span>&#34;trie.h&#34;</span> <span>// Trie, Trie_*</span></pre></div>
<p dir="auto">This provides a few benefits:</p>
<ul dir="auto">
<li>readers aren&#39;t forced to refer to documentation or use <code>grep</code> to find out where a symbol is defined (or, if you don&#39;t follow the rule below, where it comes from): your code just tells them</li>
<li>developers have a hope of being able to determine which <code>#include</code>s can be removed and which can&#39;t</li>
<li>developers are forced to consider namespace pollution (which is otherwise ignored in most C code), and encourages them to only provide small, well-defined headers</li>
</ul>
<p dir="auto">The downside is that the <code>#include</code> comments aren&#39;t checked or enforced. I&#39;ve been intending to write a checker for this for quite some time, but for now, there&#39;s nothing to stop the comments from becoming wrong - either mentioning symbols that aren&#39;t used anymore, or not mentioning symbols that are used. In your project, try to nip these problems in the bud, to stop it from spreading. You should always be able to trust your code.  This maintenance is annoying, for sure, but I think <code>#include</code> comments are worth it in aggregate.</p>
<p dir="auto">Finding where things come from is always one of my main challenges when learning a codebase. It could be a whole lot easier. I&#39;ve never seen any projects that write <code>#include</code> comments like this, but I&#39;d love to see it become a thing.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><code>#include</code> the definition of everything you use</h4><a id="user-content-include-the-definition-of-everything-you-use" aria-label="Permalink: #include the definition of everything you use" href="#include-the-definition-of-everything-you-use"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Don&#39;t depend on what your headers include. If your code uses a symbol, include the header file where that symbol is defined. Then, if your headers change their inclusions, your code won&#39;t break.</p>
<p dir="auto">Also, combined with the <code>#include</code> comment rule above, this saves your readers and fellow developers from having to follow a trail of includes just to find the definition of a symbol you&#39;re using. Your code should just tell them where it comes from.</p>

<p dir="auto">Unified headers are generally bad, because they relieve the library developer of the responsibility to provide loosely-coupled modules clearly separated by their purpose and abstraction. Even if the developer (thinks she) does this anyway, a unified header increases compilation time, and couples the user&#39;s program to the entire library, regardless of if they need it. There are numerous other disadvantages, touched on in the points above.</p>
<p dir="auto">There was a good exposé on unified headers on the <a href="http://programmers.stackexchange.com/questions/185773/library-design-provide-a-common-header-file-or-multiple-headers" rel="nofollow">Programmers&#39; Stack Exchange</a>. An answer mentions that it&#39;s reasonable for something like GTK+ to only provide a single header file. I agree, but I think that&#39;s due to the bad design of GTK+, and it&#39;s not intrinsic to a graphical toolkit.</p>
<p dir="auto">It&#39;s harder for users to write multiple <code>#include</code>s just like it&#39;s harder for users to write types. Bringing difficulty into it is missing the forest for the trees.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Provide include guards for all headers to prevent double inclusion</h4><a id="user-content-provide-include-guards-for-all-headers-to-prevent-double-inclusion" aria-label="Permalink: Provide include guards for all headers to prevent double inclusion" href="#provide-include-guards-for-all-headers-to-prevent-double-inclusion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://en.wikipedia.org/wiki/Include_guard" rel="nofollow">Include guards</a> let you include a header file &#34;twice&#34; without it breaking compilation.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Good
#ifndef INCLUDED_ALPHABET_H
#define INCLUDED_ALPHABET_H

...

#endif // ifndef INCLUDED_ALPHABET_H"><pre><span>// Good</span>
<span>#ifndef</span> <span>INCLUDED_ALPHABET_H</span>
<span>#define</span> <span>INCLUDED_ALPHABET_H</span>

...

<span>#endif</span> <span>// ifndef INCLUDED_ALPHABET_H</span></pre></div>
<p dir="auto"><a href="http://www.lysator.liu.se/c/pikestyle.html" rel="nofollow">Rob Pike argues against include guards</a>, saying you should just never include files in include files. He says that include guards still &#34;result in thousands of needless lines of code passing through the lexical analyzer&#34;.</p>
<p dir="auto">In fact, <a href="http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html" rel="nofollow">GCC will detect include guards</a>, and won&#39;t read such files a second time. I don&#39;t know if other compilers perform this optimization.</p>
<p dir="auto">I don&#39;t think it&#39;s a good idea to require your users include the dependencies of your header files. Your header file&#39;s dependencies shouldn&#39;t really be considered &#34;public&#34;. It would enforce the rule &#34;don&#39;t depend on what your header files include&#34;, but it falls apart as soon as header files are using things you don&#39;t need, like <code>FILE</code> or <code>bool</code>. Users shouldn&#39;t have to care about that if they don&#39;t need it themselves.</p>
<p dir="auto">So, always write include guards, and make your users&#39; lives easy.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Always comment <code>#endif</code>s of large conditional sections</h4><a id="user-content-always-comment-endifs-of-large-conditional-sections" aria-label="Permalink: Always comment #endifs of large conditional sections" href="#always-comment-endifs-of-large-conditional-sections"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">No global or static variables if you can help it (you probably can)</h4><a id="user-content-no-global-or-static-variables-if-you-can-help-it-you-probably-can" aria-label="Permalink: No global or static variables if you can help it (you probably can)" href="#no-global-or-static-variables-if-you-can-help-it-you-probably-can"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Global variables are just hidden arguments to all the functions that use them. They make it really hard to understand what a function does, and how it is controlled.</p>
<p dir="auto">Mutable global variables are especially evil and should be avoided at all costs. Conceptually, a global variable assignment is a bunch of <code>longjmp</code>s to set hidden, static variables. Yuck.</p>
<p dir="auto">You should always try to design your functions to be completely controllable by their arguments. Even if you have a variable that will have to be passed around to lots of a functions - if it affects their computation, it should be a argument or a member of a argument. This <em>always</em> leads to better code and better design.</p>
<p dir="auto">For example, removing global variables and constants from my <a href="https://github.com/mcinglis/trie.c">Trie.c</a> project resulted in the <code>Alphabet</code> struct, which lets users tune the storage structure to their needs. It also opened up some really cool dynamic abilities, like swapping alphabets on the fly for the same trie.</p>
<p dir="auto">Static variables in functions are just global variables scoped to that function; the arguments above apply equally to them. Just like global variables, static variables are often used as an easy way out of providing modular, pure functions. They&#39;re often defended in the name of performance (benchmarks first!). You don&#39;t need static variables, just like you don&#39;t need global variables. If you need persistent state, have the function accept that state as a argument. If you need to return something persistent, allocate memory for it.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Minimize what you expose; declare top-level names <code>static</code> where you can</h4><a id="user-content-minimize-what-you-expose-declare-top-level-names-static-where-you-can" aria-label="Permalink: Minimize what you expose; declare top-level names static where you can" href="#minimize-what-you-expose-declare-top-level-names-static-where-you-can"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Your header files should <em>only</em> include things that users need to use your library. Internal functions or structs or macros should not be provided here; declare them in their respective source files. If it&#39;s needed among multiple source files, provide an internal header file.</p>
<p dir="auto">If a function or global variable isn&#39;t exported in the header, declare it as <code>static</code> in the source file to give it internal linkage. This eliminates the chance of name-clashes among object files, enables a few optimizations, and can improve the linking speed.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Immutability saves lives: use <code>const</code> everywhere you can</h4><a id="user-content-immutability-saves-lives-use-const-everywhere-you-can" aria-label="Permalink: Immutability saves lives: use const everywhere you can" href="#immutability-saves-lives-use-const-everywhere-you-can"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>const</code> improves compile-time correctness. It isn&#39;t only for documenting read-only pointers. It should be used for every read-only variable and pointee.</p>
<p dir="auto"><code>const</code> helps the reader <em>immensely</em> in understanding a piece of functionality. If they can look at an initialization and be sure that that value won&#39;t change throughout the scope, they can reason about the rest of the scope much easier. Without <code>const</code>, everything is up in the air; the reader is forced to comprehend the entire scope to understand what is and isn&#39;t being modified. If you consistently use <code>const</code>, your reader will begin to trust you, and will be able to assume that a variable that isn&#39;t qualified with <code>const</code> is a signal that it will be changed at some point in the scope.</p>
<p dir="auto">Using <code>const</code> everywhere you can also helps you, as a developer, reason about what&#39;s happening in the control flow of your program, and where mutability is spreading. It&#39;s amazing, when using <code>const</code>, how much more helpful the compiler is, especially regarding pointers and pointees. You always want the compiler on your side.</p>
<p dir="auto">The compiler will warn if a pointee loses <code>const</code>ness in a function call (because that would let the pointee be modified), but it won&#39;t complain if a pointee gains <code>const</code>ness. Thus, if you <em>don&#39;t</em> specify your pointer arguments as <code>const</code> when they&#39;re read-only anyway, you discourage your users from using <code>const</code> in their own code:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad: sum should define its array as const.
int sum( int * xs, int n );

// Because otherwise, this will be a compilation warning:
int const xs[] = { 1, 2, 3 };
return sum( xs, sizeof xs );
// =&gt; warning: passing argument 2 of ‘sum’ discards ‘const’
//             qualifier from pointer target type"><pre><span>// Bad: sum should define its array as const.</span>
<span>int</span> <span>sum</span>( <span>int</span> <span>*</span> <span>xs</span>, <span>int</span> <span>n</span> );

<span>// Because otherwise, this will be a compilation warning:</span>
<span>int</span> <span>const</span> <span>xs</span>[] <span>=</span> { <span>1</span>, <span>2</span>, <span>3</span> };
<span>return</span> <span>sum</span>( <span>xs</span>, <span>sizeof</span> <span>xs</span> );
<span>// =&gt; warning: passing argument 2 of ‘sum’ discards ‘const’</span>
<span>//             qualifier from pointer target type</span></pre></div>
<p dir="auto">Thus, using <code>const</code> isn&#39;t really a choice, at least for function signatures. Lots of people consider it beneficial, so everyone should consider it required, whether they like it or not. If you don&#39;t use <code>const</code>, you force your users to either cast all calls to your functions (yuck), ignore <code>const</code> warnings (asking for trouble), or remove those <code>const</code> qualifiers (lose compile-time correctness).</p>
<p dir="auto">If you&#39;re forced to work with a library that ignores <code>const</code>, you can write a macro that casts for you:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// `sum` will not modify the given array; casts for `const` pointers.
#define sum( xs, n ) sum( ( int * ) xs, n )"><pre><span>// `sum` will not modify the given array; casts for `const` pointers.</span>
<span>#define</span> <span>sum</span>( <span>xs</span>, <span>n</span> ) sum( ( int * ) xs, n )</pre></div>
<p dir="auto">Only provide <code>const</code> qualifiers for pointees in function prototypes - <code>const</code> for the argument names themselves is just an implementation detail.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Unnecessary
bool Trie_has( Trie const, char const * const );
// Good
bool Trie_has( Trie, char const * );"><pre><span>// Unnecessary</span>
<span>bool</span> <span>Trie_has</span>( <span>Trie</span> <span>const</span>, <span>char</span> <span>const</span> <span>*</span> <span>const</span> );
<span>// Good</span>
<span>bool</span> <span>Trie_has</span>( <span>Trie</span>, <span>char</span> <span>const</span> <span>*</span> );</pre></div>
<p dir="auto">Unfortunately, C can&#39;t handle conversions from non-const pointee-pointees to const pointee-pointees. Thus, I recommend against making pointee-pointees <code>const</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="char ** const xss = malloc( 3 * ( sizeof char * ) );
char const * const * const yss = xss;
// Warning: initialization from incompatible pointer type

char * const * const zss = xss;
// &lt;no warning&gt;"><pre><span>char</span> <span>*</span><span>*</span> <span>const</span> <span>xss</span> <span>=</span> <span>malloc</span>( <span>3</span> <span>*</span> ( <span>sizeof</span> <span>char</span> <span>*</span> ) );
<span>char</span> <span>const</span> <span>*</span> <span>const</span> <span>*</span> <span>const</span> <span>yss</span> <span>=</span> <span>xss</span>;
<span>// Warning: initialization from incompatible pointer type</span>

<span>char</span> <span>*</span> <span>const</span> <span>*</span> <span>const</span> <span>zss</span> <span>=</span> <span>xss</span>;
<span>// &lt;no warning&gt;</span></pre></div>
<p dir="auto">If you can <code>const</code> the pointees of your <em>internal</em> structs, do. Non-constant pointees can cause mutability to needlessly spread, which makes it harder to glean information from the remaining <code>const</code> qualifiers. Because you have total control over your internal structs, if you need to remove the <code>const</code> in future, you can.</p>
<p dir="auto">You usually shouldn&#39;t <code>const</code> the pointees of your external structs. Flexibility is important when they&#39;re part of the public interface. Consider it carefully. An exception to this that I often make is for fields are best assignable to string literals, such as <code>error</code> fields. In this case, a <code>char const *</code> type prevents you and your users from modifying the underlying string literals, which would prompt a segmentation fault.</p>
<p dir="auto">While it can be reasonable to <code>const</code> the <em>pointees</em> of struct fields, it&#39;s never beneficial to <code>const</code> the struct fields themselves. For example, <a href="http://stackoverflow.com/questions/9691404/how-to-initialize-const-in-a-struct-in-c-with-malloc" rel="nofollow">it makes it painful to <code>malloc</code></a> a value of that struct. If it really makes sense to stop the fields from changing beyond their original values, just define <a href="#document-your-struct-invariants-and-provide-invariant-checkers">invariants</a> that enforce whatever qualities you need. Also, you and your users can just define individual variables of that struct as <code>const</code> to get the same effect.</p>
<p dir="auto">Only make return-type pointees <code>const</code> if you need to, and after careful consideration. I&#39;ve found that when the compiler is hinting to add a <code>const</code> to a return type, it often means that a <code>const</code> should be <em>removed</em> somewhere; not added. It can harm flexibility, so be careful.</p>
<p dir="auto">Finally, never use typecasts or pointers to get around <code>const</code> qualifiers - at least, for things you control. If the variable isn&#39;t constant, don&#39;t make it one.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Always put <code>const</code> on the right and read types right-to-left</h4><a id="user-content-always-put-const-on-the-right-and-read-types-right-to-left" aria-label="Permalink: Always put const on the right and read types right-to-left" href="#always-put-const-on-the-right-and-read-types-right-to-left"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="const char * word;              // Bad: not as const-y as it can be
const char * const word;        // Bad: makes types very weird to read
char const* const word;         // Bad: weird * placement

// Good: right-to-left, word is a constant pointer to a constant char
char const * const word;"><pre><span>const</span> <span>char</span> <span>*</span> <span>word</span>;              <span>// Bad: not as const-y as it can be</span>
<span>const</span> <span>char</span> <span>*</span> <span>const</span> <span>word</span>;        <span>// Bad: makes types very weird to read</span>
<span>char</span> <span>const</span><span>*</span> <span>const</span> <span>word</span>;         <span>// Bad: weird * placement</span>

<span>// Good: right-to-left, word is a constant pointer to a constant char</span>
<span>char</span> <span>const</span> <span>*</span> <span>const</span> <span>word</span>;</pre></div>
<p dir="auto">Because of this rule, you should always pad the <code>*</code> type qualifier with spaces.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Don&#39;t write argument names in function prototypes if they just repeat the type</h4><a id="user-content-dont-write-argument-names-in-function-prototypes-if-they-just-repeat-the-type" aria-label="Permalink: Don&#39;t write argument names in function prototypes if they just repeat the type" href="#dont-write-argument-names-in-function-prototypes-if-they-just-repeat-the-type"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">But, always declare the name of any pointer argument to communicate if it&#39;s a pointer-to-array (plural name) or a pointer-to-value (singular name).</p>
<div dir="auto" data-snippet-clipboard-copy-content="bool trie_eq( Trie trie1, Trie trie2 );         // Bad
bool trie_eq( Trie, Trie );                     // Good

// Bad - are these pointers for modification, nullity, or arrays?
void trie_add( Trie const *, char const * );

// Good
void trie_add( Trie const * trie, char const * string );"><pre><span>bool</span> <span>trie_eq</span>( <span>Trie</span> <span>trie1</span>, <span>Trie</span> <span>trie2</span> );         <span>// Bad</span>
<span>bool</span> <span>trie_eq</span>( <span>Trie</span>, <span>Trie</span> );                     <span>// Good</span>

<span>// Bad - are these pointers for modification, nullity, or arrays?</span>
<span>void</span> <span>trie_add</span>( <span>Trie</span> <span>const</span> <span>*</span>, <span>char</span> <span>const</span> <span>*</span> );

<span>// Good</span>
<span>void</span> <span>trie_add</span>( <span>Trie</span> <span>const</span> <span>*</span> <span>trie</span>, <span>char</span> <span>const</span> <span>*</span> <span>string</span> );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use <code>double</code> rather than <code>float</code>, unless you have a specific reason otherwise</h4><a id="user-content-use-double-rather-than-float-unless-you-have-a-specific-reason-otherwise" aria-label="Permalink: Use double rather than float, unless you have a specific reason otherwise" href="#use-double-rather-than-float-unless-you-have-a-specific-reason-otherwise"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">From <em>21st Century C</em>, by Ben Klemens:</p>
<div dir="auto" data-snippet-clipboard-copy-content="printf( &#34;%f\n&#34;, ( float )333334126.98 );    // 333334112.000000
printf( &#34;%f\n&#34;, ( float )333334125.31 );    // 333334112.000000"><pre><span>printf</span>( <span>&#34;%f\n&#34;</span>, ( <span>float</span> )<span>333334126.98</span> );    <span>// 333334112.000000</span>
<span>printf</span>( <span>&#34;%f\n&#34;</span>, ( <span>float</span> )<span>333334125.31</span> );    <span>// 333334112.000000</span></pre></div>
<p dir="auto">For the vast majority of applications nowadays, space isn&#39;t an issue, but floating-point errors can still pose a threat. It&#39;s much harder for numeric drift to cause problems for <code>double</code>s than it is for <code>float</code>s. Unless you have a very specific reason to use <code>float</code>s, use <code>double</code>s instead. Don&#39;t use <code>float</code>s &#34;because they will be faster&#34;, because without benchmarks, you can&#39;t know if it actually makes any discernible difference. Finish development, then perform benchmarks to identify the choke-points, then use <code>float</code>s in those areas, and see if it actually helps. Before then, prioritize everything else over any supposed performance improvements. Don&#39;t prematurely optimize.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Declare variables as late as possible</h4><a id="user-content-declare-variables-as-late-as-possible" aria-label="Permalink: Declare variables as late as possible" href="#declare-variables-as-late-as-possible"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Declaring variables where they&#39;re used reminds the reader of the type they&#39;re working with. It also suggests where to extract a function to minimize variable scope. Furthermore, it informs the reader as to where each variables are relevant. Declaring variables when they&#39;re needed almost always leads to initialization (<code>int x = 1;</code>), rather than just declaration (<code>int x;</code>). Initializing a variable usually often means you can <code>const</code> it, too.</p>
<p dir="auto">To me, all declarations (i.e. non-initializations) are shifty.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use one line per variable definition; don&#39;t bunch same types together</h4><a id="user-content-use-one-line-per-variable-definition-dont-bunch-same-types-together" aria-label="Permalink: Use one line per variable definition; don&#39;t bunch same types together" href="#use-one-line-per-variable-definition-dont-bunch-same-types-together"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This makes the types easier to change in future, because atomic lines are easier to edit. If you&#39;ll need to change all their types together, you should use your editor&#39;s block editing mode.</p>
<p dir="auto">I think it&#39;s alright to bunch semantically-connected struct members together, though, because struct definitions are much easier to comprehend than active code.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Fine
typedef struct Color {
    char r, g, b;
} Color;"><pre><span>// Fine</span>
<span>typedef</span> <span>struct</span> <span>Color</span> {
    <span>char</span> <span>r</span>, <span>g</span>, <span>b</span>;
} <span>Color</span>;</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Don&#39;t be afraid of short variable names</h4><a id="user-content-dont-be-afraid-of-short-variable-names" aria-label="Permalink: Don&#39;t be afraid of short variable names" href="#dont-be-afraid-of-short-variable-names"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If the scope fits on a screen, and the variable is used in a lot of places, and there would be an obvious letter or two to represent it, try it out and see if it helps readability. It probably will!</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Be consistent in your variable names across functions</h4><a id="user-content-be-consistent-in-your-variable-names-across-functions" aria-label="Permalink: Be consistent in your variable names across functions" href="#be-consistent-in-your-variable-names-across-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Consistency helps your readers understand what&#39;s happening. Using different names for the same values in functions is suspicious, and forces your readers to reason about unimportant things.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use <code>bool</code> from <code>stdbool.h</code> whenever you have a boolean value</h4><a id="user-content-use-bool-from-stdboolh-whenever-you-have-a-boolean-value" aria-label="Permalink: Use bool from stdbool.h whenever you have a boolean value" href="#use-bool-from-stdboolh-whenever-you-have-a-boolean-value"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="int print_steps = 0;             // Bad - is this counting steps?
bool print_steps = false;        // Good - intent is clear"><pre><span>int</span> <span>print_steps</span> <span>=</span> <span>0</span>;             <span>// Bad - is this counting steps?</span>
<span>bool</span> <span>print_steps</span> <span>=</span> false;        <span>// Good - intent is clear</span></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Explicitly compare values; don&#39;t rely on truthiness</h4><a id="user-content-explicitly-compare-values-dont-rely-on-truthiness" aria-label="Permalink: Explicitly compare values; don&#39;t rely on truthiness" href="#explicitly-compare-values-dont-rely-on-truthiness"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Explicit comparisons tell the reader what they&#39;re working with, because it&#39;s not always obvious in C, and it <em>is</em> always important. Are we working with counts or characters or booleans or pointers? The first thing I do when I see a variable being tested for truthiness in C is to hunt down the declaration to find its type. I really wish the programmer had just told me in the comparison.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad - what are these expressions actually testing for (if at all?)
if ( on_fire );
return !character;
something( first( xs ) );
while ( !at_work );

// Good - informative, and eliminates ambiguity
if ( on_fire &gt; 0 );
return character == NULL;
something( first( xs ) != &#39;\0&#39; );
while ( at_work == false );"><pre><span>// Bad - what are these expressions actually testing for (if at all?)</span>
<span>if</span> ( <span>on_fire</span> );
<span>return</span> !<span>character</span>;
<span>something</span>( <span>first</span>( <span>xs</span> ) );
<span>while</span> ( !<span>at_work</span> );

<span>// Good - informative, and eliminates ambiguity</span>
<span>if</span> ( <span>on_fire</span> <span>&gt;</span> <span>0</span> );
<span>return</span> <span>character</span> <span>==</span> <span>NULL</span>;
<span>something</span>( <span>first</span>( <span>xs</span> ) <span>!=</span> <span>&#39;\0&#39;</span> );
<span>while</span> ( <span>at_work</span> <span>==</span> false );</pre></div>
<p dir="auto">I&#39;ll often skip this rule for boolean functions named as a predicate, like <code>is_edible</code> or <code>has_client</code>. It&#39;s still not <em>completely</em> obvious what the conditional is checking for, but I usually consider the visual clutter of a <code>== true</code> or <code>== false</code> to be more of a hassle than a help to readers in this situation. Use your judgement.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Never change state within an expression (e.g. with assignments or <code>++</code>)</h4><a id="user-content-never-change-state-within-an-expression-eg-with-assignments-or-" aria-label="Permalink: Never change state within an expression (e.g. with assignments or ++)" href="#never-change-state-within-an-expression-eg-with-assignments-or-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Readable (imperative) programs flow from top to bottom: not right to left. Unfortunately, this happens way too much in C programming. I think the habit and practice was started by <em>The C Programming Language</em>, and it&#39;s stuck with much of the culture ever since. It&#39;s a really bad habit, and makes it so much harder to follow what your program is doing. Never change state in an expression.</p>
<div dir="auto" data-snippet-clipboard-copy-content="trie_add( *child, ++word );     // Bad
trie_add( *child, word + 1 );   // Good

// Good, if you need to modify `word`
word += 1;
trie_add( *child, word );

// Bad
if ( ( x = calc() ) == 0 );
// Good
x = calc();
if ( x == 0 );

// Fine; technically an assignment within an expression
a = b = c;

while ( --atoms &gt; 0 );          // Bad
while ( atoms -= 1,             // Good
        atoms &gt; 0 );

// Fine; there&#39;s no better way, without repetition
int w;
while ( w = calc_width( shape ),
        !valid_width( w ) ) {
    shape = reshape( shape, w );
}"><pre><span>trie_add</span>( <span>*</span><span>child</span>, <span>++</span><span>word</span> );     <span>// Bad</span>
<span>trie_add</span>( <span>*</span><span>child</span>, <span>word</span> <span>+</span> <span>1</span> );   <span>// Good</span>

<span>// Good, if you need to modify `word`</span>
<span>word</span> <span>+=</span> <span>1</span>;
<span>trie_add</span>( <span>*</span><span>child</span>, <span>word</span> );

<span>// Bad</span>
<span>if</span> ( ( <span>x</span> <span>=</span> <span>calc</span>() ) <span>==</span> <span>0</span> );
<span>// Good</span>
<span>x</span> <span>=</span> <span>calc</span>();
<span>if</span> ( <span>x</span> <span>==</span> <span>0</span> );

<span>// Fine; technically an assignment within an expression</span>
<span>a</span> <span>=</span> <span>b</span> <span>=</span> <span>c</span>;

<span>while</span> ( <span>--</span><span>atoms</span> <span>&gt;</span> <span>0</span> );          <span>// Bad</span>
<span>while</span> ( <span>atoms</span> <span>-=</span> <span>1</span>,             <span>// Good</span>
        <span>atoms</span> <span>&gt;</span> <span>0</span> );

<span>// Fine; there&#39;s no better way, without repetition</span>
<span>int</span> <span>w</span>;
<span>while</span> ( <span>w</span> <span>=</span> <span>calc_width</span>( <span>shape</span> ),
        !<span>valid_width</span>( <span>w</span> ) ) {
    <span>shape</span> <span>=</span> <span>reshape</span>( <span>shape</span>, <span>w</span> );
}</pre></div>
<p dir="auto">Don&#39;t use multiple assignment unless the variables&#39; values are semantically linked. If there are two variable assignments near each other that coincidentally have the same value, don&#39;t throw them into a multiple assignment just to save a line.</p>
<p dir="auto">Use the comma operator, as above, judiciously. Do without it if you can:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad
for ( int i = 0, limit = get_limit( m ); i &lt; limit; i += 1 ) {
    ...
}

// Better
int const limit = get_limit( x );
for ( int i = 0; i &lt; limit; i += 1 ) {
    ...
}"><pre><span>// Bad</span>
<span>for</span> ( <span>int</span> <span>i</span> <span>=</span> <span>0</span>, <span>limit</span> <span>=</span> <span>get_limit</span>( <span>m</span> ); <span>i</span> <span>&lt;</span> <span>limit</span>; <span>i</span> <span>+=</span> <span>1</span> ) {
    ...
}

<span>// Better</span>
<span>int</span> <span>const</span> <span>limit</span> <span>=</span> <span>get_limit</span>( <span>x</span> );
<span>for</span> ( <span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>limit</span>; <span>i</span> <span>+=</span> <span>1</span> ) {
    ...
}</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Avoid non-pure or non-trivial function calls in expressions</h4><a id="user-content-avoid-non-pure-or-non-trivial-function-calls-in-expressions" aria-label="Permalink: Avoid non-pure or non-trivial function calls in expressions" href="#avoid-non-pure-or-non-trivial-function-calls-in-expressions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Assign function calls to a variable to describe what it is, even if the variable is as simple as an <code>int result</code>. This avoids surprising your readers with state changes from non-pure functions hidden inside conditional contexts. To me, it&#39;s really unnatural to think about the expression inside an <code>if ( ... )</code> changing things on the outside world. It&#39;s much clear to assign the result of that state change to a variable, and then check that value.</p>
<p dir="auto">Even if you think it&#39;s obvious, and it will save you a line - it&#39;s not worth the potential for a slip-up. Stick to this rule, and don&#39;t think about it.</p>
<p dir="auto">If the function name is a predicate, like <code>is_adult</code> or <code>in_tree</code>, and will read naturally in a conditional context, then I think it&#39;s alright to skip assigning its result. It&#39;s also probably fine to join these kind of functions in a boolean expression if you need to, but use your judgement. Complex boolean expressions should often be extracted to a function.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Good
int r = listen( fd, backlog );
if ( r == -1 ) {
    perror( &#34;listen&#34; );
    return 1;
}

// Good
if ( is_tasty( banana ) ) {
    eat( banana );
}"><pre><span>// Good</span>
<span>int</span> <span>r</span> <span>=</span> <span>listen</span>( <span>fd</span>, <span>backlog</span> );
<span>if</span> ( <span>r</span> <span>==</span> <span>-1</span> ) {
    <span>perror</span>( <span>&#34;listen&#34;</span> );
    <span>return</span> <span>1</span>;
}

<span>// Good</span>
<span>if</span> ( <span>is_tasty</span>( <span>banana</span> ) ) {
    <span>eat</span>( <span>banana</span> );
}</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Always use brackets, even for single-statement blocks</h4><a id="user-content-always-use-brackets-even-for-single-statement-blocks" aria-label="Permalink: Always use brackets, even for single-statement blocks" href="#always-use-brackets-even-for-single-statement-blocks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Always use brackets, because it&#39;s safer, easier to change, and easier to read because it&#39;s more consistent. For the same reasons, don&#39;t put a single-line statement on the same line as the condition.</p>
<p dir="auto">What follows is actual code from <em>The C Programming Language</em>. Don&#39;t do this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="while (--argc &gt; 0 &amp;&amp; (*++argv)[0] == &#39;-&#39;)
    while (c = *++argv[0])
        switch (c) {
            ...
        }
if (argc != 1)
    printf(&#34;Usage: find -x -n pattern\n&#34;);
else
    while (getline(line, MAXLINE) &gt; 0) {
        ...
    }"><pre><span>while</span> (<span>--</span><span>argc</span> <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> (<span>*</span><span>++</span><span>argv</span>)[<span>0</span>] <span>==</span> <span>&#39;-&#39;</span>)
    <span>while</span> (<span>c</span> <span>=</span> <span>*</span><span>++</span><span>argv</span>[<span>0</span>])
        <span>switch</span> (<span>c</span>) {
            ...
        }
<span>if</span> (<span>argc</span> <span>!=</span> <span>1</span>)
    <span>printf</span>(<span>&#34;Usage: find -x -n pattern\n&#34;</span>);
<span>else</span>
    <span>while</span> (<span>getline</span>(<span>line</span>, <span>MAXLINE</span>) <span>&gt;</span> <span>0</span>) {
        ...
    }</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Avoid unsigned types because the integer conversion rules are complicated</h4><a id="user-content-avoid-unsigned-types-because-the-integer-conversion-rules-are-complicated" aria-label="Permalink: Avoid unsigned types because the integer conversion rules are complicated" href="#avoid-unsigned-types-because-the-integer-conversion-rules-are-complicated"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules" rel="nofollow">CERT attempts to explain the integer conversion rules</a>, saying:</p>
<blockquote>
<p dir="auto">Misunderstanding integer conversion rules can lead to errors, which in turn can lead to exploitable vulnerabilities. Severity: medium, Likelihood: probable.</p>
</blockquote>
<p dir="auto"><em>Expert C Programming</em> (a great book that explores the ANSI standard) also explains this in its first chapter. The takeaway is that you shouldn&#39;t declare <code>unsigned</code> variables just because they shouldn&#39;t be negative. If you want a larger maximum value, use a <code>long</code> or <code>long long</code> (the next size up).</p>
<p dir="auto">If your function will fail with a negative number, it will probably also fail with a large number - which is what it will get if passed a negative number. If your function will fail with a negative number, just assert that it&#39;s positive. Remember, lots of dynamic languages make do with a single integer type that can be either sign.</p>
<p dir="auto">Unsigned values offer no type safety; even with <code>-Wall</code> and <code>-Wextra</code>, GCC doesn&#39;t bat an eyelid at <code>unsigned int x = -1;</code>.</p>
<p dir="auto"><em>Expert C Programming</em> also provides an example for why you should cast all macros that will evaluate to an unsigned value.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define NELEM( xs ) ( ( sizeof xs ) / ( sizeof xs[0] ) )
int const xs[] = { 1, 2, 3, 4, 5, 6 };

int main( void )
{
    int const d = -1;
    if ( d &lt; NELEM( xs ) - 1 ) {
        return xs[ d + 1 ];
    }
    return 0;
}"><pre><span>#define</span> <span>NELEM</span>( <span>xs</span> ) ( ( sizeof xs ) / ( sizeof xs[0] ) )
<span>int</span> <span>const</span> <span>xs</span>[] <span>=</span> { <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span> };

<span>int</span> <span>main</span>( <span>void</span> )
{
    <span>int</span> <span>const</span> <span>d</span> <span>=</span> <span>-1</span>;
    <span>if</span> ( <span>d</span> <span>&lt;</span> <span>NELEM</span>( <span>xs</span> ) <span>-</span> <span>1</span> ) {
        <span>return</span> <span>xs</span>[ <span>d</span> <span>+</span> <span>1</span> ];
    }
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">The <code>if</code> branch won&#39;t be executed, because <code>NELEM</code> will evaluate to an <code>unsigned int</code> (via <code>sizeof</code>). So, <code>d</code> will be promoted to an <code>unsigned int</code>. <code>-1</code> in <a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="nofollow">two&#39;s complement</a> represents the largest possible unsigned value (bit-wise), so the expression will be false, and the program will return <code>0</code>. The solution in this case would be to cast the result of <code>NELEM</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define NELEM( xs ) ( long )( ( sizeof xs ) / ( sizeof xs[ 0 ] ) )"><pre><span>#define</span> <span>NELEM</span>( <span>xs</span> ) ( long )( ( sizeof xs ) / ( sizeof xs[ 0 ] ) )</pre></div>
<p dir="auto">You will need to use unsigned values to provide <a href="http://stackoverflow.com/questions/4009885/arithmetic-bit-shift-on-a-signed-integer" rel="nofollow">well-defined bit operations</a> and modular arithmetic overflow. But, try to keep those values contained, and don&#39;t let them interact with signed values.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use <code>+= 1</code> and <code>-= 1</code> over <code>++</code> and <code>--</code></h4><a id="user-content-use--1-and---1-over--and---" aria-label="Permalink: Use += 1 and -= 1 over ++ and --" href="#use--1-and---1-over--and---"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Actually, don&#39;t use either form if you can help it. Changing state should always be avoided (within reason). But, when you have to, <code>+=</code> and <code>-=</code> are obvious, simpler and less cryptic than <code>++</code> and <code>--</code>, and useful in other contexts and with other values. Also, there are no tricks about the evaluation of <code>+=</code> and <code>-=</code> and they don&#39;t have weird twin operators to provide alternative evaluations. Python does without <code>++</code> and <code>--</code> operators, and Douglas Crockford excluded them from the Good Parts of JavaScript, because we don&#39;t need them. Sticking to this rule also encourages you to avoid changing state within an expression.</p>

<div dir="auto" data-snippet-clipboard-copy-content="int x = a * b + c / d;          // Bad
int x = ( a * b ) + ( c / d );  // Good

&amp;sockaddr-&gt;sin_addr;            // Bad
&amp;( sockaddr-&gt;sin_addr );        // Good"><pre><span>int</span> <span>x</span> <span>=</span> <span>a</span> <span>*</span> <span>b</span> <span>+</span> <span>c</span> / <span>d</span>;          <span>// Bad</span>
<span>int</span> <span>x</span> <span>=</span> ( <span>a</span> <span>*</span> <span>b</span> ) <span>+</span> ( <span>c</span> / <span>d</span> );  <span>// Good</span>

<span>&amp;</span><span>sockaddr</span><span>-&gt;</span><span>sin_addr</span>;            <span>// Bad</span>
<span>&amp;</span>( <span>sockaddr</span><span>-&gt;</span><span>sin_addr</span> );        <span>// Good</span></pre></div>
<p dir="auto">You can and should make exceptions for commonly-seen combinations of operations. For example, skipping the operators when combining the equality and boolean operators is fine, because readers are probably used to that, and are confident of the result.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Fine
return hungry == true
    || ( legs != NULL &amp;&amp; fridge.empty == false );"><pre><span>// Fine</span>
<span>return</span> <span>hungry</span> <span>==</span> true
    <span>||</span> ( <span>legs</span> <span>!=</span> <span>NULL</span> <span>&amp;&amp;</span> <span>fridge</span>.<span>empty</span> <span>==</span> false );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Don&#39;t use <code>switch</code>, and avoid complicated conditionals</h4><a id="user-content-dont-use-switch-and-avoid-complicated-conditionals" aria-label="Permalink: Don&#39;t use switch, and avoid complicated conditionals" href="#dont-use-switch-and-avoid-complicated-conditionals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>switch</code> fall-through mechanism is error-prone, and you almost never want the cases to fall through anyway, so the vast majority of <code>switch</code>es are longer than the <code>if</code> equivalent. Worse, a missing <code>break</code> will still compile: this tripped me up all the time when I used <code>switch</code>. Also, <code>case</code> values have to be an integral constant expression, so they can&#39;t match against another variable. This discourages extractions of logic to functions. Furthermore, any statement inside a <code>switch</code> can be labelled and jumped to, which fosters highly-obscure bugs if, for example, you mistype <code>defau1t</code>.</p>
<p dir="auto">If you need to map different constant values to behavior, like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="switch ( x ) {
case A:
    do_something_for_a( x, y, z );
    break;
case B:
    do_something_for_b( x, y, z ):
    break;
default:
    error( x, y, z );
    break;
}
// These functions might not be explicit functions (i.e. they might
// just be a series of statements using some of those variables)."><pre><span>switch</span> ( <span>x</span> ) {
<span>case</span> <span>A</span>:
    <span>do_something_for_a</span>( <span>x</span>, <span>y</span>, <span>z</span> );
    <span>break</span>;
<span>case</span> <span>B</span>:
    <span>do_something_for_b</span>( <span>x</span>, <span>y</span>, <span>z</span> ):
    <span>break</span>;
<span>default</span>:
    <span>error</span>( <span>x</span>, <span>y</span>, <span>z</span> );
    <span>break</span>;
}
<span>// These functions might not be explicit functions (i.e. they might</span>
<span>// just be a series of statements using some of those variables).</span></pre></div>
<p dir="auto">A more explicit, testable and reusable approach is to define a function that uses ternary expressions to return a function pointer of the right type:</p>
<div dir="auto" data-snippet-clipboard-copy-content="action_fn get_x_action( x ) {
    return ( x == A ) ? do_something_for_a
         : ( x == B ) ? do_something_for_b
         : error;
}

action_fn action = get_x_action( x );
action( x, y, z );

// or just:
get_x_action( x )( x, y, z );

// `action` is a terrible name and is only used as an example. You
// should try to think of a more-informative name for your code."><pre><span>action_fn</span> <span>get_x_action</span>( <span>x</span> ) {
    <span>return</span> ( <span>x</span> <span>==</span> <span>A</span> ) ? <span>do_something_for_a</span>
         : ( <span>x</span> <span>==</span> <span>B</span> ) ? <span>do_something_for_b</span>
         : <span>error</span>;
}

<span>action_fn</span> <span>action</span> <span>=</span> <span>get_x_action</span>( <span>x</span> );
<span>action</span>( <span>x</span>, <span>y</span>, <span>z</span> );

<span>// or just:</span>
<span>get_x_action</span>( <span>x</span> )( <span>x</span>, <span>y</span>, <span>z</span> );

<span>// `action` is a terrible name and is only used as an example. You</span>
<span>// should try to think of a more-informative name for your code.</span></pre></div>
<p dir="auto">You should do a similar thing if you need to map between two sets of uncorrelated constant values, like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad
switch ( x ) {
    case A: return X;
    case B: return Y;
    case C: return Z;
    default: return ERR;
}

// Good
return ( x == A ) ? X
     : ( x == B ) ? Y
     : ( x == C ) ? Z
     : ERR;"><pre><span>// Bad</span>
<span>switch</span> ( <span>x</span> ) {
    <span>case</span> <span>A</span>: <span>return</span> <span>X</span>;
    <span>case</span> <span>B</span>: <span>return</span> <span>Y</span>;
    <span>case</span> <span>C</span>: <span>return</span> <span>Z</span>;
    <span>default</span>: <span>return</span> <span>ERR</span>;
}

<span>// Good</span>
<span>return</span> ( <span>x</span> <span>==</span> <span>A</span> ) ? <span>X</span>
     : ( <span>x</span> <span>==</span> <span>B</span> ) ? <span>Y</span>
     : ( <span>x</span> <span>==</span> <span>C</span> ) ? <span>Z</span>
     : <span>ERR</span>;</pre></div>
<p dir="auto">Don&#39;t use a <code>switch</code> where you can just use a boolean expression:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad
switch ( x ) {
    case A: case B: case C:
        return true;
    default:
        return false;
}

// Good
return x == A || x == B || x == C;

// Or, if the names are longer, this usually reads better:
return t == JSON_TYPE_null
    || t == JSON_TYPE_boolean
    || t == JSON_TYPE_number;"><pre><span>// Bad</span>
<span>switch</span> ( <span>x</span> ) {
    <span>case</span> <span>A</span>: <span>case</span> <span>B</span>: <span>case</span> <span>C</span>:
        <span>return</span> true;
    <span>default</span>:
        <span>return</span> false;
}

<span>// Good</span>
<span>return</span> <span>x</span> <span>==</span> <span>A</span> <span>||</span> <span>x</span> <span>==</span> <span>B</span> <span>||</span> <span>x</span> <span>==</span> <span>C</span>;

<span>// Or, if the names are longer, this usually reads better:</span>
<span>return</span> <span>t</span> <span>==</span> <span>JSON_TYPE_null</span>
    <span>||</span> <span>t</span> <span>==</span> <span>JSON_TYPE_boolean</span>
    <span>||</span> <span>t</span> <span>==</span> <span>JSON_TYPE_number</span>;</pre></div>
<p dir="auto">If you need the fall-through behavior of <code>switch</code>, like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="switch ( x ) {
    case A:
        // A stuff, fall through to B
    case B:
        // B stuff
        break;
    default:
        // default stuff
}"><pre><span>switch</span> ( <span>x</span> ) {
    <span>case</span> <span>A</span>:
        <span>// A stuff, fall through to B</span>
    <span>case</span> <span>B</span>:
        <span>// B stuff</span>
        <span>break</span>;
    <span>default</span>:
        <span>// default stuff</span>
}</pre></div>
<p dir="auto">The equivalent <code>if</code> is much more readable and it&#39;s obvious what&#39;s going to happen and why. The &#34;B stuff&#34; actually applies when <code>x == A</code> too, and this is explicitly declared when you use an <code>if</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="if ( x == A ) {
    // A stuff
}

if ( x == A || x == B ) {
    // B stuff
} else {
    // default stuff
}"><pre><span>if</span> ( <span>x</span> <span>==</span> <span>A</span> ) {
    <span>// A stuff</span>
}

<span>if</span> ( <span>x</span> <span>==</span> <span>A</span> <span>||</span> <span>x</span> <span>==</span> <span>B</span> ) {
    <span>// B stuff</span>
} <span>else</span> {
    <span>// default stuff</span>
}</pre></div>
<p dir="auto">You should only need to use <code>switch</code> for performance tuning (once you&#39;ve done benchmarks to identify hotspots!). Otherwise, there&#39;s always a safer, shorter, more-testable, and reusable alternative.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Separate functions and struct definitions with two lines</h4><a id="user-content-separate-functions-and-struct-definitions-with-two-lines" aria-label="Permalink: Separate functions and struct definitions with two lines" href="#separate-functions-and-struct-definitions-with-two-lines"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you limit yourself to a maximum of one blank line within functions, this rule provides clear visual separation of global elements. This is a habit I learned from Python&#39;s PEP8 style guide.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Minimize the scope of variables</h4><a id="user-content-minimize-the-scope-of-variables" aria-label="Permalink: Minimize the scope of variables" href="#minimize-the-scope-of-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If a few variables are only used in a contiguous sequence of lines, and only a single value is used after that sequence, then those first lines are a great candidate for extracting to a function.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Good: addr was only used in the first part of handle_request
int accept_request( int const listenfd )
{
    struct sockaddr addr;
    return accept( listenfd, &amp;addr, &amp;( socklen_t ){ sizeof addr } );
}

int handle_request( int const listenfd )
{
    int const reqfd = accept_request( listenfd );
    // ... stuff not involving addr, but involving reqfd
}"><pre><span>// Good: addr was only used in the first part of handle_request</span>
<span>int</span> <span>accept_request</span>( <span>int</span> <span>const</span> <span>listenfd</span> )
{
    <span>struct</span> <span>sockaddr</span> <span>addr</span>;
    <span>return</span> <span>accept</span>( <span>listenfd</span>, <span>&amp;</span><span>addr</span>, <span>&amp;</span>( <span>socklen_t</span> ){ <span>sizeof</span> <span>addr</span> } );
}

<span>int</span> <span>handle_request</span>( <span>int</span> <span>const</span> <span>listenfd</span> )
{
    <span>int</span> <span>const</span> <span>reqfd</span> <span>=</span> <span>accept_request</span>( <span>listenfd</span> );
    <span>// ... stuff not involving addr, but involving reqfd</span>
}</pre></div>
<p dir="auto">If the body of <code>accept_request</code> were left in <code>handle_request</code>, then the <code>addr</code> variable will be in the scope for the remainder of the <code>handle_request</code> function even though it&#39;s only used for getting the <code>reqfd</code>. This kind of thing adds to the cognitive load of understanding a function, and should be fixed wherever possible.</p>
<p dir="auto">Another tactic to limit the exposure of variables is to break apart complex expressions into blocks, like so:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Rather than:
bool trie_has( Trie const trie, char const * const string )
{
    Trie const * const child = Trie_child( trie, string[ 0 ] );
    return string[ 0 ] == &#39;\0&#39;
           || ( child != NULL
                &amp;&amp; Trie_has( *child, string + 1 ) );
}

// child is only used for the second part of the conditional, so we
// can limit its exposure like so:
bool trie_has( Trie const trie, char const * const string )
{
    if ( string[ 0 ] == &#39;\0&#39; ) {
        return true;
    } else {
        Trie const * const child = Trie_child( trie, string[ 0 ] );
        return child != NULL
            &amp;&amp; Trie_has( *child, string + 1 );
    }
}"><pre><span>// Rather than:</span>
<span>bool</span> <span>trie_has</span>( <span>Trie</span> <span>const</span> <span>trie</span>, <span>char</span> <span>const</span> <span>*</span> <span>const</span> <span>string</span> )
{
    <span>Trie</span> <span>const</span> <span>*</span> <span>const</span> <span>child</span> <span>=</span> <span>Trie_child</span>( <span>trie</span>, <span>string</span>[ <span>0</span> ] );
    <span>return</span> <span>string</span>[ <span>0</span> ] <span>==</span> <span>&#39;\0&#39;</span>
           <span>||</span> ( <span>child</span> <span>!=</span> <span>NULL</span>
                <span>&amp;&amp;</span> <span>Trie_has</span>( <span>*</span><span>child</span>, <span>string</span> <span>+</span> <span>1</span> ) );
}

<span>// child is only used for the second part of the conditional, so we</span>
<span>// can limit its exposure like so:</span>
<span>bool</span> <span>trie_has</span>( <span>Trie</span> <span>const</span> <span>trie</span>, <span>char</span> <span>const</span> <span>*</span> <span>const</span> <span>string</span> )
{
    <span>if</span> ( <span>string</span>[ <span>0</span> ] <span>==</span> <span>&#39;\0&#39;</span> ) {
        <span>return</span> true;
    } <span>else</span> {
        <span>Trie</span> <span>const</span> <span>*</span> <span>const</span> <span>child</span> <span>=</span> <span>Trie_child</span>( <span>trie</span>, <span>string</span>[ <span>0</span> ] );
        <span>return</span> <span>child</span> <span>!=</span> <span>NULL</span>
            <span>&amp;&amp;</span> <span>Trie_has</span>( <span>*</span><span>child</span>, <span>string</span> <span>+</span> <span>1</span> );
    }
}</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Simple constant expressions can be easier to read than variables</h4><a id="user-content-simple-constant-expressions-can-be-easier-to-read-than-variables" aria-label="Permalink: Simple constant expressions can be easier to read than variables" href="#simple-constant-expressions-can-be-easier-to-read-than-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">It can often help the readability of your code if you replace variables that are only assigned to constant expressions, with those expressions.</p>
<p dir="auto">Consider the <code>trie_has</code> example above - the <code>string[ 0 ]</code> expression is repeated twice. It would be harder to read and follow if we inserted an extra line to define a <code>char</code> variable. It&#39;s just another thing that the readers would have to keep in mind. Many programmers of other languages wouldn&#39;t think twice about repeating an array access.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Prefer compound literals to superfluous variables</h4><a id="user-content-prefer-compound-literals-to-superfluous-variables" aria-label="Permalink: Prefer compound literals to superfluous variables" href="#prefer-compound-literals-to-superfluous-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This is beneficial for the same reason as minimizing the scope of variables.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad, if `sa` is never used again.
struct sigaction sa = {
    .sa_handler = sigchld_handler,
    .sa_flags = SA_RESTART
};
sigaction( SIGCHLD, &amp;sa, NULL );

// Good
sigaction( SIGCHLD, &amp;( struct sigaction ){
    .sa_handler = sigchld_handler,
    .sa_flags = SA_RESTART
}, NULL );

// Bad
int v = 1;
setsockopt( fd, SOL_SOCKET, SO_REUSEADDR, &amp;v, sizeof v );

// Good
setsockopt( fd, SOL_SOCKET, SO_REUSEADDR, &amp;( int ){ 1 }, sizeof int );"><pre><span>// Bad, if `sa` is never used again.</span>
<span>struct</span> <span>sigaction</span> <span>sa</span> <span>=</span> {
    .<span>sa_handler</span> <span>=</span> <span>sigchld_handler</span>,
    .<span>sa_flags</span> <span>=</span> <span>SA_RESTART</span>
};
<span>sigaction</span>( <span>SIGCHLD</span>, <span>&amp;</span><span>sa</span>, <span>NULL</span> );

<span>// Good</span>
<span>sigaction</span>( <span>SIGCHLD</span>, <span>&amp;</span>( <span>struct</span> <span>sigaction</span> ){
    .<span>sa_handler</span> <span>=</span> <span>sigchld_handler</span>,
    .<span>sa_flags</span> <span>=</span> <span>SA_RESTART</span>
}, <span>NULL</span> );

<span>// Bad</span>
<span>int</span> <span>v</span> <span>=</span> <span>1</span>;
<span>setsockopt</span>( <span>fd</span>, <span>SOL_SOCKET</span>, <span>SO_REUSEADDR</span>, <span>&amp;</span><span>v</span>, <span>sizeof</span> <span>v</span> );

<span>// Good</span>
<span>setsockopt</span>( <span>fd</span>, <span>SOL_SOCKET</span>, <span>SO_REUSEADDR</span>, <span>&amp;</span>( <span>int</span> ){ <span>1</span> }, <span>sizeof</span> <span>int</span> );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Never use or provide macros that wrap control structures like <code>for</code></h4><a id="user-content-never-use-or-provide-macros-that-wrap-control-structures-like-for" aria-label="Permalink: Never use or provide macros that wrap control structures like for" href="#never-use-or-provide-macros-that-wrap-control-structures-like-for"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Macros that loop over the elements of a data structure are extremely confusing, because they&#39;re extra-syntactic and readers can&#39;t know the control flow without looking up the definition.</p>
<p dir="auto">To understand your program, it&#39;s crucial that your readers can understand its control flow.</p>
<p dir="auto">Don&#39;t provide control-macros even as an option. They&#39;re universally harmful, so don&#39;t enable it. Users can define their own if they really want to.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad
#define TRIE_EACH( TRIE, INDEX ) \
    for ( int INDEX = 0; INDEX &lt; ( TRIE ).alphabet.size; INDEX += 1 )

// Not at all obvious what&#39;s actually going to happen here.
TRIE_EACH( trie, i ) {
    Trie * const child = trie.children[ i ];
    ...
}"><pre><span>// Bad</span>
<span>#define</span> <span>TRIE_EACH</span>( <span>TRIE</span>, <span>INDEX</span> ) \
    for ( int INDEX = 0; INDEX &lt; ( TRIE ).alphabet.size; INDEX += 1 )

<span>// Not at all obvious what&#39;s actually going to happen here.</span>
<span>TRIE_EACH</span>( <span>trie</span>, <span>i</span> ) {
    <span>Trie</span> <span>*</span> <span>const</span> <span>child</span> <span>=</span> <span>trie</span>.<span>children</span>[ <span>i</span> ];
    ...
}</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Only upper-case a macro if will act differently than a function call</h4><a id="user-content-only-upper-case-a-macro-if-will-act-differently-than-a-function-call" aria-label="Permalink: Only upper-case a macro if will act differently than a function call" href="#only-upper-case-a-macro-if-will-act-differently-than-a-function-call"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">By &#34;act differently&#34;, I mean if things will break when users wouldn&#39;t expect them to. If a macro just looks different (e.g. the named arguments technique), then I don&#39;t consider that justification for an upper-case name. A macro should have an upper-case name if it:</p>
<ul dir="auto">
<li>repeats its arguments in its body, because this will break for non-pure expressions. Many compilers provide <a href="http://stackoverflow.com/questions/6440021/compiler-support-of-gnu-statement-expression" rel="nofollow">statement expressions</a> to prevent this, but it&#39;s non-standard. If you do use statement expressions, then you don&#39;t need to upper-case your macro name, because it&#39;s not relevant to your users.</li>
<li>is wrapped in blocks or a control structure, because it can&#39;t be used as an expression then.</li>
<li>modifies the surrounding context, e.g., with a <code>return</code> or <code>goto</code>.</li>
<li>takes an array literal as a named argument. (<a href="http://stackoverflow.com/questions/5503362/passing-array-literal-as-macro-argument" rel="nofollow">why</a>)</li>
</ul>
<div dir="auto"><h4 tabindex="-1" dir="auto">If a macro is specific to a function, <code>#define</code> it in the body</h4><a id="user-content-if-a-macro-is-specific-to-a-function-define-it-in-the-body" aria-label="Permalink: If a macro is specific to a function, #define it in the body" href="#if-a-macro-is-specific-to-a-function-define-it-in-the-body"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For the same reasons why we should always minimize the scope of our variables, if it makes sense to limit the scope of a macro, we should.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Initialize strings as arrays, and use <code>sizeof</code> for byte size</h4><a id="user-content-initialize-strings-as-arrays-and-use-sizeof-for-byte-size" aria-label="Permalink: Initialize strings as arrays, and use sizeof for byte size" href="#initialize-strings-as-arrays-and-use-sizeof-for-byte-size"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Always initialize your string literals as arrays, because it lets you get the byte size with just <code>sizeof str</code>. If you initialize them as pointers, you have to get the byte size with <code>strlen( str ) + 1</code> - I know I&#39;ve been bitten more than once by forgetting the <code>+ 1</code> there.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Good
char const message[] = &#34;always use arrays for strings!&#34;;
write( output, message, sizeof message );"><pre><span>// Good</span>
<span>char</span> <span>const</span> <span>message</span>[] <span>=</span> <span>&#34;always use arrays for strings!&#34;</span>;
<span>write</span>( <span>output</span>, <span>message</span>, <span>sizeof</span> <span>message</span> );</pre></div>
<p dir="auto">Also, pointer initializations are less safe than array initializations, <em>unless</em> you compile with <code>-Wwrite-strings</code> to ensure string literals are initialized with the type <code>char const *</code>. Unfortunately, <code>-Wwrite-strings</code> isn&#39;t included in <code>-Wall</code> or <code>-Wextra</code>: you have to explicitly enable it.  Without <code>-Wwrite-strings</code>, you can assign string literals to a <code>char *</code>. But your program will seg-fault when you re-assign the elements of that pointer.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Without -Wwrite-strings, this will compile without warnings, but
// it will prompt a segmentation fault at the second line.
char * xs = &#34;hello&#34;;
xs[ 0 ] = &#39;c&#39;;

// This program will compile and execute fine.
char xs[] = &#34;hello&#34;;
xs[ 0 ] = &#39;c&#39;;"><pre><span>// Without -Wwrite-strings, this will compile without warnings, but</span>
<span>// it will prompt a segmentation fault at the second line.</span>
<span>char</span> <span>*</span> <span>xs</span> <span>=</span> <span>&#34;hello&#34;</span>;
<span>xs</span>[ <span>0</span> ] <span>=</span> <span>&#39;c&#39;</span>;

<span>// This program will compile and execute fine.</span>
<span>char</span> <span>xs</span>[] <span>=</span> <span>&#34;hello&#34;</span>;
<span>xs</span>[ <span>0</span> ] <span>=</span> <span>&#39;c&#39;</span>;</pre></div>
<p dir="auto">The benefit of initializing string literals as pointers is that those pointers will point to read-only memory, potentially allowing some optimizations. Initializing string literals as arrays essentially creates a mutable string is only &#34;artificially&#34; protected against modifications with <code>const</code> - but this can be defeated with a cast.</p>
<p dir="auto">Again, I advise against prematurely optimizing. Until you&#39;ve finished development and have done benchmarks, performance should be your lowest priority. I haven&#39;t seen any tests on string literal definitions, but I&#39;d be very surprised to see any notable speed improvements by defining string literals as pointers.</p>
<p dir="auto">As mentioned in the rule on <code>const</code>ing everything: never ever cast away a <code>const</code>. Remove the <code>const</code> instead. Don&#39;t worry about &#34;artificial&#34; protections. I know I&#39;d much prefer my constant values to be protected by explicit, syntactic constructs that will warn when compiling, rather than implicit, obscure rules that will seg-fault when violated.</p>
<p dir="auto">Finally, sticking to array initializations saves you and your readers the conceptual overhead of switching between pointer initializations and array initializations, depending on if you need mutability or not.</p>
<p dir="auto">Just always initialize string literals as arrays, and keep it simple.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Where possible, use <code>sizeof</code> on the variable; not the type</h4><a id="user-content-where-possible-use-sizeof-on-the-variable-not-the-type" aria-label="Permalink: Where possible, use sizeof on the variable; not the type" href="#where-possible-use-sizeof-on-the-variable-not-the-type"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Then, if you change the type of the variable later, you only have to change it once. You&#39;ll always get the correct size.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Good
int * a = malloc( n * ( sizeof *a ) );"><pre><span>// Good</span>
<span>int</span> <span>*</span> <span>a</span> <span>=</span> <span>malloc</span>( <span>n</span> <span>*</span> ( <span>sizeof</span> <span>*</span><span>a</span> ) );</pre></div>
<p dir="auto">You can&#39;t do this with compound literals, though. I think it&#39;s a worth-while trade-off to remove a variable that&#39;s only used once.</p>
<div dir="auto" data-snippet-clipboard-copy-content="setsockopt( fd, SOL_SOCKET, SO_REUSEADDR, &amp;( int ){ 1 }, ( sizeof int ) );"><pre><span>setsockopt</span>( <span>fd</span>, <span>SOL_SOCKET</span>, <span>SO_REUSEADDR</span>, <span>&amp;</span>( <span>int</span> ){ <span>1</span> }, ( <span>sizeof</span> <span>int</span> ) );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Never use array syntax for function arguments definitions</h4><a id="user-content-never-use-array-syntax-for-function-arguments-definitions" aria-label="Permalink: Never use array syntax for function arguments definitions" href="#never-use-array-syntax-for-function-arguments-definitions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="http://c-faq.com/aryptr/aryptrequiv.html" rel="nofollow">Arrays become pointers in most expressions</a>, including <a href="http://c-faq.com/aryptr/aryptrparam.html" rel="nofollow">when passed as arguments to functions</a>. Functions can never receive an array as a argument: <a href="http://c-faq.com/aryptr/aryptr2.html" rel="nofollow">only a pointer to the array</a>. <code>sizeof</code> won&#39;t work like an array argument declaration would suggest: it would return the size of the pointer, not the array pointed to.</p>
<p dir="auto"><a href="http://hamberg.no/erlend/posts/2013-02-18-static-array-indices.html" rel="nofollow">Static array indices in function arguments are nice</a>, but only protect against very trivial situations, like when given a literal <code>NULL</code>. Also, GCC doesn&#39;t warn about their violation <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=50584" rel="nofollow">yet</a>, only Clang. I don&#39;t consider the confusing, non-obvious syntax to be worth the small compilation check.</p>
<p dir="auto">Yeah, <code>[]</code> hints that the argument will be treated as an array, but so does a plural name like <code>requests</code>, so do that instead.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Always prefer array indexing over pointer arithmetic</h4><a id="user-content-always-prefer-array-indexing-over-pointer-arithmetic" aria-label="Permalink: Always prefer array indexing over pointer arithmetic" href="#always-prefer-array-indexing-over-pointer-arithmetic"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you&#39;re working with an array of things, treat them as an array. Pointer arithmetic is confusing and bug-prone. Sticking to array indexing often lets you keep the important variables constant, and only the index variables non-constant.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad
for ( ; *str != &#39;\0&#39;; str += 1 );

// Good
for ( int i = 0; str[ i ] != &#39;\0&#39;; i += 1 );"><pre><span>// Bad</span>
<span>for</span> ( ; <span>*</span><span>str</span> <span>!=</span> <span>&#39;\0&#39;</span>; <span>str</span> <span>+=</span> <span>1</span> );

<span>// Good</span>
<span>for</span> ( <span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>str</span>[ <span>i</span> ] <span>!=</span> <span>&#39;\0&#39;</span>; <span>i</span> <span>+=</span> <span>1</span> );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Document your struct invariants, and provide invariant checkers</h4><a id="user-content-document-your-struct-invariants-and-provide-invariant-checkers" aria-label="Permalink: Document your struct invariants, and provide invariant checkers" href="#document-your-struct-invariants-and-provide-invariant-checkers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<blockquote>
<p dir="auto">An <strong>invariant</strong> is a condition that can be relied upon to be true during execution of a program.</p>
</blockquote>
<p dir="auto">For any function that takes a struct (or a pointer to a struct), all invariants of that struct should be true before and after the execution of the function. Invariants make it the caller&#39;s responsibility to provide valid data, and the function&#39;s responsibility to return valid data. Invariants save those functions from having to repeat assertions of those conditions, or worse, not even checking and working with invalid data.</p>
<p dir="auto">Provide an &#34;invariants&#34; comment section at the end of your struct definition, and list all the invariants you can think of. Also, implement <code>is_valid</code> and <code>assert_valid</code> functions for users to check those assertions on values of the structs they create on their own. These functions are crucial to being able to trust that the invariants hold for values of that struct. Without them, how will the users know?</p>
<p dir="auto"><a href="https://github.com/mcinglis/trie.c/blob/master/alphabet.h#L10">Here&#39;s an example</a> of a struct invariant.</p>
<p dir="auto">My university faculty is <a href="http://www.itee.uq.edu.au/sse/projects" rel="nofollow">pretty big</a> on software correctness. It certainly rubbed off on me.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use <code>assert</code> everywhere your program would fail otherwise</h4><a id="user-content-use-assert-everywhere-your-program-would-fail-otherwise" aria-label="Permalink: Use assert everywhere your program would fail otherwise" href="#use-assert-everywhere-your-program-would-fail-otherwise"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Write assertions to meaningfully crash your program before it does something stupid, like deleting data, or to prevent a security vulnerability, or just to prevent a segmentation fault. Good software fails fast.</p>
<p dir="auto">If a function is given a pointer it will dereference, assert that it&#39;s not null. If it&#39;s given an array index, assert that it&#39;s within bounds. Assert for any consistency that you need between arguments.</p>
<p dir="auto">That said, never depend on assertions for correctness. Your program should still work correctly when the assertion lines are removed.</p>
<p dir="auto">Don&#39;t mistake assertions for error-reporting. Assert things that you won&#39;t bother to check otherwise. If user input (not code) can invalidate an assertion, that&#39;s a bug. You should be filtering it before-hand, and reporting the errors in a readable fashion for your users.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Repeat <code>assert</code> calls; don&#39;t <code>&amp;&amp;</code> them together</h4><a id="user-content-repeat-assert-calls-dont--them-together" aria-label="Permalink: Repeat assert calls; don&#39;t &amp;&amp; them together" href="#repeat-assert-calls-dont--them-together"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Repeating your <code>assert</code> calls improves the assertion error reporting. If you chain assertions together with <code>&amp;&amp;</code>, you won&#39;t know which condition failed.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Don&#39;t use variable-length arrays</h4><a id="user-content-dont-use-variable-length-arrays" aria-label="Permalink: Don&#39;t use variable-length arrays" href="#dont-use-variable-length-arrays"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Variable-length arrays were introduced in C99 as a way to define dynamic-length arrays with automatic storage; no need for <code>malloc</code>. For a few reasons, they&#39;ve been made optional in C11. Thus, if you want to use variable-length arrays in C11, you&#39;ll have to write the <code>malloc</code> version anyway. Instead, just don&#39;t use variable-length arrays.</p>
<p dir="auto">I&#39;d advise against using variable-length arrays in C99, too. First, you have to <a href="https://www.securecoding.cert.org/confluence/display/seccode/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range" rel="nofollow">check the values</a> that control their size to protect against stack-smashing. Second, they can&#39;t be initialized. Finally, avoiding them will make it easier to upgrade to newer standards later on.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Avoid <code>void *</code> because it harms type safety</h4><a id="user-content-avoid-void--because-it-harms-type-safety" aria-label="Permalink: Avoid void * because it harms type safety" href="#avoid-void--because-it-harms-type-safety"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>void *</code> is useful for polymorphism, but polymorphism is almost never as important as type safety. Void pointers are indispensable in many situations, but you should consider other, safer alternatives first.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">If you have a <code>void *</code>, assign it to a typed variable as soon as possible</h4><a id="user-content-if-you-have-a-void--assign-it-to-a-typed-variable-as-soon-as-possible" aria-label="Permalink: If you have a void *, assign it to a typed variable as soon as possible" href="#if-you-have-a-void--assign-it-to-a-typed-variable-as-soon-as-possible"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Just like working with uninitialized variables is dangerous, working with void pointers is dangerous: you want the compiler on your side. So ditch the <code>void *</code> as soon as you can.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use C11&#39;s anonymous structs and unions rather mutually-exclusive fields</h4><a id="user-content-use-c11s-anonymous-structs-and-unions-rather-mutually-exclusive-fields" aria-label="Permalink: Use C11&#39;s anonymous structs and unions rather mutually-exclusive fields" href="#use-c11s-anonymous-structs-and-unions-rather-mutually-exclusive-fields"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If only certain fields of your struct should be set when certain other fields have certain values, use C11&#39;s anonymous structs and unions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="enum AUTOMATON_TYPE {
    AUTOMATON_TYPE_char,
    AUTOMATON_TYPE_split,
    AUTOMATON_TYPE_match
};
#define NUM_AUTOMATON_TYPES ( 3 )

typedef struct Automaton {
    enum AUTOMATON_TYPE type;
    union {
        struct { // type = char
            char c;
            struct Automaton * next;
        };
        struct { // type = split
            struct Automaton * left;
            struct Automaton * right;
        };
    };
} Automaton;"><pre><span>enum</span> <span>AUTOMATON_TYPE</span> {
    <span>AUTOMATON_TYPE_char</span>,
    <span>AUTOMATON_TYPE_split</span>,
    <span>AUTOMATON_TYPE_match</span>
};
<span>#define</span> <span>NUM_AUTOMATON_TYPES</span> ( 3 )

<span>typedef</span> <span>struct</span> <span>Automaton</span> {
    <span>enum</span> <span>AUTOMATON_TYPE</span> <span>type</span>;
    <span>union</span> {
        <span>struct</span> { <span>// type = char</span>
            <span>char</span> <span>c</span>;
            <span>struct</span> <span>Automaton</span> <span>*</span> <span>next</span>;
        };
        <span>struct</span> { <span>// type = split</span>
            <span>struct</span> <span>Automaton</span> <span>*</span> <span>left</span>;
            <span>struct</span> <span>Automaton</span> <span>*</span> <span>right</span>;
        };
    };
} <span>Automaton</span>;</pre></div>
<p dir="auto">This is much more explicit and obvious than something like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct Automaton {
    enum AUTOMATON_TYPE type;
    char c;
    struct Automaton * left;
    struct Automaton * right;
} Automaton;"><pre><span>typedef</span> <span>struct</span> <span>Automaton</span> {
    <span>enum</span> <span>AUTOMATON_TYPE</span> <span>type</span>;
    <span>char</span> <span>c</span>;
    <span>struct</span> <span>Automaton</span> <span>*</span> <span>left</span>;
    <span>struct</span> <span>Automaton</span> <span>*</span> <span>right</span>;
} <span>Automaton</span>;</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Don&#39;t typecast unless you have to (you probably don&#39;t)</h4><a id="user-content-dont-typecast-unless-you-have-to-you-probably-dont" aria-label="Permalink: Don&#39;t typecast unless you have to (you probably don&#39;t)" href="#dont-typecast-unless-you-have-to-you-probably-dont"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If it&#39;s valid to assign a value of one type to a variable of another type, then you don&#39;t have to cast it. You should only use typecasts when you need to, like:</p>
<ul dir="auto">
<li>performing true division (not integer division) of <code>int</code> expressions</li>
<li>making an array index an integer, but you can do this with assignment anyway</li>
<li>using compound literals for structs and arrays</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="// This compiles fine:
struct Apple * apples = malloc( sizeof *apples );"><pre><span>// This compiles fine:</span>
<span>struct</span> <span>Apple</span> <span>*</span> <span>apples</span> <span>=</span> <span>malloc</span>( <span>sizeof</span> <span>*</span><span>apples</span> );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Give structs TitleCase names, and typedef them</h4><a id="user-content-give-structs-titlecase-names-and-typedef-them" aria-label="Permalink: Give structs TitleCase names, and typedef them" href="#give-structs-titlecase-names-and-typedef-them"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Good
typedef struct Person {
    char * name;
    int age;
} Person;"><pre><span>// Good</span>
<span>typedef</span> <span>struct</span> <span>Person</span> {
    <span>char</span> <span>*</span> <span>name</span>;
    <span>int</span> <span>age</span>;
} <span>Person</span>;</pre></div>
<p dir="auto">TitleCase names should be used for structs so that they&#39;re recognizable without the <code>struct</code> prefix. They also let you name struct variables as the same thing as their type without names clashing (e.g. a <code>banana</code> of type <code>Banana</code>). You should always define the struct name, even if you don&#39;t need to, because you might need to later (e.g. to use as an incomplete type). Also, having a name at the top helps readability when comments are inserted, or the struct definition becomes large.</p>
<p dir="auto">I don&#39;t typedef structs used for named arguments (see below), however, because the TitleCase naming would be weird. Anyway, if you&#39;re using a macro for named arguments, then the typedef is unnecessary and the struct definition is hidden.</p>
<p dir="auto">If a user dislikes this practice of typedefing structs (which is fair, because it does have drawbacks - see below), they can always use the <code>struct</code> namespace instead.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Only typedef structs; never basic types or pointers</h4><a id="user-content-only-typedef-structs-never-basic-types-or-pointers" aria-label="Permalink: Only typedef structs; never basic types or pointers" href="#only-typedef-structs-never-basic-types-or-pointers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad
typedef double centermeters;
typedef double inches;
typedef struct Apple * Apple;
typedef void * gpointer;"><pre><span>// Bad</span>
<span>typedef</span> <span>double</span> <span>centermeters</span>;
<span>typedef</span> <span>double</span> <span>inches</span>;
<span>typedef</span> <span>struct</span> <span>Apple</span> <span>*</span> <span>Apple</span>;
<span>typedef</span> <span>void</span> <span>*</span> <span>gpointer</span>;</pre></div>
<p dir="auto">This mistake is committed by way too many codebases. It masks what&#39;s really going on, and you have to read documentation or find the <code>typedef</code> to learn how to work with it. Never do this in your own interfaces, and try to ignore the typedefs in other interfaces.</p>
<p dir="auto">These criticisms apply equally to struct typedefs, as advised above. In my opinion, the visual clarity achieved by removing all the <code>struct</code> declarations is worth requiring users be aware of (or realize) the convention. Also, having a consistent naming scheme for structs, with TitleCase names, helps recognizability.</p>
<p dir="auto">Pointer typedefs are particularly nefarious because they exclude the users from qualifying the pointee with <code>const</code>. This is a huge loss, for reasons enumerated in other rules.</p>
<p dir="auto">Function pointer typedefs are justified when you need to declare a function that returns a function pointer; the syntax without a typedef is unbearable. I&#39;ll also typedef a function pointer if the type is being repeated in many locations (more than three, or so). Some people like to typedef all function pointers, but this often masks what&#39;s going on and what&#39;s expected. Carefully consider if a function pointer typedef will actually help people understand what that type represents.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Give enums <code>UPPERCASE_SNAKE</code> names, and lowercase their values</h4><a id="user-content-give-enums-uppercase_snake-names-and-lowercase-their-values" aria-label="Permalink: Give enums UPPERCASE_SNAKE names, and lowercase their values" href="#give-enums-uppercase_snake-names-and-lowercase-their-values"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Because enums are mostly just integer constants, it&#39;s natural to name them the same way as <code>#define</code>d constants. The <code>enum</code> type prefix will communicate that it expects an enum value, and the lowercase value suffixes will communicate that they aren&#39;t quite integer constants.</p>
<div dir="auto" data-snippet-clipboard-copy-content="enum JSON_TYPE {
    JSON_TYPE_null,
    JSON_TYPE_boolean,
    JSON_TYPE_number,
    ...
};"><pre><span>enum</span> <span>JSON_TYPE</span> {
    <span>JSON_TYPE_null</span>,
    <span>JSON_TYPE_boolean</span>,
    <span>JSON_TYPE_number</span>,
    ...
};</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Define a constant for the size of every enum</h4><a id="user-content-define-a-constant-for-the-size-of-every-enum" aria-label="Permalink: Define a constant for the size of every enum" href="#define-a-constant-for-the-size-of-every-enum"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There&#39;s no versatile, future-proof way to work with loops, arrays, or bit-fields of the <code>enum</code> otherwise. Always define a constant to denote the size of the enumeration, to avoid hard-coded values (by you or your users).</p>
<div dir="auto" data-snippet-clipboard-copy-content="enum SUIT {
    SUIT_hearts,
    SUIT_diamonds,
    SUIT_clubs,
    SUIT_spades
};
#define NUM_SUITS 4"><pre><span>enum</span> <span>SUIT</span> {
    <span>SUIT_hearts</span>,
    <span>SUIT_diamonds</span>,
    <span>SUIT_clubs</span>,
    <span>SUIT_spades</span>
};
<span>#define</span> <span>NUM_SUITS</span> 4</pre></div>
<p dir="auto">I like to <code>#define</code> the size explicitly, rather than making it the last enum value. It seems natural to exclude the size of the enum from the actual enum itself - <code>NUM_SUITS</code> isn&#39;t a card suit I&#39;ve ever heard of! It also protects against one of the previous enum values from being explicitly set (e.g. <code>SUIT_hearts = 1</code>), which would mean the last enum value wouldn&#39;t represent the size of the enum.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Never begin names with <code>_</code> or end them with <code>_t</code>: they&#39;re reserved for standards</h4><a id="user-content-never-begin-names-with-_-or-end-them-with-_t-theyre-reserved-for-standards" aria-label="Permalink: Never begin names with _ or end them with _t: they&#39;re reserved for standards" href="#never-begin-names-with-_-or-end-them-with-_t-theyre-reserved-for-standards"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html" rel="nofollow">Here&#39;s a list</a> of the names reserved by future ISO C standards. <code>types_like_this_t</code> and <code>_anything</code> are identifiers that are reserved by future standards of C, so don&#39;t use them for your own identifiers.</p>
<p dir="auto">These kinds of names <em>could&#39;ve</em> provided a nice way to tell which types are part of the language standard and which types are provided by libraries. Unfortunately, <a href="https://github.com/facebook/libphenom">it&#39;s</a> <a href="https://github.com/joyent/libuv">not</a> <a href="https://github.com/liuliu/ccv">hard</a> to find popular C libraries and projects that make this mistake, which dilutes the helpfulness of such a rule.</p>
<p dir="auto">This mistake is made way too often: don&#39;t make the same mistake in your library!</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Only use pointers in structs for nullity, dynamic arrays or incomplete types</h4><a id="user-content-only-use-pointers-in-structs-for-nullity-dynamic-arrays-or-incomplete-types" aria-label="Permalink: Only use pointers in structs for nullity, dynamic arrays or incomplete types" href="#only-use-pointers-in-structs-for-nullity-dynamic-arrays-or-incomplete-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Every pointer in a struct is an opportunity for a segmentation fault.</p>
<p dir="auto">If the would-be pointer shouldn&#39;t be NULL, isn&#39;t an array of an unknown size, and isn&#39;t of the type of the struct itself, then don&#39;t make it a pointer. Just include a member of the type itself in the struct. Don&#39;t worry about the size of the containing struct until you&#39;ve done benchmarks.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Only use pointer arguments for nullity, arrays or modifications</h4><a id="user-content-only-use-pointer-arguments-for-nullity-arrays-or-modifications" aria-label="Permalink: Only use pointer arguments for nullity, arrays or modifications" href="#only-use-pointer-arguments-for-nullity-arrays-or-modifications"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This rule helps readers reason about where values are being modified. It also improves the safety by making it impossible for functions that shouldn&#39;t receive <code>NULL</code> from receiving <code>NULL</code> -- this is a huge benefit over languages that require pass-by-reference semantics (and thus <code>NULL</code> as a valid value almost everywhere).</p>
<p dir="auto">When you&#39;re reading a codebase that sticks to this rule, and its functions and types are maximally decomposed, you can often tell what a function does just by reading its prototype. This is in stark contrast to projects that pass pointers everywhere: you have no certainty anywhere.</p>
<p dir="auto">In C, you can pass struct values to functions, and by <a href="http://c-faq.com/ptrs/passbyref.html" rel="nofollow">pass-by-value semantics</a>, they&#39;ll be copied into the stack frame of the receiving function. The original struct can&#39;t be modified by that function (although it can return the modification). Like <code>const</code>, using this feature wherever you can makes it easier for your readers to reason about your program.</p>
<p dir="auto">Defining a &#34;modification&#34; gets tricky when you introduce structs with pointer members. I consider a modification to be something that affects the struct itself, or the pointees of the struct.</p>
<p dir="auto">If a struct will be &#34;modified&#34; by a function, have that function accept a pointer of that struct even if it doesn&#39;t need to. This saves the readers from having to find and memorize every relevant struct definition, to be aware of which structs have pointer members.</p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    int population;
} State;

typedef struct {
    State * states;
    int num_states;
} Country;

// Good: takes a `Country *` even though it *could* modify the array
// pointed to by the `states` member with just a `Country` value.
void country_grow( Country const * const country, double const percent ) {
    for ( int i = 0; i &lt; country-&gt;num_states; i += 1 ) {
        country-&gt;states[ i ].population *= percent;
    }
}"><pre><span>typedef</span> <span>struct</span> {
    <span>int</span> <span>population</span>;
} <span>State</span>;

<span>typedef</span> <span>struct</span> {
    <span>State</span> <span>*</span> <span>states</span>;
    <span>int</span> <span>num_states</span>;
} <span>Country</span>;

<span>// Good: takes a `Country *` even though it *could* modify the array</span>
<span>// pointed to by the `states` member with just a `Country` value.</span>
<span>void</span> <span>country_grow</span>( <span>Country</span> <span>const</span> <span>*</span> <span>const</span> <span>country</span>, <span>double</span> <span>const</span> <span>percent</span> ) {
    <span>for</span> ( <span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>country</span><span>-&gt;</span><span>num_states</span>; <span>i</span> <span>+=</span> <span>1</span> ) {
        <span>country</span><span>-&gt;</span><span>states</span>[ <span>i</span> ].<span>population</span> *= <span>percent</span>;
    }
}</pre></div>
<p dir="auto">Note the const-ness of the <code>country</code> argument above: this communicates that the country itself won&#39;t be modified, but a pointee (although it could also be taken to suggest that the pointer is for nullity, but the function name suggests otherwise). It also allows callers to pass in a pointer to a <code>Country const</code>.</p>
<p dir="auto">The other situation to use pointer arguments is if the function needs to accept <code>NULL</code> as a valid value (i.e. the poor man&#39;s <a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses" rel="nofollow">Maybe</a>). If so, be sure use <code>const</code> to signal that the pointer is not for modification, and so it can accept <code>const</code> arguments.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Good: `NULL` represents an empty list, and list is a pointer-to-const
int list_length( List const * list ) {
    int length = 0;
    for ( ; list != NULL; list = list-&gt;next ) {
        length += 1;
    }
    return length;
}"><pre><span>// Good: `NULL` represents an empty list, and list is a pointer-to-const</span>
<span>int</span> <span>list_length</span>( <span>List</span> <span>const</span> <span>*</span> <span>list</span> ) {
    <span>int</span> <span>length</span> <span>=</span> <span>0</span>;
    <span>for</span> ( ; <span>list</span> <span>!=</span> <span>NULL</span>; <span>list</span> <span>=</span> <span>list</span><span>-&gt;</span><span>next</span> ) {
        <span>length</span> <span>+=</span> <span>1</span>;
    }
    <span>return</span> <span>length</span>;
}</pre></div>
<p dir="auto">Sticking to this rule means ditching incomplete struct types, but I don&#39;t really like them anyway. (see the &#34;<a href="#c-isnt-object-oriented-and-you-shouldnt-pretend-it-is">C isn&#39;t object-oriented</a>&#34; rule)</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Prefer to return a value rather than modifying pointers</h4><a id="user-content-prefer-to-return-a-value-rather-than-modifying-pointers" aria-label="Permalink: Prefer to return a value rather than modifying pointers" href="#prefer-to-return-a-value-rather-than-modifying-pointers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This encourages immutability, cultivates <a href="https://en.wikipedia.org/wiki/Pure_function" rel="nofollow">pure functions</a>, and makes things simpler and easier to understand. It also improves safety by eliminating the possibility of a <code>NULL</code> argument.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad: unnecessary mutation (probably), and unsafe
void drink_mix( Drink * const drink, Ingredient const ingr ) {
    assert( drink != NULL );
    color_blend( &amp;( drink-&gt;color ), ingr.color );
    drink-&gt;alcohol += ingr.alcohol;
}

// Good: immutability rocks, pure and safe functions everywhere
Drink drink_mix( Drink const drink, Ingredient const ingr ) {
    return ( Drink ){
        .color = color_blend( drink.color, ingr.color ),
        .alcohol = drink.alcohol + ingr.alcohol
    };
}"><pre><span>// Bad: unnecessary mutation (probably), and unsafe</span>
<span>void</span> <span>drink_mix</span>( <span>Drink</span> <span>*</span> <span>const</span> <span>drink</span>, <span>Ingredient</span> <span>const</span> <span>ingr</span> ) {
    <span>assert</span>( <span>drink</span> <span>!=</span> <span>NULL</span> );
    <span>color_blend</span>( <span>&amp;</span>( <span>drink</span><span>-&gt;</span><span>color</span> ), <span>ingr</span>.<span>color</span> );
    <span>drink</span><span>-&gt;</span><span>alcohol</span> <span>+=</span> <span>ingr</span>.<span>alcohol</span>;
}

<span>// Good: immutability rocks, pure and safe functions everywhere</span>
<span>Drink</span> <span>drink_mix</span>( <span>Drink</span> <span>const</span> <span>drink</span>, <span>Ingredient</span> <span>const</span> <span>ingr</span> ) {
    <span>return</span> ( <span>Drink</span> ){
        .<span>color</span> <span>=</span> <span>color_blend</span>( <span>drink</span>.<span>color</span>, <span>ingr</span>.<span>color</span> ),
        .<span>alcohol</span> <span>=</span> <span>drink</span>.<span>alcohol</span> <span>+</span> <span>ingr</span>.<span>alcohol</span>
    };
}</pre></div>
<p dir="auto">This isn&#39;t always the best way to go, but it&#39;s something you should always consider.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Use structs to name functions&#39; optional arguments</h4><a id="user-content-use-structs-to-name-functions-optional-arguments" aria-label="Permalink: Use structs to name functions&#39; optional arguments" href="#use-structs-to-name-functions-optional-arguments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="struct run_server_options {
    char * port;
    int backlog;
};

#define run_server( ... ) \
    run_server_( ( struct run_server_options ){ \
        /* default values */ \
        .port = &#34;45680&#34;, \
        .backlog = 5, \
        __VA_ARGS__ \
    } )

int run_server_( struct run_server_options opts )
{
    ...
}

int main( void )
{
    return run_server( .port = &#34;3490&#34;, .backlog = 10 );
}"><pre><span>struct</span> <span>run_server_options</span> {
    <span>char</span> <span>*</span> <span>port</span>;
    <span>int</span> <span>backlog</span>;
};

<span>#define</span> <span>run_server</span>( ... ) \
    run_server_( ( struct run_server_options ){ \
        /* default values */ \
        .port = &#34;45680&#34;, \
        .backlog = 5, \
        __VA_ARGS__ \
    } )

<span>int</span> <span>run_server_</span>( <span>struct</span> <span>run_server_options</span> <span>opts</span> )
{
    ...
}

<span>int</span> <span>main</span>( <span>void</span> )
{
    <span>return</span> <span>run_server</span>( .<span>port</span> <span>=</span> <span>&#34;3490&#34;</span>, .<span>backlog</span> <span>=</span> <span>10</span> );
}</pre></div>
<p dir="auto">I learnt this from <em>21st Century C</em>. So many C interfaces could be improved immensely if they took advantage of this technique. The importance and value of (syntactic) named arguments is all-too-often overlooked in software development. If you&#39;re not convinced, read Bret Victor&#39;s <a href="http://worrydream.com/LearnableProgramming/" rel="nofollow">Learnable Programming</a>.</p>
<p dir="auto">Don&#39;t use named arguments everywhere. If a function&#39;s only argument happens to be a struct, that doesn&#39;t necessarily mean it should become the named arguments for that function. A good rule of thumb is that if the struct is used outside of that function, you shouldn&#39;t hide it with a macro like above.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Good; the typecast here is informative and expected.
book_new( ( Author ){ .name = &#34;Dennis Ritchie&#34; } );"><pre><span>// Good; the typecast here is informative and expected.</span>
<span>book_new</span>( ( <span>Author</span> ){ .<span>name</span> <span>=</span> <span>&#34;Dennis Ritchie&#34;</span> } );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Always use designated initializers in struct literals</h4><a id="user-content-always-use-designated-initializers-in-struct-literals" aria-label="Permalink: Always use designated initializers in struct literals" href="#always-use-designated-initializers-in-struct-literals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Bad - will break if struct members are reordered, and it&#39;s not
// always clear what the values represent.
Fruit apple = { &#34;red&#34;, &#34;medium&#34; };
// Good; future-proof and descriptive
Fruit watermelon = { .color = &#34;green&#34;, .size = &#34;large&#34; };"><pre><span>// Bad - will break if struct members are reordered, and it&#39;s not</span>
<span>// always clear what the values represent.</span>
<span>Fruit</span> <span>apple</span> <span>=</span> { <span>&#34;red&#34;</span>, <span>&#34;medium&#34;</span> };
<span>// Good; future-proof and descriptive</span>
<span>Fruit</span> <span>watermelon</span> <span>=</span> { .<span>color</span> <span>=</span> <span>&#34;green&#34;</span>, .<span>size</span> <span>=</span> <span>&#34;large&#34;</span> };</pre></div>
<p dir="auto">Sometimes I&#39;ll bend this rule for named arguments, by having a particular field be at the top of the struct, so that callers can call the function without having to name that single argument:</p>
<div dir="auto" data-snippet-clipboard-copy-content="run_server( &#34;3490&#34; );
run_server( .port = &#34;3490&#34;, .backlog = 10 );"><pre><span>run_server</span>( <span>&#34;3490&#34;</span> );
<span>run_server</span>( .<span>port</span> <span>=</span> <span>&#34;3490&#34;</span>, .<span>backlog</span> <span>=</span> <span>10</span> );</pre></div>
<p dir="auto">If you want to allow this, document it explicitly. It&#39;s then your responsibility to version your library correctly, if you change the ordering of the fields.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">If you&#39;re providing allocation and free functions only for a struct member, allocate memory for the whole struct</h4><a id="user-content-if-youre-providing-allocation-and-free-functions-only-for-a-struct-member-allocate-memory-for-the-whole-struct" aria-label="Permalink: If you&#39;re providing allocation and free functions only for a struct member, allocate memory for the whole struct" href="#if-youre-providing-allocation-and-free-functions-only-for-a-struct-member-allocate-memory-for-the-whole-struct"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you&#39;re providing <code>foo_alloc</code> and <code>foo_free</code> functions only so you can allocate memory for a member of the <code>Foo</code> struct, you&#39;ve lost the benefits and safety of automatic storage. You may as well have the allocation and free methods allocate memory for the whole struct, so users can pass it outside the scope it was defined (without dereferencing it), if they want.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Avoid getters and setters</h4><a id="user-content-avoid-getters-and-setters" aria-label="Permalink: Avoid getters and setters" href="#avoid-getters-and-setters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you&#39;re seeking encapsulation in C, you&#39;re probably overcomplicating things. Encourage your users to access and set struct members directly; never prefix members with <code>_</code> to denote an access level. Declare your struct invariants, and you don&#39;t need to worry about your users breaking things - it&#39;s their responsibility to provide a valid struct.</p>
<p dir="auto">As advised in <a href="#always-prefer-to-return-a-value-rather-than-modifying-pointers">another rule</a>, avoid mutability wherever you can.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Rather than:
void city_set_state( City * const c, char const * const state )
{
    c-&gt;state = state;
    c-&gt;country = country_of_state( state );
}

// Always prefer immutability and purity:
City city_with_state( City c, char const * const state )
{
    c.state = state;
    c.country = country_of_state( state );
    return c;
}

City c = { .name = &#34;Vancouver&#34; };
c = city_with_state( c, &#34;BC&#34; );
printf( &#34;%s is in %s, did you know?\n&#34;, c.name, c.country );"><pre><span>// Rather than:</span>
<span>void</span> <span>city_set_state</span>( <span>City</span> <span>*</span> <span>const</span> <span>c</span>, <span>char</span> <span>const</span> <span>*</span> <span>const</span> <span>state</span> )
{
    <span>c</span><span>-&gt;</span><span>state</span> <span>=</span> <span>state</span>;
    <span>c</span><span>-&gt;</span><span>country</span> <span>=</span> <span>country_of_state</span>( <span>state</span> );
}

<span>// Always prefer immutability and purity:</span>
<span>City</span> <span>city_with_state</span>( <span>City</span> <span>c</span>, <span>char</span> <span>const</span> <span>*</span> <span>const</span> <span>state</span> )
{
    <span>c</span>.<span>state</span> <span>=</span> <span>state</span>;
    <span>c</span>.<span>country</span> <span>=</span> <span>country_of_state</span>( <span>state</span> );
    <span>return</span> <span>c</span>;
}

<span>City</span> <span>c</span> <span>=</span> { .<span>name</span> <span>=</span> <span>&#34;Vancouver&#34;</span> };
<span>c</span> <span>=</span> <span>city_with_state</span>( <span>c</span>, <span>&#34;BC&#34;</span> );
<span>printf</span>( <span>&#34;%s is in %s, did you know?\n&#34;</span>, <span>c</span>.<span>name</span>, <span>c</span>.<span>country</span> );</pre></div>
<p dir="auto">But you should always provide an interface that allows for <a href="https://en.wikipedia.org/wiki/Declarative_programming" rel="nofollow">declarative programming</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="City const c = city_new( .name = &#34;Boston&#34;, .state = &#34;MA&#34; );
printf( &#34;I think I&#39;m going to %s,\n&#34;
        &#34;Where no one changes my state\n&#34;, c.name, c.country );"><pre><span>City</span> <span>const</span> <span>c</span> <span>=</span> <span>city_new</span>( .<span>name</span> <span>=</span> <span>&#34;Boston&#34;</span>, .<span>state</span> <span>=</span> <span>&#34;MA&#34;</span> );
<span>printf</span>( <span>&#34;I think I&#39;m going to %s,\n&#34;</span>
        <span>&#34;Where no one changes my state\n&#34;</span>, <span>c</span>.<span>name</span>, <span>c</span>.<span>country</span> );</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">C isn&#39;t object-oriented, and you shouldn&#39;t pretend it is</h4><a id="user-content-c-isnt-object-oriented-and-you-shouldnt-pretend-it-is" aria-label="Permalink: C isn&#39;t object-oriented, and you shouldn&#39;t pretend it is" href="#c-isnt-object-oriented-and-you-shouldnt-pretend-it-is"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">C doesn&#39;t have classes, methods, inheritance, (nice) object encapsulation, or real polymorphism. Not to be rude, but: <strong>deal with it</strong>. C might be able to achieve crappy, complicated imitations of those things, but it&#39;s just not worth it.</p>
<p dir="auto">As it turns out, C already has an entirely-capable language model. In C, we define data structures, and we define functionality that uses combinations of those data structures. Data and functionality aren&#39;t intertwined in complicated contraptions, and this is a good thing.</p>
<p dir="auto">Haskell, at the forefront of language design, made the same decision to separate data and functionality. Learning Haskell is one of the best things a programmer can do to improve their technique, but I think it&#39;s especially beneficial for C programmers, because of the underlying similarities between C and Haskell. Yes, C doesn&#39;t have anonymous functions, and no, you won&#39;t be writing monads in C anytime soon. But by learning Haskell, you&#39;ll learn how to write good software without classes, without mutability, and with modularity. These qualities are very beneficial for good C programming.</p>
<p dir="auto">Embrace and appreciate what C offers, rather than attempting to graft other paradigms onto it.</p>
</article></div></div>
  </body>
</html>
