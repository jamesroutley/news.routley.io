<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://semaphoreci.com/blog/monolith-microservices">Original</a>
    <h1>How to Improve Your Monolith Before Transitioning to Microservices</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
		
<p>Your team decided it’s time to get rid of that old, clunky monolith (finally!). You had a good run with it, but the monolith has grown so big that you’re spending more effort maintaining it than adding features. It’s time to try a different approach. It seems microservices are very popular these days, so maybe it makes sense to dig a bit deeper there and see what all the fuss is about?</p>



<p>A word of advice: don’t write off the monolith just yet. With some preparation, it can serve you well all the way through the transition. Here are 12 tips for making the transition to microservices as smooth as possible.</p>



<h2>#1 Ensure you know what you’re getting into</h2>



<p>A rewrite is never an easy journey, but by moving from monolith to microservices, you are changing more than the way you code; you are changing the company’s operating model. Not only do you have to learn a new, more complex tech stack but management will also need to adjust the work culture and reorganize people into smaller, <a href="https://kanbanize.com/blog/cross-functional-teams/">cross-functional teams</a>.</p>



<p>How to best reorganize the teams and the company are subjects worthy of a separate post. In this article, I want to focus on the technical aspects of the migration.</p>



<p>First, it’s important to research as much as possible about the tradeoffs involved in adopting microservices before even getting started. You want to be absolutely sure that <a href="https://semaphoreci.com/blog/microservice-architecture">microservices</a> (and not other alternative solutions such as modularized monoliths) are the right solution for you.</p>



<p>Start by learning everything you can about the microservice architecture, and check some example projects to get an idea of how it works. Here are some examples:</p>



<ul><li><a href="https://semaphoreci.com/community/tutorials/building-go-web-applications-and-microservices-using-gin">Building Go Microservice with Gin and CI/CD</a></li><li><a href="https://semaphoreci.com/blog/cicd-microservices-digitalocean-kubernetes">CI/CD for Microservices on DigitalOcean Kubernetes</a></li><li><a href="https://semaphoreci.com/blog/spring-boot-microservices-cicd">CI/CD for Microservice Spring Boot</a></li><li><a href="https://semaphoreci.com/blog/spring-boot-microservices-cicd" target="_blank" rel="noreferrer noopener">CI/CD for Microservice Spring Boot</a></li></ul>



<h2>#2 Make a plan</h2>



<p>It takes a lot of preparation to tear down a monolith since the old system must remain operational while the transition is made.</p>



<p>The migration steps can be tracked with tickets and worked towards in each sprint like any other task. This not only helps in gaining momentum (to actually someday achieve the migration), but gives transparency to the business owners regarding how the team is planning on implementing such a large change.</p>



<p>During planning, you have to:</p>



<ul><li>Disentangle dependencies within the monolith.</li><li>Identify the microservices needed.</li><li>Design data models for the microservices.</li><li>Develop a method to migrate and sync data between monolith and microservices databases.</li><li>Design APIs and plan for backward compatibility.</li><li>Capture the baseline performance of the monolith.</li><li>Set up goals for the availability and performance of the new system.</li></ul>



<p>Unless you’re migrating from a fairly simple monolith, you’ll need advanced techniques, such as Domain-Driven Design (DDD), by your side. If you’ve never used it before, I’ve written a short introduction on <a href="https://semaphoreci.com/blog/domain-driven-design-microservices">applying DDD to microservices</a> that’s worth a read.</p>



<h2>#3 Put everything in a monorepo</h2>



<p>As you break apart the monolith, a lot of code will be moved away from it and into new microservices. A <a href="https://semaphoreci.com/blog/what-is-monorepo">monorepo</a> helps you keep track of these kinds of changes. In addition, having everything in one place can help you recover from failures more quickly.</p>



<p>In all likelihood, your monolith is already contained in one repository. So, it’s just a matter of creating new folders for the microservices.</p>


<div>
<figure><img loading="lazy" width="696" height="316" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/monorepo.jpg" alt="Use a monorepo to host the microservice code along with the monolith" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/monorepo.jpg 696w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/monorepo-572x260.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/monorepo-165x75.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/monorepo-381x173.jpg 381w" sizes="(max-width: 696px) 100vw, 696px"/><figcaption>A monorepo is a shared repository containing the monolith and the new microservices.</figcaption></figure></div>


<h2>#4 Use a shared CI pipeline</h2>



<p>During development, you’ll not only be constantly shipping out new microservices but also re-deploying the monolith. The faster and more painless this process is, the more rapidly you can progress. Set up <a href="https://semaphoreci.com/cicd">continuous integration and delivery</a> (CI/CD) to test and deploy code automatically.</p>



<p>If you are using a monorepo for development, you’ll have to keep a few things in mind:</p>



<ul><li>Keep pipelines fast by enabling <a href="https://docs.semaphoreci.com/essentials/building-monorepo-projects/">change-based execution</a> or using a monorepo-aware build tool such as <a href="https://semaphoreci.com/blog/bazel-build-tutorial-examples">Bazel</a> or <a href="https://semaphoreci.com/blog/building-python-projects-with-pants">Pants</a>. This will make your <a href="https://semaphoreci.com/blog/cicd-pipeline">pipeline</a> more efficient by only running changes on the updated code.</li><li>Configure multiple <a href="https://docs.semaphoreci.com/guided-tour/deploying-with-promotions/">promotions</a>, one for each microservice and one more for the monolith. Use these promotions for continuous deployment.</li></ul>



<p>Configure <a href="https://semaphoreci.com/product/test-reports">test reports</a> to quickly spot and troubleshoot failures.</p>



<h2>#5 Ensure you have enough testing</h2>



<p>Refactoring is much more satisfying and effective when we are sure that the code has no regressions. <a href="https://semaphoreci.com/blog/test-automation">Automated tests</a> give the confidence to continuously ship out monolith updates.</p>



<p>An excellent place to start is the <a href="https://semaphoreci.com/blog/testing-pyramid">testing pyramid</a>. You will need a good amount of <a href="https://semaphoreci.com/blog/unit-testing">unit tests</a>, some <a href="https://semaphoreci.com/blog/integration-tests">integration tests</a>, and a few <a href="https://semaphoreci.com/blog/the-benefits-of-acceptance-testing">acceptance tests</a>.</p>


<div>
<figure><img loading="lazy" width="420" height="456" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/pyramid1.jpg" alt="The test pyramid can help you design tests for your microservices" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/pyramid1.jpg 420w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/pyramid1-165x179.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/pyramid1-381x414.jpg 381w" sizes="(max-width: 420px) 100vw, 420px"/><figcaption>The testing pyramid</figcaption></figure></div>


<p>Aim to run the tests as often on your local development machine as you do in your <a href="https://semaphoreci.com/blog/cicd-pipeline">continuous integration pipeline</a>.</p>



<h2>#6 Install an API Gateway or HTTP Reverse Proxy</h2>



<p>As microservices are deployed, you have to segregate incoming traffic. Migrated features are provided by the new services, while the not-yet-ready functionality is served by the monolith.</p>



<p>There are a couple of ways of routing requests, depending on their nature:</p>



<ul><li>An API gateway lets you forward API calls based on conditions such as authenticated users, cookies, feature flags, or URI patterns.</li><li>An HTTP reverse proxy does the same but for HTTP requests. In most cases, the monolith implements the UI, so most traffic will go there, at least at first.</li></ul>


<div>
<figure><img loading="lazy" width="630" height="498" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/gateway-and-proxy.jpg" alt="Use gateways or proxies to route requests to the microservices and monolith" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/gateway-and-proxy.jpg 630w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/gateway-and-proxy-572x452.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/gateway-and-proxy-165x130.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/gateway-and-proxy-381x301.jpg 381w" sizes="(max-width: 630px) 100vw, 630px"/><figcaption>Use API gateways and HTTP reverse proxies to route requests to the appropriate endpoint. You can toggle between the monolith and microservices on a very fine-grained level.</figcaption></figure></div>


<p>Once the migration is complete, the gateways and proxies will remain – they are a standard component of any microservice application since they offer forwarding and load balancing. They can also function as <a href="https://martinfowler.com/bliki/CircuitBreaker.html">circuit breakers</a> if a service goes down.</p>



<h2>#7 Consider the monolith-in-a-box pattern</h2>



<p>OK, this one only applies if you plan to use containers or Kubernetes for the microservices. In that case, containerization can help you homogenize your infrastructure. The monolith-in-a-box pattern consists of running the monolith inside a container such as Docker.</p>



<p>If you’ve never worked with containers before, this is a good opportunity to get familiar with the tech. That way, you’ll be one step closer to learning about Kubernetes down the road. It’s a lot to learn, so plan for a steep learning curve:</p>



<ol><li>Learn about Docker and containers.</li><li>Run your monolith in a container.</li><li>Develop and run your microservices in a container.</li><li>Once the migration is done and you’ve mastered containers, learn about Kubernetes.</li><li>As the work progresses, you can scale up the microservices and gradually move traffic to them.</li></ol>


<div>
<figure><img loading="lazy" width="648" height="200" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/source-to-k8s.jpg" alt="From source code to orchestration" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/source-to-k8s.jpg 648w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/source-to-k8s-572x177.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/source-to-k8s-165x51.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/source-to-k8s-381x118.jpg 381w" sizes="(max-width: 648px) 100vw, 648px"/><figcaption>Containerizing your monolith is a way of standardizing deployment, and it is an excellent first step in learning Kubernetes.</figcaption></figure></div>


<h2>#8 Warm up to changes</h2>



<p>It takes time to get used to microservices, so it’s best to start small and warm up to the new paradigm. Leave enough time for everyone to get in the proper mindset, upskill, and learn from mistakes without the pressure of a deadline.</p>



<p>During these first tentative steps you’ll learn a lot about distributed computing. You’ll have to deal with cloud SLA, set up SLAs for your own services, implement monitoring and alerts, define channels for cross-team communication, and decide on a deployment strategy.</p>



<p>Pick something easy to start with, like edge services that have little overlap with the rest of the monolith. You could, for instance, build an authentication microservice and route login requests as a first step.</p>


<div>
<figure><img loading="lazy" width="1056" height="390" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-1056x390.jpg" alt="Implement a small microservice first" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-1056x390.jpg 1056w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-784x290.jpg 784w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-768x284.jpg 768w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-572x211.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-750x277.jpg 750w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-165x61.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-381x141.jpg 381w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up-776x287.jpg 776w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/warm-up.jpg 1224w" sizes="(max-width: 1056px) 100vw, 1056px"/><figcaption>Pick something easy to start, like a simple edge service.</figcaption></figure></div>


<h2>#9 Use feature flags</h2>



<p><a href="https://semaphoreci.com/blog/feature-flags">Feature flags</a> are a software technique for changing the functionality of a system without having to re-deploy it. You can use feature flags to turn on and off portions of the monolith as they are migrated, experiment with alternative configurations, or run A/B testing.</p>



<p>An typical workflow for a feature-flag-enabled migration is:</p>



<ol><li>Identify a piece of the monolith’s functionality to migrate to a microservice.</li><li>Wrap the functionality with a feature flag. Re-deploy the monolith.</li><li>Build and deploy the microservice.</li><li>Test the microservice.</li><li>Once satisfied, disable the feature on the monolith by switching the feature off.</li><li>Repeat until the migration is complete.</li></ol>



<p>Because feature flags allow us to deploy inactive code to production and toggle it at any time, we can decouple feature releases from actual deployment. This gives developers an enormous degree of flexibility and control.</p>



<h2>#10 Modularize the monolith</h2>



<p>If your monolith is a tangle of code, you may very well end up with a tangle of <em>distributed</em> code once the migration is done. Like tidying up a house before a total renovation, modularizing the monolith is a necessary preparation step.</p>



<p>The modular monolith is a software development pattern consisting of vertically-stacked modules which are independent and interchangeable. The opposite of a modular monolith is the classic N-tier, or layered, monolith.</p>


<div>
<figure><img loading="lazy" width="1056" height="723" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-1056x723.jpg" alt="Layered vs modular monolith" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-1056x723.jpg 1056w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-784x537.jpg 784w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-768x526.jpg 768w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-572x392.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-750x513.jpg 750w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-165x113.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-381x261.jpg 381w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular-776x531.jpg 776w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/layered-vs-modular.jpg 1087w" sizes="(max-width: 1056px) 100vw, 1056px"/><figcaption>Layered vs. modular monolith architectures.</figcaption></figure></div>


<p>Layered monoliths are hard to disentangle – code tends to have too many dependencies (sometimes circular), making changes difficult to implement.</p>



<p>A modular monolith is the next best thing to microservices and a stepping stone towards them. The rule is that modules can only communicate over public APIs and everything is private by default. As a result, the code is less intertwined, relationships are easy to identify, and dependencies are clear-cut.</p>


<div>
<figure><img loading="lazy" width="337" height="319" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/modular-monolith-project-tree.jpg" alt="The source code tree of a modular monolith" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/modular-monolith-project-tree.jpg 337w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/modular-monolith-project-tree-165x156.jpg 165w" sizes="(max-width: 337px) 100vw, 337px"/><figcaption>This Java monolith has been split into independent modules.</figcaption></figure></div>


<p>Two patterns can help you refactor a monolith: the Strangler Fig and the Anticorruption Layer.</p>



<h3>Strangler fig pattern</h3>



<p>In the <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">Strangler Fig</a> pattern, we refactor the monolith from the edge to the center. We chew at the edges, progressively rewriting isolated functionality until the monolith is entirely redone.</p>



<p>Calls between modules are routed through the “strangler façade,” which emulates and interprets the legacy code’s inputs and outputs. Bit by bit, modules are created and slowly replace the old monolith.</p>


<div>
<figure><img loading="lazy" width="888" height="308" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern.jpg" alt="Using the stranger fig pattern to code the new microservices" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern.jpg 888w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern-784x272.jpg 784w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern-768x266.jpg 768w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern-572x198.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern-750x260.jpg 750w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern-165x57.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern-381x132.jpg 381w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/strangler-pattern-776x269.jpg 776w" sizes="(max-width: 888px) 100vw, 888px"/><figcaption>The monolith is modularized one piece at a time. Eventually, the old monolith is gone and is replaced by a new one.</figcaption></figure></div>


<h3>Anticorruption layer pattern</h3>



<p>You will find that, in some cases, changes in one module propagate into others as you refactor the monolith. To combat this, you can create a translation layer between rapidly-changing modules. This anticorruption layer prevents changes in one module from impacting the rest.</p>


<div>
<figure><img loading="lazy" width="636" height="252" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/anticorruption-layer.jpg" alt="Use an anticorruption layer to prevent changes in the microservices from affecting the monolith." srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/anticorruption-layer.jpg 636w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/anticorruption-layer-572x227.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/anticorruption-layer-165x65.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/anticorruption-layer-381x151.jpg 381w" sizes="(max-width: 636px) 100vw, 636px"/><figcaption>The anticorruption layer prevents changes from propagating by translating calls between modules and the monolith.</figcaption></figure></div>


<h2>#11 Decouple the data</h2>



<p>The superpower microservices give you is the ability to deploy any microservice at any time with little or no coordination with other microservices. This is why data coupling must be avoided at all costs, as it creates dependencies between services. Each microservice must have a private and independent database.</p>



<p>It can be shocking to realize that you have to denormalize the monolith’s shared database into (often redundant) smaller databases. But data locality is what will ultimately let microservices work autonomously.</p>


<div>
<figure><img loading="lazy" width="658" height="670" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/module-db.jpg" alt="Each microservice has a separate data store" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/module-db.jpg 658w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/module-db-68x68.jpg 68w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/module-db-572x582.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/module-db-165x168.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/module-db-381x388.jpg 381w" sizes="(max-width: 658px) 100vw, 658px"/><figcaption>Decoupling data into separate and independent databases.</figcaption></figure></div>


<p>After decoupling, you’ll have to install mechanisms to keep the old and new data in sync while the transition is in progress. You can, for example, set up a data-mirroring service or change the code, so transactions are written to both sets of databases.</p>


<div>
<figure><img loading="lazy" width="984" height="733" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db.jpg" alt="Use data synchronization to keep legacy db and microservices dbs in sync" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db.jpg 984w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db-784x584.jpg 784w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db-768x572.jpg 768w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db-572x426.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db-750x559.jpg 750w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db-165x123.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db-381x284.jpg 381w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/microservice-db-776x578.jpg 776w" sizes="(max-width: 984px) 100vw, 984px"/><figcaption>Use data duplication to keep tables in sync during development.</figcaption></figure></div>


<h2>#12 Add observability</h2>



<p>The new system must be faster, more performant, and more scalable than the old one. Otherwise, why bother with microservices?</p>



<p>You need a baseline to compare the old with the new. Before starting the migration, ensure you have good metrics and logs available. It may be a good idea to install some centralized logging and monitoring service, since it’s a key component for the <a href="https://semaphoreci.com/blog/honeycomb-ceo-on-sharing-customer-pain">observability</a> of any microservice application.</p>


<div>
<figure><img loading="lazy" width="780" height="456" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging.jpg" alt="Use a centralized service to log events and metrics from the microservices" srcset="https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging.jpg 780w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging-768x449.jpg 768w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging-572x334.jpg 572w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging-750x438.jpg 750w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging-165x96.jpg 165w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging-381x223.jpg 381w, https://wpblog.semaphoreci.com/wp-content/uploads/2022/07/logging-776x454.jpg 776w" sizes="(max-width: 780px) 100vw, 780px"/><figcaption>Metrics are used to compare the performance</figcaption></figure></div>


<h2>Conclusion</h2>



<p>The journey to microservices is never an easy one. But I hope that with these tips, you can save some time and frustration.</p>



<p>Remember to iterate in small increments, leverage CI/CD to guarantee that the monolith is being tested for regressions, and keep everything in one repository so you can always rewind if something goes wrong.</p>



<p>Happy coding, and thanks for reading!</p>
	</div></div>
  </body>
</html>
