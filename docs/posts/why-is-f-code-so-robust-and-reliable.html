<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/dotnet/why-is-fsharp-code-so-robust-and-reliable/">Original</a>
    <h1>Why is F# code so robust and reliable?</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-53512">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <blockquote><p>This is a guest post by Vladimir Shchur, lead developer at <a href="https://accesssoftek.com/">Access Softek</a>. Vladimir is an active open-source contributor, the author of <a href="https://github.com/Lanayx/Oxpecker">Oxpecker</a> and <a href="https://github.com/fsprojects/pulsar-client-dotnet">Pulsar.Client</a> libraries. He has also published a series of posts on <a href="https://medium.com/@lanayx">Medium</a> and <a href="https://github.com/dotnet/fsharp/pull/17277">contributed to F# Core</a>.</p></blockquote>

<p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2024/09/why-fsharp-is-robust-and-reliable.png" alt="Image why fsharp is robust and reliable"/></p>
<p>In Access Softek, we’ve been developing software for financial institutions using C# and .NET for two decades, at the same time suffering from lots of bugs. We struggled to implement the <a href="https://www.ministryoftesting.com/articles/zero-bug-policy-the-myths-and-the-reality">Zero Bug Policy</a> and had the green light to build one of our new projects, namely <a href="https://accesssoftek.com/easycoin/">EasyCoin</a>, in F#, as it was claimed to be a very robust and effective tool.</p>
<p>The EasyCoin project was challenging, requiring the implementation of distributed transactions with all the possible unexpected outcomes that could happen along the way. The transaction flow included integration with several services, including some internal SOAP ones. The project also required creating a client-facing UI, a web API, an admin site, and a few other elements. The implementation took us about a year and a half for the team of 4 F# full-stack developers, a team lead, a PM and a QA.</p>
<p>The product has been live for a year, and remarkably, only one user-facing bug has been found so far. I attribute this success to the chosen language. In this post, I will share the specific reasons F# allowed us to write robust code. Some of them may be not applicable to your projects and this also might not mention F# aspects which your company would want to leverage. The following are the particular features that made our company avoid bugs in the software we do and hence make our customers happy.</p>
<h2>Immutability by default</h2>
<p>F#’s basic blocks — values and records — are immutable by default (as in, in F#, it’s easier to write immutable code than mutable code). This is good for thread safety and general code predictability – since objects don’t change state, components can rely on them without worrying about how other parts of the program might alter them:</p>
<pre><code>let x = 1
x &lt;- 2                      // error, x is not mutable

type User = { Id: int }
let process (user: User) =
    user.Id &lt;- 2            // error, Id field is not mutable
    user &lt;- { Id: 2 }       // error, user argument is not mutable</code></pre>
<h2>Discriminated unions with exhaustive check</h2>
<p><a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/discriminated-unions">Discriminated unions (DU)</a> is an F# key feature which lets types hold a closed set of arbitrary data. Importantly, DU <code>match</code> is exhaustive, meaning that adding a case would raise warnings in all not yet handled cases, preventing potential bugs:</p>
<pre><code>open System

type LoginType =
    | Password of string
    | PinCode of int

let printLoginType loginType =
    match loginType with  // warning, not all cases are handled
    | Password password -&gt; Console.WriteLine(password)</code></pre>
<h2>No nulls by default</h2>
<p>While many modern languages added some control for doing more null checks to prevent <code>NullReferenceException</code>, F# avoided them from the inception. This means such exceptions are nearly impossible in the end-to-end F# workflows (although, you still need to handle them during interop):</p>
<pre><code>type User = { Id: int }
let user = { Id = null }     // error, null is not assignable to int
let user: User = null        // error, null is not assignable to record User

let s1: string = null        // allowed in F# 8 due to interop with C#, warning in F# 9 (when opted in)
let s2: string | null = null // allowed in F# 9 due to interop with C# and null reference type support (when opted in)</code></pre>
<p><em>Idiomatic</em> F# way to deal with missing values is using <a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/options"><code>Option&lt;&#39;T&gt;</code></a> type, so that the developer has to explicitly unwrap it and handle the missing value:</p>
<pre><code>open System

let numberOption = [1; 2; 3] |&gt; List.tryFind (fun x -&gt; x % 2 = 0)

match numberOption with
| Some x -&gt; Console.WriteLine($&#34;Even number was found: {x}&#34;)
| None -&gt; Console.WriteLine(&#34;Even number was not found&#34;)</code></pre>
<h2>No exceptions in the business logic</h2>
<p>Throwing custom exceptions is one of the popular ways to deal with errors in business logic, however it is also a source of bugs, since there is no way to ensure those exceptions are handled properly. While it is still reasonable to throw exceptions in unexpected cases (like when the database connection fails), you shouldn’t do it in the middle of the business transaction. F# has a dedicated <a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/results"><code>Result&lt;&#39;T&gt;</code></a> type for handling errors, and you can also easily define your more specific DUs:</p>
<pre><code>type TransactionStatus =
    | Ready
    | Pending

let executeTransaction transaction =
    if validate transaction then
        try
            let isReady = callExternalService transaction
            if isReady then Ok Ready else Ok Pending
        with ex -&gt;
            Error $&#34;Service is unavailable: {ex.Message}&#34;
    else
        Error &#34;Transaction is invalid&#34;</code></pre>
<h2>Strict dependency order</h2>
<p>In F#, all variables, functions, types and files can only depend on variables, functions, types and files defined earlier. The benefits of this are the fact that a circular dependency is not possible by default and extra clarity with “what depends on what”, which helps during code analysis and PR reviews:</p>
<pre><code>open System

type Person = { BillingAddress: Address } // error, since the required type is defined below
type Address = { Street: string }

helloWorld() // error, the function is defined below
let helloWorld() = Console.WriteLine(&#34;Hello&#34;)</code></pre>
<pre><code>&lt;ItemGroup&gt;
    &lt;Compile Include=&#34;Operations.fs&#34; /&gt; &lt;!-- error, since operations use models defined below --&gt;
    &lt;Compile Include=&#34;Models.fs&#34; /&gt;
&lt;/ItemGroup&gt;</code></pre>
<h2>Warnings on unused expression results</h2>
<p>F# warnings will make you think twice about dangling values, where other popular languages would simply ignore that fact, unless they had an external analyzer:</p>
<pre><code>open System.Collections.Generic

let people = Dictionary&lt;string, int&gt;()
people.Add(&#34;Jack&#34;, 1)
people.Remove(&#34;John&#34;) // warning, Remove returns bool value, you need to think about missing case</code></pre>
<h2>Typed primitives</h2>
<p>F# has a notion of <a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/units-of-measure">Units of Measure</a> which help the compiler to verify that arithmetic relationships have correct units. Among other things, this (together with <a href="https://github.com/fsprojects/FSharp.UMX"><code>FSharp.UMX</code></a> package), make it very easy to have your primitives strongly typed with zero cost at runtime:</p>
<pre><code>open FSharp.UMX

[&lt;Measure&gt;] type private tenantId
[&lt;Measure&gt;] type private transactionId

type TenantId = string&lt;tenantId&gt;
type TransactionId = string&lt;transactionId&gt;

type Transaction = {
    TenantId: TenantId
    TransactionId: TransactionId
}

let getTransactions tenantId transactionId = 
    [
        { TenantId = tenantId; TransactionId = transactionId }
        { TenantId = tenantId; TransactionId = tenantId } // error, TenantId and TransactionId are different types
    ]

getTransactions %&#34;myTenant&#34; %&#34;1234&#34;</code></pre>
<h2>Explicit conversions</h2>
<p>Implicit type conversions are a common source of accidental errors. For example, this code will compile just fine in languages such as TypeScript or C#:</p>
<pre><code>var x = 1 + &#34;&#34;;       // compiles</code></pre>
<p>F# compiler won’t allow such implicit conversions and will produce an error:</p>
<pre><code>let x = 1 + &#34;&#34;        // error, the type &#39;string&#39; does not match the type &#39;int&#39;
let y = string 1 + &#34;&#34; // ok</code></pre>
<p>Another prominent example of accidental conversion bugs is string interpolation. Let’s say we had this C# code:</p>
<pre><code>var age = 21;
var displayAge = $&#34;Your age is {age}&#34;;</code></pre>
<p>Then someone refactored the code and used anonymous type, but forgot to update the interpolation:</p>
<pre><code>var age = new { Age = 21 };
var displayAge = $&#34;Your age is {age}&#34;; // no errors or warnings, but wrongly evaluates to &#34;Your age is { Age = 21 }&#34;</code></pre>
<p>With F#, you can <a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/plaintext-formatting">specify</a> the type of the “hole” to avoid such errors:</p>
<pre><code>let age = 21
let displayAge = $&#34;Your age is %i{age}&#34;             // ok

let ageRecord = {| Age = 21 |}
let displayAgeRecord = $&#34;Your age is %i{ageRecord}&#34; // compilation error, ageRecord is not an integer</code></pre>
<h2>Functional approach to concurrency</h2>
<p>Reading and writing code with locks is difficult, so actors frameworks are there for help. <a href="https://en.wikipedia.org/wiki/Actor_model">Actors</a> simplify reasoning and reduce shared data bugs by assigning a single owner to data and communicating with each other using messages. Each actor should be able to handle different types of message and they can be conveniently modeled as Discriminated Unions.</p>
<p>F# has a built-in actor support using <a href="https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpmailboxprocessor-1.html"><code>MailboxProcessor&lt;&#39;Msg&gt;</code></a>, but you can also easily switch to a more modern <a href="https://learn.microsoft.com/dotnet/core/extensions/channels">Channels library</a>:</p>
<pre><code>open System
open System.Threading.Channels

type MyMessage =
    | Start
    | Print of string
    | Stop

let actor = Channel.CreateUnbounded&lt;MyMessage&gt;(UnboundedChannelOptions(SingleReader = true))
let actorLoopTask = backgroundTask {
    let mutable continueLoop = true
    while continueLoop do
        match! actor.Reader.ReadAsync() with
        | Start -&gt; Console.WriteLine(&#34;Started&#34;)
        | Print s -&gt; Console.WriteLine(s)
        | Stop -&gt; continueLoop &lt;- false
}

actor.Writer.TryWrite Start |&gt; ignore                 // send 1st message to the actor
actor.Writer.TryWrite (Print &#34;Hello world&#34;) |&gt; ignore // send 2nd message to the actor

actorLoopTask.Wait()</code></pre>
<h2>Explicit dependency injection</h2>
<p>OOP projects usually use DI containers for injecting dependencies at runtime, thus dependency resolution bugs often reach production, because real dependencies are not covered by unit tests and missing registration can’t be caught at compile time. With functional architecture, dependencies are passed explicitly as function arguments, which results in:</p>
<ul>
<li>Compile time verification, no “unregistered dependency” errors are possible at runtime</li>
<li>Better separation of concerns, different functions only depend on their arguments, not on shared fields (like in constructor injection)</li>
<li>Easier testing, since all you need to do is to specify function arguments</li>
</ul>
<p>Dependency injection in F# is fully described in <a href="https://medium.com/@lanayx/dependency-injection-in-f-the-missing-manual-d376e9cafd0f">this article</a>. Example code:</p>
<pre><code>let notifyUser (env: #IGetUserSettings &amp; #ISendEmail &amp; #ISendSms)   
               userId message =  
    task {  
        let! userSettings = env.GetUserSettings(userId)  
        match userSettings.NotificationType with  
        | Email address -&gt;   
            return! env.SendEmail(address, message)  
        | Sms phone -&gt;  
            return! env.SendSms(phone, message)  
    }</code></pre>
<h2>The bottom line</h2>
<p>These are just some of the ways that F# helped us write robust and readable code that dropped our bug count to nearly zero. What’s more, F# libraries let you write type-safe SQL (using <a href="https://learn.microsoft.com/dotnet/fsharp/tutorials/type-providers/">Type Providers</a>), type-safe HTML or IaC (using <a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/computation-expressions">Computational Expressions</a>), type-safe ASP.NET route parameters (using <a href="https://learn.microsoft.com/dotnet/fsharp/language-reference/plaintext-formatting"><code>printf</code> module</a>), and many more. And it is also worth mentioning that F# brings its goodness not just to .NET, but can run on other platforms with transpilers available to JavaScript and Python using the <a href="https://fable.io">Fable project</a>.</p>
<p>With that, I’m wrapping up, I hope this article has provided valuable insights and inspired you to explore F# if you haven’t done so already. F# community will be always ready to help in <a href="https://amplifyingfsharp.io/">Amplifying F#</a>, <a href="https://fsharp.org/guides/slack/">Slack</a>, <a href="https://discord.com/invite/R6n7c54">Discord</a>, or <a href="https://x.com/hashtag/fsharp?f=live">X</a>.</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
