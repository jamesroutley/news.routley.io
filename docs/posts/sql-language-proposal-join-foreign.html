<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/joelonsql/15b50b65ec343dce94db6249cfea8aaa">Original</a>
    <h1>SQL language proposal: JOIN FOREIGN</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-join-foreign-md">
      
      <div id="file-join-foreign-md-readme">
    <article itemprop="text">
<p dir="auto">The idea is to improve the SQL language, specifically the join syntax, for the special but common case when joining on foreign key columns.</p>
<h2 dir="auto"><a id="user-content-the-problem" aria-hidden="true" href="#the-problem"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The problem</h2>
<p dir="auto">Example below taken from PostgreSQL documentation <a href="https://www.postgresql.org/docs/current/sql-select.html" rel="nofollow">1</a></p>
<p dir="auto">In SQL-89, we didn&#39;t have any <code>JOIN</code> syntax yet, so queries were written in this way:</p>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> distributors d, films f
    <span>WHERE</span> <span>f</span>.<span>did</span> <span>=</span> <span>d</span>.<span>did</span></pre></div>
<p dir="auto">This improved in SQL-92:</p>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> distributors d
    <span>JOIN</span> films f <span>ON</span> <span>f</span>.<span>did</span> <span>=</span> <span>d</span>.<span>did</span></pre></div>
<p dir="auto">However, in the same standard, they also added <code>USING</code> and <code>NATURAL</code>:</p>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> distributors d
    <span>JOIN</span> films f USING (did)</pre></div>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> distributors d
    <span>NATURAL JOIN</span> films f</pre></div>
<p dir="auto">Unfortunately, <code>USING</code> and <code>NATURAL</code> suffer from problems, as they can suddenly break due to ambiguities if columns are added. <a href="http://www.databasesoup.com/2013/08/fancy-sql-monday-on-vs-natural-join-vs.html" rel="nofollow">2</a></p>
<p dir="auto">A proper database schema with foreign keys can be represented as directed graph, where the tables are the nodes and foreign keys the edges. It&#39;s a directed graph since a foreign key has a direction.
The foreign key is created on the referencing table, and the table it references is called the referenced table. There is a Many-to-one relationship between the referencing and the referenced table.</p>
<p dir="auto">Now, please take a look at the join queries above again.</p>
<p dir="auto">Other than making guesses based on the names of the tables and columns, there is no information in the SQL query code itself that tells us if <em>distributors</em> references <em>films</em>, or if it&#39;s the other way around.</p>
<p dir="auto">We currently rely solely on naming conventions to deduce the relationship between tables, that is, if it&#39;s <em>One-to-many</em> or <em>Many-to-one</em>.</p>
<p dir="auto">If there is a bug in a query written by a colleague, causing unexpected number of rows in the result set, it can sometimes be complicated to debug such a query.</p>
<p dir="auto">If the common simple joins (when joining on foreign key columns) would be written in a different syntax, the remaining joins would visually stand out and we could focus on making sure we understand them when reading a large SQL query.</p>
<p dir="auto">Not having to specify all the join columns would also improve conciseness.</p>
<p dir="auto">Problems summary:</p>
<ul dir="auto">
<li><code>JOIN USING (...)</code> and <code>NATURAL JOIN</code> improved conciseness compared to <code>JOIN ... ON</code>, but suffer from other problems <a href="http://www.databasesoup.com/2013/08/fancy-sql-monday-on-vs-natural-join-vs.html" rel="nofollow">2</a>.</li>
<li>SELECT queries doesn&#39;t contain any information on the join direction, i.e. what table is foreign vs primary in a join. The reader needs to draw conclusions based on the naming of tables/columns.</li>
<li>When writing joins, having to specify all columns involved in a join, is unnecessairly verbose.</li>
</ul>
<h2 dir="auto"><a id="user-content-the-proposal" aria-hidden="true" href="#the-proposal"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The proposal</h2>
<p dir="auto">Foreign keys are constraints with names. These names are auto-generated if not specified explicitly, and must be unique per schema according to the SQL standard, but at least PostgreSQL only require them to be unique per referencing table.</p>
<p dir="auto">By specifying the foreign key, we wouldn&#39;t need to specify the columns on which to perform the join.</p>
<p dir="auto">Here is how it would work:</p>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> films f
    <span>JOIN</span> FOREIGN <span>f</span>.<span>films_did_fkey</span> d</pre></div>
<p dir="auto">or e.g.</p>
<div><pre>    <span>LEFT JOIN</span> FOREIGN <span>f</span>.<span>films_did_fkey</span> d</pre></div>
<p dir="auto">Let&#39;s explain the <code>JOIN FOREIGN</code> syntax step-by-step:</p>
<ol dir="auto">
<li>
<p dir="auto">When <code>JOIN</code> is followed by the <code>FOREIGN</code> keyword, we indicate we want to specify a foreign key to follow on a table alias already introduced in the from clause.</p>
</li>
<li>
<p dir="auto">Next, we specify the foreign key name qualified by the referencing table alias, <code>f.films_did_fkey</code>.</p>
</li>
<li>
<p dir="auto">Lastly, we assign a new table alias <code>d</code> for the referenced table.</p>
</li>
</ol>
<p dir="auto">If we would instead want to join by first introducing <em>distributors</em> and then join <em>films</em>, the syntax would be different:</p>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> distributors d
    <span>JOIN</span> films f FOREIGN films_did_fkey REF d</pre></div>
<p dir="auto">The syntax is different enough to easily distinguish between the two cases. This is intentional and important, as the first case <code>JOIN FOREIGN</code>, can never cause extra rows, since it defines a <em>Many-to-one</em> relationship, whereas <code>JOIN ... FOREIGN ... REF</code>  could cause extra rows, since it defines a <em>One-to-many</em> relationship.</p>
<p dir="auto">Let&#39;s explain the <code>JOIN ... FOREIGN ... REF</code> syntax step-by-step:</p>
<ol dir="auto">
<li>
<p dir="auto">In the grammar, at the same place as expecting <code>ON boolean_expression</code> or <code>USING (...)</code>, we allow the keyword <code>FOREIGN</code> to indicate we want to specify the name of a foreign key for the table we just introduced in the from clause, as part of the current join statement, in the example, this is <code>JOIN films f FOREIGN</code>.</p>
</li>
<li>
<p dir="auto">Next, we specify the name of the foreign key, as the referencing table which has the foreign key, has already been specified in the first part of the join statement. We simply write <code>films_did_fkey</code>.</p>
</li>
<li>
<p dir="auto">Lastly, we need to specify what table alias to join against, <code>REF d</code>. This is necessary since even though we know the referenced table based on the foreign key, the table might have been introduced multiple times in the from clause.</p>
</li>
</ol>
<p dir="auto">To further improve conciseness and readability, a better default naming convention for foreign keys would be to give them the same name as the referenced table:</p>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> films f
    <span>JOIN</span> FOREIGN <span>f</span>.<span>distributors</span> d</pre></div>
<div><pre><span>SELECT</span> <span>f</span>.<span>title</span>, <span>f</span>.<span>did</span>, <span>d</span>.<span>name</span>, <span>f</span>.<span>date_prod</span>, <span>f</span>.<span>kind</span>
    <span>FROM</span> distributors d
    <span>JOIN</span> films f FOREIGN distributors REF d</pre></div>
<p dir="auto">Note, this proposal does not depend on any specific naming convention for foreign keys.</p>
<p dir="auto">If there are multiple foreign keys between two tables, the foreign key names could instead be based on column names. A typical example would be some table with multiple <em>user_id</em> columns, such as <em>owner_id</em> and <em>manager_id</em>, both referencing <em>users.user_id</em>, in such case, the foreign keys could be named <em>owner</em> and <em>manager</em>.</p>
<p dir="auto">Another example would be a users table with a self-referencing <em>parent_id</em> column. Such foreign key could be named <em>parent</em>.</p>
<p dir="auto">The example query from the PostgreSQL documentation is perhaps too simple to fully demonstrate and appreciate the clarity and conciseness of the proposed <code>JOIN FOREIGN</code> syntax. Here is another slightly more complicated example taken from the Grafana project <a href="https://github.com/grafana/grafana/blob/main/pkg/services/accesscontrol/database/resource_permissions.go">3</a>.</p>
<div><pre><span>SELECT</span> <span>*</span>
<span>FROM</span> permission p
<span>LEFT JOIN</span> role r <span>ON</span> <span>p</span>.<span>role_id</span> <span>=</span> <span>r</span>.<span>id</span>
<span>LEFT JOIN</span> team_role tr <span>ON</span> <span>r</span>.<span>id</span> <span>=</span> <span>tr</span>.<span>role_id</span>
<span>LEFT JOIN</span> team t <span>ON</span> <span>tr</span>.<span>team_id</span> <span>=</span> <span>t</span>.<span>id</span>
<span>LEFT JOIN</span> user_role ur <span>ON</span> <span>r</span>.<span>id</span> <span>=</span> <span>ur</span>.<span>role_id</span>
<span>LEFT JOIN</span> <span><span>&#34;</span>user<span>&#34;</span></span> u <span>ON</span> <span>ur</span>.<span>user_id</span> <span>=</span> <span>u</span>.<span>id</span>
<span>WHERE</span> <span>p</span>.<span>id</span> <span>=</span> <span>1</span>;</pre></div>
<p dir="auto">vs</p>
<div><pre><span>SELECT</span> <span>*</span>
<span>FROM</span> permission p
<span>LEFT JOIN</span> FOREIGN <span>p</span>.<span>role</span> r
<span>LEFT JOIN</span> team_role tr FOREIGN role REF r
<span>LEFT JOIN</span> FOREIGN <span>tr</span>.<span>team</span> t
<span>LEFT JOIN</span> user_role ur FOREIGN role REF r
<span>LEFT JOIN</span> FOREIGN <span>ur</span>.<span>user</span> u
<span>WHERE</span> <span>p</span>.<span>id</span> <span>=</span> <span>1</span>;</pre></div>
<p dir="auto">What&#39;s nice about this example is the need to use both <code>JOIN FOREIGN</code> and <code>JOIN ... FOREIGN ... REF</code>. It cannot be written using only <code>JOIN FOREIGN</code> statements, since we cannot reach all referenced tables from any single referencing table. For instance, we could begin with <em>team_role</em>:</p>
<div><pre><span>SELECT</span> <span>*</span>
<span>FROM</span> team_role tr
<span>LEFT JOIN</span> FOREIGN <span>tr</span>.<span>role</span> r
<span>LEFT JOIN</span> FOREIGN <span>tr</span>.<span>team</span> t</pre></div>
<p dir="auto">But then we would need <code>JOIN ... FOREIGN ... REF</code>, as none of the role nor team tables have any foreign keys to follow:</p>
<div><pre><span>LEFT JOIN</span> permission p FOREIGN role REF r
<span>LEFT JOIN</span> user_role ur FOREIGN role REF r
<span>LEFT JOIN</span> FOREIGN <span>ur</span>.<span>user</span> u
<span>WHERE</span> <span>p</span>.<span>id</span> <span>=</span> <span>1</span>;</pre></div>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
