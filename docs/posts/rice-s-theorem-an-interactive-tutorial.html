<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://busy-beavers.tigyog.app/rice">Original</a>
    <h1>Rice’s Theorem: An interactive tutorial</h1>
    
    <div id="readability-page-1" class="page"><div><p aria-hidden="false"><h2><span id="an-interactive-tutorial"></span>An interactive tutorial</h2></p><p>Turing famously showed that computers can’t decide whether your code halts. But in 1951, Henry Rice proved a much more devastating result: “computers can’t decide <i>anything</i> interesting about your code’s input-output!” In this chapter, you’ll learn exactly what he meant, and how he proved it, by building on Turing’s famous theorem.</p><p>Let’s start with a very practical question: can you replace a function with a regular expression? Imagine, one day at work, you come across this function in the codebase:</p><p>Hmm, you think ... could this function be replaced by a regular expression test?</p><p>But wouldn’t it be cool if your IDE gave you a refactoring hint? Imagine: “function <code>isNumeric</code> can be replaced by a regular expression.” The IDE is smart enough to give us other hints, like “unused variable”. Would this regular expression test be much harder?</p><p aria-hidden="true"><h2><span id="warm-up-can-be-regex"></span>Warm-up: <code>canBeRegex</code></h2></p><p>If your IDE could make this decision, it would have an internal function like this:</p><p><code>canBeRegex</code> takes the source code for a function, analyzes it, and returns <code>true</code> or <code>false</code>, telling us whether the function could be replaced with a regular expression. For example, what should the following call return?</p><p>Let’s try another function, <code>bad_isLen3</code>:</p><p>What should <code>canBeRegex</code> return when given the source code of <code>bad_isLen3</code>?</p><p>But now what about <code>awful_isLen3</code>:</p><p>This is clearly not replaceable by a regex, so <code>canBeRegex</code> should return <code>false</code> on it. Perhaps you see the problem: doesn’t <code>canBeRegex</code> need to decide whether that first line halts?</p><p aria-hidden="true"><h2><span id="that-old-halting-problem-again"></span>That old halting problem again</h2></p><p>In <a href="https://tigyog.app/d/fr9uub3hqgab/r/the-halting-problem">Chapter 1</a>, we discovered the halting problem. Here’s a quick reminder:</p><p>The <code>halts</code> function is given some JavaScript <code>code</code> in string form, and it must tell us whether it halts. For example, what should this return?</p><p>Alright, there are two reasonable answers here! If you think of <code>x</code> as a real or rational number,  <code>x</code> would never reach zero, so <code>halts</code> should return <code>false</code>. But in JavaScript floating-point numbers, it eventually gets to <code>5e-324 / 2</code>, which evaluates to zero, so <code>halts</code> should return <code>true</code>!</p><p>The point is: deciding whether code halts is <i>freaking hard</i>. And in <a href="https://tigyog.app/d/fr9uub3hqgab/r/the-halting-problem">Chapter 1</a>, we learned Turing’s proof that <code>halts</code> is actually <i>impossible</i> to implement: any implementation you write will have a bug!</p><p>So, isn’t <code>canBeRegex</code> impossible too? Put on your logician’s hat: what would we need to do to prove that <code>canBeRegex</code> is impossible to write?</p><p>So, here’s an idea for implementing <code>halts</code> using <code>canBeRegex</code>:</p><p>But does this really solve the halting problem? Let’s check. First, assume that <code>code</code> <i>does</i> halt. Now read the above <code>halts(code)</code>: what will it return?</p><p>Now assume that <code>code</code> does <i>not </i>halt. Then what will the above <code>halts(code)</code> return?</p><p>So this does solve the halting problem. But we know that’s impossible! We have a contradiction, so our initial assumption must be false. That is, <code>canBeRegex</code> cannot exist!</p><p aria-hidden="true"><h2><span id="can-halt-maybe-an-easier-question"></span><code>canHalt</code>: maybe an easier question?</h2></p><p>Perhaps you’re thinking: “A regular expression always halts. So implementing <code>canBeRegex</code> is actually <i>even harder</i> than solving the halting problem. This is not so surprising.”</p><p>Well, let’s consider a new property, <code>canHalt</code>. Given a function’s source code, it tells us whether there is at least one argument that causes the function to halt. For example, what should this return?</p><p>Now, this <code>canHalt</code> property does not imply the function <i>always</i> halts. So does Rice’s argument still work to show that <code>canHalt</code> cannot be written? Let’s try running it through the proof anyway! Assume we have <code>canHalt</code>, and then write:</p><p>Check this implementation of <code>halts</code>! If <code>code</code> halts, it should return <code>true</code>, and if <code>code</code> does not halt, it should return <code>false</code>. So, does it correctly solve the halting problem?</p><p>So, similarly, <code>canHalt</code> is also impossible to implement! Here’s how we were able to prove it. We have two functions, <code>loop</code> and <code>ret42</code>:</p><p>By injecting the <code>code</code> at the top of the <code>ret42</code> function, it either </p><p>• transforms it into the <code>loop</code> function (if <code>code</code> does <i>not </i>halt), or</p><p>• leaves it unmodified (if <code>code</code> <i>does </i>halt).</p><p>We then use <code>canHalt</code> to distinguish whether the injected <code>code</code> transformed the <code>ret42</code> function into <code>loop</code>, or left it alone. And this tells us whether <code>code</code> halts.</p><p aria-hidden="true"><h2><span id="final-boss-num-halts-is-even"></span>Final boss: <code>numHaltsIsEven</code></h2></p><p>Let’s try an even trickier function property: <code>numHaltsIsEven</code>. This considers how many distinct values you can pass to the function that would cause it to halt. It then returns <code>true</code> if that number is even.</p><p>As before, let’s write a function that will satisfy the property:</p><p>How many distinct values of <code>n</code> will cause <code>haltIf4Or8</code> to halt?</p><p>There are exactly two values, <code>4</code> and <code>8</code>, that cause this function to halt. And two is an even number, so this function should satisfy <code>numHaltsIsEven</code>.</p><p>Now let’s use our standard trick, and try to solve the halting problem by injecting the <code>code</code> at the start of <code>haltIf4Or8</code>:</p><p>Use the same “proof-by-cases” technique, first assuming <code>code</code> halts, then assuming it doesn’t. Does the above solve the halting problem?</p><p>But this is fixable. We just need to construct a function that does <i>not</i> satisfy <code>numHaltsIsEven</code>. Which of these will do the job?</p><p>Second time lucky: let’s try again to implement <code>halts</code>, by inject the <code>code</code> into <code>hangIf3</code>, then inverting the final result with <code>!</code>:</p><p>If you check it, you should find that this correctly solves the halting problem — thus proving that <code>numHaltsIsEven</code> cannot exist!</p><p aria-hidden="true"><h2><span id="now-for-an-any-property-p"></span>Now for an any property <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span></h2></p><p>Finally, you’re prepared to see Rice’s trick in its full generality. We’re given any function property <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span>, like “can be a regex” or “number of halting inputs is even”. We want to show that a function <code>isP</code> cannot be written.</p><p>We will find some function <code>t</code>, and then inject <code>code</code> at the top of it. If the <code>loop</code> function does <i>not</i> satisfy <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span>, we set <code>t</code> to a function that <i>does</i> satisfy <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span>; otherwise, we set <code>t</code> to a function that does <i>not</i> satisfy <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span>. We then ask <code>isP</code>: “would injecting <code>code</code> at the top of <code>t</code> convert it into the <code>loop</code> function?” This answers the halting problem, so <code>isP</code> cannot exist!</p><p>Well ... almost. Henry Rice says there are two properties of <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span> that make this trick work: first, <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span> must be a <b>semantic </b>property, and second, it must be a <b>non-trivial</b> property. Let’s see what they mean.</p><p aria-hidden="true"><h2><span id="too-many-variables"></span>Too many variables</h2></p><p>Perhaps you’ve seen IDE warnings like: “Function <code>f</code> has more than 20 variables. Consider splitting into smaller functions.” But that sounds like a property of functions! Didn’t we just see those are impossible to decide?</p><p>Can we really write a function <code>hasMoreThan20Vars</code> that takes a function string and tells us whether it has more than 20 variables?</p><p>Sure we can! It reads through the source code, and counts every <code>const x</code>, <code>var y</code>, et cetera. No problem here! So, what’s different about this property? To see, let’s assume we have <code>hasMoreThan20Vars</code>, and try out Rice’s trick:</p><p>Use the usual proof-by-cases: does this solve the halting problem?</p><p>The function <code>lotsOfVars</code> starts with 26 variables, so it satisfies <code>hasMoreThan20Vars</code>. Injecting some <code>code</code> at the top doesn’t make any difference to that. It doesn’t tell us anything about whether <code>code</code> halts.</p><p>When Mr. Rice says <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span> must be <b>semantic</b>, he means it must be solely concerned with the input and output of the function when called. That is: if two functions have the same input-output, then <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span> cannot be true of one, and false of the other.</p><p>Let’s see a couple of example properties. Consider a property <code>returnsInput</code>, which tells us whether a function returns its own argument. For examples</p><p>Is the property <code>returnsInput</code> semantic?</p><p>I think it’s semantic. The property can be decided by only looking at the input-output table, e.g. <code>1 -&gt; 1</code>, <code>&#34;foo&#34; -&gt; &#34;foo&#34;</code>, etc.</p><p><i>(Bonus exercise: consider the property </i><code>returnsOwnSourceCode</code><i>, which tells us whether a function will </i><a href="https://en.wikipedia.org/wiki/Quine_(computing)" target="_blank"><i>return its own source code</i></a><i>. Is </i><code>returnsOwnSourceCode</code><i> a semantic property? Will Rice’s trick work on it? Answers on a postcard!)</i></p><p aria-hidden="true"><h2><span id="solving-the-halting-problem-is-trivial"></span>Solving the halting problem is trivial?!</h2></p><p>The final property we’ll consider today is called <code>solvesHaltingProblem</code>. Given a function’s source code, it tells us whether that function solves the halting problem — that is, whether it’s a correct implementation of <code>halts</code>.</p><p>As always, let’s try to run Rice’s proof. First: does the <code>loop</code> function satisfy <code>solvesHaltingProblem</code>?</p><p>So, next, we must set <code>t</code> to a function that <i>does</i> satisfy <code>solvesHaltingProblem</code>. Can you find one?</p><p>The problem is, there is no such function — Turing taught us this. And so we can’t proceed with Rice’s proof.</p><p>If there are no functions that satisfy the property <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span>, then we can’t use <code>isP</code> to decide anything, because it always returns <code>false</code>. Similarly, if <i>every</i> function satisfies <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span>, then we can’t use <code>isP</code> to decide anything, because it always returns <code>true</code>.</p><p>This is what Rice means by <b>triviality.</b> The property <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span> is trivial if all functions satisfy it, or if none do. To show that <code>isP</code> cannot be written, Rice’s proof requires that <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span></span> is non-trivial: that it is satisfied by some, but not all, functions.</p><p aria-hidden="true"><h2><span id="conclusion"></span>Conclusion</h2></p><p>And this concludes the proof! Quoting Wikipedia: “Rice’s theorem states that all non-trivial semantic properties of programs are undecidable.” By now, you should understand what that theorem means, how to prove it, and why those “non-trivial semantic” qualifications are in there.</p><p>In the next chapter, we’ll be exploring Kurt Gödel’s second incompleteness theorem, which shows that proof systems can’t prove their own consistency! Stay tuned!</p><p><b>This chapter is free this week — to read the rest of </b><a href="https://tigyog.app/d/C:tWWwvJDWlo/r/busy-beavers"><i><b>Busy Beavers</b></i></a><b> and support me writing it, please buy the course! Or if you want to know when the next chapter comes out, </b><a href="https://tigyog.app/d/C:tWWwvJDWlo/enrollment"><b>sign up for updates here.</b></a><b> You might also enjoy our course </b><a href="https://tigyog.app/d/C-I1weB9CpTH/r/everyday-data-science"><i><b>Everyday Data Science</b></i></a><b>, which uses similar interactive storytelling. Or if you’re feeling inspired, you can use </b><a href="https://tigyog.app/"><b>TigYog</b></a><b> to write your own course just like these ones!</b></p></div></div>
  </body>
</html>
