<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2022/07/24/round-a-direction-vector-to-the-nearest-8-way-compass/">Original</a>
    <h1>Round a direction vector to an 8-way compass</h1>
    
    <div id="readability-page-1" class="page"><article id="post-19828">

<div>
<p>Modern game controllers can point in a wide range of directions. Game designers sometimes want to <a href="https://forum.unity.com/threads/does-anyone-know-how-to-get-8-directional-movement-with-a-joystick.767129/">convert the joystick direction to getÂ 8-directional movement</a>. A typical solution offered is to compute the angle, round it up and then compute back the direction vector.</p>
<pre>  <span>double</span> angle <span>=</span> <span>atan2</span><span>(</span>y<span>,</span> x<span>)</span><span>;</span>
  angle <span>=</span> <span>(</span><span>int</span><span>(</span>round<span>(</span><span>4</span> <span>*</span> angle <span>/</span> PI <span>+</span> <span>8</span><span>)</span><span>)</span> <span>%</span> <span>8</span><span>)</span> <span>*</span> PI <span>/</span> <span>4</span><span>;</span>
  xout <span>=</span> <span>cos</span><span>(</span>angle<span>)</span><span>;</span>
  yout <span>=</span> <span>sin</span><span>(</span>angle<span>)</span><span>;</span>
</pre>
<p>If you assume that the unit direction vector is in the first quadrant (both x and y are positive), then there is a direct way to compute the solution. Using 1/sqrt(2) or 0.7071 as the default solution, compare both x and y with cos(3*pi/8) and cos(pi/8), and only switch them to 1 or 0 if they are larger than cos(3*pi/8) or smaller than cos(pi/8). The full code looks as follows:</p>
<pre>  xout <span>=</span> <span>0.7071067811865475</span><span>;</span>
  yout <span>=</span> <span>0.7071067811865475</span><span>;</span>

  <span>if</span> <span>(</span>x <span>&gt;</span><span>=</span> <span>0.923879532511286</span><span>)</span> <span>{</span><span>// cos(3*pi/8)</span>
    xout <span>=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>y <span>&gt;</span><span>=</span> <span>0.923879532511286</span><span>)</span> <span>{</span><span>// cos(3*pi/8)</span>
    yout <span>=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>x <span>&lt;</span> <span>0.3826834323650898</span><span>)</span> <span>{</span><span>// cos(pi/8)</span>
    xout <span>=</span> <span>0</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>y <span>&lt;</span> <span>0.3826834323650898</span><span>)</span> <span>{</span><span>// cos(pi/8)</span>
    yout <span>=</span> <span>0</span><span>;</span>
  <span>}</span>
</pre>
<p>You can generalize the solution for the case where either x or y (or both) are negative by first taking the absolute value, and then restoring the sign at the end:</p>
<pre>  bool xneg <span>=</span> x <span>&lt;</span> <span>0</span><span>;</span>
  bool yneg <span>=</span> y <span>&lt;</span> <span>0</span><span>;</span>
  <span>if</span> <span>(</span>xneg<span>)</span> <span>{</span>
    x <span>=</span> <span>-</span>x<span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>yneg<span>)</span> <span>{</span>
    y <span>=</span> <span>-</span>y<span>;</span>
  <span>}</span>
  <span>double</span> outx <span>=</span> <span>0.7071067811865475</span><span>;</span>
  <span>double</span> outy <span>=</span> <span>0.7071067811865475</span><span>;</span>

  <span>if</span> <span>(</span>x <span>&gt;</span><span>=</span> <span>0.923879532511286</span><span>)</span> <span>{</span><span>// cos(3*pi/8)</span>
    outx <span>=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>y <span>&gt;</span><span>=</span> <span>0.923879532511286</span><span>)</span> <span>{</span><span>// cos(3*pi/8)</span>
    outy <span>=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>x <span>&lt;</span> <span>0.3826834323650898</span><span>)</span> <span>{</span><span>// cos(pi/8)</span>
    outx <span>=</span> <span>0</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>y <span>&lt;</span> <span>0.3826834323650898</span><span>)</span> <span>{</span><span>// cos(pi/8)</span>
    outy <span>=</span> <span>0</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>xneg<span>)</span> <span>{</span>
    outx <span>=</span> <span>-</span>outx<span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>yneg<span>)</span> <span>{</span>
    outy <span>=</span> <span>-</span>outy<span>;</span>
  <span>}</span>
</pre>
<p><a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2022/07/24">I wrote a small benchmark that operates on random inputs</a>. Your results will vary but on my mac laptop with LLVM 12, I get that the direct approach is 25 times faster.</p>
<table>
<tbody>
<tr>
<td>with tangent</td>
<td>40 ns/vector</td>
</tr>
<tr>
<td>fast approach</td>
<td>1.5 ns/vector</td>
</tr>
</tbody>
</table>
</div>
<div>

<p><img alt="" src="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=112&amp;d=mm&amp;r=g 2x" height="56" width="56" loading="lazy"/> </p>

</div>

</article></div>
  </body>
</html>
