<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/JuliaDebug/Cthulhu.jl">Original</a>
    <h1>Cthulhu.jl – show type-inferred Julia code</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><em>The slow descent into madness</em></p>
<p dir="auto"><g-emoji alias="warning">⚠️</g-emoji> The latest stable version is only compatible with Julia v1.8.5 and higher.</p>
<p dir="auto">Cthulhu can help you debug type inference issues by recursively showing the
type-inferred code until you find the exact point where inference gave up,
messed up, or did something unexpected. Using the Cthulhu interface, you can
debug type inference problems faster.</p>
<p dir="auto">Cthulhu&#39;s main tool, <code>descend</code>, can be invoked like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="descend(f, tt)     # function `f` and Tuple `tt` of argument types
@descend f(args)   # normal call"><pre><span>descend</span>(f, tt)     <span><span>#</span> function `f` and Tuple `tt` of argument types</span>
<span>@descend</span> <span>f</span>(args)   <span><span>#</span> normal call</span></pre></div>
<p dir="auto"><code>descend</code> allows you to interactively explore the type-annotated source
code by descending into the callees of <code>f</code>.
Press enter to select a call to descend into, select ↩  to ascend,
and press q or control-c to quit.
You can also toggle various aspect of the view, for example to suppress
&#34;type-stable&#34; (concretely inferred) annotations or view non-concrete
types in red.
Currently-active options are highlighted with color; press the corresponding
key to toggle these options. Below we walk through a simple example of
these interactive features; you can also see Cthulhu v2.8 in action in
<a href="https://youtu.be/pvduxLowpPY" rel="nofollow">this video</a>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-usage-descend" aria-hidden="true" tabindex="-1" href="#usage-descend"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage: descend</h2>
<div dir="auto" data-snippet-clipboard-copy-content="function foo()
    T = rand() &gt; 0.5 ? Int64 : Float64
    sum(rand(T, 100))
end

descend(foo, Tuple{})     # option 1: specify by function name and argument types
@descend foo()            # option 2: apply `@descend` to a working execution of the function"><pre><span>function</span> <span>foo</span>()
    T <span>=</span> <span>rand</span>() <span>&gt;</span> <span>0.5</span> <span>?</span> Int64 <span>:</span> Float64
    <span>sum</span>(<span>rand</span>(T, <span>100</span>))
<span>end</span>

<span>descend</span>(foo, Tuple{})     <span><span>#</span> option 1: specify by function name and argument types</span>
<span>@descend</span> <span>foo</span>()            <span><span>#</span> option 2: apply `@descend` to a working execution of the function</span></pre></div>
<p dir="auto">If you do this, you&#39;ll see quite a bit of text output. Let&#39;s break it down and
see it section-by-section. At the top, you may see something like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/images_readme/descend_source_show_all.png"><img src="https://github.com/JuliaDebug/Cthulhu.jl/raw/master/images_readme/descend_source_show_all.png" alt="source-section-all"/></a></p>
<p dir="auto">This shows your original source code (together with line numbers, which here were in the REPL).
The cyan annotations are the types of the variables: <code>Union{Float64, Int64}</code> means &#34;either a <code>Float64</code>
or an <code>Int64</code>&#34;.
Small <em>concrete</em> unions (where all the possibilities are known exactly) are generally are not a problem
for type inference, unless there are so many that Julia stops trying to work
out all the different combinations (see <a href="https://julialang.org/blog/2018/08/union-splitting/" rel="nofollow">this blog post</a>
for more information).</p>
<p dir="auto"><strong>Note</strong>: if the function has default positional or keyword arguments, you may see only the signature
of the function. Internally, Julia creates additional methods to fill in default arguments, which in turn call the &#34;body&#34; method that appears in the source text. If you&#39;re descending into one of these &#34;default-filling&#34; functions,
you won&#39;t be able to see types on variables that appear in the body method, so to reduce confusing the entire body is eliminated. You&#39;ll have an opportunity to descend further into the &#34;body&#34; method in the &#34;call menu&#34; described below.</p>
<p dir="auto">In the next section you may see something like</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/images_readme/descend_toggles.png"><img src="https://github.com/JuliaDebug/Cthulhu.jl/raw/master/images_readme/descend_toggles.png" alt="toggles"/></a></p>
<p dir="auto">This section shows you some interactive options you have for controlling the display.
Normal text inside <code>[]</code> generally indicates &#34;off&#34;, and color is used for &#34;on&#34; or specific options.
For example, if you hit <code>w</code> to turn on warnings, now you should see something like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/images_readme/descend_source_toggles_warn.png"><img src="https://github.com/JuliaDebug/Cthulhu.jl/raw/master/images_readme/descend_source_toggles_warn.png" alt="warn"/></a></p>
<p dir="auto">Note that the <code>w</code> in the <code>[w]arn</code> toggle is now shown in cyan, indicating that it is &#34;on.&#34;
Now you can see small concrete unions in yellow, and concretely inferred code in cyan.
Serious forms of poor inferrability are colored in red (of which there are none in this example);
these generally hurt runtime performance and may make compiled code more vulnerable to being invalidated.</p>
<p dir="auto">In the final section, you see:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/images_readme/descend_calls.png"><img src="https://github.com/JuliaDebug/Cthulhu.jl/raw/master/images_readme/descend_calls.png" alt="calls"/></a></p>
<p dir="auto">This is a menu of calls that you can further descend into. Move the dot <code>•</code> with the up and down
arrow keys, and hit Enter to descend into a particular call. Note that the naming of calls can sometimes
vary from what you see in the source-text; for example, if you&#39;re descending into kwarg-function <code>foo</code>,
then the &#34;body&#34; function might be called something like <code>#foo#123</code>.</p>
<p dir="auto">Any calls that are made at runtime (<a href="https://en.wikipedia.org/wiki/Dynamic_dispatch" rel="nofollow">dynamic dispatch</a>) cannot be descended into;
if you select one, you&#39;ll see</p>
<div data-snippet-clipboard-copy-content="[ Info: This is a runtime call. You cannot descend into it."><pre><code>[ Info: This is a runtime call. You cannot descend into it.
</code></pre></div>
<p dir="auto">and the call menu will be printed again.</p>
<p dir="auto">Calls that start with <code>%nn = ...</code> are in Julia&#39;s internal
<a href="https://docs.julialang.org/en/v1/devdocs/ast/" rel="nofollow">Abstract Syntax Tree (AST)</a> form;
for these calls, Cthulhu and/or <a href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/TypedSyntax/README.md">TypedSyntax</a> (a sub-package living inside the Cthulhu repository) failed to &#34;map&#34; the call back to the original source code.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-caveats" aria-hidden="true" tabindex="-1" href="#caveats"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Caveats</h2>
<p dir="auto">As a word of warning, <strong>mapping type inference results back to the source is hard, and there may be errors or omissions in this mapping</strong>. See the <a href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/TypedSyntax/README.md">TypedSyntax README</a> for further details about the challenges. When you think there are reasons to doubt what you&#39;re seeing, a reliable but harder-to-interpret strategy is to directly view the <a href="#viewing-the-internal-representation-of-julia-code"><code>[T]yped code</code></a> rather than the <code>[S]ource code</code>.</p>
<p dir="auto">For problems you encounter, please consider filing issues for (and/or making pull requests to fix) any failures you observe. See <a href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> for tips on filing effective bug reports.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-methods-descend" aria-hidden="true" tabindex="-1" href="#methods-descend"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Methods: descend</h2>
<ul dir="auto">
<li><code>@descend_code_typed</code></li>
<li><code>descend_code_typed</code></li>
<li><code>@descend_code_warntype</code></li>
<li><code>descend_code_warntype</code></li>
<li><code>@descend</code>: Shortcut for <code>@descend_code_typed</code></li>
<li><code>descend</code>: Shortcut for <code>descend_code_typed</code></li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-usage-ascend" aria-hidden="true" tabindex="-1" href="#usage-ascend"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage: ascend</h2>
<p dir="auto">Cthulhu also provides the &#34;upwards-looking&#34; <code>ascend</code>. While <code>descend</code> allows
you to explore a call tree starting from the outermost caller, <code>ascend</code>
allows you to explore a call chain or tree starting from the innermost
callee. Its primary purpose is to support analysis of invalidation and inference
triggers in conjunction with <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile</a>,
but you can use it as a standalone tool.
There is a <a href="https://www.youtube.com/watch?v=7VbXbI6OmYo" rel="nofollow">video using ascend to fix invalidations</a>,
where the part on <code>ascend</code> starts at minute 4:55.</p>
<p dir="auto">For example, you can use it to examine all the inferred callers of a method instance:</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; m = which(length, (Set{Symbol},))
length(s::Set) in Base at set.jl:55

julia&gt; mi = m.specializations[1]      # or `mi = first(Base.specializations(m))` on Julia 1.10+
MethodInstance for length(::Set{Symbol})

julia&gt; ascend(mi)
Choose a call for analysis (q to quit):
 &gt;   length(::Set{Symbol})
       union!(::Set{Symbol}, ::Vector{Symbol})
         Set{Symbol}(::Vector{Symbol})
         intersect!(::Set{Union{Int64, Symbol}}, ::Vector{Symbol})
           _shrink(::typeof(intersect!), ::Vector{Union{Int64, Symbol}}, ::Tuple{Vector{Symbol}})
             intersect(::Vector{Union{Int64, Symbol}}, ::Vector{Symbol})
       union!(::Set{Symbol}, ::Set{Symbol})
         union!(::Set{Symbol}, ::Set{Symbol}, ::Set{Symbol})
           union(::Set{Symbol}, ::Set{Symbol})"><pre>julia<span>&gt;</span> m <span>=</span> <span>which</span>(length, (Set{Symbol},))
<span>length</span>(s<span>::</span><span>Set</span>) <span>in</span> Base at set<span>.</span>jl<span>:</span><span>55</span>

julia<span>&gt;</span> mi <span>=</span> m<span>.</span>specializations[<span>1</span>]      <span><span>#</span> or `mi = first(Base.specializations(m))` on Julia 1.10+</span>
MethodInstance <span>for</span> <span>length</span>(<span>::</span><span>Set{Symbol}</span>)

julia<span>&gt;</span> <span>ascend</span>(mi)
Choose a call <span>for</span> analysis (q to quit)<span>:</span>
 <span>&gt;</span>   <span>length</span>(<span>::</span><span>Set{Symbol}</span>)
       <span>union!</span>(<span>::</span><span>Set{Symbol}</span>, <span>::</span><span>Vector{Symbol}</span>)
         <span>Set</span><span>{Symbol}</span>(<span>::</span><span>Vector{Symbol}</span>)
         <span>intersect!</span>(<span>::</span><span>Set{Union{Int64, Symbol}}</span>, <span>::</span><span>Vector{Symbol}</span>)
           <span>_shrink</span>(<span>::</span><span>typeof</span>(intersect!), <span>::</span><span>Vector{Union{Int64, Symbol}}</span>, <span>::</span><span>Tuple{Vector{Symbol}}</span>)
             <span>intersect</span>(<span>::</span><span>Vector{Union{Int64, Symbol}}</span>, <span>::</span><span>Vector{Symbol}</span>)
       <span>union!</span>(<span>::</span><span>Set{Symbol}</span>, <span>::</span><span>Set{Symbol}</span>)
         <span>union!</span>(<span>::</span><span>Set{Symbol}</span>, <span>::</span><span>Set{Symbol}</span>, <span>::</span><span>Set{Symbol}</span>)
           <span>union</span>(<span>::</span><span>Set{Symbol}</span>, <span>::</span><span>Set{Symbol}</span>)</pre></div>
<p dir="auto">You use the up/down arrows to navigate this menu, enter to select a call to <code>descend</code> into,
and your space bar to toggle branch-folding.</p>
<p dir="auto">It also works on stacktraces. If your version of Julia stores the most recent error in the global <code>err</code> variable, you can use</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Cthulhu

julia&gt; sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(f::Symbol, x::Float64)
   @ Base.Math ./math.jl:33
 [2] sqrt
   @ ./math.jl:677 [inlined]
 [3] sqrt(x::Int64)
   @ Base.Math ./math.jl:1491
 [4] top-level scope
   @ REPL[1]:1

julia&gt; ascend(err)
Choose a call for analysis (q to quit):
 &gt;   throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:33
       sqrt(::Int64) at ./math.jl:1491"><pre>julia<span>&gt;</span> <span>using</span> Cthulhu

julia<span>&gt;</span> <span>sqrt</span>(<span>-</span><span>1</span>)
ERROR<span>:</span> DomainError with <span>-</span><span>1.0</span><span>:</span>
sqrt will only <span>return</span> a complex result <span>if</span> called with a complex argument. Try <span>sqrt</span>(<span>Complex</span>(x)).
Stacktrace<span>:</span>
 [<span>1</span>] <span>throw_complex_domainerror</span>(f<span>::</span><span>Symbol</span>, x<span>::</span><span>Float64</span>)
   @ Base<span>.</span>Math <span>./</span>math<span>.</span>jl<span>:</span><span>33</span>
 [<span>2</span>] sqrt
   @ <span>./</span>math<span>.</span>jl<span>:</span><span>677</span> [inlined]
 [<span>3</span>] <span>sqrt</span>(x<span>::</span><span>Int64</span>)
   @ Base<span>.</span>Math <span>./</span>math<span>.</span>jl<span>:</span><span>1491</span>
 [<span>4</span>] top<span>-</span>level scope
   @ REPL[<span>1</span>]<span>:</span><span>1</span>

julia<span>&gt;</span> <span>ascend</span>(err)
Choose a call <span>for</span> analysis (q to quit)<span>:</span>
 <span>&gt;</span>   <span>throw_complex_domainerror</span>(<span>::</span><span>Symbol</span>, <span>::</span><span>Float64</span>) at <span>./</span>math<span>.</span>jl<span>:</span><span>33</span>
       <span>sqrt</span>(<span>::</span><span>Int64</span>) at <span>./</span>math<span>.</span>jl<span>:</span><span>1491</span></pre></div>
<p dir="auto">If this isn&#39;t available to you, a more &#34;manual&#34; approach is:</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; bt = try
           [sqrt(x) for x in [1, -1]]
       catch
           catch_backtrace()
       end;

julia&gt; ascend(bt)
Choose a call for analysis (q to quit):
 &gt;   throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:33
       sqrt at ./math.jl:582 =&gt; sqrt at ./math.jl:608 =&gt; iterate at ./generator.jl:47 =&gt; collect_to! at ./array.jl:710 =&gt; collect_to_with_first!(::Vector{Float64}, ::Float64, ::Base.Generator{Vector{Int64}, typeof(sqrt)}, ::Int64) at ./array.jl:688
         collect(::Base.Generator{Vector{Int64}, typeof(sqrt)}) at ./array.jl:669
           eval(::Module, ::Any) at ./boot.jl:360
             eval_user_input(::Any, ::REPL.REPLBackend) at /home/tim/src/julia-master/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:139
..."><pre>julia<span>&gt;</span> bt <span>=</span> <span>try</span>
           [<span>sqrt</span>(x) <span>for</span> x <span>in</span> [<span>1</span>, <span>-</span><span>1</span>]]
       <span>catch</span>
           <span>catch_backtrace</span>()
       <span>end</span>;

julia<span>&gt;</span> <span>ascend</span>(bt)
Choose a call <span>for</span> analysis (q to quit)<span>:</span>
 <span>&gt;</span>   <span>throw_complex_domainerror</span>(<span>::</span><span>Symbol</span>, <span>::</span><span>Float64</span>) at <span>./</span>math<span>.</span>jl<span>:</span><span>33</span>
       sqrt at <span>./</span>math<span>.</span>jl<span>:</span><span>582</span> <span>=&gt;</span> sqrt at <span>./</span>math<span>.</span>jl<span>:</span><span>608</span> <span>=&gt;</span> iterate at <span>./</span>generator<span>.</span>jl<span>:</span><span>47</span> <span>=&gt;</span> collect_to! at <span>./</span>array<span>.</span>jl<span>:</span><span>710</span> <span>=&gt;</span> <span>collect_to_with_first!</span>(<span>::</span><span>Vector{Float64}</span>, <span>::</span><span>Float64</span>, <span>::</span><span>Base.Generator{Vector{Int64}, typeof(sqrt)}</span>, <span>::</span><span>Int64</span>) at <span>./</span>array<span>.</span>jl<span>:</span><span>688</span>
         <span>collect</span>(<span>::</span><span>Base.Generator{Vector{Int64}, typeof(sqrt)}</span>) at <span>./</span>array<span>.</span>jl<span>:</span><span>669</span>
           <span>eval</span>(<span>::</span><span>Module</span>, <span>::</span><span>Any</span>) at <span>./</span>boot<span>.</span>jl<span>:</span><span>360</span>
             <span>eval_user_input</span>(<span>::</span><span>Any</span>, <span>::</span><span>REPL.REPLBackend</span>) at <span>/</span>home<span>/</span>tim<span>/</span>src<span>/</span>julia<span>-</span>master<span>/</span>usr<span>/</span>share<span>/</span>julia<span>/</span>stdlib<span>/</span>v1.<span>6</span><span>/</span>REPL<span>/</span>src<span>/</span>REPL<span>.</span>jl<span>:</span><span>139</span>
<span>...</span></pre></div>
<p dir="auto">The calls that appear on the same line separated by <code>=&gt;</code> represent inlined methods; when you select such a line,
you enter at the final (topmost) call on that line.</p>
<p dir="auto">Using Cthulhu may be particularly useful for <code>MethodError</code>s, since those exist purely in the type-domain.</p>
<p dir="auto">By default,</p>
<ul dir="auto">
<li><code>descend</code> views non-optimized code without &#34;warn&#34; coloration of types</li>
<li><code>ascend</code> views non-optimized code with &#34;warn&#34; coloration</li>
</ul>
<p dir="auto">You can toggle between these with <code>o</code> and <code>w</code>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-combine-static-and-runtime-information" aria-hidden="true" tabindex="-1" href="#combine-static-and-runtime-information"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Combine static and runtime information</h2>
<p dir="auto">Cthulhu has access only to &#34;static&#34; type information, the same information available to the Julia compiler and type inference.
In some situations, this will lead to incomplete or misleading information about type instabilities.</p>
<p dir="auto">Take for example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="using Infiltrator: @infiltrate
using Cthulhu: @descend
using Base: @noinline # already exported, but be explcit

function foo(n)
    x = n &lt; 2 ? 2 * n : 2.5 * n
    y = n &lt; 4 ? 3 * n : 3.5 * n
    z = n &lt; 5 ? 4 * n : 4.5 * n
    # on Julia v1.6, there is no union splitting for this number of cases.
    bar(x, y, z)
end

@noinline function bar(x, y, z)
    string(x + y + z)
end"><pre><span>using</span> Infiltrator<span>:</span> <span>@infiltrate</span>
<span>using</span> Cthulhu<span>:</span> <span>@descend</span>
<span>using</span> Base<span>:</span> <span>@noinline</span> <span><span>#</span> already exported, but be explcit</span>

<span>function</span> <span>foo</span>(n)
    x <span>=</span> n <span>&lt;</span> <span>2</span> <span>?</span> <span>2</span> <span>*</span> n <span>:</span> <span>2.5</span> <span>*</span> n
    y <span>=</span> n <span>&lt;</span> <span>4</span> <span>?</span> <span>3</span> <span>*</span> n <span>:</span> <span>3.5</span> <span>*</span> n
    z <span>=</span> n <span>&lt;</span> <span>5</span> <span>?</span> <span>4</span> <span>*</span> n <span>:</span> <span>4.5</span> <span>*</span> n
    <span><span>#</span> on Julia v1.6, there is no union splitting for this number of cases.</span>
    <span>bar</span>(x, y, z)
<span>end</span>

<span>@noinline</span> <span>function</span> <span>bar</span>(x, y, z)
    <span>string</span>(x <span>+</span> y <span>+</span> z)
<span>end</span></pre></div>
<p dir="auto">Then invoke:</p>

<p dir="auto">Now, descend into <code>bar</code>: move the cursor down (or wrap around by hitting the up arrow) until
the dot is next to the <code>bar</code> call:</p>
<div data-snippet-clipboard-copy-content=" ⋮
   4  (4.5 * n::Int64)::Float64
 • 6 bar(x, y, z)
   ↩"><pre><code> ⋮
   4  (4.5 * n::Int64)::Float64
 • 6 bar(x, y, z)
   ↩
</code></pre></div>
<p dir="auto">and then hit Enter. Then you will see the code for <code>bar</code> with its type annotations.</p>
<p dir="auto">Notice that many variables are annotated as <code>Union</code>.
To give Cthulhu more complete type information, we have to actually run some Julia code. There are many ways to do this. In this example, we use <a href="https://github.com/JuliaDebug/Infiltrator.jl"><code>Infiltrator.jl</code></a>.</p>
<p dir="auto">Add an <code>@infiltrate</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="function foo(n)
    x = n &lt; 2 ? 2 * n : 2.5 * n
    y = n &lt; 4 ? 3 * n : 3.5 * n
    z = n &lt; 5 ? 4 * n : 4.5 * n
    # on Julia v1.6, there is no union splitting for this number of cases.
    @infiltrate
    bar(x, y, z)
end

@noinline function bar(x, y, z)
    string(x + y + z)
end"><pre><span>function</span> <span>foo</span>(n)
    x <span>=</span> n <span>&lt;</span> <span>2</span> <span>?</span> <span>2</span> <span>*</span> n <span>:</span> <span>2.5</span> <span>*</span> n
    y <span>=</span> n <span>&lt;</span> <span>4</span> <span>?</span> <span>3</span> <span>*</span> n <span>:</span> <span>3.5</span> <span>*</span> n
    z <span>=</span> n <span>&lt;</span> <span>5</span> <span>?</span> <span>4</span> <span>*</span> n <span>:</span> <span>4.5</span> <span>*</span> n
    <span><span>#</span> on Julia v1.6, there is no union splitting for this number of cases.</span>
    <span>@infiltrate</span>
    <span>bar</span>(x, y, z)
<span>end</span>

<span>@noinline</span> <span>function</span> <span>bar</span>(x, y, z)
    <span>string</span>(x <span>+</span> y <span>+</span> z)
<span>end</span></pre></div>
<p dir="auto">Now invoke <code>foo</code> to get REPL in the scope just before <code>bar</code> gets called:</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; foo(4)
Infiltrating foo(n::Int64) at ex.jl:10:

infil&gt;"><pre>julia<span>&gt;</span> <span>foo</span>(<span>4</span>)
Infiltrating <span>foo</span>(n<span>::</span><span>Int64</span>) at ex<span>.</span>jl<span>:</span><span>10</span><span>:</span>

infil<span>&gt;</span></pre></div>
<p dir="auto">Enter <code>@descend bar(x, y, z)</code> you can see that, for <code>foo(4)</code>, the types within <code>bar</code> are fully inferred.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-viewing-the-internal-representation-of-julia-code" aria-hidden="true" tabindex="-1" href="#viewing-the-internal-representation-of-julia-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Viewing the internal representation of Julia code</h2>
<p dir="auto">Anyone using Cthulhu to investigate the behavior of Julia&#39;s compiler will
prefer to examine the
While Cthulhu tries to place type-annotations on the source code, this obscures
detail and can occassionally go awry (see details <a href="https://github.com/JuliaDebug/Cthulhu.jl/blob/master/TypedSyntax/README.md">here</a>).
For anyone who needs more direct insight, it can be better to look directly at Julia&#39;s
internal representations of type-inferred code.
Looking at type-inferred code can be a bit daunting initially, but you grow more
comfortable with practice. Consider starting with a
<a href="https://juliadebug.github.io/JuliaInterpreter.jl/stable/ast/" rel="nofollow">tutorial on &#34;lowered&#34; representation</a>,
which introduces most of the new concepts. Type-inferrred code differs from
lowered representation by having additional type annotation.
Moreover, <code>call</code> statements that can be inferred are converted to <code>invoke</code>s
(these correspond to static dispatch), whereas dynamic dispatch is indicated by the
remaining <code>call</code> statements.
Depending on whether you&#39;re looking at optimized or non-optimized code,
it may also incorporate inlining and other fairly significant transformations
of the original code as written by the programmer.</p>
<p dir="auto">This video demonstrates Cthulhu for viewing &#34;raw&#34; type-inferred code:
<a href="https://www.youtube.com/watch?v=qf9oA09wxXY" rel="nofollow">Watch on YouTube</a>
<a href="https://www.youtube.com/watch?v=qf9oA09wxXY" rel="nofollow"><img src="https://camo.githubusercontent.com/bd5cf77f33b7b5ae78789025d8a73776292a20cdbe4bc06e97957a8b8ec6273e/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f7166396f413039777858592f302e6a7067" alt="Click to watch video" data-canonical-src="https://img.youtube.com/vi/qf9oA09wxXY/0.jpg"/></a></p>
<p dir="auto">The version of Cthulhu in the demo is a little outdated, without the newest features,
but may still be relevant for users who want to view code at this level of detail.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-customization" aria-hidden="true" tabindex="-1" href="#customization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Customization</h2>
<p dir="auto">The default configuration of toggles in the <code>@descend</code> menu can be customized
with <code>Cthulhu.CONFIG</code> and persistently saved (via Preferences.jl) using
<code>Cthulhu.save_config!()</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; Cthulhu.CONFIG.enable_highlighter = true # Change default
true

julia&gt; Cthulhu.save_config!(Cthulhu.CONFIG) # Will be automatically read next time you `using Cthulhu`"><pre>julia<span>&gt;</span> Cthulhu<span>.</span>CONFIG<span>.</span>enable_highlighter <span>=</span> <span>true</span> <span><span>#</span> Change default</span>
<span>true</span>

julia<span>&gt;</span> Cthulhu<span>.</span><span>save_config!</span>(Cthulhu<span>.</span>CONFIG) <span><span>#</span> Will be automatically read next time you `using Cthulhu`</span></pre></div>
</article>
          </div></div>
  </body>
</html>
