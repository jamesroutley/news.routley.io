<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.germanvelasco.com/blog/phoenix-1-7-is-view-less">Original</a>
    <h1>Phoenix 1.7 is View-less</h1>
    
    <div id="readability-page-1" class="page"><div>
      <iframe src="https://www.youtube.com/embed/h-803kOXq3g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">
</iframe>

<p><a href="https://phoenixframework.org/blog/phoenix-1.7-released">Phoenix 1.7-rcâ€™s announcement</a> mentions that Phoenix is
dropping <a href="https://hexdocs.pm/phoenix_view/Phoenix.View.html"><code>Phoenix.View</code></a>.</p>

<p>But donâ€™t worry. Itâ€™s for a good reason.</p>

<blockquote>
  <p>Phoenix team unified the HTML rendering approaches whether from a controller
request, or a LiveView.</p>
</blockquote>

<p>So, controllers and LiveViews will both render function components!</p>

<p>Hereâ€™s how it works. ðŸ‘‡</p>

<h2 id="function-components-instead-of-views">Function components instead of views</h2>

<p>Controllers now render templates via format-based Elixir modules (the
announcement still calls them <em>view modules</em>).</p>

<p>Suppose we have the following route:</p>

<div><div><pre><code> <span>get</span> <span>&#34;/greet&#34;</span><span>,</span> <span>GreetController</span><span>,</span> <span>:hello</span>
</code></pre></div></div>

<p>That means we need a <code>GreetController</code> with a <code>hello</code> action (I know, itâ€™s not
restful, but itâ€™s just an example! ðŸ˜‰)</p>

<p>Our controller code doesnâ€™t change (we could use the <code>params</code> and define
<code>assigns</code>, but you get the idea):</p>

<div><div><pre><code><span>defmodule</span> <span>ScoutWeb</span><span>.</span><span>GreetController</span> <span>do</span>
  <span>use</span> <span>ScoutWeb</span><span>,</span> <span>:controller</span>

  <span>def</span> <span>hello</span><span>(</span><span>conn</span><span>,</span> <span>_</span><span>)</span> <span>do</span>
    <span>render</span><span>(</span><span>conn</span><span>,</span> <span>:hello</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Now hereâ€™s where things get different.</p>

<p>Before Phoenix 1.7, our controller would expect a <code>GreetView</code> with a
<code>render(&#34;hello.html&#34;, assigns)</code> function, or our <code>GreetView</code> would expect to
find a <em><code>hello.html.eex</code></em> template under the <em><code>views/greet/</code></em> directory.</p>

<p>Now, our controller expects us to define a <code>GreetHTML</code> (notice the caps in
<code>HTML</code> for the format weâ€™re rendering). And it expects us to define that
view-like module <strong>next</strong> to the <em><code>greet_controller.ex</code></em> module:</p>

<blockquote>
  <p>Additionally, we have collocated the view modules next to their controller
files. This brings the same benefits of LiveView collocation â€“Â highly coupled
files live together. Files that must change together now live together,
whether writing LiveView or controller features.</p>
</blockquote>

<p>The <code>GreetHTML</code> needs to <code>use ScoutWeb, :html</code> and:</p>

<ul>
  <li>Define a <code>hello</code> function component inside <code>GreetHTML</code>, or</li>
  <li>Collocate a <em>hello.html.heex</em> template based on what <code>embed_templates</code> defines.</li>
</ul>

<p>Letâ€™s take a look at both.</p>

<h3 id="function-component">Function component</h3>

<p>We can define a <code>hello</code> function component like this:</p>

<div><div><pre><code><span>defmodule</span> <span>GreetHTML</span> <span>do</span>
  <span>use</span> <span>ScoutWeb</span><span>,</span> <span>:html</span>

  <span>def</span> <span>hello</span><span>(</span><span>assigns</span><span>)</span> <span>do</span>
    <span>~H&#34;&#34;</span><span>&#34;
    &lt;h1&gt;Hello world!&lt;/h1&gt;
    &#34;&#34;&#34;</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Notice how we can include the <code>~H</code> sigil directly inside the <code>hello</code> function.
Thatâ€™s because <code>use ScoutWeb, :html</code> declares our <code>GreetHTML</code> to <code>use
Phoenix.Component</code>. If youâ€™ve used LiveView, that should look eerily familiar.</p>

<p>But maybe inline components arenâ€™t your style. No worries.</p>

<h3 id="embedding-templates">Embedding templates</h3>

<p>Our <code>GreetHTML</code> can specify where to find our templates (instead of relying on
the <em><code>views/greet/</code></em> convention). But keep in mind that the idea is to collocate
our templates next to our <code>GreetHTML</code> module!</p>

<p>So, we specify where to find the templates with the new <code>embed_templates</code> macro:</p>

<div><div><pre><code><span>defmodule</span> <span>GreetHTML</span> <span>do</span>
  <span>use</span> <span>ScoutWeb</span><span>,</span> <span>:html</span>

  <span>embed_templates</span> <span>&#34;greet/*&#34;</span>
<span>end</span>
</code></pre></div></div>

<p>We can now create a <code>greet/hello.html.heex</code> template and include the following:</p>



<p>As you can see, <em>everything</em> is now defined under the <em><code>controllers/</code></em> directory:</p>

<div><div><pre><code>lib/scout_web/controllers
â”œâ”€â”€ greet_controller.ex
â”œâ”€â”€ greet_html
â”‚Â Â  â””â”€â”€ hello.html.heex
â”œâ”€â”€ greet_html.ex
</code></pre></div></div>

<p>Iâ€™m not sure I like it all being under <code>controllers</code> since that directory no
longer solely contains controllers, but maybe Iâ€™ll grow accustomed to it (or,
perhaps, we can find a different name in time). But I think itâ€™s great to have
everything in the same place.</p>

<p>And I like that it works very similarly to LiveViewâ€”where we either render
the component inline via <code>~H</code> or create the template next to the LiveView by
default.</p>

<h3 id="did-we-lose-any-view-goodness">Did we lose any View goodness?</h3>

<p>The beauty is that I donâ€™t think weâ€™ve lost the nice things from <code>Phoenix.View</code>.</p>

<p>For example, if we reference a function in the collocated template, it should be
defined in that <code>GreetHTML</code> moduleâ€”which acts like our view modules did
before.</p>

<p>So, if we were to have the following in our <code>hello.html.heex</code> template:</p>

<div><div><pre><code><span>&lt;h1&gt;</span><span>&lt;%=</span> <span>greeting</span><span>()</span> <span>%&gt;</span><span>&lt;/h1&gt;</span>
</code></pre></div></div>

<p>We would define that function inside the <code>GreetHTML</code> module:</p>

<div><div><pre><code><span>defmodule</span> <span>GreetHTML</span> <span>do</span>
  <span>use</span> <span>ScoutWeb</span><span>,</span> <span>:html</span>

  <span>embed_templates</span> <span>&#34;greet/*&#34;</span>

  <span>def</span> <span>greeting</span> <span>do</span>
    <span>&#34;Hello world!&#34;</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<h2 id="how-do-i-migrate-my-codebase">How do I migrate my codebase?</h2>

<p>The changes in Phoenix 1.7 are backwards compatible. If you want to keep using
<code>Phoenix.View</code>, you can do so by adding <code>:phoenix_view</code> as a dependency.</p>

<p>But if you want to migrate to the new component-based format, you can follow
<code>Phoenix.Views</code>â€™ guides on <a href="https://hexdocs.pm/phoenix_view/Phoenix.View.html#module-migrating-to-phoenix-component">migrating to Phoenix.Component</a>.</p>


    </div></div>
  </body>
</html>
