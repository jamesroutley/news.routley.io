<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://learn.microsoft.com/en-us/answers/questions/009ae104-47ff-475c-adc1-d5f9604927de/can-i-open-16-bit-application-in-windows-8?forum=windows-all&amp;referrer=answers">Original</a>
    <h1>&#34;This question has been retired&#34;</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>
I’ve been writing a lot of Python code that does string templating lately. Historically, I’ve been using <code>format</code> or <a href="https://mustache.github.io/">Mustache</a> for that, but in the last few years, f-strings have increasingly become my simple templating engine of choice, especially for shorter templates or those that need embedded logic. I still have to use <code>jinja2</code> a whole lot in other contexts, and <code>string.Template</code> also exists, but neither sparks joy in me, so I reach for f-strings whenever I can.
  </p>
<p>
Now, the issue with f-strings is that they are     <i>
immediate</i>. They evaluate in place. Why is this sometimes a problem? Occasionally, I want to define a template now and fill it in later:
  </p>
<div><pre><code>my_template = f&#34;&#34;&#34;{name.capitalize()}:

{description}
&#34;&#34;&#34;

# somewhere else entirely in my code
my_template.format(
	name=&#34;entity&#34;,
	description=&#34;description of my entity&#34;
)</code></pre></div><p>
I could _almost_  do this with trusty old <code>str.format</code>, but then I lose the ability to embed logic directly in the template. Of course, this is rarely an issue, and has a simple solution: put it in a function.</p><div><pre><code>def my_template(name, description):
	return f&#34;&#34;&#34;{name.capitalize()}:

{description}
&#34;&#34;&#34;

# somewhere else entirely in my code
my_template(&#34;entity&#34;, &#34;description of my entity&#34;)</code></pre></div><p>
But where’s the fun in that? Let’s do something unnecessary and complex instead. It’ll blow up in production and give you the perfect excuse to earn some on-call bucks.
  </p>

<p>
So what we are going to do is create an object we can call <code>format</code> on as expected. We want something that behaves like f-strings and <code>str.format</code> simultaneously, evaluated on-demand with variable bindings, but still supporting logic. Let’s call it <code>Fstr</code>.
  </p>
<div> <pre><code>class Fstr:
	def __init__(self, string):
		self.string = string
		
	def format(self, **kwargs):
		# TODO: what do we do here?
		pass
		
my_template = Fstr(&#34;&#34;&#34;{name.capitalize()}:

{description}
&#34;&#34;&#34;)

# somewhere else entirely in my code
my_template.format(
	name=&#34;entity&#34;,
	description=&#34;description of my entity&#34;
)</code></pre></div>
<p>
So far, so unimpressive. But what do we do now? As always, the answer is to use <code>eval</code>! It’s dangerous, slow, and therefore perfect.
  </p>
<div>
  <pre><code>class Fstr:
	def __init__(self, string):
		self.string = string
		
	def format(self, **kwargs):
		expr = f&#34;f&#39;&#39;&#39;{self.string}&#39;&#39;&#39;&#34;
		return eval(expr, {}, kwargs)
		
my_template = Fstr(&#34;&#34;&#34;{name.capitalize()}:

{description}
&#34;&#34;&#34;)

# somewhere else entirely in my code
my_template.format(
	name=&#34;entity&#34;,
	description=&#34;description of my entity&#34;
)</code></pre></div>
<p>
So what’s actually happening here? What does <code>f&#34;f&#39;&#39;&#39;{self.string}&#39;&#39;&#39;&#34;</code> mean? Naturally, we are turning a regular string into an f-string literal using an f-string!
  </p>
<p>
In case that explanation didn’t help, let’s visualize what this expands to.
  </p>
<div>
  <pre><code># the input
string = &#34;&#34;&#34;{name.capitalize()}:

{description}
&#34;&#34;&#34;

# the f-string
f&#34;f&#39;&#39;&#39;{string}&#39;&#39;&#39;&#34;

# the output
f&#39;&#39;&#39;{name.capitalize()}:

{description}
&#39;&#39;&#39;</code></pre></div>
<p>
So now we have an appropriate string literal. All we need to do to close the loop is <code>eval</code> it and give that evaluation the appropriate bindings. Luckily, the bindings already got passed into the function in the appropriate format (keyword argument handling did it for us), and we can just pass them into <code>eval</code> as is!
  </p>

<p>
I hope you enjoyed this slight return into weird meta-programming territory. A bit more tame than what long-time readers might be used to, but it excited me enough to write it up anyway.
  </p>
<p>
See you around!
  </p>
      
    </div></div>
  </body>
</html>
