<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://karthinks.com/software/different-strokes-for-different-folks/">Original</a>
    <h1>Emacs and the mouse: A modest defense of the rodent</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      <p>A modest defense of the rodent</p>
<p>So, Emacs and the mouse.  This is an unexpectedly contentious topic, with discussions that end, at best, with careless dismissal.  More often they turn into arguments with folks talking past one another.</p>
<p>The advantages of using the mouse for common actions in Emacs are immediate and obvious.  Window selection is a natural extension of basic mouse usage.  Resizing windows is a snap.  Context (right-click) menus
<span><small>
See <code>context-menu-mode</code>.
</small></span>
and drag and drop support, which improve with each new Emacs release, are very intuitive.  The mouse provides access to basic editor functions with no learning curve, and no exhortations to work through the Emacs tutorial are necessary.  Also, feature discoverability via Emacs’ menu-bar is surprisingly good.</p>
<p>Unfortunately, I have to address the rodent in the room carefully before we can talk about mitigating the many disadvantages of mouse-first interaction, since Emacs users tend to be very opinionated about this topic.  <strong>Ergonomics</strong>, <strong>speed</strong>, and <strong>efficiency</strong> are three common reasons people advocate for the keyboard against the mouse for non-graphical work.  I’m not convinced any of these arguments hold water.  The first two are research-worthy topics on their own, with many quotable precedents, and beyond my ability to argue for or against convincingly just from personal experience
<span><small>
Besides, anyone who’s had bouts of RSI has made up their mind already on this topic.
</small></span>
.  On the matter of speed, for instance, I am obliged to include this quote because y’all are going to send me emails linking to it otherwise:</p>
<blockquote>
<p>We’ve done a cool $50 million of R &amp; D on the Apple Human Interface. We discovered, among other things, two pertinent facts:</p>
<p>Test subjects consistently report that keyboarding is faster than mousing.</p>
<p>The stopwatch consistently proves mousing is faster than keyboarding.</p>
<p>– <a href="https://en.wikipedia.org/wiki/Bruce_Tognazzini">Bruce Tognazzini</a></p>
</blockquote>
<p>So let’s pretend for the purpose of today’s discussion that we’re not concerned about the difference in editing speed one way or another.</p>
<p>In the context of Emacs specifically, there are further disadvantages.  For example, mouse actions compose in limited ways (such as when dragging to form selections) and cannot build on each other like key sequences can with prefix keys and transient maps.  You can’t automate mouse usage with keyboard macros easily.</p>
<p>But today we’re primarily going to address the third reason: efficiency.</p>
<p>I find the arguments about efficiency, in the sense of poor expressivity or economy of motion, shortsighted at best.  Here are two facets of this argument, where “mouse” includes any kind of pointing device.</p>
<p><strong>Economy</strong>:</p>
<blockquote>
<p>Frequent context switching between the keyboard, mouse and keyboard+mouse is wasteful and causes low amounts of constant friction.</p>
</blockquote>
<p><strong>Expressivity</strong>:</p>
<blockquote>
<p>Mouse usage has a low ceiling: it makes easy tasks trivial but involved actions impossible.  Adding buttons or widgets to the screen doesn’t scale.</p>
</blockquote>
<h2 id="economy-and-interprogram-contexts">Economy and interprogram contexts</h2>
<p><strong>Economy</strong> first.  I actually agree with the context switching argument, to the extent that the friction of repeated switching feels progressively more annoying.  But the conclusion – it’s best to avoid the mouse to avoid context switching – is shortsighted because it only applies if you’re <em>only ever</em> in Emacs and never have to use the mouse, or conversely if you’re <em>never</em> in a text editor and always in a mouse-driven (or keyboard+mouse driven) application like a 3D modeling tool or a big commercial IDE.  Most of us are somewhere in the middle.</p>
<p>I’m as keyboard-centric as you can reasonably get: besides Emacs, I use a tiling window manager, a <a href="https://qutebrowser.org/">keyboard-driven web browser</a> and mostly TUI applications.  Keybindings are the topic I’ve written the most about on this website – an embarrassing amount of yakshaving devoted to an inane subject.  Even so, I use the mouse frequently because it’s often the best way to select text, images and links, do graphical work, and to interact with (both simple and complex) GUI software.</p>
<p>When working on something that involves Emacs <em>and</em> one of these mouse driven applications, having to move over to the keyboard for the Emacs bit is exactly the friction we’d like to avoid.  The other app may not be flexible, but Emacs is!  So we don’t need to switch to the Emacs-typical both-hands-at-keyboard context.  Here are a few examples of quick interprogram interaction involving Emacs that you can easily do without moving your hand off the mouse.</p>
<h3 id="pasting-text-from-other-applications-into-a-new-buffer">Pasting text from other applications into a new buffer</h3>
<p>Switch to a scratch buffer+window in Emacs to paste some text:</p>
<video preload="metadata" width="700" controls="">
<source src="/img/strokes-drag-text.mp4" type="video/mp4"/>
<a href="https://karthinks.com/img/strokes-drag-text.mp4%22">[VIDEO: Create a scratch buffer with strokes]</a></video>
<p>I use a mouse gesture in Emacs to create a scratch buffer in Org mode – courtesy of the <a href="https://codeberg.org/emacs-weirdware/scratch">scratch</a> package – then drag some text into it
<span><small>
Incidentally, the text is a LaTeX environment that is rendered automatically via Org’s new LaTeX preview system.
</small></span>
.  I then switch back to the previous buffer using another mouse gesture.</p>
<h3 id="git-clone-from-a-repository-url">git-clone from a repository URL</h3>
<video preload="metadata" width="700" controls="">
<source src="/img/strokes-git-clone.mp4" type="video/mp4"/>
<a href="https://karthinks.com/img/strokes-git-clone.mp4%22">[VIDEO: git-clone from repository URL]</a></video>
<p>Middle click to paste a link from the clipboard.  (This is only for clarity, it’s unrelated to the actual action.)  Then use a mouse gesture to git-clone from that link to a prespecified directory.</p>
<h3 id="open-a-project-directory-in-dired-so-we-can-drag-and-drop-a-file">open a project directory in dired so we can drag and drop a file</h3>
<video preload="metadata" width="700" controls="">
<source src="/img/strokes-project-dired.mp4" type="video/mp4"/>
<a href="https://karthinks.com/img/strokes-project-dired.mp4%22">[VIDEO: project directory in dired]</a></video>
<p>Use a mouse gesture to bring up a list of directories in the active project.  Pick one – also using the mouse – then drag an image file into dired before switching back.</p>
<h3 id="mpv-plus-live-video-transcript-in-emacs">mpv + live video transcript in Emacs</h3>
<p>Control mpv (a video player) by clicking around in a live transcript file in Emacs:</p>
<video preload="metadata" width="700" controls="">
<source src="https://i.imgur.com/DQ9cmED.mp4" type="video/mp4"/>
<a href="https://i.imgur.com/DQ9cmED.mp4&#34;">[VIDEO: live, clickable transcripts with elfeed-tube]</a></video>
<p>No mouse gestures here – the clickable transcripts and mpv connection are provided by <a href="https://github.com/karthink/elfeed-tube">elfeed-tube</a>, which was designed to be usable with the mouse since it involves interacting with a video player.</p>
<p>My counter-argument can be summarized: <strong>Use the lowest effort means of interaction in each context you work in.  Often this means driving Emacs with the mouse.</strong></p>
<h2 id="expressivity">Expressivity</h2>
<p>The <strong>expressivity</strong> counterargument: Buttons and widgets indeed don’t scale, but they bear the additional burdern of discoverability.  Mouse interactions in Emacs don’t have to be prescribed or discoverable –  when they are actions <em>we</em> set up, typically after repeatedly observing a cumbersome task that could be mouse-driven.  Point-and-click in an editor is not as expressive as full-on keyboard usage, but that’s only true in the generic sense.  The relevant question is if we can express the <em>specific verbs that we care about</em>, and from the above demos it’s clear we can.</p>
<p>An example: considering that using the mouse to select and resize windows is already a more natural experience than spamming <code>C-x o</code> and friends (or your <code>evil-mode</code> equivalents), it is possible to extend it to be a more comprehensive approach to window and buffer management:</p>
<video preload="metadata" width="700" controls="">
<source src="/img/strokes-window-handling.mp4" type="video/mp4"/>
<a href="https://karthinks.com/img/strokes-window-handling.mp4%22">[VIDEO: strokes window handling demo]</a>
</video>
<p>This demo showcases the use of mouse gestures to do the following:</p>
<ul>
<li>Split the frame vertically and horizontally</li>
<li>Delete windows</li>
<li>Cycle through buffers in windows by left and right clicking the buffer name in the mode line.</li>
<li>Delete other windows</li>
<li>Swap windows to the right and left</li>
<li>Toggle between the last two buffers shown in a window</li>
<li>Go back to a previous window configuration (via <code>tab-bar-history-back</code> or <code>winner-undo</code>)</li>
</ul>
<h2 id="how-to-mouse-around">How to mouse around</h2>
<p>This is not, strictly speaking, an article on how to use the mouse in Emacs – it’s more about <em>why</em> and <em>when</em>.  For the how I suggest reading <a href="https://amodernist.com/texts/emacs-mouse.html">Philip Kaludercic’s write-up</a>.  You could also try just clicking around, especially in the mode line!  However the use of gestures in Emacs rarely gets much attention, so here we go.</p>
<p>For once, this is going to be a short description, since this is a <a href="https://karthinks.com/software/more-batteries-included-with-emacs/#strokes--m-x-strokes-help">batteries included</a> situation.  Emacs ships with everything you need.</p>
<p>Adding mouse gesture support to Emacs is easy with the included Strokes library
<span><small>
Many thanks to David Bakhash and the Emacs maintainers for strokes.el.
</small></span>
.  For each action you want to map to a gesture,</p>
<ol>
<li>Find or (optional) write a command that does the thing.</li>
<li>Set it to a mouse stroke (gesture) with <code>strokes-global-set-stroke</code>.</li>
</ol>
<p>That’s it
<span><small>
<code>M-x strokes-help</code> has more information.
</small></span>
.</p>
<p>Optionally, you could change the mouse button you hold down to perform a gesture.  The default is <code>S-mouse-2</code>, which is rather awkward.  I use a side button on my mouse (typically the “forward” button):</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>keymap-global-set</span> <span>&#34;&lt;down-mouse-9&gt;&#34;</span> <span>&#39;strokes-do-stroke</span>)
</span></span></code></pre></div><p>Also optionally, you can hide the live-display of the stroke as you draw (<code>strokes-use-strokes-buffer</code>) – I left it in for clarity in the demos.</p>
<p>I’ve not had to customize anything else about the strokes library, but feel free to explore – it has support for multi-glyph (complex) strokes, for instance.</p>
<p>There are a few general mouse settings you might be interested in:</p>
<ul>
<li><code>mouse-autoselect-window</code>: Set to <code>t</code> for focus-follows-mouse behavior inside Emacs.  Typically what you’d want if you use mouse gestures.</li>
<li><code>mouse-drag-and-drop-region</code>: To enable text drag-and-drop within Emacs,</li>
<li><code>mouse-drag-and-drop-region-cross-program</code>: (Emacs 29+) and across programs from Emacs.</li>
<li><code>dired-mouse-drag-files</code>: To drag files from dired to other programs.</li>
</ul>
<h2 id="improving-strokes">Improving Strokes</h2>
<p>Mouse gestures are a decades-old concept, as many features included with Emacs are.  And the Strokes library has a list of notes and todos, as many features included with Emacs do.</p>
<ol>
<li><strong>No contextual actions</strong>: The use of strokes is limited, as of Emacs 29, by the lack of support for mode-specific or buffer-local strokes.  This means the same gesture cannot do different things in different contexts without writing cumbersome, bespoke dispatch commands to handle this.</li>
<li><strong>Somewhat unreliable gesture matching</strong>:  Drawing with the mouse or trackpad is fuzzy and imprecise.  The matching algorithm is quite rudimentary and there are mismatches when you have many strokes defined (&gt; 25, let’s say), even with an increased “grid” resolution when drawing.  Fixing 1 can take the pressure off the matching algorithm, but we could also use a more sophisticated approach to matching.</li>
<li><strong>No multi-touch gestures</strong>: This can increases the dimensionality of the gesture space, allowing for a greater number of “basic strokes” – although the OS usually captures and maps most of these for its window management.</li>
</ol>
<p>Despite these limitations, this is a very handy tool.  I’m not sure why gestures aren’t more common – we only see them on touch interfaces these days.  You can draw them anywhere on the screen, and they tolerate a fair bit of fuzz.  They avoid the problem of having to move the mouse over to a small target on screen.  Not having to fill the screen up with buttons is a win by itself.  The only significant problem appears to be that they’re not (re)discoverable, but this isn’t a problem inside Emacs: we have <code>strokes-describe-stroke</code> (like <code>describe-key</code>) and <code>strokes-list-strokes</code>.</p>
<h2 id="it-s-not-all-or-nothing-dot-it-s-not-even-something-dot">It’s not all or nothing.  It’s not even something.</h2>
<p>Some of the “talking past each other” I mentioned in the beginning is because of assumptions we make about using the mouse in text editors.  We gravitate to one of two specious requirements:</p>
<ul>
<li>The mouse should <em>substitute</em> for the keyboard, such as when using menu or toolbar buttons <em>instead</em> of keybindings.</li>
<li>The mouse should <em>complement</em> the keyboard, so we work best with a hand each on the keyboard and mouse.  (This is the <a href="http://acme.cat-v.org/">Acme editor</a> approach.)</li>
</ul>
<p>Actual usage patterns are messier than either of these.  Sometimes we’re working in a mouse-heavy context, sometimes it’s two handed keyboarding, sometimes its a mix.  Often the editor is at the periphery of the task at hand, sometimes it’s dead center
<span><small>
This is true despite Emacs swallowing up my desktop applications.  Calendar, email, reading, some web browsing… the list keeps growing.
</small></span>
.  Any degree of flexibility on the part of the editor is welcome.  Instead of dismissing the mouse on the basis of the available design affordances, it can help to think about what we actually care to avoid – frequent context switching for me, your answer will be different – and how driving Emacs with the mouse helps us do that.</p>

    </div></div>
  </body>
</html>
