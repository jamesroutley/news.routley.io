<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://behind.pretix.eu/2018/01/20/cups-driver/">Original</a>
    <h1>Writing your own CUPS printer driver in 100 lines of Python (2018)</h1>
    
    <div id="readability-page-1" class="page"><div role="main">

    <article>

        

<!--         <header class="post-header">
            <a id="blog-logo" href="https://behind.pretix.eu">
                
                    <span class="blog-title">pretix – behind the scenes</span>
                
            </a>
        </header> -->

        <!-- <span class="post-meta">
            <time datetime="2018-01-20">20 Jan 2018</time>
            
                on Technology and Printers
            
        </span> -->

        <!-- <h1 class="post-title">Writing your own CUPS printer driver in 100 lines of Python</h1> -->

        <section>
            <p>In <a href="https://pretix.eu/about/en/blog/20171007-release-180/">version 1.8</a> of pretix, we introduced shipping
management as a new feature for the pretix Hosted and Enterprise editions. With this plug-in, you can choose not to
deliver your tickets to your visitors as a downloadable file, but to send them via snail mail instead. Of course,
you can just download those tickets as regular-sized PDF files, print them out and ship them, but the feature is
usually most interesting if you want to send out high-quality tickets that look good e.g. in a gift wrapping under
a christmas tree or pinned to a wall as a souvenier of the event.</p>

<p>For this purpose, you will need a thermal ticket printer as well as suitable ticket paper. Last year, I took a closer
look at this market and tested devices from two of the major ticket printer vendors: The <a href="https://tls-bocasystems.com/en/38/lemur">BOCA Lemur</a>
as well as the <a href="http://www.practicalautomation.com/cost-effective-ticket-printers.html">Practical Automation uITL+2003CF</a> model.
In our test, the printing quality of both printers was very similar. The uITL+ is missing a network port in contrast to the 
BOCA Lemur, but the uITL+ features a nicer case (smaller and metal instead of plastic) and is way more affordable to obtain,
at least here in Europe.</p>

<p>For this reason, we chose the uITL+ as our reference printer and for our first customer installation. You’ve already
seen a photo of the uITL+ in our last blogpost:</p>

<p><img src="https://behind.pretix.eu/assets/images/2018-01-cups/printer.jpg" alt="Ticket printer"/></p>

<p>However, there is another downside to the uITL+: It only comes with a Windows driver, while the BOCA printers come with
drivers for all platforms, including <a href="http://www.bocasystems.com/linux_driver.php">packages</a> for Debian, Ubuntu, Fedora,
CentOS, Arch Linux, FreeBSD, and even an ARM build for the Raspberry Pi.</p>

<p>Both printers speak FGL (“Friendly Ghost Language”) over the wire, a communication protocol common to the world
of ticketing printers. With FGL, you can send ASCII text and style information in order to render your tickets directly
on the printer (but we want to send PDFs rendered on the server instead, which is why we need a driver to convert).
Documentations of FGL can be obtained via the websites of <a href="http://www.bocasystems.com/documents/fgl46.doc">both</a>
<a href="http://www.practicalautomation.com/uploads/6/3/3/0/633048/pmitx308.pdf">vendors</a>. This also means that the drivers are, in
theory, cross-compatible with minimal adjustments in configuration.
However, the license of the BOCA driver forbids using their driver to control printers of other vendors. Additionally, no
sources of the driver are available and some builds (like the ARM build of the Raspberry Pi package) only run on very old operating systems
since they link to very old library versions.</p>

<p>Therefore, to use the uITL+ from a Linux operating system, we need to roll our own driver.</p>

<p>Printing on unix-like operating systems like Linux or macOS is usually done through the <a href="https://en.wikipedia.org/wiki/CUPS">CUPS</a>
daemon. CUPS is responsible for handling printer configuration, scheduling print jobs and actually talking to the printer
over the wire. Unfortunately, though, CUPS does not speak FGL out of the box.</p>

<p>If we look into CUPS’ <a href="https://www.cups.org/doc/postscript-driver.html">documentation on driver development</a>, we see that we
basically need to work on two tasks:</p>

<ol>
  <li>
    <p>We need to write a filter program that takes rastered pixel data as an input and outputs FGL code.</p>
  </li>
  <li>
    <p>We need to generate a <a href="https://en.wikipedia.org/wiki/PostScript_Printer_Description">PPD file</a> that contains configuration
information about the printer (i.e. name, name of the newly created filter, paper sizes, cutter settings).</p>
  </li>
</ol>

<h3 id="writing-a-cups-filter">Writing a CUPS filter</h3>

<p>Let’s get started with writing our CUPS filter, which we will call <code>rastertofgl</code>. Usually, most CUPS filters are written
in C, but I decided to choose Python instead – not only because I know it better, but also because writing it in a compiled
language also means that we need to cross-compile it to different architectures like ARM if we want to run it on devices
like the Raspberry Pi, which creates additional effort. Basically, we can use any language because the filter just needs
to be an executable that reads a data stream on standard input and outputs a data stream on standard output.</p>

<p>The incoming data stream consists of pages of data in the <a href="https://www.cups.org/doc/spec-raster.html">CUPS Raster Format</a>,
version 3. Every page starts with a page header of fixed length containing meta information such as the color space, page 
size, orientation, etc. In order to be able to conveniently access this data later, let’s start by defining a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">namedtuple</a>
for storage. For brevity, I’m not including all the 104 properties here:</p>

<figure><pre><code data-lang="python"><span>CupsRas3</span> <span>=</span> <span>namedtuple</span><span>(</span>
    <span>&#39;CupsRas3&#39;</span><span>,</span>
    <span>&#39;MediaClass MediaColor MediaType OutputType AdvanceDistance &#39;</span>
    <span>&#39;AdvanceMedia Collate CutMedia Duplex HWResolutionH &#39;</span>
    <span>&#39;HWResolutionV ImagingBoundingBoxL ImagingBoundingBoxB &#39;</span>
    <span>&#39;ImagingBoundingBoxR ImagingBoundingBoxT InsertSheet Jog &#39;</span>
    <span>&#39;LeadingEdge MarginsL MarginsB ManualFeed MediaPosition&#39;</span>
    <span>...</span>
<span>)</span></code></pre></figure>

<p>Next, we make use of the <a href="https://docs.python.org/3/library/struct.html">struct</a> module from Python’s standard library
to read the magic word from the beginning and then split the binary stream into all its different components. From the
header, we then know the width and height of the page in pixels as well as the number of bits per pixels, allowing us to
read all of the page into a bytearray and then continuing with parsing the next page:</p>

<figure><pre><code data-lang="python"><span>def</span> <span>read_ras3</span><span>(</span><span>rdata</span><span>):</span>
    <span>if</span> <span>not</span> <span>rdata</span><span>:</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#39;No data received&#39;</span><span>)</span>

    <span># Check for magic word (either big-endian or little-endian)
</span>    <span>magic</span> <span>=</span> <span>unpack</span><span>(</span><span>&#39;@4s&#39;</span><span>,</span> <span>rdata</span><span>[</span><span>0</span><span>:</span><span>4</span><span>])[</span><span>0</span><span>]</span>
    <span>if</span> <span>magic</span> <span>!=</span> <span>b</span><span>&#39;RaS3&#39;</span> <span>and</span> <span>magic</span> <span>!=</span> <span>b</span><span>&#39;3SaR&#39;</span><span>:</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;This is not in RaS3 format&#34;</span><span>)</span>
    <span>rdata</span> <span>=</span> <span>rdata</span><span>[</span><span>4</span><span>:]</span>  <span># Strip magic word
</span>    <span>pages</span> <span>=</span> <span>[]</span>

    <span>while</span> <span>rdata</span><span>:</span>  <span># Loop over all pages
</span>        <span>struct_data</span> <span>=</span> <span>unpack</span><span>(</span>
            <span>&#39;@64s 64s 64s 64s I I I I I II IIII I I I II I I I I &#39;</span>
            <span>&#39;I I I I II I I I I I I I I I I I I I I I I f ff ffff &#39;</span>
            <span>&#39;IIIIIIIIIIIIIIII ffffffffffffffff 64s 64s 64s 64s 64s&#39;</span>
            <span>&#39;64s 64s 64s 64s 64s 64s 64s 64s 64s 64s 64s 64s 64s &#39;</span>
            <span>&#39;64s&#39;</span><span>,</span>
            <span>rdata</span><span>[</span><span>0</span><span>:</span><span>1796</span><span>]</span>
        <span>)</span>
        <span>data</span> <span>=</span> <span>[</span>
            <span># Strip trailing null-bytes of strings
</span>            <span>b</span><span>.</span><span>decode</span><span>().</span><span>rstrip</span><span>(</span><span>&#39;</span><span>\x00</span><span>&#39;</span><span>)</span> <span>if</span> <span>isinstance</span><span>(</span><span>b</span><span>,</span> <span>bytes</span><span>)</span> <span>else</span> <span>b</span>
            <span>for</span> <span>b</span> <span>in</span> <span>struct_data</span>
        <span>]</span>
        <span>header</span> <span>=</span> <span>CupsRas3</span><span>.</span><span>_make</span><span>(</span><span>data</span><span>)</span>

        <span># Read image data of this page into a bytearray
</span>        <span>imgdata</span> <span>=</span> <span>rdata</span><span>[</span>
            <span>1796</span><span>:</span><span>1796</span> <span>+</span> <span>(</span>
                <span>header</span><span>.</span><span>cupsWidth</span> <span>*</span> <span>header</span><span>.</span><span>cupsHeight</span> <span>*</span>
                <span>header</span><span>.</span><span>cupsBitsPerPixel</span> <span>//</span> <span>8</span>
            <span>)</span>
        <span>]</span>
        <span>pages</span><span>.</span><span>append</span><span>((</span><span>header</span><span>,</span> <span>imgdata</span><span>))</span>

        <span># Remove this page from the data stream,
</span>        <span># continue with the next page
</span>        <span>rdata</span> <span>=</span> <span>rdata</span><span>[</span>
            <span>1796</span> <span>+</span> <span>(</span><span>header</span><span>.</span><span>cupsWidth</span> <span>*</span> <span>header</span><span>.</span><span>cupsHeight</span> <span>*</span>
                    <span>header</span><span>.</span><span>cupsBitsPerPixel</span> <span>//</span> <span>8</span><span>):</span>
        <span>]</span>

    <span>return</span> <span>pages</span></code></pre></figure>

<p>This allows us to read all the data we get from CUPS!</p>

<figure><pre><code data-lang="python"><span>pages</span> <span>=</span> <span>read_ras3</span><span>(</span><span>sys</span><span>.</span><span>stdin</span><span>.</span><span>buffer</span><span>.</span><span>read</span><span>())</span></code></pre></figure>

<p>Now, we need to interpret this data as an image and then re-output it as FGL.
Unfortunately, CUPS sends us grayscale values and our printer only supports pixels that are
either fully black or white. Since we do not want to drop grayscale values compeltely,
we want to apply <a href="https://en.wikipedia.org/wiki/Dither">Dither</a>. Additionally, to make the
conversion logic easier, we want to rotate the picture since we want to print the tickets
in landscape mode (<a href="https://github.com/pretix/cups-fgl-printers/issues/1">for now</a>).</p>

<p>This makes it cumbersome with pure standard library features, so I decided that it is feasible
to introduce <a href="https://pillow.readthedocs.io/">Pillow</a> as a dependency, since Pillow is also
available from the package repositories of all major Linux distributions – and probably installed
on your system already. Let’s go ahead and load the pixels into Pillow, then!</p>

<figure><pre><code data-lang="python"><span>for</span> <span>i</span><span>,</span> <span>datatuple</span> <span>in</span> <span>enumerate</span><span>(</span><span>pages</span><span>):</span>
    <span>(</span><span>header</span><span>,</span> <span>imgdata</span><span>)</span> <span>=</span> <span>datatuple</span>

    <span>if</span> <span>header</span><span>.</span><span>cupsColorSpace</span> <span>!=</span> <span>0</span> <span>or</span> <span>header</span><span>.</span><span>cupsNumColors</span> <span>!=</span> <span>1</span><span>:</span>
        <span>raise</span> <span>ValueError</span><span>(</span>
            <span>&#39;Invalid color space, only monocolor supported&#39;</span>
        <span>)</span>

    <span>im</span> <span>=</span> <span>Image</span><span>.</span><span>new</span><span>(</span><span>&#34;L&#34;</span><span>,</span> <span>(</span><span>header</span><span>.</span><span>cupsWidth</span><span>,</span> <span>header</span><span>.</span><span>cupsHeight</span><span>))</span>
    <span>im</span> <span>=</span> <span>im</span><span>.</span><span>rotate</span><span>(</span><span>90</span><span>)</span>
    <span>pixels</span> <span>=</span> <span>im</span><span>.</span><span>load</span><span>()</span>
    <span>for</span> <span>j</span><span>,</span> <span>b</span> <span>in</span> <span>enumerate</span><span>(</span><span>imgdata</span><span>):</span>
        <span>pixels</span><span>[</span><span>j</span> <span>%</span> <span>header</span><span>.</span><span>cupsWidth</span><span>,</span> <span>j</span> <span>//</span> <span>header</span><span>.</span><span>cupsWidth</span><span>]</span> <span>=</span> <span>b</span></code></pre></figure>

<p>Pillow can automatically convert the picture to black and white for us, if we ask it to:</p>

<figure><pre><code data-lang="python">    <span>im</span> <span>=</span> <span>im</span><span>.</span><span>convert</span><span>(</span><span>&#39;1&#39;</span><span>)</span>
    <span>pixels</span> <span>=</span> <span>im</span><span>.</span><span>load</span><span>()</span></code></pre></figure>

<p>If we want to send the raster data to the printer, we need to follow the FGL instructions
for graphical data, which expects us to send 8 lines of pixels at a time: One byte for each
column with each bit of the byte representing one of the 8 lines. We therefore loop over
the image in blocks of 8 lines and create a row of bytes for each of these blocks. If any
of these pixels is non-white, we’ll send the row to the printer, preceeded my a “move”
command:</p>

<figure><pre><code data-lang="python">    <span>for</span> <span>yoffset</span> <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>im</span><span>.</span><span>height</span><span>,</span> <span>8</span><span>):</span>
        <span>row</span> <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>im</span><span>.</span><span>width</span>
        <span>for</span> <span>x</span> <span>in</span> <span>range</span><span>(</span><span>im</span><span>.</span><span>width</span><span>):</span>
            <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>8</span><span>):</span>
                <span>if</span> <span>pixels</span><span>[</span>
                    <span>min</span><span>(</span><span>x</span><span>,</span> <span>im</span><span>.</span><span>width</span> <span>-</span> <span>1</span><span>),</span>
                    <span>min</span><span>(</span><span>yoffset</span> <span>+</span> <span>j</span><span>,</span> <span>im</span><span>.</span><span>height</span> <span>-</span> <span>1</span><span>)</span>
                <span>]</span> <span>&lt;</span> <span>128</span><span>:</span>
                    <span>row</span><span>[</span><span>x</span><span>]</span> <span>|=</span> <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>7</span> <span>-</span> <span>j</span><span>)</span>
        <span>if</span> <span>any</span><span>(</span><span>row</span><span>):</span>
            <span># FGL: &lt;RCy,x&gt;: Move to correct position
</span>            <span># FGL: &lt;Gnn&gt;: nn bytes of graphics are following
</span>            <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span><span>.</span><span>write</span><span>(</span><span>&#39;&lt;RC{},{}&gt;&lt;G{}&gt;&#39;</span><span>.</span><span>format</span><span>(</span>
                <span>yoffset</span><span>,</span> <span>0</span><span>,</span> <span>len</span><span>(</span><span>row</span><span>)</span>
            <span>).</span><span>encode</span><span>())</span>
            <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span><span>.</span><span>write</span><span>(</span><span>bytes</span><span>(</span><span>row</span><span>))</span></code></pre></figure>

<p>Almost there! We now only need to send either “print” or a “print and cut” command, depending
on the options of the print job (or the printer’s defautl options):</p>

<figure><pre><code data-lang="python">    <span>if</span> <span>header</span><span>.</span><span>CutMedia</span> <span>in</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>and</span> <span>i</span> <span>==</span> <span>len</span><span>(</span><span>pages</span><span>)</span> <span>-</span> <span>1</span><span>:</span>
        <span># Cut after last ticket of file/job/set
</span>        <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#39;&lt;p&gt;&#39;</span><span>)</span>
    <span>elif</span> <span>header</span><span>.</span><span>CutMedia</span> <span>==</span> <span>4</span><span>:</span>  <span># Cut after page
</span>        <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#39;&lt;p&gt;&#39;</span><span>)</span>
    <span>else</span><span>:</span>  <span># Do not cut
</span>        <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span><span>.</span><span>write</span><span>(</span><span>b</span><span>&#39;&lt;q&gt;&#39;</span><span>)</span></code></pre></figure>

<p>We can now test that our filter is running correctly by obtaining a sample stream of CUPS raster data
and piping it through our filter and directly into the printer:</p>

<pre><code># cat sample.raster | ./rastertofgl &gt; /dev/usb/lp1
</code></pre>

<p>It works! To use this with cups, we now also need to write a PPD file.</p>

<h3 id="ppd-printer-defintion">PPD printer defintion</h3>

<p>PPD is a nasty format that is no fun to write by hand. Luckily, CUPS comes with a tool named <a href="https://www.cups.org/doc/man-ppdc.html">ppdc</a>
that allows us to write a slightly higher-level DRV file and then later compile it to a PPD. The full reference for
DRV files can be found <a href="https://www.cups.org/doc/ref-ppdcfile.html">here</a>. For our case we start with some boilerplate
details like the printer’s name:</p>

<pre><code>#include &lt;font.defs&gt;
#include &lt;media.defs&gt;
{
  Manufacturer &#34;Practical Automation&#34;
  ModelName &#34;ITL-2003&#34;
  PCFileName &#34;paITL2003.ppd&#34;
  Version 1.0
  Attribute &#34;NickName&#34; &#34;&#34; &#34;Practical Automation ITL-2003&#34;
</code></pre>

<p>Next, we define the name of the filter that we want to apply, which is the rastertofgl script we just wrote:</p>

<pre><code>  Filter &#34;application/vnd.cups-raster 100 rastertofgl&#34;
</code></pre>

<p>We also need to tell CUPS the DPI and the color model, in order to receive the correct number and type of pixels for our
filter:</p>

<pre><code>  *Resolution - 8 0 0 0 203dpi
  ColorModel Gray/Grayscale w chunky 0
</code></pre>

<p>We want to give the user the option to turn the printer’s cutter on or off – or choose whether the printer shall cut after
every single ticket or just after every print job:</p>

<pre><code>  Group &#34;General/General&#34;
    Option &#34;fooCutMedia/Cut Labels&#34; PickOne AnySetup 10,0
      Choice &#34;Never/Never cut media&#34; &#34;&lt;&lt;/CutMedia 0&gt;&gt;setpagedevice&#34;
      *Choice &#34;Job/Cut after job&#34; &#34;&lt;&lt;/CutMedia 2&gt;&gt;setpagedevice&#34;
      Choice &#34;Page/Cut after every ticket&#34; &#34;&lt;&lt;/CutMedia 4&gt;&gt;setpagedevice&#34;
</code></pre>

<p>CUPS also has an integrated <code>Cutter yes</code> directive, but this only allows to turn the cutter on or off completely, while
we want to have all three options here.</p>

<pre><code>  VariablePaperSize Yes
  HWMargins 0,00 0,00 0,00 0,00
  MinSize 0,00 0,00
  MaxSize 0,00 0,00
</code></pre>

<p>And then, finally, we need to specify all paper sizes that we want to support. We like tickets of the regular 8x3.25” size
best, but our PPD file includes 55 other different paper sizes as well. Here’s just one example of how this looks:</p>

<pre><code>  CustomMedia &#34;ticket8x3.25/Ticket 8x3.25in&#34; 576,00 234,00 1,00 2,00 0,00 0,00 &#34;&lt;&lt;/PageSize[576 234]/ImagingBBox null&gt;&gt;setpagedevice&#34; &#34;&lt;&lt;/PageSize[576 234]/ImagingBBox null&gt;&gt;setpagedevice&#34;
</code></pre>



<p>Half a day, 100 lines of python, and 69 test tickets printed later, we’re done! We just need to place the filter and the 
PPD files in the correct places and our printer driver will be
available to use. To make it easier for you, I created packages for <a href="https://aur.archlinux.org/packages/cups-fgl-printers-git/">Arch Linux</a>
and <a href="https://download.pretix.eu/">Debian</a>.
All source code of the driver can be found on <a href="https://github.com/pretix/cups-fgl-printers">GitHub</a>, of course.</p>

<p>Some issues remain, for example our filter currently fails for unclear reasons whenever I want to print a PDF from a GTK-based
PDF viewer – printing the same file with <code>lpr</code> from the command line works fine.</p>

<p>If you are interested in printing and shipping tickets, make sure to check out <a href="https://pretix.eu/about/en/features/tickets">pretix’ Shipping feature</a>
and <a href="https://github.com/pretix/pretix-printtool">automated printing tool</a>! You can also buy your ticket printer and paper from
us for a competitive price – just drop a line at sales@pretix.eu for more information.</p>

        </section>

        

        

    </article>

</div></div>
  </body>
</html>
