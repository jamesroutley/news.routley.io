<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.michaelpj.com/blog/2024/09/03/lsp-good-bad-ugly.html">Original</a>
    <h1>LSP: The Good, the Bad, and the Ugly</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>For a few years now I have been working on the <a href="https://github.com/haskell/haskell-language-server">Haskell Language Server</a> (HLS), and the <a href="https://github.com/haskell/lsp"><code>lsp</code> library</a> for the LSP protocol and writing LSP servers. 
Unsurprisingly, I have developed some opinions about the design of the LSP!</p>

<p>Recently I gave a talk about HLS and LSP at the Haskell Ecosystem Workshop at Zurihac 2024.
One slide featured a hastily-written table of “LSP: the good, the bad, and the ugly”.
As I gave the talk I realised that there was plenty to say on that topic, hence this post.</p>

<p>Most of what I have to say is about the <em>architecture</em> or design of the protocol.
I won’t have much to say about the <em>features</em> that the protocol supports.
Other people probably have a lot to say about that (e.g the folks working on languages that use heavy editor integration, like interactive theorem provers).
My perspective here is from my time <em>implementing</em> LSP servers, rather than my time using them.</p>

<p>I will repeat this a few times, but I want to be very clear that LSP is great and I am very happy that it exists.
While this is going to be a mostly critical post, it is criticism that exists in the context of me being happy to be working on editor tooling that is going to Just Work for a wide spectrum of users!</p>

<p>Finally, I want to also mention the excellent post <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html">LSP could have been better</a>, which is the best critical writing that I’ve read on LSP, and which inspired several of the points I’m going to make.</p>

<!-- more -->



<h2 id="it-addresses-the-problem">It addresses the problem!</h2>

<p>The most important things about the LSP are:</p>
<ol>
  <li>It exists</li>
  <li>It is omnipresent</li>
  <li>It has a decent feature set</li>
  <li>It works well enough</li>
</ol>

<p>That is, it actually succeeds in significantly addressing the problem of providing IDE tooling to a wide variety of editors at much lower cost to tooling developers.
This is huge, and not to be under-appreciated!
It is now awful to remember the situation even a few years ago, where most open-source editors had poor and inconsistent support for most programming languages.
Now someone can write a new editor and, with a bit of work on a LSP client, come out with best-in-class programming language support.
Amazing!</p>

<h2 id="focus-on-presentation-over-semantics">Focus on presentation over semantics</h2>

<p>As <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html#Focus-on-Presentation">Alex says</a>, it’s a great choice for the LSP to focus on presentation, i.e. the things that actually appear in the editor, rather than the semantic structure of the program (which is wildly different from language to language).</p>

<p>The presentation-first approach works pretty well, although some semantic elements have crept in over time.
For example:</p>
<ul>
  <li>There is a “type hierarchy” request. Is this just a widget that represents a tree of arbitrary stuff that you can consider “types”? Or is there some implication that the relationship that the tree shows should be <em>subtyping</em>, making it a bit more specific to languages with inheritance? Unclear.</li>
  <li>There are various tags that indicate the nature of entries in e.g. completion lists, and these are usually semantic rather than presentational. For example, a completion item is tagged as <em>deprecated</em>, rather than being tagged as <em>non-emphasized</em> or similar.</li>
</ul>

<p>It’s awkward, since obviously the appropriate editor widgets for a IDE protocol will make some references to programming language constructs!
But I think it’s a good direction, I wish they’d committed even more to it.</p>

<h2 id="backwards-compatibility">Backwards compatibility</h2>

<p>Perhaps because it is a Microsoft project, the LSP has always hewed to pretty strict backwards compatibility.
This is great for users!
It means that even older or less-maintained language servers or editors continue to pretty much just work, which is a real blessing.
I even think the “capability” model that they chose to indicate what servers and clients do support is fine.<sup id="fnref:capability-inconsistent" role="doc-noteref"><a href="#fn:capability-inconsistent" rel="footnote">1</a></sup></p>

<p>Occasionally backwards compatibility is not handled well. 
Take for example the <a href="https://github.com/microsoft/language-server-protocol/issues/1888">messy situation</a> with configuration:</p>
<ul>
  <li>Initially, configuration was pushed from the client to the server using the <code>workspace/didChangeConfiguration</code> notification</li>
  <li>Then, they added the ability for the server to pull configuration using <code>workspace/configuration</code>
</li>
  <li>In order to keep receiving change notifications, you now have to dynamically register for <code>workspace/didChangeConfiguration</code>
</li>
  <li>This broke old servers, which were not dynamically registering because they didn’t have to before</li>
</ul>

<p>However, I think it’s pretty remarkable that this is the only real backwards compatibility break I know of!</p>

<h2 id="machine-readable-specification-of-types">Machine-readable specification of types</h2>

<p>Thank all that is holy<sup id="fnref:dirk-the-saviour" role="doc-noteref"><a href="#fn:dirk-the-saviour" rel="footnote">2</a></sup> that there is a <a href="https://github.com/microsoft/vscode-languageserver-node/blob/main/protocol/metaModel.json">machine-readable specification</a> of the LSP types and methods.</p>

<p>Is it a bit weird? 
Yes! 
Is it written in their own home-rolled format? 
Yes!
Do I care?
No!</p>

<p>The LSP <a href="#massive-specification">is massive</a>.
The Haskell implementation of the protocol, which I maintain, used to have all of those types and their serializations defined <em>by hand</em>.
This was awful, tedious, and error-prone (especially given the <a href="#weird-types">weirdness of the types</a>).
It took me quite a long time, but this is now all generated, which has removed 90% of the toil from maintaining that library, and nearly eliminated bugs relating to the JSON serialization of types.<sup id="fnref:nearly" role="doc-noteref"><a href="#fn:nearly" rel="footnote">3</a></sup></p>

<h2 id="dynamic-registration">Dynamic registration</h2>

<p>I’m just going to briefly disagree with <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html#Dynamic-Registration">Alex</a> here. 
Dynamic registration is good, actually.
The reason is that the LSP supports changing configuration at runtime, and that means that the server’s capabilities can change at runtime.
If the user un-checks “semantic tokens” in their configuration, then the server really wants to say to the client “I can’t do semantic tokens any more!”. 
Otherwise the client will keep asking, and the server has to either return empty data or errors, neither of which is quite right.</p>

<p>It’s implemented messily<sup id="fnref:dynamic-registration-options" role="doc-noteref"><a href="#fn:dynamic-registration-options" rel="footnote">4</a></sup> and is a pain to work with, but I think there’s a fundamentally good idea there.</p>



<p>(I know, it’s supposed to be “The bad” next, but I wanted to talk about the really interesting stuff first!)</p>

<h2 id="not-a-truly-open-project">Not a truly open project</h2>

<p>Given how crucial LSP has become to the open-source community, you would hope that the project itself was an open one.
Sadly this is not at all the case.</p>

<p>The LSP specification has, as far as I can tell, <em>one</em> committer, Dirk Bäumer, who works for Microsoft (I assume on the VSCode team).<sup id="fnref:dirk" role="doc-noteref"><a href="#fn:dirk" rel="footnote">5</a></sup>
There have been many small contributions by outsiders, but nobody else has commit access.</p>

<p>Major changes to the spec are driven by internal forces inside Microsoft.
For example, the latest version of the spec adds a bunch of new content for supporting notebooks.
That doesn’t look to me like something the community was particularly asking for, but I guess some PM inside Microsoft decided they wanted VSCode to support notebooks, so now it’s in the spec.</p>

<p>There is zero open discussion of features before they are added to the spec.
Typically they are implemented in VSCode, and then the specification is updated as a <em>fait accompli</em> to document those changes.
Implementers of open-source language servers get very influence on the development of the specification.<sup id="fnref:dirk-again" role="doc-noteref"><a href="#fn:dirk-again" rel="footnote">6</a></sup>
There is not even a <a href="https://github.com/microsoft/language-server-protocol/issues/1642">community space for implementers of language servers</a> to get together and talk about the many tricky corners.</p>

<p>Another consequence of the lack of openness     is that there is no forum for agreeing on extensions to the somewhat arbitrary enumerations that the LSP specification has for things like symbol types.
In <em>theory</em> the client and the server can agree on what types they support, and then use those.
But the way it ususally works with other standards is that there is a well known set of identifiers that is agreed upon outside the main specification process.
What happens in the LSP world is that we have no way of agreeing at all, so in practice the set of symbol types that gets used are exactly the ones that are in the spec.</p>

<p>This is not really good enough for such an important project, in my opinion.
The LSP should be an open standard, like HTTP, with an open committee that represents the large community which is invested in LSP, and can offer their insight in how to evolve it.</p>

<h2 id="non-acknowledgment-of-concurrency">Non-acknowledgment of concurrency</h2>

<p>Here’s what the specification has to say about concurrency:</p>

<blockquote>
  <p>Responses to requests should be sent in roughly the same order as the requests appear on the server or client side. …</p>

  <p>However, the server may decide to use a parallel execution strategy and may wish to return responses in a different order than the requests were received. The server may do so as long as this reordering doesn’t affect the correctness of the responses. …</p>
</blockquote>

<p>This pretty much amounts to “yeah, you’ll want to use concurrency, but if something weird happens that’s your problem”.
That’s a pretty disappointing attitude.
Working out a way to make everything make sense at the protocol level in the face of concurrency is hard, but it’s really necessary.</p>

<p>In particular, it’s somewhat disingenuous to suggest that concurrent server processing is an unusual approach when the specification itself simply cannot work without it.<sup id="fnref:concurrency" role="doc-noteref"><a href="#fn:concurrency" rel="footnote">7</a></sup>
For example:</p>

<ul>
  <li>Requests cannot be cancelled unless the server can handle the cancellation request concurrently with processing the original request.</li>
  <li>Progress tracking cannot work unless the server can send notifications (<em>and</em> in the case of <code>window/workDoneProgress</code>, send and handle responses to requests!) concurrently with processing a request.</li>
</ul>

<h2 id="missing-causality">Missing causality</h2>

<p>As <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html#Causality-Casualty">Alex points out</a>, the LSP has a problem accounting for causality.
In particular, both failure and asynchronous processing lead to situations where we may not be sure of the ordering of events.</p>

<p>Consider:</p>
<ol>
  <li>The client sends the server a document change notification for document D.</li>
  <li>The server updates its internal state (e.g. compilation results) to account for the change to D.</li>
  <li>The client requests code actions for D, and the server responds.</li>
</ol>

<p>The question is: when does 2 happen in relation to 3?</p>
<ul>
  <li>If the server fails to apply the change entirely, then 2 may not ever happen.</li>
  <li>If the server processes the change asynchronously but responds to the code action request before it finishes, then 2 may happen after 3.</li>
</ul>

<p>So the client really has no idea whether or not the results it is getting are up-to-date or not.
This matters <em>most</em> for applying text edits, which we will discuss shortly, but it’s a general problem.
Contra Alex, I don’t think it’s enough to just avoid retain the causality that you get from message sequencing.
If we expect the server to process requests asynchronously, then we are inevitably going to lose this ordering, and we need something stronger.</p>

<h2 id="state-synchronization">State synchronization</h2>

<p>A lot of the core operations of the LSP are <em>state synchronization</em> processes.
That is, one of the parties (server or client) has some state, and they want to keep the other party updated about what the state is.
Usually this is uni-directional – meaning that one side is the source of truth, and the other side just needs to be updated – but sometimes it is (or could be) bi-directional, meaning that both sides can change the state.</p>

<p>Here’s a big table of the features in the LSP that I think are secretly just state synchronization:</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Direction</th>
      <th>Dependencies</th>
      <th>Push/pull</th>
      <th>Incremental</th>
      <th>Filtering</th>
      <th>Invalidation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Configuration</td>
      <td>C to S</td>
      <td> </td>
      <td>Push (old), pull (new)</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Text documents</td>
      <td>C to S<sup id="fnref:apply-edit" role="doc-noteref"><a href="#fn:apply-edit" rel="footnote">8</a></sup>
</td>
      <td>Config</td>
      <td>Push</td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Diagnostics</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Push (old), pull (new)</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td>
<img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/> (pull)</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Symbols</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Semantic tokens</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Progress<sup id="fnref:progress" role="doc-noteref"><a href="#fn:progress" rel="footnote">9</a></sup>
</td>
      <td>S to C</td>
      <td> </td>
      <td>Push</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Code actions</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Code lenses</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Inlay hints</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Inline values</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Document link</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Document highlight</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
    <tr>
      <td>Document colour</td>
      <td>S to C</td>
      <td>Config, documents</td>
      <td>Pull</td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
      <td><img title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"/></td>
      <td><img title=":x:" alt=":x:" src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png" height="20" width="20"/></td>
    </tr>
  </tbody>
</table>

<p>Let’s talk a little about each of these columns.</p>

<p><strong>Direction</strong> means “which direction do updates go?”. 
If the server is the source of truth, then updates flow from server to client.</p>

<p>The LSP very much has state on both sides of the protocol.
Fortunately, it is almost always synchronized in one direction only.
The one exception to this is text document contents, because the <em>server</em> has the ability to change the state of text documents though <code>workspace/applyEdit</code>!
This is quite interesting, and causes causality problems: the server needs to track document versions when it sends <code>applyEdit</code> messages so that the client knows whether they apply to its version of the state.
Perhaps this ad-hoc version tracking is enough, and we can just tag it on to a primarily uni-directional synchronization.
But possibly this indicates that we should be looking at text document synchronization as a truly bi-directional synchronization problem.<sup id="fnref:crdts" role="doc-noteref"><a href="#fn:crdts" rel="footnote">10</a></sup></p>

<p><strong>Dependencies</strong> lists <em>other</em> pieces of state which this state depends on. The state of the diagnostics managed by the server <em>depends on</em> the state of the text documents managed by the client. A change to the text document state may invalidate the diagnostic state, and to interpret the diagnostic state you need to know what text document state it is based on.</p>

<p>Dependencies complicate the causality story significantly. 
I don’t know how you handle this gracefully, but I’m pretty sure that you need to.</p>

<p><strong>Push/pull</strong> indicates whether updates are pushed from the producer to the consumer, or pulled from the consumer to the producer.</p>

<p>Both methods have advantages and disadvantages:</p>
<ul>
  <li>Push
    <ul>
      <li>Producer can ensure that the consumer gets up-to-date information promptly</li>
      <li>Producer can send updates as soon as they have computed them</li>
      <li>Consumer may receive updates frequently or while it is doing something else</li>
    </ul>
  </li>
  <li>Pull
    <ul>
      <li>Consumer can avoid dealing with updates when they don’t care about them</li>
      <li>Consumer must take responsibility for ensuring they are up to date</li>
      <li>Producer may need to compute updates for the client at any time</li>
    </ul>
  </li>
</ul>

<p>Over time the LSP spec has moved towards having the client be in control (i.e. <em>push</em> client state <em>to</em> the server, <em>pull</em> server state <em>from</em> the server).<sup id="fnref:exceptions" role="doc-noteref"><a href="#fn:exceptions" rel="footnote">11</a></sup>
But in general it makes sense to use either method for any given kind of state.</p>

<p><strong>Incremental</strong> indicates whether there is support for sending updates that only include what has changed since the previous update.
This is obviously useful when updates are large.
Unsurprisingly, the two features that support incremental updates are the ones that involve transferring lots of data: text document contents and semantic tokens.</p>

<p>However, incremental updates are in principle useful for almost any kind of state, if the state gets big enough.</p>

<p><strong>Filtering</strong> indicates whether or not the synchronized state can be filtered to a subset. 
Often this is done using a document and range selector to only get the state in that visible region.</p>

<p>Filtering is a natural way to reduce the amount of data being sent.
If you don’t need the diagnostics for the whole project, then you don’t have to send (and process) the diagnostics for the whole project.
Filtering works naturally with a pull-based model (since you can specify the filter when you pull), but can also work perfectly well in a push-based model: the consumer just needs to keep the producer updated about what subset of the state it is interested in.</p>

<p><strong>Invalidation</strong> indicates whether the producer has the means to tell the consumer to invalidate any cached state it has and re-request it.
Invalidation is mostly necessary in a pull-based model, since in a push-based model the producer can usually just promptly tell the consumer what has changed.
In a pull-based model, the producer needs to be able to push a notification that tells the consumer that they can’t keep using the state they currently have and must re-sync.</p>

<h3 id="whither-state-synchronization">Whither state synchronization?</h3>

<p>Okay, that was a lot of dimensions to consider! There are a whole bunch of problems here:</p>

<ol>
  <li>The implementations of state synchronization are inconsistent between different features.
    <ul>
      <li>Pretty much every single entry in this table is implemented completely differently.</li>
      <li>Compare how delta updates are encoded in <code>WorkspaceEdit</code> versus <code>SemanticTokensDelta</code>, and how they are used!</li>
    </ul>
  </li>
  <li>The feature sets are inconsistent.
    <ul>
      <li>Incrementality is only implemented for text document contents and semantic tokens, if you want it for a different state, you’re out of luck.</li>
    </ul>
  </li>
  <li>Many methods are required.
    <ul>
      <li>In the JSON-RPC world we need a bunch of requests for each feature in order to handle the different things we want to do.</li>
      <li>Semantic tokens needs 4!</li>
    </ul>
  </li>
  <li>Dependency tracking is ad-hoc or unimplemented.
    <ul>
      <li>With a few exceptions (text document versions), information about state dependencies is lost.</li>
    </ul>
  </li>
</ol>

<p>The other lesson is that the problem is quite complex.
There are many things we might want to do, and it’s not easy to fit them all together.
As usual, I don’t fault the LSP designers here: the complexity clearly emerged over time, and it’s not that surprising that they didn’t manage to design ahead of it.
But with the benefit of hindsight, I think we could do better.</p>

<p>Specifically, I think we could have a <em>generic</em> state synchronization protocol as part of the LSP that would allow synchronizing many different kinds of state, and support <em>all</em> of the operations listed above.
Then server and client implementers could implement it once, and use it for everything.
While I’m not an expert and I wouldn’t want to have to draft such a thing myself<sup id="fnref:lies" role="doc-noteref"><a href="#fn:lies" rel="footnote">12</a></sup>, state synchronization is a well-studied problem in the academic literature, so we should be able to benefit from a lot of prior art.</p>



<p>This is just stuff that’s kind of annoying but not a huge fundamental problem. 
There’s a lot of it, though.</p>

<h2 id="massive-specification">Massive specification</h2>

<p>The LSP specification is big. 
Really big.
Last time I checked it had 90 (!) methods and 407 (!!) types.
Printing it to a PDF gives you 285 pages (!!!).</p>

<p>This just makes it hard to understand and implement. 
Now I’m not necessarily saying that there should be fewer <em>features</em> in the spec, but I do believe that what is there could be significantly simplified (see for example the discussion of <a href="#state-synchronization">state synchronization</a>).
But it seems unlikely that we are going to get simplification, and instead we will just get an ever-increasing long tail of features.</p>

<h2 id="backwards-compatibility-1">Backwards compatibility</h2>

<p>Didn’t I just list this under the good features? 
I did, but it’s a double-edged sword. 
Being backwards compatible means keeping old features and behaviours in the spec.
This imposes a cost on implementers because they need to understand and support all variants of behaviour, or risk old language servers not working.</p>

<p>There is no clean solution to this.
I think the best approach is to continue trying hard to keep backwards compatibility, and then occasionally do a large break to a new “major version” that is very noticeably different.
Of course, this also has costs.<sup id="fnref:python3" role="doc-noteref"><a href="#fn:python3" rel="footnote">13</a></sup></p>

<h2 id="weird-types">Weird types</h2>

<p>Here is the definition of the <code>InitializeParams.workspaceFolders</code> field:</p>
<div><div><pre><code>workspaceFolders?: WorkspaceFolder[] | null;
</code></pre></div></div>

<p>There are no fewer than <em>three</em> empty states here:</p>
<ol>
  <li>The field is absent</li>
  <li>The field is present, and the value is the empty list</li>
  <li>The field is present, and the value is null</li>
</ol>

<p>What is the difference between these? 
Why do we have all of them? 
How should servers interpret them?</p>

<p>Certainly the spec needs to tolerate missing fields in many cases for backwards compatibility reasons: a server that does not support a feature will not send messages with empty lists, it will send messages with missing fields.
But this could be handled uniformly and strictly: such fields should be missing iff the server/client states that it does not support that feature.</p>

<p>A lot of this is just the Typescript origin of the LSP leaking out, with it being common to allow <code>null</code> in lots of places it doesn’t need to be.
At the very least, the specification should <em>say</em> what the different cases mean, or if it’s okay to treat them equivalently.<sup id="fnref:encourage-sense" role="doc-noteref"><a href="#fn:encourage-sense" rel="footnote">14</a></sup></p>

<p>This combines badly with the relics left by backwards compatibility.
It can be hard to tell if a type is just strange, or whether it is the union of an old form and a new form, which both need to be supported (and are maybe equivalent or maybe not).</p>

<h2 id="specification-is-imprecise-and-inconsistent">Specification is imprecise and inconsistent</h2>

<p>The LSP specification is just not very tightly written.
It leaves a lot unspecified, which is a real problem.</p>

<p>Importantly, while I earlier praised the LSP for <a href="#focus-on-presentation-over-semantics">focussing on presentation</a>… the specification usually does not actually <em>specify</em> the presentation.</p>

<p>Consider “code lenses”. 
The specification for <code>textDocument/codeLens</code> says:</p>

<blockquote>
  <p>A code lens represents a command that should be shown along with source text, like the number of references, a way to run tests, etc.</p>
</blockquote>

<p>What does that mean? 
“A command that should be shown along with source text”, shown where?</p>

<p>In the absence of clear direction about how a presentation feature should be implemented, most people turn to the <em>de facto</em> reference implementation: VSCode.
VSCode implements code lenses by rendering them inline in the buffer, triggerable by clicking.</p>

<p>However, since the specification doesn’t actually say where the code lens is supposed to be displayed, implementations can differ.
Emacs’ <code>lsp-mode</code> plugin has an option to display code lenses at the <em>end</em> of lines.
This results in odd behaviour for servers that <a href="https://github.com/microsoft/language-server-protocol/issues/1558">erroneously assumed</a> that VSCode’s implementation was normative.</p>

<p>While that example is arguably not the fault of the specification (it wasn’t offering normative guidance, but I think it could have been clear about that!), the spec is riddled with details that clearly are intended to affect presentation, but it is unclear how.</p>

<p>For example:</p>
<ul>
  <li>
<code>CompletionItem</code>s can have <code>detail</code>, <code>documentation</code>, <code>labelDetails.detail</code>, and <code>labelDetails.description</code>. I challenge you to work out what the effect of setting these various fields is intended to be without trying it out in VSCode.</li>
  <li>
<code>InlayHint</code>s can have a <code>paddingLeft</code> boolean field, but it is not specified how much padding to insert, or what the goal of the padding is.</li>
</ul>

<p>Also, to be a bit petty, there are quite a few small but annoying errors of the sort that I feel would really have been caught if there was more that one person looking at the changes. 
This one tripped me up recently: <em>server</em> capability fields are usually suffixed with “provider”. But there is exactly one client capability field that is suffixed with “provider”, probably just by mistake: <code>colorProvider</code>.</p>

<h2 id="configuration-model">Configuration model</h2>

<p>It’s a <a href="https://github.com/microsoft/language-server-protocol/issues/972">particularly</a> <a href="https://github.com/microsoft/language-server-protocol/issues/567">big</a> mess.
For some reason they have been reluctant to specify what the configuration methods are actually supposed to do, which led to a lot of confusion.
The configuration model is actually very simple (basically just JSON blobs that you can fetch by path prefixes), they just really need to write it down.</p>

<h2 id="text-encoding">Text encoding</h2>

<p><a href="https://github.com/microsoft/language-server-protocol/issues/376">Much</a> <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html#Coordinates">ink</a> has been spilled over this already.
I don’t have much to add: UTF-16 was a bad choice driven by Windows, it should just have been unicode code points from the start.</p>

<h2 id="impoverished-interaction-model">Impoverished interaction model</h2>

<p>If you want to go outside what the LSP has built in, then you pretty much have to do it by offering code actions.<sup id="fnref:custom-methods" role="doc-noteref"><a href="#fn:custom-methods" rel="footnote">15</a></sup>
But the interaction model for code actions is very basic: the user triggers them, and then they do something.
In particular, you can’t really do the kind of multi-step operations that we’re used to from fancy IDEs in the past, or even something as basic as telling the user what you’re going to do and asking them to confirm before doing it.</p>

<p>Even the built-in refactorings have pretty simplistic interaction models, as <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html#Simplistic-Refactorings">Alex points out</a>.</p>

<h2 id="json-rpc">JSON-RPC</h2>

<p>JSON-RPC is… okay. 
It’s not the best transport layer, but it’s pretty simple to implement correctly and once you’ve done that once you’re done with it.</p>

<p>The main problem with JSON-RPC is that it enables other problems:</p>

<ol>
  <li>The presence of unacknowledged notifications encourages loss of <a href="#missing-causality">causality</a>
</li>
  <li>The fact that some fields can be omitted is just <a href="https://github.com/microsoft/language-server-protocol/issues/1883">annoying</a> and not used in practice.</li>
</ol>

<p>It wouldn’t be my choice but I don’t hate it that much.</p>



<p>Realistically, most of the complaints I have are problems for developers of language servers and clients, which is a comparatively small population compared to the number of people who <em>use</em> those tools.
So I don’t think it’s really a good idea to do a big re-engineering of the protocol <em>just</em> to make it easier for implementers… and even if we did, a big new protocol version would make things harder for implementers in the short term!
Hence I don’t think there’s a good case for a big LSP 2.0, unless it came bundled with some significant improvements for users.</p>

<p>What I <em>would</em> like is for the LSP to transition to a truly open model.
I have no idea how that would come about and I don’t have the zeal to pursue it, but if it’s something you’re interested in, maybe drop me a line.</p>


  </div>

  
    
  

</article>

      </div>
    </div></div>
  </body>
</html>
