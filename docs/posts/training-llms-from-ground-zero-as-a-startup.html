<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.yitay.net/blog/training-great-llms-entirely-from-ground-zero-in-the-wilderness">Original</a>
    <h1>Training LLMs from ground zero as a startup</h1>
    
    <div id="readability-page-1" class="page"><div data-block-type="2" data-border-radii="{&#34;topLeft&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0},&#34;topRight&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0},&#34;bottomLeft&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0},&#34;bottomRight&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0}}" id="block-b483bce734b07625b66c"><div>

<div>
  <p>Given that we‚Äôve successfully trained<a href="https://reka.ai/reka-flash-an-efficient-and-capable-multimodal-language-model/"> <span>pretty strong multimodal language models</span></a><span> </span>at Reka, many people have been particularly curious about the experiences of building infrastructure and training large language &amp; multimodal models from scratch from a completely clean slate.¬†</p><p>I complain a lot about external (outside Google) infrastructure and code on my social media, leading people to really be curious about what are the things I miss and what I hate/love in the wilderness. So here‚Äôs a post (finally). This blogpost sheds light on the challenges and lessons learned.</p><p>I hope this post will be interesting and/or educational for many.</p>
</div>




















  
  



</div></div><div data-block-type="2" data-border-radii="{&#34;topLeft&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0},&#34;topRight&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0},&#34;bottomLeft&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0},&#34;bottomRight&#34;:{&#34;unit&#34;:&#34;px&#34;,&#34;value&#34;:0.0}}" id="block-yui_3_17_2_1_1709664202692_9722"><div>

<div>
  <h4>Hardware Lottery in the Era of LLMs</h4><p>The first requisite for training models is acquiring compute. This seems straightforward and easy enough. However, the largest surprise turned out to be the instability of compute providers and how large variance the quality of clusters, accelerators and their connectivity were depending on the source.¬†</p><p>People always assume it‚Äôs simply a question/debate of accelerator choice (TPUs vs GPUs etc) and all GPU clusters are created equal. For us, this soon proved to be false. As we sampled across different service providers, we find that the <em>variance of hardware quality differs vastly even for the same hardware,</em> i.e., GPUs (H100s). Note that here, hardware refers to overall cluster quality and not necessarily the chips or accelerators per se. Just like a lottery. Basically:</p><blockquote><p>Not all hardware is created equal. <em>The variance of cluster quality across hardware providers is so high that it is literally a lottery pertaining to how much pain one would have to go through to train good models. In short, a hardware lottery in the era of LLMs.¬†</em></p></blockquote><p>More specifically, we‚Äôve leased a few clusters from several compute providers, each with a range of hundreds to thousands of chips. We‚Äôve seen clusters that range from passable (just annoying problems that are solvable with some minor SWE hours) to totally unusable clusters that fail every few hours due to a myriad of reasons. Specifically, some clusters have nodes that fail every N hour with issues ranging from cabling issues (where N is unreasonably small), GPU hardware errors etc. Even more surprisingly, every cluster across the same provider could also be vastly different in terms of how robust it was.¬†</p><p>Meanwhile, even though some other clusters could have significantly more stable nodes, they might suffer from poor I/O and file system that even saving checkpoints could result in timeouts or ungodly amounts of time chipping away at cluster utilisation. Some other compute sources require a completely different software layer to even run and are non-friendly to teams that bring their own codebases - requiring additional migration costs to run experiments or large jobs.¬†</p><p>Nothing is perfect! But some are way worse than others for sure.¬†</p><p>The most frustrating part? It‚Äôs almost impossible to really tell ahead of time, especially in the frenzy of everything, what kind of hardware one was going to get and how robust/fault-tolerant the experience would be.¬†</p><p>On top of that, you also have no way of telling if the vendor just fails to deliver on time and delays the shipment by a couple of months, leaving one stranded without being able to procure from other sources for weeks or months. Some providers would also accidentally delete your checkpoint ¬Ø\_(„ÉÑ)_/¬Ø.</p><p>Did I mention you‚Äôll also get a different Model Flop Utilisation (MFU) for different clusters!? This was a non negligible amount of compute wasted if one is unlucky enough to find a provider with badly cabled nodes or some other issues. Systems with very sub-optimal file systems would have the MFU of training runs tank the moment a team mate starts transferring large amounts of data across clusters.</p><p>Every service provider also had different levels of support. These range from being polite to nonchalant, ‚Äúchatgpt-style‚Äù canned responses to blaming the user for every single thing that goes wrong.</p><p>Overall, every single cluster we tried feels like they have their own vibe, struggles and failure modes. It was also almost as though every single cluster needed their own hot-fixes for their own set of issues - some more tolerable than others. That said, we‚Äôve learned that fail safes are important, and finding fast hot fixes for any clusters could be key.</p><p>In the past couple of months, we‚Äôve built so much just to make sure things are usable, e.g., tooling around monitoring, efficient checkpointing, and various other optimisations even to the extent of installing our custom file system for scalable data storage - and what is just the tip of the iceberg of what is actually required.¬†</p><p>These combinations of toolings resulted in a nontrivial amount of MFU improvements while also minimising downtime in the face of terrible hardware.¬†</p><h4><strong>On GPUs vs TPUs</strong></h4><p>We‚Äôre training our models on GPUs for the most part at Reka. Personally, I‚Äôve used TPUs all my life when it comes to large language model training at Google pre-Reka life. CUDA and <em>nccl</em> were the most alien thing to me ever. (I only learned it‚Äôs pronounced ‚ÄúNickel‚Äù from one of my coworkers who used to work at Nvidia lol)</p><p>I was completely taken aback by the failure rate of GPUs as opposed to my experiences on TPUs at Google. In fact, I don‚Äôt actually recall TPUs failing much even for large runs, though <em>I was not sure if I was protected from knowing this just by the sheer robustness of the outrageously good infra and having a dedicated hardware team</em>. In fact, the<a href="https://blog.research.google/2022/10/ul2-20b-open-source-unified-language.html"> <span>UL2 20B</span></a> model (at Google) was trained by leaving the job running accidentally for a month. It never failed. If this were in GPU land, it would have failed within the first few days for sure.</p><p>That said, I think this could be more about the competency of the hardware team that manages your accelerators rather than the underlying chip. The presence of having good hardware support (from your compute provider) is important. And so much hinges on them being actually competent, reinforcing the notion of the ‚Äúhardware lottery‚Äù.</p><p>GPU land feels strange. It feels like multinode training is more of an afterthought as opposed to distributed training as a first class citizen on TPU pods. In GPU land, it feels as if different providers cable them in different ways to enable multi-node training which leads to the high variance across how things are done at different places. I‚Äôm no expert in hardware though but this is the impression I get.¬†</p><h4><strong>The pain of multi-cluster setups</strong></h4><p>I spent most of my professional career on Google infra, which ran mostly on<a href="https://research.google/pubs/large-scale-cluster-management-at-google-with-borg/"> <span>Borg</span></a>,<a href="https://github.com/google-deepmind/xmanager"> <span>Xmanager</span></a> and<a href="https://cloud.google.com/blog/products/storage-data-transfer/a-peek-behind-colossus-googles-file-system"> <span>Colossus</span></a>. where everything can be assessed from literally anywhere. Therefore, the concept of having to actually set up new environments in different clusters is a foreign one to me.</p><p>In the current world, having multiple clusters of accelerator pools seems inevitable unless one specially builds for a large number in a single location. More specifically, GPU supply (or lack thereof) also naturally resulted in this pattern of cluster procurement in which things are fragmented by nature. Training large models also require large terabytes of data which can create a lot of inconvenience even just moving them around. Meanwhile, replicating data is generally also not straightforward and prohibitive at extremely large scales.</p><p>Obviously, the ideal case here is some kind of orchestration layer that is specially built to send jobs to different servers. I believe many big AI-first companies generally have some sort of infrastructure in place to improve the quality of life for AI researchers. However, building this type of sophisticated &amp; fancy ML training infrastructure is not really possible for a lean and new startup at the beginning.</p><p>For now, we ended up developing many internal workflows to mitigate many of these issues and are continuing to move towards the gold standard of a world class experimentation infrastructure. </p><p>(I was told this scrappy setup was more or less the norm for non top-tier / large companies).¬†¬†</p><h4><strong>Code in the wild</strong></h4><p>It is no secret that my favourite codebase of all time is <a href="https://github.com/google-research/t5x"><span>T5X</span></a> and <a href="https://github.com/tensorflow/mesh"><span>Mesh Tensorflow</span></a> (named tensors ftw) but these options quickly became not viable as 1) they don‚Äôt get as much support outside Google, 2) they are kind of deprecated and 3) they are not friendly to folks on our team that are not xooglers.</p><p>We ended up going for something vanilla, seemingly stable and more popular (i.e., pytorch) that is more accessible to most people on the team (except me lol). In my first few months, I was tripping all over pip, git, docker and all these wild life stuff. Then again, I am not 100% sure about how stable or user friendly it would be to use a google codebase externally (it would have been pretty nasty I guess).¬†</p><p>To be very frank, I would have to say the quality of codebases externally significantly lag behind those I‚Äôve been used to at Google. Primarily because codebase within Google tends to be written by ML rockstars themselves (e.g, Noam Shazeer, Barret Zoph, Adam Roberts, Hyung Won Chung et al.) and just feel better (e.g., superior vibes) compared to those I‚Äôve tried externally. In particular, I found myself super annoyed with the code quality when dabbling with stuff built by other companies (some way worse than others ü§ó).¬†</p><p>Also, I never knew that the ability to change model parallelism was not automatic (for free) until some codebases required me to write a converter to change the parallelism of a model. Surely a WTF moment for me.</p><p>The other striking thing is how little support these codebases have for large scale encoder-decoder training or even prefixLM training. To that end, even flash attention has consistently declined to provide support for prefixLM training (i.e., custom masks) despite reasonable demand on their github issues for whatever reason.¬†</p><p>I know I should be using Jax. A friend just shamed me for using pytorch, but this is a startup and we decided to move fast. I‚Äôm sorry we would do better to be cooler next time. I‚Äôm not proud of this fact.</p><h4><strong>Less principled, more Yolo</strong></h4><p>Scaling models systematically generally requires one to go from small to large in a principled way, i.e., run experiments in multiple phrases (1B-&gt;8B-&gt;64B-&gt;300B etc) and pick the winners and continuously scale them up. In a startup, we had way less compute to perform these massive sweeps to check hparams. In the end, we had to work with many <a href="https://twitter.com/_jasonwei/status/1757486124082303073"><span>Yolo runs </span></a>(that fortunately turned out well).</p><h4><strong>In a nutshell</strong></h4><p>Figuring out things in the wilderness was an interesting experience. It was unfortunately not painless. Compute scarcity and also unreliable compute providers made things significantly harder than expected but we‚Äôre glad we pulled through with brute technical strength.¬†</p><p>All in all, this is only a small part of the story of how we started a company, raised some money, bought some chips and matched Gemini pro/GPT 3.5 and outperformed many others in less than a year having to build everything from scratch. </p><p>There‚Äôs still more to write about, data pipelines, human evaluation, etc, but this is already a very long post. More next time. Send @YitayML DMs on X for feedback! </p><p><strong>Acknowledgements</strong></p><p>I thank Dani Yogatama, Piotr Padlewski, Matthew Henderson, Donovan Ong, Che Zheng, Aitor Ormazabal, Deyu Fu, on the Reka team for feedback on this post.¬†</p><p>I also thank external folks, Jason Wei, Hyung Won Chung, Vinh Tran &amp; Mostafa Dehghani for feedback on this post.¬†</p>
</div>




















  
  



</div></div></div>
  </body>
</html>
