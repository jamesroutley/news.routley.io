<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.prodvana.io/blog/declarative-configs">Original</a>
    <h1>Imperative configs are out; Declarative configs are in</h1>
    
    <div id="readability-page-1" class="page"><div data-framer-name="Content" data-framer-component-type="RichTextContainer"><p>Have you ever had to look up directions to meet a friend? Then memorized it or written it down? Only to find a roadblock, accident, electrical issues on the tracks, and many other unforeseeable issues. Whatever the mode of transportation -  train, driving, bus, walking, biking, we’ve all been there. </p><p>In 2012, my dad flew from Thailand to New Jersey to visit me during my freshman year of college. To prepare for driving and getting around in the US, he did a large amount of research, mapped out the routes he would take, and even printed the directions out in advance from Google Maps for his entire week-long trip. You can imagine what happened next.</p><p>My dad got lost multiple times just getting from JFK to Princeton’s campus. All the prep work he had done upfront could not prepare him for the unknowns of the real world, from confusing exit signs, windy roads, and, unlabeled side roads.</p><p>Google Maps launched turn-by-turn navigation in 2012. So when he finally got to Princeton, I showed him the power of turn-by-turn directions and how Google Maps would recalculate automatically. </p><h3>Declarative vs. Imperative</h3><p>My dad switched from working with a map printout without knowing real-time conditions, <strong>the imperative flow</strong>, to Google Maps with turn-by-turn directions, <strong>the declarative flow</strong>. This completely changed how he traveled. It gave him the confidence to travel into unknown areas without significant prep work.</p><p>The insight that declarative flows make life easier for the user is hardly new. We use them in many other parts of our lives -- from stock portfolio optimization, retirement planning, fitness goals with meal prep, autocomplete text, and more. Yet, software delivery is <em><strong>still</strong> </em>rooted in the imperative flow today.  </p><p>Current continuous delivery systems require engineers to define steps upfront, similar to how my dad had to print out directions driving from JFK to Princeton. With CD systems today, engineers are forced to prioritize the “How” of delivery and not the “What.”</p><p>CD systems ask you to codify the pipeline statically because they assume static environments. Real-world cloud environments are anything but static. Just as my dad got lost going from JFK to Princeton using paper maps, static pipelines will ultimately fail to deliver the outcome you want in a timely and optimal manner. This is because the fundamental premise of “being static” that CD systems are built on is broken in a cloud-native world. It is a relic from waterfall SDLC and GoldMaster compact disc printing.</p><p>After reading this, you might be thinking, <em>“Aren’t most CD systems declarative?”</em></p><p>Many CD systems claim to be declarative. For example, Argo CD brands itself as the <a href="https://argo-cd.readthedocs.io/en/stable/" rel="noreferrer noopener" target="_blank">“Declarative GitOps CD for Kubernetes</a>.” Harness touts “declarative GitOps and powerful, easy-to-use pipelines” on its <a href="https://harness.io/products/continuous-delivery" rel="noreferrer noopener" target="_blank">CD product page</a>.  <strong>Unfortunately, these systems are declarative about the </strong><em><strong>pipeline</strong></em><strong>, not the </strong><em><strong>delivery</strong></em>. </p><p>For example, while Argo CD is declarative within a single environment, it needs to be paired with the imperative Argo Workflows to coordinate delivery across environments. In all cases, the engineers are still forced to think about the “How” and not the “What.&#34;</p><p>The remainder of this blog will walk through a real-world, concrete technical example of how the imperative flow struggles to deliver software to its full potential. </p><h3>A Concrete Technical Example</h3><p>To see how imperative workflows fall apart, let’s walk through a real example.</p><p>In this example, there are two environments: staging and production. You want to deploy code to staging, wait one hour, validate, and then deploy to production.</p><p>A traditional CD product (Tekton, GitHub Actions, Argo Workflows, CircleCI) will require you to define a pipeline like:</p><p><img data-framer-asset="data:framer/asset-reference,IJg7b0aM5i7RRuo69bRP6hpTGt0.png" data-framer-height="710" data-framer-width="1576" height="355" src="https://framerusercontent.com/images/IJg7b0aM5i7RRuo69bRP6hpTGt0.png" width="788"/></p><p>As you mature, you will start to add more to the configuration. Typical advances include automatically validating the health of the environment.</p><p><img data-framer-asset="data:framer/asset-reference,cRQl5vXqvKjO01Xf5kKK5uw5A.png" data-framer-height="760" data-framer-width="1578" height="380" src="https://framerusercontent.com/images/cRQl5vXqvKjO01Xf5kKK5uw5A.png" width="789"/></p><p>In this case, `wait` task was replaced with `check_alerts` task on staging. </p><p>This encounters two big issues with imperative pipelines</p><ul><li data-preset-tag="p"><p>Ordering - What if the alert fires during the staging push, before the `check_alerts` task runs, or right after `check_alerts`?</p></li><li data-preset-tag="p"><p>Imperative pipelines are modeling a set of steps. Alerts, push tasks, and conditionals show up as equally important, causing your original intent to be lost.</p></li></ul><p>Alerts are powerful, but <strong>automation</strong> is how you get a full night’s sleep. This is if the system knows and performs the right action based on the failure. In this specific case, we want to rollback the configuration to this point:</p><p><img data-framer-asset="data:framer/asset-reference,7c9eyVmGFkYJKWYuZ5pT3exLKM.jpg" data-framer-height="2311" data-framer-width="1580" height="1155" src="https://framerusercontent.com/images/7c9eyVmGFkYJKWYuZ5pT3exLKM.jpg" width="790"/></p><p><strong>NOTE:</strong> The config has now more than doubled in line count, making it impossible to remember the original intent of the configuration. </p><p>As we continue to evolve our environments, we now add beta, which should be deployed between staging and production. Code is shown below:</p><p><img data-framer-asset="data:framer/asset-reference,nB3iLW2mfQsq9alHQfEDCvd8h94.jpg" data-framer-height="4021" data-framer-width="1578" height="2010" src="https://framerusercontent.com/images/nB3iLW2mfQsq9alHQfEDCvd8h94.jpg" width="789"/></p><p>The configuration has become so complicated that it does not fit vertically on a 4k monitor. It is also incredibly error-prone. </p><p>I purposely introduced an error above - can you find it?</p><p><strong>OPPORTUNITY: For the first 25 people that find the error and </strong><a href="https://calendly.com/andrewfong/introductions?month=2022-10" rel="noreferrer noopener" target="_blank"><strong>book a demo</strong></a><strong>, you’ll receive a $50 Amazon Gift Card! </strong></p><h3>Declare It</h3><p>Rewriting the above stages declaratively makes the code much simpler without losing sight of the outcome. Starting from the base case - <strong>define the outcome</strong>:</p><p><img data-framer-asset="data:framer/asset-reference,ldejg252aXXQ6sjVGQw2yMWaGs.png" data-framer-height="400" data-framer-width="1584" height="200" src="https://framerusercontent.com/images/ldejg252aXXQ6sjVGQw2yMWaGs.png" width="792"/></p><p>Notice that there is <strong>no pipeline being defined</strong>. An intelligent delivery system uses this configuration to <strong>deliver your intention: the outcome</strong>. </p><p>Juxtapose this with an imperative system where the pipeline is your intention. Therefore, the system cannot adapt.</p><p>The rest of the configuration following the above looks like this:</p><p><strong>Alert Checks</strong></p><p><img data-framer-asset="data:framer/asset-reference,sO1ky2qd7PFOpOTG3N6SbFO1Z0.png" data-framer-height="500" data-framer-width="1576" height="250" src="https://framerusercontent.com/images/sO1ky2qd7PFOpOTG3N6SbFO1Z0.png" width="788"/></p><p><strong>Adding Auto Rollbacks</strong></p><p><img data-framer-asset="data:framer/asset-reference,S8h19Vm6mE68PpaM4Jg2t62hRT0.png" data-framer-height="650" data-framer-width="1578" height="325" src="https://framerusercontent.com/images/S8h19Vm6mE68PpaM4Jg2t62hRT0.png" width="789"/></p><p><strong>Adding Beta environment</strong></p><p><img data-framer-asset="data:framer/asset-reference,RcRn6CaewOaUwT9X7UWbSSCpvM.jpg" data-framer-height="912" data-framer-width="1576" height="456" src="https://framerusercontent.com/images/RcRn6CaewOaUwT9X7UWbSSCpvM.jpg" width="788"/></p><h3>Enabling a New Class of Delivery Systems</h3><p>Declarative configurations free up the delivery system to make intelligent choices and enable user workflows that seemed too hard or impossible in an imperative system. Let’s take the simple case of retries.  </p><p>In the real world of production, things rarely work exactly as planned. Maybe an alert goes off and turns out to be a red herring. This red herring causes a push to fail between staging and prod. What happens in a traditional CD system? </p><p>If a pipeline fails halfway, most CD systems don’t have the ability to retry. The only option is to restart a pipeline from the very beginning. Now with declarative configs, an intelligent delivery system, the system will detect that staging is already on the desired version and skip that push, allowing you to deliver value to your customers faster.</p><p>Another example is skipping environments in a push. Take the scenario from the previous section. Skipping staging here isn’t just skipping the push to staging step, but it is also skipping the alert checks on staging and any staging rollbacks. An intelligent delivery system will be able to take the declarative config and trivially allow skipping of staging, where most CD systems do not support skipping out of the box.</p><p>These are just two of the many ways that an intelligent delivery system can take advantage of declarative configuration. Our mental model of delivery is so tightly coupled to static pipelines that we do not even consider the powerful alternatives that exist.</p><p>A significantly more powerful &amp; robust delivery workflow has emerged by coupling declarative configuration with an intelligent delivery system.</p><p>Just as Google Maps gives you turn-by-turn directions adjusting based on current conditions, <a href="https://www.prodvana.io/" target="_blank">Prodvana’s Dynamic Delivery Platform</a> gives you the power of real-time pipelines. Dynamic Delivery will substantially reduce overhead, and like my dad with paper maps, you’ll never want to go back to static pipelines again. </p></div></div>
  </body>
</html>
