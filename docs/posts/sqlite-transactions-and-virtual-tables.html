<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://misfra.me/2025/sqlite-transactions-and-virtual-tables/">Original</a>
    <h1>SQLite Transactions and Virtual Tables</h1>
    
    <div id="readability-page-1" class="page"><section>
<p>In my <a href="https://misfra.me/2025/virtual-tables-in-sqlite-with-go/">previous post</a> I introduced SQL virtual tables and how to use them in Go—registering modules per connection, defining schemas, and querying external sources as regular tables.</p>
<p>Now let’s dive into more advanced virtual-table implementations: those that support writes and full transactional behavior.</p>
<h3 id="writes-and-transaction-support-in-virtual-tables">Writes and Transaction Support in Virtual Tables</h3>
<p>SQLite’s virtual-table interface isn’t read-only. By implementing <a href="https://sqlite.org/vtab.html#xupdate"><code>xUpdate</code></a> you can expose writable tables over any data source. But true transactional integrity requires more than just row-level updates—it requires hooks for transaction boundaries:</p>
<ul>
<li><strong><code>xBegin</code></strong>: Signal the start of a transaction.</li>
<li><strong><code>xSync</code></strong>: Prepare work for a durable commit; failures here abort everything.</li>
<li><strong><code>xCommit</code></strong>: Finalize the transaction (cleanup only).</li>
<li><strong><code>xRollback</code></strong>: Revert changes if the transaction is aborted.</li>
</ul>
<p>But what happens when your virtual table is modified alongside other virtual tables—or normal tables? How does SQLite ensure everything commits or rolls back atomically?</p>
<h3 id="sqlite-transactions-under-the-hood">SQLite Transactions Under the Hood</h3>
<p>Before tackling vtable hooks, let’s review how SQLite handles transactions by default.</p>
<h4 id="rollback-journals">Rollback Journals</h4>
<p>In its simplest mode, SQLite uses a rollback journal. Before overwriting any page, it writes the original page to a journal file. If something goes wrong, SQLite restores from the journal to guarantee atomicity.</p>
<blockquote>
<p><em>Note: SQLite also supports WAL mode, but that’s outside the scope of this post.</em></p></blockquote>
<h4 id="super-journals-for-multiple-databases">Super-Journals for Multiple Databases</h4>
<p>If you attach additional databases, a single rollback journal per file can’t coordinate commits across them. Enter the super-journal: a top-level journal file that spans all affected databases, ensuring a multi-file commit remains atomic.</p>
<p>For multiple virtual tables within the same database file, however, the standard rollback journal suffices; no super-journal is required. In all cases—whether multiple vtables in one file or across attached databases—virtual-table hooks (<code>xSync</code>, <code>xCommit</code>, <code>xRollback</code>) are invoked as part of SQLite’s transaction process.</p>
<h3 id="two-phase-commit-with-virtual-tables">Two-Phase Commit with Virtual Tables</h3>
<p>SQLite’s two-phase commit breaks down as follows:</p>
<ol>
<li>
<p><strong>Phase One (<code>xSync</code>)</strong></p>
<ul>
<li>SQLite writes and syncs all pages (or journals) to disk for every B-tree and attached database.</li>
<li>For virtual tables, it invokes each module’s <code>xSync</code> hook. If any <code>xSync</code> fails, the entire transaction is rolled back—atomicity is preserved.</li>
</ul>
</li>
<li>
<p><strong>Phase Two (Cleanup)</strong></p>
<ul>
<li>Once durability is guaranteed, SQLite cleans up journal files and finalizes the commit.</li>
</ul>
</li>
</ol>
<p>Below is the core of phase-two logic from <a href="https://github.com/sqlite/sqlite/blob/dc2d79f80fab9bda99ad95f4c7de752feefa927a/src/vdbeaux.c#L3141-L3159"><code>vdbeaux.c</code></a>. Notice that errors are deliberately ignored—this is purely cleanup:</p>
<pre><code>/* All files and directories have already been synced, so the following
** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and
** deleting or truncating journals. If something goes wrong while
** this is happening we don&#39;t really care. The integrity of the
** transaction is already guaranteed, but some stray &#39;cold&#39; journals
** may be lying around. Returning an error code won&#39;t help matters.
*/
disable_simulated_io_errors();
sqlite3BeginBenignMalloc();
for(i=0; i&lt;db-&gt;nDb; i++){
  Btree *pBt = db-&gt;aDb[i].pBt;
  if( pBt ){
    sqlite3BtreeCommitPhaseTwo(pBt, 1);
  }
}
sqlite3EndBenignMalloc();
enable_simulated_io_errors();

/* Now perform virtual-table cleanup */
sqlite3VtabCommit(db);
</code></pre>
<p>And in <a href="https://github.com/sqlite/sqlite/blob/dc2d79f80fab9bda99ad95f4c7de752feefa927a/src/vtab.c#L1016-L1032"><code>vtab.c</code></a>, the virtual-table commit hook is similarly treated as best-effort:</p>
<pre><code>/* From vtab.c: errors in xCommit are ignored—this is purely cleanup. */
int sqlite3VtabCommit(sqlite3 *db){
  callFinaliser(db, offsetof(sqlite3_module,xCommit));
  return SQLITE_OK;
}
</code></pre>
<p>Because <code>xSync</code> already ensured all data is safely on disk, SQLite ignores return codes from <code>xCommit</code> and <code>xRollback</code>. These hooks should only remove temporary state (journals, locks) and must not perform work that can fail.</p>

<ul>
<li><strong>Durability must go in <code>xSync</code>.</strong> Anything that can fail—network I/O, disk writes—belongs in <code>xSync</code> so errors here abort the transaction.</li>
<li><strong><code>xRollback</code> may still be called after <code>xSync</code>.</strong> Even though xSync needs to take care of durability, operations may still need to be rolled back if another <code>xSync</code> failed.</li>
<li><strong>Keep <code>xCommit</code> and <code>xRollback</code> idempotent.</strong> Perform only cleanup; avoid any operation that can fail.</li>
</ul>
<p>By now, you should understand how SQLite’s rollback and super-journal mechanisms coordinate atomic commits, and how your virtual tables hook into that two-phase process to ensure consistency across both built-in and custom tables.</p>

</section></div>
  </body>
</html>
