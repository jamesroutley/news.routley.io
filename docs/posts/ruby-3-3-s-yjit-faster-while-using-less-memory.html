<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://railsatscale.com/2023-12-04-ruby-3-3-s-yjit-faster-while-using-less-memory/">Original</a>
    <h1>Ruby 3.3&#39;s YJIT: Faster While Using Less Memory</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>This year, the YJIT team has been working hard to improve and optimize YJIT. We’re proud
to say that the version of YJIT to be included with Ruby 3.3 is leaps and bounds ahead
of Ruby 3.2’s. It provides better performance across the board, while also warming up faster
and using less memory. The 3.3 release is also more robust, including a number of
bug fixes along with an improved test suite. In this blog post, we share some early
numbers.</p>



<p>YJIT 3.3 includes several optimizations not present in 3.2. One of the main
differences, performance-wise, is that we have much better JIT coverage. That
is, there are much fewer situations where YJIT needs to fall back to the
interpreter. In particular, YJIT is now able to better handle calls with
splats as well as optional parameters, it’s able to compile exception
handlers, and it can handle megamorphic call sites and instance variable
accesses without falling back to the interpreter.</p>

<p>We’ve also implemented specialized inlined primitives for certain core
method calls such as <code>Integer#!=</code>, <code>String#!=</code>, <code>Kernel#block_given?</code>,
<code>Kernel#is_a?</code>, <code>Kernel#instance_of?</code>, <code>Module#===</code>, and more. It also inlines
trivial Ruby methods that only return a constant value such as <code>#blank?</code> and
<a href="https://github.com/rails/rails/pull/49909">specialized <code>#present?</code></a> from Rails.
These can now be used without needing to perform expensive method calls in
most cases.
Lastly, YJIT has a new register allocator which results in slightly
more efficient machine code.</p>

<p>In terms of reducing YJIT’s memory usage, this may be surprising to
some, but the bulk of the memory used by YJIT is not taken by generated
machine code, but rather by metadata YJIT uses to keep track of various
pieces of information associated with said generated code. As such, we’ve
spent a good amount of effort making multiple incremental improvements
to cut down the size of the metadata that we keep.</p>

<p>Another key piece in terms of memory usage has been the introduction of
a “cold threshold” heuristic. With this new heuristic, YJIT tries to cut
down on the amount of “cold”, rarely used method that get compiled. This
doesn’t make any difference on benchmarks, but it’s important for real-world
production scenarios, because there is often a long tail of rarely used
methods that get compiled, which keeps gradually increasing the size of
the generated machine code, sometimes even multiple days after code has
been deployed to production. With this heuristic, we’ve been able to cut
down the size of the generated machine code and its associated metadata
by about 20%. The key takeaway is, we’ve reduced memory usage not just by
using less memory per piece of compiled code, but also by compiling less
code in the first place.</p>

<p>Finally, this may or may not count as an optimization, but we’ve also
made some changes to try and ship YJIT with better defaults out of the
box. Following the 3.2 release, we’ve received feedback from multiple
production deployments that it was necessary to adjust the YJIT
configuration to change the memory size and call threshold values to
get better performance. With YJIT 3.3, we’ve set default values that
should work better for most production deployments. YJIT should now
automatically increase the call threshold for any deployments that
load more than a trivial amount of code, which should result in
a smoother warm-up.</p>

<h2 id="new-features-in-yjit-33">New Features in YJIT 3.3</h2>

<p>YJIT 3.3 doesn’t just include performance improvements. We’ve also added some
new features to make your life easier. One such feature is that it’s now possible
to enable YJIT at run-time from Ruby code by calling <code>RubyVM::YJIT.enable</code>. This
makes it possible to selectively enable YJIT on some forked processes without
enabling it on all processes. It also makes it
possible to only enable YJIT after your app is done booting, so that you can
completely avoid compiling initialization code. The next Rails release will
take advantage of this to
<a href="https://github.com/rails/rails/pull/49947">automatically enable YJIT</a> in an initializer.</p>

<p>We’ve also improved the way we collect run-time stats.
Prior to this, in order to collect performance statistics, you needed to
rebuild Ruby from source to produce a special stats build. Most end users found
this inconvenient, particularly in a production environment. Most of the stats
provided by <code>--yjit-stats</code> are now available in release builds. This will make
troubleshooting performance issues easier.
Please note here that we are talking about statistics for you to consult about
your programs. For security and privacy reasons, YJIT does not “phone home”.</p>

<p>Another recent addition is a new <code>--yjit-perf</code> command-line option which
enables profiling with Linux perf by setting up frame pointers for YJIT
frames and producing a perf map.
More details about new additions to YJIT and Ruby 3.3 are provided in
the <a href="https://www.ruby-lang.org/en/news/2023/12/11/ruby-3-3-0-rc1-released/">release notes</a> for Ruby 3.3.0-rc1.</p>

<h2 id="performance-on-benchmarks">Performance on benchmarks</h2>

<p>We’ve benchmarked YJIT using the headline benchmarks from the <a href="https://github.com/Shopify/yjit-bench">yjit-bench</a> suite.
These are benchmarks based on real-world gems which aim to be representative of real-world use cases,
with a bias towards things that we believe represent typical web workloads.
The graph below shows a comparison of the performance of the Ruby 3.2 interpreter, Ruby 3.3 interpreter,
Ruby 3.2 + YJIT, and Ruby 3.3 + YJIT. The benchmarks were run on a Ryzen 7 3700X machine running Ubuntu Linux 22.04.
Higher is better, with bars being normalized to 1.0 for the performance
of the Ruby 3.2 interpreter. For these experiments, we used a bleeding edge commit directly from the Ruby/master
branch of the <a href="https://github.com/ruby/ruby">git repository</a>.</p>

<p><img src="https://railsatscale.com/2023-12-04-ruby-3-3-s-yjit-faster-while-using-less-memory/images/bars_speedup.png" alt="" width="95%"/></p>

<p>As you can see, YJIT 3.3 delivers a performance boost over YJIT 3.2 on every benchmark,
and the difference is usually quite significant.
Notably, rendering liquid templates is now over 2.5x faster with YJIT enabled than it is using only the
Ruby 3.2 interpreter. Railsbench is about 65% faster with YJIT. We’ve turned the
<a href="https://railsatscale.com/2023-08-25-we-turned-lobsters-into-a-rails-benchmark-for-yjit/">lobste.rs</a> website
into a benchmark, which we can render over 50% faster with YJIT as well, and if you’re using the Ruby LSP
language server in your code editor, YJIT also provides a 50%+ performance boost there too.</p>

<h2 id="memory-usage-on-benchmarks">Memory usage on benchmarks</h2>

<p>JIT compilers typically come with a tradeoff, which is that to some extent, they’re trading slightly
increased memory usage for better performance. As outlined previously, we’ve done a lot to reduce
the amount of memory overhead YJIT incurs. The overhead is still nonzero, but it has been
much improved, to the extent that it’s no longer an issue for our production deployments
at Shopify.</p>

<p><img src="https://railsatscale.com/2023-12-04-ruby-3-3-s-yjit-faster-while-using-less-memory/images/bars_memory.png" alt="" width="95%"/></p>

<p>The graph above shows the memory usage on each of our benchmarks running with and without YJIT enabled for
both Ruby 3.2.2 and 3.3.0. The great news is that the memory usage for YJIT 3.3 is below that
of YJIT 3.2 on almost every benchmark. Part of this reduction in memory usage is due to the work the YJIT team put in to
use memory more effectively. YJIT executes a higher percentage of total YARV instructions than before,
it generates more machine code per Ruby method compiled, and manages to do this with less total overhead.</p>

<p>However, much of the credit for the reduced total memory usage goes to my colleagues
Peter Zhu and Matthew Valentine-House. They’ve done some great work on the Ruby Garbage Collector (GC)
to <a href="https://railsatscale.com/2023-08-08-two-garbage-collection-improvements-made-our-storefronts-8-faster/">improve its performance</a>
and reduce CRuby’s memory usage. You can see this in the above graphs too. It’s not just YJIT’s memory usage
that went down. The memory usage of the CRuby 3.3.0 interpreter is below that of the 3.2.2
interpreter for most benchmarks.</p>

<p>In the spirit of transparency, we note that in the graph above, there is an anomaly, which is that YJIT’s
memory overhead on the <code>hexapdf</code> benchmark is much higher than on other benchmarks. This is something
we’ve discovered as we were producing graphs for this blog post, and are currently investigating. As far
as we can tell so far, it seems to be an issue caused by glibc’s malloc not releasing memory to the
operating system often enough in the presence of <code>mmap</code> calls. Manually calling <code>malloc_trim(3)</code> or
using <code>jemalloc</code> seems to fix the issue.</p>

<h2 id="sfr-production-deployment">SFR Production Deployment</h2>

<p>YJIT has been deployed to all of Shopify’s StoreFront Renderer (SFR) infrastructure for all of 2023.
For context, SFR renders all Shopify storefronts, which is the first thing buyers see when they navigate
to a store hosted by Shopify. It is mostly written in Ruby, depends on over 220 Ruby gems, renders millions of
Shopify stores in over 175 countries, and is served by multiple clusters distributed worldwide.
We’ve deployed Ruby 3.2.2 and 3.3.0 (Ruby master) to experimental clusters (a subset of SFR servers) so
we could gather experimental data for this blog post.</p>

<h3 id="performance-yjit-33-vs-the-cruby-33-interpreter">Performance: YJIT 3.3 vs the CRuby 3.3 Interpreter</h3>

<p>The following graph is a snapshot from our dashboard comparing the performance of the Ruby 3.3.0 interpreter vs YJIT 3.3.0
over the last 12 hours. The speedup figures that we see tend to change over time depending on web traffic, but we believe
it’s representative of the kinds of speedups you can hope to get from YJIT 3.3.
The Y-axis shows the speedup YJIT provides compared to the interpreter. This is computed based on the
total end-to-end time needed to generate a response, including time the SFR servers spend doing I/O, waiting on
databases, and other operations YJIT cannot optimize.
As we can see, the amount of speed boost that YJIT provides over the interpreter changes depending on time of
day and web traffic, but YJIT is consistently faster than the interpreter on average, even on the p99 slowest
requests. This is great, because speeding up the slowest requests makes the most difference to user experience.</p>

<p><img src="https://railsatscale.com/2023-12-04-ruby-3-3-s-yjit-faster-while-using-less-memory/images/sfr_interp_33_vs_yjit.png" alt="" width="95%"/></p>

<p>YJIT 3.3 is generally quite a bit faster than YJIT 3.2 on average. The difference is especially marked on the p99
slowest requests. This is likely because of targeted optimizations made to reduce the time YJIT takes to generate
code, as well as the addition of a “cold threshold” heuristic to reduce the
long tail of code that YJIT compiles. That is, YJIT 3.3 is more selective about which Ruby code it optimizes.</p>

<h3 id="memory-usage-yjit-33-vs-the-cruby-33-interpreter">Memory usage: YJIT 3.3 vs the CRuby 3.3 Interpreter</h3>

<p><img src="https://railsatscale.com/2023-12-04-ruby-3-3-s-yjit-faster-while-using-less-memory/images/sfr_mem_yjit33_interp.png" alt="" width="75%"/></p>

<p>The graph above shows the RSS (Resident Set Size) and PSS (Proportional Set Size) of processes running YJIT
3.3 vs the CRuby 3.3 interpreter over the last 12 hours. When looking at the PSS, which takes into consideration
memory shared between multiple server processes with Unicorn, the memory overhead of enabling YJIT is
currently below 8% for our SFR deployment, which we deem to be a good memory vs performance tradeoff.</p>

<h2 id="optcarrot-and-ruby3x3">Optcarrot and Ruby3x3</h2>

<p>At RubyConf 2015, Yukihiro Matsumoto (aka Matz), chief designer of the Ruby programming language,
<a href="https://www.youtube.com/watch?v=LE0g2TUsJ4U&amp;t=3248s">announced Ruby3x3</a>, the goal of making Ruby 3
three times faster than Ruby 2. He compared this objective to John F. Kennedy’s goal of landing
humans on the moon within the decade. Despite the lack of concrete plans to achieve this, Matz
stated that a JIT compiler may be useful in achieving his inspiring objective.</p>

<p>The <a href="https://github.com/mame/optcarrot">optcarrot benchmark</a> is not one that we look at often at Shopify, because
we don’t consider it to be representative of web workloads, or the workloads that the majority of Ruby users
typically run. This benchmark is a NES emulator. It implements its own interpreter loop, and contains multiple
large methods that perform a lot of bitwise arithmetic, which is something that is almost nonexistent in web
software. However, NES emulators will always be cool, and as self-respecting programmers, we have a moral
duty to ensure that Ruby can make them run fast, akin to the hippocratic oath sworn by doctors.</p>

<p>In December of 2020, Takashi Kokubun’s MJIT achieved <a href="https://k0kubun.medium.com/ruby-3-0-jit-and-beyond-4d9404ce33c">a significant milestone</a> by showing that it could run <code>optcarrot</code>
more than 3 times faster than Ruby 2.0, thereby achieving the Ruby3x3 goal (as long as you accept
performance on <code>optcarrot</code> to be a representative metric of Ruby’s performance).
Today, with the imminent release of YJIT 3.3, we can proudly say that Ruby 3.3 is over 3.3 times
faster than the CRuby 3.3 interpreter on this benchmark, thereby hitting a new major milestone, which
we have coined post-hoc as Ruby3.3x3.3.</p>

<p><img src="https://railsatscale.com/2023-12-04-ruby-3-3-s-yjit-faster-while-using-less-memory/images/bars_optcarrot.png" alt="" width="95%"/></p>

<p>As can be seen in the graph above, performance on <code>optcarrot</code> has gone up markedly with every new
YJIT release. According to stats produced by <code>--yjit-stats</code>, YJIT now executes more
than 99.1% of the instructions in this benchmark, and is also able to inline 79.9% of C function calls,
most of which are calls to Ruby runtime functions which YJIT is able to optimize. We hope to be able
to deliver even better performance for Ruby NES emulators next year.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Ruby 3.3.0 release will be available for you to download <a href="https://www.ruby-lang.org/en/">on ruby-lang.org</a>
on December 25th. In the mean time, if you’re feeling really impatient to play with Ruby 3.3, you can find the latest
release candidate along with its release notes on the <a href="https://www.ruby-lang.org/en/downloads/releases/">Ruby releases page</a>.
With this release comes a much more capable version of YJIT, with multiple major improvements. The bottom line is that YJIT
performs better, while using memory more efficiently and warming up faster.</p>

<p>If you’re interested in learning more about YJIT, we’ve published a paper at the MPLR 2023 conference, which is now freely available
through <a href="https://dl.acm.org/doi/10.1145/3617651.3622982">ACM open access</a>. A video recording of our presentation at MPLR is also
<a href="https://www.youtube.com/watch?v=fMGuQXNqlaE&amp;t=9900s">available on YouTube</a>.
There are also multiple presentations about YJIT available on YouTube, ranging from
<a href="https://www.youtube.com/watch?v=X0JRhh8w_4I">very approachable</a> to <a href="https://www.youtube.com/watch?v=EMchdR9C8XM">deeply technical</a>.</p>

<p>Lastly, I’d like to give a big thanks to Shopify, Ruby &amp; Rails Infrastructure and the YJIT team for making this project possible.
Thank you Aaron Patterson for helping me put together this blog post.
A special shout out goes to Alan Wu and Takashi Kokubun. Two incredibly talented programmers that I have the privilege to work
with on the YJIT project. They’ve worked tirelessly to make the Ruby 3.3 release as performant and stable as possible.
If you’re using YJIT in production, please give us a shout out on Twitter/X. It’s always very rewarding for us to hear about
YJIT being deployed in the wild!</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
