<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blueberrywren.dev/blog/on-zig/">Original</a>
    <h1>Zig and the design choices within</h1>
    
    <div id="readability-page-1" class="page"><section>
    <div>


      



  <meta property="og:title" content="Opinion piece: On Zig (and the design choices within)"/>
  <title> Opinion piece: On Zig (and the design choices within) </title>




<div>
  <p><strong>2025-10-14</strong></p>
  
  <p><img src="https://blueberrywren.dev/wren_glasses.png" alt="A Wren."/>  
</p></div>

<details><summary>
Table of contents
</summary>

    <ul>
    
        <li>
            <a href="https://blueberrywren.dev/blog/on-zig/#ideological-differences">Ideological differences</a>
            
                <ul>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#memory">Memory</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#philosophy">Philosophy</a>
                        </li>
                    
                </ul>
            
        </li>
    
        <li>
            <a href="https://blueberrywren.dev/blog/on-zig/#practical">Practical</a>
            
                <ul>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#comptime">Comptime</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#casting">Casting</a>
                        </li>
                    
                </ul>
            
        </li>
    
        <li>
            <a href="https://blueberrywren.dev/blog/on-zig/#semantics">Semantics</a>
            
                <ul>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#result-location-semantics-rls">Result location semantics (RLS)</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#pointer-reference-optimization">Pointer reference optimization</a>
                        </li>
                    
                </ul>
            
        </li>
    
        <li>
            <a href="https://blueberrywren.dev/blog/on-zig/#misc-improvable-things">Misc. Improvable things</a>
            
                <ul>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#speed">Speed</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#tooling">Tooling</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#debug-mode">Debug mode</a>
                        </li>
                    
                </ul>
            
        </li>
    
        <li>
            <a href="https://blueberrywren.dev/blog/on-zig/#misc-improvable-things-that-won-t-be-improved-for-reasons-beyond-me">Misc. Improvable things that won&#39;t be improved for reasons beyond me</a>
            
                <ul>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#behavior-around-undefined">Behavior around undefined</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#tabs">Tabs</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#iteration">Iteration</a>
                        </li>
                    
                        <li>
                            <a href="https://blueberrywren.dev/blog/on-zig/#warnings">Warnings</a>
                        </li>
                    
                </ul>
            
        </li>
    
        <li>
            <a href="https://blueberrywren.dev/blog/on-zig/#my-only-note-on-the-community">My only note on the community</a>
            
        </li>
    
        <li>
            <a href="https://blueberrywren.dev/blog/on-zig/#summary">Summary</a>
            
        </li>
    
    </ul>

</details>

<p>(From someone who has spent far too much time thinking about the designs of programming languages)</p>
<p>This post is split up into a few sections. I would also like to preface this post with:</p>
<ol>
<li>Existing memory safe languages are not perfect. Rust will be used as an example quite a bit, as from what is currently avaliable, it embodies closer to what I think is reasonable in a programming language. However, there is still much room for improvement in this space.</li>
<li>All of the following is ultimately my opinion. If you disagree, you are welcome to find me somewhere on the internet and ask me more.</li>
<li>I bear no grudge or ill will against anyone who contributes to, works on, or is otherwise involved in the Zig community. The following are things I have noted about the language, not the people behind it. If you enjoy Zig, go and write it, and make cool stuff - I am not the programming language police.</li>
<li>Exception to the above: I have one gripe about the Zig community. This gripe &#34;targets&#34; no one person in particular; rather, larger trends.</li>
</ol>
<h2 id="ideological-differences">Ideological differences</h2>
<h3 id="memory">Memory</h3>
<p>First, and very much foremost, Zig is not memory safe. This is, in my opinion, the most
egregious thing in this post, by a very large margin. Moreso, Zig does not make any attempt to
be memory safe -
it can catch some things at runtime, with specific allocators, but so can C these days. Indeed, there
are some cases, like use-after-realloc, that <code>asan</code> can catch and Zig cannot.</p>
<p>A language in the modern day that does not make an attempt at memory safety is, in my opinion, not reasonable. It has been shown that in some areas, up to 70% of security bugs are due to memory safety issues (<a href="https://www.chromium.org/Home/chromium-security/memory-safety/">Source</a>).</p>
<p>I subscribe to the idea that the user must be constrained. It is perhaps harsh to say, but for large and complex programs, I believe that there are very few programmers who will write memory-correct code nine times out of ten. When writing code with others, that goes down. I personally do not believe I fit into that category.</p>
<p>The fact that Zig allows the user to write faulty software is supported by various somewhat informal, but still useful, statistics. Notably, the following statistic disregard duplicates, and unreported errors. However, general trends are still of note. </p><details><summary>Here are some:</summary>
<ol>
<li>The Rust compiler has had a lifetime 59,780 issues reported. Of these, 4,158 contain one of &#34;crash&#34;, &#34;segmentation fault&#34;, or &#34;segfault&#34;.</li>
<li>The Zig compiler has had a lifetime 13,269 issues reported. Of these, 2,260 contain one of &#34;crash&#34;, &#34;segmentation fault&#34;, or &#34;segfault&#34;.</li>
</ol>
<p>This means that, roughly:</p>
<ol>
<li>7% of lifetime issues reported in the Rust compiler are crashes.</li>
<li>17% of lifetime issues reported in the Zig compiler are crashes.</li>
</ol>
<p>Not ideal.</p>
<ol>
<li>The Node/v8 JS runtime, written partially itself in JS and partially in C++, has had a lifetime 19,631 issues reported, 1,710 of which contain one of the above keywords.</li>
<li>The Deno JS runtime, written primarily in Rust, has had a lifetime 13,422 issues reported, 552 of which contain one of the above keywords.</li>
<li>The Bun JS runtime, written in Zig, has had a lifetime 13,828 issues reported, 3676 of which contain one of the above keywords.</li>
</ol>
<p>Again, this roughly means:</p>
<ol>
<li>8.7% of lifetime issues reported in Node are crashes.</li>
<li>4.1% of lifetime issues reported in Deno are crashes.</li>
<li>26.5% (!!!) of lifetime issues reported in Bun are crashes.</li>
</ol>
<p>Also not great. Again, these statistics are slightly off at best simply due to the nature of their collection, but the trends do not lie.</p>
</details>
<p>If you&#39;re not reading the above: It can be summarized as &#34;Not ideal.&#34;</p>
<h3 id="philosophy">Philosophy</h3>
<p>At one point, this part of the article contained a runthrough of the <code>zig zen</code>, and my opinions on each bullet point. I have decided that that is not a constructive discussion of Zig. It suffices for me to say that I do not believe Zig particularly embodies its own zen.</p>
<h2 id="practical">Practical</h2>
<h3 id="comptime">Comptime</h3>
<p>Zig does generics in an odd way. I believe this is the best way of putting it.
This post is not meant to be, nor will it contain, a proper explanation of Zig&#39;s <code>comptime</code>
capabilities, so I refer the reader to the wider internet there. However, doing generics
with &#34;normal&#34; code means that there are multiple ways to write the same generic function.
There is no standardization between different libraries, different styles of writing code, and
different users of Zig. Every person can do generics in their own special way.</p>
<p>This obviously has slightly dire effects on readability. In practice, most Zig users are reasonable enough
to stick to some &#34;common patterns&#34; of doing generics and similar, but it is widely known that if the user is giving the ability to do something, it will be done. I believe that generics are important enough they should be first class.</p>
<p>Arguments can be made that Zig&#39;s comptime is also useful for other things, not just generics. Some examples I have been given are conditional compilation, and variadic functions. Beyond these, I am yet to see a convincing motivating example that <em>requires</em> the machinery that Zig provides. Every such example can, in my experience, be solved with less powerful (and hence, for the most part, less confusing) machinery.</p>
<p>As a result, I am inclined to believe that Zig&#39;s comptime is a very large and all-encompassing feature that ultimately brings very little to the table that smaller features cannot.</p>
<p>I am personally a proponent of a good macro system, but I will readily admit people can also go overboard with one of those.</p>
<h3 id="casting">Casting</h3>
<p>Zig&#39;s casting is a bit cumbersome. To cast a float to a specific int width, for example, must be done with <code>@as(i32, @intFromFloat(flt))</code>. Bit of a mouthful. Inference can help here (For example if a variable is already known to be a <code>i32</code>, the outer cast is not needed), but I would think that with Zig&#39;s comptime abilities, this could be made a bit nicer. Luckily, it is common Zig practice to annotate everything if possible, so this does come up slightly less in practice. It is still a bit bulky however.</p>
<p>Float to int casting additionally can invoke undefined behavior if the float is outside the integer&#39;s range. I personally prefer truncating semantics, with perhaps a specialized method (<code>intFromFloatUnsafe</code>?) for UB semantics. That&#39;s more of a personal preference though.</p>
<h2 id="semantics">Semantics</h2>
<h3 id="result-location-semantics-rls">Result location semantics (RLS)</h3>
<p><a href="https://ziglang.org/documentation/0.15.1/#Result-Location-Semantics">See here</a>.</p>
<p>Result location semantics are in theory a quite nice idea. Knowing predictably where things are going to be placed in memory is, of course, good for any systems-adjacent language! In practice, there are several choices within RLS that I find counterintuitive. Take the following example, where we attempt to swap two struct members in place:</p>
<pre data-lang="rust"><code data-lang="rust"><span>
</span><span>const</span><span> std </span><span>= @</span><span>import</span><span>(</span><span>&#34;std&#34;</span><span>);
</span><span>const</span><span> What </span><span>= </span><span>struct </span><span>{
</span><span>    a: i32,
</span><span>    b: i32,
</span><span>};
</span><span>
</span><span>pub </span><span>fn </span><span>main</span><span>() void {
</span><span>    var x: What </span><span>= </span><span>.{ .a </span><span>= </span><span>1</span><span>, .b </span><span>= </span><span>2 </span><span>};
</span><span>    x </span><span>=</span><span> What { .a </span><span>=</span><span> x.b, .b </span><span>=</span><span> x.a };
</span><span>    std.log.</span><span>info</span><span>(</span><span>&#34;x: {}&#34;</span><span>, .{x});
</span><span>
</span><span>    var y: What </span><span>= </span><span>.{ .a </span><span>= </span><span>1</span><span>, .b </span><span>= </span><span>2 </span><span>};
</span><span>    y </span><span>= </span><span>.{ .a </span><span>=</span><span> y.b, .b </span><span>=</span><span> y.a };
</span><span>    std.log.</span><span>info</span><span>(</span><span>&#34;y: {}&#34;</span><span>, .{y});
</span><span>}
</span></code></pre>
<p>This outputs the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span>info: x: .{ .a </span><span>= </span><span>2</span><span>, .b </span><span>= </span><span>1 </span><span>}
</span><span>info: y: .{ .a </span><span>= </span><span>2</span><span>, .b </span><span>= </span><span>2 </span><span>}
</span></code></pre>
<p>I will note that the equivalent C can only be written in the former style, and it prints the former.</p>
<p>The only difference between the latter and the former is whether the type name is present. This is intended behavior! Indeed, this very example is given in the Zig reference, a fact that I find odd. Why give a warning against something when you could just fix it? Zig does not have move or copy constructors; I do not think there is very much reason for the latter to ever behave the way it does. One extra register is all you ever need, even for an arbitrary parallel move! (<a href="https://compiler.club/parallel-moves/">Source</a>.)</p>
<h3 id="pointer-reference-optimization">Pointer reference optimization</h3>
<p>In its previous form, PRO has been removed from Zig. There was a long period where this would print <code>5</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>const</span><span> std </span><span>= @</span><span>import</span><span>(</span><span>&#34;std&#34;</span><span>);
</span><span>
</span><span>const </span><span>AAAA </span><span>= </span><span>struct </span><span>{
</span><span>    foo: [100]u32,
</span><span>};
</span><span>
</span><span>fn </span><span>kindabad</span><span>(</span><span>a</span><span>: AAAA, </span><span>b</span><span>: *AAAA) void {
</span><span>  b.</span><span>*</span><span>.foo[</span><span>0</span><span>] </span><span>= </span><span>5</span><span>;
</span><span>
</span><span>  std.debug.</span><span>print</span><span>(</span><span>&#34;unideal: {}&#34;</span><span>, .{ a.foo[</span><span>0</span><span>] });
</span><span>}
</span><span>
</span><span>pub </span><span>fn </span><span>main</span><span>() </span><span>!</span><span>void {
</span><span>    var f: </span><span>AAAA </span><span>=</span><span> undefined;
</span><span>
</span><span>    f.foo[</span><span>0</span><span>] </span><span>= </span><span>0</span><span>;
</span><span>
</span><span>    </span><span>kindabad</span><span>(f, </span><span>&amp;</span><span>f);
</span><span>}
</span></code></pre>
<p>As Zig would correctly, per PRO at the time, but incorrectly per common sense, pass <code>a</code> as a reference.</p>
<p>This is actually mildly unfortunate. It&#39;s a very interesting optimization, and being able to guarantee behavior around optimization of parameter passing would also be quite beneficial. Unfortunately, Zig simply does not have the level of control needed to do it. Aliasing is freely allowed, and in order to make PRO work, it cannot be. Rust can, and in many cases does, do this! It&#39;s a shame Zig has to miss out.</p>
<p>There is current work to make PRO work in the case of pure functions (<a href="https://github.com/ziglang/zig/issues/5973#issuecomment-2380332493">Source</a>), so I remain hopeful that it will return in some form eventually.</p>
<h2 id="misc-improvable-things">Misc. Improvable things</h2>
<h3 id="speed">Speed</h3>
<p>The Zig compiler is not particularly fast. The LLVM backend even more so; compared to Clang, (which has the home field advantage, but can still be quite slow), and by my measurements, Clang is consistently between 3-10x faster. A new Zig backend has been written to help fix this; by similar measurements, it is consistently faster than Clang by 1.5-2x, and much faster than the Zig LLVM backend. While these numbers are nothing to scoff at, I believe there is more room for improvement, and I would like to see where it goes. Zig is a simpler language than C when comptime is not involved, and I would be excited to see that reflected in the benchmarks. It is also possible that Zig could use LLVM more efficiently, but I cannot comment on this without digging into the internals of the compiler.</p>
<p>Of course, all of this is quite reasonable. The Zig compiler has had far, far fewer man-hours put into it, and this of course reflects in aspects of the compiler that simply take a lot of time, such as these. I look forward to seeing what can be done in the future.</p>
<h3 id="tooling">Tooling</h3>
<h4 id="build-system">Build system</h4>
<p>The Zig build system is a little confusing. It is very neat to be able to write build system code in the language itself, and this is a feature I believe more languages should have. Unfortunately, it is as of current not well documented enough to justify its own complexity. This of course can be improved, and I hope it is.</p>
<h4 id="language-server">Language server</h4>
<p>Zig currently does not have a &#34;first class&#34; language server. The &#34;Zig Language Server&#34;, or ZLS, is unofficial; It does not have real compiler integration, so it is unfortunately limited in some ways. The creator of Zig apparently does not use a language server while programming, so I do slightly understand why it is not a priority, but I personally believe tools like a good language server are quite essential to wider/popular usage. Here are some quotes I have heard from people who have used it far more than I:</p>
<ul>
<li>&#34;Deeply horrid&#34;</li>
<li>&#34;It is one of the worst LSPs I have ever used&#34;</li>
<li>&#34;Don&#39;t get me started&#34;</li>
</ul>
<p>Apparently it is very limited when <code>comptime</code> comes into play, and cannot handle compound types like 2D arrays.</p>
<p>I cannot offer much firsthand experience however.</p>
<h3 id="debug-mode">Debug mode</h3>
<p>There are always more errors to be caught. I particularly recently noticed that Zig cannot currently catch use-after-realloc errors, like the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span>const</span><span> std </span><span>= @</span><span>import</span><span>(</span><span>&#34;std&#34;</span><span>);
</span><span>
</span><span>pub </span><span>fn </span><span>main</span><span>() </span><span>!</span><span>void {
</span><span>    </span><span>const</span><span> allocator </span><span>=</span><span> std.heap.page_allocator;
</span><span>
</span><span>    var buffer </span><span>=</span><span> try allocator.</span><span>alloc</span><span>(</span><span>u8</span><span>, </span><span>4</span><span>);
</span><span>
</span><span>    buffer[</span><span>0</span><span>] </span><span>= </span><span>1</span><span>;
</span><span>    
</span><span>    </span><span>const</span><span> new_buffer </span><span>=</span><span> try allocator.</span><span>realloc</span><span>(buffer, </span><span>8</span><span>);
</span><span>    
</span><span>    </span><span>// Should be caught!
</span><span>    buffer[</span><span>0</span><span>] </span><span>= </span><span>99</span><span>; 
</span><span>
</span><span>    allocator.</span><span>free</span><span>(new_buffer);
</span><span>}
</span></code></pre>
<p>Address sanitizer with Clang can catch this, so theoretically Zig should be able to catch it (perhaps with a similar system) too.</p>
<h2 id="misc-improvable-things-that-won-t-be-improved-for-reasons-beyond-me">Misc. Improvable things that won&#39;t be improved for reasons beyond me</h2>
<h3 id="behavior-around-undefined">Behavior around <code>undefined</code></h3>
<h4 id="debug-mode-1">Debug mode</h4>
<p>Apparently, it is desired that comparisons with <code>undefined</code> panic. This seems reasonable to me. However, the issue for this has been open <a href="https://github.com/ziglang/zig/issues/63">for almost ten years</a>, which makes me worry that it might be a while still until it is finished.</p>
<p>This panics in <code>Debug</code> and <code>ReleaseSafe</code> modes, however, so it does at least work in some cases.</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub </span><span>fn </span><span>main</span><span>() void {
</span><span>    </span><span>const</span><span> x: </span><span>u32 </span><span>=</span><span> undefined;
</span><span>    </span><span>if </span><span>(x </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>1</span><span>;
</span><span>    } </span><span>else </span><span>{
</span><span>        </span><span>return </span><span>0</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<h4 id="safety">Safety</h4>
<p>According to <a href="https://github.com/ziglang/zig/issues/21915">this issue</a>, it is &#34;not a goal of the Zig compiler&#34; to catch issues like the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub </span><span>fn </span><span>main</span><span>() void {
</span><span>    var buf: []</span><span>u8 </span><span>=</span><span> undefined;
</span><span>    
</span><span>    </span><span>// Very not allowed!
</span><span>    buf[</span><span>0</span><span>] </span><span>= </span><span>1</span><span>;
</span><span>}
</span></code></pre>
<p>This just seems silly to me. Catching something like this, in the simple case, should be just one pass over the AST; why not do it?</p>
<h3 id="tabs">Tabs</h3>
<p>Zig simply doesn&#39;t allow tabs in comments and strings? <a href="https://github.com/ziglang/zig-spec/issues/38">This issue</a> explains more, but the justification of &#34;it (a tab) is ambiguous (in) how it should be rendered&#34;, I do not quite agree with.</p>
<p>Strings make some sense; you can still write <code>\t</code> for a tab, and they do indeed make output ambiguous. However, they&#39;re still allowed in indentation! This means that in commenting out code, you can take a program from valid to invalid. <code>zig fmt</code> does reify tabs into spaces, but if your editor is misconfigured and you&#39;re not running <code>zig fmt</code> constantly?</p>
<pre><code><span>tabs.zig:5:36: error: comment contains invalid byte: &#39;\t&#39;
</span><span>//        const str: *const [1:0]u8 = &#34;w&#34;;
</span><span>  ^~~~~~~~~~~
</span></code></pre>
<p>Very odd.</p>
<h3 id="iteration">Iteration</h3>
<p>Zig does not have a way to iterate through a slice or similar in any way except one-at-a-time forwards. Anything else? You&#39;re using a <code>while</code> loop, and you&#39;ll enjoy it. Zig blanket bans proposals to change the language, so despite issues like <a href="https://github.com/ziglang/zig/issues/21814">this one</a>, I doubt this will happen any time soon.</p>
<h3 id="warnings">Warnings</h3>
<p>Zig doesn&#39;t have &#39;em. Everything is an error. In practice, this mostly manifests through reasonably harmless things like &#34;unused variable&#34; notices becoming errors, which is reasonably annoying when just trying to spitball.</p>

<p>For the most part, the community is about par for the course for programming language communities; that is to say, quite nice. However, I have had some reasonably negative interactions that I feel are somewhat of a general trend. They usually proceed like the following:</p>
<ol>
<li>I ask a question about solving something in Zig. Often, given my background, it is about adapting my more functional-esque thinking to Zig.</li>
<li>Someone chimes in with a half-solution that does not actually address my problem.</li>
<li>I attempt to communicate this to them, which often involves explaining the features I would use in &lt;insert other language&gt;.</li>
<li>They insist that these features are not needed, but do not elaborate on how one would solve the problem without them.</li>
</ol>
<p>This is unpleasant, and while it&#39;s not a particularly uncommon thing to see in programming language communities, Zig seems to have a bit of a bad case of it. I suspect it is due to Zig&#39;s fairly minimalistic nature; it lacks a lot of features that one would otherwise use to solve problems. Of course, this is the appeal for many, but still. It is made worse when said topic is something one is particularly knowledgeable about, and the people you are conversing with believe they can solve the issue without that knowledge.</p>
<p>I do not believe that a few bad apples necessarily spoil the whole barrel here, but they definitely sour it.</p>
<h2 id="summary">Summary</h2>
<p>I find Zig interesting, with an unfortunately negative connotation. I believe the goal of a C-like memory unsafe language &#34;for the modern day&#34;, while interesting at first glance, ignores many of the issues that make C a problem in said modern day. Much of Zig seems to me like &#34;wishful thinking&#34;; if every programmer was 150% smarter and more capable, perhaps it would work. Alas, they are not; myself included.</p>
<p>I believe that modern concerns of memory safety and correctness require modern solutions; not performing patchwork fixes over the core issue.</p>




      </div>
  </section></div>
  </body>
</html>
