<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mattkeeter.com/blog/2022-12-10-xor/">Original</a>
    <h1>A neat XOR trick</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<!-- End header -->



<h2>A Neat XOR Trick</h2>
<p>There&#39;s a neat trick to solve <a href="https://adventofcode.com/2022/day/6">Advent of Code, day 6</a>
in a single pass.</p>
<p>Looking over the <a href="https://www.reddit.com/r/adventofcode/comments/zdw0u6/2022_day_6_solutions/iz4l6xk/">solutions mega-thread</a>,
it seems like not many people discovered this trick;
when I <a href="https://www.reddit.com/r/adventofcode/comments/zdw0u6/2022_day_6_solutions/iz4l6xk/">posted about it</a>,
people found it to be noteworthy.</p>
<p>Let&#39;s start with a brief summary of the problem: you&#39;re given an input string,
e.g.</p>
<pre><code>nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg
</code></pre>
<p>Within this string, you want to find the first <code>W</code>-character window in which
every character is unique.</p>
<p>For this example, with a 4-character window, this occurs here:</p>
<pre><code>nznrnf [rfnt] jfmvfwmzdfjlvtqnbhcprsg
</code></pre>
<p>Naively, you can do this with three nested loops:</p>
<pre><code>fn run(s: &amp;[char], window_size: usize) -&gt; usize {
    for i in 0..s.len() - window_size {
        let mut unique = true;
        for j in 0..window_size {
            for k in (j + 1)..window_size {
                if s[i + j] == s[i + k] {
                    unique = false;
                }
            }
        }
        if unique {
            return i + window_size;
        }
    }
    panic!(&#34;No unique window found&#34;);
}
</code></pre>
<p>With an input string of length <code>N</code> and a window size <code>W</code>, the
<a href="https://en.wikipedia.org/wiki/Big_O_notation">running time</a>
of this implementation is <code>O(N * W * W)</code>.</p>
<p>There&#39;s an obvious algorithmic optimization: instead of comparing each element
within the window, we could instead build a <code>HashSet</code> and check its size:</p>
<pre><code>fn run(s: &amp;[char], window_size: usize) -&gt; usize {
    for i in 0..s.len() - window_size {
        let mut set = HashSet::new();
        for j in 0..window_size {
            set.insert(s[i + j]);
        }
        if set.len() == window_size {
            return i + window_size;
        }
    }
    panic!(&#34;No unique window found&#34;);
}
</code></pre>
<p>Insertion into the <code>HashSet</code> is <code>O(1)</code>, so our running time is down to <code>O(N * W)</code>.</p>
<p>(Whether this is faster <em>in practice</em> is left as an exercise to the reader,
since it adds allocation into the mix)</p>
<p>However, there&#39;s <em>still</em> room to improve, with a little trickery.</p>
<p>First, let&#39;s eliminate the <code>HashSet</code>.  We can consider each character as a
bitmask:</p>
<pre><code>a = 10000000000000000000000000000000
b = 01000000000000000000000000000000
c = 00100000000000000000000000000000
d = 00010000000000000000000000000000
...etc
</code></pre>
<p>Given a set of characters, we can see which ones are present by combining
these bitmasks with <em>or</em> (which is written as <code>|</code>):</p>
<pre><code>a | b | c = 11100000000000000000000000000000
</code></pre>
<p>If we have a set of <code>W</code> characters, the <em>or</em> of their bitmasks will have <code>W</code>
bits set <strong>if and only if</strong> those characters are unique.</p>
<pre><code>a | b | c = 11100000000000000000000000000000
a | b | b = 11000000000000000000000000000000
</code></pre>
<p>Hopefully, this is intuitively obvious: each character can only activate one bit
in the result, so if we have <code>W</code> bits set, then we have <code>W</code> unique characters.</p>
<p>In Rust, we check how many bits are set with <a href="https://doc.rust-lang.org/std/primitive.u32.html#method.count_ones"><code>count_ones</code></a>.
With <code>-C target-cpu=native</code> passed to the compiler,
it should compile down to 1-2 instructions:</p>
<ul>
<li><a href="https://www.felixcloutier.com/x86/popcnt"><code>popcnt</code></a> on x86;</li>
<li><a href="https://developer.arm.com/documentation/ddi0602/2022-09/SIMD-FP-Instructions/CNT--Population-Count-per-byte-"><code>cnt.8b</code></a> followed by <a href="https://developer.arm.com/documentation/dui0801/h/A64-SIMD-Vector-Instructions/UADDLV--vector-"><code>uaddlv.8b</code></a> on AArch64</li>
</ul>
<p>We can use this bitmask to replace our <code>HashSet</code>:</p>
<pre><code>fn run(s: &amp;[char], window_size: usize) -&gt; usize {
    for i in 0..s.len() - window_size {
        let mut set = 0u32;
        for j in 0..window_size {
            set |= 1 &lt;&lt; (s[i + j] as u32 - &#39;a&#39; as u32);
        }
        if set.count_ones() as usize == window_size {
            return i + window_size;
        }
    }
    panic!(&#34;No unique window found&#34;);
}
</code></pre>
<p>(and now there are zero allocations!)</p>
<p>The code is still <code>O(N * W)</code> – because we have an outer and inner loop –
but it&#39;s prepared us for the final trick.</p>
<p>Consider a slight modification to our previous axiom:</p>
<p>If we have a set of <code>W</code> characters, the <a href="https://en.wikipedia.org/wiki/Exclusive_or"><em><strong>xor</strong></em></a>
of their bitmasks will have <code>W</code> bits set <strong>if and only if</strong> those characters are
unique.</p>
<pre><code>a ^ b ^ c = 11100000000000000000000000000000
a ^ b ^ b = 10000000000000000000000000000000
</code></pre>
<p>This is <em>less</em> intuitively obvious: everyone that I&#39;ve presented it to,
including myself, has to convince themself that it&#39;s correct.</p>
<p><a href="https://www.reddit.com/r/adventofcode/comments/zdw0u6/2022_day_6_solutions/iz5ku3s/">One reply</a> on Reddit has a particularly good explanation
(edited to match the convention of using <code>W</code> for window size):</p>
<blockquote>
<p>This algorithm is just counting how many characters appear an odd number of
times in a window of size <code>W</code>. That number will be <code>W</code> if-and-only-if they&#39;re
all unique!</p>
</blockquote>
<p>Using <code>xor</code> is more powerful than <code>or</code>, because of one particular property:</p>
<pre><code>a ^ b ^ a = b
</code></pre>
<p>Applying <em>xor</em> twice will turn a bit on, then back off.</p>
<p>In other words, we can maintain the bitset for a sliding window in a single
<code>u32</code>, turning bits on as they enter the window and off as they leave.</p>
<p>This eliminates the inner loop from our previous function:</p>
<pre><code>fn run(s: &amp;[char], window_size: usize) -&gt; usize {
    let mut set = 0u32;
    for i in 0..s.len() {
        // Turn on bits as they enter the window
        set ^= 1 &lt;&lt; (s[i] as u32 - &#39;a&#39; as u32);

        // Turn off bits as they leave the window
        if i &gt;= window_size {
            set ^= 1 &lt;&lt; (s[i - window_size] as u32 - &#39;a&#39; as u32);
        }

        // Check the current window and see if we&#39;re done
        if set.count_ones() as usize == window_size {
            return i + 1;
        }
    }
    panic!(&#34;No unique window found&#34;);
}
</code></pre>
<p>With this last trick, we&#39;re down to <code>O(N)</code> running time, with no dependence on
the window size!
I didn&#39;t do rigorous benchmarking, but
<a href="https://www.reddit.com/r/adventofcode/comments/zdw0u6/2022_day_6_solutions/iz67dm2/">one reply</a>
said that this trick sped up their code by almost 3x.</p>
<p>There&#39;s no moral to the story, other than &#34;xor is cool&#34;.  I hope everyone is
enjoying Advent of Code!</p>
<h2>Further reading</h2>
<p>If you want to read about overengineered solutions to Advent of Code problems,
I&#39;ve got a few other blog posts in this vein:</p>
<ul>
<li><a href="https://www.mattkeeter.com/blog/2021-12-27-brute">2021, Day 24: Brute-forcing 22 trillion parameters</a></li>
<li><a href="https://www.mattkeeter.com/projects/synthesis/">2019, Day 21: Program Synthesis with Z3</a> (a personal favorite)</li>
<li><a href="https://www.mattkeeter.com/projects/elfjit">2018, Day 21: Elf Assembly JIT Compiler</a></li>
</ul>

<!-- Begin footer -->
</div></div>
  </body>
</html>
