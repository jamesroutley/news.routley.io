<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.williammanley.net/2022/02/23/pip-and-cargo-are-not-the-same.html">Original</a>
    <h1>Pip and cargo are not the same</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>I often see Rust’s cargo package manager dismissed in online discussions by
analogy to pip and npm.  Cargo/rust doesn’t suffer from many of the problems
that pip does.  Some of these reasons are not just about cargo, they’re also
about how Rust is different to Python and about how Cargo and Rust integrate:</p>

<ol>
  <li>There are only venvs with Cargo, so you can’t install crates into a location
where it will interfere with other unrelated rust programs.</li>
  <li>Rust programs are “almost statically linked”.  Typically they only dynamically
link against libc, and possibly a few more common libraries like openssl.</li>
  <li>You don’t need to worry about reproducing the build environment on the host
that will be running the executable.  Usually just copying the executable
over is sufficient (see (2)).</li>
  <li>There is a 1 to 1 relationship between cargo crate names and what gets <code>use</code>d
in the rust file. With pip your pypi package <code>moo</code> can include Python package
<code>foo</code>, or whatever else it likes.</li>
  <li>Similarly you can’t <code>use</code> something in your rust code that you haven’t asked
for in your <code>Cargo.toml</code> - transitive dependencies of your dependencies
(mostly) don’t affect you.</li>
  <li>Rust provides many tools for managing privacy, so the public interface of a
package is explicit. This makes it much harder to accidentally depend on
something the crate author considers an implementation detail, making a cargo
update much less likely to break your application than the Python equivalent.</li>
  <li>There is a culture of taking compatibility seriously in the rust ecosystem.
Crates are expected to maintain API compatibility for major versions and
<a href="https://doc.rust-lang.org/cargo/reference/semver.html">Cargo requires the same</a>.</li>
  <li>Cargo requires lockfiles, and can generate a lockfile just based on the
<code>Cargo.toml</code> and the crates.io index.  Pip has <code>pip freeze</code>, but that just
captures the packages you’ve got installed.  So it requires that the packages
be installed in the first place, and won’t include packages that are required
on other OSs for example.  <a href="https://pipenv.pypa.io/en/latest/">Pipenv</a> helps here.</li>
  <li>Rust packages tend to be more self-contained than Python ones.  Often Python
packages will be bindings to existing libraries, while Rust ones will be pure
rust.  This means that you run into issues of missing system dependencies far
less often with Cargo than Pip.</li>
  <li>Rust maintains much better backwards compatibility than Python.  Upgrading
to a newer version of Rust for a dependency is very unlikely to break your
build - and if it will break anything it will break at build time, rather
than run time.  Upgrading Python often causes your code or dependencies to break
and requires you upgrade Python on your deployment target as well.  Rust
doesn’t even need to be installed on your deployment target.</li>
  <li>A rust executable can include different versions of the same crate in the
same rust executable - so you don’t need your transitive dependencies to all
agree on the same version if there are compatibility issues.</li>
</ol>

<p>I don’t have any first hand experience with npm, but I believe at least some of
the above will apply there too.</p>


</div></div>
  </body>
</html>
