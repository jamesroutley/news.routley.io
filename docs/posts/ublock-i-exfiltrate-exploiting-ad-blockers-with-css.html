<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://portswigger.net/research/ublock-i-exfiltrate-exploiting-ad-blockers-with-css">Original</a>
    <h1>uBlock, I exfiltrate: exploiting ad blockers with CSS</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    
    
<div>
    <p><img alt="Gareth Heyes" src="http://ballingt.com/content/images/profiles/callout_gareth_heyes_114px.png"/></p>
</div>
    <ul>
        <li>
            <p><span></span><strong>Published: </strong>06 December 2021 at 14:00 UTC</p>
        </li>
        <li>
            <p><strong>Updated: </strong>06 December 2021 at 14:25 UTC</p>
        </li>
        <li>
        </li>
    </ul>
    <p><img src="http://ballingt.com/cms/images/30/cd/cda5-article-css-exfiltration-article.jpg" alt="Image showing code being extracted from a vacuum cleaner"/></p><p>Ad blockers like uBlock Origin are extremely popular, and typically have access to every page a user visits. Behind the scenes, they&#39;re powered by community-provided filter lists - CSS selectors that dictate which elements to block. These lists are not entirely trusted, so they&#39;re constrained to prevent malicious rules from stealing user data.</p><p>In this post, we&#39;ll show you how we were able to bypass these restrictions in uBlock Origin, use a novel CSS-based exploitation technique to extract data from scripts and attributes, and even steal passwords from Microsoft Edge.  All vulnerabilities discussed in this post have been reported to uBlock Origin and patched.</p><p>Please note that these techniques assume a malicious rule has been installed. We did find a technique to encourage malicious rule installation, but believe that the most plausible attack vector is a compromised filter list. Due to ethical (not to mention legal) concerns, we opted not explore this vector.</p> <p>A while ago one of my heroes, <a href="https://twitter.com/taviso">Tavis Ormandy</a> <a href="https://twitter.com/taviso/status/1430533518879199236?s=20">mentioned on Twitter</a> that uBlock Origin was vulnerable to CSS injection in their filter rules. I had a quick look at his injection vector and indeed I was able to control more or less the full CSS of the injected filter rule:</p><p><code>example.com##div:style(--foo: 1/*)</code></p><p>This was quickly patched but I managed to find a <a href="https://github.com/uBlockOrigin/uBlock-issues/issues/1794">bypass</a> that worked in the latest uBlock Origin version:</p><p><code>##input,input/*</code></p><p>After reporting this, I was informed by the developer <a href="https://twitter.com/gorhill">Raymond Hill</a> that uBlock Origin also has cosmetic filters that allow more powerful CSS selectors they even let you define your own CSS rules but are restricted (limiting the use of URL requests), so I thought this would be a good place to look for another bypass. In this context cosmetic filters seem to use a different code path than normal filters. You can&#39;t use backslashes inside rules for instance. However, you can use an opening comment inside the selector and again use two rules to smuggle unrestricted CSS:</p><p><code>*#$#* /* { font-family: &#39; background-color:red;&#39;; }</code></p><p>This works because document.querySelector tolerates malformed selectors:</p><p><code>document.querySelector(&#39;input[class&#39;);</code></p><p>uBlock Origin was using this function to validate the selector. They fixed the comment bypass by looking for opening comments so I spent some time with my <a href="https://portswigger-labs.net/css-fuzzer/">CSS fuzzer</a> to understand deeply what syntax is allowed in CSS. I discovered some interesting behavior: inside a selector you can use curly braces. They also have to have an open and closing brace - because if they don&#39;t, then a semicolon will not start a new rule:</p><p><code>&lt;style&gt;</code></p><p>I found this behavior by running my fuzzer in reverse e.g. finding which characters do not allow semicolons to create a new rule. For instance using the fuzz vector <code>$chr;background:url(red.png);}</code> highlighted curly braces as well as other characters. I then manually verified you could use curly braces inside the selector:</p><p><code>&lt;style&gt;</code></p><p>Using this knowledge I could bypass the patch using a vector that doesn&#39;t use comments:</p><p><code>*#$#* {background:url(/abc);x{  background-color: red;}</code></p><p>After that was patched I began to look for ways to make background requests. Fuzzing various properties and trying various techniques I was unable to use the <code>url()</code> to make requests. So instead I started to look for alternative CSS functions. I found a function called <code>image-set()</code>, this function allows you to make requests with a CSS string on Firefox and this works perfectly in uBlock Origin:</p><p><code>*#$#* { font-family: &#39;blah&#39;; background:image-set(&#39;https://hackvertor.co.uk/images/logo.gif&#39; 1x) }</code></p><p>There is an alias called <code>-webkit-image-set()</code> which allows strings as URLs on Firefox. Chrome has the function too but you must use it in combination with the <code>url()</code> function.</p><h3>Exfiltrating with CSS</h3><p>If I could compromise a filter list then I would have control over the CSS on every web site when using uBlock Origin but what could I do? Most research on CSS exploitation has focused on attribute-based selector attacks - because they make it quite easy to steal passwords in inputs. <a href="https://twitter.com/thornmaker">David</a>, <a href="https://twitter.com/sirdarckcat">Eduardo</a> and I covered it in our <a href="http://businessinfo.co.uk/labs/talk/The_Sexy_Assassin.ppt">CSS The Sexy Assassin</a> talk back in 2008! <a href="https://twitter.com/WisecWisec">Stefano di Paola</a> and <a href="https://twitter.com/kuza55">Alex K.</a> also had the <a href="https://www.youtube.com/watch?v=RNt_e0WR1sc">same idea</a>. There has also been some excellent follow-up research from <a href="https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf">Pepe Villa</a>, <a href="https://www.nds.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2012/08/16/scriptlessAttacks-ccs2012.pdf">Mario Heiderich et al</a>, <a href="https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b">d0nut</a> and <a href="https://research.securitum.com/css-data-exfiltration-in-firefox-via-single-injection-point/">Michał Bentkowski</a> covering all sorts of CSS exfiltration techniques. But there are limitations: you can only read attribute values, so you usually can&#39;t steal keystrokes. I began to think about what CSS I could inject to steal content from the page. </p><p>So I decided to focus on custom fonts to see what was possible. Custom fonts are great because you can choose the characters they get assigned to. This allows you to steal those characters when a request is made for the font. The Unicode range property allows you to select which characters the font should apply to:</p><p><code>unicode-range: U+0061;</code></p><p>In this example the font will be loaded if the element contains a lowercase &#34;a&#34;. The trouble is that you can&#39;t get repeated characters, and the font request is made for the entire content - not specific parts of the element&#39;s text node. </p><p>First, let&#39;s make a custom font keylogger in CSS. This is a well known technique but we first need to understand how stealing keystrokes in CSS works and this is a great starting point.</p><p><code>&lt;link href=&#34;steal-lowercase.css&#34; rel=&#34;stylesheet&#34; /&gt;</code></p><p><a href="https://portswigger-labs.net/css-exfiltration-38654E0E45/test.html">CSS keylogger PoC</a></p><p>This creates a basic keylogger - the @font-face rule defines our custom font, and makes a request to /a when the character is a lowercase &#34;a&#34; - with a font-family of steal. This is then repeated for the other characters. Styles.css simply assigns the font-family to steal - which uses our custom font. The result is that when a victim types into the input, a request is made for every character you type (excluding repeated characters). But if you change the input into a password field, the attack will fail. This is because the characters get masked and therefore the custom font isn&#39;t loaded - as the masked characters don&#39;t correspond to the unicode range defined in the font.</p><p>This is true on all browsers, except when you unmask the characters in Edge by clicking on the eye icon in the input. In this case, the font is loaded and the characters stolen!</p><p><img src="http://ballingt.com/cms/images/5f/62/94a5-article-edge-unmask-password.png" alt="Screenshot showing Edge sending keystrokes when unmasking"/></p><p>An interesting thing about loading fonts on Firefox compared to Chrome, is that Firefox loads them synchronously, where Chrome is asynchronous. This has the advantage of leaking the characters in the correct order in Firefox.</p><p>One thing I discovered is that you can make scripts display their contents when using display:block. I later found out that <a href="https://twitter.com/cgvwzq">Pepe Villa</a> had the same idea. This means we can steal the contents of a script by assigning a font:</p><p><code>&lt;link href=&#34;steal-lowercase.css&#34; rel=&#34;stylesheet&#34; /&gt;</code></p><p><a href="https://portswigger-labs.net/css-exfiltration-38654E0E45/steal-script-contents/test.html">Stealing script contents PoC</a></p><p>This is great but has a limitation: it will try to steal the contents of the entire script and any repeated characters will not be loaded. What we are interested in is &#34;supersecret&#34; - is there any way to just steal that?</p><p>I looked at <code>::first-letter</code> selector - which (as the name suggests), allows you to control the first letter of the text node. This works for fonts so you can steal the first letter on Chrome, but it doesn&#39;t let you steal the other characters, doesn&#39;t work in conjunction with the :not selector, and doesn&#39;t seem to work on Firefox:</p><p><code>&lt;link href=&#34;steal-uppercase.css&#34; rel=&#34;stylesheet&#34; /&gt;</code></p><p>I then looked at the <code>::first-line</code> selector. This selector is interesting as it allows you to select part of the text. If I could somehow force the text onto separate lines then maybe I could steal a specific part of it. The ch unit allows you to specify the width of a single zero character in the chosen font. I suspect zero is used because it&#39;s more likely to be available in many different fonts. This would allow you to break apart letters and force them onto the next line.</p><p>My first attempt was to change the font inside the selector, assign a width, and force it to break all the words apart. This worked in an older version of Safari but not in Chrome or Firefox:</p><p><code>&lt;link href=&#34;steal-uppercase.css&#34; rel=&#34;stylesheet&#34; /&gt;</code></p><p><a href="https://portswigger-labs.net/css-exfiltration-38654E0E45/steal-first-line-safari/test.html">Stealing first line on Safari PoC</a></p><p>It doesn&#39;t work in Chrome or Firefox because <code>::first-line</code> only supports a limited amount of CSS and when a font is assigned the whole content is assigned the font not the <code>::first-line</code> selector. How could I make it work in Firefox? I thought about this for a while - and although now it seems obvious, at the time it wasn&#39;t! How about reversing the operation and using <code>::first-line</code> as a mask? We could then use the width to define a mask of characters we didn&#39;t want to include! This means we could steal a substring of characters to the length of the required string. This works perfectly on Firefox and retains the order of the characters too:</p><p><code>&lt;link href=&#34;steal-lowercase.css&#34; rel=&#34;stylesheet&#34; /&gt;</code></p><p><img src="http://ballingt.com/cms/images/0e/9f/25b4-article-firefox-steal-n-characters.png" alt="Screenshot showing technique to extract certain parts of the text"/></p><p><a href="https://portswigger-labs.net/css-exfiltration-38654E0E45/steal-n-characters-firefox/test.html">Stealing n characters on Firefox PoC</a></p><p>The above example will exclude the text &#34;some&#34; and steal the characters after excluding repeated characters. Pretty cool eh? How about the characters at the end though; we can&#39;t steal those if they are repeated characters. Well, we can use CSS animations and animate the mask to steal the contents backwards on Firefox!</p><p>We use the same template as previously but update the styles to include an animation:</p><p><code>div {</code></p><p>So the mask starts at 20ch, we break the words as before. The animation fill mode ensures it only plays and stops at the end - and the animation-iteration-count ensures that it only plays once. The result is the characters are stolen backwards.</p><p><img src="http://ballingt.com/cms/images/d0/46/a9b7-article-firefox-steal-characters-backwards.png" alt="Screenshot showing extracting characters in reverse on Firefox"/></p><p><a href="https://portswigger-labs.net/css-exfiltration-38654E0E45/steal-reversed-firefox/test.html">Stealing characters reversed on Firefox PoC</a></p><p>Moving on from <code>::first-line</code>, I started to look at the <code>attr()</code> function in CSS. Unfortunately inputs will not allow pseudo elements, so :before and :after will not work - which means that you can&#39;t use <code>attr()</code> to extract attributes and assign them using content. There is one exception to this: checkboxes. If you have a checkbox/radio with a sensitive attribute, then you can extract it using <code>attr()</code> and assign a font to steal the contents on Chrome:</p><p><code>&lt;link href=&#34;steal-uppercase.css&#34; rel=&#34;stylesheet&#34; /&gt;</code></p><p><a href="https://portswigger-labs.net/css-exfiltration-38654E0E45/steal-attribute-values-checkboxes/test.html">Stealing attributes in checkboxes PoC</a></p><h3>JavaScript URL injection</h3><p>Finally, I spent some time trying to exploit uBlock Origin to try and get a filter list automatically installed. I looked at how a user can add a filter list from a webpage and I noticed that uBlock has an allow list of domains that enable you to open the add filter dialog in the extension. One of those allow listed domains is GitHub.com, so you can use the following link on Github to open the add filter dialog:</p><p><code>https://subscribe.adblockplus.org/?location=https://my-website/filter.txt&amp;title=EasyList</code></p><p>The domain &#34;subscribe.adblockplus.org&#34; doesn&#39;t actually exist but uBlock Origin uses it to add the filter. It was possible to inject a JavaScript URL, fortunately for them the extension&#39;s <a href="http://ballingt.com/web-security/cross-site-scripting/content-security-policy">CSP</a> prevented exploitation. Nevertheless, uBlock Origin <a href="https://github.com/uBlockOrigin/uBlock-issues/issues/1797">fixed the JavaScript injection vulnerability</a> too.</p><p>So if you could convince a user to add your filter - or maybe do a pull request for one of the existing filters with an injection - then you could use the techniques in this post to steal data. Another approach would be to compromise a site hosting filters, perhaps using <a href="http://ballingt.com/web-security/web-cache-poisoning">web cache poisoning</a> or <a href="http://ballingt.com/web-security/request-smuggling">HTTP request smuggling</a>. Needless to say, we didn&#39;t attempt any of this.</p><h3>Conclusion</h3><p>uBlock Origin provides powerful filters to control which elements are allowed on a page. They can prevent malicious adverts from exploiting your computer. However - if they are vulnerable to CSS injection, and a user loads a malicious filter, then it&#39;s possible to exfiltrate data from any web page using pure CSS. Ultimately, CSS-based injection attacks can have a similar impact to <a href="https://portswigger.net/web-security/cross-site-scripting">XSS</a> when an affected page contains sensitive information that can be extracted.</p><h3>Materials</h3><p>All the attacks mentioned above can be <a href="https://github.com/PortSwigger/css-exfiltration">downloaded from our Git repository</a>.</p><h3>Disclosure</h3><p>uBlock Origin does not provide a security contact or email address to report vulnerabilities to. Therefore this was disclosed via their public GitHub issues.</p><p><b>2021-08-25 05:16</b> - Tavis reported his bug</p>
    
    <p><a href="http://ballingt.com/research/articles">Back to all articles</a></p>
</div></div>
  </body>
</html>
