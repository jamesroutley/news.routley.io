<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wryl.tech/log/2024/the-software-crisis.html">Original</a>
    <h1>The Software Crisis</h1>
    
    <div id="readability-page-1" class="page"><div><p>
In 1968, at the first NATO Software Engineering conference, the term &#34;software crisis&#34; was coined.

These conferences were pivotal moments in computing history, as they were some of the first efforts to pin down and codify the current practices in programming automatic computing machines.

On July 16th, 1969, the Apollo 11 mission launched, sporting some of the most advanced engineering practices known at the time. The last NATO Software Engineering conference was held in October of the same year.

I can imagine enthusiastic conversations about guidance control, redundancy, and general speculation around how the Apollo program&#39;s approach to constructing programs worked.

In his 1972 Turing Award lecture, Edsger Dijkstra made clear the perceived cause of the software crisis: an increase in computing hardware complexity and speed, without the organizational methods to address the growing complexity of software that utilized this hardware.

</p><p>
The term &#34;software crisis&#34; isn&#39;t featured much in current conversation around programming practices. We generally think we&#39;ve &#34;figured it out&#34;, with some minor difficulties that are deemed &#34;essential&#34; or &#34;tolerable&#34;.

Time and distance from the &#34;problems of the past&#34;, along with the development of new languages and organizational methods, has pushed us into a state of comfort. Our ecosystems are teeming with life and new software.

</p><p>
We&#39;ve figured it out by now, right?

<i>Right?</i>
</p><p>

It seems as if this state of comfort is due to a sense of defeat and acceptance, rather than of a true, genuine comfort. We peer endlessly at the machines in front of us, and we establish mental models for their inner workings.

From seasoned programmers and technology enthusiasts to the passively invested users of technology, we form shortcuts, abstract models that allow us to avoid thinking about the millions of moving parts that make up the things we use.

</p><p>
Very rarely do these models reflect reality.

It&#39;s a nice coincidence when they do.

It&#39;s catastrophic when they don&#39;t.
</p><p>

Various efforts have been made to address pieces of the software crisis, but they all follow the same pattern of &#34;abstract it away&#34;. If we sweep the unsavory details into structures we can control, we can achieve some level of &#34;independence&#34; at the cost of performance.

However, <i>much</i> of the early advancements in computing and adjacent fields occurred on machines where building towers of abstraction had a direct cost, and in contexts where that cost couldn&#39;t be paid. Every roadblock that was hit was met with a hardware upgrade.

In theory, this is a natural growth cycle. As we learn how to utilize our resources more efficiently, we hit a point where the current restrictions cannot be bypassed, necessitating a hardware upgrade. In practice, we grow hungry for capacity long before we&#39;ve understood its limitations.

That hunger for ability was slow to grow before the advent of commercialization of personal computing, but companies selling equipment don&#39;t make money waiting for their users to master their products. The growth cycle accelerated, and accelerated, and accelerated...

</p><p>
As personal computing grew more popular, and hardware release cycles grew faster, &#34;abstract it away&#34; became the default mode of thinking.

Out of sight, out of mind.
</p><p>

We developed methods of building nested layers of abstractions, hiding information at multiple levels. We took the problem of constructing software and morphed it into towering layers. We integrated these layers into the software required to use our computers, and the software that drives our lives.

The wider software industry accelerated its release cycles and capital influence, bringing about the proverbial death of the individual developer. We lament the easy access to fundamental features of a machine, like graphics and sound. It is no longer easy to build software, and nothing comes with a manual.

If curious developers can no longer build software without scaling mountains, what hope is there for the broader problem? The software crisis doesn&#39;t just apply to the profession of building software, but to anybody that uses software. Users have little to no control, save for things afforded to them by the author.

</p><p>
Those who construct software are placed in a unique blind spot. We produce tools that we may not understand the true potential of for decades. We are often caught in fits of creative problem solving, the passion of the craft, or the pressure of peers.

</p><p>
We forget that software construction, just like software usage, is a human activity.
</p><p>

We are separated from the responsibility of the tools that we build. This has been the norm for several decades, with the perceived stakes being lowered as commercialization took hold. We continue reaching for abstraction as a tool to avoid the hard thoughts, and this has bled into how people develop and use software.

When machines were small, and we couldn&#39;t afford endless abstractions (unless they were &#34;free&#34;), we knew the cost of sweeping things under the rug. Small inefficiencies added up. There was a <i>limit</i> to how far you could separate yourself from the machine. Newcomers had a low-cost entry point, if they were curious enough.

</p><p>
The water was shallow enough to learn to swim in.
</p><p>

The solution to the software crisis will not be a reversion to more constrained platforms, but a constraint on the number of layers of abstraction we are allowed to apply, as well as the requirement of information preservation between these layers. We must narrow the (<a href="https://en.wikipedia.org/wiki/Semantic_gap">semantic gap</a>) so that <i>everyone</i> may scale it.

Programming models, user interfaces, and foundational hardware can, <i>and must</i>, be shallow and composable. We must, as a profession, give agency to the users of the tools we produce. Relying on towering, monolithic structures sprayed with endless coats of paint cannot last. We cannot move or reconfigure them without tearing them down.

There have been movements to bring awareness to the software crisis, such as (<a href="https://handmade.network/manifesto">Handmade</a>), (<a href="https://permacomputing.net/Principles/">Permacomputing</a>), and various retro-computing circles. We&#39;re starting to realize just how deep in this crisis we are. Counterculture movements are health signals, and a fever is brewing.
</p><p>
Things can be better.

I&#39;ll show you how.
</p>
</div></div>
  </body>
</html>
