<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tweag.io/blog/2025-12-18-rules_img/">Original</a>
    <h1>A faster path to container images in Bazel</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Say you have a Bazel project that builds a web application, and you want to deploy it as a Docker container. The app is already built by Bazel, so you just need to package it into an image with the right base layers and configuration. This should be quick. Bazel is good at this sort of thing. But when you add container image building to your setup, something surprising happens: your builds start downloading gigabytes of base image data, your CI slows down, and pushing images feels slow. This is the story of why that happens and how <a href="https://github.com/bazel-contrib/rules_img"><code>rules_img</code></a> fixes it.</p>
<blockquote>
<p>Prefer watching to reading? <a href="https://www.youtube.com/watch?v=biYXmAv4Ppk">The content of this post is also available in video form</a>.</p>
</blockquote>
<h2 id="the-components"><a href="#the-components" aria-label="the components permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The components</h2>
<p>Before we dive in, we need to establish where data lives and where it moves. There are three main players:</p>
<ul>
<li><strong>The registry</strong> (like Docker Hub or gcr.io): A remote server that stores container images. You download base images from here and push your built images back to it.</li>
<li><strong>Your local machine</strong>: Where you run <code>bazel build</code> or <code>bazel run</code>. This is your laptop or workstation.</li>
<li><strong>Remote execution and remote cache</strong>: A remote caching backend (like Aspect Workflows, BuildBuddy, EngFlow, or Google’s RBE) that runs Bazel actions on remote machines and caches the results. Optional, but common in CI and larger projects.</li>
</ul>
<p>The core tension is simple: to build a container image that extends a base image, you need information about that base. The question is how much information, and where does it need to be?</p>
<h2 id="the-scenario"><a href="#the-scenario" aria-label="the scenario permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The scenario</h2>
<p>Here’s what building a container image looks like with <code>rules_oci</code>, the current recommended approach. I’ll show the data flow explicitly:</p>
<div data-language="python"><pre><code>

pull<span>(</span>
    name <span>=</span> <span>&#34;ubuntu&#34;</span><span>,</span>
    image <span>=</span> <span>&#34;index.docker.io/library/ubuntu:24.04&#34;</span><span>,</span>
    digest <span>=</span> <span>&#34;sha256:1e622c5...&#34;</span><span>,</span>
<span>)</span>




oci_image<span>(</span>
    name <span>=</span> <span>&#34;app_image&#34;</span><span>,</span>
    base <span>=</span> <span>&#34;@ubuntu&#34;</span><span>,</span>  
    tars <span>=</span> <span>[</span><span>&#34;:app_layer.tar&#34;</span><span>]</span><span>,</span>
    entrypoint <span>=</span> <span>[</span><span>&#34;/app/bin/server&#34;</span><span>]</span><span>,</span>
<span>)</span>




oci_push<span>(</span>
    name <span>=</span> <span>&#34;push&#34;</span><span>,</span>
    image <span>=</span> <span>&#34;:app_image&#34;</span><span>,</span>
    repository <span>=</span> <span>&#34;gcr.io/my-project/app&#34;</span><span>,</span>
<span>)</span></code></pre></div>
<p><strong>Data flow summary:</strong></p>
<ol>
<li>Registry → Local machine: full base image (hundreds of MB)</li>
<li>Local machine → Remote cache: full base image (anything that’s not already cached)</li>
<li>Remote cache → Remote Executor (creating an image): full image (hundreds of MB)</li>
<li>Remote cache → Local machine: full image (hundreds of MB)</li>
<li>Local machine → Registry: missing layers</li>
</ol>
<p>Here’s the same thing with <code>rules_img</code>:</p>
<div data-language="python"><pre><code>


pull<span>(</span>
    name <span>=</span> <span>&#34;ubuntu&#34;</span><span>,</span>
    registry <span>=</span> <span>&#34;index.docker.io&#34;</span><span>,</span>
    repository <span>=</span> <span>&#34;library/ubuntu&#34;</span><span>,</span>
    tag <span>=</span> <span>&#34;24.04&#34;</span><span>,</span>
    digest <span>=</span> <span>&#34;sha256:1e622c5...&#34;</span><span>,</span>
<span>)</span>




image_layer<span>(</span>
    name <span>=</span> <span>&#34;app_layer&#34;</span><span>,</span>
    srcs <span>=</span> <span>{</span>
        <span>&#34;/app/bin/server&#34;</span><span>:</span> <span>&#34;//cmd/server&#34;</span><span>,</span>  
        <span>&#34;/app/config&#34;</span><span>:</span> <span>&#34;//configs:prod&#34;</span><span>,</span>
    <span>}</span><span>,</span>
<span>)</span>




image_manifest<span>(</span>
    name <span>=</span> <span>&#34;app&#34;</span><span>,</span>
    base <span>=</span> <span>&#34;@ubuntu&#34;</span><span>,</span>  
    layers <span>=</span> <span>[</span><span>&#34;:app_layer&#34;</span><span>]</span><span>,</span>  
    entrypoint <span>=</span> <span>[</span><span>&#34;/app/bin/server&#34;</span><span>]</span><span>,</span>
<span>)</span>





image_push<span>(</span>
    name <span>=</span> <span>&#34;push_app&#34;</span><span>,</span>
    image <span>=</span> <span>&#34;:app&#34;</span><span>,</span>
    registry <span>=</span> <span>&#34;ghcr.io&#34;</span><span>,</span>
    repository <span>=</span> <span>&#34;my-project/app&#34;</span><span>,</span>
    tag <span>=</span> <span>&#34;latest&#34;</span><span>,</span>
<span>)</span></code></pre></div>
<p><strong>Data flow summary:</strong></p>
<ol>
<li>Registry → Local machine: only manifest + config (~10 KB)</li>
<li>Local machine → Remote cache: only metadata on base images</li>
<li>Remote cache → Local machine → Registry: only missing blobs (often just your new layers)</li>
<li>Base layers (almost) never move through local machine or remote executors</li>
</ol>
<h2 id="a-twominute-primer-on-images"><a href="#a-twominute-primer-on-images" aria-label="a twominute primer on images permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A two‑minute primer on images</h2>
<p>An OCI image is a bundle of metadata and bytes. The bytes live in <em>layers</em>, which are compressed tar archives that encode file additions and deletions. The metadata lives in three JSON objects:</p>
<ul>
<li>The <em>config</em>: what to run, environment variables, user, working directory, and the list of uncompressed layer digests (also called diff IDs)</li>
<li>The <em>manifest</em>: pointers to one config and many layer blobs, identified by digest, size, and media type</li>
<li>The <em>index</em>: for multi‑architecture images, a list of per‑platform manifests</li>
</ul>
<p>Tags in a registry point at a manifest digest. The digests are content-addressed, so the same bytes always mean the same name everywhere.</p>
<p><span>
      <a href="https://words.filippo.io/static/2c013ad4d476d25db7c0322b0665dd58/2bef9/layers_in_a_trenchcoat.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="A container image is just some tar files in a trenchcoat" title="A container image is just some tar files in a trenchcoat" src="https://words.filippo.io/static/2c013ad4d476d25db7c0322b0665dd58/fcda8/layers_in_a_trenchcoat.png" srcset="/static/2c013ad4d476d25db7c0322b0665dd58/12f09/layers_in_a_trenchcoat.png 148w,
/static/2c013ad4d476d25db7c0322b0665dd58/e4a3f/layers_in_a_trenchcoat.png 295w,
/static/2c013ad4d476d25db7c0322b0665dd58/fcda8/layers_in_a_trenchcoat.png 590w,
/static/2c013ad4d476d25db7c0322b0665dd58/efc66/layers_in_a_trenchcoat.png 885w,
/static/2c013ad4d476d25db7c0322b0665dd58/2bef9/layers_in_a_trenchcoat.png 1024w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p><strong>How builds usually work.</strong> <code>docker build</code> executes a Dockerfile <em>inside</em> a base image. Each step like <code>RUN</code>, <code>COPY</code>, or <code>ADD</code> runs against a snapshot of the previous root file system and produces a new layer. The final image is the base’s layers plus the layers created by those steps. This is convenient, but it assumes you have the base image bytes locally while you build.</p>
<p><strong>How Bazel thinks about it.</strong> Bazel does not need to <em>run inside</em> the base at all. It builds your program artifacts the same way it always does<sup id="fnref-1"><a href="#fn-1">1</a></sup>, then assembles an image by writing a config and a manifest that reference the base image <em>by digest</em> alongside the new layers you produced. Bazel needs the base’s identity to compose a correct manifest and, later, to upload or load the image. But it doesn’t have to materialize the base layers during the build itself<sup id="fnref-2"><a href="#fn-2">2</a></sup>.</p>
<p><strong>Why this matters for performance.</strong> Assembling an image is easy. It’s mostly JSON with a few checksums. The hard part is <em>data locality</em>: getting the right bytes to the right place at the right time. Do the executors have to download layers just to write a small manifest? Does a pusher really need to pull all blobs to a workstation before uploading them again? Does a local daemon have to ingest layers it already owns? <code>rules_img</code> answers those questions by moving metadata first and moving bytes only at the edges.</p>
<h2 id="the-status-quo-rules_oci"><a href="#the-status-quo-rules_oci" aria-label="the status quo rules_oci permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The status quo: rules_oci</h2>
<p>The first major ruleset for building container images in Bazel was <code>rules_docker</code>, which integrated with every language ecosystem: Python, Node.js, Java, Scala, Groovy, C++, Go, Rust, and D. This approach proved extremely hard to maintain. Any change in a language ruleset could ripple into <code>rules_docker</code>. Today it is mostly unmaintained and lacks official bzlmod support.</p>
<p>The current recommendation is <a href="https://github.com/bazel-contrib/rules_oci"><code>rules_oci</code></a>, which takes the opposite approach: use only off‑the‑shelf tools, maintain a strict complexity budget, and delegate layer creation to language rulesets or end users. This design results in a maintainable project with a narrow scope that’s easy to understand.</p>
<figure>
<p><img src="https://words.filippo.io/ba15c362074a6f3d56c09848d334ea3b/rules_oci_repo_rule.svg" alt="Data transfers performed by rules_oci when pulling a base image"/></p>
<figcaption>Data transfers performed by rules_oci when pulling a base image</figcaption>
</figure>
<p>Under the hood, <code>rules_oci</code> represents images as complete <a href="https://specs.opencontainers.org/image-spec/image-layout/">OCI layouts</a> on disk. When you pull a base image, the repository rule downloads the full image—all blobs, all layers—into a tree artifact. When you build an image with <code>oci_image</code> or <code>oci_image_index</code>, the result is again a directory containing every blob of that image. Layers are always tar files, with no separate metadata to describe them, and the ruleset does not use Bazel providers to pass structured information between targets. This approach is simple and works well for local builds, but as we scaled to Remote Execution, we encountered bottlenecks that this design did not address.</p>
<h2 id="from-bottlenecks-to-breakthroughs-how-rules_img-works"><a href="#from-bottlenecks-to-breakthroughs-how-rules_img-works" aria-label="from bottlenecks to breakthroughs how rules_img works permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>From bottlenecks to breakthroughs: how rules_img works</h2>
<p>I started with a simple goal: build container images in Bazel and let Remote Execution carry the weight. I used <code>rules_oci</code> in my experiments, the recommended way of building container images in Bazel today<sup id="fnref-3"><a href="#fn-3">3</a></sup>. I was surprised by the inefficiencies I saw. Repository rules that pulled base images ran again and again in CI, even when nothing had changed<sup id="fnref-4"><a href="#fn-4">4</a></sup>. My laptop shoveled data uphill to the remote cache before any real work could begin. Actions that only wrote a few lines of JSON insisted on dragging entire layer blobs along for the ride. When the build finally finished on RBE, Bazel downloaded every layer into a push tool’s runfiles, only to upload them to a registry a moment later. Loading images into Docker added insult to injury by ignoring layers that were already present. None of that felt like Bazel, so I ran experiments until a pattern emerged.</p>
<p><strong>The breakthrough: treat images as metadata first.</strong> The key was to see the whole build as a metadata pipeline and to move bytes only at the edges. Keep base images shallow until you truly need a blob. Assemble manifests from digests and sizes, not gigabytes. Push and load by streaming from content‑addressable storage straight to the destination, and skip anything that already exists there. Once that clicked, the rest of the design fell into place.</p>
<p><strong>Pulling, without the pain.</strong> Base pulls were the first time sink. In <code>rules_img</code>, the repository rule fetches only the manifest and config JSON files at build time. Just enough metadata to know what layers exist and their digests. The actual layer blobs are never downloaded during the build<sup id="fnref-5"><a href="#fn-5">5</a></sup>. They wait until the run phase when you <code>bazel run</code> a push or load target. CI becomes predictable, and Remote Execution doesn’t spend its morning downloading CUDA for the fourth time this week. Less data moves during builds, and the cache behaves like a cache.</p>
<p><strong>Stop hauling bytes uphill.</strong> The next fix addressed the torrent of developer-to-remote uploads. We generate metadata-only providers wherever possible. The heavy blobs live in content-addressable storage (CAS) and stream later to whoever needs them, whether that’s a registry or a local daemon. Your workstation stops being a relay, cold starts are faster, and incremental builds are a breeze.</p>
<p><strong>Let manifests stay tiny.</strong> Manifest assembly had been oddly heavyweight. We reshaped the graph so each layer is built in a single action that computes both the blob and the metadata that describes it<sup id="fnref-6"><a href="#fn-6">6</a></sup>. The layer blob stays in Bazel’s CAS, while only a small JSON descriptor (digest, size, media type) flows through the build graph. Downstream actions consume only this metadata during the build phase, so they schedule quickly, cache well, and avoid pulling gigabytes across executors. The manifests remain correct, and the path to them is light. The actual blob bytes only move later during <code>bazel run</code> when you push or load.</p>
<p><strong>Push without the round trip.</strong> Pushing used to mean downloading all layers to a local tool and then sending them back up again. With <code>rules_img</code>, we defer all blob transfers to the run phase (<code>bazel run //:push</code>). The build phase only produces a lightweight push specification: a JSON file listing what needs pushing. When you run the pusher, it first asks the registry what blobs it already has, then streams only the missing ones directly from CAS. In environments where your registry speaks the same CAS protocol, the push is close to zero‑copy. For very large monorepos, you can even emit pushes as a side effect of Build Event Service uploads. The principle is simple. Build time produces metadata, run time moves bytes, and nothing passes through your workstation unnecessarily. See the <a href="https://github.com/bazel-contrib/rules_img/blob/main/docs/push-strategies.md">push strategies documentation</a> for other configurations including direct CAS-to-registry transfers.</p>
<p><strong>Loading should be incremental.</strong> <code>docker load</code> treats every import like a blank slate. When containerd is available, <code>rules_img</code> talks to its content store and streams only what is missing<sup id="fnref-7"><a href="#fn-7">7</a></sup>. It can also load a single platform from a multi‑platform image, which keeps feedback loops tight<sup id="fnref-8"><a href="#fn-8">8</a></sup>. If containerd isn’t available, we fall back to <code>docker load</code> and tell you what you’re giving up.</p>
<p><strong>Extra touches that add up.</strong> Performance rarely comes from one trick alone. We use hardlink-based deduplication inside layers so identical files don’t bloat your tars. We support <a href="https://github.com/containerd/stargz-snapshotter/blob/main/docs/estargz.md">eStargz</a> to make layers seekable and quick to start with the stargz snapshotter.</p>
<p><strong>Quick start.</strong> If you want to try it, here is a minimal setup:</p>
<div data-language="python"><pre><code>
bazel_dep<span>(</span>name <span>=</span> <span>&#34;rules_img&#34;</span><span>,</span> version <span>=</span> <span>&#34;&lt;version&gt;&#34;</span><span>)</span>

pull <span>=</span> use_repo_rule<span>(</span><span>&#34;@rules_img//img:pull.bzl&#34;</span><span>,</span> <span>&#34;pull&#34;</span><span>)</span>


pull<span>(</span>
    name <span>=</span> <span>&#34;ubuntu&#34;</span><span>,</span>
    registry <span>=</span> <span>&#34;index.docker.io&#34;</span><span>,</span>
    repository <span>=</span> <span>&#34;library/ubuntu&#34;</span><span>,</span>
    tag <span>=</span> <span>&#34;24.04&#34;</span><span>,</span>
    digest <span>=</span> <span>&#34;sha256:1e622c5f073b4f6bfad6632f2616c7f59ef256e96fe78bf6a595d1dc4376ac02&#34;</span><span>,</span>
<span>)</span></code></pre></div>
<div data-language="python"><pre><code>
load<span>(</span><span>&#34;@rules_img//img:layer.bzl&#34;</span><span>,</span> <span>&#34;image_layer&#34;</span><span>)</span>
load<span>(</span><span>&#34;@rules_img//img:image.bzl&#34;</span><span>,</span> <span>&#34;image_manifest&#34;</span><span>)</span>

image_layer<span>(</span>
    name <span>=</span> <span>&#34;app_layer&#34;</span><span>,</span>
    srcs <span>=</span> <span>{</span>
        <span>&#34;/app/bin/server&#34;</span><span>:</span> <span>&#34;//cmd/server&#34;</span><span>,</span>
        <span>&#34;/app/config&#34;</span><span>:</span> <span>&#34;//configs:prod&#34;</span><span>,</span>
    <span>}</span><span>,</span>
    compress <span>=</span> <span>&#34;zstd&#34;</span><span>,</span>
<span>)</span>

image_manifest<span>(</span>
    name <span>=</span> <span>&#34;app_image&#34;</span><span>,</span>
    base <span>=</span> <span>&#34;@ubuntu&#34;</span><span>,</span>
    layers <span>=</span> <span>[</span><span>&#34;:app_layer&#34;</span><span>]</span><span>,</span>
<span>)</span></code></pre></div>
<p>Optional <code>.bazelrc</code> speed dials if you like the metadata‑first defaults:</p>
<div data-language="text"><pre><code>common --@rules_img//img/settings:compress=zstd
common --@rules_img//img/settings:estargz=enabled
common --@rules_img//img/settings:push_strategy=lazy
# Or: cas_registry / bes (see docs for setup)</code></pre></div>
<h2 id="conclusion-container-images-that-feel-native-to-bazel"><a href="#conclusion-container-images-that-feel-native-to-bazel" aria-label="conclusion container images that feel native to bazel permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion: container images that feel native to Bazel</h2>
<p>The performance gains are real. Pulling large base images on fresh machines takes seconds instead of minutes. Loading into Docker takes milliseconds for incremental updates instead of reloading the full image, which could waste 1–5 minutes in the workflows we examined. Manifest assembly actions run dramatically faster, especially on RBE systems that fetch inputs eagerly<sup id="fnref-9"><a href="#fn-9">9</a></sup>. Building push targets no longer destroys the benefits of Build without the Bytes. Where other rulesets might download gigabytes to your machine, <code>rules_img</code> downloads only a few kilobytes of metadata, saving many gigabytes in transfers and minutes per push. A comprehensive benchmark would warrant its own blog post given the wide matrix of possible configurations, RBE backends, image sizes, and network conditions.</p>
<p>Our aim with <code>rules_img</code> is straightforward: make Bazel feel native for container images, with no unnecessary bytes and no unnecessary waits. By treating images as metadata with on-demand bytes, we get faster CI, quieter laptops, and a build graph that scales without drama. Try it, tell us what flies, and tell us what still hurts. There’s more to tune, and we intend to keep tuning.</p>
<p><strong>Get started with rules_img: <a href="https://github.com/bazel-contrib/rules_img">github.com/bazel-contrib/rules_img</a></strong></p>
</div></div></div></div>
  </body>
</html>
