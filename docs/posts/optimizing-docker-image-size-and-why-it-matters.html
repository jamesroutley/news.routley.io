<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://contains.dev/blog/optimizing-docker-image-size">Original</a>
    <h1>Optimizing Docker image size and why it matters</h1>
    
    <div id="readability-page-1" class="page"><div><p><strong>Why does size matter?</strong> Docker images are a core component in our development and production lifecycles. Having a large image can make every step of the process slow and tedious. Size affects how long it takes to build the image locally, on CI/CD, or in production and it affects how quickly we can spin up new instances that run our code. Reducing the size of the image can have benefits both for developers and your users.</p><div><p><img src="https://contains.dev/images/pull-anim.svg"/></p><p>Illustration of pulling a large Docker image layer</p></div><p>So, what can you do about it?</p><p>There are several important considerations that go into picking a base image. In the context of optimizing image size, each base image comes with its own dependencies and footprint.</p><p>Usually, the first choice you need to make is which distribution you want. Image sizes vary between them:</p><div><div><div><div><p><img width="24" height="24" src="https://contains.dev/logos/debian.svg"/></p><p>Debian</p></div><p><span>124</span> MB</p></div><div><div><p><img width="24" height="24" src="https://contains.dev/logos/ubuntu.svg"/></p><p>Ubuntu</p></div><p><span>73</span> MB</p></div><div><div><p><img width="24" height="24" src="https://contains.dev/logos/alpine.svg"/></p><p>Alpine</p></div><p><span>6</span> MB</p></div><div><div><p><img width="24" height="24" src="https://contains.dev/logos/centos.svg"/></p><p>CentOS</p></div><p><span>231</span> MB</p></div><div><div><p><img width="24" height="24" src="https://contains.dev/logos/fedora.svg"/></p><p>Fedora</p></div><p><span>153</span> MB</p></div></div></div><p>It’s not just a matter of image size though, each of these images comes with its own philosophy or tools you might prefer. Alpine is lightweight, security-focused, and based on <a href="https://wiki.musl-libc.org/functional-differences-from-glibc.html" target="_blank">musl-libc instead of glibc</a>. Ubuntu has long-term enterprise support, comes bundled with many utilities and supports a vast amount of packages, and so on.</p><p>Next, you can decide if you want your parent image to come bundled with additional dependencies. Often you need to weigh the convenience of having a base image with all dependencies pre-installed against the size of the resulting image.</p><p>For example, if you have a Node.js app you can use the <a href="https://contains.dev/library/node"><code>node</code></a> image, or <a href="https://contains.dev/library/python"><code>python</code></a> if you’re using Python, etc. Within those images, usually you can specify the distribution you’d like using the appropriate tag, for example, <a href="https://contains.dev/library/node/alpine"><code>node:alpine</code></a> for Alpine Linux and <a href="https://contains.dev/library/python/3-bullseye"><code>python:3-bullseye</code></a> for Debian Bullseye.</p><p>The less specific or specialized your parent image is, the more control you have over the image size:</p><p>A closer look at <a href="https://contains.dev/library/node/16-bullseye"><code>node:16-bullseye</code></a> shows that it has <a href="https://contains.dev/library/buildpack-deps"><code>buildpack-deps</code></a> as its parent image, which comes with lots of dependencies you might not need. So if you’re willing to take care of the Node.js installation, you can do it directly on the Debian image and reduce the image size considerably.</p><p>Docker makes it especially easy to add files you didn’t mean to add to an image. Each <code>ADD</code> or <code>COPY</code> and even the <code>RUN</code> commands in your Dockerfile can include files you weren’t expecting.</p><p>It isn&#39;t easy to see exactly which files are added and where. So the first step is to be able to quickly inspect which files are added to each layer. Each layer corresponds to specific commands in your Dockerfile, and from there we can decide what and how to optimize.</p><p>There are 3 easy methods you can use:</p><h2>Docker CLI</h2><p>You can save any local image as a <code>tar</code> archive and then inspect its contents.</p><div><div><pre><p><span>bash-3.2$</span> <b>docker save</b> <span>&lt;image-digest&gt;</span> -o image.tar</p><p><span>bash-3.2$</span> tar -xf image.tar -C image</p><p><span>bash-3.2$</span> cd image</p><div><p><span>bash-3.2$</span> tar -xf</p><!-- --> <p><span>&lt;layer-digest&gt;</span>/layer.tar</p></div><p><span>bash-3.2$</span> ls</p><p><span>etc</span></p><p><span>tmp</span></p><p><span>usr</span></p><p><span>var</span></p></pre></div></div><h2>Dive</h2><p>An excellent <a href="https://github.com/wagoodman/dive" target="_blank">open-source tool</a> to visualize and analyze local Docker images.</p><p><a href="https://github.com/wagoodman/dive" target="_blank"><img src="https://contains.dev/images/dive.png"/></a></p><h2>Contains.dev</h2><p>Our <a href="https://contains.dev">contains.dev</a> offers many tools to analyze layers, their contents, and their size. Including navigating a treemap of your image:</p><p><a href="https://contains.dev/library/httpd/latest/insights/treemap"><img src="https://contains.dev/images/treemap.gif"/></a></p><p>With these methods, you&#39;re set up to assess improvements to your image size. There are a few common areas that have straightforward solutions that improve the overall image size:</p><h2>.dockerignore</h2><p>An important way to ensure you’re not bringing in unintended files is to define a <code>.dockerignore</code> file. This file has a similar syntax to <code>.gitignore</code> :</p><p>Then when you run <code>COPY . .</code> it’ll make sure not to copy files defined in your <code>.dockerignore</code>. Defining this file has the added benefit of reducing the size of the Docker build context, which are all the files Docker gathers when building an image. A smaller build context results in faster build times.</p><h2>Package managers</h2><p>Depending on the package manager you’re using, you can instruct it to install the minimum needed packages you explicitly defined.</p><p>For example:</p><ul><li><code>apt-get -y --no-install-recommends</code> - don’t install optional recommended packages.</li><li><code>npm install --production</code> - don’t install development dependencies.</li></ul><h2>Caches</h2><p>Many processes will create temporary files, caches, and other files that have no benefit to your specific use case. For example, running <code>apt-get update</code> will update internal files that you don’t need to persist because you’ve already installed all the packages you need. So we can add <code>rm -rf /var/lib/apt/lists/*</code> as part of the <em>same layer</em> to remove those (removing them with a separate <code>RUN</code> will keep them in the original layer, see “Avoid duplicating files”). Docker recognize this is an issue and went as far as adding <code>apt-get clean</code> <a href="https://github.com/moby/moby/blob/03e2923e42446dbb830c654d0eec323a0b4ef02a/contrib/mkimage/debootstrap#L82-L105" target="_blank">automatically for their official Debian and Ubuntu images</a>.</p><p>Each layer in your image might have a leaner version that is sufficient for your needs. The best way to see that is to audit your layers with the techniques mentioned above.</p><p>Docker uses read-only layers of files that are <a href="https://docs.docker.com/storage/storagedriver/#images-and-layers" target="_blank">overlaid on top of each other</a>. This means that when you make changes to files that come from previous layers, they’re copied into the new layer you’re creating. It isn’t always obvious that this is happening, for example:</p><p>We’re just <code>chmod</code>&#39;ing an existing file, but Docker can’t change the file in its original layer, so that results in a new layer where the file is copied in its entirety with the new permissions.</p><p>In newer versions of Docker, this can now be written as the following to avoid this issue using Docker’s <a href="https://docs.docker.com/develop/develop-images/build_enhancements/" target="_blank">BuildKit</a>:</p><p>Other non-intuitive cases of file duplication between layers:</p><p>In this example, we created 3 copies of our file throughout different layers of the image. Despite removing the file in the last layer, the image still contains the file in other layers which contributes to the overall size of the image.</p><p>Making a small change to a file or moving it will create an entire copy of the file. Deleting a file will only hide it from the final image, but it will still exist in its original layer, taking up space. This is all a result of <a href="https://docs.docker.com/storage/storagedriver/#images-and-layers" target="_blank">how images are structured</a> as a series of read-only layers. This provides reusability of layers and efficiencies with regards to how images are stored and executed. But this also means we need to be aware of the underlying structure and take it into account when we create our Dockerfile.</p><p>For cases where we have Dockerfile steps that aren’t used at runtime.</p><p>The Dockerfile might include several steps that take care of setting up an environment for compiling the program that will run at runtime. This is especially common for compiled languages like Go.</p><p>To solve this issue Docker introduced multi-stage builds starting from Docker Engine v17.05. This allows us to perform all preparations steps as before, but then copy only the essential files or output from these steps.</p><p>As shown in the example below, the effects on image size can be dramatic:</p><p>This basic example compiles a simple Go program. The naive way on the left results in a 961 MB image. When using a multi-stage build, we copy just the compiled binary which results in a 7 MB image. The example on the left can be improved by choosing a leaner parent image, but it still would fall short of the optimal case on the right.</p><p>Multi-stage builds introduce a lot of flexibility with support for advanced cases like multiple <code>FROM</code> statements, copying a single file from an external image, and more. These techniques can be combined to reduce the image size to a minimum. Check out the official Docker docs for <a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank">more info</a>.</p><p>Keeping your image optimized and small pays huge dividends in the development process and in going to production. The techniques above will help you gain a good understanding of what&#39;s going on inside your image, which has benefits beyond the optimization work.</p></div></div>
  </body>
</html>
