<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://commutative.xyz/~miguelmurca/blog/x/autoref.html">Original</a>
    <h1>LaTeX3 Automatic Labels for Fun and No Profit</h1>
    
    <div id="readability-page-1" class="page">
  
  <p>I‚Äôm a PhD student in physics, which means I‚Äôve spent the
  better part of the last 10 years writing LaTeX. For those not in
  the know, LaTeX is a 40-year old superset of a 46-year old
  typesetting system ‚Äì i.e., a macro based programming language to
  produce print documents. Notably, it‚Äôs mostly
  intended <em>not</em> as a programming language; its strongest
  suit is arguably the way it beautifully typesets mathematics, and
  its solution to express complex mathematical expressions. For
  example,</p>
  <div>
    <pre><code><span>\sqrt</span><span>{</span><span>\frac</span><span>{</span>a+b<span>}{</span><span>\vert</span><span>{</span>c<span>}</span><span>\vert</span><span>}</span>
</code></pre>
  </div>
  <p>refers to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <mrow>
    <msqrt>
      <mrow>
        <mfrac>
          <mrow>
            <mi>
              a
            </mi>
            <mo>
              +
            </mo>
            <mi>
              b
            </mi>
          </mrow>
          <mrow>
            <mi>
              |
            </mi>
            <mrow>
              <mi>
                c
              </mi>
            </mrow>
            <mi>
              |
            </mi>
          </mrow>
        </mfrac>
      </mrow>
    </msqrt>
  </mrow></math>. Indeed, if you‚Äôve ever needed to write a
  mathematical expression into a computer, you‚Äôre likely to have
  used either TeX or some form of pidgin TeX.</p>
  <p>But, (La)TeX really is Turing complete ‚Äì it‚Äôs just extremely
  convoluted. This makes (La)TeX a reasonably fun esoteric
  programming language to play around with. On the
  other hand, being able to wrangle (La)TeX‚Äôs macro system lets you
  automate repetitive tasks, or generally extend (La)TeX‚Äôs
  functionality, which end up being of practical use. This is
  why there is also a community effort to improve programming
  (&#34;macro writing&#34;) in LaTeX.</p>
  <p>LaTeX3 is a ‚Äúnew kernel for LaTeX [‚Ä¶ based on] its own
  consistent interface to all the functions needed to control
  TeX.&#34;<sup><a href="https://mirrors.up.pt/pub/CTAN/macros/latex/contrib/l3kernel/expl3.pdf">[@expl3.pdf]</a></sup>
  The ‚Äúnew‚Äù qualifier is arguable, seeing as it has been in
  development since 1989, but, in short, we now have access to a
  set of base macros in LaTeX which are more sophisticated and
  behave more predictably. Unfortunately, however, due to Knuth‚Äôs
  own <a href="https://en.wikipedia.org/wiki/Literate_programming">fondness of
  literate programming</a> (the man invented the concept, after
  all), and because of the nature of LaTeX‚Äôs output,<sup>[citation
  needed]</sup> most information about LaTeX3‚Äôs functionality is
  buried deep in long PDFs with interspersed prose and code and
  accessible only via <code>texdoc &lt;designator you must
  guess&gt;</code>.  A notable (and welcome)
  exception is <a href="https://www.alanshawn.com/latex3-tutorial/">this article by Alan
  Xiang, which I recommend reading</a>. In any case, this post is
  my attempt to make a small contribution to practical and
  digestible LaTeX3 materials, so that you, too, can procrastinate
  writing your document by writing very convoluted LaTeX
  macros.</p>
  <h2 id="problem-statement-and-goal">Problem statement and
  goal</h2>
  <p>In LaTeX, you may <code>\label{...}</code> sections,
  equations, ‚Ä¶, and later refer to their identifier with
  <code>\ref{...}</code>. So, for example,</p>
  <div>
    <pre><code><span>\documentclass</span><span>{</span>article<span>}</span>
<span>\begin</span><span>{</span>document<span>}</span>

<span>\section</span><span>{</span>First section<span>}</span>
<span>\label</span><span>{</span>sec:first-section<span>}</span>

Some text here.

This is actually section~<span>\ref</span><span>{</span>sec:first-section<span>}</span>.

<span>\end</span><span>{</span>document<span>}</span>
</code></pre>
  </div>
  <p>yields</p>
  <pre><code>1 First section

    Some text here.
    This is actually section 1.
</code></pre>
  <p>As said, this also works for equations, and is most useful in
  mathematical documents, where you want to reference equations in
  the body of text. LaTeX2e provides the <code>equation</code>
  environment, which automatically typesets a nice
  <code>(eqno)</code> next to your equation, and which you can
  label and reference: </p>
  <div>
    <pre><code><span>\documentclass</span><span>{</span>article<span>}</span>
<span>\let\implies\Longrightarrow</span> <span>% \implies == \Longrightarrow</span>
<span>\begin</span><span>{</span>document<span>}</span>

<span>\begin</span><span>{</span>equation<span>}</span> <span>\label</span><span>{</span>eq:a-implies-b<span>}</span>
    A <span>\implies</span> B
<span>\end</span><span>{</span>equation<span>}</span>
<span>\begin</span><span>{</span>equation<span>}</span> <span>\label</span><span>{</span>eq:b-implies-c<span>}</span>
    B <span>\implies</span> C
<span>\end</span><span>{</span>equation<span>}</span>

From eqs.~<span>$</span><span>(</span><span>\ref</span><span>{eq:a</span><span>-</span><span>implies</span><span>-</span><span>b}, </span><span>\ref</span><span>{eq:b</span><span>-</span><span>implies</span><span>-</span><span>c}</span><span>)</span><span>$</span>, we conclude that <span>$</span><span>A</span><span>$</span> implies
<span>$</span><span>C</span><span>$</span>.

<span>\end</span><span>{</span>document<span>}</span>
</code></pre>
  </div>
  <p>yields something as</p>
  <pre><code>            A ‚áí B       (1)
            B ‚áí C       (2)

From eqs. (1,2), we conclude that A implies C.
</code></pre>
  <p>However, labels must be unique throughout the document. And
  so, when writing out a long document, it quickly becomes quite
  upsetting to think up a good label for an equation you are
  certain you will only reference in the next line of text.
  Wouldn‚Äôt it be nice to have some <code>\AutoLabel</code> and
  <code>\AutoRef</code> macros that would let you just</p>
  <div>
    <pre><code><span>\begin</span><span>{</span>equation<span>}</span> <span>\AutoLabel</span>
    1 + 1 = 2
<span>\end</span><span>{</span>equation<span>}</span>

Equation~<span>\AutoRef</span><span>{}</span> can be proven with set theory.
</code></pre>
  </div>
  <h2 id="first-steps">First steps</h2>
  <p>The simplest approach to this problem is to have
  <code>\AutoLabel</code> generate a different label every time
  it‚Äôs called in a systematic way, and have <code>\AutoRef</code>
  reference that label when it‚Äôs called.</p>
  <div>
    <pre><code><span>\documentclass</span><span>{</span>article<span>}</span>
<span>\let\implies\Longrightarrow</span>

<span>\ExplSyntaxOn</span>
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autolabel<span>_</span>int
<span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autolabel<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\label</span> <span>{</span>autolabelprefix- <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoRef</span><span>}{}{</span>
    <span>\exp</span><span>_</span>args:Ne <span>\ref</span> <span>{</span>autolabelprefix-<span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
<span>}</span>
<span>\ExplSyntaxOff</span>

<span>\begin</span><span>{</span>document<span>}</span>

<span>\begin</span><span>{</span>equation<span>}</span> <span>\AutoLabel</span>
    A <span>\implies</span> B
<span>\end</span><span>{</span>equation<span>}</span>

I have just defined eq.~<span>\AutoRef</span><span>{}</span>.

<span>\end</span><span>{</span>document<span>}</span>
</code></pre>
  </div>
  <p>Let‚Äôs break this down line by line:</p>
  
  <p>Anything between <code>\ExplSyntaxOn</code> and
  <code>\ExplSyntaxOff</code> obeys LaTeX3‚Äôs syntax rules, rather
  than LaTeX2e‚Äôs rules. Indeed, (La)TeX allows you to (roughly
  speaking) re-define syntax rules on the fly; in particular, the
  ‚Äúfunction‚Äù of each character as it is parsed. So, for example,
  while <code>\</code> is usually a special character (indicating
  that what follows is a control sequence), you can change its
  value halfway through the document to function as a regular
  character. A typical (ab)use of this mechanism in LaTeX2e was the
  modification of the ‚Äúcharacter type‚Äù (the ‚Äúcharacter code‚Äù, or
  ‚Äúcatcode&#34;) of <code>@</code> between special character
  and regular letter to guard internal commands from the end-user.
  This procedure was summarized with the <code>\makeatletter</code>
  and <code>\makeatother</code> commands (to, respectively, set the
  catcode of <code>@</code> to ‚Äúregular letter‚Äù and ‚Äúother
  character&#34;), and you‚Äôll often find, in LaTeX2e code, code that
  looks like:</p>
  <div>
    <pre><code><span>\makeatletter</span>
<span>\newcommand</span><span>{</span><span>\@</span>internalcommand<span>}{</span>Do something<span>}</span>
<span>\newcommand</span><span>{</span><span>\endusercommand</span><span>}{</span><span>\@</span>internalcommand<span>\ </span>and something else.<span>}</span>
<span>\makeatother</span>
</code></pre>
  </div>
  <p>Calling <code>\@internalcommand</code> after
  <code>\makeatother</code> yields an error, because, after
  <code>\makeatother</code> is called, LaTeX doesn‚Äôt know how to
  interpret the character <code>@</code> anymore. This also
  highlights the fact that the catcode switching happens as these
  declarations are parsed, even though the expressions in the
  declarations themselves are <em>not</em> evaluated at the time of
  declaration. This finds expression in the following example, a
  mistake I‚Äôve incurred in more than once:</p>
  <div>
    <pre><code><span>\newcommand</span><span>{</span><span>\boom</span><span>}{</span><span>\makeatletter\@</span>destroytheworld<span>\makeatother</span><span>}</span>
</code></pre>
  </div>
  <p>Calling <code>\boom</code> later in the document errors out,
  since at the time of declaration, <code>\@</code> is parsed as
  the command in the declaration, not
  <code>\@destroytheworld</code>. At macro declaration time, the
  parser sees <code>\makeatletter</code>, but only as a macro that
  is part of the declaration ‚Äì it doesn‚Äôt make sense to ‚Äúrun‚Äù the
  definition at declaration time, after all. It thus parses the
  rest of the declaration based on its current rules, which do
  <em>not</em> expect <code>@</code> to be a regular character. So,
  as far as the parser cares, <code>\boom</code> reads
  <code>[macro: \makeatletter] [macro: \@] [letters:
  destroytheworld] [macro: \makeatother]</code>. When
  <code>\boom</code> is finally called, LaTeX complains about the
  use of <code>\@</code>.</p>
  <p>This is a reasonably long tangent to say that
  <code>\ExplSyntaxOn</code> modifies catcodes, to favour better
  and more consistent macro names, and to provide a nicer
  ‚Äúprogramming‚Äù environment. There are two notable effects: first,
  within <code>expl3</code> rules, spaces are ignored. Really,
  dealing with spaces within macro declarations is a true pain
  point of LaTeX2e; not just spaces you type out, but also spaces
  implied by new lines. Here‚Äôs an example; what do you expect the
  differences to be between <code>\a</code>, <code>\b</code>,
  <code>\c</code>, and <code>\d</code>?</p>
  <div>
    <pre><code><span>\newcommand</span><span>{</span><span>\a</span><span>}{</span>foobar<span>}</span>
<span>\newcommand</span><span>{</span><span>\b</span><span>}{</span>
    foobar
<span>}</span>
<span>\newcommand</span><span>{</span><span>\c</span><span>}{</span>
    foo
    bar<span>%</span>
<span>}</span>
<span>\newcommand</span><span>{</span><span>\d</span><span>}{</span>foo<span>%</span>
    bar<span>}</span>
</code></pre>
  </div>
  <p>I tested these out by calling <code>.\a..\b..\c..\d.</code>
  within a LaTeX document; the periods are there to highlight
  eventual spacing. The results are as follows:</p>
  <pre><code>.foobar..‚ê£foobar‚ê£..‚ê£foo‚ê£bar..foobar.
</code></pre>
  <p>(I‚Äôve highlighted spaces for you, with the <code>‚ê£</code>
  character.) Essentially, what you would expect happens in the
  body of text ‚Äì that a single newline becomes a space ‚Äì is also
  happening within the macro declaration, inserting spurious spaces
  everywhere. These spaces can only be avoided by inserting comment
  characters, <code>%</code>, before the end of the line, which the
  parser interprets as an explicit instruction to ignore the
  newline. This results in a mess of <code>%</code> everywhere in
  macro declarations, since, at some point, macro writers start
  putting a <code>%</code> at the end of every line where they
  don‚Äôt <em>explicitly</em> want some space. While, in the example
  given, the spaces are not too critical (although unwanted),
  within complicated macro declarations spurious spaces will cause
  some really nasty bugs and crashes. The situation is even worse
  with double newlines, which get transformed into a
  paragraph, and that will <em>really</em> mess up your
  command‚Äôs parsing.</p>
  <p>The other notable catcode switch is making <code>:</code> and
  <code>_</code> ‚Äúregular letters‚Äù. So, while in LaTeX2e, macro
  names are generally composed of <code>a-zA-Z</code> (and,
  eventually, <code>@</code>), in LaTeX3, macros names are expected
  to be of the form (<code>texdoc expl3</code>, sec. 3.2.),</p>
  <pre><code>\‚ü®module‚ü©_‚ü®description‚ü©:‚ü®arg-spec‚ü©
</code></pre>
  <p>where <code>module</code> would be a unique per-macro package
  prefix, to avoid name collisions, and <code>description</code>
  would be the actual name of the macro. <code>arg-spec</code> is a
  bit more special, telling you what <em>kind</em> of argument the
  macro expects, and, notably, if the command will expand it or
  not. Think of it as only slightly more than type hints. Macro
  expansion is a big topic ‚Äì too big to cover here ‚Äì but here‚Äôs an
  illustrative example:</p>
  <div>
    <pre><code><span>\newcommand</span><span>{</span><span>\foobar</span><span>}{</span>A winner is you!<span>}</span>
<span>\newcommand</span><span>{</span><span>\myname</span><span>}{</span>foobar<span>}</span>

<span>\csname\myname\endcsname</span> <span>% The macro named `\myname`</span>
                         <span>% (so, `\\myname`, if it were possible.)</span>

<span>\expandafter\csname\myname\endcsname</span> <span>% \foobar</span>
</code></pre>
  </div>
  <p>Read more about expansion <a href="https://www.overleaf.com/learn/latex/Articles/How_does_%5Cexpandafter_work%3A_The_meaning_of_expansion">
  here</a>.</p>
  <p>In <code>expl3</code>, the <code>arg-spec</code> bit of a
  macro will tell you what the macro consumes, and if it will
  expand what it consumes. The main ones to care about (though you
  can find a complete list in <code>texdoc expl3</code>, chapter 3,
  and throughout the main reference for programming in LaTeX3,
  <code>texdoc interface3</code>) are:</p>
  <ul>
    <li><code>n</code> ‚Äì a braced set of characters (&#34;token
    list&#34;),</li>
    <li><code>N</code> ‚Äì a single character (&#34;token&#34;); a macro is a
    single token,</li>
    <li><code>c</code> ‚Äì a macro <em>name</em>
    (<code>foobar</code>, rather than <code>\foobar</code>); thus,
    a token list,</li>
    <li><code>V</code> ‚Äì a variable, i.e., a macro containing a
    value (read on),</li>
    <li><code>v</code> ‚Äì a variable‚Äôs <em>name</em>; like
    <code>c</code>, but for <code>V</code>,</li>
    <li><code>e</code> ‚Äì a braced set of characters to be fully
    expanded before consumption,</li>
    <li><code>o</code> ‚Äì a braced set of characters to be expanded
    once before consumption,</li>
    <li><code>T</code> and <code>F</code> ‚Äì a braced set of
    characters to be inserted in case some condition evaluates to
    true or false, respectively.</li>
  </ul>
  <p>The notion of a ‚Äúvariable‚Äù also appears here, as LaTeX3 tries
  to separate the notion of a macro that <em>does</em> something (a
  function) from a macro that merely stores some value (a
  variable). So, in LaTeX3 terms, <code>\foo</code> below would be
  a variable, whereas <code>\baz</code> is a function:</p>
  <div>
    <pre><code><span>\newcommand</span><span>{</span><span>\foo</span><span>}{</span>winner<span>}</span>
<span>\newcommand</span><span>{</span><span>\baz</span><span>}</span>[1]<span>{</span>A #1 is you!<span>}</span>

<span>\baz</span><span>{</span><span>\foo</span><span>}</span>
</code></pre>
  </div>
  <p>Though I should really say,</p>
  <div>
    <pre><code><span>\ExplSyntaxOn</span>
<span>\cs</span><span>_</span>new:Nn <span>\baz</span>:N <span>{</span>
    A #1 is you!
<span>}</span>
<span>\tl</span><span>_</span>new:Nn <span>\foo</span> <span>{</span>winner<span>}</span>
<span>\baz</span>:N <span>\foo</span>
<span>\ExplSyntaxOff</span>
</code></pre>
  </div>
  <p>Even more correct would be</p>
  <div>
    <pre><code><span>\ExplSyntaxOn</span>
<span>\cs</span><span>_</span>new:Nn <span>\baz</span>:N <span>{</span>
    A #1 is you!
<span>}</span>
<span>\cs</span><span>_</span>generate<span>_</span>variant:Nn <span>\baz</span>:N <span>{</span>V<span>}</span>
<span>\tl</span><span>_</span>new:Nn <span>\foo</span> <span>{</span>winner<span>}</span>
<span>\baz</span>:V <span>\foo</span>
<span>\ExplSyntaxOff</span>
</code></pre>
  </div>
  <p>And, finally, heck it, <code>texdoc expl3</code> specifies
  that variables should be named as
  <code>\‚ü®scope‚ü©_‚ü®module‚ü©_‚ü®description‚ü©_‚ü®type‚ü©</code>, so here‚Äôs
  some good, honest to God, LaTeX3:</p>
  <div>
    <pre><code><span>\ExplSyntaxOn</span>
<span>\cs</span><span>_</span>new:Nn <span>\custom</span><span>_</span>baz:N <span>{</span>
    A #1 is you!
<span>}</span>
<span>\cs</span><span>_</span>generate<span>_</span>variant:Nn <span>\custom</span><span>_</span>baz:N <span>{</span>V<span>}</span>
<span>\tl</span><span>_</span>new:Nn <span>\l</span><span>_</span>custom<span>_</span>foo<span>_</span>tl <span>{</span>winner<span>}</span>
<span>\custom</span><span>_</span>baz:N <span>\l</span><span>_</span>custom<span>_</span>foo<span>_</span>tl
<span>\ExplSyntaxOff</span>
</code></pre>
  </div>
  <p>This is the price to pay for the magical expansion control
  tools that LaTeX3 gives.</p>
  <p>Finally, we move to the following line,</p>
  <div>
    <pre><code><span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autolabel<span>_</span>int
</code></pre>
  </div>
  <p>Here, we‚Äôre declaring a new integer variable. As good LaTeX3
  netizens, we use the correct variable naming scheme, and declare
  the variable to be global with <code>g_</code> (labels will need
  to be globally unique to the document, so this makes sense). We
  can expect this variable to be initialized to 0; from page 168 of
  <code>texdoc interface3</code>:</p>
  <blockquote>
    <p>The ‚ü®integer‚ü© is initially equal to 0.</p>
  </blockquote>
  <p>The idea will be that we can generate infinite unique labels
  by choosing a unique prefix, and suffixing it with an increasing
  integer; <code>\g_autolabel_int</code> will hold this
  integer.</p>
  <p>Next line:</p>
  <div>
    <pre><code><span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autolabel<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\label</span> <span>{</span>autolabelprefix- <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
<span>}</span>
</code></pre>
  </div>
  <p>Here we declare a user-facing command, with
  <code>\NewDocumentCommand</code> (LaTeX3‚Äôs version of
  <code>\newcommand</code>, much nicer to use and about which you
  can read with <code>texdoc xparse</code>). Thus, there is no need
  to adhere to LaTeX3‚Äôs naming conventions. The declaration
  furthermore specifies that it takes no arguments from the user,
  and leaves in its place, when called, two instructions: a global
  increment of the <code>\g_autolabel_int</code> variable, and
  <code>\exp_args:Ne \label {autolabelprefix- \int_use:N
  \g_autolabel_int}</code>. Here is what
  <code>interface3.pdf</code> has to say about
  <code>\exp_args:Ne</code>:</p>
  <blockquote>
    <p>This function absorbs two arguments (the ‚ü®function‚ü© name and
    the ‚ü®tokens‚ü©) and exhaustively expands the ‚ü®tokens‚ü©. The result
    is inserted in braces into the input stream after reinsertion
    of the ‚ü®function‚ü©. Thus the ‚ü®function‚ü© may take more than one
    argument: all others are left unchanged.</p>
  </blockquote>
  <p>Ideally, we would have some labelling function
  <code>\label:n</code> with a variant <code>\label:e</code>, that
  would expand whatever would be given to it before taking the
  result as the actual label text. But, we don‚Äôt, since
  <code>label</code> is a LaTeX2e command (<code>texdoc
  latex2e</code>, chap. 7.1). So, we use <code>LaTeX3</code>‚Äôs
  <code>\exp_args:Ne</code>, to leave the first token
  (<code>\label</code>) alone while the braced tokens that follow
  are not fully expanded. Only then is this token list passed as
  argument to <code>\label</code>.</p>
  <p>Inside the token list, we find <code>autolabelprefix-
  \int_use:N \g_autolabel_int</code>: since <code>\int_use:N</code>
  will ‚Äú[recover] the content of an ‚ü®integer‚ü© and [place] it
  directly in the input stream‚Äù, we get, after full expansion, our
  unique label, of the form</p>
  <pre><code>autolabelprefix-‚ü®label number‚ü©
</code></pre>
  <p>Finally, we have the declaration of the command that
  references this label:</p>
  <div>
    <pre><code><span>\NewDocumentCommand</span><span>{</span><span>\AutoRef</span><span>}{}{</span>
    <span>\exp</span><span>_</span>args:Ne <span>\ref</span> <span>{</span>autolabelprefix-<span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
<span>}</span>
</code></pre>
  </div>
  <p>It‚Äôs fairly similar to <code>\AutoLabel</code>, with the
  exception that the relevant LaTeX2e function is now
  <code>\ref</code>, rather than <code>\label</code>. Since we know
  the form of the generated labels, we reconstruct the label at
  referencing time, by once again using the
  <code>\g_autolabel_int</code> variable and
  <code>\exp_args:Ne</code>.</p>
  <h2 id="multiple-labels">Multiple Labels</h2>
  <p>The above solution works fine, but it quickly breaks down if
  we wish to reference two equations after <em>both</em> their
  declarations. To recover a previous example,</p>
  <div>
    <pre><code><span>% snip</span>
<span>\begin</span><span>{</span>equation<span>}</span> <span>\AutoLabel</span>
    A <span>\implies</span> B
<span>\end</span><span>{</span>equation<span>}</span>
<span>\begin</span><span>{</span>equation<span>}</span> <span>\AutoLabel</span>
    B <span>\implies</span> C
<span>\end</span><span>{</span>equation<span>}</span>

Eqs.~<span>\AutoRef\ </span>and <span>\AutoRef\ </span>imply <span>$</span><span>A </span><span>\implies</span><span> C</span><span>$</span>.
</code></pre>
  </div>
  <p>will not work, as the output will read</p>
  <pre><code>Eqs. (2) and (2) imply A ‚áí C.
</code></pre>
  <p>We can deal with this quite simply, by counting the number of
  labels and references separately:</p>
  <div>
    <pre><code><span>\ExplSyntaxOn</span>
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autolabel<span>_</span>int
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autoref<span>_</span>int
<span>\tl</span><span>_</span>const:Nn <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>{</span>autolabelprefix-<span>}</span>

<span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}</span> <span>{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autolabel<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\label</span><span>{</span> <span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int <span>}</span>
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoRef</span><span>}{}</span> <span>{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autoref<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\ref</span><span>{</span> <span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autoref<span>_</span>int<span>}</span>
<span>}</span>
<span>\ExplSyntaxOff</span>
</code></pre>
  </div>
  <p>I‚Äôve sneaked in <code>\c_autoprefix_tl</code> as a constant
  token list holding the prefix, just because it looks that much
  nicer than a repeated arbitrary constant string throughout the
  source, and I‚Äôve also done away with the scope for the sake of
  readability. Otherwise everything is still quite similar to the
  previous definition. Things start going awry when using, for
  example, the <code>gather</code> environment from the
  <code>amsmath</code> package:</p>
  <div>
    <pre><code><span>% snip</span>
<span>\begin</span><span>{</span>gather<span>}</span> 
    A <span>\implies</span> B <span>\AutoLabel</span> <span>\\</span>
    B <span>\implies</span> C <span>\AutoLabel</span>
<span>\end</span><span>{</span>gather<span>}</span>
</code></pre>
  </div>
  <p>produces</p>
  <pre><code>Eqs. ?? and ?? imply A ‚áí C.
</code></pre>
  <p>What‚Äôs going on? LaTeX3 does have some console debugging
  capabilities, with commands such as <code>tl_show:N</code>, but
  it‚Äôs easier, here, to just go with LaTeX‚Äôs version of
  print-debugging: placing values directly in the text. We thus
  modify the <code>\AutoLabel</code> definition to not only label
  the equations, but also place the label‚Äôs name in the text
  stream:</p>
  <div>
    <pre><code><span>% snip</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}</span> <span>{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autolabel<span>_</span>int
    <span>% üëá new addition</span>
    <span>{</span><span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\label</span><span>{</span> <span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int <span>}</span>
<span>}</span>
<span>% snip</span>
</code></pre>
  </div>
  <p>Once again compiling, we find that the equations now read:</p>
  <pre><code>    A ‚áí Bautolabelprefix‚àí3   (1)
    B ‚áí Cautolabelprefix‚àí4   (2)
</code></pre>
  <p>Huh?! Where did labels 1 and 2 go? The problem seems to happen
  only with <code>amsmath</code> environments, and so a little bit
  of trolling its documentation (<code>texdoc amsmath</code>)
  reveals the following paragraph:</p>
  <blockquote>
    <p><code>ifmeasuring@</code> ‚Äì All display environments get
    typeset twice‚Äîonce during a ‚Äúmeasuring‚Äù phase and then again
    during a ‚Äúproduction‚Äù phase; <code>\ifmeasuring@</code> will be
    used to determine which case we‚Äôre in, so we can take
    appropriate action.</p>
    <p><code>\newif\ifmeasuring@</code></p>
  </blockquote>
  <p>Uh oh. Our <code>\AutoLabel</code> function is getting called
  twice: once in a box that <code>amsmath</code> uses to perform
  measurements, and then discards, and then again when the actual
  typesetting happens. To make matters worse, <code>amsmath</code>
  is using a Plain TeX Boolean, <code>\ifmeasuring@</code>,
  <em>and</em> the Boolean‚Äôs name has a <code>@</code> in it.
  Here‚Äôs what <code>interface3.pdf</code> has to say on its
  Booleans, and Plain TeX‚Äôs Booleans:</p>
  <blockquote>
    <p>TeXhackers note: The <code>bool</code> data type is not
    implemented using the
    <code>\iffalse</code>/<code>\iftrue</code> primitives, in
    contrast to <code>\newif</code>, etc., in plain TeX, LaTeX2e
    and so on. Programmers should not base use of <code>bool</code>
    switches on any particular expectation of the
    implementation.</p>
  </blockquote>
  <p>Plain TeX Booleans are very fickle, and likely to misbehave if
  the Boolean test looks anything other than</p>
  
  <p>We might get away with giving some arguments to
  <code>\a</code> or <code>\b</code>, but no more than that;
  certainly, something like
  <code>\ifbool\a\b\c\else\d\e\f\fi</code> is bound to cause you
  trouble. So, our first step is moving the whole of
  <code>\AutoLabel</code> into a single macro of its own:</p>
  <div>
    <pre><code><span>\ExplSyntaxOn</span>
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autolabel<span>_</span>int
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autoref<span>_</span>int
<span>\tl</span><span>_</span>const:Nn <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>{</span>autolabelprefix-<span>}</span>

<span>\cs</span><span>_</span>new:Nn <span>\autolabel</span>: <span>{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autolabel<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\label</span><span>{</span> <span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int <span>}</span>
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}{</span>
    <span>\autolabel</span>:
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoRef</span><span>}{}{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autoref<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\ref</span><span>{</span> <span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autoref<span>_</span>int<span>}</span>
<span>}</span>
<span>\ExplSyntaxOff</span>
</code></pre>
  </div>
  <p>Now, we need only to test <code>\ifmeasuring@</code> inside
  <code>\AutoLabel</code>, and behave accordingly; i.e., if,
  indeed, measuring, we don‚Äôt want to do anything at all. But,
  recall that LaTeX3 and LaTeX2e‚Äôs relationship with <code>@</code>
  is different, and LaTeX3 won‚Äôt correctly interpret
  <code>\ifmeasuring@</code> at all (it‚Äôs not expecting macro names
  to have <code>@</code>s in them). We may get around this by first
  using a <code>c</code>-type argument, and an auxiliary
  definition:</p>
  <div>
    <pre><code><span>% snip</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}{</span>
    <span>\cs</span><span>_</span>set<span>_</span>eq:Nc <span>\amsmath</span><span>_</span>ifmeasuring <span>{</span>ifmeasuring@<span>}</span>
    <span>\amsmath</span><span>_</span>ifmeasuring<span>\else\autolabel</span>:<span>\fi</span>
<span>}</span>
<span>% snip</span>
</code></pre>
  </div>
  <p>We‚Äôre using the <code>Nc</code> variant of
  <code>\cs_set_eq:NN</code>, about which
  <code>interface3.pdf</code> tells us:</p>
  <blockquote>
    <p>Globally creates ‚ü®control sequence1‚ü© and sets it to have the
    same meaning as ‚ü®control sequence2‚ü© or ‚ü®token‚ü©. The second
    control sequence may subsequently be altered with- out
    affecting the copy.</p>
  </blockquote>
  <p>Is this very kosher? Absolutely not. Is this the least cursed
  LaTeX macro ever written? Not even close, and it works, to boot.
  Run your compilation steps again, and you‚Äôll find the document
  now correctly reads</p>
  <pre><code>        A ‚áí B               (1)
        B ‚áí C               (2)

Eqs. 1 and 2 imply A ‚áí C.
</code></pre>
  <h2 id="some-final-improvements">Some final improvements</h2>
  <p>The last thing that‚Äôs missing is the ability to repeatedly
  reference the same equation. As it stands, there is no way to
  typeset something like</p>
  <pre><code>Eqs. 1 and 2 imply A ‚áí C, but eq. 1 does not imply B ‚áí A.
</code></pre>
  <p>Let‚Äôs fix that. Specifically, let‚Äôs modify
  <code>\AutoRef</code> to take in an optional argument. If the
  argument is present, and equal to <code>n</code>, then that
  command should reference the <code>n</code>th equation before it.
  Thus, our previous example would correspond to something like</p>
  <div>
    <pre><code>Eqs.~<span>\AutoRef\ </span>and <span>\AutoRef</span> imply <span>$</span><span>A </span><span>\implies</span><span> C</span><span>$</span>, but <span>\AutoRef</span><span>[2]</span> does not imply <span>$</span><span>B </span><span>\implies</span><span> A</span><span>$</span>.
</code></pre>
  </div>
  <p>I‚Äôll once again give you the final answer, and then break down
  any new elements:</p>
  <div>
    <pre><code><span>\ExplSyntaxOn</span>
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autolabel<span>_</span>int
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autoref<span>_</span>int
<span>\tl</span><span>_</span>const:Nn <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>{</span>autolabelprefix-<span>}</span>

<span>\cs</span><span>_</span>new:Nn <span>\autolabel</span>: <span>{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autolabel<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\label</span><span>{</span> <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}{</span>
    <span>\cs</span><span>_</span>set<span>_</span>eq:Nc<span>\amsmath</span><span>_</span>ifmeasuring<span>{</span>ifmeasuring@<span>}</span>
    <span>\amsmath</span><span>_</span>ifmeasuring<span>\else\autolabel</span>:<span>\fi</span>
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoRef</span><span>}{</span>o<span>}{</span>
    <span>\cs</span><span>_</span>set<span>_</span>eq:Nc<span>\amsmath</span><span>_</span>ifmeasuring<span>{</span>ifmeasuring@<span>}</span>
    <span>\IfValueF</span><span>{</span>#1<span>}</span>
        <span>{</span><span>\amsmath</span><span>_</span>ifmeasuring<span>\else\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autoref<span>_</span>int<span>\fi</span><span>}</span>
    <span>\IfValueTF</span><span>{</span>#1<span>}</span>
        <span>{</span><span>\int</span><span>_</span>set<span>_</span>eq:NN <span>\l</span><span>_</span>tmpa<span>_</span>int <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
        <span>{</span><span>\int</span><span>_</span>set<span>_</span>eq:NN <span>\l</span><span>_</span>tmpa<span>_</span>int <span>\g</span><span>_</span>autoref<span>_</span>int<span>}</span>
    <span>\IfValueT</span><span>{</span>#1<span>}</span>
        <span>{</span><span>\int</span><span>_</span>sub:Nn <span>\l</span><span>_</span>tmpa<span>_</span>int <span>{</span>#1 - 1<span>}}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\ref</span> <span>{</span><span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\l</span><span>_</span>tmpa<span>_</span>int<span>}</span>
<span>}</span>
<span>\ExplSyntaxOff</span>
</code></pre>
  </div>
  <p>First, note that I‚Äôve also guarded the
  <code>\g_autoref_int</code> counter against double incrementation
  due to measuring ‚Äì something we‚Äôd neglected to previously do, but
  it‚Äôs plausible <code>\AutoRef</code> is called within an
  <code>amsmath</code> environment. Otherwise, the main difference
  to the previous definitions has to do with the inclusion of the
  optional (<code>o</code>) argument in the declaration of
  <code>\AutoRef</code>.When no value is given for these arguments,
  they take a special flag value (usually denoted
  <code>-NoValue-</code> in the documentation). <code>xparse</code>
  provides the nice <code>IfValue(TF)</code> macros to deal with
  the cases where, respectively, the argument takes some value, or
  no value.</p>
  <p>So, when we find that the user passed some optional value, we
  calculate the corresponding ‚Äúabsolute label number‚Äù; this is
  given by the current auto-labelling number, minus the number the
  user gave minus one (in other words: if
  <code>g_autolabel_int</code> is currently <code>2</code>,
  implying <code>autoprefix-1</code> and <code>-2</code> were
  already defined, and the user passes in <code>\AutoRef[2]</code>,
  they are referencing <code>autoprefix-1</code>, and <code>1 =
  2-(2-1)</code>).</p>
  <p>If, on the other hand, the user did not pass in any value,
  then they are referencing the most recent label; as before, we
  increment <code>g_autoref_int</code>, and set
  <code>\l_tmpa_int</code> to hold this number:
  </p>
  <div>
    <pre><code><span>\amsmath</span><span>_</span>ifmeasuring<span>\else\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autoref<span>_</span>int<span>\fi</span>
<span>\int</span><span>_</span>set<span>_</span>eq:NN <span>\l</span><span>_</span>tmpa<span>_</span>int <span>\g</span><span>_</span>autoref<span>_</span>int
</code></pre>
  </div>
  <p>Then, the final line correctly references the most recent
  label:</p>
  <div>
    <pre><code><span>\exp</span><span>_</span>args:Ne <span>\ref</span> <span>{</span><span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\l</span><span>_</span>tmpa<span>_</span>int<span>}</span>
</code></pre>
  </div>
  <p>This <em>almost</em> works, except for the following edge
  case: what do you expect the following code to produce?</p>
  <div>
    <pre><code><span>\begin</span><span>{</span>equation<span>}</span> <span>\AutoLabel</span>
    A = A
<span>\end</span><span>{</span>equation<span>}</span>

<span>\AutoRef</span><span>[1]</span> constitutes a ``tautology&#39;&#39;.

<span>\begin</span><span>{</span>equation<span>}</span>
    A = B
<span>\end</span><span>{</span>equation<span>}</span>

Eq.~<span>\AutoRef</span><span>{}</span> does not constitute a tautology.
</code></pre>
  </div>
  <p>As it stands, the first call to <code>\AutoRef[1]</code>
  correctly references the label of the first equation, but it does
  <em>not</em> advance <code>\g_autoref_int</code>, because a value
  is given. Therefore, when <code>\AutoRef</code> is called a
  second time, in the second paragraph, it again references the
  first equation. This is, however, the behaviour we might expect
  in the following situation (which, with apologies, is more
  synthetic):</p>
  <div>
    <pre><code><span>\begin</span><span>{</span>gather<span>}</span>
    A <span>\AutoLabel</span> <span>\\</span>
    B <span>\AutoLabel</span> <span>\\</span>
    C <span>\AutoLabel</span>
<span>\end</span><span>{</span>gather<span>}</span>

Eq~<span>\AutoRef</span><span>[1]</span> and <span>\AutoRef</span><span>{}</span> and <span>\AutoRef</span><span>{}</span>.
</code></pre>
  </div>
  <p>Indeed, here, we do <em>not</em> expect
  <code>\AutoRef[1]</code> to advance
  <code>\g_autoref_int</code>.</p>
  <p>The bottom line is that, to get the intended behaviour,
  calling <code>\AutoRef[1]</code> should be indifferent from
  simply calling <code>\AutoRef</code>; but only in the case where
  the two would produce the same result. This is not currently the
  case. But!, LaTeX3 has us covered with some pretty comprehensive
  arithmetic tools. The following modification to
  <code>\AutoRef</code> is sufficient:</p>
  <div>
    <pre><code><span>% snip</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoRef</span><span>}{</span>o<span>}{</span>
    <span>\cs</span><span>_</span>set<span>_</span>eq:Nc<span>\amsmath</span><span>_</span>ifmeasuring<span>{</span>ifmeasuring@<span>}</span>
    <span>% üëá main difference</span>
    <span>\tl</span><span>_</span>set:Nn <span>\l</span><span>_</span>tmpb<span>_</span>tl <span>{</span>#1<span>}</span>
    <span>\IfValueT</span><span>{</span>#1<span>}</span>
        <span>{</span><span>\int</span><span>_</span>compare:nNnT <span>{</span>#1<span>}</span>=<span>{</span>1<span>}</span> <span>{</span>
            <span>\int</span><span>_</span>compare:nNnT <span>{</span><span>\g</span><span>_</span>autoref<span>_</span>int<span>}</span>=<span>{</span><span>\g</span><span>_</span>autolabel<span>_</span>int - 1<span>}</span> 
                <span>{</span><span>\tl</span><span>_</span>set:NV <span>\l</span><span>_</span>tmpb<span>_</span>tl <span>\c</span><span>_</span>novalue<span>_</span>tl<span>}}}</span>
    <span>% üëÜ</span>
    <span>% üëá But notice also the use of \l_tmpb_tl below, now:</span>
    <span>\exp</span><span>_</span>args:Ne <span>\IfValueF</span><span>{</span><span>\tl</span><span>_</span>use:N <span>\l</span><span>_</span>tmpb<span>_</span>tl<span>}</span>
        <span>{</span><span>\amsmath</span><span>_</span>ifmeasuring<span>\else\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autoref<span>_</span>int<span>\fi</span><span>}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\IfValueTF</span><span>{</span><span>\tl</span><span>_</span>use:N <span>\l</span><span>_</span>tmpb<span>_</span>tl<span>}</span>
        <span>{</span><span>\int</span><span>_</span>set<span>_</span>eq:NN <span>\l</span><span>_</span>tmpa<span>_</span>int <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
        <span>{</span><span>\int</span><span>_</span>set<span>_</span>eq:NN <span>\l</span><span>_</span>tmpa<span>_</span>int <span>\g</span><span>_</span>autoref<span>_</span>int<span>}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\IfValueT</span><span>{</span><span>\tl</span><span>_</span>use:N <span>\l</span><span>_</span>tmpb<span>_</span>tl<span>}</span>
        <span>{</span><span>\exp</span><span>_</span>args:NNe <span>\int</span><span>_</span>sub:Nn <span>\l</span><span>_</span>tmpa<span>_</span>int <span>{</span><span>\tl</span><span>_</span>use <span>\l</span><span>_</span>tmpb<span>_</span>tl - 1<span>}}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\ref</span> <span>{</span><span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\l</span><span>_</span>tmpa<span>_</span>int<span>}</span>
<span>}</span>
<span>% snip</span>
</code></pre>
  </div>
  <p>The idea is not so different; but now, instead of addressing
  the optional argument directly (<code>#1</code>), we start by
  assigning it to <code>\l_tmpb_tl</code>. Then, if we find that
  the user did pass in some value, but that this value is 1, and
  would result in the same as not having provided any value at all,
  we put the empty value into <code>\l_tmpb_tl</code>. The rest of
  the command is therefore processed, in that case, as though the
  user had not supplied a value.</p>
  <p>Using <code>\l_tmpb_tl</code> instead of <code>#1</code>
  requires some further care with <code>\exp_args:Ne</code> to make
  sure the value of <code>\l_tmpb_tl</code> is expanded before it‚Äôs
  tested, but nothing special.</p>
  
  <p>Thus, we have our final set of LaTeX3 macros:</p>
  <div>
    <pre><code><span>\ExplSyntaxOn</span>
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autolabel<span>_</span>int
<span>\int</span><span>_</span>new:N <span>\g</span><span>_</span>autoref<span>_</span>int
<span>\tl</span><span>_</span>const:Nn <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>{</span>autolabelprefix-<span>}</span>

<span>\cs</span><span>_</span>new:Nn <span>\autolabel</span>: <span>{</span>
    <span>\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autolabel<span>_</span>int
    <span>\exp</span><span>_</span>args:Ne <span>\label</span><span>{</span> <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoLabel</span><span>}{}{</span>
    <span>\cs</span><span>_</span>set<span>_</span>eq:Nc<span>\amsmath</span><span>_</span>ifmeasuring<span>{</span>ifmeasuring@<span>}</span>
    <span>\amsmath</span><span>_</span>ifmeasuring<span>\else\autolabel</span>:<span>\fi</span>
<span>}</span>
<span>\NewDocumentCommand</span><span>{</span><span>\AutoRef</span><span>}{</span>o<span>}{</span>
    <span>\cs</span><span>_</span>set<span>_</span>eq:Nc<span>\amsmath</span><span>_</span>ifmeasuring<span>{</span>ifmeasuring@<span>}</span>
    <span>\tl</span><span>_</span>set:Nn <span>\l</span><span>_</span>tmpb<span>_</span>tl <span>{</span>#1<span>}</span>
    <span>\IfValueT</span><span>{</span>#1<span>}</span>
        <span>{</span><span>\int</span><span>_</span>compare:nNnT <span>{</span>#1<span>}</span>=<span>{</span>1<span>}</span> <span>{</span>
            <span>\int</span><span>_</span>compare:nNnT <span>{</span><span>\g</span><span>_</span>autoref<span>_</span>int<span>}</span>=<span>{</span><span>\g</span><span>_</span>autolabel<span>_</span>int - 1<span>}</span> 
                <span>{</span><span>\tl</span><span>_</span>set:NV <span>\l</span><span>_</span>tmpb<span>_</span>tl <span>\c</span><span>_</span>novalue<span>_</span>tl<span>}}}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\IfValueF</span><span>{</span><span>\tl</span><span>_</span>use:N <span>\l</span><span>_</span>tmpb<span>_</span>tl<span>}</span>
        <span>{</span><span>\amsmath</span><span>_</span>ifmeasuring<span>\else\int</span><span>_</span>gincr:N <span>\g</span><span>_</span>autoref<span>_</span>int<span>\fi</span><span>}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\IfValueTF</span><span>{</span><span>\tl</span><span>_</span>use:N <span>\l</span><span>_</span>tmpb<span>_</span>tl<span>}</span>
        <span>{</span><span>\int</span><span>_</span>set<span>_</span>eq:NN <span>\l</span><span>_</span>tmpa<span>_</span>int <span>\g</span><span>_</span>autolabel<span>_</span>int<span>}</span>
        <span>{</span><span>\int</span><span>_</span>set<span>_</span>eq:NN <span>\l</span><span>_</span>tmpa<span>_</span>int <span>\g</span><span>_</span>autoref<span>_</span>int<span>}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\IfValueT</span><span>{</span><span>\tl</span><span>_</span>use:N <span>\l</span><span>_</span>tmpb<span>_</span>tl<span>}</span>
        <span>{</span><span>\exp</span><span>_</span>args:NNe <span>\int</span><span>_</span>sub:Nn <span>\l</span><span>_</span>tmpa<span>_</span>int <span>{</span><span>\tl</span><span>_</span>use <span>\l</span><span>_</span>tmpb<span>_</span>tl - 1<span>}}</span>
    <span>\exp</span><span>_</span>args:Ne <span>\ref</span> <span>{</span><span>\tl</span><span>_</span>use:N <span>\c</span><span>_</span>autoprefix<span>_</span>tl <span>\int</span><span>_</span>use:N <span>\l</span><span>_</span>tmpa<span>_</span>int<span>}</span>
<span>}</span>
<span>\ExplSyntaxOff</span>
</code></pre>
  </div>
  <p>While quite a modest contribution to the <a href="https://ctan.math.illinois.edu/">very hefty history of LaTeX
  packages</a>, it nonetheless served as a basis for discussing
  important points of LaTeX3 macro writing, such as syntax
  differences, token list manipulation, controlled expansion,
  variables and functions, Boolean tests, and LaTeX2e interfacing.
  Not too shabby. Hopefully this post is also a good enough
  introduction that you may now directly reference important
  reference documents, such as <code>interface3.pdf</code>,
  yourself.</p>
  <p>Personally, I also find the macro itself quite useful in
  practice, and it‚Äôs something I‚Äôve been using in my scientific
  writing. I am yet to find out if Physical Review will be upset by
  it.</p>
  <p>As a parting gift, and to point the interested user towards
  property lists, here is an exercise for the reader: the
  <code>revtex4-2</code> document class, mandated by Physical
  Review, does not support the use of <code>\footnotetext</code>
  and <code>\footnotenumber</code>. This means that any footnote
  text really must be in the middle of the source of the body of
  text. Can you write <code>\FootnoteLater</code> and
  <code>\FootnoteNow</code> to rectify this?</p>
  <hr/>
  <p><strong>A Post-Scriptum for HackerNews readers:</strong> I
  like to submit these posts to HN, as I feel like the average HN
  user fits the intended audience. But, 1. famously, HN can be
  quite predictable in some of their responses (by what I expect
  is, essentially, a meme effect), and 2. I‚Äôve had some unexpected
  experiences resulting from previously reaching FP in HN. So,
  consider this a preemptive response to some points I expect to be
  raised. If you‚Äôre coming in from HN and you see someone fail to
  account for these answers, you‚Äôll know they haven‚Äôt even read the
  whole thing. So:</p>
  <ol>
    <li>It‚Äôs weird I even have to say this, but don‚Äôt stalk me and
    email me at my personal address. This is genuinely something
    that has happened, inexplicably. If you wish to contact me by
    email, by all means do so to <code>miguelmurca+autoref [√¶t]
    cumperativa.xyz</code>.</li>
    <li>Again, strange that I would need to point this out, but do
    not assume my nationality, or language. This post is in
    English. If you wish to write me, please do so in English.</li>
    <li>Yes, we are aware of <a href="https://github.com/typst/typst">typst</a>. I think it‚Äôs cool,
    but C++ hasn‚Äôt replaced C, Rust hasn‚Äôt replaced C++, Typst is
    unlikely to replace LaTeX. Likewise, many are aware of
      <a href="https://www.luatex.org/">LuaTeX</a>, but, again, the
      entrenching of a 40-odd year system is not to be
      underestimated. I am rooting for <code>typst</code>, anyway,
      and hope it finds its place. A good place to start would be
      to provide a compilation toolchain from <code>typst</code> to
      TeX, if they really want to replace TeX.
    </li>
    <li>There are, in fact, reasons why someone would not want to
    just use your favourite form of Markdown plus pidgin TeX, not
    least of all because not everyone is just taking notes, and
    also because not everyone (dare I say, most people) who are
    using LaTeX are of the computer science/technology subject.
    Also, on a purely personal level, if you were taking your class
    notes in Markdown+TeX, either the syllabus was too easy or you
    were making it way harder for yourself.</li>
    <li>Yes, LaTeX is ugly and antiquated. It <em>is</em> old. It‚Äôs
    an evolving, niche, very precocious thing, and it suffers from
    this. And, yet, it seems to have its place. But, if you just
    look at it like an esoteric programming language, why should
    this be a problem?</li>
    <li>Even though I strived to be correct, it‚Äôs likely I‚Äôve
    incurred in some error. There are a lot of people who are
    <em>really</em> good with LaTeX in HN, and I expect them to
    point out any errors (for which I will be very grateful, and
    will duly correct). But, at the end of the day, LaTeX is far
    from my primary occupation, and I felt like the sort of
    introduction that this text would be able to give to the
    average programmer w.r.t. LaTeX would outweigh any eventual
    minor error, easily corrected by consulting the official
    references.</li>
    <li>Yes, it‚Äôs <code>$YEAR</code> and we‚Äôre still producing
    PDFs. Again, historical reasons plus the fact that most people
    doing maths are not necessarily very interested in
    computers.</li>
    <li>99% of the time that you‚Äôre writing LaTeX, you need to know
    literally nothing of what‚Äôs contained in this blog post.</li>
    <li>(La)TeX does not have a grammar. Parsing TeX is Turing
    complete. This does not mean that you could not write a grammar
    for, roughly speaking, ‚Äúmuch‚Äù of TeX, especially ‚Äúmany‚Äù
    mathematical expressions. I suspect this is what quite a few
    pidgin TeX-related programs do.</li>
  </ol>
  
  <hr/>
  


</div>
  </body>
</html>
