<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jtolio.com/2016/03/go-channels-are-bad-and-you-should-feel-bad/">Original</a>
    <h1>Problems with Go channels (2016)</h1>
    
    <div id="readability-page-1" class="page"><div>
  

<p><em>Update: If you’re coming to this blog post from a compendium titled “Go is
not good,” I want to make it clear that I am ashamed to be on such a list. Go
is absolutely the least worst programming language I’ve ever used. At the
time I wrote this, I wanted to curb a trend I was seeing, namely, overuse of
one of the more warty parts of Go. I still think channels could be much better,
but overall, Go is wonderful. It’s like if your favorite toolbox had
<a href="https://blog.codinghorror.com/content/images/uploads/2012/06/6a0120a85dcdae970b017742d249d5970d-800wi.jpg">this</a>
in it; the tool can have uses (even if it could have had more uses), and it
can still be your favorite toolbox!</em></p>

<p><em>Update 2: I would be remiss if I didn’t point out this excellent survey of real
issues: <a href="https://songlh.github.io/paper/go-study.pdf">Understanding Real-World Concurrency Bugs In Go</a>.
A significant finding of this survey is that… Go channels cause lots of bugs.</em></p>

<p>I’ve been using Google’s <a href="http://golang.org/">Go programming language</a> on and
off since mid-to-late 2010, and I’ve had legitimate product code written in Go
for <a href="http://www.spacemonkey.com/">Space Monkey</a> since January 2012 (before Go
1.0!). My initial experience with Go was back when I was researching Hoare’s
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a>
model of concurrency and the <a href="https://en.wikipedia.org/wiki/%CE%A0-calculus">π-calculus</a>
under <a href="http://matt.might.net">Matt Might</a>’s
<a href="http://www.ucombinator.org/">UCombinator research group</a> as part of my
(<a href="https://www.jtolio.com/writing/2015/11/research-log-cell-states-and-microarrays/">now redirected</a>)
PhD work to better enable multicore development. Go was announced right then
(how serendipitous!) and I immediately started kicking tires.</p>

<p>It quickly became a core part of Space Monkey development. Our production
systems at Space Monkey currently account for over 425k lines of pure
Go (<em>not</em> counting all of our vendored libraries, which would make it just shy
of 1.5 million lines), so not the most Go you’ll ever
see, but for the relatively young language we’re heavy users. We’ve
<a href="https://www.jtolio.com/writing/2014/04/go-space-monkey/">written about our Go usage</a>
before. We’ve open-sourced some fairly heavily used libraries; many people seem
to be fans of our
<a href="https://godoc.org/github.com/spacemonkeygo/openssl">OpenSSL bindings</a>
(which are faster than <a href="https://golang.org/pkg/crypto/tls/">crypto/tls</a>, but
please keep openssl itself up-to-date!), our
<a href="https://godoc.org/github.com/spacemonkeygo/errors">error handling library</a>,
<a href="https://godoc.org/github.com/spacemonkeygo/spacelog">logging library</a>, and
<a href="https://godoc.org/gopkg.in/spacemonkeygo/monitor.v1">metric collection library/zipkin client</a>.
We use Go, we love Go, we think it’s the least bad programming language for our
needs we’ve used so far.</p>

<p>Although I don’t think I can talk myself out of mentioning my widely avoided
<a href="https://github.com/jtolds/gls">goroutine-local-storage library</a> here either
(which even though it’s a hack that you shouldn’t use, it’s a beautiful hack),
hopefully my other experience will suffice as valid credentials that I kind of
know what I’m talking about before I explain my deliberately inflamatory post
title.</p>




<div>
  <figure>
  <img src="https://www.jtolio.com/images/wat/darth-helmet.jpg" alt="Darth Helmet" onmouseover="this.src=&#39;\/images\/wat\/darth-helmet.gif&#39;;" onclick="this.src=&#39;\/images\/wat\/darth-helmet.gif&#39;; this.onmouseout=null;" onmouseout="this.src=&#39;\/images\/wat\/darth-helmet.jpg&#39;;"/>

</figure>

</div>


<h2 id="wait-what:7de476e370ca6a780a51fd680c5a51dd">Wait, what?</h2>

<p>If you ask the proverbial programmer on the street what’s so special
about Go, she’ll most likely tell you that Go is most known for channels and
goroutines. Go’s theoretical underpinnings are heavily based in Hoare’s CSP
model, which is itself incredibly fascinating and interesting and I firmly
believe has much more to yield than we’ve appropriated so far.</p>

<p>CSP (and the π-calculus) both use communication as the core synchronization
primitive, so it makes sense Go would have channels. Rob Pike has been
fascinated with CSP (with good reason) for a
<a href="https://en.wikipedia.org/wiki/Newsqueak">considerable</a>
<a href="https://en.wikipedia.org/wiki/Alef_%28programming_language%29">while</a>
<a href="https://en.wikipedia.org/wiki/Limbo_%28programming_language%29">now</a>.</p>

<p>But from a pragmatic perspective (which Go prides itself on), Go got channels
wrong. Channels as implemented are pretty much a solid anti-pattern in my book
at this point. Why? Dear reader, let me count the ways.</p>




<h3 id="you-probably-won-t-end-up-using-just-channels:7de476e370ca6a780a51fd680c5a51dd">You probably won’t end up using just channels.</h3>

<p>Hoare’s Communicating Sequential Processes is a computational model where
essentially the only synchronization primitive is sending or receiving on a
channel. As soon as you use a mutex, semaphore, or condition variable, bam,
you’re no longer in pure CSP land. Go programmers often tout this model and
philosophy through the chanting of the
<a href="http://lesswrong.com/lw/k5/cached_thoughts/">cached thought</a>
“<a href="https://blog.golang.org/share-memory-by-communicating">share memory by communicating</a>.”</p>

<p>So let’s try and write a small program using just CSP in Go! Let’s make a
high score receiver. All we will do is keep track of the largest high score
value we’ve seen. That’s it.</p>

<p>First, we’ll make a <code>Game</code> struct.</p>

<div><pre><span></span><span>type</span> Game <span>struct</span> {
  bestScore <span>int</span>
  scores    <span>chan</span> <span>int</span>
}
</pre></div>


<p><code>bestScore</code> isn’t going to be protected by a mutex! That’s fine, because we’ll
simply have one goroutine manage its state and receive new scores over a
channel.</p>

<div><pre><span></span><span>func</span> (g *Game) run() {
  <span>for</span> score := <span>range</span> g.scores {
    <span>if</span> g.bestScore &lt; score {
      g.bestScore = score
    }
  }
}
</pre></div>


<p>Okay, now we’ll make a helpful constructor to start a game.</p>

<div><pre><span></span><span>func</span> NewGame() (g *Game) {
  g = &amp;Game{
    bestScore: 0,
    scores:    make(<span>chan</span> <span>int</span>),
  }
  <span>go</span> g.run()
  <span>return</span> g
}
</pre></div>


<p>Next, let’s assume someone has given us a <code>Player</code> that can return scores.
It might also return an error, cause hey maybe the incoming TCP stream can die
or something, or the player quits.</p>

<div><pre><span></span><span>type</span> Player <span>interface</span> {
  NextScore() (score <span>int</span>, err <span>error</span>)
}
</pre></div>


<p>To handle the player, we’ll assume all errors are fatal and pass received
scores down the channel.</p>

<div><pre><span></span><span>func</span> (g *Game) HandlePlayer(p Player) <span>error</span> {
  <span>for</span> {
    score, err := p.NextScore()
    <span>if</span> err != <span>nil</span> {
      <span>return</span> err
    }
    g.scores &lt;- score
  }
}
</pre></div>


<p>Yay! Okay, we have a <code>Game</code> type that can keep track of the highest score a
<code>Player</code> receives in a thread-safe way.</p>

<p>You wrap up your development and you’re on your way to having customers. You
make this game server public and you’re incredibly successful! Lots of games
are being created with your game server.</p>

<p>Soon, you discover people sometimes leave your game. Lots of games no longer
have any players playing, but nothing stopped the game loop. You are getting
overwhelmed by dead <code>(*Game).run</code> goroutines.</p>

<p><strong>Challenge:</strong> fix the goroutine leak above without mutexes or panics.
For real, scroll up to the above code and come up with a plan for fixing this
problem using just channels.</p>



<p>For what it’s worth, it totally can be done with channels only, but observe the
simplicity of the following solution which doesn’t even have this problem:</p>

<div><pre><span></span><span>type</span> Game <span>struct</span> {
  mtx sync.Mutex
  bestScore <span>int</span>
}

<span>func</span> NewGame() *Game {
  <span>return</span> &amp;Game{}
}

<span>func</span> (g *Game) HandlePlayer(p Player) <span>error</span> {
  <span>for</span> {
    score, err := p.NextScore()
    <span>if</span> err != <span>nil</span> {
      <span>return</span> err
    }
    g.mtx.Lock()
    <span>if</span> g.bestScore &lt; score {
      g.bestScore = score
    }
    g.mtx.Unlock()
  }
}
</pre></div>


<p>Which one would you rather work on? Don’t be deceived into thinking that the
channel solution somehow makes this more readable and understandable in more
complex cases. Teardown is very hard. This sort of teardown is just a piece of
cake with a mutex, but the hardest thing to work out with Go-specific channels
only. Also, if anyone replies that channels sending channels is easier to
reason about here it will cause me an immediate head-to-desk motion.</p>

<p>Importantly, this particular case might actually be <em>easily</em> solved <em>with
channels</em> with some runtime assistance Go doesn’t provide! Unfortunately, as
it stands, there are simply a surprising amount of problems that are solved
better with traditional synchronization primitives than with Go’s version of
CSP. We’ll talk about what Go could have done to make this case easier later.</p>

<p><strong>Exercise:</strong> Still skeptical? Try making both solutions above (channel-only
vs. mutex-only) stop asking for scores from <code>Players</code> once <code>bestScore</code> is 100
or greater. Go ahead and open your text editor. This is a small, toy problem.</p>

<p>The summary here is that you will be using traditional synchronization
primitives in addition to channels if you want to do anything real.</p>




<h3 id="channels-are-slower-than-implementing-it-yourself:7de476e370ca6a780a51fd680c5a51dd">Channels are slower than implementing it yourself</h3>

<p>One of the things I assumed about Go being so heavily based in CSP theory is
that there should be some pretty killer scheduler optimizations the runtime
can make with channels. Perhaps channels aren’t always the most straightforward
primitive, but surely they’re efficient and fast, right?</p>

<div>
  <figure>
  <img src="https://www.jtolio.com/images/wat/jon-stewart.jpg" alt="John Stewart" onmouseover="this.src=&#39;\/images\/wat\/jon-stewart.gif&#39;;" onclick="this.src=&#39;\/images\/wat\/jon-stewart.gif&#39;; this.onmouseout=null;" onmouseout="this.src=&#39;\/images\/wat\/jon-stewart.jpg&#39;;"/>

</figure>

</div>


<p>As <a href="https://twitter.com/HiattDustin">Dustin Hiatt</a> points out on
<a href="http://bravenewgeek.com/go-is-unapologetically-flawed-heres-why-we-use-it/">Tyler Treat’s post about Go</a>,</p>

<blockquote>
<p>Behind the scenes, channels are using locks to serialize access and provide
threadsafety. So by using channels to synchronize access to memory, you are,
in fact, using locks; locks wrapped in a threadsafe queue. So how do Go’s
fancy locks compare to just using mutex’s from their standard library <code>sync</code>
package? The following numbers were obtained by using Go’s builtin
benchmarking functionality to serially call Put on a single set of their
respective types.</p>

<pre><code>BenchmarkSimpleSet-8 3000000 391 ns/op
BenchmarkSimpleChannelSet-8 1000000 1699 ns/o
</code></pre>
</blockquote>

<p>It’s a similar story with unbuffered channels, or even the same test under
contention instead of run serially.</p>

<p>Perhaps the Go scheduler will improve, but in the meantime, good old mutexes
and condition variables are very good, efficient, and fast. If you want
performance, you use the tried and true methods.</p>




<h3 id="channels-don-t-compose-well-with-other-concurrency-primitives:7de476e370ca6a780a51fd680c5a51dd">Channels don’t compose well with other concurrency primitives</h3>

<p>Alright, so hopefully I have convinced you that you’ll at least be interacting
with primitives besides channels sometimes. The standard library certainly
seems to prefer traditional synchronization primitives over channels.</p>

<p>Well guess what, it’s actually somewhat challenging to use channels alongside
mutexes and condition variables correctly!</p>

<p>One of the interesting things about channels that makes a lot of sense coming
from CSP is that channel sends are synchronous. A channel send and channel
receive are intended to be synchronization barriers, and the send and receive
should happen at the same virtual time. That’s wonderful if you’re in
well-executed CSP-land.</p>

<div>
  <figure>
  <img src="https://www.jtolio.com/images/wat/obama.jpg" alt="Barack Obama" onmouseover="this.src=&#39;\/images\/wat\/obama.gif&#39;;" onclick="this.src=&#39;\/images\/wat\/obama.gif&#39;; this.onmouseout=null;" onmouseout="this.src=&#39;\/images\/wat\/obama.jpg&#39;;"/>

</figure>

</div>


<p>Pragmatically, Go channels also come in a buffered variety. You can allocate a
fixed amount of space to account for possible buffering so that sends and
receives are disparate events, but the buffer size is capped. Go doesn’t
provide a way to have arbitrarily sized buffers - you have to allocate the
buffer size in advance. <em>This is fine</em>, I’ve seen people argue on the mailing
list, <em>because memory is bounded anyway.</em></p>

<p>Wat.</p>

<p>This is a bad answer. There’s all sorts of reasons to use an arbitrarily
buffered channel. If we knew everything up front, why even have <code>malloc</code>?</p>




<p>Not having arbitrarily buffered channels means that a naive send on <em>any</em>
channel could block at any time. You want to send on a channel and update some
other bookkeeping under a mutex? Careful! Your channel send might block!</p>

<div><pre><span></span>  <span>// ...</span>
  s.mtx.Lock()
  <span>// ...</span>
  s.ch &lt;- val <span>// might block!</span>
  s.mtx.Unlock()
  <span>// ...</span>
</pre></div>


<p>This is a recipe for dining philosopher dinner fights. If you take a lock, you
should quickly update state and release it and not do anything blocking under
the lock if possible.</p>

<p>There is a way to do a non-blocking send on a channel in Go, but it’s not the
default behavior. Assume we have a channel <code>ch := make(chan int)</code> and we want
to send the value <code>1</code> on it without blocking. Here is the minimum amount of
typing you have to do to send without blocking:</p>

<div><pre><span></span>  <span>select</span> {
  <span>case</span> ch &lt;- 1: <span>// it sent</span>
  <span>default</span>: <span>// it didn&#39;t</span>
  }
</pre></div>


<p>This isn’t what naturally leaps to mind for beginning Go programmers.</p>

<p>The summary is that because many operations on channels block, it takes careful
reasoning about philosophers and their dining to successfully use channel
operations alongside and under mutex protection, without causing deadlocks.</p>




<h3 id="callbacks-are-strictly-more-powerful-and-don-t-require-unnecessary-goroutines:7de476e370ca6a780a51fd680c5a51dd">Callbacks are strictly more powerful and don’t require unnecessary goroutines.</h3>

<div>
  <figure>
  <img src="https://www.jtolio.com/images/wat/yael-grobglas.jpg" alt="Yael Grobglas" onmouseover="this.src=&#39;\/images\/wat\/yael-grobglas.gif&#39;;" onclick="this.src=&#39;\/images\/wat\/yael-grobglas.gif&#39;; this.onmouseout=null;" onmouseout="this.src=&#39;\/images\/wat\/yael-grobglas.jpg&#39;;"/>

</figure>

</div>


<p>Whenever an API uses a channel, or whenever I point out that a channel makes
something hard, someone invariably points out that I should just spin up
a goroutine to read off the channel and make whatever translation or fix I need
as it reads of the channel.</p>

<p>Um, no. What if my code is in a hotpath? There’s very few instances that
require a channel, and if your API could have been designed with mutexes,
semaphores, and callbacks and no additional goroutines (because all event edges
are triggered by API events), then using a channel forces me to add another
stack of memory allocation to my resource usage. Goroutines are much lighter
weight than threads, yes, but lighter weight doesn’t mean the lightest weight
possible.</p>

<p>As I’ve formerly <a href="http://www.informit.com/articles/article.aspx?p=2359758#comment-2061767464">argued in the comments on an article about using channels</a> (lol the internet),
your API can <em>always</em> be more general, <em>always</em> more flexible, and take
drastically less resources if you use callbacks instead of channels.
“Always” is a scary word, but I mean it here. There’s proof-level stuff going
on.</p>

<p>If someone provides a callback-based API to you and you need a channel, you can
provide a callback that sends on a channel with little overhead and full
flexibility.</p>

<p>If, on the other hand, someone provides a channel-based API to you and you need
a callback, you have to spin up a goroutine to read off the channel <em>and</em> you
have to hope that no one tries to send more on the channel when you’re done
reading so you cause blocked goroutine leaks.</p>

<p>For a super simple real-world example, check out the
<a href="https://godoc.org/golang.org/x/net/context">context interface</a> (which
incidentally is an incredibly useful package and what you should be using
instead of <a href="https://github.com/jtolds/gls">goroutine-local storage</a>):</p>

<div><pre><span></span><span>type</span> Context <span>interface</span> {
  ...
  <span>// Done returns a channel that closes when this work unit should be canceled.</span>
  Done() &lt;-<span>chan</span> <span>struct</span>{}

  <span>// Err returns a non-nil error when the Done channel is closed</span>
  Err() <span>error</span>
  ...
}
</pre></div>


<p>Imagine all you want to do is log the corresponding error when the <code>Done()</code>
channel fires. What do you have to do? If you don’t have a good place you’re
already selecting on a channel, you have to spin up a goroutine to deal with
it:</p>

<div><pre><span></span>  <span>go</span> <span>func</span>() {
    &lt;-ctx.Done()
    logger.Errorf(<span>&#34;canceled: %v&#34;</span>, ctx.Err())
  }()
</pre></div>


<p>What if <code>ctx</code> gets garbage collected without closing the channel <code>Done()</code>
returned? Whoops! Just leaked a goroutine!</p>

<p>Now imagine we changed <code>Done</code>’s signature:</p>

<div><pre><span></span>  <span>// Done calls cb when this work unit should be canceled.</span>
  Done(cb <span>func</span>())
</pre></div>


<p>First off, logging is so easy now. Check it out:
<code>ctx.Done(func() { log.Errorf(&#34;canceled: %v&#34;, ctx.Err()) })</code>.
But lets say you really do need some select behavior. You can just call it like
this:</p>

<div><pre><span></span>  ch := make(<span>chan</span> <span>struct</span>{})
  ctx.Done(<span>func</span>() { close(ch) })
</pre></div>


<p>Voila! No expressiveness lost by using a callback instead. <code>ch</code> works like
the channel <code>Done()</code> used to return, and in the logging case we didn’t need to
spin up a whole new stack. I got to keep my stack traces (if our log package
is inclined to use them); I got to avoid another stack allocation and another
goroutine to give to the scheduler.</p>

<p>Next time you use a channel, ask yourself if there’s some goroutines you could
eliminate if you used mutexes and condition variables instead. If the answer is
yes, your code will be more efficient if you change it. And if you’re trying to
use channels just to be able to use the <code>range</code> keyword over a collection, I’m
going to have to ask you to put your keyboard away or just go back to writing
Python books.</p>

<div>
  <figure>
  <img src="https://www.jtolio.com/images/wat/zooey-deschanel.jpg" alt="Zooey Deschanel" onmouseover="this.src=&#39;\/images\/wat\/zooey-deschanel.gif&#39;;" onclick="this.src=&#39;\/images\/wat\/zooey-deschanel.gif&#39;; this.onmouseout=null;" onmouseout="this.src=&#39;\/images\/wat\/zooey-deschanel.jpg&#39;;"/>

<figcaption>
      <p>more like Zooey De-channel, amirite</p>
  </figcaption>

</figure>

</div>





<h3 id="the-channel-api-is-inconsistent-and-just-cray-cray:7de476e370ca6a780a51fd680c5a51dd">The channel API is inconsistent and just cray-cray</h3>

<p>Closing or sending on a closed channel panics! Why? If you want to close a
channel, you need to either synchronize its closed state externally (with
mutexes and so forth that don’t compose well!) so that other writers don’t
write to or close a closed channel, or just charge forward and close or write
to closed channels and expect you’ll have to recover any raised panics.</p>

<p>This is such bizarre behavior. Almost every other operation in Go has a way to
avoid a panic (type assertions have the <code>, ok =</code> pattern, for example), but
with channels you just get to deal with it.</p>

<p>Okay, so when a send will fail, channels panic. I guess that makes some kind
of sense. But unlike almost everything else with nil values, sending to a nil
channel won’t panic. Instead, it will block forever! That’s pretty
counter-intuitive. That might be useful behavior, just like having a can-opener
attached to your weed-whacker might be useful (and found in Skymall), but it’s
certainly unexpected. Unlike interacting with nil maps (which do implicit
pointer dereferences), nil interfaces (implicit pointer dereferences),
unchecked type assertions, and all sorts of other things, nil channels exhibit
actual channel behavior, as if a brand new channel was just instantiated for
this operation.</p>

<p>Receives are slightly nicer. What happens when you receive on a closed channel?
Well, that works - you get a zero value. Okay that makes sense I guess. Bonus!
Receives allow you to do a <code>, ok =</code>-style check if the channel was open when
you received your value. Thank heavens we get <code>, ok =</code> here.</p>

<p>But what happens if you receive from a nil channel? <em>Also blocks forever!</em> Yay!
Don’t try and use the fact that your channel is nil to keep track of if you
closed it!</p>




<h2 id="what-are-channels-good-for:7de476e370ca6a780a51fd680c5a51dd">What are channels good for?</h2>

<p>Of course channels are good for some things (they are a generic container
after all), and there are certain things you can only do with them (<code>select</code>).</p>




<h3 id="they-are-another-special-cased-generic-datastructure:7de476e370ca6a780a51fd680c5a51dd">They are another special-cased generic datastructure</h3>

<p>Go programmers are so used to arguments about generics that I can feel the PTSD
coming on just by bringing up the word. I’m not here to talk about it so wipe
the sweat off your brow and let’s keep moving.</p>

<p>Whatever your opinion of generics is, Go’s maps, slices, and channels are data
structures that support generic element types, because they’ve been
special-cased into the language.</p>

<p>In a language that doesn’t allow you to write your own generic containers,
<em>anything</em> that allows you to better manage collections of things is valuable.
Here, channels are a thread-safe datastructure that supports arbitrary value
types.</p>

<p>So that’s useful! That can save some boilerplate I suppose.</p>

<p>I’m having trouble counting this as a win for channels.</p>




<h3 id="select:7de476e370ca6a780a51fd680c5a51dd">Select</h3>

<p>The main thing you can do with channels is the <code>select</code> statement. Here you
can wait on a fixed number of inputs for events. It’s kind of like epoll, but
you have to know upfront how many sockets you’re going to be waiting on.</p>

<p>This is truly a useful language feature. Channels would be a complete wash if
not for <code>select</code>. But holy smokes, let me tell you about the first time you
decide you might need to select on multiple things but you don’t know how many
and you have to use <code>reflect.Select</code>.</p>




<h2 id="how-could-channels-be-better:7de476e370ca6a780a51fd680c5a51dd">How could channels be better?</h2>

<p>It’s really tough to say what the most tactical thing the Go language team
could do for Go 2.0 is (the Go 1.0 compatibility guarantee is good but
hand-tying), but that won’t stop me from making some suggestions.</p>




<h3 id="select-on-condition-variables:7de476e370ca6a780a51fd680c5a51dd">Select on condition variables!</h3>

<p>We could just obviate the need for channels! This is where I propose we get
rid of some sacred cows, but let me ask you this, how great would it be if you
could select on any custom synchronization primitive? (A: So great.) If we had
that, we wouldn’t need channels at all.</p>




<h3 id="gc-could-help-us:7de476e370ca6a780a51fd680c5a51dd">GC could help us?</h3>

<p>In the very first example, we could easily solve the high score server cleanup
with channels if we were able to use directionally-typed channel garbage
collection to help us clean up.</p>

<div>
  <figure>
  <img src="https://www.jtolio.com/images/wat/joel-mchale.jpg" alt="Joel McHale" onmouseover="this.src=&#39;\/images\/wat\/joel-mchale.gif&#39;;" onclick="this.src=&#39;\/images\/wat\/joel-mchale.gif&#39;; this.onmouseout=null;" onmouseout="this.src=&#39;\/images\/wat\/joel-mchale.jpg&#39;;"/>

</figure>

</div>


<p>As you know, Go has directionally-typed channels. You can have a channel type
that only supports reading (<code>&lt;-chan</code>) and a channel type that only supports
writing (<code>chan&lt;-</code>). Great!</p>

<p>Go also has garbage collection. It’s clear that certain kinds of book keeping
are just too onerous and we shouldn’t make the programmer deal with
them. We clean up unused memory! Garbage collection is useful and neat.</p>

<p>So why not help clean up unused or deadlocked channel reads? Instead of having
<code>make(chan Whatever)</code> return one bidirectional channel, have it return two
single-direction channels (<code>chanReader, chanWriter := make(chan Type)</code>).</p>




<p>Let’s reconsider the original example:</p>

<div><pre><span></span><span>type</span> Game <span>struct</span> {
  bestScore <span>int</span>
  scores    <span>chan</span>&lt;- <span>int</span>
}

<span>func</span> run(bestScore *<span>int</span>, scores &lt;-<span>chan</span> <span>int</span>) {
  <span>// we don&#39;t keep a reference to a *Game directly because then we&#39;d be holding</span>
  <span>// onto the send side of the channel.</span>
  <span>for</span> score := <span>range</span> scores {
    <span>if</span> *bestScore &lt; score {
      *bestScore = score
    }
  }
}

<span>func</span> NewGame() (g *Game) {
  <span>// this make(chan) return style is a proposal!</span>
  scoreReader, scoreWriter := make(<span>chan</span> <span>int</span>)
  g = &amp;Game{
    bestScore: 0,
    scores:    scoreWriter,
  }
  <span>go</span> run(&amp;g.bestScore, scoreReader)
  <span>return</span> g
}

<span>func</span> (g *Game) HandlePlayer(p Player) <span>error</span> {
  <span>for</span> {
    score, err := p.NextScore()
    <span>if</span> err != <span>nil</span> {
      <span>return</span> err
    }
    g.scores &lt;- score
  }
}
</pre></div>


<p>If garbage collection closed a channel when we could prove no more values are
ever coming down it, this solution is completely fixed. Yes yes, the comment
in <code>run</code> is indicative of the existence of a rather large gun aimed at your
foot, but at least the problem is easily solveable now, whereas it really
wasn’t before. Furthermore, a smart compiler could probably make appropriate
proofs to reduce the damage from said foot-gun.</p>




<h3 id="other-smaller-issues:7de476e370ca6a780a51fd680c5a51dd">Other smaller issues</h3>

<ul>
<li><strong>Dup channels?</strong> - If we could use an equivalent of the <code>dup</code> syscall on
channels, then we could also solve the multiple producer problem quite
easily. Each producer could close their own <code>dup</code>-ed channel without ruining
the other producers.</li>
<li><strong>Fix the channel API!</strong> - Close isn’t idempotent? Send on closed
channel panics with no way to avoid it? Ugh!</li>
<li><strong>Arbitrarily buffered channels</strong> - If we could make buffered channels with
no fixed buffer size limit, then we could make channels that don’t block.</li>
</ul>




<h2 id="what-do-we-tell-people-about-go-then:7de476e370ca6a780a51fd680c5a51dd">What do we tell people about Go then?</h2>

<p>If you haven’t yet, please go take a look at my current favorite programming
post: <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">What Color is Your Function</a>. Without being about Go specifically, this blog post much more
eloquently than I could lays out exactly why goroutines are Go’s best feature
(and incidentally one of the ways Go is better than Rust for some
applications).</p>

<p>If you’re still writing code in a programming language that forces keywords
like <code>yield</code> on you to get high performance, concurrency, or an event-driven
model, you are living in the past, whether or not you or anyone else knows it.
Go is so far one of the best entrants I’ve seen of languages that implement an
M:N threading model that’s not 1:1, and dang that’s powerful.</p>

<p>So, tell folks about goroutines.</p>

<p>If I had to pick one other leading feature of Go, it’s interfaces.
Statically-typed <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> makes
extending and working with your own or someone else’s project so fun and
amazing it’s probably worth me writing an entirely different set of words about
it some other time.</p>




<h2 id="so:7de476e370ca6a780a51fd680c5a51dd">So…</h2>

<p>I keep seeing people charge in to Go, eager to use channels to their full
potential. Here’s my advice to you.</p>

<p><strong>JUST STAHP IT</strong></p>

<p>When you’re writing APIs and interfaces, as bad as the advice “never” can be,
I’m pretty sure there’s never a time where channels are better, and every Go
API I’ve used that used channels I’ve ended up having to fight. I’ve never
thought “oh good, there’s a channel here;” it’s always instead been some
variant of <em><strong>WHAT FRESH HELL IS THIS?</strong></em></p>

<p>So, <em>please, please use channels where appropriate and only
where appropriate.</em></p>

<p>In all of my Go code I work with, I can count on one hand the number of times
channels were really the best choice. Sometimes they are. That’s great! Use
them then. But otherwise just stop.</p>

<div>
 <figure>
  <img src="https://www.jtolio.com/images/wat/michael-cera.jpg" alt="Michael Cera" onmouseover="this.src=&#39;\/images\/wat\/michael-cera.gif&#39;;" onclick="this.src=&#39;\/images\/wat\/michael-cera.gif&#39;; this.onmouseout=null;" onmouseout="this.src=&#39;\/images\/wat\/michael-cera.jpg&#39;;"/>

</figure>

</div>


<p><em>Special thanks for the valuable feedback provided by my proof readers
Jeff Wendling, <a href="https://github.com/azdagron">Andrew Harding</a>,
<a href="https://twitter.com/taterbase">George Shank</a>, and
<a href="http://bravenewgeek.com">Tyler Treat</a>.</em></p>

<p>If you want to work on Go with us at Space Monkey, please
<a href="https://www.jtolio.com/contact/">hit me up</a>!</p>

</div></div>
  </body>
</html>
