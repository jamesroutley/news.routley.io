<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frankchiarulli.com/blog/shiftapi/">Original</a>
    <h1>ShiftAPI: Full-Stack Type Safety from Go</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve been craving full-stack type safety from Go for years.</p>
<p>The TypeScript ecosystem figured this out a while ago. tRPC gives you end-to-end types from backend to frontend. You change a return type on the server and your frontend lights up with compiler errors. It’s great. Go has nothing like it.</p>
<p>I kept running into the same problem: I’d write a Go struct, then rewrite it as a TypeScript interface, sometimes with an OpenAPI spec in between. They’d drift apart, and it was a pain every time I wanted to add a feature. I’d swear I’d fix it this time. I never did.</p>
<p>So I built <a target="_blank" href="https://github.com/fcjr/shiftapi">ShiftAPI</a>.</p>
<h2 id="what-it-does"><a target="_self" href="#what-it-does">What It Does</a></h2>
<p>ShiftAPI is a thin layer on top of <code>net/http</code>. You define your Go types, write a handler, and ShiftAPI reflects those types into an OpenAPI 3.1 schema at runtime. The types themselves are captured at compile time via generics. Validation happens automatically via <a target="_blank" href="https://github.com/go-playground/validator">go-playground/validator</a> struct tags. Interactive docs get served at <code>/docs</code>. You don’t write any of this by hand.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="go" data-theme="Overnight"><code data-language="go" data-theme="Overnight"><span data-line=""><span>type</span><span> CreateUserRequest </span><span>struct</span><span> {</span></span>
<span data-line=""><span>    Name  </span><span>string</span><span> `</span><span>json:&#34;name&#34; validate:&#34;required&#34;</span><span>`</span></span>
<span data-line=""><span>    Email </span><span>string</span><span> `</span><span>json:&#34;email&#34; validate:&#34;required,email&#34;</span><span>`</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>type</span><span> CreateUserResponse </span><span>struct</span><span> {</span></span>
<span data-line=""><span>    ID    </span><span>string</span><span> `</span><span>json:&#34;id&#34;</span><span>`</span></span>
<span data-line=""><span>    Name  </span><span>string</span><span> `</span><span>json:&#34;name&#34;</span><span>`</span></span>
<span data-line=""><span>    Email </span><span>string</span><span> `</span><span>json:&#34;email&#34;</span><span>`</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>func</span><span> CreateUser</span><span>(r </span><span>*</span><span>http.Request, body </span><span>*</span><span>CreateUserRequest) (</span><span>*</span><span>CreateUserResponse, </span><span>error</span><span>) {</span></span>
<span data-line=""><span>    // your logic here</span></span>
<span data-line=""><span>    return</span><span> &amp;</span><span>CreateUserResponse{</span></span>
<span data-line=""><span>        ID:    </span><span>&#34;</span><span>123</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>        Name:  body.Name,</span></span>
<span data-line=""><span>        Email: body.Email,</span></span>
<span data-line=""><span>    }, </span><span>nil</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="go" data-theme="Overnight"><code data-language="go" data-theme="Overnight"><span data-line=""><span>api </span><span>:=</span><span> shiftapi.</span><span>New</span><span>()</span></span>
<span data-line=""><span>shiftapi.</span><span>Post</span><span>(api, </span><span>&#34;</span><span>/users</span><span>&#34;</span><span>, CreateUser)</span></span>
<span data-line=""><span>shiftapi.</span><span>ListenAndServe</span><span>(</span><span>&#34;</span><span>:8080</span><span>&#34;</span><span>, api)</span></span>
<span data-line=""><span>// interactive docs at http://localhost:8080/docs</span></span></code></pre></figure>
<p>That’s the whole thing. Invalid requests get a <code>422 Unprocessable Entity</code> with per-field errors before your handler is ever called:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="json" data-theme="Overnight"><code data-language="json" data-theme="Overnight"><span data-line=""><span>{</span></span>
<span data-line=""><span>    &#34;message&#34;</span><span>: </span><span>&#34;</span><span>validation failed</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>    &#34;errors&#34;</span><span>: </span><span>[</span></span>
<span data-line=""><span>        { </span><span>&#34;field&#34;</span><span>: </span><span>&#34;</span><span>Name</span><span>&#34;</span><span>,  </span><span>&#34;message&#34;</span><span>: </span><span>&#34;</span><span>this field is required</span><span>&#34;</span><span> },</span></span>
<span data-line=""><span>        { </span><span>&#34;field&#34;</span><span>: </span><span>&#34;</span><span>Email</span><span>&#34;</span><span>, </span><span>&#34;message&#34;</span><span>: </span><span>&#34;</span><span>must be a valid email address</span><span>&#34;</span><span> }</span></span>
<span data-line=""><span>    ]</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>But the schema generation isn’t the point. The point is what it enables on the frontend.</p>
<h2 id="the-typescript-side"><a target="_self" href="#the-typescript-side">The TypeScript Side</a></h2>
<p>This is the part I actually cared about.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="bash" data-theme="Overnight"><code data-language="bash" data-theme="Overnight"><span data-line=""><span>npm</span><span> install</span><span> @shiftapi/vite-plugin</span></span></code></pre></figure>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="Overnight"><code data-language="ts" data-theme="Overnight"><span data-line=""><span>// vite.config.ts</span></span>
<span data-line=""><span>import</span><span> shiftapi </span><span>from</span><span> &#34;</span><span>@shiftapi/vite-plugin</span><span>&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> { defineConfig } </span><span>from</span><span> &#34;</span><span>vite</span><span>&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>export</span><span> default</span><span> defineConfig</span><span>({</span></span>
<span data-line=""><span>    plugins</span><span>:</span><span> [</span></span>
<span data-line=""><span>        shiftapi</span><span>({</span></span>
<span data-line=""><span>            server</span><span>:</span><span> &#34;</span><span>./cmd/server</span><span>&#34;</span><span>,</span><span> // your Go entry point</span></span>
<span data-line=""><span>        }),</span></span>
<span data-line=""><span>    ],</span></span>
<span data-line=""><span>});</span></span></code></pre></figure>
<p>The Vite plugin extracts the OpenAPI spec from your Go binary and generates TypeScript types via <a target="_blank" href="https://github.com/openapi-ts/openapi-typescript">openapi-typescript</a>. In dev mode it also starts your Go server, proxies API requests through Vite, watches your <code>.go</code> files, and hot-reloads the frontend when types change. Edit a struct field in Go, and your TypeScript client updates automatically.</p>
<p>Then you use the generated typed client:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="Overnight"><code data-language="ts" data-theme="Overnight"><span data-line=""><span>import</span><span> { client } </span><span>from</span><span> &#34;</span><span>@shiftapi/client</span><span>&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>const { </span><span>data</span><span> } </span><span>=</span><span> await </span><span>client</span><span>.</span><span>POST</span><span>(</span><span>&#34;</span><span>/users</span><span>&#34;</span><span>,</span><span> {</span></span>
<span data-line=""><span>    body</span><span>:</span><span> {</span><span> name</span><span>:</span><span> &#34;</span><span>frank</span><span>&#34;</span><span>,</span><span> email</span><span>:</span><span> &#34;</span><span><a href="https://frankchiarulli.com/cdn-cgi/l/email-protection" data-cfemail="721400131c1932170a131f021e175c111d1f">[email protected]</a></span><span>&#34;</span><span> },</span></span>
<span data-line=""><span>});</span></span>
<span data-line=""><span>// body and response are fully typed from your Go structs</span></span></code></pre></figure>
<p>A type error in your frontend means your API contract is broken. You find out at build time, not in production. One source of truth. The Go struct.</p>
<h2 id="why-nethttp"><a target="_self" href="#why-nethttp">Why <code>net/http</code></a></h2>
<p>I didn’t want to build a framework. I wanted to build a layer.</p>
<p>The <code>API</code> type implements <code>http.Handler</code>. You can use it with the standard library server and any middleware that accepts <code>http.Handler</code>. Test with <code>httptest</code>. Mount it under a prefix with <code>http.StripPrefix</code>. There’s no custom router and no framework you’re locked into. If you decide ShiftAPI isn’t for you, your handlers are still just functions that take a request and return a response.</p>
<p>Errors work the way you’d expect in Go: return an error from your handler and it becomes a JSON error response. Return <code>shiftapi.Error</code> when you need to control the status code:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="go" data-theme="Overnight"><code data-language="go" data-theme="Overnight"><span data-line=""><span>return</span><span> nil</span><span>, shiftapi.</span><span>Error</span><span>(http.StatusNotFound, </span><span>&#34;</span><span>user not found</span><span>&#34;</span><span>)</span></span></code></pre></figure>
<p>Any other error returns <code>500</code>. You write functions that return values or errors. That’s it.</p>
<h2 id="try-it"><a target="_self" href="#try-it">Try It</a></h2>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="bash" data-theme="Overnight"><code data-language="bash" data-theme="Overnight"><span data-line=""><span>npm</span><span> create</span><span> shiftapi@latest</span></span></code></pre></figure>
<p>This scaffolds a full-stack project with a Go backend and a React or Svelte frontend wired together. Or just grab the library:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="bash" data-theme="Overnight"><code data-language="bash" data-theme="Overnight"><span data-line=""><span>go</span><span> get</span><span> github.com/fcjr/shiftapi</span></span></code></pre></figure>
<p>ShiftAPI is still early and there are rough edges. But the core idea works today: define a Go struct once, and get validation, docs, error handling, and a typed TypeScript client without writing any of it yourself.</p>
<p>Source code is on <a target="_blank" href="https://github.com/fcjr/shiftapi">GitHub</a>.</p><hr/><p><a target="_blank" href="https://github.com/fcjr/frankchiarulli.com/edit/main/public/shiftapi/index.md">Edit on GitHub</a></p></div></div>
  </body>
</html>
