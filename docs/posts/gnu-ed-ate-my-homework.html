<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://edoverflow.com/2022/gnu-ed-ate-my-homework/">Original</a>
    <h1>GNU ed ate my homework</h1>
    
    <div id="readability-page-1" class="page"><section><p>If you have ever ventured into the archives of old UNIX books and mailing lists, you will have undoubtedly come across the legend of <code>ed</code>. <code>ed</code> (pronounced /iː diː/) is a text editor just like <code>vim</code> and <code>emacs</code>. However, contrary to its counterparts, <code>ed</code> comes with what an interface that could be best summarised as…</p><pre tabindex="0"><code>$ ed
q
?
q
?
q
?
qqqqqqqqqqqqqqqqqq
?
q
?
q

?
q
$
</code></pre><p>In spite of all of this, legend has it: “<a href="https://www.gnu.org/fun/jokes/ed-msg.en.html">ed is the standard text editor</a>”. So much so that most Linux distributions set <code>/bin/ed</code> to a <code>Priority</code> of <code>-100</code>.</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>$ sudo update-alternatives --config editor
</span></span><span><span>There are 5 choices for the alternative editor (providing ∕usr∕bin∕editor).
</span></span><span><span>
</span></span><span><span>  Selection    Path               Priority   Status
</span></span><span><span>------------------------------------------------------------
</span></span><span><span>* 0            ∕usr∕bin∕vim.gtk3   50        auto mode
</span></span><span><span>  1            ∕bin∕ed            -100       manual mode
</span></span><span><span>  2            ∕bin∕nano           40        manual mode
</span></span><span><span>  3            ∕usr∕bin∕code       0         manual mode
</span></span><span><span>  4            ∕usr∕bin∕vim.gtk3   50        manual mode
</span></span><span><span>  5            ∕usr∕bin∕vim.tiny   15        manual mode
</span></span></code></pre></div><p>Jokes aside, despite being a frequent <a href="https://micro-editor.github.io/"><code>micro</code></a> and <a href="https://code.visualstudio.com/">Visual Studio Code</a> user, I find myself toying around with <code>ed</code> and its source code at times. Most notably the <a href="https://www.gnu.org/software/ed/">GNU implementation of <code>ed</code></a>.</p><p>This is the story of a <del>bug</del> feature in GNU <code>ed</code> I stumbled across last year while reviewing the source code which could result in one losing their work.</p><h2 id="a-brief-history-in-time">A brief history in time</h2><p>To understand the significance of this design flaw, we must briefly venture back to the origin of the GNU <code>ed</code> editor. In 1976, Brian Kernighan and P.J. Plauger published a book titled <a href="https://www.goodreads.com/book/show/515602.Software_Tools_in_Pascal">&#34;<em>Software Tools in Pascal</em>&#34;</a> which explored writing good code using the <a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal programming language</a>. This book contains brilliant passages such as:</p><blockquote><p>“In real life, by the way, you would certainly name the routine <code>sort</code>, not <code>bubble</code>, so you could change the algorithm without upsetting users.”</p><p>— Brian Kernighan &amp; P.J. Plauger, <a href="https://www.goodreads.com/book/show/515602.Software_Tools_in_Pascal">Software Tools in Pascal</a> in reference to “<a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a>”</p></blockquote><p>Why is this book of any significance? As stated in <a href="https://www.gnu.org/software/ed/manual/ed_manual.html">GNU’s <code>info</code> page</a> on <code>ed</code>, the GNU implementation of <code>ed</code> drew inspiration from Chapter 6, “<em>Editing</em>”. The first GNU implementation was designed according to Kernighan and Plauger’s specification.</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>ed-0.1 ❯ cat THANKS
</span></span><span><span>[...]
</span></span><span><span>
</span></span><span><span>GNU ed originated with the editor algorithm from Brian W. Kernighan &amp; P.
</span></span><span><span>J. Plauger&#39;s wonderful book &#34;Software Tools in Pascal,&#34; Addison-Wesley,
</span></span><span><span>1981. [...]
</span></span></code></pre></div><p>While reading the book, this passage in particular stood out to me (emphasis mine):</p><blockquote><p>“Error recovery is a second major influence on the design of the editor. […] <code>edit</code> maintains precious files, so it must be cautious. […] <strong>It must recover gracefully, for otherwise some trifling mistake could cause the loss of valuable information.</strong>”</p><p>— Brian Kernighan &amp; P.J. Plauger, <a href="https://www.goodreads.com/book/show/515602.Software_Tools_in_Pascal">Software Tools in Pascal</a></p></blockquote><p>Keep this quote in mind. We will come back to this passage in just a bit.</p><h2 id="straight-to-the-source">Straight to the source</h2><p>To examine how GNU <code>ed</code> works under the hood, grab a copy of the <a href="https://mirrors.sarata.com/gnu/ed/">latest GNU release</a> (version <code>1.18</code> as of writing this blog post). The source code is easy to navigate with only 8 C files.</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>❯ find . -name &#34;*.c&#34;
</span></span><span><span>./buffer.c
</span></span><span><span>./io.c
</span></span><span><span>./carg_parser.c
</span></span><span><span>./main_loop.c
</span></span><span><span>./main.c
</span></span><span><span>./signal.c
</span></span><span><span>./global.c
</span></span><span><span>./regex.c
</span></span></code></pre></div><p>GNU <code>ed</code> has a <a href="https://en.wikipedia.org/wiki/SIGHUP">SIGHUP</a> handler in <code>signal.c</code> which generates a backup file whenever the <code>ed</code> process encounters a SIGHUP signal. This ensures one does not lose their work if the <code>ed</code> process crashes. This is similar to <code>vim</code> swap files. <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p><p>I have taken the liberty of including my own comments in the <code>sighup_handler()</code> function below to help guide the reader.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>void</span> <span>sighup_handler</span>(<span>int</span> signum)
</span></span><span><span>{
</span></span><span><span>  <span>// [...]
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>// Listen for SIGHUP signal
</span></span></span><span><span><span></span>  <span>if</span> (mutex)
</span></span><span><span>  {
</span></span><span><span>    sighup_pending <span>=</span> true;
</span></span><span><span>    <span>return</span>;
</span></span><span><span>  }
</span></span><span><span>  sighup_pending <span>=</span> false;
</span></span><span><span>
</span></span><span><span>  <span>// Hardcode backup filename
</span></span></span><span><span><span></span>  <span>const</span> <span>char</span> hb[] <span>=</span> <span>&#34;ed.hup&#34;</span>;
</span></span><span><span>
</span></span><span><span>  <span>// If there are unsaved changes, write current buffer to ed.hup
</span></span></span><span><span><span></span>  <span>// in current working directory
</span></span></span><span><span><span></span>  <span>if</span> (last_addr() <span>&lt;=</span> <span>0</span> <span>||</span> <span>!</span>modified() <span>||</span>
</span></span><span><span>      write_file(hb, <span>&#34;w&#34;</span>, <span>1</span>, last_addr()) <span>&gt;=</span> <span>0</span>)
</span></span><span><span>    exit(<span>0</span>); <span>// Exit here if write was successful
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>// Otherwise continue executing code and attempt to write to home directory
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>// Get home directory location from $HOME environment variable
</span></span></span><span><span><span></span>  <span>char</span> <span>*</span><span>const</span> s <span>=</span> getenv(<span>&#34;HOME&#34;</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Check if $HOME environment variable is set
</span></span></span><span><span><span></span>  <span>if</span> (<span>!</span>s <span>||</span> <span>!</span>s[<span>0</span>])
</span></span><span><span>    exit(<span>1</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Get length of $HOME path
</span></span></span><span><span><span></span>  <span>const</span> <span>int</span> len <span>=</span> strlen(s);
</span></span><span><span>
</span></span><span><span>  <span>// Does $HOME end with a forward slash? 1 if it does, 0 else
</span></span></span><span><span><span></span>  <span>const</span> <span>int</span> need_slash <span>=</span> s[len <span>-</span> <span>1</span>] <span>!=</span> <span>&#39;/&#39;</span>;
</span></span><span><span>
</span></span><span><span>  <span>// Construct full path for backup file
</span></span></span><span><span><span></span>  <span>char</span> <span>*</span><span>const</span> hup <span>=</span> (len <span>+</span> need_slash <span>+</span> (<span>int</span>)<span>sizeof</span> hb <span>&lt;</span> path_max(<span>0</span>)) <span>?</span> (<span>char</span> <span>*</span>)malloc(len <span>+</span> need_slash <span>+</span> <span>sizeof</span> hb) <span>:</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>  <span>// Throw error if path construction fails
</span></span></span><span><span><span></span>  <span>if</span> (<span>!</span>hup)
</span></span><span><span>    exit(<span>1</span>);
</span></span><span><span>
</span></span><span><span>  memcpy(hup, s, len);
</span></span><span><span>
</span></span><span><span>  <span>// Append forward slash to $HOME if missing final forward slash
</span></span></span><span><span><span></span>  <span>if</span> (need_slash)
</span></span><span><span>    hup[len] <span>=</span> <span>&#39;/&#39;</span>;
</span></span><span><span>
</span></span><span><span>  <span>// Copy backup file contents to
</span></span></span><span><span><span></span>  memcpy(hup <span>+</span> len <span>+</span> need_slash, hb, <span>sizeof</span> hb);
</span></span><span><span>
</span></span><span><span>  <span>// Write contents to
</span></span></span><span><span><span></span>  <span>if</span> (write_file(hup, <span>&#34;w&#34;</span>, <span>1</span>, last_addr()) <span>&gt;=</span> <span>0</span>)
</span></span><span><span>    exit(<span>0</span>);
</span></span><span><span>  exit(<span>1</span>); <span>/* hup file write failed */</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Unfortunately, as indicated by my code comment, the backup file will always be named <code>ed.hup</code> which leaves much to be desired.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>const</span> <span>char</span> hb[] <span>=</span> <span>&#34;ed.hup&#34;</span>;
</span></span></code></pre></div><p>There are so many reasons why this may cause issues. If GNU <code>ed</code> cannot write to either the home directory or the current directory’s <code>ed.hup</code> file, the user will lose all their work when <code>ed</code> crashes. To explore why this is a bad idea, I will use a scenario.</p><h2 id="sudo-make-me-a-sandwich">Sudo make me a sandwich</h2><p>Since this is not a tutorial on how to use <code>ed</code>, briefly: the way <code>ed</code> works is you can append lines to a buffer using the <code>a</code> command and then write to a file using the <code>w</code> command. There is more to it but this should be enough for the reader to understand everything outlined below.</p><p><code>ed</code> is launched in the home directory using <code>sudo</code> and some text is written to a buffer.</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>❯ ls
</span></span><span><span>❯ sudo ed
</span></span><span><span>a
</span></span><span><span>Writing some text to a buffer using sudo
</span></span><span><span>After the single &#39;.&#39;, this process will experience
</span></span><span><span>a SIGHUP signal from a different terminal window
</span></span><span><span>.
</span></span><span><span>141
</span></span></code></pre></div><p>This process experiences a SIGHUP signal called using <code>sudo kill -SIGHUP &lt;pid&gt;</code> in another terminal window. <code>ed</code> writes the contents of the buffer to a <code>ed.hup</code> file in the current working directory (i.e. <code>$HOME</code>).</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>❯ ls -l
</span></span><span><span>total 4
</span></span><span><span>-rw-r--r-- 1 root        wheel    141 Feb  7 13:07 ed.hup
</span></span><span><span>❯ cat ed.hup
</span></span><span><span>Writing some text to a buffer using sudo
</span></span><span><span>After the single &#39;.&#39;, this process will experience
</span></span><span><span>a SIGHUP signal from a different terminal window
</span></span></code></pre></div><p>Now we navigate to a subdirectory (e.g. <code>demo</code>) and repeat the same process using <code>sudo</code> and cause <code>ed</code> to encounter a SIGHUP signal. Since <code>ed</code> favours the current working directory over the <code>$HOME</code> directory, the <code>ed.hup</code> will be written to the current working directory.</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>demo ❯ ls
</span></span><span><span>total 4
</span></span><span><span>-rw-r--r-- 1 root        wheel    141 Feb  7 13:07 ed.hup
</span></span><span><span>demo ❯ cat ed.hup
</span></span><span><span>Writing some text to a buffer using sudo
</span></span><span><span>After the single &#39;.&#39;, this process will experience
</span></span><span><span>a SIGHUP signal from a different terminal window
</span></span></code></pre></div><p>Our current directory structure can be illustrated as follows by running <code>tree</code> in the home directory.</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>❯ tree
</span></span><span><span>.
</span></span><span><span>├── ed.hup
</span></span><span><span>└── demo
</span></span><span><span>    └── ed.hup
</span></span></code></pre></div><p>With this setup, we can finally demonstrate how <code>ed</code> could end up eating your homework. In the subdirectory, launch <code>ed</code> <strong>without</strong> <code>sudo</code> and cause the process to crash.</p><div><pre tabindex="0"><code data-lang="plaintext"><span><span>demo ❯ ed
</span></span><span><span>a
</span></span><span><span>This is my homework for the assignment on Tuesday!
</span></span><span><span>I hope this doesn&#39;t get lost. :(
</span></span><span><span>.
</span></span><span><span>ed.hup: Permission denied
</span></span><span><span>/Users/&lt;user&gt;/ed.hup: Permission denied
</span></span><span><span>84
</span></span><span><span>demo ❯ ls -l
</span></span><span><span>total 4
</span></span><span><span>-rw-r--r-- 1 root wheel 141 Feb  7 13:07 ed.hup
</span></span><span><span>demo ❯ cat ed.hup
</span></span><span><span>Writing some text to a buffer using sudo
</span></span><span><span>After the single &#39;.&#39;, this process will experience
</span></span><span><span>a SIGHUP signal from a different terminal window
</span></span><span><span>demo ❯ cd $HOME
</span></span><span><span>❯ cat ed.hup
</span></span><span><span>Writing some text to a buffer using sudo
</span></span><span><span>After the single &#39;.&#39;, this process will experience
</span></span><span><span>a SIGHUP signal from a different terminal window
</span></span></code></pre></div><p>We just lost all our homework. <code>ed</code> failed to write to the <code>ed.hup</code> files in both the current working directory and the home directory because the process lacked the required privileges.</p><p>The passage from Kernighan and Plauger’s seems very fitting here.</p><blockquote><p>“Error recovery is a second major influence on the design of the editor. […] <code>edit</code> maintains precious files, so it must be cautious. […] <strong>It must recover gracefully, for otherwise some trifling mistake could cause the loss of valuable information.</strong>”</p><p>— Brian Kernighan &amp; P.J. Plauger, <a href="https://www.goodreads.com/book/show/515602.Software_Tools_in_Pascal">Software Tools in Pascal</a></p></blockquote><p>This is a lesson on why not to use static backup filenames.</p><p><img src="https://user-images.githubusercontent.com/18099289/159934659-fd991f62-c2fb-40f3-9a5d-15252c7cd875.png" alt=""/></p><hr/><h2 id="update-apr-2022">Update (Apr, 2022)</h2><ul><li><a href="https://twitter.com/qrs">@qrs</a> notified me on Twitter that a SIGHUP
is sent when the connection drops; not during an <code>ed</code> crash. I have
updated the blog post accordingly.</li><li>Hacker News user
<a href="https://news.ycombinator.com/user?id=projektfu">projektfu</a> <a href="https://news.ycombinator.com/item?id=30894308">noted</a>
users should consider using “<code>sudo -e</code> instead of <code>sudo $EDITOR</code> when editing
something important with root permissions”.</li></ul></section></div>
  </body>
</html>
