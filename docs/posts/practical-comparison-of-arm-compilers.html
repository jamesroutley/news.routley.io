<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://m0agx.eu/practical-comparison-of-ARM-compilers.html">Original</a>
    <h1>Practical Comparison of ARM Compilers</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        
        
        <p>My inspiration for this article was this <a href="https://old.reddit.com/r/embedded/comments/13ozrn9/what_is_the_value_of_using_a_proprietary_compiler/">thread in r/embedded</a>. There are still many myths and misconception when it comes to the
simple questions &#34;Which compiler should I use?&#34; or &#34;Which compiler is the best?&#34;. I will try to share my practical experience with GCC, Clang and IAR on Cortex-M (<strong>and Cortex-M only</strong>). This article does not cover IDEs or debuggers. All three toolchains generate standard ELF files that can be used by <code>gdb</code> (with its countless GUIs) and <a href="https://www.segger.com/products/development-tools/ozone-j-link-debugger/">Ozone</a>, and all three toolchains can work with any IDE/editor.</p>
<p><strong>TL;DR</strong> GCC, Clang and IAR are all good for Cortex-M.</p>
<p>I can honestly say that (in the 2020s) GCC, clang and IAR are all rock-solid on Cortex-M.
Throughout my career I have been mainly dealing with &#34;control-style code&#34; with lots of branches, events, communication
and interfacing. I found the code generated by different compilers performing almost identically.
This may not hold for signal processing code. If your project relies on &#34;heavy&#34; algorithms
you should be benchmarking it across compilers, different optimization levels,
different compiler flags, versions of the same compiler to see which one works best.</p>
<p>The issues I ran into where the toolchain was a contributing factor could be roughly categorized into:</p>
<ol>
<li>&#34;Obviously&#34; bad code that changed behaviour depending on the particular compiler version</li>
<li>&#34;Obviously&#34; bad code that changed behaviour depending on optimization level</li>
<li>&#34;Obviously&#34; bad code that changed behaviour depending on compiler flags</li>
<li>&#34;Obviously&#34; bad code that depended on undefined behaviour</li>
<li>&#34;Non-obviously&#34; bad code that depended on implementation-defined behaviour of the compiler</li>
</ol>

<p>The &#34;traditional&#34; or &#34;theoretical academic&#34; embedded toolchain consists of a compiler + assembler + linker.
In practice there are more pieces to the puzzle:</p>
<ul>
<li>Editor or IDE (example: IAR Embedded Workbench)</li>
<li>Build system (example: GNU Make or <code>iarbuild</code>)</li>
<li>Debugger (example: <code>gdb</code>, Eclipse plugins for <code>gdb</code>, <a href="https://www.segger.com/products/development-tools/ozone-j-link-debugger/">SEGGER Ozone</a> etc.)</li>
<li>C standard library (example: newlib)</li>
<li>Linker scripts</li>
<li>MCU startup code</li>
<li>C runtime initialization code</li>
<li>Libraries (example: CMSIS)</li>
<li>&#34;Small tools&#34; like <code>size</code>, <code>objcopy</code>, <code>objdump</code>, <code>srecord</code>, <code>ar</code></li>
<li>&#34;Large tools&#34; like static analyzers (eg. C-STAT, clang-tidy), linters, coverage analyzers, profilers</li>
<li>&#34;Middleware&#34;, &#34;big&#34; libraries, network stacks, file systems etc.</li>
<li>RTOS</li>
<li>All the things needed for C++...</li>
</ul>
<p>It may be hard to distinguish where the toolchain ends, where the libraries start etc. You often get a whole package from the chip vendor like Simplicity Studio from Silabs that has the entire GCC toolchain, Eclipse-based IDE and also all kinds of headers, libraries and network stacks for their chips.</p>
<p>If you pick the stock <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">Arm GNU toolchain</a> toolchain (formerly called GNU Arm Embedded) you will only get the GCC compiler, GNU binutils (eg. <code>ld</code> linker), <code>gdb</code>, C runtime init code (<code>crt0</code>), <code>newlib</code> C standard library. You will have to get the device headers, startup code and linker script from the silicon vendor yourself. This is different than for example the <code>avr-gcc</code> toolchain that has pretty much everything built-in (headers and linker scripts) so you can start development with only a <code>main.c</code> (this can be due to AVR chips being less complex than Cortex-M chips and being only made by a single company).</p>

<h2>Familiarity</h2>
<p>Familiarity is the single most powerful force when it comes to toolchain selection. It is much easier <strong>and faster</strong> to use the tools that you already know, right? The same applies to the team you are working with. If you have had ten successful projects with GCC you will highly likely stick with GCC. If you have had ten with IAR you will also stick with it.</p>
<p>This can be both good and bad. The good side is obvious. The bad one often is &#34;we have always used XYZ 1.3 [that was released a decade ago] so we have to use it now&#34;, even when better alternatives are available.</p>
<h2>Customer wants XYZ</h2>
<p>This is an obvious requirement. If you are supposed to only provide a working device (+ manufacturing instructions) to a company that outsourced the development work to you then the toolchain selection is not that important (as long as you deliver a working product).</p>
<p>However, if you are a silicon vendor and you have to provide libraries for your customers to use then you have to target multiple toolchains. The same applies to firmware middleware and libraries. Of course there is no sense in trying to support all possible toolchains and their versions but at least in my silicon development career I had to support GCC and IAR simultaneously because the customers asked for it.</p>
<h2>Maintaining an old project</h2>
<p>This is one of the very few (in my opinion) reasons to stick with an old toolchain. Some electronic products have long lifetimes (for example in industrial automation) so it is not uncommon to find yourself working on a product that has been delivered a decade ago, qualified, certified, passed from one team to another across the years and has some small features added every second year. In that case you do not want to re-learn all the toolchain &amp; application quirks.</p>
<p>It also makes sense to keep a minimal VM with the complete toolchain in case the OS becomes unavailable, unsupported or some license activation is not possible anymore. Naturally, an open-source toolchain like GCC or Clang is less at risk of disappearing in the future or deprecation and lack of support compared to a toolchain made only by a single company.</p>
<h2>Certification / safety</h2>
<p>Safety-critical product development comes with lots of special constraints. Depending on the overall safety architecture, requirements and relevant standards there may be a need for extra compiler &#34;paperwork&#34; (or qualification). Usually a commercial vendor like IAR can provide certification paperwork for its compiler. However, there are also companies like <a href="https://solidsands.com/">SolidSands</a> that provide test suites for open-source compilers so it may still be possible to use GCC in a device needing functional safety.</p>

<p>GCC and Clang from the user&#39;s point of view are nearly 100% identical. It is <a href="https://interrupt.memfault.com/blog/arm-cortexm-with-llvm-clang">almost trivial</a> to build an embedded C project that was started with GCC with Clang (unless you have used a horrible amount of GCC extensions). Object code can also be freely linked. For example GCC&#39;s <a href="https://interrupt.memfault.com/blog/arm-cortexm-with-llvm-clang#update-clang-baremetal">libc can be linked</a> with your Clang object files. You will immediately feel like at home as the vast majority of command line options are identical. There are some differences when it comes to warnings. I think that Clang supports more of them. IAR on the other hand comes with its own independent heritage so reading the documentation is necessary to find out the command line options. Of course GCC &amp; Clang are open source so you can do almost anything you want while IAR comes in various editions, needs license servers, activation keys etc.</p>
<p>One GCC-specific extension that I really like are <a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html">nested functions</a>. They are basically functions within functions (and the inner function has access to variables of the outer function). I used them from time to time to limit the scope of small helper functions (like wrapping mathematical formulas or doing small computation). The problem is (apart from being only supported by GCC) that they are a <a href="https://thephd.dev/lambdas-nested-functions-block-expressions-oh-my">surprisingly</a> complex <a href="https://nullprogram.com/blog/2019/11/15/">topic</a> so I had to give them up for portability reasons.</p>
<h2>Build systems</h2>
<p>All three compilers work nicely with GNU Make. IAR also comes with its own <code>iarbuild</code> tool that uses an XML file to define the project files and options. This XML file is generated by the Embedded Workbench IDE (but can also be altered by hand).</p>
<p>IAR has slightly different command line options and arguments so the makefiles need tweaking. Overall, I would say that it is pretty easy to get IAR to work with plain makefiles.</p>
<p>In the past IAR was only available for Windows but as of today (from <a href="https://www.prnewswire.com/news-releases/iar-systems-launches-cross-platform-build-tools-for-efficient-building-and-testing-in-cicd-environments-301416281.html">2021</a>?) IAR also comes as a command-line only package (<code>bxarm</code>) that runs on Linux. This means that an IAR project can be integrated into a CI pipeline with Jenkins or Buildbot just as easily as GCC or Clang.</p>
<p>Lifehack: use IAR on the build server to check that your code builds with IAR but avoid the hassle of setting up IAR &amp; licenses on every developer workstation, keep developing primarily with GCC or Clang. If the IAR build fails the developer will get instant feedback from the build server.</p>
<h2>Code portability</h2>
<p>I can say from my experience that developing mostly low-level code using all three compilers is not that hard if you stick to standard C constructs, avoid inline assembly, don&#39;t use too many attributes and too many <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html">compiler extensions</a>. All three compilers support at least <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11</a>. There are some differences when it comes to the standard library but I found them pretty harmless like missing <code>itoa()</code> (which is <em>not</em> part of the C standard but still handy).</p>
<p>Whenever some <code>#ifdef</code>s are necessary I wrap the toolchain-specifics into my own functions. For example <code>myapp_itoa()</code> that either calls the toolchain&#39;s <code>itoa()</code> or custom code. This allows me to keep the &#34;messy&#34; code in a single place, avoid duplication and make clean calls to <code>myapp_something()</code> everywhere else. You can also wrap on the <a href="https://mcuoneclipse.com/2023/07/22/gnu-linker-wizardry-wrapping-printf-with-timestamps/">linker level</a> but that makes your build toolchain-specific.</p>
<h2>Code size</h2>
<p>I found out that IAR (configured for smallest code size optimization) consistently delivered binaries that were approximately 2-3% smaller compared to GCC with <code>-Os</code>. Clang on the other hand made binaries that were approximately 4% larger compared to GCC. I did not do any exact performance measurements or benchmarking. All binaries functioned identically, passed all my test cases, there were no timing-critical features only some communication code that was expecting responses within tens of milliseconds.</p>
<p><strong>Is it significant?</strong> Maybe. All projects I have worked on (that could afford a Cortex-M) were not that code size sensitive. Price constrained products tend to gravitate towards cheap PIC16 and PIC12 anyway. My customers often asked for a particular memory headroom. For example &#34;no more than 60% flash utilization for version 1.0&#34; so the MCU was always over-specced. This is pretty reasonable if you plan to keep the same product alive for a number of years and extend its functionality along the way. However, if you are working on an extremely cost sensitive product, say, an ASIC motor controller with a mask ROM CPU then every single byte will count. For example many ICs sold as &#34;motor controllers&#34; actually have a built-in CPU that runs the control algorithm.</p>
<p>Small note: GCC &amp; Clang binaries are always multiple of 4 bytes while IAR &#34;stride&#34; is 2 bytes. Poorly written code that CRCs the firmware blob word-wise will fail on IAR binaries.</p>
<h2>Warnings</h2>
<p>All three compilers give decent warnings. I have a feeling that Clang gives the best messages and output that points exactly to the issue, even within a single line (this is highly subjective). I found IAR to be picky about volatile accesses. Code like <code>uint32_t x = REG_A + REG_B;</code> would (correctly) give warnings that the access order is undefined. I have never seen this warning in GCC.</p>
<p>Sometimes some warnings have to be enabled and disabled within the code. For example I enable padding warnings (<code>-Wpadded</code>) is some structs that should have the exact layout preserved (eg. when transmitting them over a wire or saving to flash). The syntax and contents of <code>#pragma</code>s that change warnings are different between GCC/Clang and IAR so some <code>#ifdef</code>s are necessary.</p>
<p>Overall, it is great to build your code with multiple toolchains and as many warnings enabled as practical because some issues may be spotted only by the first tool, but not the second (and vice versa for other issues).</p>
<h2>Attributes</h2>
<p>In embedded projects sometimes you have to dive &#34;below C&#34;. Attributes are a way of telling the compiler what to do with your <a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">code</a> or <a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">data</a> that can&#39;t be expressed in standard C. Some attributes that I tend to use:</p>
<ul>
<li>alignment - Example: DMA needs word (4 bytes) alignment but you have an <code>uint8_t</code>, without the attribute the compiler can place the variable at any address and DMA may not work. Another example: the Cortex-M vector table needs to be aligned on 256 bytes (or more). The attribute is necessary when using it as an array in RAM.</li>
<li>section - Example: putting functions in RAM instead of flash (for speed or to let them run while flash is being modified).</li>
<li>forced inlining &amp; flattening - Example: putting a function and all functions it calls in RAM. It is expensive but may improve performance (both speed &amp; power consumption) or may be necessary (eg. during flash operations).</li>
<li>deprecation - When a variable or function is scheduled to be retired/removed it can show you where it is still used (or give a warning to a new developer that tries to use it).</li>
<li>unused (applied to function arguments) - Example: you have a family of functions and pass them as pointers. It is nice to <code>typedef</code> the function pointers but if the arguments of all of them are not matched you will get a warning about a bad cast. It may be easier to declare all functions with redundant arguments and mark the redundant ones as unused. Another example is a volatile variable that you plan to inspect with the debugger. It is &#34;not used&#34; as far as the compiler sees it but still serves a purpose.</li>
<li>format (checking that the arguments match the format string in <code>printf</code> and <code>scanf</code>-like functions) - Example: own, wrapped <code>printf</code>-like function used for logging.</li>
</ul>
<p>The syntax differs across compilers. GCC and Clang are obviously 100% compatible, IAR is different but accepts some of GCC&#39;s attributes. My recommendation: wrap the attributes in macros and have a look at the ones already defined in CMSIS (see: <code>cmsis_compiler.h</code>).</p>
<h2>Built-ins</h2>
<p>Built-ins (or <a href="https://en.wikipedia.org/wiki/Intrinsic_function">intrinsics</a>) are the single biggest area that I find different across compilers. I would divide the intrinsics into two broad categories: the ones that emit a particular instruction that is not available in C (eg. <code>WFE</code>, <code>WFI</code>, <code>SEI</code>, <code>SEV</code>) and regular functions that may map efficiently to hardware instructions (eg. <code>__builtin_bswap32</code> is a single <code>REV16</code> in Cortex-M). They can either be &#34;truly built-in&#34; or they can be provided as <a href="https://arm-software.github.io/CMSIS_5/Core_A/html/group__CMSIS__Core__InstructionInterface.html">assembly code wrapped in macros or functions</a>.</p>
<p>Clang &amp; GCC are pretty identical when it comes to built-ins but IAR is very different. Why do you need intrinsics in the first place and how often? I tend to use them maybe 2-3 times a year. I mostly use the ones dealing with <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">operations on bits</a>. Example: you read a status register from the hardware and want to find the first (or last) bit that is set to execute the right handler. You can loop and shift but in GCC you can also call <code>__builtin_ffs</code> (yes, it is a real name). It may (or may not) be more efficient than a regular loop but if the code is moved to a different CPU it may be built using more efficient instructions. For example <code>__builtin_popcount</code> maps to a single instruction in x86. A compiler <a href="https://lemire.me/blog/2016/05/23/the-surprising-cleverness-of-modern-compilers/">may be smart enough</a> to <a href="https://github.com/llvm-mirror/llvm/blob/f36485f7ac2a8d72ad0e0f2134c17fd365272285/lib/Transforms/Scalar/LoopIdiomRecognize.cpp#L960">recognize</a> what you are doing and still replace it with <code>popcount</code>. I prefer explicit (and well commented) code when it comes to handling seldomly used features so I would rather use an intrinsic clearly stating the intent rather than a loop.</p>
<p>Using intrinsics is easier than assembly because they still look and behave like regular C functions. It is still worth knowing which data manipulation operations <a href="https://m0agx.eu/fast-integer-scaling-on-cortex-m0.html">map efficiently</a> to CPU instructions. I worked once on a sensor ASIC that had a stream of data delivered to the CPU from an ADC. For some arcane reason the digital designers highly preferred to deliver the data from the ADC FIFO &#34;slightly&#34; out of order if I could reorder it cheaply on the CPU side. In that case I found the <code>REV16</code> Cortex-M instruction (and the <code>__REV16()</code> intrinsic) that could do the reordering in a single cycle and some silicon area was saved.</p>
<h2>Linker syntax &amp; symbols</h2>
<p>The three compilers obviously come with their own linkers. There is a lot of compatibility between GCC and Clang. Object code can be freely linked and linker script syntax is identical. The command line options for <code>ld</code> and <code>lld</code> are identical. IAR&#39;s <code>xlink</code> is a different beast.</p>
<p>I would say that the linker script syntax is where IAR tools really shine. The syntax actually <em>makes sense</em> and is <em>human-readable</em>. <a href="https://github.com/STMicroelectronics/STM32CubeL4/blob/master/Projects/NUCLEO-L412KB/Templates_LL/EWARM/stm32l412xx_flash.icf">Example</a> (I removed the comments):</p>
<div><table><tbody><tr><td><div><pre><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span></pre></div></td><td><div><pre><span></span><code><span>define</span><span> </span><span>symbol</span><span> </span><span>__ICFEDIT_intvec_start__</span><span> </span><span>=</span><span> </span><span>0</span><span>x08000000</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__ICFEDIT_region_ROM_start__</span><span>    </span><span>=</span><span> </span><span>0</span><span>x08000000</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__ICFEDIT_region_ROM_end__</span><span>      </span><span>=</span><span> </span><span>0</span><span>x0801FFFF</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__ICFEDIT_region_RAM_start__</span><span>    </span><span>=</span><span> </span><span>0</span><span>x20000000</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__ICFEDIT_region_RAM_end__</span><span>      </span><span>=</span><span> </span><span>0</span><span>x20009FFF</span><span>;</span>

<span>define</span><span> </span><span>symbol</span><span> </span><span>__ICFEDIT_size_cstack__</span><span> </span><span>=</span><span> </span><span>0</span><span>x400</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__ICFEDIT_size_heap__</span><span>   </span><span>=</span><span> </span><span>0</span><span>x200</span><span>;</span>

<span>define</span><span> </span><span>symbol</span><span> </span><span>__region_SRAM1_start__</span><span>  </span><span>=</span><span> </span><span>0</span><span>x20000000</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__region_SRAM1_end__</span><span>    </span><span>=</span><span> </span><span>0</span><span>x20007FFF</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__region_SRAM2_start__</span><span>  </span><span>=</span><span> </span><span>0</span><span>x20008000</span><span>;</span>
<span>define</span><span> </span><span>symbol</span><span> </span><span>__region_SRAM2_end__</span><span>    </span><span>=</span><span> </span><span>0</span><span>x20009FFF</span><span>;</span>

<span>define</span><span> </span><span>memory</span><span> </span><span>mem</span><span> </span><span>with</span><span> </span><span>size</span><span> </span><span>=</span><span> </span><span>4</span><span>G</span><span>;</span>
<span>define</span><span> </span><span>region</span><span> </span><span>ROM_region</span><span>      </span><span>=</span><span> </span><span>mem:</span><span>[</span><span>from</span><span> </span><span>__ICFEDIT_region_ROM_start__</span><span>   </span><span>to</span><span> </span><span>__ICFEDIT_region_ROM_end__</span><span>];</span>
<span>define</span><span> </span><span>region</span><span> </span><span>RAM_region</span><span>      </span><span>=</span><span> </span><span>mem:</span><span>[</span><span>from</span><span> </span><span>__ICFEDIT_region_RAM_start__</span><span>   </span><span>to</span><span> </span><span>__ICFEDIT_region_RAM_end__</span><span>];</span>
<span>define</span><span> </span><span>region</span><span> </span><span>SRAM1_region</span><span>    </span><span>=</span><span> </span><span>mem:</span><span>[</span><span>from</span><span> </span><span>__region_SRAM1_start__</span><span>   </span><span>to</span><span> </span><span>__region_SRAM1_end__</span><span>];</span>
<span>define</span><span> </span><span>region</span><span> </span><span>SRAM2_region</span><span>    </span><span>=</span><span> </span><span>mem:</span><span>[</span><span>from</span><span> </span><span>__region_SRAM2_start__</span><span>   </span><span>to</span><span> </span><span>__region_SRAM2_end__</span><span>];</span>

<span>define</span><span> </span><span>block</span><span> </span><span>CSTACK</span><span>    </span><span>with</span><span> </span><span>alignment</span><span> </span><span>=</span><span> </span><span>8</span><span>,</span><span> </span><span>size</span><span> </span><span>=</span><span> </span><span>__ICFEDIT_size_cstack__</span><span>   </span><span>{</span><span> </span><span>};</span>
<span>define</span><span> </span><span>block</span><span> </span><span>HEAP</span><span>      </span><span>with</span><span> </span><span>alignment</span><span> </span><span>=</span><span> </span><span>8</span><span>,</span><span> </span><span>size</span><span> </span><span>=</span><span> </span><span>__ICFEDIT_size_heap__</span><span>     </span><span>{</span><span> </span><span>};</span>

<span>initialize</span><span> </span><span>by</span><span> </span><span>copy</span><span> </span><span>{</span><span> </span><span>readwrite</span><span> </span><span>};</span>
<span>do</span><span> </span><span>not</span><span> </span><span>initialize</span><span>  </span><span>{</span><span> </span><span>section</span><span> </span><span>.</span><span>noinit</span><span> </span><span>};</span>

<span>place</span><span> </span><span>at</span><span> </span><span>address</span><span> </span><span>mem:</span><span>__ICFEDIT_intvec_start__</span><span> </span><span>{</span><span> </span><span>readonly</span><span> </span><span>section</span><span> </span><span>.</span><span>intvec</span><span> </span><span>};</span>

<span>place</span><span> </span><span>in</span><span> </span><span>ROM_region</span><span>   </span><span>{</span><span> </span><span>readonly</span><span> </span><span>};</span>
<span>place</span><span> </span><span>in</span><span> </span><span>RAM_region</span><span>   </span><span>{</span><span> </span><span>readwrite</span><span>,</span>
<span>                        </span><span>block</span><span> </span><span>CSTACK</span><span>,</span><span> </span><span>block</span><span> </span><span>HEAP</span><span> </span><span>};</span>
<span>place</span><span> </span><span>in</span><span> </span><span>SRAM1_region</span><span> </span><span>{</span><span> </span><span>};</span>
<span>place</span><span> </span><span>in</span><span> </span><span>SRAM2_region</span><span> </span><span>{</span><span> </span><span>};</span>
</code></pre></div></td></tr></tbody></table></div>

<p>What do we have here? Definition of addresses, then some sections (regions), magic names for stack &amp; heap, what goes into RAM, what goes into ROM (flash) and... that is it. Even without reading any <code>xlink</code> documentation you can instantly understand 90% of this script. Now compare it with a basic GNU <a href="https://github.com/ARM-software/CMSIS_5/blob/develop/Device/ARM/ARMCM0/Source/GCC/gcc_arm.ld">linker script that is almost 300 lines long</a>.</p>
<p><strong>Is it significant?</strong> Maybe (again). The projects I worked on did not require any elaborate linking schemes. I usually delivered a bootloader + bootloadable application combo so I did not have to hack linker scripts too much. There are some extra features provided by IAR. For example automatically adding checksums to the binary images. However, I prefer to have a Python script do the postprocessing explicitly (like adding checksum and magic values to the application so that it is recognized by the bootloader). To me the IAR linker syntax simply makes sense. The GNU syntax is too difficult to follow.</p>
<h2>Startup code</h2>
<p>There are <a href="https://embeddedartistry.com/blog/2019/04/17/exploring-startup-implementations-newlib-arm/">surprisingly</a>
many things that have to happen before <code>main()</code> is reached. Startup code has many responsibilities. For example:</p>
<ul>
<li>&#34;Chip startup&#34; eg. configuration of the clocks, busses and supplies</li>
<li>&#34;CPU startup&#34; eg. enabling the FPU</li>
<li>&#34;Board startup&#34; eg. enabling external RAM and bumping supply voltages to increase clock speeds</li>
<li>C runtime startup eg. initializing static variables and zeroing out memory, initializing the standard library</li>
</ul>
<p>All these features are commonly called &#34;the startup code&#34; even though they deal with different things.
Chip startup is provided by the chip vendor (eg. NXP). CPU startup comes from ARM (eg. CMSIS).
Board startup depends on the exact PCB so most likely you have to write it yourself (or based on
an existing demo). All these steps are mostly independent of the toolchain.</p>
<p>C runtime startup is the one that differs the most across toolchains.
For example: in GCC the data initialization is done by simple loops (see <code>__cmsis_start</code> for an example),
IAR has it own <code>__iar_data_init3</code>, <code>newlib</code> needs <code>__libc_init_array</code> and provides a <code>_start()</code>
function, IAR has a <code>__low_level_init</code> etc. All these differences are mostly &#34;cosmetic&#34;
unless you have a very complicated system with multiple memories, binary sections etc.
The startup code is not portable (maybe only between GCC and Clang) but it is written only
once, pretty small and usually included in the toolchain or demos from the chip supplier.</p>
<h2>Analyzers &amp; additional tools</h2>
<h3>What is great about GCC?</h3>
<h4><code>gcov</code></h4>
<p>GCC toolchain provides an extremely useful <a href="https://mcuoneclipse.com/2014/12/26/code-coverage-for-embedded-target-with-eclipse-gcc-and-gcov/">coverage analyzer</a> called <code>gcov</code>.
Code coverage tools tell you which lines of code have been reached and executed.
As we all know, code that was not tested is almost for sure not correct. And code that was never ran was for sure never tested.
The output product of <code>gcov</code> is an HTML report that has all of your project&#39;s source code highlighted in green (executed)
or red (not executed) plus the percentage of code executed per file.</p>
<p>Code coverage with GCC works basically like this:</p>
<ol>
<li>You compile your code with <code>--coverage</code> and GCC adds special instructions that track every branch (this of course affects runtime performance).</li>
<li>The binary has to be linked with <code>libgcov</code> and implement a way to save data to a file (the easiest way is probably semihosting).</li>
<li>The project now has to be ran on the actual target and exercised, preferably by a series of tests to have the code go into as many branches as possible.</li>
<li>Once enough testing is done the code has to save coverage data to a file.</li>
<li>The coverage file is postprocessed to an HTML report.</li>
</ol>
<p>There are of course commercial coverage tools that may be easier to set up but <code>gcov</code>&#39;s main advantage is that it is simply part of GCC.</p>
<h4>Static analyzer</h4>
<p>GCC has had an <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html">integrated</a>
static code analyzer <a href="https://developers.redhat.com/articles/2022/04/12/state-static-analysis-gcc-12-compiler">for a while</a> now.
It is enabled by adding <code>-fanalyzer</code> to compiler flags. You can think of this feature as simply
building your code (but without producing any output files) and hoping to not get any build warnings.</p>
<h4>GNU complexity</h4>
<p><a href="https://www.gnu.org/software/complexity/">GNU complexity</a> is a tool that analyzes code for <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a>.
In simple terms: the more branches (and control flow statements like <code>break</code>, <code>continue</code>, <code>return</code>) there are in the code
the more difficult it is to understand (and to make sure that it does what is intended).
A single <code>if</code> statement has two branches so you need at least two test cases to exercise them both. If a function has four <code>return</code> points you need at least four test cases.
What if there are 50 or 100 or more possible code paths? You are in trouble. You are deeply in trouble. The code is untestable
and unmaintainable. Having a code complexity analyzer allows you to quickly find code spots that need
more care and refactoring. The sooner you spot them the easier the refactoring.</p>
<h3>What is great about Clang?</h3>
<p>Apart from extra warnings (and less language extensions than GCC) Clang has a very useful code analyzer called <a href="https://clang.llvm.org/extra/clang-tidy/">Clang-Tidy</a>.
The output is an HTML report. The analyzer covers different &#34;spots&#34; than the compiler. I did not find many issues
in my code after first analysis but some of them were clearly valid (or the code was poorly written). There were
some false-positives but they can easily be silenced using magic <a href="https://clang.llvm.org/extra/clang-tidy/#suppressing-undesired-diagnostics">comments</a>.
Running Clang-Tidy is as easy as replacing <code>clang</code> with <code>clang-tidy</code> in the Makefiles (+some small flag adjustments).</p>
<h3>What is great about IAR?</h3>
<p>The tool I like the most from the IAR ecosystem is <a href="https://www.iar.com/cstat">C-STAT</a>. It is a static code analyzer
(like Clang-Tidy) that includes <a href="https://en.wikipedia.org/wiki/MISRA_C">MISRA</a> checking. Some customers require you
to provide code that is MISRA-clean (or document and justify all deviations). Due to various licensing &amp; copyright
shenanigans there are no open-source tools that can check your code for MISRA violations. I researched
multiple MISRA tools and found IAR C-STAT to be the &#34;least bad&#34; (I could not get anything useful done with PC-Lint) because it is the only tool you can actually buy
when you have a small team. Other vendors do not even give a price when they hear that your development team is less than 15 people.</p>
<p>C-STAT is very easy to add when you already have a build setup with IAR. Of course the whole codebase has 
to build cleanly with IAR first. The output is an HTML report that points to all issues in your codebase.</p>

<p>In my opinion the three Cortex-M compilers perform almost identically in 95% of portable C use cases.
There are some small advantages and disadvantages that may be relevant depending on the exact project requirements.
Binaries may have better or worse performance depending on your exact code so you should always profile your firmware
if performance is important.
To deliver really high quality firmware I simply recommend using a mix of tools:</p>
<ul>
<li>GCC builds for &#34;general use&#34;</li>
<li>GCC builds with <code>gcov</code></li>
<li>GCC <code>-fanalyzer</code> for static analysis</li>
<li>GNU complexity</li>
<li>Clang builds for testing portability and more warnings</li>
<li><code>clang-tidy</code> for static analysis</li>
<li>IAR builds for testing portability and more warnings</li>
<li>IAR C-STAT for static analysis and MISRA checking</li>
</ul>
<p>Does it look like overkill? <strong>With a proper CI setup the cost of supporting all the
tools is next to nothing.</strong> Every developer can pick their favourite toolchain for
daily work and CI takes care of the rest. Of course it is best to <a href="https://llis.nasa.gov/lesson/1196">&#34;test as you fly, fly as you test&#34;</a> so ideally you would have hardware-in-the-loop tests for all builds.
Once you decide which toolchain is going to be used for the release builds
it is best to concentrate most of development &amp; testing effort on that particular build
so you don&#39;t end up developing something for 2 months with GCC and hoping that everything
will turn out perfect when built with IAR in the last week before delivery.</p>
<p>The biggest general &#34;cost&#34; I see is making a test suite for hardware-in-the-loop testing.
This cost is totally independent of the selected toolchain.
Adding one more binary from another toolchain to an existing test suite is practically free.</p>
<p>If your firmware is built with more than one toolchain you can also almost instantly rule out or confirm compiler bugs.
I think everybody was at least once in a situation where a trivial code change in one place
triggered some totally unexplainable behaviour in a different place. If it happens on two different
binaries then you know that the issue is more likely in your code (or silicon😁) than in the compiler.
Different compilers may also help uncover obscure implementation-defined behaviour that you were not aware of
(say hello to missing <code>volatile</code> here and there). 
Undefined behaviour should of course be avoided at all cost by enabling compiler warnings.</p>
<p>Every time I get a failure notification from the CI server I feel a teeny-tiny spark of satisfaction
that &#34;the process is working&#34; and that the <a href="https://www.yegor256.com/2022/07/05/safety-net.html">safety net</a>
caught something automatically that could have surfaced much later and in worse circumstances.</p>
    </article></div>
  </body>
</html>
