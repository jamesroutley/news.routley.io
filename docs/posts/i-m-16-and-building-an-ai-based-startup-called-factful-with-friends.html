<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://factful.io/">Original</a>
    <h1>Show HN: I&#39;m 16 and building an AI based startup called Factful with friends</h1>
    
    <div id="readability-page-1" class="page"><section>
			<p>For some reason, when I was a younger programmer, I developed the belief that I needed to learn Haskell and Category Theory to become a better programmer. It would be a long, arduous challenge, but then one day, I’d finally <em>get it</em>. I’d grok the pure math of <em>function composition</em> and use it to design perfect systems, entirely free of bugs. Once I learned what a <em>monoid in the category of endofunctors</em> was, I would be slinging those around all day, cranking out provably correct code with mathematically optimal API surfaces, instead of throwing another ad-hoc unit test on the pile and trying to unflake my integration tests for the 1000th time, like a schmuck.</p>
<p>I actually never got around to learning that fancy stuff because it turns out the schmucky approach works just fine (actually it’s much better than waiting for silver bullets like fancy programming languages!), but recently I had extra time and watched Bartosz Milewski’s 10 hour <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Category Theory for Programmers</a> class on youtube. It’s a great course! Because of how clear the material is and how well Bartosz explains it, I can definitely say the problem is with the topic itself. Specifically, I’m disappointed with the credibility that category theory has as a tool for programmers. It’s often spoken of as an extremely high level, powerful tool, but it really isn’t worth learning to upgrade your skillset, not even in a “I don’t use this every day but it will make me smarter learning it” way.
(If you’re looking for a math power-up, I’ll explain why I think Abstract Algebra is the topic to study.)</p>
<p>I think Category Theory for programming is not as popular these days, but for younger me, and particularly in academic/intellectual circles it definitely had an aura. I’m writing this in case I can help someone like my younger self and persuade them to stick with (eg) python instead and learn it well.</p>
<p>It could be the obsession everybody had with monads. They’re a great example of why learning category theory isn’t worth it.
Beforehand, I understood a Monad as a generic container type like <code>List[T]</code> with a function <code>fmap()</code> (or <code>map</code>) that lets you apply a function “to the thing inside the container” and you could chain together. I really like the <a href="https://fsharpforfunandprofit.com/rop/">train tracks</a> metaphor for it.</p>
<p>Now, I’m finally one of those wizards who understands what “a monad is a monoid in the category of endofunctors” is and I’m worse off for it. It’s the same description I just used, but it took 10 hours to learn and added 0 to my programming skillset or intuition. It did not enlighten me as to why monads are useful, when they should be used, or why they are powerful. I know the phrase is used tongue in cheek, but it’s a joke how vacuous it is. It’s not even worth trying to understand it. Let me show you.</p>
<h3 id="a-complicated-definition-that-gives-little">A complicated definition that gives little</h3>
<p>The “category of endofunctors” in Haskell is actually just types like <code>List[T]</code>.
Functors are mappings between categories that “preserve structure”, and endofunctors map a category to itself.
In Haskell there’s only one category, so all functors are endofunctors.
This category is called <code>Hask</code> and it contains the types that variables can have, like <code>Bool</code> or <code>Number</code>. The arrows (morphisms) are functions between types like <code>isEven: Number -&gt; Bool</code>
<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.
Since Hask is the category of “simple types”, <em>endofunctors are just generic types</em> like <code>List[T]</code>.
To be able to “preserve the original structure” of <code>Hask</code>, wherever you have a function from <code>T -&gt; Something</code> you need to be able to run on a <code>List[T]</code> and get a <code>List[Something]</code>, aka “call the function on the value inside the container” with <code>fmap</code>.</p>
<p>Generic types for containers with a <code>map()</code> function are powerful! The idea that things like <code>Option</code> can have a <code>map</code> function just like <code>Result</code>, <code>List</code> and <code>Promise</code> is really nice and ergonomic. This is 90% of the value of monads anyway, and it’s actually from its parent concept <code>Functor</code>.</p>
<p>So that’s “the category of endofunctors” bit. It’s container generics. The “<em>monoid in</em>” the category of endofunctors bit is just one more function that lets you unwrap the container and unlocks the ability to chain calls to <code>fmap()</code><sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. Haskell comes with special syntax (<code>&lt;&lt;=</code>) to chain the calls for you.</p>
<p>So in the end, monads are still “generic containers that can be chained together”. We’re right back where we started, but it took a lot of time to define all of those terms in actual category theory. If I wanted to actually learn about monads I could have spent those 10 hours reading tutorials, figuring out how people use them in practice with like monad transformers, or actually writing code that uses them. That’s the problem: This stuff is so abstract it takes a long time to learn, and it’s not worth the payoff.</p>
<h3 id="vague-descriptions-instead-of-concrete-tools">Vague descriptions instead of concrete tools</h3>
<p>Imagine the kind of programming model you would need to unify a 30 year old COBOL codebase, a Java FactoryFactory enterprise swamp, a compiler written in LISP, and an accounting program written in Forth. You couldn’t use any special features of those languages, and would need to have the simplest programming model. While it would be “the most abstract”, that abstractness wouldn’t really give you much power as a programmer. It’s like thinking that Turing Machines <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> are the best programming language because they’re the most abstract.</p>
<p>Bartosz in his course makes the point that category theory works by completely ignoring the specific properties of the objects it studies, and reducing them to points connected by arrows. For example, if your Category is “types available in Haskell”, you can’t point to “the numeric types” because you can’t talk about anything specific like a number. You can say an object has more arrows pointing to it than other objects, or that there are arrows that form a cycle, or that for every pair of arrows then there’s a third arrow that looks like this… Then it becomes a lot of work to define even simple things like the empty set: it’s “a terminal object”, an object that has an arrow to it from every other object. It’s a lot of overhead to work at this high an abstraction level.</p>
<p>In programming, we have a lot of information about our domain that we constantly use. All the quantities we deal with are finite, like memory, bandwidth and IEEE floats. Sequential reads from disk are faster than random reads. Accesses to RAM at locations aligned to word boundaries are faster than other locations. Sometimes these things cause bugs and we work around them and other times they’re features we use to our benefit. We exploit concrete knowledge about computers to do our jobs, but Category Theory’s MO is to ignore that knowledge so it ends up being too vague to be useful. It’s the polar opposite of Leetcode, which is too specific. But grinding Leetcode is 10x more useful than studying CT: every so often you’ll actually use a DFS.</p>
<p>I feel like this whole Category Theory thing was some kind of gatekeepy “I’m smarter than you” shtick. I’m glad it’s no longer trendy in my circles. If you’re a young student who’s heard about the topic and is thinking of learning it, I hope you’ll reconsider. Even learning “regular” Haskell and bikeshedding between monad transformer libraries is more useful than learning Category Theory.</p>
<p>The shame is that there is pure math that would help most programmers model their systems better and work with composition! It’s Abstract Algebra.</p>
<h3 id="abstract-algebra-is-math-that-will-make-you-better-as-a-programmer">Abstract Algebra is math that will make you better as a programmer</h3>
<p>Abstract algebra, or modern algebra, (in math departments it’s just called Algebra) studies how sets of objects change under different operations, and what happens when the properties of the operations vary. It’s usually taught starting with group theory.</p>
<p>Group theory is kind of what laypeople imagine category theory to be!
It’s also about abstract objects, with arrows between them. The main practical difference is that there’s an extra stipulation that each object needs to have an inverse: eg 5 needs to have a -5 to add back to 0 to form a group.</p>
<p>Learning category theory is like trying to climb a vertical ice sheet, there’s very little to grab onto. Group theory is less steep and made of rock, with examples you can grab onto and learn from. The “everything needs an inverse” requirement of groups gives them structure, and makes them deeply related to the notion of symmetry <sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>. Symmetry is in and of itself immensely powerful for programmers: you definitely want to know when you can cut your problem in half because of it.</p>
<p>Abstract Algebra has a very high ceiling too, and you can keep squeezing coding insight juice out of it a long way. I’ve barely started but it’s been useful the whole way, with applications like elliptic curves (they form a cyclic group! <em>that’s</em> why they’re used in cryptography), error correcting codes and <a href="https://adventofcode.com/2023/day/8">Advent of Code</a> cycle finding problems <sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p>
<p>It’s still plenty abstract if you like that! It builds a lot of muscles for thinking about abstract things like cosets and group actions, but it <em>actually</em> builds intuition about how binary relations compose. In programming, we often define new operations, like “a customer can pause their subscription for 2 weeks at a time.” Then we have to reason about how that interacts with all the other operations in our domain model:</p>
<ul>
<li>Can you cancel a pause before it happens? Does it have an inverse?</li>
<li>What happens if pause-then-cancel vs cancel-then-pause ? Do the operations commute?</li>
<li>If two user accounts get merged, do the pauses merge? How do mappings (homomorphisms) affect it?</li>
</ul>
<p>It doesn’t give you any solved answers or blueprints, but you go through so many instances of groups when learning the concept that you get dramatically stronger at reasoning about binary operations. And the really nice thing about it is, it goes really well with Linear Algebra (which arguably is the THE MOST USEFUL MATH FOR PROGRAMMERS) and thinking about commutativity. A lot of the reason matrices are weird is that they don’t naturally commute: given two matrices A, B, AB != BA, and group theory can explain some of the consequences.</p>
<h3 id="programmers-dont-need-the-math-of-math">Programmers don’t need “the math of math”</h3>
<p>Back when I was a impressionable youngster, one of my naïve reasons for wanting to learn CT was to wield “the math behind math itself”.
I thought that I would learn this special thing and then get superpowers: x-ray beams would shoot out of my eyes and I’d be able to do laps around mathematicians.</p>
<p>In practice you need to learn a ton of (non-CT) math before “exhausting” its patterns and needing to abstract.
There is a lot of powerful knowledge in each Category that you can learn and apply before you need to generalize across Categories.</p>
<p>A lot of important developments from the impossibility of a quintic equation to the proof of Fermat’s Last Theorem use Abstract Algebra. You can do a whole undergrad (several years of study) in math before needing the “power” of the genericness of CT.</p>
<h3 id="how-useful-is-math-to-programming">How useful is math to programming?</h3>
<p>Math isn’t even the best avenue to upskill your programming.
Ask every super-senior programmer, they’ll all tell you: the most effective way to get better as a programmer is to write mountains of real world code. The second most effective is to read mountains of real world code.</p>
<p>Those two things are so valuable that for the rest of the list of potential improvements, the ranking doesn’t really matter. Reading and writing tons of code will make you at least 3x better in your day to day, everything else like IDEs/workflows, leetcode, and even math just pales in comparison, probably like 1.03x each.
(The real percentage improvement is impossible to measure and is the source of much debate online.)</p>
<p>I’m not against doing math, I’m doing a ton of it. Eventually, if you hit a point where you’ve read mountains of code already and want to get to the next level, the smaller improvements add up and can be worth it.
Just don’t start with Category Theory, pick up Abstract Algebra <sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> and Linear Algebra first. They will have a much higher payoff, both in short-term applications and in long-term conceptual patterns. You can even layer on CT after that, and I’m sure it will enhance the base you’ve built with algebra.</p>
<!-- [^footnote-lm]: Linear Maps
[^foonote-linalg]: I've also been watching some linear algebra and I recommend this OCW class for building up intuition about matrices, eigenvalues and SVD, low-rank approximations, etc.

Linear algebra is a close relative of Algebra. It's literally the study of Algebra, but limited to functions that [^footnote-lm] have the property: f(a + x) = f(a) + f(x).[^footnote-linalg] -->



			
				<hr/>
				


<a href="https://disqus.com">comments powered by <span>Disqus</span></a>
			

			<hr/>
			


<ul>
	
	<li><a href="https://amedee.me/missing-middle/">The Missing Middle in Tech Education</a></li>
	
	<li><a href="https://amedee.me/2022/11/09/debugging/">Debugging Is Science</a></li>
	
	<li><a href="https://amedee.me/2022/11/08/dont-call-yourself-a-programmer/">Patio11&#39;s Don&#39;t Call Yourself a Programmer, and Other Career Advice</a></li>
	
	<li><a href="https://amedee.me/2022/11/06/zoxy/">Forget about localhost:3000 with zoxy</a></li>
	
	<li><a href="https://amedee.me/2022/08/22/7-powers-programming-languages/">The 7 Powers in Programming Language Adoption</a></li>
	
</ul>

		</section></div>
  </body>
</html>
