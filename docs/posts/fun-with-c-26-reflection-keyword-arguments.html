<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pydong.org/posts/KwArgs/">Original</a>
    <h1>Fun with C&#43;&#43;26 reflection: Keyword Arguments</h1>
    
    <div id="readability-page-1" class="page"><div><p>In this blog post, we’ll explore implementing order-independent keyword arguments for C++ through use of C++26’s <a href="https://wg21.link/p2996">proposed reflection</a> features. I stumbled upon this technique while experimenting with reflection a few days ago and thought it might be worthwhile to share, as it nicely showcases just how powerful the proposed reflection features are.</p><p>An example implementation of the technique presented in this blog post can be found on <a href="https://github.com/tsche/kwargs">GitHub</a>. It can be used with Bloomberg’s experimental <a href="https://github.com/bloomberg/clang-p2996">P2996 clang fork</a>. If you enjoy these shenanigans, feel free to leave a star. :)</p><h2 id="prior-art"><span>Prior art</span><a href="#prior-art"><i></i></a></h2><p>Named, labeled or keyword arguments have been proposed many times over the years, but as <a href="https://cplusplus.github.io/EWG/ewg-closed.html#150">EWG issue 150</a> notes: all of these attempts have failed. Here is several past proposals on the topic:</p><ul><li><a href="https://wg21.link/n4172">n4172</a> Named arguments</li><li><a href="https://wg21.link/p1229">p1229</a> Labelled Parameters</li><li><a href="https://wg21.link/p0671">p0671</a> Self-explanatory Function Arguments</li></ul><p>Since none of these proposals were accepted, we have to be somewhat creative to get similar functionality in C++. Naturally, there are various approaches to this problem. Below is a short overview of what you can already do without reflection.</p><h3 id="designated-initializers"><span>Designated initializers</span><a href="#designated-initializers"><i></i></a></h3><p>Let’s start with the simplest way to achieve keyword argument-like syntax. C++20 introduced designated initializers for aggregate types, which gives us the initialization syntax <code>Point{.x=42, .y=7}</code>.</p><p>In a function call’s argument list the type can potentially be deduced, so we could write <code>foo({.x=2, .y=2})</code>. While this requires extra curly braces and <code>.</code>-prefixes for every member name, syntactically this is almost what we want.</p><p>Usage example (<a href="https://godbolt.org/z/ja5oha875">Run on Compiler Explorer</a>):</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span>struct</span> <span>FooArgs</span> <span>{</span>
  <span>int</span> <span>x</span><span>;</span>
  <span>int</span> <span>y</span><span>;</span>
<span>};</span>

<span>void</span> <span>foo</span><span>(</span><span>FooArgs</span> <span>args</span><span>)</span> <span>{</span>
  <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;x: {} y: {}&#34;</span><span>,</span> <span>args</span><span>.</span><span>x</span><span>,</span> <span>args</span><span>.</span><span>y</span><span>);</span>
<span>}</span>

<span>struct</span> <span>BarArgs</span> <span>{</span>
  <span>int</span> <span>x</span><span>;</span>
<span>};</span>

<span>void</span> <span>bar</span><span>(</span><span>int</span> <span>x</span><span>,</span> <span>BarArgs</span> <span>args</span><span>)</span> <span>{</span>
  <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;x: {} y: {}&#34;</span><span>,</span> <span>x</span><span>,</span> <span>args</span><span>.</span><span>x</span><span>);</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>// optional keyword arguments</span>
  <span>foo</span><span>({.</span><span>x</span> <span>=</span> <span>2</span><span>,</span> <span>.</span><span>y</span> <span>=</span> <span>42</span><span>});</span>
  <span>foo</span><span>({.</span><span>x</span> <span>=</span> <span>2</span><span>});</span>

  <span>// positional arguments and keyword arguments</span>
  <span>bar</span><span>(</span><span>12</span><span>,</span> <span>{.</span><span>x</span> <span>=</span> <span>10</span><span>});</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Unfortunately this has various drawbacks:</p><ul><li><strong>Extra Type Definitions</strong> - we need to define a type for every set of keyword arguments out-of-line.</li><li><strong>Optional Arguments</strong> - While <code>std::optional</code> can be used to express optionality of arguments, additional keyword arguments cannot be passed.</li><li><strong>Order Sensitivity</strong> - Arguments must appear in the exact order their corresponding members were declared in the aggregate, although skipping members is still fine.</li></ul><h3 id="helper-objects"><span>Helper objects</span><a href="#helper-objects"><i></i></a></h3><p>As it turns out, making the desired syntax <code>bar(12, x = 10)</code> valid C++ is not actually that difficult. To do this, let <code>x</code> be an object of some type with an <code>operator=</code> overload that wraps the value in some way that later lets us retrieve it by name.</p><p>You might be able to see the problem here already - this needs to be done for <em>every</em> named argument.</p><p>Essentially, all you need to do at the library side of things is define a wrapper, like so:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>,</span> <span>util</span><span>::</span><span>fixed_string</span> <span>Name</span><span>&gt;</span>
<span>struct</span> <span>TypedArg</span> <span>{</span>
  <span>T</span> <span>value</span><span>;</span>
  <span>decltype</span><span>(</span><span>auto</span><span>)</span> <span>operator</span><span>*</span><span>(</span><span>this</span> <span>auto</span><span>&amp;&amp;</span> <span>self</span><span>)</span> <span>{</span>
    <span>return</span> <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>decltype</span><span>(</span><span>self</span><span>)</span><span>&gt;</span><span>(</span><span>self</span><span>).</span><span>value</span><span>;</span>
  <span>}</span>
<span>};</span>

<span>template</span> <span>&lt;</span><span>util</span><span>::</span><span>fixed_string</span> <span>Name</span><span>&gt;</span>
<span>struct</span> <span>Arg</span> <span>{</span>
  <span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
  <span>TypedArg</span><span>&lt;</span><span>T</span><span>,</span> <span>Name</span><span>&gt;</span> <span>operator</span><span>=</span><span>(</span><span>T</span><span>&amp;&amp;</span> <span>value</span><span>)</span> <span>const</span><span>{</span>
    <span>return</span> <span>{</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>value</span><span>)};</span>
  <span>}</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><p>Now we can introduce helpers like this:</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>constexpr</span> <span>inline</span> <span>Arg</span><span>&lt;</span><span>&#34;name&#34;</span><span>&gt;</span> <span>name</span><span>;</span>
</pre></td></tr></tbody></table></code></p></div><p>This could potentially be hidden behind a macro to reduce the possibility of messing up the repetition of the argument’s name, but you still need to carefully do this wherever keyword arguments shall be used.</p><p>To accept keyword arguments, functions must wrap their parameters as well.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>void</span> <span>foo</span><span>(</span><span>int</span> <span>x</span><span>,</span> <span>int</span> <span>y</span><span>);</span>
<span>// becomes</span>
<span>void</span> <span>foo</span><span>(</span><span>TypedArg</span><span>&lt;</span><span>int</span><span>,</span> <span>&#34;x&#34;</span><span>&gt;</span> <span>x</span><span>,</span> <span>TypedArg</span><span>&lt;</span><span>int</span><span>,</span> <span>&#34;y&#34;</span><span>&gt;</span> <span>y</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>Once again, a macro could help here.</p><p>To access the wrapped value, we can use the unary <code>*</code> operator:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>void</span> <span>bar</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>TypedArg</span><span>&lt;</span><span>int</span><span>,</span> <span>&#34;x&#34;</span><span>&gt;</span> <span>x</span><span>)</span> <span>{</span>
  <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;a: {} x: {}&#34;</span><span>,</span> <span>a</span><span>,</span> <span>*</span><span>x</span><span>);</span>
<span>}</span>

<span>constexpr</span> <span>inline</span> <span>Arg</span><span>&lt;</span><span>&#34;x&#34;</span><span>&gt;</span> <span>x</span><span>;</span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>bar</span><span>(</span><span>10</span><span>,</span> <span>x</span> <span>=</span> <span>4</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://godbolt.org/z/h7a3vMaqY">Run on Compiler Explorer</a></p><h4 id="order-independent-arguments"><span>Order-independent arguments</span><a href="#order-independent-arguments"><i></i></a></h4><p>To support order-independent arguments, functions can receive the keyword arguments as a pack. We can then pick out the desired keyword arguments by re-using <code>std::get</code>’s ability to retrieve a tuple’s element by type.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>Needle</span><span>,</span> <span>typename</span><span>...</span> <span>Ts</span><span>&gt;</span>
<span>constexpr</span> <span>decltype</span><span>(</span><span>auto</span><span>)</span> <span>pick</span><span>(</span><span>Ts</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>{</span>
  <span>return</span> <span>*</span><span>std</span><span>::</span><span>get</span><span>&lt;</span><span>Needle</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Ts</span><span>&gt;</span><span>(</span><span>args</span><span>)...));</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Now, keyword arguments can be passed in any order (<a href="https://godbolt.org/z/4ePfobjG5">Run on Compiler Explorer</a>):</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>void</span> <span>oof</span><span>(</span><span>auto</span><span>...</span> <span>kwargs</span><span>)</span> <span>{</span>
  <span>auto</span> <span>x</span> <span>=</span> <span>pick</span><span>&lt;</span><span>TypedArg</span><span>&lt;</span><span>int</span><span>,</span> <span>&#34;x&#34;</span><span>&gt;&gt;</span><span>(</span><span>kwargs</span><span>...);</span>
  <span>auto</span> <span>y</span> <span>=</span> <span>pick</span><span>&lt;</span><span>TypedArg</span><span>&lt;</span><span>int</span><span>,</span> <span>&#34;y&#34;</span><span>&gt;&gt;</span><span>(</span><span>kwargs</span><span>...);</span>
  <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;x: {}, y: {}&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>);</span>
<span>}</span>

<span>constexpr</span> <span>inline</span> <span>Arg</span><span>&lt;</span><span>&#34;x&#34;</span><span>&gt;</span> <span>x</span><span>;</span>
<span>constexpr</span> <span>inline</span> <span>Arg</span><span>&lt;</span><span>&#34;y&#34;</span><span>&gt;</span> <span>y</span><span>;</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>oof</span><span>(</span><span>y</span><span>=</span><span>42</span><span>,</span> <span>x</span><span>=</span><span>2</span><span>);</span>
  <span>oof</span><span>(</span><span>x</span><span>=</span><span>2</span><span>,</span>  <span>y</span><span>=</span><span>42</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>The same technique can be used to implement optional arguments. To do this, simply let <code>pick</code> return a default if none of the argument pack’s elements was of the desired type.</p><h4 id="args-variable-template"><span><code>args</code> variable template</span><a href="#args-variable-template"><i></i></a></h4><p>To further improve upon this, we want to eliminate the error-prone and somewhat unpleasant need to define helpers out-of-line first. Since they are all of the same type, we can instead use a single variable template <code>arg</code>:</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>util</span><span>::</span><span>fixed_string</span> <span>Name</span><span>&gt;</span>
<span>constexpr</span> <span>inline</span> <span>Arg</span><span>&lt;</span><span>Name</span><span>&gt;</span> <span>arg</span><span>{};</span>
</pre></td></tr></tbody></table></code></p></div><p>This allows us to write code like this (<a href="https://godbolt.org/z/GP8GE3n8z">Run on Compiler Explorer</a>):</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>foo</span><span>(</span><span>arg</span><span>&lt;</span><span>&#34;x&#34;</span><span>&gt;</span> <span>=</span> <span>2</span><span>,</span> <span>arg</span><span>&lt;</span><span>&#34;y&#34;</span><span>&gt;</span> <span>=</span> <span>42</span><span>);</span>
<span>bar</span><span>(</span><span>12</span><span>,</span> <span>arg</span><span>&lt;</span><span>&#34;x&#34;</span><span>&gt;</span> <span>=</span> <span>10</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>However, that approach is still somewhat verbose. Also note that the space between <code>&gt;</code> and <code>=</code> is required to avoid parsing issues.</p><h4 id="user-defined-literal-operator-template"><span>User-defined literal operator template</span><a href="#user-defined-literal-operator-template"><i></i></a></h4><p>A user-defined <a href="https://en.cppreference.com/w/cpp/language/user_literal#Literal_operators">literal operator template</a> can be used to further streamline the syntax:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>template</span><span>&lt;</span><span>util</span><span>::</span><span>fixed_string</span> <span>Name</span><span>&gt;</span>
<span>constexpr</span> <span>Arg</span><span>&lt;</span><span>Name</span><span>&gt;</span> <span>operator</span> <span>&#34;&#34;</span><span>_arg</span><span>()</span> <span>{</span>
  <span>return</span> <span>{};</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Now, we can write:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>// optional keyword arguments</span>
<span>foo</span><span>(</span><span>&#34;x&#34;</span><span>_arg</span> <span>=</span> <span>2</span><span>,</span> <span>&#34;y&#34;</span><span>_arg</span> <span>=</span> <span>42</span><span>);</span>
<span>foo</span><span>(</span><span>&#34;x&#34;</span><span>_arg</span> <span>=</span> <span>2</span><span>);</span>

<span>// positional arguments and keyword arguments</span>
<span>bar</span><span>(</span><span>12</span><span>,</span> <span>&#34;x&#34;</span><span>_arg</span> <span>=</span> <span>10</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://godbolt.org/z/5oPTdsKbz">Run on Compiler Explorer</a></p><p>This might be a little prettier than the previous example, but it’s still rather verbose. However, if we want the desired syntax back we could still write:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>constexpr</span> <span>inline</span> <span>auto</span> <span>x</span> <span>=</span> <span>&#34;x&#34;</span><span>_arg</span><span>;</span>
<span>constexpr</span> <span>inline</span> <span>auto</span> <span>y</span> <span>=</span> <span>&#34;y&#34;</span><span>_arg</span><span>;</span>

<span>foo</span><span>(</span><span>x</span><span>=</span><span>2</span><span>,</span> <span>y</span><span>=</span><span>3</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><h2 id="a-reflective-approach"><span>A reflective approach</span><a href="#a-reflective-approach"><i></i></a></h2><p>So.. can we do any better with reflection?</p><p><a href="https://pjg1.site/assets/img/reflection-reflection-everywhere.jpg"><img src="https://pjg1.site/assets/img/reflection-reflection-everywhere.jpg" alt="Reflection, reflection everywhere!" loading="lazy"/></a></p><p>While we might not be able to provide the desired syntax <code>foo(3, x=5)</code> directly, reflection allows us to inject new class types with named non-static data members. For all intents and purposes the keyword arguments are therefore collected into a named tuple.</p><p>This means we can constrain the receiving function to express non-optionality of keyword arguments:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
  <span>requires</span> <span>requires</span><span>(</span><span>T</span> <span>kwargs</span><span>)</span> <span>{</span>
    <span>{</span> <span>kwargs</span><span>.</span><span>x</span> <span>}</span> <span>-&gt;</span> <span>std</span><span>::</span><span>convertible_to</span><span>&lt;</span><span>int</span><span>&gt;</span><span>;</span>
    <span>{</span> <span>kwargs</span><span>.</span><span>y</span> <span>}</span> <span>-&gt;</span> <span>std</span><span>::</span><span>convertible_to</span><span>&lt;</span><span>int</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>void</span> <span>foo</span><span>(</span><span>erl</span><span>::</span><span>kwargs_t</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>const</span><span>&amp;</span> <span>kwargs</span><span>)</span> <span>{</span>
  <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;x: {} y: {}&#34;</span><span>,</span> <span>kwargs</span><span>.</span><span>x</span><span>,</span> <span>erl</span><span>::</span><span>get</span><span>&lt;</span><span>&#34;y&#34;</span><span>&gt;</span><span>(</span><span>kwargs</span><span>));</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://cpp26.godbolt.org/z/nT751eM9n">Run on compiler explorer</a></p><p>All keyword arguments that we require to exist can safely be accessed using member access syntax or <code>erl::get</code>.</p><p>Optional keyword arguments can be accessed with <code>erl::get_or</code> or a combination of <code>erl::get</code> with <code>erl::has_arg</code> or an inline requires expression:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
<span>void</span> <span>foo</span><span>(</span><span>erl</span><span>::</span><span>kwargs_t</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>const</span><span>&amp;</span> <span>kwargs</span><span>)</span> <span>{</span>
  <span>if</span> <span>constexpr</span> <span>(</span><span>erl</span><span>::</span><span>has_arg</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>&#34;x&#34;</span><span>))</span> <span>{</span>
    <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;x: {}&#34;</span><span>,</span> <span>get</span><span>&lt;</span><span>&#34;x&#34;</span><span>&gt;</span><span>(</span><span>kwargs</span><span>));</span>
  <span>}</span>

  <span>if</span> <span>constexpr</span> <span>(</span><span>requires</span> <span>{</span> <span>kwargs</span><span>.</span><span>y</span><span>;</span> <span>})</span> <span>{</span>
    <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;y: {}&#34;</span><span>,</span> <span>kwargs</span><span>.</span><span>y</span><span>);</span>
  <span>}</span>

  <span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;z: {}&#34;</span><span>,</span> <span>get_or</span><span>&lt;</span><span>&#34;z&#34;</span><span>&gt;</span><span>(</span><span>kwargs</span><span>,</span> <span>&#34;&lt;unmatched&gt;&#34;</span><span>));</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://cpp26.godbolt.org/z/9h3hnT5nx">Run on Compiler Explorer</a></p><p>To create the keyword argument tuple at the call site, we need to wrap all keyword arguments somehow - for this we will later introduce the macro <code>make_args</code>. This is how it can be used:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre><span>// optional keyword arguments</span>
<span>foo</span><span>(</span><span>make_args</span><span>(</span><span>y</span> <span>=</span> <span>42</span><span>,</span> <span>x</span> <span>=</span> <span>2</span><span>));</span>
<span>foo</span><span>(</span><span>make_args</span><span>(</span><span>x</span> <span>=</span> <span>2</span><span>));</span>

<span>// positional arguments and keyword arguments</span>
<span>bar</span><span>(</span><span>12</span><span>,</span> <span>make_args</span><span>(</span><span>x</span> <span>=</span> <span>10</span><span>));</span>

<span>// references</span>
<span>int</span> <span>const</span> <span>baz</span> <span>=</span> <span>24</span><span>;</span>
<span>bar</span><span>(</span><span>12</span><span>,</span> <span>make_args</span><span>(</span><span>&amp;</span><span>x</span> <span>=</span> <span>baz</span><span>));</span>

<span>// shorthand</span>
<span>int</span> <span>x</span> <span>=</span> <span>2</span><span>;</span>
<span>foo</span><span>(</span><span>make_args</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>=</span><span>23</span><span>));</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://cpp26.godbolt.org/z/36s4jnbdv">Run on Compiler Explorer</a></p><p>The order in which keyword arguments appear does not matter <em>and</em> we can use shorthands. If this reminds you of lambdas, you’re spot on.</p><h2 id="reflecting-lambda-closure-types"><span>Reflecting lambda closure types</span><a href="#reflecting-lambda-closure-types"><i></i></a></h2><p>Lambda captures are almost a perfect fit - their order does not matter, their type is deduced and lambdas introduce a class type with every capture corresponding to a non-static data member for us.</p><p>Unfortunately though lambda closures are neither decomposable through a structured binding (<a href="https://godbolt.org/z/Wrjq37Y61">unless you use GCC</a>) nor are lambda captures directly accessible outside of the lambda’s body.</p><p>Nevertheless, C++26 reflection allows us to reflect private members.</p><blockquote><p><strong>Expansion</strong></p><p>Since this blog post is mostly about <a href="https://wg21.link/p2996">P2996</a>, expansion statements (as proposed in <a href="https://wg21.link/p1306">P1306</a>) are not used. In lieu of expansion statements, we will instead use the <code>expand</code> helper. The syntax might look a little weird at first, but you’ll get used to it.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>//p1306 expansion statement</span>
<span>template</span> <span>for</span> <span>(</span><span>constexpr</span> <span>auto</span> <span>member</span> <span>:</span> <span>nonstatic_data_members_of</span><span>(</span><span>^^</span><span>Type</span><span>))</span> <span>{</span>
 <span>// ...</span>
<span>}</span>

<span>// roughly equivalent to</span>
<span>[</span><span>:</span><span>expand</span><span>(</span><span>nonstatic_data_members_of</span><span>(</span><span>^^</span><span>Type</span><span>))</span><span>:</span><span>]</span>
 <span>&gt;&gt;</span> <span>[]</span><span>&lt;</span><span>std</span><span>::</span><span>meta</span><span>::</span><span>info</span><span>...</span> <span>Member</span><span>&gt;</span> <span>{</span>
   <span>// ...</span>
 <span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>The implementation of <code>expand</code> looks roughly like this:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td><pre><span>namespace</span> <span>impl</span> <span>{</span>
<span>template</span> <span>&lt;</span><span>auto</span><span>...</span> <span>Vs</span><span>&gt;</span>
<span>struct</span> <span>Replicator</span> <span>{</span>
 <span>template</span> <span>&lt;</span><span>typename</span> <span>F</span><span>&gt;</span>
 <span>constexpr</span> <span>decltype</span><span>(</span><span>auto</span><span>)</span> <span>operator</span><span>&gt;&gt;</span><span>(</span><span>F</span> <span>fnc</span><span>)</span> <span>const</span> <span>{</span>
   <span>return</span> <span>fnc</span><span>.</span><span>template</span> <span>operator</span><span>()</span><span>&lt;</span><span>Vs</span><span>...&gt;();</span>
 <span>}</span>
<span>};</span>

<span>template</span> <span>&lt;</span><span>auto</span><span>...</span> <span>Vs</span><span>&gt;</span>
<span>constexpr</span> <span>static</span> <span>Replicator</span><span>&lt;</span><span>Vs</span><span>...</span><span>&gt;</span> <span>replicator</span><span>{};</span>
<span>}</span>  <span>// namespace impl</span>

<span>template</span> <span>&lt;</span><span>std</span><span>::</span><span>ranges</span><span>::</span><span>range</span> <span>R</span><span>&gt;</span>
<span>consteval</span> <span>auto</span> <span>expand</span><span>(</span><span>R</span> <span>const</span><span>&amp;</span> <span>range</span><span>)</span> <span>{</span>
 <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>meta</span><span>::</span><span>info</span><span>&gt;</span> <span>args</span><span>;</span>
 <span>for</span> <span>(</span><span>auto</span> <span>item</span> <span>:</span> <span>range</span><span>)</span> <span>{</span>
   <span>args</span><span>.</span><span>push_back</span><span>(</span><span>reflect_value</span><span>(</span><span>item</span><span>));</span>
 <span>}</span>
 <span>return</span> <span>substitute</span><span>(</span><span>^^</span><span>impl</span><span>::</span><span>replicator</span><span>,</span> <span>args</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>This has the added benefit of giving us the items as a pack.</p></blockquote><p>With <code>expand</code> we can now print some information about a lambda closure type, so let’s do that.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>int</span> <span>baz</span> <span>=</span> <span>42</span><span>;</span>
  <span>auto</span> <span>closure</span> <span>=</span> <span>[</span><span>x</span><span>=</span><span>420</span><span>,</span> <span>&amp;</span><span>bar</span> <span>=</span> <span>baz</span><span>]{};</span>
  <span>using</span> <span>closure_type</span> <span>=</span> <span>decltype</span><span>(</span><span>closure</span><span>);</span>

  <span>[</span><span>:</span><span>expand</span><span>(</span><span>nonstatic_data_members_of</span><span>(</span><span>^^</span><span>closure_type</span><span>))</span><span>:</span><span>]</span> <span>&gt;&gt;</span> <span>[</span><span>&amp;</span><span>]</span><span>&lt;</span><span>auto</span><span>...</span> <span>members</span><span>&gt;</span> <span>{</span>
    <span>(</span><span>std</span><span>::</span><span>println</span><span>(</span><span>&#34;has identifier: {} - type: {:&lt;5} - value: {}&#34;</span><span>,</span> 
                  <span>has_identifier</span><span>(</span><span>members</span><span>),</span>
                  <span>display_string_of</span><span>(</span><span>type_of</span><span>(</span><span>members</span><span>)),</span>
                  <span>closure</span><span>.[</span><span>:</span><span>members</span><span>:</span><span>]),</span> <span>...);</span>
  <span>};</span>
<span>}</span>

<span>// Output:</span>
<span>// has identifier: false - type: int   - value: 420</span>
<span>// has identifier: false - type: int &amp; - value: 42</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://cpp26.godbolt.org/z/W67WhrETq">Run on Compiler Explorer</a></p><p><a href="https://pjg1.site/assets/img/private_properties.jpg"><img src="https://pjg1.site/assets/img/private_properties.jpg" alt="private properties" loading="lazy"/></a></p><p>Good news, <del>we can reuse Java memes</del> we can get types of lambda captures and references are properly handled. Even better, we can splice in the respective member to access captures outside of the lambda (for now.. see <a href="https://wg21.link/p3473">P3587</a>). Bad news though, the members are all unnamed.</p><blockquote><p><strong>Order of captures</strong></p><p>Note that <a href="https://standards.pydong.org/c++/expr.prim.lambda.capture#10">[expr.prim.lambda.capture]/10</a> makes the declaration order of the lambda closure’s members <strong>unspecified</strong>. While the following hackery with lambdas might work, it is not guaranteed.</p></blockquote><h2 id="parsing-the-capture-list"><span>Parsing the capture list</span><a href="#parsing-the-capture-list"><i></i></a></h2><p>To work around the lack of member names, we can stringify the capture list and parse it to recover the member names from it. To do this, we introduce the macro <code>make_args</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>namespace</span> <span>kwargs</span> <span>{</span>
<span>template</span> <span>&lt;</span><span>fixed_string</span> <span>str</span><span>,</span> <span>typename</span> <span>T</span><span>&gt;</span>
<span>auto</span> <span>from_lambda</span><span>(</span><span>T</span><span>&amp;&amp;</span> <span>captures</span><span>)</span> <span>{</span>
  <span>// ...</span>
<span>}</span>
<span>}</span>

<span>#define make_args(...) ::kwargs::from_lambda&lt;#__VA_ARGS__&gt;([__VA_ARGS__] {})
</span></pre></td></tr></tbody></table></code></p></div><p>Let’s address the elephant in the room - parsing even a subset of C++ correctly is difficult. Lambda capture lists can be highly complex, but the vast majority of “odd” ones aren’t really meaningful in the context of named arguments. This allows us to limit the scope of our parser.</p><p>We obviously want to support captures of the form <code>arg1 = 123, arg2 = ident</code>, but it would also be nice to allow for shorthands such as <code>x,y</code> - which would be equivalent to <code>x=x,y=y</code> in a lambda’s capture list.</p><p>Additionally, capturing arguments by reference is sometimes necessary. Our parser must therefore handle cases like <code>&amp;foo = bar</code> or <code>&amp;foo</code> without failing. This leaves us with two grammar rules:</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>capture-list  ::= capture (&#34;,&#34; capture)* ;
capture       ::= [&#34;&amp;&#34;] identifier [ &#34;=&#34; expression ] ;
</pre></td></tr></tbody></table></code></p></div><h3 id="utilities"><span>Utilities</span><a href="#utilities"><i></i></a></h3><p>Unfortunately, parsing expressions is still unavoidable since they can contain commas, as in <code>foo(1, 2)</code>, <code>Foo{1, 2}</code> or <code>foo[1, 2]</code>. However, since we do not actually need to understand the expressions, it’s sufficient to ensure we do not prematurely stop on a <code>,</code> inside unbalanced curly braces, parentheses or square brackets when skipping forward to the next capture.</p><p>Let’s start by defining a <code>Parser</code> base class:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>struct</span> <span>Parser</span> <span>{</span>
  <span>std</span><span>::</span><span>string_view</span> <span>data</span><span>;</span>
  <span>std</span><span>::</span><span>size_t</span> <span>cursor</span><span>{</span><span>0</span><span>};</span>

  <span>[[</span><span>nodiscard</span><span>]]</span> <span>constexpr</span> <span>char</span> <span>current</span><span>()</span> <span>const</span> <span>{</span> <span>return</span> <span>data</span><span>[</span><span>cursor</span><span>];</span> <span>}</span>
  <span>[[</span><span>nodiscard</span><span>]]</span> <span>constexpr</span> <span>bool</span> <span>is_valid</span><span>()</span> <span>const</span> <span>{</span> <span>return</span> <span>cursor</span> <span>&lt;</span> <span>data</span><span>.</span><span>length</span><span>();</span> <span>}</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><p>The desired utility can now be implemented. Since it does not matter if the code we parse is syntactically valid, counting <code>(]</code> the same way as <code>()</code> is fine.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>constexpr</span> <span>void</span> <span>skip_to</span><span>(</span><span>std</span><span>::</span><span>same_as</span><span>&lt;</span><span>char</span><span>&gt;</span> <span>auto</span><span>...</span> <span>needles</span><span>)</span> <span>{</span>
  <span>int</span> <span>brace_count</span> <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span>(</span><span>is_valid</span><span>())</span> <span>{</span>
    <span>if</span> <span>(</span><span>char</span> <span>c</span> <span>=</span> <span>current</span><span>();</span> <span>brace_count</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>((</span><span>c</span> <span>==</span> <span>needles</span><span>)</span> <span>||</span> <span>...))</span> <span>{</span>
      <span>break</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;[&#39;</span> <span>||</span> <span>c</span> <span>==</span> <span>&#39;{&#39;</span> <span>||</span> <span>c</span> <span>==</span> <span>&#39;(&#39;</span><span>)</span> <span>{</span>
      <span>++</span><span>brace_count</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;]&#39;</span> <span>||</span> <span>c</span> <span>==</span> <span>&#39;}&#39;</span> <span>||</span> <span>c</span> <span>==</span> <span>&#39;)&#39;</span><span>)</span> <span>{</span>
      <span>--</span><span>brace_count</span><span>;</span>
    <span>}</span>
    <span>++</span><span>cursor</span><span>;</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Since whitespace is also often not significant, another utility function to skip whitespace - let’s call it <code>skip_whitespace</code> - is also very useful. Since its implementation is trivial, it is omitted here.</p><h3 id="implementing-the-parser"><span>Implementing the parser</span><a href="#implementing-the-parser"><i></i></a></h3><p>At this point, it’s also advisable to reject various captures that would not make sense for our use case. These include:</p><div><table><thead><tr><th>Capture Kind</th><th>Reasoning</th></tr></thead><tbody><tr><td>Capturing <code>this</code></td><td>A member cannot be named <code>this</code>, so injecting the container would fail.</td></tr><tr><td>Default captures <code>=</code> and <code>&amp;</code></td><td>Since the lambda’s body is empty, these would not capture anything.</td></tr><tr><td>Packs <code>...foo</code></td><td>Every argument must have a name for keyword argument handling.</td></tr></tbody></table></div><p>With the aforementioned utilities, the actual capture list parser can now be implemented as follows:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td><pre><span>struct</span> <span>NameParser</span> <span>:</span> <span>Parser</span> <span>{</span>
  <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>string_view</span><span>&gt;</span> <span>names</span><span>;</span>
  <span>constexpr</span> <span>bool</span> <span>parse</span><span>()</span> <span>{</span>
    <span>while</span> <span>(</span><span>is_valid</span><span>())</span> <span>{</span>
      <span>skip_whitespace</span><span>();</span>

      <span>if</span> <span>(</span><span>current</span><span>()</span> <span>==</span> <span>&#39;&amp;&#39;</span><span>)</span> <span>{</span>
        <span>// might be captured by reference</span>
        <span>++</span><span>cursor</span><span>;</span>
        <span>skip_whitespace</span><span>();</span>
      <span>}</span>

      <span>if</span> <span>(</span><span>current</span><span>()</span> <span>==</span> <span>&#39;.&#39;</span><span>)</span> <span>{</span>
        <span>// pack captured, reject</span>
        <span>return</span> <span>false</span><span>;</span>
      <span>}</span>

      <span>auto</span> <span>start</span> <span>=</span> <span>cursor</span><span>;</span>
      <span>// find `=`, `,` or whitespace</span>
      <span>skip_to</span><span>(</span><span>&#39;=&#39;</span><span>,</span> <span>&#39;,&#39;</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>&#39;\r&#39;</span><span>,</span> <span>&#39;\n&#39;</span><span>,</span> <span>&#39;\t&#39;</span><span>);</span>

      <span>// retrieve the name</span>
      <span>if</span> <span>(</span><span>cursor</span> <span>-</span> <span>start</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>// default capture or invalid name</span>
        <span>return</span> <span>false</span><span>;</span>
      <span>}</span>

      <span>auto</span> <span>name</span> <span>=</span> <span>data</span><span>.</span><span>substr</span><span>(</span><span>start</span><span>,</span> <span>cursor</span> <span>-</span> <span>start</span><span>);</span>
      <span>if</span> <span>(</span><span>name</span> <span>==</span> <span>&#34;this&#34;</span> <span>||</span> <span>name</span> <span>==</span> <span>&#34;*this&#34;</span><span>)</span> <span>{</span>
        <span>// this captured, reject</span>
        <span>return</span> <span>false</span><span>;</span>
      <span>}</span>
      <span>names</span><span>.</span><span>push_back</span><span>(</span><span>name</span><span>);</span>
      
      <span>// skip ahead to next capture</span>
      <span>// this won&#39;t move the cursor if the current character is already `,`</span>
      <span>skip_to</span><span>(</span><span>&#39;,&#39;</span><span>);</span>
      <span>++</span><span>cursor</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><blockquote><p><strong>Constexpr Exceptions</strong></p><p><a href="https://wg21.link/p3068">P3068</a> proposes support for exceptions during constant evaluation. If accepted, we could make <code>names</code> a local variable and have <code>parse</code> return it. Invalid captures could then be rejected by throwing an exception.</p></blockquote><h2 id="injecting-the-kwargs-container-type"><span>Injecting the kwargs container type</span><a href="#injecting-the-kwargs-container-type"><i></i></a></h2><p>Since we now know the names for the lambda’s unnamed members, we can inject an aggregate class type with <strong>named</strong> members of appropriate type for every capture of the lambda.</p><p>First, we need to parse the stringified capture list and create data member specifications that associate each non-static data member of the lambda closure with its corresponding name. This can then be used to inject the keyword argument container type.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>Impl</span><span>&gt;</span>
<span>struct</span> <span>[[</span><span>nodiscard</span><span>]]</span> <span>kwargs_t</span> <span>:</span> <span>Impl</span> <span>{</span>
  <span>using</span> <span>type</span> <span>=</span> <span>Impl</span><span>;</span>
<span>};</span>

<span>template</span> <span>&lt;</span><span>util</span><span>::</span><span>fixed_string</span> <span>Names</span><span>,</span> <span>typename</span><span>...</span> <span>Ts</span><span>&gt;</span>
<span>constexpr</span> <span>auto</span> <span>make</span><span>(</span><span>Ts</span><span>&amp;&amp;</span><span>...</span> <span>values</span><span>)</span> <span>{</span>
  <span>struct</span> <span>kwargs_impl</span><span>;</span>
  <span>consteval</span> <span>{</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>meta</span><span>::</span><span>info</span><span>&gt;</span> <span>types</span><span>{</span><span>^^</span><span>Ts</span><span>...};</span>
    <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>meta</span><span>::</span><span>info</span><span>&gt;</span> <span>args</span><span>;</span>

    <span>auto</span> <span>parser</span> <span>=</span> <span>NameParser</span><span>{</span><span>Names</span><span>.</span><span>to_sv</span><span>()};</span>
    <span>if</span><span>(</span><span>!</span><span>parser</span><span>.</span><span>parse</span><span>())</span> <span>{</span>
        <span>// name list rejected or parsing error, abort</span>
        <span>return</span><span>;</span>
    <span>}</span>

    <span>// associate every argument with the corresponding name</span>
    <span>// retrieved by parsing the capture list</span>
    <span>for</span> <span>(</span><span>auto</span> <span>[</span><span>member</span><span>,</span> <span>name</span><span>]</span> <span>:</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>zip</span><span>(</span><span>types</span><span>,</span> <span>parser</span><span>.</span><span>names</span><span>))</span> <span>{</span>
        <span>args</span><span>.</span><span>push_back</span><span>(</span><span>data_member_spec</span><span>(</span><span>member</span><span>,</span> <span>{.</span><span>name</span> <span>=</span> <span>name</span><span>}));</span>
    <span>}</span>
    <span>define_aggregate</span><span>(</span><span>^^</span><span>kwargs_impl</span><span>,</span> <span>args</span><span>);</span>
  <span>};</span>

  <span>// ensure injecting the class worked</span>
  <span>static_assert</span><span>(</span><span>is_type</span><span>(</span><span>^^</span><span>kwargs_impl</span><span>),</span> <span>&#34;Could not inject named argument class&#34;</span><span>);</span>

  <span>return</span> <span>kwargs_t</span><span>&lt;</span><span>kwargs_impl</span><span>&gt;</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>At this point <code>make&lt;&#34;x,y&#34;&gt;(123, &#34;foo&#34;)</code> can already be used to make named arguments <code>x=123</code> and <code>y=&#34;foo&#34;</code> without the use of lambdas.</p><p>For the lambda hackery to work, we need to reflect the lambda’s private non-static data members to produce an appropriate keyword argument container. Finally we need to extract these members from the lambda produced by the <code>make_args</code> macro.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>util</span><span>::</span><span>fixed_string</span> <span>Names</span><span>,</span> <span>typename</span> <span>T</span><span>&gt;</span>
<span>auto</span> <span>from_lambda</span><span>(</span><span>T</span><span>&amp;&amp;</span> <span>lambda</span><span>)</span> <span>{</span>
  <span>using</span> <span>fnc_t</span> <span>=</span> <span>std</span><span>::</span><span>remove_cvref_t</span><span>&lt;</span><span>T</span><span>&gt;</span><span>;</span>

  <span>return</span> <span>[</span><span>:</span><span>meta</span><span>::</span><span>expand</span><span>(</span><span>nonstatic_data_members_of</span><span>(</span><span>^^</span><span>fnc_t</span><span>))</span><span>:</span><span>]</span>
    <span>&gt;&gt;</span> <span>[</span><span>&amp;</span><span>]</span><span>&lt;</span><span>auto</span><span>...</span> <span>member</span><span>&gt;</span><span>()</span> <span>{</span>
      <span>return</span> <span>make</span><span>&lt;</span><span>Names</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>lambda</span><span>).[</span><span>:</span><span>member</span><span>:</span><span>]...);</span>
    <span>};</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>As mentioned before, to simplify usage on the receiving side, <code>kwargs_t&lt;T&gt;</code> should also implement the <a href="https://en.cppreference.com/w/cpp/utility/tuple/tuple-like">tuple protocol</a>. This means we need to provide specializations for <code>std::tuple_size</code> and <code>std::tuple_element</code>. Also we’ll need to implement <code>get</code> for <code>kwargs_t&lt;T&gt;</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
<span>struct</span> <span>std</span><span>::</span><span>tuple_size</span><span>&lt;</span><span>kwargs_t</span><span>&lt;</span><span>T</span><span>&gt;&gt;</span>
  <span>:</span> <span>public</span> <span>integral_constant</span><span>&lt;</span><span>size_t</span><span>,</span>
      <span>nonstatic_data_members_of</span><span>(</span><span>^^</span><span>std</span><span>::</span><span>remove_cvref_t</span><span>&lt;</span><span>T</span><span>&gt;</span><span>).</span><span>size</span><span>()</span><span>&gt;</span><span>{};</span>

<span>template</span> <span>&lt;</span><span>std</span><span>::</span><span>size_t</span> <span>I</span><span>,</span> <span>typename</span> <span>T</span><span>&gt;</span>
<span>struct</span> <span>std</span><span>::</span><span>tuple_element</span><span>&lt;</span><span>I</span><span>,</span> <span>kwargs_t</span><span>&lt;</span><span>T</span><span>&gt;&gt;</span> <span>{</span>
  <span>using</span> <span>type</span> <span>=</span> <span>[</span><span>:</span><span>get_nth_field</span><span>(</span><span>^^</span><span>T</span><span>,</span> <span>I</span><span>)</span><span>:</span><span>];</span>
<span>};</span>

<span>template</span> <span>&lt;</span><span>std</span><span>::</span><span>size_t</span> <span>I</span><span>,</span> <span>typename</span> <span>T</span><span>&gt;</span>
<span>constexpr</span> <span>auto</span> <span>get</span><span>(</span><span>kwargs_t</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>const</span><span>&amp;</span> <span>t</span><span>)</span> <span>noexcept</span> <span>{</span>
  <span>return</span> <span>t</span><span>.[</span><span>:</span><span>get_nth_field</span><span>(</span><span>^^</span><span>T</span><span>,</span> <span>I</span><span>)</span><span>:</span><span>];</span>
<span>}</span>

</pre></td></tr></tbody></table></code></p></div><p>Additionally, we want to be able to retrieve keyword arguments by name. Since this might fail, it can be useful to return a default value when no member with the requested name is found. For this, we introduce <code>get_or</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>fixed_string</span> <span>name</span><span>,</span> <span>typename</span> <span>T</span><span>&gt;</span>
<span>constexpr</span> <span>auto</span> <span>get_or</span><span>(</span><span>kwargs_t</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>const</span><span>&amp;</span> <span>t</span><span>)</span> <span>{</span>
  <span>return</span> <span>t</span><span>.[</span><span>:</span><span>get_nth_field</span><span>(</span><span>^^</span><span>T</span><span>,</span> <span>get_member_index</span><span>(</span><span>name</span><span>.</span><span>to_sv</span><span>()))</span><span>:</span><span>];</span>
<span>}</span>

<span>template</span> <span>&lt;</span><span>fixed_string</span> <span>name</span><span>,</span> <span>typename</span> <span>T</span><span>,</span> <span>typename</span> <span>R</span><span>&gt;</span>
<span>constexpr</span> <span>auto</span> <span>get_or</span><span>(</span><span>kwargs_t</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>const</span><span>&amp;</span> <span>t</span><span>,</span> <span>R</span> <span>default_</span><span>)</span> <span>{</span>
  <span>if</span> <span>constexpr</span> <span>(</span><span>get_member_index</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>name</span><span>.</span><span>to_sv</span><span>())</span> <span>==</span> <span>-</span><span>1U</span><span>Z</span><span>)</span> <span>{</span>
    <span>return</span> <span>default_</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span>t</span><span>.[</span><span>:</span><span>get_nth_field</span><span>(</span><span>^^</span><span>T</span><span>,</span> <span>get_member_index</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>name</span><span>.</span><span>to_sv</span><span>()))</span><span>:</span><span>];</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><h2 id="function-parameter-reflection"><span>Function parameter reflection</span><a href="#function-parameter-reflection"><i></i></a></h2><p>What if we could wrap any function and convert keyword arguments to positional arguments in calls to it as needed? Thanks to <a href="https://wg21.link/p3096">P3096</a> function parameter reflection, this would also be possible.</p><p>Essentially, we want to be able to write the following:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>void</span> <span>foo_impl</span><span>(</span><span>int</span> <span>x</span><span>,</span> <span>char</span> <span>c</span><span>,</span> <span>double</span> <span>d</span><span>)</span> <span>{</span>
  <span>printf</span><span>(</span><span>&#34;x: %d c: %c d: %f</span><span>\n</span><span>&#34;</span><span>,</span> <span>x</span><span>,</span> <span>c</span><span>,</span> <span>d</span><span>);</span>
<span>}</span>
<span>constexpr</span> <span>inline</span> <span>erl</span><span>::</span><span>kwargs</span><span>::</span><span>Wrap</span><span>&lt;^^</span><span>foo_impl</span><span>&gt;</span> <span>foo</span><span>;</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>foo</span><span>(</span><span>3</span><span>,</span> <span>&#39;c&#39;</span><span>,</span> <span>2.2</span><span>);</span>
  <span>foo</span><span>(</span><span>3</span><span>,</span> <span>&#39;c&#39;</span><span>,</span> <span>make_args</span><span>(</span><span>d</span> <span>=</span> <span>2.2</span><span>));</span>
  <span>foo</span><span>(</span><span>3</span><span>,</span> <span>make_args</span><span>(</span><span>c</span> <span>=</span> <span>&#39;c&#39;</span><span>,</span> <span>d</span> <span>=</span> <span>2.2</span><span>));</span>
  <span>foo</span><span>(</span><span>make_args</span><span>(</span><span>c</span> <span>=</span> <span>&#39;c&#39;</span><span>,</span> <span>x</span> <span>=</span> <span>3</span><span>,</span> <span>d</span> <span>=</span> <span>2.2</span><span>));</span>

  <span>// error: Argument `d` missing.</span>
  <span>// foo(3, make_args(c = &#39;c&#39;));</span>

  <span>// error: Positional argument `x` repeated as keyword argument.</span>
  <span>// foo(3, make_args(x = 4));</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://cpp26.godbolt.org/z/qoaPYd8Te">Run on Compiler Explorer</a></p><blockquote><p>Note that this only works with free functions and static member functions. Function templates and function objects are <strong>not supported</strong>.</p></blockquote><h3 id="implementation"><span>Implementation</span><a href="#implementation"><i></i></a></h3><p>Unfortunately non-trailing packs are not deduced. If our keyword argument tuple were the first parameter this would be trivial, but realistically that does not look very nice and would also be inconsistent with our previous mixed usage.</p><p>Consider the following example (<a href="https://godbolt.org/z/4fYq8aPzc">Run on Compiler Explorer</a>):</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span><span>...</span> <span>Args</span><span>,</span> <span>typename</span> <span>T</span><span>&gt;</span>
<span>void</span> <span>foo</span><span>(</span><span>Args</span><span>...</span> <span>args</span><span>,</span> <span>T</span> <span>kwargs</span><span>);</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>foo</span><span>&lt;</span><span>int</span><span>&gt;</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>);</span> <span>// OK</span>

  <span>// Args... = &lt;&gt;, T = int</span>
  <span>// error: no matching function for call to &#39;foo&#39;</span>
  <span>foo</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p><a href="https://wg21.link/p2347">P2347</a> solves this issue, for more information please refer to cor3ntin’s amazing <a href="https://cor3ntin.github.io/posts/variadic/">blog post about it</a>.</p><h4 id="pack-indexing"><span>Pack indexing</span><a href="#pack-indexing"><i></i></a></h4><p>To circumvent this limitation, we can leverage <a href="https://wg21.link/p2662">P2662</a> pack indexing to extract the last argument, which allows us to check if it is a keyword argument container.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>std</span><span>::</span><span>meta</span><span>::</span><span>info</span> <span>F</span><span>&gt;</span>
<span>requires</span> <span>(</span><span>is_function</span><span>(</span><span>F</span><span>))</span>
<span>struct</span> <span>Wrap</span> <span>{</span>
  <span>template</span> <span>&lt;</span><span>typename</span><span>...</span> <span>Args</span><span>&gt;</span>
    <span>requires</span> <span>(</span><span>sizeof</span><span>...(</span><span>Args</span><span>)</span> <span>&gt;</span> <span>0</span><span>)</span>
  <span>static</span> <span>constexpr</span> <span>decltype</span><span>(</span><span>auto</span><span>)</span> <span>operator</span><span>()(</span><span>Args</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>{</span>
    <span>using</span> <span>T</span> <span>=</span> <span>std</span><span>::</span><span>remove_cvref_t</span><span>&lt;</span><span>Args</span><span>...[</span><span>pos_only</span><span>]</span><span>&gt;</span><span>;</span>

    <span>if</span> <span>constexpr</span> <span>(</span><span>erl</span><span>::</span><span>is_kwargs</span><span>&lt;</span><span>T</span><span>&gt;</span><span>)</span> <span>{</span>
      <span>// handle keyword arguments</span>
      <span>// ...</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// no keyword arguments</span>
      <span>return</span> <span>[</span><span>:</span><span>F</span><span>:</span><span>](</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...);</span>
    <span>}</span>
  <span>}</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><h4 id="combining-positional-and-keyword-arguments"><span>Combining positional and keyword arguments</span><a href="#combining-positional-and-keyword-arguments"><i></i></a></h4><p>To properly merge the received positional arguments with the given keyword arguments, we need to:</p><ul><li>Expand <code>args</code> <strong>except for the last element</strong></li><li>Extract the remaining parameters of <code>F</code> from the last element of <code>args</code> (the keyword argument container)</li></ul><blockquote><p><strong>Expansion</strong></p><p>For the following to work, one adjustment to the aforementioned <code>expand</code> helper must be made.</p><p><code>Replicator</code>’s <code>operator&gt;&gt;</code> expands all elements of the range into the template argument list of a single call to the given lambda. Similarly we want <code>operator&gt;&gt;=</code> to call the lambda once per element, passing one template argument at a time.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>auto</span><span>...</span> <span>Vs</span><span>&gt;</span>
<span>struct</span> <span>Replicator</span> <span>{</span>
 <span>template</span> <span>&lt;</span><span>typename</span> <span>F</span><span>&gt;</span>
 <span>constexpr</span> <span>decltype</span><span>(</span><span>auto</span><span>)</span> <span>operator</span><span>&gt;&gt;</span><span>(</span><span>F</span> <span>fnc</span><span>)</span> <span>const</span> <span>{</span>
   <span>return</span> <span>fnc</span><span>.</span><span>template</span> <span>operator</span><span>()</span><span>&lt;</span><span>Vs</span><span>...&gt;();</span>
 <span>}</span>

 <span>template</span> <span>&lt;</span><span>typename</span> <span>F</span><span>&gt;</span>
 <span>constexpr</span> <span>void</span> <span>operator</span><span>&gt;&gt;=</span><span>(</span><span>F</span> <span>fnc</span><span>)</span> <span>const</span> <span>{</span>
   <span>(</span><span>fnc</span><span>.</span><span>template</span> <span>operator</span><span>()</span><span>&lt;</span><span>Vs</span><span>&gt;(),</span> <span>...);</span>
 <span>}</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><p>Additionally, we introduce a shorthand <code>sequence(N)</code>, which is equivalent to <code>expand(std::ranges::iota_view{0U, N})</code>.</p></blockquote><p>To do this, we need two nested expansions. The first expansion must expand the reflected parameters of <code>F</code>, except for the first <code>sizeof...(Args) - 1</code> parameters. The second expansion shall expand an integer sequence from <code>0</code> to <code>sizeof...(Args) - 1</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>static</span> <span>constexpr</span> <span>std</span><span>::</span><span>size_t</span> <span>pos_only</span> <span>=</span> <span>sizeof</span><span>...(</span><span>Args</span><span>)</span> <span>-</span> <span>1</span><span>;</span>

<span>return</span> <span>[</span><span>:</span><span>meta</span><span>::</span><span>expand</span><span>(</span><span>parameters_of</span><span>(</span><span>F</span><span>)</span> <span>|</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>drop</span><span>(</span><span>pos_only</span><span>))</span><span>:</span><span>]</span> 
<span>&gt;&gt;</span> <span>[</span><span>&amp;</span><span>]</span><span>&lt;</span><span>auto</span><span>...</span> <span>Params</span><span>&gt;</span> <span>{</span>
  <span>return</span> <span>[</span><span>:</span><span>meta</span><span>::</span><span>sequence</span><span>(</span><span>pos_only</span><span>)</span><span>:</span><span>]</span>
  <span>&gt;&gt;</span> <span>[</span><span>&amp;</span><span>]</span><span>&lt;</span><span>std</span><span>::</span><span>size_t</span><span>...</span> <span>Idx</span><span>&gt;</span> <span>{</span>
    <span>return</span> <span>[</span><span>:</span><span>F</span><span>:</span><span>](</span>
      <span>/* positional arguments */</span>
      <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>...[</span><span>Idx</span><span>]</span><span>&gt;</span><span>(</span><span>args</span><span>...[</span><span>Idx</span><span>])...,</span> 
      <span>/* keyword arguments */</span>
      <span>get</span><span>&lt;</span><span>meta</span><span>::</span><span>get_member_index</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>identifier_of</span><span>(</span><span>Params</span><span>))</span><span>&gt;</span><span>(</span><span>args</span><span>...[</span><span>pos_only</span><span>])...);</span>
  <span>};</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><h4 id="adding-diagnostics"><span>Adding diagnostics</span><a href="#adding-diagnostics"><i></i></a></h4><p>We also want to detect and report errors when:</p><ul><li>A positional argument is repeated as keyword argument</li><li>A required argument was missing altogether</li></ul><p>For this we can use <code>expand</code> in combination with the <code>&gt;&gt;=</code> operator to look at <code>F</code>’s parameters one at a time. Also <a href="https://wg21.link/p2741">p2741</a> can be used at this point to provide very nice diagnostics.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>,</span> <span>std</span><span>::</span><span>size_t</span> <span>PosOnly</span> <span>=</span> <span>0</span><span>&gt;</span>
<span>static</span> <span>constexpr</span> <span>void</span> <span>check_args</span><span>()</span> <span>{</span>
  <span>[</span><span>:</span><span>erl</span><span>::</span><span>meta</span><span>::</span><span>expand</span><span>(</span><span>parameters_of</span><span>(</span><span>F</span><span>)</span> <span>|</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>take</span><span>(</span><span>PosOnly</span><span>))</span><span>:</span><span>]</span> 
  <span>&gt;&gt;=</span> <span>[</span><span>&amp;</span><span>]</span><span>&lt;</span><span>auto</span> <span>Param</span><span>&gt;</span> <span>{</span>
    <span>static_assert</span><span>(</span><span>!</span><span>erl</span><span>::</span><span>meta</span><span>::</span><span>has_member</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>identifier_of</span><span>(</span><span>Param</span><span>)),</span>
      <span>std</span><span>::</span><span>string</span><span>{}</span> <span>+</span> <span>&#34;In call to `&#34;</span> <span>+</span> <span>identifier_of</span><span>(</span><span>F</span><span>)</span> <span>+</span> <span>&#34;`: &#34;</span>
      <span>&#34;Positional argument `&#34;</span> <span>+</span> <span>identifier_of</span><span>(</span><span>Param</span><span>)</span> <span>+</span> <span>&#34;` &#34;</span>
      <span>&#34;repeated as keyword argument.&#34;</span>
    <span>);</span>
  <span>};</span>

  <span>[</span><span>:</span><span>erl</span><span>::</span><span>meta</span><span>::</span><span>expand</span><span>(</span><span>parameters_of</span><span>(</span><span>F</span><span>)</span> <span>|</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>drop</span><span>(</span><span>PosOnly</span><span>))</span><span>:</span><span>]</span> 
  <span>&gt;&gt;=</span> <span>[</span><span>&amp;</span><span>]</span><span>&lt;</span><span>auto</span> <span>Param</span><span>&gt;</span> <span>{</span>
    <span>static_assert</span><span>(</span><span>erl</span><span>::</span><span>meta</span><span>::</span><span>has_member</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>identifier_of</span><span>(</span><span>Param</span><span>)),</span>
      <span>&#34;In call to `&#34;</span> <span>+</span> <span>std</span><span>::</span><span>string</span><span>(</span><span>identifier_of</span><span>(</span><span>F</span><span>))</span> <span>+</span> <span>&#34;`: &#34;</span>
      <span>&#34;Argument `&#34;</span> <span>+</span> <span>identifier_of</span><span>(</span><span>Param</span><span>)</span> <span>+</span> <span>&#34;` missing.&#34;</span>
    <span>);</span>
  <span>};</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><h2 id="bonus-format-strings-with-named-arguments"><span>Bonus: Format strings with named arguments</span><a href="#bonus-format-strings-with-named-arguments"><i></i></a></h2><p>Aside from positional arguments, the awesome <code>fmt</code> library also allows for named arguments. You might be able to recognize the approach used in <code>fmt</code>, here’s what the code would look like:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>fmt</span><span>::</span><span>print</span><span>(</span><span>&#34;Hello, {name}! The answer is {number}. Goodbye, {name}.&#34;</span><span>,</span>
           <span>fmt</span><span>::</span><span>arg</span><span>(</span><span>&#34;name&#34;</span><span>,</span> <span>&#34;World&#34;</span><span>),</span> <span>fmt</span><span>::</span><span>arg</span><span>(</span><span>&#34;number&#34;</span><span>,</span> <span>42</span><span>));</span>

<span>// alternatively</span>
<span>using</span> <span>namespace</span> <span>fmt</span><span>::</span><span>literals</span><span>;</span>
<span>fmt</span><span>::</span><span>print</span><span>(</span><span>&#34;Hello, {name}! The answer is {number}. Goodbye, {name}.&#34;</span><span>,</span>
           <span>&#34;name&#34;</span><span>_a</span><span>=</span><span>&#34;World&#34;</span><span>,</span> <span>&#34;number&#34;</span><span>_a</span><span>=</span><span>42</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>Let’s implement similar functionality using <code>erl::kwargs_t</code>.</p><h3 id="transforming-the-format-string"><span>Transforming the format string</span><a href="#transforming-the-format-string"><i></i></a></h3><p>Since <code>std::format</code> does not yet support named arguments like <code>fmt</code>, we need to transform the format string into a format that <code>std::format</code> understands.</p><p><code>std::format</code> allows referring to arguments by position (e.g. <code>std::format(&#34;{1}{0}&#34;, 0, 42)</code>). We can therefore expand all keyword arguments into the <code>std::format</code> call’s argument list and transform the format string so it refers to them by position rather than by name.</p><p>The parser utilities we defined earlier can be re-used to transform the format string. Here’s an example implementation:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td><pre><span>struct</span> <span>FmtParser</span> <span>:</span> <span>Parser</span> <span>{</span>
  <span>constexpr</span> <span>std</span><span>::</span><span>string</span> <span>transform</span><span>(</span><span>std</span><span>::</span><span>ranges</span><span>::</span><span>forward_range</span> <span>auto</span><span>&amp;&amp;</span> <span>names</span><span>)</span> <span>{</span>
    <span>std</span><span>::</span><span>string</span> <span>out</span><span>;</span>
    <span>int</span> <span>brace_count</span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span><span>is_valid</span><span>())</span> <span>{</span>
      <span>out</span> <span>+=</span> <span>current</span><span>();</span>

      <span>if</span> <span>(</span><span>current</span><span>()</span> <span>==</span> <span>&#39;{&#39;</span><span>)</span> <span>{</span>
        <span>++</span><span>cursor</span><span>;</span>

        <span>if</span> <span>(</span><span>current</span><span>()</span> <span>==</span> <span>&#39;{&#39;</span><span>)</span> <span>{</span>
          <span>// double curly braces means escaped curly braces</span>
          <span>// =&gt; treat the content as text</span>
          <span>auto</span> <span>start</span> <span>=</span> <span>cursor</span><span>;</span>
          <span>// skip to first unbalanced }</span>
          <span>// this will match the outer {</span>
          <span>skip_to</span><span>(</span><span>&#39;}&#39;</span><span>);</span>
          <span>out</span> <span>+=</span> <span>data</span><span>.</span><span>substr</span><span>(</span><span>start</span><span>,</span> <span>cursor</span> <span>-</span> <span>start</span><span>);</span>
          <span>continue</span><span>;</span>
        <span>}</span>

        <span>// find name</span>
        <span>auto</span> <span>start</span> <span>=</span> <span>cursor</span><span>;</span>
        <span>skip_to</span><span>(</span><span>&#39;}&#39;</span><span>,</span> <span>&#39;:&#39;</span><span>);</span>
        <span>auto</span> <span>name</span> <span>=</span> <span>data</span><span>.</span><span>substr</span><span>(</span><span>start</span><span>,</span> <span>cursor</span> <span>-</span> <span>start</span><span>);</span>

        <span>// replace name</span>
        <span>auto</span> <span>it</span> <span>=</span> <span>std</span><span>::</span><span>find</span><span>(</span><span>names</span><span>.</span><span>begin</span><span>(),</span> <span>names</span><span>.</span><span>end</span><span>(),</span> <span>name</span><span>);</span>
        <span>auto</span> <span>idx</span> <span>=</span> <span>std</span><span>::</span><span>distance</span><span>(</span><span>names</span><span>.</span><span>begin</span><span>(),</span> <span>it</span><span>);</span>
        <span>out</span> <span>+=</span> <span>itoa</span><span>(</span><span>idx</span><span>);</span>

        <span>out</span> <span>+=</span> <span>current</span><span>();</span>
      <span>}</span>
      <span>++</span><span>cursor</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>out</span><span>;</span>
  <span>}</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="wrapping-stdformat_string"><span>Wrapping <code>std::format_string</code></span><a href="#wrapping-stdformat_string"><i></i></a></h3><p>At some point we will have to produce a <code>std::format_string</code>. To avoid having to resort to runtime format checking, we can instead instantiate a template function that handles formatting for us. This function shall receive the format string as constant template argument.</p><p>So let’s first provide a replacement for the <code>std::format_string</code> argument of <code>format</code> - note that the constructor must be <code>consteval</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>Args</span><span>&gt;</span>
<span>struct</span> <span>NamedFormatString</span> <span>{</span>
  <span>using</span> <span>format_type</span> <span>=</span> <span>std</span><span>::</span><span>string</span> <span>(</span><span>*</span><span>)(</span><span>Args</span> <span>const</span><span>&amp;</span><span>);</span>
  <span>format_type</span> <span>format</span><span>;</span>

  <span>template</span> <span>&lt;</span><span>typename</span> <span>Tp</span><span>&gt;</span>
    <span>requires</span> <span>std</span><span>::</span><span>convertible_to</span><span>&lt;</span><span>Tp</span> <span>const</span><span>&amp;</span><span>,</span> <span>std</span><span>::</span><span>string_view</span><span>&gt;</span>
  <span>consteval</span> <span>explicit</span><span>(</span><span>false</span><span>)</span> <span>NamedFormatString</span><span>(</span><span>Tp</span> <span>const</span><span>&amp;</span> <span>str</span><span>)</span> <span>{</span>
    <span>auto</span> <span>parser</span> <span>=</span> <span>FmtParser</span><span>{</span><span>str</span><span>};</span>
    <span>auto</span> <span>fmt</span>    <span>=</span> <span>parser</span><span>.</span><span>transform</span><span>(</span><span>meta</span><span>::</span><span>get_member_names</span><span>&lt;</span><span>typename</span> <span>Args</span><span>::</span><span>type</span><span>&gt;</span><span>());</span>
    <span>format</span>      <span>=</span> <span>extract</span><span>&lt;</span><span>format_type</span><span>&gt;</span><span>(</span>
                    <span>substitute</span><span>(</span><span>^^</span><span>format_impl</span><span>,</span> <span>{</span><span>meta</span><span>::</span><span>intern</span><span>(</span><span>fmt</span><span>),</span><span>^^</span><span>Args</span><span>}));</span>
  <span>}</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><p>This will instantiate <code>format_impl</code> with the transformed format string as constant template argument for us. In <code>format_impl</code> we can retrieve the keyword arguments and simply delegate to <code>std::format</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>util</span><span>::</span><span>fixed_string</span> <span>fmt</span><span>,</span> <span>typename</span> <span>Args</span><span>&gt;</span>
<span>std</span><span>::</span><span>string</span> <span>format_impl</span><span>(</span><span>Args</span> <span>const</span><span>&amp;</span> <span>kwargs</span><span>)</span> <span>{</span>
  <span>return</span> <span>[</span><span>:</span><span>meta</span><span>::</span><span>sequence</span><span>(</span><span>std</span><span>::</span><span>tuple_size_v</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>)</span><span>:</span><span>]</span>
  <span>&gt;&gt;</span> <span>[</span><span>&amp;</span><span>]</span><span>&lt;</span><span>std</span><span>::</span><span>size_t</span><span>...</span> <span>Idx</span><span>&gt;</span><span>()</span> <span>{</span>
    <span>return</span> <span>std</span><span>::</span><span>format</span><span>(</span><span>fmt</span><span>,</span> <span>get</span><span>&lt;</span><span>Idx</span><span>&gt;</span><span>(</span><span>kwargs</span><span>)...);</span>
  <span>};</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>We can now define two versions of <code>format</code> - one for named arguments and one to wrap the existing functionality of <code>std::format</code>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
  <span>requires</span><span>(</span><span>is_kwargs</span><span>&lt;</span><span>T</span><span>&gt;</span><span>)</span>
<span>void</span> <span>print</span><span>(</span><span>NamedFormatString</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>fmt</span><span>,</span> <span>T</span> <span>const</span><span>&amp;</span> <span>kwargs</span><span>)</span> <span>{</span>
  <span>fmt</span><span>.</span><span>print</span><span>(</span><span>kwargs</span><span>);</span>
<span>}</span>

<span>template</span> <span>&lt;</span><span>typename</span><span>...</span> <span>Args</span><span>&gt;</span>
  <span>requires</span><span>(</span><span>sizeof</span><span>...(</span><span>Args</span><span>)</span> <span>!=</span> <span>1</span> <span>||</span> <span>(</span><span>!</span><span>is_kwargs</span><span>&lt;</span><span>std</span><span>::</span><span>remove_cvref_t</span><span>&lt;</span><span>Args</span><span>&gt;&gt;</span> <span>&amp;&amp;</span> <span>...))</span>
<span>void</span> <span>print</span><span>(</span><span>std</span><span>::</span><span>format_string</span><span>&lt;</span><span>Args</span><span>...</span><span>&gt;</span> <span>fmt</span><span>,</span> <span>Args</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>{</span>
  <span>std</span><span>::</span><span>print</span><span>(</span><span>fmt</span><span>,</span> <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Similarly, <code>std::print</code> and <code>std::println</code> can be wrapped using the same approach.</p><h3 id="usage"><span>Usage</span><a href="#usage"><i></i></a></h3><p>With this, we can now write:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>erl</span><span>::</span><span>format</span><span>(</span><span>&#34;{bar}{foo}&#34;</span><span>,</span> <span>make_args</span><span>(</span><span>bar</span><span>=</span><span>0</span><span>,</span> <span>foo</span><span>=</span><span>42</span><span>));</span>
<span>// instead of</span>
<span>std</span><span>::</span><span>format</span><span>(</span><span>&#34;{1}{0}&#34;</span><span>,</span> <span>0</span><span>,</span> <span>42</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>Notice how the order in which arguments appear in <code>make_args</code> does not matter.</p><p>Here’s a full example (<a href="https://cpp26.godbolt.org/z/1fda3or8v">Run on compiler explorer</a>):</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span>#include</span> <span>&lt;vector&gt;</span><span>
#include</span> <span>&lt;iostream&gt;</span><span>
</span>
<span>#define KWARGS_FORMATTING 1
#include</span> <span>&lt;kwargs.h&gt;</span><span>
</span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>int</span> <span>x</span> <span>=</span> <span>3</span><span>;</span>
  <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>list</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>};</span>

  <span>erl</span><span>::</span><span>print</span><span>(</span><span>&#34;{} {}</span><span>\n</span><span>&#34;</span><span>,</span> <span>42</span><span>,</span> <span>x</span><span>);</span>
  <span>erl</span><span>::</span><span>print</span><span>(</span><span>&#34;{1} {0}</span><span>\n</span><span>&#34;</span><span>,</span> <span>x</span><span>,</span> <span>42</span><span>);</span>
  <span>erl</span><span>::</span><span>print</span><span>(</span><span>&#34;{x} {y}</span><span>\n</span><span>&#34;</span><span>,</span> <span>make_args</span><span>(</span><span>x</span><span>=</span><span>42</span><span>,</span> <span>y</span><span>=</span><span>x</span><span>));</span>

  <span>erl</span><span>::</span><span>print</span><span>(</span><span>&#34;x: {} list: {} : {}&#34;</span><span>,</span> <span>x</span><span>,</span> <span>list</span><span>,</span> <span>&#34;foo&#34;</span><span>);</span>
  <span>erl</span><span>::</span><span>print</span><span>(</span><span>&#34;x: {0} list: {2} : {1}&#34;</span><span>,</span> <span>x</span><span>,</span> <span>&#34;foo&#34;</span><span>,</span> <span>list</span><span>);</span>

  <span>erl</span><span>::</span><span>println</span><span>(</span><span>&#34;x: {x} list: {list} : {str}&#34;</span><span>,</span> 
               <span>make_args</span><span>(</span><span>x</span><span>=</span><span>x</span><span>,</span> <span>str</span><span>=</span><span>&#34;foo&#34;</span><span>,</span> <span>list</span><span>=</span><span>list</span><span>));</span>

  <span>erl</span><span>::</span><span>println</span><span>(</span><span>&#34;x: {x} list: {list} : {str}&#34;</span><span>,</span> 
               <span>make_args</span><span>(</span><span>x</span><span>,</span> <span>str</span><span>=</span><span>&#34;foo&#34;</span><span>,</span> <span>list</span><span>));</span>

  <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>erl</span><span>::</span><span>format</span><span>(</span><span>&#34;{x} {y}&#34;</span><span>,</span> <span>make_args</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>=</span><span>3</span><span>))</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div></div></div>
  </body>
</html>
