<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2023/11/28/parsing-8-bit-integers-quickly/">Original</a>
    <h1>Parsing 8-bit integers quickly</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Suppose that you want to parse quickly 8-bit integers (0, 1, 2, …, 254, 255) from an ASCII/UTF-8 string. The problem comes up in the simdzone project lead by Jeroen Koekkoek (NLnet Labs). You are given a string and its length: e.g., ’22’ and length is 2. The naive approach in C might be:</p>
<pre><span>int</span> parse_uint8_naive<span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>size_t</span> len<span>,</span> uint8_t <span>*</span>num<span>)</span> <span>{</span>
  uint32_t n <span>=</span> <span>0</span><span>;</span>
<span>  for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>,</span> r <span>=</span> len <span>&amp;</span> <span>0x3</span><span>;</span> i <span>&lt;</span> r<span>;</span> i<span>+</span><span>+</span><span>)</span> <span>{</span>
    uint8_t d <span>=</span> <span>(</span>uint8_t<span>)</span><span>(</span>str<span>[</span>i<span>]</span> <span>-</span> <span>&#39;0&#39;</span><span>)</span><span>;</span>
<span>    if</span> <span>(</span>d <span>&gt;</span> <span>9</span><span>)</span>
<span>     return</span> <span>0</span><span>;</span>
    n <span>=</span> n <span>*</span> <span>10</span> <span>+</span> d<span>;</span>
<span>  }</span>
<span>  *</span>num <span>=</span> <span>(</span>uint8_t<span>)</span>n<span>;</span>
<span>  return</span> n <span>&lt;</span> <span>256</span> <span>&amp;</span><span>&amp;</span> len <span>&amp;</span><span>&amp;</span> len <span>&lt;</span> <span>4</span><span>;</span>
<span>}</span>
</pre>
<p>This code is a C function that takes a string of characters, its length, and a pointer to an unsigned 8-bit integer as input arguments. The function returns a Boolean value indicating whether the input string can be parsed into an unsigned 8-bit integer or not.</p>
<p>The function first initializes a 32-bit unsigned integer <code>n</code> to zero, we will store our answer there. The function then iterates over the input string, extracting each digit character from the string and converting it to an unsigned 8-bit integer. The extracted digit is then added to <code>n</code> after being multiplied by 10. This process continues until the end of the string or until the function has processed 4 bytes of the string. Finally, the function assigns the value of <code>n</code> to the unsigned 8-bit integer pointed to by <code>num</code>. It then returns a boolean value indicating whether the parsed integer is less than 256 and the length of the input string is between 1 and 3 characters.  If the input string contains any non-digit characters or if the length of the string is greater than 3 bytes, the function returns false.</p>
<p>In C++, you could call <tt>from_chars</tt>:</p>
<pre><span>int</span> parse_uint8_fromchars<span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>size_t</span> len<span>,</span> uint8_t <span>*</span>num<span>)</span> <span>{</span>
<span>  auto</span> <span>[</span>p<span>,</span> ec<span>]</span> <span>=</span> <span>std</span><span>::</span>from_chars<span>(</span>str<span>,</span> str <span>+</span> len<span>,</span> <span>*</span>num<span>)</span><span>;</span>
<span>  return</span> <span>(</span>ec <span>=</span><span>=</span> <span>std</span><span>::</span>errc<span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

</pre>
<p>The <code>std::from_chars</code> function takes three arguments: a pointer to the beginning of the input character sequence, a pointer to the end of the input character sequence, and a reference to the output variable that will hold the parsed integer value. The function returns a <code>std::from_chars_result</code> object that contains two members: a pointer to the first character that was not parsed, and an error code that indicates whether the parsing was successful or not.</p>
<p>In this function, the <code>std::from_chars</code> function is called with the input string and its length as arguments, along with a pointer to the unsigned 8-bit integer that will hold the parsed value. The function then checks whether the error code returned by <code>std::from_chars</code> is equal to <code>std::errc()</code>, which indicates that the parsing was successful. If the parsing was successful, the function returns <code>true</code>. Otherwise, it returns <code>false</code>.</p>
<p>Can we do better than these functions? Suppose that you can always read 4 bytes, even if the string is shorter (i.e., there is a buffer). This is often a safe assumption. Then you can load your input into a 32-bit word and process all bytes at once, in a single register. This often called SWAR: In computer science, SWAR means SIMD within a register, which is a technique for performing parallel operations on data contained in a processor register.</p>
<p>Jeroen Koekkoek first came up with a valid SWAR approach, but it was only about 40% than the naive approach in the case where we had unpredictable inputs, and no faster than the naive approach given predictable inputs. Let us examine an approach that might be competitive all around:</p>
<pre><span>int</span> parse_uint8_fastswar<span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>size_t</span> len<span>,</span> uint8_t <span>*</span>num<span>)</span> <span>{</span>
<span>  union</span> <span>{</span>
    uint8_t as_str<span>[</span><span>4</span><span>]</span><span>;</span>
    uint32_t as_int<span>;</span>
<span>  }</span> digits<span>;</span>
<span>  memcpy</span><span>(</span><span>&amp;</span>digits<span>.</span>as_int<span>,</span> str<span>,</span> <span>sizeof</span><span>(</span>digits<span>)</span><span>)</span><span>;</span>
  digits<span>.</span>as_int <span>^</span><span>=</span> <span>0x30303030</span><span>lu</span><span>;</span>
  digits<span>.</span>as_int <span>&lt;</span><span>&lt;</span><span>=</span> <span>(</span><span>4</span> <span>-</span> <span>(</span>len <span>&amp;</span> <span>0x3</span><span>)</span><span>)</span> <span>*</span> <span>8</span><span>;</span>
  uint32_t y <span>=</span> <span>(</span><span>(</span>UINT64_C<span>(</span><span>0x640a0100</span><span>)</span> <span>*</span> digits<span>.</span>as_int<span>)</span><span>&gt;</span><span>&gt;</span><span>32</span><span>)</span><span>&amp;</span><span>0xff</span><span>;</span>
<span>  *</span>num <span>=</span> <span>(</span>uint8_t<span>)</span><span>(</span>y<span>)</span><span>;</span>
<span>  return</span> <span>(</span>digits<span>.</span>as_int <span>&amp;</span> <span>0xf0f0f0f0</span><span>)</span> <span>=</span><span>=</span> <span>0</span> <span>&amp;</span><span>&amp;</span> y <span>&lt;</span> <span>256</span> <span>&amp;</span><span>&amp;</span> len <span>!</span><span>=</span> <span>0</span> 
<span>          &amp;</span><span>&amp;</span> len <span>&lt;</span> <span>4</span><span>;</span>
<span>}</span>

</pre>
<p>Again, this code is a C function that takes a string of characters, its length, and a pointer to an unsigned 8-bit integer as input arguments. The function returns a boolean value indicating whether the input string can be parsed into an unsigned 8-bit integer or not. The function first initializes a union <code>digits</code> that contains an array of 4 unsigned 8-bit integers and a 32-bit unsigned integer. The function then copies the input string into the 32-bit unsigned integer using the <code>memcpy</code> function. The <code>memcpy</code> function copies the input string into the 32-bit unsigned integer.</p>
<p>The function then flips the bits of the 32-bit unsigned integer using the XOR operator and the constant value <code>0x30303030lu</code>. This operation converts each digit character in the input string to its corresponding decimal value. Indeed, the ASCII characters from 0 to 9 have code point values 0x30 to 0x39 in ASCII. The function then shifts the 32-bit unsigned integer to the left by a certain number of bits, depending on the length of the input string. This operation removes any trailing bytes that were not part of the input string.</p>
<p>The next part is where I contributed to the routine. The function then multiplies the 32-bit unsigned integer by the constant value <code>0x640a0100</code> using a 64-bit unsigned integer. It is a concise way to do two multiplications (by 100 and by 10) and two sums at once. Observe that 0x64 is 100 and 0x0a is 10. The result of this multiplication is then shifted to the right by 32 bits and masked with the value <code>0xff</code>. This operation extracts the least significant byte of the 32-bit unsigned integer, which represents the parsed unsigned 8-bit integer. Finally, the function assigns the value of the parsed unsigned 8-bit integer to the unsigned 8-bit integer pointed to by <code>num</code>. It then returns a boolean value indicating whether the parsed integer is less than 256 and the length of the input string is between 1 and 3 characters.</p>
<p>To test these functions, <a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2023/11/28">I wrote a benchmark</a>. The benchmark uses random inputs, or sequential inputs (0,1,…), and it ends up being very relevant. I use GCC 12 and an Ice Lake (Intel) linux server running at 3.2 GHz. I report the number of millions of numbers parsed by second.</p>
<table>
<tbody>
<tr>
<td></td>
<td>random numbers</td>
<td>sequential numbers</td>
</tr>
<tr>
<td>from_chars</td>
<td>145 M/s</td>
<td>255 M/s</td>
</tr>
<tr>
<td>naive</td>
<td>210 M/s</td>
<td>345 M/s</td>
</tr>
<tr>
<td>SWAR</td>
<td>450 M/s</td>
<td>450 M/s</td>
</tr>
</tbody>
</table>
<p>So the SWAR approach is effectively twice as fast as the naive approach when the inputs are unpredictable. Otherwise, for predictable inputs, we still have a 30% gain according to my numbers. The from_chars results are disappointing all around.</p>
<p>Can you do better? <a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2023/11/28">The benchmark is available</a>.</p>
<p><strong>Credit</strong>: I am grateful to Jeroen Koekkoek from NLnet Labs for suggesting this problem.</p>
</div></div>
  </body>
</html>
