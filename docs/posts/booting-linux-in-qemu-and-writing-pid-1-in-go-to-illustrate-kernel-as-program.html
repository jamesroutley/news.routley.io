<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://serversfor.dev/linux-inside-out/the-linux-kernel-is-just-a-program/">Original</a>
    <h1>Booting Linux in QEMU and Writing PID 1 in Go to Illustrate Kernel as Program</h1>
    
    <div id="readability-page-1" class="page"><article> <p>Most books and courses introduce Linux through shell commands, leaving the kernel as a mysterious black box doing magic behind the scenes.</p>
<p>In this post, we will run some experiments to demystify it: the Linux kernel is just a binary that you can build and run.</p>
<p>The experiments are designed so you can follow along if you have a Linux PC.
But this is completely optional, the goal is to build a mental model about how Linux works, seeing how components of the system fit together.</p>
<p>But first let’s talk about what a kernel is.</p>
<h2 id="what-is-a-kernel">What is a kernel?</h2>
<p>Computers are built from CPUs, memory, and other devices, like video cards, network cards, keyboards,
displays, and a lot of other stuff.</p>
<p>These devices can be manufactured by different companies, have different capabilities, and can be programmed differently.</p>
<p>An operating system kernel provides an abstraction to use these devices and resources conveniently and securely. Without one, writing programs would be much more difficult. We would need to write the low-level code to use every device that our program needs, and it’s likely that it wouldn’t work on other computers.</p>
<p>A kernel</p>
<ul>
<li>gives us APIs to interact with the hardware over a unified interface</li>
<li>manages how programs can use the computer’s CPU, memory and other resources</li>
<li>provides access control over what resources can a program access</li>
<li>provides additional features like firewalls, file systems, mechanisms for programs to communicate, etc.</li>
</ul>
<p>The closest analogy from the software development world is that the kernel is a <strong>runtime</strong> for our computer.</p>
<h2 id="where-is-the-kernel">Where is the kernel?</h2>
<p>On most Linux distributions we will find the kernel under the <code>/boot</code> directory.
Let’s enter the directory and list its contents:</p>
<pre tabindex="0" data-language="bash"><code><span><span>~</span><span>$ cd /boot</span></span>
<span><span>/boot$</span><span> ls</span><span> -1</span></span>
<span><span>System.map-6.12.43+deb13-amd64</span></span>
<span><span>System.map-6.12.48+deb13-amd64</span></span>
<span><span>config-6.12.43+deb13-amd64</span></span>
<span><span>config-6.12.48+deb13-amd64</span></span>
<span><span>efi</span></span>
<span><span>grub</span></span>
<span><span>initrd.img-6.12.43+deb13-amd64</span></span>
<span><span>initrd.img-6.12.48+deb13-amd64</span></span>
<span><span>vmlinuz-6.12.43+deb13-amd64</span></span>
<span><span>vmlinuz-6.12.48+deb13-amd64</span></span></code></pre>
<p>We see a few files here, but the one we are looking for is <strong>vmlinuz-6.12.48+deb13-amd64</strong>. This single file is the kernel.</p>
<p>If you ever wondered what this name means:</p>
<ul>
<li>vmlinuz: <code>vm</code> for virtual memory, <code>linux</code>, and <code>z</code> indicating compression</li>
<li>6.12.48+deb13: this is the kernel version, and the distribution (Debian 13)</li>
<li>amd64: this is the architecture of our system</li>
</ul>
<p><strong>Note:</strong> Different distributions may use slightly different naming conventions. vmlinuz is commonly the bootable compressed kernel image.</p>
<h2 id="lets-start-the-kernel">Let’s start the kernel</h2>
<p>In our first experiment we will copy this kernel into another directory and run it.</p>
<p>First, let’s create a directory and copy the kernel there.</p>
<p><strong>Note:</strong> Your kernel version might differ, remember to check it before the <code>cp</code> command.</p>
<pre tabindex="0" data-language="bash"><code><span><span>/boot$</span><span> cd</span></span>
<span><span>~</span><span>$ mkdir linux-inside-out</span></span>
<span><span>~</span><span>$ cd linux-inside-out/</span></span></code></pre>
<pre tabindex="0" data-language="bash"><code><span><span>~</span><span>/linux-inside-out$ cp /boot/vmlinuz-6.12.48+deb13-amd64 </span><span>.</span></span>
<span><span>~</span><span>/linux-inside-out$ ls -lh</span></span>
<span><span>total</span><span> 12M</span></span>
<span><span>-rw-r--r--</span><span> 1</span><span> zsoltkacsandi</span><span> zsoltkacsandi</span><span> 12M</span><span> Dec</span><span>  1</span><span> 09:44</span><span> vmlinuz-6.12.48+deb13-amd64</span></span></code></pre>
<p>Then install some tools that are needed for this experiment.</p>
<p>We will use QEMU, a virtual machine emulator, because our kernel needs something that works like a computer, and because we do not want to mess up our original operating system.</p>
<pre tabindex="0" data-language="bash"><code><span><span>~</span><span>$ sudo apt update</span></span>
<span><span>~</span><span>$ sudo apt install -y qemu-system-x86 qemu-utils</span></span></code></pre>
<p>Then start a virtual machine with our kernel:</p>
<pre tabindex="0" data-language="bash"><code><span><span>~</span><span>/linux-inside-out$ qemu-system-x86_64 </span><span>\</span></span>
<span><span>  -m</span><span> 256M</span><span> \</span></span>
<span><span>  -kernel</span><span> vmlinuz-6.12.48+deb13-amd64</span><span> \</span></span>
<span><span>  -append</span><span> &#34;console=ttyS0&#34;</span><span> \</span></span>
<span><span>  -nographic</span></span></code></pre>
<p>The output should be something like this:</p>
<pre tabindex="0" data-language="bash"><code><span><span>SeaBIOS</span><span> (version </span><span>1.16.3-debian-1.16.3-2</span><span>)</span></span>
<span><span>iPXE</span><span> (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+06FC6D30+06F06D30 CA00</span></span>
<span><span>Booting</span><span> from</span><span> ROM...</span></span>
<span><span>Probing</span><span> EDD</span><span> (edd=off </span><span>to</span><span> disable</span><span>)... o</span></span>
<span><span>[    0.000000] Linux version 6.12.48+deb13-amd64 (</span><span><a href="https://serversfor.dev/cdn-cgi/l/email-protection" data-cfemail="a4c0c1c6cdc5ca89cfc1d6cac1c8e4c8cdd7d0d78ac0c1c6cdc5ca8acbd6c3">[email protected]</a></span><span>) (</span><span>x86_64-linux-gnu-gcc-14</span><span> (Debian </span><span>14.2.0-19</span><span>) 14.2.0, )</span></span>
<span><span>[    0.000000] Command line: console</span><span>=</span><span>ttyS0</span></span>
<span><span>...</span></span>
<span><span>[    2.055627] RAS: Correctable Errors collector initialized.</span></span>
<span><span>[    2.161843] clk: Disabling unused clocks</span></span>
<span><span>[    2.162218] PM: genpd: Disabling unused power domains</span></span>
<span><span>[    2.179652] /dev/root: Can</span><span>&#39;t open blockdev</span></span>
<span><span>[    2.180871] VFS: Cannot open root device &#34;&#34; or unknown-block(0,0): error -6</span></span>
<span><span>[    2.181038] Please append a correct &#34;root=&#34; boot option; here are the available partitions:</span></span>
<span><span>[    2.181368] List of all bdev filesystems:</span></span>
<span><span>[    2.181477]  fuseblk</span></span>
<span><span>[    2.181516]</span></span>
<span><span>[    2.181875] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span></span>
<span><span>[    2.182495] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.48+deb13-amd64 #1  Debian 6.12.48-1</span></span>
<span><span>[    2.182802] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014</span></span>
<span><span>...</span></span>
<span><span>[    2.186426] Kernel Offset: 0x30e00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)</span></span>
<span><span>[    2.186949] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---</span></span></code></pre>
<p>You can exit by pressing <kbd>Ctrl</kbd> + <kbd>A</kbd> then <kbd>X</kbd>.</p>
<p>So, we’ve just started the same kernel that is running on our computer. It took 2 seconds, it printed a lot
of log messages, then panicked.</p>
<p>This panic is not a bug, actually this is expected - once our kernel initializes itself, it tries to mount
the root filesystem, and hand over control to a program called init.</p>
<p>So let’s give one to it.</p>
<p>We will write a simple program that we will use as an init program.</p>
<p>We will use Golang for two reasons:</p>
<ul>
<li>it has an easy to learn syntax, that readers coming from different backgrounds can pick up and understand quickly</li>
<li>it can build a statically-linked binary with no C dependencies, making it portable and perfect for our minimal experiment</li>
</ul>
<p>First let’s install Golang, and create a new project called <code>init</code>:</p>
<pre tabindex="0" data-language="bash"><code><span><span>~</span><span>/linux-inside-out$ sudo apt -y install golang</span></span>
<span><span>~</span><span>/linux-inside-out$ mkdir init</span></span>
<span><span>~</span><span>/linux-inside-out$ cd init</span></span>
<span><span>~</span><span>/linux-inside-out/init$</span></span>
<span><span>~</span><span>/linux-inside-out/init$ go mod init init</span></span>
<span><span>go:</span><span> creating</span><span> new</span><span> go.mod:</span><span> module</span><span> init</span></span>
<span><span>go:</span><span> to</span><span> add</span><span> module</span><span> requirements</span><span> and</span><span> sums:</span></span>
<span><span>go</span><span> mod</span><span> tidy</span></span></code></pre>
<p>Create a new file, called <code>main.go</code>:</p>
<pre tabindex="0" data-language="go"><code><span><span>package</span><span> main</span></span>
<span></span>
<span><span>import</span><span> (</span></span>
<span><span>    &#34;</span><span>fmt</span><span>&#34;</span></span>
<span><span>    &#34;</span><span>os</span><span>&#34;</span></span>
<span><span>    &#34;</span><span>time</span><span>&#34;</span></span>
<span><span>)</span></span>
<span></span>
<span><span>func</span><span> main</span><span>() {</span></span>
<span><span>    fmt.</span><span>Println</span><span>(</span><span>&#34;Hello from Go init!&#34;</span><span>)</span></span>
<span><span>    fmt.</span><span>Println</span><span>(</span><span>&#34;PID:&#34;</span><span>, os.</span><span>Getpid</span><span>()) </span><span>// printing the PID (process ID)</span></span>
<span></span>
<span><span>    for</span><span> i </span><span>:=</span><span> 0</span><span>; ; i</span><span>++</span><span> { </span><span>// every two seconds printing the text &#34;tick {tick number}&#34;</span></span>
<span><span>        fmt.</span><span>Println</span><span>(</span><span>&#34;tick&#34;</span><span>, i)</span></span>
<span><span>        time.</span><span>Sleep</span><span>(</span><span>2</span><span> *</span><span> time.Second)</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>Then build the program and run it:</p>
<pre tabindex="0" data-language="bash"><code><span><span>~</span><span>/linux-inside-out/init$ CGO_ENABLED</span><span>=</span><span>0</span><span> go</span><span> build</span><span> -o</span><span> init</span><span> .</span></span>
<span><span>~</span><span>/linux-inside-out/init$ ./init</span></span>
<span><span>Hello</span><span> from</span><span> Go</span><span> init!</span></span>
<span><span>PID:</span><span> 3086</span></span>
<span><span>tick</span><span> 0</span></span>
<span><span>tick</span><span> 1</span></span></code></pre>
<p>Press <kbd>Ctrl</kbd> + <kbd>C</kbd> to stop it.</p>
<p>As you can see, this is a regular program that got the PID 3086 and prints some text to the output.
There is nothing special about it.</p>
<p><strong>Note:</strong> If you use another programming language for this experiment, you will need to compile a statically-linked binary.
Without that the following parts of the experiment will not work.</p>
<p>Now we create a simple initramfs filesystem.
When the kernel starts it does not have all of the parts loaded that are needed to access the disks in the computer, so it needs a filesystem loaded into the memory called <strong>initramfs</strong> (Initial RAM filesystem).</p>
<pre tabindex="0" data-language="bash"><code><span><span>~</span><span>/linux-inside-out$ mkdir -p rootfs/{</span><span>proc,sys,dev}</span></span>
<span><span>~</span><span>/linux-inside-out$ cp ./init/init rootfs/init</span></span>
<span><span>~</span><span>/linux-inside-out$ sudo mknod rootfs/dev/console c 5 1</span></span>
<span><span>~</span><span>/linux-inside-out$ sudo mknod rootfs/dev/null c 1 3</span></span></code></pre>
<p>The cp and mkdir commands might be familiar. The mknod command creates special files that programs use to communicate with hardware devices.</p>
<p>Our root filesystem directory structure looks like this:</p>
<pre tabindex="0" data-language="bash"><code><span><span>|</span><span>--</span><span> dev</span><span>             # dev (devices) directory</span></span>
<span><span>|</span><span>   |</span><span>--</span><span> console</span><span>     # console device</span></span>
<span><span>|</span><span>   `</span><span>--</span><span> null        </span><span># null device</span></span>
<span><span>|</span><span>--</span><span> init            </span><span># our Golang program</span></span>
<span><span>|</span><span>--</span><span> proc            </span><span># a directory called proc</span></span>
<span><span>`</span><span>--</span><span> sys</span><span>             # a directory called sys</span></span></code></pre>
<p>Now let’s package the files into an archive file, called initramfs.img.</p>
<pre tabindex="0" data-language="bash"><code><span><span>( </span><span>cd</span><span> rootfs</span><span> &amp;&amp; </span><span>find</span><span> .</span><span> |</span><span> cpio</span><span> -H</span><span> newc</span><span> -o</span><span> ) </span><span>&gt;</span><span> initramfs.img</span></span></code></pre>
<p>Then start a virtual machine again, with the kernel and initramfs:</p>
<pre tabindex="0" data-language="bash"><code><span><span>qemu-system-x86_64</span><span> \</span></span>
<span><span>  -m</span><span> 256M</span><span> \</span></span>
<span><span>  -kernel</span><span> vmlinuz-6.12.48+deb13-amd64</span><span> \</span></span>
<span><span>  -initrd</span><span> initramfs.img</span><span> \</span></span>
<span><span>  -append</span><span> &#34;console=ttyS0 rdinit=/init&#34;</span><span> \</span></span>
<span><span>  -nographic</span></span></code></pre>
<pre tabindex="0" data-language="bash"><code><span><span>SeaBIOS</span><span> (version </span><span>1.16.3-debian-1.16.3-2</span><span>)</span></span>
<span><span>iPXE</span><span> (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+0EFC6D30+0EF06D30 CA00</span></span>
<span><span>Booting</span><span> from</span><span> ROM...</span></span>
<span><span>Probing</span><span> EDD</span><span> (edd=off </span><span>to</span><span> disable</span><span>)... o</span></span>
<span><span>[    0.000000] Linux version 6.12.48+deb13-amd64 (</span><span><a href="https://serversfor.dev/cdn-cgi/l/email-protection" data-cfemail="e98d8c8b808887c4828c9b878c85a985809a9d9ac78d8c8b808887c7869b8e">[email protected]</a></span><span>) (</span><span>x86_64-linux-gnu-gcc-14</span><span> (Debian </span><span>14.2.0-19</span><span>) 14.2.0, GNU ld (</span><span>GNU</span><span> Binutils</span><span> for</span><span> Debian</span><span>) 2.44) </span><span>#1 SMP PR)</span></span>
<span><span>[    0.000000] Command line: console</span><span>=</span><span>ttyS0</span><span> rdinit</span><span>=</span><span>/init</span></span>
<span><span>...</span></span>
<span><span>[    1.922229] RAS: Correctable Errors collector initialized.</span></span>
<span><span>[    2.158525] clk: Disabling unused clocks</span></span>
<span><span>[    2.158865] PM: genpd: Disabling unused power domains</span></span>
<span><span>[    2.264545] Freeing unused decrypted memory: 2028K</span></span>
<span><span>[    2.327128] Freeing unused kernel image (</span><span>initmem</span><span>) memory: 4148K</span></span>
<span><span>[    2.406015] Write protecting the kernel read-only data: 28672k</span></span>
<span><span>[    2.407968] Freeing unused kernel image (</span><span>rodata/data</span><span> gap</span><span>) memory: 488K</span></span>
<span><span>[    2.555150] x86/mm: Checked W+X mappings: passed, no W+X pages found.</span></span>
<span><span>[    2.557822] tsc: Refined TSC clocksource calibration: 2903.977 MHz</span></span>
<span><span>[    2.558399] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x29dbf0142be, max_idle_ns: 440795300983 ns</span></span>
<span><span>[    2.565700] clocksource: Switched to clocksource tsc</span></span>
<span><span>[    2.672446] Run /init as init process</span></span>
<span><span>Hello</span><span> from</span><span> Go</span><span> init!</span></span>
<span><span>PID:</span><span> 1</span></span>
<span><span>tick</span><span> 0</span></span>
<span><span>tick</span><span> 1</span></span>
<span><span>tick</span><span> 2</span></span></code></pre>
<p>Our kernel booted normally, then it started our Go program, the init process.
A program that is running is called <strong>process</strong>.</p>
<p>There are a few important points to note here:</p>
<ul>
<li>Our Go program got the <strong>process ID</strong> 1 (<code>PID: 1</code>). <strong>PID 1</strong> is the first process to start, it is called the <strong>init</strong> process.
The purpose of the init process is to start the other programs that need to be running for the operating system.</li>
<li>Up until the <code>Run /init as init process</code> line we are in the <strong>kernel space</strong>. With the init process starting we are entering into the <strong>user space</strong>.</li>
<li>We have just built a (rather simple) <strong>Linux distribution</strong>. Two files, that’s it. A Linux distribution is really just a Linux kernel, a bunch of programs and config files packaged together.</li>
</ul>
<h2 id="what-we-have-learnt-so-far">What we have learnt so far</h2>
<p>We have already learnt quite a few important concepts that are essential to understand Linux systems:</p>
<ul>
<li>The <strong>Linux kernel</strong> is a single, few megabytes file, sitting on your disk</li>
<li>A <strong>Linux distribution</strong> is just a kernel and a set of other programs and config files</li>
<li>A <strong>process</strong> is a program that is under execution</li>
<li><strong>PID</strong> is the process ID</li>
<li>What the <strong>init</strong> process is</li>
<li>We familiarized ourselves with the concepts of <strong>kernel space</strong> and <strong>user space</strong></li>
</ul> </article></div>
  </body>
</html>
