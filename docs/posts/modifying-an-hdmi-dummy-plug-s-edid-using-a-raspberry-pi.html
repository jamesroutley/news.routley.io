<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.downtowndougbrown.com/2025/06/modifying-an-hdmi-dummy-plugs-edid-using-a-raspberry-pi/">Original</a>
    <h1>Modifying an HDMI dummy plug&#39;s EDID using a Raspberry Pi</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>I recently found myself needing to change the monitor that a cheap HDMI “dummy plug” pretended to be. It was a random one I had bought on Amazon several years ago that acted as a 4K monitor, and I needed it to be something simpler that didn’t support a 4K resolution. The story behind why is a long one that I’m still figuring out and might eventually become a separate blog post in the future.</p>



<p>If you’re not familiar with dummy plugs, here’s a quick primer: they are tiny dongles you can plug into an HDMI, DVI, etc. port that don’t actually do anything with the video signal. They simply have the minimum circuitry needed for a video source device, like a computer, to think that a monitor is hooked up. In general this entails a pull-up resistor on pin 19 (HPD) to +5V, as well as a little I<sup>2</sup>C EEPROM chip containing the <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data" target="_blank" rel="noreferrer noopener">Extended Display Identification Data (EDID)</a>. This is useful for headless machines to force the OS to think a monitor is attached.</p>



<figure><img fetchpriority="high" decoding="async" width="265" height="300" src="https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4533-e1748812707110-265x300.jpg" alt="" srcset="https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4533-e1748812707110-265x300.jpg 265w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4533-e1748812707110-905x1024.jpg 905w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4533-e1748812707110-768x869.jpg 768w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4533-e1748812707110.jpg 1063w" sizes="(max-width: 265px) 100vw, 265px"/></figure>



<p>The EDID contains all the info about the monitor: the manufacturer, manufacture date, supported resolutions, audio channels, color space, and stuff like that. My goal was to replace the dummy plug’s EDID with an identical copy of an EDID from one of my many 1080p HDMI capture devices. Then, the computer I plugged it into would think the capture device was plugged in instead of a 4K monitor, and everything would be hunky dory.</p>



<p>I wasn’t sure if the dummy plug’s EDID EEPROM would be programmable, but I decided to give it a shot. There was a chance that it would have its write-protect pin configured to disable programming, but I figured it wouldn’t hurt to try.</p>



<p>Conveniently, I found that my Raspberry Pi Zero has an I<sup>2</sup>C controller wired to the correct pins on its HDMI port. This makes sense — the Pi would need to be able to read the EDID of an attached monitor. <a href="https://forums.raspberrypi.com/viewtopic.php?t=329239#p1970760" target="_blank" rel="noreferrer noopener">This post on the Raspberry Pi Forums</a> and <a href="https://github.com/raspberrypi/linux/issues/6207#issuecomment-2149784322" target="_blank" rel="noreferrer noopener">this GitHub comment</a> were helpful for explaining which I<sup>2</sup>C controller(s) to look at in software on various Pi devices:</p>



<ul>
<li>Pi 0-3:
<ul>
<li><code>/dev/i2c-2</code></li>
</ul>
</li>



<li>Pi 4:
<ul>
<li><code>/dev/i2c-20</code></li>



<li><code>/dev/i2c-21</code></li>
</ul>
</li>



<li>Pi 5:
<ul>
<li><code>/dev/i2c-11</code></li>



<li><code>/dev/i2c-12</code></li>
</ul>
</li>
</ul>



<p>Before I go further,<strong> I want to make it clear that it may be possible to screw up a monitor if you follow these instructions while a real monitor is plugged in and it doesn’t have its EDID protected</strong>. Be careful to only run these commands if you have something attached to the HDMI port that you’re not afraid of bricking, such as a dummy plug! <strong>Also, make sure you are confident you’re on the correct I<sup>2</sup>C bus! Always read the EDID and parse it first to make sure it actually contains an EDID before you attempt a write.</strong> If you attempt these commands on a PC, it’s possible that you could accidentally flash hardware that isn’t an EDID, like a RAM module’s SPD EEPROM.</p>



<p>Starting from a fresh Raspberry Pi OS Lite install, I performed the following modifications:</p>



<ul>
<li><code>sudo raspi-config</code>
<ul>
<li>Under Interface Options, enable I<sup>2</sup>C <a href="https://www.raspberrypi.com/documentation/computers/configuration.html" target="_blank" rel="noreferrer noopener">as described in the Raspberry Pi documentation</a>.</li>
</ul>
</li>



<li><code>sudo apt install i2c-tools</code>
<ul>
<li>Unfortunately, this requires network access, which creates a bit of a problem if you are on a Pi Zero. You might need a USB-Ethernet adapter to make this happen. Another slightly crazy option is to temporarily take the SD card out of your Pi, put it into your desktop PC running Debian/Ubuntu, run <code>sudo apt install binfmt-support qemu-user-static</code> on your PC, <a href="https://wiki.debian.org/RaspberryPi/qemu-user-static" target="_blank" rel="noreferrer noopener">chroot into the SD card’s rootfs</a> (options 1.3 and 2.1 worked for me), and run the apt install command inside of the chroot.</li>
</ul>
</li>
</ul>



<p>And with those prerequisites out of the way, I was ready to start tinkering with the dummy plug’s EEPROM. Note that I also needed an HDMI-to-Mini-HDMI adapter.</p>



<figure><a href="https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4600.jpg" target="_blank" rel=" noreferrer noopener"><img decoding="async" width="224" height="300" src="https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4600-224x300.jpg" alt="" srcset="https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4600-224x300.jpg 224w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4600-765x1024.jpg 765w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4600-768x1028.jpg 768w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4600-1147x1536.jpg 1147w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/img_4600.jpg 1494w" sizes="(max-width: 224px) 100vw, 224px"/></a></figure>



<p>Since I was using a Raspberry Pi Zero, I chose bus 2. You could change the number below to something else on a different model, as listed above (e.g. 20 or 21 on a Pi 4).</p>





<p>I ran i2cdetect to see if the EDID EEPROM was recognized:</p>





<p>This came back with the following result, showing that an I<sup>2</sup>C device was detected at address 0x50, which is exactly the address used for EDID:</p>



<pre>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</pre>



<p>Interestingly, this particular dummy plug also responds with addresses 0x51 through 0x57 present. These other addresses seem to contain copies of the same EDID. Not all dummy plugs show up like this — another one I have only detects 0x50. Anyway, next, I dumped the original EDID from it:</p>


<div><pre title="">get-edid -b $edid_i2c &gt; edid-orig.bin
</pre></div>


<pre>2</pre>



<p>Nice! To make sure I got a good dump, I tried it twice and compared the results to make sure they were identical. Then I printed it in a format suitable for copying/pasting to something like <a href="https://www.edidreader.com/" target="_blank" rel="noreferrer noopener">edidreader.com</a>:</p>


<div><pre title="">od -v -An -txC edid-orig.bin
</pre></div>


<p>This spit out a nice little hex dump of the EDID that was stored on it:</p>



<pre> 00 ff ff ff ff ff ff 00 1a ae 31 9d 00 00 00 00</pre>



<p>Pasting it into the site linked above, I could see it was a valid EDID:</p>



<figure><img decoding="async" width="465" height="476" src="https://www.downtowndougbrown.com/wp-content/uploads/2025/06/image.png" alt="" srcset="https://www.downtowndougbrown.com/wp-content/uploads/2025/06/image.png 465w, https://www.downtowndougbrown.com/wp-content/uploads/2025/06/image-293x300.png 293w" sizes="(max-width: 465px) 100vw, 465px"/></figure>



<p>Now that I was confident I had the dummy plug’s original EDID backed up, I unplugged it from the Pi’s HDMI port and plugged my capture device in instead, and repeated the exact same procedure to dump its EDID:</p>


<div><pre title="">get-edid -b $edid_i2c &gt; edid-capture-card.bin
</pre></div>


<p>I confirmed it was also a valid EDID. Finally, I unplugged the capture device and connected the dummy plug again, and wrote the capture device’s EDID to it with this fun little code snippet. <a href="https://github.com/galkinvv/edid-checked-writer" target="_blank" rel="noreferrer noopener">There are tools out there</a> that can probably do this more efficiently, but hey, this works and doesn’t require any special packages other than the standard userspace Linux I<sup>2</sup>C tools and bash or dash!</p>


<div><pre title="">edidbytes=($(od -v -An -txC edid-capture-card.bin))
for i in &#34;${!edidbytes[@]}&#34;; do
	byte=0x${edidbytes[$i]}
	echo Writing byte $i: $byte...
	i2cset -f -y $edid_i2c 0x50 $i $byte
done
</pre></div>


<p>As a quick explanation, this reads the entire EDID (probably 256 bytes in size) from the dump file created earlier, and formats it into an array of two-digit hex strings using od. Each entry in the array represents one byte in the EDID. Then it loops over each byte, prepending a “0x” prefix and writing it out to the EEPROM using i2cset.</p>



<p>After running this code, I re-read the EDID from the dummy plug and checked to see if it matched the file I started from:</p>


<div><pre title="">get-edid -b $edid_i2c &gt; edid-test.bin
diff edid-test.bin edid-capture-card.bin
</pre></div>


<p>The diff command produced no output at all, which indicated that the new dump was identical. The dummy plug’s EEPROM had successfully been reprogrammed with the EDID from my capture device!</p>



<p>Of course, at this point I anxiously plugged it into my test computer, powered the computer up, and noticed that everything was great and it acted as though my HDMI capture device was plugged in instead of a 4K monitor. Success!</p>



<p>I thought I’d share this procedure in case it’s useful for someone else in the future. You could probably also use this solution to go in the opposite direction — upgrading an old 1080p dummy plug to add 4K support. <strong>Again, be careful with these commands!</strong> I wouldn’t recommend tinkering with I<sup>2</sup>C writes on an actual PC. Use a Raspberry Pi so you don’t accidentally brick your desktop PC.</p>
			  
			</div></div>
  </body>
</html>
