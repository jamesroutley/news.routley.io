<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/choosing-a-postgres-primary-key">Original</a>
    <h1>Choosing a Postgres Primary Key</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>Primary keys are important. They uniquely identify rows of data in tables, and make it easy to fetch data. The job of a database is to archive and recall data and you&#39;re going to have a hard time finding data without a good primary key or a good index.</p>
<p>Sometimes it makes sense to use a <a href="https://en.wikipedia.org/wiki/Natural_key">“natural key”</a> (like an <code>email</code> column in a <code>users</code> table) and sometimes it’s better to use a “<a href="https://en.wikipedia.org/wiki/Surrogate_key">surrogate key”</a>, a value made <em>for the purpose</em> of identifying a row (and has no other meaning).</p>
<p>At first glance, the question of <em>which</em> primary key to use is easy! Just throw a <code>integer</code>/<code>serial</code> on there, right? Numeric IDs are cool, but what about random value IDs or <a href="https://en.wikipedia.org/wiki/Uuid">Universally Unique IDentifiers (UUIDs)</a>?</p>
<p>Turns out the question of which identifier (and in this case, UUID) to use is complicated -- we&#39;re going to dive into some of the complexity and inherent trade-offs, and figure things out:</p>
<ul>
<li>What are the choices for identifiers?</li>
<li>If we choose to use/add UUIDs, which ones should we choose?</li>
<li>How can we get these UUIDs into postgres?</li>
<li>Which UUIDs perform best?</li>
</ul>
<p>But first, a quick history lesson.</p>
<h2 id="a-brief-history-of-identifiers-and-why-we-use-them">A brief history of identifiers and why we use them</h2>
<h3 id="integerbiginteger"><code>integer</code>/<code>biginteger</code></h3>
<p>Let&#39;s think about identifying rows of data from first principles. What&#39;s the first way you might think of identifying things? Assigning them numbers!</p>
<p>We can set up a table like this:</p>

<p>This looks great, but what should <code>id</code> be on new rows? I don&#39;t know -- maybe the application can figure it out? If they store some value in memory? That doesn&#39;t seem right.</p>
<p>Maybe we could figure out the next integer from what&#39;s in the table itself -- we just need to be able to &#34;count&#34; upwards. We <em>do</em> have all the <code>users</code> tables rows in there, so we should be able to do it:</p>

<p>After running that query, we can double check our results:</p>

<table><thead><tr><th>id</th><th>email</th><th>name</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>new@example.com</code></td><td><code>new user</code></td></tr><tr><td><code>2</code></td><td><code>new2@example.com</code></td><td><code>new user</code></td></tr></tbody></table>
<p>Using <code>COUNT(*)</code> in our query is not the most efficient (or even easiest) solution though, and hopefully it&#39;s clear why -- <strong>counting a sequence of numbers for primary keys is a feature built in to Postgres</strong>!</p>
<p><a href="https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL">serial/bigserial</a> is the right tool in our toolbox to maintain a shared, auto-incrementing sequence of numbers. Let&#39;s pretend we read the <a href="https://www.postgresql.org/docs">postgres documentation</a> and use those instead.</p>
<h3 id="serialbigserial"><code>serial</code>/<code>bigserial</code></h3>
<p><code>serial</code> is essentially a convenient macro for using <a href="https://www.postgresql.org/docs/current/sql-createsequence.html">Postgres sequences</a>, a database-managed auto-incrementing stream of <code>integer</code>.</p>
<p>Let&#39;s hear it from the docs:</p>
<blockquote>
<p>The data types <code>smallserial</code>, <code>serial</code> and <code>bigserial</code> are not true types, but merely a notational convenience for creating unique identifier columns (similar to the <code>AUTO_INCREMENT</code> property supported by some other databases).</p>
</blockquote>
<p>Using a <code>serial</code> column to create the <code>users</code> table would look like this:</p>

<p>OK, now let&#39;s try inserting into it - we shouldn&#39;t have to specify <code>id</code>:</p>


<table><thead><tr><th>id</th><th>email</th><th>name</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>user@example.com</code></td><td><code>new user</code></td></tr></tbody></table>

<p>It works, as you might expect - now the application doesn&#39;t have to <em>somehow magically know</em> the right ID to use when inserting.</p>
<p>But what does <code>serial</code> actually do? Using a serial column is operationally similar to the following SQL:</p>

<p>Back in application land, the <code>INSERT</code> statement returns, and provides the new <code>id</code> the database assigned our new row. Multiple application instances don&#39;t need to coordinate what ID to use -- they just <em>don&#39;t</em>, and find out from the database.</p>
<p><strong>We&#39;ve taken a somewhat meandering path to get here, but this is the standard solution for most reasonable database schemas.</strong></p>
<h3 id="why-not-stop-at-serial">Why not stop at <code>serial</code>?</h3>
<p>There are few issues with sequences:</p>
<ul>
<li>When writing automation that simply iterates through id values, note that <code>serial</code> columns  can have gaps, even if you never <code>DELETE</code> (e.x. if an <code>INSERT</code> was rolled back — sequences live <em>outside</em> transactions).</li>
<li>When used from outside code <code>serial</code> may leak some data or give attackers an edge (e.x., if <code>yoursite.com/users/50</code> works, how about <code>yoursite.com/users/51</code>?).</li>
<li><code>serial</code> is PostgreSQL specific (i.e. not SQL standards compliant)</li>
</ul>
<p>Don&#39;t be too put off by these reasons -- <code>serial</code> is still the go-to for most use-cases.</p>
<p>Even the last point about <code>serial</code> not being standards compliant is solved in Postgres 10+ by using...</p>
<h3 id="integerbiginteger-again"><code>integer</code>/<code>biginteger</code> (again!)</h3>
<p>Postgres 10 <a href="https://www.postgresql.org/docs/10/release-10.html#id-1.11.6.26.5.7">added support</a> for the <code>IDENTITY</code> column syntax in <code>CREATE TABLE</code> (EDB has a great writeup on the <a href="https://www.enterprisedb.com/blog/postgresql-10-identity-columns-explained">addition</a>).</p>
<p>This means we can happily go back to using <code>integer</code>/<code>biginteger</code>:</p>

<p>So how does <em>this</em> work? Postgres does the same thing under the covers -- it generates a <code>sequence</code>. As this syntax is standards compliant, it&#39;s generally recommended practice for DBAs going forward, for the sake of the realm.</p>
<p><strong>So <code>integer</code>s are great, but information leakage is still a problem. How do we fix that?</strong> Well, make the numbers random, obviously.</p>
<h3 id="random-numeric-ids">Random Numeric IDs</h3>
<p>Let&#39;s say the application using the DB has some <a href="https://python.org">Python</a> code like the following:</p>

<p>That <em>looks</em> good, but there&#39;s a problem -- <a href="https://docs.python.org/3/library/random.html">random</a> is a <em>pseudorandom</em> generator.</p>
<p><a href="https://en.wikipedia.org/wiki/Pseudorandomness">Pseudo-random</a> numbers are <em>not</em> what we want for ensuring user IDs cannot be easily guessed/collide. It&#39;s possible to get the exact same sequence of values out of a pseudo-random number generator by using the same <em>seed value</em>.</p>
<p>Sometimes you <em>want</em> pseudo-random behavior (let&#39;s say for testing or fuzzing), but it&#39;s generally not desired for production systems that might run from a duplicated identical application image, since they <em>could</em> have weak pseudo-random seed initialization.</p>
<h3 id="secure-random-numeric-ids">(Secure) Random Numeric IDs</h3>
<p><strong>At the very least</strong> we need a properly secure random numbers -- we need Python&#39;s <a href="https://docs.python.org/3/library/secrets.html">secrets</a> module:</p>

<p>Now we have a secure random value coming in for our user IDs. But having values like <code>583247</code> and <code>8923916</code> get generated are cool and all, but there are a few problems:</p>
<ul>
<li>These numbers are random <em>and</em> quite inscrutable</li>
<li>The keyspace is fairly small (maybe good for comments on a popular website, but not for IDs!)</li>
<li>People can still <em>technically</em> check them all (the guessing space is 1 to <code>MAX_RANDOM_USER_ID</code>!)</li>
</ul>
<p>We need something better.</p>
<h3 id="secure-random-uuids">(Secure) Random UUIDs</h3>
<p>Along comes UUIDs -- you&#39;re probably used to seeing them now, values like this UUIDv4:</p>
<p><code>468e8075-5815-4fe2-80d3-45a31827954b</code> .</p>
<p>They&#39;re <em>very</em> random (almost always generated with secure random sources), and while they&#39;re even worse for remembering, they&#39;re near impossible to practically guess -- the search space is just too large!</p>
<p>More importantly, UUIDs introduce methodology to the madness -- different versions of UUID are derived different ways -- combined with other sources of randomness or known values.</p>
<p>There are a lot of <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Versions">versions of UUID</a>, but let&#39;s discuss the ones we&#39;re more likely to use/see day to day.</p>
<h3 id="uuidv1">UUIDv1</h3>
<p><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_1_(date-time_and_MAC_address)">Version 1 UUIDs</a> have three two components:</p>
<ul>
<li>a 60 bit date-time (at nanosecond precision)</li>
<li>a 48 bit <a href="https://en.wikipedia.org/wiki/MAC_address">MAC address</a></li>
</ul>
<p>But where&#39;s the randomness? Well v1s assume that you <em>won&#39;t</em> generate a ton of values in the same nanosecond (and there are some extra bits reserved for differentiating even when you do), but another source is the MAC address. MAC addresses uniquely (usually) identify network cards -- which is a security risk -- and those bits can be made random.</p>
<p>Here&#39;s what a UUIDv1 looks like:</p>

<p>You can generate v1 UUIDs in Postgres natively thanks to the <a href="https://www.postgresql.org/docs/current/uuid-ossp.html">uuid-ossp contrib module</a>. Here&#39;s how to generate a v1 UUID with random MAC address:</p>

<h3 id="uuidv4">UUIDv4</h3>
<p>Version 4 UUIDs use <em>all</em> the available bits for randomness -- <em>122 bits worth</em>!.</p>
<p>UUIDv4s look like this:</p>

<p>These don&#39;t have a time component, but  they don&#39;t have in time they make up for in randomness -- it is <em>very</em> unlikely for them to collide, so they make for excellent Global Unique IDentifiers (&#34;GUID&#34;s).</p>
<p>We can generate them in Postgres like this (with <code>uuid-ossp</code>):</p>

<p>Since Postgres would catch a collision on a <code>PRIMARY KEY</code> or <code>UNIQUE INDEX</code> column, we&#39;re done right? If we want to generate UUIDs all we need to do is choose UUID v1 or V4, and we won&#39;t leak any schema structure information to the outside world, right?</p>
<p>This is a workable solution, but as you might expect, it&#39;s not that easy.</p>
<h3 id="the-post-uuidv1v4-era-a-cambrian-explosion-of-identifiers">The Post-UUIDv1/v4 era: A Cambrian explosion of identifiers</h3>
<p><span><span><img alt="thats-alot-of-uuids.png" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>UUIDv1 and v4 were a start, but weren&#39;t enough for <em>many</em> companies out there. There are a couple shortcomings that plague both v1 and v2:</p>
<ul>
<li>UUIDs are twice the size of <code>bigint</code>/<code>bigserial</code></li>
<li>UUIDv1s contain a time element but they&#39;re <em>not</em> lexicographically sortable (this means they <code>SORT</code> terribly, relative to <code>integer</code> or a <code>timestamp</code> column)</li>
<li>UUIDv1s are less random than UUIDv4, and can collide/overlap in close enough time intervals, at large scale</li>
<li>UUIDv4s index <em>terribly</em>, as they&#39;re essentially random values (obviously, they <code>SORT</code> terribly as well)</li>
</ul>
<p>Many of the world&#39;s biggest companies generated UUIDs at speeds that made all of these deficiencies a problem.</p>
<p>A cambrian explosion of UUIDs resulted, as noticed by the IETF -- this resulted in the <a href="https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-01.html">new UUID formats</a> (v6,v7,v8) being published in 2021.</p>
<p>Here&#39;s a quick list (from that IETF document):</p>
<ul>
<li>LexicalUUID by <a href="https://blog.twitter.com/engineering">Twitter</a></li>
<li><a href="https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake">Snowflake</a> by <a href="https://blog.twitter.com/engineering">Twitter</a></li>
<li><a href="https://github.com/boundary/flake">Flake</a> by <a href="http://www.bmc.com/">Boundary (now BMC TrueSight Pulse)</a></li>
<li>ShardingID by <a href="http://instagram-engineering.com/">Instagram</a></li>
<li><a href="https://github.com/segmentio/ksuid">KSUID</a> by <a href="https://segment.com/blog/engineering/">Segment</a></li>
<li><a href="https://github.com/ppearcy/elasticflake">Elasticflake</a> by <a href="https://github.com/ppearcy/elasticflake">P. Pearcy</a></li>
<li><a href="https://github.com/s-yadav/FlakeId">FlakeID</a> by <a href="https://github.com/T-PWK">T. Pawlak</a></li>
<li><a href="https://github.com/sony/sonyflake">Sonyflake</a> by <a href="https://github.com/sony">Sony</a></li>
<li><a href="https://laravel.com/docs/5.7/helpers#method-str-ordered-uuid">orderedUuid</a> by <a href="https://darkghosthunter.medium.com/">IT. Cabrera</a></li>
<li>COMBGUID by <a href="https://github.com/richardtallent">R. Tallent</a></li>
<li><a href="https://github.com/ulid/spec">ULID</a> by <a href="https://github.com/alizain">A. Feerasta</a></li>
<li><a href="https://github.com/chilts/sid">SID</a> by <a href="https://github.com/chilts">A. Chilton</a></li>
<li><a href="https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html">pushID</a> by <a href="https://google.com/">Google</a></li>
<li><a href="https://github.com/rs/xid">XID</a> by <a href="https://github.com/rs">O. Poitrey</a></li>
<li><a href="https://www.mongodb.com/docs/manual/reference/method/ObjectId/">ObjectID</a> by <a href="https://www.mongodb.com/blog/channel/engineering-blog">MongoDB</a></li>
<li><a href="https://github.com/ericelliott/cuid">CUID</a> by <a href="https://github.com/ericelliott">E. Elliott</a></li>
</ul>
<p>That&#39;s... A lot of UUIDs. They&#39;re all slightly different, but the innovation was summed up by the IETF:</p>
<blockquote>
<p>An inspection of these implementations details the following trends that help define this standard:</p>
<ul>
<li>Timestamps MUST be k-sortable. That is, values within or close to the same timestamp are ordered properly by sorting algorithms.</li>
<li>Timestamps SHOULD be big-endian with the most-significant bits of the time embedded as-is without reordering.</li>
<li>Timestamps SHOULD utilize millisecond precision and Unix Epoch as timestamp source. Although, there is some variation to this among implementations depending on the application requirements.</li>
<li>The ID format SHOULD be Lexicographically sortable while in the textual representation.</li>
<li>IDs MUST ensure proper embedded sequencing to facilitate sorting when multiple UUIDs are created during a given timestamp.</li>
<li>IDs MUST NOT require unique network identifiers as part of achieving uniqueness.</li>
<li>Distributed nodes MUST be able to create collision resistant Unique IDs without a consulting a centralized resource.
<strong>The IETF went on to introduce three 3 new types of UUIDs</strong> that have these properties these companies were looking for: UUIDv6, UUIDv7, and UUIDv8.</li>
</ul>
</blockquote>
<p>So what&#39;s the difference you ask?</p>
<ul>
<li><strong>UUIDv6</strong> - 62 bits of <a href="https://en.wikipedia.org/wiki/Gregorian_calendar">gregorian</a> time + 48 bits of randomness</li>
<li><strong>UUIDv7</strong> - 36 bits of big endian unix timestamp (seconds since epoch + leapseconds w/ optional sub-second precision) + variable randomness up to 62 bits</li>
<li><strong>UUIDv8</strong> - variable size timestamp (32/48/60/64 bits) + variable size clock (8/12 bits) + variable randomness (54/62 bits)</li>
</ul>
<p>It&#39;s not quite easy to work out what this all <em>means</em> but let&#39;s boil it down:</p>
<ul>
<li>All of these UUIDs sort properly (the &#34;high bits&#34; of time are first, like putting the year before the month -- &#34;2022/07&#34;)</li>
<li>UUIDv6 <em>requires</em> randomness</li>
<li>The data contained in the UUID can be variable (ex. UUIDv8), this means you can bytes that mean something else (ex. an encoding of the compute region you&#39;re running in)</li>
</ul>
<p>Alright, done hearing about UUIDs? Let&#39;s get to the fun part.</p>
<h2 id="benchmarking-id-generation-with-uuid-ossp-and-pg_idkit">Benchmarking ID generation with <code>uuid-ossp</code> and <code>pg_idkit</code></h2>
<p>With the history lesson behind us, let’s benchmark these ID generation mechanisms against each other! For UUIDv1 and UUIDv4 we can use <a href="https://www.postgresql.org/docs/current/uuid-ossp.html">uuid-ossp</a>.</p>
<p>Unfortunately, <code>uuid-ossp</code> isn&#39;t <em>quite</em> so advanced as to have many of these newer UUIDs we&#39;ve been discussing, so we’ll pull in <a href="https://github.com/t3hmrman/pg_idkit">pg_idkit</a> here.</p>
<p><a href="https://github.com/t3hmrman/pg_idkit">pg_idkit</a> is built with Rust, so it gives us access to the following ID generation crates:</p>
<ul>
<li><a href="https://crates.io/crates/nanoid">nanoid</a> (a <a href="https://www.npmjs.com/package/nanoid">well known package</a> from the NodeJS ecosystem)</li>
<li><a href="https://crates.io/crates/ksuid">ksuid</a></li>
<li><a href="https://crates.io/crates/ulid">ulid</a></li>
<li><a href="https://crates.io/crates/rs-snowflake">rs-snowflake</a> (Twitter&#39;s Snowflake algorithm)</li>
<li><a href="https://crates.io/crates/timeflake-rs">timeflake-rs</a> (Inspired by Twitter&#39;s Snowflake, Instagram&#39;s ID and Firebase&#39;s PushID)</li>
<li><a href="https://crates.io/crates/sonyflake">sonyflake</a></li>
<li><a href="https://crates.io/crates/pushid">pushid</a></li>
<li><a href="https://crates.io/crates/xid">xid</a></li>
<li><a href="https://crates.io/crates/cuid">cuid</a></li>
<li><a href="https://crates.io/crates/uuidv6">uuidv6</a></li>
<li><a href="https://crates.io/crates/uuid7">uuid7</a></li>
</ul>
<p>For each type of UUID, we can test the following:</p>
<ul>
<li><strong>Generation speed:</strong> **How fast can I generate IDs (let&#39;s say 1,000,000 of them)?</li>
<li><strong>Table &amp; Index size:</strong> How much larger do tables and associated indices get?</li>
</ul>

<h3 id="generation-speed">Generation speed</h3>
<p>Generation speed is pretty easy to test, we can enable <code>\\timing</code> mode on <code>psql</code> and run a simple benchmark with <code>generate_series</code>:</p>

<p>Running all of the ID generation mechanisms on a <em>single core</em> of my machine (which happens to be an <a href="https://system76.com/laptops/oryx">Oryx Pro</a>), the lowest of 5 runs for each ID looks like this:</p>
<p><span><span><img alt="Generation speed test" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>To be fair, <strong>generation speed shouldn’t be a deal breaker</strong> as it’s unlikely to be the bottle neck for most applications. That said, it is nice to have some data on where each ID generation mechanism lands.</p>

<h3 id="table--index-size">Table &amp; Index size</h3>
<p>We can check the size of our tables &amp; related indices with this query (after running <code>VACUUM</code>):</p>

<p>Here are the sizes in tabular form:</p>
<p><span><span><img alt="Sizes in tabular form" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>These numbers are <em>mostly</em> a reflection of the <em>length</em> of the default settings of <code>pg_idkit</code> but probably worth having in front of you anyway.</p>
<p>With this, we probably have enough information to make a decision (and a new library to generate our UUIDs with)!</p>
<h2 id="which-id-should-you-use">Which ID should you use?</h2>
<p>As usual, <em>it depends</em> -- you didn&#39;t think it&#39;d be that easy, did you?</p>
<p>All I can offer are some general rules of thumb that hopefully work for you:</p>
<ul>
<li><code>integer</code>s and <code>serial</code> have obvious benefits for simplicity, storage, and sortability. You <em>might</em> not want to expose them to the world though.</li>
<li>If you want the ultimate in collision avoidance UUIDv4 is OK</li>
<li>UUIDv1 <em>could</em> have been great, <em>but</em> it doesn&#39;t lexicographically sort.</li>
<li>The best time-based ID seems to be <code>xid</code>, with good performance <em>and</em> sort friendliness</li>
<li>If you want to be a little more standards-oriented, UUID v6/v7</li>
</ul>
<p>As usual, the best results will come from weighing all the options and finding what&#39;s best for your use-case, and doing appropriate testing on your data.</p>
<h2 id="possible-improvements">Possible Improvements</h2>
<p>We’ve done some good exploration so far, but here are some ideas for interesting use cases for <code>pg_idkit</code> and measuring the impact of ID generation using it.</p>
<h3 id="usecase-generating-our-created_at-columns-from-our-ids">Usecase: Generating our <code>created_at</code> columns from our IDs</h3>
<p>One interesting feature would be using at least partially time-based UUIDs for <code>created_at</code> columns -- we could save space by <em>virtualizing</em> our <code>created_at</code> columns:</p>

<p>Ideally we could use the <code>GENERATED ALWAYS AS ( ... )</code> syntax for <a href="https://www.postgresql.org/docs/current/ddl-generated-columns.html">generated columns</a> while creating the table, but as the time of this post <em>Postgres does not yet support virtual generated columns (only stored ones)</em>.</p>
<h3 id="benchmarking-measuring-index-fragmentation">Benchmarking: Measuring index fragmentation</h3>
<p>How fragmented do our indices get after use of each of these methods?</p>
<p>Luckily for us Postgres has the <a href="https://www.postgresql.org/docs/current/pgstattuple.html">pgstattuple extension</a> so we can find out -- thanks to <a href="https://dba.stackexchange.com/questions/273556/how-do-we-select-fragmented-indexes-from-postgresql">Laurenz Albe on StackOverflow</a>).</p>
<p>Integrating and including these tests in the <code>pg_idkit</code> README would greatly help people looking to make a decision.</p>
<h3 id="benchmarking-measuring-sort-friendliness">Benchmarking: Measuring <code>SORT</code> friendliness</h3>
<p>Another great metric to measure might be performance of these indices on certain common <code>SORT</code> patterns. While this is inherently workload-specific, it would be great to pick a workload and see what we get.</p>
<p>In most code bases, simple <code>WHERE</code> queries with <code>SORT</code>s abound, and one of the big benefits of UUIDv6, UUIDv7 and the other alternatives is lexicographic sorting, after all.</p>
<p>Knowing <em>just how good</em> a certain ID generation method is at maintaining locality would be nice to know.</p>
<p>Creating and using a function like <code>idkit_uuidv1_extract_timestamptz</code> and using it in a <a href="https://www.postgresql.org/docs/14/indexes-expressional.html">“functional index” (an index on an expression)</a> could resolve the sort unfriendliness of UUIDv1 as well!</p>
<h2 id="wrap-up">Wrap-up</h2>
<p>Identifiers have a long history and are surprisingly unsolved at present. It can be confusing but thanks to the power of Postgres we don&#39;t have to over-think it -- tables can be migrated from one ID pattern to another, and we can use DDL statements in transactions.</p>
<p>Hopefully this article helps you head off some bikeshedding with your teammates when you next discuss which IDs are best to use.</p>
<h2 id="more-postgres-articles">More Postgres articles</h2>
<ul>
<li><a href="https://supabase.com/blog/partial-postgresql-data-dumps-with-rls">Partial data dumps using Postgres Row Level Security</a></li>
<li><a href="https://supabase.com/blog/postgresql-views">Postgres Views</a></li>
<li><a href="https://supabase.com/blog/audit">Postgres Auditing in 150 lines of SQL</a></li>
<li><a href="https://supabase.com/blog/cracking-postgres-interview">Cracking PostgreSQL Interview Questions</a></li>
<li><a href="https://supabase.com/blog/postgresql-templates">What are PostgreSQL Templates?</a></li>
<li><a href="https://supabase.com/blog/realtime-row-level-security-in-postgresql">Realtime Postgres RLS on Supabase</a></li>
<li><a href="https://supabase.com/blog/seen-by-in-postgresql">Implementing &#34;seen by&#34; functionality with Postgres</a></li>
</ul></div></article></div>
  </body>
</html>
