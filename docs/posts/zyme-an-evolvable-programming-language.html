<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zyme.dev">Original</a>
    <h1>Show HN: Zyme – An Evolvable Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div>
      <section id="introduction">
        <p>
          
          <h2>an evolvable language for genetic programming</h2> 
        </p>
        <div>
          <p>
            Zyme is an <a href="https://en.wikipedia.org/wiki/Esoteric_programming_language">esoteric</a> language for <a href="https://en.wikipedia.org/wiki/Genetic_programming">genetic programming</a>: creating computer programs by means of natural selection.
          </p>
          <p>
            For successful evolution mutations must generate a wide range of phenotypic variation, a feat nearly impossible when randomly modifying the code of conventional programming languages.
            Zyme is designed to maximize the likelihood of a bytecode mutation creating a novel yet non-fatal change in program behavior.
          </p>
          <p>
            Diverging from conventional register or stack-based architectures, Zyme uses a unique molecular automaton-based virtual machine, mimicking an abstract cellular metabolism.
            This design enables fuzzy control flow and precludes invalid runtime states, transforming potential crashes into opportunities for adaptation.
          </p>
       </div>
      </section>
      <section id="demonstration">
        <section>
          <h2>Interactive demonstration</h2>
        </section>
        <section id="story_source">
          
          <div>
            <h3>Compile the source code</h3>
            <p>
              Genetic programming begins with an initial program, often generated randomly.
              However, evolution can be impeded by an unsuitable choice of this initial program.
              Two common ways in which programs prove inadequate are:
            </p>
            <ul>
                <li>
                  The program may be too small and lack complexity, rendering it overly fragile.
                </li>
                <li>
                  The program&#39;s behaviour might not produce output in the required format (or any output at all), preventing meaningful evaluation.
                  For example, if a program should return a single byte representing a category in a <a href="https://en.wikipedia.org/wiki/Statistical_classification">classification problem</a>, but fails to return anything, there&#39;s nothing to assess.
                </li>
              </ul>
            
            <p>
              The Zyme assembler compiles human-readable source code into the mutable bytecode, enabling you to build bespoke initial programs for specific machine learning tasks.
            </p>
          </div>
        </section>
        <section>
          
        </section>
        <section>
          <div>
            <legend id="bytecode_title">
              <h3>Bytecode</h3>
            </legend>
            <div id="mutable_bytecode">
              
              <p id="initial_prompt">Compile source code to generate bytecode</p>
            </div>
          </div>
          <div>
            <h3>Mutate the bytecode</h3>
            <p>Click on each byte to mutate it.</p>
            <p>
              This <span>&#34;Hello Creatures.&#34;</span> source code generates three strands, which are the primitive data structure of the Zyme virtual machine.
              Strands are just arrays of bytes, however - given they are <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a> - they are interpreted as both code (a sequence of instructions) and data (a sequence of integer values).
            </p>
            <p>
              The strands are concatenated, with empty or null bytes <span>00</span> as separators to produce the bytecode ready for mutation.
            </p>
            <p>
              Any binary data is valid bytecode on the Zyme virtual machine.
              This design ensures that programs cannot crash; however, they may instead return no output or perform no useful function.
            </p>
            <p>
              Try to mutate the bytecode to reveal the hidden message<sup><a href="#hidden_hint">1</a></sup>.
            </p>
          </div>
        </section>
        <section>
          
        </section>
        <section>
          
          <div>
            <h3>Execute the program</h3>
            <p>
              The Zyme virtual machine executes input bytecode by first splitting it into its constituent strands, then evaluating each independently and in parallel.
              Within each strand, execution proceeds sequentially, with each byte encoding an individual opcode.
              These instructions manipulate the state of the current strand to perform various arithmetic, logical and control flow operations.
            </p>
            <p>
              Strands interact by binding to one another to form temporary <a href="https://en.wikipedia.org/wiki/Protein_complex">complexes</a>.
              Specific machine instructions control when and how binding occurs.
              For instance, the <span>WAIT</span> instruction opens a binding site, and the <span>LOAD</span> instruction binds to a waiting open site.
            </p>
            <p>
              Binding can only occur successfully when the motif sequences associated with the binding sites match.
              Motifs are specified after the instruction, e.g., <span>WAIT</span> <span>%”ABCDABCD”</span> <span>|</span>.
              Importantly, these motifs do not require exact matches, allowing for fuzzy control flow.
            </p>
          </div>
        </section>
      </section>
      <section id="essay">
        <section>
          <div>
            <h2>Zyme in practice</h2>
            <p>
              While mutating the <span>“Hello Creatures.”</span> program above to produce garbled output (or revealing the <span>“Secret!”</span> message) may illustrate the quirky features of Zyme, it is far from real-world machine learning.
              This example was selected as a familiar context to illustrate core features of the virtual machine, like its fuzzy matching motif system, rather than reflecting a practical application.
              Nevertheless, Zyme does include tools for creating sophisticated initial programs beyond this simple demonstration.
              Further, preliminary experiments indicate that mutating these programs can generate non-trivial variation in behaviour, indicating that, maybe, just maybe, Zyme could serve as a foundation for a novel machine learning approach.
            </p>
          </div>
          
        </section>
        <section>
          <div>
            <h3>Language features</h3>
            <p>
              The design of Zyme&#39;s language balances the capacity for abstraction with evolutionary potential.
              While abstraction and encapsulation help developers manage complexity by dividing programs into independent components and modules, this can conflict with the goal of being an evolvable language.
              A primary benefit of modularization — preventing unintended interactions between independent components — can impede evolution.
              These interactions aren&#39;t inherently harmful; rather, the risk lies in manipulating data structures in ways that breach abstraction boundaries, potentially leading to unpredictable or undefined behaviour.
            </p>
            <p>
              Traditional programming languages view this undefined behaviour as dangerous.
              However, in the context of an evolvable language like Zyme, this unpredictability becomes a feature.
              It&#39;s precisely this potential for unexpected interactions that drives evolution in the system.
            </p>
            <p>
              Zyme employs macros to create abstractions without restricting runtime interactions.
              These macros can group functionally related strands, allowing them to be treated as single units in the source code.
              During compilation, any explicit trace of the groups is lost as all strands are ultimately compiled to byte arrays.
              This ensures that when resulting bytecode undergoes mutation, nothing prevents potential interactions between strands, regardless of their original source code organisation.
            </p>
            <p>
              <a href="#src1">Source 1</a> illustrates a macro that transforms a given sequence of instructions into a ‘function’ call by emulating a stack frame.
              Instead of executing instructions directly within a &#39;caller&#39; strand, they are placed in a separate &#39;callee&#39; strand, which is then invoked through the motif binding system.
              The outcome is that this macro abstracts over the motif system involved in managing multiple strands, making it transparent to the user at the point of use (shown in <a href="#src2">Source 2</a>).
            </p>
            <p>
              To elaborate, the first line in <a href="#src1">Source 1</a> defines the <span>remote</span> macro, which takes a single argument, <span>block</span> - the block of instructions to be called in a separate stack frame.
              The macro&#39;s body uses a nested lexical scope, denoted by <span>{ ... }</span>, where new definitions are locally confined.
              Within this scope, the first statement defines <span>address</span>, which serves as the unique motif for strand binding.
              Rather than specifying it literally, <span>%</span> is used to generate a fresh motif: a new motif guaranteed to be unique by the compiler.
              This feature allows multiple calls to the macro, as each instance will contain a distinct motif locally bound to <span>address</span>.
            </p>
            <p>
              Next a new strand is generated that will open a new binding site containing the <span>address</span> motif, using <span>WAIT</span> instruction as seen in the initial interactive demonstration.
              The block of instructions provided as the argument, <span>block</span> is then inserted into this strand, followed by the <span>RTRN</span> instruction.
              This will become the ‘callee’ strand.
            </p>
            <p>
              The macro concludes with the <span>emit</span> keyword, specifying what remains in place of the lexical scope after macro evaluation.
              In this instance, it&#39;s a sequence of instructions that initiates the &#39;function&#39; call using the <span>CALL</span> instruction on the <span>address</span> motif.
              This will become part of the ‘callee’ strand.
              Note, both the generated &#39;callee&#39; strand and the instructions in the &#39;caller&#39; strand now operate with the same shared motif.
            </p>
            <p>
              When executed in the virtual machine, the <span>CALL</span> instruction causes the two strands to bind, temporarily shifting execution control from the &#39;caller&#39; strand&#39;s call site to the &#39;callee&#39; strand.
              Execution resumes where the &#39;callee&#39; strand was waiting - after the <span>address</span> motif consumed by the <span>WAIT</span> instruction, at the start of the <span>block</span> argument passed to the macro.
              Once the <span>block</span> instructions complete, the <span>RTRN</span> instruction triggers strand unbinding, returning control to the &#39;caller&#39; strand&#39;s waiting point: after the <span>address</span> motif consumed by the <span>CALL</span> instruction.
            </p> 
            <p>
              Try this macro by copying <a href="#src1">Source 1</a> into the initial interactive demonstration source code, and substituting the original <span>trim_motif</span> macro with <a href="#src2">Source 2</a>.
              Note, in <a href="#src2">Source 2</a>, the square brackets <span>[ ... ]</span> group instructions into a single argument for the <span>remote</span> macro.
              These changes do not change the initial program’s behaviour, however the resulting bytecode now contains an additional strand.
            </p>
            <p>
              Despite targeting a virtual machine with an esoteric instruction set, the Zyme enables developers to create abstractions and write structured code, without compromising on evolutionary potential.
            </p>
          </div>
          <div>
            <div id="src1">
              <legend><h3>Source 1</h3></legend>
              <pre><span>let</span> remote block <span>=&gt;</span> <span>{</span>
    <span>let</span> address <span>=&gt;</span> <span>%</span> <span>;</span>
    WAIT address <span>|</span> block RTRN <span>;</span>

    <span>emit</span> <span>=&gt;</span> CALL address <span>|</span> <span>;</span>
<span>};</span></pre>
            </div>
            <div id="src2">
              <legend><h3>Source 2</h3></legend>
              <pre><span>let</span> trim_motif <span>=&gt;
    </span>remote <span>[</span> insert_empty <span>|</span>&gt; <span>|</span>&gt; <span>] ;</span></pre>
            </div>
          </div>
        </section>
        <section>
          <div>
            <h3>Machine learning and mutations</h3>
            <p>
              For Zyme to serve as a viable foundation for a machine learning approach, it must be possible to effectively evolve its bytecode.
              This means significantly improving program performance through iterative random mutations.
            </p>
            <p>
              This approach to optimising or improving computer programs - <a href="https://en.wikipedia.org/wiki/Genetic_programming">genetic programming</a> - is not new and has a rich <a href="https://link.springer.com/journal/10710">literature</a>.
              The process operates with a population of programs in a two-step cycle of mutation and selection.
              Traditionally, the first generation starts with a population of random programs, in this case I used a population constructed in the manner I described earlier.
              This process operates as follows:
            </p>
            <ol>
              <li>
                mutation - randomly mutate programs in the current population of programs to generate new candidate programs.
              </li>
              <li>
                selection - evaluate each new candidate program&#39;s performance by assessing its ability to produce desired outputs for given inputs, similar to supervised learning.
                Choose the top-performing programs to form the next generation&#39;s population.
              </li>
            </ol>
            <p>
              The process repeats, and theoretically the performance of the programs should improve over successive generations.
            </p>
            <p>
              But does this work in practice for Zyme?
            </p>
            <p>
              In the loose sense, Zyme works; I can observe performance improvements over time as programs undergo mutation.
              While it is not hard to find mutations that improve the performance at a given task, this phenomenon isn&#39;t unique to Zyme; randomly adjusting parameters of any machine learning system or statistical model would likely exhibit some degree of improvement over time.
              The critical issue is whether mutations of Zyme bytecode can reliably produce non-trivial improvements, potentially yielding results competitive with established machine learning methods.
            </p>
            <p>
              This is something I am actively exploring.
              I am currently testing Zyme on small-scale problems to assess its effectiveness and resolve unforeseen issues that emerged after the design phase.
              The results, while limited so far, are encouraging.
            </p>
            <p>
              I have been exploring many different ways to mutate the bytecode - often referred to as genetic operators - from single point mutations to more elaborate cross over techniques.
              Interestingly, I have observed that programs quickly increase their resistance to mutations over the first few generations.
              In multiple trials, I&#39;ve observed that a specific mutation regime (combining point mutations and crossover) initially results in only a ~3% survival rate of mutated programs.
              Where survival here means the program still outputs a correctly formatted return value, allowing for evaluation of program performance.
              However, in subsequent generations the survival rate can increase up to as high as ~60%.
            </p>
            <p>
              It&#39;s tempting to attribute this phenomenon to bloat-induced statistical artifact.
              <a href="https://ieeexplore.ieee.org/abstract/document/6792715">Bloat</a> happens when programs expand uncontrollably, often incorporating &#39;dead-code&#39; regions in the bytecode that don&#39;t provide any functionality or improve performance directly.
              This surplus code may dilute effects of mutation, and by potentially protecting the functional bytecode, result in an increase in mutation resistance.
            </p>
            <p>
              While I&#39;ve observed bloat in Zyme, I don’t think this is driving the increase in mutation resistance and survival rate.
              Surprisingly, as the survival rate of mutated programs increases, I&#39;m also observing a significant increase in variation in performance among these programs at each generation.
            </p>
            <p>
              In early generations, when survival rates are ~3%, most surviving mutations are <a href="https://en.wikipedia.org/wiki/Synonymous_substitution">synonymous</a> – new programs typically maintain the same performance as their predecessors, with performance improvements being very rare.
              However, in later generations as survival rates climb, I observe a shift: fewer synonymous mutations and more non-fatal mutations that alter performance levels.
              This simultaneous increase in mutation resistance, survival rate, and performance variation seems counterintuitive if bloat were the primary driver?
            </p>
            <p>
              I am not sure what is going on here, but this is one of many interesting early observations.
              Our next steps are to start scaling up to see how Zyme performs on less trivial problems.
            </p>
          </div>
          
        </section>
      </section>
      
    </div></div>
  </body>
</html>
