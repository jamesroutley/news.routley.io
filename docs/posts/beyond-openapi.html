<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antonz.org/interactive-api-tutorials/">Original</a>
    <h1>Beyond OpenAPI</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div><div><header></header><p>Not all documentation is created equal. According to the popular classification, there are four document types: tutorials, how-to guides, technical references, and explanations.</p><div><p><img alt="Four types of documentation" src="https://antonz.org/interactive-api-tutorials/documentation.png"/></p></div><p>OpenAPI, the de facto standard for documenting APIs, is a decent reference-style documentation (and client code generator, of course). But it can&#39;t serve as a good how-to or tutorial.</p><p>In this article, I will introduce a concise and readable way to write interactive tutorials and how-tos for any HTTP API (REST, RPC, or other style). And for that (surprise, surprise), we will rely on the HTTP protocol itself.</p><h2 id="a-crash-course-in-http-messages">A crash course in HTTP messages</h2><p>HTTP/1.x is a plain-text protocol that describes the communication between the client and the server. The client sends messages like this:</p><pre tabindex="0"><code>POST /anything/chat HTTP/1.1
host: httpbingo.org
content-type: application/json
user-agent: curl/7.87.0

{
    &#34;message&#34;: &#34;Hello!&#34;
}
</code></pre><p>And receives messages like this in response:</p><pre tabindex="0"><code>HTTP/1.1 200 OK
date: Mon, 28 Aug 2023 07:51:49 GMT
content-type: application/json

{
    &#34;message&#34;: &#34;Hi!&#34;
}
</code></pre><blockquote><p>HTTP/2, the successor to HTTP/1.1, is a binary protocol. However, all tools (such as the browser devtools or curl) display HTTP/2 messages in plain text (just like HTTP/1.1), so we can safely ignore this fact for our purposes.</p></blockquote><div><div><figure><img alt="HTTP request and response" src="https://antonz.org/interactive-api-tutorials/http-messages.png"/><figcaption>It&#39;s easy to read HTTP requests and responses once you get used to it.</figcaption></figure></div></div><p><strong>HTTP request</strong> consists of three main sections:</p><ol><li>Request line:</li></ol><pre tabindex="0"><code>POST /anything/chat HTTP/1.1
</code></pre><ul><li>The <em>method</em> (<code>POST</code>) defines the operation the client wants to perform.</li><li>The <em>path</em> (<code>/anything/chat</code>) is the URL of the requested resource (without the protocol, domain and port).</li><li>The <em>version</em> (<code>HTTP/1.1</code>) indicates the version of the HTTP protocol.</li></ul><ol start="2"><li>Request headers:</li></ol><pre tabindex="0"><code>host: httpbingo.org
content-type: application/json
user-agent: curl/7.87.0
</code></pre><p>Each header is a key-value pair that tells the server some useful information about the request. In our case it&#39;s the hostname of the server (<code>httpbingo.org</code>), the type of the content (<code>application/json</code>) and the client&#39;s self-identification (<code>user-agent</code>).</p><ol start="3"><li>Request body:</li></ol><pre tabindex="0"><code>{
    &#34;message&#34;: &#34;Hello!&#34;
}
</code></pre><p>The actual data that the client sends to the server.</p><p>The HTTP protocol is stateless, so any state must be contained within the request itself, either in the headers or in the body.</p><p><strong>HTTP response</strong> also consists of three main sections:</p><ol><li>Status line:</li></ol><pre tabindex="0"><code>HTTP/1.1 200 OK
</code></pre><ul><li>The <em>version</em> (<code>HTTP/1.1</code>) indicates the version of the HTTP protocol.</li><li>The <em>status code</em> (<code>200</code>) tells whether the request was successful or not, and why (there are many status codes for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">different situations</a>).</li><li>The <em>status message</em> is a human-readable description of the status code. HTTP/2 does not have it.</li></ul><ol start="2"><li>Response headers:</li></ol><pre tabindex="0"><code>date: Mon, 28 Aug 2023 07:51:49 GMT
content-type: application/json
</code></pre><p>Similar to request headers, these provide useful information about the response to the client.</p><ol start="3"><li>Response body:</li></ol><pre tabindex="0"><code>{
    &#34;message&#34;: &#34;Hi!&#34;
}
</code></pre><p>The actual data that the server sends to the client.</p><p>There is much more to the HTTP protocol, but this basic knowledge is enough to cover most of API use cases. So let&#39;s move on.</p><h2 id="using-http-to-document-api-usage">Using HTTP to document API usage</h2><p>We are going to take an HTTP request:</p><pre tabindex="0"><code>POST /anything/chat HTTP/1.1
host: httpbingo.org
content-type: application/json
user-agent: curl/7.87.0

{
    &#34;message&#34;: &#34;Hello!&#34;
}
</code></pre><p>And modify it just a little bit:</p><ul><li>include the full URL in the request line instead of the path;</li><li>remove the protocol version.</li></ul><pre tabindex="0"><code>POST http://httpbingo.org/anything/chat
content-type: application/json

{
    &#34;message&#34;: &#34;Hello!&#34;
}
</code></pre><p>This format is perfect for API usage examples. It&#39;s concise and readable, yet formal enough to be executed programmatically (directly from the documentation, as we&#39;ll see shortly).</p><h2 id="writing-an-interactive-api-guide">Writing an interactive API guide</h2><p>Instead of telling you how to write an interactive API tutorial, I&#39;m going to show you one. We&#39;ll use <a href="https://docs.github.com/en/rest/gists/gists">Gists API</a> as an example. It&#39;s a compact and useful GitHub service for storing code snippets (called &#34;gists&#34;).</p><div><div><figure><img alt="GitHub Gists" src="https://antonz.org/interactive-api-tutorials/gists.png"/><figcaption>Gists are quite handy when a full-blown Git repository is too much.</figcaption></figure></div></div><p>Even if you are not a GitHub user, you still have access to the Gists API.</p><h3 id="reading-gists">Reading gists</h3><p>Let&#39;s take a look at the <strong>public gists</strong> of my pal Redowan (user <code>rednafi</code>). The response can be quite chatty, so we&#39;ll only select the 3 most recent (<code>per_page = 3</code>):</p><pre tabindex="0"><code>GET https://api.github.com/users/rednafi/gists?per_page=3
accept: application/json
</code></pre><codapi-snippet sandbox="fetch" editor="basic"></codapi-snippet><p>A family of non-standard <code>x-ratelimit</code> headers tell us how GitHub <strong>limits</strong> our requests:</p><ul><li>There is a total number of <code>x-ratelimit-limit</code> requests available per hour.</li><li>We&#39;ve already used <code>x-ratelimit-used</code> requests.</li><li>So there are <code>x-ratelimit-remaining</code> requests left.</li></ul><p>We need to keep an eye on these to make sure we don&#39;t exceed the quota.</p><p>We can use a combination of <code>page</code> and <code>per_page</code> query parameters to select a <strong>slice of gists</strong>. For example, here are gists 10-15:</p><pre tabindex="0"><code>GET https://api.github.com/users/rednafi/gists?page=3&amp;per_page=5
accept: application/json
</code></pre><codapi-snippet sandbox="fetch" editor="basic"></codapi-snippet><p>Note that GitHub provides navigation links in the <code>link</code> header:</p><pre tabindex="0"><code>link:
    &lt;https://api.github.com/user/30027932/gists?page=2&amp;per_page=5&gt;; rel=&#34;prev&#34;,
    &lt;https://api.github.com/user/30027932/gists?page=4&amp;per_page=5&gt;; rel=&#34;next&#34;,
    &lt;https://api.github.com/user/30027932/gists?page=7&amp;per_page=5&gt;; rel=&#34;last&#34;,
    &lt;https://api.github.com/user/30027932/gists?page=1&amp;per_page=5&gt;; rel=&#34;first&#34;
</code></pre><p>That&#39;s thoughtful of them!</p><p>Okay, now let&#39;s take a look at the <strong>specific gist</strong> with id <code>88242fd822603290255877e396664ba5</code> (this one is mine; let&#39;s not bother Redowan anymore):</p><pre tabindex="0"><code>GET https://api.github.com/gists/88242fd822603290255877e396664ba5
accept: application/json
</code></pre><codapi-snippet sandbox="fetch" editor="basic"></codapi-snippet><p>We can see that there is a <code>greet.py</code> file written in the Python <code>language</code> with a certain <code>content</code>:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Greeter</span>:
</span></span><span><span>    <span>def</span> <span>__init__</span>(<span>self</span>, <span>greeting</span>):
</span></span><span><span>        <span>self</span><span>.</span><span>greeting</span> <span>=</span> <span>greeting</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>greet</span>(<span>self</span>, <span>who</span>):
</span></span><span><span>        <span>print</span>(<span>f</span><span>&#34;</span><span>{</span><span>self</span><span>.</span><span>greeting</span><span>}</span><span>, </span><span>{</span><span>who</span><span>}</span><span>!&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>gr</span> <span>=</span> <span>Greeter</span>(<span>&#34;Hello&#34;</span>)
</span></span><span><span><span>gr</span><span>.</span><span>greet</span>(<span>&#34;world&#34;</span>)
</span></span></code></pre></div><codapi-snippet sandbox="python" editor="basic"></codapi-snippet><p><em>(yep, you can also create interactive Python examples!)</em></p><p>Interestingly, the gist has a <code>history</code>. It appears that every time you edit a gist, GitHub creates a new version, while also keeping previous versions.</p><p>Let&#39;s get the <strong>earliest revision</strong>, which has a <code>version</code> = <code>4c10d27cfb163d654745f1d72f2c7ce14225b83b</code> (a bit long, I know):</p><pre tabindex="0"><code>GET https://api.github.com/gists/88242fd822603290255877e396664ba5/4c10d27cfb163d654745f1d72f2c7ce14225b83b
accept: application/json
</code></pre><codapi-snippet sandbox="fetch" editor="basic"></codapi-snippet><p>The code in the gist was much simpler back then:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>msg</span> <span>=</span> <span>&#34;Hello, world!&#34;</span>
</span></span><span><span><span>print</span>(<span>msg</span>)
</span></span></code></pre></div><codapi-snippet sandbox="python" editor="basic"></codapi-snippet><h3 id="modifying-gists">Modifying gists</h3><p>Okay, so we know how to list gists for a user, how to get a specific gist, and even how to get a specific revision. Now let&#39;s <strong>create a new gist</strong>!</p><pre tabindex="0"><code>POST https://api.github.com/gists
content-type: application/json
accept: application/json

{
    &#34;description&#34;: &#34;Greetings in Markdown&#34;,
    &#34;public&#34;: true,
    &#34;files&#34;:{
        &#34;README.md&#34;:{
            &#34;content&#34;:&#34;Hello, world!&#34;
        }
    }
}
</code></pre><codapi-snippet sandbox="fetch" editor="basic"></codapi-snippet><p>What&#39;s that? We have a <code>401 Unauthorized</code> error. The response body explains: &#34;requires authentication&#34; and even provides a link to the documentation (oh, I just love GitHub APIs).</p><p>Understandably, GitHub does not allow anonymous users to create new gists. We have to authenticate with an API token.</p><blockquote><p>If you want the following examples to work, enter your API token in the field below. You can create one with a &#39;gist&#39; scope in the <a href="https://github.com/settings/tokens">GitHub settings</a>.</p><p>After you enter the token below, it will be stored locally in the browser and will not be sent anywhere (except to the GitHub API when you click the Run button).</p></blockquote></div></div></article></div></div></div>
  </body>
</html>
