<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/magiblot/tvision">Original</a>
    <h1>Modern Turbo Vision 2.0</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">A modern port of Turbo Vision 2.0, the classical framework for text-based user interfaces. Now cross-platform and with Unicode support.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/20713561/81506401-4fffdd80-92f6-11ea-8826-ee42612eb82a.png"><img src="https://user-images.githubusercontent.com/20713561/81506401-4fffdd80-92f6-11ea-8826-ee42612eb82a.png" alt="tvedit on Konsole"/></a></p>
<p dir="auto">I started this as a personal project at the very end of 2018. By May 2020 I considered it was very close to feature parity with the original, and decided to make it open.</p>
<p dir="auto">The original goals of this project were:</p>
<ul dir="auto">
<li>Making Turbo Vision work on Linux by altering the legacy codebase as little as possible.</li>
<li>Keeping it functional on DOS/Windows.</li>
<li>Being as compatible as possible at the source code level with old Turbo Vision applications. This led me to implement some of the Borland C++ RTL functions, as explained below.</li>
</ul>
<p dir="auto">At one point I considered I had done enough, and that any attempts at revamping the library and overcoming its original limitations would require either extending the API or breaking backward compatibility, and that a major rewrite would be most likely necessary.</p>
<p dir="auto">However, between July and August 2020 I found the way to integrate full-fledged Unicode support into the existing arquitecture, wrote the <a href="https://github.com/magiblot/turbo">Turbo</a> text editor and also made the new features available on Windows. So I am confident that Turbo Vision can now meet many of the expectations of modern users and programmers.</p>
<p dir="auto">The original location of this project is <a href="https://github.com/magiblot/tvision">https://github.com/magiblot/tvision</a>.</p>

<ul dir="auto">
<li><a href="#what-for">What is Turbo Vision good for?</a></li>
<li><a href="#how-to">How do I use Turbo Vision?</a></li>
<li><a href="#downloads">Releases and downloads</a></li>
<li>Build environment
<ul dir="auto">
<li><a href="#build-linux">Linux</a></li>
<li><a href="#build-msvc">Windows (MSVC)</a></li>
<li><a href="#build-mingw">Windows (MinGW)</a></li>
<li><a href="#build-borland">Windows/DOS (Borland C++)</a></li>
<li><a href="#build-cmake">Turbo Vision as a CMake dependency</a></li>
</ul>
</li>
<li><a href="#features">Features</a></li>
<li><a href="#apichanges">API changes</a></li>
<li><a href="#applications">Applications using Turbo Vision</a></li>
<li><a href="#unicode">Unicode support</a></li>
<li><a href="#clipboard">Clipboard interaction</a></li>
<li><a href="#color">Extended color support</a></li>
</ul>

<h2 dir="auto"><a id="user-content-what-is-turbo-vision-good-for" aria-hidden="true" href="#what-is-turbo-vision-good-for"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What is Turbo Vision good for?</h2>
<p dir="auto">A lot has changed since Borland created Turbo Vision in the early 90&#39;s. Many GUI tools today separate appearance specification from behaviour specification, use safer or dynamic languages which do not segfault on error, and support either parallel or asynchronous programming, or both.</p>
<p dir="auto">Turbo Vision does not excel at any of those, but it certainly overcomes many of the issues programmers still face today when writing terminal applications:</p>
<ol dir="auto">
<li>
<p dir="auto">Forget about terminal capabilities and direct terminal I/O. When writing a Turbo Vision application, all you have to care about is what you want your application to behave and look like—there is no need to add workarounds in your code. Turbo Vision tries its best to produce the same results on all environments. For example: in order to get a bright background color on the Linux console, the <em>blink</em> attribute has to be set. Turbo Vision does this for you.</p>
</li>
<li>
<p dir="auto">Reuse what has already been done. Turbo Vision provides many widget classes (also known as <em>views</em>), including resizable, overlapping windows, pull-down menus, dialog boxes, buttons, scroll bars, input boxes, check boxes and radio buttons. You may use and extend these; but even if you prefer creating your own, Turbo Vision already handles event dispatching, display of fullwidth Unicode characters, etc.: you do not need to waste time rewriting any of that.</p>
</li>
<li>
<p dir="auto">Can you imagine writing a text-based interface that works both on Linux and Windows (and thus is cross-platform) out-of-the-box, with no <code>#ifdef</code>s? Turbo Vision makes this possible. First: Turbo Vision keeps on using <code>char</code> arrays instead of relying on the implementation-defined and platform-dependent <code>wchar_t</code> or <code>TCHAR</code>. Second: thanks to UTF-8 support in <code>setlocale</code> in <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setlocale-wsetlocale#utf-8-support" rel="nofollow">recent versions of Microsoft&#39;s RTL</a>, code like the following will work as intended:</p>
</li>
</ol>
<div data-snippet-clipboard-copy-content="    std::ifstream f(&#34;コンピュータ.txt&#34;); // On Windows, the RTL converts this to the system encoding on-the-fly."><pre>    std::ifstream <span>f</span>(<span><span>&#34;</span>コンピュータ.txt<span>&#34;</span></span>); <span><span>//</span> On Windows, the RTL converts this to the system encoding on-the-fly.</span></pre></div>

<h2 dir="auto"><a id="user-content-how-do-i-use-turbo-vision" aria-hidden="true" href="#how-do-i-use-turbo-vision"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How do I use Turbo Vision?</h2>
<p dir="auto">You can get started with the <a href="https://archive.org/details/BorlandTurboVisionForCUserSGuide/mode/1up" rel="nofollow">Turbo Vision For C++ User&#39;s Guide</a>, and look at the sample applications <a href="https://github.com/magiblot/tvision/blob/master/hello.cpp"><code>hello</code></a>, <a href="https://github.com/magiblot/tvision/tree/master/examples/tvdemo"><code>tvdemo</code></a> and <a href="https://github.com/magiblot/tvision/tree/master/examples/tvedit"><code>tvedit</code></a>. Once you grasp the basics,
I suggest you take a look at the <a href="https://archive.org/details/bitsavers_borlandTurrogrammingGuide1992_25707423" rel="nofollow">Turbo Vision 2.0 Programming Guide</a>, which is, in my opinion, more intuitive and easier to understand, despite using Pascal. By then you will probably be interested in the <a href="https://github.com/magiblot/tvision/tree/master/examples/palette"><code>palette</code></a> example, which contains a detailed description of how palettes are used.</p>
<p dir="auto">Don&#39;t forget to check out the <a href="#features">features</a> and <a href="#apichanges">API changes</a> sections as well.</p>

<h2 dir="auto"><a id="user-content-releases-and-downloads" aria-hidden="true" href="#releases-and-downloads"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Releases and downloads</h2>
<p dir="auto">This project has no stable releases for the time being. If you are a developer, try to stick to the latest commit and report any issues you find while upgrading.</p>
<p dir="auto">If you just want to test the demo applications:</p>
<ul dir="auto">
<li>Unix systems: you&#39;ll have to build Turbo Vision yourself. You may follow the <a href="#build-linux">build instructions</a> below.</li>
<li>Windows: you can find up-to-date binaries in the <a href="https://github.com/magiblot/tvision/actions?query=branch:master+event:push">Actions</a> section. Click on the first successful workflow (with a green tick) in the list. At the bottom of the workflow page, as long as you have logged in to GitHub, you&#39;ll find an <em>Artifacts</em> section with the following files:
<ul dir="auto">
<li><code>examples-dos32.zip</code>: 32-bit executables built with Borland C++. No Unicode support.</li>
<li><code>examples-x86.zip</code>: 32-bit executables built with MSVC. Windows Vista or later required.</li>
<li><code>examples-x64.zip</code>: 64-bit executables built with MSVC. x64 Windows Vista or later required.</li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-build-environment" aria-hidden="true" href="#build-environment"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Build environment</h2>

<h3 dir="auto"><a id="user-content-linux" aria-hidden="true" href="#linux"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Linux</h3>
<p dir="auto">Turbo Vision can be built as an static library with CMake and GCC/Clang.</p>
<div data-snippet-clipboard-copy-content="cmake . -B ./build -DCMAKE_BUILD_TYPE=Release &amp;&amp; # Could also be &#39;Debug&#39;, &#39;MinSizeRel&#39; or &#39;RelWithDebInfo&#39;.
cmake --build ./build # or `cd ./build; make`"><pre>cmake <span>.</span> -B ./build -DCMAKE_BUILD_TYPE=Release <span>&amp;&amp;</span> <span><span>#</span> Could also be &#39;Debug&#39;, &#39;MinSizeRel&#39; or &#39;RelWithDebInfo&#39;.</span>
cmake --build ./build <span><span>#</span> or `cd ./build; make`</span></pre></div>
<p dir="auto">CMake versions older than 3.13 may not support the <code>-B</code> option. You can try the following instead:</p>
<div data-snippet-clipboard-copy-content="mkdir -p build; cd build
cmake .. -DCMAKE_BUILD_TYPE=Release &amp;&amp;
cmake --build ."><pre>mkdir -p build<span>;</span> <span>cd</span> build
cmake .. -DCMAKE_BUILD_TYPE=Release <span>&amp;&amp;</span>
cmake --build <span>.</span></pre></div>
<p dir="auto">The above produces the following files:</p>
<ul dir="auto">
<li><code>libtvision.a</code>, which is the Turbo Vision library.</li>
<li>The demo applications <code>hello</code>, <code>tvdemo</code>, <code>tvedit</code>, <code>tvdir</code>, which were bundled with the original Turbo Vision (although some of them have a few improvements).</li>
<li>The demo applications <code>mmenu</code> and <code>palette</code> from Borland&#39;s Technical Support.</li>
<li><code>tvhc</code>, the Turbo Vision Help Compiler.</li>
</ul>
<p dir="auto">The library and executables can be found in <code>./build</code>.</p>
<p dir="auto">The build requirements are:</p>
<ul dir="auto">
<li>A compiler supporting C++14.</li>
<li><code>libncursesw</code> (note the &#39;w&#39;).</li>
<li><code>libgpm</code> (for mouse support on the Linux console) (optional).</li>
</ul>
<p dir="auto">If your distribution provides separate <em>devel</em> packages (e.g. <code>libncurses-dev</code>, <code>libgpm-dev</code> in Debian-based distros), install these too.</p>
<p dir="auto">The minimal command line required to build a Turbo Vision application (e.g. <code>hello.cpp</code> with GCC) from this project&#39;s root is:</p>
<div data-snippet-clipboard-copy-content="g++ -std=c++14 -o hello hello.cpp ./build/libtvision.a -Iinclude -lncursesw -lgpm"><pre>g++ -std=c++14 -o hello hello.cpp ./build/libtvision.a -Iinclude -lncursesw -lgpm</pre></div>
<p dir="auto">You may also need:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>-Iinclude/tvision</code> if your application uses Turbo Vision 1.x includes (<code>#include &lt;tv.h&gt;</code> instead of <code>#include &lt;tvision/tv.h&gt;</code>).</p>
</li>
<li>
<p dir="auto"><code>-Iinclude/tvision/compat</code> if your application includes Borland headers (<code>dir.h</code>, <code>iostream.h</code>, etc.).</p>
</li>
<li>
<p dir="auto">On Gentoo (and possibly others): <code>-ltinfow</code> if both <code>libtinfo.so</code> and <code>libtinfow.so</code> are available in your system. Otherwise, you may get a segmentation fault when running Turbo Vision applications (<a href="https://github.com/magiblot/tvision/issues/11" data-hovercard-type="issue" data-hovercard-url="/magiblot/tvision/issues/11/hovercard">#11</a>). Note that <code>tinfo</code> is bundled with <code>ncurses</code>.</p>
</li>
</ul>
<p dir="auto"><code>-lgpm</code> is only necessary if Turbo Vision was built with <code>libgpm</code> support.</p>
<p dir="auto">The backward-compatibility headers in <code>include/tvision/compat</code> emulate the Borland C++ RTL. Turbo Vision&#39;s source code still depends on them, and they could be useful if porting old applications. This also means that including <code>tvision/tv.h</code> will bring several <code>std</code> names to the global namespace.</p>

<h3 dir="auto"><a id="user-content-windows-msvc" aria-hidden="true" href="#windows-msvc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Windows (MSVC)</h3>
<p dir="auto">The build process with MSVC is slightly more complex, as there are more options to choose from. Note that you will need different build directories for different target architectures. For instance, to generate optimized binaries:</p>
<div data-snippet-clipboard-copy-content="cmake . -B ./build &amp;&amp; # Add &#39;-A x64&#39; (64-bit) or &#39;-A Win32&#39; (32-bit) to override the default platform.
cmake --build ./build --config Release # Could also be &#39;Debug&#39;, &#39;MinSizeRel&#39; or &#39;RelWithDebInfo&#39;."><pre>cmake <span>.</span> -B ./build <span>&amp;&amp;</span> <span><span>#</span> Add &#39;-A x64&#39; (64-bit) or &#39;-A Win32&#39; (32-bit) to override the default platform.</span>
cmake --build ./build --config Release <span><span>#</span> Could also be &#39;Debug&#39;, &#39;MinSizeRel&#39; or &#39;RelWithDebInfo&#39;.</span></pre></div>
<p dir="auto">In the example above, <code>tvision.lib</code> and the example applications will be placed at <code>./build/Release</code>.</p>
<p dir="auto">If you wish to link Turbo Vision statically against Microsofts&#39;s run-time library (<code>/MT</code> instead of <code>/MD</code>), enable the <code>TV_USE_STATIC_RTL</code> option (<code>-DTV_USE_STATIC_RTL=ON</code> when calling <code>cmake</code>).</p>
<p dir="auto">If you wish to link an application against Turbo Vision, note that MSVC won&#39;t allow you to mix <code>/MT</code> with <code>/MD</code> or debug with non-debug binaries. All components have to be linked against the RTL in the same way.</p>
<p dir="auto">If you develop your own Turbo Vision application make sure to enable the following compiler flags, or else you will get compilation errors when including <code>&lt;tvision/tv.h&gt;</code>:</p>
<div data-snippet-clipboard-copy-content="/permissive-
/Zc:__cplusplus"><pre><code>/permissive-
/Zc:__cplusplus
</code></pre></div>
<p dir="auto">If you use <a href="#build-cmake">Turbo Vision as a CMake submodule</a>, these flags will be enabled automatically.</p>
<p dir="auto"><strong>Note:</strong> Turbo Vision uses <code>setlocale</code> to set the <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setlocale-wsetlocale#utf-8-support" rel="nofollow">RTL functions in UTF-8 mode</a>. This won&#39;t work if you use an old version of the RTL.</p>
<p dir="auto">With the RTL statically linked in, and if UTF-8 is supported in <code>setlocale</code>, Turbo Vision applications are portable and work by default on <strong>Windows Vista and later</strong>.</p>

<h3 dir="auto"><a id="user-content-windows-mingw" aria-hidden="true" href="#windows-mingw"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Windows (MinGW)</h3>
<p dir="auto">Once your MinGW environment is properly set up, build is done in a similar way to Linux:</p>
<div data-snippet-clipboard-copy-content="cmake . -B ./build -G &#34;MinGW Makefiles&#34; -DCMAKE_BUILD_TYPE=Release &amp;&amp;
cmake --build ./build"><pre>cmake <span>.</span> -B ./build -G <span><span>&#34;</span>MinGW Makefiles<span>&#34;</span></span> -DCMAKE_BUILD_TYPE=Release <span>&amp;&amp;</span>
cmake --build ./build</pre></div>
<p dir="auto">In the example above, <code>libtvision.a</code> and all examples are in <code>./build</code> if <code>TV_BUILD_EXAMPLES</code> option is <code>ON</code> (the default).</p>
<p dir="auto">If you wish to link an application against Turbo Vision, simply add <code>-L./build/lib -ltvision</code> to your linker and <code>-I./include</code> to your compiler</p>

<h3 dir="auto"><a id="user-content-windowsdos-borland-c" aria-hidden="true" href="#windowsdos-borland-c"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Windows/DOS (Borland C++)</h3>
<p dir="auto">Turbo Vision can still be built either as a DOS or Windows library with Borland C++. Obviously, there is no Unicode support here.</p>
<p dir="auto">I can confirm the build process works with:</p>
<ul dir="auto">
<li>Borland C++ 4.52 with the Borland PowerPack for DOS.</li>
<li>Turbo Assembler 4.0.</li>
</ul>
<p dir="auto">You may face different problems depending on your build environment. For instance, Turbo Assembler needs a patch to work under Windows 95. On Windows XP everything seems to work fine. On Windows 10, MAKE may emit the error <code>Fatal: Command arguments too long</code>, which can be fixed by upgrading MAKE to the one bundled with Borland C++ 5.x.</p>
<p dir="auto">Yes, this works on 64-bit Windows 10. What won&#39;t work is the Borland C++ installer, which is a 16-bit application. You will have to run it on another environment or try your luck with <a href="https://github.com/otya128/winevdm">winevdm</a>.</p>
<p dir="auto">A Borland Makefile can be found in the <code>project</code> directory. Build can be done by doing:</p>
<div data-snippet-clipboard-copy-content="cd project
make.exe &lt;options&gt;"><pre><span>cd</span> project
make.exe <span>&lt;</span>options<span>&gt;</span></pre></div>
<p dir="auto">Where <code>&lt;options&gt;</code> can be:</p>
<ul dir="auto">
<li><code>-DDOS32</code> for 32-bit DPMI applications (which still work on 64-bit Windows).</li>
<li><code>-DWIN32</code> for 32-bit native Win32 applications (not possible for TVDEMO, which relies on <code>farcoreleft()</code> and other antiquities).</li>
<li><code>-DDEBUG</code> to build debug versions of the application and the library.</li>
<li><code>-DTVDEBUG</code> to link the applications with the debug version of the library.</li>
<li><code>-DOVERLAY</code>, <code>-DALIGNMENT={2,4}</code>, <code>-DEXCEPTION</code>, <code>-DNO_STREAMABLE</code>, <code>-DNOTASM</code> for things I have nave never used but appeared in the original makefiles.</li>
</ul>
<p dir="auto">This will compile the library into a <code>LIB</code> directory next to <code>project</code>, and will compile executables for the demo applications in their respective <code>examples/*</code> directories.</p>
<p dir="auto">I&#39;m sorry, the root makefile assumes it is executed from the <code>project</code> directory. You can still run the original makefiles directly (in <code>source/tvision</code> and <code>examples/*</code>) if you want to use different settings.</p>

<h3 dir="auto"><a id="user-content-turbo-vision-as-a-cmake-dependency-not-borland-c" aria-hidden="true" href="#turbo-vision-as-a-cmake-dependency-not-borland-c"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Turbo Vision as a CMake dependency (not Borland C++)</h3>
<p dir="auto">If you choose the CMake build system for your application, there are two main ways to link against Turbo Vision:</p>
<ul dir="auto">
<li>
<p dir="auto">Installing Turbo Vision and importing it with <code>find_package</code>. Installation depends on the generator type:</p>
<ul dir="auto">
<li>
<p dir="auto">First, decide an install prefix. The default one will work out-of-the-box, but usually requires admin privileges. On Unix systems, you can use <code>$HOME/.local</code> instead. On Windows, you can use any custom path you want but you&#39;ll have to add it to the <code>CMAKE_PREFIX_PATH</code> environment variable when building your application.</p>
</li>
<li>
<p dir="auto">For mono-config generators (<code>Unix Makefiles</code>, <code>Ninja</code>...), you only have to build and install once:</p>
<div data-snippet-clipboard-copy-content="cmake . -B ./build # &#39;-DCMAKE_INSTALL_PREFIX=...&#39; to override the install prefix.
cmake --build ./build
cmake --install ./build"><pre>cmake <span>.</span> -B ./build <span><span>#</span> &#39;-DCMAKE_INSTALL_PREFIX=...&#39; to override the install prefix.</span>
cmake --build ./build
cmake --install ./build</pre></div>
</li>
<li>
<p dir="auto">For multi-config generators (<code>Visual Studio</code>, <code>Ninja Multi-Config</code>...) you should build and install all configurations:</p>
<div data-snippet-clipboard-copy-content="cmake . -B ./build # &#39;-DCMAKE_INSTALL_PREFIX=...&#39; to override the install prefix.
cmake --build ./build --config Release
cmake --build ./build --config Debug --target tvision
cmake --build ./build --config RelWithDebInfo --target tvision
cmake --build ./build --config MinSizeRel --target tvision
cmake --install ./build --config Release
cmake --install ./build --config Debug --component library
cmake --install ./build --config RelWithDebInfo --component library
cmake --install ./build --config MinSizeRel --component library"><pre>cmake <span>.</span> -B ./build <span><span>#</span> &#39;-DCMAKE_INSTALL_PREFIX=...&#39; to override the install prefix.</span>
cmake --build ./build --config Release
cmake --build ./build --config Debug --target tvision
cmake --build ./build --config RelWithDebInfo --target tvision
cmake --build ./build --config MinSizeRel --target tvision
cmake --install ./build --config Release
cmake --install ./build --config Debug --component library
cmake --install ./build --config RelWithDebInfo --component library
cmake --install ./build --config MinSizeRel --component library</pre></div>
</li>
</ul>
<p dir="auto">Then, in your application&#39;s <code>CMakeLists.txt</code>, you may import it like this:</p>
<div data-snippet-clipboard-copy-content="find_package(tvision CONFIG)
target_link_libraries(my_application tvision::tvision)"><pre><span>find_package</span>(tvision <span>CONFIG</span>)
<span>target_link_libraries</span>(my_application tvision::tvision)</pre></div>
</li>
<li>
<p dir="auto">Have Turbo Vision in a submodule in your repository and import it with <code>add_subdirectory</code>:</p>
<div data-snippet-clipboard-copy-content="add_subdirectory(tvision) # Assuming Turbo Vision is in the &#39;tvision&#39; directory.
target_link_libraries(my_application tvision)"><pre><span>add_subdirectory</span>(tvision) <span><span>#</span> Assuming Turbo Vision is in the &#39;tvision&#39; directory.</span>
<span>target_link_libraries</span>(my_application tvision)</pre></div>
</li>
</ul>
<p dir="auto">In either case, <code>&lt;tvision/tv.h&gt;</code> will be available in your application&#39;s include path during compilation, and your application will be linked against the necessary libraries (Ncurses, GPM...) automatically.</p>

<h2 dir="auto"><a id="user-content-features" aria-hidden="true" href="#features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Features</h2>
<h3 dir="auto"><a id="user-content-modern-platforms-not-borland-c" aria-hidden="true" href="#modern-platforms-not-borland-c"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Modern platforms (not Borland C++)</h3>
<ul dir="auto">
<li>UTF-8 support. You can try it out in the <code>tvedit</code> application.</li>
<li>24-bit color support (up from the original 16 colors).</li>
<li>&#39;Open File&#39; dialogs accepts both Unix and Windows-style file paths and can expand <code>~/</code> into <code>$HOME</code>.</li>
<li>Redirection of <code>stdin</code>/<code>stdout</code>/<code>stderr</code> does not interfere with terminal I/O.</li>
<li>Compatibility with 32-bit help files.</li>
</ul>
<p dir="auto">There are a few environment variables that affect the behaviour of all Turbo Vision applications:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>TVISION_MAX_FPS</code>: maximum refresh rate, default <code>60</code>. This can help keep smoothness in terminal emulators with unefficient handling of box-drawing characters. Special values for this option are <code>0</code>, to disable refresh rate limiting, and <code>-1</code>, to actually draw to the terminal in every call to <code>THardwareInfo::screenWrite</code> (useful when debugging).</p>
</li>
<li>
<p dir="auto"><code>TVISION_CODEPAGE</code>: the character set used internally by Turbo Vision to translate <em>extended ASCII</em> into Unicode. Valid values at the moment are <code>437</code> and <code>850</code>, with <code>437</code> being the default, although adding more takes very little effort.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-unix" aria-hidden="true" href="#unix"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Unix</h3>
<ul dir="auto">
<li>Ncurses-based terminal support.</li>
<li>Extensive mouse and keyboard support:
<ul dir="auto">
<li>Support for X10 and SGR mouse encodings.</li>
<li>Support for Xterm&#39;s <a href="https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:modifyOtherKeys" rel="nofollow"><em>modifyOtherKeys</em></a>.</li>
<li>Support for Paul Evans&#39; <a href="http://www.leonerd.org.uk/hacks/fixterms/" rel="nofollow"><em>fixterms</em></a> and Kitty&#39;s <a href="https://sw.kovidgoyal.net/kitty/keyboard-protocol/" rel="nofollow">keyboard protocol</a>.</li>
<li>Support for key modifiers (via <code>TIOCLINUX</code>) and mouse (via GPM) in the Linux console.</li>
</ul>
</li>
<li>Custom signal handler that restores the terminal state before the program crashes.</li>
<li>When <code>stderr</code> is a tty, messages written to it are redirected to a buffer to prevent them from messing up the display and are eventually printed to the console when the application shuts down or is suspended.</li>
</ul>
<p dir="auto">The following environment variables are also taken into account:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>TERM</code>: Ncurses uses it to determine terminal capabilities. It is set automatically by the terminal emulator.</p>
</li>
<li>
<p dir="auto"><code>COLORTERM</code>: when set to <code>truecolor</code> or <code>24bit</code>, Turbo Vision will assume the terminal emulator supports 24-bit color. It is set automatically by terminal emulators that support it.</p>
</li>
<li>
<p dir="auto"><code>TVISION_ESCDELAY</code>: the number of milliseconds to wait after receiving an ESC key press, default <code>10</code>. If another key is pressed during this delay, it will be interpreted as an Alt+Key combination. Using a larger value is useful when the terminal doesn&#39;t support the Alt key.</p>
</li>
<li>
<p dir="auto"><code>TVISION_USE_STDIO</code>: when not empty, terminal I/O is performed through <code>stdin</code>/<code>stdout</code>, so that it can be redirected from the shell. By default, Turbo Vision performs terminal I/O through <code>/dev/tty</code>, allowing the user to redirect <code>stdin</code>, <code>stdout</code> and <code>stderr</code> for their needs, without affecting the application&#39;s stability.</p>
<p dir="auto">For example, the following will leave <code>out.txt</code> empty:</p>

<p dir="auto">While the following will dump all the escape sequences and text printed by the application into <code>out.txt</code>:</p>
<div data-snippet-clipboard-copy-content="TVISION_USE_STDIO=1 tvdemo | tee out.txt"><pre>TVISION_USE_STDIO=1 tvdemo <span>|</span> tee out.txt</pre></div>
</li>
<li>
<p dir="auto"><code>TVISION_DISPLAY</code>: strategy for drawing to screen. Valid values are <code>ansi</code> and <code>ncurses</code>, with <code>ansi</code> being the default. The Ncurses library is used in either case, with the difference that <code>ncurses</code> uses Ncurses&#39; own draw methods and is limited to 16 colors, while <code>ansi</code> supports 24-bit color and avoids redundant buffering and UTF-8 to wide char conversions.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-windows" aria-hidden="true" href="#windows"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Windows</h3>
<ul dir="auto">
<li>Only compatible with the Win32 Console API. On terminal emulators that don&#39;t support this, Turbo Vision will automatically pop up a separate console window.</li>
<li>Applications fit the console window size instead of the buffer size (no scrollbars are visible) and the console buffer is restored when exiting or suspending Turbo Vision.</li>
</ul>
<p dir="auto">The following are not available when compiling with Borland C++:</p>
<ul dir="auto">
<li>The console&#39;s codepage is set to UTF-8 on startup and restored on exit.</li>
<li>Microsoft&#39;s C runtime functions are set automatically to UTF-8 mode, so you as a developer don&#39;t need to use the <code>wchar_t</code> variants.</li>
<li>If the console crashes, a new one is allocated automatically.</li>
</ul>
<p dir="auto"><strong>Note:</strong> Turbo Vision writes UTF-8 text directly to the Windows console. If the console is set in legacy mode and the bitmap font is being used, Unicode characters will not be displayed properly (<a href="https://user-images.githubusercontent.com/20713561/91917174-7a1f4600-ecbf-11ea-8c7a-2ec80d31d2ca.png" rel="nofollow">photo</a>). To avoid this, Turbo Vision detects this situation and tries to change the console font to <code>Consolas</code> or <code>Lucida Console</code>.</p>
<h3 dir="auto"><a id="user-content-all-platforms" aria-hidden="true" href="#all-platforms"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>All platforms</h3>
<p dir="auto">The following are new features not available in Borland&#39;s release of Turbo Vision or in previous open source ports (Sigala, SET):</p>
<ul dir="auto">
<li>Middle mouse button and mouse wheel support.</li>
<li>Arbitrary screen size support (up to 32767 rows or columns) and graceful handling of screen resize events.</li>
<li>Windows can be resized from their bottom left corner.</li>
<li>Windows can be dragged from empty areas with the middle mouse button.</li>
<li>Improved usability of menus: they can be closed by clicking again on the parent menu item.</li>
<li>Improved usability of scrollbars: dragging them also scrolls the page. Clicking on an empty area of the scrollbar moves the thumb right under the cursor. They respond by default to mouse wheel events.</li>
<li><code>TInputLine</code>s no longer scroll the text display on focus/unfocus, allowing relevant text to stay visible.</li>
<li>Support for LF line endings in <code>TFileViewer</code> (<code>tvdemo</code>) and <code>TEditor</code> (<code>tvedit</code>). <code>TEditor</code> preserves the line ending on file save but all newly created files use CRLF by default.</li>
<li><code>TEditor</code>: context menu on right click.</li>
<li><code>TEditor</code>: drag scroll with middle mouse button.</li>
<li><code>TEditor</code>, <code>TInputLine</code>: delete whole words with <code>kbAltBack</code>, <code>kbCtrlBack</code> and <code>kbCtrlDel</code>.</li>
<li><code>TEditor</code>: the Home key toggles between beginning of line and beginning of indented text.</li>
<li><code>TEditor</code>: support for files bigger than 64 KiB on 32-bit or 64-bit builds.</li>
<li><code>tvdemo</code>: event viewer applet useful for event debugging.</li>
<li><code>tvdemo</code>: option to change the background pattern.</li>
</ul>

<h2 dir="auto"><a id="user-content-api-changes" aria-hidden="true" href="#api-changes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API changes</h2>
<ul dir="auto">
<li>
<p dir="auto">Screen writes are buffered and are usually sent to the terminal once for every iteration of the active event loop (see also <code>TVISION_MAX_FPS</code>). If you need to update the screen during a busy loop, you may use <code>TScreen::flushScreen()</code>.</p>
</li>
<li>
<p dir="auto"><code>TDrawBuffer</code> is no longer a fixed-length array. The equivalent of <code>sizeof(TDrawBuffer)/sizeof(ushort)</code> is the <code>.length()</code> method.</p>
</li>
<li>
<p dir="auto"><code>TTextDevice</code> is now buffered, so if you were using <code>otstream</code> you may have to send <code>std::flush</code> or <code>std::endl</code> through it for <code>do_sputn</code> to be invoked.</p>
</li>
<li>
<p dir="auto"><code>TApplication</code> now provides <code>dosShell()</code>, <code>cascade()</code> and <code>tile()</code>, and handles <code>cmDosShell</code>, <code>cmCascade</code> and <code>cmTile</code> by default. These functions can be customized by overriding <code>getTileRect()</code> and <code>writeShellMsg()</code>. This is the same behaviour as in the Pascal version.</p>
</li>
<li>
<p dir="auto">Mouse wheel support: new mouse event <code>evMouseWheel</code>. The wheel direction is specified in the new field <code>event.mouse.wheel</code>, whose possible values are <code>mwUp</code>, <code>mwDown</code>, <code>mwLeft</code> or <code>mwRight</code>.</p>
</li>
<li>
<p dir="auto">Middle mouse button support: new mouse button flag <code>mbMiddleButton</code>.</p>
</li>
<li>
<p dir="auto">The <code>buttons</code> field in <code>evMouseUp</code> events is no longer empty. It now indicates which button was released.</p>
</li>
<li>
<p dir="auto">Triple-click support: new mouse event flag <code>meTripleClick</code>.</p>
</li>
<li>
<p dir="auto"><code>TRect</code> methods <code>move</code>, <code>grow</code>, <code>intersect</code> and <code>Union</code> now return <code>TRect&amp;</code> instead of being <code>void</code> so that they can be chained.</p>
</li>
<li>
<p dir="auto"><code>TOutlineViewer</code> now allows the root node to have siblings.</p>
</li>
<li>
<p dir="auto">New function <code>ushort popupMenu(TPoint where, TMenuItem &amp;aMenu, TGroup *receiver=0)</code> which spawns a <code>TMenuPopup</code> on the desktop. See <code>source/tvision/popupmnu.cpp</code>.</p>
</li>
<li>
<p dir="auto">New virtual method <code>TMenuItem&amp; TEditor::initContextMenu(TPoint p)</code> that determines the entries of the right-click context menu in <code>TEditor</code>.</p>
</li>
<li>
<p dir="auto"><code>fexpand</code> can now take a second parameter <code>relativeTo</code>.</p>
</li>
<li>
<p dir="auto">New class <code>TStringView</code>, inspired by <code>std::string_view</code>.</p>
<ul dir="auto">
<li>Many functions which originally had null-terminated string parameters now receive <code>TStringView</code> instead. <code>TStringView</code> is compatible with <code>std::string_view</code>, <code>std::string</code> and <code>const char *</code> (even <code>nullptr</code>).</li>
</ul>
</li>
<li>
<p dir="auto">New class <code>TSpan&lt;T&gt;</code>, inspired by <code>std::span</code>.</p>
</li>
<li>
<p dir="auto">New classes <code>TDrawSurface</code> and <code>TSurfaceView</code>, see <code>&lt;tvision/surface.h&gt;</code>.</p>
</li>
<li>
<p dir="auto">New method <code>TVMemMgr::reallocateDiscardable()</code> which can be used along <code>allocateDiscardable</code> and <code>freeDiscardable</code>.</p>
</li>
<li>
<p dir="auto">New method <code>TView::textEvent()</code> which allows receiving text in an efficient manner, see <a href="#clipboard">Clipboard interaction</a>.</p>
</li>
<li>
<p dir="auto">Unicode support, see <a href="#unicode">Unicode</a>.</p>
</li>
<li>
<p dir="auto">True Color support, see <a href="#color">extended colors</a>.</p>
</li>
<li>
<p dir="auto">New method <code>static void TEvent::waitEvent(int timeoutMs)</code> which may block for up to <code>timeoutMs</code> milliseconds waiting for input events. If it blocks, it has the side effect of flushing screen updates. It is invoked by <code>TProgram::getEvent()</code> with <code>static int TProgram::appEventTimeout</code> (default <code>20</code>) as argument so that the event loop doesn&#39;t consume 100% CPU.</p>
</li>
<li>
<p dir="auto">New method <code>static void TEvent::putNothing()</code> which puts an <code>evNothing</code> event into the event queue and causes <code>TEvent::waitEvent()</code> not to block until an <code>evNothing</code> is returned by <code>TEvent::getKeyEvent()</code>. This will usually cause the main thread to wake up from <code>TEvent::waitEvent()</code> and to invoke <code>TApplication::idle()</code> immediately. This method is thread-safe, so it can be used to unblock the event loop from any other thread.</p>
</li>
<li>
<p dir="auto">It is now possible to specify a maximum text width or maximum grapheme count in <code>TInputLine</code>. This is done through a new parameter in <code>TInputLine</code>&#39;s constructor, <code>ushort limitMode</code>, which controls how the second constructor parameter, <code>uint limit</code>, is to be treated. The <code>ilXXXX</code> constants define the possible values of <code>limitMode</code>:</p>
<ul dir="auto">
<li><code>ilMaxBytes</code> (the default): the text can be up to <code>limit</code> bytes long, including the null terminator.</li>
<li><code>ilMaxWidth</code>: the text can be up to <code>limit</code> columns wide.</li>
<li><code>ilMaxGraphemes</code>: the text can contain up to <code>limit</code> non-combining characters.</li>
</ul>
<p dir="auto">In any case, the text in a <code>TInputLine</code> can never be more than 256 bytes long, including the null terminator.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-screenshots" aria-hidden="true" href="#screenshots"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Screenshots</h2>
<p dir="auto">You will find some screenshots <a href="https://github.com/magiblot/tvision/issues/7" data-hovercard-type="issue" data-hovercard-url="/magiblot/tvision/issues/7/hovercard">here</a>. Feel free to add your own!</p>
<h2 dir="auto"><a id="user-content-contributing" aria-hidden="true" href="#contributing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contributing</h2>
<p dir="auto">If you know of any Turbo Vision applications whose source code has not been lost and that could benefit from this, let me know.</p>

<h2 dir="auto"><a id="user-content-applications-using-turbo-vision" aria-hidden="true" href="#applications-using-turbo-vision"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Applications using Turbo Vision</h2>
<p dir="auto">If your application is based on this project and you&#39;d like it to appear in the following list, just let me know.</p>
<ul dir="auto">
<li><a href="https://github.com/magiblot/turbo">Turbo</a> by <a href="https://github.com/magiblot">magiblot</a>, a proof-of-concept text editor.</li>
<li><a href="https://github.com/magiblot/tvterm">tvterm</a> by <a href="https://github.com/magiblot">magiblot</a>, a proof-of-concept terminal emulator.</li>
<li><a href="https://github.com/electroly/tmbasic">TMBASIC</a> by <a href="https://github.com/electroly">Brian Luft</a>, a programming language for creating console applications.</li>
</ul>


<p dir="auto">The Turbo Vision API has been extended to allow receiving Unicode input and displaying Unicode text. The supported encoding is UTF-8, for a number of reasons:</p>
<ul dir="auto">
<li>It is compatible with already present data types (<code>char *</code>), so it does not require intrusive modifications to existing code.</li>
<li>It is the same encoding used for terminal I/O, so redundant conversions are avoided.</li>
<li>Conformance to the <a href="http://utf8everywhere.org/" rel="nofollow">UTF-8 Everywhere Manifesto</a>, which exposes many other advantages.</li>
</ul>
<p dir="auto">Note that when built with Borland C++, Turbo Vision does not support Unicode. However, this does not affect the way Turbo Vision applications are written, since the API extensions are designed to allow for encoding-agnostic code.</p>
<h2 dir="auto"><a id="user-content-reading-unicode-input" aria-hidden="true" href="#reading-unicode-input"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reading Unicode input</h2>
<p dir="auto">The traditional way to get text from a key press event is as follows:</p>
<div data-snippet-clipboard-copy-content="// &#39;ev&#39; is a TEvent, and &#39;ev.what&#39; equals &#39;evKeyDown&#39;.
switch (ev.keyDown.keyCode) {
    // Key shortcuts are usually checked first.
    // ...
    default: {
        // The character is encoded in the current codepage
        // (CP437 by default).
        char c = ev.keyDown.charScan.charCode;
        // ...
    }
}"><pre><span><span>//</span> &#39;ev&#39; is a TEvent, and &#39;ev.what&#39; equals &#39;evKeyDown&#39;.</span>
<span>switch</span> (ev.keyDown.keyCode) {
    <span><span>//</span> Key shortcuts are usually checked first.</span>
    <span><span>//</span> ...</span>
    <span>default</span>: {
        <span><span>//</span> The character is encoded in the current codepage</span>
        <span><span>//</span> (CP437 by default).</span>
        <span>char</span> c = ev.<span>keyDown</span>.<span>charScan</span>.<span>charCode</span>;
        <span><span>//</span> ...</span>
    }
}</pre></div>
<p dir="auto">Some of the existing Turbo Vision classes that deal with text input still depend on this methodology, which has not changed. Single-byte characters, when representable in the current codepage, continue to be available in <code>ev.keyDown.charScan.charCode</code>.</p>
<p dir="auto">Unicode support consists in two new fields in <code>ev.keyDown</code> (which is a <code>struct KeyDownEvent</code>):</p>
<ul dir="auto">
<li><code>char text[4]</code>, which may contain whatever was read from the terminal: usually a UTF-8 sequence, but possibly any kind of raw data.</li>
<li><code>uchar textLength</code>, which is the number of bytes of data available in <code>text</code>, from 0 to 4.</li>
</ul>
<p dir="auto">Note that the <code>text</code> field may contain garbage or uninitialized data from position <code>textLength</code> on.</p>
<p dir="auto">You can also get a <code>TStringView</code> out of a <code>KeyDownEvent</code> with the <code>getText()</code> method.</p>
<p dir="auto">So a Unicode character can be retrieved from <code>TEvent</code> in the following way:</p>
<div data-snippet-clipboard-copy-content="switch (ev.keyDown.keyCode) {
    // ...
    default: {
        std::string_view sv = ev.keyDown.getText();
        processText(sv);
    }
}"><pre><span>switch</span> (ev.keyDown.keyCode) {
    <span><span>//</span> ...</span>
    <span>default</span>: {
        std::string_view sv = ev.<span>keyDown</span>.<span>getText</span>();
        <span>processText</span>(sv);
    }
}</pre></div>
<p dir="auto">Let&#39;s see it from another perspective. If the user types <code>ñ</code>, a <code>TEvent</code> is generated with the following <code>keyDown</code> struct:</p>
<div data-snippet-clipboard-copy-content="KeyDownEvent {
    union {
        .keyCode = 0xA4,
        .charScan = CharScanType {
            .charCode = 164 (&#39;ñ&#39;), // In CP437
            .scanCode = 0
        }
    },
    .controlKeyState = 0x200 (kbInsState),
    .text = {&#39;\xC3&#39;, &#39;\xB1&#39;}, // In UTF-8
    .textLength = 2
}"><pre>KeyDownEvent {
    <span>union</span> {
        .<span>keyCode</span> = <span>0xA4</span>,
        .<span>charScan</span> = CharScanType {
            .<span>charCode</span> = <span>164</span> (<span><span>&#39;</span>ñ<span>&#39;</span></span>), <span><span>//</span> In CP437</span>
            .<span>scanCode</span> = <span>0</span>
        }
    },
    .<span>controlKeyState</span> = <span>0x200</span> (kbInsState),
    .<span>text</span> = {<span><span>&#39;</span><span>\xC3</span><span>&#39;</span></span>, <span><span>&#39;</span><span>\xB1</span><span>&#39;</span></span>}, <span><span>//</span> In UTF-8</span>
    .<span>textLength</span> = <span>2</span>
}</pre></div>
<p dir="auto">However, if they type <code>€</code> the following will happen:</p>
<div data-snippet-clipboard-copy-content="KeyDownEvent {
    union {
        .keyCode = 0x0 (kbNoKey), // &#39;€&#39; not part of CP437
        .charScan = CharScanType {
            .charCode = 0,
            .scanCode = 0
        }
    },
    .controlKeyState = 0x200 (kbInsState),
    .text = {&#39;\xE2&#39;, &#39;\x82&#39;, &#39;\xAC&#39;}, // In UTF-8
    .textLength = 3
}"><pre>KeyDownEvent {
    <span>union</span> {
        .<span>keyCode</span> = <span>0x0</span> (kbNoKey), <span><span>//</span> &#39;€&#39; not part of CP437</span>
        .<span>charScan</span> = CharScanType {
            .<span>charCode</span> = <span>0</span>,
            .<span>scanCode</span> = <span>0</span>
        }
    },
    .<span>controlKeyState</span> = <span>0x200</span> (kbInsState),
    .<span>text</span> = {<span><span>&#39;</span><span>\xE2</span><span>&#39;</span></span>, <span><span>&#39;</span><span>\x82</span><span>&#39;</span></span>, <span><span>&#39;</span><span>\xAC</span><span>&#39;</span></span>}, <span><span>//</span> In UTF-8</span>
    .<span>textLength</span> = <span>3</span>
}</pre></div>
<p dir="auto">If a key shortcut is pressed instead, <code>text</code> is empty:</p>
<div data-snippet-clipboard-copy-content="KeyDownEvent {
    union {
        .keyCode = 0xB (kbCtrlK),
        .charScan = CharScanType {
            .charCode = 11 (&#39;♂&#39;),
            .scanCode = 0
        }
    },
    .controlKeyState = 0x20C (kbCtrlShift | kbInsState),
    .text = {},
    .textLength = 0
}"><pre>KeyDownEvent {
    <span>union</span> {
        .<span>keyCode</span> = <span>0xB</span> (kbCtrlK),
        .<span>charScan</span> = CharScanType {
            .<span>charCode</span> = <span>11</span> (<span><span>&#39;</span>♂<span>&#39;</span></span>),
            .<span>scanCode</span> = <span>0</span>
        }
    },
    .<span>controlKeyState</span> = <span>0x20C</span> (kbCtrlShift | kbInsState),
    .<span>text</span> = {},
    .<span>textLength</span> = <span>0</span>
}</pre></div>
<p dir="auto">So, in short: views designed without Unicode input in mind will continue to work exactly as they did before, and views which want to be Unicode-aware will have no issues in being so.</p>
<h2 dir="auto"><a id="user-content-displaying-unicode-text" aria-hidden="true" href="#displaying-unicode-text"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Displaying Unicode text</h2>
<p dir="auto">The original design of Turbo Vision uses 16 bits to represent a <em>screen cell</em>—8 bit for a character and 8 bit for <a href="https://en.wikipedia.org/wiki/BIOS_color_attributes" rel="nofollow">BIOS color attributes</a>.</p>
<p dir="auto">A new <code>TScreenCell</code> type is defined in <code>&lt;tvision/scrncell.h&gt;</code> which is capable of holding a limited number of UTF-8 codepoints in addition to extended attributes (bold, underline, italic...). However, you should not write text into a <code>TScreenCell</code> directly but make use of Unicode-aware API functions instead.</p>
<h3 dir="auto"><a id="user-content-text-display-rules" aria-hidden="true" href="#text-display-rules"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Text display rules</h3>
<p dir="auto">A character provided as argument to any of the Turbo Vision API functions that deal with displaying text is interpreted as follows:</p>
<ul dir="auto">
<li>Non-printable characters in the range <code>0x00</code> to <code>0xFF</code> are interpreted as characters in the active codepage. For instance, <code>0x7F</code> is displayed as <code>⌂</code> and <code>0xF0</code> as <code>≡</code> if using CP437. As an exception, <code>0x00</code> is always displayed as a regular space. These characters are all one column wide.</li>
<li>Character sequences which are not valid UTF-8 are interpreted as sequences of characters in the current codepage, as in the case above.</li>
<li>Valid UTF-8 sequences with a display width other than one are taken care of in a special way, see below.</li>
</ul>
<p dir="auto">For example, the string <code>&#34;╔[\xFE]╗&#34;</code> may be displayed as <code>╔[■]╗</code>. This means that box-drawing characters can be mixed with UTF-8 in general, which is useful for backward compatibility. If you rely on this behaviour, though, you may get unexpected results: for instance, <code>&#34;\xC4\xBF&#34;</code> is a valid UTF-8 sequence and is displayed as <code>Ŀ</code> instead of <code>─┐</code>.</p>
<p dir="auto">One of the issues of Unicode support is the existence of <a href="https://convertcase.net/vaporwave-wide-text-generator/" rel="nofollow">multi-width</a> characters and <a href="https://en.wikipedia.org/wiki/Combining_Diacritical_Marks" rel="nofollow">combining</a> characters. This conflicts with Turbo Vision&#39;s original assumption that the screen is a grid of cells occupied by a single character each. Nevertheless, these cases are handled in the following way:</p>
<ul dir="auto">
<li>
<p dir="auto">Multi-width characters can be drawn anywhere on the screen and nothing bad happens if they overlap partially with other characters.</p>
</li>
<li>
<p dir="auto">Zero-width characters overlay the previous character. For example, the sequence <code>में</code> consists of the single-width character <code>म</code> and the combining characters <code>े</code> and <code>ं</code>. In this case, three Unicode codepoints are fit into the same cell.</p>
<p dir="auto">The <code>ZERO WIDTH JOINER</code> (<code>U+200D</code>) is always omitted, as it complicates things too much. For example, it can turn a string like <code>&#34;👩👦&#34;</code> (4 columns wide) into <code>&#34;👩‍👦&#34;</code> (2 columns wide). Not all terminal emulators respect the ZWJ, so, in order to produce predictable results, Turbo Vision will print both <code>&#34;👩👦&#34;</code> and <code>&#34;👩‍👦&#34;</code> as <code>👩👦</code>.</p>
</li>
<li>
<p dir="auto">No notable graphical glitches will occur as long as your terminal emulator respects character widths as measured by <code>wcwidth</code>.</p>
</li>
</ul>
<p dir="auto">Here is an example of such characters in the <a href="https://github.com/magiblot/turbo">Turbo</a> text editor:
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/20713561/103179253-51344980-488a-11eb-9a29-79b9acb1b4b9.png"><img src="https://user-images.githubusercontent.com/20713561/103179253-51344980-488a-11eb-9a29-79b9acb1b4b9.png" alt="Wide character display"/></a></p>
<h3 dir="auto"><a id="user-content-unicode-aware-api-functions" aria-hidden="true" href="#unicode-aware-api-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Unicode-aware API functions</h3>
<p dir="auto">The usual way of writing to the screen is by using <code>TDrawBuffer</code>. A few methods have been added and others have changed their meaning:</p>
<div data-snippet-clipboard-copy-content="void TDrawBuffer::moveChar(ushort indent, char c, TColorAttr attr, ushort count);
void TDrawBuffer::putChar(ushort indent, char c);"><pre><span>void</span> <span>TDrawBuffer::moveChar</span>(<span>ushort</span> indent, <span>char</span> c, TColorAttr attr, <span>ushort</span> count);
<span>void</span> <span>TDrawBuffer::putChar</span>(<span>ushort</span> indent, <span>char</span> c);</pre></div>
<p dir="auto"><code>c</code> is always interpreted as a character in the active codepage.</p>
<div data-snippet-clipboard-copy-content="ushort TDrawBuffer::moveStr(ushort indent, TStringView str, TColorAttr attr);
ushort TDrawBuffer::moveCStr(ushort indent, TStringView str, TAttrPair attrs);"><pre><span>ushort</span> <span>TDrawBuffer::moveStr</span>(<span>ushort</span> indent, TStringView str, TColorAttr attr);
<span>ushort</span> <span>TDrawBuffer::moveCStr</span>(<span>ushort</span> indent, TStringView str, TAttrPair attrs);</pre></div>
<p dir="auto"><code>str</code> is interpreted according to the rules exposed previously.</p>
<div data-snippet-clipboard-copy-content="ushort TDrawBuffer::moveStr(ushort indent, TStringView str, TColorAttr attr, ushort width, ushort begin=0); // New"><pre><span>ushort</span> <span>TDrawBuffer::moveStr</span>(<span>ushort</span> indent, TStringView str, TColorAttr attr, <span>ushort</span> width, <span>ushort</span> begin=<span>0</span>); <span><span>//</span> New</span></pre></div>
<p dir="auto"><code>str</code> is interpreted according to the rules exposed previously. However:</p>
<ul dir="auto">
<li><code>width</code> specifies the maximum number of display columns that should be read from <code>str</code>.</li>
<li><code>begin</code> specifies the number of display columns that should be skipped at the beginning of <code>str</code>. This is useful for horizontal scrolling. If <code>begin</code> is in the middle of a multi-width character, the remaining positions in that character are filled with spaces.</li>
</ul>
<p dir="auto">The return values are the number of display columns that were actually filled with text.</p>
<div data-snippet-clipboard-copy-content="void TDrawBuffer::moveBuf(ushort indent, const void *source, TColorAttr attr, ushort count);"><pre><span>void</span> <span>TDrawBuffer::moveBuf</span>(<span>ushort</span> indent, <span>const</span> <span>void</span> *source, TColorAttr attr, <span>ushort</span> count);</pre></div>
<p dir="auto">The name of this function is misleading. Even in its original implementation, <code>source</code> is treated as a string. So it is equivalent to <code>moveStr(indent, TStringView((const char*) source, count), attr)</code>.</p>
<p dir="auto">There are other useful Unicode-aware functions:</p>
<div data-snippet-clipboard-copy-content="int cstrlen(TStringView s);"><pre><span>int</span> <span>cstrlen</span>(TStringView s);</pre></div>
<p dir="auto">Returns the displayed length of <code>s</code> according to the aforementioned rules, discarding <code>~</code> characters.</p>
<div data-snippet-clipboard-copy-content="int strwidth(TStringView s); // New"><pre><span>int</span> <span>strwidth</span>(TStringView s); <span><span>//</span> New</span></pre></div>
<p dir="auto">Returns the displayed length of <code>s</code>.</p>
<p dir="auto">On Borland C++, these methods assume a single-byte encoding and all characters being one column wide. This makes it possible to write encoding-agnostic <code>draw()</code> and <code>handleEvent()</code> methods that work on both platforms without a single <code>#ifdef</code>.</p>
<p dir="auto">The functions above are implemented using the functions from the <code>TText</code> namespace, another API extension. You will have to use them directly if you want to fill <code>TScreenCell</code> objects with text manually. To give an example, below are some of the <code>TText</code> functions. You can find all of them with complete descriptions in <code>&lt;tvision/ttext.h&gt;</code>.</p>
<div data-snippet-clipboard-copy-content="size_t TText::next(TStringView text);
size_t TText::prev(TStringView text, size_t index);
void TText::drawChar(TSpan&lt;TScreenCell&gt; cells, char c);
size_t TText::drawStr(TSpan&lt;TScreenCell&gt; cells, size_t indent, TStringView text, int textIndent);
bool TText::drawOne(TSpan&lt;TScreenCell&gt; cells, size_t &amp;i, TStringView text, size_t &amp;j);"><pre><span>size_t</span> <span>TText::next</span>(TStringView text);
<span>size_t</span> <span>TText::prev</span>(TStringView text, <span>size_t</span> index);
<span>void</span> <span>TText::drawChar</span>(TSpan&lt;TScreenCell&gt; cells, <span>char</span> c);
<span>size_t</span> <span>TText::drawStr</span>(TSpan&lt;TScreenCell&gt; cells, <span>size_t</span> indent, TStringView text, <span>int</span> textIndent);
<span>bool</span> <span>TText::drawOne</span>(TSpan&lt;TScreenCell&gt; cells, <span>size_t</span> &amp;i, TStringView text, <span>size_t</span> &amp;j);</pre></div>
<p dir="auto">For drawing <code>TScreenCell</code> buffers into a view, the following methods are available:</p>
<div data-snippet-clipboard-copy-content="void TView::writeBuf(short x, short y, short w, short h, const TScreenCell *b); // New
void TView::writeLine(short x, short y, short w, short h, const TScreenCell *b); // New"><pre><span>void</span> <span>TView::writeBuf</span>(<span>short</span> x, <span>short</span> y, <span>short</span> w, <span>short</span> h, <span>const</span> TScreenCell *b); <span><span>//</span> New</span>
<span>void</span> <span>TView::writeLine</span>(<span>short</span> x, <span>short</span> y, <span>short</span> w, <span>short</span> h, <span>const</span> TScreenCell *b); <span><span>//</span> New</span></pre></div>
<h3 dir="auto"><a id="user-content-example-unicode-text-in-menus-and-status-bars" aria-hidden="true" href="#example-unicode-text-in-menus-and-status-bars"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: Unicode text in menus and status bars</h3>
<p dir="auto">It&#39;s as simple as it can be. Let&#39;s modify <code>hello.cpp</code> as follows:</p>
<div data-snippet-clipboard-copy-content="TMenuBar *THelloApp::initMenuBar( TRect r )
{
    r.b.y = r.a.y+1;
    return new TMenuBar( r,
      *new TSubMenu( &#34;~Ñ~ello&#34;, kbAltH ) +
        *new TMenuItem( &#34;階~毎~料入報最...&#34;, GreetThemCmd, kbAltG ) +
        *new TMenuItem( &#34;五劫~の~擦り切れ&#34;, cmYes, kbNoKey, hcNoContext ) +
        *new TMenuItem( &#34;העברית ~א~ינטרנט&#34;, cmNo, kbNoKey, hcNoContext ) +
         newLine() +
        *new TMenuItem( &#34;E~x~it&#34;, cmQuit, cmQuit, hcNoContext, &#34;Alt-X&#34; )
        );
}

TStatusLine *THelloApp::initStatusLine( TRect r )
{
    r.a.y = r.b.y-1;
    return new TStatusLine( r,
        *new TStatusDef( 0, 0xFFFF ) +
            *new TStatusItem( &#34;~Alt-Ç~ Exit&#34;, kbAltX, cmQuit ) +
            *new TStatusItem( 0, kbF10, cmMenu )
            );
}"><pre>TMenuBar *<span>THelloApp::initMenuBar</span>( TRect r )
{
    r.<span>b</span>.<span>y</span> = r.<span>a</span>.<span>y</span>+<span>1</span>;
    <span>return</span> <span>new</span> <span>TMenuBar</span>( r,
      *<span>new</span> <span>TSubMenu</span>( <span><span>&#34;</span>~Ñ~ello<span>&#34;</span></span>, kbAltH ) +
        *<span>new</span> <span>TMenuItem</span>( <span><span>&#34;</span>階~毎~料入報最...<span>&#34;</span></span>, GreetThemCmd, kbAltG ) +
        *<span>new</span> <span>TMenuItem</span>( <span><span>&#34;</span>五劫~の~擦り切れ<span>&#34;</span></span>, cmYes, kbNoKey, hcNoContext ) +
        *<span>new</span> <span>TMenuItem</span>( <span><span>&#34;</span>העברית ~א~ינטרנט<span>&#34;</span></span>, cmNo, kbNoKey, hcNoContext ) +
         <span>newLine</span>() +
        *<span>new</span> <span>TMenuItem</span>( <span><span>&#34;</span>E~x~it<span>&#34;</span></span>, cmQuit, cmQuit, hcNoContext, <span><span>&#34;</span>Alt-X<span>&#34;</span></span> )
        );
}

TStatusLine *<span>THelloApp::initStatusLine</span>( TRect r )
{
    r.<span>a</span>.<span>y</span> = r.<span>b</span>.<span>y</span>-<span>1</span>;
    <span>return</span> <span>new</span> <span>TStatusLine</span>( r,
        *<span>new</span> <span>TStatusDef</span>( <span>0</span>, <span>0xFFFF</span> ) +
            *<span>new</span> <span>TStatusItem</span>( <span><span>&#34;</span>~Alt-Ç~ Exit<span>&#34;</span></span>, kbAltX, cmQuit ) +
            *<span>new</span> <span>TStatusItem</span>( <span>0</span>, kbF10, cmMenu )
            );
}</pre></div>
<p dir="auto">Here is what it looks like:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/20713561/103179255-5396a380-488a-11eb-88ad-0192adbe233e.png"><img src="https://user-images.githubusercontent.com/20713561/103179255-5396a380-488a-11eb-88ad-0192adbe233e.png" alt="Unicode Hello"/></a></p>
<h3 dir="auto"><a id="user-content-example-writing-unicode-aware-draw-methods" aria-hidden="true" href="#example-writing-unicode-aware-draw-methods"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: writing Unicode-aware <code>draw()</code> methods</h3>
<p dir="auto">The following is an excerpt from an old implementation of <code>TFileViewer::draw()</code> (part of the <code>tvdemo</code> application), which does not draw Unicode text properly:</p>
<div data-snippet-clipboard-copy-content="if (delta.y + i &lt; fileLines-&gt;getCount()) {
    char s[maxLineLength+1];
    p = (char *)(fileLines-&gt;at(delta.y+i));
    if (p == 0 || strlen(p) &lt; delta.x)
        s[0] = EOS;
    else
        strnzcpy(s, p+delta.x, maxLineLength+1);
    b.moveStr(0, s, c);
}
writeBuf( 0, i, size.x, 1, b );"><pre><span>if</span> (delta.y + i &lt; fileLines-&gt;<span>getCount</span>()) {
    <span>char</span> s[maxLineLength+<span>1</span>];
    p = (<span>char</span> *)(fileLines-&gt;<span>at</span>(delta.<span>y</span>+i));
    <span>if</span> (p == <span>0</span> || <span>strlen</span>(p) &lt; delta.<span>x</span>)
        s[<span>0</span>] = EOS;
    <span>else</span>
        <span>strnzcpy</span>(s, p+delta.<span>x</span>, maxLineLength+<span>1</span>);
    b.<span>moveStr</span>(<span>0</span>, s, c);
}
<span>writeBuf</span>( <span>0</span>, i, size.x, <span>1</span>, b );</pre></div>
<p dir="auto">All it does is move part of a string in <code>fileLines</code> into <code>b</code>, which is a <code>TDrawBuffer</code>. <code>delta</code> is a <code>TPoint</code> representing the scroll offset in the text view, and <code>i</code> is the index of the visible line being processed. <code>c</code> is the text color. A few issues are present:</p>
<ul dir="auto">
<li><code>TDrawBuffer::moveStr(ushort, const char *, TColorAttr)</code> takes a null-terminated string. In order to pass a substring of the current line, a copy is made into the array <code>s</code>, at the risk of a <a href="https://github.com/magiblot/tvision/commit/8aa2bf4af4474b85e86e340b08d7c56081b68986">buffer overrun</a>. The case where the line does not fit into <code>s</code> is not handled, so at most <code>maxLineLenght</code> characters will be copied. What&#39;s more, a multibyte character near position <code>maxLineLength</code> could be copied incompletely and be displayed as garbage.</li>
<li><code>delta.x</code> is the first visible column. With multibyte-encoded text, it is no longer true that such column begins at position <code>delta.x</code> in the string.</li>
</ul>
<p dir="auto">Below is a corrected version of the code above that handles Unicode properly:</p>
<div data-snippet-clipboard-copy-content="if (delta.y + i &lt; fileLines-&gt;getCount()) {
    p = (char *)(fileLines-&gt;at(delta.y+i));
    if (p)
        b.moveStr(0, p, c, size.x, delta.x);
}
writeBuf( 0, i, size.x, 1, b );"><pre><span>if</span> (delta.y + i &lt; fileLines-&gt;<span>getCount</span>()) {
    p = (<span>char</span> *)(fileLines-&gt;<span>at</span>(delta.<span>y</span>+i));
    <span>if</span> (p)
        b.<span>moveStr</span>(<span>0</span>, p, c, size.<span>x</span>, delta.<span>x</span>);
}
<span>writeBuf</span>( <span>0</span>, i, size.x, <span>1</span>, b );</pre></div>
<p dir="auto">The overload of <code>moveStr</code> used here is <code>TDrawBuffer::moveStr(ushort indent, TStringView str, TColorAttr attr, ushort width, ushort begin)</code>. This function not only provides Unicode support, but also helps us write cleaner code and overcome some of the limitations previously present:</p>
<ul dir="auto">
<li>The intermediary copy is avoided, so the displayed text is not limited to <code>maxLineLength</code> bytes.</li>
<li><code>moveStr</code> takes care of printing the string starting at column <code>delta.x</code>. We do not even need to worry about how many bytes correspond to <code>delta.x</code> columns.</li>
<li>Similarly, <code>moveStr</code> is instructed to copy at most <code>size.x</code> columns of text without us having to care about how many bytes that is nor dealing with edge cases. The code is written in an encoding-agnostic way and will work whether multibyte characters are being considered or not.</li>
<li>In case you hadn&#39;t realized yet, the intermediary copy in the previous version was completely unnecessary. It would have been necessary only if we had needed to trim the end of the line, but that was not the case: text occupies all of the view&#39;s width, and <code>TView::writeBuf</code> already takes care of not writing beyond it. Yet it is interesting to see how an unnecessary step not only was limiting functionality but also was prone to bugs.</li>
</ul>
<h2 dir="auto"><a id="user-content-unicode-support-across-standard-views" aria-hidden="true" href="#unicode-support-across-standard-views"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Unicode support across standard views</h2>
<p dir="auto">Support for creating Unicode-aware views is in place, and most views in the original Turbo Vision library have been adapted to handle Unicode.</p>
<p dir="auto">The following views can display Unicode text properly. Some of them also do horizontal scrolling or word wrapping; all of that should work fine.</p>
<ul>
<li> <code>TStaticText</code> (<a href="https://github.com/magiblot/tvision/commit/7b15d45da231f75f2677454021c2e34ad1149ca8"><code>7b15d45d</code></a>).</li>
<li> <code>TFrame</code> (<a href="https://github.com/magiblot/tvision/commit/81066ee5c05496612dfcd9cf75df5702cbfb9679"><code>81066ee5</code></a>).</li>
<li> <code>TStatusLine</code> (<a href="https://github.com/magiblot/tvision/commit/477b3ae91fd84eb1487dca18a87b3f7b8699c576"><code>477b3ae9</code></a>).</li>
<li> <code>THistoryViewer</code> (<a href="https://github.com/magiblot/tvision/commit/81066ee5c05496612dfcd9cf75df5702cbfb9679"><code>81066ee5</code></a>).</li>
<li> <code>THelpViewer</code> (<a href="https://github.com/magiblot/tvision/commit/81066ee5c05496612dfcd9cf75df5702cbfb9679"><code>81066ee5</code></a>, <a href="https://github.com/magiblot/tvision/commit/8c7dac2a61000f17e09cc31ebbb58b030f95c0e5"><code>8c7dac2a</code></a>, <a href="https://github.com/magiblot/tvision/commit/20f331e362255d45859c36050ff75ffab078c3ab"><code>20f331e3</code></a>).</li>
<li> <code>TListViewer</code> (<a href="https://github.com/magiblot/tvision/commit/81066ee5c05496612dfcd9cf75df5702cbfb9679"><code>81066ee5</code></a>).</li>
<li> <code>TMenuBox</code> (<a href="https://github.com/magiblot/tvision/commit/81066ee5c05496612dfcd9cf75df5702cbfb9679"><code>81066ee5</code></a>).</li>
<li> <code>TTerminal</code> (<a href="https://github.com/magiblot/tvision/commit/ee821b69c5dd81c565fe1add1ac6f0a2f8a96a01"><code>ee821b69</code></a>).</li>
<li> <code>TOutlineViewer</code> (<a href="https://github.com/magiblot/tvision/commit/6cc8cd38da5841201544d6ba103f9662d7675213"><code>6cc8cd38</code></a>).</li>
<li> <code>TFileViewer</code> (from the <code>tvdemo</code> application) (<a href="https://github.com/magiblot/tvision/commit/068bbf7a0a13482bda91f9f3411ec614f9a1e6ff"><code>068bbf7a</code></a>).</li>
<li> <code>TFilePane</code> (from the <code>tvdir</code> application) (<a href="https://github.com/magiblot/tvision/commit/9bcd897cb7cf010ef34d0281d42e9ea58345ce53"><code>9bcd897c</code></a>).</li>
</ul>
<p dir="auto">The following views can, in addition, process Unicode text or user input:</p>
<ul>
<li> <code>TInputLine</code> (<a href="https://github.com/magiblot/tvision/commit/81066ee5c05496612dfcd9cf75df5702cbfb9679"><code>81066ee5</code></a>, <a href="https://github.com/magiblot/tvision/commit/cb489d42d522f7515c870942bcaa8f0f3dea3f35"><code>cb489d42</code></a>).</li>
<li> <code>TEditor</code> (<a href="https://github.com/magiblot/tvision/commit/702114dc03a13ebce2b52504eb122c97f9892de9"><code>702114dc</code></a>). Instances are in UTF-8 mode by default. You may switch back to single-byte mode by pressing <code>Ctrl+P</code>. This only changes how the document is displayed and the encoding of user input; it does not alter the document. This class is used in the <code>tvedit</code> application; you may test it there.</li>
</ul>
<p dir="auto">Views not in this list may not have needed any corrections or I simply forgot to fix them. Please submit an issue if you notice anything not working as expected.</p>
<p dir="auto">Use cases where Unicode is not supported (not an exhaustive list):</p>
<ul>
<li> Highlighted key shortcuts, in general (e.g. <code>TMenuBox</code>, <code>TStatusLine</code>, <code>TButton</code>...).</li>
</ul>


<p dir="auto">The Turbo Vision API offers no integration with the system clipboard. As a developer you can still access it by other means (e.g. via <a href="https://github.com/jtanx/libclipboard">libclipboard</a>). But unless you do that, the only way for a user to paste text into your application is to do so through the terminal emulator.</p>
<p dir="auto">Unfortunately, each character is processed as a separate <code>evKeyDown</code> event. If the user pastes 5000 characters, the application will execute the same operations as if the user pressed the keyboard 5000 times. This involves drawing views, completing the event loop, updating the screen, etcetera. As you can imagine, this is far from optimal.</p>
<p dir="auto">For the purpose of dealing with this situation, the Turbo Vision API has been extended with the following function:</p>
<div data-snippet-clipboard-copy-content="Boolean TView::textEvent(TEvent &amp;event, TSpan&lt;char&gt; dest, size_t &amp;length);"><pre><span>Boolean</span> <span>TView::textEvent</span>(TEvent &amp;event, TSpan&lt;<span>char</span>&gt; dest, <span>size_t</span> &amp;length);</pre></div>
<p dir="auto"><code>TEditor</code> takes advantage of this function to provide a good user experience when pasting text through the terminal. You can check it out in the <code>tvedit</code> application. As a developer, you may be interested in using it if you are implementing a text editing component. Otherwise, you don&#39;t need to care about it.</p>
<p dir="auto">Just for the record, here is a more detailed explanation:</p>
<p dir="auto"><code>textEvent()</code> tries to read text from standard input and stores it in a user-provided buffer <code>dest</code>. It returns <code>False</code> when no more events are available in the program&#39;s input queue or if a non-text event is found, in which case this event is saved with <code>putEvent()</code> so that it can be processed in the next iteration of the event loop.</p>
<p dir="auto">The exact number of bytes read is stored in the output parameter <code>length</code>, which can never be greater than <code>dest.size()</code>.</p>
<p dir="auto">It is intended to be used as follows:</p>
<div data-snippet-clipboard-copy-content="// &#39;ev&#39; is a TEvent, and &#39;ev.what&#39; equals &#39;evKeyDown&#39;.
// If the event contains text...
if (ev.keyDown.textLength) {
    char buf[512];
    size_t length;
    // Fill &#39;buf&#39; with text from the input queue,
    // including the text in &#39;ev&#39;.
    while (textEvent(ev, buf, length)) {
        // Process &#39;length&#39; bytes of text in &#39;buf&#39;.
        // ...
    }
    // &#39;textEvent()&#39; clears &#39;ev&#39; after reading it the first time
    // (by this point, &#39;ev.what&#39; is &#39;evNothing&#39;).
}"><pre><span><span>//</span> &#39;ev&#39; is a TEvent, and &#39;ev.what&#39; equals &#39;evKeyDown&#39;.</span>
<span><span>//</span> If the event contains text...</span>
<span>if</span> (ev.keyDown.textLength) {
    <span>char</span> buf[<span>512</span>];
    <span>size_t</span> length;
    <span><span>//</span> Fill &#39;buf&#39; with text from the input queue,</span>
    <span><span>//</span> including the text in &#39;ev&#39;.</span>
    <span>while</span> (<span>textEvent</span>(ev, buf, length)) {
        <span><span>//</span> Process &#39;length&#39; bytes of text in &#39;buf&#39;.</span>
        <span><span>//</span> ...</span>
    }
    <span><span>//</span> &#39;textEvent()&#39; clears &#39;ev&#39; after reading it the first time</span>
    <span><span>//</span> (by this point, &#39;ev.what&#39; is &#39;evNothing&#39;).</span>
}</pre></div>


<p dir="auto">The Turbo Vision API has been extended to allow more than the original 16 colors.</p>
<p dir="auto">Colors can be specified using any of the following formats:</p>
<ul dir="auto">
<li><a href="https://en.wikipedia.org/wiki/BIOS_color_attributes" rel="nofollow">BIOS color attributes</a> (4-bit), the format used originally on MS-DOS.</li>
<li>RGB (24-bit).</li>
<li><code>xterm-256color</code> palette indices (8-bit).</li>
<li>The <em>terminal default</em> color. This is the color used by terminal emulators when no display attributes (bold, color...) are enabled (usually white for foreground and black for background).</li>
</ul>
<p dir="auto">Although Turbo Vision applications are likely to be ran in a terminal emulator, the API makes no assumptions about the display device. That is, the complexity of dealing with terminal emulators is hidden from the programmer and managed by Turbo Vision itself.</p>
<p dir="auto">For example: color support varies among terminals. If the programmer uses a color format not supported by the terminal emulator, Turbo Vision will quantize it to what the terminal can display. The following images represent the quantization of a 24-bit RGB picture to 256, 16 and 8 color palettes:</p>
<table>
<thead>
<tr>
<th>24-bit color (original)</th>
<th>256 colors</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/20713561/111095336-7c4f4080-853d-11eb-8331-798898a2af68.png"><img src="https://user-images.githubusercontent.com/20713561/111095336-7c4f4080-853d-11eb-8331-798898a2af68.png" alt="mpv-shot0005"/></a></td>
<td><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/20713561/111095333-7b1e1380-853d-11eb-8c4d-989fe24d0498.png"><img src="https://user-images.githubusercontent.com/20713561/111095333-7b1e1380-853d-11eb-8c4d-989fe24d0498.png" alt="mpv-shot0002"/></a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>16 colors</th>
<th>8 colors (bold as bright)</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/20713561/111095334-7bb6aa00-853d-11eb-9a3f-e7decc0bac7d.png"><img src="https://user-images.githubusercontent.com/20713561/111095334-7bb6aa00-853d-11eb-9a3f-e7decc0bac7d.png" alt="mpv-shot0003"/></a></td>
<td><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/20713561/111095335-7bb6aa00-853d-11eb-9098-38d6f6c3c1da.png"><img src="https://user-images.githubusercontent.com/20713561/111095335-7bb6aa00-853d-11eb-9098-38d6f6c3c1da.png" alt="mpv-shot0004"/></a></td>
</tr>
</tbody>
</table>
<p dir="auto">Extended color support basically comes down to the following:</p>
<ul dir="auto">
<li>Turbo Vision has originally used <a href="https://en.wikipedia.org/wiki/BIOS_color_attributes" rel="nofollow">BIOS color attributes</a> stored in an <code>uchar</code>. <code>ushort</code> is used to represent attribute pairs. This is still the case when using Borland C++.</li>
<li>In modern platforms a new type <code>TColorAttr</code> has been added which replaces <code>uchar</code>. It specifies a foreground and background color and a style. Colors can be specified in different formats (BIOS color attributes, 24-bit RGB...). Styles are the typical ones (bold, italic, underline...). There&#39;s also <code>TAttrPair</code>, which replaces <code>ushort</code>.</li>
<li><code>TDrawBuffer</code>&#39;s methods, which used to take <code>uchar</code> or <code>ushort</code> parameters to specify color attributes, now take <code>TColorAttr</code> or <code>TAttrPair</code>.</li>
<li><code>TPalette</code>, which used to contain an array of <code>uchar</code>, now contains an array of <code>TColorAttr</code>. The <code>TView::mapColor</code> method also returns <code>TColorAttr</code> instead of <code>uchar</code>.</li>
<li><code>TView::mapColor</code> has been made virtual so that the palette system can be bypassed without having to rewrite any <code>draw</code> methods.</li>
<li><code>TColorAttr</code> and <code>TAttrPair</code> can be initialized with and casted into <code>uchar</code> and <code>ushort</code> in a way such that legacy code still compiles out-of-the-box without any change in functionality.</li>
</ul>
<p dir="auto">Below is a more detailed explanation aimed at developers.</p>
<details>
<summary>API reference of extended color support (<i>click to expand</i>).</summary>
<h2 dir="auto"><a id="user-content-data-types" aria-hidden="true" href="#data-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Data Types</h2>
<p dir="auto">In the first place we will explain the data types the programmer needs to know in order to take advantage of the extended color suport.</p>
<p dir="auto">To get access to them, define the macro <code>Uses_TColorAttr</code> before including <code>&lt;tvision/tv.h&gt;</code>. You may not need to do this because other classes like <code>TView</code> or <code>TDrawBuffer</code> already depend on it.</p>
<p dir="auto">All the types described in this section are <em>trivial</em>. This means that they can be <code>memset</code>&#39;d and <code>memcpy</code>&#39;d. But variables of these types are <em>uninitialized</em> when declared without initializer, just like primitive types. So make sure you don&#39;t manipulate them before initializing them.</p>
<h3 dir="auto"><a id="user-content-color-format-types" aria-hidden="true" href="#color-format-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Color format types</h3>
<p dir="auto">Several types are defined which represent different color formats.
The reason why these types exist is to allow distinguishing color formats using the type system. Some of them also have public fields which make it easier to manipulate individual bits.</p>
<ul dir="auto">
<li>
<p dir="auto"><code>TColorBIOS</code> represents a BIOS color. It behaves the same as <code>uint8_t</code>, but allows accessing the <code>r</code>, <code>g</code>, <code>b</code> and <code>bright</code> bits individually.</p>
<p dir="auto">The memory layout is:</p>
<ul dir="auto">
<li>Bit 0: Blue (field <code>b</code>).</li>
<li>Bit 1: Green (field <code>g</code>).</li>
<li>Bit 2: Red (field <code>r</code>).</li>
<li>Bit 3: Bright (field <code>bright</code>).</li>
<li>Bits 4-7: unused.</li>
</ul>
<div data-snippet-clipboard-copy-content="TColorBIOS bios = 0x4;  // 0x4: red.
bios.bright = 1;        // 0xC: light red.
bios.b = bios.r;        // 0xD: light magenta.
bios = bios ^ 3;        // 0xE: yellow.
uint8_t c = bios;       // Implicit conversion to integer types."><pre>TColorBIOS bios = <span>0x4</span>;  <span><span>//</span> 0x4: red.</span>
bios.bright = <span>1</span>;        <span><span>//</span> 0xC: light red.</span>
bios.b = bios.r;        <span><span>//</span> 0xD: light magenta.</span>
bios = bios ^ <span>3</span>;        <span><span>//</span> 0xE: yellow.</span>
<span>uint8_t</span> c = bios;       <span><span>//</span> Implicit conversion to integer types.</span></pre></div>
<p dir="auto">In terminal emulators, BIOS colors are mapped to the basic 16 ANSI colors.</p>
</li>
<li>
<p dir="auto"><code>TColorRGB</code> represents a color in 24-bit RGB. It behaves the same as <code>uint32_t</code> but allows accessing the <code>r</code>, <code>g</code> and <code>b</code> bit fields individually.</p>
<p dir="auto">The memory layout is:</p>
<ul dir="auto">
<li>Bits 0-7: Blue (field <code>b</code>).</li>
<li>Bits 8-15: Green (field <code>g</code>).</li>
<li>Bits 16-23: Red (field <code>r</code>).</li>
<li>Bits 24-31: unused.</li>
</ul>
<div data-snippet-clipboard-copy-content="TColorRGB rgb = 0x9370DB;   // 0xRRGGBB.
rgb = {0x93, 0x70, 0xDB};   // {R, G, B}.
rgb = rgb ^ 0xFFFFFF;       // Negated.
rgb.g = rgb.r &amp; 0x88;       // Access to individual components.
uint32_t c = rgb;           // Implicit conversion to integer types."><pre>TColorRGB rgb = <span>0x9370DB</span>;   <span><span>//</span> 0xRRGGBB.</span>
rgb = {<span>0x93</span>, <span>0x70</span>, <span>0xDB</span>};   <span><span>//</span> {R, G, B}.</span>
rgb = rgb ^ <span>0xFFFFFF</span>;       <span><span>//</span> Negated.</span>
rgb.g = rgb.r &amp; <span>0x88</span>;       <span><span>//</span> Access to individual components.</span>
<span>uint32_t</span> c = rgb;           <span><span>//</span> Implicit conversion to integer types.</span></pre></div>
</li>
<li>
<p dir="auto"><code>TColorXTerm</code> represents an index into the <code>xterm-256color</code> color palette. It behaves the same as <code>uint8_t</code>.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-tcolordesired" aria-hidden="true" href="#tcolordesired"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>TColorDesired</code></h3>
<p dir="auto"><code>TColorDesired</code> represents a color which the programmer intends to show on screen, encoded in any of the supported color types.</p>
<p dir="auto">A <code>TColorDesired</code> can be initialized in the following ways:</p>
<ul dir="auto">
<li>
<p dir="auto">As a BIOS color: with a <code>char</code> literal or a <code>TColorBIOS</code> object:</p>
<div data-snippet-clipboard-copy-content="TColorDesired bios1 = &#39;\xF&#39;;
TColorDesired bios2 = TColorBIOS(0xF);"><pre>TColorDesired bios1 = <span><span>&#39;</span><span>\xF</span><span>&#39;</span></span>;
TColorDesired bios2 = TColorBIOS(<span>0xF</span>);</pre></div>
</li>
<li>
<p dir="auto">As a RGB color: with an <code>int</code> literal or a <code>TColorRGB</code> object:</p>
<div data-snippet-clipboard-copy-content="TColorDesired rgb1 = 0xFF7700; // 0xRRGGBB.
TColorDesired rgb2 = TColorRGB(0xFF, 0x77, 0x00); // {R, G, B}.
TColorDesired rgb3 = TColorRGB(0xFF7700); // 0xRRGGBB."><pre>TColorDesired rgb1 = <span>0xFF7700</span>; <span><span>//</span> 0xRRGGBB.</span>
TColorDesired rgb2 = TColorRGB(<span>0xFF</span>, <span>0x77</span>, <span>0x00</span>); <span><span>//</span> {R, G, B}.</span>
TColorDesired rgb3 = TColorRGB(<span>0xFF7700</span>); <span><span>//</span> 0xRRGGBB.</span></pre></div>
</li>
<li>
<p dir="auto">As an XTerm palette index: with a <code>TColorXTerm</code> object.</p>
</li>
<li>
<p dir="auto">As the <em>terminal default</em> color: through zero-initialization:</p>
<div data-snippet-clipboard-copy-content="TColorDesired def1 {};
// Or with &#39;memset&#39;:
TColorDesired def2;
memset(&amp;def2, 0, sizeof(def2));"><pre>TColorDesired def1 {};
<span><span>//</span> Or with &#39;memset&#39;:</span>
TColorDesired def2;
<span>memset</span>(&amp;def2, <span>0</span>, <span>sizeof</span>(def2));</pre></div>
</li>
</ul>
<p dir="auto"><code>TColorDesired</code> has methods to query the contained color, but you will usually not need to use them. See the struct definition in <code>&lt;tvision/colors.h&gt;</code> for more information.</p>
<p dir="auto">Trivia: the name is inspired by <a href="https://www.scintilla.org/index.html" rel="nofollow">Scintilla</a>&#39;s <code>ColourDesired</code>.</p>
<h3 dir="auto"><a id="user-content-tcolorattr" aria-hidden="true" href="#tcolorattr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>TColorAttr</code></h3>
<p dir="auto"><code>TColorAttr</code> describes the color attributes of a screen cell. This is the type you are most likely to interact with if you intend to change the colors in a view.</p>
<p dir="auto">A <code>TColorAttr</code> is composed of:</p>
<ul dir="auto">
<li>
<p dir="auto">A foreground color, of type <code>TColorDesired</code>.</p>
</li>
<li>
<p dir="auto">A background color, of type <code>TColorDesired</code>.</p>
</li>
<li>
<p dir="auto">A style bitmask containing a combination of the following flags:</p>
<ul dir="auto">
<li><code>slBold</code>.</li>
<li><code>slItalic</code>.</li>
<li><code>slUnderline</code>.</li>
<li><code>slBlink</code>.</li>
<li><code>slReverse</code>.</li>
<li><code>slStrike</code>.</li>
</ul>
<p dir="auto">These flags are based on the basic display attributes selectable through <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters" rel="nofollow">ANSI escape codes</a>. The results may vary between terminal emulators. <code>slReverse</code> is probably the least reliable of them: prefer using the <code>TColorAttr reverseAttribute(TColorAttr attr)</code> free function over setting this flag.</p>
</li>
</ul>
<p dir="auto">The most straight-forward way to create a <code>TColorAttr</code> is by means of the <code>TColorAttr(TColorDesired fg, TColorDesired bg, ushort style=0)</code> and <code>TColorAttr(int bios)</code> constructors:</p>
<div data-snippet-clipboard-copy-content="// Foreground: RGB 0x892312
// Background: RGB 0x7F00BB
// Style: Normal.
TColorAttr a1 = {TColorRGB(0x89, 0x23, 0x12), TColorRGB(0x7F, 0x00, 0xBB)};

// Foreground: BIOS 0x7.
// Background: RGB 0x7F00BB.
// Style: Bold, Italic.
TColorAttr a2 = {&#39;\x7&#39;, 0x7F00BB, slBold | slItalic};

// Foreground: Terminal default.
// Background: BIOS 0xF.
// Style: Normal.
TColorAttr a3 = {{}, TColorBIOS(0xF)};

// Foreground: Terminal default.
// Background: Terminal default.
// Style: Normal.
TColorAttr a4 = {};

// Foreground: BIOS 0x0
// Background: BIOS 0x7
// Style: Normal
TColorAttr a5 = 0x70;"><pre><span><span>//</span> Foreground: RGB 0x892312</span>
<span><span>//</span> Background: RGB 0x7F00BB</span>
<span><span>//</span> Style: Normal.</span>
TColorAttr a1 = {<span>TColorRGB</span>(<span>0x89</span>, <span>0x23</span>, <span>0x12</span>), <span>TColorRGB</span>(<span>0x7F</span>, <span>0x00</span>, <span>0xBB</span>)};

<span><span>//</span> Foreground: BIOS 0x7.</span>
<span><span>//</span> Background: RGB 0x7F00BB.</span>
<span><span>//</span> Style: Bold, Italic.</span>
TColorAttr a2 = {<span><span>&#39;</span><span>\x7</span><span>&#39;</span></span>, <span>0x7F00BB</span>, slBold | slItalic};

<span><span>//</span> Foreground: Terminal default.</span>
<span><span>//</span> Background: BIOS 0xF.</span>
<span><span>//</span> Style: Normal.</span>
TColorAttr a3 = {{}, <span>TColorBIOS</span>(<span>0xF</span>)};

<span><span>//</span> Foreground: Terminal default.</span>
<span><span>//</span> Background: Terminal default.</span>
<span><span>//</span> Style: Normal.</span>
TColorAttr a4 = {};

<span><span>//</span> Foreground: BIOS 0x0</span>
<span><span>//</span> Background: BIOS 0x7</span>
<span><span>//</span> Style: Normal</span>
TColorAttr a5 = <span>0x70</span>;</pre></div>
<p dir="auto">The fields of a <code>TColorAttr</code> can be accessed with the following free functions:</p>
<div data-snippet-clipboard-copy-content="TColorDesired getFore(const TColorAttr &amp;attr);
TColorDesired getBack(const TColorAttr &amp;attr);
ushort getStyle(const TColorAttr &amp;attr);
void setFore(TColorAttr &amp;attr, TColorDesired fg);
void setBack(TColorAttr &amp;attr, TColorDesired bg);
void setStyle(TColorAttr &amp;attr, ushort style);"><pre>TColorDesired <span>getFore</span>(<span>const</span> TColorAttr &amp;attr);
TColorDesired <span>getBack</span>(<span>const</span> TColorAttr &amp;attr);
<span>ushort</span> <span>getStyle</span>(<span>const</span> TColorAttr &amp;attr);
<span>void</span> <span>setFore</span>(TColorAttr &amp;attr, TColorDesired fg);
<span>void</span> <span>setBack</span>(TColorAttr &amp;attr, TColorDesired bg);
<span>void</span> <span>setStyle</span>(TColorAttr &amp;attr, <span>ushort</span> style);</pre></div>
<h3 dir="auto"><a id="user-content-tattrpair" aria-hidden="true" href="#tattrpair"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>TAttrPair</code></h3>
<p dir="auto"><code>TAttrPair</code> is a pair of <code>TColorAttr</code>, used by some API functions to pass two attributes at once.</p>
<p dir="auto">You may initialize a <code>TAttrPair</code> with the <code>TAttrPair(const TColorAttrs &amp;lo, const TColorAttrs &amp;hi)</code> constructor:</p>
<div data-snippet-clipboard-copy-content="TColorAttr cNormal = {0x234983, 0x267232};
TColorAttr cHigh = {0x309283, 0x127844};
TAttrPair attrs = {cNormal, cHigh};
TDrawBuffer b;
b.moveCStr(0, &#34;Normal text, ~Highlighted text~&#34;, attrs);"><pre>TColorAttr cNormal = {<span>0x234983</span>, <span>0x267232</span>};
TColorAttr cHigh = {<span>0x309283</span>, <span>0x127844</span>};
TAttrPair attrs = {cNormal, cHigh};
TDrawBuffer b;
b.moveCStr(<span>0</span>, <span><span>&#34;</span>Normal text, ~Highlighted text~<span>&#34;</span></span>, attrs);</pre></div>
<p dir="auto">The attributes can be accessed with the <code>[0]</code> and <code>[1]</code> subindices:</p>
<div data-snippet-clipboard-copy-content="TColorAttr lo = {0x892343, 0x271274};
TColorAttr hi = &#39;\x93&#39;;
TAttrPair attrs = {lo, hi};
assert(lo == attrs[0]);
assert(hi == attrs[1]);"><pre>TColorAttr lo = {<span>0x892343</span>, <span>0x271274</span>};
TColorAttr hi = <span><span>&#39;</span><span>\x93</span><span>&#39;</span></span>;
TAttrPair attrs = {lo, hi};
<span>assert</span>(lo == attrs[<span>0</span>]);
<span>assert</span>(hi == attrs[<span>1</span>]);</pre></div>
<h2 dir="auto"><a id="user-content-changing-the-appearance-of-a-tview" aria-hidden="true" href="#changing-the-appearance-of-a-tview"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Changing the appearance of a <code>TView</code></h2>
<p dir="auto">Views are commonly drawn by means of a <code>TDrawBuffer</code>. Most <code>TDrawBuffer</code> member functions take color attributes by parameter. For example:</p>
<div data-snippet-clipboard-copy-content="ushort TDrawBuffer::moveStr(ushort indent, TStringView str, TColorAttr attr);
ushort TDrawBuffer::moveCStr(ushort indent, TStringView str, TAttrPair attrs);
void TDrawBuffer::putAttribute(ushort indent, TColorAttr attr);"><pre><span>ushort</span> <span>TDrawBuffer::moveStr</span>(<span>ushort</span> indent, TStringView str, TColorAttr attr);
<span>ushort</span> <span>TDrawBuffer::moveCStr</span>(<span>ushort</span> indent, TStringView str, TAttrPair attrs);
<span>void</span> <span>TDrawBuffer::putAttribute</span>(<span>ushort</span> indent, TColorAttr attr);</pre></div>
<p dir="auto">However, the views provided with Turbo Vision usually store their color information in palettes. A view&#39;s palette can be queried with the following member functions:</p>
<div data-snippet-clipboard-copy-content="TColorAttr TView::mapColor(uchar index);
TAttrPair TView::getColor(ushort indices);"><pre>TColorAttr <span>TView::mapColor</span>(uchar index);
TAttrPair <span>TView::getColor</span>(<span>ushort</span> indices);</pre></div>
<ul dir="auto">
<li>
<p dir="auto"><code>mapColor</code> looks up a single color attribute in the view&#39;s palette, given an index into the palette. Remember that the palette indices for each view class can be found in the Turbo Vision headers. For example, <code>&lt;tvision/views.h&gt;</code> says the following about <code>TScrollBar</code>:</p>
<div data-snippet-clipboard-copy-content="/* ---------------------------------------------------------------------- */
/*      class TScrollBar                                                  */
/*                                                                        */
/*      Palette layout                                                    */
/*        1 = Page areas                                                  */
/*        2 = Arrows                                                      */
/*        3 = Indicator                                                   */
/* ---------------------------------------------------------------------- */"><pre><span><span>/*</span> ---------------------------------------------------------------------- <span>*/</span></span>
<span><span>/*</span>      class TScrollBar                                                  <span>*/</span></span>
<span><span>/*</span>                                                                        <span>*/</span></span>
<span><span>/*</span>      Palette layout                                                    <span>*/</span></span>
<span><span>/*</span>        1 = Page areas                                                  <span>*/</span></span>
<span><span>/*</span>        2 = Arrows                                                      <span>*/</span></span>
<span><span>/*</span>        3 = Indicator                                                   <span>*/</span></span>
<span><span>/*</span> ---------------------------------------------------------------------- <span>*/</span></span></pre></div>
</li>
<li>
<p dir="auto"><code>getColor</code> is a helper function that allows querying two cell attributes at once. Each byte in the <code>indices</code> parameter contains an index into the palette. The <code>TAttrPair</code> result contains the two cell attributes.</p>
<p dir="auto">For example, the following can be found in the <code>draw</code> method of <code>TMenuBar</code>:</p>
<div data-snippet-clipboard-copy-content="TAttrPair cNormal = getColor(0x0301);
TAttrPair cSelect = getColor(0x0604);"><pre>TAttrPair cNormal = getColor(<span>0x0301</span>);
TAttrPair cSelect = getColor(<span>0x0604</span>);</pre></div>
<p dir="auto">Which would be equivalent to this:</p>
<div data-snippet-clipboard-copy-content="TAttrPair cNormal = {mapColor(1), mapColor(3)};
TAttrPair cSelect = {mapColor(4), mapColor(6)};"><pre>TAttrPair cNormal = {<span>mapColor</span>(<span>1</span>), <span>mapColor</span>(<span>3</span>)};
TAttrPair cSelect = {<span>mapColor</span>(<span>4</span>), <span>mapColor</span>(<span>6</span>)};</pre></div>
</li>
</ul>
<p dir="auto">As an API extension, the <code>mapColor</code> method has been made <code>virtual</code>. This makes it possible to override Turbo Vision&#39;s hierarchical palette system with a custom solution without having to rewrite the <code>draw()</code> method.</p>
<p dir="auto">So, in general, there are three ways to use extended colors in views:</p>
<ol dir="auto">
<li>
<p dir="auto">By providing extended color attributes directly to <code>TDrawBuffer</code> methods, if the palette system is not being used. For example:</p>
<div data-snippet-clipboard-copy-content="// The &#39;TMyView&#39; class inherits from &#39;TView&#39; and overrides &#39;TView::draw&#39;.
void TMyView::draw()
{
    TDrawBuffer b;
    TColorAttr color {0x1F1C1B, 0xFAFAFA, slBold};
    b.moveStr(0, &#34;This is bold black text over a white background&#34;, color);
    /* ... */
}"><pre><span><span>//</span> The &#39;TMyView&#39; class inherits from &#39;TView&#39; and overrides &#39;TView::draw&#39;.</span>
<span>void</span> <span>TMyView::draw</span>()
{
    TDrawBuffer b;
    TColorAttr color {<span>0x1F1C1B</span>, <span>0xFAFAFA</span>, slBold};
    b.<span>moveStr</span>(<span>0</span>, <span><span>&#34;</span>This is bold black text over a white background<span>&#34;</span></span>, color);
    <span><span>/*</span> ... <span>*/</span></span>
}</pre></div>
</li>
<li>
<p dir="auto">By modifying the palettes. There are two ways to do this:</p>
<ol dir="auto">
<li>By modifying the application palette after it has been built. Note that the palette elements are <code>TColorAttr</code>. For example:</li>
</ol>
<div data-snippet-clipboard-copy-content="void updateAppPalette()
{
    TPalette &amp;pal = TProgram::application-&gt;getPalete();
    pal[1] = {0x762892, 0x828712};              // TBackground.
    pal[2] = {0x874832, 0x249838, slBold};      // TMenuView normal text.
    pal[3] = {{}, {}, slItalic | slUnderline};  // TMenuView disabled text.
    /* ... */
}"><pre><span>void</span> <span>updateAppPalette</span>()
{
    TPalette &amp;pal = TProgram::application-&gt;<span>getPalete</span>();
    pal[<span>1</span>] = {<span>0x762892</span>, <span>0x828712</span>};              <span><span>//</span> TBackground.</span>
    pal[<span>2</span>] = {<span>0x874832</span>, <span>0x249838</span>, slBold};      <span><span>//</span> TMenuView normal text.</span>
    pal[<span>3</span>] = {{}, {}, slItalic | slUnderline};  <span><span>//</span> TMenuView disabled text.</span>
    <span><span>/*</span> ... <span>*/</span></span>
}</pre></div>
<ol start="2" dir="auto">
<li>By using extended color attributes in the application palette definition:</li>
</ol>
<div data-snippet-clipboard-copy-content="static const TColorAttr cpMyApp[] =
{
    {0x762892, 0x828712},               // TBackground.
    {0x874832, 0x249838, slBold},       // TMenuView normal text.
    {{}, {}, slItalic | slUnderline},   // TMenuView disabled text.
    /* ... */
};

// The &#39;TMyApp&#39; class inherits from &#39;TApplication&#39; and overrides &#39;TView::getPalette&#39;.
TPalette &amp;TMyApp::getPalette() const
{
    static TPalette palette(cpMyApp);
    return palette;
}"><pre><span>static</span> <span>const</span> TColorAttr cpMyApp[] =
{
    {<span>0x762892</span>, <span>0x828712</span>},               <span><span>//</span> TBackground.</span>
    {<span>0x874832</span>, <span>0x249838</span>, slBold},       <span><span>//</span> TMenuView normal text.</span>
    {{}, {}, slItalic | slUnderline},   <span><span>//</span> TMenuView disabled text.</span>
    <span><span>/*</span> ... <span>*/</span></span>
};

<span><span>//</span> The &#39;TMyApp&#39; class inherits from &#39;TApplication&#39; and overrides &#39;TView::getPalette&#39;.</span>
TPalette &amp;<span>TMyApp::getPalette</span>() <span>const</span>
{
    <span>static</span> TPalette <span>palette</span>(cpMyApp);
    <span>return</span> palette;
}</pre></div>
</li>
<li>
<p dir="auto">By returning extended color attributes from an overriden <code>mapColor</code> method:</p>
</li>
</ol>
<div data-snippet-clipboard-copy-content="// The &#39;TMyScrollBar&#39; class inherits from &#39;TScrollBar&#39; and overrides &#39;TView::mapColor&#39;.
TColorAttr TMyScrollBar::mapColor(uchar index) noexcept
{
    // In this example the values are hardcoded,
    // but they could be stored elsewhere if desired.
    switch (index)
    {
        case 1:     return {0x492983, 0x826124}; // Page areas.
        case 2:     return {0x438939, 0x091297}; // Arrows.
        case 3:     return {0x123783, 0x329812}; // Indicator.
        default:    return errorAttr;
    }
}"><pre><span><span>//</span> The &#39;TMyScrollBar&#39; class inherits from &#39;TScrollBar&#39; and overrides &#39;TView::mapColor&#39;.</span>
TColorAttr <span>TMyScrollBar::mapColor</span>(uchar index) <span>noexcept</span>
{
    <span><span>//</span> In this example the values are hardcoded,</span>
    <span><span>//</span> but they could be stored elsewhere if desired.</span>
    <span>switch</span> (<span>index</span>)
    {
        <span>case</span> <span>1</span>:     <span>return</span> {<span>0x492983</span>, <span>0x826124</span>}; <span><span>//</span> Page areas.</span>
        <span>case</span> <span>2</span>:     <span>return</span> {<span>0x438939</span>, <span>0x091297</span>}; <span><span>//</span> Arrows.</span>
        <span>case</span> <span>3</span>:     <span>return</span> {<span>0x123783</span>, <span>0x329812</span>}; <span><span>//</span> Indicator.</span>
        <span>default</span>:    <span>return</span> errorAttr;
    }
}</pre></div>
<h2 dir="auto"><a id="user-content-display-capabilities" aria-hidden="true" href="#display-capabilities"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Display capabilities</h2>
<p dir="auto"><code>TScreen::screenMode</code> exposes some information about the display&#39;s color support:</p>
<ul dir="auto">
<li>If <code>(TScreen::screenMode &amp; 0xFF) == TDisplay::smMono</code>, the display is monocolor (only relevant in DOS).</li>
<li>If <code>(TScreen::screenMode &amp; 0xFF) == TDisplay::smBW80</code>, the display is grayscale (only relevant in DOS).</li>
<li>If <code>(TScreen::screenMode &amp; 0xFF) == TDisplay::smCO80</code>, the display supports at least 16 colors.
<ul dir="auto">
<li>If <code>TScreen::screenMode &amp; TDisplay::smColor256</code>, the display supports at least 256 colors.</li>
<li>If <code>TScreen::screenMode &amp; TDisplay::smColorHigh</code>, the display supports even more colors (e.g. 24-bit color). <code>TDisplay::smColor256</code> is also set in this case.</li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-backward-compatibility" aria-hidden="true" href="#backward-compatibility"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Backward-compatibility</h2>
<p dir="auto">The types defined previously represent concepts that are also important when developing for Borland C++:</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Layout in Borland C++</th>
<th>Layout in modern platforms</th>
</tr>
</thead>
<tbody>
<tr>
<td>Color Attribute</td>
<td><code>uchar</code>. A BIOS color attribute.</td>
<td><code>struct TColorAttr</code>.</td>
</tr>
<tr>
<td>Color</td>
<td>A 4-bit number.</td>
<td><code>struct TColorDesired</code>.</td>
</tr>
<tr>
<td>Attribute Pair</td>
<td><code>ushort</code>. An attribute in each byte.</td>
<td><code>struct TAttrPair</code>.</td>
</tr>
</tbody>
</table>
<p dir="auto">One of this project&#39;s key principles is that the API should be used in the same way both in Borland C++ and modern platforms, that is, without the need for <code>#ifdef</code>s. Another principle is that legacy code should compile out-of-the-box, and adapting it to the new features should increase complexity as little as possible.</p>
<p dir="auto">Backward-compatibility is accomplished in the following way:</p>
<ul dir="auto">
<li>
<p dir="auto">In Borland C++, <code>TColorAttr</code> and <code>TAttrPair</code> are <code>typedef</code>&#39;d to <code>uchar</code> and <code>ushort</code>, respectively.</p>
</li>
<li>
<p dir="auto">In modern platforms, <code>TColorAttr</code> and <code>TAttrPair</code> can be used in place of <code>uchar</code> and <code>ushort</code>, respectively. That is, the assertions in the following code won&#39;t fail:</p>
<div data-snippet-clipboard-copy-content="// Any value which fits into a &#39;uchar&#39; can be
// losslessly passed through TColorAttr.
uchar c = 0;
do {
    assert(uchar(TColorAttr {c}) == c);
} while (c++ &lt; UCHAR_MAX);

// Any value which fits into a &#39;ushort&#39; can be
// losslessly passed through TAttrPair.
ushort s = 0;
do {
    assert(ushort(TAttrPair {s}) == s);
} while (s++ &lt; USHRT_MAX);"><pre><span><span>//</span> Any value which fits into a &#39;uchar&#39; can be</span>
<span><span>//</span> losslessly passed through TColorAttr.</span>
uchar c = <span>0</span>;
<span>do</span> {
    <span>assert</span>(<span>uchar</span>(TColorAttr {c}) == c);
} <span>while</span> (c++ &lt; UCHAR_MAX);

<span><span>//</span> Any value which fits into a &#39;ushort&#39; can be</span>
<span><span>//</span> losslessly passed through TAttrPair.</span>
<span>ushort</span> s = <span>0</span>;
<span>do</span> {
    <span>assert</span>(<span>ushort</span>(TAttrPair {s}) == s);
} <span>while</span> (s++ &lt; USHRT_MAX);</pre></div>
<p dir="auto">A <code>TColorAttr</code> initialized with <code>uchar</code> represents a BIOS color attribute. When converting back to <code>uchar</code>, the following happens:</p>
<ul dir="auto">
<li>If <code>fg</code> and <code>bg</code> are BIOS colors, and <code>style</code> is cleared, the resulting <code>uchar</code> represents the same BIOS color attribute contained in the <code>TColorAttr</code> (as in the code above).</li>
<li>Otherwise, the conversion results in a color attribute that stands out, i.e. white on magenta, meaning that the programmer should consider replacing <code>uchar</code>/<code>ushort</code> with <code>TColorAttr</code>/<code>TAttrPair</code> if they intend to support the extended color attributes.</li>
</ul>
<p dir="auto">The same goes for <code>TAttrPair</code> and <code>ushort</code>, considering that it is composed of two <code>TColorAttr</code>.</p>
</li>
</ul>
<p dir="auto">A use case of backward-compatibility within Turbo Vision itself is the <code>TPalette</code> class, core of the palette system. In its original design, it used a single data type (<code>uchar</code>) to represent different things: array length, palette indices or color attributes.</p>
<p dir="auto">The new design simply replaces <code>uchar</code> with <code>TColorAttr</code>. This means there are no changes in the way <code>TPalette</code> is used, yet <code>TPalette</code> is now able to store extended color attributes.</p>
<p dir="auto"><code>TColorDialog</code> hasn&#39;t been remodeled yet, and thus it can&#39;t be used to pick extended color attributes at runtime.</p>
<h3 dir="auto"><a id="user-content-example-adding-extended-color-support-to-legacy-code" aria-hidden="true" href="#example-adding-extended-color-support-to-legacy-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: adding extended color support to legacy code</h3>
<p dir="auto">The following pattern of code is common across <code>draw</code> methods of views:</p>
<div data-snippet-clipboard-copy-content="void TMyView::draw()
{
    ushort cFrame, cTitle;
    if (state &amp; sfDragging)
    {
        cFrame = 0x0505;
        cTitle = 0x0005;
    }
    else
    {
        cFrame = 0x0503;
        cTitle = 0x0004;
    }
    cFrame = getColor(cFrame);
    cTitle = getColor(cTitle);
    /* ... */
}"><pre><span>void</span> <span>TMyView::draw</span>()
{
    <span>ushort</span> cFrame, cTitle;
    <span>if</span> (state &amp; sfDragging)
    {
        cFrame = <span>0x0505</span>;
        cTitle = <span>0x0005</span>;
    }
    <span>else</span>
    {
        cFrame = <span>0x0503</span>;
        cTitle = <span>0x0004</span>;
    }
    cFrame = <span>getColor</span>(cFrame);
    cTitle = <span>getColor</span>(cTitle);
    <span><span>/*</span> ... <span>*/</span></span>
}</pre></div>
<p dir="auto">In this case, <code>ushort</code> is used both as a pair of palette indices and as a pair of color attributes. <code>getColor</code> now returns a <code>TAttrPair</code>, so even though this compiles out-of-the-box, extended attributes will be lost in the implicit conversion to <code>ushort</code>.</p>
<p dir="auto">The code above still works just like it did originally. It&#39;s only non-BIOS color attributes that don&#39;t produce the expected result. Because of the compatibility between <code>TAttrPair</code> and <code>ushort</code>, the following is enough to enable support for extended color attributes:</p>
<div data-snippet-clipboard-copy-content="-    ushort cFrame, cTitle;
+    TAttrPair cFrame, cTitle;"><pre><span><span>-</span>    ushort cFrame, cTitle;</span>
<span><span>+</span>    TAttrPair cFrame, cTitle;</span></pre></div>
<p dir="auto">Nothing prevents you from using different variables for palette indices and color attributes, which is what should actually be done. The point of backward-compatibility is the ability to support new features without changing the program&#39;s logic, that is, minimizing the risk of increasing code complexity or introducing bugs.</p>
</details>
<br/>
</article>
          </div></div>
  </body>
</html>
