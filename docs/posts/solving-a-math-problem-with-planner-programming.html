<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/solving-a-math-problem-with-planner-programming/">Original</a>
    <h1>Solving a math problem with planner programming</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    <date>
                        
                            July 2, 2024
                        </date>
                
                
                
                    <h2>
                        More opportunities to mess with exotic technology
                    </h2>
                

                

                
                    
                        <p>The deadline for the <a href="https://buttondown.email/hillelwayne/archive/logic-for-programmers-update/" target="_blank">logic book</a> is coming up! I&#39;m hoping to have it ready for early access by either the end of this week or early next week. During a break on Monday I saw this interesting problem on <a href="https://math.stackexchange.com/questions/4939319/how-many-steps-are-needed-to-turn-one-a-into-at-least-100-000-as-using-only" target="_blank">Math Stack Exchange</a>:</p>
<blockquote>
<p>Suppose that at the beginning there is a blank document, and a letter &#34;a&#34; is written in it. In the following steps, only the three functions of &#34;select all&#34;, &#34;copy&#34; and &#34;paste&#34; can be used. </p>
<p>Find the minimum number of steps to reach at least 100,000 a&#39;s (each of the three operations of &#34;select all&#34;, &#34;copy&#34; and &#34;paste&#34; is counted as one step). If the target number is not specified, and I want to get the exact amount of a, is there a general formula?</p>
</blockquote>
<p>The first two answers look for analytic solutions. The <a href="https://math.stackexchange.com/a/4939673" target="_blank">last answer</a> shares a C++ program that finds it via breadth-first search. I&#39;ll reproduce it here:</p>
<div><pre><span></span><code><span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>#include</span><span> </span><span>&lt;queue&gt;</span>

<span>enum</span><span> </span><span>Mode</span>
<span>{</span>
<span>    </span><span>SELECT</span><span>,</span>
<span>    </span><span>COPY</span><span>,</span>
<span>    </span><span>PASTE</span>
<span>};</span>

<span>struct</span><span> </span><span>Node</span>
<span>{</span>
<span>    </span><span>int</span><span> </span><span>noOfAs</span><span>;</span>
<span>    </span><span>int</span><span> </span><span>steps</span><span>;</span>
<span>    </span><span>int</span><span> </span><span>noOfAsCopied</span><span>;</span>
<span>    </span><span>Mode</span><span> </span><span>mode</span><span>;</span>
<span>};</span>

<span>int</span><span> </span><span>main</span><span>()</span>
<span>{</span>
<span>    </span><span>std</span><span>::</span><span>queue</span><span>&lt;</span><span>Node</span><span>&gt;</span><span> </span><span>q</span><span>;</span>

<span>    </span><span>q</span><span>.</span><span>push</span><span>({</span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>SELECT</span><span>});</span>

<span>    </span><span>while</span><span> </span><span>(</span><span>!</span><span>q</span><span>.</span><span>empty</span><span>())</span>
<span>    </span><span>{</span>
<span>        </span><span>Node</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>q</span><span>.</span><span>front</span><span>();</span>
<span>        </span><span>q</span><span>.</span><span>pop</span><span>();</span>

<span>        </span><span>if</span><span> </span><span>(</span><span>n</span><span>.</span><span>noOfAs</span><span> </span><span>&gt;=</span><span> </span><span>100000</span><span>)</span>
<span>        </span><span>{</span>
<span>            </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span>.</span><span>steps</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>            </span><span>break</span><span>;</span>
<span>        </span><span>}</span>

<span>        </span><span>switch</span><span> </span><span>(</span><span>n</span><span>.</span><span>mode</span><span>)</span>
<span>        </span><span>{</span>
<span>        </span><span>case</span><span> </span><span>SELECT</span><span>:</span>
<span>            </span><span>q</span><span>.</span><span>push</span><span>({</span><span>n</span><span>.</span><span>noOfAs</span><span>,</span><span> </span><span>n</span><span>.</span><span>steps</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>n</span><span>.</span><span>noOfAsCopied</span><span>,</span><span> </span><span>COPY</span><span>});</span>
<span>            </span><span>break</span><span>;</span>
<span>        </span><span>case</span><span> </span><span>COPY</span><span>:</span>
<span>            </span><span>q</span><span>.</span><span>push</span><span>({</span><span>n</span><span>.</span><span>noOfAs</span><span>,</span><span> </span><span>n</span><span>.</span><span>steps</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>n</span><span>.</span><span>noOfAs</span><span>,</span><span> </span><span>PASTE</span><span>});</span>
<span>            </span><span>break</span><span>;</span>
<span>        </span><span>case</span><span> </span><span>PASTE</span><span>:</span>
<span>            </span><span>q</span><span>.</span><span>push</span><span>({</span><span>n</span><span>.</span><span>noOfAs</span><span>,</span><span> </span><span>n</span><span>.</span><span>steps</span><span>,</span><span> </span><span>n</span><span>.</span><span>noOfAsCopied</span><span>,</span><span> </span><span>SELECT</span><span>});</span>
<span>            </span><span>q</span><span>.</span><span>push</span><span>({</span><span>n</span><span>.</span><span>noOfAs</span><span> </span><span>+</span><span> </span><span>n</span><span>.</span><span>noOfAsCopied</span><span>,</span><span> </span><span>n</span><span>.</span><span>steps</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>n</span><span>.</span><span>noOfAsCopied</span><span>,</span><span> </span><span>PASTE</span><span>});</span>
<span>            </span><span>break</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>This is guaranteed to find a shortest possible solution due to a fun property of BFS: the distance of nodes to the origin never decreases. If you evaluate Node Y after Node X, then Y.dist &gt;= X.dist, meaning that the first valid solution will be a shortest possible solution. I should make this into a logic book example! </p>
<p>This also has the drawback of preventing <a href="https://www.hillelwayne.com/post/cleverness/" target="_blank">the use of an insight</a>. We <em>should</em> be able to fuse the select and copy steps together, meaning instead of having three actions (select, copy, paste) we only need two (selectcopy, paste), where selectcopy takes twice as many steps as pasting.</p>
<p>But we can&#39;t make that optimization because it breaks monotonicity. We&#39;re now pushing a mix of <code>n+1</code> and <code>n+2</code> steps onto the queue, and there&#39;s no way to order things to guarantee all of the <code>n+1</code> steps are searched before any <code>n+2</code> step.</p>
<p>I thought I&#39;d try to solve it with planning language instead, so we can get both the elegant solution and the optimization.</p>
<h3>Planning</h3>

<p>The rough idea of planning is that you provide an initial state, a set of actions, and a target, and the tool finds the shortest sequence of actions that reaches the target. I&#39;ve written about it in-depth <a href="https://www.hillelwayne.com/post/picat/" target="_blank">here</a> and also a comparison of planning to model checking <a href="https://www.hillelwayne.com/post/picat/" target="_blank">here</a>. I like how some tough problems in imperative and functional paradigms become easy problems with planning. </p>
<p>This is all in <a href="http://picat-lang.org/" target="_blank">Picat</a>, by the way, which I&#39;ve talked about more <a href="https://buttondown.email/hillelwayne/archive/picat-is-my-favorite-new-toolbox-language/" target="_blank">here</a> and in the <a href="https://www.hillelwayne.com/post/picat/" target="_blank">planning piece</a>. I&#39;ll just be explaining the planning stuff specific to this problem.</p>
<div><pre><span></span><code><span>import</span> <span>planner</span><span>.</span>
<span>import</span> <span>util</span><span>.</span>

<span>main</span> <span>=&gt;</span>
  <span>Init</span> <span>=</span> <span>$</span><span>state</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span> <span>% one a, nothing copied</span>
  <span>,</span> <span>best_plan</span><span>(</span><span>Init</span><span>,</span> <span>Plan</span><span>,</span> <span>Cost</span><span>)</span>
  <span>,</span> <span>nl</span>
  <span>,</span> <span>printf</span><span>(</span><span>&#34;Cost=%d%n&#34;</span><span>,</span> <span>Cost</span><span>)</span>
  <span>,</span> <span>printf</span><span>(</span><span>&#34;Plan=%s%n&#34;</span><span>,</span> <span>join</span><span>([</span><span>P</span><span>[</span><span>1</span><span>]</span><span>:</span> <span>P</span> <span>in</span> <span>Plan</span><span>],</span> <span>&#34; &#34;</span><span>))</span>
  <span>.</span>
</code></pre></div>
<p>We&#39;re storing the state of the system as two integers: the number of characters printed and the number of characters on our clipboard. Since we&#39;ll be fusing selects and copies, we don&#39;t need to also track the number of characters selected <del>(unlike the C++)</del>.</p>
<div><pre><span></span><code><span>final</span><span>(</span><span>state</span><span>(</span><span>A</span><span>,</span> <span>_</span><span>))</span> <span>=&gt;</span> <span>A</span> <span>&gt;=</span> <span>100000.</span>

<span>action</span><span>(</span><span>state</span><span>(</span><span>A</span><span>,</span> <span>Clipboard</span><span>),</span> <span>To</span><span>,</span> <span>Action</span><span>,</span> <span>Cost</span><span>)</span> <span>?=&gt;</span>
  <span>NewA</span> <span>=</span> <span>A</span> <span>+</span> <span>Clipboard</span>
   <span>,</span> <span>To</span> <span>=</span> <span>$</span><span>state</span><span>(</span><span>NewA</span><span>,</span> <span>Clipboard</span><span>)</span>
   <span>,</span> <span>Action</span> <span>=</span> <span>{</span><span>&#34;P&#34;</span><span>,</span> <span>To</span><span>}</span>
   <span>,</span> <span>Cost</span> <span>=</span> <span>1</span>
   <span>.</span>
</code></pre></div>
<p>The paste action just adds the clipboard to the character count. Because Picat is a research language it&#39;s a little weird with putting expressions inside structures. If we did <code>$state(1 + 1)</code> it would store it as <em>literally</em> <code>$state(1 + 1)</code>, not <code>state(2)</code>.</p>
<p>Also you have to use dollar signs for definitions but no dollar signs for pattern matching inside a function definition. I have <em>no idea</em> why.</p>
<div><pre><span></span><code><span>action</span><span>(</span><span>state</span><span>(</span><span>A</span><span>,</span> <span>Clipboard</span><span>),</span> <span>To</span><span>,</span> <span>Action</span><span>,</span> <span>Cost</span><span>)</span> <span>?=&gt;</span>
  <span>To</span> <span>=</span> <span>$</span><span>state</span><span>(</span><span>A</span><span>,</span> <span>A</span><span>)</span>
   <span>,</span> <span>Action</span> <span>=</span> <span>{</span><span>&#34;SC&#34;</span><span>,</span> <span>To</span><span>}</span>
   <span>,</span> <span>Cost</span> <span>=</span> <span>2</span>
   <span>.</span>
</code></pre></div>
<p>And that&#39;s it! That&#39;s the whole program. 
Running this gives us:</p>
<div><pre><span></span><code>Cost=42
Plan=SC P P SC P P SC P P SC P P SC P P SC 
     P P SC P P SC P P SC P P P SC P P P
</code></pre></div>
<p>To find if there&#39;s a sequence that gets us <em>exactly</em> 100,000, we just need to make one change:</p>
<div><pre><span></span><code><span>- final(state(A, _)) =&gt; A &gt;= 100000.</span>
<span>+ final(state(A, _)) =&gt; A = 100000.</span>
</code></pre></div>
<p>This returns a cost of 43.</p>
<p>On the other hand, I can&#39;t get it to find a path that makes exactly <code>100,001</code> characters, even with some optimizations.  This is because the shortest path is over 9000 steps long! I haven&#39;t checked if the C++ BFS can find it.</p>
<h3>Metaplanning</h3>
<p>One reason planning fascinates me so much is that, if a problem is now easy, you can play around with it. Like if I wanted to add &#34;delete a character&#34; as a move, that&#39;s easy:</p>
<div><pre><span></span><code><span>action</span><span>(</span><span>state</span><span>(</span><span>A</span><span>,</span> <span>Clipboard</span><span>),</span> <span>To</span><span>,</span> <span>Action</span><span>,</span> <span>Cost</span><span>)</span> <span>?=&gt;</span>
  <span>A</span> <span>&gt;</span> <span>0</span>
  <span>,</span> <span>NewA</span> <span>=</span> <span>A</span> <span>-</span> <span>1</span>
  <span>,</span> <span>To</span> <span>=</span> <span>$</span><span>state</span><span>(</span><span>NewA</span><span>,</span> <span>Clipboard</span><span>)</span>
  <span>,</span> <span>Action</span> <span>=</span> <span>{</span><span>&#34;D&#34;</span><span>,</span> <span>To</span><span>}</span>
  <span>,</span> <span>Cost</span> <span>=</span> <span>1</span>
  <span>.</span>
</code></pre></div>
<p>This doesn&#39;t make exceeding or reaching 100,000 easier, but it makes reaching 100,001 take 47 steps instead of 9000.</p>
<p>With some tweaks, I can also ask questions like &#34;what numbers does it make <em>the most</em> easier?&#34; or &#34;Do some numbers have more than one shortest path? Which number has the most?&#34;</p>
<p>Planning is really cool.</p>
                    
                

                
                    <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.email/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
                

            </div></div>
  </body>
</html>
