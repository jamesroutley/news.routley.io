<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.tempus-ex.com/hello-video-codec/">Original</a>
    <h1>Video codec in 100 lines of Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>It can&#39;t be overstated how crucial video codecs are to the products we use every day. Without them, we wouldn&#39;t be able to watch videos on YouTube or meet remotely via Zoom. But how do they work? In this post, we&#39;ll explore at a high level the key concepts and defining characteristics of video codecs. Then, to further demystify them, we&#39;ll even implement one from scratch in about a hundred lines of Rust.</p><p>Transmitting uncompressed video requires an immense amount of bandwidth. 8-bit 4K video at 60 FPS requires about 12 gbps of bandwidth to transfer uncompressed. If you want to deliver 4K video to consumers over the Internet, you&#39;re going to need to compress that down to about 50 mbps, which means you&#39;ll need a compression ratio of about 240:1 (which is extremely high).</p><p>A video codec is an algorithm which aims to compress video via one of two means:</p><ol><li>Eliminating redundant information</li><li>Eliminating insignificant information that has a low impact on quality</li></ol><h2 id="spatial-redundancy">Spatial Redundancy</h2><p>Generally images produced by cameras do not have much randomness in them. If you look at this image, it&#39;s easy to see that the blue pixels of the sky and water tend to be near other blue pixels:</p><figure><img src="https://blog.tempus-ex.com/content/images/2021/07/life-from-the-ocean@2x.jpg" alt="" loading="lazy" width="988" height="556" srcset="https://blog.tempus-ex.com/content/images/size/w600/2021/07/life-from-the-ocean@2x.jpg 600w, https://blog.tempus-ex.com/content/images/2021/07/life-from-the-ocean@2x.jpg 988w" sizes="(min-width: 720px) 720px"/><figcaption>&#34;Life From The Ocean&#34; from the <a href="https://www.blackmagicdesign.com/products/blackmagicpocketcinemacamera/gallery">Blackmagic Pocket Cinema Gallery</a></figcaption></figure><p>Similarly, pixels near red pixels tend to be red. Video codecs rely heavily on this observation and exploit it via techniques such as:</p><ul><li><strong>Intra Prediction</strong> – Intra prediction uses other pixels within the current frame to predict each pixel&#39;s color. Often the prediction is as simple as the average of the pixel to the left and the pixel above. After making predictions, codecs can encode the error (also known as the &#34;prediction residual&#34;) instead of the full pixel value.</li><li><strong>Discrete Cosine Transform (DCT)</strong> – This technique is used by JPEG, H.264, H.265, ProRes, and many more. For an excellent overview of how it works, including MATLAB code, see <a href="https://ottverse.com/discrete-cosine-transform-dct-video-compression/">Discrete Cosine Transform in Video Compression – Explain Like I’m 5</a>. DCTs can be used to eliminate spatial redundancy losslessly, but usually are used for lossy codecs as quality can be degraded quite gracefully by dropping DCT coefficients.</li></ul><h2 id="temporal-redundancy">Temporal Redundancy</h2><p>In a video, subsequent frames are generally very similar to one another. Here are two subsequent frames from <a href="https://gooseberry.blender.org">Cosmos Laundromat</a>:</p><figure><img src="https://blog.tempus-ex.com/content/images/2021/07/05388.png" alt="" loading="lazy" width="2000" height="838" srcset="https://blog.tempus-ex.com/content/images/size/w600/2021/07/05388.png 600w, https://blog.tempus-ex.com/content/images/size/w1000/2021/07/05388.png 1000w, https://blog.tempus-ex.com/content/images/size/w1600/2021/07/05388.png 1600w, https://blog.tempus-ex.com/content/images/2021/07/05388.png 2048w" sizes="(min-width: 720px) 720px"/></figure><figure><img src="https://blog.tempus-ex.com/content/images/2021/07/05389.png" alt="" loading="lazy" width="2000" height="838" srcset="https://blog.tempus-ex.com/content/images/size/w600/2021/07/05389.png 600w, https://blog.tempus-ex.com/content/images/size/w1000/2021/07/05389.png 1000w, https://blog.tempus-ex.com/content/images/size/w1600/2021/07/05389.png 1600w, https://blog.tempus-ex.com/content/images/2021/07/05389.png 2048w" sizes="(min-width: 720px) 720px"/></figure><p>Pretty similar right?</p><p>By referencing data in past frames, video codecs can use inter-frame prediction techniques such as motion estimation in order to more accurately predict a pixel&#39;s value.</p><h2 id="coding-redundancy">Coding Redundancy</h2><p>Lastly, the way the data is serialized to bits is of utmost importance. Many codecs are designed such that values written to the bitstream are typically very small, making variants of <a href="https://en.wikipedia.org/wiki/Golomb_coding">Golomb coding</a> very popular.</p><p>Lossy codecs can also drop the less significant information to achieve compression goals. As a simple example, many codecs operate on <a href="https://en.wikipedia.org/wiki/YUV">YUV color</a>, where it is very common to <a href="https://en.wikipedia.org/wiki/Chroma_subsampling">subsample the chroma components</a> (the components that primarily determine the hue rather than the brightness of a pixel).</p><p>Codecs that utilize DCTs may simply drop coefficients until compression goals are reached.</p><p>Now that we know about the basic concepts, let&#39;s see how some of them work together to form a fully functional lossless codec.</p><p>This codec will be an &#34;intra codec&#34;. It will not attempt to eliminate temporal redundancies. It will operate on one frame at a time and only produce key-frames.</p><p>Furthermore, the codec will operate on each channel independently. So the input to our encoder will just be a single plane, defined like this:</p><pre><code>pub struct Plane&lt;T&gt; {
    pub data: T,
    pub width: usize,
    pub height: usize,
    pub sample_stride: usize,
    pub row_stride: usize,
}</code></pre><p>Our encoding and decoding processes will consist of two steps:</p><ol><li>Predict what the next pixel will be (Intra Prediction).</li><li>Code the prediction residual via <a href="https://unix4lyfe.org/rice-coding/">Rice coding</a> (a type of <a href="https://en.wikipedia.org/wiki/Golomb_coding">Golomb coding</a>).</li></ol><h2 id="intra-prediction">Intra Prediction</h2><p>We&#39;ll iterate through pixels in raster order and use the surrounding pixels for prediction. There is a relatively standard notation for the surrounding pixels, which looks like this:</p><figure><img src="https://blog.tempus-ex.com/content/images/2021/07/1920px-Pixel-prediction.svg-3.png" alt="" loading="lazy" width="240" height="234"/></figure><p>We will use the fixed prediction function that <a href="https://en.wikipedia.org/wiki/Lossless_JPEG#LOCO-I_algorithm">LOCO-I</a> uses:</p><figure><img src="https://blog.tempus-ex.com/content/images/2021/07/Screen-Shot-2021-07-03-at-3.18.22-AM.png" alt="" loading="lazy" width="600" height="142" srcset="https://blog.tempus-ex.com/content/images/2021/07/Screen-Shot-2021-07-03-at-3.18.22-AM.png 600w"/></figure><pre><code>pub fn fixed_prediction(a: u16, b: u16, c: u16) -&gt; i32 {
    let min_a_b = a.min(b);
    let max_a_b = a.max(b);
    if c &gt;= max_a_b {
        min_a_b as _
    } else if c &lt;= min_a_b {
        max_a_b as _
    } else {
        a as i32 + b as i32 - c as i32
    }
}
</code></pre><p>The prediction residual for each pixel is simply X minus the prediction. So if our predictions are any good, the prediction residuals will be very small numbers.</p><p>Let&#39;s see what they look like for this 4K frame from <a href="https://mango.blender.org">Tears of Steel</a>, obtained from the <a href="https://media.xiph.org">wonderful collection of test media at xiph.org</a>:</p><figure><img src="https://blog.tempus-ex.com/content/images/2021/07/tears_of_steel_12130.jpg" alt="" loading="lazy" width="2000" height="837" srcset="https://blog.tempus-ex.com/content/images/size/w600/2021/07/tears_of_steel_12130.jpg 600w, https://blog.tempus-ex.com/content/images/size/w1000/2021/07/tears_of_steel_12130.jpg 1000w, https://blog.tempus-ex.com/content/images/size/w1600/2021/07/tears_of_steel_12130.jpg 1600w, https://blog.tempus-ex.com/content/images/size/w2400/2021/07/tears_of_steel_12130.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><p>If we visualize the cube root of the prediction residuals, they look like this:</p><figure><img src="https://blog.tempus-ex.com/content/images/2021/07/error-2.jpg" alt="" loading="lazy" width="2000" height="837" srcset="https://blog.tempus-ex.com/content/images/size/w600/2021/07/error-2.jpg 600w, https://blog.tempus-ex.com/content/images/size/w1000/2021/07/error-2.jpg 1000w, https://blog.tempus-ex.com/content/images/size/w1600/2021/07/error-2.jpg 1600w, https://blog.tempus-ex.com/content/images/size/w2400/2021/07/error-2.jpg 2400w" sizes="(min-width: 720px) 720px"/><figcaption>The cube root of the prediction residual magnitudes.</figcaption></figure><p>The image is pretty dark. In fact, if you visualize the raw prediction residuals, the image looks almost completely black. This is perfect because we can code the small prediction residuals in much less space than the raw pixel values.</p><h2 id="coding-the-prediction-residual">Coding the Prediction Residual</h2><p>To ensure that small numbers take up minimal space, we&#39;ll use <a href="https://unix4lyfe.org/rice-coding/">Rice coding</a>. A simple Rust implementation looks like this:</p><pre><code>pub fn encode_value&lt;T: Write&gt;(k: u32, x: i32, dest: &amp;mut BitstreamWriter&lt;T&gt;) -&gt; Result&lt;()&gt; {
    let x = ((x &gt;&gt; 30) ^ (2 * x)) as u32;
    let high_bits = x &gt;&gt; k;
    dest.write_bits(1, (high_bits + 1) as _)?;
    dest.write_bits((x &amp; ((1 &lt;&lt; k) - 1)) as _, k as _)?;
    Ok(())
}</code></pre><p>An important aspect of Rice coding is that it has two inputs: a parameter <em>k</em> and the number to be encoded. A small parameter <em>k</em> makes small numbers require less space and big numbers require more space. A large parameter <em>k</em> makes small numbers require more space and big numbers require less space. We&#39;re going to want a small <em>k</em> when we&#39;re confident that our prediction is accurate and a larger <em>k</em> when we&#39;re not so confident. This parameter has to be known by the decoder, so it can&#39;t rely on knowing the true value of the pixel being encoded – it can only depend on the values of the previous pixels.</p><pre><code>pub fn k(a: u16, b: u16, c: u16, d: u16) -&gt; u32 {
    let activity_level =
        (d as i32 - b as i32).abs() + (b as i32 - c as i32).abs() + (c as i32 - a as i32).abs();
    let mut k = 0;
    while (3 &lt;&lt; k) &lt; activity_level {
        k += 1;
    }
    k
}
</code></pre><p>In this function, we make <em>k</em> small when the surrounding pixels are similar to each other and large when there&#39;s a lot of &#34;activity&#34;.</p><h2 id="all-together">All Together</h2><p>All that&#39;s left is to scan through the pixels and use the above functions to write out the bitstream:</p><pre><code>fn encode&lt;T: AsRef&lt;[u16]&gt;, W: Write&gt;(plane: &amp;Plane&lt;T&gt;, dest: W) -&gt; Result&lt;()&gt; {
    let mut bitstream = BitstreamWriter::new(dest);
    let data = plane.data.as_ref();

    let mut b = 0;
    for row in 0..plane.height {
        let mut a = 0;
        let mut c = 0;
        for col in 0..plane.width {
            let x = data[row * plane.row_stride + col * plane.sample_stride];
            let d = if row &gt; 0 &amp;&amp; col + 1 &lt; plane.width {
                data[(row - 1) * plane.row_stride + (col + 1) * plane.sample_stride]
            } else {
                0
            };

            let prediction = fixed_prediction(a, b, c);
            let prediction_residual = x as i32 - prediction;

            encode_value(k(a, b, c, d), prediction_residual, &amp;mut bitstream)?;

            c = b;
            b = d;
            a = x;
        }
        b = data[row * plane.row_stride];
    }

    bitstream.flush()
}</code></pre><p>Easy! The decode function just does the inverse. See the <a href="https://github.com/tempus-ex/hello-video-codec">GitHub repository</a> for runnable code, including the decode function.</p><h2 id="comparisons">Comparisons</h2><p>This codec is so simple it can&#39;t possibly be any good, right? Let&#39;s find out!</p><p>We&#39;ll test on the above 4K frame from Tears of Steel, which uses 16-bit RGB color, requiring 42.1MB of space if uncompressed.</p><p>If we compress it using our codec, we get it down to 25.5MB. Generally 2:1 is a pretty typical ratio for lossless compression so this isn&#39;t bad at all.</p><p>In fact, if we losslessly convert it to a PNG (which is based on <a href="https://en.wikipedia.org/wiki/Deflate">DEFLATE</a>), even after <a href="https://pmt.sourceforge.io/pngcrush/">pngcrush</a>ing it to death, it only compresses to 31.5 MB. For this image, our codec outperforms PNG!</p><p>And lastly, if we losslessly convert it to JPEG 2000 (which is based on <a href="https://en.wikipedia.org/wiki/Discrete_wavelet_transform">Discrete Wavelet Transforms</a>), it compresses to 23.1MB. So for this image, our &#34;hello world&#34; codec is already pretty close to JPEG 2000!</p><p>Our codec already has pretty reasonable compression, but it also has one more thing going for it: It&#39;s insanely low complexity, meaning it&#39;s incredibly fast!</p><p>Now that we have a working codec, what can we do to improve it?</p><ul><li><strong>Coding Optimizations</strong> – The naive Rice coding above has a flaw: When we&#39;re confident in our predictions, but end up being completely wrong, we end up writing values using an obscene number of bits. With a simple trick, we could put an upper bound on the number of bits used for each value. It&#39;s also possible to further constrain the range of the values being written using modulo operations.</li><li><strong>Context Modeling</strong> – As the encoder makes predictions, it&#39;s possible to have it learn from its mistakes and apply corrections to later predictions.</li><li><strong>Prediction Residual Transforms</strong> – The prediction residuals themselves can be compressed using other techniques such as DCTs.</li><li><strong>Machine Learning?</strong> – There are many groups investigating the use of machine learning as a way to improve efficiency, e.g. with more accurate predictions. ML-based codecs are still far from reaching the mainstream, but early results such as those by <a href="https://www.wave.one">WaveOne</a> are promising.</li></ul><p>If you like working on this sort of thing, come <a href="https://tempus-ex.com/careers">join us at Tempus Ex</a> and get paid to do things like this.</p></div></div>
  </body>
</html>
