<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexanderell.is/posts/websockets-from-scratch/">Original</a>
    <h1>Writing a toy WebSocket server from scratch</h1>
    
    <div id="readability-page-1" class="page"><section id="wrapper">
            <article>
                <header>
                    
                    <h2>
                        ...so you can appreciate the libraries that do it for you
                    </h2>
                    <h2>
                    Aug 28, 2022
                    · 4153 words
                    · 20 minutes read
                      <span>
                            
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <p>WebSocket (WS) connections are pretty neat. I’ve gotten to play around with them
before, both for personal and professional projects, but my view has mostly been
at a high level and concerned mainly with the things that I can build on top of
them. I haven’t spent much time digging through the protocol.</p>
<p>I thought it would be pretty interesting to build a toy WS server from scratch.
Like many other projects, I find building a toy system to be such a good way to
learn more, and I’ll be talking about this toy WS server (and some of those
things I learned) in the rest of the post.</p>

<p>The main idea behind the WebSocket protocol is bi-directional communication.
Rather than the usual request/response lifecycle, with a client asking a server
for resources, WebSockets allow for messages to be sent in either direction.
Think of a chat application, where the client should be notified by the server
that there’s a new message for them. You could have the client long poll,
continuously asking the server if there’s anything new, but with a WebSocket
connection, the server can independently send those new messages to the client,
allowing the client to passively receive when it needs to.</p>

<p>WebSocket connections are initiated via a regular HTTP request from the client
that indicates it would like to switch, or upgrade, to talking via a WebSocket
connection. It’s <em>kind of</em> like sending someone a Slack message asking if they
want to hop on a quick video call — it’s still communicating over the computer,
and you’re using one method to initiate the next.</p>
<p>The steps to the flow are the following:</p>
<ol>
<li>Client sends an HTTP request to the server indicating it would like to switch
to WS</li>
<li>Server responds saying it’s OK to switch to WS</li>
<li>Client and server can start sending WS frames back and forth</li>
</ol>
<!---
participant "Client" as C
participant "Server" as S

C->S: HTTP: "I would like to talk WebSocket with you!"

S->C: HTTP: "WebSocket sounds good to me!"

C->S: WebSocket: "data"

S->C: WebSocket: "some other data"

S->C: WebSocket: "some other data initiated by the server"
-->







<!---
participant "Client" as C
participant "Server" as S

C->S: GET /websocket HTTP/1.1\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: key

note over S: Hash key with magic string and encode.\nMaybe decide on extension/protocol

S->C: HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: modified-key

note over C: Start sending WS frames

C->S: WebSocket frames as binary

S->C: WebSocket frames as binary

S->C: WebSocket frames as binary
-->































































                </section>
            </article>

            

            

            

            

        </section></div>
  </body>
</html>
