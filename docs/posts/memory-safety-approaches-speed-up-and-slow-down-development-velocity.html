<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/when-to-use-memory-safe-part-2">Original</a>
    <h1>Memory Safety Approaches Speed Up and Slow Down Development Velocity</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<section>
<h2 id="borrow-checking-and-beyond">
 Borrow Checking and Beyond</h2>
<p>
A lot of languages are working on borrow checking blends that are better for development velocity.
</p>

</section>
<section>
<p>
Some languages are using it under the hood:
</p>
<ul>
<li>
<a href="https://aardappel.github.io/lobster/memory_management.html">Lobster</a> is using borrowing and other static analysis techniques under the hood to eliminate a lot of reference counting overhead.
</li>
<li>
<a href="https://github.com/Kindelia/Kind">Kind</a> is using a blend of borrowing and cloning to fuel a purely functional language.
</li>
</ul>

</section>
<section>
<p>
<a href="https://vale.dev/">Vale</a> is building something similar to borrow checking but at the <a href="https://verdagon.dev/blog/zero-cost-memory-safety-regions-overview">regions</a> level, to largely eliminate memory safety overhead without introducing aliasing restrictions. Its opt-in nature means the user can use it where it makes sense and doesn&#39;t hinder development velocity.
</p>

</section>
<section>
<p>
<a href="https://github.com/microsoft/verona">Verona</a> and <a href="http://forty2.is/">Forty2</a> are experimenting with mixing regions and garbage collection.
</p>

</section>
<section>
<p>
Some languages are also putting borrow checkers on top of simpler and more flexible foundations:
</p>
<ul>
<li>
<a href="https://austral-lang.org/">Austral</a> is building one on top of <a href="https://austral-lang.org/linear-types">linear types</a>.
</li>
<li>
<a href="https://www.val-lang.dev/">Val</a> is working on one built on top of <a href="https://www.jot.fm/issues/issue_2022_02/article2.pdf">Mutable Value Semantics</a>.
</li>
</ul>

</section>
<section>
<p>
<a href="https://cone.jondgoodwin.com/">Cone</a> is particularly interesting because it builds a borrow checker on top of any user-specified memory management strategy.
</p>

</section>
<section>
<h2 id="garbage-collection">
 Garbage Collection</h2>

</section>
<section>
<p>
<b>Garbage collection is probably the best approach for developer velocity.</b> It completely decouples your goals from the constraints of memory management. You are free to solve your problem without tracking extra requirements, such as C++&#39;s single ownership or Rust&#39;s borrow checking.
</p>

</section>
<section>
<p>
This is a good thing, because most of your code doesn&#39;t need to care about memory management. In most programs, profiling shows only a small portion of code that&#39;s performance sensitive, requiring more precise control of memory. <a href="#note23" data-noteid="23">23</a>
</p>

</section>
<section>
<p>
I particularly liked this quote from the Garbage Collection Handbook:
</p>
<p>
Above all, memory management is a software engineering issue. Well-designed programs are built from components [...] that are highly cohesive and loosely coupled. [...] modules should not have to know the rules of the memory management game played by other modules. [...] GC uncouples the problem of memory management from interfaces.
</p>

</section>
<section>
<p>
In garbage collection, we don&#39;t have to satisfy the move-to-move constraint, or borrow-to-borrow constraint. We dont have to worry about matching pointers versus values. There&#39;s just one kind of reference, rather than Rust&#39;s 5 or C++&#39;s 7. <a href="#note24" data-noteid="24">24</a>
</p>

</section>
<section>
<p>
GC also doesn&#39;t cause any refactoring to satisfy single ownership (like C++&#39;s <span>unique_ptr</span>) or mutability requirements (like in Rust), because those concepts never existed to begin with. <a href="#note25" data-noteid="25">25</a>
</p>

</section>
<section>
<h2 id="gcd-code-can-be-more-correct">
 GC&#39;d code can be more correct</h2>

</section>
<section>
<p>
There are certain errors that arise in borrow checked and MMM languages, which don&#39;t happen in GC languages.
</p>

</section>
<section>
<p>
Often, instead of holding a reference to an object like in a GC&#39;d language, the borrow checker will force us to hold a key into a central collection, such as an ID into a hash map. If we try to &#34;dereference&#34; <a href="#note26" data-noteid="26">26</a> the ID of an object that no longer exists, we often get a run-time error (a <span>None</span> or <span>Err</span> usually) that we have to handle or propagate.
</p>

</section>
<section>
<p>
<a href="https://www.ponylang.io/">Pony</a> is a great example of how a garbage collected language can reach further towards correctness than other languages. Pony is one of the only languages that <a href="https://ponylang.zulipchat.com/#narrow/stream/189985-beginner-help/topic/Evan.20asks.20a.20question/near/279137078">literally cannot cause a run-time error</a>. Like Erlang, it is incredibly resilient. <a href="#note27" data-noteid="27">27</a>
</p>

</section>
<section>
<p>
Garbage collection can also be better with privacy, since objects are never accidentally reused or mixed up with each other. For example, the borrow checker can <a href="https://news.ycombinator.com/item?id=32240161">turn memory safety problems into privacy problems</a> if one&#39;s not careful.
</p>

</section>
<section>
<h2 id="gc-can-be-slow-in-specific-domains">
 GC can be slow in specific domains</h2>
<p>
If one has unusually constrained latency requirements, such as in high frequency trading or a real-time first-person shooter game, it can take quite some time to refactor and tune the program to not have unwelcome latency spikes.
</p>

</section>
<section>
<p>
For example, to avoid the Java garbage collector firing in a specific scope, one has to completely avoid the <span>new</span> keyword in that scope, and avoid calling any functions that might sneakily use <span>new</span>. Coding without <span>new</span> in Java is a particularly arcane challenge.
</p>

</section>
<section>
<p>
It&#39;s a little easier in C#, where we can use the <span>struct</span> keyword to make a class without any heap allocation. High-performance Unity games sometimes use this style, but it&#39;s still rather difficult.
</p>

</section>
<section>
<h2 id="garbage-collections-future">
 Garbage Collection&#39;s Future</h2>
<p>
Garbage collection is more than fast enough for most situations. And even for those situations where it&#39;s latency spikes are too burdensome, there are solutions on the horizon.
</p>

</section>
<section>
<p>
<a href="https://cone.jondgoodwin.com/">Cone</a> and <a href="https://github.com/microsoft/verona">Verona</a> will allow us to explicitly separate GC regions from each other, such that we can create and destroy a temporary short-lived region before its first collection even needs to happen. By using regions wisely, one can probably avoid the vast majority of collections. <a href="#note28" data-noteid="28">28</a>
</p>

</section>
<section>
<p>
Cone aims to take that even further by blending in a borrow checker, plus allowing more allocation strategies such as arenas, reference counting, or even custom ones from the users themselves.
</p>

</section>
<section>
<p>
With these advances, we might be able to get GC&#39;s development velocity advantages without the usual performance drawbacks.
</p>

</section>
<section>
<h2 id="reference-counting">
 Reference Counting</h2>

</section>
<section>
<p>
Reference counting, like in Swift, generally has the benefits that garbage collection does.
</p>

</section>
<section>
<p>
It does have one drawback: any cycle of references pointing at each other could cause a memory leak, wasting the available memory. This can be largely mitigated with good tooling that detects these cycles in development.
</p>

</section>
<section>
<p>
However, reference counting has three nice benefits: weak references, deterministic destruction, and the ability to make constraint references.
</p>

</section>
<section>
<p>
A <b>weak reference</b> is a mechanism for determining if the pointed-at object is still alive. This can be useful for a program&#39;s logic. For example, a Rocket might check if the target Spaceship has already been destroyed, to know whether it should safely fall into the planet&#39;s ocean.
</p>

</section>
<section>
<p>
Reference-counted objects are <b>destroyed deterministically</b>, which helps us have finer control over our program&#39;s performance.
</p>

</section>
<section>
<p>
One can also specify where they expect a reference-counted object to be destroyed, simply by asserting that they have the last reference (in other words, asserting the reference count is 1 at the end of the scope). I call this a <b>constraint reference</b> <a href="#note29" data-noteid="29">29</a> and it can help us detect our program&#39;s logic bugs in a way that no other paradigm can.
</p>

</section>
<section>
<h2 id="conclusions">
 Conclusions</h2>
<p>
MMM, borrow checking, GC, and RC each have their strengths and weaknesses. However, in the dimension of development velocity, my general conclusions would be:
</p>
<ul>
<li>
Garbage collection is often the best, since it decouples memory concerns from the actual problem at hand.
</li>
<li>
Reference counting is almost as good as garbage collection, and possibly even better if one uses its specific unique abilities.
</li>
<li>
MMM can be pretty good, as long as one uses proper architectures and tools to detect memory problems.
</li>
<li>
Borrow checking is almost as good as the others, if we augment it with Rust&#39;s other aspects like <span>RefCell</span>.
</li>
</ul>

</section>
<section>
<p>
But that&#39;s <i>too</i> general! Here&#39;s some rough guidelines to help with more specific situations:
</p>
<ul>
<li>
When making a game, default to something GC or RC, like Swift or C#. They offer great development velocity, plus value types (<span>struct</span>) for the more performance-sensitive areas. If one need even more performance, then:
</li>
<ul>
<li>
If working on a single player game, an MMM language with proper architecture and memory safety mitigations is a stellar option.
</li>
<li>
If working on a multiplayer game that has particular security risks, then Rust is a good option.
</li>
</ul>
<li>
When making a web server, default to a memory-safe language with RC or GC (such as C#), and bonus points if it has good concurrency support like Pony or Go.
</li>
<ul>
<li>
If working on something extremely latency-sensitive, Rust could be better. MMM isn&#39;t really advisable for something exposed to the network.
</li>
</ul>
<li>
When making a mobile app, stick to Swift, Kotlin, or Typescript. GC is particularly good here because its pauses can happen in between user actions.
</li>
<li>
If working on something that needs high reliability and correctness, look into something like Pony. It&#39;s run-time is guaranteed to never cause a run-time error that&#39;s not explicitly created by the user.
</li>
</ul>

</section>
<section>
<p>
There are also a lot of other languages improving, blending, and even creating new memory safety paradigms.
</p>

</section>
<section>
<p>
Of course, one should consider all this in context. Developer velocity is one of the most important factors in language choice, but not the only factor:
</p>
<ul>
<li>
An open-source project might want a language that encourages simplicity more, for a healthier community of contributors.
</li>
<li>
A real-time first-person shooter game would still want an approach with more predictable performance, even if it takes longer to code.
</li>
<li>
A safety critical application would still want an approach that encourages more correctness, even at the cost of developer velocity.
</li>
</ul>

</section>
<section>
<p>
I hope this post has given you a broader perspective on how various memory safety approaches affect development velocity!
</p>

</section>
<section>
<p>
If you&#39;re interested in this kind of thing, then check out <a href="https://verdagon.dev/blog/when-to-use-memory-safe-part-1">Part 1</a> which talks about memory safety in unsafe languages, and keep an eye out for the next parts on our <a href="https://verdagon.dev/rss.xml">RSS feed</a>, <a href="https://twitter.com/vale_pl">twitter</a>, <a href="https://discord.gg/SNB8yGH">discord server</a>, or <a href="https://reddit.com/r/vale">subreddit</a>!
</p>

</section>
<section>
<p>
If you found this interesting or entertaining, please consider sponsoring me:
</p>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor me on GitHub!
  </a>
</center>

<p>
With your help, I can write this kind of nonsense more often!
</p>

</section>
<section>
<p>
Cheers,
</p>
<p>
- Evan Ovadia
</p>


</section>

      </div></div>
  </body>
</html>
