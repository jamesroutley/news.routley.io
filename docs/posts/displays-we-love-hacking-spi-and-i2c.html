<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/">Original</a>
    <h1>Displays We Love Hacking: SPI and I2C</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>I’ve talked about HD44780 displays before – they’ve been a mainstay of microcontroller projects for literal decades. In the modern hobbyist world, there’s an elephant in the room – the sheer variety of I2C and SPI displays you can buy. They’re all so different, some are LCD and some are OLED, some have a touchscreen layer and some don’t, some come on breakouts and some are a bare panel. No matter which one you pick, there are things you deserve to know.</p>
<p>These displays are exceptionally microcontroller-friendly, they require hardly any GPIOs, or none extra if you already use I2C. They’re also unbelievably cheap, and so tiny that you can comfortably add one even if you’re hurting for space. Sure, they require more RAM and a more sophisticated software library than HD44780, but with modern microcontrollers, this is no problem at all. As a result, you will see them in almost every project under the sun.</p>
<p>What do you need for those? What are the requirements to operate one? What kind of tricks can you use with them? Let’s go through the main aspects.</p>

<h2>The Basics</h2>
<p><img decoding="async" data-attachment-id="650902" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_6/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg" data-orig-size="950,500" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_displays_i2cspi_6" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg?w=800" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg?w=800" alt="" width="800" height="421" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg 950w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg?resize=250,132 250w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg?resize=400,211 400w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_6.jpg?resize=800,421 800w" sizes="(max-width: 800px) 100vw, 800px"/>These displays are all fundamentally the same in how you create the data to be displayed. There’s no interface to show text strings anymore like there is with HD44780 displays – you take control of pixels, monochrome or color, and you have to send them to the display from your microcontroller. This means you have to have enough RAM to represent all those pixels, or generate them on the fly naturally, which puts a cap on the kinds of MCUs you can use.</p>
<p>It’s possible to send partial updates to such a display, so that you can create UI by sending different chunks of data to different regions of the display. For instance, I’ve once built an UI that solely did partial updates for a 320 x 480 color display driven by an ESP32, in a project where RAM was already at a premium. To help with such tasks, many displays allow you to read pixel data out of them. However, it will require more intricate code, so a typical library allocates a full screen’s worth of space for the display and calls it a day.</p>
<p>There are two interfaces typically used for these displays – I2C and SPI. I2C is easier and is likely already available in your project, but it puts a cap on your data transfer speed. This means that you will hardly ever see a color display with an I2C interface – because, as a rule, you need to send 16 times more data to update a color display as opposed to a monochrome one, for the same amount of pixels. You can push SPI faster – whereas I2C typically goes either 100 kHz or 400 kHz, rarely 1 MHz, you can typically push data into an SPI display at a few MHz clock rate, often even 10 MHz.</p>
<figure id="attachment_650903" aria-describedby="caption-attachment-650903"><img decoding="async" data-attachment-id="650903" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_7/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg" data-orig-size="1000,600" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;3.2&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;Canon PowerShot G12&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1439999675&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;10.775&#34;,&#34;iso&#34;:&#34;400&#34;,&#34;shutter_speed&#34;:&#34;0.008&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="hadimg_displays_i2cspi_7" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg?w=800" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg?w=400" alt="" width="400" height="240" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg 1000w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg?resize=250,150 250w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg?resize=400,240 400w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_7.jpg?resize=800,480 800w" sizes="(max-width: 400px) 100vw, 400px"/><figcaption id="caption-attachment-650903">This SPI display gives you a 240×320 color pixel area to draw anything on. <a href="https://commons.wikimedia.org/wiki/File:Arduino_2,2%22_TFT_display_(20679950896).jpg" target="_blank">By [AaltoFablab], CC 2.0</a></figcaption></figure><p>On the other hand, I2C is easier to wire up. If your SPI wiring or configuration is incorrect, an SPI display will not display a picture and just leave you hanging. If you can detect an I2C display on the bus, it can accept your data – SPI displays have no such detection mechanism, at least, not as far as I know, and definitely not for the vast majority of small displays that don’t even expose the MISO pin.</p>
<p>If you’ve miswired an SPI display, you will get no output and no idea on what’s going on, until you re-inspect your wiring and code, thoroughly look the problem up online, or plug a logic analyzer in. It’s not like miswiring SPI displays is all that easy, but it’s not uncommon when doing bringup on unfamiliar displays, and it can happen to anyone. Also, the extra SPI pins require extra GPIOs, and it’s not uncommon that you can’t share the SPI bus with other displays unless you add a 74×125 gate to make sure that your SPI display is not interfering with other devices on the bus.</p>
<p>These factors are not a problem as such, they’re merely things I describe so that you know which display to pick in which situation. If you’re starting out in electronics and you’re fine with monochrome output, pick up an I2C OLED, they’re numerous and software support is omnipresent. If you want high speed updates or color output, you’ll have to work with an SPI display. By the way, displays like SSD1306 and SH1106 OLEDs support both I2C and SPI – it depends on how the breakout is wired up; TFT displays only support SPI as a rule. Picked one of the two, and found the GPIOs needed? Let’s talk software.</p>
<h2>A Little Code</h2>
<figure id="attachment_650900" aria-describedby="caption-attachment-650900"><img loading="lazy" decoding="async" data-attachment-id="650900" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_4/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg" data-orig-size="1900,1370" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_displays_i2cspi_4" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg?w=800" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg?w=400" alt="" width="400" height="288" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg 1900w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg?resize=250,180 250w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg?resize=400,288 400w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg?resize=800,577 800w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_4.jpg?resize=1536,1108 1536w" sizes="(max-width: 400px) 100vw, 400px"/><figcaption id="caption-attachment-650900">Even an ATMega328P can work with such a display – though, sometimes, barely. <a href="https://commons.wikimedia.org/wiki/File:MicroSD_card_connected_to_Arduino_nano_with_OLED_display.jpg" target="_blank">By [Turbospok] CC BY-SA 4.0</a></figcaption></figure><p>For most of the popular programming languages and platforms, there’s already a library to work with an average screen you can buy. If you have a favourite language or platform you’d like to use, see if there’s a pre-written library for it that works with your specific screen, and purchase accordingly. To look the library up, all you need to know is the display controller name and the display resolution. If there isn’t a library yet, you can one by modifying one of the existing screen libraries for your screen’s parameters. Of course, that might not be how you’ve planned to spend your evening. But what if you have to? What if you got yourself a display and it doesn’t work with existing libraries?</p>
<p>If you want to know how a system works, it’s helpful to see how it breaks – so let’s describe possible (but rare) software incompatibilities and see where they come from. I’ll discuss wiring problems in a later section, for now, let’s assume you have a working link with the display and all GPIOs are in order. First thing to look into, then, is the controller IC type. Every LCD or OLED screen has an IC bonded to the panel – it’s the square pretty piece of silicon, that is often covered with a black sticker to protect the silicon from stray photons and general damage. There’s different families and models of these ICs, and they’re a defining feature for a typical screen – when picking a library, it’s important to know which screen controller it’s for.</p>
<p>Different controllers might require different SPI modes, control pins or clock speeds. However, most often, what’s different is the ‘language’ that the controller uses – its registers and their addresses, the values you need to write into these addresses, and the way it accepts screen data. If you port a library from one controller to another, you might need to change the way that the library speaks to the controller in general, learning it from a working library for your controller in a different language. If controllers are similar, say, ST7789 vs ST7789V, they’ll often speak the same fundamental language, and you might only need to change a few register values in the initialization sequence.</p>
<p><img loading="lazy" decoding="async" data-attachment-id="650899" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_3/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png" data-orig-size="793,898" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_displays_i2cspi_3" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png?w=353" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png?w=552" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png?w=353" alt="" width="353" height="400" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png 793w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png?resize=221,250 221w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png?resize=353,400 353w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_3.png?resize=552,625 552w" sizes="(max-width: 353px) 100vw, 353px"/>Initialization sequence is a sequence of register writes that you have to send to your display before you can show any data on it, and it is often the key for fixing display problems. For instance, if you have a certain controller display and a library only supports that controller with a different resolution panel connected to it, what you’d need to change is the bytes in initialization sequence responsible for controller-to-panel wiring mapping. Sometimes the resolution is the same, but the pixels are wired slightly differently, and that also fixable in the initialization sequence.</p>
<p>The initialization sequence is also where you can rotate or flip a display ‘in hardware’, in case your project needs the display to be in a certain non-default orientation – find a value to change, and the display will map the pixels in a different way. A single controller IC could work with a myriad, which is why, even if you find a datasheet for the display controller IC, it might not help you when you need to make your actual display work, because the controller datasheet might not have the exact initialization parameters you need to know.</p>
<p>If you can’t find the proper initialization sequence or it’s hard to introspect the code, you can always sniff it with a logic analyzer! It can also help you figure out things like different commands to write pixels to the display – sending data to the display also has to be preceded by a certain command sequence, which has you give the display the address of the place you want to push the pixels into. Those commands are somewhat standardized by MIPI Alliance, so there’s only a few common ones and they don’t tend to change for the same display manufacturer, but it’s a good thing to keep in mind depending on how much you need to adapt your library.</p>
<p>This is about what you need to know when it comes to display software. Chances are, you’ll never have any problems on this front, but now you know where to look if you do. Let’s descend to more earthly matters – wiring.</p>
<h2>A Little Wiring</h2>
<p>The overwhelming majority of SPI and I2C displays expect 3.3 V VCC. Make sure to not reverse GND and VCC – if you do, your display’s controller IC will die. Also, many display breakouts include a 3.3 V linear regulator on them, so that people can power them from 5 V too – it’s not exactly needed, but it can be nice to have. Other than that, for LCD panels, you will need to manage the backlight. You can typically hardwire it to VCC and GND – a resistor shouldn’t be needed, as it’s usually included on the breakout PCB. If you want manual backlight control, an N-FET or an NPN transistor will make quick work of that if it’s low-side (GND-side) control, P-FET or PNP for high-side (VCC-side) control, and, of course, you can PWM it!</p>
<p><img loading="lazy" decoding="async" data-attachment-id="650895" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_1/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png" data-orig-size="1086,1027" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_displays_i2cspi_1" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png?w=661" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png?w=250" alt="" width="250" height="236" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png 1086w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png?resize=250,236 250w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png?resize=400,378 400w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_1.png?resize=661,625 661w" sizes="(max-width: 250px) 100vw, 250px"/>SPI and I2C displays differ in their wiring. I2C displays rarely ever need anything other than SDA and SCL. Here’s one exception though, and that is the RST signal, something that both I2C and SPI displays tend to need. Everywhere I’ve seen it, it’s a non-negotiable signal – after the display gets powered up, you need to ground RST for a bit before you even dare to send data. If your display breakout has RST exposed and you ignore it, you’re setting yourself up for a bad time.</p>
<p>However, that doesn’t mean you need to waste a GPIO on a signal that only changes once! As a rule, a simple resistor-capacitor circuit is sufficient to toggle the display’s RST pin right after power-up, and many breakouts include this circuit by default, with an extra diode to make sure that even the quickest power dips still result in a display reset. The capacitor has to be in single-digit uF range, but that’s not much of a problem to source, it doesn’t have to have a super good temperature coefficient or high maximum voltage or anything. Here we go, that’s one more spare GPIO for your project use!</p>
<p>SPI displays also need CS, naturally. Some displays perma-ground CS and never expose it to the user, which takes the SPI bus hostage and is all-around annoying to work with. If you want to ground CS and not waste a GPIO on it, you always do it out of your own volition! Some displays won’t like a perma-grounded CS, as they use the CS signal for internal purposes and expect you to switch it as you send data, but, for instance, typical SH1106 OLEDs sure don’t seem to mind.</p>
<p><img loading="lazy" decoding="async" data-attachment-id="650894" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_2/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png" data-orig-size="854,428" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_displays_i2cspi_2" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png?w=800" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png?w=800" alt="" width="800" height="401" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png 854w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png?resize=250,125 250w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png?resize=400,200 400w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_2.png?resize=800,401 800w" sizes="(max-width: 800px) 100vw, 800px"/></p>
<p>Another signal that exclusively SPI displays need is D/C, also known as A0. This signal tells the display whether you’re currently sending data or commands to it – since displays operate in 8-bit mode and you have to use the whole 8 bits for your commands or data bytes, you need some sort of sideband to tell the display which one it’s receiving at any given moment. If you want to omit this pin, you can either send data to the display in 9-bit SPI mode instead of the default 8-bit mode, something that your MCU often won’t support, or do <a href="https://bitbanksoftware.blogspot.com/2023/11/3-wire-spi-explained.html" target="_blank">a witty workaround!</a> Oh, and for panels capable of both SPI and I2C mode, this signal might be used for the LSB of the I2C address when the panel is wired up for I2C mode, so that you can theoretically have two of the same displays on the same bus. If you need more than two of these displays, add more I2C buses, or use I2C address translators.</p>
<h2>A Little Hacking</h2>
<figure id="attachment_650907" aria-describedby="caption-attachment-650907"><img loading="lazy" decoding="async" data-attachment-id="650907" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_8/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg" data-orig-size="900,800" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;2.7&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;COOLPIX L25&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1358482448&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;4&#34;,&#34;iso&#34;:&#34;200&#34;,&#34;shutter_speed&#34;:&#34;0.1&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="hadimg_displays_i2cspi_8" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg?w=703" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg?w=400" alt="" width="400" height="356" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg 900w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg?resize=250,222 250w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg?resize=400,356 400w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_8.jpg?resize=703,625 703w" sizes="(max-width: 400px) 100vw, 400px"/><figcaption id="caption-attachment-650907">If you’re developing your own board, make sure you’re using the right FFC pad pitch for the panel connector</figcaption></figure>
<p>Display breakout boards are amazing and they’re what you will use in the majority of case – you can use them easily on your custom boards too, just put a 4-pin header on the board and plug a display breakout into it. However, breakouts shall not constrain you. If you want to build a smaller device, you can always put the bare panel on your board – you need the FPC footprint and mechanical considerations for the bare panel, but that’s it. Make sure you really really have the correct pitch for the display FPC connector – lifting it from open-source KiCad projects is your best bet, and a datasheet for the panel (not the controller IC!) will help too. It’s really annoying to produce a board that – print the board out on paper if you must.</p>
<p>Many OLED displays want charge caps – find breakout schematics online and repeat them, and if you can’t find schematics, re-draw the breakout you have and measure the caps with a capacitance meter. Some LCD panels require an external boost circuit, especially color OLEDs and some small TFTs – there’s some open-source projects to learn from if you want to work with a panel that has such a requirement.</p>
<p>When you need to unglue a display panel from its breakout for whatever purposes, reverse-engineering or repair alike, mind you that it’s typically glued to the PCB with double-sided tape. Use a hairdryer to heat up the tape from the PCB side (not the screen glass side!) and then use a plastic spudger to lift it equally from all sides, a credit card could work wonders too. Be very, very careful and measured while applying force, don’t shatter the LCD/OLED glass, and don’t tear the FPC! If you’re working on one of the OLED screens that fold over a board, desoldering the FPC first might help – then you can rotate the panel, which should help free up the display from the tape a fair bit faster, just be careful gripping it. Isopropyl alcohol might be tempting to use, but beware – it might damage the polarizer layer on the panel, heat from a hairdryer is what I’ve found works best. A hot air gun at soldering temps is likely to cause the SMD parts on the other side of the breakout to shift by accident, but if you don’t have any to worry about, that could work in a pinch too!</p>
<p>A lot of the common OLED and LCD displays have Linux kernel drivers! With the right modprobe command or a DeviceTree snippet, you’ll be surprised to see the Linux boot logs and then a `tty` prompt appear on your tiny screen. You can’t quite send arbitrary commands or tweak the initialization sequence easily while using a Linux driver, but it’s all open-source, so there’s some ways around it.</p>
<p><img loading="lazy" decoding="async" data-attachment-id="650901" data-permalink="https://hackaday.com/2023/12/21/displays-we-love-hacking-spi-and-i2c/hadimg_displays_i2cspi_5/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_5.jpg" data-orig-size="800,600" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="hadimg_displays_i2cspi_5" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_5.jpg?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_5.jpg?w=800" src="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_5.jpg?w=250" alt="" width="250" height="188" srcset="https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_5.jpg 800w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_5.jpg?resize=250,188 250w, https://hackaday.com/wp-content/uploads/2023/10/hadimg_displays_i2cspi_5.jpg?resize=400,300 400w" sizes="(max-width: 250px) 100vw, 250px"/>That about sums up what you should know about the most common type of display you can encounter. With the basic things out of the way, you should be able to get to whatever goal you need this display for, instead of spending time debugging common problems. The displays themselves are fascinating, too – just a few months ago, on Hackaday Discord, we’ve been watching someone abuse the SSD1306 controller OLED screens to create dithering and ‘hardware-accelerated’ graphics! Whatever thing you might discover, now you’re a few steps closer.</p>
<p>Next time, let’s peek into the kingdom of parallel RGB screens. Whenever you want a screen with high resolution and decent refresh rate, or simply a screen wider than 3″, maybe you even want a touchscreen-enabled panel, parallel RGB is where it’s at.</p>
	            </div></div>
  </body>
</html>
