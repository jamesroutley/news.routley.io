<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/crdt-filesync/">Original</a>
    <h1>Local, first, forever</h1>
    
    
<p>So I was at the <a href="https://www.localfirstconf.com/">Local-First Conf</a> the other day, listening to <a href="https://www.youtube.com/watch?v=NMq0vncHJvU">Martin Kleppmann</a>, and this slide caught my attention:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/talk.webp"></figure>
<p>Specifically, this part:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/talk2.webp"></figure>
<p>But first, some context.</p>
<h1 id="what-is-local-first">What is local-first?</h1>
<p>For the long version, go to Ink &amp; Switch, who coined the term: <a href="https://www.inkandswitch.com/local-first/">www.inkandswitch.com/local-first/</a></p>
<p>Here’s my short version:</p>
<ul>
  <li>It’s software.</li>
  <li>That prefers keeping your data local.</li>
  <li>But it still goes to the internet occasionally to sync with other users, fetch data, back up, etc.</li>
</ul>
<p>If it doesn’t go to the internet at all, it’s just local software.</p>
<p>If it doesn’t work offline with data it already has, then it’s just normal cloud software. You all know the type — sorry, Dave, I can’t play the song I just downloaded because your internet disappeared for one second...</p>
<p>But somewhere in the middle — local-first. We love it because it’s good for the end user, you and me, not for the corporations that produce it.</p>
<h1 id="whats-the-problem-with-local-first">What’s the problem with local-first?</h1>
<p>The goal of local-first software is to get control back into the hands of the user, right? You own the data (literally, it’s on your device), yada-yada-yada. That part works great.</p>
<p>However, local-first software still has this online component. For example, personal local-first software still needs to sync between your own devices. And syncing doesn’t work without a server...</p>
<p>So here we have a problem: somebody writes local-first software. Everybody who bought it can use it until the heat death of the universe. They <em>own</em> it.</p>
<p>But if the company goes out of business, syncing will stop working. And companies go out of business all the time.</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/bonto.webp"></figure>
<p>What do we do?</p>
<h1 id="cue-dropbox">Cue Dropbox</h1>
<p>The solution is to use something widely available that will probably outlive our company. We need something popular, accessible to everyone,  has multiple implementations, and can serve as a sync server.</p>
<p>And what’s the most common end-user application of cloud sync?</p>
<p>Dropbox! Well, not necessarily Dropbox, but any cloud-based file-syncing solution. iCloud Drive, OneDrive, Google Drive, <a href="https://tonsky.me/blog/syncthing/">Syncthing</a>, etc.</p>
<p>It’s perfect — many people already have it. There are multiple implementations, so if Microsoft or Apple go out of business, people can always switch to alternatives. File syncing is a commodity.</p>
<p>But file syncing is a “dumb” protocol. You can’t “hook” into sync events, or update notifications, or conflict resolution. There isn’t much API; you just save files and they get synced. In case of conflict, best case, you get two files. Worst — you get only one :)</p>
<p>This simplicity has an upside and a downside. The upside is: if you can work with that, you would work everywhere. That’s the interoperability part from Martin’s talk.</p>
<p>The downside is: you can’t do much with it, and it probably won’t be optimal. But will it be enough?</p>
<h1 id="version-1-super-naive">Version 1: Super-naive</h1>
<p>Let’s just save our state in a file and let Dropbox sync it (in my case, I’m using Syncthing, but it’s the same idea. From now on, I’ll use “Dropbox” as a common noun).</p>
<p>Simple:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/naive.webp"></figure>
<p>But what happens if you change the state on two machines? Well, you get a conflict file:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/naive_conflict.webp"></figure>
<p>Normally, it would’ve been a problem. But it’s not if you are using CRDT!</p>
<blockquote>
  <p>CRDT is a collection of data types that all share a very nice property: they can always be merged. It’s not always the perfect merge, and not everything can be made into a CRDT, but IF you can put your data into a CRDT, you can be sure: all merges will go without conflicts.</p>
</blockquote>
<p>With CRDT, we can solve conflicts by opening both files, merging states, and saving back to <code>state.xml</code>. Simple!</p>
<p>Even in this form, Dropbox as a common sync layer works! There are some downsides, though:</p>
<ul>
  <li>conflicting file names are different between providers,</li>
  <li>some providers might not handle conflicts at all,</li>
  <li>it needs state-based CRDT.</li>
</ul>
<h1 id="version-2-a-file-per-client">Version 2: A file per client</h1>
<p>The only way to avoid conflicts is to always edit locally. So let’s give each client its own file!</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/file_per_client.webp"></figure>
<p>Now we just watch when files from other clients get changed and merge them with our own.</p>
<p>And because each file is only edited on one machine, Dropbox will not report any conflicts. Any conflicts inside the data will be resolved by us via CRDT magic.</p>
<h1 id="version-3-operations-based">Version 3: Operations-based</h1>
<p>What if your CRDT is operation-based? Meaning, it’s easier to send operations around, not the whole state?</p>
<p>You can always write operations into a separate append-only file. Again, each client only writes to its own, so no conflicts on the Dropbox level:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/ops.webp"></figure>
<p>Now, the operations log can grow quite long, and we can’t count on Dropbox to reliably and efficiently sync only parts of the file that were updated.</p>
<p>In that case, we split operations into chunks. Less work for Dropbox to sync and less for us to catch up:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/ops_batches.webp"></figure>
<p>You can, of course, save the position in the file to only apply operations you haven’t seen. Basic stuff.</p>
<p>Theoretically, you should be able to do operational transformations this way, too.</p>
<h1 id="demo">Demo</h1>
<p>A very simple proof-of-concept demo is at <a href="https://github.com/tonsky/crdt-filesync">github.com/tonsky/crdt-filesync</a>.</p>
<p>Here’s a video of it in action:</p>
<figure>
  <video autoplay="" muted="" loop="" preload="auto" playsinline="" controls="">
    <source src="https://tonsky.me/blog/crdt-filesync/demo.mp4" type="video/mp4">
  </video>
</figure>
<p>Under the hood, it uses Automerge for merging text edits. So it’s a proper CRDT, not just two files merging text diffs.</p>
<h1 id="conclusion">Conclusion</h1>
<p>If you set out to build a local-first application that users have complete control and ownership over, you need something to solve data sync.</p>
<p>Dropbox and other file-sync services, while very basic, offer enough to implement it in a simple but working way.</p>
<p>Sure, it won’t be as real-time as a custom solution, but it’s still better for casual syncs. Think Apple Photos: only your own photos, not real-time, but you know they will be everywhere by the end of the day. And that’s good enough!</p>
<p>Imagine if Obsidian Sync was just “put your files in the folder” and it would give you conflict-free sync? For free? Forever? Just bring your own cloud?</p>
<p>I’d say it sounds pretty good.</p>


  </body>
</html>
