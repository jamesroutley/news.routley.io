<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/crdt-filesync/">Original</a>
    <h1>Local First, Forever</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <p>So I was at the <a href="https://www.localfirstconf.com/" target="_blank">Local-First Conf</a> the other day, listening to <a href="https://www.youtube.com/watch?v=NMq0vncHJvU" target="_blank">Martin Kleppmann</a>, and this slide caught my attention:</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/talk.webp?t=1719240073" width="720" height="405"/>        </figure>
        <p>Specifically, this part:</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/talk2.webp?t=1719240073" width="720" height="550"/>        </figure>
        <p>But first, some context.</p>
        
        <p>For the long version, go to Ink &amp; Switch, who coined the term: <a href="https://www.inkandswitch.com/local-first/" target="_blank">www.inkandswitch.com/local-first/</a></p>
        <p>Here’s my short version:</p>
        <ul>
          <li>It’s software.</li>
          <li>That prefers keeping your data local.</li>
          <li>But it still goes to the internet occasionally to sync with other users, fetch data, back up, etc.</li>
        </ul>
        <p>If it doesn’t go to the internet at all, it’s just local software.</p>
        <p>If it doesn’t work offline with data it already has, then it’s just normal cloud software. You all know the type — sorry, Dave, I can’t play the song I just downloaded because your internet disappeared for one second...</p>
        <p>But somewhere in the middle — local-first. We love it because it’s good for the end user, you and me, not for the corporations that produce it.</p>
        
        <p>The goal of local-first software is to get control back into the hands of the user, right? You own the data (literally, it’s on your device), yada-yada-yada. That part works great.</p>
        <p>However, local-first software still has this online component. For example, personal local-first software still needs to sync between your own devices. And syncing doesn’t work without a server...</p>
        <p>So here we have a problem: somebody writes local-first software. Everybody who bought it can use it until the heat death of the universe. They <em>own</em> it.</p>
        <p>But if the company goes out of business, syncing will stop working. And companies go out of business all the time.</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/bonto.webp?t=1719240073" width="720" height="375"/>        </figure>
        <p>What do we do?</p>
        
        <p>The solution is to use something widely available that will probably outlive our company. We need something popular, accessible to everyone,  has multiple implementations, and can serve as a sync server.</p>
        <p>And what’s the most common end-user application of cloud sync?</p>
        <p>Dropbox! Well, not necessarily Dropbox, but any cloud-based file-syncing solution. iCloud Drive, OneDrive, Google Drive, <a href="https://tonsky.me/blog/syncthing/">Syncthing</a>, etc.</p>
        <p>It’s perfect — many people already have it. There are multiple implementations, so if Microsoft or Apple go out of business, people can always switch to alternatives. File syncing is a commodity.</p>
        <p>But file syncing is a “dumb” protocol. You can’t “hook” into sync events, or update notifications, or conflict resolution. There isn’t much API; you just save files and they get synced. In case of conflict, best case, you get two files. Worst — you get only one :)</p>
        <p>This simplicity has an upside and a downside. The upside is: if you can work with that, it would work everywhere. That’s the interoperability part from Martin’s talk.</p>
        <p>The downside is: you can’t do much with it, and it probably won’t be optimal. But will it be enough?</p>
        
        <p>Let’s just save our state in a file and let Dropbox sync it (in my case, I’m using Syncthing, but it’s the same idea. From now on, I’ll use “Dropbox” as a common noun).</p>
        <p>Simple:</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/naive.webp?t=1719240073" width="685" height="280"/>        </figure>
        <p>But what happens if you change the state on two machines? Well, you get a conflict file:</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/naive_conflict.webp?t=1719240073" width="685" height="280"/>        </figure>
        <p>Normally, it would’ve been a problem. But it’s not if you are using CRDT!</p>
        <blockquote>
          <p>CRDT is a collection of data types that all share a very nice property: they can always be merged. It’s not always the perfect merge, and not everything can be made into a CRDT, but IF you can put your data into a CRDT, you can be sure: all merges will go without conflicts.</p>
        </blockquote>
        <p>With CRDT, we can solve conflicts by opening both files, merging states, and saving back to <code>state.xml</code>. Simple!</p>
        <p>Even in this form, Dropbox as a common sync layer works! There are some downsides, though:</p>
        <ul>
          <li>conflicting file names are different between providers,</li>
          <li>some providers might not handle conflicts at all,</li>
          <li>it needs state-based CRDT.</li>
        </ul>
        
        <p>The only way to avoid conflicts is to always edit locally. So let’s give each client its own file!</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/file_per_client.webp?t=1719240073" width="685" height="280"/>        </figure>
        <p>Now we just watch when files from other clients get changed and merge them with our own.</p>
        <p>And because each file is only edited on one machine, Dropbox will not report any conflicts. Any conflicts inside the data will be resolved by us via CRDT magic.</p>
        
        <p>What if your CRDT is operation-based? Meaning, it’s easier to send operations around, not the whole state?</p>
        <p>You can always write operations into a separate append-only file. Again, each client only writes to its own, so no conflicts on the Dropbox level:</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/ops.webp?t=1719240073" width="685" height="280"/>        </figure>
        <p>Now, the operations log can grow quite long, and we can’t count on Dropbox to reliably and efficiently sync only parts of the file that were updated.</p>
        <p>In that case, we split operations into chunks. Less work for Dropbox to sync and less for us to catch up:</p>
        <figure>
<img src="https://tonsky.me/blog/crdt-filesync/ops_batches.webp?t=1719240073" width="685" height="280"/>        </figure>
        <p>You can, of course, save the position in the file to only apply operations you haven’t seen. Basic stuff.</p>
        <p>Theoretically, you should be able to do operational transformations this way, too.</p>
        
        <p>A very simple proof-of-concept demo is at <a href="https://github.com/tonsky/crdt-filesync" target="_blank">github.com/tonsky/crdt-filesync</a>.</p>
        <p>Here’s a video of it in action:</p>
        <figure>
          <video autoplay="" muted="" loop="" preload="auto" playsinline="" controls="" width="720" height="721">
            <source src="demo.mp4?t=1719240073" type="video/mp4"/>
          </video>
        </figure>
        <p>Under the hood, it uses Automerge for merging text edits. So it’s a proper CRDT, not just two files merging text diffs.</p>
        
        <p>If you set out to build a local-first application that users have complete control and ownership over, you need something to solve data sync.</p>
        <p>Dropbox and other file-sync services, while very basic, offer enough to implement it in a simple but working way.</p>
        <p>Sure, it won’t be as real-time as a custom solution, but it’s still better for casual syncs. Think Apple Photos: only your own photos, not real-time, but you know they will be everywhere by the end of the day. And that’s good enough!</p>
        <p>Imagine if Obsidian Sync was just “put your files in the folder” and it would give you conflict-free sync? For free? Forever? Just bring your own cloud?</p>
        <p>I’d say it sounds pretty good.</p>
        
      </article></div>
  </body>
</html>
