<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/stringchaos/">Original</a>
    <h1>String Chaos and Compiler Sleight-of-Hand</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-07-17T00:00:00-07:00">July 17, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>We need to talk about strings.</p>

<p>I’m working on porting my Python assembler to C, and I’m getting to the harder stuff. As I wrote about <a href="https://www.datadoodad.com/recurse%20center/Assembler-Part-2/">in my last post</a> I settled on parallel arrays to deal with lookups for various assembly commands. Now I need to start thinking about how to support symbols.</p>

<p>Symbols are a slightly different beast because, unlike the finite list of assembly commands, symbols can be arbitrary in number. That means I need some sort of symbols table that can grow every time the assembler discovers a new <strong>label</strong> (a line like <code>(JUMPHERE)</code>) or a <strong>symbol</strong> (a human-friendly name for an arbitrary space in RAM, like <code>@my_var</code>). As with the lookup tables from last time, the obvious choice is a hashmap, which can do inserts and lookups in constant time, but I’m leaving hashmaps for another day. So the way I see it I have two options:</p>
<ol>
  <li><strong>parallel arrays</strong> (again). These have the advantage of being easy to use but the disadvantage of being static in size, which means I either have to allocate enough space to safely handle what I determine to be a reasonable number of symbols (probably not a great idea, and also inefficient for small programs with few labels) or include functionality to reallocate larger arrays in the event that the symbols outgrow the array initially allocated for them (. . .nah)</li>
  <li>a <strong>linked list</strong>, with each node holding a key/value pair. Linked lists also have the advantage of being relatively easy to implement, and, like the parallel arrays solution, have linear time commplexity. However, unlike arrays, they’re dynamic, which means they need only take up as much space as the number of symbols we encounter – nothing more, nothing less.</li>
</ol>

<p>Linked list it is! My decision made, I turned towards implementation.</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>Node</span> <span>{</span>
    <span>char</span><span>*</span>        <span>key</span><span>;</span>
    <span>int</span>          <span>value</span><span>;</span>
    <span>struct</span> <span>Node</span><span>*</span> <span>next</span><span>;</span>
<span>}</span> <span>Node</span><span>;</span>

<span>Node</span><span>*</span> <span>create_node</span><span>(</span><span>char</span><span>*</span> <span>key</span><span>,</span> <span>int</span> <span>val</span><span>)</span>
<span>{</span>
    <span>Node</span><span>*</span> <span>node</span>   <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>Node</span><span>));</span>

    <span>node</span><span>-&gt;</span><span>key</span> <span>=</span> <span>key</span><span>;</span>
    <span>node</span><span>-&gt;</span><span>value</span>  <span>=</span> <span>val</span><span>;</span>
    <span>node</span><span>-&gt;</span><span>next</span>   <span>=</span> <span>NULL</span><span>;</span>

    <span>return</span> <span>node</span><span>;</span>
<span>}</span>

 <span>void</span> <span>insert_node</span><span>(</span><span>Node</span><span>*</span> <span>head</span><span>,</span> <span>Node</span><span>*</span> <span>new_node</span><span>)</span>
 <span>{</span>
     <span>while</span> <span>(</span><span>head</span><span>-&gt;</span><span>next</span> <span>!=</span> <span>NULL</span><span>)</span>
         <span>head</span> <span>=</span> <span>head</span><span>-&gt;</span><span>next</span><span>;</span>
 
     <span>head</span><span>-&gt;</span><span>next</span> <span>=</span> <span>new_node</span><span>;</span>
 <span>}</span>
</code></pre></div></div>

<p>So far, so good, right? *brushes dirt off hands*</p>

<p>Just need a little search function specific to this assembler: it’ll perform a linear search for a given <code>key</code> string and return the matching <code>value</code> if it finds it. If not, it’ll insert a new node into the list with that <code>key</code> and assign it a unique integer value (the arbitrary memory address that that symbol key will be associated with).</p>

<div><div><pre><code><span>int</span> <span>search</span><span>(</span><span>Node</span><span>*</span> <span>head</span><span>,</span> <span>char</span><span>*</span> <span>target</span><span>,</span> <span>int</span><span>*</span> <span>default_val</span><span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>Node</span><span>*</span> <span>cur</span> <span>=</span> <span>head</span><span>;</span> <span>cur</span> <span>!=</span> <span>NULL</span><span>;</span> <span>cur</span> <span>=</span> <span>cur</span><span>-&gt;</span><span>next</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span><span>cur</span><span>-&gt;</span><span>key</span> <span>==</span> <span>target</span><span>)</span>
            <span>return</span> <span>cur</span><span>-&gt;</span><span>value</span><span>;</span>
    <span>}</span>

    <span>insert_node</span><span>(</span><span>head</span><span>,</span> <span>create_node</span><span>(</span><span>target</span><span>,</span> <span>*</span><span>default_val</span><span>));</span>

    <span>return</span> <span>(</span><span>*</span><span>default_val</span><span>)</span><span>++</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s say, then, we have the following linked list <code>key/value</code> pairs (an abridged version of how the assmbler’s symbols table will be initialized):</p>

<div><div><pre><code>SP/0 -&gt; LCL/1 -&gt; ARG/2 -&gt; THIS/3 -&gt; THAT/4 -&gt; 
</code></pre></div></div>

<p>Now we can search for things:</p>

<div><div><pre><code><span>int</span> <span>default_val</span> <span>=</span> <span>16</span><span>;</span>   <span>// default value for symbol additions</span>
<span>int</span> <span>res</span><span>;</span>                <span>// search result</span>

<span>res</span> <span>=</span> <span>search</span><span>(</span><span>symbols</span><span>,</span> <span>&#34;ARG&#34;</span><span>,</span> <span>&amp;</span><span>default_val</span><span>);</span>     <span>// =&gt; 2</span>
<span>res</span> <span>=</span> <span>search</span><span>(</span><span>symbols</span><span>,</span> <span>&#34;my_var&#34;</span><span>,</span> <span>&amp;</span><span>default_val</span><span>);</span>  <span>// =&gt; 16</span>
<span>res</span> <span>=</span> <span>search</span><span>(</span><span>symbols</span><span>,</span> <span>&#34;x&#34;</span><span>,</span> <span>&amp;</span><span>default_val</span><span>);</span>       <span>// =&gt; 17</span>
<span>res</span> <span>=</span> <span>search</span><span>(</span><span>symbols</span><span>,</span> <span>&#34;THAT&#34;</span><span>,</span> <span>&amp;</span><span>default_val</span><span>);</span>    <span>// =&gt; 4</span>
</code></pre></div></div>

<p>And now the linked list looks like this:</p>

<div><div><pre><code>SP/0 -&gt; LCL/1 -&gt; ARG/2 -&gt; THIS/3 -&gt; THAT/4 -&gt; my_var/16 -&gt; x/17 -&gt;
</code></pre></div></div>

<p>It works! But it probably shouldn’t. Or, rather, it works because the compiler is doing a little legerdemain that obscures the reasons why this solution is not excellent.</p>



<figure>
<img src="https://www.datadoodad.com/assets/images/2023-07-17/chaos-reigns.gif" alt="chaos reigns" width="100%;"/>
<figcaption>I&#39;m pretty sure the compiler is the fox in this metaphor</figcaption>
</figure>

<p>The problem lies in my naive approach to comparing strings: <code>cur-&gt;key == target</code>. This is not doing what I think it’s doing, that is, comparing the string of characters to which each pointer is pointing. No, what it’s doing is comparing the <em>pointers</em>, full stop. Which, come to think of it, seems like it shouldn’t even work in the first place, since how could the string “ARG” that I’m passing into <code>search()</code> have the same address as the the node whose <code>key</code> is “ARG”? And yet, if we printed the addresses of <code>cur-&gt;key</code> and <code>target</code> from within the <code>search()</code> function, it turns out that they’re the same!</p>

<p>Here’s a more concise illustration of this unexpected behaviour:</p>

<div><div><pre><code><span>char</span> <span>*</span><span>symbol_1</span> <span>=</span> <span>&#34;my_var&#34;</span><span>;</span>
<span>char</span> <span>*</span><span>symbol_2</span> <span>=</span> <span>&#34;my_var&#34;</span><span>;</span>
<span>Node</span><span>*</span> <span>my_node</span> <span>=</span> <span>create_node</span><span>(</span><span>symbol_1</span><span>,</span> <span>10</span><span>);</span>

<span>if</span> <span>(</span><span>symbol_1</span> <span>==</span> <span>symbol_2</span><span>)</span>
    <span>printf</span><span>(</span><span>&#34;symbol_1 == symbol_2</span><span>\n</span><span>&#34;</span><span>);</span> <span>// this gets printed</span>
<span>else</span>
    <span>printf</span><span>(</span><span>&#34;symbol_1 != symbol_2</span><span>\n</span><span>&#34;</span><span>);</span>

<span>printf</span><span>(</span><span>&#34;symbol_1 address: %p</span><span>\n</span><span>&#34;</span><span>,</span> <span>symbol_1</span><span>);</span>
<span>printf</span><span>(</span><span>&#34;symbol_2 address: %p</span><span>\n</span><span>&#34;</span><span>,</span> <span>symbol_2</span><span>);</span>
<span>printf</span><span>(</span><span>&#34;my_node-&gt;key:     %p</span><span>\n</span><span>&#34;</span><span>,</span> <span>my_node</span><span>-&gt;</span><span>key</span><span>);</span>
</code></pre></div></div>

<p>The above outputs:</p>

<div><div><pre><code>symbol_1 == symbol_2
symbol_1 address: 0x10d56feb8
symbol_2 address: 0x10d56feb8
my_node-&gt;key:     0x10d56feb8
</code></pre></div></div>

<p>That’s counterintuitive! After all, we’re creating two separate char pointers, <code>symbol_1</code> and <code>symbol_2</code>, so intuitively <code>symbol_1 != symbol_2</code> (since they ought to be pointing to different places in memorry), and yet they share the same address along with <code>my_node-&gt;key</code>.</p>

<p>Turns out there are a few things going on here. The first is called string interning, where the compiler notices that we’re initializing two char pointers with the same string. Rather than putting that same string in memory twice, the compiler does some optimizations and just points them both to the same sequence of characters. That’s why inspecting the addresses of <code>symbol_1</code> and <code>symbol_2</code> reveals them to be pointing at precisely the same location in memory.</p>

<p>The second issue has to do with building the Node struct. When we set <code>node-&gt;key = key</code>, we are effectively assigning one char pointer (<code>node.key</code>) the value of another char pointer (<code>key</code>), which means that both are pointing to the same spot in memory.</p>

<p>Here is a revised version copies the contents of the <code>key</code> string to newly-allocated space in memory and performs string comparisons not by comparing their pointers (<code>str_1 == str_2</code>) but by comparing their contents, character-for-character (<code>strcmp(str_1, str_2)</code>):</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>Node</span> <span>{</span>
    <span>char</span><span>*</span>        <span>key</span><span>;</span>
    <span>int</span>          <span>value</span><span>;</span>
    <span>struct</span> <span>Node</span><span>*</span> <span>next</span><span>;</span>
<span>}</span> <span>Node</span><span>;</span>

<span>Node</span><span>*</span> <span>create_node</span><span>(</span><span>char</span><span>*</span> <span>key</span><span>,</span> <span>int</span> <span>val</span><span>)</span>
<span>{</span>
    <span>Node</span><span>*</span> <span>node</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>Node</span><span>));</span>

    <span>node</span><span>-&gt;</span><span>key</span> <span>=</span> <span>malloc</span><span>(</span><span>strlen</span><span>(</span><span>key</span><span>)</span> <span>+</span> <span>1</span><span>);</span>
    <span>strcpy</span><span>(</span><span>node</span><span>-&gt;</span><span>key</span><span>,</span> <span>key</span><span>);</span>
    <span>node</span><span>-&gt;</span><span>value</span> <span>=</span> <span>val</span><span>;</span>
    <span>node</span><span>-&gt;</span><span>next</span>  <span>=</span> <span>NULL</span><span>;</span>

    <span>return</span> <span>node</span><span>;</span>
<span>}</span>

<span>int</span> <span>search</span><span>(</span><span>Node</span><span>*</span> <span>head</span><span>,</span> <span>char</span><span>*</span> <span>target</span><span>,</span> <span>int</span><span>*</span> <span>default_val</span><span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>Node</span><span>*</span> <span>cur</span> <span>=</span> <span>head</span><span>;</span> <span>cur</span> <span>!=</span> <span>NULL</span><span>;</span> <span>cur</span> <span>=</span> <span>cur</span><span>-&gt;</span><span>next</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>strcmp</span><span>(</span><span>cur</span><span>-&gt;</span><span>key</span><span>,</span> <span>target</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>cur</span><span>-&gt;</span><span>value</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>insert_node</span><span>(</span><span>head</span><span>,</span> <span>create_node</span><span>(</span><span>target</span><span>,</span> <span>(</span><span>*</span><span>default_val</span><span>)</span><span>++</span><span>));</span>

    <span>return</span> <span>*</span><span>default_val</span><span>;</span>
<span>}</span>

</code></pre></div></div>

<p>In the <code>create_node()</code> function, we first allocate space on the heap for a new Node struct (20 bytes in my estimation – two 8-byte pointers and a 4-byte int). Then we allocate enough space starting where <code>node-&gt;key</code> is pointing to accommodate the string that has to fit there (<code>strlen(key) + 1</code>). Finally we can stick the contents of the <code>key</code> parameter there using <code>strcpy()</code>. Now, if <code>search()</code> checks for equality using <code>cur-&gt;key == target</code>, this comparison will be false even if the contents of each char pointer are the same, since each is pointing to a separate place in memory, which is to say that the first and second pointers are not the same. Instead, we check for equality using <code>strcmp</code> (which returns 0 when the contents of each string are identical).</p>



<p>Here’s my full linked list implementation, which I’ve fleshed out with wrapper struct <code>LinkedList</code> to hold on to references to the head and tail of the linked list.</p>

<div><div><pre><code><span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span>typedef</span> <span>struct</span> <span>Node</span> <span>{</span>
    <span>char</span><span>*</span>        <span>key</span><span>;</span>
    <span>int</span>          <span>val</span><span>;</span>
    <span>struct</span> <span>Node</span><span>*</span> <span>next</span><span>;</span>
<span>}</span> <span>Node</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>LinkedList</span> <span>{</span>
    <span>Node</span><span>*</span> <span>head</span><span>;</span>
    <span>Node</span><span>*</span> <span>tail</span><span>;</span>
    <span>int</span>   <span>len</span><span>;</span>
<span>}</span> <span>LinkedList</span><span>;</span>

<span>Node</span><span>*</span> <span>create_node</span><span>(</span><span>char</span><span>*</span> <span>key</span><span>,</span> <span>int</span> <span>val</span><span>)</span>
<span>{</span>
    <span>Node</span><span>*</span> <span>node</span>  <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>Node</span><span>));</span>

    <span>node</span><span>-&gt;</span><span>key</span>   <span>=</span> <span>malloc</span><span>(</span><span>strlen</span><span>(</span><span>key</span><span>)</span> <span>+</span> <span>1</span><span>);</span>
    <span>strcpy</span><span>(</span><span>node</span><span>-&gt;</span><span>key</span><span>,</span> <span>key</span><span>);</span>
    <span>node</span><span>-&gt;</span><span>val</span>   <span>=</span> <span>val</span><span>;</span>
    <span>node</span><span>-&gt;</span><span>next</span>  <span>=</span> <span>NULL</span><span>;</span>

    <span>return</span> <span>node</span><span>;</span>
<span>}</span>

<span>LinkedList</span><span>*</span> <span>create_linked_list</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>LinkedList</span><span>*</span> <span>linkedlist</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>LinkedList</span><span>));</span>
    <span>linkedlist</span><span>-&gt;</span><span>head</span> <span>=</span> <span>NULL</span><span>;</span>
    <span>linkedlist</span><span>-&gt;</span><span>tail</span> <span>=</span> <span>NULL</span><span>;</span>
    <span>linkedlist</span><span>-&gt;</span><span>len</span>  <span>=</span> <span>0</span><span>;</span>

    <span>return</span> <span>linkedlist</span><span>;</span>
<span>}</span>

<span>void</span> <span>print_linked_list</span><span>(</span><span>LinkedList</span><span>*</span> <span>linkedlist</span><span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>Node</span><span>*</span> <span>cur</span> <span>=</span> <span>linkedlist</span><span>-&gt;</span><span>head</span><span>;</span> <span>cur</span> <span>!=</span> <span>NULL</span><span>;</span> <span>cur</span> <span>=</span> <span>cur</span><span>-&gt;</span><span>next</span><span>)</span>
        <span>printf</span><span>(</span><span>&#34;%s/%d -&gt; &#34;</span><span>,</span> <span>cur</span><span>-&gt;</span><span>key</span><span>,</span> <span>cur</span><span>-&gt;</span><span>val</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>

<span>int</span> <span>append</span><span>(</span><span>LinkedList</span><span>*</span> <span>linkedlist</span><span>,</span> <span>Node</span><span>*</span> <span>new_node</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>linkedlist</span><span>-&gt;</span><span>head</span> <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
        <span>linkedlist</span><span>-&gt;</span><span>head</span> <span>=</span> <span>linkedlist</span><span>-&gt;</span><span>tail</span> <span>=</span> <span>new_node</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>linkedlist</span><span>-&gt;</span><span>tail</span><span>-&gt;</span><span>next</span> <span>=</span> <span>new_node</span><span>;</span>
        <span>linkedlist</span><span>-&gt;</span><span>tail</span> <span>=</span> <span>linkedlist</span><span>-&gt;</span><span>tail</span><span>-&gt;</span><span>next</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>++</span><span>linkedlist</span><span>-&gt;</span><span>len</span><span>;</span>
<span>}</span>

<span>int</span> <span>search</span><span>(</span><span>LinkedList</span><span>*</span> <span>linkedlist</span><span>,</span> <span>char</span><span>*</span> <span>target_key</span><span>,</span> <span>int</span><span>*</span> <span>default_val</span><span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>Node</span><span>*</span> <span>cur</span> <span>=</span> <span>linkedlist</span><span>-&gt;</span><span>head</span><span>;</span> <span>cur</span> <span>!=</span> <span>NULL</span><span>;</span> <span>cur</span> <span>=</span> <span>cur</span><span>-&gt;</span><span>next</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>strcmp</span><span>(</span><span>cur</span><span>-&gt;</span><span>key</span><span>,</span> <span>target_key</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>cur</span><span>-&gt;</span><span>val</span><span>;</span>
    <span>}</span>

    <span>append</span><span>(</span><span>linkedlist</span><span>,</span> <span>create_node</span><span>(</span><span>target_key</span><span>,</span> <span>*</span><span>default_val</span><span>));</span>

    <span>return</span> <span>(</span><span>*</span><span>default_val</span><span>)</span><span>++</span><span>;</span>
<span>}</span>

<span>int</span> <span>delete_node</span><span>(</span><span>LinkedList</span><span>*</span> <span>linkedlist</span><span>,</span> <span>char</span><span>*</span> <span>target_key</span><span>)</span>
<span>{</span>
    <span>/* doesn&#39;t yet handle deletion of head node */</span>

    <span>Node</span><span>*</span> <span>tmp</span><span>;</span>
    <span>for</span> <span>(</span><span>Node</span><span>*</span> <span>cur</span> <span>=</span> <span>linkedlist</span><span>-&gt;</span><span>head</span><span>;</span> <span>cur</span><span>-&gt;</span><span>next</span> <span>!=</span> <span>NULL</span><span>;</span> <span>cur</span> <span>=</span> <span>cur</span><span>-&gt;</span><span>next</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>strcmp</span><span>(</span><span>cur</span><span>-&gt;</span><span>next</span><span>-&gt;</span><span>key</span><span>,</span> <span>target_key</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>tmp</span> <span>=</span> <span>cur</span><span>-&gt;</span><span>next</span><span>-&gt;</span><span>next</span><span>;</span>
            <span>free</span><span>(</span><span>cur</span><span>-&gt;</span><span>next</span><span>-&gt;</span><span>key</span><span>);</span>
            <span>free</span><span>(</span><span>cur</span><span>-&gt;</span><span>next</span><span>);</span>
            <span>cur</span><span>-&gt;</span><span>next</span> <span>=</span> <span>tmp</span><span>;</span>
            <span>return</span> <span>0</span><span>;</span>           <span>// return 0 if found</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>-</span><span>1</span><span>;</span>                  <span>// return -1 if not found</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span>
<span>{</span>

    <span>int</span> <span>default_val</span> <span>=</span> <span>16</span><span>;</span>       <span>// starting default val for inserts</span>

    <span>// create empty linked list</span>
    <span>LinkedList</span><span>*</span> <span>symbols</span> <span>=</span> <span>create_linked_list</span><span>();</span>

    <span>// add something</span>
    <span>append</span><span>(</span><span>symbols</span><span>,</span> <span>create_node</span><span>(</span><span>&#34;my_key&#34;</span><span>,</span> <span>100</span><span>));</span>

    <span>// search for something that doesn&#39;t exist</span>
    <span>search</span><span>(</span><span>symbols</span><span>,</span> <span>&#34;your_key&#34;</span><span>,</span> <span>&amp;</span><span>default_val</span><span>);</span> <span>//  =&gt; returns 16</span>

    <span>// print</span>
    <span>print_linked_list</span><span>(</span><span>symbols</span><span>);</span> <span>// =&gt; my_key/100 -&gt; your_key/16 -&gt;</span>

</code></pre></div></div>


          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
