<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.persistent.info/2025/03/infinite-mac-os-x.html">Original</a>
    <h1>Infinite Mac OS X</h1>
    
    <div id="readability-page-1" class="page"><article>
<p><strong>tl;dr:</strong> Infinite Mac can now <a href="https://infinitemac.org/?filter=macosx">run early Mac OS X</a>, with <a href="https://infinitemac.org/2001/Mac%20OS%20X%2010.1">10.1</a> and <a href="https://infinitemac.org/2003/Mac%20OS%20X%2010.3">10.3</a> being the best supported versions. It’s not particularly snappy, but as someone who lived through that period, I can tell you that it wasn’t much better on real hardware. Infinite HD has also been rebuilt to have some notable indie software from that era.</p>

<p>
  <img alt="Mac OS X 10.1 running NetNewsWire Lite and Terminal" height="928" src="https://persistent.info/images/infinite-mac-mac-os-x-10.1.webp" width="1184"/>
</p>

<h3>Porting PearPC</h3>

<p>I’ve been <a href="https://github.com/search?q=repo%3Amihaip%2Finfinite-mac+219&amp;type=commits&amp;s=committer-date&amp;o=desc">tracking</a> DingusPPC progress since my initial <a href="https://blog.persistent.info/2023/12/dingusppc.html">port</a> and making the occasional contribution <a href="https://github.com/dingusdev/dingusppc/commits?author=mihaip">myself</a>, with the hope of using it to run Mac OS X in Infinite Mac. While it has continued to improve, I reached a plateau last summer; my attempts would result in either kernel panics or graphical corruption. I tried to reduce the problem a bit via a <a href="https://github.com/dingusdev/dingusppc/pull/120">deterministic execution mode</a>, but it wasn’t really clear where to go next. I decided to take a break from this emulator and explore alternate paths of getting Mac OS X to run.</p>

<p><a href="https://github.com/sebastianbiallas/pearpc">PearPC</a> was the obvious choice – it was created with the express purpose of emulating Mac OS X on x86 Windows and Linux machines in the early 2000s. By <a href="https://www.osnews.com/story/7085/pearpc-01-is-it-a-miracle/">all accounts</a>, it did this successfully for a few years, until interest waned after the Intel switch. I had earlier <a href="https://blog.persistent.info/2023/12/dingusppc.html#:~:text=I%20also%20briefly%20considered%20PearPC%20(which%20is%20much%20more%20focused%20on%20early%20PowerMacs%20than%20QEMU)%2C%20but%20it%E2%80%99s%20also%20in%20a%20state%20of%20abandonment%20(development%20mostly%20stopped%20in%202005%2C%20with%20a%20brief%20resurrection%20in%202015).">dismissed it</a> as a “dead” codebase, but I decided that the satisfaction of getting something working compensated for dealing with legacy C++ (complete with its own <a href="https://github.com/sebastianbiallas/pearpc/blob/master/src/tools/str.h">string class</a>, <a href="https://github.com/sebastianbiallas/pearpc/blob/master/src/tools/snprintf.cc">sprintf implementation</a>, and <a href="https://github.com/sebastianbiallas/pearpc/blob/master/src/system/gif.cc">GIF decoder</a>). An encouraging discovery was that <a href="https://github.com/kanjitalk755">kanjitalk755</a> (the de-facto Basilisk II and SheepShaver maintainer) had somewhat recently set up <a href="https://github.com/sebastianbiallas/pearpc/compare/master...kanjitalk755:pearpc:macos_sdl2">an experimental branch</a> of PearPC that built and ran on modern macOS. I was able to replicate their work without too much trouble, and with that existence proof I started on my sixth port of an emulator to WebAssembly/Emscripten and the Infinite Mac runtime.</p>

<p>In some ways PearPC not being actively developed made things easier – I didn’t have to worry about merging in changes from upstream, or agonize over how to structure my modifications to make them easier to contribute back. It was also helpful that PearPC was already a multi-platform codebase and thus had the right layers of abstraction to make adding another target pretty easy. As a bonus, it didn’t make pervasive use of threads or other harder-to-port concepts. Over the course of a few days, I was able to <a href="https://github.com/mihaip/pearpc/commit/a63c1145964843c09e4d21fc55c182ccb53e82ce">get it to build</a>, <a href="https://github.com/mihaip/pearpc/commit/b13f6813321af579895122a71aa09ba2cb793717">output video</a>, <a href="https://github.com/mihaip/pearpc/commit/dde5322f13a2ca64727cd94a98795f5c1f20f6b0">load disk images</a>, and <a href="https://github.com/mihaip/pearpc/commit/526ba08845122e991268c5d995167efbd083ac8e">get mouse and keyboard input</a> hooked up. It was pretty satisfying to have Mac OS X 10.2 running in a browser more reliably than it previously had.</p>

<h3>Performance</h3>

<p>While PearPC ran 10.2 more reliably, it felt slower than DingusPCC. I had spent some time last year making <a href="https://github.com/dingusdev/dingusppc/commit/564c43c907917f498d7090c6f108ead03f6b123d">some</a> <a href="https://github.com/dingusdev/dingusppc/commit/b759f25d87a21b95ea0384fa9a83644591bb6305">optimizations</a> to the latter, partly inspired by the <a href="https://github.com/kwhr0/macemu/blob/master/SheepShaver/src/TinyPPC.cpp">TinyPPC emulator</a> in <a href="http://kwhr0.g2.xrea.com/macemu.html">this SheepShaver fork</a> (aren’t all these names fun?). I <a href="https://github.com/mihaip/pearpc/commit/0856ed0acb9674420fb6c858e684a02033b3cdc3">ported</a> DingusPPC’s benchmark harness and then <a href="https://github.com/mihaip/pearpc/commit/75dbcfb9f5e28735792bff085d58cb206631564b">set</a> <a href="https://github.com/mihaip/pearpc/commit/71059084de0169b760f4c908d52961d2e69399a1">about</a> <a href="https://github.com/mihaip/pearpc/commit/c87caace8a5479caf160a6a0a8d9183de5165132">replicating</a> <a href="https://github.com/mihaip/pearpc/commit/4ac34d860b0b58d6ff3cefa630d98f5681443b5b">the</a> <a href="https://github.com/mihaip/pearpc/commit/3e979205950b9d540577204d8e86a494f53157a2">performance</a> <a href="https://github.com/mihaip/pearpc/commit/14d050101f1ada51c49197e494211f7e9e15e847">work</a> <a href="https://github.com/mihaip/pearpc/commit/c3b29968fde9c5d860ba9fdfcf5c5a3b3537760b">in</a> <a href="https://github.com/mihaip/pearpc/commit/6cad14c927b12ec832709d15d9663ba1b2b0dd78">PearPC</a> (both emulators are pure interpreters driven by a lookup table, so the process was relatively straightforward). I was able to shave off about 15 seconds from the 10.2 boot time – it helps from a <a href="https://folklore.org/Saving_Lives.html">saving lives perspective</a>, but is still not enough given that it takes almost 2 minutes to be fully operational. In the end, I copped out and <a href="https://github.com/mihaip/infinite-mac/commit/280a527ef0b682dc142bd14ec61cbe37978a39f7">added a UI disclaimer</a> that Mac OS X can be slow to boot. I also got flashbacks to the <a href="https://arstechnica.com/gadgets/2001/04/macos-x/#page-6:~:text=will%20Mac%20OS%20X%20have%20a%20snappy%20UI">“is it snappy yet?”</a> discussions from the early days of Mac OS X – it was indeed slow, but not this slow.</p>

<p>Performance is still not as good as DingusPPC’s – the biggest bottleneck is the lack of any kind of caching in the MMU, so all loads and stores are expensive since they involve complex address computations. DingusPPC has a much more mature <a href="https://github.com/dingusdev/dingusppc/blob/master/zdocs/developers/cpu/powerpc/mmuemu.md">tiered cache</a> that appears to be quite effective. More generally, while PearPC may be more stable than DingusPPC at running 10.2-10.4, it’s a much less principled codebase (I came across <a href="https://github.com/sebastianbiallas/pearpc/commit/152604c0af3f0613bae37cf4287f188a42be0c06">many mystery commits</a>) and it “cheats” in many ways (it has a <a href="https://github.com/sebastianbiallas/pearpc/blob/7eb63de8a92b86e1b7438019ddcf935005112501/src/io/prom/promboot.cc#L977">custom</a> firmware and <a href="https://github.com/sebastianbiallas/pearpc/blob/7eb63de8a92b86e1b7438019ddcf935005112501/ppccfg.example#L75-L78">video driver</a>, and only the <a href="https://github.com/sebastianbiallas/pearpc/blob/7eb63de8a92b86e1b7438019ddcf935005112501/src/cpu/cpu_generic/ppc_alu.cc#L116-L117">subset</a> of PowerPC instructions that are needed for Mac OS X are implemented). I’m still holding out hope for DingusPPC to be the fast, stable, and correct choice for the long term.</p>

<h3>A Side Quest</h3>

<p>I implemented the “unified decoding table” approach in PearPC’s interpreter one opcode family at a time. When I got to the floating point operations, I assumed it was going to be another mechanical change. I was instead surprised to see that behavior regressed – I got some rendering glitches in the Dock, and the Finder windows would not open at all. After some debugging, I noticed that the <a href="https://github.com/mihaip/pearpc/blob/3e979205950b9d540577204d8e86a494f53157a2/src/cpu/cpu_generic/ppc_dec.cc#L106-L172">dispatching for opcode groups 59 and 63</a> didn’t just do a basic lookup on the relevant instruction bits. It first checked the <code>FP</code> bit of the <a href="https://en.wikipedia.org/wiki/Machine_state_register">Machine State Register (MSR)</a>, and if it was not set it would throw a “floating point unavailable” exception.</p>

<p>I initially thought this was the emulator being pedantic – all PowerPC chips used in Macs had an FPU, so this should never happen. However, setting a breakpoint showed that the exception was being hit pretty frequently during Mac OS X startup. The <a href="https://github.com/apple-oss-distributions/xnu/tree/xnu-124.7">xnu kernel sources</a> of that time period are available, and though I’m not familiar with the details, there are places where the FP bit <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-124.7/osfmk/ppc/cswtch.s#L201">is</a> <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-124.7/osfmk/ppc/cswtch.s#L1012">cleared</a> and a <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-124.7/osfmk/ppc/cswtch.s#L656-L707">handler for the resulting exception</a> is registered. I assume this is an optimization to avoid having to save/restore FPU registers during context switches (if they’re not being used). The upshot was that once I implemented the equivalent <code>FP</code> check in my optimized dispatch code, the rendering problems went away.</p>

<p>This reminded me of the rendering glitches that I had encountered when trying to run Mac OS X under DingusPPC. Even when booting from the 10.2 install CD (which does not kernel panic) I would end up with missing text and other issues:</p>

<p>
  <img alt="Mac OS X 10.2 installer showing text rendering glitches" height="624" src="https://persistent.info/images/infinite-mac-mac-os-x-10.2-installer-broken.webp" width="832"/>
</p>

<p>Checking the DingusPPC sources showed that it never checked the <code>FP</code> bit, and always allowed floating point instructions to go through. I did a quick hack to check it and raise an exception if needed, and the glitches went away!</p>

<p>
  <img alt="Mac OS X 10.2 installer correctly rendering text" height="624" src="https://persistent.info/images/infinite-mac-mac-os-x-10.2-installer-fixed.webp" width="832"/>
</p>

<p>The <a href="https://github.com/dingusdev/dingusppc/pull/135">proper implementation</a> was a bit more complicated, and I ended up <a href="https://github.com/dingusdev/dingusppc/pull/136">revising it a bit</a> to avoid a performance hit (and another contributor did <a href="https://github.com/dingusdev/dingusppc/commit/82a48899f0c28a9418a07b56b5d39f7e161b1549">another pass</a>). But at the end of it all, DingusPPC became a lot more stable, which was a nice side effect. Better yet, it can run 10.1 reliably, which PearPC cannot. I ended up using a combination of both emulators to run a broader subset of early Mac OS X (unfortunately 10.0 is still unstable, and the Public Beta kernel panics immediately, but I’m holding out hope for the future).</p>

<h3>Rebuilding Infinite HD</h3>

<p>Part of the appeal of Infinite Mac is that the emulated machines also have an “Infinite HD” mounted with a lot of era-appropriate software to try. With Mac OS X running, it was time to build an alternate version that went beyond the 80s and 90s classic Mac apps I had collected. I had my favorites, but I also <a href="https://hachyderm.io/@mihaip/113977444999284253">put out a call for suggestions</a> and got plenty of ideas.</p>

<p>For actually building the disk image, I extended the <a href="https://blog.persistent.info/2022/03/blog-post.html#:~:text=Building%20Disk%20Images%2C%20or%20Docker%201995%2Dstyle">automated approach</a> that I first launched the site with. Disk images were even more popular in the early days of Mac OS X than they are today, so I <a href="https://github.com/mihaip/infinite-mac/commit/a7f69373a7b2eb1d85ea33e975180b4a2ca02a44">added a way</a> to import .dmgs as additional folders in the generated image. However, I quickly discovered that despite having the same extension, there are <a href="https://github.com/libyal/libmodi/blob/main/documentation/Mac%20OS%20disk%20image%20types.asciidoc#1-overview">many variants</a>, and the <code>hdiutil</code> that ships with modern macOS cannot always mount images generated more than 20 years ago. In the end I ended up with a <a href="https://github.com/mihaip/infinite-mac/commit/119000a268bb3f21180e06ea899331b2307b695e">Rube Goldberg approach</a> that first extracts the raw partition via <a href="https://github.com/Lekensteyn/dmg2img">dmg2img</a> and then recreates a “modern” disk image that can be mounted and copied from.</p>

<p>As for getting the actual software, the usual sites like <a href="https://macintoshgarden.org/">Macintosh Garden</a> do have some from that era, but it’s not a priority for them. Early to mid 2000s Mac OS X software appears to be a bit of a blind spot – it’s too new to be truly “retro”, but too old to still be available from the original vendor (<a href="https://rogueamoeba.com/legacy/">though</a> <a href="https://files.omnigroup.com/software/MacOSX/">there</a> <a href="https://download-cdn.panic.com/">are</a> <a href="https://c-command.com/dropdmg/support#older-versions">exceptions</a>). I ended up using the <a href="https://web.archive.org/">Wayback Machine</a> a lot. As a bonus, I also installed the companion “Developer” CDs for each Mac OS X version, so tools like Project Builder and Interface Builder are also accessible.</p>

<p>
  <img alt="Mac OS X 10.4 running Delicious Library, CandyBar, PCalc and Pixelmator" height="768" src="https://persistent.info/images/infinite-mac-mac-os-x-hd.webp" width="1024"/>
</p>

<p>The only limitation that I ran into is that my disk build process is centered around HFS, but HFS+ was the default of that time period, and it introduced more advanced capabilities like longer file names containing arbitrary Unicode characters. Files from disk images that rely HFS+ features do not translate losslessly, but luckily this was not an issue for most software. To actually mount multiple drives (up to 3, between the boot disk, Infinite HD, and <a href="https://blog.persistent.info/2023/09/infinite-mac-improved-persistence.html">Saved HD</a>), I <a href="https://github.com/mihaip/dingusppc/commit/51019e4fa0109fa8268cd547b92dee0e7065ac5c">ended</a> <a href="https://github.com/mihaip/pearpc/commit/93f224a8a9676479ff79aad9bf7632d400a5c693">up</a> <a href="https://github.com/mihaip/dingusppc/commit/b220d7b9ed39953780d2a42f9f83caaf8a6cf06e">borrowing</a> a clever solution from a <a href="https://github.com/joevt/dingusppc/">DingusPPC fork</a>: a multi-partition disk image is created on the fly from an arbitrary number of partition images that are specified at startup.</p>

<h3>Aqua</h3>

<p>To make the addition of Mac OS X to Infinite Mac complete, I also wanted to have an Aqua mode for the site’s controls, joining the <a href="https://blog.persistent.info/search/label/Infinite%20Mac#:~:text=To%20reduce%20the%20cognitive%20dissonance%20(and%20to%20have%20a%20bit%20of%20fun)%2C%20I%20made%20the%20UI%20resemble%20the%20look%2Dand%2Dfeel%20of%20the%20OS%20that%20is%20being%20booted">classic, Platinum</a>, and <a href="https://blog.persistent.info/search/label/Infinite%20Mac#:~:text=With%20the%20initial%20emulator%20being%20brought%20up%2C%20there%20were%20some%20more%20fun%20tasks%2C%20like%20adding%20a%20NeXT%2Dstyle%20monitor%20frame%20and%20a%20NeXT%20appearance%20to%20the%20Infinite%20Mac%20controls%20(working%20on%20them%20is%20giving%20me%20Kaleidoscope%20scheme%20flashbacks).">NeXT</a> appearances. That prompted the question: <a href="https://512pixels.net/projects/aqua-screenshot-library/">which Aqua</a>?</p>

<p>
  <img alt="Screenshots of the logout dialog in Mac OS X 10.1 to 10.4" height="369" src="https://persistent.info/images/infinite-mac-mac-os-x-aqua.webp" width="901"/></p>

<p>Though the more subdued versions from 10.3 and 10.4 are my favorites, I decided to go with the 10.0/10.1 one since it has the biggest nostalgia factor. I wanted to use the exact same image assets as the OS, and since they make heavy use of semi-transparency, regular screenshots were not going to be good enough. I used <a href="https://github.com/fuzziqersoftware/resource_dasm">resource_dasm</a> and <a href="https://kwasi-ich.de/software/aqua/">pxm2tga</a> to extract the original assets from <a href="http://www.atpm.com/11.06/customizing.shtml">Extras.rsrc</a> and create <a href="https://github.com/mihaip/infinite-mac/commit/cbc6a3ea8ac0523fbea27dbd57770837c60465db">my own version of Aqua</a>:</p>

<p>
  <img alt="Infinite Mac custom instance configuration dialog, rendered with an Aqua appearance" height="708" src="https://persistent.info/images/infinite-mac-mac-os-x-custom.webp" width="661"/>
</p>

<p>If the recent rumors of a <a href="https://www.bloomberg.com/news/articles/2025-03-10/apple-readies-dramatic-design-overhauls-for-ios-19-ipados-19-and-macos-16">big UI revamp</a> do come true, it’ll be nice to have this reference point of its ancestor.</p>

<h3>Odds and Ends</h3>

<p>The ability to mount multiple images means that you can also have a Mac OS 9 partition and start the Classic compatibility environment (this only works under 10.1 – PearPC never supported Classic). You can thus emulate classic Mac apps inside an emulated Mac OS X inside a WebAssembly virtual machine:</p>

<p>
  <img alt="Mac OS X 10.1 running Stickies, Scrapbook and Calculator under Classic" height="624" src="https://persistent.info/images/infinite-mac-mac-os-x-classic.webp" width="832"/>
</p>

<p>There was a recent storm in a teacup about <a href="https://mjtsai.com/blog/2025/01/30/repeating-calculator-operations/">a Calculator behavior change</a>. Using these Mac OS X images, it’s possible to verify that versions through 10.3 didn’t have the “repeatedly press equals” behavior, but 10.4 did.</p>

<p>Since Mac OS X boot is rather slow, I wanted to have a way to show more progress. PearPC has <a href="https://github.com/mihaip/infinite-mac/blob/cb6b16c3ace1b36c9228d991397176c0036bc960/src/Data/PearPCConfig.txt#L56-L61">a built-in way</a> to trigger verbose mode, but DingusPPC did not, so I added a way to <a href="https://github.com/dingusdev/dingusppc/commit/a6e1b8c338b4b93fcafe97605dc8b493c61fb2a3">specify Open Firmware variables at startup</a>. This is now exposed in the <a href="https://infinitemac.org/2001/Mac%20OS%20X%2010.1?edit">custom instance dialog</a> via the “Debug Mode” switch.</p>

<p>Though I’ve moved away from custom domain names, I thought <a href="https://macosx.app">macosx.app</a> would make a nice <a href="https://system6.app">addition</a> <a href="https://system7.app">to</a> <a href="https://macos8.app">my</a> <a href="https://macos9.app">collection</a>. Unfortunately it’s taken, though in a rather weird way. I even contacted the YouTuber whose video it redirects to, and he said he was not the one that registered it. It expires in a couple of months, so maybe I’ll be able to grab it.</p>

<h3>The End Of The Line?</h3>

<blockquote>“When Alexander saw the breadth of his domain, he wept for there were no more worlds to conquer.”</blockquote>

<p>Mac OS X support catches Infinite Mac up to the modern day, unless I happen to get access to some <a href="https://web.archive.org/web/20171006210639/https://twitter.com/mcclure111/status/916405883202129921">time travel mechanics</a>. There are of course two more CPU transitions to go through and numerous small changes, but Tiger is fundamentally recognizable to any current-day macOS user.</p>
<p>Except that in the retrocomputing world, it’s always possible to go deeper or more obscure. <a href="https://en.wikipedia.org/wiki/A/UX">A/UX</a> is not something that I’m very familiar with, but it was a contemporary of classic Mac OS and would be interesting to compare to NeXTStep. <a href="https://github.com/pruten/shoebill">Shoebill</a> runs it, and the codebase looks approachable enough to port. Then there’s <a href="https://github.com/mihaip/infinite-mac/issues/167">Lisa</a>, the <a href="https://en.wikipedia.org/wiki/Apple_Pippin">Pippin</a> (DingusPPC has some <a href="https://github.com/dingusdev/dingusppc/blob/master/machines/machinepippin.cpp">nascent support</a>), and further afield the Newton (via <a href="https://github.com/pguyot/Einstein">Einstein</a>?). We’ll see what moves me next.</p>

<h3>A Post-Credits Sequence</h3>

<p>When I first began exploring ways of running Mac OS X, I mentioned that <a href="https://blog.persistent.info/2023/12/dingusppc.html#:~:text=The%20obvious%20choice%20was%20QEMU%20%E2%80%93%20it%20has%20very%20broad%20guest%20OS%20support%20and%20is%20very%20actively%20developed.%20However%2C%20it%E2%80%99s%20also%20a%20beast%20of%20a%20project%20to%20build%20and%20navigate%20around%3B%20it%20didn%E2%80%99t%20seem%20like%20it%20would%20be%20something%20I%20would%20able%20to%20make%20much%20progress%20on%20while%20working%20on%20it%20for%20a%20few%20hours%20a%20week.">QEMU seemed too daunting to port</a> to WebAssembly given my limited time. Furthermore, the performance of the <a href="https://github.com/atrosinenko/qemujs">qemu.js</a> experiment from a few years ago made it seem like even if it did run, it would be much too slow to be usable. However, I recently became aware of <a href="https://github.com/ktock/qemu-wasm">qemu-wasm</a> via <a href="https://fosdem.org/2025/schedule/event/fosdem-2025-6290-running-qemu-inside-browser/">this FOSDEM presentation</a>. The performance of its Linux guest <a href="https://ktock.github.io/qemu-wasm-demo/">demos</a> is encouraging: I ran an impromptu bennmark of computing an MD5 checksum of 100 MB of data and it completed it in 8 seconds (vs. 13 for DingusPPC and 18 for PearPC). There’s still a big gap between that and a graphical guest like Mac OS X, but it’s nice to have this existence proof.</p>
</article></div>
  </body>
</html>
