<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://debamitro.github.io/blog/mystery-of-missing-audio-samples-ii/">Original</a>
    <h1>The Mystery of the Missing Audio Samples - II</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>(This is a continuation from my previous <a href="https://debamitro.github.io/blog/mystery-of-missing-audio-samples-i/">blog post</a>.)</p>
<h2 id="re-cap">Re-cap</h2>
<p>I was trying to read in audio samples from my microphone using Rust’s <a href="https://github.com/rustaudio/cpal">cpal</a> library. Somehow I couldn’t get 44100 samples per second even though I had verified that the sampling rate was 44100 Hz. I tried various things and nothing seemed to work.</p>
<h2 id="more-attempts-to-solve-the-mystery">More attempts to solve the mystery</h2>
<h3 id="attempt-4">Attempt 4</h3>
<p>Cpal uses <a href="https://crates.io/crates/coreaudio-rs">coreaudio-rs</a> on OSX, which is a “Rust-esque” interface over Apple’s CoreAudio framework. From my comparisons of portaudio and cpal, I picked one difference which seemed important to me. When portaudio wants to ‘stop’ an input stream, it calls a bunch of stuff including <a href="https://developer.apple.com/documentation/audiotoolbox/1439607-audiounitreset">AudioUnitReset</a> - and cpal was <em>not</em> doing this one particular call. What’s more, coreaudio-rs doesn’t even have a way to call the AudioUnitReset routine. I downloaded and built my own copies of cpal and coreaudio-rs and made the necessary changes. This taught me how to modify Cargo.toml to tweak where a dependent package got picked up from - the crate registry, a git repo, or a local directory. I didn’t get the desired result yet - I was still receiving somewhere between 40000 and 43000 samples per second.</p>
<h3 id="attempt-5">Attempt 5</h3>
<p>Since nothing seemed to help, I decided to see what happened if I tried to record audio for more than 5 seconds. I added a delay of 500ms after the 5 seconds, like</p>
<div><pre tabindex="0"><code data-lang="rust">    println<span>!</span>(<span>&#34;start recording&#34;</span>);
    stream.play();
    std::thread::sleep(std::time::Duration::from_secs(<span>5</span>);
    std::thread::sleep(std::time::Duration::from_millis(<span>500</span>);
    println<span>!</span>(<span>&#34;stop recording&#34;</span>);
</code></pre></div><p>For the first time I got close to 44100 x 5 samples. I started experimenting with the additional delay, and I found out that if I added 600ms I got all 44100 x 5 samples.</p>
<h2 id="the-aha-moment">The Aha! moment</h2>
<p>This is when the solution finally occurred to me - all the samples arrive as expected, but they can take a while to arrive. I was not waiting long enough. And why? Because I was doing the equivalent of looking at my watch and expecting an 8-hour job to be done in 8 hours precisely. Instead, I should have stopped looking at my watch and simply waited for the job to finish. Coming to my particular problem, I knew I should have got 44100 x 5 samples - so I should have waited till I got all of them.</p>
<h2 id="the-solution">The solution</h2>
<p>Here is what I did - I added a variable delay based on the total number of samples received.</p>
<div><pre tabindex="0"><code data-lang="rust">    <span>let</span> max_samples: <span>usize</span> <span>=</span> <span>5</span> <span>*</span> <span>44100</span> <span>*</span> <span>2</span>;
    <span>if</span> <span>let</span> Ok(stream) <span>=</span> device.build_input_stream (<span>&amp;</span>custom_config,
                                                       catch_data,
                                                       catch_error) {
        println<span>!</span>(<span>&#34;start recording&#34;</span>);
        stream.play();
        std::thread::sleep(std::time::Duration::from_secs(<span>5</span>);
        <span>while</span> num_samples2.load(Ordering::Relaxed) <span>&lt;</span> max_samples {
            std::thread::sleep(std::time::Duration::from_millis(<span>200</span>));
        }
</code></pre></div><p>And this worked again and again. It worked for both debug and release builds. What’s more, I went back to the first thing I had done - adding a print statement in the callback function. And even then I did not miss a single sample.</p>
<h2 id="reflection">Reflection</h2>
<p>I realized that this solution was right in front of me all along. Because this is how portaudio works. The callback function supplied to the portaudio stream is supposed to return 0 when it knows it should receive more samples, and return 1 when it knows it got all the samples it needed. The portaudio ‘paex_record.c’ example which I was running had this all along - in the 8 lines starting from <a href="https://github.com/PortAudio/portaudio/blob/52aee492edc64605dcc65afff13776c4dad81910/examples/paex_record.c#L112">here</a>. A lot of my debugging attempts were unnecessary to solve the problem. They did help me learn a lot of Rust concepts, so I am not complaining!</p>

      </div></div>
  </body>
</html>
