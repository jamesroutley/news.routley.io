<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/jaffray/archive/caching-is-an-abstraction-not-an-optimization/">Original</a>
    <h1>Caching is an abstraction, not an optimization</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                
                June 30, 2025
                
                
            </date>
            

            

            

            
            
            <p><img alt="NULL BITMAP.png" src="https://assets.buttondown.email/images/b496ee4d-509d-4108-91c9-289bd6057f33.png"/></p>
            
            

            
            
            <p>I&#39;ve always been told that caching is a tool to make software faster. That, given some careful considerations to consistency, caching makes it so that when you want to read a given piece of data, you don&#39;t have to go all the way back to some backend database or API server or SSD and can instead just read from some faster location like memory for the same data. Caching is thus a tool to improve performance.</p>
<p>My feelings now are that that perspective on caching is wrong, or at least incomplete. Having worked on software recently chiefly concerned with moving data between object storage, disk, and memory, I think now caching is probably best understood as a tool for making software <em>simpler</em>.</p>
<p>Something that always struck me as weird is, how come we have all these pre-baked caching algorithms, LRU, LFU, and so on. It seems like for my application I should have a much more fine-grained understanding of how things should work. Why am I outsourcing the understanding of my data to a generic &#34;policy?&#34; If I fetch some data, it seems like I <em>know</em> whether I&#39;ll need that data again in the near future, so I should explicitly be telling the system whether or not to hold on to it, and for how long.</p>
<p>One good reason is that it&#39;s a clean abstraction boundary!</p>
<p>Coming to caching from the belief that &#34;I will personally manage when my data needs to be stored in faster storage&#34; rather than the &#34;naïve&#34; belief (&#34;I will go to disk every time&#34;), caching much more resembles an <em>abstraction</em> rather than an <em>optimization</em>.</p>
<p>Two programs could have similar behaviour but structured very differently, the difference being that one utilizes caching as an abstraction and one explicitly has the concept of different tiers of storage.</p>
<p><img alt="image.png" src="https://assets.buttondown.email/images/adbad69f-6c88-4710-8463-4ab0eca54277.png?w=960&amp;fit=max"/></p>
<p>As an existence proof, if you look at the systems, databases, which have to carefully manage the dance between memory and disk, you&#39;ll find they work this way. The way a buffer pool works is that any time you try to read data you first pull it into memory if it&#39;s not already there. The way OS disk access works is that any data you read first gets pulled into the page cache (unless you&#39;re using direct IO).</p>
<p>(As an aside that calculus may change somewhat for many workloads, with ever faster SSDs and ever faster APIs for accessing them, but that’s a story for a different time.)</p>
<p>My takeaway from this is that it&#39;s a reminder that it&#39;s possible to come up with a design that works, and that satisfies the functional requirements of a system from the perspective of &#34;having adequate fast access to the data it needs&#34; that nonetheless could be designed more cleanly and having more separated concerns.</p>
<p>Of course there are downsides to this particular abstraction, classically the OS page cache and <code>fsync</code> causes a lot of problems via misuse. It raises the question of &#34;are these concerns truly separate.&#34;</p>
<p>Whenever I heard about people understanding caching algorithms better and spending more time on caching algorithms, it often seemed to me like a misdirection. This isn&#39;t the problem you want to solve, the problem you want to solve is &#34;I want my data in fast storage as often as possible,&#34; not &#34;I want to game this system that is holding my data access hostage.&#34; It feels like an unholy manipulation of <a href="https://x.com/abhi9u/status/1899422783991693418?utm_source=jaffray&amp;utm_medium=email&amp;utm_campaign=caching-is-an-abstraction-not-an-optimization" target="_blank">implementation details</a> secondary to what I actually want to do.</p>
<p>But I think two things are true that make this belief incorrect:</p>
<ol>
<li>Data access is sufficiently unpredictable in real-world workload that we are forced to rely on heuristics, and fitting of heuristics, that we have to do this in any remotely realistic system. The belief that I&#39;m doing this to the exclusion of some smarter, bespoke data movement strategy is an illusion.</li>
<li>Caching is in fact, <em>such</em> a good abstraction, that it <em>merits</em> this kind of arcane study to make it function better in practice. Caching can not fail, it can only <em>be</em> failed.</li>
</ol>
<p>Maybe it&#39;s the curse of very successful abstractions that they&#39;re invisible until they hurt you, which means it&#39;s easy to undervalue them and in cases like mine, not even realize they&#39;re abstractions in the first place.</p>
            
            

            

            



        </div></div>
  </body>
</html>
