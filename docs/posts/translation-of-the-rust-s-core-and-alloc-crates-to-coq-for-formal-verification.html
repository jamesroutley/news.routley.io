<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://formal.land/blog/2024/04/26/translation-core-alloc-crates">Original</a>
    <h1>Translation of the Rust&#39;s core and alloc crates to Coq for formal verification</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container" itemprop="articleBody"><p>We continue our work on formal verification of <a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer">Rust</a> programs with our tool <a href="https://github.com/formal-land/coq-of-rust" target="_blank" rel="noopener noreferrer">coq-of-rust</a>, to translate Rust code to the formal proof system <a href="https://coq.inria.fr/" target="_blank" rel="noopener noreferrer">Coq</a>. One of the limitation we had was the handling of primitive constructs from the standard library of Rust, like <a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap_or_default" target="_blank" rel="noopener noreferrer">Option::unwrap_or_default</a> or all other primitive functions. For each of these functions, we had to make a Coq definition to represent its behavior. This is both tedious and error prone.</p>
<p>To solve this issue, we worked on the translation of the <a href="https://doc.rust-lang.org/core/" target="_blank" rel="noopener noreferrer">core</a> and <a href="https://doc.rust-lang.org/alloc/" target="_blank" rel="noopener noreferrer">alloc</a> crates of Rust using <code>coq-of-rust</code>. These are very large code bases, with a lot of unsafe or advanced Rust code. We present what we did to have a &#34;best effort&#34; translation of these crates. The resulting translation is in the following folders:</p>
<ul>
<li><a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/alloc" target="_blank" rel="noopener noreferrer">CoqOfRust/alloc</a></li>
<li><a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/core" target="_blank" rel="noopener noreferrer">CoqOfRust/core</a></li>
</ul>

<figure><p><img decoding="async" loading="lazy" alt="Crab with a pen" src="https://formal.land/assets/images/crab-in-library-33b99a73bc3cfc9a6c36bcb893f870a1.webp" width="1024" height="1024"/>
</p><figcaption>A crab in a library</figcaption></figure>
<h2 id="initial-run-">Initial run üê•<a href="#initial-run-" aria-label="Direct link to Initial run üê•" title="Direct link to Initial run üê•">‚Äã</a></h2>
<p>An initial run of <code>coq-of-rust</code> on the <code>alloc</code> and <code>core</code> crates of Rust generated us two files of a few hundred thousands lines of Coq corresponding to the whole translation of these crates. This is a first good news, as it means the tool runs of these large code bases. However the generated Coq code does not compile, even if the errors are very rare (one every few thousands lines).</p>
<p>To get an idea, here is the size of the input Rust code as given by the <code>cloc</code> command:</p>
<ul>
<li><code>alloc</code>: 26,299 lines of Rust code</li>
<li><code>core</code>: 54,192 lines of Rust code</li>
</ul>
<p>Given that this code uses macros that we expand in our translation, the actual size that we have to translate is even bigger.</p>
<h2 id="splitting-the-generated-code-">Splitting the generated code ü™ì<a href="#splitting-the-generated-code-" aria-label="Direct link to Splitting the generated code ü™ì" title="Direct link to Splitting the generated code ü™ì">‚Äã</a></h2>
<p>The main change we made was to split the output generated by <code>coq-of-rust</code> with one file for each input Rust file. This is possible because our translation is insensitive to the order of definitions and context-free. So, even if there are typically cyclic dependencies between the files in Rust, something that is forbidden in Coq, we can still split them.</p>
<p>We get the following sizes as output:</p>
<ul>
<li><code>alloc</code>: 54 Coq files, 171,783 lines of Coq code</li>
<li><code>core</code>: 190 Coq files, 592,065 lines of Coq code</li>
</ul>
<p>The advantages of having the code split are:</p>
<ul>
<li>it is easier to read and navigate in the generated code</li>
<li>it is easier to compile as we can parallelize the compilation</li>
<li>it is easier to debug as we can focus on one file at a time</li>
<li>it is easier to ignore files that do not compile</li>
<li>it will be easier to maintain, as it is easier to follow the diff of a single file</li>
</ul>
<h2 id="fixing-some-bugs-">Fixing some bugs üêû<a href="#fixing-some-bugs-" aria-label="Direct link to Fixing some bugs üêû" title="Direct link to Fixing some bugs üêû">‚Äã</a></h2>
<p>We had some bugs related to the collisions between module names. These can occur when we choose a name for the module for an <code>impl</code> block. We fixed these by adding more information in the module names to make them more unique, like the <code>where</code> clauses that were missing. For example, for the implementation of the <code>Default</code> trait for the <code>Mapping</code> type:</p>
<div><div><pre tabindex="0"><code><span><span>#[derive(Default)]</span><span></span><br/></span><span><span></span><span>struct</span><span> </span><span>Mapping</span><span>&lt;</span><span>K</span><span>,</span><span> </span><span>V</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>// ...</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div>
<p>we were generating the following Coq code:</p>
<div><div><pre tabindex="0"><code><span><span>Module</span><span> Impl_core_default_Default_for_dns_Mapping_K_V</span><span>.</span><span></span><br/></span><span><span>  </span><span>(* ...trait implementation ... *)</span><span></span><br/></span><span><span></span><span>End</span><span> Impl_core_default_Default_for_dns_Mapping_K_V</span><span>.</span><br/></span></code></pre></div></div>
<p>We now generate:</p>
<div><div><pre tabindex="0"><code><span><span>Module</span><span> Impl_core_default_Default_where_core_default_Default_K_where_core_default_Default_V_for_dns_Mapping_K_V</span><span>.</span><span></span><br/></span><span><span>  </span><span>(* ... *)</span><br/></span></code></pre></div></div>
<p>with a module name that includes the <code>where</code> clauses of the <code>impl</code> block, stating that both <code>K</code> and <code>V</code> should implement the <code>Default</code> trait.</p>
<p>Here is the list of files that do not compile in Coq, as of today:</p>
<ul>
<li><code>alloc/boxed.v</code></li>
<li><code>core/any.v</code></li>
<li><code>core/array/mod.v</code></li>
<li><code>core/cmp/bytewise.v</code></li>
<li><code>core/error.v</code></li>
<li><code>core/escape.v</code></li>
<li><code>core/iter/adapters/flatten.v</code></li>
<li><code>core/net/ip_addr.v</code></li>
</ul>
<p>This represents 4% of the files. Note that in the files that compile there are some unhandled Rust constructs that are axiomatized, so this does not give the whole picture of what we do not support.</p>
<h2 id="example-">Example üîé<a href="#example-" aria-label="Direct link to Example üîé" title="Direct link to Example üîé">‚Äã</a></h2>
<p>Here is the source code of the <code>unwrap_or_default</code> method for the <code>Option</code> type:</p>
<div><div><pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>unwrap_or_default</span><span>(</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>T</span><span></span><br/></span><span><span></span><span>where</span><span></span><br/></span><span><span>    </span><span>T</span><span>:</span><span> </span><span>Default</span><span>,</span><span></span><br/></span><span><span></span><span>{</span><span></span><br/></span><span><span>    </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>Some</span><span>(</span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span> x</span><span>,</span><span></span><br/></span><span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>T</span><span>::</span><span>default</span><span>(</span><span>)</span><span>,</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div>
<p>We translate it to:</p>
<div><div><pre tabindex="0"><code><span><span>Definition</span><span> unwrap_or_default </span><span>(</span><span>T </span><span>:</span><span> Ty</span><span>.</span><span>t</span><span>)</span><span> </span><span>(</span><span>œÑ </span><span>:</span><span> list Ty</span><span>.</span><span>t</span><span>)</span><span> </span><span>(</span><span>Œ± </span><span>:</span><span> list Value</span><span>.</span><span>t</span><span>)</span><span> </span><span>:</span><span> M </span><span>:=</span><span></span><br/></span><span><span>  </span><span>let</span><span> Self </span><span>:</span><span> Ty</span><span>.</span><span>t </span><span>:=</span><span> Self T </span><span>in</span><span></span><br/></span><span><span>  </span><span>match</span><span> œÑ</span><span>,</span><span> Œ± </span><span>with</span><span></span><br/></span><span><span>  </span><span>|</span><span> </span><span>[</span><span>]</span><span>,</span><span> </span><span>[</span><span> self </span><span>]</span><span> </span><span>=&gt;</span><span></span><br/></span><span><span>    ltac</span><span>:</span><span>(</span><span>M</span><span>.</span><span>monadic</span><br/></span><span><span>      </span><span>(</span><span>let</span><span> self </span><span>:=</span><span> M</span><span>.</span><span>alloc </span><span>(</span><span>|</span><span> self </span><span>|</span><span>)</span><span> </span><span>in</span><span></span><br/></span><span><span>      M</span><span>.</span><span>read </span><span>(</span><span>|</span><span></span><br/></span><span><span>        M</span><span>.</span><span>match_operator </span><span>(</span><span>|</span><span></span><br/></span><span><span>          self</span><span>,</span><span></span><br/></span><span><span>          </span><span>[</span><span></span><br/></span><span><span>            </span><span>fun</span><span> Œ≥ </span><span>=&gt;</span><span></span><br/></span><span><span>              ltac</span><span>:</span><span>(</span><span>M</span><span>.</span><span>monadic</span><br/></span><span><span>                </span><span>(</span><span>let</span><span> Œ≥</span><span>0_0</span><span> </span><span>:=</span><span></span><br/></span><span><span>                  M</span><span>.</span><span>get_struct_tuple_field_or_break_match </span><span>(</span><span>|</span><span></span><br/></span><span><span>                    Œ≥</span><span>,</span><span></span><br/></span><span><span>                    </span><span>&#34;core::option::Option::Some&#34;</span><span>,</span><span></span><br/></span><span><span>                    </span><span>0</span><span></span><br/></span><span><span>                  </span><span>|</span><span>)</span><span> </span><span>in</span><span></span><br/></span><span><span>                </span><span>let</span><span> x </span><span>:=</span><span> M</span><span>.</span><span>copy </span><span>(</span><span>|</span><span> Œ≥</span><span>0_0</span><span> </span><span>|</span><span>)</span><span> </span><span>in</span><span></span><br/></span><span><span>                x</span><span>)</span><span>)</span><span>;</span><span></span><br/></span><span><span>            </span><span>fun</span><span> Œ≥ </span><span>=&gt;</span><span></span><br/></span><span><span>              ltac</span><span>:</span><span>(</span><span>M</span><span>.</span><span>monadic</span><br/></span><span><span>                </span><span>(</span><span>M</span><span>.</span><span>alloc </span><span>(</span><span>|</span><span></span><br/></span><span><span>                  M</span><span>.</span><span>call_closure </span><span>(</span><span>|</span><span></span><br/></span><span><span>                    M</span><span>.</span><span>get_trait_method </span><span>(</span><span>|</span><span> </span><span>&#34;core::default::Default&#34;</span><span>,</span><span> T</span><span>,</span><span> </span><span>[</span><span>]</span><span>,</span><span> </span><span>&#34;default&#34;</span><span>,</span><span> </span><span>[</span><span>]</span><span> </span><span>|</span><span>)</span><span>,</span><span></span><br/></span><span><span>                    </span><span>[</span><span>]</span><span></span><br/></span><span><span>                  </span><span>|</span><span>)</span><span></span><br/></span><span><span>                </span><span>|</span><span>)</span><span>)</span><span>)</span><span></span><br/></span><span><span>          </span><span>]</span><span></span><br/></span><span><span>        </span><span>|</span><span>)</span><span></span><br/></span><span><span>      </span><span>|</span><span>)</span><span>)</span><span>)</span><span></span><br/></span><span><span>  </span><span>|</span><span> </span><span>_</span><span>,</span><span> </span><span>_</span><span> </span><span>=&gt;</span><span> M</span><span>.</span><span>impossible</span><br/></span><span><span>  </span><span>end</span><span>.</span><br/></span></code></pre></div></div>
<p>We prove that it is equivalent to the simpler functional code:</p>
<div><div><pre tabindex="0"><code><span><span>Definition</span><span> unwrap_or_default </span><span>{</span><span>T </span><span>:</span><span> </span><span>Set</span><span>}</span><span></span><br/></span><span><span>    </span><span>{</span><span>_</span><span> </span><span>:</span><span> core</span><span>.</span><span>simulations</span><span>.</span><span>default</span><span>.</span><span>Default</span><span>.</span><span>Trait T</span><span>}</span><span></span><br/></span><span><span>    </span><span>(</span><span>self </span><span>:</span><span> Self T</span><span>)</span><span> </span><span>:</span><span></span><br/></span><span><span>    T </span><span>:=</span><span></span><br/></span><span><span>  </span><span>match</span><span> self </span><span>with</span><span></span><br/></span><span><span>  </span><span>|</span><span> None </span><span>=&gt;</span><span> core</span><span>.</span><span>simulations</span><span>.</span><span>default</span><span>.</span><span>Default</span><span>.</span><span>default </span><span>(</span><span>Self </span><span>:=</span><span> T</span><span>)</span><span></span><br/></span><span><span>  </span><span>|</span><span> Some x </span><span>=&gt;</span><span> x</span><br/></span><span><span>  </span><span>end</span><span>.</span><br/></span></code></pre></div></div>
<p>This simpler definition is what we use when verifying code. The proof of equivalence is in <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/core/proofs/option.v" target="_blank" rel="noopener noreferrer">CoqOfRust/core/proofs/option.v</a>. In case the original source code changes, we are sure to capture these changes thanks to our proof. Because the translation of the <code>core</code> library was done automatically, we trust the generated definitions more than definitions that would be done by hand. However, there can still be mistakes or incompleteness in <code>coq-of-rust</code>, so we still need to check at proof time that the code makes sense.</p>
<h2 id="conclusion">Conclusion<a href="#conclusion" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">‚Äã</a></h2>
<p>We can now work on the verification of Rust programs with more trust in our formalization of the standard library. Our next target is to simplify our proof process, which is still tedious. In particular, showing that simulations are equivalent to the original Rust code requires doing the name resolution, introduction of high-level types, and removal of the side-effects. We would like to split these steps.</p>
<p>If you are interested in formally verifying your Rust projects, do not hesitate to get in touch with us at¬†<a href="mailto:contact@formal.land" target="_blank" rel="noopener noreferrer">contact@formal.land</a>¬†üíå! Formal verification provides the highest level of safety for critical applications, with a mathematical guarantee of the absence of bugs for a given specification.</p></div></div>
  </body>
</html>
