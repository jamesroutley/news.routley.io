<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.selfref.com/self-signed-jwts">Original</a>
    <h1>Self-Signed JWTs</h1>
    
    <div id="readability-page-1" class="page"><div> <p>Get a load of this (totally normalized) BS.</p>
<div><p>
&#34;We have just the offering for you! 
</p><p>Visit our website. Create an account. Verify your email. Create a project. Add your credit card. Go to settings. Create an API key. Add it to your password manager. Drop it in your .env file. Download our SDK. Import it. Pass your env var in. Never share your API key. Make sure you never commit it to source control.</p>
<p>On the client, we have a React SDK. Make sure you use your publishable key for that. For the server, download our admin SDK. Use your secret key. Never mix the two up.”</p>
</div>
<p>It’s truly wild to me what some of y’all will tolerate.</p>
<h3 id="making-your-own-api-key">Making your own API key</h3>
<p>Let me show you something… Did you know generating a JWK is stupidly easy?</p>
<pre tabindex="0" data-language="ts"><code><span><span>import</span><span> { generateKeyPair, exportJWK } </span><span>from</span><span> &#39;jose&#39;</span></span>
<span></span>
<span><span>const</span><span> keyPair</span><span> =</span><span> await</span><span> generateKeyPair</span><span>(</span><span>&#39;ES256&#39;</span><span>, {</span></span>
<span><span>  extractable: </span><span>true</span><span>,</span></span>
<span><span>})</span></span>
<span><span>const</span><span> publicKeyJWK</span><span> =</span><span> await</span><span> exportJWK</span><span>(keyPair.publicKey)</span></span>
<span><span>const</span><span> privateKeyJWK</span><span> =</span><span> await</span><span> exportJWK</span><span>(keyPair.privateKey)</span></span></code></pre>
<p>That’s it. Your JWK keypair is now effectively your own self-issued API key.</p>
<p>No need to visit a website, make an account, verify your email, create a project, go to settings, create an API key, or copy it and use it. You just generated your own.</p>
<h3 id="how-do-we-use-this">How do we use this?</h3>
<p>Let’s see how we can get rid of secret versus publishable keys and separate client and admin SDKs.</p>
<p>Who cares whether you’re on the client or server? If your app wants to authorize a privileged action, it should be able to do so without separate keys or SDKs.</p>
<p>Here’s how to implement this:</p>
<ol>
<li>Store your app’s private JWK on the server</li>
<li>Using whatever auth scheme you have, implement a function that returns whether to allow a given action</li>
<li>Express privileged actions as claims in your JWT—if a privileged action is allowed, include the claim in the payload and sign the JWT with your private key</li>
<li>Give your client SDK a function that reverse-proxies to your API, adding a signed JWT to the request’s Authorization header with any privileged claims you want to include</li>
</ol>
<p>Here’s what the client-side JWT generation looks like:</p>
<pre tabindex="0" data-language="ts"><code><span><span>import</span><span> { SignJWT } </span><span>from</span><span> &#39;jose&#39;</span></span>
<span></span>
<span><span>const</span><span> jwt</span><span> =</span><span> await</span><span> new</span><span> SignJWT</span><span>({</span></span>
<span><span>  // Clients shouldn&#39;t be able to destroy the database</span></span>
<span><span>  // unless the action is allowed, so this is a claim</span></span>
<span><span>  destroyDatabase: </span><span>true</span><span>,</span></span>
<span><span>})</span></span>
<span><span>// Include the public key in the JWT header so the server </span></span>
<span><span>// can verify the signature and associate the request</span></span>
<span><span>// with your account</span></span>
<span><span>.</span><span>setProtectedHeader</span><span>({ alg: </span><span>&#39;ES256&#39;</span><span>, jwk: publicKeyJWK })</span></span>
<span><span>.</span><span>sign</span><span>(privateKeyJWK);</span></span></code></pre>
<h3 id="charging-for-your-api">Charging for your API</h3>
<p>But what if you want to charge for your API?</p>
<p>Simple: make your API return a payment URL when a request is made with a public key that isn’t associated with a paid account.</p>
<p>Your client SDK can present this to the developer (for example, by logging it to the console).</p>
<p>After the developer pays, associate their public key with the paid account in your database and stop returning payment URLs for future requests from that key.</p>
<h3 id="b2b2c">B2B2C</h3>
<p>What about situations where your customers are developers who want to give <em>their</em> end users API keys?</p>
<p>This is where you need to deviate from JOSE standards.</p>
<p>One approach is hierarchical JWK derivation. Here’s the idea:</p>
<ol>
<li>Your developer customers create a master JWK</li>
<li>They derive child JWKs for each of their end users from that master key</li>
<li>You modify the JWT scheme to include a zero-knowledge proof that the end user’s key is derived from the developer’s master public key</li>
</ol>
<p>This way, you can verify that an end user is authorized by a specific developer without the developer having to manage API keys for their users.</p>
<p>I don’t have a ready-made example of this, but the concept is solid. If you want to explore this further, hit me up on <a href="https://x.com/danscan">Twitter</a> and I’ll help you out.</p> </div></div>
  </body>
</html>
