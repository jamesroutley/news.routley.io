<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://triangulatedexistence.mataroa.blog/blog/i-uncovered-an-acpi-bug-in-my-dell-inspiron-5667-it-was-plaguing-me-for-8-years/">Original</a>
    <h1>I uncovered an ACPI bug in my Dell Inspiron 5567. It was plaguing me for 8 years</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            <p>Imagine you close your laptop lid to put it to sleep, but instead of pausing, it reboots. Not every time, just often enough to be infuriating. You try to save your work, but the machine decides to start over. </p>
<p>For eight years, this has been the reality of using my Dell Inspiron 5567. A bug I couldn&#39;t explain, happening across every OS I installed. This is the story of how I dug into the firmware&#39;s source code and found the single, flawed command responsible.</p>
<h2 id="intro">Intro</h2>
<p>This laptop has been my companion since I was in 7th grade. It&#39;s the machine where I learned everything from C++ to Python. When it couldn&#39;t upgrade to Windows 11, I gave it a new life with Linux Mint.
While that came with its own set of technical puzzles to solve, one bug has been a constant frustration across every OS: S3 Sleep.</p>
<h2 id="the-bug">The Bug</h2>
<p>Whenever I put my laptop to sleep, it was a gamble. Sometimes, instead of pausing, it would completely restart. This happened whether I closed the lid or let it idle. </p>
<p>Since the bug persisted across both Windows and Linux, I knew the fault wasn&#39;t in the operating system, but something much deeper: the firmware itself.</p>
<h2 id="ignition-of-spark">Ignition of spark</h2>
<p><a href="https://github.com/Zephkek/Asus-ROG-Aml-Deep-Dive">https://github.com/Zephkek/Asus-ROG-Aml-Deep-Dive</a></p>
<p>Literally this GitHub repo. Just check this out, it&#39;s the thing I needed. I knew that it was an ACPI fault, but I needed to know how to read the code from the ACPI tables.</p>
<p>In Linux (and even in Windows), this boils down to these two commands:</p>
<div><pre><span></span><span># Extract all ACPI tables into binary .dat files; sudo for admin privileges in Linux</span>
sudo<span> </span>acpidump<span> </span>-b

<span># Decompile the main table into human-readable ACPI Source Language (.dsl)</span>
iasl<span> </span>-d<span> </span>*.dat
</pre></div>

<p>This is it.</p>
<h2 id="raw-code-around-the-main-problem-point">Raw code around the main problem point</h2>
<p>I found &#34;Method(_PTS&#34; under <code>dsdt.dsl</code>. In fact, everything is under <code>dsdt.dsl</code>. </p>
<p>Note: </p>
<ul>
<li>
<p>I&#39;ve taken all the function calls properly and ensured that I can show you the entire process. </p>
</li>
<li>
<p>I haven&#39;t shown the scopes; I have just shown the methods.</p>
</li>
<li>
<p>The indentation has also been preserved to distinguish one method from the other.</p>
</li>
</ul>
<pre><code>    Method (_PTS, 1, NotSerialized)  // _PTS: Prepare To Sleep
    {
        If (Arg0)
        {
            PTS (Arg0)
            \_SB.TPM.TPTS (Arg0)
            \_SB.PCI0.LPCB.SPTS (Arg0)
            \_SB.PCI0.NPTS (Arg0)
            RPTS (Arg0)
        }
    }
    Method (PTS, 1, NotSerialized)
    {
    }
        Method (TPTS, 1, Serialized)
        {
            Switch (ToInteger (Arg0))
            {
                Case (0x04)
                {
                    RQST = Zero
                    FLAG = 0x09
                    SRSP = Zero
                    SMI = OFST /* \OFST */
                    Return (SRSP) /* \_SB_.TPM_.SRSP */
                }
                Case (0x05)
                {
                    RQST = Zero
                    FLAG = 0x09
                    SRSP = Zero
                    SMI = OFST /* \OFST */
                    Return (SRSP) /* \_SB_.TPM_.SRSP */
                }

            }
        }
                Method (SPTS, 1, NotSerialized)
                {
                    SLPX = One
                    SLPE = One
                    If ((Arg0 == 0x03))
                    {
                        AES3 = One
                    }
                }
                Method (NPTS, 1, NotSerialized)
                {
                    PA0H = PM0H /* \_SB_.PCI0.PM0H */
                    PALK = PMLK /* \_SB_.PCI0.PMLK */
                    PA1H = PM1H /* \_SB_.PCI0.PM1H */
                    PA1L = PM1L /* \_SB_.PCI0.PM1L */
                    PA2H = PM2H /* \_SB_.PCI0.PM2H */
                    PA2L = PM2L /* \_SB_.PCI0.PM2L */
                    PA3H = PM3H /* \_SB_.PCI0.PM3H */
                    PA3L = PM3L /* \_SB_.PCI0.PM3L */
                    PA4H = PM4H /* \_SB_.PCI0.PM4H */
                    PA4L = PM4L /* \_SB_.PCI0.PM4L */
                    PA5H = PM5H /* \_SB_.PCI0.PM5H */
                    PA5L = PM5L /* \_SB_.PCI0.PM5L */
                    PA6H = PM6H /* \_SB_.PCI0.PM6H */
                    PA6L = PM6L /* \_SB_.PCI0.PM6L */
                }
    Method (RPTS, 1, NotSerialized)
    {
        P80D = Zero
        D8XH (Zero, Arg0)
        ADBG (Concatenate (&#34;_PTS=&#34;, ToHexString (Arg0)))
        If ((Arg0 == 0x03))
        {
            If (CondRefOf (\_PR.DTSE))
            {
                If ((\_PR.DTSE &amp;&amp; (TCNT &gt; One)))
                {
                    TRAP (0x02, 0x1E)
                }
            }
        }

        If ((IVCM == One))
        {
            \_SB.SGOV (0x02040000, Zero)
            \_SB.SGOV (0x02010002, Zero)
        }

        If (CondRefOf (\_SB.TPM.PTS))
        {
            \_SB.TPM.PTS (Arg0)
        }

        EV1 (Arg0, Zero)
    }
</code></pre>
<h2 id="explaining-the-problem-in-this-raw-code">Explaining the problem in this raw code</h2>
<p>After decompiling the tables, I began to trace the <code>_PTS</code> (Prepare To Sleep) method. It acts as a simple dispatcher, calling a sequence of other methods to prepare different hardware components. </p>
<p>Most of these were dead ends: the local <code>PTS</code> method was completely empty, and the methods for the Northbridge (<code>NPTS</code>) and Root Ports (<code>RPTS</code>) were just performing standard state-saving and debug routines. </p>
<p>The logic for the TPM was more interesting, but it only contained specific instructions for hibernate (S4) and shutdown (S5), doing nothing for S3 sleep. None of these were the culprit.</p>
<p>The main problem is about to show up, the Southbridge:</p>
<pre><code>Method (SPTS, 1, NotSerialized)
{
    SLPX = One
    SLPE = One
    If ((Arg0 == 0x03))
    {
        AES3 = One
    }
}
</code></pre>
<p>No, not this one. I&#39;ll show you a pseudocode:</p>
<div><pre><span></span><span>/*</span>
<span>================================================================================</span>
<span> Southbridge_PrepareToSleep: The Buggy Method</span>
<span> </span>
<span> This function is called to give the final &#34;go to sleep&#34; command to the</span>
<span> motherboard&#39;s main power controller, which lives in the Southbridge.</span>
<span>================================================================================</span>
<span>*/</span>
<span>void</span><span> </span><span>Southbridge_PrepareToSleep</span><span>(</span><span>int</span><span> sleep_state) {</span>
<span>    </span><span>// THE CORE LOGICAL ERROR:</span>
<span>    </span><span>// This function needs to perform two steps in order:</span>
<span>    </span><span>//   1. Set the hardware&#39;s &#34;sleep_type_register&#34; to tell it if we want</span>
<span>    </span><span>//      S3 (pause/suspend) or S5 (stop/shutdown).</span>
<span>    </span><span>//   2. Set the &#34;sleep_enable_bit&#34; to tell the hardware to &#34;GO NOW&#34;.</span>
<span>    </span><span>//</span>
<span>    </span><span>// This code completely skips Step 1.</span>

<span>    </span><span>// ----------------- THE ACTUAL BUGGY CODE -----------------</span>

<span>    </span><span>// This line sets a secondary, auxiliary flag. It is NOT the main command</span>
<span>    </span><span>// that tells the hardware which sleep state to enter.</span>
<span>    SOUTHBRIDGE.some_sleep_flag </span><span>=</span><span> </span><span>1</span><span>;         </span><span>// Original ASL: SLPX = One</span>

<span>    </span><span>// THIS IS STEP 2 - THE &#34;GO&#34; BUTTON.</span>
<span>    </span><span>// The code triggers the sleep transition immediately, without having</span>
<span>    </span><span>// set the destination (sleep type) first. This is the root of the bug.</span>
<span>    SOUTHBRIDGE.sleep_enable_bit </span><span>=</span><span> </span><span>1</span><span>;        </span><span>// Original ASL: SLPE = One</span>
<span>    </span>
<span>    </span><span>// This &#39;if&#39; block is the firmware&#39;s broken attempt to handle S3.</span>
<span>    </span><span>// It sets another minor flag but still fails to set the main hardware</span>
<span>    </span><span>// sleep_type_register, so the hardware never gets the primary command.</span>
<span>    </span><span>if</span><span> (sleep_state </span><span>==</span><span> S3_SUSPEND) {</span>
<span>        SOUTHBRIDGE.acpi_s3_enable_flag </span><span>=</span><span> </span><span>1</span><span>; </span><span>// Original ASL: AES3 = One</span>
<span>    }</span>
<span>}</span>
</pre></div>

<blockquote>
<p>This is the only method in the entire sequence that unconditionally writes to what is clearly the main sleep trigger register (SLPE). The other methods are all responsible for saving state or handling their own specific hardware. SPTS is the one that recklessly pushes the &#34;Go&#34; button for the whole system without properly setting up the &#34;Go where?&#34; part first.
</p>
</blockquote>
<p>Let me explain some more.</p>
<p>Assigning SLPE to One literally instructs the motherboard, &#34;Hey buddy, I have taken care of the rest, you can shut down everything else.&#34;</p>
<p><strong>You need to realise that <code>SLPE = One</code> is more like a <code>return</code> statement, except that it instructs the motherboard to shut down. In normal programming terms, don&#39;t put any sort of statements after <code>SLPE = One</code>, all of them will be randomly futile.</strong></p>
<p>To understand the severity of this bug, we need to look at what <code>SLPE = One</code> actually does. The southbridge physically contains the dedicated hardware block that controls the motherboard&#39;s power rails. When you tell the computer to enter S3 sleep, the southbridge&#39;s PMC is what actually cuts power to the CPU, RAM (partially), fans, and other components. The SLPE (Sleep Enable) bit is a direct command to this specific piece of hardware.</p>
<h2 id="s3-deep-sleep-vs-s5-shutdown">S3 (Deep Sleep) vs S5 (Shutdown)</h2>
<p><code>&lt;Edit1&gt;</code></p>
<p><img alt="Waking_and_Sleeping-2.png" src="https://triangulatedexistence.mataroa.blog/images/a3b050c9.png"/></p>
<p>A diagram on the Sleeping States (pretty important here). <a href="https://uefi.org/specs/ACPI/6.5/16_Waking_and_Sleeping.html">Please read this part of the ACPI docs if you want to know more.</a></p>
<p><code>&lt;/Edit1&gt;</code></p>
<p>We know that our _PTS dispatcher method executes like this:</p>
<pre><code>    Method (_PTS, 1, NotSerialized)  // _PTS: Prepare To Sleep
    {
        If (Arg0)
        {
            PTS (Arg0)
            \_SB.TPM.TPTS (Arg0)
            \_SB.PCI0.LPCB.SPTS (Arg0)
            \_SB.PCI0.NPTS (Arg0)
            RPTS (Arg0)
        }
    }
</code></pre>
<p>So, the flow is like this: PTS (Literally an empty method) -&gt; TPTS (TPM) -&gt; SPTS (Southbridge) -&gt; NPTS (Northbridge) -&gt; RPTS (Root Port).</p>
<p>Now, let&#39;s look at our SPTS code.</p>
<pre><code>                Method (SPTS, 1, NotSerialized)
                {
                    SLPX = One
                    SLPE = One
                    If ((Arg0 == 0x03))
                    {
                        AES3 = One
                    }
                }
</code></pre>
<p>Here, S3 isn&#39;t covered. A conditional branch is executed after <code>SLPE = One</code>. It doesn&#39;t make sense to even use that condition after that assignment.</p>
<p>The question arises when you realise that this is the same code running for S5 too: how does my computer even shut down properly then?</p>
<p>Notice the TPTS method:</p>
<pre><code>        Method (TPTS, 1, Serialized)
        {
            Switch (ToInteger (Arg0))
            {
                Case (0x04)
                {
                    RQST = Zero
                    FLAG = 0x09
                    SRSP = Zero
                    SMI = OFST /* \OFST */
                    Return (SRSP) /* \_SB_.TPM_.SRSP */
                }
                Case (0x05)
                {
                    RQST = Zero
                    FLAG = 0x09
                    SRSP = Zero
                    SMI = OFST /* \OFST */
                    Return (SRSP) /* \_SB_.TPM_.SRSP */
                }

            }
        }
</code></pre>
<p>In TPTS, the same statements are written for S4 (Hibernate) and S5 (Shutdown) states. After saving the RAM to the disk, hibernation occurs by shutting everything down. TPTS saves the day. </p>
<p>The TPTS method executes before the buggy SPTS method. As you can see in its code, TPTS has a specific Case for S5 (Shutdown), correctly preparing the hardware.</p>
<p>TPTS is not responsible for S3 sleep (and it doesn&#39;t even need to be responsible in this case).</p>
<h2 id="outro">Outro</h2>
<p>Where there&#39;s garbage, there&#39;s luck. And luck also means pulling the garbage values from the register. That&#39;s exactly what happens every time I try to close the lid of my laptop... it depends on an actual garbage value.</p>
<p>How will I explain all this to the 13-year-old me? How many hours were lost just thinking about this...?</p>
<p>Damn.</p>
<hr/>
<p>Do you know how I feel? </p>
<p>More like <a href="https://xkcd.com/2347/">XKCD 2347</a>.</p>
<p>In the world of AI hype, we DO deserve more tech-reviewers decoding the ACPI tables and ACTUALLY telling us if the system is stable or not. That&#39;s... the only demand from this disillusioned mind.</p>
<p>This was intended to be a technical report, and I rest my sorry case here.</p>
        </div></div>
  </body>
</html>
