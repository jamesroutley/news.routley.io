<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://raganwald.com/2020/05/03/fractran.html">Original</a>
    <h1>John Conway&#39;s FRACTRAN, a ridiculous, yet surprisingly deep language (2020)</h1>
    
    <div id="readability-page-1" class="page"><div id="container">
      <div>

              <!-- end header -->


        <hr/>

        <section id="main_content">

          



  
  

  

  
    
    
  




          

          <p>On April 8, 2020, <a href="https://en.wikipedia.org/wiki/John_Horton_Conway">John Horton Conway</a> developed symptoms of COVID-19. On April 11, 2020, he succumbed to the disease.<sup id="fnref:solveit" role="doc-noteref"><a href="#fn:solveit" rel="footnote">1</a></sup><sup id="fnref:princeton" role="doc-noteref"><a href="#fn:princeton" rel="footnote">2</a></sup><sup id="fnref:guardian" role="doc-noteref"><a href="#fn:guardian" rel="footnote">3</a></sup><sup id="fnref:nyt" role="doc-noteref"><a href="#fn:nyt" rel="footnote">4</a></sup></p>

<p>Like so very, very many, I mourn Conway’s passing, and yet I also celebrate his life. I celebrate his accomplishments, I celebrate his curiosity, and I celebrate his skill at making important topics in mathematics engaging and interesting.</p>

<p>One of the finest examples of that skill is the programming language FRACTRAN, the subject of this essay.</p>

<hr/>

<h2 id="prelude">Prelude</h2>

<hr/>

<p><img src="https://george.mand.is/assets/images/fractran/john-conway-1993.jpg" alt="John Horton Conway in 1993"/></p>

<p><em>John Horton Conway in 1993</em></p>

<hr/>

<p>Conway touched my own life from early days. As I described in <a href="https://raganwald.com/2018/08/03/eight-queens.html">The Eight Queens Problem… and Raganwald’s Unexpected Nostalgia</a>:</p>

<blockquote>
  <p><em>My mother had sent me to a day camp for gifted kids once, and it was organized like a university. The “students” self-selected electives, and I picked one called Whodunnit. It turned out to be a half-day exercise in puzzles and games, and I was hooked.</em></p>
</blockquote>

<p>One of the things we talked about in “Whodunnit” was <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game of Life</a>. I don’t recall playing with it much: There was a lot going on, and it’s entirely possible that I was too busy falling in love with Raymond Smullyan to have curiosity left over for John Conway.<sup id="fnref:HL" role="doc-noteref"><a href="#fn:HL" rel="footnote">5</a></sup><sup id="fnref:TSL" role="doc-noteref"><a href="#fn:TSL" rel="footnote">6</a></sup><sup id="fnref:CoL" role="doc-noteref"><a href="#fn:CoL" rel="footnote">7</a></sup></p>

<hr/>

<p><a href="http://raganwald.com/hashlife/"><img src="https://george.mand.is/assets/images/fractran/hashlife.png" alt="Hashlife"/></a></p>

<p><em><a href="http://raganwald.com/hashlife/">An infinitely scrolling implementation of Conway’s Game of Life</a></em></p>

<hr/>

<p>I went on to rediscover Conway’s Game of Life several times in my life. Some years ago, I read William Poundstone’s <a href="https://www.amazon.com/gp/product/0809252023/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=raganwald001-20&amp;linkId=2676ba561595f3a279e159b2b0be475b&amp;language=en_US">The Recursive Universe: Cosmic Complexity and the Limits of Scientific Knowledge</a>, and it literally blew my mind.</p>

<p>I learned a little about Game Theory. I spotted <a href="https://www.rand.org/pubs/commercial_books/CB149-1.html">Games of Strategy: Theory and Applications</a> in a library and picked it up, thinking it would help my Backgammon.</p>

<p>That led me to Conway’s <a href="https://en.wikipedia.org/wiki/On_Numbers_and_Games">On Numbers and Games</a>, and via parallel paths, to <a href="https://en.wikipedia.org/wiki/Surreal_number">Surreal Numbers</a>. Like the Game of Life, Surreal Numbers keep popping up unexpectedly, reigniting my interest in how the way we represent data, affords or hinders working with that data.</p>

<p>The subject of numbers and representation leads us to <a href="https://en.wikipedia.org/wiki/FRACTRAN">FRACTRAN</a>.<sup id="fnref:elegance" role="doc-noteref"><a href="#fn:elegance" rel="footnote">8</a></sup><sup id="fnref:horton" role="doc-noteref"><a href="#fn:horton" rel="footnote">9</a></sup></p>

<hr/>

<h2 id="table-of-contents">Table of Contents</h2>

<hr/>

<p><a href="https://flickr.com/photos/stewart/99129170"><img src="https://george.mand.is/assets/images/fractran/books.jpg" alt="Books © Stewart Butterfield, 2012, Some Rights Reserved"/></a></p>

<p><em>“Books” © Stewart Butterfield, 2012, Some Rights Reserved</em></p>

<hr/>

<p><a href="#prelude">Prelude</a></p>

<p><a href="#fractran">FRACTRAN</a></p>

<ul>
  <li><a href="#our-first-fractran-program">our first fractran program</a></li>
  <li><a href="#writing-a-fractran-based-fibonacci-function-in-javascript">writing a fractran-based fibonacci function in javascript</a></li>
</ul>

<p><a href="#marvin-minsky&#39;s-magnificent-machines">Marvin Minsky’s Magnificent Machines</a></p>

<ul>
  <li><a href="#magnificent-minsky-machines">magnificent minsky machines</a></li>
  <li><a href="#creating-a-magnificent-minsky-machine">creating a magnificent minsky machine</a></li>
  <li><a href="#a-notation-for-magnificent-minsky-machines">a notation for magnificent minsky machines</a></li>
  <li><a href="#the-magnificent-minsky-multiplication-machine">the magnificent minsky multiplication machine</a></li>
  <li><a href="#implementing-magnificent-minsky-machines">implementing magnificent minsky machines</a></li>
</ul>

<p><a href="#marvellous-minsky-machines">Marvellous Minsky Machines</a></p>

<ul>
  <li><a href="#an-algorithm-to-derive-a-marvellous-minsky-machine-from-any-magnificent-minsky-machine">an algorithm to derive a marvellous minsky machine from any magnificent minsky machine</a></li>
</ul>

<p><a href="#gödel-numbering-and-masterful-minsky-machines">Gödel Numbering and Masterful Minsky Machines</a></p>

<ul>
  <li><a href="#register-machines">register machines</a></li>
  <li><a href="#encoding-state-with-prime-factorization">encoding state with prime factorization</a></li>
  <li><a href="#the-masterful-minsky-machine">the masterful minsky machine</a></li>
</ul>

<p><a href="#on-equivalence">On Equivalence</a></p>

<ul>
  <li><a href="#fractran-and-marvellous-minsky-machines">fractran and marvellous minsky machines</a></li>
  <li><a href="#polygame">polygame</a></li>
</ul>

<p><a href="#the-collatz-conjecture">The Collatz Conjecture</a></p>

<ul>
  <li><a href="#why-fractran-really-matters">why fractran really matters</a></li>
</ul>

<p><a href="#addenda">Addenda</a></p>

<ul>
  <li><a href="#conways-fractran-a-ridiculous-logical-language-lecture">conway’s “fractran: a ridiculous logical language” lecture</a></li>
  <li><a href="#norman-wildbergers-lecture-on-the-collatz-conjecture">norman wildberger’s lecture on the collatz conjecture</a></li>
  <li><a href="#vikram-ramanathan-on-fractran">vikram ramanathan on fractran</a></li>
  <li><a href="#notes">notes</a></li>
</ul>

<hr/>

<h2 id="fractran">FRACTRAN</h2>

<hr/>

<p><a href="https://en.wikipedia.org/wiki/FRACTRAN"><img src="https://george.mand.is/assets/images/fractran/fractran-star-qualities.png" alt="Only FRACTRAN has these star qualities"/></a></p>

<p><em>A fragment of John Horton Conway’s paper on FRACTRAN</em></p>

<hr/>

<p>In 1987, Conway contributed <em>FRACTRAN: A SIMPLE UNIVERSAL PROGRAMMING LANGUAGE FOR ARITHMETIC</em> to a special workshop on problems in communication and computation conducted in the summers of 1984 and 1985 in Morristown, New Jersey, and the summer of 1986 in Palo Alto. California.</p>

<p>FRACTRAN itself was not an important open problem in the field, but as the editors noted:</p>

<blockquote>
  <p><em>Perhaps the most entertaining of all the contributions is Conway’s fascinating article on FRACTRAN, a strange collection of numbers, which when operated on in a simple way, yield all possible computations. We begin with his article.</em></p>
</blockquote>

<p>–Thomas M. Cover &amp; B. Gotinath, “Open Problems in Communication &amp; Computation”<sup id="fnref:scihub" role="doc-noteref"><a href="#fn:scihub" rel="footnote">10</a></sup></p>

<h3 id="our-first-fractran-program">our first fractran program</h3>

<p>As Wikipedia notes, a FRACTRAN program is an ordered list of positive fractions together with an initial positive integer input <em>n</em>. The program is run by updating the integer <em>n</em> as follows:</p>

<ol>
  <li>for the first fraction <em>f</em> in the list for which <em>nf</em> is an integer, replace <em>n</em> by <em>nf</em></li>
  <li>repeat this rule until no fraction in the list produces an integer when multiplied by <em>n</em>, then halt.</li>
</ol>

<p>For example, this is a FRACTRAN program for computing any Fibonacci number: <code>17/65</code>, <code>133/34</code>, <code>17/19</code>, <code>23/17</code>, <code>2233/69</code>, <code>23/29</code>, <code>31/23</code>, <code>74/341</code>, <code>31/37</code>, <code>41/31</code>, <code>129/287</code>, <code>41/43</code>, <code>13/41</code>, <code>1/13</code>, <code>1/3</code>.<sup id="fnref:snark" role="doc-noteref"><a href="#fn:snark" rel="footnote">11</a></sup></p>

<p>All FRACTRAN programs also start with an initial value for <em>n</em>. That value is sometimes a constant, and sometimes provided by the user. When it’s provided by the user, there is sometimes a need to prepare <em>n</em> to make it usable.</p>

<p>In this program’s case, to compute <code>fib(x)</code> for some value of <em>x</em>, we compute <code>n = 78 * 5^(x - 1)</code>.</p>

<p>Let’s use this program to compute <code>fib(7)</code>. We start with <code>n = 78 * 5^(7-1)</code>, which is <strong>1,218,750</strong>. We’ll follow along for a while to get the feel for what happens:<sup id="fnref:debug-fib" role="doc-noteref"><a href="#fn:debug-fib" rel="footnote">12</a></sup></p>

<ul>
  <li>The first fraction in the program is 17/65. 1,218,750 multiplied by 17/65 is 318,750, so we replace 1,218,750 with 318,750 and begin again.</li>
  <li>The first fraction in the program is 17/65. 318,750 leaves a remainder when divided by 65, so we move on.</li>
  <li>The next fraction in the program is 133/34. 318,750 multiplied by 133/34 is 1,246,875, so we replace 318,750 with 1,246,875 and begin again.</li>
</ul>

<p>We leave it to run for a very long time, and then we see:</p>

<ul>
  <li>The next fraction in the program is 13/41. 24,576 leaves a remainder when divided by 41, so we move on.</li>
  <li>The next fraction in the program is 1/13. 24,576 leaves a remainder when divided by 13, so we move on.</li>
  <li>The next fraction in the program is 1/3. 24,576 multiplied by 1/3 is 8,192, so we replace 24,576 with 8,192 and begin again.</li>
</ul>

<p>8,192 is an important number, because <em>none</em> of the divisors divide evenly into 8,192. So we see</p>

<ul>
  <li>The first fraction in the program is 17/65. 8,192 leaves a remainder when divided by 65, so we move on.</li>
  <li>The next fraction in the program is 133/34. 8,192 leaves a remainder when divided by 34, so we move on.</li>
  <li>The next fraction in the program is 17/19. 8,192 leaves a remainder when divided by 19, so we move on.</li>
</ul>

<p>…</p>

<ul>
  <li>The next fraction in the program is 13/41. 8,192 leaves a remainder when divided by 41, so we move on.</li>
  <li>The next fraction in the program is 1/13. 8,192 leaves a remainder when divided by 13, so we move on.</li>
  <li>The next fraction in the program is 1/3. 8,192 leaves a remainder when divided by 3, so we move on. None of the demoninators in the program divide evenly into 8,192, so the program halts.</li>
</ul>

<p>All FRACTRAN programs produce a series of values for <em>n</em>, and the result we want must be extracted from them. For our Fibonacci program, the values begin with <code>1,218,750</code>, <code>318,750</code>, <code>1,246,875</code>, and <code>1,115,625</code>, and then end with <code>221,184</code>, <code>73,728</code>, <code>24,576</code>, and <code>8,192</code>.<sup id="fnref:n-fib" role="doc-noteref"><a href="#fn:n-fib" rel="footnote">13</a></sup></p>

<p>In the case of Fibonacci, the result we want is the <code>log2</code> of the last value for <em>n</em>. The last value of <em>n</em> is 8,192, and <code>log2(8,192)</code> is <strong>13</strong>, the answer we want. The 7th Fibonacci number is 13.</p>

<p>We have now seen the three elements that every FRACTRAN program has:</p>

<ol>
  <li>The program itself, a finite list of fractions. This program’s list is <code>17/65</code>, <code>133/34</code>, <code>17/19</code>, <code>23/17</code>, <code>2233/69</code>, <code>23/29</code>, <code>31/23</code>, <code>74/341</code>, <code>31/37</code>, <code>41/31</code>, <code>129/287</code>, <code>41/43</code>, <code>13/41</code>, <code>1/13</code>, and <code>1/3</code>.</li>
  <li>An initial value of <em>n</em>. This may be a constant, it may be a user-supplied value, or it may be a transformation of a user-defined value. This program’s transformation can be expressed in JavaScript as <code>n =&gt; 78 * Math.pow(5, n-1)</code>.</li>
  <li>A transformation from the values of <em>n</em> into the result we want, encoded the way we want it. In our case, it is something like <code>values =&gt; Math.log2(last(values))</code> .</li>
</ol>

<h3 id="writing-a-fractran-based-fibonacci-function-in-javascript">writing a fractran-based fibonacci function in javascript</h3>

<p>Writing a FRACTRAN interpreter is very easy. Let’s begin by writing a JavaScript Fibonacci function that uses our FRACTRAN program for its implementation. The main thing we’ll need to watch out for is that that values of <em>n</em> can grow very, very large, so we will want to use big integers, aka “BigInts.”<sup id="fnref:bigint" role="doc-noteref"><a href="#fn:bigint" rel="footnote">14</a></sup></p>

<p>One consequence of working with big integers is that many of the things we depend on for numbers no longer work. For example, <code>Math.log2(8192) =&gt; 13</code>, but <code>Math.log2(8192n) =&gt; TypeError: Cannot convert a BigInt value to a number</code>. We’ll have to write our own <code>log2</code> function.</p>

<p>The same goes for <code>Math.pow</code>, we’ll have to write our own. Feel free to use these implementations if you like:<sup id="fnref:github" role="doc-noteref"><a href="#fn:github" rel="footnote">15</a></sup></p>

<div><div><pre><code><span>// Any sufficiently complicated function that loops, contains an ad hoc,</span>
<span>// informally-specified, bug-ridden, slow implementation of</span>
<span>// half of Linear Recursion</span>
<span>const</span> <span>log2</span> <span>=</span> <span>(</span><span>n</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> <span>result</span> <span>=</span> <span>0</span><span>n</span><span>;</span>

  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>// degenerate condition</span>
    <span>if</span> <span>(</span><span>n</span> <span>===</span> <span>1</span><span>n</span><span>)</span> <span>break</span><span>;</span>

    <span>// termination conditions</span>
    <span>if</span> <span>(</span><span>n</span> <span>%</span> <span>2</span><span>n</span> <span>===</span> <span>1</span><span>n</span><span>)</span> <span>return</span><span>;</span>
    <span>if</span> <span>(</span><span>n</span> <span>&lt;</span> <span>1</span><span>n</span><span>)</span> <span>return</span><span>;</span>

    <span>//divide and conquer</span>
    <span>++</span><span>result</span><span>;</span>
    <span>n</span> <span>=</span> <span>n</span> <span>/</span> <span>2</span><span>n</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>result</span><span>;</span>
<span>}</span>

<span>const</span> <span>pow</span> <span>=</span> <span>(</span><span>base</span><span>,</span> <span>exponent</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>exponent</span> <span>&lt;</span> <span>0</span><span>n</span><span>)</span> <span>return</span><span>;</span>

  <span>let</span> <span>result</span> <span>=</span> <span>1</span><span>n</span><span>;</span>

  <span>while</span> <span>(</span><span>exponent</span><span>--</span> <span>&gt;</span> <span>0</span><span>n</span><span>)</span> <span>result</span> <span>=</span> <span>result</span> <span>*</span> <span>base</span><span>;</span>

  <span>return</span> <span>result</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Now go ahead and write your own implementation. Ignore the code below until you’ve written your own.</p>

<div><div><pre><code><span>// uses log2 and pow from above to formulate the seed and decipher the result</span>

<span>const</span> <span>fib</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>program</span> <span>=</span> <span>(</span>
    <span>&#39;</span><span>17/65, 133/34, 17/19, 23/17, 2233/69, 23/29, 31/23, 74/341,</span><span>&#39;</span> <span>+</span>
    <span>&#39;</span><span> 31/37, 41/31, 129/287, 41/43, 13/41, 1/13, 1/3</span><span>&#39;</span>
  <span>).</span><span>split</span><span>(</span><span>/</span><span>(?:\s</span><span>*,|</span><span>\s)\s</span><span>*/</span><span>).</span><span>map</span><span>(</span><span>f</span> <span>=&gt;</span> <span>f</span><span>.</span><span>split</span><span>(</span><span>&#39;</span><span>/</span><span>&#39;</span><span>).</span><span>map</span><span>(</span><span>n</span> <span>=&gt;</span> <span>BigInt</span><span>(</span><span>n</span><span>)));</span>

  <span>let</span> <span>n</span> <span>=</span> <span>78</span><span>n</span> <span>*</span> <span>pow</span><span>(</span><span>5</span><span>n</span><span>,</span> <span>BigInt</span><span>(</span><span>x</span><span>)</span> <span>-</span> <span>1</span><span>n</span><span>);</span>

  <span>program_start</span><span>:</span> <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>[</span><span>numerator</span><span>,</span> <span>denominator</span><span>]</span> <span>of</span> <span>program</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>n</span> <span>%</span> <span>denominator</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>{</span>
        <span>n</span> <span>=</span> <span>(</span><span>n</span> <span>*</span> <span>numerator</span><span>)</span> <span>/</span> <span>denominator</span><span>;</span>
        <span>continue</span> <span>program_start</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>break</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>log2</span><span>(</span><span>n</span><span>);</span>
<span>};</span>

<span>fib</span><span>(</span><span>7</span><span>)</span>
  <span>//=&gt; 13</span>
</code></pre></div></div>

<p>This is very cool. The FRACTRAN program is very small and ridiculously simple: It’s just fractions. And the central FRACTRAN interpreter is also very small: It’s literally a <code>for</code> loop inside a <code>while</code> loop, and the <code>while</code> loop (along with a <code>break</code> statement) could have been avoided if JavaScript supported <code>GOTO</code>.<sup id="fnref:chch" role="doc-noteref"><a href="#fn:chch" rel="footnote">16</a></sup></p>

<p>For all its apparent elegance, FRACTRAN appears at first glance to be inscrutable. Is it one of those languages that is neither good for reading nor writing? Or is there a method to the madness of writing a program by composing a list of fractions?</p>

<p>To answer this question, we must first consider the work of another great mind no longer with us, <a href="http://web.media.mit.edu/~minsky/">Marvin Minsky</a>.</p>

<hr/>

<h2 id="marvin-minskys-magnificent-machines">Marvin Minsky’s Magnificent Machines</h2>

<hr/>

<p><a href="http://web.media.mit.edu/~minsky/"><img src="https://george.mand.is/assets/images/fractran/marvin-minsky.jpg" alt="Marvin Minsky"/></a></p>

<p><em>Marvin Minsky posing with one of MIT’s demonstrations of Robotics and AI</em></p>

<hr/>

<p>In September of 1987, <a href="http://sb.longnow.org/">Stewart Brand</a> published <a href="https://www.amazon.com/Media-Lab-Inventing-Future-M-I-T/dp/0670814423/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=raganwald001-20&amp;linkId=e5653e0666603d4426dc84ed2719d0a8&amp;language=en_US">The Media Lab: Inventing the Future at M.I.T.</a>. To say that the book affected me does not do its impact justice. Like many business and technical hagiographies, it was breathless in its admiration for what M.I.T.–and director Nicholas Negroponte–were trying to do.</p>

<p>It was also highly revealing: Brand described in detail how the Media Lab was funded by its corporate sponsors, and how the funding model drove research. Their motto was, “Demo or Die,” which meant that the money went to the people who could not only wow their peers, but also provide the stage-magic that would open the wallets of their corporate sponsors.</p>

<p>I was working in technology Enterprise Sales at the time, and keenly understood that while it’s really difficult to sell sizzle without steak, it’s equally improbable to secure the sale when you have perfectly good steak, but no sizzle.<sup id="fnref:gatekeepers" role="doc-noteref"><a href="#fn:gatekeepers" rel="footnote">17</a></sup></p>

<p>One of the figures mentioned in The Media Lab was <a href="http://web.media.mit.edu/~minsky/">Marvin Minsky</a>. Minsky was considered a giant in Artificial Intelligence, and Artificial Intelligence was the <a href="https://en.wikipedia.org/wiki/Tulip_mania">tulip mania</a> of the day. History would show that as the book was released, AI funding was starting another of its cyclical collapses, but as I read the book, the magazines and book shelves were groaning under the weight of breathless prose and utopian visions.</p>

<hr/>

<iframe width="560" height="315" src="https://www.youtube.com/embed/-Hx8RixhoOM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<hr/>

<p>In 1985, Minsky had published <a href="https://www.amazon.com/exec/obidos/ISBN=0671657135/marvinminskyA/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=raganwald001-20&amp;linkId=cbacf6f35f9fee30f018335fa1518663&amp;language=en_US">The Society of Mind</a>, and I bought it on the strength of reading about Minsky in The Media Lab. In 1994, a company called Voyager published a <a href="http://web.media.mit.edu/~minsky/Voyager.html">CD-ROM version of The Society of Mind</a> that I “played” using one of Apple’s quirkier products, a CD-ROM reader and audio-CD player they borrowed from Phillips and branded as <a href="https://en.wikipedia.org/wiki/PowerCD">PowerCD</a>.</p>

<p>One of the features of the CD-ROM was an interactive tour of Minsky’s office. I still vividly recall his discussion of a mirror he had hanging on the wall, and his mention that Feynman had written an <a href="https://en.wikipedia.org/wiki/QED:_The_Strange_Theory_of_Light_and_Matter" title="QED: The Strange Theory of Light and Matter">entire book</a> devoted to explaining just one thing: How light <strong>actually</strong> reflects off a mirror, and that in this book, he explains why all of the things non-specialists believe about light and reflection are actually false.</p>

<p>Like Feynman and Conway, Minsky had a talent for explaining challenging ideas. And also like Feynman and Conway, he had made enormous contributions to the progress of human knowledge. One of his areas of research was in computability, and specifically, the study of a certain class of idealized computing machines that are now named <em>Minsky Machines</em> in his honour.<sup id="fnref:mm-esolang" role="doc-noteref"><a href="#fn:mm-esolang" rel="footnote">18</a></sup><sup id="fnref:mm-wiki" role="doc-noteref"><a href="#fn:mm-wiki" rel="footnote">19</a></sup></p>

<h3 id="magnificent-minsky-machines">magnificent minsky machines</h3>

<p>A <em>Minsky Machine</em> is an idealized machine that has been proven to be computationally universal. Minsky Machines are part of the family of idealized machines called <a href="https://en.wikipedia.org/wiki/Register_machine">Register Machines</a>.</p>

<p>Like Register Machines and Turing Machines, Minsky machines form a little family, with slight differences between them in the way they are imagined, but all are computationally equivalent. We shall discuss one particularly simple form of Minsky Machine that we shall call the “Magnificent” Minsky Machine.<sup id="fnref:term-of-art" role="doc-noteref"><a href="#fn:term-of-art" rel="footnote">20</a></sup></p>

<p>Like a <a href="https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html" title="What is a Turing Machine?">Turing Machine</a>, a Magnificent Minsky Machine has a finite number of states. However, instead of having a single tape that stretches to infinity in one or both directions, Magnificent Minsky Machines have a finite number of tapes, each of which stretches to infinity in only one direction.</p>

<p>Like a Turing Machine, a Magnificent Minsky Machine has a tape-head for each tape, and based on its instructions, can move its tape-heads and change to a different state. Unlike a Turing Machine, a Magnificent Minsky Machine can move its tape-heads any finite amount in either direction. We call these directions forward (“away from the beginning”), and backwards (“towards the beginning”).</p>

<p>When a Turing Machine matches a particular symbol under its tape-head, it can write a symbol, and it can also move the tape-head one square in either direction.</p>

<p>Unlike a Turing Machine, a Magnificent Minsky Machine cannot write anything on its tapes, and therefore, does not match anything under its tape-heads. What it can do is test whether it is possible to perform a move. Since it is always possible to move forward, the only test we care about is whether a move backwards is possible.</p>

<p>Also unlike a Turing Machine, a Magnificent Minsky Machine can move zero <em>or more</em> of its tape-heads at the same time. Therefore, its test may check whether one or more tape-heads can be moved backwards.</p>

<p>To give a literal example, if the tape-head is at the beginning, no backwards move is possible. If the tape-head is <em>n</em> squares forward, all moves backwards &lt;= <em>n</em> squares are possible, but all moves &gt; <em>n</em> squares are not possible.</p>

<p>The net effect of these design choices is that a Magnificent Minsky Machine can store an arbitrary amount of state, just like a Turing Machine, but it stores that state by having each tape-head be an arbitrary distance from the beginning of its tape.<sup id="fnref:spiders" role="doc-noteref"><a href="#fn:spiders" rel="footnote">21</a></sup></p>

<hr/>

<p><img src="https://george.mand.is/assets/images/fractran/multi-tape.jpeg" alt="Multi Tape"/></p>

<p><em>An illustration of a multi-tape machine.</em></p>

<hr/>

<h3 id="creating-a-magnificent-minsky-machine">creating a magnificent minsky machine</h3>

<p>Let’s write a program using a Magnificent Minsky Machine. Now that we have the general idea of how these machines operate, here is how we will specify each Magnificent Minsky Machine, i.e. How we shall write its “program:”</p>

<ol>
  <li>Our machine will have a finte number of states, denoted with consecutive positive integers, i.e. 1, 2, 3, …</li>
  <li>Each state will have an finite and ordered list of rules.</li>
  <li>Each rule will be expressed as “Do this, provided that.” Thus, they will have two clauses: An <em>action clause</em>, and a <em>guard clause</em>.</li>
  <li>The action clause shall consist of a set of tape-heads to move forward, and a positive integer for each tape-head stating how many squares to move. We shall note these as tuples of <code>(tape-identifier^squares-to-move-forward)</code>. The action clause is an unordered set of such tuples, with no two tuples in the same rule sharing the same tape-head. The action clause will also include a positive integer indicating the next state to enter.</li>
  <li>The guard clause shall consist of a set of tape-heads to move backwards, and a positive integer stating how many squares to move towards the beginning. As with the action clause, no two guard clauses in the same rule can share the same tape-head.</li>
  <li>Because no two clauses in the same rule can share the same tape-head, it follows that no one rule can both test a tape-head in the guard clause and simultaneously move a tape-head in the action clause.</li>
</ol>

<p>Our Magnificent Minsky Machine is initialized with the tape-heads being placed in a specific set of positions, so in addition to listing the states and rules therein, the description of a Magnificent Minsky Machine will also include instructions for setting up the initial position of the tape-heads.</p>

<p>When we wish to run a Magnificent Minsky Machine, we start it in state 1. We operate our machine by scanning the rules within the current state, in order.</p>

<p>For each rule, we check its guard clause. If it is possible to move all of the tape-heads in the guard clause towards the beginning, the rule “fires,” and we move the tape-heads towards the beginning as specified by the guard clause. We then consult the action clause, and move all of the tape-heads listed away from the end by the amounts listed. Finally, when a rule fires, if it lists a next state, we change to that state and return to scanning the rules within the current state, in order.</p>

<p>If any rule’s guard clause cannot perform <strong>all</strong> of the required movement of tape-heads towards the beginning, the rule fails, and the tape-heads are not disturbed. We then move on and try the next rule in that state’s list, and the next, and so forth. If all of the rules in the current state fail, the machine halts. It follows, trivially, that if the machine enters a state without any rules, it must necessarily halt.</p>

<p>If the machine attempts to transition to an undefined state, it also halts. An explicit transition to state 0, therefore, is the well-formed way to explicitly halt the machine.</p>

<p>Now we’re ready to discuss a simple notation for Magnificent Minsky Machines, and to try one out.</p>

<h3 id="a-notation-for-magnificent-minsky-machines">a notation for magnificent minsky machines</h3>

<p>Consider a Magnificent Minsky Machine that will add two numbers. We will only need one state, with two rules. Our notation will be simple. In each state, there is a comma-separated list of rules. Since we will only have one state in our first machine, we will only discuss how to write down the rules right now.</p>

<p>Our state will have a comma-sparated list of rules, i.e. <code>rule1, rule2</code>. Whitespace is not significant, so we could also write <code>rule1,rule2</code> or even:</p>



<p>(As is usual with most programming languages, how we arrange our program with whitespace is a matter of organizing the layout for human readability.)</p>

<p>Each rule willl have an action clause and a guard clause, separated with <code>/</code>, e.g.:</p>

<div><div><pre><code>actionClause1/guardClause1,
actionClause2/guardClause2
</code></pre></div></div>

<p>The <code>/</code> obviously resembles the notation for division, but in a Magnificent Minsky Machine, it doesn’t actually mean “divide,” it just separates the action clause from the guard clause in each rule.</p>

<p>The action clauses and guard clauses both have exactly the same notation: One or more tuples of the form <code>(t^s)</code>, where <code>t</code> identifies the tape-head, and <code>s</code> identifies the number of squares to move. The <code>^</code> character means exponentiation in some programming langauges, but in a Magnificent Minsky Machine, it’s just a way of separating two numbers.</p>

<p>Thus, <code>(1^1)(4^1)/(3^1)</code> is a rule with two clauses:</p>

<ul>
  <li><code>(1^1)(4^1)</code> is the action clause, and it has two tuples: <code>(1^1)</code> says to move tape-head 1 by one squre, and <code>(4^1)</code> says to move tape-head 4 by one square.</li>
  <li><code>(3^1)</code> is the guard clause, and it says to move tape-head 3 by one square.</li>
</ul>

<p>In a Magnificent Minsky Machine, action clauses always move the tape-heads forward, and guard clauses always move the tapehead backwards, so we don’t need to have our clauses use a <code>+</code> or <code>-</code>, or arrows pointing in different directions, it is enough to know that clauses to the left of the <code>/</code> are action clauses and move the tape-heads forward, while clauses to the right of the <code>/</code> are guard clauses, and move the tape-heads backwards.</p>

<p>Now to our first machine: Our machine only has one state, <code>1</code>, and it has two rules:</p>



<p>Our program adds two numbers positive numbers, which we shall call <code>a</code> and <code>b</code>. It has three tapes, 1, 2, and 3. To set the machine up, we place tape-head 1 at the beginning of its tape, tape-head 2 <code>a</code> squares forward, and we place tape-head 3 <code>b</code> squares forward. When the machine halts, tape-head 1 will be <code>a + b</code> squares forward, while tape-heads 2 and 3 will be at the beginning.</p>

<p>We can use it to add the numbers 2+2, and we’ll see if it comes up with 4. Here’s how we’ll show the position of the tape-heads graphically:<sup id="fnref:graphically" role="doc-noteref"><a href="#fn:graphically" rel="footnote">22</a></sup></p>



<p>This shows that tape-head 1 is at the beginning, while tape-heads 2 and 3 are two squares forward, the beginning conditions for adding 2 and 2.</p>

<p>Our machine begins in state 1 (it’s the only state this machine has). The first rule is <code>(1^1)/(2^1)</code>. It checks to see if tape-head 2 can move one square towards the beginning. It can, therefore it also executes the action of moving tape-head 1 one square away from the beginning. It states in state 1, and now the tape-head positions are:</p>



<p>Once again, it consults its rules, and the first rule fires again, producing:</p>



<p>The third time through, rule 1 fails to fire because its guard clause <code>(2^1)</code> fails. It remains in its only state, and checks the second rule, <code>(1^1)/(3^1)</code>. Tape-head 3 can be moved one square towards the beginning, and it does so while moving tape-head 1 away from the beginning:</p>



<p>Once again, it consults its rules, and the second rule fires again, producing:</p>



<p>The last time through, neither rule can fire, because neither tape-head 2 or tape-head 3 can move one square towards the beginning, so the machine halts. As we desired, tape-head 1 is now four squares forward of the beginning, so our machine has added 2 and 2 to produce 4.</p>

<h3 id="the-magnificent-minsky-multiplication-machine">the magnificent minsky multiplication machine</h3>

<p>Now we’ll write a Magnificient Minsky Machine that multiplies two numbers using our notation. We will use more than one state, so we separate states with <code>;</code>, and show a transition to a different state with <code>→</code>.</p>

<p>Our states will be numbered from 1, in the order we list them. With this scheme, our multiplication machine can be written as:</p>

<div><div><pre><code>(1^0)/(2^1)→2,    (1^0)/(3^1)   ;
(1^1)(4^1)/(3^1), (1^0)/(1^0)→3 ;
(3^1)/(4^1),      (1^0)/(1^0)→1
</code></pre></div></div>

<p>Or even:</p>

<div><div><pre><code>(1^0)/(2^1)→2,
(1^0)/(3^1);

(1^1)(4^1)/(3^1),
(1^0)/(1^0)→3;

(3^1)/(4^1),
(1^0)/(1^0)→1
</code></pre></div></div>

<p>As with the addition machine, we give it three tapes: A result tape that must be empty, and two multiplicand tapes, with the tape-head advanced by the value of the multiplicand. We also supply a fourth tape to use as a temporary variable. Thus, to multiply 3 and 39, we set the machine’s tapes to <code>0, 3, 39, 0</code>.</p>

<p>The operation of the machine is easy to describe at a high level. There’s one idiom that we first introduce: <code>(1^0)</code> is a <code>NOOP</code> clause. If used as a guard clause, it always succeeds because every tape-head is always in a position where it can move zero squares backwards. And if used as an action clause, it does nothing because it moves the tape-head zero squares forward. And a clause like <code>(1^0)/(0^1)→1</code> is a Magnificient Minsky Machine’s way of writing <code>GOTO</code>: It always succeeds, doesn’t move any tape-heads, and changes to state <code>1</code>.</p>

<p>The initial state (<code>1</code>) has two rules:</p>

<ol>
  <li><code>(1^0)/(2^1)→2</code>, which decrements tape 2 and then changes to state 2, followed by;</li>
  <li><code>(1^0)/(3^1)</code>, which decrements tape 3 and remains in state 1.</li>
</ol>

<p>The net effect of these two rules is that whenever the machine is in state 1, it tries to decrement tape 2 and move to state 2. If that fails, it tries to decrement tape 3 and remain in state 1. When it decrements tape 3 and remains in state 1, it clearly will do it again, and again, and again until it can decrement state 3 no more, at which point it will fail both of its rules, and halt.</p>

<p>The second state’s two rules are:</p>

<ol>
  <li><code>(1^1)(4^1)/(3^1)</code>, which increments tapes 1 and 4, decrements tape 3, and stays in state 2, followed by;</li>
  <li><code>(1^0)/(1^0)→3</code> which is a simple <code>GOTO 3</code>.</li>
</ol>

<p>The net effect of state 2’s rules is simply to add the value of tape 3 to whatever is in tape 1, while simultaneously making a copy of tape 3 in tape 4 (because in our Magnificient Minsky Machines, successfully reading a value also consumes that value).</p>

<p>The third states two rules are:</p>

<ol>
  <li><code>(3^1)/(4^1)</code>, which copies tape 3’s original value back to tape 3 from tape 4, followed by;</li>
  <li><code>(1^0)/(1^0)→1</code> which is a simple <code>GOTO 1</code>.</li>
</ol>

<p>The net effect of the third rule is to restore tape 3. Since this machine copies the value of tape 3 to tape 1 once for every square of tape 2, the net effect is to multiply tapes 2 and 3.</p>

<h3 id="implementing-magnificent-minsky-machines">implementing magnificent minsky machines</h3>

<p>Manually simulating ideal computing machines loses its lustre once you’ve manually verified that <code>3 * 13 = 39</code>. Without peeking ahead, try writing an interpreter that can parse our notation and output the result.</p>

<p>For example, we’d like to write:</p>

<div><div><pre><code><span>const</span> <span>evaluate</span> <span>=</span> <span>(</span><span>program</span><span>,</span> <span>...</span><span>tapes</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>};</span>

<span>evaluate</span><span>(</span>
  <span>&#39;</span><span>(1^1)/(2^1), (1^1)/(3^1)</span><span>&#39;</span><span>,</span>
  <span>0</span><span>,</span> <span>2</span><span>,</span> <span>3</span>
<span>)</span>
  <span>//=&gt; [5, 0, 0]</span>

<span>evaluate</span><span>(</span><span>`
  (1^0)/(2^1)→2,    (1^0)/(3^1)   ;
  (1^1)(4^1)/(3^1), (1^0)/(1^0)→3 ;
  (3^1)/(4^1),      (1^0)/(1^0)→1
  `</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>,</span> <span>13</span><span>,</span> <span>0</span>
<span>)</span>
  <span>//=&gt; [39, 0, 0, 0]</span>
</code></pre></div></div>

<p>No peeking until you’ve tried it yourself!</p>

<div><div><pre><code><span>const</span> <span>parse</span> <span>=</span> <span>(</span><span>program</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>parseProgram</span> <span>=</span> <span>program</span> <span>=&gt;</span> <span>program</span><span>.</span><span>split</span><span>(</span><span>/</span><span>\s</span><span>*;</span><span>\s</span><span>*/</span><span>).</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>s</span><span>.</span><span>trim</span><span>());</span>
  <span>const</span> <span>parseState</span> <span>=</span> <span>state</span> <span>=&gt;</span> <span>state</span><span>.</span><span>split</span><span>(</span><span>/</span><span>(?:\s</span><span>*,|</span><span>\s)\s</span><span>*/</span><span>).</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>s</span><span>.</span><span>trim</span><span>());</span>
  <span>const</span> <span>parseRule</span> <span>=</span> <span>(</span><span>rule</span><span>,</span> <span>stateIndex</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>[</span><span>clauses</span><span>,</span> <span>nextState</span><span>]</span> <span>=</span> <span>rule</span><span>.</span><span>includes</span><span>(</span><span>&#39;</span><span>→</span><span>&#39;</span><span>)</span> <span>?</span> <span>rule</span><span>.</span><span>split</span><span>(</span><span>/</span><span>\s</span><span>*→</span><span>\s</span><span>*/</span><span>).</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>s</span><span>.</span><span>trim</span><span>())</span> <span>:</span> <span>[</span><span>rule</span><span>.</span><span>trim</span><span>(),</span> <span>stateIndex</span> <span>+</span> <span>1</span><span>]</span>

    <span>return</span> <span>[</span><span>clauses</span><span>,</span> <span>typeof</span> <span>nextState</span> <span>===</span> <span>&#39;</span><span>string</span><span>&#39;</span> <span>?</span> <span>parseInt</span><span>(</span><span>nextState</span><span>,</span> <span>10</span><span>)</span> <span>:</span> <span>nextState</span><span>];</span>
  <span>};</span>
  <span>const</span> <span>parseClauses</span> <span>=</span> <span>clauses</span> <span>=&gt;</span> <span>clauses</span><span>.</span><span>split</span><span>(</span><span>&#39;</span><span>/</span><span>&#39;</span><span>).</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>s</span><span>.</span><span>trim</span><span>());</span>
  <span>const</span> <span>parseClause</span> <span>=</span> <span>clause</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>clause</span> <span>===</span> <span>&#39;&#39;</span><span>)</span> <span>return</span> <span>[];</span>

    <span>const</span> <span>strippedClause</span> <span>=</span> <span>clause</span><span>.</span><span>substring</span><span>(</span><span>1</span><span>,</span> <span>clause</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>);</span> <span>// strip opening and closing ()</span>
    <span>const</span> <span>pairs</span> <span>=</span> <span>strippedClause</span><span>.</span><span>split</span><span>(</span><span>/</span><span>\)\s</span><span>*</span><span>\(</span><span>/</span><span>).</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>s</span><span>.</span><span>trim</span><span>());</span>

    <span>return</span> <span>pairs</span><span>.</span><span>map</span><span>(</span><span>p</span> <span>=&gt;</span> <span>p</span><span>.</span><span>split</span><span>(</span><span>/</span><span>\s</span><span>*</span><span>\^\s</span><span>*/</span><span>).</span><span>map</span><span>(</span><span>s</span> <span>=&gt;</span> <span>parseInt</span><span>(</span><span>s</span><span>,</span> <span>10</span><span>)));</span>
  <span>};</span>

  <span>return</span> <span>[[]].</span><span>concat</span><span>(</span>
    <span>parseProgram</span><span>(</span><span>program</span><span>).</span><span>map</span><span>(</span>
      <span>(</span><span>state</span><span>,</span> <span>stateIndex</span><span>)</span> <span>=&gt;</span> <span>parseState</span><span>(</span><span>state</span><span>).</span><span>map</span><span>(</span>
        <span>rule</span> <span>=&gt;</span> <span>{</span>
          <span>const</span> <span>[</span><span>_clauses</span><span>,</span> <span>nextState</span><span>]</span> <span>=</span> <span>parseRule</span><span>(</span><span>rule</span><span>,</span> <span>stateIndex</span><span>);</span>
          <span>const</span> <span>clauses</span> <span>=</span> <span>parseClauses</span><span>(</span><span>_clauses</span><span>).</span><span>map</span><span>(</span><span>parseClause</span><span>);</span>

          <span>return</span> <span>clauses</span><span>.</span><span>concat</span><span>([</span><span>nextState</span><span>]);</span>
        <span>}</span>
      <span>)</span>
    <span>)</span>
  <span>);</span>
<span>}</span>

<span>const</span> <span>interpret</span> <span>=</span> <span>(</span><span>parsed</span><span>,</span> <span>input</span> <span>=</span> <span>[])</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>tapes</span> <span>=</span> <span>[</span><span>&#39;</span><span>ANCHOR</span><span>&#39;</span><span>,</span> <span>...</span><span>input</span><span>];</span> <span>// fake 1-indexing</span>

  <span>let</span> <span>stateIndex</span> <span>=</span> <span>1</span><span>;</span>

  <span>run</span><span>:</span> <span>while</span> <span>(</span><span>stateIndex</span> <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>stateIndex</span> <span>&lt;</span> <span>parsed</span><span>.</span><span>length</span><span>)</span> <span>{</span>
    <span>const</span> <span>rules</span> <span>=</span> <span>parsed</span><span>[</span><span>stateIndex</span><span>];</span>
    <span>for</span> <span>(</span><span>const</span> <span>[</span><span>actionClauses</span><span>,</span> <span>guardClauses</span><span>,</span> <span>nextState</span><span>]</span> <span>of</span> <span>rules</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>guardClauses</span><span>.</span><span>some</span><span>(</span>
        <span>([</span><span>tapeIndex</span><span>,</span> <span>squares</span><span>])</span> <span>=&gt;</span> <span>tapes</span><span>[</span><span>tapeIndex</span><span>]</span> <span>===</span> <span>undefined</span> <span>||</span> <span>tapes</span><span>[</span><span>tapeIndex</span><span>]</span> <span>&lt;</span> <span>squares</span>
      <span>))</span> <span>continue</span><span>;</span>
      <span>for</span> <span>(</span><span>const</span> <span>[</span><span>tapeIndex</span><span>,</span> <span>squares</span><span>]</span> <span>of</span> <span>guardClauses</span><span>)</span> <span>{</span>
        <span>tapes</span><span>[</span><span>tapeIndex</span><span>]</span> <span>=</span> <span>tapes</span><span>[</span><span>tapeIndex</span><span>]</span> <span>-</span> <span>squares</span><span>;</span>
      <span>}</span>
      <span>for</span> <span>(</span><span>const</span> <span>[</span><span>tapeIndex</span><span>,</span> <span>squares</span><span>]</span> <span>of</span> <span>actionClauses</span><span>)</span> <span>{</span>
        <span>tapes</span><span>[</span><span>tapeIndex</span><span>]</span> <span>=</span> <span>(</span><span>tapes</span><span>[</span><span>tapeIndex</span><span>]</span> <span>||</span> <span>0</span><span>)</span> <span>+</span> <span>squares</span><span>;</span>
      <span>}</span>
      <span>stateIndex</span> <span>=</span> <span>nextState</span><span>;</span>
      <span>continue</span> <span>run</span><span>;</span>
    <span>}</span>
    <span>break</span><span>;</span>
  <span>}</span>

  <span>const</span> <span>output</span> <span>=</span> <span>tapes</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>);</span> <span>// unfake 1-indexing</span>

  <span>return</span> <span>output</span><span>;</span>
<span>}</span>

<span>const</span> <span>evaluate</span> <span>=</span> <span>(</span><span>program</span><span>,</span> <span>...</span><span>tapes</span><span>)</span> <span>=&gt;</span> <span>interpret</span><span>(</span><span>parse</span><span>(</span><span>program</span><span>),</span> <span>tapes</span><span>);</span>
</code></pre></div></div>

<p>Now that we have a machine to emulate our machines, we can explore an interesting idea.</p>

<hr/>

<h2 id="marvellous-minsky-machines">Marvellous Minsky Machines</h2>

<hr/>

<p><img src="https://george.mand.is/assets/images/fractran/Marvellous-Spatuletail-Dubi-Shapiro-ABCbirds.org_.jpg" alt="Marvellous Spatuletail Dubi Shapir/ABCbirds.Org "/></p>

<p><em>Marvellous Spatuletails are endemic to Peru. (Dubi Shapiro/ABCbirds.org)</em></p>

<hr/>

<p>Here is another Magnificent Minsky Machine that multiplies two numbers, we shall call it the <strong>marvellous multiplier</strong>:</p>

<div><div><pre><code>(1^1)(4^1)(6^1)/(3^1)(5^1) ,
(7^1)/(5^1)                ,
(3^1)(8^1)/(4^1)(7^1)      ,
(1^0)/(7^1)                ,
(5^1)/(6^1)                ,
(7^1)/(8^1)                ,
(5^1)/(2^1)                ,
(1^0)/(3^1)
</code></pre></div></div>

<p>This is a one-state multiplier. Our previous multiplier needed three states:</p>

<div><div><pre><code>(1^0)/(2^1)→2,    (1^0)/(3^1)   ;
(1^1)(4^1)/(3^1), (1^0)/(1^0)→3 ;
(3^1)/(4^1),      (1^0)/(1^0)→1
</code></pre></div></div>

<p>How does our marvellous multiplier work without the other states?</p>

<p>The not-very-secret secret is that in addition to the four tapes our multiplier needs to do its main business, we’ve added four more tapes: 5, 6, 7, and 8. We only ever set them to 1 or zero, so they act like flags that emulate four additional states.</p>

<p>Let’s analyze this, state-by state. The first state of the original multiplier had two rules:</p>

<div><div><pre><code>(1^0)/(2^1)→2,
(1^0)/(3^1)
</code></pre></div></div>

<p>These two rules are the <em>last</em> rules of the marvellous multiplier:</p>



<p>Why are they the last rules? Since we are using tapes 5, 6, 7, and 8 to emulate other states, every rule that comes before these rules is guarded by <code>(5^1)</code>, <code>(6^1)</code>, <code>(7^1)</code>, or <code>(8^1)</code>. Thus, these rules only come into play if <em>none</em> of these state-emulation tape-heads are one square forward.</p>

<p>But what about the rules themselves? The second rule, <code>(1^0)/(3^1)</code>, is the same thing we already have, it decrements tape 3 and remains in the only state, thus it will clear tape 3 and then the entire program will halt, just as with the original.</p>

<p>The first of our original rules is different. Instead of <code>(1^0)/(2^1)→2</code>, we have <code>(5^1)/(2^1)</code>. Instead of setting the next state to 2, we increment tape 5.</p>

<p>That leads us to the original state 2:</p>

<div><div><pre><code>(1^1)(4^1)/(3^1),
(1^0)/(1^0)→3
</code></pre></div></div>

<p>And our marvellous machine’s equivalent:</p>

<div><div><pre><code>(1^1)(4^1)(6^1)/(3^1)(5^1),
(7^1)/(5^1)
</code></pre></div></div>

<p>Both of these rules are guarded by <code>(5^1)</code>, which matches what we saw from the rule in the original state 1: incrementing tape 5 makes this machine act like it’s in the original state 2.</p>

<p>The first rule of the original machine incremented tapes 1 and 4, decremented tape 3, and remained in state 2. Our new rule also increments tapes 1 and 4, and decrements tape 3. And we know that we have to have it get back to the emulated state 2 by incrementing tape 5. But it is forbidden to both decrement and increment the same tape in our Minsky Machines, so it increments tape 6 instead.</p>

<p>How does that get us to incrementing tape 5? Look further down, and we find this rule:</p>



<p>If the marvellous multiplier finds itself with tape 6 incremented, it turns around and increments tape 5. Thus, incrementing tape 6 is an indirect way of incrementing tape 5, and that’s what our machine does when it is already decrementing tape 5.</p>

<p>We already know why the second of our original rules for state 2, <code>(1^0)/(1^0)→3</code>, becomes <code>(7^1)/(5^1)</code> in the marvellous multiplier. Instead of always matching with a <code>(1^0)</code> guard, it only matches when tape 5 is incremented, because tape 5 emulates state 2. And instead of setting having a NOOP action with <code>(1^0)</code> and setting the next state to 3, it increments tape 7 because tape 7 emulates state 3.</p>

<p>We now know everything we need to know to interpret how the marvellous machine’s <code>(3^1)(8^1)/(4^1)(7^1), (1^0)/(7^1)</code> emulates the original’s <code>(3^1)/(4^1), (1^0)/(1^0)→1</code>, and why there’s a <code>(7^1)/(8^1)</code> rule added to support it.</p>

<p>The marvellous multiplier illustrates a key property of these Minsky Machines: <strong>For every Magnificent Minsky Machine with two or more states, there exists an equivalent Marvellous Minsky Machine with just one state, but more tapes.</strong></p>

<h3 id="an-algorithm-to-derive-a-marvellous-minsky-machine-from-any-magnificent-minsky-machine">an algorithm to derive a marvellous minsky machine from any magnificent minsky machine</h3>

<p>From our exploration of the marvellous multiplier, we picked up a few tricks for emulating states with additional tapes:</p>

<ol>
  <li>Place the original state 1 last;</li>
  <li>For each state beyond 1, set up two additional tapes, <code>stateTape</code> and <code>stateTapePrime</code>;</li>
  <li>Guard the rules of the original state with <code>stateTape</code>;</li>
  <li>For rules outside the state that transfer to the state, remove the nextState and add an action to increment <code>stateTape</code>.</li>
  <li>For rules of the original state that remain in the state, add an action to increment <code>stateTapePrime</code>;</li>
  <li>Add a rule to transfer from <code>stateTapePrime</code> to <code>stateTape</code>.</li>
</ol>

<p>This can, of course, be automated. If you’re keen, have a go at it before reading this example. If you’re <strong>really</strong> keen, see if you can devise your own algorithm for deriving a Marvellous Minsky Machine from any Magnificent Minsky Machine.<sup id="fnref:eminem" role="doc-noteref"><a href="#fn:eminem" rel="footnote">23</a></sup></p>

<div><div><pre><code><span>const</span> <span>maxTapeIndexOf</span> <span>=</span> <span>(</span><span>parsed</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> <span>max</span> <span>=</span> <span>undefined</span><span>;</span>

  <span>for</span> <span>(</span><span>const</span> <span>rules</span> <span>of</span> <span>parsed</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>))</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>[</span><span>actionClause</span><span>,</span> <span>guardClause</span><span>]</span> <span>of</span> <span>rules</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>const</span> <span>[</span><span>tapeIndex</span><span>]</span> <span>of</span> <span>actionClause</span><span>.</span><span>concat</span><span>(</span><span>guardClause</span><span>))</span> <span>{</span>
        <span>if</span> <span>(</span><span>max</span> <span>===</span> <span>undefined</span> <span>||</span> <span>tapeIndex</span> <span>&gt;</span> <span>max</span><span>)</span> <span>max</span> <span>=</span> <span>tapeIndex</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> <span>max</span><span>;</span>
<span>};</span>

<span>const</span> <span>maxStateNumberOf</span> <span>=</span> <span>(</span><span>parsed</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>parsed</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>;</span>
<span>}</span>

<span>const</span> <span>NOOP</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>0</span><span>];</span>
<span>const</span> <span>isNOOP</span> <span>=</span> <span>([,</span><span>squares</span><span>])</span> <span>=&gt;</span> <span>squares</span> <span>===</span> <span>0</span><span>;</span>
<span>const</span> <span>isActionable</span> <span>=</span> <span>([,</span><span>squares</span><span>])</span> <span>=&gt;</span> <span>squares</span> <span>!==</span> <span>0</span><span>;</span>

<span>const</span> <span>SUCCESS</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>0</span><span>];</span>
<span>const</span> <span>isSuccess</span> <span>=</span> <span>([,</span><span>squares</span><span>])</span> <span>=&gt;</span> <span>squares</span> <span>===</span> <span>0</span><span>;</span>
<span>const</span> <span>canFail</span> <span>=</span> <span>([,</span><span>squares</span><span>])</span> <span>=&gt;</span> <span>squares</span> <span>!==</span> <span>0</span><span>;</span>

<span>const</span> <span>ruleCanFail</span> <span>=</span> <span>([,</span> <span>guardClause</span><span>])</span> <span>=&gt;</span> <span>guardClause</span><span>.</span><span>every</span><span>(</span><span>canFail</span><span>);</span>

<span>const</span> <span>withClause</span> <span>=</span> <span>(</span><span>clauses</span><span>,</span> <span>clause</span><span>)</span> <span>=&gt;</span> <span>clauses</span><span>.</span><span>filter</span><span>(</span><span>canFail</span><span>).</span><span>concat</span><span>([</span><span>clause</span><span>]);</span>

<span>const</span> <span>toMarvellous</span> <span>(</span><span>parsed</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>maxTapeIndex</span> <span>=</span> <span>maxTapeIndexOf</span><span>(</span><span>parsed</span><span>);</span>
  <span>const</span> <span>maxStateNumber</span> <span>=</span> <span>maxStateNumberOf</span><span>(</span><span>parsed</span><span>);</span>

  <span>const</span> <span>stateToTape</span> <span>=</span> <span>new</span> <span>Map</span><span>();</span>

  <span>for</span> <span>(</span><span>let</span> <span>stateNumber</span> <span>=</span> <span>2</span><span>;</span> <span>stateNumber</span> <span>&lt;=</span> <span>maxStateNumber</span><span>;</span> <span>++</span><span>stateNumber</span><span>)</span> <span>{</span>
    <span>const</span> <span>offset</span> <span>=</span> <span>maxTapeIndex</span> <span>+</span> <span>(</span><span>2</span> <span>*</span> <span>stateNumber</span><span>)</span> <span>-</span> <span>3</span><span>;</span>

    <span>stateToTape</span><span>.</span><span>set</span><span>(</span><span>stateNumber</span><span>,</span> <span>{</span> <span>stateIndex</span><span>:</span> <span>offset</span><span>,</span> <span>statePrimeIndex</span><span>:</span> <span>offset</span> <span>+</span> <span>1</span> <span>});</span>
  <span>}</span>

  <span>const</span> <span>state1</span> <span>=</span> <span>parsed</span><span>[</span><span>1</span><span>];</span>

  <span>// adjust all rules in state 1 to set an emulated state</span>
  <span>// rather than use an explicit nextState if they point to</span>
  <span>// another state</span>
  <span>for</span> <span>(</span><span>const</span> <span>rule</span> <span>of</span> <span>state1</span><span>)</span> <span>{</span>
    <span>const</span> <span>[</span><span>actionClause</span><span>,</span> <span>guardClause</span><span>,</span> <span>nextState</span><span>]</span> <span>=</span> <span>rule</span><span>;</span>
    <span>if</span> <span>(</span><span>nextState</span> <span>&gt;</span> <span>1</span><span>)</span> <span>{</span>
      <span>rule</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>withClause</span><span>(</span><span>actionClause</span><span>,</span> <span>[</span><span>stateToTape</span><span>.</span><span>get</span><span>(</span><span>nextState</span><span>).</span><span>stateIndex</span><span>,</span> <span>1</span><span>]);</span>
      <span>rule</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>let</span> <span>stateIndex</span> <span>=</span> <span>1</span><span>;</span>
  <span>let</span> <span>aggregateRules</span> <span>=</span> <span>[];</span>
  <span>for</span> <span>(</span><span>const</span> <span>rules</span> <span>of</span> <span>parsed</span><span>.</span><span>slice</span><span>(</span><span>2</span><span>))</span> <span>{</span>
    <span>++</span><span>stateIndex</span><span>;</span>

    <span>if</span> <span>(</span><span>rules</span><span>.</span><span>every</span><span>(</span><span>ruleCanFail</span><span>))</span> <span>{</span>
      <span>// if we cannot guarantee action,</span>
      <span>// add an explicit fall-through to halt</span>
      <span>// this will get guarded below</span>
      <span>rules</span><span>.</span><span>push</span><span>([[</span><span>NOOP</span><span>],</span> <span>[</span><span>SUCCESS</span><span>],</span> <span>0</span><span>]);</span>
    <span>}</span>

    <span>const</span> <span>stateEmulationGuard</span> <span>=</span> <span>[</span><span>stateToTape</span><span>.</span><span>get</span><span>(</span><span>stateIndex</span><span>).</span><span>stateIndex</span><span>,</span> <span>1</span><span>];</span>

    <span>for</span> <span>(</span><span>const</span> <span>rule</span> <span>of</span> <span>rules</span><span>)</span> <span>{</span>
      <span>const</span> <span>[</span><span>actionClause</span><span>,</span> <span>guardClause</span><span>,</span> <span>nextState</span><span>]</span> <span>=</span> <span>rule</span><span>;</span>

      <span>if</span> <span>(</span><span>nextState</span> <span>===</span> <span>stateIndex</span><span>)</span> <span>{</span>
        <span>// this rule remains in the same state. we cannot directly</span>
        <span>// emulate the sate, because we are already guarding for it,</span>
        <span>// so we set the state-prime</span>
        <span>rule</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>withClause</span><span>(</span><span>actionClause</span><span>,</span> <span>[</span><span>stateToTape</span><span>.</span><span>get</span><span>(</span><span>nextState</span><span>).</span><span>statePrimeIndex</span><span>,</span> <span>1</span><span>]);</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>nextState</span> <span>&gt;</span> <span>1</span><span>)</span> <span>{</span>
        <span>// set an emulated state rather than use an explicit nextState</span>
        <span>// if nextState</span>
        <span>rule</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>withClause</span><span>(</span><span>actionClause</span><span>,</span> <span>[</span><span>stateToTape</span><span>.</span><span>get</span><span>(</span><span>nextState</span><span>).</span><span>stateIndex</span><span>,</span> <span>1</span><span>]);</span>
      <span>}</span>

      <span>rule</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>withClause</span><span>(</span><span>guardClause</span><span>,</span> <span>stateEmulationGuard</span><span>);</span>
      <span>rule</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>aggregateRules</span> <span>=</span> <span>aggregateRules</span><span>.</span><span>concat</span><span>(</span><span>rules</span><span>);</span> <span>// TODO: refactor to flatMap</span>

  <span>}</span>

  <span>for</span> <span>(</span><span>const</span> <span>{</span> <span>stateIndex</span><span>,</span> <span>statePrimeIndex</span> <span>}</span> <span>of</span> <span>stateToTape</span><span>.</span><span>values</span><span>())</span> <span>{</span>
    <span>const</span> <span>actionClauses</span> <span>=</span> <span>[[</span><span>stateIndex</span><span>,</span> <span>1</span><span>]];</span>
    <span>const</span> <span>guardClauses</span> <span>=</span> <span>[[</span><span>statePrimeIndex</span><span>,</span> <span>1</span><span>]];</span>

    <span>aggregateRules</span><span>.</span><span>push</span><span>([</span><span>actionClauses</span><span>,</span> <span>guardClauses</span><span>,</span> <span>1</span><span>]);</span>
  <span>}</span>

  <span>aggregateRules</span> <span>=</span> <span>aggregateRules</span><span>.</span><span>concat</span><span>(</span><span>state1</span><span>);</span>

  <span>return</span> <span>[[]].</span><span>concat</span><span>([</span><span>aggregateRules</span><span>]);</span>
<span>}</span>
</code></pre></div></div>

<p>That is truly marvellous, but is it <em>meaningful</em>?</p>

<p>Yes, it is meaningful, and we’re about to find out why.</p>

<hr/>

<h2 id="gödel-numbering-and-masterful-minsky-machines">Gödel Numbering and Masterful Minsky Machines</h2>

<hr/>

<p><img src="https://george.mand.is/assets/images/fractran/godeleinstein.jpg" alt="Godeleinstein"/></p>

<p><em>Kurt Gödel and Albert Einstein</em></p>

<hr/>

<p>Formally, a <a href="https://en.wikipedia.org/wiki/Gödel_numbering">Gödel Numbering</a> is a scheme for assigning a unique natural number to every symbol and statement in a formal language. Kurt Gödel used such a scheme to show that formal systems capable of making statements about themselves were equivalent to systems that make statements about numbers, and from there he went on to show that in such systems, there were necessarily statements that were true but not provable.</p>

<p>Informally, a Gödel Numbering is a mapping between natural numbers and some other mathematical concept or entity. Let’s keep that in mind.</p>

<h3 id="register-machines">register machines</h3>

<p>A Minsky Machine’s tapes are easily represented as natural numbers. We have presented the machine as moving over a tape, which our actions and guards moving the head away from and back towards the beginning of the tape.</p>

<p>And while we could implement the tapes with arrays or some such, natural numbers are a better choice because they more neatly fit the affordances our tapes provide: Incrementing by a certain amount, testing whether they can be decremented by a certain amount, and decrementing them by a certain amount.</p>

<p>In fact, if we let go of the notion of tapes, we can think of our Minsky Machines as operating on a finite set of registers, each of which holds a natural number. And this is where things get interesting:</p>

<p>In a “Magnificent” Minsky Machine, the current state of the world is represented by the machine’s current state and the current state of its registers. But a “Marvellous” Minsky Machine does away with the machine’s current state. the “state of the world” is encoded entirely by the contents of its registers.</p>

<p>This brings up an interesting possibility: We were able to “flatten” a Magnificent Minsky Machine into a Marvellous Minsky Machine, getting rid of its states by encoding the machine states into register values.</p>

<p>Could we “flatten” the registers by encoding their value into a single natural number? Could we develop a Minsky Machine that only needs one number to encode its entire state?</p>

<h3 id="encoding-state-with-prime-factorization">encoding state with prime factorization</h3>

<p>When Gödel developed his numbering system, he needed a way to encode a finite number of finite numbers in a single finite natural number. In this way, he could encode any statement in any formal language as a single natural number.</p>

<p>There are various ways to encode a finite number of finite numbers in a single finite natural number. For example, we could just write the numbers out like text, separating the numbers with a comma like a CSV file. We wouldn’t need 8 or 16 bits for each “character,” 4 bits could handle this easily.</p>

<p>While that’s certainly <em>possible</em>, the things that lists of characters makes easy–like searching for any arbitrary substring–are not useful to us, and the things that are useful to us are not easy with lists of characters.</p>

<p>We know our requirements: We need to quickly and easily decrement one or more “registers,” preferably in a single step. And we need to quickly and easily increment several “registers” in a single step.</p>

<p>Gödel chose to use <a href="https://en.wikipedia.org/wiki/Integer_factorization" title="Integer Factorization">prime factorization</a> to encode a finite number of finite numbers, and that method suits us perfectly.</p>

<p>With prime factorization, we encode lists of numbers as exponents of consecutive primes. Thus, the list <code>[1, 9, 6, 2]</code> is encoded as 2¹3⁹5⁶7², or 30,139,593,750. While the numbers might become very large, they’re workable for the kinds of toy exercises we’re performing here.</p>

<p>Prime factorization can be used to encode a Minsky Machine’s state, using the exponents of consecutive primes as virtual registers. But that’s not its only use. Action clauses in our rules are tuples of a register and an amount to increment. So <code>(3^2)</code> means, “increment the register identified as <code>3</code>, by 2.”</p>

<p>The two is definitely a natural number. But the register indicator could be anything. Our Minsky Machines don’t allow indirect access or iteration over them, so there’s nothing really binding them to consecutive integers.</p>

<p>So what if we labeled the registers with <em>consecutive primes</em>? In that case, an action clause like <code>(1^1)(4^1)(6^1)</code> would become <code>(2^1)(7^1)(13^1)</code>. And we can do the same thing with guard clauses: <code>(3^1)(5^1)</code> would become <code>(5^1)(11^1)</code>.</p>

<p>Now we see the obvious!<sup id="fnref:obvious" role="doc-noteref"><a href="#fn:obvious" rel="footnote">24</a></sup></p>

<p>We can represent action and guard clauses as natural numbers with prime factorization. So a rule like <code>(1^1)(4^1)(6^1)/(3^1)(5^1)</code> would become <code>(2^1)(7^1)(13^1)/(5^1)(11^1)</code> when we swap the consecutive tape numbers for consecutive primes. We then turn that notation into an arithmetic expression by converting the increments and decrements to exponents, which would be 2¹7¹13¹/5¹11¹.</p>

<p>And that can be written as a pair of natural numbers separated with a forward slash, i.e. <code>182/55</code>.</p>

<p>The final part of our single-number Minsky Machine will be its input and output. With a Magnificent or Marvellous Minsky Machine, we listed the initial values of the registers. So for adding having a value of <code>0</code> in register 1, <code>3</code> in register 2, and <code>13</code> in register 3, we would include the parameters <code>0, 3, 13</code>.</p>

<p>And for output, our machine would return the value of all the registers, and the value we want would be in one or more of them, depending on how we wrote our program. For example, the Marvellous Multiplication Machine returns <code>39, 0, 0, 0, 0, 0, 0, 0</code>.</p>

<p>We will encode these with prime factorization as well. So the input of <code>0, 3, 13</code> would become 3³5¹³, or 32,958,984,375. Likewise, the output of <code>39, 0, 0, 0, 0, 0, 0, 0</code> would become 2³⁹, or 549,755,813,888.</p>

<p>This transformation is extremely simple, and once again we can perform it mechanically:<sup id="fnref:two-hundred" role="doc-noteref"><a href="#fn:two-hundred" rel="footnote">25</a></sup></p>

<div><div><pre><code><span>const</span> <span>PRIMES</span> <span>=</span> <span>[</span>
  <span>2</span><span>n</span><span>,</span> <span>3</span><span>n</span><span>,</span> <span>5</span><span>n</span><span>,</span> <span>7</span><span>n</span><span>,</span> <span>11</span><span>n</span><span>,</span>
  <span>13</span><span>n</span><span>,</span> <span>17</span><span>n</span><span>,</span> <span>19</span><span>n</span><span>,</span> <span>23</span><span>n</span><span>,</span> <span>29</span><span>n</span><span>,</span>

  <span>// ... 180 more primes ...</span>

  <span>1153</span><span>n</span><span>,</span> <span>1163</span><span>n</span><span>,</span> <span>1171</span><span>n</span><span>,</span> <span>1181</span><span>n</span><span>,</span>	<span>1187</span><span>n</span><span>,</span>
  <span>1193</span><span>n</span><span>,</span> <span>1201</span><span>n</span><span>,</span>	<span>1213</span><span>n</span><span>,</span> <span>1217</span><span>n</span><span>,</span>	<span>1223</span><span>n</span>
<span>];</span>

<span>const</span> <span>tapeToPrime</span> <span>=</span> <span>tape</span> <span>=&gt;</span> <span>PRIMES</span><span>[</span><span>tape</span> <span>-</span> <span>1</span><span>];</span>
<span>const</span> <span>exponentiate</span> <span>=</span> <span>([</span><span>tape</span><span>,</span> <span>amount</span><span>])</span> <span>=&gt;</span> <span>pow</span><span>(</span><span>tapeToPrime</span><span>(</span><span>tape</span><span>),</span> <span>BigInt</span><span>(</span><span>amount</span><span>));</span>
<span>const</span> <span>multiply</span> <span>=</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>*</span> <span>y</span><span>;</span>
<span>const</span> <span>godelizeClauses</span> <span>=</span> <span>clauses</span> <span>=&gt;</span> <span>clauses</span><span>.</span><span>map</span><span>(</span><span>exponentiate</span><span>).</span><span>reduce</span><span>(</span><span>multiply</span><span>,</span> <span>1</span><span>n</span><span>);</span>

<span>export</span> <span>const</span> <span>toMasterful</span> <span>=</span> <span>(</span><span>magnificentProgram</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>parsedMarvellous</span> <span>=</span> <span>parse</span><span>(</span><span>toMarvellous</span><span>(</span><span>magnificentProgram</span><span>));</span>
  <span>const</span> <span>godelized</span> <span>=</span> <span>parsedMarvellous</span><span>[</span><span>1</span><span>].</span><span>map</span><span>(</span>
    <span>([</span><span>actions</span><span>,</span> <span>guards</span><span>])</span> <span>=&gt;</span> <span>[</span><span>actions</span><span>,</span> <span>guards</span><span>].</span><span>map</span><span>(</span><span>godelizeClauses</span><span>)</span>
  <span>);</span>

  <span>return</span> <span>pp</span><span>(</span><span>godelized</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Now what about actually <em>evaluating</em> a single-number Minsky Machine? If you are extremely keen, you can write your own implementation. We want to end up with something like:</p>

<div><div><pre><code><span>const</span> <span>evaluate</span> <span>=</span> <span>(</span><span>program</span><span>,</span> <span>initialState</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>};</span>

<span>// masterful adding machine</span>
<span>// 3²5³ =&gt; 1,125</span>
<span>// 2⁵ =&gt; 32</span>
<span>evaluate</span><span>(</span>
  <span>&#39;</span><span>2/3, 2/5</span><span>&#39;</span><span>,</span>
  <span>1125</span>
<span>)</span>
  <span>//=&gt; 32</span>

<span>// masterful multiplication machine</span>
<span>// 3³5¹³ =&gt; 32,958,984,375</span>
<span>// 2³⁹ =&gt; 549,755,813,888</span>
<span>evaluate</span><span>(</span>
  <span>&#39;</span><span>182/55, 17/11, 95/119, 1/17, 11/13, 17/19, 11/3, 1/5</span><span>&#39;</span><span>,</span>
  <span>32958984375</span><span>n</span>
<span>)</span>
  <span>//=&gt; 549755813888n</span>
</code></pre></div></div>

<p>We will need functions to convert BigInts to their factorization, and factorizations back to BigInts. If you wish, you may use these helpers for your implementation:</p>

<div><div><pre><code><span>// Converts BigInts to their prime factorizations,</span>
<span>// represented as a map from prime to exponent.</span>
<span>//</span>
<span>// Examples:</span>
<span>//   17 =&gt; Map { 17 =&gt; 1 }</span>
<span>//   39 =&gt; Map { 3 =&gt; 1, 13 =&gt; 1 }</span>
<span>//   44 =&gt; Map { 2 =&gt; 2, 11 =&gt; 1}</span>
<span>//</span>
<span>// Accepts BigInts or numbers, returns a factorization</span>
<span>// as ordinary numbers</span>

<span>// Relies on simple factoring code adapted from</span>
<span>// http://www.javascripter.net/math/primes/factorization.htm</span>
<span>export</span> <span>const</span> <span>toFactors</span> <span>=</span> <span>(</span><span>n</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>n</span> <span>=</span> <span>BigInt</span><span>(</span><span>n</span><span>);</span>

  <span>if</span> <span>(</span><span>n</span> <span>&lt;=</span> <span>0</span><span>n</span><span>)</span> <span>return</span><span>;</span>

  <span>const</span> <span>factorization</span> <span>=</span> <span>new</span> <span>Map</span><span>();</span>

  <span>while</span> <span>(</span><span>n</span> <span>&gt;</span> <span>1</span><span>n</span><span>)</span> <span>{</span>
    <span>const</span> <span>primeFactorBigInt</span> <span>=</span> <span>leastFactor</span><span>(</span><span>n</span><span>)</span>
    <span>const</span> <span>primeFactor</span> <span>=</span> <span>unsafeToNumber</span><span>(</span><span>leastFactor</span><span>(</span><span>n</span><span>));</span>

    <span>factorization</span><span>.</span><span>set</span><span>(</span>
      <span>primeFactor</span><span>,</span>
      <span>factorization</span><span>.</span><span>has</span><span>(</span><span>primeFactor</span><span>)</span> <span>?</span> <span>factorization</span><span>.</span><span>get</span><span>(</span><span>primeFactor</span><span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>1</span>
    <span>);</span>

    <span>n</span> <span>=</span> <span>n</span> <span>/</span> <span>primeFactorBigInt</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>factorization</span><span>;</span>
<span>}</span>

<span>const</span> <span>pow</span> <span>=</span> <span>(</span><span>base</span><span>,</span> <span>exponent</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>base</span> <span>=</span> <span>BigInt</span><span>(</span><span>base</span><span>);</span>
  <span>exponent</span> <span>=</span> <span>BigInt</span><span>(</span><span>exponent</span><span>);</span>

  <span>if</span> <span>(</span><span>exponent</span> <span>&lt;</span> <span>0</span><span>n</span><span>)</span> <span>return</span><span>;</span>

  <span>let</span> <span>result</span> <span>=</span> <span>1</span><span>n</span><span>;</span>

  <span>while</span> <span>(</span><span>exponent</span><span>--</span> <span>&gt;</span> <span>0</span><span>n</span><span>)</span> <span>result</span> <span>=</span> <span>result</span> <span>*</span> <span>base</span><span>;</span>

  <span>return</span> <span>result</span><span>;</span>
<span>}</span>

<span>// Converts prime factorization to BigInts</span>
<span>export</span> <span>const</span> <span>fromFactors</span> <span>=</span> <span>g</span> <span>=&gt;</span> <span>[...</span><span>g</span><span>.</span><span>entries</span><span>()].</span><span>reduce</span><span>((</span><span>acc</span><span>,</span> <span>[</span><span>factor</span><span>,</span> <span>exponent</span><span>])</span> <span>=&gt;</span> <span>acc</span> <span>*</span> <span>pow</span><span>(</span><span>factor</span><span>,</span> <span>exponent</span><span>),</span> <span>1</span><span>n</span><span>);</span>

<span>// find the least factor in n by trial division</span>
<span>function</span> <span>leastFactor</span><span>(</span><span>composite</span><span>)</span> <span>{</span>

 <span>// if (isNaN(n) || !isFinite(n)) return NaN;</span>

 <span>if</span> <span>(</span><span>composite</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>0</span><span>n</span><span>;</span>
 <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>1</span><span>n</span> <span>||</span> <span>composite</span><span>*</span><span>composite</span> <span>&lt;</span> <span>2</span><span>n</span><span>)</span> <span>return</span> <span>1</span><span>n</span><span>;</span>
 <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>2</span><span>n</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>2</span><span>n</span><span>;</span>
 <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>3</span><span>n</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>3</span><span>n</span><span>;</span>
 <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>5</span><span>n</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>5</span><span>n</span><span>;</span>

 <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>7</span><span>n</span><span>;</span> <span>(</span><span>i</span> <span>*</span> <span>i</span><span>)</span> <span>&lt;</span> <span>composite</span><span>;</span> <span>i</span> <span>+=</span> <span>30</span><span>n</span><span>)</span> <span>{</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>i</span>         <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span><span>;</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>(</span><span>i</span> <span>+</span>  <span>4</span><span>n</span><span>)</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span> <span>+</span> <span>4</span><span>n</span><span>;</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>(</span><span>i</span> <span>+</span>  <span>6</span><span>n</span><span>)</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span> <span>+</span> <span>6</span><span>n</span><span>;</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>(</span><span>i</span> <span>+</span> <span>10</span><span>n</span><span>)</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span> <span>+</span> <span>10</span><span>n</span><span>;</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>(</span><span>i</span> <span>+</span> <span>12</span><span>n</span><span>)</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span> <span>+</span> <span>12</span><span>n</span><span>;</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>(</span><span>i</span> <span>+</span> <span>16</span><span>n</span><span>)</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span> <span>+</span> <span>16</span><span>n</span><span>;</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>(</span><span>i</span> <span>+</span> <span>22</span><span>n</span><span>)</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span> <span>+</span> <span>22</span><span>n</span><span>;</span>
   <span>if</span> <span>(</span><span>composite</span> <span>%</span> <span>(</span><span>i</span> <span>+</span> <span>24</span><span>n</span><span>)</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>return</span> <span>i</span> <span>+</span> <span>24</span><span>n</span><span>;</span>
 <span>}</span>

 <span>// it is prime</span>
 <span>return</span> <span>composite</span><span>;</span>
<span>}</span>

<span>function</span> <span>unsafeToNumber</span><span>(</span><span>big</span><span>)</span> <span>{</span>
  <span>return</span> <span>parseInt</span><span>(</span><span>big</span><span>.</span><span>toString</span><span>(),</span> <span>10</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Have a go at it before peeking!</p>

<h3 id="the-masterful-minsky-machine">the masterful minsky machine</h3>

<p>This is the <strong>Masterful</strong> Minsky Machine. It has just one state, and it encodes its state and clauses with single natural numbers:</p>

<div><div><pre><code><span>const</span> <span>parse</span> <span>=</span> <span>(</span><span>program</span><span>)</span> <span>=&gt;</span> <span>program</span><span>.</span><span>trim</span><span>().</span><span>split</span><span>(</span><span>/,</span><span>?\s</span><span>+/</span><span>).</span><span>map</span><span>(</span>
  <span>rule</span> <span>=&gt;</span> <span>rule</span><span>.</span><span>split</span><span>(</span><span>&#39;</span><span>/</span><span>&#39;</span><span>).</span><span>map</span><span>(</span>
    <span>chars</span> <span>=&gt;</span> <span>parseInt</span><span>(</span><span>chars</span><span>,</span> <span>10</span><span>)</span>
  <span>)</span>
<span>);</span>

<span>const</span> <span>interpret</span> <span>=</span> <span>(</span><span>rules</span><span>,</span> <span>state</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>run</span><span>:</span> <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>[</span><span>action</span><span>,</span> <span>guard</span><span>]</span> <span>of</span> <span>rules</span><span>)</span> <span>{</span>
      <span>const</span> <span>factoredState</span> <span>=</span> <span>toFactors</span><span>(</span><span>state</span><span>);</span>

      <span>// check guard clause</span>
      <span>const</span> <span>factoredGuard</span> <span>=</span> <span>toFactors</span><span>(</span><span>guard</span><span>);</span>
      <span>if</span> <span>([...</span><span>factoredGuard</span><span>.</span><span>keys</span><span>()].</span><span>some</span><span>(</span>
        <span>factor</span> <span>=&gt;</span> <span>factoredGuard</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>)</span> <span>&gt;</span> <span>(</span><span>factoredState</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>)</span> <span>||</span> <span>0</span><span>)</span>
      <span>))</span> <span>continue</span><span>;</span>

      <span>for</span> <span>(</span><span>const</span> <span>[</span><span>factor</span><span>,</span> <span>guardValue</span><span>]</span> <span>of</span> <span>factoredGuard</span><span>.</span><span>entries</span><span>())</span> <span>{</span>
        <span>const</span> <span>oldStateValue</span> <span>=</span> <span>factoredState</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>);</span>

        <span>factoredState</span><span>.</span><span>set</span><span>(</span><span>factor</span><span>,</span> <span>oldStateValue</span> <span>-</span> <span>guardValue</span><span>);</span>
      <span>}</span>

      <span>const</span> <span>actionGuard</span> <span>=</span> <span>toFactors</span><span>(</span><span>action</span><span>);</span>
      <span>for</span> <span>(</span><span>const</span> <span>[</span><span>factor</span><span>,</span> <span>actionValue</span><span>]</span> <span>of</span> <span>actionGuard</span><span>.</span><span>entries</span><span>())</span> <span>{</span>
        <span>const</span> <span>oldStateValue</span> <span>=</span> <span>factoredState</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>)</span> <span>||</span> <span>0</span><span>;</span>

        <span>factoredState</span><span>.</span><span>set</span><span>(</span><span>factor</span><span>,</span> <span>oldStateValue</span> <span>+</span> <span>actionValue</span><span>);</span>
      <span>}</span>

      <span>state</span> <span>=</span> <span>fromFactors</span><span>(</span><span>factoredState</span><span>);</span>

      <span>continue</span> <span>run</span><span>;</span>
    <span>}</span>
    <span>break</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>state</span><span>;</span>
<span>}</span>

<span>const</span> <span>evaluate</span> <span>=</span> <span>(</span><span>program</span><span>,</span> <span>initialState</span><span>)</span> <span>=&gt;</span> <span>interpret</span><span>(</span><span>parse</span><span>(</span><span>program</span><span>),</span> <span>initialState</span><span>);</span>
</code></pre></div></div>

<p>And of course, we can try it out:</p>

<div><div><pre><code><span>// the masterful adding machine</span>
<span>// 3²5³ =&gt; 1,125</span>
<span>// 2⁵ =&gt; 32</span>
<span>evaluate</span><span>(</span>
  <span>&#39;</span><span>2/3, 2/5</span><span>&#39;</span><span>,</span>
  <span>1125</span>
<span>)</span>
  <span>//=&gt; 32</span>

<span>// the masterful multiplication machine</span>
<span>// 3³5¹³ =&gt; 32,958,984,375</span>
<span>// 2³⁹ =&gt; 549,755,813,888</span>
<span>evaluate</span><span>(</span>
  <span>&#39;</span><span>182/55, 17/11, 95/119, 1/17, 11/13, 17/19, 11/3, 1/5</span><span>&#39;</span><span>,</span>
  <span>32958984375</span><span>n</span>
<span>)</span>
  <span>//=&gt; 549755813888n</span>
</code></pre></div></div>

<p>It works. And that’s not all… Does this look familiar?</p>

<div><div><pre><code><span>// the masterful fibonacci machine</span>
<span>// 78 * 5⁽⁷⁻¹⁾ =&gt; 1,218,750</span>
<span>// 2¹³ =&gt; 8,192</span>
<span>evaluate</span><span>(</span>
  <span>`17/65, 133/34, 17/19, 23/17, 2233/69, 23/29, 31/23,
   74/341, 31/37, 41/31, 129/287, 41/43, 13/41, 1/13, 1/3`</span><span>,</span>
  <span>1218750</span>
<span>)</span>
  <span>//=&gt; 8192n</span>
</code></pre></div></div>

<p>Our Masterful Minsky Machine evaluates FRACTRAN programs, and it’s not difficult to see why.</p>

<hr/>

<h2 id="on-equivalence">On Equivalence</h2>

<hr/>

<p><img src="https://george.mand.is/assets/images/fractran/alan-turing.jpg" alt="Alan Turing"/></p>

<p><em><a href="https://plato.stanford.edu/entries/turing/">Alan Matheson Turing</a></em></p>

<hr/>

<p>The word “equivalence” has a very specific meaning in computability. When we say that two computation machines are “computationally equivalent,” we mean that they both share some set of properties we consider important with respect to computing, although they may differ wildly in other respects.</p>

<p>Computers that we program with programming languages are computation machines. If we one of them in the language Haskell, and program the other in the language Piet, we can say that they are both computationally equivalent, as there is nothing in principle that we can compute in Haskell that we can’t compute with Piet.<sup id="fnref:Piet" role="doc-noteref"><a href="#fn:Piet" rel="footnote">26</a></sup></p>

<p>Even if “computational equivalence” doesn’t care about how a computation is achieved, <em>how it does it</em> matters in a different, deeper way. The languages <a href="https://coffeescript.org/">CoffeeScript</a> and JavaScript are equivalent in a deeper way than Haskell and Piet, because under the hood, “CoffeeScript is just JavaScript,” as creator <a href="http://ashkenas.com">Jeremy Ashkenas</a> says.</p>

<p>With this in mind, let’s ask ourselves: “Is a Marvellous Minsky Machine equivalent to a FRACTRAN machine in a superficial, computationally equivalent way? Or is there a deeper relationship? If we look under the hood, will we find that “FRACTRAN is just a Marvellous Minsky Machine”?”</p>

<h3 id="fractran-and-marvellous-minsky-machines">fractran and marvellous minsky machines</h3>

<p>Examining the code superficially, FRACTRAN looks very different from the Marvellous Minsky Machine. The core of the FRACTRAN interpreter tests a remainder, then performs one multiplication and one division if the remainder is zero:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>const</span> <span>[</span><span>numerator</span><span>,</span> <span>denominator</span><span>]</span> <span>of</span> <span>program</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>n</span> <span>%</span> <span>denominator</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>{</span>
    <span>n</span> <span>=</span> <span>(</span><span>n</span> <span>*</span> <span>numerator</span><span>)</span> <span>/</span> <span>denominator</span><span>;</span>
    <span>continue</span> <span>program_start</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Whereas, the Marvellous Minsky Machine performs multiple comparisons of magnitude, then performs subtractions, and additions, wrapped in a lot of factorization faff:</p>

<div><div><pre><code><span>const</span> <span>factoredState</span> <span>=</span> <span>toFactors</span><span>(</span><span>state</span><span>);</span>

<span>// check guard clause</span>
<span>const</span> <span>factoredGuard</span> <span>=</span> <span>toFactors</span><span>(</span><span>guard</span><span>);</span>
<span>if</span> <span>([...</span><span>factoredGuard</span><span>.</span><span>keys</span><span>()].</span><span>some</span><span>(</span>
  <span>factor</span> <span>=&gt;</span> <span>factoredGuard</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>)</span> <span>&gt;</span> <span>(</span><span>factoredState</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>)</span> <span>||</span> <span>0</span><span>)</span>
<span>))</span> <span>continue</span><span>;</span>

<span>for</span> <span>(</span><span>const</span> <span>[</span><span>factor</span><span>,</span> <span>guardValue</span><span>]</span> <span>of</span> <span>factoredGuard</span><span>.</span><span>entries</span><span>())</span> <span>{</span>
  <span>const</span> <span>oldStateValue</span> <span>=</span> <span>factoredState</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>);</span>

  <span>factoredState</span><span>.</span><span>set</span><span>(</span><span>factor</span><span>,</span> <span>oldStateValue</span> <span>-</span> <span>guardValue</span><span>);</span>
<span>}</span>

<span>const</span> <span>actionGuard</span> <span>=</span> <span>toFactors</span><span>(</span><span>action</span><span>);</span>
<span>for</span> <span>(</span><span>const</span> <span>[</span><span>factor</span><span>,</span> <span>actionValue</span><span>]</span> <span>of</span> <span>actionGuard</span><span>.</span><span>entries</span><span>())</span> <span>{</span>
  <span>const</span> <span>oldStateValue</span> <span>=</span> <span>factoredState</span><span>.</span><span>get</span><span>(</span><span>factor</span><span>)</span> <span>||</span> <span>0</span><span>;</span>

  <span>factoredState</span><span>.</span><span>set</span><span>(</span><span>factor</span><span>,</span> <span>oldStateValue</span> <span>+</span> <span>actionValue</span><span>);</span>
<span>}</span>

<span>state</span> <span>=</span> <span>fromFactors</span><span>(</span><span>factoredState</span><span>);</span>
</code></pre></div></div>

<p>Those of you familiar with number theory have already grasped that <strong>these are both the same algorithm!</strong></p>

<p>If we divide 1,218,750 by 65 and have no remainder, it’s because:</p>

<ol>
  <li>The prime factorization of 65 is 5¹13¹.</li>
  <li>The prime factorization of 1,218,750 is 2¹3¹5⁶13¹.</li>
  <li>Checking whether the remainder of 1,218,750 by 65 is zero is exactly the same thing as testing whether any of the prime factors of 65 have an exponent greater than the exponent of the same factor in 1,218,750.</li>
</ol>

<p>Likewise, actually dividing 1,218,750 by 65 and getting a result of 18,750 is exactly the same thing as turning  2¹3¹5⁶13¹ into  2¹3¹5⁵13⁰, which is 18,750.That’s just basic arithmetic.</p>

<p>If we look at how our code handles the action clauses, it’s no different. Multiplying 18,750 by 17 is exactly the same thing as turning 2¹3¹5⁵ into 2¹3¹5⁵17¹, for the same reason: “Arithmetic.”</p>

<p>Marvellous Minsky Machines are deeply related to FRACTRAN interpreters, because they <strong>are</strong> FRACTRAN interpreters. We’re just doing a lot of things by hand that the <code>%</code>, <code>/</code>, and <code>*</code> operators do for us in JavaScript, or whatever language Conway used in 1972, had he bothered to write a computer implementation.</p>

<h3 id="polygame">polygame</h3>

<p>In 1979, Ludmila Gregušová and Ivan Korec published “Small Universal Minsky Machines” in The Proceedings of the 8th Symposium on Mathematical Foundations in Computer Science. In it, they describe <em>universal</em> Minsky Machines that can compute anything computable.<sup id="fnref:summ" role="doc-noteref"><a href="#fn:summ" rel="footnote">27</a></sup></p>

<p>In the paper, they present a universal machine, <code>U</code>, with 37 rules. It can simulate a Minsky Machine, just as a Universal Turing Machine can simulate any Turing Machine. A Universal Minsky Machine takes as its input a description of another Minsky Machine, plus input for that machine, and produces as its output what the described Minsky Machine would produce.</p>

<p>These machines are ingenious, and a lot of work goes into figuring out exactly how to encode the machine to be simulated so that it’s amenable to being simulated. For example, Gregušová and Korec also give a 32-rule universal machine, but it requires an enormously larger encoding for the simulated machine than the 37-rule version.</p>

<p>Now, what do Universal Minsky Machines tell us about FRACTRAN?</p>

<p>Well, if:</p>

<ol>
  <li>A Magnificent Minsky Machine, U, can simulate any Magnificent Minsky Machine, and;</li>
  <li>For every Magnificent Minsky Machine, there is an equivalent Marvellous Minsky Machine, and;</li>
  <li>For every Marvellous Minsky Machine, there is an equivalent FRACTRAN program, therefore:</li>
  <li><em>For every Magnificent Minsky Machine, there is an equivalent FRACTRAN program</em>.</li>
</ol>

<p>And thus:</p>

<ol>
  <li>Since there exists a Magnificent Minsky Machine, U, that can simulate any Magnificent Minsky Machine,</li>
  <li>Therefore, there exists a FRACTRAN program, that can simulate any FRACTRAN program.</li>
</ol>

<p>And here it is, John Horton Conway’s POLYGAME:</p>

<hr/>

<p><img src="https://george.mand.is/assets/images/fractran/polygame.png" alt="POLYGAME"/></p>

<p><em>An excerpt of Conway’s paper on FRACTRAN, showing the POLYGAME program.</em></p>

<hr/>

<p>There is a wonderful explanation of POLYGAME’s workings in <a href="https://george.mand.is/assets/fractran/open-problems-in-communication-and-computation-1987.pdf">Open Problems in Communication &amp; Computation</a>. Polygame can compute <em>any</em> computable function, we just have to find the function’s “catalogue number.”  You’ll want to read Conway’s original description to grasp how that works.</p>

<p>But the thing to know about POLYGAME is that every recursively enumerable function <em>f</em> has a catalogue number, <em>c</em>. And given <code>c * 2 ^ 2 ^ n</code>, POLYGAME will produce <code>2 ^ 2 ^ f(n)</code>.</p>

<p>POLYGAME is a Universal FRACTRAN Program.<sup id="fnref:golf" role="doc-noteref"><a href="#fn:golf" rel="footnote">28</a></sup></p>

<h2 id="the-collatz-conjecture">The Collatz Conjecture</h2>

<hr/>

<p><a href="https://en.wikipedia.org/wiki/Lothar_Collatz"><img src="https://george.mand.is/assets/images/fractran/LotharCollatz.jpg" alt="Lothar Collatz"/></a></p>

<p><em>Lothar Collatz in mid-lecture.</em></p>

<hr/>

<p><a href="https://en.wikipedia.org/wiki/Collatz_conjecture">The Collatz conjecture</a> is a conjecture in mathematics that concerns a sequence defined as follows: Start with any positive integer <em>n</em>. Then each term is obtained from the previous term as follows: if the previous term is even, the next term is one half of the previous term. If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.</p>

<p>The sequence of terms obtained in this manner is known as the Collatz sequence. The conjecture is named after <a href="https://en.wikipedia.org/wiki/Lothar_Collatz">Lothar Collatz</a>, who introduced the idea in 1937, two years after receiving his doctorate.</p>

<p>Here’s a FRACTRAN program to test the Collatz Conjecture for any <em>x</em>. We set <em>n</em> to be 2ˣ, and then every subsequent value of <em>n</em> of the form 2ʸ is the next term of the Collatz sequence.</p>

<div><div><pre><code>165/14, 11/63, 38/21, 13/7, 34/325, 1/13,
184/95, 1/19, 7/11, 13/17, 19/23, 1575/4
</code></pre></div></div>

<p>It halts when it reaches 2¹, corresponding to the original Collatz sequence reaching 1. If you can find a number <em>Z</em> that disproves the Collatz conjecture, this program will run forever when given 2ᶻ.</p>

<p>If you want to run it, the existing FRACTRAN interpreter given above will work, albeit it won’t give any clue as to what is happening. As an exercise, you might want to try rewriting our FRACTRAN interpreter to output the machine’s state after every pass over the program.</p>

<p>If you’re really ambitious, you’ll rewrite the interpreter as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">generator</a>. That will allow you to output the Collatz sequence. Here’s a sample implementation:</p>

<div><div><pre><code><span>function</span> <span>*</span> <span>interpret</span> <span>(</span><span>program</span><span>,</span> <span>n</span><span>)</span> <span>{</span>
  <span>program_start</span><span>:</span> <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>yield</span> <span>n</span><span>;</span>
    <span>for</span> <span>(</span><span>const</span> <span>[</span><span>numerator</span><span>,</span> <span>denominator</span><span>]</span> <span>of</span> <span>program</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>n</span> <span>%</span> <span>denominator</span> <span>===</span> <span>0</span><span>n</span><span>)</span> <span>{</span>
        <span>n</span> <span>=</span> <span>(</span><span>n</span> <span>*</span> <span>numerator</span><span>)</span> <span>/</span> <span>denominator</span><span>;</span>
        <span>continue</span> <span>program_start</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>break</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>const</span> <span>parse</span> <span>=</span> <span>program</span> <span>=&gt;</span> <span>program</span>
  <span>.</span><span>trim</span><span>().</span><span>split</span><span>(</span><span>/</span><span>(?:\s</span><span>*,|</span><span>\s)\s</span><span>*/</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>f</span> <span>=&gt;</span> <span>f</span><span>.</span><span>split</span><span>(</span><span>&#39;</span><span>/</span><span>&#39;</span><span>).</span><span>map</span><span>(</span><span>n</span> <span>=&gt;</span> <span>BigInt</span><span>(</span><span>n</span><span>)));</span>

<span>const</span> <span>collatz</span> <span>=</span>
  <span>&#39;</span><span>165/14, 11/63, 38/21, 13/7, 34/325, 1/13, </span><span>&#39;</span> <span>+</span>
  <span>&#39;</span><span>184/95, 1/19, 7/11, 13/17, 19/23, 1575/4</span><span>&#39;</span><span>;</span>

<span>function</span> <span>test</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
  <span>const</span> <span>n</span> <span>=</span> <span>pow</span><span>(</span><span>2</span><span>n</span><span>,</span> <span>x</span><span>);</span>

  <span>for</span> <span>(</span><span>const</span> <span>nn</span> <span>of</span> <span>interpret</span><span>(</span><span>parse</span><span>(</span><span>collatz</span><span>),</span> <span>n</span><span>))</span> <span>{</span>
    <span>if</span> <span>(</span><span>log2</span><span>(</span><span>nn</span><span>)</span> <span>!=</span> <span>undefined</span><span>)</span>  <span>console</span><span>.</span><span>log</span><span>(</span><span>log2</span><span>(</span><span>nn</span><span>).</span><span>toString</span><span>());</span>
  <span>}</span>
<span>}</span>

<span>test</span><span>(</span><span>3</span><span>)</span>
  <span>//=&gt;</span>
    <span>3</span>
    <span>10</span>
    <span>5</span>
    <span>16</span>
    <span>8</span>
    <span>4</span>
    <span>2</span>
    <span>1</span>
</code></pre></div></div>

<p>Interesting. And?</p>

<h3 id="why-fractran-really-matters">why fractran really matters</h3>

<hr/>

<p><a href="https://www.conwaylife.com/wiki/Collatz_5n%2B1_simulator"><img src="https://george.mand.is/assets/images/fractran/Collatz5nplus1simulator.png" alt="Collatz 5n+1 simulator"/></a></p>

<p><em>The <a href="https://www.conwaylife.com/wiki/Collatz_5n%2B1_simulator">Collatz 5n+1 simulator</a> is an unknown fate pattern constructed by David Bell in December 2017 that simulates the Collatz 5n+1 algorithm using sliding block memory and p1 technology, while always having a population below 32000.</em><sup id="fnref:collatz-life" role="doc-noteref"><a href="#fn:collatz-life" rel="footnote">29</a></sup></p>

<hr/>

<p>In <a href="https://george.mand.is/assets/fractran/Conway-On-Unsettleable-Arithmetical-Problems.pdf">On Unsettleable Arithmetical Problems</a>, Conway described the specific Collatz function <code>n/2 | 3n + 1</code> as a <em>bipartite linear function</em>. He then generalized the idea to <em>k-partite linear functions</em>, with <em>k</em> linear possibilities.</p>

<p>A Collatz function is a k-partite linear function where each possibility is defined as <code>(a * n / b) + c</code>, and the value of the entire function is the first linear possibility with an integral result.</p>

<p>Next, Conway described the <em>Collatz Game</em>, which takes a Collatz function, a starting value of <em>n</em>, and a <em>target value</em>. For the Collatz conjecture, the Collatz function is <code>n/2 | 3n + 1</code> and the target value is 1.</p>

<p>The Collatz game consists of generating the Collatz sequence for <em>n</em>, and stopping when when its next term is the target value, when its next term is undefined, or when the sequence enters a loop.</p>

<p>We say that a Collatz game is <em>decidable</em> if we can create an algorithm for determining whether that game reaches the target value for all starting values of <em>n</em>. Lots of Collatz games are decidable. For example, the game <code>n/2 | n + 1</code> is decidable.</p>

<p>Where does FRACTRAN come in?</p>

<p>Every FRACTRAN program is a k-partite Collatz function where the value of <em>c</em> for every possibility is 0. Thus, every FRACTRAN program is both a Collatz function and the basis of a Collatz game. We will call the set of all Collatz games that are also FRACTRAN programs, <em>FRACTRAN games</em>.</p>

<p><a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice’s Theorem</a> states that all non-trivial, semantic properties of programs are undecidable. That includes whether the program enters a particular state. For a FRACTRAN program, its state is encoded in <em>n</em>, so it is undecidable whether FRACTRAN programs ever generate a particular target value of <em>n</em>.</p>

<p>And it follows that <em>FRACTRAN games</em> are undecidable. This doesn’t speak directly to the Collatz conjecture, because <code>(1/2)n | 3n + 1</code> is not a FRACTRAN game. But it does follow that <em>arbitrary</em> Collatz games are undecidable, since the set of all Collatz games includes the set of all FRACTRAN games.</p>

<p>Conway went on to do much more work on the subject of Collatz functions and Collatz games, including addressing Collatz functions like <code>(1/2)n | 3n + 1</code> through the medium of POLYGAME. Others have taken these ideas further. Stuart A. Kurtz and Janos Simon built upon Conways’ work with FRACTRAN in <a href="https://george.mand.is/assets/fractran/undecidability-generalized-collatz-problem.pdf%20%E2%80%9CThe%20Undecidability%20of%20the%20Generalized%20Collatz%20Problem%E2%80%9D">The Undecidability of the Generalized Collatz Problem</a>.</p>

<p>FRACTRAN, then, is more than just a ridiculous way to represent register machines: Its correspondence to Collatz functions and its universality make a direct contribution to our understanding of Collatz functions, and may help us one day determine whether the Collatz Conjecture is provably true, or undecidable.</p>

<p><em>THE END</em></p>

<p>(discuss on <a href="https://www.reddit.com/r/math/comments/gi9x0k/remembering_john_conways_fractran_a_ridiculous/">/r/math</a>, <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/ghpek3/remembering_john_conways_fractran_a_ridiculous/">/r/programminglanguages</a>, and <a href="https://news.ycombinator.com/item?id=23142232">hacker hews</a>)</p>

<hr/>

<h2 id="addenda">Addenda</h2>

<hr/>

<p><a href="https://www.flickr.com/photos/thane/20366806"><img src="https://george.mand.is/assets/images/fractran/jhc.jpg" alt="John Horton Conway © 2005 Thane Plambeck"/></a></p>

<p><em>John Horton Conway © 2005 Thane Plambeck</em></p>

<hr/>

<h3 id="conways-fractran-a-ridiculous-logical-language-lecture">conway’s “fractran: a ridiculous logical language” lecture</h3>



<iframe width="560" height="315" src="https://www.youtube.com/embed/548BH-YFT1E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>



<h3 id="norman-wildbergers-lecture-on-the-collatz-conjecture">norman wildberger’s lecture on the collatz conjecture</h3>



<iframe width="560" height="315" src="https://www.youtube.com/embed/K0yMyUn--0s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>



<h3 id="vikram-ramanathan-on-fractran">vikram ramanathan on fractran</h3>

<p><a href="https://vikramramanathan.com">Vikram Ramanathan</a> has written <a href="https://george.mand.is/assets/fractran/ramanathan.pdf">a nice, compact essay</a> about their experience developing a FRACTRAN interpreter and how to approach FRACTRAN programming.</p>

<hr/>

<h3 id="notes">notes</h3>


        </section>

        


      </div>
    </div></div>
  </body>
</html>
