<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://angelolloti.com/blog/trust-3">Original</a>
    <h1>Parsing Terraria&#39;s .wld Files (trust pt. 3)</h1>
    
    <div id="readability-page-1" class="page"><div>   <div><div> <p><a href="https://angelolloti.com/blog/?tag=binary">binary</a><span>, </span><a href="https://angelolloti.com/blog/?tag=rust">rust</a><span>, </span><a href="https://angelolloti.com/blog/?tag=trust">trust</a><span></span></p><!-- HTML_TAG_START --><p>Welcome to part three of my journey through writing a Terraria game server in Rust. Since <a href="https://angelolloti.com/blog/trust-2">part 2</a>, I&#39;ve gotten the client to be able to enter a password and begin to connect.</p>
<h2>Protocol Recap</h2>
<p>When a player first connects, they send the version identifier using a type 1 packet. It is a string with the length annotated by the first byte. <code>5265727261726961323739</code> is <code>Terraria279</code> in ASCII.</p>
<pre><code>[c-&gt;s]: (1) 0b5465727261726961323739
</code></pre><p>If the server has a password, it sends a type 37 packet with no data to challenge the client.</p>
<pre><code>[s-&gt;c]: (37) 
</code></pre><p>The client is prompted and sends back the password. This is once again a byte-annotated string. <code>70617373776f7264</code> is <code>password</code> in ASCII.</p>
<pre><code>[c-&gt;s]: (38) 0870617373776f7264
</code></pre><p>If the password is incorrect, the server can send back text using a type 2 packet to refuse the connection. If the password is correct or there is no password, the server sends the player a type 3 packet. The first byte represents the player&#39;s ID on the server. The second is a boolean that is always set to false.</p>
<pre><code>[s-&gt;c]: (3) 0000
</code></pre><p>After this, the client begins sending a whole bunch of data about their player. First is type 4, which represents the player&#39;s character details.</p>
<pre><code>[c-&gt;s]: (4) 000000036c6f6c00000000d75a37ff7d5a695a4bafa58ca0b4d7ffe6afa0693c001000
</code></pre><p>The packet is represented by the following struct. For more information on what each bit in the flags signifies, check the <a href="https://github.com/xDimGG/trust/blob/48271674c6bb3636baf524f058809722af0a64c9/src/network/messages.rs#L105-L129">code comments</a>.</p>
<pre><code>
PlayerDetails {
    client_id: <span>u8</span>,
    skin_variant: <span>u8</span>,
    hair: <span>u8</span>,
    name: <span>String</span>,
    hair_dye: <span>u8</span>,
    hide_accessory: <span>u16</span>,
    hide_misc: <span>u8</span>,
    hair_color: RGB,
    skin_color: RGB,
    eye_color: RGB,
    shirt_color: RGB,
    undershirt_color: RGB,
    pants_color: RGB,
    shoe_color: RGB,
    flags_1: <span>u8</span>,
    flags_2: <span>u8</span>,
    flags_3: <span>u8</span>,
},
</code></pre><p>The Terraria server does a couple of checks here.</p>
<ol>
<li>The character name does not match someone else&#39;s name on the server.</li>
<li>The name is no more than 20 characters long.</li>
<li>The name is not empty (<code>name != &#34;&#34;</code>).</li>
<li>The player and world are both <a href="https://terraria.fandom.com/wiki/Journey_Mode">journey mode</a> or both not journey mode.</li>
</ol>
<p>If everything is good, the player&#39;s character details are emitted to all the other players in the server.</p>
<p>Next up is the player&#39;s UUID. This is again just a string. <code>38663037383932632d663363302d346433332d613966392d616435313932356462393532</code> represents <code>8f07892c-f3c0-4d33-a9f9-ad51925db952</code> in ASCII. The server doesn&#39;t actually have to do anything with this.</p>
<pre><code>[c-&gt;s]: (68) 2438663037383932632d663363302d346433332d613966392d616435313932356462393532
</code></pre><p>Next is the player&#39;s health and mana. Only the health has to be broadcasted to other players.</p>
<pre><code>[c-&gt;s]: (16) 0064006400
[c-&gt;s]: (42) 0014001400
</code></pre><pre><code>
PlayerHealth {
    client_id: <span>u8</span>,
    current: <span>i16</span>,
    maximum: <span>i16</span>,
},


PlayerMana {
    client_id: <span>u8</span>,
    current: <span>i16</span>,
    maximum: <span>i16</span>,
},
</code></pre><p>Next is any buffs the player has active. This gets broadcasted.</p>
<pre><code>[c-&gt;s]: (50) 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
</code></pre><pre><code>
PlayerBuffs {
    client_id: <span>u8</span>,
    buffs: [<span>u16</span>; MAX_BUFFS],
},
</code></pre><p>Next is the player&#39;s active loadout. As of Terraria 1.4.4, player&#39;s can have different armor loadouts so this packet notifies the server of which loadout the player has active and what accessories to hide. This gets broadcasted.</p>
<pre><code>[c-&gt;s]: (147) 00000000
</code></pre><pre><code>
PlayerLoadout {
    client_id: <span>u8</span>,
    index: <span>u8</span>,
    hide_accessory: <span>u16</span>,
},
</code></pre><p>Next, the player sends a whole bunch of type 5 packets. It represents each item the player has on their character. This includes not just inventory items, but also armor, ammo, other loadouts, and more. This gets broadcasted.</p>
<pre><code>
PlayerInventorySlot {
    client_id: <span>u8</span>,
    slot_id: <span>i16</span>,
    amount: <span>i16</span>,
    prefix: <span>u8</span>,
    item_id: <span>i16</span>,
},
</code></pre><p>Finally, the player sends an empty packet with type 6, which triggers the server to send metadata about the world. After that is received, the client send a type 8 packet which makes the server send back even more world data, which includes some tile data. All the packets until now have been quite simple to implement, but now the client is expecting world data and our program doesn&#39;t hold a world.</p>
<h2>Parsing .wld Files</h2>
<p>In order to get some world data, we should probably parse the .wld file that Terraria store&#39;s world data in. I googled around a bit and it seems that others have already figured out, documented, and written parsers for it in the past. Notably, there is <a href="https://github.com/TEdit/Terraria-Map-Editor">Terraria Map Editor</a>, which provides a UI for editing Terraria world files and updating lots of tiles at once with Microsoft Paint-like tools. It&#39;s a neat tool and could be a good reference point to work off. However, after exploring the decompiled code some more, there is a <code>WorldFile</code> class which contains a <code>LoadWorld</code> method. It&#39;s actually not that hard to read, so I&#39;m just going to work off that.</p>
<p>For starters, where does Terraria store <code>.wld</code> file? On Windows, it&#39;s in <code>Documents &gt; My Games &gt; Terraria &gt; Worlds</code>. On macOS, it&#39;s in <code>~/Library/Application Support/Terraria/Worlds</code>. Let&#39;s get the contents of the file and pass it to the reader that was created in <a href="https://angelolloti.com/blog/trust-2">part 2</a>.</p>
<pre><code><span>let</span> <span>contents</span> = fs::<span>read</span>(<span>&#34;Courtyard_of_Grasshoppers.wld&#34;</span>).<span>unwrap</span>();
<span>let</span> <span>mut </span><span>reader</span> = Reader::<span>new</span>(contents.<span>as_slice</span>());
</code></pre><p>In the decompiled code, the first thing done on the reader is ReadInt32(), and <code>WorldFile._versionNumber</code> is set to that number. Similarly, in our code, we can write the following.</p>
<pre><code><span>let</span> <span>version</span> = reader.<span>read_i32</span>();
<span>println!</span>(<span>&#34;File version: {}&#34;</span>, version);
</code></pre><p>Running this, we get:</p>
<pre><code>File version: 279
</code></pre><p>Nice. It&#39;s the same as the Terraria version from earlier. At this point, there is a branch in the code. Before version 88, we call <code>WorldFile.LoadWorld_Version1_Old_BeforeRelease88</code>. Starting from version 88, <code>WorldFile.LoadWorld_Version2</code> is called. Let&#39;s go ahead and just implement <code>WorldFile.LoadWorld_Version2</code>. We can always support older versions later. Within <code>LoadWorld_Version2</code>, the first function called is <code>LoadFileFormatHeader</code>, which looks like so.</p>
<pre><code><span><span>public</span> <span>static</span> <span>bool</span> <span>LoadFileFormatHeader</span>(<span>BinaryReader reader, <span>out</span> <span>bool</span>[] importance, <span>out</span> <span>int</span>[] positions</span>)</span> {
    importance = (<span>bool</span>[]) <span>null</span>;
    positions = (<span>int</span>[]) <span>null</span>;
    <span>if</span> ((WorldFile._versionNumber = reader.ReadInt32()) &gt;= <span>135</span>) {
        <span>try</span> {
            Main.WorldFileMetadata = FileMetadata.Read(reader, FileType.World);
        }
        <span>catch</span> (FormatException ex) {
            Console.WriteLine(Language.GetTextValue(<span>&#34;Error.UnableToLoadWorld&#34;</span>));
            Console.WriteLine((<span>object</span>) ex);
            <span>return</span> <span>false</span>;
        }
    }
    <span>else</span>
        Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
    <span>short</span> length1 = reader.ReadInt16();
    positions = <span>new</span> <span>int</span>[(<span>int</span>) length1];
    <span>for</span> (<span>int</span> index = <span>0</span>; index &lt; (<span>int</span>) length1; ++index)
        positions[index] = reader.ReadInt32();
    <span>ushort</span> length2 = reader.ReadUInt16();
    importance = <span>new</span> <span>bool</span>[(<span>int</span>) length2];
    <span>byte</span> num1 = <span>0</span>;
    <span>byte</span> num2 = <span>128</span>;
    <span>for</span> (<span>int</span> index = <span>0</span>; index &lt; (<span>int</span>) length2; ++index) {
        <span>if</span> (num2 == (<span>byte</span>) <span>128</span>) {
            num1 = reader.ReadByte();
            num2 = (<span>byte</span>) <span>1</span>;
        }
        <span>else</span>
            num2 &lt;&lt;= <span>1</span>;
        <span>if</span> (((<span>int</span>) num1 &amp; (<span>int</span>) num2) == (<span>int</span>) num2)
            importance[index] = <span>true</span>;
    }
    <span>return</span> <span>true</span>;
}
</code></pre><p>Ok, so a call to <code>FileMetadata.Read</code> is made. We can navigate to <code>FileMetadata</code> and find that the <code>Read</code> method looks like this.</p>
<pre><code><span><span>private</span> <span>void</span> <span>Read</span>(<span>BinaryReader reader</span>)</span> {
    <span>long</span> num1 = (<span>long</span>) reader.ReadUInt64();
    <span>if</span> ((num1 &amp; <span>72057594037927935L</span>) != <span>27981915666277746L</span>)
        <span>throw</span> <span>new</span> FormatException(<span>&#34;Expected Re-Logic file format.&#34;</span>);
    <span>byte</span> num2 = (<span>byte</span>) ((<span>ulong</span>) num1 &gt;&gt; <span>56</span> &amp; (<span>ulong</span>) <span>byte</span>.MaxValue);
    FileType fileType = FileType.None;
    FileType[] values = (FileType[]) Enum.GetValues(<span>typeof</span> (FileType));
    <span>for</span> (<span>int</span> index = <span>0</span>; index &lt; values.Length; ++index) {
        <span>if</span> (values[index] == (FileType) num2) {
            fileType = values[index];
            <span>break</span>;
        }
    }
    <span>this</span>.Type = fileType != FileType.None ? fileType : <span>throw</span> <span>new</span> FormatException(<span>&#34;Found invalid file type.&#34;</span>);
    <span>this</span>.Revision = reader.ReadUInt32();
    <span>this</span>.IsFavorite = ((<span>long</span>) reader.ReadUInt64() &amp; <span>1L</span>) == <span>1L</span>;
}
</code></pre><p>If we convert <code>72057594037927935</code> to binary, it&#39;s just 56 <code>1</code>s. If we convert <code>27981915666277746</code> to hexadecimal and use an online hex to ASCII tool, we get <code>cigoler</code>. That&#39;s <code>relogic</code> backwards. <code>Re-Logic</code> is the name of the company that made Terraria. This seems to be a magic number for Re-Logic files. The reason it&#39;s backwards is that we are using little endian encoding. Let&#39;s go ahead and add a check for this magic number.</p>
<pre><code><span>let</span> <span>magic</span> = reader.<span>read_bytes</span>(<span>7</span>);
<span>if</span> magic != <span>&#34;relogic&#34;</span>.<span>as_bytes</span>() {
    <span>panic!</span>(<span>&#34;not a relogic file&#34;</span>)
}
</code></pre><p>After this, we can read the <code>fileType</code> as 1 byte.</p>
<pre><code><span>let</span> <span>file_type</span> = reader.<span>read_byte</span>()?;
</code></pre><p>Running the code, we get this.</p>
<pre><code>File type: 2
</code></pre><p>The code corresponds to this enum.</p>
<pre><code><span>public</span> <span>enum</span> FileType : <span>byte</span> {
    None,
    Map,
    World,
    Player,
}
</code></pre><p>Since we are dealing with a world file, the value 2 makes sense. Next is <code>this.Revision = reader.ReadUInt32();</code> and <code>this.IsFavorite = ((long) reader.ReadUInt64() &amp; 1L) == 1L;</code>.</p>
<pre><code><span>let</span> <span>revision</span> = reader.<span>read_u32</span>();
<span>println!</span>(<span>&#34;Revision: {}&#34;</span>, revision);
<span>let</span> <span>favorite</span> = reader.<span>read_u64</span>() &amp; <span>1</span> == <span>1</span>;
<span>println!</span>(<span>&#34;Is favorite: {}&#34;</span>, favorite);
</code></pre><p>Now, we get this output.</p>
<pre><code>File version: 279
File type: 2
Revision: 3
Is favorite: false
</code></pre><p>Looks pretty good. Back to the parent function, <code>LoadFileFormatHeader</code>, we read the positions like so.</p>
<pre><code><span>short</span> length1 = reader.ReadInt16();
positions = <span>new</span> <span>int</span>[(<span>int</span>) length1];
<span>for</span> (<span>int</span> index = <span>0</span>; index &lt; (<span>int</span>) length1; ++index)
    positions[index] = reader.ReadInt32();
</code></pre><p>Let&#39;s go ahead and do that in Rust.</p>
<pre><code><span>let</span> <span>mut </span><span>positions</span> = <span>Vec</span>::<span>with_capacity</span>(reader.<span>read_i16</span>() <span>as</span> <span>usize</span>);
<span>for</span> <span>_</span> <span>in</span> <span>0</span>..positions.<span>capacity</span>() {
    positions.<span>push</span>(reader.<span>read_i32</span>());
}
<span>println!</span>(<span>&#34;File positions: {:?}&#34;</span>, positions);
</code></pre><p>With this in place, we get this in our console:</p>
<pre><code>File positions: [159, 3413, 6618450, 6656473, 6656475, 6656542, 6656546, 6656550, 6656554, 6656576, 6656607]
</code></pre><p>What the Terraria world parser does is that after reading each section of data, it checks that the cursor is at the correct position before proceeding. This turns out to be <em>really</em> useful when reading the file myself. It prevents me from accidentally reading loads of garbage without realizing and provides checkpoints for me as I&#39;m writing the parser. If we parsed some block but the cursor doesn&#39;t match, it&#39;s a sign that we did something wrong.</p>
<p>Next up is the code for getting the &#34;importance&#34; of things. At this point it&#39;s not clear what this is for, but becomes apparent when reading the tiles. &#34;important&#34; tiles contain extra data.</p>
<pre><code><span>let</span> <span>mut </span><span>importance</span> = <span>vec!</span>[<span>false</span>; reader.<span>read_u16</span>() <span>as</span> <span>usize</span>];
<span>let</span> <span>mut </span><span>byte</span> = <span>0</span>;
<span>let</span> <span>mut </span><span>mask</span> = <span>128</span>;
<span>for</span> <span>i</span> <span>in</span> &amp;<span>mut</span> importance {
    <span>if</span> mask == <span>128</span> {
        byte = reader.<span>read_byte</span>();
        mask = <span>1</span>;
    } <span>else</span> {
        mask &lt;&lt;= <span>1</span>;
    }

    <span>if</span> (byte &amp; mask) == mask {
        *i = <span>true</span>;
    }
}
<span>println!</span>(<span>&#34;Importance count: {}&#34;</span>, importance.<span>len</span>());
</code></pre><p>All that this code is doing is reading the individual bits of the reader as booleans. Running this spits out:</p>
<pre><code>Importance count: 693
</code></pre><p>We may also check our <code>reader.cur</code> at this point and see that it is <code>159</code>, which matches the first position in our positions array.</p>
<p>You can imagine how the rest of this goes. It&#39;s basically just writing a bunch of <a href="https://github.com/xDimGG/trust/blob/main/src/world/types.rs">structs and enums</a> and lots of calls to the <a href="https://github.com/xDimGG/trust/blob/main/src/world/reader.rs">reader</a>. Writing it all out in a blog post would take a very long time and be quite boring. I&#39;ll just tell you the most interesting part.</p>
<h2>Parsing Strings, Revisited</h2>
<p>Once I finished writing the parser, my world file was working just fine. However, I tried downloading someone else&#39;s world file and got an error from <code>str::from_utf8</code>. For some reason, the string wasn&#39;t being parsed correctly. At first, I thought that maybe Terraria files don&#39;t use UTF-8 strings, so I poked around the decompiled code a bit and couldn&#39;t figure out what was wrong. I tried checking the C# documentation for information on how <a href="https://learn.microsoft.com/en-us/uwp/api/windows.storage.streams.datawriter.writestring?view=winrt-22621">WriteString</a> encodes the string, however, the only thing the page says is <code>Writes a string value to the output stream.</code>. Very helpful, Microsoft. I walked away from my computer a bit and that&#39;s when it hit me that maybe the strings I&#39;m reading are just too long. Up to this point, I parsed strings by reading the first byte as the length and the rest as the string, which means that I could only support strings of length less than 256. As it turns out, this is not what the C# <code>DataWriter</code> does. In fact, it uses a varying-length integer, similar to UTF-8. What this means is that the first bit represents whether there is still more data about the length.</p>
<p>Suppose we have a string of length 64. Its length will just be encoded as <code>01000000</code>. If our string&#39;s length is 300, which is <code>100101100</code> in binary. The first byte will contain the least seven bits of the number, <code>0101100</code>. The most significant bit will be set to <code>1</code> to signify that there are still more bits to read. The second byte will contain the remaining bits, <code>10</code>, with the most significant bit set to <code>0</code> to signify that there are no more bits. In the end, our <code>300</code> becomes <code>10101100 00000010</code>. Two bytes. Until now, I&#39;ve treated the string length as just 1 byte, which means we actually couldn&#39;t support any string whose length is greater than 127, since the first bit is reserved.</p>
<p>Our updated <code>read_string</code> function looks like this now.</p>
<pre><code><span>pub</span> <span>fn</span> <span>read_length</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> <span>usize</span> {
    <span>let</span> <span>mut </span><span>length</span> = <span>self</span>.<span>read_byte</span>() <span>as</span> <span>usize</span>;
    <span>let</span> <span>mut </span><span>shift</span> = <span>7</span>;
    <span>while</span> length &amp; (<span>1</span> &lt;&lt; shift) != <span>0</span> {
        length &amp;= !(<span>1</span> &lt;&lt; shift);
        length |= (<span>self</span>.<span>read_byte</span>() <span>as</span> <span>usize</span>) &lt;&lt; shift;
        shift += <span>7</span>;
    }

    length
}

<span>pub</span> <span>fn</span> <span>read_string</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> <span>String</span> {
    <span>let</span> <span>length</span> = <span>self</span>.<span>read_length</span>();
    std::<span>str</span>::<span>from_utf8</span>(<span>self</span>.<span>read_bytes</span>(length)).<span>unwrap_or</span>(<span>&#34;&#34;</span>).<span>to_string</span>()
}
</code></pre><p>On the write side, it looks like this.</p>
<pre><code><span>pub</span> <span>fn</span> <span>write_length</span>(&amp;<span>mut</span> <span>self</span>, <span>mut</span> len: <span>usize</span>) {
    <span>while</span> len &gt;= (<span>1</span> &lt;&lt; <span>7</span>) {
        <span>self</span>.<span>write_byte</span>((len &amp; <span>0b1111111</span>) <span>as</span> <span>u8</span> | (<span>1</span> &lt;&lt; <span>7</span>));
        len &gt;&gt;= <span>7</span>;
    }

    <span>self</span>.<span>write_byte</span>(len <span>as</span> <span>u8</span>)
}

<span>pub</span> <span>fn</span> <span>write_string</span>(&amp;<span>mut</span> <span>self</span>, string: <span>String</span>) {
    <span>self</span>.<span>write_length</span>(string.<span>len</span>());
    <span>self</span>.<span>write_bytes</span>(string.<span>as_bytes</span>().<span>to_vec</span>())
}
</code></pre><h2>Up and Running</h2>
<p>Anyway, with that figured out, the World file parser is done! It has an annoyingly large number of fields, but it works. This means that now, we can begin to send world data to the player.</p>
<p><img src="https://angelolloti.com/trust-3.png" alt="connecting to trust server"/></p>
<p>It works! For some reason, Re-Logic decided to make world tile packets zlib-compressed, which meant I had to dig into <a href="https://github.com/DinoChiesa/DotNetZip">DotNetZip</a> to figure out exactly what parameters were being used. It turns out that the way Terraria uses the library ends up removing the zlib header and trailing checksum. It was quite tricky to figure out, but using the proxy made it easier. As a bonus, I added this to the proxy:</p>
<pre><code>disp_data = data[<span>1</span>:]
<span>if</span> data[<span>0</span>] == <span>10</span>:
    disp_data = zlib.decompress(disp_data, wbits=-<span>15</span>)
<span>print</span>(<span>f&#39;<span>{prefix}</span> (<span>{data[<span>0</span>]}</span>) <span>{disp_data.<span>hex</span>()}</span>&#39;</span>)
</code></pre><p>which decompresses any packets containing tile data.</p>
<h2>Closing Notes</h2>
<p>So, we have our world and we can move around in it. We can even break blocks, but breaking stuff doesn&#39;t drop anything. In fact, everything we&#39;re doing is only on the client side. In order to support block-breaking and whatnot, we&#39;ll need to mutate the world object. We&#39;ll also have to be able to save the world, which means doing everything we just did in reverse. We&#39;ve come a lot further than what I though would be possible! Everything from here should be smooth sailing. See you again in part 4!</p>
<!-- HTML_TAG_END --></div></div> 
			
			
		</div></div>
  </body>
</html>
