<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nikolaivazquez.com/blog/divan/">Original</a>
    <h1>Divan: Fast and Simple Benchmarking for Rust</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="announcing-divan">Announcing Divan!</h2>
<p><a href="https://github.com/nvzqz/divan">Divan</a> is a framework for quick <strong>comfy
bench</strong>marking of <a href="https://www.rust-lang.org">Rust</a> code.</p>
<p>Get started easily with <a href="#examples">examples</a> that span from introductory to advanced
scenarios. The entire <a href="https://github.com/nvzqz/divan/tree/v0.1.0/examples/benches">example benchmark
suite</a> compiles and
runs in 40 seconds on my machine.</p>
<h2 id="compared-to-criterion">Compared to Criterion</h2>
<p>The current go-to Rust benchmarking library is
<a href="https://github.com/bheisler/criterion.rs">Criterion.rs</a>, a port of <a href="https://github.com/haskell/criterion">Haskell’s
Criterion</a>. It works very well and has
many useful features.</p>
<p>However, I believed we could have a <a href="#simpler-benchmarking">simpler API</a> while
being more powerful, such as <a href="#generic-benchmarks">benchmarking generic functions</a>.</p>
<h2 id="follow-along">Follow Along</h2>
<details><summary>Run these benchmarks locally! Steps:</summary><ol>
<li>
<p><a href="https://www.rust-lang.org/tools/install">Install Rust</a></p>
</li>
<li>
<p>Clone the repository:</p>
<pre is:raw="" tabindex="0"><code><span><span>git</span><span> </span><span>clone</span><span> </span><span>https://github.com/nvzqz/divan.git</span></span>
<span><span>cd</span><span> </span><span>divan/examples</span></span></code></pre>
</li>
<li>
<p>Open <a href="https://github.com/nvzqz/divan/blob/v0.1.0/examples/benches/scratch.rs"><code>divan/examples/benches/scratch.rs</code></a>
in your editor:</p>
<pre is:raw="" tabindex="0"><code><span><span>// scratch.rs</span></span>
<span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span></span>
<span><span>    divan</span><span>::</span><span>main</span><span>();</span></span>
<span><span>}</span></span></code></pre>
<p>This can be run with:</p>
<pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-q</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>--bench</span><span> </span><span>scratch</span></span></code></pre>
</li>
</ol></details>
<h2 id="usage">Usage</h2>
<h3 id="examples">Examples</h3>
<p>Divan has <a href="https://github.com/nvzqz/divan/tree/v0.1.0/examples/benches">many practical examples</a>.
These can all be benchmarked locally with:</p>
<pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-q</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>--all-features</span></span></code></pre>
<details><summary>Each example file can also be run on its own. Run the <a href="https://github.com/nvzqz/divan/blob/v0.1.0/examples/benches/string.rs"><code>string.rs</code></a> benchmarks with:</summary><pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-q</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>--bench</span><span> </span><span>string</span></span></code></pre><pre is:raw="" tabindex="0"><code><span><span>string         fastest       │ slowest       │ median        │ mean          │ samples │ iters</span></span>
<span><span>├─ char_count                │               │               │               │         │</span></span>
<span><span>│  ├─ Ascii                  │               │               │               │         │</span></span>
<span><span>│  │  ├─ 0     0.926 ns      │ 1.069 ns      │ 0.967 ns      │ 0.964 ns      │ 100     │ 409600</span></span>
<span><span>│  │  │        0 B/s         │ 0 B/s         │ 0 B/s         │ 0 B/s         │         │</span></span>
<span><span>│  │  │        0 char/s      │ 0 char/s      │ 0 char/s      │ 0 char/s      │         │</span></span>
<span><span>│  │  ├─ 8     2.157 ns      │ 2.341 ns      │ 2.238 ns      │ 2.225 ns      │ 100     │ 204800</span></span>
<span><span>│  │  │        3.708 GB/s    │ 3.417 GB/s    │ 3.574 GB/s    │ 3.595 GB/s    │         │</span></span>
<span><span>│  │  │        3.708 Gchar/s │ 3.417 Gchar/s │ 3.574 Gchar/s │ 3.595 Gchar/s │         │</span></span>
<span><span>│  │  ├─ 64    3.703 ns      │ 4.049 ns      │ 3.744 ns      │ 3.766 ns      │ 100     │ 204800</span></span>
<span><span>│  │  │        17.28 GB/s    │ 15.8 GB/s     │ 17.09 GB/s    │ 16.99 GB/s    │         │</span></span>
<span><span>│  │  │        17.28 Gchar/s │ 15.8 Gchar/s  │ 17.09 Gchar/s │ 16.99 Gchar/s │         │</span></span>
<span><span>│  │  ╰─ 1024  33.54 ns      │ 35.18 ns      │ 34.2 ns       │ 34.23 ns      │ 100     │ 12800</span></span>
<span><span>│  │           30.52 GB/s    │ 29.1 GB/s     │ 29.93 GB/s    │ 29.91 GB/s    │         │</span></span>
<span><span>│  │           30.52 Gchar/s │ 29.1 Gchar/s  │ 29.93 Gchar/s │ 29.91 Gchar/s │         │</span></span>
<span><span>│  ╰─ Unicode                │               │               │               │         │</span></span>
<span><span>│     ├─ 0     0.926 ns      │ 1.049 ns      │ 0.936 ns      │ 0.943 ns      │ 100     │ 409600</span></span>
<span><span>│     │        0 B/s         │ 0 B/s         │ 0 B/s         │ 0 B/s         │         │</span></span>
<span><span>│     │        0 char/s      │ 0 char/s      │ 0 char/s      │ 0 char/s      │         │</span></span>
<span><span>│     ├─ 8     6.857 ns      │ 7.833 ns      │ 7.182 ns      │ 7.183 ns      │ 100     │ 102400</span></span>
<span><span>│     │        4.52 GB/s     │ 3.957 GB/s    │ 4.316 GB/s    │ 4.315 GB/s    │         │</span></span>
<span><span>│     │        1.166 Gchar/s │ 1.021 Gchar/s │ 1.113 Gchar/s │ 1.113 Gchar/s │         │</span></span>
<span><span>│     ├─ 64    16.46 ns      │ 24.76 ns      │ 17.27 ns      │ 17.41 ns      │ 100     │ 25600</span></span>
<span><span>│     │        15.3 GB/s     │ 10.13 GB/s    │ 14.58 GB/s    │ 14.41 GB/s    │         │</span></span>
<span><span>│     │        3.887 Gchar/s │ 2.584 Gchar/s │ 3.704 Gchar/s │ 3.674 Gchar/s │         │</span></span>
<span><span>│     ╰─ 1024  140.3 ns      │ 340.8 ns      │ 142.9 ns      │ 145.2 ns      │ 100     │ 3200</span></span>
<span><span>│              28.74 GB/s    │ 11.83 GB/s    │ 28.23 GB/s    │ 27.78 GB/s    │         │</span></span>
<span><span>│              7.297 Gchar/s │ 3.004 Gchar/s │ 7.163 Gchar/s │ 7.05 Gchar/s  │         │</span></span>
<span><span>...</span></span></code></pre></details>
<h3 id="benchmark-registration">Benchmark Registration</h3>
<p>Divan benchmarks can be registered anywhere using the
<a href="https://docs.rs/divan/0.1.0/divan/attr.bench.html"><code>#[divan::bench]</code></a>
attribute, like <a href="https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a>:</p>
<pre is:raw="" tabindex="0"><code><span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span></span>
<span><span>    // Run registered benchmarks.</span></span>
<span><span>    divan</span><span>::</span><span>main</span><span>();</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Define a `fibonacci` function and</span></span>
<span><span>// register it for benchmarking.</span></span>
<span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>fn</span><span> </span><span>fibonacci</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>    </span><span>fn</span><span> </span><span>compute</span><span>(</span><span>n</span><span>:</span><span> </span><span>u64</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>        </span><span>if</span><span> n </span><span>&lt;=</span><span> </span><span>1</span><span> </span><span>{</span></span>
<span><span>            </span><span>1</span></span>
<span><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span></span>
<span><span>            </span><span>compute</span><span>(</span><span>n </span><span>-</span><span> </span><span>2</span><span>)</span><span> </span><span>+</span><span> </span><span>compute</span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>)</span></span>
<span><span>        </span><span>}</span></span>
<span><span>    </span><span>}</span></span>
<span></span>
<span><span>    </span><span>compute</span><span>(</span><span>divan</span><span>::</span><span>black_box</span><span>(</span><span>10</span><span>))</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch       fastest  │ slowest │ median   │ mean     │ samples │ iters</span></span>
<span><span>╰─ fibonacci  179.3 ns │ 204 ns  │ 180.6 ns │ 181.5 ns │ 100     │ 3200</span></span></code></pre>
<p>And that’s all that’s needed, because OS-dependent <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a> shenanigans enables
you to <a href="#register-benchmarks-anywhere">register benchmarks anywhere</a>.</p>
<h3 id="benchmark-options">Benchmark Options</h3>
<p>How each benchmark is executed can be controlled via
<a href="https://docs.rs/divan/0.1.0/divan/attr.bench.html#options">attribute options</a>,
such as <a href="https://docs.rs/divan/0.1.0/divan/attr.bench.html#max_time"><code>max_time</code></a>
and <a href="https://docs.rs/divan/0.1.0/divan/attr.bench.html#sample_size"><code>sample_size</code></a>:</p>
<pre is:raw="" tabindex="0"><code><span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>(</span></span>
<span><span>    max_time </span><span>=</span><span> 0</span><span>.</span><span>001</span><span>,</span><span> // seconds</span></span>
<span><span>    sample_size </span><span>=</span><span> 64</span><span>,</span><span> // 64 × 84 = 5376</span></span>
<span><span>)]</span></span>
<span><span>fn</span><span> </span><span>fibonacci</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>    // ...</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch       fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>╰─ fibonacci  179.9 ns │ 184.5 ns │ 181.2 ns │ 181.1 ns │ 84      │ 5376</span></span></code></pre>
<h3 id="benchmark-in-ci">Benchmark in CI</h3>
<p>Divan’s <a href="#sample-size-scaling">sample size scaling</a> enables you to run benchmarks in CI due to reduced
timing noise. To demonstrate, <a href="https://github.com/nvzqz/divan/blob/v0.1.0/.github/workflows/ci.yml#L119-L140">all examples are benchmarked in
CI</a>:</p>
<ul>
<li><a href="https://github.com/nvzqz/divan/actions/runs/6410601867/job/17404249771#step:4:203">Linux</a></li>
<li><a href="https://github.com/nvzqz/divan/actions/runs/6410601867/job/17404250208#step:4:201">macOS</a></li>
<li><a href="https://github.com/nvzqz/divan/actions/runs/6410601867/job/17404250630#step:4:198">Windows</a></li>
</ul>
<h3 id="module-tree-hierarchy">Module Tree Hierarchy</h3>
<p>Rust naturally groups functions and types into
<a href="https://doc.rust-lang.org/std/keyword.mod.html">modules</a>. Divan reflects this
grouping in its tree output formatting.</p>
<p>If we want to compare our recursive fibonacci implementation against an
iterative implementation, they can be placed together in a module:</p>
<pre is:raw="" tabindex="0"><code><span><span>mod</span><span> </span><span>fibonacci</span><span> </span><span>{</span></span>
<span><span>    </span><span>const</span><span> N</span><span>:</span><span> </span><span>u64</span><span> </span><span>=</span><span> </span><span>10</span><span>;</span></span>
<span></span>
<span><span>    </span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>    </span><span>fn</span><span> </span><span>iterative</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>        </span><span>let</span><span> </span><span>mut</span><span> previous </span><span>=</span><span> </span><span>1</span><span>;</span></span>
<span><span>        </span><span>let</span><span> </span><span>mut</span><span> current </span><span>=</span><span> </span><span>1</span><span>;</span></span>
<span></span>
<span><span>        </span><span>for</span><span> _ </span><span>in</span><span> </span><span>2</span><span>..=</span><span>divan</span><span>::</span><span>black_box</span><span>(</span><span>N</span><span>)</span><span> </span><span>{</span></span>
<span><span>            </span><span>let</span><span> next </span><span>=</span><span> previous </span><span>+</span><span> current</span><span>;</span></span>
<span><span>            previous </span><span>=</span><span> current</span><span>;</span></span>
<span><span>            current </span><span>=</span><span> next</span><span>;</span></span>
<span><span>        </span><span>}</span></span>
<span></span>
<span><span>        current</span></span>
<span><span>    </span><span>}</span></span>
<span></span>
<span><span>    </span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>    </span><span>fn</span><span> </span><span>recursive</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>        </span><span>fn</span><span> </span><span>compute</span><span>(</span><span>n</span><span>:</span><span> </span><span>u64</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>            </span><span>if</span><span> n </span><span>&lt;=</span><span> </span><span>1</span><span> </span><span>{</span></span>
<span><span>                </span><span>1</span></span>
<span><span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span></span>
<span><span>                </span><span>compute</span><span>(</span><span>n </span><span>-</span><span> </span><span>2</span><span>)</span><span> </span><span>+</span><span> </span><span>compute</span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>)</span></span>
<span><span>            </span><span>}</span></span>
<span><span>        </span><span>}</span></span>
<span></span>
<span><span>        </span><span>compute</span><span>(</span><span>divan</span><span>::</span><span>black_box</span><span>(</span><span>N</span><span>))</span></span>
<span><span>    </span><span>}</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch          fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>╰─ fibonacci              │          │          │          │         │</span></span>
<span><span>   ├─ iterative  4.334 ns │ 9.383 ns │ 4.497 ns │ 5.855 ns │ 100     │ 102400</span></span>
<span><span>   ╰─ recursive  154.6 ns │ 185.9 ns │ 159.8 ns │ 159.7 ns │ 100     │ 3200</span></span></code></pre>
<p>Options can be set across all benchmarks in a module using the
<a href="https://docs.rs/divan/0.1.0/divan/attr.bench_group.html#options"><code>#[divan::bench_group]</code></a>
attribute macro, such as
<a href="https://docs.rs/divan/0.1.0/divan/attr.bench_group.html#max_time"><code>max_time</code></a>
and
<a href="https://docs.rs/divan/0.1.0/divan/attr.bench_group.html#sample_size"><code>sample_size</code></a>:</p>
<pre is:raw="" tabindex="0"><code><span><span>#[</span><span>divan</span><span>::</span><span>bench_group</span><span>(</span></span>
<span><span>    max_time </span><span>=</span><span> 0</span><span>.</span><span>001</span><span>,</span></span>
<span><span>    sample_size </span><span>=</span><span> 64</span><span>,</span></span>
<span><span>)]</span></span>
<span><span>mod</span><span> </span><span>fibonacci</span><span> </span><span>{</span></span>
<span><span>    </span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>    </span><span>fn</span><span> </span><span>iterative</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>        // ...</span></span>
<span><span>    </span><span>}</span></span>
<span></span>
<span><span>    </span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>    </span><span>fn</span><span> </span><span>recursive</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>u64</span><span> </span><span>{</span></span>
<span><span>        // ...</span></span>
<span><span>    </span><span>}</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch          fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>╰─ fibonacci              │          │          │          │         │</span></span>
<span><span>   ├─ iterative  4.238 ns │ 7.504 ns │ 4.895 ns │ 4.822 ns │ 100     │ 6400</span></span>
<span><span>   ╰─ recursive  149.4 ns │ 361.6 ns │ 154.6 ns │ 157.4 ns │ 97      │ 6208</span></span></code></pre>
<h3 id="filter-by-regex">Filter by Regex</h3>
<p>When running Divan on the command line, you can filter <code>path::to::function</code>
against a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a>:</p>
<pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-q</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>--bench</span><span> </span><span>threads</span><span> </span><span>--</span><span> </span><span>&#39;</span><span>id$</span><span>&#39;</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>threads                 fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>╰─ thread_id                     │          │          │          │         │</span></span>
<span><span>   ╰─ std                        │          │          │          │         │</span></span>
<span><span>      ├─ thread                  │          │          │          │         │</span></span>
<span><span>      │  ╰─ current_id           │          │          │          │         │</span></span>
<span><span>      │     ├─ t=1      9.131 ns │ 10.43 ns │ 9.701 ns │ 9.587 ns │ 100     │ 51200</span></span>
<span><span>      │     ├─ t=4      9.781 ns │ 10.1 ns  │ 9.863 ns │ 9.856 ns │ 100     │ 51200</span></span>
<span><span>      │     ├─ t=10     9.781 ns │ 71.3 ns  │ 10.43 ns │ 12.2 ns  │ 100     │ 25600</span></span>
<span><span>      │     ╰─ t=16     9.777 ns │ 115.2 ns │ 11.09 ns │ 15.79 ns │ 112     │ 14336</span></span>
<span><span>      ╰─ thread_local            │          │          │          │         │</span></span>
<span><span>         ╰─ id                   │          │          │          │         │</span></span>
<span><span>            ├─ t=1      1.543 ns │ 1.706 ns │ 1.553 ns │ 1.575 ns │ 100     │ 409600</span></span>
<span><span>            ├─ t=4      0.627 ns │ 11.14 ns │ 1.685 ns │ 1.559 ns │ 100     │ 409600</span></span>
<span><span>            ├─ t=10     0.688 ns │ 1.868 ns │ 1.716 ns │ 1.634 ns │ 100     │ 204800</span></span>
<span><span>            ╰─ t=16     0.688 ns │ 1.93 ns  │ 1.706 ns │ 1.656 ns │ 112     │ 229376</span></span></code></pre>
<h3 id="generic-benchmarks">Generic Benchmarks</h3>
<p>Divan can benchmark functions with <a href="https://docs.rs/divan/0.1.0/divan/attr.bench.html#types">generic types</a>.
The following example benchmarks
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;&amp;str&gt;</code></a> for
<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a> and <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>:</p>
<pre is:raw="" tabindex="0"><code><span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>(</span><span>types </span><span>=</span><span> </span><span>[</span></span>
<span><span>    </span><span>&amp;</span><span>str</span><span>,</span></span>
<span><span>    </span><span>String</span><span>,</span></span>
<span><span>])]</span></span>
<span><span>fn</span><span> </span><span>from_str</span><span>&lt;&#39;</span><span>a</span><span>,</span><span> </span><span>T</span><span>&gt;()</span><span> </span><span>-&gt;</span><span> </span><span>T</span></span>
<span><span>where</span></span>
<span><span>    </span><span>T</span><span>:</span><span> </span><span>From</span><span>&lt;</span><span>&amp;</span><span>&#39;</span><span>a</span><span> </span><span>str</span><span>&gt;,</span></span>
<span><span>{</span></span>
<span><span>    divan</span><span>::</span><span>black_box</span><span>(</span><span>&#34;</span><span>hello world</span><span>&#34;</span><span>)</span><span>.</span><span>into</span><span>()</span></span>
<span><span>}</span></span></code></pre>
<p>Divan can also benchmark functions with <a href="https://docs.rs/divan/0.1.0/divan/attr.bench.html#consts">generic <code>const</code>
values</a>. The
following example benchmarks initializing <a href="https://doc.rust-lang.org/std/primitive.array.html">stack-allocated
arrays</a> of lengths 1000,
2000, and 3000:</p>
<pre is:raw="" tabindex="0"><code><span><span>const</span><span> LEN</span><span>:</span><span> </span><span>usize</span><span> </span><span>=</span><span> </span><span>2000</span><span>;</span></span>
<span></span>
<span><span>const</span><span> </span><span>fn</span><span> </span><span>len</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>usize</span><span> </span><span>{</span></span>
<span><span>    </span><span>3000</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>(</span><span>consts </span><span>=</span><span> </span><span>[</span></span>
<span><span>    1000</span><span>,</span></span>
<span><span>    </span><span>LEN</span><span>,</span></span>
<span><span>    len</span><span>(),</span></span>
<span><span>])]</span></span>
<span><span>fn</span><span> </span><span>init_array</span><span>&lt;</span><span>const</span><span> </span><span>N</span><span>:</span><span> </span><span>usize</span><span>&gt;()</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>i32</span><span>;</span><span> </span><span>N</span><span>]</span><span> </span><span>{</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> result </span><span>=</span><span> </span><span>[</span><span>0</span><span>;</span><span> </span><span>N</span><span>];</span></span>
<span></span>
<span><span>    </span><span>for</span><span> i </span><span>in</span><span> </span><span>0</span><span>..</span><span>N</span><span> </span><span>{</span></span>
<span><span>        result</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> divan</span><span>::</span><span>black_box</span><span>(</span><span>i </span><span>as</span><span> </span><span>i32</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span></span>
<span><span>    result</span></span>
<span><span>}</span></span></code></pre>
<p>When ran, these benchmarks will output:</p>
<pre is:raw="" tabindex="0"><code><span><span>scratch        fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>├─ from_str             │          │          │          │         │</span></span>
<span><span>│  ├─ &amp;str     0.738 ns │ 0.799 ns │ 0.759 ns │ 0.757 ns │ 100     │ 409600</span></span>
<span><span>│  ╰─ String   26.8 ns  │ 32.18 ns │ 30.39 ns │ 30.42 ns │ 100     │ 25600</span></span>
<span><span>╰─ init_array           │          │          │          │         │</span></span>
<span><span>   ├─ 1000     572.5 ns │ 598.6 ns │ 583 ns   │ 584.5 ns │ 100     │ 800</span></span>
<span><span>   ├─ 2000     1.155 µs │ 1.197 µs │ 1.166 µs │ 1.165 µs │ 100     │ 400</span></span>
<span><span>   ╰─ 3000     1.759 µs │ 1.801 µs │ 1.77 µs  │ 1.77 µs  │ 100     │ 400</span></span></code></pre>
<p>The <a href="https://github.com/nvzqz/divan/blob/v0.1.0/examples/benches/collections.rs"><code>collections.rs</code></a>
example contains many more generic benchmarks:</p>
<pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>-q</span><span> </span><span>--bench</span><span> </span><span>collections</span></span></code></pre>
<h3 id="benchmark-context">Benchmark Context</h3>
<p>Benchmarks can take a <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html"><code>Bencher</code></a> argument to provide context and more control
over how benchmarks are run.</p>
<pre is:raw="" tabindex="0"><code><span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>fn</span><span> </span><span>clone_string</span><span>(</span><span>bencher</span><span>:</span><span> divan</span><span>::</span><span>Bencher</span><span>)</span><span> </span><span>{</span></span>
<span><span>    </span><span>let</span><span> s </span><span>=</span><span> </span><span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;</span><span>...</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>    bencher</span><span>.</span><span>bench</span><span>(</span><span>||</span><span> </span><span>{</span></span>
<span><span>        s</span><span>.</span><span>clone</span><span>()</span></span>
<span><span>    </span><span>})</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch          fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>╰─ clone_string  26.71 ns │ 56.66 ns │ 28.17 ns │ 28.87 ns │ 100     │ 12800</span></span></code></pre>
<h3 id="benchmark-inputs">Benchmark Inputs</h3>
<p>Each invocation can be given an input using <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.with_inputs"><code>with_inputs</code></a>, which can then be
used by-reference with <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.bench_refs"><code>bench_refs</code></a> or by-value with <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.bench_values"><code>bench_values</code></a>.</p>
<pre is:raw="" tabindex="0"><code><span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>fn</span><span> </span><span>append_ref</span><span>(</span><span>bencher</span><span>:</span><span> divan</span><span>::</span><span>Bencher</span><span>)</span><span> </span><span>{</span></span>
<span><span>    bencher</span></span>
<span><span>        </span><span>.</span><span>with_inputs</span><span>(</span><span>||</span><span> </span><span>{</span></span>
<span><span>            </span><span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;</span><span>...</span><span>&#34;</span><span>)</span></span>
<span><span>        </span><span>})</span></span>
<span><span>        </span><span>.</span><span>bench_refs</span><span>(</span><span>|</span><span>s</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>String</span><span>|</span><span> </span><span>{</span></span>
<span><span>            </span><span>*</span><span>s </span><span>+=</span><span> </span><span>&#34;</span><span>abc</span><span>&#34;</span><span>;</span></span>
<span><span>        </span><span>});</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>fn</span><span> </span><span>append_value</span><span>(</span><span>bencher</span><span>:</span><span> divan</span><span>::</span><span>Bencher</span><span>)</span><span> </span><span>{</span></span>
<span><span>    bencher</span></span>
<span><span>        </span><span>.</span><span>with_inputs</span><span>(</span><span>||</span><span> </span><span>{</span></span>
<span><span>            </span><span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;</span><span>...</span><span>&#34;</span><span>)</span></span>
<span><span>        </span><span>})</span></span>
<span><span>        </span><span>.</span><span>bench_values</span><span>(</span><span>|</span><span>s</span><span>:</span><span> </span><span>String</span><span>|</span><span> </span><span>{</span></span>
<span><span>            s </span><span>+</span><span> </span><span>&#34;</span><span>abc</span><span>&#34;</span></span>
<span><span>        </span><span>});</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch          fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>├─ append_ref    23.87 ns │ 24.85 ns │ 24.19 ns │ 24.19 ns │ 100     │ 25600</span></span>
<span><span>╰─ append_value  24.2 ns  │ 42.26 ns │ 24.52 ns │ 24.78 ns │ 100     │ 25600</span></span></code></pre>
<h3 id="measure-throughput">Measure Throughput</h3>
<p>Divan uses <a href="https://docs.rs/divan/0.1.0/divan/counter/index.html">counters</a> to
track quantities processed during each iteration. Currently there are:
<a href="https://docs.rs/divan/0.1.0/divan/counter/struct.BytesCount.html"><code>BytesCount</code></a>, <a href="https://docs.rs/divan/0.1.0/divan/counter/struct.CharsCount.html"><code>CharsCount</code></a>, and <a href="https://docs.rs/divan/0.1.0/divan/counter/struct.ItemsCount.html"><code>ItemsCount</code></a>.</p>
<p>The following example generates strings from 50 random <a href="https://doc.rust-lang.org/std/primitive.char.html">Unicode scalars</a>
and measures the throughput in <a href="https://docs.rs/divan/0.1.0/divan/counter/struct.CharsCount.html">scalars</a> and
<a href="https://docs.rs/divan/0.1.0/divan/counter/struct.BytesCount.html">bytes</a>.</p>
<pre is:raw="" tabindex="0"><code><span><span>use</span><span> divan</span><span>::</span><span>counter</span><span>::</span><span>{</span><span>BytesCount</span><span>,</span><span> </span><span>CharsCount</span><span>};</span></span>
<span></span>
<span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>fn</span><span> </span><span>to_uppercase</span><span>(</span><span>bencher</span><span>:</span><span> divan</span><span>::</span><span>Bencher</span><span>)</span><span> </span><span>{</span></span>
<span><span>    </span><span>let</span><span> len</span><span>:</span><span> </span><span>usize</span><span> </span><span>=</span><span> </span><span>50</span><span>;</span></span>
<span></span>
<span><span>    bencher</span></span>
<span><span>        </span><span>.</span><span>counter</span><span>({</span></span>
<span><span>            // Constant across inputs.</span></span>
<span><span>            </span><span>CharsCount</span><span>::</span><span>new</span><span>(</span><span>len</span><span>)</span></span>
<span><span>        </span><span>})</span></span>
<span><span>        </span><span>.</span><span>with_inputs</span><span>(</span><span>||</span><span> </span><span>-&gt;</span><span> </span><span>String</span><span> </span><span>{</span></span>
<span><span>            </span><span>(</span><span>0</span><span>..</span><span>len</span><span>)</span><span>.</span><span>map</span><span>(</span><span>|</span><span>_</span><span>|</span><span> fastrand</span><span>::</span><span>char</span><span>(</span><span>..</span><span>))</span><span>.</span><span>collect</span><span>()</span></span>
<span><span>        </span><span>})</span></span>
<span><span>        </span><span>.</span><span>input_counter</span><span>(</span><span>|</span><span>s</span><span>:</span><span> </span><span>&amp;</span><span>String</span><span>|</span><span> </span><span>{</span></span>
<span><span>            // Changes based on input.</span></span>
<span><span>            </span><span>BytesCount</span><span>::</span><span>of_str</span><span>(</span><span>s</span><span>)</span></span>
<span><span>        </span><span>})</span></span>
<span><span>        </span><span>.</span><span>bench_refs</span><span>(</span><span>|</span><span>s</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>String</span><span>|</span><span> </span><span>{</span></span>
<span><span>            s</span><span>.</span><span>to_uppercase</span><span>()</span></span>
<span><span>        </span><span>});</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch          fastest       │ slowest       │ median        │ mean          │ samples │ iters</span></span>
<span><span>╰─ to_uppercase  911 ns        │ 1.088 µs      │ 942.4 ns      │ 952.4 ns      │ 100     │ 800</span></span>
<span><span>                 217.3 MB/s    │ 181 MB/s      │ 209 MB/s      │ 205.7 MB/s    │         │</span></span>
<span><span>                 54.88 Mchar/s │ 45.94 Mchar/s │ 53.05 Mchar/s │ 52.49 Mchar/s │         │</span></span></code></pre>
<p>By default, bytes throughput is displayed in powers of 1000 (KB), as seen above.
If you prefer powers of 1024 (KiB), set <code>DIVAN_BYTES_FORMAT</code> in your
environment:</p>
<pre is:raw="" tabindex="0"><code><span><span>DIVAN_BYTES_FORMAT</span><span>=</span><span>binary</span><span> </span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>-q</span><span> </span><span>--bench</span><span> </span><span>scratch</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch          fastest       │ slowest       │ median        │ mean          │ samples │ iters</span></span>
<span><span>╰─ to_uppercase  911 ns        │ 1.885 µs      │ 937.1 ns      │ 958.9 ns      │ 100     │ 800</span></span>
<span><span>                 206.2 MiB/s   │ 99.15 MiB/s   │ 199.4 MiB/s   │ 194.9 MiB/s   │         │</span></span>
<span><span>                 54.88 Mchar/s │ 26.52 Mchar/s │ 53.35 Mchar/s │ 52.14 Mchar/s │         │</span></span></code></pre>
<p>The <a href="https://github.com/nvzqz/divan/blob/v0.1.0/examples/benches/string.rs"><code>string.rs</code></a>
example contains many more benchmarks with counters:</p>
<pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-q</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>--bench</span><span> </span><span>string</span></span></code></pre>
<h3 id="measure-thread-contention">Measure Thread Contention</h3>
<p>Divan can benchmark contention of <a href="https://doc.rust-lang.org/std/sync/index.html">atomics and
locks</a> across multiple threads.</p>
<p>Thread count 0 indicates using <a href="https://doc.rust-lang.org/std/thread/fn.available_parallelism.html">available
parallelism</a>,
which is 10 on my machine.</p>
<pre is:raw="" tabindex="0"><code><span><span>use</span><span> std</span><span>::</span><span>sync</span><span>::</span><span>{</span><span>Mutex</span><span>,</span><span> </span><span>RwLock</span><span>};</span></span>
<span></span>
<span><span>fn</span><span> </span><span>thread_counts</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>Vec</span><span>&lt;</span><span>usize</span><span>&gt;</span><span> </span><span>{</span></span>
<span><span>    </span><span>vec!</span><span>[</span><span>/* available parallelism */</span><span> </span><span>0</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>8</span><span>]</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>(</span><span>threads </span><span>=</span><span> thread_counts</span><span>())]</span></span>
<span><span>fn</span><span> </span><span>mutex</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>i32</span><span> </span><span>{</span></span>
<span><span>    </span><span>static</span><span> LOCK</span><span>:</span><span> </span><span>Mutex</span><span>&lt;</span><span>i32</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Mutex</span><span>::</span><span>new</span><span>(</span><span>0</span><span>);</span></span>
<span></span>
<span><span>    </span><span>*</span><span>LOCK</span><span>.</span><span>lock</span><span>()</span><span>.</span><span>unwrap</span><span>()</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>(</span><span>threads </span><span>=</span><span> thread_counts</span><span>())]</span></span>
<span><span>fn</span><span> </span><span>rw_lock</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>i32</span><span> </span><span>{</span></span>
<span><span>    </span><span>static</span><span> LOCK</span><span>:</span><span> </span><span>RwLock</span><span>&lt;</span><span>i32</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>0</span><span>);</span></span>
<span></span>
<span><span>    </span><span>*</span><span>LOCK</span><span>.</span><span>read</span><span>()</span><span>.</span><span>unwrap</span><span>()</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch     fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>├─ mutex             │          │          │          │         │</span></span>
<span><span>│  ├─ t=1   9.639 ns │ 11.51 ns │ 9.883 ns │ 9.893 ns │ 100     │ 51200</span></span>
<span><span>│  ├─ t=4   9.715 ns │ 163.3 ns │ 23.07 ns │ 35.82 ns │ 100     │ 12800</span></span>
<span><span>│  ├─ t=8   10 ns    │ 1.322 µs │ 17.81 ns │ 113.8 ns │ 104     │ 1664</span></span>
<span><span>│  ╰─ t=10  11.34 ns │ 916.3 ns │ 19.16 ns │ 154.1 ns │ 100     │ 3200</span></span>
<span><span>╰─ rw_lock           │          │          │          │         │</span></span>
<span><span>   ├─ t=1   17.2 ns  │ 17.86 ns │ 17.53 ns │ 17.46 ns │ 100     │ 25600</span></span>
<span><span>   ├─ t=4   17.2 ns  │ 319.9 ns │ 28.92 ns │ 96.77 ns │ 100     │ 6400</span></span>
<span><span>   ├─ t=8   16.53 ns │ 338.1 ns │ 17.88 ns │ 65.83 ns │ 104     │ 3328</span></span>
<span><span>   ╰─ t=10  15.89 ns │ 442.3 ns │ 168.5 ns │ 147.5 ns │ 100     │ 6400</span></span></code></pre>
<p>You can eyeball the <code>iters</code> column to check how contention from multi-threading
affects the function. The number of iterations decreases as the duration of each
iteration increases.</p>
<p>Sample count is always the next multiple of thread count, which is why 8 threads
produce 104 samples when sample count defaults to 100. This ensures at least 100
samples run under the same conditions: competing against 7 other threads.</p>
<p>To increase the chance for contention, all threads are <a href="https://github.com/nvzqz/divan/blob/v0.1.0/src/bench/mod.rs#L820-L828">synchronized immediately
before and
after</a> the
sampled section using a <a href="https://doc.rust-lang.org/std/sync/struct.Barrier.html"><code>Barrier</code></a>. This also prevents work done by other
threads before and after the sample from affecting the current thread’s
measurements.</p>
<p>The
<a href="https://github.com/nvzqz/divan/blob/v0.1.0/examples/benches/threads.rs"><code>threads.rs</code></a>
example contains many multi-threaded benchmarks for <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>, <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>,
<a href="https://doc.rust-lang.org/std/thread/struct.ThreadId.html"><code>ThreadId</code></a>, and more:</p>
<pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-q</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>--bench</span><span> </span><span>threads</span></span></code></pre>
<h3 id="cpu-timestamp">CPU Timestamp</h3>
<p>Divan uses the portable <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a> timer by default. For extra precision, you
can instead use the CPU’s <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">timestamp counter
(TSC)</a>:</p>
<pre is:raw="" tabindex="0"><code><span><span>DIVAN_TIMER</span><span>=</span><span>tsc</span><span> </span><span>cargo</span><span> </span><span>bench</span><span> </span><span>...</span></span></code></pre>
<p>The TSC is architecture-specific:</p>
<ul>
<li>x86: <a href="https://doc.rust-lang.org/core/arch/x86/fn._rdtsc.html"><code>rdtsc</code></a> followed by <a href="https://doc.rust-lang.org/core/arch/x86/fn.__rdtscp.html"><code>rdtscp</code></a>,
with frequency obtained by measuring against <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a></li>
<li>AArch64: <a href="https://developer.arm.com/documentation/ddi0595/2021-12/AArch64-Registers/CNTVCT-EL0--Counter-timer-Virtual-Count-register?lang=en"><code>cntvct_el0</code></a>
with frequency obtained from <a href="https://developer.arm.com/documentation/ddi0595/2021-12/AArch64-Registers/CNTFRQ-EL0--Counter-timer-Frequency-register?lang=en"><code>cntfrq_el0</code></a></li>
</ul>
<p>The <a href="https://github.com/nvzqz/divan/blob/v0.1.0/examples/benches/time.rs"><code>time.rs</code></a>
example benchmarks TSC against <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a> and <a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html"><code>SystemTime</code></a>:</p>
<pre is:raw="" tabindex="0"><code><span><span>cargo</span><span> </span><span>bench</span><span> </span><span>-q</span><span> </span><span>-p</span><span> </span><span>examples</span><span> </span><span>--bench</span><span> </span><span>time</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>time                 fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>├─ duration_since             │          │          │          │         │</span></span>
<span><span>│  ├─ instant        3.393 ns │ 4.94 ns  │ 3.414 ns │ 3.444 ns │ 100     │ 204800</span></span>
<span><span>│  ├─ system_time    4.268 ns │ 4.512 ns │ 4.309 ns │ 4.336 ns │ 100     │ 102400</span></span>
<span><span>│  ╰─ tsc (aarch64)  0.021 ns │ 0.064 ns │ 0.034 ns │ 0.039 ns │ 100     │ 1638400</span></span>
<span><span>╰─ now                        │          │          │          │         │</span></span>
<span><span>   ├─ instant        18.18 ns │ 19.32 ns │ 18.34 ns │ 18.44 ns │ 100     │ 25600</span></span>
<span><span>   ├─ system_time    17.36 ns │ 18.34 ns │ 17.53 ns │ 17.62 ns │ 100     │ 25600</span></span>
<span><span>   ╰─ tsc (aarch64)  0.738 ns │ 0.779 ns │ 0.759 ns │ 0.755 ns │ 100     │ 409600</span></span></code></pre>
<p>Note that
<a href="https://github.com/nvzqz/divan/blob/v0.1.0/examples/benches/time.rs#L62"><code>time::duration_since</code></a>
for TSC is extremely fast because it is simply doing
<a href="https://doc.rust-lang.org/std/primitive.u64.html#method.saturating_sub"><code>u64::saturating_sub</code></a>,
since an optimized timing implementation would want to keep the value as TSC
units for as long as possible before dividing by the TSC frequency.</p>
<h2 id="design">Design</h2>
<p>I deliberately designed Divan with multiple considerations in mind, the most
important being <a href="#simpler-benchmarking">simpler benchmarking</a> and <a href="#getting-out-of-your-way">getting out of your way</a>.</p>
<h3 id="simpler-benchmarking">Simpler Benchmarking</h3>
<p>From the beginning, my goal was to make Rust benchmarking simple and easy. Divan
accomplishes this in many ways:</p>
<h4 id="register-benchmarks-anywhere">Register Benchmarks Anywhere</h4>
<p>Rust’s <a href="https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a>
attribute makes unit testing very simple and straightforward. Divan achieves the
same simplicity with
<a href="https://docs.rs/divan/0.1.0/divan/attr.bench.html"><code>#[divan::bench]</code></a> using
<a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a> shenanigans to make benchmarked functions visible to
<a href="https://docs.rs/divan/0.1.0/divan/fn.main.html"><code>divan::main()</code></a>.</p>
<ul>
<li><a href="https://docs.rs/linkme"><code>linkme</code></a> provides
<a href="https://docs.rs/linkme/0.1.0/linkme/struct.DistributedSlice.html"><code>DistributedSlice</code></a>,
which coerces to <a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>&amp;[T]</code></a> using link-time pseudo-symbols for the range of
start and end addresses.</li>
<li>For other platforms, Divan implements
<a href="https://github.com/nvzqz/divan/blob/v0.1.0/src/entry/list.rs#L6-L13"><code>EntryList</code></a>,
a thread-safe append-only linked list constructed before <a href="https://doc.rust-lang.org/stable/reference/crates-and-source-files.html#main-functions"><code>main</code></a> runs.</li>
</ul>
<p>Linker-based approaches to registration are limited to few platforms. Divan is
<a href="https://github.com/nvzqz/divan/actions/workflows/ci.yml">tested in CI</a> to work
on macOS, Linux, and Windows.</p>
<h4 id="bencher-by-value"><code>Bencher</code> By-Value</h4>
<p>When benchmarking with <a href="#benchmark-context">context</a>, the <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html"><code>Bencher</code></a> argument is
provided by-value instead of
<a href="https://docs.rs/criterion/0.5.1/criterion/struct.Criterion.html#method.bench_function">by-reference</a>.
Divan then leverages the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder
pattern</a>
to provide various benefits:</p>
<ul>
<li>Reduce cognitive load when reading and writing benchmarks.</li>
<li>Prevent accidental reuse by making <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html"><code>Bencher</code></a> no longer usable after you’ve
called a method like <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.bench"><code>bench</code></a>. If a benchmark method is not called, the
compiler will warn that the value must be used.</li>
<li>More powerful polymorphism with <a href="#benchmark-inputs">benchmark inputs</a>, where later operations
like <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.input_counter"><code>input_counter</code></a> and <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.bench_values"><code>bench_values</code></a> act on the input type. See <a href="#type-driven-apis">type-driven APIs</a>.</li>
</ul>
<h3 id="sample-size-scaling">Sample Size Scaling</h3>
<p>An operation may be too fast for the timer to measure. On Mac M1, the smallest
duration for <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a> and <a href="#cpu-timestamp">CPU timestamp</a> is 41 nanoseconds, which cannot
accurately measure an addition that takes 1 nanosecond.</p>
<p>Divan overcomes timer precision by using <em>ν(s)</em> many iterations per sample,
where <em>t(s)</em> is at least 100 × timer precision. I chose 100 because it
is easy to reason about and produces high quality results. This is calculated by
re-timing each <em>t(2 × s)</em> so that the final result is not solely
dependent on the initial duration.</p>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>ν</mi><mo stretchy="false">(</mo><mn>2</mn><mo>×</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>t</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>100</mn><mo>×</mo><msub><mi>τ</mi><mtext>precision</mtext></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>s</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>t</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>100</mn><mo>×</mo><msub><mi>τ</mi><mtext>precision</mtext></msub></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\nu(s) =
\begin{cases}
\nu(2 \times s)
&amp; \text{if } t(s) &lt; 100 \times \tau_{\textrm{precision}} \\
s
&amp; \text{if } t(s) \ge 100 \times \tau_{\textrm{precision}}
\end{cases}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ν</span><span>(</span><span>s</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span>{</span></span><span><span><span><span><span><span><span><span></span><span><span>ν</span><span>(</span><span>2</span><span></span><span>×</span><span></span><span>s</span><span>)</span></span></span><span><span></span><span><span>s</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span><span><span>if </span></span><span>t</span><span>(</span><span>s</span><span>)</span><span></span><span>&lt;</span><span></span><span>100</span><span></span><span>×</span><span></span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span><span>precision</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span><span></span><span><span><span>if </span></span><span>t</span><span>(</span><span>s</span><span>)</span><span></span><span>≥</span><span></span><span>100</span><span></span><span>×</span><span></span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span><span>precision</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span><span></span></span></span></span></span></p><p>If you don’t consider that <em>t(s)</em> re-times, and instead assume <em>t(s)</em> returns a
consistent predictable value, then this can be reasoned about as:</p>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>≈</mo><msup><mn>2</mn><mfrac><mrow><mn>100</mn><mo>×</mo><msub><mi>τ</mi><mtext>precision</mtext></msub></mrow><mrow><mi>t</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac></msup></mrow><annotation encoding="application/x-tex">
\nu(s) \approx 2^{\frac{100 \times \tau_{\textrm{precision}}}{t(s)}}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ν</span><span>(</span><span>s</span><span>)</span><span></span><span>≈</span><span></span></span><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span><span><span></span><span><span><span><span><span><span></span><span><span><span>t</span><span>(</span><span>s</span><span>)</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>100</span><span>×</span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span>precision</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="robust-benchmarking-paper">Robust Benchmarking Paper</h4>
<p>I was inspired to scale sample size based on timer precision because of the
paper <a href="https://arxiv.org/abs/1608.04295">Robust Benchmarking in Noisy
Environments</a> by <a href="https://github.com/jiahao">Jiahao
Chen</a> and <a href="https://github.com/jrevels">Jarrett
Revels</a>.</p>
<p>This paper concludes with the description of <em>ν(t)</em>, an oracle function that
maps from the theoretical minimum execution time to the number of iterations to
overcome timer precision. They found the generalized logistic function to work
well:</p>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">⌊</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mfrac><msub><mi>τ</mi><mtext>accuracy</mtext></msub><msub><mi>τ</mi><mtext>precision</mtext></msub></mfrac><mo>−</mo><mn>1</mn></mrow><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mi>a</mi><mo>×</mo><mrow><mo fence="true">(</mo><mi>t</mi><mo>−</mo><mi>b</mi><mo>×</mo><msub><mi>τ</mi><mtext>accuracy</mtext></msub><mo fence="true">)</mo></mrow></mrow></msup></mrow></mfrac><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">
\nu(t) = \left\lfloor
1 +
\frac{
\frac{
\tau_{\textrm{accuracy}}
}{
\tau_{\textrm{precision}}
}
- 1
}{
1 + e^{a \times \left(t - b \times \tau_{\textrm{accuracy}}\right)}
}
\right\rfloor
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ν</span><span>(</span><span>t</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span>⌊</span></span><span>1</span><span></span><span>+</span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>1</span><span>+</span><span><span>e</span><span><span><span><span><span><span></span><span><span><span>a</span><span>×</span><span><span><span>(</span></span><span>t</span><span>−</span><span>b</span><span>×</span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span>accuracy</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span><span></span><span><span><span><span><span><span></span><span><span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span>precision</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span>accuracy</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span>−</span><span>1</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span><span>⌋</span></span></span></span></span></span></p><p>…where reasonable values of <em>a</em> and <em>b</em> are approximately:</p>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.25em" columnalign="right left right left" columnspacing="0em 1em 0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0.005</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><mi>a</mi><mo>×</mo><msub><mi>τ</mi><mtext>precision</mtext></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><mn>0.02</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0.4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><mi>b</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><mn>0.6</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
0.005 &amp; &lt; a \times \tau_{\textrm{precision}} &amp;&amp; &lt; 0.02 \\
0.4 &amp; &lt; b &amp;&amp; &lt; 0.6
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>0.005</span></span></span><span><span></span><span><span>0.4</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>&lt;</span><span></span><span>a</span><span></span><span>×</span><span></span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span><span>precision</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span><span></span><span><span></span><span></span><span>&lt;</span><span></span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>&lt;</span><span></span><span>0.02</span></span></span><span><span></span><span><span></span><span></span><span>&lt;</span><span></span><span>0.6</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></p><p>This paper’s approach is significantly more complex than that of Divan. Although
simpler, Divan achieves similarly meaningful results by the commonality of
relying on timer precision:</p>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>≈</mo><msup><mn>2</mn><mfrac><mrow><mn>100</mn><mo>×</mo><msub><mi>τ</mi><mtext>precision</mtext></msub></mrow><mi>t</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">
\nu(t) \approx 2^{\frac{100 \times \tau_{\textrm{precision}}}{t}}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ν</span><span>(</span><span>t</span><span>)</span><span></span><span>≈</span><span></span></span><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span><span><span></span><span><span><span><span><span><span></span><span><span><span>t</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>100</span><span>×</span><span><span>τ</span><span><span><span><span><span><span></span><span><span><span>precision</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>Divan does not use timer accuracy because it wasn’t clear how accuracy can be
obtained without a more accurate reference timer, when <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a> is usually
implemented with the most accurate timer. I’m open to making sample size scaling
smarter, but the current approach works well enough.</p>
<p>This paper also concludes that the smallest duration is the most meaningful
number, because any extra time spent can be attributed to error due to poor
performance conditions, such as being unscheduled by the operating system. I
agree 99.999% of the time, except for when you want to <a href="#measure-thread-contention">measure thread
contention</a>.</p>
<h3 id="getting-out-of-your-way">Getting Out of Your Way</h3>
<p>Divan allows you to focus on what’s most important: your code. It is designed to
be difficult to misuse and employs various techniques to reduce its timing
footprint.</p>
<h4 id="type-driven-apis">Type-Driven APIs</h4>
<p>When benchmarking with <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html"><code>Bencher</code></a>, you cannot call any of the
<a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.bench_values"><code>bench_values</code></a>/<a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.bench_refs"><code>bench_refs</code></a>/<a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.input_counter"><code>input_counter</code></a> functions until you provide
<a href="#benchmark-inputs">benchmark inputs</a>. Likewise, the standard <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.bench"><code>bench</code></a> function cannot be called
if you have already provided inputs.</p>
<p>This is made possible by the fact that the <a href="https://doc.rust-lang.org/std/primitive.unit.html"><code>()</code></a> type does not implement the
<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a> family of traits. <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html"><code>Bencher</code></a> uses <a href="https://doc.rust-lang.org/std/primitive.unit.html"><code>()</code></a> as the default for a generic
type until <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html#method.with_inputs"><code>with_inputs</code></a> is called, at which point <a href="https://docs.rs/divan/0.1.0/divan/struct.Bencher.html"><code>Bencher</code></a> uses the
provided <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a> type.</p>
<h4 id="deferred-drop">Deferred Drop</h4>
<p>When values are returned by the benchmarked function, <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> destructors
will not run until after the sample is recorded. This is achieved by storing
results in a buffer, which will be dropped after the sample.</p>
<p>If buffering is not done carefully, it could affect the accuracy of benchmarks
by accidentally also <a href="https://github.com/bheisler/criterion.rs/blob/0.5.1/src/bencher.rs#L267-L269">timing buffer capacity checks and
reallocation</a>.
To ensure accurate benchmarks, Divan implements this <em>very efficiently</em> by
<a href="https://github.com/nvzqz/divan/blob/v0.1.0/src/bench/mod.rs#L904-L929">iterating over a preallocated
slice</a> of
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a> “drop slots” to store outputs in.</p>
<p>Only one of the following functions will benchmark <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>LinkedList</code></a> deallocation
time:</p>
<pre is:raw="" tabindex="0"><code><span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>fn</span><span> </span><span>defer</span><span>()</span><span> </span><span>-&gt;</span><span> std</span><span>::</span><span>collections</span><span>::</span><span>LinkedList</span><span>&lt;</span><span>i32</span><span>&gt;</span><span> </span><span>{</span></span>
<span><span>    </span><span>(</span><span>0</span><span>..</span><span>1000</span><span>)</span><span>.</span><span>collect</span><span>()</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[</span><span>divan</span><span>::</span><span>bench</span><span>]</span></span>
<span><span>fn</span><span> </span><span>drop</span><span>()</span><span> </span><span>{</span></span>
<span><span>    // Benchmarks can be implemented in terms of each other.</span></span>
<span><span>    _ </span><span>=</span><span> divan</span><span>::</span><span>black_box</span><span>(</span><span>defer</span><span>());</span></span>
<span><span>}</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>scratch   fastest  │ slowest  │ median   │ mean     │ samples │ iters</span></span>
<span><span>├─ defer  26.12 µs │ 31.87 µs │ 29.56 µs │ 30.13 µs │ 100     │ 100</span></span>
<span><span>╰─ drop   65.37 µs │ 75.2 µs  │ 69.43 µs │ 68.3 µs  │ 100     │ 100</span></span></code></pre>
<p>Note that if <a href="https://doc.rust-lang.org/std/mem/fn.needs_drop.html"><code>needs_drop</code></a> for the output is false (e.g. <a href="https://doc.rust-lang.org/std/primitive.unit.html"><code>()</code></a>, <a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>,
<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;&#39;static str</code></a>), Divan <strong>will not allocate</strong> storage for deferring
output drop. Likewise if output is a <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">zero sized type
(ZST)</a>.</p>
<p><a href="#benchmark-inputs">Benchmark inputs</a> are stored <a href="https://github.com/nvzqz/divan/blob/v0.1.0/src/bench/defer.rs#L105-L124">together contiguously with outputs in
memory</a>.
The resulting access pattern is monotonically increasing, which is easily
prefetched into cache.</p>
<h4 id="efficient-enums">Efficient Enums</h4>
<p>Divan internally uses an
<a href="https://github.com/nvzqz/divan/blob/v0.1.0/src/time/timestamp/mod.rs#L42-L56"><code>UntaggedTimestamp</code></a>
<a href="https://doc.rust-lang.org/std/keyword.union.html"><code>union</code></a>, which can be either an <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a> or a <a href="#cpu-timestamp">CPU timestamp</a>. The variant
is kept track of by an external
<a href="https://github.com/nvzqz/divan/blob/v0.1.0/src/time/timer.rs#L165-L174"><code>TimerKind</code></a>
instance, unlike a conventional <a href="https://doc.rust-lang.org/std/keyword.enum.html"><code>enum</code></a> which internally stores the variant
tag. Externally storing the variant tag is a micro-optimization to prevent extra
time spent on storing the timestamp during the sample.</p>
<h2 id="future-plans">Future Plans</h2>
<p>Divan has many opportunities for features. Future versions will have:</p>
<ul>
<li>Better output options:
<ul>
<li>HTML output with interactive graphs. Hovering over a graph will reveal
data points.</li>
<li>Machine-readable output like JSON and CSV.</li>
<li>Colored terminal output with customizable themes.</li>
</ul>
</li>
<li>Improved statistics:
<ul>
<li>Baseline comparison.</li>
<li>Sample variance.</li>
</ul>
</li>
<li>More profiling tools:
<ul>
<li><a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> profiling similar to <a href="https://docs.rs/dhat"><code>dhat-rs</code></a>,
but with minimal performance impact.</li>
<li>Custom profiler plugins like <a href="https://docs.rs/pprof"><code>pprof</code></a>.</li>
</ul>
</li>
<li>Async <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> benchmarking to measure server and client performance.</li>
<li>Registering benchmarks without attribute macros to support more platforms like
WebAssembly.</li>
<li>Runtime argument values, as an alternative to const generics. Const parameters
are great for benchmarking different array sizes, but they have <a href="https://github.com/rust-lang/rust/issues/95174">limited type
support</a> and greatly increase
benchmark compile times.</li>
</ul>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>I especially want to thank <a href="https://github.com/thomcc">Thom Chiovoloni</a> for his
benchmarking advice over many blue moons, and for the <a href="#cpu-timestamp">CPU timestamp</a>
implementation. Thom will also be helping me maintain Divan!</p>
<p>Thanks also to the folks who provided feedback on drafts of this post: <a href="https://chacin.dev">Carlos
Chacin</a>, <a href="https://predr.ag">Predrag Gruevski</a>, <a href="https://tim.mcnamara.nz">Tim
McNamara</a>, <a href="https://benw.is">Ben Wis</a>, <a href="https://github.com/ramonacat">Ramona
Łuczkiewicz</a>, <a href="https://coreyja.com">Corey
Alexander</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Now that you know how to measure performance with Divan, I invite you to try it
out in your own Rust projects. I’m eagerly curious to know what insights it will
reveal to the community!</p>
<p>Please get involved and help make Divan the standard benchmarking tool for Rust:</p>
<ul>
<li><a href="https://github.com/sponsors/nvzqz">Sponsor regularly</a> or <a href="https://paypal.me/nvzqz">donate
once</a> 💖</li>
<li>Implement or collaborate on my <a href="#future-plans">future plans</a> 🚀</li>
<li>Tell your friends and colleagues about <a href="https://github.com/nvzqz/divan">Divan</a>
🗣</li>
</ul>
<p>If you enjoyed this post, <a href="https://buttondown.email/nikolai">subscribe to my
newsletter</a>.</p>
<h2 id="discuss">Discuss</h2>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/1703xwe/announcing_divan_fast_and_simple_benchmarking_for/">Reddit</a></li>
<li><a href="https://news.ycombinator.com/item?id=37773599">Hacker News</a></li>
<li><a href="https://lobste.rs/s/etnchk/divan_fast_simple_benchmarking_for_rust">Lobsters</a></li>
<li><a href="https://twitter.com/NikolaiVazquez/status/1709732051115442529">Twitter</a></li>
<li><a href="https://hachyderm.io/@nikolai/111179659061831881">Mastodon</a></li>
</ul></div></div>
  </body>
</html>
