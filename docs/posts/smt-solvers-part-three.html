<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://shapr.github.io/posts/2022-04-11-smt-solvers-part-three.html">Original</a>
    <h1>SMT Solvers part three</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            

            <p>
    Posted on April 11, 2022
    
</p>

<p><img src="https://www.politico.com/news/2022/03/images/lasabrjotur.png"/></p>

<p>Recurse Center has a workshop in the first week, introduction to pairing.</p>
<p>We all sign up in a google spreadsheet, row labels on the left are people names,
column labels are programming language names.</p>
<p>The intersection of person and language can have three values:</p>
<ul>
<li>empty</li>
<li>ok</li>
<li>preferred</li>
</ul>
<p>I have the impression that the RC faculty solves this semi-manually, but I don’t really know. In any case, why not hit it with the biggest hammer?</p>

<p>I started with a list of users like <code>[(&#34;shae&#34;,0,1,2),(&#34;chris&#34;,2,1,0)]</code> where the tuple elements were name and language preference.
I arbitrarily decided that a preferred language was 2, an ok language was 1, and empty was 0.</p>
<p>I decided my value proposition would be something like “amount of points removed from the total by subtracting one user from another” and it just didn’t work out. I got stuck and frustrated.</p>

<p>A few days later I brought this up during a pairing session with <a href="https://github.com/cdsmith">Chris Smith</a>.</p>
<p>After giving Chris a hand wavy explanation and a quick tour of the SMT examples, he suggested we take the approach from the
<a href="https://github.com/LeventErkok/sbv/blob/master/Documentation/SBV/Examples/Optimization/VM.hs">Virtual Machine allocation example</a>.</p>
<p>If you read the Dennis Yurichev’s book <a href="https://sat-smt.codes/">SAT/SMT By Example</a> VM allocation is in the section on Knapsack problems, and that’s pretty much what we have.</p>
<p>Chris also suggested we change the scoring function to be the sum of the matched part of the pairs.</p>
<p>When Chris and I started out with a list of tuples it worked, but hard to add new languages.
We converted the players to a tuple of <code>(String,[Int])</code> and it got much easier.</p>
<p>Originally I wanted to return the players and what language matched them, but matching people is more fun because they have something to talk about.</p>

<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a> <span>{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span>module</span> <span>Main</span> <span>where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span>import</span> <span>Control.Monad</span> (forM_)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span>import</span> <span>Data.Maybe</span> (fromJust)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span>import</span> <span>Data.SBV</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span>import</span> <span>Data.SBV.Internals</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span> main ::</span> <span>IO</span> ()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> main <span>=</span> <span>do</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>   <span>LexicographicResult</span> res <span>&lt;-</span> optimize <span>Lexicographic</span> allocate</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>   <span>case</span> res <span>of</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>     <span>Satisfiable</span> config model <span>-&gt;</span> <span>print</span> <span>$</span> <span>filter</span> ((<span>==</span> <span>True</span>) <span>.</span> cvToBool <span>.</span> <span>snd</span>) (modelAssocs model)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>     _ <span>-&gt;</span> <span>print</span> <span>&#34;Unsatisfiable&#34;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a> <span>-- per language: 0 &#34;no interest&#34;, 1 &#34;ok&#34;, 2 &#34;preferred&#34;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a> <span>-- (&#34;name&#34;,[javascript, python, haskell,lisp] )</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span> players ::</span> [<span>Player</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> players <span>=</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>   [ (<span>&#34;p1 &#34;</span>, [<span>0</span>, <span>1</span>, <span>2</span>, <span>0</span>]),</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p2 &#34;</span>, [<span>0</span>, <span>1</span>, <span>0</span>, <span>1</span>]),</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p3 &#34;</span>, [<span>0</span>, <span>2</span>, <span>0</span>, <span>1</span>]),</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p4 &#34;</span>, [<span>0</span>, <span>1</span>, <span>2</span>, <span>0</span>]),</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p5 &#34;</span>, [<span>0</span>, <span>1</span>, <span>0</span>, <span>2</span>]),</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p6 &#34;</span>, [<span>0</span>, <span>1</span>, <span>0</span>, <span>0</span>]),</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p7 &#34;</span>, [<span>0</span>, <span>1</span>, <span>0</span>, <span>0</span>]),</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p8 &#34;</span>, [<span>0</span>, <span>1</span>, <span>2</span>, <span>0</span>]),</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p9 &#34;</span>, [<span>0</span>, <span>1</span>, <span>0</span>, <span>0</span>]),</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;p0 &#34;</span>, [<span>0</span>, <span>1</span>, <span>0</span>, <span>0</span>]),</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>     (<span>&#34;bot &#34;</span>, [<span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>])</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>   ]</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a> <span>type</span> <span>Player</span> <span>=</span> (<span>String</span>, <span>Score</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a> <span>type</span> <span>Score</span> <span>=</span> [<span>Int</span>]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span> score ::</span> <span>Score</span> <span>-&gt;</span> <span>Score</span> <span>-&gt;</span> <span>SWord32</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a> score s1 s2 <span>=</span> <span>fromIntegral</span> <span>$</span> <span>maximum</span> <span>$</span> <span>zipWith</span> scoreLang s1 s2</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>   <span>where</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>     scoreLang a b <span>=</span> (<span>2</span> <span>*</span> <span>min</span> a b) <span>+</span> <span>max</span> a b</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span> allocate ::</span> <span>Goal</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a> allocate <span>=</span> <span>do</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>   <span>let</span> uPairs <span>=</span> uniquePairs players</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>pairname ((n1, _), (n2, _)) <span>=</span> n1 <span>&lt;&gt;</span> n2</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>   vars <span>&lt;-</span> sBools <span>$</span> pairname <span>&lt;$&gt;</span> uPairs</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>   <span>let</span> pairsWithVars <span>=</span> <span>zip</span> uPairs<span> vars ::</span> [((<span>Player</span>, <span>Player</span>), <span>SBool</span>)]</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>   forM_ players <span>$</span> \(name, _) <span>-&gt;</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>     constrain <span>$</span> pbMutexed [v <span>|</span> (((n1, _), (n2, _)), v) <span>&lt;-</span> pairsWithVars, n1 <span>==</span> name <span>||</span> n2 <span>==</span> name]</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>   maximize</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>     <span>&#34;best pairs&#34;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>     (<span>sum</span> [ite v (score s1 s2) <span>0</span> <span>|</span> (((n1, s1), (n2, s2)), v) <span>&lt;-</span> pairsWithVars]<span> ::</span> <span>SWord32</span>)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span> uniquePairs ::</span> [a] <span>-&gt;</span> [(a, a)]</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a> uniquePairs [] <span>=</span> []</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a> uniquePairs (x <span>:</span> xs) <span>=</span> <span>map</span> (x,) xs <span>&lt;&gt;</span> uniquePairs xs</span></code></pre></div>

<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[(<span>&#34;p1 p8 &#34;</span>,<span>True</span><span> ::</span> <span>Bool</span>),(<span>&#34;p2 p5 &#34;</span>,<span>True</span><span> ::</span> <span>Bool</span>),(<span>&#34;p3 p9 &#34;</span>,<span>True</span><span> ::</span> <span>Bool</span>),(<span>&#34;p4 p7 &#34;</span>,<span>True</span><span> ::</span> <span>Bool</span>),(<span>&#34;p6 p0 &#34;</span>,<span>True</span><span> ::</span> <span>Bool</span>),(<span>&#34;best pairs&#34;</span>,<span>20</span><span> ::</span> <span>Word32</span>)]</span></code></pre></div>
<p>This means player 1 is matched with player 8, player 2 is matched with player 5, … and the “best pairs” result means the total utility of this combination is 20.</p>

<p>The VM allocation example uses <a href="https://hackage.haskell.org/package/sbv-8.17/docs/Data-SBV.html#v:pbStronglyMutexed">pbStronglyMutexed</a> and that surprised us when one of our inputs gave “Unsatisfiable.” After a moment of staring at the code, we realized there were an odd number of players.
You can’t pair up every player if you don’t have an even number of players!</p>
<p>Chris suggested we switch to <a href="https://hackage.haskell.org/package/sbv-8.17/docs/Data-SBV.html#v:pbMutexed">pbMutexed</a> which requires that there is “at most one bit” set, so we wouldn’t have that error again.</p>
<p>I had the idea to add a faculty / bot player with all zero values so they’d be the odd one out unless a player was left without a match.</p>
<p>Normally, the results of this code looked like the somewhat unreadable output below:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>shaejoe          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>shaebob          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>shaebob2         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>shaebob3         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>shaebob4         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>shaebob5         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>joebob           <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>joebob2          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>joebob3          <span>=</span>  <span>True</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>joebob4          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>joebob5          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>bobbob2          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>bobbob3          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>bobbob4          <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>bobbob5          <span>=</span>  <span>True</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>bob2bob3         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>bob2bob4         <span>=</span>  <span>True</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>bob2bob5         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>bob3bob4         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>bob3bob5         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>bob4bob5         <span>=</span> <span>False</span><span> ::</span> <span>Bool</span></span></code></pre></div>
<p>To improve readability, we pattern matched on the result and only displayed the pairs that were matched, it looks much nicer.</p>

<p>The pairing workshop uses google sheets for signup, and I have the urge to export that as CSV and read that directly into the players datastructure, maybe that’s a short and easy improvement?</p>
<p>At one point we were using <a href="https://hackage.haskell.org/package/sbv-8.17/docs/Data-SBV.html#t:OptimizeStyle">Pareto (Just 5)</a> instead of <code>LexicographicResult</code>, that returned the top five solutions. If I can think of how that’s useful, I’ll switch back to that.</p>
<p>The output formatting could be much nicer?</p>

<p>If you get excited about SMT solvers, check out the syllabus for <a href="http://composition.al/CSE290Q-2019-09/">Lindsey Kuper</a>’s course, and <a href="https://sat-smt.codes/">the book</a> by Dennis Yurichev.</p>
<p>Send me your suggestions for improvement, I want to hear what you think!</p>

        </div></div>
  </body>
</html>
