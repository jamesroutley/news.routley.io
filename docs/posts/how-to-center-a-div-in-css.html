<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joshwcomeau.com/css/center-a-div/">Original</a>
    <h1>How to center a div in CSS</h1>
    
    <div id="readability-page-1" class="page"><article data-layout="tutorial"><a id="introduction"><h2>Introduction</h2></a><p>For a long time, centering an element within its parent was a surprisingly tricky thing to do. As CSS has evolved, we&#39;ve been granted more and more tools we can use to solve this problem. These days, we&#39;re spoiled for choice!</p><p>I decided to create this tutorial to help you understand the trade-offs between different approaches, and to give you an arsenal of strategies you can use, to handle centering in all sorts of scenarios.</p><p>Honestly, this turned out to be <em>way more interesting</em> than I initially thought<!-- -->¬†<!-- -->üòÖ. Even if you&#39;ve been using CSS for a while, I bet you&#39;ll learn at least 1 new strategy!</p><p>The first strategy we&#39;ll look at is one of the oldest. If we want to center an element horizontally, we can do so using margins set to the special value <code>auto</code>:</p><!--$?--><template id="B:0"></template><!--/$--><p>First, we need to constrain the element&#39;s width; by default, elements in Flow layout will expand horizontally to fill the available space, and we can&#39;t really center something that is full-width.</p><p>I <em>could</em> constrain the width with a fixed value (eg. <code>200px</code>), but really what I want in this case is for the element to shrinkwrap around its content. <code>fit-content</code> is a magical value that does exactly this. Essentially, it makes ‚Äúwidth‚Äù behave like ‚Äúheight‚Äù, so that the element‚Äôs size is determined by its contents.</p><p><strong>Why am I setting <code>max-width</code> instead of <code>width</code>?</strong> Well, my goal is to stop the element from expanding horizontally. I want to clamp its maximum size. If I used <code>width</code> instead, it would lock it to that size, and the element would overflow when the container is really narrow. If you drag that ‚ÄúContainer Width‚Äù slider all the way to the left, you can see that the element shrinks with its container.</p><p>Now that our element is constrained, we can center it with <em>auto margins</em>.</p><p>I like to think of auto margins like <em>Hungry Hungry Hippos</em>. Each auto margin will try to gobble up as much space as possible. For example, check out what happens if we <em>only</em> set <code>margin-left: auto</code>:</p><!--$?--><template id="B:1"></template><!--/$--><p>When <code>margin-left</code> is the only side with auto margins, <em>all</em> of the extra space gets applied as margin to that side. When we set both <code>margin-left: auto</code> <em>and</em> <code>margin-right: auto</code>, the two hippos each gobble up an equal amount of space. This forces the element to the center.</p><p><em>Also:</em> I&#39;ve been using <code>margin-left</code> and <code>margin-right</code> because they&#39;re familiar, but there&#39;s a better, more-modern way to do this:</p><!--$?--><template id="B:2"></template><!--/$--><p><code>margin-inline</code> will set both <code>margin-left</code> and <code>margin-right</code> to the same value (<code>auto</code>). It has <a href="https://caniuse.com/mdn-css_properties_margin-inline" rel="noopener noreferrer" target="_blank">very good browser support</a>, having landed in all major browsers several years ago.</p><p>Even though this centering method has been around forever, I still find myself reaching for it on a regular basis! It&#39;s particularly useful when we want to center a single child, without affecting any of its siblings (for example, an image in-between paragraphs in a blog post).</p><p>Let&#39;s continue on our centering journey.</p><p>Flexbox is designed to give us a <em>ton</em> of control when it comes to distributing a group of items along a primary axis. It offers some <em>really</em> powerful tools for centering!</p><p>Let&#39;s start by centering a single element, both horizontally and vertically:</p><!--$?--><template id="B:3"></template><!--/$--><p>The really cool thing about Flexbox centering is that it works <em>even when the children don‚Äôt fit in their container!</em> Try shrinking the width/height, and notice that the element overflows symmetrically.</p><p>It also works for <em>multiple</em> children. We can control how they stack with the <code>flex-direction</code> property:</p><!--$?--><template id="B:4"></template><!--/$--><p>Out of all the centering patterns we&#39;ll explore in this tutorial, this is probably the one I use the most. It&#39;s a great jack-of-all-trades, a great default option.</p><p>So far, we&#39;ve been looking at how to center an element within its parent container. But what if we want to center an element in a different context? Certain elements like dialogs, prompts, and GDPR banners need to be centered within the viewport.</p><p>This is the domain of <em>positioned layout,</em> a layout mode used when we want to take something out of flow and anchor it to something else.</p><p>Here&#39;s what this looks like:</p><!--$?--><template id="B:5"></template><!--/$--><p>Of all the strategies we&#39;ll discuss, this one is probably the most complex. Let&#39;s break it down.</p><p>We&#39;re using <code>position: fixed</code>, which anchors this element to the viewport. I like to think of the viewport like a pane of glass that sits in front of the website, like the window of a train that shows the landscape scrolling by. An element with <code>position: fixed</code> is like a ladybug that lands on the window.</p><p>Next, we&#39;re setting <code>inset: 0px</code>, which is a shorthand that sets <code>top</code>, <code>left</code>, <code>right</code>, and <code>bottom</code> all to the same value, <code>0px</code>.</p><p>With only these two properties, the element would stretch to fill the entire viewport, growing so that it&#39;s 0px from each edge. This can be useful in some contexts, but it&#39;s not what we&#39;re going for here. We need to constrain it.</p><p>The exact values we pick will vary on the specifics of each situation, but in general we want to set default values (with <code>width</code> and <code>height</code>), as well as max values (<code>max-width</code> and <code>max-height</code>), so that the element doesn&#39;t overflow on smaller viewports.</p><p><strong>There&#39;s something interesting here:</strong> we&#39;ve set up an impossible condition. Our element can&#39;t be 0px from the left <em>and</em> 0px from the right <em>and</em> only 12rem wide (assuming the viewport is wider than 12rem). We can only pick 2:</p><!--$?--><template id="B:6"></template><!--/$--><p><strong>The CSS rendering engine resolves this tension by prioritizing.</strong> It will listen to the <code>width</code> constraint, since that seems important. And if it can&#39;t anchor to the left <em>and</em> the right, it&#39;ll pick an option based on the page&#39;s language; so, in a left-to-right language like English, it&#39;ll sit along the left edge.</p><p><em>But!</em> When we bring our old friend <code>margin: auto</code> into the equation, something interesting happens. It changes how the browser resolves the impossible condition; instead of anchoring to the left edge, <em>it centers it</em>.</p><p>And, unlike auto margins in <em>Flow</em> layout, we can use this trick to center an element both horizontally <em>and</em> vertically.</p><!--$?--><template id="B:7"></template><!--/$--><p>It&#39;s a lot to remember, but there are 4 key ingredients for this trick.</p><ol><li><p>Fixed positioning</p></li><li><p>Anchoring to all 4 edges with <code>inset: 0px</code></p></li><li><p>Constrained width and height</p></li><li><p>Auto margins</p></li></ol><p>We can use the same trick to center something in a single direction. For example, we can build a GDPR cookie banner that is horizontally centered, but anchored near the bottom of the viewport:</p><!--$?--><template id="B:8"></template><!--/$--><p>By omitting <code>top: 0px</code>, we remove the impossible condition in the vertical direction, and our banner is anchored to the bottom edge. As a nice touch, I used the <code>calc</code> function to clamp the max width, so that there&#39;s always a bit of buffer around the element.</p><p>I also swapped <code>margin: auto</code> for <code>margin-inline: auto</code>, which isn&#39;t strictly necessary, but feels more precise.</p><p>The approach described above requires that we give our element a specific size, but what about when we don&#39;t <em>know</em> how big it should be?</p><p>In the past, we had to resort to transform hacks to accomplish this, but fortunately, our friend <code>fit-content</code> can help here as well!</p><!--$?--><template id="B:9"></template><!--/$--><p>This will cause the element to shrink around its contents. We can still set a <code>max-width</code> if we&#39;d like to constrain it (eg. <code>max-width: 60vw</code>), but we don&#39;t <em>need</em> to set a max-width; the element will automatically stay contained within the viewport.</p><p>The most terse way I know to center something both horizontally and vertically is with CSS Grid:</p><!--$?--><template id="B:a"></template><!--/$--><p>The <code>place-content</code> property is a shorthand for both <code>justify-content</code> and <code>align-content</code>, applying the same value to both rows and columns. The result is a 1√ó1 grid with a cell right in the middle of the parent container.</p><p>This solution <em>looks</em> quite a bit like our Flexbox solution, but it&#39;s important to keep in mind that it uses a totally different layout algorithm. In my own work, I&#39;ve found that the CSS Grid solution isn&#39;t as universally effective as the Flexbox one.</p><p>For example, consider the following setup:</p><!--$?--><template id="B:b"></template><!--/$--><p>Weird, right? Why does the CSS Grid version get so teensy-tiny?!</p><p><strong>Here&#39;s the deal:</strong> the child element is given <code>width: 50%</code> and <code>height: 50%</code>. In Flexbox, these percentages are calculated based on the parent element, <code>.container</code>, which is what we want.</p><p>In CSS Grid, however, the percentages are <em>relative to the grid cell.</em> We&#39;re saying that the child element should be 50% as wide as its column, and 50% as tall as its row.</p><p>Now, we haven&#39;t actually given the row/column an explicit size; we haven&#39;t defined <code>grid-template-columns</code> or <code>grid-template-rows</code>. When we omit this information, the grid tracks will calculate their size <em>based on their contents</em>, shrinkwrapping around whatever is in each row/column.</p><p>The end result is that our grid cell is the same size as <code>.element</code>‚Äôs original size, and then the element shrinks to 50% of that grid cell:</p><!--$?--><template id="B:c"></template><!--/$--><p>This is a whole rabbithole, and I don&#39;t want to get too far off track; my point is that CSS Grid is a sophisticated layout algorithm, and sometimes, the extra complexity gets in the way. We <em>could</em> add some more CSS to fix this code, but I think it&#39;s simpler to use Flexbox instead.</p><p><strong>CSS Grid gives us one more centering super-power.</strong> With CSS Grid, we can assign multiple elements to the same cell:</p><!--$?--><template id="B:d"></template><!--/$--><p>We still have a 1√ó1 grid, except now we&#39;re cramming <em>multiple</em> children to sit in that cell with <code>grid-row</code> / <code>grid-column</code>.</p><p>In case it&#39;s not clear, here&#39;s a quick sketch of the HTML for this kind of setup:</p><pre></pre><p>In other layout modes, the elements would stack horizontally or vertically, but with this CSS Grid setup, the elements stack back-to-front, since they&#39;re all told to share the same grid space. Pretty cool, right?</p><p>Incredibly, this can work <em>even when the child elements are different sizes!</em> Check this out:</p><!--$?--><template id="B:e"></template><!--/$--><p>In this demo, dashed red lines are added to show the grid row and column. Notice that they expand to contain the largest child; with all the elements added, the resulting cell is as wide as the pink skyline image, and as tall as the colourful space image!</p><p>We do need one more property to make this work: <code>place-items: center</code>. <code>place-items</code> is a shorthand for <code>justify-items</code> and <code>align-items</code>, and these properties control the alignment of the images <em>within</em> the grid cell.</p><p>Without this property, the grid cell would still be centered, but the images <em>within</em> that cell would all stack in the top-left corner:</p><!--$?--><template id="B:f"></template><!--/$--><p><em>This is pretty advanced stuff!</em> You can learn more about how the CSS Grid layout mode works in a recent tutorial I published, <a href="https://www.joshwcomeau.com/css/interactive-guide-to-grid/">An Interactive Guide to CSS Grid</a>.</p><p>Text is its own special thing in CSS. We can&#39;t influence individual characters using the techniques explored in this post.</p><p>For example, if we try to center a paragraph with Flexbox, we&#39;ll center the <em>block of text</em>, not the text itself:</p><!--$?--><template id="B:10"></template><!--/$--><p>Flexbox is centering the paragraph within the viewport, but it doesn&#39;t affect the individual characters. They remain left-aligned.</p><p>We need to use <code>text-align</code> to center the text:</p><!--$?--><template id="B:11"></template><!--/$--><p>Earlier, we saw how we can use auto margins to center an element horizontally in Flow layout. If we want that element to be centered vertically as well, we need to switch to a different layout mode, like Flexbox or Grid.</p><p>‚Ä¶or do we?</p><p>Check this out:</p><!--$?--><template id="B:12"></template><!--/$--><p><em>What the heck??</em> <code>align-content</code> is a CSS Grid thing, but we aren&#39;t setting <code>display: grid</code> here. How is this working?</p><p>One of the biggest epiphanies I&#39;ve ever had about CSS is that it&#39;s a <em>collection of layout algorithms.</em> The properties we write are <em>inputs</em> to those algorithms. <code>align-content</code> was first implemented in Flexbox, and took on an even bigger role in CSS Grid, but it wasn&#39;t implemented in the default layout algorithm, Flow layout. Until now.</p><p>As I write this in early 2024, browser vendors are in the process of implementing <code>align-content</code> in Flow layout, so that it controls the ‚Äúblock‚Äù direction alignment of content. It&#39;s still early days; this new behaviour is only available in Chrome Canary (<a href="chrome://flags/#enable-experimental-web-platform-features">behind a flag</a>) and Safari Technical Preview.</p><p>(I should note, the demo above is fake. I got a feel for the new <code>align-content</code> support in Chrome Canari and Safari TP, and then recreated the exact same behaviour using Flexbox. Sorry for the deception!)</p><p>So, for many years, I treated CSS like a collection of patterns. I had a bunch of memorized snippets that would paste from my brain, to solve whatever problem I was currently facing.</p><p>This worked alright, but it did feel pretty limiting. And every now and then, things would inexplicably break; a snippet I‚Äôd used hundreds of times would suddenly behave differently.</p><p>When I took the time to learn CSS at a deeper level, my experience with the language completely changed. So many things clicked into place. Instead of relying on memorized snippets, I could instead rely on my intuition! ‚ú®</p><p>In this tutorial, we‚Äôve explored a handful of useful centering patterns, and I hope they‚Äôll come in handy the next time you need to center something. Truthfully, though, we&#39;ve only scratched the surface here; there are <em>so many ways</em> we can use modern CSS to center stuff! Instead of memorizing even more snippets, I think it&#39;s better to build a robust mental model of how CSS works, so that we can come up with solutions on-the-fly!</p><p>I spent 2 years of my life creating the ultimate resource for developing a deep understanding of CSS. It&#39;s called <a href="https://css-for-js.dev/" rel="noopener noreferrer" target="_blank"><strong>CSS for JavaScript Developers</strong></a>.</p><p>If you found this tutorial helpful, you‚Äôll get <em>so much</em> out of my course. We take a similar approach to the entire CSS language, building an intuition for how all of the different layout algorithms work.</p><p>It includes interactive text content like this blog post, but also videos, exercises, real-world-inspired workshops, and even a few minigames. It&#39;s unlike any other course you‚Äôve taken.</p><p>If this sounds interesting to you, you can learn more here:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span></li></ul><p>Before we wrap up, let&#39;s summarize what we&#39;ve learned by building a sort of decision tree, so that we can figure out when to use which method.</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>If we want to horizontally center a single element without disturbing any of its siblings, we can use the <a href="#centering-with-auto-margins">Flow layout auto margin strategy</a>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>If we want to center a stack of elements one on top of the other, we can use <a href="#centering-a-stack-of-elements">CSS Grid</a>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>If we want to center text, we can use <a href="#centering-text">text-align</a>. This can be used in conjunction with any of the additional methods.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>Finally, in most other situations, we can use <a href="#centering-with-flexbox">Flexbox</a>. It&#39;s the most versatile method; it can be used to center one or multiple children, horizontally and/or vertically, whether they&#39;re contained or overflowing.</p></li></ul><p>Like a carpenter‚Äôs workshop, we&#39;ve assembled quite a lot of helpful tools in this tutorial, each with its own specialized purpose. I hope that you‚Äôve learned some new strategies here! Happy centering. ‚ù§Ô∏è</p><div><div><h3>Last Updated</h3><p>February 13th, 2024</p></div></div></article></div>
  </body>
</html>
