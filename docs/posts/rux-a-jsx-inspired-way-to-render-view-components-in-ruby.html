<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/camertron/rux">Original</a>
    <h1>Rux: A JSX-inspired way to render view components in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><h2 tabindex="-1" dir="auto"><a id="user-content-rux" aria-hidden="true" href="#rux"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>rux</h2>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/camertron/rux/actions/workflows/unit_tests.yml/badge.svg?branch=master"><img src="https://github.com/camertron/rux/actions/workflows/unit_tests.yml/badge.svg?branch=master" alt="Unit Tests"/></a></p>
<p dir="auto">Rux is a JSX-inspired way to write HTML tags in your Ruby code. It can be used to render view components in Rails via the <a href="https://github.com/camertron/rux-rails">rux-rails gem</a>. This repo however contains only the rux parser itself.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-introduction" aria-hidden="true" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Introduction</h2>
<p dir="auto">A bit of background before we dive into how to use rux.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-react-and-jsx" aria-hidden="true" href="#react-and-jsx"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>React and JSX</h3>
<p dir="auto">React mainstreamed the idea of composing websites from a series of components. To make it conceptually easier to transition from HTML templates to Javascript components, React also introduced an HTML-based syntax called JSX that allows developers to embed HTML into their Javascript code.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-rails-view-components" aria-hidden="true" href="#rails-view-components"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Rails View Components</h3>
<p dir="auto">For a long time, Rails didn&#39;t really have any support for components, preferring to rely on HTML template languages like ERB and HAML. The fine folks at Github however decided components could work well in Rails and released their <a href="https://github.com/github/view_component">view_component framework</a>. There was even some talk about merging view_component into Rails core as <code>ActionView::Component</code>, but unfortunately it looks like that won&#39;t be happening.</p>
<p dir="auto"><strong>NOTE</strong>: I&#39;m going to be focusing on Rails examples here using the view_component gem, but rendering views from a series of components is a framework-agnostic idea.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-view-component-example" aria-hidden="true" href="#view-component-example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>View Component Example</h3>
<p dir="auto">A view component is just a class. The actual view portion is usually stored in a secondary template file that the component renders in the context of an instance of that class. For example, here&#39;s a very basic view component that displays a person&#39;s name on the page:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# app/components/name_component.rb
class NameComponent &lt; ViewComponent::Base
  def initialize(first_name:, last_name:)
    @first_name = first_name
    @last_name = last_name
  end
end"><pre><span># app/components/name_component.rb</span>
<span>class</span> <span>NameComponent</span> &lt; <span>ViewComponent</span>::<span>Base</span>
  <span>def</span> <span>initialize</span><span>(</span><span>first_name</span>:<span>,</span> <span>last_name</span>:<span>)</span>
    <span>@first_name</span> <span>=</span> <span>first_name</span>
    <span>@last_name</span> <span>=</span> <span>last_name</span>
  <span>end</span>
<span>end</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="&lt;%# app/components/name_component.html.erb %&gt;
&lt;span&gt;&lt;%= @first_name %&gt; &lt;%= last_name %&gt;&lt;/span&gt;"><pre><span><span>&lt;%#</span> app/components/name_component.html.erb <span>%&gt;</span></span>
<span>&lt;</span><span>span</span><span>&gt;</span><span>&lt;%=</span> <span>@first_name</span> <span>%&gt;</span><span> &lt;%=</span> <span>last_name</span> <span>%&gt;</span><span>&lt;/</span><span>span</span><span>&gt;</span></pre></div>
<p dir="auto">View components have a number of very nice properties. Read about them on <a href="https://viewcomponent.org/" rel="nofollow">viewcomponent.org</a> or watch Joel Hawksley&#39;s excellent 2019 <a href="https://www.youtube.com/watch?v=y5Z5a6QdA-M" rel="nofollow">Railsconf talk</a>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-html-in-your-ruby" aria-hidden="true" href="#html-in-your-ruby"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>HTML in Your Ruby</h2>
<p dir="auto">Rux does one thing: it lets you write HTML in your Ruby code. Here&#39;s the name component example from earlier rewritten in rux (sorry about the syntax highlighting, Github doesn&#39;t know about rux yet).</p>
<div dir="auto" data-snippet-clipboard-copy-content="# app/components/name_component.rux
class NameComponent &lt; ViewComponent::Base
  def initialize(first_name:, last_name:)
    @first_name = first_name
    @last_name = last_name
  end

  def call
    &lt;span&gt;
      {@first_name} {@last_name}
    &lt;/span&gt;
  end
end"><pre><span># app/components/name_component.rux</span>
<span>class</span> <span>NameComponent</span> &lt; <span>ViewComponent</span>::<span>Base</span>
  <span>def</span> <span>initialize</span><span>(</span><span>first_name</span>:<span>,</span> <span>last_name</span>:<span>)</span>
    <span>@first_name</span> <span>=</span> <span>first_name</span>
    <span>@last_name</span> <span>=</span> <span>last_name</span>
  <span>end</span>

  <span>def</span> <span>call</span>
    &lt;<span>span</span>&gt;
      <span>{</span><span>@first_name</span><span>}</span> <span>{</span><span>@last_name</span><span>}</span>
    &lt;/<span>span</span>&gt;
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto"><strong>NOTE</strong>: The example above takes advantage of a feature of the view_component gem that lets you define a <code>call</code> method instead of creating a separate template file.</p>
<p dir="auto">Next, we&#39;ll run the <code>ruxc</code> tool to translate the rux code into Ruby code, eg. <code>ruxc app/components/name_component.rux</code>. Here&#39;s the result:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class NameComponent &lt; ViewComponent::Base
  def initialize(first_name:, last_name:)
    @first_name = first_name
    @last_name = last_name
  end

  def call
    Rux.tag(&#34;span&#34;) {
      Rux.create_buffer.tap { |_rux_buf_,|
        _rux_buf_ &lt;&lt; @first_name
        _rux_buf_ &lt;&lt; &#34; &#34;
        _rux_buf_ &lt;&lt; @last_name
      }.to_s
    }
  end
end"><pre><span>class</span> <span>NameComponent</span> &lt; <span>ViewComponent</span>::<span>Base</span>
  <span>def</span> <span>initialize</span><span>(</span><span>first_name</span>:<span>,</span> <span>last_name</span>:<span>)</span>
    <span>@first_name</span> <span>=</span> <span>first_name</span>
    <span>@last_name</span> <span>=</span> <span>last_name</span>
  <span>end</span>

  <span>def</span> <span>call</span>
    <span>Rux</span><span>.</span><span>tag</span><span>(</span><span>&#34;span&#34;</span><span>)</span> <span>{</span>
      <span>Rux</span><span>.</span><span>create_buffer</span><span>.</span><span>tap</span> <span>{</span> |<span>_rux_buf_</span><span>,</span>|
        <span>_rux_buf_</span> &lt;&lt; <span>@first_name</span>
        <span>_rux_buf_</span> &lt;&lt; <span>&#34; &#34;</span>
        <span>_rux_buf_</span> &lt;&lt; <span>@last_name</span>
      <span>}</span><span>.</span><span>to_s</span>
    <span>}</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">As you can see, the span tag was converted to a <code>Rux.tag</code> call. The instance variables containing the first and last names are concatenated together and rendered inside the span.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-composing-components" aria-hidden="true" href="#composing-components"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Composing Components</h2>
<p dir="auto">Things get even more interesting when it comes to rendering components inside other components. Let&#39;s create a greeting component that makes use of the name component:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# app/components/greeting_component.rux
class GreetingComponent &lt; ViewComponent::Base
  def call
    &lt;div&gt;
      Hey there &lt;NameComponent first-name=&#34;Homer&#34; last-name=&#34;Simpson&#34; /&gt;!
    &lt;/div&gt;
  end
end"><pre><span># app/components/greeting_component.rux</span>
<span>class</span> <span>GreetingComponent</span> &lt; <span>ViewComponent</span>::<span>Base</span>
  <span>def</span> <span>call</span>
    &lt;<span>div</span>&gt;
      <span>Hey</span> <span>there</span> &lt;<span>NameComponent</span> <span>first</span>-<span>name</span><span>=</span><span>&#34;Homer&#34;</span> <span>last</span>-<span>name</span><span>=</span><span>&#34;Simpson&#34;</span> /&gt;!
    &lt;/<span>div</span>&gt;
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">The <code>ruxc</code> tool produces:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class GreetingComponent &lt; ViewComponent::Base
  def call
    Rux.tag(&#34;div&#34;) {
      Rux.create_buffer.tap { |_rux_buf_,|
        _rux_buf_ &lt;&lt; &#34; Hey there &#34;
        _rux_buf_ &lt;&lt; render(NameComponent.new(first_name: &#34;Homer&#34;, last_name: &#34;Simpson&#34;))
        _rux_buf_ &lt;&lt; &#34;! &#34;
      }.to_s
    }
  end
end"><pre><span>class</span> <span>GreetingComponent</span> &lt; <span>ViewComponent</span>::<span>Base</span>
  <span>def</span> <span>call</span>
    <span>Rux</span><span>.</span><span>tag</span><span>(</span><span>&#34;div&#34;</span><span>)</span> <span>{</span>
      <span>Rux</span><span>.</span><span>create_buffer</span><span>.</span><span>tap</span> <span>{</span> |<span>_rux_buf_</span><span>,</span>|
        <span>_rux_buf_</span> &lt;&lt; <span>&#34; Hey there &#34;</span>
        <span>_rux_buf_</span> &lt;&lt; <span>render</span><span>(</span><span>NameComponent</span><span>.</span><span>new</span><span>(</span><span>first_name</span>: <span>&#34;Homer&#34;</span><span>,</span> <span>last_name</span>: <span>&#34;Simpson&#34;</span><span>)</span><span>)</span>
        <span>_rux_buf_</span> &lt;&lt; <span>&#34;! &#34;</span>
      <span>}</span><span>.</span><span>to_s</span>
    <span>}</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">The <code>&lt;NameComponent&gt;</code> tag was translated into an instance of the <code>NameComponent</code> class and the attributes into its keyword arguments.</p>
<p dir="auto"><strong>NOTE</strong>: The <code>render</code> method is provided by <code>ViewComponent::Base</code>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-embedding-ruby" aria-hidden="true" href="#embedding-ruby"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Embedding Ruby</h2>
<p dir="auto">Since rux code is translated into Ruby code, anything goes. You&#39;re free to put any valid Ruby statements inside the curly braces.</p>
<p dir="auto">For example, let&#39;s say we want to change our greeting component to greet a variable number of people:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# app/components/greeting_component.rux
class GreetingComponent &lt; ViewComponent::Base
  def initialize(people:)
    # people is an array of hashes containing :first_name and :last_name keys
    @people = people
  end

  def call
    &lt;div&gt;
      {@people.map do |person|
        &lt;NameComponent
          first-name={person[:first_name]}
          last-name={person[:last_name]}
        /&gt;
      end}
    &lt;/div&gt;
  end
end"><pre><span># app/components/greeting_component.rux</span>
<span>class</span> <span>GreetingComponent</span> &lt; <span>ViewComponent</span>::<span>Base</span>
  <span>def</span> <span>initialize</span><span>(</span><span>people</span>:<span>)</span>
    <span># people is an array of hashes containing :first_name and :last_name keys</span>
    <span>@people</span> <span>=</span> <span>people</span>
  <span>end</span>

  <span>def</span> <span>call</span><span></span>
    &lt;<span>div</span>&gt;
      <span>{</span><span>@people</span><span>.</span><span>map</span> <span>do</span> |<span>person</span>|
        &lt;<span>NameComponent</span>
          <span>first</span>-<span>name</span><span>=</span><span>{</span><span>person</span><span>[</span><span>:first_name</span><span>]</span><span>}</span>
          <span>last</span>-<span>name</span><span>=</span><span>{</span><span>person</span><span>[</span><span>:last_name</span><span>]</span><span>}</span>
        <span>/&gt;</span>
<span>      end}</span>
<span>    &lt;/div</span>&gt;
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">Notice we were able to embed Ruby within rux within Ruby within rux. Within Ruby. The rux parser supports unlimited levels of nesting, although you&#39;ll probably not want to go <em>too</em> crazy.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-keyword-arguments-only" aria-hidden="true" href="#keyword-arguments-only"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Keyword Arguments Only</h2>
<p dir="auto">Any view component that will be rendered by rux must <em>only</em> accept keyword arguments in its constructor. For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class MyComponent &lt; ViewComponent::Base
  # GOOD
  def initialize(first_name:, last_name:)
  end

  # BAD
  def initialize(first_name, last_name)
  end

  # BAD
  def initialize(first_name, last_name = &#39;Simpson&#39;)
  end
end"><pre><span>class</span> <span>MyComponent</span> &lt; <span>ViewComponent</span>::<span>Base</span>
  <span># GOOD</span>
  <span>def</span> <span>initialize</span><span>(</span><span>first_name</span>:<span>,</span> <span>last_name</span>:<span>)</span>
  <span>end</span>

  <span># BAD</span>
  <span>def</span> <span>initialize</span><span>(</span><span>first_name</span><span>,</span> <span>last_name</span><span>)</span>
  <span>end</span>

  <span># BAD</span>
  <span>def</span> <span>initialize</span><span>(</span><span>first_name</span><span>,</span> <span>last_name</span> <span>=</span> <span>&#39;Simpson&#39;</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">In other words, positional arguments are not allowed. This is because there&#39;s no such thing as a positional HTML attribute - all HTML attributes are key/value pairs. So, in order to match up with HTML, rux components are written with keyword arguments.</p>
<p dir="auto">Note also that the rux parser will replace dashes with underscores in rux tag attributes to adhere to both HTML and Ruby syntax conventions, since HTML attributes use dashes while Ruby keyword arguments use underscores. For example, here&#39;s how to write a rux tag for <code>MyComponent</code> above:</p>
<div dir="auto" data-snippet-clipboard-copy-content="&lt;MyComponent first-name=&#34;Homer&#34; last-name=&#34;Simpson&#34; /&gt;"><pre>&lt;<span>MyComponent</span> <span>first</span>-<span>name</span><span>=</span><span>&#34;Homer&#34;</span> <span>last</span>-<span>name</span><span>=</span><span>&#34;Simpson&#34;</span> /&gt;</pre></div>
<p dir="auto">Notice that the rux attribute &#34;first-name&#34; is passed to <code>MyComponent#initialize</code> as &#34;first_name&#34;.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-how-it-works" aria-hidden="true" href="#how-it-works"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How it Works</h2>
<p dir="auto">Translating rux code (Ruby + HTML tags) into Ruby code happens in three phases: lexing, parsing, and emitting. The lexer phase is implemented as a wrapper around the lexer from the <a href="https://github.com/whitequark/parser">Parser gem</a> that looks for specific patterns in the token stream. When it finds an opening HTML tag, it hands off lexing to the rux lexer. When the tag ends, the lexer continues emitting Ruby tokens, and so on.</p>
<p dir="auto">In the parsing phase, the token stream is transformed into an intermediate representation of the code known as an abstract syntax tree, or AST. It&#39;s the parser&#39;s job to work out which tags are children of other tags, associate attributes with tags, etc.</p>
<p dir="auto">Finally it&#39;s time to generate Ruby code in the emitting phase. The rux gem makes use of the visitor pattern and the excellent <a href="https://github.com/mbj/unparser">unparser gem</a> to walk over all the nodes in the AST and generate a big string of Ruby code. This big string is the final product that can be written to a file and executed by the Ruby interpreter.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-transpiling-rux-to-ruby" aria-hidden="true" href="#transpiling-rux-to-ruby"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Transpiling Rux to Ruby</h2>
<p dir="auto">While the <code>ruxc</code> tool is a convenient way to transpile rux to Ruby via the command line, it&#39;s also possible to do so programmatically.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-transpiling-strings" aria-hidden="true" href="#transpiling-strings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Transpiling Strings</h3>
<p dir="auto">Let&#39;s say you have a string containing a bunch of rux code. You can transpile it to Ruby like so:</p>
<div dir="auto" data-snippet-clipboard-copy-content="require &#39;rux&#39;

str = &#39;some rux code&#39;
Rux.to_ruby(str)"><pre><span>require</span> <span>&#39;rux&#39;</span>

<span>str</span> <span>=</span> <span>&#39;some rux code&#39;</span>
<span>Rux</span><span>.</span><span>to_ruby</span><span>(</span><span>str</span><span>)</span></pre></div>
<p dir="auto"><strong>NOTE</strong>: The <code>to_ruby</code> method accepts a visitor instance as its second argument (see below for more information about creating custom visitors). It uses the default visitor if no second argument is provided.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-transpiling-files" aria-hidden="true" href="#transpiling-files"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Transpiling Files</h3>
<p dir="auto">Rux comes with a handy <code>File</code> class to make transpiling files easier:</p>
<div dir="auto" data-snippet-clipboard-copy-content="require &#39;rux&#39;

f = Rux::File.new(&#39;path/to/some/file.rux&#39;)

# get result as a string, same as calling Rux.to_ruby
f.to_ruby

# write result to path/to/some/file.rb
f.write

# write result to the given file
f.write(&#39;somewhere/else/file.rb&#39;)

# the default file the result will be written, i.e. the location
# #write will write to
f.default_outfile"><pre><span>require</span> <span>&#39;rux&#39;</span>

<span>f</span> <span>=</span> <span>Rux</span>::<span>File</span><span>.</span><span>new</span><span>(</span><span>&#39;path/to/some/file.rux&#39;</span><span>)</span>

<span># get result as a string, same as calling Rux.to_ruby</span>
<span>f</span><span>.</span><span>to_ruby</span>

<span># write result to path/to/some/file.rb</span>
<span>f</span><span>.</span><span>write</span>

<span># write result to the given file</span>
<span>f</span><span>.</span><span>write</span><span>(</span><span>&#39;somewhere/else/file.rb&#39;</span><span>)</span>

<span># the default file the result will be written, i.e. the location</span>
<span># #write will write to</span>
<span>f</span><span>.</span><span>default_outfile</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-custom-visitors" aria-hidden="true" href="#custom-visitors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Visitors</h2>
<p dir="auto">Rux comes with a default visitor capable of emitting Ruby code that is mostly compatible with the view_component gem discussed earlier. A little bit of extra work is required to render rux components in Rails, which is why the rux-rails gem uses a modified version of the default visitor to emit Ruby code that will render correctly in Rails views. It&#39;s likely other frameworks that want to render rux components will need a custom visitor as well.</p>
<p dir="auto">Visitors should inherit from the <code>Rux::Visitor</code> class and implement the various methods. See lib/rux/visitor.rb for details. If you&#39;re looking to tweak the default visitor, inherit from <code>Rux::DefaultVisitor</code> instead, and see lib/rux/default_visitor.rb for details.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-custom-tag-builders" aria-hidden="true" href="#custom-tag-builders"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Tag Builders</h2>
<p dir="auto">The <code>Rux.tag</code> method emits HTML tags via the configured tag builder. You can configure a custom tag builder by setting <code>Rux.tag_builder</code> to any object that responds to the <code>call</code> method (and accepts three arguments). For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class MyTagBuilder
  def call(tag_name, attributes = {}, &amp;block)
    # Should return a string, eg. &#39;&lt;div foo=&#34;bar&#34;&gt;&lt;/div&gt;&#39;.
    # When called, the block should return the tag&#39;s body contents.
  end
end

Rux.tag_builder = MyTagBuilder.new"><pre><span>class</span> <span>MyTagBuilder</span>
  <span>def</span> <span>call</span><span>(</span><span>tag_name</span><span>,</span> <span>attributes</span> <span>=</span> <span>{</span><span>}</span><span>,</span> &amp;<span>block</span><span>)</span>
    <span># Should return a string, eg. &#39;&lt;div foo=&#34;bar&#34;&gt;&lt;/div&gt;&#39;.</span>
    <span># When called, the block should return the tag&#39;s body contents.</span>
  <span>end</span>
<span>end</span>

<span>Rux</span><span>.</span><span>tag_builder</span> <span>=</span> <span>MyTagBuilder</span><span>.</span><span>new</span></pre></div>
<p dir="auto">Or, since the only requirement is that the tag builder respond to <code>#call</code>, you could pass a lambda:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Rux.tag_builder = -&gt; (tag_name, attributes = {}, &amp;block) do
  # Should return a string, eg. &#39;&lt;div foo=&#34;bar&#34;&gt;&lt;/div&gt;&#39;.
  # When called, the block should return the tag&#39;s body contents.
end"><pre><span>Rux</span><span>.</span><span>tag_builder</span> <span>=</span> <span>-&gt;</span> <span>(</span><span>tag_name</span><span>,</span> <span>attributes</span> <span>=</span> <span>{</span><span>}</span><span>,</span> &amp;<span>block</span><span>)</span> <span>do</span>
  <span># Should return a string, eg. &#39;&lt;div foo=&#34;bar&#34;&gt;&lt;/div&gt;&#39;.</span>
  <span># When called, the block should return the tag&#39;s body contents.</span>
<span>end</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-custom-buffers" aria-hidden="true" href="#custom-buffers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Buffers</h2>
<p dir="auto">You may have noticed calls to <code>Rux.create_buffer</code> in the code examples above. Rux comes with a default buffer implementation, but you can configure a custom one as well. The rux-rails gem for example configures rux to use <code>ActiveSupport::SafeBuffer</code> in order to be compatible with Rails view rendering. Buffer implementations only need to define two methods: <code>#&gt;&gt;</code> and <code>#to_s</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class MyBuffer
  def initialize
    @buffer = &#39;&#39;
  end

  def &lt;&lt;(thing)
    # it&#39;s important to handle nils here
    @buffer &lt;&lt; (thing || &#39;&#39;)
  end

  def to_s
    @buffer
  end
end

Rux.buffer = MyBuffer"><pre><span>class</span> <span>MyBuffer</span>
  <span>def</span> <span>initialize</span>
    <span>@buffer</span> <span>=</span> <span>&#39;&#39;</span>
  <span>end</span>

  <span>def</span> &lt;&lt;<span>(</span><span>thing</span><span>)</span>
    <span># it&#39;s important to handle nils here</span>
    <span>@buffer</span> &lt;&lt; <span>(</span><span>thing</span> || <span>&#39;&#39;</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>to_s</span>
    <span>@buffer</span>
  <span>end</span>
<span>end</span>

<span>Rux</span><span>.</span><span>buffer</span> <span>=</span> <span>MyBuffer</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-library-path" aria-hidden="true" href="#the-library-path"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Library Path</h2>
<p dir="auto">It is my hope that, in the future, Ruby and Rails devs will publish collections of view components in gem form that other devs can use in their own projects. Maybe some of those view component libraries will even be written in rux. Accordingly, I wanted a way of adding rux components to Rails&#39; eager load system, but without actually depending on Rails.</p>
<p dir="auto">The rux library path is a way for libraries written in rux to register themselves. The rux-rails gem automatically appends every entry in the library path to the Rails eager load and autoload paths so .rux files are automatically reloaded in development mode. Hopefully the library path enables other frameworks to do something similar.</p>
<p dir="auto">Adding a path is done like so:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Rux.library_paths &lt;&lt; &#39;path/to/dir/with/rux/files&#39;"><pre><span>Rux</span><span>.</span><span>library_paths</span> &lt;&lt; <span>&#39;path/to/dir/with/rux/files&#39;</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-editor-support" aria-hidden="true" href="#editor-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Editor Support</h2>
<p dir="auto">Sublime Text: <a href="https://github.com/camertron/rux-SublimeText">https://github.com/camertron/rux-SublimeText</a></p>
<p dir="auto">Atom: <a href="https://github.com/camertron/rux-atom">https://github.com/camertron/rux-atom</a></p>
<p dir="auto">VSCode: <a href="https://github.com/camertron/rux-vscode">https://github.com/camertron/rux-vscode</a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-running-tests" aria-hidden="true" href="#running-tests"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Running Tests</h2>
<p dir="auto"><code>bundle exec rspec</code> should do the trick.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">Licensed under the MIT license. See LICENSE for details.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-authors" aria-hidden="true" href="#authors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Authors</h2>
<ul dir="auto">
<li>Cameron C. Dutro: <a href="http://github.com/camertron">http://github.com/camertron</a></li>
</ul>
</article>
          </div></div>
  </body>
</html>
