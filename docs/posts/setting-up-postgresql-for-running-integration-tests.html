<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gajus.com/blog/setting-up-postgre-sql-for-running-integration-tests">Original</a>
    <h1>Setting up PostgreSQL for running integration tests</h1>
    
    <div id="readability-page-1" class="page"><div><div id="blog-post-body"><div><p>When it comes to testing, achieving performance and reliability is crucial. In this article, I&#39;ll explain how to set up <a href="https://www.postgresql.org/">PostgreSQL</a> for tests and discuss some common pitfalls to avoid.</p>
<h2 id="isolation-as-the-primary-goal"><a aria-hidden="true" href="#isolation-as-the-primary-goal">Isolation as the primary goal</a></h2>
<p>Before we dive into the details, let&#39;s define our goals:</p>
<ul>
<li><strong>Isolation</strong> – We want to ensure that each test runs in isolation. At the very least, this means that each test should have its own database. This ensures that tests don&#39;t interfere with each other and that you can run tests in parallel without any issues.</li>
<li><strong>performance</strong> – We want to ensure that setting up PostgreSQL for tests is fast. A slow solution is going to be cost prohibitive for running tests in CI/CD pipelines. The solution that we come up with must allow us to execute tests without introducing too much overhead.</li>
</ul>
<p>The rest of this article will focus on what we have tried, what worked, and what didn&#39;t work.</p>
<h2 id="what-didnt-work"><a aria-hidden="true" href="#what-didnt-work">What didn&#39;t work</a></h2>
<h3 id="using-transactions"><a aria-hidden="true" href="#using-transactions">Using transactions</a></h3>
<p>The first approach we tried was to use <a href="https://www.postgresql.org/docs/current/tutorial-transactions.html">transactions</a>. We would start a transaction at the beginning of each test and roll it back at the end.</p>
<p>The basic idea is illustrated in the following example:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="ts" data-theme="default"><code data-language="ts" data-theme="default"><span data-line=""><span>test</span><span>(</span><span>&#39;calculates total basket value&#39;</span><span>, </span><span>async</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>  </span><span>await</span><span> pool.</span><span>transaction</span><span>(</span><span>async</span><span> (</span><span>tx</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>    </span><span>await</span><span> tx.</span><span>query</span><span>(sql.</span><span>unsafe</span><span>`</span></span>
<span data-line=""><span>      INSERT INTO basket (product_id, quantity)</span></span>
<span data-line=""><span>      VALUES (1, 2)</span></span>
<span data-line=""><span>    `</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>    </span><span>const</span><span> </span><span>total</span><span> </span><span>=</span><span> </span><span>await</span><span> </span><span>getBasketTotal</span><span>(tx);</span></span>
<span data-line=""> </span>
<span data-line=""><span>    </span><span>expect</span><span>(total).</span><span>toBe</span><span>(</span><span>20</span><span>);</span></span>
<span data-line=""><span>  });</span></span>
<span data-line=""><span>});</span></span></code></pre></div>
<p>The transaction approach works well for simple cases (e.g., testing a single function), but it quickly becomes a problem when dealing with tests that <em>test integration</em> between multiple components. Due to connection pooling, nested transactions, and other factroes, the necessary work to make the transaction approach work would have meant that we are not replicating the real-world behavior of our application, i.e. it would not provide the confidence we need.</p>
<p>For consistency, we also want to avoid mixing testing approaches. Even though using transactions would suffice for some tests, we want to have a consistent approach across all tests.</p>
<h3 id="using-sqlite"><a aria-hidden="true" href="#using-sqlite">Using SQLite</a></h3>
<p>Another approach we tried was to use SQLite. SQLite is an in-memory database that is fast and easy to set up.</p>
<p>Similar to the transaction approach, SQLite works well for simple cases. However, it quickly becomes a problem when dealing with code paths that use PostgreSQL-specific features. In our case, due to the use of various PostgreSQL extensions, PL/pgSQL functions, and other PostgreSQL-specific features, we couldn&#39;t use SQLite for our tests.</p>
<p><a href="https://github.com/electric-sql/pglite">pglite</a> provides PostgreSQL packaged as a <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module">WASM module</a> that can be used in Node.js. This might be a good alternative, though we haven&#39;t tried it yet. Regardless, the current lack of support for extensions would have been a blocker for us.</p>
<h3 id="using-pg_tmp"><a aria-hidden="true" href="#using-pg_tmp">Using <code>pg_tmp</code></a></h3>
<p>Another approach we tried was to use <a href="https://eradman.com/ephemeralpg/"><code>pg_tmp</code></a>. <code>pg_tmp</code> is a tool that creates a temporary PostgreSQL instance for each test.</p>
<p>In theory, <code>pg_tmp</code> is a good solution. It allows a complete isolation of tests. In practice, is a lot slower than we could tolerate. With <code>pg_tmp</code>, it takes a few seconds to start and populate the database, and this overhead quickly adds up when running thousands of tests.</p>
<p>Let&#39;s say you have 1000 tests, and each test takes 1 second to run. If you add 2 seconds of overhead for creating a new database, you are looking at an additional 2000 seconds (33 minutes) of overhead.</p>
<p>If you like this approach, you could also probably get away with using Docker containers. Depending on many factors, Docker containers might be even faster than <code>pg_tmp</code>.</p>
<p><a href="https://github.com/allaboutapps/integresql">integresql</a> is a project that I came across in a <a href="https://news.ycombinator.com/item?id=26947964">HN thread</a>. It seems like a good alternative that reduces the overhead of creating a new database to about 500ms. It has a pooling mechanism that allows you to reduce the overhead even further. We decided against continuing on this path because we were happy with the level of isolation that we got from using <a href="#template-databases">template databases</a>.</p>
<h2 id="what-worked"><a aria-hidden="true" href="#what-worked">What worked</a></h2>
<p>After trying various approaches, we settled on combining two approaches: <a href="#template-databases"><em>template databases</em></a> and <a href="#mounting-a-memory-disk"><em>mounting a memory disk</em></a>. This approach allowed us to isolate each test at a database level without introducing too much overhead or complexity.</p>
<h3 id="template-databases"><a aria-hidden="true" href="#template-databases">Template Databases</a></h3>
<p>A <a href="https://www.postgresql.org/docs/current/manage-ag-templatedbs.html">template databases</a> is a database that serves as a template for creating new databases. When you create a new database from a template database, the new database has the same schema as the template database. The steps to create a new database from a template database are as follows:</p>
<ol>
<li>Create a template database (<code>ALTER DATABASE &lt;database_name&gt; is_template=true;</code>)</li>
<li>Create a new database from the template database (<code>CREATE DATABASE &lt;new_database_name&gt; TEMPLATE &lt;template_database_name&gt;;</code>)</li>
</ol>
<p>The key advantage of using template databases is that you do not need to mess with managing multiple PostgreSQL instances. You can create copy databases and have each test run in isolation.</p>
<p>However, on its own, template databases are not fast enough for our use case. The time it takes to create a new database from a template database is still too high for running thousands of tests:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="sql" data-theme="default"><code data-language="sql" data-theme="default"><span data-line=""><span>postgres</span><span>=</span><span># </span><span>CREATE</span><span> </span><span>DATABASE</span><span> foo TEMPLATE contra;</span></span>
<span data-line=""><span>CREATE</span><span> </span><span>DATABASE</span></span>
<span data-line=""><span>Time</span><span>: </span><span>1999</span><span>.</span><span>758</span><span> ms (</span><span>00</span><span>:</span><span>02</span><span>.</span><span>000</span><span>)</span></span></code></pre></div>
<p>This is where the <a href="#mounting-a-memory-disk">memory mounting</a> comes in.</p>
<p>The other limitation of template databases to be aware of is that no other sessions can be connected to the source database while it is being copied. <code>CREATE DATABASE</code> will fail if any other connection exists when it starts; during the copy operation, new connections to the source database are prevented. It is an easy enough limitation to work around using a <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex pattern</a>, but it is something to be aware of.</p>
<h3 id="mounting-a-memory-disk"><a aria-hidden="true" href="#mounting-a-memory-disk">Mounting a memory disk</a></h3>
<p>The final piece of the puzzle is mounting a memory disk. By mounting a memory disk, and creating the template database on the memory disk, we can significantly reduce the overhead of creating a new database.</p>
<p>I will talk about how to mount a memory disk in the next section, but first, let&#39;s see how much of a difference it makes.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="sql" data-theme="default"><code data-language="sql" data-theme="default"><span data-line=""><span>postgres</span><span>=</span><span># </span><span>CREATE</span><span> </span><span>DATABASE</span><span> bar TEMPLATE contra;</span></span>
<span data-line=""><span>CREATE</span><span> </span><span>DATABASE</span></span>
<span data-line=""><span>Time</span><span>: </span><span>87</span><span>.</span><span>168</span><span> ms</span></span></code></pre></div>
<p>This is a significant improvement and makes the approach viable for our use case.</p>
<p>Needless to say, this approach is not without its drawbacks. The data is stored in memory, which means that it is not persistent. If the database crashes or the server restarts, the data is lost. However, for running tests, this is not a problem. The data is recreated from the template database each time a new database is created.</p>
<h3 id="using-docker-container-with-a-memory-disk"><a aria-hidden="true" href="#using-docker-container-with-a-memory-disk">Using Docker container with a memory disk</a></h3>
<p>The approach we settled on was to use a Docker container with a memory disk. Here is how you can set it up:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="bash" data-theme="default"><code data-language="bash" data-theme="default"><span data-line=""><span>$</span><span> </span><span>docker</span><span> </span><span>run</span><span> </span><span>\</span></span>
<span data-line=""><span>  </span><span>-p</span><span> </span><span>5435</span><span>:5432</span><span> </span><span>\</span></span>
<span data-line=""><span>  </span><span>--tmpfs</span><span> </span><span>/var/lib/pg/data</span><span> </span><span>\</span></span>
<span data-line=""><span>  </span><span>-e</span><span> </span><span>PGDATA=/var/lib/pg/data</span><span> </span><span>\</span></span>
<span data-line=""><span>  </span><span>-e</span><span> </span><span>POSTGRES_PASSWORD=postgres</span><span> </span><span>\</span></span>
<span data-line=""><span>  </span><span>--name</span><span> </span><span>contra-database</span><span> </span><span>\</span></span>
<span data-line=""><span>  </span><span>--rm</span><span> </span><span>\</span></span>
<span data-line=""><span>  </span><span>postgres:14</span></span></code></pre></div>
<p>In the above command, we are creating a Docker container with a memory disk mounted at <code>/var/lib/pg/data</code>. We are also setting the <code>PGDATA</code> environment variable to <code>/var/lib/pg/data</code> to ensure that PostgreSQL uses the memory disk for data storage. The end result is that the underlying data is stored in memory, which significantly reduces the overhead of creating a new database.</p>
<h3 id="managing-test-databases"><a aria-hidden="true" href="#managing-test-databases">Managing test databases</a></h3>
<p>The basic idea is to create a template database before running the tests and then create a new database from the template database for each test. Here is a simplified version of how you can manage test databases:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="ts" data-theme="default"><code data-language="ts" data-theme="default"><span data-line=""><span>import</span><span> {</span></span>
<span data-line=""><span>  createPool,</span></span>
<span data-line=""><span>  sql,</span></span>
<span data-line=""><span>  stringifyDsn,</span></span>
<span data-line=""><span>} </span><span>from</span><span> </span><span>&#39;slonik&#39;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>type</span><span> </span><span>TestDatabase</span><span> </span><span>=</span><span> {</span></span>
<span data-line=""><span>  </span><span>destroy</span><span>:</span><span> () </span><span>=&gt;</span><span> </span><span>Promise</span><span>&lt;</span><span>void</span><span>&gt;;</span></span>
<span data-line=""><span>  </span><span>getConnectionUri</span><span>:</span><span> () </span><span>=&gt;</span><span> </span><span>string</span><span>;</span></span>
<span data-line=""><span>  </span><span>name</span><span>:</span><span> () </span><span>=&gt;</span><span> </span><span>string</span><span>;</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> </span><span>createTestDatabasePooler</span><span> </span><span>=</span><span> </span><span>async</span><span> (</span><span>connectionUrl</span><span>:</span><span> </span><span>string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>  </span><span>const</span><span> </span><span>pool</span><span> </span><span>=</span><span> </span><span>await</span><span> </span><span>createPool</span><span>(connectionUrl, {</span></span>
<span data-line=""><span>    connectionTimeout: </span><span>5_000</span><span>,</span></span>
<span data-line=""><span>    </span><span>// This ensures that we don&#39;t attempt to create multiple databases in parallel.</span></span>
<span data-line=""><span>    maximumPoolSize: </span><span>1</span><span>,</span></span>
<span data-line=""><span>  });</span></span>
<span data-line=""> </span>
<span data-line=""><span>  </span><span>const</span><span> </span><span>createTestDatabase</span><span> </span><span>=</span><span> </span><span>async</span><span> (</span></span>
<span data-line=""><span>    </span><span>templateName</span><span>:</span><span> </span><span>string</span><span>,</span></span>
<span data-line=""><span>  )</span><span>:</span><span> </span><span>Promise</span><span>&lt;</span><span>TestDatabase</span><span>&gt; </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>    </span><span>const</span><span> </span><span>database</span><span> </span><span>=</span><span> </span><span>&#39;test_&#39;</span><span> </span><span>+</span><span> </span><span>uid</span><span>();</span></span>
<span data-line=""> </span>
<span data-line=""><span>    </span><span>await</span><span> pool.</span><span>query</span><span>(sql.</span><span>typeAlias</span><span>(</span><span>&#39;void&#39;</span><span>)</span><span>`</span></span>
<span data-line=""><span>      CREATE DATABASE ${</span><span>sql</span><span>.</span><span>identifier</span><span>([</span><span>database</span><span>])</span><span>}</span></span>
<span data-line=""><span>      TEMPLATE ${</span><span>sql</span><span>.</span><span>identifier</span><span>([</span><span>templateName</span><span>])</span><span>}</span></span>
<span data-line=""><span>    `</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>    </span><span>return</span><span> {</span></span>
<span data-line=""><span>      </span><span>destroy</span><span>: </span><span>async</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        </span><span>await</span><span> pool.</span><span>query</span><span>(sql.</span><span>typeAlias</span><span>(</span><span>&#39;void&#39;</span><span>)</span><span>`</span></span>
<span data-line=""><span>          DROP DATABASE ${</span><span>sql</span><span>.</span><span>identifier</span><span>([</span><span>database</span><span>])</span><span>}</span></span>
<span data-line=""><span>        `</span><span>);</span></span>
<span data-line=""><span>      },</span></span>
<span data-line=""><span>      </span><span>getConnectionUri</span><span>: () </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        </span><span>return</span><span> </span><span>stringifyDsn</span><span>({</span></span>
<span data-line=""><span>          </span><span>...</span><span>parseDsn</span><span>(connectionUrl),</span></span>
<span data-line=""><span>          databaseName: database,</span></span>
<span data-line=""><span>          password: </span><span>&#39;unsafe_password&#39;</span><span>,</span></span>
<span data-line=""><span>          username: </span><span>&#39;contra_api&#39;</span><span>,</span></span>
<span data-line=""><span>        });</span></span>
<span data-line=""><span>      },</span></span>
<span data-line=""><span>      </span><span>name</span><span>: () </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        </span><span>return</span><span> database;</span></span>
<span data-line=""><span>      },</span></span>
<span data-line=""><span>    };</span></span>
<span data-line=""><span>  };</span></span>
<span data-line=""> </span>
<span data-line=""><span>  </span><span>return</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>    </span><span>return</span><span> </span><span>createTestDatabase</span><span>(</span><span>&#39;contra_template&#39;</span><span>);</span></span>
<span data-line=""><span>  };</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> </span><span>getTestDatabase</span><span> </span><span>=</span><span> </span><span>await</span><span> </span><span>createTestDatabasePooler</span><span>();</span></span></code></pre></div>
<p>At this point, you can use <code>getTestDatabase</code> to create a new database for each test. The <code>destroy</code> method can be used to clean up the database after the test has run.</p>
<h2 id="conclusion"><a aria-hidden="true" href="#conclusion">Conclusion</a></h2>
<p>This setup allows us to run thousands of tests in parallel across multiple shards without any issues. The overhead of creating a new database is minimal, and the isolation is at a database level. We are happy with the performance and reliability that this setup provides.</p></div></div></div></div>
  </body>
</html>
