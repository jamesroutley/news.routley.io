<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.chrome.com/docs/web-platform/deprecating-xslt">Original</a>
    <h1>Removing XSLT for a more secure browser</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    
    




<div translate="no">
  
    
    
      <div>
        
          <p><img alt="Mason Freed" src="https://web.dev/images/authors/masonfreed.jpg" decoding="async" height="64" loading="lazy" width="64"/></p>
      </div>
    
  
    
    
      <div>
        
          <p><img alt="Dominik Röttsches" src="https://web.dev/images/authors/drott.jpg" decoding="async" height="64" loading="lazy" width="64"/></p>
      </div>
    
  
</div>

<p>
  Published: October 29, 2025
</p>


<p>Chrome intends to deprecate and remove XSLT from the browser. This document
details how you can migrate your code before the removal in late-2026.</p>

<p>Chromium has officially deprecated XSLT, including the
<a href="https://developer.mozilla.org/docs/Web/API/XSLTProcessor">XSLTProcessor</a>
JavaScript API and the <a href="https://en.wikipedia.org/wiki/Processing_Instruction#:%7E:text=The%20most%20common%20use%20of%20a%20processing%20instruction%20is%20to%20request%20the%20XML%20document%20be%20rendered%20using%20a%20stylesheet%20using%20the%20%27xml%2Dstylesheet%27%20target">XML stylesheet processing
instruction</a>.
We intend to remove support from version 155 (November 17, 2026). The
<a href="https://github.com/mozilla/standards-positions/issues/1287#issuecomment-3227145793">Firefox</a>
and
<a href="https://github.com/whatwg/html/issues/11523#issuecomment-3149280766">WebKit</a>
projects have also indicated plans to remove XSLT from their browser engines.
This document provides some history and context, explains how we are removing
XSLT to make Chrome safer, and provides a path for migrating before these
features are removed from the browser.</p>

<h2 id="what_is_being_removed" data-text="What is being removed?" tabindex="-1">What is being removed?</h2>

<p>There are two APIs in the browser that implement XSLT, and both are being
removed:</p>

<ul>
<li>The
<a href="https://developer.mozilla.org/docs/Web/API/XSLTProcessor">XSLTProcessor</a>
class (for example, <code translate="no" dir="ltr">new XSLTProcessor()</code>).</li>
<li>The <a href="https://developer.mozilla.org/docs/Web/XML/XSLT/Guides/Transforming_XML_with_XSLT">XSLT Processing
Instruction</a>
(for example, <code translate="no" dir="ltr">&lt;?xml-stylesheet … ?&gt;</code>).</li>
</ul>

<h2 id="timeline_for_chrome" data-text="Timeline For Chrome" tabindex="-1">Timeline For Chrome</h2>

<p>Chrome has the following plan:</p>

<ul>
<li>Chrome 142 (Oct 28, 2025): Early warning console messages added to Chrome.</li>
<li>Chrome 143 (Dec 2, 2025): Official deprecation of the API - deprecation
warning messages begin to show in the console and in lighthouse.</li>
<li>Chrome 148 (March 10, 2026 Canary): Canary, Dev, and Beta releases begin
disabling XSLT by default, as an early-warning.</li>
<li>Chrome 152 (Aug 25, 2026): Origin Trial (OT) and Enterprise Policy (EP) go
live for testing. These allow sites and enterprises to continue using
features past the removal date.</li>
<li>Chrome 155 (Nov 17, 2026): XSLT stops functioning on Stable releases, for
all users other than Origin Trial and Enterprise Policy participants.**</li>
<li>Chrome 164 (Aug 17, 2027): Origin Trial and Enterprise Policy stop
functioning. XSLT is disabled for all users.**</li>
</ul>

<h2 id="what_is_xslt" data-text="What is XSLT?" tabindex="-1">What is XSLT?</h2>

<p>XSLT, or Extensible Stylesheet Language Transformations, is a language used to
transform XML documents, commonly into other formats such as HTML. It uses an
XSLT stylesheet file to define the rules for this conversion, and an XML file
containing the data used as input.</p>

<p>In browsers, when an XML file is received that links to an XSLT stylesheet, the
browser uses the rules in that stylesheet to rearrange, format, and convert the
raw XML data into a structured page (often HTML) that can be rendered for the
user.</p>

<p>For example, an XSLT stylesheet could take the following XML input:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="XML"><code translate="no" dir="ltr">&lt;?xml<span> </span>version=&#34;1.0&#34;?&gt;
&lt;?xml-stylesheet<span> </span>type=&#34;text/xsl&#34;<span> </span>href=&#34;demo.xsl&#34;<span> </span>?&gt;
&lt;page&gt;
<span> </span>&lt;message&gt;
<span>  </span>Hello<span> </span>World.
<span> </span>&lt;/message&gt;
&lt;/page&gt;
</code></pre></devsite-code>
<p>and this XSL stylesheet:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="XSLT"><code translate="no" dir="ltr">&lt;xsl:stylesheet<span> </span>xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;&gt;
<span>  </span>&lt;xsl:output<span> </span>method=&#34;html&#34;/&gt;
<span>  </span>&lt;xsl:template<span> </span>match=&#34;/page/message&#34;&gt;
<span>    </span>&lt;body&gt;
<span>      </span>&lt;p&gt;Message:<span> </span>&lt;xsl:value-of<span> </span>select=&#34;.&#34;/&gt;&lt;/p&gt;
<span>    </span>&lt;/body&gt;
<span>  </span>&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre></devsite-code>
<p>and process them into this HTML for the browser to display: HTML</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="HTML"><code translate="no" dir="ltr">&lt;body&gt;
  &lt;p&gt;Message: Hello World.&lt;/p&gt;
&lt;/body&gt;
</code></pre></devsite-code>
<p>In addition to the XSL processing instruction shown in the previous example,
there&#39;s also the
<a href="https://developer.mozilla.org/docs/Web/API/XSLTProcessor/XSLTProcessor">XSLTProcessor</a>
JavaScript API which can be used to process local XML documents with local XSLT
stylesheets.</p>

<h2 id="history_of_xslt" data-text="History of XSLT" tabindex="-1">History of XSLT</h2>

<p>XSLT was recommended by the World Wide Web Consortium (W3C) on <a href="https://www.w3.org/TR/xslt-10/">November 16,
1999</a>, as a language for transforming XML
documents into other formats, most commonly HTML for display in web browsers.
Before the official 1.0 recommendation, Microsoft took an early initiative by
shipping a proprietary implementation based on a W3C working draft in <a href="https://en.wikipedia.org/wiki/Internet_Explorer_5">Internet
Explorer 5.0</a>, released in
March 1999. Following the official standard, Mozilla implemented native XSLT 1.0
support in <a href="https://www-archive.mozilla.org/status/2000-09-06">Netscape 6</a> in
late 2000. Other major browsers, including Safari, Opera, and later Chrome, also
incorporated native XSLT 1.0 processors, making client-side XML-to-HTML
transformations a viable web technology in the early 2000s.</p>

<p>The XSLT language itself continued to evolve, with the release of <a href="https://www.w3.org/TR/xslt20/">XSLT 2.0 in
2007</a> and <a href="https://www.w3.org/TR/xslt-30/">XSLT 3.0 in
2017</a>, which introduced powerful features like
regular expressions, improved data types, and the ability to process JSON.
Browser support, however, stagnated. Today, all major web browser engines only
provide native support for the original XSLT 1.0 from 1999. This lack of
advancement, coupled with the rise of the use of JSON as a wire format, and
JavaScript libraries and frameworks (like jQuery, React, and Vue.js) that offer
more flexible and powerful DOM manipulation and templating, has led to a
significant decline in the use of client-side XSLT. Its role within the web
browser has been largely superseded by these JavaScript-based technologies.</p>

<h2 id="why_does_xslt_need_to_be_removed" data-text="Why does XSLT need to be removed?" tabindex="-1">Why does XSLT need to be removed?</h2>

<p>The continued inclusion of XSLT 1.0 in web browsers presents a significant and
unnecessary security risk. The underlying libraries that process these
transformations, such as <a href="https://github.com/GNOME/libxslt">libxslt</a> (used by
Chromium browsers), are complex, aging C/C++ codebases. This type of code is
notoriously susceptible to memory safety vulnerabilities like buffer overflows,
which can lead to arbitrary code execution. For example, security audits and bug
trackers have repeatedly identified high-severity vulnerabilities in these
parsers (e.g., <a href="https://nvd.nist.gov/vuln/detail/CVE-2025-7425">CVE-2025-7425</a>
and <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-22834">CVE-2022-22834</a>, both in
libxslt). Because client-side XSLT is now a niche, rarely-used feature, these
libraries receive far less maintenance and security scrutiny than core
JavaScript engines, yet they represent a direct, potent attack surface for
processing untrusted web content. Indeed, XSLT is the source of several recent
<a href="https://www.offensivecon.org/speakers/2025/ivan-fratric.html">high-profile security
exploits</a> that
continue to put browser users at risk. The security risks of maintaining this
brittle, legacy functionality far outweighs its limited modern utility.</p>

<p>Furthermore, the original purpose of client-side XSLT—transforming data into
renderable HTML—has been superseded by safer, more ergonomic, and
better-maintained JavaScript APIs. Modern web development relies on things like
the Fetch API to retrieve data (typically JSON) and the DOMParser API to safely
parse XML or HTML strings into a DOM structure within the browser&#39;s secure
JavaScript sandbox. Frameworks like React, Vue, and Svelte then manage the
rendering of this data efficiently and securely. This modern toolchain is
actively developed, benefits from the massive security investment in JavaScript
engines, and is what virtually all web developers use today. Indeed, only about
<a href="https://chromestatus.com/metrics/feature/timeline/popularity/79">0.02%</a> of web
page loads today actually use XSLT at all, with less than
<a href="https://chromestatus.com/metrics/feature/timeline/popularity/78">0.001%</a> using
XSLT processing instructions.</p>

<p>This is not a Chrome or Chromium-only action: the other two major browser
engines also support the removal of XSLT from the web platform:
<a href="https://github.com/whatwg/html/issues/11523#issuecomment-3149280766">WebKit</a>,
<a href="https://github.com/whatwg/html/issues/11523#issuecomment-3149788558">Gecko</a>.</p>

<p>For these reasons, deprecating and removing XSLT reduce the browser&#39;s attack
surface for all users, simplify the web platform, and allow engineering
resources to be focused on securing the technologies that actually power the
modern web, with no practical loss of capability for developers.</p>

<h2 id="improving_xml_parsing_security" data-text="Improving XML parsing security" tabindex="-1">Improving XML parsing security</h2>

<p>Similar to the severe security issues in libxslt, severe
<a href="https://gitlab.gnome.org/GNOME/libxml2/-/issues/950">security</a>
<a href="https://project-zero.issues.chromium.org/issues/432450829">issues</a> were
recently reported against libxml2 which is used in Chromium for parsing,
serialization and testing the well-formedness of XML. To address future security
issues with XML parsing In Chromium we plan to phase out the usage of libxml2
and replace XML parsing with a memory-safe XML parsing library written in Rust.
Importantly, we won&#39;t be removing XML from the browser; only XSLT is being
considered for removal here. We intend to ensure that replacing libxml2 is
entirely transparent to web developers.</p>

<h2 id="how_to_migrate" data-text="How to migrate" tabindex="-1">How to migrate</h2>

<p>There are a few alternative paths for migration.</p>

<h3 id="json" data-text="JSON" tabindex="-1">JSON</h3>

<p>For sites that are fully built on XML and XSL there is no one-size-fits all way
to make the transition. Migration options include moving the XSLT processing
pipeline to the server side and sending down the rendered HTML to the client, or
migrating server-side XML API endpoints to
<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, and performing client-side rendering
using JavaScript to transform JSON into HTML DOM and CSS.</p>

<h3 id="client-side_xslt_in_javascript" data-text="Client-side XSLT in JavaScript" tabindex="-1">Client-side XSLT in JavaScript</h3>

<p>There are a few client-side (JavaScript-based) XSLT libraries available, but the
largest by far is produced by
<a href="https://www.saxonica.com/welcome/welcome.xml">Saxonica</a> (view the
<a href="https://www.saxonica.com/saxonjs/documentation3/index.html#!starting">comprehensive documentation for
Saxonica</a>).
The implementation goes well beyond the XSLT 1.0 implementation in web browsers,
implementing full support for the latest <a href="https://www.w3.org/TR/xslt-30/">v3.0
standard</a>, and eventually the <a href="https://qt4cg.org/specifications/xslt-40/Overview.html">in-progress v4.0
standard</a>.</p>

<h3 id="polyfill" data-text="Polyfill" tabindex="-1">Polyfill</h3>

<p>There is a polyfill that attempts to allow existing code, which depends on web
browsers&#39; implementations of XSLT 1.0, to continue functioning, while not using
native XSLT features from the browser. The polyfill is <a href="https://github.com/search?q=XSLT%20polyfill&amp;type=repositories">located on
GitHub</a>.</p>

<p>The polyfill contains a functional WASM-based polyfilled replacement for the
XSLTProcessor class, so existing JavaScript code can continue to work as-is:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="HTML"><code translate="no" dir="ltr">&lt;script src=&#34;xslt-polyfill.min.js&#34;&gt;&lt;/script&gt;

&lt;script&gt;
const xsltProcessor = new XSLTProcessor();
xsltProcessor.importStylesheet(xsltDoc);
const fragment = xsltProcessor.transformToFragment(xmlDoc, document);
&lt;/script&gt;
</code></pre></devsite-code>
<p>The polyfill also provides an automatic utility function for an easy way to
replace XML documents that use XSLT processing instructions:</p>

<p>For an original <code translate="no" dir="ltr">demo.xml</code> file like this:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="XML"><code translate="no" dir="ltr">&lt;?xml<span> </span>version=&#34;1.0&#34;?&gt;
&lt;?xml-stylesheet<span> </span>type=&#34;text/xsl&#34;<span> </span>href=&#34;demo.xsl&#34;?&gt;
&lt;ROOT&gt;
...content...
</code></pre></devsite-code>
<p>One line can be added to invoke the polyfill and transform the document with the
referenced XSLT stylesheet:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="XML"><code translate="no" dir="ltr">&lt;?xml<span> </span>version=&#34;1.0&#34;?&gt;
&lt;?xml-stylesheet<span> </span>type=&#34;text/xsl&#34;<span> </span>href=&#34;demo.xsl&#34;?&gt;
&lt;ROOT&gt;
&lt;script<span> </span>src=&#34;xslt-polyfill.min.js&#34;
<span>   </span>xmlns=&#34;http://www.w3.org/1999/xhtml&#34;&gt;&lt;/script&gt;
...content...
</code></pre></devsite-code>
<p>In this case, the new <code translate="no" dir="ltr">&lt;script&gt;</code> element loads the polyfill, which detects the
XML document type and the XSLT processing instruction and transparently loads
it, replacing the document.</p>

<h2 id="extension" data-text="Extension" tabindex="-1">Extension</h2>

<p>There&#39;s also a <a href="https://chromewebstore.google.com/search/xslt%20polyfill">Chrome
extension</a> that can be
added to supported browsers, which will apply the same XSLT polyfill to all raw
XML pages that contain XSLT processing instructions or calls to XSLTProcessor.
This can be used for applications where the source XML or XSLT cannot be
changed, to maintain functionality.</p>

<p>In particular, when XSLT is disabled, Chrome now shows a warning banner that
links directly to an extension search page, to help users locate an extension:</p>

<p><img src="https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message.png" alt="The message shown in Chrome when xslt is detected." srcset="https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_36.png 36w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_48.png 48w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_72.png 72w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_96.png 96w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_480.png 480w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_720.png 720w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_856.png 856w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_960.png 960w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_1440.png 1440w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_1920.png 1920w,https://developer.chrome.com/static/docs/web-platform/deprecating-xslt/image/deprecation-message_2880.png 2880w" sizes="(max-width: 840px) 100vw, 856px"/></p>

<h2 id="specific_use_cases" data-text="Specific use cases" tabindex="-1">Specific use cases</h2>

<p>In the <a href="https://github.com/whatwg/html/issues/11523">discussion in HTML
standards</a>, several concrete use
cases were identified. This section talks specifically about each of them, to
recommend paths forward for developers publishing XML resources that use XSLT
today.</p>

<h3 id="rss_and_atom_feeds" data-text="RSS and Atom Feeds" tabindex="-1">RSS and Atom Feeds</h3>

<p>In many existing RSS or Atom feeds, XSLT is used to make raw XML feeds
human-readable when viewed directly in a browser. The primary use case is that
when a user accidentally clicks on a site&#39;s RSS feed link, rather than pasting
that link into their RSS reader, they get a formatted HTML response that they
can read, rather than the raw XML itself.</p>

<p>There are two paths forward for this use case. The &#34;standard&#34; HTML way to do
this is to add <code translate="no" dir="ltr">&lt;link rel=&#34;alternate&#34; type=&#34;application/rss+xml&#34;&gt;</code> to an
(HTML-based) site, rather than adding an explicit (user-visible) <code translate="no" dir="ltr">&lt;a
href=&#34;something.xml&#34;&gt;</code> that users might accidentally click. This solution allows
RSS readers to find the feed if a user pastes in just the website URL, but it
also allows human users to see the regular HTML content without getting confused
by a link to an XML resource. This also follows the normal web paradigm that
HTML is for humans and XML is for machines. Of course this doesn&#39;t solve the
case where a user just &#34;has&#34; an RSS link from somewhere, and they paste it into
their web browser (rather than their RSS reader).</p>

<p>When that solution isn&#39;t wanted, the polyfill offers another path. As mentioned
previously, the RSS/Atom XML feed can be augmented with one line, <code translate="no" dir="ltr">&lt;script
src=&#34;xslt-polyfill.min.js&#34; xmlns=&#34;http://www.w3.org/1999/xhtml&#34;&gt;&lt;/script&gt;</code>,
which will maintain the existing behavior of XSLT-based transformation to HTML.
That shouldn&#39;t affect RSS reader&#39;s ability to continue parsing the XML, since
the <code translate="no" dir="ltr">&lt;script&gt;</code> is a direct child of the root element.</p>

<h3 id="api_output_for_embedded_devices" data-text="API output for embedded devices" tabindex="-1">API output for embedded devices</h3>

<p>Some commercial embedded devices measure or otherwise generate XML data for
consumption by users on the local network. Some of these devices do this by
generating a single XML data feed that uses XSLT to transform it into a
human-readable HTML format. That allows the API to be directly viewed in a
browser without needing additional code on the device or in the browser.</p>

<h3 id="lazy_templating_for_web_sites" data-text="Lazy templating for web sites" tabindex="-1">Lazy templating for web sites</h3>

<p>Web developers sometimes use XSLT on the client side to apply presentation
markup to semantic markup, functioning as a lazy templating language that is
separate from the JavaScript ecosystem.</p>

<p>There are two solutions to this more general problem. For an existing site built
in this way, the easiest solution is likely just to add the polyfill to maintain
existing functionality. Or perhaps perform the XSLT transformation on the server
side, and serve the resulting HTML to the client, rather than the raw XML. The
more long-term solution for such properties would be to migrate to a more modern
JavaScript or JSON-based framework.</p>

<p>If you encounter a specific problem in Chrome related to this XSLT deprecation,
<a href="https://issues.chromium.org/issues/new?component=1456730&amp;template=2210866">report a bug here</a>.</p>

  

  
</div></div>
  </body>
</html>
