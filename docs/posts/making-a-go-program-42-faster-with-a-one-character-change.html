<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hmarr.com/blog/go-allocation-hunting/">Original</a>
    <h1>Making a Go program 42% faster with a one character change</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    <header>
      
      <time datetime="2022-11-13">2022-11-13</time>
    </header>
    <p>If you read the title and thought “well, you were probably just doing something silly beforehand”, you’re right! But what is programming if not an exercise in making silly mistakes? Tracking down silly mistakes is where all the fun is to be had!</p>
<p>I’ll also state the usual benchmarking caveat up front: the 42% speedup was measured while running the program on my data on my computer, so take that number with a big old pinch of salt.</p>
<h2>What does the program do?</h2>
<p><a href="https://github.com/hmarr/codeowners">codeowners</a> is a Go program that prints out the owners for each file in a repository according to a set of rules defined in a <a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax">GitHub <code>CODEOWNERS</code> file</a>. A rule might say that all files ending in <code>.go</code> are owned by the <code>@gophers</code> team, or all files in the <code>docs/</code> directory are owned by the <code>@docs</code> team.</p>
<p>When considering a given path, the last rule that matches wins. A simple but naive matching algorithm iterates backwards through the rules for each path, stopping when it finds a match. Smarter algorithms do exist, but that’s for another day. Here’s what the <code>Ruleset.Match</code> function looks like:</p>
<pre><code><span>type</span> Ruleset <span>[</span><span>]</span>Rule</code></pre>
<h2>Finding the slow bits with pprof and flamegraphs</h2>
<p>The tool was a tad slow when running it against a moderately large repository:</p>
<pre><code><span><span>$</span> <span>hyperfine codeowners</span></span></code></pre>
<p>To see where the program was spending its time, I recorded a CPU profile with pprof. You can get a CPU profile generated by adding this snippet to the top of your <code>main</code> function:</p>
<pre><code>pprofFile<span>,</span> pprofErr <span>:=</span> os<span>.</span><span>Create</span><span>(</span><span>&#34;cpu.pprof&#34;</span><span>)</span></code></pre>
<p><em>Aside: I use pprof quite a lot, so I’ve got that code saved as a <a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">vscode snippet</a>. I just type <code>pprof</code>, hit tab, and that snippet appears.</em></p>
<p>Go comes with a handy interactive profile visualisation tool. I visualised the profile as a flamegraph by running the following command then navigating to the flamegraph view in the menu at the top of the page.</p>
<pre><code><span><span>$</span> <span>go tool pprof -http<span>=</span><span>&#34;:8000&#34;</span> ./codeowners ./cpu.pprof</span></span></code></pre>
<p>As I expected, most of the time was being spent in that <code>Match</code> function. The CODEOWNERS patterns are compiled to regular expressions, and the majority of the <code>Match</code> function’s time was spent in Go’s regex engine. But I also noticed a lot of time was being spent allocating and reclaiming memory. The purple blocks in the flamegraph below match the pattern <code>gc|malloc</code>, and you can see in aggregate they represent a meaningful part of the program’s execution time.</p>
<img src="https://hmarr.com/images/codeowners-flamegraph.png" width="936" height="536" alt="Flamegraph showing time spent in the regex engine and malloc"/>
<h2>Hunting heap allocations with escape analysis traces</h2>
<p>So let’s see if there are any allocations we can get rid of to reduce the GC pressure and time spent in <code>malloc</code>.</p>
<p>The Go compiler uses a technique called escape analysis to figure out when some memory needs to live on the heap. Say a function initialises a struct then returns a pointer to it. If the struct was allocated on the stack, the pointer that’s returned would become invalid as soon as the function returns and the corresponding stack frame is invalidated. In that case the Go compiler would determine that the pointer has “escaped” the function, and move the struct to the heap instead.</p>
<p>You can see these decisions being made by passing <code>-gcflags=-m</code> to <code>go build</code>:</p>
<pre><code><span><span><span>$</span> <span>go build -gcflags<span>=</span>-m *.go <span><span>2</span>&gt;</span><span>&amp;1</span> <span>|</span> <span>grep</span> codeowners.go</span></span></span></code></pre>
<p>The output is a little noisy, but you can ignore most of it. As we’re looking for allocations, “<code>moved to heap</code>” is the phrase we should be concerned about. Looking back at the <code>Match</code> code above, the <code>Rule</code> structs are stored within the <code>Ruleset</code> slice, which we can be confident is already on the heap. And as a pointer to the rule is returned, no extra allocation should be necessary.</p>
<p>Then I saw it—by assigning <code>rule := r[i]</code>, we <em>copy</em> the heap allocated <code>Rule</code> out of the slice onto the stack, then by returning <code>&amp;rule</code> we create an (escaping) pointer to the copy of the struct. Fortunately, fixing this is easy. We just need to move the ampersand up a bit so we take a reference to the struct in the slice rather than copying it:</p>
<pre><code><span><span> </span><span>func (r Ruleset) Match(path string) (*Rule, error) {<br/></span><span> </span><span>	for i := len(r) - 1; i &gt;= 0; i-- {<br/></span></span><span><span>-</span><span>		rule := r[i]<br/></span></span><span><span>+</span><span>		rule := &amp;r[i]<br/></span></span><span><span> </span><span>		match, err := rule.Match(path)<br/></span><span> </span><span>		if match || err != nil {<br/></span></span><span><span>-</span><span>			return &amp;rule, err<br/></span></span><span><span>+</span><span>			return rule, err<br/></span></span><span><span> </span><span>		}<br/></span><span> </span><span>	}<br/></span><span> </span><span>	return nil, nil<br/></span><span> </span><span>}</span></span></code></pre>
<p>I did consider two other approaches:</p>
<ol>
<li>Changing <code>Ruleset</code> from being <code>[]Rule</code> to <code>[]*Rule</code>, which would mean we no longer need to explicitly take a reference to the rule.</li>
<li>Returning a <code>Rule</code> rather than a <code>*Rule</code>. This would still copy the <code>Rule</code>, but it should stay on the stack instead of moving to the heap.</li>
</ol>
<p>However, both of these would have resulted in a breaking change as this method is part of the public API.</p>
<p>Anyway, after making that change we can see if it had the desired effect by getting a new trace from the compiler and comparing it to the old one:</p>
<pre><code>$ diff trace-a trace-b</code></pre>
<p>Success! The allocation is gone. Now let’s see how removing that one heap allocation affects performance:</p>
<pre><code><span><span>$</span> <span>hyperfine ./codeowners-a ./codeowners-b</span></span></code></pre>
<p>As that allocation was happening for <em>every single path</em> that was being matched against, removing it got a 1.7x speed increase (meaning it ran 42% faster) in this instance. Not bad for a one character change.</p>
<p><em>Update: the title originally stated the optimisation made the program run 70% faster, rather than 42% (with a 1.7x change in speed). Thanks @enedil for pointing that out!</em></p>

  </article>
</div></div>
  </body>
</html>
