<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mayerowitz.io/blog/a-journey-into-shaders">Original</a>
    <h1>Interactive intro to shaders</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote><p><em>This article is interactive: you can play with the code and sliders to interact with the shaders. Enjoy!</em></p></blockquote>
<p>What if I told you that it could takes just few lines of code to create graphics as simple as gradients or as complex as rain effects? Welcome to the world of shaders!</p>
<p>I’ve been fascinated by shaders for a couple of years. but each time I attempted to dive into the subject, I felt like I was learning to read and write all over again — it was overwhelming.
When I transitioned this website to <a href="https://kit.svelte.dev/" rel="nofollow">Svelte</a>, I saw an opportunity to replace a simple CSS animation on my homepage with a shader-based animation. The original CSS animation manipulated the <code>border-radius</code> property to produce a calm and minimalist animation, illustrated below.</p>

<p>You might wonder why I would bother re-doing something that already exists. Well, it’s because the simplicity of the task seemed like the perfect stepping stone—challenging, yet manageable. Plus, having recently defended my PhD, I finally had the time to delve into this passion project!</p>
<p>I hear about shaders all the time, when scrolling generative artists on <strike>twitter</strike> X, when I want to change the look of Minecraft, or even when I want to train an AI (<a href="https://blogs.nvidia.com/blog/2012/09/10/what-is-cuda-2/" rel="nofollow">CUDA</a> is basically an API for shaders). So now it’s the time to demystify this damn thing and start writing one of my own! In this article, you’ll join me on my journey as we explore the world of <em>fragment</em> shaders, making it as approachable as possible for a beginner with basic understanding in programing.</p>
<blockquote><p>For anyone looking for an in-depth introduction to shaders, I highly recommend  <a href="https://thebookofshaders.com/" rel="nofollow">The Book of Shaders</a></p></blockquote>
<h2>Shaders: the good, the bad and the ugly</h2>
<p>If you’re into video games, you’ve likely heard of shaders. They’re the magic behind enhancing <a href="https://lettier.github.io/3d-game-shaders-for-beginners/normal-mapping.html" rel="nofollow">lighting</a>, conjuring up <a href="https://webglfundamentals.org/webgl/lessons/webgl-fog.html" rel="nofollow">special effects</a>, and even generating <a href="https://en.wikipedia.org/wiki/Cel_shading" rel="nofollow">cartoonish looks</a> (yes, that’s why there’s a ‘shade’ in ‘cell shading’). In a way, shaders is what makes modern games look so good when compared to their ’90s counterparts. But what exactly is a shader?</p>
<p>Let’s start simple: A shader is a small program running on your GPU that takes, at the very least, pixel coordinates as input and spits out a color as output. The reason why they are so popular in video games and computer graphics is that they are <em>extremly</em> fast. Their secret sauce? <em>Parallelization</em>. These programs are designed to work on multiple pixels at the same time, making them ridiculously efficient.</p>
<div><div><p><img src="https://erikarow.land/_app/immutable/assets/cpu_nvidia_anim.195dc856.gif" alt="A robot drawing through iterative splash of paint."/></p><p><span></span>
            <span>The CPU, smart but slow</span></p></div></div>
<div><div><p><img src="https://erikarow.land/_app/immutable/assets/gpu_nvidia_anim.ad080591.gif" alt="Hundreds of pipes spitting paint in a fraction of a second to draw the Joconde"/></p><p><span></span>
            <span>The GPU, dumb and fast</span></p></div></div>
<blockquote><p>Side Note: Shaders come in different dialects. For this article, I’ll focus on the OpenGL Shading Language (GLSL), mainly because it’s browser-friendly!</p></blockquote>
<p>This incredible power comes, however, at some costs: Shaders have to be <em>compact</em> and <em>low-level</em>. This means you can’t lean on high-level abstractions or import libraries to do the heavy lifting (* <a href="https://medium.com/frontendweb/find-how-many-packages-we-need-to-run-a-react-hello-world-app-695fbb755af7" rel="nofollow">laugh in javascript</a> *). Moreover, their parallel nature makes them <em>memoryless</em> and <em>stateless</em>. This translates to: “You can’t store or share data between pixels or shader executions.” These constraints make shaders a tough nut to crack, especially if you’ve been pampered by high-level languages (guilty as charged).</p>
<h2>Coordinates is All You Need</h2>
<p>Shaders transform pixel coordinates into colors, encoded in RGBA—each channel ranging from 0 to 1. (It is also possible to manipulate <a href="https://shader-tutorial.dev/basics/vertex-shader/" rel="nofollow">vertex positions</a>, but this topic is left as an exercise to the reader).
Typically, coordinates are normalized between 0 and 1. In this coordinate space, (0, 0) is the lower left corner, and (1, 1) is the upper right. These coordinates are commonly referred to as <a href="https://stackoverflow.com/questions/10568390/difference-between-uv-and-st-texture-coordinates" rel="nofollow">st or uv</a> by convention.
Now, let’s imagine you want to write the simplest shader: a gradient where the red component increases from left to right and the green component ascends from bottom to top. That is, find the function f(x,y) in the following illustration:</p>
<svg width="300" height="300"><rect width="80%" height="80%" stroke="black" x="10%" y="10%" stroke-width="0.5%" fill="none"></rect><line x1="60" y1="10%" x2="60" y2="90%" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="60" x2="90%" y2="60" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="90" y1="10%" x2="90" y2="90%" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="90" x2="90%" y2="90" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="120" y1="10%" x2="120" y2="90%" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="120" x2="90%" y2="120" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="150" y1="10%" x2="150" y2="90%" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="150" x2="90%" y2="150" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="180" y1="10%" x2="180" y2="90%" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="180" x2="90%" y2="180" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="210" y1="10%" x2="210" y2="90%" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="210" x2="90%" y2="210" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="240" y1="10%" x2="240" y2="90%" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="240" x2="90%" y2="240" stroke="gray" stroke-dasharray="2,4" stroke-width="0.5%"></line><text x="0%" y="98%">(0,0)</text><text x="85%" y="98%">(1,0)</text><text x="0%" y="8%">(0,1)</text><text x="85%" y="8%">(1,1)</text><rect x="160" y="145" width="35%" height="15" fill="white"></rect><rect x="150" y="150" width="3%" height="3%" r="2%" fill="rgb(127.5, 127.5,0)"></rect><text x="160" y="158">=f(0.50,0.50)</text></svg>
<p>Sure, it might appear too basic, but think of it as a prime playground to get cozy with shader syntax. Go ahead, check out the implementation below and tinker with it -— how about changing the gradient from black to blue?</p>
<div><div><details open=""><summary>Code show/hide</summary>
        <div><div>

        <pre>varying vec2 vUv;

void main() {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 st = vUv;

  // redish in x, greenish in y
  // Try to modify the following line to have a blue gradient
  // from left to right.
  gl_FragColor = vec4(st.x, st.y, 0.0, 1.0); // RGBA
}</pre></div></div></details>   
    </div>
</div>
<details><summary>Hint</summary>
        To get a blue gradient, replace line 10 with 
    <code>gl_FragColor = vec4(0.0, 0.0, st.x, 1.0);</code></details>
<p>There are a few interesting things to note here about the syntax:</p>
<ul><li><strong>Inputs</strong>: We can declare input to the shaders that can be <em>varying</em> or <em>uniform</em>. Varying variables are different for each pixel, while uniform variables are the same for all pixels. Here, we declare a varying variable <code>vUv</code>, which is a 2D vector representing the position of the pixel on a plane. It is declared as <code>varying</code> because the value is different for each pixel on the screen.</li>
<li><strong>Coordinates Origin</strong>: Take note, the origin of UV space is at the lower-left corner. If you’re used to SVG or HTML canvas, this might feel like driving on the other side of the road.</li>
<li><strong>Built-in types</strong>: Just like C, shaders demand type declaration. You’ll come across a range of types suited for vectors and matrices—think <code>vec2</code>, <code>vec3</code>, <code>vec4</code>, <code>mat2</code>, <code>mat3</code>, and the list goes on.</li>
<li><strong>Swizzling</strong>: Accessing elements of a vector? Easy, just use the dot notation (vec2(1, 2).x gives you 1). Want to slice and dice your vector? Use the xy notation (vec4(1, 2, 3, 4).xy returns vec2(1, 2)). If you’re working with colors, feel free to use the <code>myvector.rgba</code> syntax — This is entirely up to you.</li>
<li><strong>Output</strong>: There’s no return statement. The color for each pixel is determined by the value of <code>gl_FragColo</code> at the end of the <code>main()</code> function.</li></ul>
<p>So even with our super simple example, you can already feel the power of shaders. Without it, an equivalent result would have required a loop over all the pixels of the canvas — 90000 in this case — just to create this gradient. But this is just the beginning; shaders could do so much more than that.</p>
<h2>One Step() Beyond</h2>
<p>Now, to reproduce my original animation, I need to draw shapes with salient edges. While this may seem trivial, it is not. Forget about a handy drawCircle() function. Instead, we turn to our ever-reliable friends: math and trigonometry.</p>
<p>To create something like a disk, consider each pixel’s distance to the disk’s center. This distance calculation could be done using the Pythagorean theorem, however, we also have a built-in function for that: <code>distance(vec2 p1, vec2 p2)</code>. If you map this distance to the color of the pixel, you will get a circular gradient.</p>
<p>But wait, you may anticipate, “a gradient is not a solid disk!” And you’d be right. The secret sauce for that is another built-in function: <code>step(float threshold, float value)</code>. The step() function takes in the distance and sharply transitions it into either 0 or 1, depending on whether the distance crosses a certain threshold.</p>
<div><div><details open=""><summary>Code show/hide</summary>
        <div><div>

        <pre>uniform float u_slider;
varying vec2 vUv;

void main() {
    vec2 st = vUv;

    // Distance of the current pixel to the center of the canvas
    float d = distance(st, vec2(0.5));

    // Using step to get a sharp circle
    // s = 1 if d &gt; 0.25, 0 otherwise
    float s = step(0.25, d);

    // Mix the two colors based on the slider
    // color = u_slider * s + (1-u_slider) * d
    float brightness = mix(d, s, u_slider);

    gl_FragColor = vec4(vec3(brightness), 1.0);
}</pre></div></div></details>   
    </div>
<h5>Slide to the right to apply the step() function</h5>

<p><span>&lt;distance()</span>
        <span>step()&gt;</span></p></div>
<blockquote><p>Noticed those jagged edges, also known as aliasing, around the disk when applying <code>step()</code>? That’s because the transition from 0 to 1 is a bit too abrupt. The solution is another built-in function called <code>smoothstep(float t_start, float t_end, float x)</code>, which—as you might guess—smooths things out.</p></blockquote>
<p>You may find it initially challenging, but this method of shaping with distance is your Swiss Army knife for crafting the mind-blowing shaders you often stumble upon online. So let’s dive a bit deeper into it!</p>
<h2>Signed Distance Functions (SDF)</h2>
<p>When you think of shapes, it’s natural to imagine them as a series of connected points. But here’s a twist: you can also represent shapes in terms of their distance to other points in space. This is where <em>Signed Distance Functions</em> (SDFs) come into play. Why “signed,” you ask? The distance is signed because it can be negative if the point is inside the shape.</p>
<p>To start off, let’s revisit the circle we created earlier and adapt it using SDFs. The key is to determine a function that calculates the distance from any given point in space to our circle. Starting simply, let’s find the distance to the origin. In the image below, it becomes evident that the distance <code>d </code> from the origin to the circle is essentially the distance from the origin to the center of the circle <code>C</code> minus the radius <code>r</code>.</p>
<svg width="300" height="300"><defs><marker id="arrowhead" orient="auto" markerWidth="5" markerHeight="4" refX="4" refY="2"><path d="M 0 0 V 4 L 5 2 Z"></path></marker></defs><line x1="10%" y1="260" x2="133" y2="157" stroke="orange" stroke-width="1%" stroke-dasharray="3,1"></line><text x="69" y="194.4">d</text><rect width="80%" height="80%" stroke="black" x="10%" y="10%" stroke-width="0.5%" fill="none"></rect><line x1="60" y1="10%" x2="60" y2="90%" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="60" x2="90%" y2="60" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="90" y1="10%" x2="90" y2="90%" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="90" x2="90%" y2="90" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="120" y1="10%" x2="120" y2="90%" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="120" x2="90%" y2="120" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="150" y1="10%" x2="150" y2="90%" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="150" x2="90%" y2="150" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="180" y1="10%" x2="180" y2="90%" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="180" x2="90%" y2="180" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="210" y1="10%" x2="210" y2="90%" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="210" x2="90%" y2="210" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line><line x1="240" y1="10%" x2="240" y2="90%" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line>
        <line x1="10%" y1="240" x2="90%" y2="240" stroke="lightgray" stroke-dasharray="2,4" stroke-width="0.5%"></line><text x="0%" y="98%">(0,0)</text><text x="85%" y="98%">(1,0)</text><text x="0%" y="8%">(0,1)</text><text x="85%" y="8%">(1,1)</text><line x1="180" y1="120" x2="240" y2="120" stroke="black" stroke-width="0.5%" stroke-dasharray="3,1"></line><text x="200" y="115">r</text><circle cx="180" cy="120" r="60" stroke="teal" stroke-width="1%" fill="none"></circle><circle cx="180" cy="120" r="1%" fill="orange"></circle><text x="175" y="115">C</text><line x1="10%" y1="90%" x2="180" y2="120" stroke="black" stroke-width="0.5%" marker-end="url(#arrowhead)"></line><text x="100" y="216">v</text></svg>
<p>This observation translates beautifully into a function:</p>
<pre><!-- HTML_TAG_START --><code>float circleSDF(vec2 p, float r) {
    return length(p) - r;
}</code><!-- HTML_TAG_END --></pre>
<blockquote><p>You can interpret this function in two ways. It either measures the distance from a point p to a circle centered at the origin, or the distance from the origin to the circle itself. It’s all a matter of perspective!</p></blockquote>
<p>However, we’re rarely interested in just the distance to the origin. We want the distance to <em>any</em> point in the UV space. To achieve this, we merely translate the point <code>p</code> by the pixel’s position <code>uv</code>. The SDF function then returns negative distances for pixels inside the circle and positive distances for those outside. These two realms are separated by the circle, where the distance is exactly zero.</p>
<p>What about shading this SDF to make it visually compelling? Simple. Apply the 1. - step() function to the distance. The pixels with negative distances (inside the circle) take the value 1, and those outside take the value 0. </p>
<div><div><details open=""><summary>Code show/hide</summary>
        <div><div>

        <pre>varying vec2 vUv;
uniform float u_slider;

float circleSDF(vec2 p, float r)
{
  return length(p) - r;
}

void main() {
    vec2 uv = vUv;

    // Signed distance to a circle centered at (0.5, 0.5)
    float d = circleSDF(vec2(0.5) - uv, u_slider);

    // Default color to orange
    vec3 color = vec3(1.0, 0.6, 0.2);
    // Teal if inside the circle
    if (d &lt; 0.0) {
        color = vec3(0., 0.6, 0.6);
    }

    // Increase luminosity with distance to center
    gl_FragColor = vec4(color, 1.0); //RGBA
}</pre></div></div></details>   
    </div>
<h5>Slide to the right to change the radius of the circle</h5>

<p><span>0</span>
        <span>0.5</span></p></div>
<p>This article won’t delve into the other shapes you can define with SDFs—though I strongly recommend this <a href="https://iquilezles.org/articles/distfunctions2d/" rel="nofollow">comprehensive list</a> by Inigo Quilez for those curious minds. Instead, we’ll focus on how to merge these individual shapes to craft our end-goal: a beautiful blob.</p>

<h2>One and One Makes Another One</h2>
<p>SDFs has some interesting properties, one of them is that it is especially easy to create new shapes with <a href="https://en.wikipedia.org/wiki/Boolean_algebra#Diagrammatic_representations" rel="nofollow">boolean operations</a>. To have the union of the two SDFs, you need to take the minimum of the two distances. For pixels that are in either of the two shapes (or in both), the min() will output a negative distance, and for pixels that are outside both shapes, the min() will output a positive distance. </p>
<p>We end up with a new SDF that is negative inside the union of the two shapes, and positive outside. In the exemple below, I start by showing the two SDFs, one in red and one in green. With the slider, you can see the result of the union of the two shapes using the min() function.</p>
<div><div><details open=""><summary>Code show/hide</summary>
        <div><div>

        <pre>varying vec2 vUv;
uniform float u_slider;

float circleSDF(vec2 p, float r)
{
  return length(p) - r;
}

void main() {
    vec2 uv = vUv;

    // The SDF for each disk
    float d1 = circleSDF(vec2(0.6) - uv, 0.2);
    float d2 = circleSDF(vec2(0.4) - uv, 0.2);

    // Output each disk to a different color channel
    vec3 color = vec3(0.0);
    color.r = 1. - smoothstep(0., 0.01, d1); // red
    color.g = 1. - smoothstep(0., 0.01, d2); // green

    // Union of disks
    // Merging is as simple as taking the min()
    float d = min(d1, d2);
    // Set `dc` to yellow if within the union of the two circles
    vec3 dc = (1. - smoothstep(0.,0.01, d)) * vec3(1.0, 1.0, 0.);

    // FINAL COLOR
    // Mix color and dc according to slider value
    // mix(x, y, a) = x * (1.0 - a) + y * a
    color = mix(color, dc, u_slider);

    gl_FragColor = vec4(color, 1.0);
}</pre></div></div></details>   
    </div>
<h5>Slide to apply min() of the two SDFs</h5>

<p><span>&lt;Disjointed</span>
        <span>Joined&gt;</span></p></div>
<blockquote><p>Have you noticed that I used <code>1.-smoothstep()</code>? This is because <code>step()</code> (and <code>smoothstep()</code>) outputs 1 when the distance is <strong>above</strong> the threshold (<em>i.e</em> outside the disk). To get a positive value <strong>inside</strong> the shape, we need to invert the output.</p></blockquote>
<p>Complex shapes — like a blob! — are thus the combination of many simple SDFs. Like legos, you have many simple SDFs (building blocks) that can be combined to any shape you want. That said, a blob is smooth and jelly-like, unlike the sharp angle at the junction of our two disks. Luckily, SDFs have one last magic property for us.</p>
<h2>Smooth operator</h2>
<p>To create an appealing effect, we would like the shapes to blend smoothly together like in a lava lamp. However, the <code>min()</code> function is not smooth, it has sharp discontinuites when it transitions between two distances. Instead, we would prefer a function that smoothly shift from one distance to another. Luckily, this problem has already been solved and is unoriginally called <a href="https://iquilezles.org/articles/smin/" rel="nofollow">smooth minimum</a>. The function takes an additional argument to control the smoothing strengh (often denoted <code>k</code>).</p>
<div><div><details open=""><summary>Code show/hide</summary>
        <div><div>

        <pre>varying vec2 vUv;
uniform float u_slider;

float circleSDF(vec2 p, float r)
{
  return length(p) - r;
}

// Polynomial smooth min
float smin(float a, float b, float k)
{
    float h = max( k-abs(a-b), 0.0 )/k;
    return min( a, b ) - h*h*k*(1.0/4.0);
}

void main() {
    vec2 uv = vUv;

    // The SDF for each disk
    float d1 = circleSDF(vec2(0.65) - uv, 0.2);
    float d2 = circleSDF(vec2(0.35) - uv, 0.2);

    // Union of disks
    float d = 1. - smoothstep(0., 0.01, smin(d1, d2, u_slider/3.+0.001));

    gl_FragColor = vec4(vec3(d), 1.0);
}</pre></div></div></details>   
    </div>
<h5>Slide to increase the smoothing factor</h5>

<p><span>&lt;k=0</span>
        <span>k=1&gt;</span></p></div>
<h2>I Like to Move it</h2>
<p>We can pass any arbitrary variable to our shader, much like the slider you’ve played with in this article. To get closer to our goal, we need to animate the circles. Doing so is as simple as feeding the shader with a time uniform that can then be used to defin the circles’ positions. Here I generate my time uniform <code>u_time</code> through javascript and then use it as an input in my shader to control my SDFs. The shader will refresh 60 times per second by default, each time with a new <code>u_time</code> value, creating a smooth animation. With a few extra balls and a bit of parameter tweeking, we end up with a cute blobby shape.</p>
<blockquote><p>To make the blob oscillating, we can use periodic functions (e.g. sin,cos) to control each balls.</p></blockquote>
<p>A metaball is a combination of multiple SDFs, to clean up our code, we can use a loop to combine them together, instead of manually updating the final distance variable like in our previous exemple. To further speed-up the process, we first define the centers of each balls, and then store it in an array that can be easily accessed in the loop to iteratively update the distance value. Pay attention to lines 40-43 in the code below.</p>
<div><div><details open=""><summary>Code show/hide</summary>
        <div><div>

        <pre>uniform float u_time;
varying vec2 vUv;
uniform float u_slider;

// C-style macro to define constants
#define K 0.4

float circleSDF(vec2 uv, vec2 p, float r)
{
  return length(p-uv) - r;
}

float smin(float a, float b, float k)
{
  float h = max( k-abs(a-b), 0.0 )/k;
  return min( a, b ) - h*h*k*(1.0/4.0);
}

// Map a value from -1 to 1 to out_min to out_max
float trigmap(float x, float out_min, float out_max)
{
  return out_min + (x + 1.) * (out_max - out_min) / (2.);
}

void main() {
  vec2 uv = vUv;

  // Define the center of each metaball
  vec2 c1 = vec2(0.4,trigmap(cos(u_time), 0.3, 0.4));
  vec2 c2 = vec2(trigmap(sin(u_time), 0.4, 0.7), 0.5);
  vec2 c3 = vec2(0.5, trigmap(cos(u_time), 0.6, 0.7));
  vec2 c4 = vec2(trigmap(cos(u_time), 0.4, 0.63), 0.3);
  // Store the centers in an array
  vec2 centers[4] = vec2[4](c1,c2,c3,c4);

  // Initialize the distance and define the smoothing factor
  float d = 99.;

  // Iterate over the centers and compute the sdf
  for (int i = 0; i &lt; 4; i++) {
    vec2 c = centers[i];
    float sdf = circleSDF(uv, c, .1*u_slider);
    d = smin(d, sdf, K);
  }
  // Define the metaball
  float metaball = 1. - smoothstep(0., 0.005, d);
  
  gl_FragColor = vec4(vec3(metaball), 1.0);
}</pre></div></div></details>   
    </div>
<h5>Adjust the size of the metaballs</h5>

</div>
<p>And voila, our baby’s born. You should now be ready to write some shaders of your own. If writing code is not your thing, you now have a better understanding of what’s going under the hood of node-based editor in <a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/index.html" rel="nofollow">Blender’s shader nodes</a> or <a href="https://unity.com/features/shader-graph" rel="nofollow">Unity’s Shader Graph</a>.</p>
<p>This sad monochrome blob is functional but boring. Let’s make it juicer!</p>
<h2>The Final Touch</h2>
<p>To truly appreciate the magic of shaders, there’s nothing like taking the wheel and manipulating the blob in real-time. This final section will guide you on how to introduce user interactivity into your shader. Essentially, you will learn how to let users control the position of a ball within the blob by using their mouse.</p>
<p>First things first: We’ll use the mouse coordinates as a uniform input into the shader. This will allow real-time interaction with our creation.</p>

<p>Once the mouse coordinates are received, adding them to the array of ball centers will allow the user to interactively control a ball. As you see, it only takes one line of code to create interactivity!</p>
<div><div>

        <pre>vec2 centers[5] = vec2[5](c1,c2,c3,c4,u_mouse);</pre></div></div>
<p>Next, it’s just fun and iterations. To get to the final result, I extensively use the <code>mix(colorA, colorB, percent)</code> function. It’s equivalent to if/else blocks when <code>percent</code> is a boolean. For example, to get red outside the metaball (where <code>metaball == 0</code>) and green within it, you can write. </p>
<div><div>

        <pre>vec3 color = mix(
        vec3(1., 0., 0.), // Red 
        vec3(0., 1., 0.), // Green
        metaball)</pre></div></div>
<p>Finally, we get this beauty</p>
<div><div><details><summary>Code show/hide</summary>
        <div><div>

        <pre>uniform float u_time;
uniform float u_slider;
uniform vec2 u_mouse;
varying vec2 vUv;

// C-style macro to define constants
#define K 0.4
#define REPEL 0.001
#define DISTLIM 0.1

float circleSDF(vec2 uv, vec2 p, float r)
{
  return length(p-uv) - r;
}

float smin(float a, float b, float k)
{
  float h = max( k-abs(a-b), 0.0 )/k;
  return min( a, b ) - h*h*k*(1.0/4.0);
}

// Map a value from -1 to 1 to out_min to out_max
float trigmap(float x, float out_min, float out_max)
{
  return out_min + (x + 1.) * (out_max - out_min) / (2.);
}

void main() {
  vec2 uv = vUv;

  // Handle Mouse
  vec2 m = u_mouse.xy; // normalize mouse coordinates
  m.y = 1.0 - m.y; // invert y axis to match the canvas
  m.x = (m.x);

  // Define the center of each metaball
  vec2 c1 = vec2(0.35,trigmap(cos(u_time), 0.3, 0.7));
  vec2 c2 = vec2(trigmap(cos(u_time), 0.3, 0.7), 0.7);
  vec2 c3 = vec2(0.7, trigmap(sin(u_time), 0.3, 0.7));
  vec2 c4 = vec2(trigmap(cos(u_time), 0.3, 0.7), 0.3);
  
  // Store the centers in an array
  vec2 centers[5] = vec2[5](c1,c2,c3,c4,m);

  // Color is function of the centroid
  vec2 ctroid = (c1 + c2 + c3 + c4) / 4.;
  ctroid *= vec2(1.3, 0.7);
  vec4 color = vec4(1.);

  // Initialize the distance and define the smoothing factor
  float d = 99.;

  // Iterate over the centers and compute the sdf
  for (int i = 0; i &lt; 5; i++) {
    vec2 c = centers[i];
    float sdf = circleSDF(uv, c, .15);
    d = smin(d, sdf, K);
  }
  // Define the metaball
  float metaball = 1. - smoothstep(0., 0.003, d);

  // Final color
  float fx = ((clamp(m.x, 0., 1.)/20.) + 1. );
  float fy = ((clamp(m.y, 0., 1.)/10.) + 1. );
  float shine = exp(-abs(d));
  float membrane = 1. - smoothstep(0.001, 0.005, clamp(abs(d), 0., 1.));
  float dist = distance(uv, ctroid);

  color.rgb = mix(vec3(255./255. * fy, 249./255., 240./255. * fx),
                vec3(225./255., 230./255., 230./255.), dist);
  color.rgb = mix(vec3(0.35, 0., 0.), color.rgb, shine);
  // color the membrane
  color.rgb = mix(color.rgb, vec3(0.5, 0.3, 0.3), membrane);
  vec4 bg = vec4(255./255., 249./255., 240./255., 1.) * (1. - distance(uv, vec2(0.5)));
  color = mix(bg*metaball, color, metaball);
  
  gl_FragColor = color;
}</pre></div></div></details>   
    </div>
</div>
<p>That concludes this introduction. I’m glad I’ve finally learned to write shaders! This article barely scratches the surface of the basics, but there’s no reason to be afraid anymore—neither for you nor for me. Stay tuned for future articles where we’ll explore how to elevate this blob into the third dimension. In the meantime, feel free to experiment; you can change the color scheme or tweak the positions of the balls. For updates, you can follow me on <a href="https://twitter.com/AntoineMyrwtz" rel="nofollow">Twitter</a>.</p>
<h2>References</h2>
<ul><li><a href="https://thebookofshaders.com/" rel="nofollow">The book of shaders</a></li>
<li><a href="https://iquilezles.org/" rel="nofollow">Inigo Quilez</a></li>
<li><a href="https://www.youtube.com/watch?v=f4s1h2YETNY" rel="nofollow">An introduction to Shader Art Coding (Youtube)</a></li>
<li><a href="https://www.shadertoy.com/" rel="nofollow">Shadertoy</a></li></ul>
<h2>Comments</h2></div></div>
  </body>
</html>
