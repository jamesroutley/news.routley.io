<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=36895220">Original</a>
    <h1>Launch HN: PeerDB (YC S23) – Fast, Native ETL/ELT for Postgres</h1>
    
    <div id="readability-page-1" class="page"><div><td colspan="2"></td><td><div><p>Hi HN! I&#39;m Sai, the co-founder and CEO of PeerDB (<a href="https://www.peerdb.io/">https://www.peerdb.io/</a>), a Postgres-first data-movement platform that makes moving data in and out of Postgres fast and simple. PeerDB is free and open (<a href="https://github.com/PeerDB-io/peerdb">https://github.com/PeerDB-io/peerdb</a>) and we provide a Docker stack for users to try us out. Our repo is at <a href="https://github.com/PeerDB-io/peerdb">https://github.com/PeerDB-io/peerdb</a> and there’s a 5-minute quickstart here: <a href="https://docs.peerdb.io/quickstart">https://docs.peerdb.io/quickstart</a>.</p><p>For the past 8 years, working at Microsoft on Postgres on Azure, and before that at Citus Data, I’ve worked closely with customers running Postgres at the heart of their data stack, storing anywhere from 10s of GB of data to 10s of TB.</p><p>This was when I got exposed to the challenges customers faced when moving data in and out of Postgres. Usually they would try existing ETL tools, fail, and decide to build in-house solutions. Common issues with these tools included painfully slow syncs - syncing 100s of GB of data took days; flaky and unreliable - frequent crashes, loss of data precision on target etc., and; feature-limited - lack of configurability, unsupported data types and so on.</p><p>I remember a specific scenario where a tool didn’t support something as simple as the Postgres’ COPY command to ingest data. This would have improved the throughput by orders of magnitude. We (customer and me) reached out to that company to request them to add this feature. They couldn’t prioritize this feature because it wasn’t very easy - their tech stack was designed to support 100s of connectors rather than supporting a native Postgres feature.</p><p>After multiple such occurrences, I thought, why not build a tool specialized for Postgres, making the lives of many Postgres users easier. I reached out to my long-time buddy Kaushik, who was building operating systems at Google and had led data teams at Safegraph and Palantir. We spent a few weeks building an MVP that streamed data in real-time from Postgres to BigQuery. It was 10 times faster than existing tools and maintained data freshness of less than 30 seconds. We realized that there were many Postgres native and infrastructural optimizations we could do to provide a rich data-movement experience for Postgres users. This is when we decided to start PeerDB!</p><p>We started with two main use cases: Real-time Change Data Capture from Postgres (demo: <a href="https://docs.peerdb.io/usecases/realtime-cdc#demo">https://docs.peerdb.io/usecases/realtime-cdc#demo</a>) and Real-time Streaming of query results from Postgres (demo: <a href="https://docs.peerdb.io/usecases/realtime-streaming-of-query-results#demo">https://docs.peerdb.io/usecases/realtime-streaming-of-query-...</a>). The 2nd demo shows PeerDB streaming a table with 100M rows from Postgres to Snowflake.</p><p>We implement multiple optimizations to provide a fast, reliable, feature-rich experience.  For performance, we can parallelize the initial load of a large table, still ensuring consistency. Syncing 100s of GB goes from days to minutes. We do this by logically partitioning the table based on internal tuple identifiers (CTID) and parallelly streaming those partitions (inspired by this DuckDB blog - <a href="https://duckdb.org/2022/09/30/postgres-scanner.html#parallelization" rel="nofollow noreferrer">https://duckdb.org/2022/09/30/postgres-scanner.html#parallel...</a>)</p><p>For CDC, we don’t use Debezium, rather handle replication more natively—reading the slot, replicating the changes, keeping state etc. We made this choice mainly for flexibility. Staying native helps us use existing and future Postgres enhancements more effectively. For example, if the order of rows across tables on the target is not important, we can parallelize reading of a single slot across multiple tables and improve performance. Our architecture is designed for real-time syncs, which enables data-freshness of a few 10s of seconds even at large throughputs (10k+ tps).</p><p>We have fault tolerance mechanisms for reliability (<a href="https://blog.peerdb.io/using-temporal-to-scale-data-synchronization-at-peerdb">https://blog.peerdb.io/using-temporal-to-scale-data-synchron...</a>) and support multiple features including log-based (CDC) / query based streaming, efficient syncing of tables with large (TOAST) columns, configurable batching and parallelism to prevent OOMs and crashes etc.</p><p>For usability - we provide a Postgres compatible SQL layer for data-movement. This makes the life of data engineers much easier. They can develop pipelines using a framework they are familiar with, without needing to deal with custom UIs and REST APIs. They can use Postgres&#39; 100s of integrations to build and manage ETL. We extend Postgres&#39; SQL grammar with a few new intuitive SQL commands to enable real-time data streaming across stores. Because of this, we were able to add dbt integration via Dagster (in private preview) in a few hours! We expect data-engineers to unravel similar integrations with PeerDB easily, and plan to make this grammar richer as we evolve.</p><p>PeerDB consists of the following components to handle data replication: (1) PeerDB Server uses the pgwire protocol to mimic a PostgreSQL server, responsible for query routing and generating gRPC requests to the Flow API. It relies on AST analysis to make informed decisions on routing. (2) Flow API: an API layer that deals with gRPC commands, orchestrating the data sync operations; (3) Flow Workers execute the data read-write operations from the source to the destination. Built to scale horizontally, they interact with Temporal for increased resilience. The types of data replication supported include CDC streaming replication and query-based batch replication. Workers do all of the heavy lifting, and have data store specific optimizations.</p><p>Currently we support 6 target data stores (BigQuery, Snowflake, Postgres, S3, Kafka etc) for data movement from Postgres. This doc captures the current status of the connectors: <a href="https://docs.peerdb.io/sql/commands/supported-connectors">https://docs.peerdb.io/sql/commands/supported-connectors</a>.</p><p>As we spoke to more customers, we realized that getting data into PostgreSQL at scale is equally important and hard. For example one of our customers wants to periodically sync data in multiple SQL Server instances (running on the edge) to their centralized Postgres database. Requests for Oracle to Postgres migrations are also common. So now we’re also supporting source data stores with Postgres as the target (currently SQL Server and Postgres itself, with more to come).</p><p>We are actively working with customers to onboard them to our self-hosted enterprise offering. Our fully hosted offering on the cloud is in private preview. We haven’t yet decided on the pricing. One common concern we’ve heard from customers is that existing tools are expensive and charge based on the amount of data transferred. To address this, we are considering a more transparent way of pricing—for example, pricing based on provisioned hardware (cpu, memory, disk). We’re open for feedback on this!</p><p>Check out our github repo - <a href="https://github.com/PeerDB-io/peerdb">https://github.com/PeerDB-io/peerdb</a> and go ahead and give it a spin (5-minute quickstart <a href="https://docs.peerdb.io/quickstart">https://docs.peerdb.io/quickstart</a>).</p><p>We want to provide the world’s best data-movement experience for Postgres. We would love to get your feedback on product experience, our thesis and anything else that comes to your mind. It would be super useful for us. Thank you!</p></div></td></div></div>
  </body>
</html>
