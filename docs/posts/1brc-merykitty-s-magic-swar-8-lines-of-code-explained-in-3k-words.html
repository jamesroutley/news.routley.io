<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://questdb.io/blog/1brc-merykittys-magic-swar/">Original</a>
    <h1>1brc merykitty&#39;s magic SWAR: 8 lines of code explained in 3k words</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>
  QuestDB is a high performance time series database with SQL
  analytics that can power through data ingestion and analysis.
  It&#39;s <a href="https://github.com/questdb/questdb">open source</a>
  and integrates with many tools and languages. Give us a try!</p><hr/><p>In a
<a href="https://questdb.io/blog/billion-row-challenge-step-by-step/" target="_blank" rel="noopener noreferrer">recent blog post</a>
I described the most important optimizations I and other contestants applied at
the recent <a href="https://1brc.dev/" target="_blank" rel="noopener noreferrer">One Billion Row Challenge (1BRC)</a>. Using them I
showed how the performance of the initial idiomatic, parallelized Java code
improves by a factor of 40. We went from 71 seconds, down to 1.7.</p><p>The optimization techniques we applied ranged from simple and digestible to
arcane and mystifying. One technique in particular stood out as especially
awesome but cryptic, and I noted that explaining it would take another full blog
post.</p><p>So, here we are!</p><h2><a aria-hidden="true" tabindex="-1" id="enter-the-1brc"></a>Enter the 1BRC<a href="#enter-the-1brc" title="Direct link to heading">#</a></h2><p>Several experts predicted at the outset of the 1BRC contest that, once the
&#34;usual suspects&#34; are dealt with, one particular concern would become the
botteneck: parsing the temperature from the CSV file. It isn&#39;t a complicated
format – the temperature can range from -99.9 to 99.9, so there are a total of
four possible arrangements of characters: <code>-XX.X</code>, <code>-X.X</code>, <code>X.X</code>, and <code>XX.X</code>.
But, when your goal is to parse one billion of them in less than a second, every
little detail and variation becomes an issue.</p><p>Initially, contestants used the <code>Double.parseDouble()</code> library call. But soon
enough, custom solutions started popping up that were up to a screenful long.
Many adopted an approach that looked pretty optimal. It didn&#39;t involve any
loops, and had the seeming &#34;theoretical minimum&#34; of two branching points,
covering the four possibilities.</p><p>Then, out of the blue, a solution appeared that set the Twitter #1BRC hashtag on
fire. No <code>if</code> statements, and just a single read from the file! It was a part of
the solution contributed by Quân Anh Mai (GitHub handle
<a href="https://github.com/MeryKitty" target="_blank" rel="noopener noreferrer">@merykitty</a>). The code looked like nothing less
than magic incantations, and even the top experts nodded in disbelief.</p><p>Since 1BRC was an open source contest, everyone could look at and copy ideas
from others. As a result, this snippet spread like wildfire and became a
standard element of all the top solutions. The winning contestant, Thomas
Wuerthinger, went as far as listing Quân Anh as a part of the team that
contributed to his solution.</p><blockquote><p><strong>Big thanks to Quân Anh, who reviewed this post for correctness and approved
it!</strong></p></blockquote><h2><a aria-hidden="true" tabindex="-1" id="unpacking-merykittys-magic-swar"></a>Unpacking merykitty’s Magic SWAR<a href="#unpacking-merykittys-magic-swar" title="Direct link to heading">#</a></h2><p>Merykitty&#39;s code consists of nothing but a fixed sequence of 18 ALU operations:
bitwise shift, AND, NOT and XOR; arithmetic add, subtract, and multiply; and a
single low-level function call <code>numberOfTrailingZeros()</code>, for which the JDK has
a compiler intrinsic using specialized CPU instructions.</p><p>In goes a <code>long</code> number filled with 8 bytes from the CSV (in little-endian
order), and out comes the temperature as an integer (10x the actual
temperature).</p><p>We pack eight bytes of input into a single CPU register, and then perform
operations on the register as a whole. Usually, such work is performed using
specialized CPU instructions, designed specifically to operate on many bytes of
data at once. Such instructions are called &#34;Single Instruction, Multiple Data&#34;,
or SIMD for short. In this case, we&#39;re using standard CPU registers and
instructions – this kind of technique goes by the name of &#34;SIMD Within A
Register&#34;, or SWAR.</p><p>The full code at a glance:</p><blockquote><p>Note: this is not the exact original code by merykitty. It is slightly
transformed for easier reading.
<a href="https://github.com/gunnarmorling/1brc/blob/dfec2cdbe6a0334cff054f333ec4b4d9e4d775cf/src/main/java/dev/morling/onebrc/CalculateAverage_merykitty.java#L165-L195" target="_blank" rel="noopener noreferrer">View the original</a>.</p></blockquote><p>The value of the <code>inputData</code> parameter comes from a direct native memory read of
the <code>mmap</code>&#39;d CSV file. We don&#39;t have to deal with that code since it&#39;s a
separate concern.</p><p>Now, we&#39;ve all seen a line or two of bit-twiddling code here and there that
looks cryptic at first. However, after half an hour explaining it to yourself,
it becomes kind of familiar and not that scary.</p><p>But have you ever seen <em>this</em> much of it in one place? And solving such a
complex, high-level problem like parsing temperature? It seems to lie beyond
human comprehension.</p><p>I&#39;m here to show you that you can get it. It&#39;s just a number of steps, after
all. They are put together amazingly tight, like a rocket engine. But when you
zoom in on each part alone, you&#39;ll see it boils down to familiar concepts. No
maths beyond 6th grade, I promise!</p><p>At a high-level, the code code takes these steps:</p><ol><li>Detect whether the number is negative (i.e., the first character is <code>-</code>)</li><li>Zero out the sign character, if any</li><li>Find where is the decimal dot</li><li>Shift the contents so that the digits align with the template <code>XY.Z</code> placed
over the bits of the <code>long</code> value</li><li>Transform the ASCII characters to their digit values</li><li>Multiply each digit by its weight (1x, 10x, 100x), and add them all up</li><li>Apply the sign</li></ol><p>When you break it down into steps like this, it sounds less magical right away.
These are the reasonable steps to take. But the really interesting bits come
when you try to do them with nothing but ALU operations.</p><h3><a aria-hidden="true" tabindex="-1" id="1-detect-the-minus-sign"></a>1. Detect the minus sign<a href="#1-detect-the-minus-sign" title="Direct link to heading">#</a></h3><p>This code detects the minus sign:</p><p>Let me reverse the order of negation (<code>~</code>) and shifting, to make the explanation
easier, like this:</p><p>The result is that <code>broadcastSign</code> contains either all zeros, or all ones. In
other words, it has the sign bit broadcast across the entire <code>long</code> word. How
does it work? It relies on the special property of the ASCII code for the minus
sign. Its bit number 4 is zero, as opposed to all the digits, where it&#39;s one.</p><p>To better explain it, let&#39;s use some visuals. I&#39;ll print the CSV input
characters reflected right-to-left, to help you remember they&#39;re stored in
little-endian order. Here&#39;s a temperature reading of -10.8 ℃, with the bit
number 4 emphasized in each character:</p><figure><div><p><img alt="Image shows the little-endian order of ASCII bytes that spell out -10.8. Bit number 4 in each byte is marked with a red rectangle." src="http://ablwr.github.io/img/blog/2024-03-07/input-word-1.webp" loading="lazy"/></p><figcaption>Bit structure of the input word -10.8</figcaption></div></figure><p>So, what happens when we perform the bitwise ops as the code says? We&#39;ll start
with the full <code>long</code> word just like in the picture, with the three missing bytes
added on the left:</p><p><code>00000000 00000000 00000000 00111000 00101110 00110000 00110001 00101101</code></p><p>Then shift it left by 59:</p><p><code>inputData &lt;&lt; 59</code> =</p><p><code>01101000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</code></p><p>Our special bit that tells the difference between a digit and the minus sign is
now all the way to the left. Let us apply the negation now, flipping all the
bits:</p><p><code>~(inputData &lt;&lt; 59)</code> =</p><p><code>10010111 11111111 11111111 11111111 11111111 11111111 11111111 11111111</code></p><p>Now the leftmost bit is <code>1</code> when the first character is a minus sign, and <code>0</code>
when it&#39;s not a minus sign.</p><p>Next, we make an <em>arithmetic</em> shift right by 63. This means that the leftmost
bit, as it moves to the right, leaves a &#34;trail&#34; of itself:</p><p><code>broadcastSign = ( ~(inputData &lt;&lt; 59) ) &gt;&gt; 63</code> =</p><p><code>11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111</code></p><p>We end up with the whole long word full of that leftmost bit! If it was 0, the
whole word would be zero.</p><p>So that&#39;s our <code>broadcastSign</code>. It is all ones if there&#39;s a minus sign, and all
zeros if there&#39;s no minus sign. Our example has the minus sign, and therefore
it&#39;s all ones.</p><h3><a aria-hidden="true" tabindex="-1" id="2-zero-out-the-sign-character"></a>2. Zero out the sign character<a href="#2-zero-out-the-sign-character" title="Direct link to heading">#</a></h3><p>Now that we&#39;ve dealt with the minus sign and stored its information in a
variable, we want to get rid of it from the input data. This will make the input
data more uniform, and we&#39;ll then only deal with the absolute value of the
temperature.</p><p>It&#39;s very easy to zero out the lowest byte in a <code>long</code> number. To do so, just
apply the AND mask that has ones all over it, except for the lowest 8 bits. But,
the challenge is that this lowest byte may be either a minus sign or a digit,
and we must definitely keep the digit intact.</p><p>So, we&#39;ll construct the AND mask by relying on the <code>broadcastSign</code> variable to
guide the calculation towards either all ones (such a mask leaves everything as
it was), or the lowest 8 bits set to zero:</p><p>Let&#39;s zoom in on the steps now.</p><p><code>broadcastSign</code> =</p><p><code>11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111</code></p><p><code>0xFF</code> =</p><p><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 11111111</code></p><p><code>broadcastSign &amp; 0xFF</code> =</p><p><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 11111111</code></p><p>Then we flip all the bits (<code>~</code>), so</p><p><code>maskToRemoveSign = ~(broadcastSign &amp; 0xFF)</code> =</p><p><code>11111111 11111111 11111111 11111111 11111111 11111111 11111111 00000000</code></p><p>This is the case where the minus sign is present. Otherwise, we&#39;d have all zeros
in <code>broadcastSign</code>, resulting in all ones in the mask. We got exactly what we
wanted.</p><p>Now we apply this to <code>inputData</code>, with another AND operation:</p><p>The minus sign is now gone from our <code>inputWord</code>. But if there was a digit
instead of the minus sign, it would still be there, untouched.</p><h3><a aria-hidden="true" tabindex="-1" id="3-find-where-is-the-decimal-dot"></a>3. Find where is the decimal dot<a href="#3-find-where-is-the-decimal-dot" title="Direct link to heading">#</a></h3><p>We&#39;ll find the dot with this statement:</p><p>You may have noticed that the dot character <code>.</code> has the same distinguishing
property as the minus character: its bit 4 is zero. We&#39;ll use that property once
again to locate the dot character in the input word. This time we&#39;ll apply an
AND mask that has 1 at bit 4 of each of the three possible bytes where the dot
may appear:</p><p>Or, in more condensed hexadecimal notation:</p><p>Now, since the distinguishing bit is 0 in the dot character, we&#39;ll use the
negated input word, where this bit will be 1:</p><p>The result is all zero bits except bit number 4 in byte number 3, that is, bit
number 3 * 8 + 4 = 28. Now we apply <code>numberOfTrailingZeros</code> to that, and get
the number 28. So, for our example of -10.8 ℃, <code>int dotPos = 28</code>.</p><h3><a aria-hidden="true" tabindex="-1" id="4-shift-the-contents-to-align-to-template"></a>4. Shift the contents to align to template<a href="#4-shift-the-contents-to-align-to-template" title="Direct link to heading">#</a></h3><p>Now that we have the position of the dot, we want to shift the contents of the
<code>inputWord</code> so that each byte has the same meaning, regardless of the original
input format. We want the word to fit into this template:</p><p><code>0 0 0 Z . Y X 0</code></p><p>where:</p><ul><li><code>X</code> is the tens digit</li><li><code>Y</code> is the ones digit</li><li><code>Z</code> is the decimal digit</li></ul><blockquote><p>NOTE: <code>0</code> represents a zero byte, not the ASCII character <code>&#34;0&#34;</code></p></blockquote><p>So far, our word could be in any of these layouts (remember we zeroed out the
minus):</p><p>And we&#39;ll use this line of code to align it:</p><p>For our Example 1, with -10.8 ℃, it&#39;s easy — the word is already aligned,
<code>dotPos = 28</code>, and so we shift by zero.</p><p>To see this line of code in action, let&#39;s use Example 2, a temperature reading
of -7.7 ℃:</p><figure><div><p><img alt="Image shows the little-endian order of ASCII bytes that spell out -7.7. Bit number 4 in each byte is marked with a red rectangle." src="http://ablwr.github.io/img/blog/2024-03-07/input-word-2.webp" loading="lazy"/></p><figcaption>Bit structure of the input word -7.7</figcaption></div></figure><p>After completing the steps that remove the minus sign, the bytes in the input
word will be like this:</p><p><code>0 0 0 0 7 . 7 0</code></p><p>Recall the calculation from the previous step: we apply a mask that ignores the
rightmost red rectangle, and isolates the bits in the other three rectangles.</p><p>So, it will detect that the 3rd byte from the right has a zero bit in the red
rectangle. That&#39;s bit number 2 * 8 + 4 = 20. Therefore, <code>dotPos = 20</code>, and
since we shift left by <code>28 - dotPos</code>, we&#39;ll shift by <code>28 - 20 = 8</code> — one byte to
the left.</p><p>The result will be this:</p><p><code>0 0 0 7 . 7 0 0</code></p><p>And here&#39;s our template once again:</p><p><code>0 0 0 Z . Y X 0</code></p><p><code>X</code> comes out as <code>0</code>, exactly as it should be. Our number -7.7 ℃ is equal to
-07.7 ℃ — the tens digit is indeed zero.</p><p>This step already feels a bit magical. With nothing but straight-through bit
manipulation, we managed to align all the different cases to the same fixed
template!</p><h3><a aria-hidden="true" tabindex="-1" id="5-transform-the-ascii-characters-to-their-digit-values"></a>5. Transform the ASCII characters to their digit values<a href="#5-transform-the-ascii-characters-to-their-digit-values" title="Direct link to heading">#</a></h3><blockquote><p>From this point on, we return to Example 1: -10.8 ℃.</p></blockquote><p>So far we&#39;ve been a bit loose in our notation — we used <code>0</code> to represent the
zero-valued byte, but all the other digits represented ASCII characters. At this
point we have to clean this up, because we are after the numerical value of the
temperature.</p><p>It turns out that the designers of the ASCII table were very careful about this
and made it super-simple to go from the digit to the number! As we can see in
this excerpt:</p><p>So all we have to do is zero out the left hex digit (3), and we have the
numbers. Since a hex digit corresponds to exactly four bits, this will be easy.</p><p>Given our template, the ASCII_TO_DIGIT_MASK constant should now make sense:</p><p>There are <code>F</code>s under each of the three digits. Let&#39;s go back to our example 1,
-10.8 ℃, and set the value of <code>alignedToTemplate</code> against this mask (excuse my
one last misuse of <code>0</code> to mean both zero and ASCII <code>&#34;0&#34;</code>):</p><p>Matching this to our template, we can see that this exactly represents our
number 10.8.</p><h3><a aria-hidden="true" tabindex="-1" id="6-multiply-each-digit-with-its-weight-and-add-them-all-up"></a>6. Multiply each digit with its weight, and add them all up<a href="#6-multiply-each-digit-with-its-weight-and-add-them-all-up" title="Direct link to heading">#</a></h3><p>And now, for the truly epic grand finale! We&#39;ll find a single integer that
multiplies our <code>digits</code> number, and somehow magically the temperature value will
materialize in the middle of the resulting integer!</p><p>To get there, we&#39;ll rely heavily on the fact that multiplication and addition
are linear operations, and can be decomposed into independent parts that combine
into the final result.</p><p>First, let&#39;s see how we could arrange a multiplier that would make the sum <code>X</code> +
<code>Y</code> + <code>Z</code> appear within the result. To do so, we&#39;ll evaluate a schematic
representation of our <code>digits</code> number. In this representation, each symbol
represents four bits, and <code>.</code> represents <code>0000</code>:</p><p>We can shift it left by 16 and 24 to align <code>X</code>, <code>Y</code>, and <code>Z</code> within the same bit
range:</p><p>Now we can sum up these three:</p><p>Here <code>W</code> stands for <code>X + Y + Z</code>, and is at most 5 bits wide because the sum of
three decimal digits is at most 27. Now we can shift this number to the right
and apply an AND mask to eliminate what we don&#39;t need:</p><p>Bam, out comes our sum!</p><p>Now, we could do exactly as described: use two more variables to hold the two
shifted numbers, and then sum them up. However, there&#39;s a much simpler and
cleaner way to represent this. We just need to remember how multiplication
works. It&#39;s nothing but a sequence of shift-left and add operations! Like this:</p><p>So, what is the factor that will do all of our calculation in one go? We simply
need a binary number with all zeros except at positions 0 (no shift), 16, and
24:</p><p>Or, in the more condensed HEX representation,</p><p>Now we can perform that single multiplication, and get exactly the same effect
as we showed above:</p><p>This is pretty awesome, but… We don&#39;t actually need <code>X</code> + <code>Y</code> + <code>Z</code>, we just
used that for practice. We need <code>100 * X</code> + <code>10 * Y</code> + <code>Z</code>!</p><p>This is where things get <em>really</em> tense. We got assured that our <code>WW</code> part of
the result is at most 5 bits wide, representing 27. But, with our actual
calculation, this can be a number up to 999, a <em>ten</em>-digit number in binary! And
those two <code>WW</code> are right next to <code>Y</code> on the left. Apparently we have room for
only 8 bits. Will their bits get mixed together, spoiling our result?</p><p>We have to look at this very carefully. Let&#39;s use our schematic again, but now
we&#39;ll add the decimal multipliers <code>100</code> and <code>10</code> in the right places:</p><p>We can see that the first two rows give us no trouble.</p><ul><li>In the first row, <code>Z</code> is well isolated from the others.</li><li>In the second row, <code>X</code> is tightly below <code>Y</code>, but that row is only multiplied
by 10, with the maximum value of 90, occupying 7 bits.</li><li>In the third row, however, we have <code>X * 100</code>, ten bits wide, enroaching on the
bit positions of <code>Y</code>. Here, it seems that the scheme may break.</li></ul><p>But then, almost as a <em>deus ex machina</em>, we realize that <code>Y</code> is also multiplied
by <code>100</code>, which breaks down into <code>4 * 25</code> — that 4 in there is a round binary
number <code>100</code>.</p><p>Just like multiplying by <strong>decimal</strong> <code>100</code> results in a <strong>decimal</strong> number
ending in two zeros, so does multiplying by <strong>binary</strong> <code>100</code> result in a
<strong>binary</strong> number ending with two zeros. The rightmost two bits of <code>Y * 100</code>
will therefore be zero, and that is <em>exactly</em> the two bits that we need to fit
<code>X * 100</code>!</p><p>So we escape by a split hair and get a clean sum of all three rows in the bit
range <code>41..32</code>. As merykitty commented, <code>// That was close :)</code></p><p>Let&#39;s wrap up this step with the complete formula:</p><p><code>0x3FF</code> is a number with ten ones in binary form, isolating our ten-bit-wide
result.</p><h3><a aria-hidden="true" tabindex="-1" id="7-apply-the-sign"></a>7. Apply the sign<a href="#7-apply-the-sign" title="Direct link to heading">#</a></h3><p>After all the fireworks in the previous step, this step is kind of an
anticlimax. And yet, even here we find ingenious tricks.</p><p>So far, we have the absolute value of the temperature (multiplied by 10 so that
it&#39;s an integer), and, in a separate variable, we have the information whether
there is a minus sign. This is encoded in the variable <code>broadcastSign</code> as 0 for
&#34;no minus&#34;, and -1 for &#34;yes minus&#34;.</p><p>How do you put the sign on the absolute value, without using an <code>if</code>? If the &#34;no
minus&#34; case was encoded as 1, it would be a trivial multiplication. But, that&#39;s
just wishful thinking, we have what we have. We&#39;re so close, is there anything
else we can use? One last magic trick?</p><p>Yes, there is a trick! It&#39;s a very well-known, basic concept, but coming to
realize it&#39;s the right thing in this moment was a touch of genius.</p><p>There&#39;s a good chance you already know how signed integers work in programming
languages. We don&#39;t just slap on a sign bit to signal a negative number. We use
the two&#39;s complement formula:</p><p><code>-n = NOT(n) + 1</code></p><p>Now look and marvel how this formula serves us the solution on a silver platter.
We need one of these two things to happen:</p><ol><li><code>value = absValue</code> when there is no minus sign</li></ol><p>OR</p><ol start="2"><li><code>value = NOT(absValue) + 1</code> when there is a minus sign.</li></ol><p>We can call upon the <code>XOR</code> operation to act as switchable negation: <code>n XOR -1</code>
is <code>NOT(n)</code>, and <code>n XOR 0</code> is just <code>n</code>. Guess what, this is an exact match to
the value of <code>broadcastSign</code>! As for our optional <code>+ 1</code>, we can conveniently use
<code>-broadcastSign</code>. So, our formula is this:</p><p><code>temperature = (absValue ^ broadcastSign) - broadcastSign</code></p><p>And there it is, our temperature has materialized!</p><h3><a aria-hidden="true" tabindex="-1" id="8-bonus-compute-the-end-of-the-csv-row"></a>8. Bonus: compute the end of the CSV row<a href="#8-bonus-compute-the-end-of-the-csv-row" title="Direct link to heading">#</a></h3><p>Now that we have the temperature, you may wonder why go on. In the broader 1BRC
solution, it was very important to also cheaply find out where the next CSV line
starts.</p><p>We calculate that by using the decimal dot as the anchor, because after it
there&#39;s always one decimal, followed by a newline. <code>dotPos</code>, as you recall, is
the number of bits, not bytes, so we divide it by 8 (shift right by 3, same
thing) and add three, in order to point out the first byte of the next CSV line:</p><p><code>nextLineStart = (dotPos &gt;&gt;&gt; 3) + 3</code></p><h2><a aria-hidden="true" tabindex="-1" id="conclusion"></a>Conclusion<a href="#conclusion" title="Direct link to heading">#</a></h2><p>While I can hope this blog post explained the mystery behind merykitty&#39;s magic
SWAR, the real mystery is how a single guy working alone could come up with all
this in just a few days of casually doing an online challenge with a T-shirt and
a coffee mug as a reward.</p><p>That is the kind of mystery you won&#39;t find a blog post explaining.</p><p>Take care!</p><div><div><div><p><a href="http://ablwr.github.io/download/">Download QuestDB</a><span> Open source under Apache 2.0. Blazing fast ingest. SQL analytics. </span></p></div></div></div></article></div></div>
  </body>
</html>
