<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://web.dev/webtransport/">Original</a>
    <h1>Using WebTransport</h1>
    
    <div id="readability-page-1" class="page"><article><header><nav aria-label="breadcrumbs"><ul role="list"><li><a data-label="post, home breadcrumb" data-action="click" data-category="web.dev" href="https://web.dev/"> Home </a></li><li><a data-label="post, path breadcrumb" data-action="click" data-category="web.dev" href="https://web.dev/blog"> All articles </a></li></ul></nav><p>WebTransport is an API offering low-latency, bidirectional, client-server messaging. Learn more about its use cases, and how to give feedback about the future of the implementation.</p><p><time>Jun 8, 2020</time> â€” Updated <time>Jul 18, 2022</time></p></header><h2 id="background">Background <a href="#background">#</a></h2><h3 id="whats-webtransport">What&#39;s WebTransport? <a href="#whats-webtransport">#</a></h3><p><a href="https://w3c.github.io/webtransport/" rel="noopener">WebTransport</a> is a web API that uses the <a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html" rel="noopener">HTTP/3</a> protocol as a bidirectional transport. It&#39;s intended for two-way communications between a web client and an HTTP/3 server. It supports sending data both unreliably via its <a href="#datagram">datagram APIs</a>, and reliably via its <a href="#stream">streams APIs</a>.</p><p><a href="https://tools.ietf.org/html/draft-ietf-quic-datagram-00" rel="noopener">Datagrams</a> are ideal for sending and receiving data that do not need strong delivery guarantees. Individual packets of data are limited in size by the <a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit" rel="noopener">maximum transmission unit (MTU)</a> of the underlying connection, and may or may not be transmitted successfully, and if they are transferred, they may arrive in an arbitrary order. These characteristics make the datagram APIs ideal for low-latency, best-effort data transmission. You can think of datagrams as <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" rel="noopener">user datagram protocol (UDP)</a> messages, but encrypted and congestion-controlled.</p><p>The streams APIs, in contrast, provide <a href="https://en.wikipedia.org/wiki/Reliability_(computer_networking)" rel="noopener">reliable</a>, ordered data transfer. They&#39;re <a href="https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#name-streams" rel="noopener">well-suited</a> to scenarios where you need to send or receive one or more streams of ordered data. Using multiple WebTransport streams is analogous to establishing multiple <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" rel="noopener">TCP</a> connections, but since HTTP/3 uses the lighter-weight <a href="https://www.chromium.org/quic" rel="noopener">QUIC</a> protocol under the hood, they can be opened and closed without as much overhead.</p><h3 id="use-cases">Use cases <a href="#use-cases">#</a></h3><p>This a small list of possible ways developers might use WebTransport.</p><ul><li>Sending game state at a regular interval with minimal latency to a server via small, unreliable, out-of-order messages.</li><li>Receiving media streams pushed from a server with minimal latency, independent of other data streams.</li><li>Receiving notifications pushed from a server while a web page is open.</li></ul><p>We&#39;re interested in <a href="#feedback">hearing more</a> about how you plan to use WebTransport.</p><h2 id="status">Current status <a href="#status">#</a></h2><h2 id="webtransports-relationship-to-other-technologies">WebTransport&#39;s relationship to other technologies <a href="#webtransports-relationship-to-other-technologies">#</a></h2><h3 id="is-webtransport-a-replacement-for-websockets">Is WebTransport a replacement for WebSockets? <a href="#is-webtransport-a-replacement-for-websockets">#</a></h3><p>Maybe. There are use cases where either <a href="https://developer.mozilla.org/docs/Web/API/WebSockets_API" rel="noopener">WebSockets</a> or WebTransport might be valid communication protocols to use.</p><p>WebSockets communications are modeled around a single, reliable, ordered stream of messages, which is fine for some types of communication needs. If you need those characteristics, then WebTransport&#39;s streams APIs can provide them as well. In comparison, WebTransport&#39;s datagram APIs provide low-latency delivery, without guarantees about reliability or ordering, so they&#39;re not a direct replacement for WebSockets.</p><p>Using WebTransport, via the datagram APIs or via multiple concurrent Streams API instances, means that you don&#39;t have to worry about <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking" rel="noopener">head-of-line blocking</a>, which can be an issue with WebSockets. Additionally, there are performance benefits when establishing new connections, as the underlying <a href="https://www.fastly.com/blog/quic-handshake-tls-compression-certificates-extension-study" rel="noopener">QUIC handshake</a> is faster than starting up TCP over TLS.</p><p>WebTransport is part of a new draft specification, and as such the WebSocket ecosystem around client and server libraries is currently much more robust. If you need something that works &#34;out of the box&#34; with common server setups, and with broad web client support, WebSockets is a better choice today.</p><h3 id="is-webtransport-the-same-as-a-udp-socket-api">Is WebTransport the same as a UDP Socket API? <a href="#is-webtransport-the-same-as-a-udp-socket-api">#</a></h3><p>No. WebTransport is not a <a href="https://www.w3.org/TR/raw-sockets/" rel="noopener">UDP Socket API</a>. While WebTransport uses HTTP/3, which in turn uses UDP &#34;under the hood,&#34; WebTransport has requirements around encryption and congestion control that make it more than a basic UDP Socket API.</p><h3 id="is-webtransport-an-alternative-to-webrtc-data-channels">Is WebTransport an alternative to WebRTC data channels? <a href="#is-webtransport-an-alternative-to-webrtc-data-channels">#</a></h3><p>Yes, for client-server connections. WebTransport shares many of the same properties as <a href="https://developer.mozilla.org/docs/Web/API/RTCDataChannel" rel="noopener">WebRTC data channels</a>, although the underlying protocols are different.</p><p>Generally, running a HTTP/3-compatible server requires less setup and configuration than maintaining a WebRTC server, which involves understanding multiple protocols (<a href="https://developer.mozilla.org/docs/Web/API/WebRTC_API/Connectivity#ICE_candidates" rel="noopener">ICE</a>, <a href="https://webrtc-security.github.io/#4.3.1." rel="noopener">DTLS</a>, and <a href="https://developer.mozilla.org/docs/Web/API/RTCSctpTransport" rel="noopener">SCTP</a>) in order to get a working transport. WebRTC entails many more moving pieces that could lead to failed client/server negotiations.</p><p>The WebTransport API was designed with the web developer use cases in mind, and should feel more like writing modern web platform code than using WebRTC&#39;s data channel interfaces. <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=302019" rel="noopener">Unlike WebRTC</a>, WebTransport is supported inside of <a href="https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener">Web Workers</a>, which allows you to perform client-server communications independent of a given HTML page. Because WebTransport exposes a <a href="https://streams.spec.whatwg.org/" rel="noopener">Streams</a>-compliant interface, it supports optimizations around <a href="https://streams.spec.whatwg.org/#backpressure" rel="noopener">backpressure</a>.</p><p>However, if you already have a working WebRTC client/server setup that you&#39;re happy with, switching to WebTransport may not offer many advantages.</p><h2 id="try-it-out">Try it out <a href="#try-it-out">#</a></h2><p>The best way to experiment with WebTransport is to start up a compatible HTTP/3 server. You can then use this page with a <a href="https://googlechrome.github.io/samples/webtransport/client.html" rel="noopener">basic JavaScript client</a> to try out client/server communications.</p><p>Additionally, a community-maintained echo server is available at <a href="https://webtransport.day/" rel="noopener">webtransport.day</a>.</p><h2 id="using-the-api">Using the API <a href="#using-the-api">#</a></h2><p>WebTransport was designed on top of modern web platform primitives, like the <a href="https://developer.mozilla.org/docs/Web/API/Streams_API" rel="noopener">Streams API</a>. It relies heavily on <a href="https://developer.mozilla.org/docs/Web/JavaScript/Guide/Using_promises" rel="noopener">promises</a>, and works well with <a href="https://developer.mozilla.org/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener"><code>async</code> and <code>await</code></a>.</p><p>The current WebTransport implementation in Chromium supports three distinct types of traffic: datagrams, as well as both unidirectional and bidirectional streams.</p><h3 id="connecting-to-a-server">Connecting to a server <a href="#connecting-to-a-server">#</a></h3><p>You can connect to a HTTP/3 server by creating a <code>WebTransport</code> instance. The scheme of the URL should be <code>https</code>. You need to explicitly specify the port number.</p><p>You should use the <code>ready</code> promise to wait for the connection to be established. This promise will not be fulfilled until the setup is complete, and will reject if the connection fails at the QUIC/TLS stage.</p><p>The <code>closed</code> promise fulfills when the connection closes normally, and rejects if the closure was unexpected.</p><p>If the server rejects the connection due to a <a href="https://tools.ietf.org/html/draft-vvv-webtransport-quic-01#section-3.2" rel="noopener">client indication</a> error (e.g. the path of the URL is invalid), then that causes <code>closed</code> to reject, while <code>ready</code> remains unresolved.</p><web-copy-code><pre><code><span>const</span> url <span>=</span> <span>&#39;https://example.com:4999/foo/bar&#39;</span><span>;</span></code></pre> </web-copy-code><h3 id="datagram">Datagram APIs <a href="#datagram">#</a></h3><p>Once you have a WebTransport instance that&#39;s connected to a server, you can use it to send and receive discrete bits of data, known as <a href="https://en.wikipedia.org/wiki/Datagram" rel="noopener">datagrams</a>.</p><p>The <code>writeable</code> getter returns a <code><a href="https://developer.mozilla.org/docs/Web/API/WritableStream" rel="noopener">WritableStream</a></code>, which a web client can use to send data to the server. The <code>readable</code> getter returns a <code><a href="https://developer.mozilla.org/docs/Web/API/ReadableStream" rel="noopener">ReadableStream</a></code>, allowing you to listen for data from the server. Both streams are inherently unreliable, so it is possible that the data you write will not be received by the server, and vice versa.</p><p>Both types of streams use <code><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="noopener">Uint8Array</a></code> instances for data transfer.</p><web-copy-code><pre><code><span>// Send two datagrams to the server.</span></code></pre> </web-copy-code><h3 id="stream">Streams APIs <a href="#stream">#</a></h3><p>Once you&#39;ve connected to the server, you could also use WebTransport to send and receive data via its Streams APIs.</p><p>Each chunk of all streams is a <code>Uint8Array</code>. Unlike with the Datagram APIs, these streams are reliable. But each stream is independent, so data order across streams is not guaranteed.</p><h4 id="sendstream">SendStream <a href="#sendstream">#</a></h4><p>A <code><a href="https://wicg.github.io/web-transport/#sendstream" rel="noopener">SendStream</a></code> is created by the web client using the <code>createSendStream()</code> method of a <code>WebTransport</code> instance, which returns a promise for the <code>SendStream</code>.</p><p>Use the <code><a href="https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/close" rel="noopener">close()</a></code> method of the <code><a href="https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter" rel="noopener">WritableStreamDefaultWriter</a></code> to close the associated HTTP/3 connection. The browser tries to send all pending data before actually closing the associated connection.</p><web-copy-code><pre><code><span>// Send two Uint8Arrays to the server.</span></code></pre> </web-copy-code><p>Similarly, use the <code><a href="https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/abort" rel="noopener">abort()</a></code> method of the <code><a href="https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter" rel="noopener">WritableStreamDefaultWriter</a></code> to send a <a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-19.4" rel="noopener">QUIC RESET_STREAM</a> to the server. When using <code>abort()</code>, the browser may discard any pending data that hasn&#39;t yet been sent.</p><web-copy-code><pre><code><span>const</span> ws <span>=</span> <span>await</span> transport<span>.</span><span>createSendStream</span><span>(</span><span>)</span><span>;</span></code></pre> </web-copy-code><h4 id="receivestream">ReceiveStream <a href="#receivestream">#</a></h4><p>A <code><a href="https://wicg.github.io/web-transport/#receivestream" rel="noopener">ReceiveStream</a></code> is initiated by the server. Obtaining a <code>ReceiveStream</code> is a two-step process for a web client. First, it calls the <code>receiveStreams()</code> method of a <code>WebTransport</code> instance, which returns a <code>ReadableStream</code>. Each chunk of that <code>ReadableStream</code>, is, in turn, a <code>ReceiveStream</code> that can be used to read <code>Uint8Array</code> instances sent by the server.</p><web-copy-code><pre><code><span>async</span> <span>function</span> <span>readFrom</span><span>(</span><span>receiveStream</span><span>)</span> <span>{</span></code></pre> </web-copy-code><p>You can detect stream closure using the <code><a href="https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader/closed" rel="noopener">closed</a></code> promise of the <code><a href="https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader" rel="noopener">ReadableStreamDefaultReader</a></code>. When the underlying HTTP/3 connection is <a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-19.8" rel="noopener">closed with the FIN bit</a>, the <code>closed</code> promise is fulfilled after all the data is read. When the HTTP/3 connection is closed abruptly (for example, by <code><a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-19.4" rel="noopener">STREAM_RESET</a></code>), then the <code>closed</code> promise rejects.</p><web-copy-code><pre><code><span>// Assume an active receiveStream</span></code></pre> </web-copy-code><h4 id="bidirectionalstream">BidirectionalStream <a href="#bidirectionalstream">#</a></h4><p>A <code><a href="https://wicg.github.io/web-transport/#bidirectional-stream" rel="noopener">BidirectionalStream</a></code> might be created either by the server or the client.</p><p>Web clients can create one using the <code>createBidirectionalStream()</code> method of a <code>WebTransport</code> instance, which returns a promise for a <code>BidirectionalStream</code>.</p><web-copy-code><pre><code><span>const</span> stream <span>=</span> <span>await</span> transport<span>.</span><span>createBidirectionalStream</span><span>(</span><span>)</span><span>;</span></code></pre> </web-copy-code><p>You can listen for a <code>BidirectionalStream</code> created by the server with the <code>receiveBidirectionalStreams()</code> method of a <code>WebTransport</code> instance, which returns a <code>ReadableStream</code>. Each chunk of that <code>ReadableStream</code>, is, in turn, a <code>BidirectionalStream</code>.</p><web-copy-code><pre><code><span>const</span> rs <span>=</span> transport<span>.</span><span>receiveBidrectionalStreams</span><span>(</span><span>)</span><span>;</span></code></pre> </web-copy-code><p>A <code>BidirectionalStream</code> is just a combination of a <code>SendStream</code> and <code>ReceiveStream</code>. The examples from the previous two sections explain how to use each of them.</p><h3 id="more-examples">More examples <a href="#more-examples">#</a></h3><p>The <a href="https://wicg.github.io/web-transport/" rel="noopener">WebTransport draft specification</a> includes a number of additional inline examples, along with full documentation for all of the methods and properties.</p><h3 id="webtransport-in-chromes-devtools">WebTransport in Chrome&#39;s DevTools <a href="#webtransport-in-chromes-devtools">#</a></h3><p>Unfortunately, <a href="https://developer.chrome.com/docs/devtools/" rel="noopener">Chrome&#39;s DevTools</a> do not currently support WebTransport. You can &#34;star&#34; <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1152290" rel="noopener">this Chrome issue</a> to be notified about updates on the DevTools interface.</p><h2 id="browser-support">Browser support <a href="#browser-support">#</a></h2><p>The WebTransport features described in this article are shipping in Chrome, Edge, and other Chromium-based browsers, starting with <a href="https://chromestatus.com/feature/4854144902889472" rel="noopener">version 97</a>.</p><p>Firefox does not currently have support for WebTransport. Updates on their position can be found in this <a href="https://github.com/mozilla/standards-positions/issues/167" rel="noopener">GitHub issue</a>.</p><p>Safari does not currently have support for WebTransport.</p><p>As with all features that do not have universal browser support, coding defensively via <a href="https://developer.mozilla.org/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection" rel="noopener">feature detection</a> is a best practice.</p><h2 id="polyfill">Polyfill <a href="#polyfill">#</a></h2><p>A polyfill (or rather ponyfill that provides functionality as a standalone module you can use) called <a href="https://github.com/fails-components/webtransport-ponyfill-websocket" rel="noopener"><code>webtransport-ponyfill-websocket</code></a> that implements some of the features of WebTransport is available. Carefully read the constraints in the project&#39;s <code>README</code> to determine if this solution can work for your use case.</p><h2 id="privacy-and-security-considerations">Privacy and security considerations <a href="#privacy-and-security-considerations">#</a></h2><p>See the <a href="https://wicg.github.io/web-transport/#privacy-security" rel="noopener">corresponding section</a> of the draft specification for authoritative guidance.</p><h2 id="feedback">Feedback <a href="#feedback">#</a></h2><p>The Chrome team wants to hear your thoughts and experiences using this API.</p><h3 id="feedback-about-the-api-design">Feedback about the API design <a href="#feedback-about-the-api-design">#</a></h3><p>Is there something about the API that&#39;s awkward or doesn&#39;t work as expected? Or are there missing pieces that you need to implement your idea?</p><p>File an issue on the <a href="https://github.com/WICG/web-transport/issues" rel="noopener">Web Transport GitHub repo</a>, or add your thoughts to an existing issue.</p><h3 id="problem-with-the-implementation">Problem with the implementation? <a href="#problem-with-the-implementation">#</a></h3><p>Did you find a bug with Chrome&#39;s implementation?</p><p>File a bug at <a href="https://new.crbug.com" rel="noopener">https://new.crbug.com</a>. Include as much detail as you can, along with simple instructions for reproducing.</p><h3 id="planning-to-use-the-api">Planning to use the API? <a href="#planning-to-use-the-api">#</a></h3><p>Your public support helps Chrome prioritize features, and shows other browser vendors how critical it is to support them.</p><ul><li>Send a tweet to <a href="https://twitter.com/chromiumdev" rel="noopener">@ChromiumDev</a> using the hashtag <a href="https://twitter.com/search?q=%23WebTransport&amp;src=typed_query&amp;f=live" rel="noopener"><code>#WebTransport</code></a> and details on where and how you&#39;re using it.</li></ul><h3 id="general-discussion">General discussion <a href="#general-discussion">#</a></h3><p>You can use the <a href="https://groups.google.com/a/chromium.org/g/web-transport-dev" rel="noopener">web-transport-dev Google Group</a> for general questions or problems that don&#39;t fit into one of the other categories.</p><h2 id="acknowledgements">Acknowledgements <a href="#acknowledgements">#</a></h2><p>This article incorporates information from the <a href="https://github.com/w3c/webtransport/blob/main/explainer.md" rel="noopener">WebTransport Explainer</a>, <a href="https://wicg.github.io/web-transport/" rel="noopener">draft specification</a>, and <a href="https://docs.google.com/document/d/1UgviRBnZkMUq4OKcsAJvIQFX6UCXeCbOtX_wMgwD_es/edit#" rel="noopener">related design docs</a>. Thank you to the respective authors for providing that foundation.</p><p><em>The hero image on this post is by <a href="https://unsplash.com/photos/dPgPoiUIiXk" rel="noopener">Robin Pierre</a> on Unsplash.</em></p><nav aria-label="tags"><a href="https://web.dev/tags/capabilities/">Capabilities</a><a href="https://web.dev/tags/network/">Network</a></nav><div><p><span> Last updated: <time>Jul 18, 2022</time> </span> â€” <a href="https://github.com/GoogleChrome/web.dev/blob/main/src/site/content/en/blog/webtransport/index.md"> Improve article </a></p></div></article></div>
  </body>
</html>
