<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://saashammer.com/blog/lightweight-javascript-framework-review-for-django-developers/">Original</a>
    <h1>Lightweight JavaScript Framework Review (For Django Developers)</h1>
    
    <div id="readability-page-1" class="page"><div>
<div data-controller="highlight toc smart-link">
<div>
<h2 id="introduction">Introduction</h2>
<p>Many developers are confused when they try to find a <code>Lightweight Javascript Framework</code> for the Django project because there are so many options.</p>
<p>In this post, I will talk and compare lightweight javascript frameworks, and help you decide which one is the best for your Django project.</p>
<p>If you want to:</p>
<ol>
<li>Render HTML in Django, and use Javascript to enhance the server-rendred HTML.</li>
<li>Say no to the heavy frontend solutions such as <code>React</code>, <code>Vue</code>, <code>Svelte</code>, <code>Angular</code></li>
<li>Say no to the <code>Decoupled Architecture</code></li>
</ol>
<p>Then this post can help you!</p>
<h2 id="why-this-post-is-unique">Why this Post is Unique</h2>
<p>Unlike other posts which only compare existing solutions in the Django community, I will also talk about solutions in other communities (Phoenix, Rails, Laravel) and how they influenced each other.</p>
<p>Below is a list of frameworks that I will talk about in this post</p>
<ol>
<li>Phoenix LiveView</li>
<li>Laravel Livewire</li>
<li>Hotwire (Turbo, Stimulus)</li>
<li>StimulusReflex</li>
<li>Catalyst</li>
<li>HTMX</li>
<li>Unpoly</li>
<li>Alpine.js</li>
<li>Django Reactor</li>
<li>Django Unicorn</li>
<li>django-sockpuppet</li>
<li>Tetra</li>
</ol>
<p>I hope that can help you get a better understanding.</p>
<h2 id="phoenix-liveview">Phoenix LiveView</h2>
<p><img src="https://saashammer.com/static/vendors/images/blog/light-javascript-framework/phoenix.png" width="800"/></p>
<p>At first, I&#39;d like to talk about <code>Phoenix LiveView</code>, because it is so important and inspired so many javascript frameworks.</p>
<blockquote>
<p>Phoenix is a web development framework written in the functional programming language Elixir.</p>
</blockquote>
<p><code>Phoenix LiveView</code> is library which enables <code>rich</code>, <code>real-time user experiences</code> with server-rendered HTML.</p>
<p>The <code>LiveView</code> applications are <code>stateful</code> due to the bidirectional communication with <code>WebSockets</code>.</p>
<p>Events in LiveView are regular messages which may cause changes to its state. Once the state changes, <code>LiveView</code> will re-render the relevant parts of its HTML template and push it back to the browser, which updates itself in the most efficient manner.</p>
<p>A LiveView begins as a regular HTTP request and HTML response, and then upgrades to a stateful view on client connect (Websocket). Any time a stateful view changes or updates its socket assigns, it is automatically re-rendered and the updates are pushed to the client.</p>
<p>For example, to react to a click on a button:</p>
<pre><code>&lt;button phx-click=&#34;inc_temperature&#34;&gt;+&lt;/button&gt;
</code></pre>
<p>On the server</p>
<pre><code>def handle_event(&#34;inc_temperature&#34;, _value, socket) do
  {:ok, new_temp} = Thermostat.inc_temperature(socket.assigns.id)
  {:noreply, assign(socket, :temperature, new_temp)}
end
</code></pre>
<p>After receiving the message, the server re-rendered the HTML, push it back to the client via Websocket, the page UI can be updated and user feel it is real-time.</p>
<p><img alt="Phoenix LiveView" src="https://saashammer.com/static/vendors/images/blog/light-javascript-framework/liveview.jpeg"/></p>
<p>With <code>LiveView</code>, in many cases, developers do not need to write a single line of JavaScript to build feature.</p>
<p>But you should also know, in some cases, developers still need to sprinkle JavaScript behavior directly into the HTML. For example, tabs, dropdowns, popovers and modals.</p>
<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/k4mSbCoBTPI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>
<h3 id="websocket">Websocket</h3>
<p>As we already know, <code>WebSocket</code> is very important in <code>Phoenix LiveView</code>, since it makes bidirectional communication between the client and the server possible.</p>
<blockquote>
<p>Elixir is a functional, <strong>concurrent</strong>, general-purpose programming language that runs on the BEAM virtual machine which is also used to implement the Erlang programming language. Elixir builds on top of Erlang and shares the same abstractions for building distributed, fault-tolerant applications</p>
</blockquote>
<p>You should also know, other programming languages such as PHP, Ruby, Python can not do the same as <code>Elixir</code> in the <code>Concurrency</code> area.</p>
<p>And you can check this post <a href="https://dockyard.com/blog/2016/08/09/phoenix-channels-vs-rails-action-cable">Phoenix Channels vs Rails Action Cable</a></p>
<p>So developers in other community usually solve the problem in this way:</p>
<ol>
<li>User trigger some event (click the button)</li>
<li>Use <code>HTTP</code> to transfer event from the client to the server. (not Websocket)</li>
<li>Server re-render the component HTML, and return HTML back in HTTP response.</li>
<li>Extract HTML from the HTTP response and update page UI.</li>
</ol>
<p>Next, let&#39;s take a look at some other javascript frameworks.</p>

<ul>
<li><a href="https://github.com/edelvalle/reactor/">Django Reactor</a> is a port of <code>Phoenix LiveView</code>, it depends on <code>Django channels</code>, a package which provides Websocket support.</li>
<li><a href="https://github.com/adamghill/django-unicorn">Django Unicorn</a> is inspired by Phoenix LiveView, but it does not depend on <code>Websocket</code>. When event fired on the browser, it sends <code>AJAX</code> request to the backend, and then use the response to update the page UI.</li>
</ul>
<p>For example, to react to a click on a button in <code>Django Unicorn</code></p>
<pre><code>&lt;button unicorn:click=&#34;increment&#34;&gt;+&lt;/button&gt;
</code></pre>
<p>The server component</p>
<pre><code>from django_unicorn.components import UnicornView


class ClicksView(UnicornView):
    count = 0

    def increment(self):
        self.count += 1
</code></pre>
<p>From Github stats, more people like <code>Django Unicorn</code> than <code>Reactor</code>, I guess that is because:</p>
<ol>
<li><code>Django Unicorn</code> does not depend on <code>Websocket</code>, which makes the infrastructure simpler.</li>
<li>The <code>attributes</code> (for example <code>unicorn:click</code>) is cleaner than using Django templatetag.</li>
</ol>

<p><img src="https://saashammer.com/static/vendors/images/blog/light-javascript-framework/laravel.svg" width="800"/></p>
<p><code>Laravel</code> is the most popular web framework in the PHP community.</p>
<p><a href="https://github.com/livewire/livewire">Laravel Livewire</a> is a full-stack framework for Laravel, which is also inspired by <code>Phoenix LiveView</code></p>
<p>Let&#39;s take a look at the <code>counter</code> example.</p>
<pre><code>&lt;button wire:click=&#34;increment&#34;&gt;+&lt;/button&gt;
</code></pre>
<p>The server side:</p>
<pre><code>class Counter extends Component
{
    public $count = 0;

    public function increment()
    {
        $this-&gt;count++;
    }

    public function render()
    {
        return view(&#39;livewire.counter&#39;);
    }
}
</code></pre>
<p><code>Livewire</code> also use HTTP to transfer data, but it can also work with <code>websocket</code> to provide real-time functionality.</p>
<p>Actually <code>Livewire</code> and <code>Alpine.js</code> are created by ONE developer, Caleb Porzio, they can work together very well and people in Laravel community usually choose this combination.</p>
<p>Below is a component, which use both <code>Livewire</code> and <code>Alpine.js</code>:</p>
<pre><code>&lt;div x-data=&#34;{ open: false }&#34;&gt;
    &lt;button @click=&#34;open = true&#34;&gt;Show More...&lt;/button&gt;

    &lt;ul x-show=&#34;open&#34; @click.outside=&#34;open = false&#34;&gt;
        &lt;li&gt;&lt;button wire:click=&#34;archive&#34;&gt;Archive&lt;/button&gt;&lt;/li&gt;
        &lt;li&gt;&lt;button wire:click=&#34;delete&#34;&gt;Delete&lt;/button&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<ol>
<li>The <code>Alpine.js</code> can do the pure frontend work.</li>
<li>The <code>Livewire</code> is used to communicate with the backend server.</li>
</ol>
<p>This project also inspired Django developers and there is a project <a href="https://www.tetraframework.com/">https://www.tetraframework.com/</a>, you can check if if you are interested.</p>
<p>Now we have seen some solutions which are inspired by <code>Phoenix LiveView</code>, next, let&#39;s take a look at another way to solve the Javascript issue.</p>
<h2 id="stimulus">Stimulus</h2>
<p><img src="https://saashammer.com/static/vendors/images/blog/light-javascript-framework/rails.svg" width="800"/></p>
<p><code>Stimulus</code> is part of the Rails official frontend solution <code>Hotwire</code>.</p>
<blockquote>
<p>Stimulus is a JavaScript framework with modest ambitions, is designed to enhance static or server-rendered HTML, by connecting JavaScript objects to elements on the page using simple annotations.</p>
</blockquote>
<p>These JavaScript objects are called <code>controllers</code>, and Stimulus continuously monitors the page waiting for HTML <code>data-controller</code> attributes to appear. For each attribute, Stimulus looks at the attribute’s value to find a corresponding controller class, creates a new instance of that class, and connects it to the element.</p>
<p>For example, we have HTML:</p>
<pre><code>&lt;div data-controller=&#34;hello&#34;&gt;
  &lt;input data-hello-target=&#34;name&#34; type=&#34;text&#34;&gt;
  &lt;button data-action=&#34;click-&gt;hello#greet&#34;&gt;Greet&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>And we have <code>hello_controller.js</code></p>
<pre><code>import { Controller } from &#34;@hotwired/stimulus&#34;

export default class extends Controller {
  static targets = [ &#34;name&#34; ]

  greet() {
    const element = this.nameTarget
    const name = element.value
    console.log(`Hello, ${name}!`)
  }
}
</code></pre>
<p>Notes:</p>
<ol>
<li>When Stimulus detect <code>data-controller=&#34;hello&#34;</code>, it will create a new controller instance from <code>hello_controller.js</code> and attach it to the HTML.</li>
<li><code>data-action=&#34;click-&gt;hello#greet&#34;</code> means, if user click the button, <code>great</code> method in <code>hello controller</code> will be executed to handle the JS event.</li>
</ol>
<p><code>Stimulus</code> is a pure frontend framework, and can be used with <strong>ANY</strong> backend framework.</p>
<ol>
<li>I highly recommend you to read <a href="https://m.signalvnoise.com/stimulus-1-0--a-modest-javascript-framework-for-the-html-you-already-have/">Stimulus 1.0: A modest JavaScript framework for the HTML you already have</a>, published in 2018, by DHH, the creator of Ruby on Rails.</li>
<li>You can also check <a href="https://stimulus.hotwired.dev/">Stimulus official doc</a> to learn more.</li>
</ol>
<h3 id="stimulusreflex">StimulusReflex</h3>
<p><code>StimulusReflex</code> extends capabilities of both <code>Rails</code> and <code>Stimulus</code> by intercepting user interactions and passing them to Rails over real-time websockets.</p>
<p><code>StimulusReflex</code> can make <code>Rails</code> app work like <code>Phoenix LiveView</code> (it is also inspired by <code>LiveView</code>), by using the <code>Rails ActionCable</code>, which integrates WebSockets with Rails.</p>
<p>For example:</p>
<pre><code>&lt;a href=&#34;#&#34;
  data-reflex=&#34;click-&gt;Counter#increment&#34;
  data-step=&#34;1&#34;
  data-count=&#34;&lt;%= @count.to_i %&gt;&#34;
&gt;Increment &lt;%= @count.to_i %&gt;&lt;/a&gt;
</code></pre>
<p>The <code>data-reflex</code> attribute allows us to map an action on the client to code that will be executed on the server.</p>
<pre><code>class CounterReflex &lt; ApplicationReflex
  def increment
    @count = element.dataset[:count].to_i + element.dataset[:step].to_i
  end
end
</code></pre>
<p>On the server, we use <code>element.dataset[:count]</code> to access the <code>data-count</code>, increment the value by 1 and set <code>@count</code>. The <code>Reflex</code> will then push the DOM back to client via Websocket. At last, client will update the page UI.</p>
<p>Please check <a href="https://docs.stimulusreflex.com/">https://docs.stimulusreflex.com/</a> to know more about StimulusReflex</p>
<p>This project also inspired Django developers and there is a project <a href="https://github.com/jonathan-s/django-sockpuppet">django-sockpuppet</a>, which is port of the StimulusReflex.</p>
<h3 id="turbo">Turbo</h3>
<p><code>Turbo</code> derived from Rails <code>Turbolinks</code> package, now it is also part of Rails official frontend solution (<code>Hotwire</code>).</p>
<blockquote>
<p>Stimulus pairs beautifully with Turbo to provide a complete solution for fast, compelling applications with a minimal amount of effort.</p>
</blockquote>
<p>One interesting feature brought by <code>Turbo</code> is <code>Turbo Stream</code></p>
<p>A Turbo Streams message is a fragment of HTML consisting of <code>&lt;turbo-stream&gt;</code> elements. The stream message below demonstrates the seven possible stream actions</p>
<pre><code>&lt;turbo-stream action=&#34;append&#34; target=&#34;messages&#34;&gt;
  &lt;template&gt;
    &lt;div id=&#34;message_1&#34;&gt;
      This div will be appended to the element with the DOM ID &#34;messages&#34;.
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/turbo-stream&gt;
</code></pre>
<p>With Turbo Stream, we can return HTML from the server to <code>manipunate</code> page DOM <strong>without using Javascript</strong>, this can let us build many powerful features such as <code>chat room</code>, <code>auto complete search box</code>, and etc.</p>
<p>Another feature of <code>Turbo</code> is <code>Turbo Frame</code></p>
<blockquote>
<p>Turbo Frames allow predefined parts of a page to be updated on request. Any links and forms inside a frame are captured, and the frame contents automatically updated after receiving a response</p>
</blockquote>
<p><code>Turbo Frame</code> provide an opportunity to decompose pages into self-contained fragments.</p>
<p>Both <code>Turbo Stream</code> and <code>Turbo Frame</code> are inspired by <code>Phoenix LiveView</code></p>
<p>I highly recommend you to check this youtube video <a href="https://www.youtube.com/watch?v=nMRtc0poYZI">What is Hotwire?</a></p>
<h3 id="catalyst">Catalyst</h3>
<blockquote>
<p>Web Components is a suite of different technologies allowing you to create reusable custom elements</p>
</blockquote>
<p>Stimulus inspired Catalyst <a href="https://github.com/github/catalyst">Catalyst</a>, GitHub’s web component set of patterns.</p>
<p><code>Github</code> is the web component lover, Stimulus inspired them to build Catalyst, which help developers to build web components using <code>Stimulus</code> like syntax.</p>
<p>The backend <code>Component</code> can have one-to-one relationship with frontend web component, allowing developers to work on a single abstraction for both front-end and backend.</p>
<pre><code>&lt;hello-world&gt;
  &lt;input data-target=&#34;hello-world.name&#34; type=&#34;text&#34;&gt;

  &lt;button data-action=&#34;click:hello-world#greet&#34;&gt;
    Greet
  &lt;/button&gt;

  &lt;span data-target=&#34;hello-world.output&#34;&gt;
  &lt;/span&gt;
&lt;/hello-world&gt;
</code></pre>
<pre><code>import { controller, target } from &#34;@github/catalyst&#34;

@controller
class HelloWorldElement extends HTMLElement {
  @target name: HTMLElement
  @target output: HTMLElement

  greet() {
    this.output.textContent = `Hello, ${this.name.value}!`
  }
}
</code></pre>
<p>Catalyst is a very interesting tech, and you can check links below to learn more.</p>
<ul>
<li><a href="https://github.github.io/catalyst/guide/introduction/">Catalyst doc</a></li>
<li><a href="https://github.blog/2021-05-04-how-we-use-web-components-at-github/">How we use Web Components at GitHub</a></li>
</ul>
<h2 id="htmx">HTMX</h2>
<blockquote>
<p>HTMX allows you to access AJAX, CSS Transitions, WebSockets and Server Sent Events directly in HTML, using attributes</p>
</blockquote>
<pre><code>&lt;button hx-post=&#34;/clicked&#34; hx-swap=&#34;outerHTML&#34;&gt;
  Click Me
&lt;/button&gt;
</code></pre>
<ol>
<li>The attributes have <code>hx</code> prefix</li>
<li>The above HTML code means: when a user clicks on this button, issue an AJAX request to <code>/clicked</code>, and replace the entire button with the response</li>
</ol>
<p>With HTMX, the workflow is very simple, client trigger event and send request, the server return HTML, and then the client update the page according to the response.</p>
<p>HTMX focus more on the communication between the server using Ajax, it seems like <code>Django Unicorn</code>, but the backend does not need to implement <code>stateful component</code>, just render HTML with Django view and get things done.</p>
<p>You can check <a href="https://htmx.org/examples/">https://htmx.org/examples/</a> to know more about HTMX.</p>
<p>There is a project <a href="https://unpoly.com/">Unpoly</a> which do similar work as HTMX, you can check if you are interested.</p>
<h2 id="alpinejs">Alpine.js</h2>
<blockquote>
<p>Alpine is a rugged, minimal tool for composing behavior directly in your markup.</p>
</blockquote>
<p>Let&#39;s check an example counter built by Alpine.js</p>
<pre><code>&lt;div x-data=&#34;{ count: 0 }&#34;&gt;
    &lt;button x-on:click=&#34;count++&#34;&gt;Increment&lt;/button&gt;
    &lt;span x-text=&#34;count&#34;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<ol>
<li>With <code>x-data</code>, we declared a counter component, which has <code>count=0</code></li>
<li><code>x-on:click</code> means if user click the button, the <code>count++</code> will run.</li>
<li><code>x-text=&#34;count&#34;</code> means the DOM element will display the <code>count</code> value of the component.</li>
</ol>
<p>As you can see, it is easy to use Alpine.js to sprinkle JavaScript behavior directly into the HTML.</p>
<p>Alpine.js directives syntax is very similar with <code>Vue.js</code>, because Vue.js is very popular in the PHP community.</p>
<p><code>Alpine.js</code> is a good option to deal with pure frontend stuff, for example: tabs, modals.</p>
<p>Please check <a href="https://alpinejs.dev/">https://alpinejs.dev/</a> if you want to know more about Alpine.js</p>
<h2 id="rough-comparison">Rough Comparison</h2>
<p>Now, we already know many lightweight javascript frameworks, next, we will compare some of them and find out some promising solutions.</p>
<h3 id="django-reactor">Django Reactor</h3>
<p>As we know, this package needs you to install <code>Django channels</code>, a package which provides Websocket support.</p>
<p>Compared with HTTP, Websocket needs more resources on the server (for example: redis connections), and make things more complicated when you need to <code>scale</code> your web application.</p>
<p>That is why I do not recommend any frontend framework which <strong>require</strong> Websocket (<code>Django Reactor</code>, <code>django-sockpuppet</code>)</p>
<p>Actually, if you take a look at <code>Laravel Livewire</code>, and <code>Hotwire</code> (official frontend framework in Rails community), they use <code>HTTP</code> to transfer data by default, and <code>Websocket</code> is optional.</p>
<h3 id="django-unicorn">Django Unicorn</h3>
<p><a href="https://github.com/adamghill/django-unicorn">Django Unicorn</a> use HTTP to transfer data, and the attributes are clean.</p>
<p>It can help the client do communication between the server using Ajax without writing Javascript.</p>
<p>If you want to sprinkle JavaScript behavior directly into the HTML (tabs, dropdowns, popovers and modals), you might still need vanilla javascript or other framework such as <code>Alpine.js</code></p>
<p><code>django-unicorn + Alpine.js</code> can be a promising solution.</p>
<h3 id="htmx_1">HTMX</h3>
<p>HTMX also focuses more on the <code>communication</code> between the server using Ajax. Unlike <code>Django Unicorn</code>, it is a generalized framework, and developers can user it with any backend framework.</p>
<p>When using HTMX with Django, developers can still use Django views to return HTML, no need to touch <code>component</code>, which is straightforward.</p>
<p>If you want to sprinkle JavaScript behavior directly into the HTML (tabs, dropdowns, popovers and modals), you have below options:</p>
<ol>
<li>Vanilla javascript</li>
<li>Alpine.js</li>
<li><a href="https://hyperscript.org/">hyperscript</a> is a sister project of HTMX</li>
</ol>
<p>From the community, many people like <code>HTMX + Alpine.js</code> solution, for example: <a href="https://django-htmx-alpine.nicholasmoen.com/">https://django-htmx-alpine.nicholasmoen.com/</a></p>
<p><code>HTMX + Alpine.js</code> can be a promising solution.</p>
<h3 id="hotwire-turbo-stimulus">Hotwire (Turbo + Stimulus)</h3>
<p>As we know, <code>Hotwire</code> is the official frontend solution in the Rails community, which includes <code>Turbo</code> and <code>Stimulus</code>.</p>
<p>The <code>Turbo</code> package contains:</p>
<ol>
<li><code>Turbo Drive</code> accelerates links and form submissions by negating the need for full page reloads. Which bring <code>SPA</code> experience to our app.</li>
<li><code>Turbo Frames</code> decompose pages into independent contexts, which scope navigation and can be lazily loaded.</li>
<li><code>Turbo Streams</code> deliver page changes over WebSocket, SSE or in response to form submissions using just HTML and a set of CRUD-like actions.</li>
<li><code>Turbo Native</code> help build hybrid apps for iOS and Android</li>
</ol>
<p>The <code>Stimulus</code> is designed to enhance static or server-rendered HTML, by connecting JavaScript objects to elements on the page using simple annotations</p>
<ol>
<li>We can see <code>Turbo</code> as a competitor of <code>HTMX</code>, they communicate with the backend server.</li>
<li><code>Stimulus</code> can be seen as a competitor of <code>Alpine.js</code>, they do pure frontend work.</li>
</ol>
<p><code>Hotwire</code> can be used with <strong>ANY</strong> backend framework, and it is also very popular in the PHP community (Symfony).</p>
<p>So <code>Turbo + Stimulus</code> can be a promising solution.</p>
<h2 id="which-solution-should-i-choose">Which Solution Should I Choose</h2>
<p>Now we got below promising solutions:</p>
<ol>
<li><code>django-unicorn + Alpine.js</code></li>
<li><code>HTMX + Alpine.js</code></li>
<li><code>Turbo + Stimulus</code> (<code>Hotwire</code>)</li>
</ol>
<p>In the Django community, it seems <code>HTMX + Alpine.js</code> is more popular than <code>django-unicorn + Alpine.js</code>, since they are similar, I will only talk about <code>HTMX + Alpine.js</code> in the next sections. If you prefer <code>django-unicorn</code>, please feel free to switch.</p>
<p>Next, I will compare <code>HTMX + Alpine.js</code> with <code>Turbo + Stimulus</code>.</p>
<h3 id="ecosystem">Ecosystem</h3>
<p>Let&#39;s first take a look at <code>Hotwire</code>.</p>
<p><code>Hotwire</code> is the official frontend framework in Rails, it is build by people at Basecamp, and powers the <code>Basecamp</code>, <code>HEY</code> email service. (and other Rails web applications)</p>
<p>Both <code>Basecamp</code> and <code>HEY</code> are large web applications, which means <code>Hotwire</code> is solid and <strong>works good as your codebase grow bigger and bigger.</strong></p>
<p>And there are many high quality tutorials, open source projects about <code>Hotwire</code>. Since <code>Hotwire</code> is pure frontend framework, we can easily make them work with any backend web frameworks. (<code>Symfony</code>, <code>Django</code>, <code>Flask</code>...)</p>
<ol>
<li><a href="https://github.com/skatkov/awesome-stimulusjs">Awesome StimulusJS</a></li>
<li><a href="https://turbo-showcase.herokuapp.com/">Turbo Showcase</a></li>
<li><a href="https://thoughtbot.com/blog/tags/hotwire">https://thoughtbot.com/blog/tags/hotwire</a></li>
</ol>
<p>Backed by Rails community and some successful business companies, <code>Hotwire</code> has healthy ecosystem.</p>
<p>In most cases, if you meet problem, you can easily find answer at StackOverflow, someone&#39;s blog, or Github.</p>
<p>Next, let&#39;s take a look at <code>Alpine.js</code> and <code>HTMX</code></p>
<p><code>Alpine.js</code> is very popular, and there are many resources about it.</p>
<p>From what I see, most of the blogs, videos, open sources projects about HTMX, come from Python developers (Django, Flask), I guess that is because <code>Laravel</code> and <code>Rails</code> already have default frontend solution, so most developers would not try HTMX.</p>
<p>I tried to find what business companies that are using <code>Alpine.js + HTMX</code> to build what products, but I can not find that info.</p>
<p>So the ecosystem of <code>Hotwire</code> seems better than <code>Alpine.js + HTMX</code>, and the <strong>large web applications give developers confidence that they can stick with it as the project grow.</strong></p>
<h3 id="difficulty-of-installation">Difficulty of Installation</h3>
<p><code>HTMX + Alpine.js</code> is easy to install, we can import via CDN link, no need transpile or bundle solution.</p>
<pre><code>&lt;script src=&#34;https://unpkg.com/<a href="https://saashammer.com/cdn-cgi/l/email-protection" data-cfemail="e38b978e9bcd8c9184a3d2cdd4cdd3">[email protected]</a>&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://unpkg.com/<a href="https://saashammer.com/cdn-cgi/l/email-protection" data-cfemail="751419051c1b101f0635465b0d5b0d">[email protected]</a>/dist/cdn.min.js&#34;&gt;&lt;/script&gt;
</code></pre>
<p>And then you can write code to enhance the HTML, which is cool!</p>
<p>To install <code>Turbo + Stimulus</code> in your Django project, now you need a bundle solution.</p>
<p>Some Django developers complain they do not like to touch tedious Webpack config or frontend config stuff. Fortunately, the project <a href="https://github.com/AccordBox/python-webpack-boilerplate">python-webpack-boilerplate</a> can help you create frontend project which bundled by Webpack within minutes, even you have no idea how to config Webpack.</p>
<p><code>python-webpack-boilerplate</code> also has detailed doc and pre-defined config to help you keep Javascript and CSS/SCSS in good style.</p>
<p>From <code>Rails 7</code>, it introduced a new tech <code>importmap</code> to use JavaScript libraries made for ES modules (ESM) without the need for transpiling or bundling.</p>
<p>In the future, Django developers can switch to <code>importmap</code> and drop the Webpack, and some people already did attempt. <a href="https://github.com/dropseed/django-importmap">django-importmap</a></p>
<p>So <code>HTMX + Alpine.js</code> is easy to install than <code>Turbo + Stimulus</code>, but <strong>many people overestimate the difficulty</strong>.</p>
<p>Because I am pretty sure a beginner Django developer can use <a href="https://github.com/AccordBox/python-webpack-boilerplate">python-webpack-boilerplate</a> to install <code>Turbo + Stimulus</code> within ONE hour.</p>
<h3 id="directives-or-vanilla-javascript">Directives or Vanilla Javascript</h3>
<p><code>HTMX</code> has about 30 custom attributes (also called <code>directives</code>).</p>
<p><code>Alpine.js</code> has about 18 custom attributes (also called <code>directives</code>).</p>
<p>For some people, <code>directives</code> is the killer feature, which can let them get things done directly in the template.</p>
<p>However, the <code>directives</code> adds a new layer of complexity, even people who already learned Javascript, still need to learn the syntax (for example, what does <code>hx-trigger=&#34;keyup changed delay:1s&#34;</code> mean?).</p>
<p>The <code>Stimulus</code> in <code>Hotwire</code> only use attributes to pass value from the server-rendered HTML to the <code>Stimulus Controller</code>, and the <code>Stimulus Controller</code> is written with normal Javascript syntax, which is more friendly to Javascript people.</p>
<h3 id="encapsulation">Encapsulation</h3>
<p>About 10 years ago, when we build web application, we are told we better <strong>decouple HTML, CSS, and JavaScript</strong></p>
<p>At that time, we write Javascript code in a separate JS file with the help of framework such as <code>jQuery</code>.</p>
<ol>
<li>If we want to change content, we edit HTML</li>
<li>If we want to change style, we edit CSS</li>
<li>If we want to change frontend behavior, we change Javascript.</li>
</ol>
<p>Let&#39;s take a look at the Alpine.js official Dropdown component</p>
<pre><code>&lt;div class=&#34;flex justify-center&#34;&gt;
    &lt;div
        x-data=&#34;{
            open: false,
            toggle() {
                if (this.open) {
                    return this.close()
                }

                this.$refs.button.focus()

                this.open = true
            },
            close(focusAfter) {
                if (! this.open) return

                this.open = false

                focusAfter &amp;&amp; focusAfter.focus()
            }
        }&#34;
        x-on:keydown.escape.prevent.stop=&#34;close($refs.button)&#34;
        x-on:focusin.window=&#34;! $refs.panel.contains($event.target) &amp;&amp; close()&#34;
        x-id=&#34;[&#39;dropdown-button&#39;]&#34;
        class=&#34;relative&#34;
    &gt;
        &lt;!-- Button --&gt;
        &lt;button
            x-ref=&#34;button&#34;
            x-on:click=&#34;toggle()&#34;
            :aria-expanded=&#34;open&#34;
            :aria-controls=&#34;$id(&#39;dropdown-button&#39;)&#34;
            type=&#34;button&#34;
            class=&#34;bg-white px-5 py-2.5 rounded-md shadow&#34;
        &gt;
            &lt;span&gt;Actions&lt;/span&gt;
            &lt;span aria-hidden=&#34;true&#34;&gt;&amp;darr;&lt;/span&gt;
        &lt;/button&gt;

    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Notes:</p>
<ol>
<li>This is part of the full code.</li>
<li><strong>Do you really believe writing Javascript in your template file is a good idea?</strong></li>
<li>If you check the code after 1 month, could you quickly understand what the Alpine.js component do?</li>
<li>If you need to update some logic, you might need to change multiple templates?</li>
</ol>
<p>Even Alpine.js provides a way to register component (<code>Alpine.data</code>), so developers can reuse the code. From what I see, very few Django developers do that.</p>
<p><code>Stimulus</code> encourage developers to write Javascript in <code>.js</code>, and one controller is for one <code>one type of work</code>. (For example: <code>dropdown_controller.js</code>), this helps the frontend code better organized.</p>
<p>After you write some Stimulus components, you can <strong>reuse</strong> them in convenient way.</p>
<p>You can check <a href="https://www.stimulus-components.com/">Stimulus Components</a>, which can help you understand and follow the <code>DRY</code> (Don&#39;t Repeat Yourself) principle with Stimulus.</p>
<h3 id="code-quality-code-linting">Code Quality, Code Linting</h3>
<p><img src="https://saashammer.com/static/vendors/images/blog/light-javascript-framework/ts_logo.png"/></p>
<blockquote>
<p>TypeScript is a strict syntactical superset of JavaScript and adds optional static typing to the language.</p>
</blockquote>
<p>Both <code>Stimulus</code> and <code>Turbo</code> are written with TypeScript,</p>
<p>And you can also write Stimulus controller with <code>TypeScript</code></p>
<p><a href="https://github.com/stimulus-use/stimulus-use">https://github.com/stimulus-use/stimulus-use</a> is an interesting project, it learned from <code>React Hook</code> and bring the <code>use</code> syntax to Stimulus. So we can just write callback method in the Stimulus controller.</p>
<p>As a 3-party package which will be used by other people, it is written in TypeScript, to improve the code quality.</p>
<p>Since the Stimulus Controller is a Javascript file, developers can also use mature code linting tool such as <code>Eslint</code> and <code>Prettier</code> to keep the Javascript code in good style.</p>
<p>Let&#39;s take a look at <code>Alpine.js + HTMX</code></p>
<ol>
<li>Both <code>Alpine.js</code> and <code>HTMX</code> are written with regular Javascript.</li>
<li>Some people also shared TypeScript solution in Alpine.js, but very few people use it.</li>
<li>The code linting tool can not help you detect Javascript very well in the template.</li>
</ol>
<h3 id="learning-curve">Learning Curve</h3>
<p><code>Alpine.js + HTMX</code> is <strong>easy to install and get started</strong>, but things might become a little complicated as your project grow.</p>
<p><code>Turbo + Stimulus</code> is a little hard to install and get started, but once you understand the concepts, the rest is to build feature with Vanilla javascript. You do not need to remember custom directives such as (<code>hx-trigger</code>, <code>hx-get</code>, <code>hx-post</code>), or the argument syntax such as <code>keyup changed delay:1s</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>If you want to start quickly (prototyping) and do not like to <strong>learn</strong> Javascript, you can choose <code>Alpine.js + HTMX</code> (or <code>Alpine.js + django-unicorn</code>).</p>
<p>If you do not mind learning some Javascript, and want a <strong>solid</strong> solution, please try <code>Hotwire</code>. You might feel slow at first, but after you learn it, you will like it and <strong>you do not need to switch to another solution</strong> until your product exceed the size of <code>https://basecamp.com/</code>, or <code>https://www.hey.com/</code></p>
<h2 id="faq">FAQ</h2>
<h3 id="are-there-good-learning-resources-about-hotwire-and-django">Are there good learning resources about Hotwire and Django?</h3>
<p>I released a book to help people to learn Hotwire with Django in a systematic way, please check <a href="https://leanpub.com/hotwire-django">The Definitive Guide to Hotwire and Django</a></p>
<h3 id="should-i-use-turbo-and-stimulus-together">Should I use Turbo and Stimulus together?</h3>
<p>They are built to solve different problems, and you can use one of them in your project.</p>
<p>For example, you can use <code>Stimulus</code> as a replacement of jQuery.</p>
<p>If possible, you better use them together for better user experience.</p>
</div>
</div>
</div></div>
  </body>
</html>
