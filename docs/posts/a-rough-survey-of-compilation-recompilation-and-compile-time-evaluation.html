<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scattered-thoughts.net/writing/a-rough-survey-of-compilation-recompilation-and-compile-time-evaluation/">Original</a>
    <h1>A rough survey of compilation, recompilation, and compile-time evaluation</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>(<em>This is part of a series on the design of <a href="https://github.com/jamii/zest">zest</a>. See the list of posts <a href="https://www.scattered-thoughts.net/#zest">here</a></em>.)</p>
<p>Questions include:</p>
<ul>
<li>Is compilation deterministic? Can the output vary depending on the target platform? On environment variables? On the time of day? On the order in which modules are compiled?</li>
<li>Is incremental compilation possible? Does it have well-defined semantics or does the output depend on the order in which changes are made?</li>
<li>Can compilation be parallelized, or does the order of compilation matter?</li>
<li>Are there well-defined semantics for changing code in a running process? What happens to old closures and old types?</li>
<li>How does compile-time evaluation interact with binding? Can compile-time code create new bindings or modules? Are all declarations evaluated, or only reachable declarations, or are they evaluated lazily at runtime?</li>
<li>Is it possible to determine at compile-time what declarations are reachable, or can runtime reflection reach any declaration? Is it possible to tree-shake ie only emit code for declarations that are reachable?</li>
<li>If values are constructed at compile-time and used at runtime, how are they moved/serialized between stages?</li>
<li>Does code always behave the same when evaluated at compile-time vs runtime, or are there different dialects?</li>
<li>What happens if compile-time evaluation doesn&#39;t terminate?</li>
</ul>
<p>See <a href="https://www.scattered-thoughts.net/writing/there-are-no-strings-on-me/">there are no strings on me</a> for context.</p>
<p>Not covering every language under the sun. Mostly focusing on languages where I have real experience, plus a smattering of interesting unfamiliar languages at the end.</p>
<p>I&#39;m interested in <a href="mailto:jamie@scattered-thoughts.net">hearing about</a> languages where the answers to the questions above differ significantly from the languages below.</p>
<h2 id="zig">zig</h2>
<pre><code><span>&gt; zig version
</span><span>0.14.0
</span></code></pre>
<p>Every type has an associated namespace.</p>
<pre data-lang="zig"><code data-lang="zig"><span>const </span><span>Foo </span><span>= </span><span>struct </span><span>{
</span><span>    x</span><span>: </span><span>usize</span><span>, </span><span>// instances of Foo will have a field `x`
</span><span>
</span><span>    </span><span>pub const</span><span> bar </span><span>= </span><span>1</span><span>; </span><span>// this is a constant attached to the Foo type
</span><span>    </span><span>pub fn </span><span>quux</span><span>() </span><span>void </span><span>{} </span><span>// this is a function attached to the Foo type
</span><span>}</span><span>;
</span></code></pre>
<p><code>@import(&#34;./foo.zig&#34;)</code> returns a struct type whose associated namespace contains all the public top-level declarations in that file. Every call to <code>@import(&#34;./foo.zig&#34;)</code> returns the same struct type, so circular imports are fine.</p>
<p>Types are first-class values in the compile-time dialect but cannot be referenced at all in the runtime dialect. This enables a fair amount of meta-programming at compile-time without giving up precise tree-shaking.</p>
<p>Declarations are wrapped in a lazy thunk and only forced if either evaluated at compile-time, or reachable from exported functions after specialization and compile-time evaluation.</p>
<pre data-lang="zig"><code data-lang="zig"><span>const</span><span> foo </span><span>= </span><span>1 </span><span>/ </span><span>0</span><span>; </span><span>// this is fine because it&#39;s not reachable
</span><span>
</span><span>const</span><span> bar </span><span>= </span><span>1 </span><span>/ </span><span>0</span><span>; </span><span>// this is an error becauses it&#39;s reachable
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    bar</span><span>;
</span><span>}
</span></code></pre>
<p>Bindings are resolved eagerly at parse-time:</p>
<pre data-lang="zig"><code data-lang="zig"><span>fn </span><span>foo</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>nonsense</span><span>()</span><span>; </span><span>// error
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{}
</span></code></pre>
<p>But accessing a declaration from a namespace is resolved only when evaluated or reachable:</p>
<pre data-lang="zig"><code data-lang="zig"><span>const </span><span>real </span><span>= </span><span>struct </span><span>{}</span><span>;
</span><span>
</span><span>fn </span><span>foo</span><span>(</span><span>x</span><span>: </span><span>usize</span><span>) </span><span>void </span><span>{
</span><span>    </span><span>if </span><span>(x </span><span>== </span><span>0</span><span>) {
</span><span>        real.</span><span>nonsense</span><span>()</span><span>;
</span><span>    }
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>comptime </span><span>foo</span><span>(</span><span>42</span><span>)</span><span>; </span><span>// ok, because branch body isn&#39;t evaluated
</span><span>    </span><span>foo</span><span>(</span><span>42</span><span>)</span><span>; </span><span>// error, because branch body is reachable
</span><span>}
</span></code></pre>
<p>Declarations can be mutually recursive. The runtime detects cycles:</p>
<pre data-lang="zig"><code data-lang="zig"><span>// error: struct &#39;test.T&#39; depends on itself
</span><span>const </span><span>T </span><span>= </span><span>struct </span><span>{
</span><span>    a</span><span>: </span><span>if </span><span>(</span><span>@sizeOf</span><span>(T) </span><span>== </span><span>8</span><span>) u32 </span><span>else</span><span> u64</span><span>,
</span><span>}</span><span>;
</span></code></pre>
<p>Compile-time evaluation is deterministic and cannot perform side-effects (but can access variables set by the build file for conditional compilation).</p>
<pre data-lang="zig"><code data-lang="zig"><span>fn </span><span>foo</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>).debug.</span><span>print</span><span>(</span><span>&#34;hello!&#34;</span><span>,</span><span> .{})</span><span>;
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>comptime </span><span>foo</span><span>()</span><span>; </span><span>// error, no printing at compile-time
</span><span>    </span><span>foo</span><span>()</span><span>; </span><span>// ok, printing is allowed at runtime
</span><span>}
</span></code></pre>
<p>Compile-time evaluation emulates the target platform, so cross-compilation works naturally.</p>
<pre data-lang="zig"><code data-lang="zig"><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>const</span><span> comptime_word_size </span><span>= </span><span>comptime </span><span>@typeInfo</span><span>(usize).int.bits</span><span>;
</span><span>    </span><span>const</span><span> runtime_word_size </span><span>= </span><span>@typeInfo</span><span>(usize).int.bits</span><span>;
</span><span>    </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>).debug.</span><span>assert</span><span>(comptime_word_size </span><span>==</span><span> runtime_word_size)</span><span>;
</span><span>}
</span></code></pre>
<p>It&#39;s intended that the order of declarations and the order of their lazy evaluation does not matter. At the time of writing it&#39;s possible to observe the order of evaluation using <code>usingnamespace</code>, but this is slated to be <a href="https://github.com/ziglang/zig/issues/20663">removed</a>.</p>
<pre data-lang="zig"><code data-lang="zig"><span>const </span><span>T1 </span><span>= </span><span>struct </span><span>{
</span><span>    </span><span>pub const</span><span> x </span><span>= </span><span>0</span><span>;
</span><span>}</span><span>;
</span><span>
</span><span>const </span><span>T2 </span><span>= </span><span>struct </span><span>{
</span><span>    </span><span>const</span><span> a </span><span>= </span><span>@typeInfo</span><span>(T2).@</span><span>&#34;struct&#34;</span><span>.decls.len</span><span>; </span><span>// evaluated before `usingnamepsace` so doesn&#39;t include `x`
</span><span>    </span><span>pub usingnamespace </span><span>(</span><span>if </span><span>(a </span><span>== </span><span>0</span><span>) T1 </span><span>else</span><span> T1)</span><span>; </span><span>// depends on `a` so forces `a` to be evaluated earlier
</span><span>    </span><span>const</span><span> b </span><span>= </span><span>@typeInfo</span><span>(T2).@</span><span>&#34;struct&#34;</span><span>.decls.len</span><span>; </span><span>// evaluated after `usingnamespace` so includes `x`
</span><span>}</span><span>;
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>).debug.</span><span>assert</span><span>(T2.a </span><span>== </span><span>0</span><span>)</span><span>;
</span><span>    </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>).debug.</span><span>assert</span><span>(T2.b </span><span>== </span><span>1</span><span>)</span><span>;
</span><span>}
</span></code></pre>
<p>Comptime zig is a slightly different dialect from runtime zig, so staging affects behaviour:</p>
<pre data-lang="zig"><code data-lang="zig"><span>const </span><span>List </span><span>= </span><span>struct </span><span>{
</span><span>    next</span><span>: </span><span>?*</span><span>const List</span><span>,
</span><span>}</span><span>;
</span><span>
</span><span>fn </span><span>list</span><span>(</span><span>n</span><span>: </span><span>usize</span><span>) </span><span>*</span><span>const List </span><span>{
</span><span>    </span><span>return </span><span>&amp;</span><span>List</span><span>{ .next </span><span>= </span><span>if </span><span>(n </span><span>== </span><span>0</span><span>) </span><span>null </span><span>else </span><span>list</span><span>(n </span><span>- </span><span>1</span><span>) }</span><span>;
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>).debug.</span><span>print</span><span>(</span><span>&#34;{}</span><span>\n</span><span>&#34;</span><span>,</span><span> .{</span><span>comptime </span><span>list</span><span>(</span><span>3</span><span>)})</span><span>;
</span><span>    </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>).debug.</span><span>print</span><span>(</span><span>&#34;{}</span><span>\n</span><span>&#34;</span><span>,</span><span> .{</span><span>list</span><span>(</span><span>3</span><span>)})</span><span>;
</span><span>}
</span></code></pre>
<pre><code><span>test.List{ .next = test.List{ .next = test.List{ .next = test.List{ ... } } } }
</span><span>test.List{ .next = test.List{ .next = General protection exception (no address available)
</span></code></pre>
<p>In the <code>list</code> function above, at comptime each list node is heap-allocated and garbage-collected, but at runtime each list node is stack-allocated and returning a pointer to a node is UB.</p>
<p>Arbitrary data-structures can be passed from compile-time to runtime, and are baked into the executable&#39;s constant section. To guarantee deterministic compilation, code evaluated at compile-time is not allowed to convert pointers to integers.</p>
<p>Type can be parameterized by arbitrary values.</p>
<pre data-lang="zig"><code data-lang="zig"><span>fn </span><span>T</span><span>(</span><span>comptime </span><span>param</span><span>: </span><span>anytype</span><span>) </span><span>type </span><span>{
</span><span>    </span><span>return struct </span><span>{
</span><span>        </span><span>pub const</span><span> value </span><span>=</span><span> param</span><span>;
</span><span>    }</span><span>;
</span><span>}
</span></code></pre>
<p>I don&#39;t think the equality rules for such type parameters are documented? From some experimentation, it seems that:</p>
<ul>
<li>Parameters of different types are not equal.</li>
<li>Parameters of the same type are compared by structural equality.</li>
<li>Types are not allowed to close over pointers to mutable variables.</li>
<li>Constructing cyclic parameters using const declarations is detected as a dependency loop.</li>
</ul>
<p>Excessive compile-time computation is detected by counting the number of backwards edges traversed by the interpreter.</p>
<pre data-lang="zig"><code data-lang="zig"><span>fn </span><span>wide</span><span>(</span><span>n</span><span>: </span><span>usize</span><span>) </span><span>usize </span><span>{
</span><span>    </span><span>if </span><span>(n </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>0</span><span>;
</span><span>    } </span><span>else </span><span>{
</span><span>        </span><span>return </span><span>wide</span><span>(n </span><span>- </span><span>1</span><span>) </span><span>+ </span><span>wide</span><span>(n </span><span>- </span><span>1</span><span>)</span><span>;
</span><span>    }
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>comptime </span><span>wide</span><span>(</span><span>30</span><span>)</span><span>;
</span><span>}
</span></code></pre>
<pre><code><span>&gt; zig run test.zig
</span><span>test.zig:5:20: error: evaluation exceeded 1000 backwards branches
</span><span>        return wide(n - 1) + wide(n - 1);
</span><span>               ~~~~^~~~~~~
</span><span>test.zig:5:20: note: use @setEvalBranchQuota() to raise the branch limit from 1000
</span><span>test.zig:5:20: note: called from here (23 times)
</span><span>test.zig:5:34: note: called from here (5 times)
</span><span>        return wide(n - 1) + wide(n - 1);
</span><span>                             ~~~~^~~~~~~
</span><span>test.zig:10:18: note: called from here
</span><span>    comptime wide(30);
</span><span>             ~~~~^~~~
</span><span>referenced by:
</span><span>    posixCallMainAndExit: /nix/store/5yjsvw9r543c8h1mq6ylcgk6w3aphwb2-zig/lib/std/start.zig:647:22
</span><span>    _start: /nix/store/5yjsvw9r543c8h1mq6ylcgk6w3aphwb2-zig/lib/std/start.zig:464:40
</span><span>    3 reference(s) hidden; use &#39;-freference-trace=5&#39; to see all references
</span></code></pre>
<p>The limit can be raised locally with <a href="https://ziglang.org/documentation/master/#toc-setEvalBranchQuota">setEvalBranchQuota</a>. This is nicely composable - if I test that I&#39;ve raised the quota enough within my library, I don&#39;t have to worry that users of my library will hit errors from adding their own compile-time computation.</p>
<h2 id="rust">rust</h2>
<pre><code><span>&gt; rustc --version
</span><span>rustc 1.82.0 (f6e511eec 2024-10-15)
</span></code></pre>
<p>Modules are entirely second-class and there is no way to refer to a module directly. Cyclic dependencies are allowed between different modules in the same crate.</p>
<p>A limited subset of the language is available at compile time for defining constants and type parameters.</p>
<p>All constants are evaluated strictly, even if not reachable.</p>
<pre data-lang="rust"><code data-lang="rust"><span>// error: attempt to divide `1_usize` by zero
</span><span>const</span><span> x</span><span>: </span><span>usize </span><span>= </span><span>1</span><span>/</span><span>0</span><span>;
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>-&gt; </span><span>() {}
</span></code></pre>
<p>Cycles are detected statically, rather than dynamically as in zig ie unreachable code can still trigger cycle detection.</p>
<pre data-lang="rust"><code data-lang="rust"><span>// error: cycle detected when simplifying constant for the type system `x`
</span><span>const</span><span> x</span><span>: </span><span>usize </span><span>=</span><span> y</span><span>;
</span><span>
</span><span>const</span><span> y</span><span>: </span><span>usize </span><span>= </span><span>if </span><span>false </span><span>{x} </span><span>else </span><span>{</span><span>1</span><span>}</span><span>;
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>-&gt; </span><span>() {}
</span></code></pre>
<p>This means that cycle detection doesn&#39;t depend on eg what platform the code is compiled on, but on the other hand requires a separate macro system for conditional compilation.</p>
<p>Compile-time constants are also type-checked before evaluation.</p>
<pre data-lang="rust"><code data-lang="rust"><span>// error: expected `usize`, found `&amp;str`
</span><span>const</span><span> x</span><span>: </span><span>usize </span><span>= </span><span>if </span><span>false </span><span>{</span><span>&#34;foo&#34;</span><span>} </span><span>else </span><span>{</span><span>1</span><span>}</span><span>;
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>-&gt; </span><span>() {}
</span></code></pre>
<p>Long running const fns are detected by the interpreter. Rust doesn&#39;t currently provide the whole stack trace, although I&#39;m sure they could provide an option for that.</p>
<pre data-lang="rust"><code data-lang="rust"><span>const fn </span><span>wide</span><span>(</span><span>n</span><span>: </span><span>usize</span><span>) </span><span>-&gt; </span><span>usize </span><span>{
</span><span>    </span><span>if</span><span> n </span><span>== </span><span>0 </span><span>{
</span><span>       </span><span>0
</span><span>    } </span><span>else </span><span>{
</span><span>       </span><span>wide</span><span>(n</span><span>-</span><span>1</span><span>) </span><span>+ </span><span>wide</span><span>(n</span><span>-</span><span>1</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span>// error: constant evaluation is taking a long time
</span><span>const</span><span> x</span><span>: </span><span>usize </span><span>= </span><span>wide</span><span>(</span><span>30</span><span>)</span><span>;
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>-&gt; </span><span>() {}
</span></code></pre>
<pre><code><span>&gt; cargo run --bin main
</span><span>   Compiling testrs v0.1.0 (/home/jamie/testrs)
</span><span>error: constant evaluation is taking a long time
</span><span>  --&gt; src/bin/main.rs:5:8
</span><span>   |
</span><span>5  |        wide(n-1) + wide(n-1)
</span><span>   |        ^^^^^^^^^
</span><span>   |
</span><span>   = note: this lint makes sure the compiler doesn&#39;t get stuck due to infinite loops in const eval.
</span><span>           If your compilation actually takes a long time, you can safely allow the lint.
</span><span>help: the constant being evaluated
</span><span>  --&gt; src/bin/main.rs:10:1
</span><span>   |
</span><span>10 | const x: usize = wide(25);
</span><span>   | ^^^^^^^^^^^^^^
</span><span>   = note: `#[deny(long_running_const_eval)]` on by default
</span></code></pre>
<p>I couldn&#39;t find any actual documentation on the limits, but the <a href="https://github.com/rust-lang/rust/commit/23f93a1266e0530445db590c15e0bb5c1c624eb6">commit</a> introducing this error mentions counting function calls and back-edges.</p>
<p>The errors can be downgraded to warnings by annotating the const value with <code>#[allow(long_running_const_eval)]</code>. Putting this annotation on a const function doesn&#39;t seem to have any effect though - it has to be on the const value that the error was attributed to.</p>
<h2 id="julia">julia</h2>
<pre><code><span>&gt; julia --version
</span><span>julia version 1.11.3
</span></code></pre>
<p>Modules are declared with <code>module ... end</code>. Modules don&#39;t inherit their enclosing scope but can access it explicitly with <code>parentmodule</code>.</p>
<pre data-lang="julia"><code data-lang="julia"><span>x </span><span>= </span><span>1
</span><span>
</span><span>module</span><span> Test
</span><span>
</span><span>print(x) </span><span>//</span><span> error
</span><span>print(parentmodule(Test)</span><span>.</span><span>x) </span><span>//</span><span> ok
</span><span>
</span><span>end
</span></code></pre>
<p>The module system has no relation to files. <code>include(&#34;foo.jl&#34;)</code> behaves exactly like textual inclusion and doesn&#39;t require creating a module. Using <code>include(&#34;foo.jl&#34;)</code> in the repl is equivalent to copy-and-pasting the contents of <code>foo.jl</code>.</p>
<p>Modules have identity. Redefining a module simply rebinds the name to a new module, but does not affect the old module.</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt; </span><span>module</span><span> Foo; x </span><span>= </span><span>1</span><span>; </span><span>end
</span><span>WARNING</span><span>:</span><span> replacing </span><span>module</span><span> Foo.
</span><span>Main.Foo
</span><span>
</span><span>julia</span><span>&gt; </span><span>module</span><span> Bar; p() </span><span>=</span><span> print(Main.Foo.x); </span><span>end
</span><span>Main.Bar
</span><span>
</span><span>julia</span><span>&gt;</span><span> Bar.p()
</span><span>1
</span><span>julia</span><span>&gt;</span><span> Foo.x </span><span>= </span><span>2
</span><span>2
</span><span>
</span><span>julia</span><span>&gt;</span><span> Bar.p()
</span><span>2
</span><span>julia</span><span>&gt;</span><span> OldFoo </span><span>=</span><span> Foo
</span><span>Main.Foo
</span><span>
</span><span>julia</span><span>&gt; </span><span>module</span><span> Foo; x </span><span>= </span><span>3</span><span>; </span><span>end
</span><span>WARNING</span><span>:</span><span> replacing </span><span>module</span><span> Foo.
</span><span>Main.Foo
</span><span>
</span><span>julia</span><span>&gt;</span><span> OldFoo.x
</span><span>2
</span><span>
</span><span>julia</span><span>&gt;</span><span> Foo.x
</span><span>3
</span><span>
</span><span>julia</span><span>&gt;</span><span> Bar.p()
</span><span>2
</span></code></pre>
<p>Types can&#39;t be redefined within the same module.</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt; </span><span>struct </span><span>T </span><span>end
</span><span>
</span><span>julia</span><span>&gt; </span><span>struct </span><span>T</span><span>; x</span><span>::</span><span>Int</span><span>64</span><span>; </span><span>end
</span><span>ERROR</span><span>:</span><span> invalid redefinition of constant Main.T
</span><span>Stacktrace</span><span>:
</span><span> [</span><span>1</span><span>] top</span><span>-</span><span>level scope
</span><span>   @ REPL[</span><span>38</span><span>]</span><span>:</span><span>1
</span></code></pre>
<p>Tools like <a href="https://timholy.github.io/Revise.jl/stable/">Revise.jl</a> automate the process of keeping source code in sync with running code, but <a href="https://timholy.github.io/Revise.jl/stable/limitations/#Limitations">can&#39;t change</a> the inability to redefine types.</p>
<p>Julia behaves as if late-bound, but compilation might inline functions. To avoid having to constantly guard the functions haven&#39;t changed, julia specializes functions on &#39;world age&#39;. Every new function definition increases the world age.</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt;</span><span> Base.tls_world_age()
</span><span>0x000000000000683c
</span><span>
</span><span>julia</span><span>&gt;</span><span> Base.tls_world_age()
</span><span>0x000000000000683c
</span><span>
</span><span>julia</span><span>&gt;</span><span> f() </span><span>= </span><span>1
</span><span>f (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt;</span><span> Base.tls_world_age()
</span><span>0x000000000000683d
</span></code></pre>
<p>A function called at one world age will never see updated definitions from a later world age. To switch to new age the programmer must explicitly <code>invokelatest</code>.</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt;</span><span> foo() </span><span>= </span><span>1
</span><span>foo (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt;</span><span> bar() </span><span>=</span><span> foo()
</span><span>bar (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt; </span><span>function </span><span>test</span><span>()
</span><span>       println(bar())
</span><span>       eval(</span><span>:</span><span>(Main.foo() </span><span>= </span><span>2</span><span>))
</span><span>       println(invokelatest(bar))
</span><span>       println(bar())
</span><span>       </span><span>end
</span><span>test (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt;</span><span> test()
</span><span>1
</span><span>2
</span><span>1
</span><span>
</span><span>julia</span><span>&gt;</span><span> bar()
</span><span>2
</span></code></pre>
<p>Top-level statements can perform arbitrary side-effects, so load order is trivially observable. In fact, loading a module <code>Foo</code> calls <code>Foo.__init__()</code> if it exists.</p>
<p>Code that runs at jit-time (eg @generated functions) can perform arbitrary side-effects, so jit order is observable.</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt; </span><span>@</span><span>generated </span><span>function </span><span>foo</span><span>(x)
</span><span>       println(</span><span>&#34;foo&#34;</span><span>)
</span><span>       </span><span>:x
</span><span>       </span><span>end
</span><span>foo (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt; </span><span>@</span><span>generated </span><span>function </span><span>bar</span><span>(x)
</span><span>       println(</span><span>&#34;bar&#34;</span><span>)
</span><span>       </span><span>:x
</span><span>       </span><span>end
</span><span>bar (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt; </span><span>function </span><span>quux</span><span>(x)
</span><span>       foo(x)
</span><span>       bar(x)
</span><span>       </span><span>end
</span><span>quux (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt;</span><span> quux(</span><span>1</span><span>)
</span><span>foo
</span><span>bar
</span><span>1
</span><span>
</span><span>julia</span><span>&gt;</span><span> quux(</span><span>1</span><span>)
</span><span>1
</span></code></pre>
<p>There is no clear phase separation and no guarantee of deterministic compilation. This creates many <a href="https://docs.julialang.org/en/v1/manual/modules/#Module-initialization-and-precompilation">caveats</a> for precompilation.</p>
<p>Types can be parameterized by values, but only &#39;plain data&#39; values. This makes equality simple.</p>
<pre><code><span>help?&gt; isbitstype
</span><span>search: isbitstype isbits isabstracttype ismutabletype isprimitivetype isconcretetype nonmissingtype
</span><span>
</span><span>  isbitstype(T)
</span><span>
</span><span>  Return true if type T is a &#34;plain data&#34; type, meaning it is immutable and contains no references
</span><span>  to other values, only primitive types and other isbitstype types. Typical examples are numeric
</span><span>  types such as UInt8, Float64, and Complex{Float64}. This category of types is significant since
</span><span>  they are valid as type parameters, may not track isdefined / isassigned status, and have a defined
</span><span>  layout that is compatible with C. If T is not a type, then return false.
</span></code></pre>
<p>There are no guards on evaluation time. A generated function with an infinite loop requires restarting the repl.</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt; </span><span>@</span><span>generated </span><span>function </span><span>foo</span><span>()
</span><span>       </span><span>while </span><span>true
</span><span>       </span><span>end
</span><span>    </span><span>end
</span><span>foo (generic </span><span>function </span><span>with </span><span>1</span><span> method)
</span><span>
</span><span>julia</span><span>&gt;</span><span> foo()
</span><span>^</span><span>C</span><span>^</span><span>C</span><span>^</span><span>C
</span></code></pre>
<h2 id="clojure">clojure</h2>
<pre><code><span>&gt; clj --version
</span><span>Clojure CLI version 1.12.0.1479
</span></code></pre>
<p>Top-level expressions can have arbitrary side-effects, including mutating environments. Load order is very observable.</p>
<pre data-lang="clj"><code data-lang="clj"><span>(ns </span><span>test.core</span><span>)
</span><span>
</span><span>(def </span><span>x </span><span>1</span><span>)
</span><span>
</span><span>(ns-unmap (find-ns </span><span>&#39;</span><span>test.core) </span><span>&#39;</span><span>x)
</span><span>
</span><span>(def </span><span>y </span><span>x) </span><span>; Syntax error. Unable to resolve symbol: x in this context
</span></code></pre>
<p>Like julia, this creates many caveats for AOT compilation.</p>
<p>Clojure is early-bound, but binds to a mutable <code>Var</code> and dereferences on every call:</p>
<pre data-lang="clj"><code data-lang="clj"><span>user=&gt; (def </span><span>x </span><span>1</span><span>)
</span><span>#&#39;</span><span>user/x
</span><span>user=&gt; (defn </span><span>foo</span><span>[] x)
</span><span>#&#39;</span><span>user/foo
</span><span>user=&gt; (foo)
</span><span>1
</span><span>user=&gt; (def </span><span>x </span><span>2</span><span>)
</span><span>#&#39;</span><span>user/x
</span><span>user=&gt; (foo)
</span><span>2
</span><span>user=&gt; (defn </span><span>bar</span><span>[] y)
</span><span>Syntax error compiling at (REPL:1:1).
</span><span>Unable to resolve symbol: y in this context
</span></code></pre>
<p>It&#39;s possible to get a direct reference to the <code>Var</code> itself.</p>
<pre data-lang="clj"><code data-lang="clj"><span>user=&gt; x
</span><span>2
</span><span>user=&gt; </span><span>#&#39;</span><span>x
</span><span>#&#39;</span><span>user/x
</span><span>user=&gt; (type </span><span>#&#39;</span><span>x)
</span><span>clojure.lang.Var
</span><span>user=&gt; (var-get </span><span>#&#39;</span><span>x)
</span><span>2
</span></code></pre>
<p>Circular references are handled by forward declaration:</p>
<pre data-lang="clj"><code data-lang="clj"><span>user=&gt; (declare odd)
</span><span>#&#39;</span><span>user/odd
</span><span>user=&gt; (defn </span><span>even </span><span>[x] (if (zero? x) </span><span>true </span><span>(odd (dec x))))
</span><span>#&#39;</span><span>user/even
</span><span>user=&gt; (defn </span><span>odd </span><span>[x] (if (zero? x) </span><span>false </span><span>(even (dec x))))
</span><span>#&#39;</span><span>user/odd
</span><span>user=&gt; (even </span><span>3</span><span>)
</span><span>false
</span></code></pre>
<p>This means that it&#39;s not possible to have circular dependencies between namespaces (without shenanigans).</p>
<p>Reloading a namespace mutates all of the existing <code>Var</code>s rather than replacing them, but does not remove old declarations that no longer exist:</p>
<pre data-lang="clj"><code data-lang="clj"><span>user=&gt; (println (slurp </span><span>&#34;./src/test/core.clj&#34;</span><span>))
</span><span>(ns </span><span>test.core</span><span>)
</span><span>
</span><span>(def </span><span>x </span><span>1</span><span>)
</span><span>
</span><span>(def </span><span>y </span><span>2</span><span>)
</span><span>
</span><span>(defn </span><span>foo </span><span>[]
</span><span>  y)
</span><span>nil
</span><span>user=&gt; (require </span><span>&#39;</span><span>test.core)
</span><span>nil
</span><span>user=&gt; test.core/x
</span><span>1
</span><span>user=&gt; (println (slurp </span><span>&#34;./src/test/core.clj&#34;</span><span>))
</span><span>(ns </span><span>test.core</span><span>)
</span><span>
</span><span>(def </span><span>x </span><span>2</span><span>)
</span><span>
</span><span>(defn </span><span>foo </span><span>[]
</span><span>  y)
</span><span>nil
</span><span>user=&gt; (require </span><span>&#39;</span><span>test.core)
</span><span>nil
</span><span>user=&gt; test.core/x
</span><span>1
</span><span>user=&gt; (require </span><span>&#39;</span><span>test.core </span><span>:reload</span><span>)
</span><span>nil
</span><span>user=&gt; test.core/x
</span><span>2
</span><span>user=&gt; test.core/y
</span><span>2
</span><span>user=&gt; (test.core/foo)
</span><span>2
</span></code></pre>
<p>The reloading is made possible by every namespace having a globally unique name.
This means that it&#39;s not possible to load two different versions of the same library.</p>
<p>Namespaces are first-class, but their value can only be obtained indirectly:</p>
<pre data-lang="clj"><code data-lang="clj"><span>user=&gt; test.core/x
</span><span>2
</span><span>user=&gt; test.core
</span><span>Syntax error (ClassNotFoundException) compiling at (REPL:0:0).
</span><span>test.core
</span><span>user=&gt; (find-ns </span><span>&#39;</span><span>test.core)
</span><span>#object</span><span>[clojure.lang.Namespace 0x4cafa9aa </span><span>&#34;test.core&#34;</span><span>]
</span></code></pre>
<p>There are no guards on evaluation time. A macro with an infinite loop will require restarting the repl.</p>
<pre data-lang="clj"><code data-lang="clj"><span>user=&gt; (defmacro </span><span>foo</span><span>[] (loop [] (recur)))
</span><span>#&#39;</span><span>user/foo
</span><span>user=&gt; (foo)
</span></code></pre>
<h2 id="erlang">erlang</h2>
<pre><code><span>&gt; erl -version
</span><span>Erlang (SMP,ASYNC_THREADS) (BEAM) emulator version 13.2.2.14
</span></code></pre>
<p>Modules are not first-class and are typically just represented by a symbol, but all their contents are available via reflection functions eg <code>module_info</code>.</p>
<p>The runtime stores the last two versions of each module. Loading a new version of a module causes the runtime to kill any processes that have direct references to the oldest version.</p>
<p>A direct function call <code>foo()</code> always calls the same version of the function as the calling function. An indirect function call <code>module:foo()</code> always calls the latest version of the function.</p>
<p>Closures never update their function version. Calling a closure fails if the matching code does not exist in either of the last two module versions.</p>
<pre data-lang="erl"><code data-lang="erl"><span>1</span><span>&gt; </span><span>c</span><span>(</span><span>test</span><span>)</span><span>.
</span><span>{</span><span>ok</span><span>,</span><span>test</span><span>}
</span><span>2</span><span>&gt; </span><span>X </span><span>= </span><span>test</span><span>:</span><span>echo</span><span>(</span><span>&#34;foo&#34;</span><span>)</span><span>.
</span><span>#</span><span>Fun&lt;test</span><span>.</span><span>0</span><span>.</span><span>31264253</span><span>&gt;
</span><span>3</span><span>&gt; </span><span>% echo is in the newest version of test
</span><span>3</span><span>&gt; </span><span>X()</span><span>.
</span><span>&#34;foo&#34;
</span><span>4</span><span>&gt; </span><span>% deleted the echo function in test.erl
</span><span>4</span><span>&gt; </span><span>c</span><span>(</span><span>test</span><span>)</span><span>.
</span><span>{</span><span>ok</span><span>,</span><span>test</span><span>}
</span><span>5</span><span>&gt; </span><span>% but echo is still in the old version of test
</span><span>5</span><span>&gt; </span><span>X()</span><span>.
</span><span>&#34;foo&#34;
</span><span>6</span><span>&gt; </span><span>% compiling again removes the old version of test
</span><span>6</span><span>&gt; </span><span>c</span><span>(</span><span>test</span><span>)</span><span>.
</span><span>{</span><span>ok</span><span>,</span><span>test</span><span>}
</span><span>7</span><span>&gt; </span><span>% now echo is not defined anywhere
</span><span>7</span><span>&gt; </span><span>X()</span><span>.
</span><span>** </span><span>exception </span><span>error</span><span>: </span><span>bad function </span><span>#</span><span>Fun&lt;test</span><span>.</span><span>0</span><span>.</span><span>31264253</span><span>&gt;
</span><span>8</span><span>&gt; </span><span>% undeleted the echo function in test.erl
</span><span>8</span><span>&gt; </span><span>c</span><span>(</span><span>test</span><span>)</span><span>.
</span><span>{</span><span>ok</span><span>,</span><span>test</span><span>}
</span><span>9</span><span>&gt; </span><span>% now the newest version of test once again contains a function whose hash matches the hash stored in X
</span><span>9</span><span>&gt; </span><span>X()</span><span>.
</span><span>&#34;foo&#34;
</span></code></pre>
<p>Typically upgrades are done by reloading all changed modules and then messaging all affected processes to notify them that they need to do an indirect call soon to switch to the latest version. Making this work correctly requires careful planning when writing the code.</p>
<p>There is no compile-time evaluation and aot compilation is mostly straightforward, although load order is observable via <code>on_load</code> and can differ depending on whether code is loaded on demand or via a precompiled release.</p>
<hr/>
<p>These last few languages I&#39;m not familiar with.</p>
<h2 id="unison">unison</h2>
<pre><code><span>&gt; ucm --version
</span><span>unison version: release/0.5.27 (built on 2024-10-01)
</span></code></pre>
<p>Top-level declarations can contain arbitrary pure expressions. Non-pure expressions won&#39;t type-check due to the effect system.</p>
<p>Declarations seem to be evaluated lazily, even though they&#39;re not typed as <a href="https://www.unison-lang.org/docs/fundamentals/values-and-functions/delayed-computations/">delayed values</a>. You can add a declaration that causes an error and won&#39;t encounter an exception until you evaluate it (even though the type doesn&#39;t include the exception effect).</p>
<pre><code><span>-- typed as `Nat`
</span><span>foo = 1/0
</span><span>
</span><span>bar b = if b then foo else 2
</span><span>
</span><span>-- no exception, even though foo is reachable
</span><span>&gt; bar false
</span><span>
</span><span>-- exception: divide by zero
</span><span>&gt; bar true
</span></code></pre>
<p>Namespaces don&#39;t really exist. Code is stored as a set of content-addressed values/functions. Version control is baked in to the language and each version of a project is just a map from identifiers like <code>lib.base.data.List.map</code> to values/functions. Declaring a namespace in a file is just sugar to avoid typing out the full identifiers of each declaration.</p>
<h2 id="terra">terra</h2>
<p>Similar staging to zig, but with lua as the compile-time language. Lua is late-bound but terra is early-bound. Compiling a terra function does lua table lookups to resolve namespaced identifiers, which can cause arbitrary side-effects in lua, so compilation is not deterministic and compile order is obserable.</p>
<h2 id="other-lisps">other lisps</h2>
<p>Other lisps that I&#39;ve looked at share the same model inherited by clojure, where terms are evaluated one by one in order and can cause arbitrary side effects. AOT compilation gets bolted on later and put the onus on the programmer to ensure reasonable behaviour. Eg <a href="https://www.reddit.com/r/Common_Lisp/comments/xt7jn4/how_to_build_a_proper_loading_order_from_asdf/">this common lisp discussion</a> notes that:</p>
<blockquote>
<p>...you wouldn&#39;t be able to reproduce that way; file compilation has different semantics than repl interaction (the latter happens strictly at &#34;load&#34; or &#34;execute&#34; time, while the former happens partially at &#34;compile&#34; time)</p>
</blockquote>
<p>Racket is slightly different. It still allows arbitrary side-effects at compile-time, but where possible it <a href="https://docs.racket-lang.org/reference/eval-model.html#(part._separate-compilation)">rolls back mutations</a> after compiling a module. This helps prevent runtime behaviour from depending on the order of compilation of modules, allowing modules to be compiled independently and in parallel as long as they refrain from non-undoable side-effects.</p>

</article></div>
  </body>
</html>
