<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://inko-lang.org">Original</a>
    <h1>Inko Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>


<p>Inko doesn&#39;t rely on garbage collection to manage memory. Instead, Inko relies
on single ownership and move semantics. Values start out as owned and are
dropped when they go out of scope:</p>

<div><pre><code><span>let</span><span> </span>numbers<span> </span><span>=</span><span> </span><span>[</span><span>10</span><span>,</span><span> </span><span>20</span><span>,</span><span> </span><span>30</span><span>]</span><span>

</span><span># &#34;numbers&#34; is no longer in use here, so it&#39;s dropped.</span><span>
</span><span>return</span><span>
</span></code></pre></div>
<p>These values can be borrowed either mutably or immutably. Inko allows multiple
borrows (both mutable and immutable borrows), and allows moving of the borrowed
values while borrows exist:</p>

<div><pre><code><span>let</span><span> </span>a<span> </span><span>=</span><span> </span><span>[</span><span>10</span><span>,</span><span> </span><span>20</span><span>,</span><span> </span><span>30</span><span>]</span><span>

</span><span># All of this is perfectly fine:</span><span>
</span><span>let</span><span> </span>b<span> </span><span>=</span><span> </span><span>ref</span><span> </span>a<span> </span><span># borrows &#34;a&#34; immutably</span><span>
</span><span>let</span><span> </span>c<span> </span><span>=</span><span> </span><span>mut</span><span> </span>a<span> </span><span># borrows &#34;a&#34; mutably</span><span>
</span><span>let</span><span> </span>d<span> </span><span>=</span><span> </span>a<span>     </span><span># moves &#34;a&#34; into &#34;d&#34;</span><span>
</span></code></pre></div>
<p>This gives you the benefits of single ownership, but at a fraction of the cost
compared to languages such as Rust. The use of single ownership also means more
predictable behaviour and performance, and not having to spend a long time
adjusting different garbage collection settings.</p>



<p>With Inko you never again have to worry about NULL pointers, use-after-free
errors, unexpected runtime errors, data races, and other types of errors
commonly found in other languages. For optional data Inko provides an <code>Option</code>
type, which is an algebraic data type that you can pattern match against. Inko
supports both mutable and immutable references, allowing you to restrict
mutation where necessary.</p>



<p>Inko uses lightweight processes for concurrency, and its concurrency model is
inspired by <a href="https://www.erlang.org/">Erlang</a> and
<a href="https://www.ponylang.io/">Pony</a>. Processes are isolated from each other and
communicate by sending messages. Processes and messages are defined as classes
and methods, and the compiler type-checks these to ensure correctness.</p>

<p>The compiler ensures that data sent between processes is unique, meaning there
are no outside references to the data. This removes the need for (deep) copying
data, and makes data races impossible. Inko also supports multi-producer
multi-consumer channels, allowing processes to communicate with each other
without needing explicit references to each other.</p>

<p>Here&#39;s how you&#39;d implement a simple concurrent counter:</p>

<div><pre><code><span>class</span><span> </span><span>async</span><span> </span><span>Counter</span><span> </span><span>{</span><span>
  </span><span>let</span><span> </span><span>@value</span><span>:</span><span> </span><span>Int</span><span>

  </span><span>fn</span><span> </span><span>async</span><span> </span><span>mut</span><span> </span>increment<span> </span><span>{</span><span>
    </span><span>@value</span><span> </span><span>+=</span><span> </span><span>1</span><span>
  </span><span>}</span><span>

  </span><span>fn</span><span> </span><span>async</span><span> </span><span>send_to</span><span>(</span><span>channel</span><span>:</span><span> </span><span>Channel</span><span>[</span><span>Int</span><span>])</span><span> </span><span>{</span><span>
    </span>channel<span>.</span><span>send</span><span>(</span><span>@value</span><span>)</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>

</span><span>class</span><span> </span><span>async</span><span> </span><span>Main</span><span> </span><span>{</span><span>
  </span><span>fn</span><span> </span><span>async</span><span> </span>main<span> </span><span>{</span><span>
    </span><span>let</span><span> </span>counter<span> </span><span>=</span><span> </span><span>Counter</span><span> </span><span>{</span><span> </span><span>@value</span><span> </span><span>=</span><span> </span><span>0</span><span> </span><span>}</span><span>
    </span><span>let</span><span> </span>output<span> </span><span>=</span><span> </span><span>Channel</span><span>.</span><span>new</span><span>(</span><span>size</span><span>:</span><span> </span><span>1</span><span>)</span><span>

    </span>counter<span>.</span><span>increment</span><span>
    </span>counter<span>.</span><span>increment</span><span>
    </span>counter<span>.</span><span>send_to</span><span>(</span>output<span>)</span><span>
    </span>output<span>.</span><span>receive</span><span> </span><span># =&gt; 2</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div>


<p>Inko uses a form of error handling inspired by Joe Duffy&#39;s excellent article
<a href="http://joeduffyblog.com/2016/02/07/the-error-model/">&#34;The Error Model&#34;</a>. Errors
are represented using the algebraic type &#34;Result&#34;, and Inko provides syntax
sugar in the form of <code>try</code> and <code>throw</code> to make error handling easy. Critical
errors that can&#39;t/shouldn&#39;t be handled are supported in the form of &#34;panics&#34;,
which abort the program when they occur.</p>

<p>For example, here&#39;s how you&#39;d handle errors when opening a file and calculating
its size:</p>

<div><pre><code><span>import</span><span> </span>std<span>.</span><span>fs</span><span>.</span><span>file</span><span>.</span><span>ReadOnlyFile</span><span>
</span><span>import</span><span> </span>std<span>.</span><span>stdio</span><span>.</span><span>STDOUT</span><span>

</span><span>class</span><span> </span><span>async</span><span> </span><span>Main</span><span> </span><span>{</span><span>
  </span><span>fn</span><span> </span><span>async</span><span> </span>main<span> </span><span>{</span><span>
    </span><span>let</span><span> </span>size<span> </span><span>=</span><span>
      </span><span>ReadOnlyFile</span><span>
        </span><span>.</span><span>new</span><span>(</span><span>&#39;README.md&#39;</span><span>)</span><span>             </span><span># =&gt; Result[ReadOnlyFile, Error]</span><span>
        </span><span>.</span><span>then</span><span> </span><span>fn</span><span> </span><span>(</span>file<span>)</span><span> </span><span>{</span><span> </span>file<span>.</span><span>size</span><span> </span><span>}</span><span> </span><span># =&gt; Result[Int, Error]</span><span>
        </span><span>.</span><span>unwrap_or</span><span>(</span><span>0</span><span>)</span><span>                 </span><span># =&gt; Int</span><span>

    </span><span>STDOUT</span><span>.</span><span>new</span><span>.</span><span>print</span><span>(</span>size<span>.</span><span>to_string</span><span>)</span><span> </span><span># =&gt; 1099</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div>


<p>Inko aims to be an efficient language, though it doesn&#39;t aim to compete with
low-level languages such as C and Rust. Instead, we aim to provide a compelling
alternative to the likes of Ruby, Erlang, and Go.</p>

<p>Inko uses a native code compiler, using <a href="https://llvm.org/">LLVM</a> as its
backend, and aims to provide a balance between fast compile times and good
runtime performance. The native code is statically linked against a small
runtime library written in Rust, which takes care of scheduling processes,
non-blocking IO, and provides various low-level functions.</p>



<p>Inko supports pattern matching on a variety of types, such as tuples and
algebraic data types:</p>

<div><pre><code><span>match</span><span> </span><span>[</span><span>10</span><span>,</span><span> </span><span>20</span><span>].</span><span>opt</span><span>(</span><span>1</span><span>)</span><span> </span><span>{</span><span>
  </span><span>case</span><span> </span><span>Some</span><span>(</span>number<span>)</span><span> </span><span>-&gt;</span><span> </span>number<span> </span><span># =&gt; 20</span><span>
  </span><span>case</span><span> </span><span>None</span><span> </span><span>-&gt;</span><span> </span><span>0</span><span>
</span><span>}</span><span>

</span><span>match</span><span> </span><span>(</span><span>10</span><span>,</span><span> </span><span>&#39;hello&#39;</span><span>)</span><span> </span><span>{</span><span>
  </span><span>case</span><span> </span><span>(</span><span>10</span><span>,</span><span> </span><span>&#39;hello&#39;</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>&#39;foo&#39;</span><span>
  </span><span>case</span><span> </span><span>(</span><span>20</span><span>,</span><span> </span>_<span>)</span><span> </span><span>-&gt;</span><span> </span><span>&#39;bar&#39;</span><span>
  </span><span>case</span><span> </span>_<span> </span><span>-&gt;</span><span> </span><span>&#39;baz&#39;</span><span>
</span><span>}</span><span>
</span></code></pre></div>
<p>You can also match against literals such as integers and strings, and against
regular classes:</p>

<div><pre><code><span>class</span><span> </span><span>Person</span><span> </span><span>{</span><span>
  </span><span>let</span><span> </span><span>@name</span><span>:</span><span> </span><span>String</span><span>
  </span><span>let</span><span> </span><span>@age</span><span>:</span><span> </span><span>Int</span><span>
</span><span>}</span><span>

</span><span>let</span><span> </span>alice<span> </span><span>=</span><span> </span><span>Person</span><span> </span><span>{</span><span> </span><span>@name</span><span> </span><span>=</span><span> </span><span>&#39;Alice&#39;</span><span>,</span><span> </span><span>@age</span><span> </span><span>=</span><span> </span><span>42</span><span> </span><span>}</span><span>

</span><span>match</span><span> </span>alice<span> </span><span>{</span><span>
  </span><span>case</span><span> </span><span>{</span><span> </span><span>@name</span><span> </span><span>=</span><span> </span>name<span> </span><span>}</span><span> </span><span>-&gt;</span><span> </span>name<span> </span><span># =&gt; &#39;Alice&#39;</span><span>
</span><span>}</span><span>
</span></code></pre></div>
<p>Pattern matching is compiled down to decision trees, and the compiler tries to
keep their sizes as small as possible. The compiler also ensures that all
patterns are covered.</p>

</div>
</div></div>
  </body>
</html>
