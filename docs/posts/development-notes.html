<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macwright.com/2022/02/04/development-notes.html">Original</a>
    <h1>Development notes</h1>
    
    <div id="readability-page-1" class="page"><div><p>So in the course of working on <a href="https://www.placemark.io/">Placemark</a>, I’m solving a lot of small problems that are each too small and niche to merit their own blog post. But I hate letting things go unwritten, so here they are, smorgasbord style.</p><h3 id="getting-tailwind-and-radix-to-play-nice-together">Getting Tailwind and Radix to play nice together</h3><p>I’ve been using <a href="https://tailwindcss.com/">Tailwind</a> for Placemark’s CSS foundation, and <a href="https://www.radix-ui.com/">Radix</a> for many of its UI components. This <em>mostly</em> works great, because Radix makes it easy to style your own components.</p><p>However, there’s a catch: a lot of important UI states for Radix are distinguished by <code>aria</code> accessibility properties or HTML <code>data-</code> attributes. For example, when the trigger for a dropdown menu is engaged, Radix adds <code>data-state=&#34;open&#34;</code> to the element. This is all fine and dandy if you’re writing new CSS classes, or using a CSS-in-JS solution, but I’m doing neither: Placemark just uses old-fashioned classes. And Tailwind doesn’t give you a class that changes the color of a button when the <code>data-state</code> attribute changes.</p><p>The solution isn’t too bad, but it was a little tricky to track down:</p><div><div><pre><code><span>const</span> <span>plugin</span> <span>=</span> <span>require</span><span>(</span><span>&#34;</span><span>tailwindcss/plugin</span><span>&#34;</span><span>);</span>

<span>module</span><span>.</span><span>exports</span> <span>=</span> <span>{</span>
  <span>// ...</span>
  <span>// In tailwind.config.js</span>
  <span>plugins</span><span>:</span> <span>[</span>
    <span>plugin</span><span>(</span><span>function</span> <span>({</span> <span>addVariant</span> <span>})</span> <span>{</span>
      <span>addVariant</span><span>(</span><span>&#34;</span><span>aria-expanded</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>&amp;[aria-expanded=&#39;true&#39;]</span><span>&#34;</span><span>);</span>
      <span>addVariant</span><span>(</span><span>&#34;</span><span>data-state-on</span><span>&#34;</span><span>,</span> <span>&#39;</span><span>&amp;[data-state=&#34;on&#34;]</span><span>&#39;</span><span>);</span>
    <span>}),</span>
  <span>]</span>
<span>}</span>
</code></pre></div></div><p>So you can create a “plugin” that just uses addVariant to add another selector to Tailwind’s knowledge. So now I can add <code>aria-expanded:bg-purple-500</code>, just like I’d add a <code>hover:</code> or <code>dark:</code> variant.</p><h3 id="using-maybe-and-either-types">Using Maybe and Either types</h3><p>There are certain parts of Placemark, like file format converters, that have very detailed success &amp; error types. For example, a file import might fail because of a syntax error in a JSON or XML file, and we want to report that. Or an import might partly succeed with notes, and the notes should be displayed.</p><p>There are a lot of ways you could implement this. Just off the top of my head:</p><ul><li>Returning either the result or an <code>Error</code> type from each function and using <code>instanceof</code> to check which was produced. The downside is that you might forget to check which type you have and access the <code>.message</code> property of an Error when you were looking for the message property of a success object.</li><li>Throwing errors and catching them. The downside is that TypeScript doesn’t include the types of errors in its type system and all errors that you catch in try/catch are <code>unknown</code>, so you have to do some sketchy type reassignment.</li><li>Creating a <a href="https://thoughtbot.com/blog/the-case-for-discriminated-union-types-with-typescript">discriminated union</a> to return plain objects with error or success <code>type</code> properties.</li><li>Using an implementation of <a href="https://101wiki.softlang.org/Concept:Either_type">the <code>Either</code> type</a>.</li></ul><p>I floated from the first solution to the last, after discovering <a href="https://gigobyte.github.io/purify/getting-started">purify</a>, a very servicable module for these types. There’s lots of theory behind the Either type, but in essence it’s a container that might have a failure or a success value, and makes it very hard to accidentally deal with one when you mean the other.</p><p>So now, for example, a conversion method in Placemark might have this type signature, which neatly types both the error and successful case:</p><div><div><pre><code><span>forwardBinary</span><span>?:</span> <span>(</span>
  <span>file</span><span>:</span> <span>File</span><span>,</span>
  <span>options</span><span>:</span> <span>ImportOptions</span>
<span>)</span> <span>=&gt;</span> <span>EitherAsync</span><span>&lt;</span><span>Error</span> <span>|</span> <span>PlacemarkError</span><span>,</span> <span>ConvertResult</span><span>&gt;</span><span>;</span>
</code></pre></div></div><p>This abstraction isn’t free, though. Here are some things that came up.</p><p>My tests that deal with these Either values got annoying. If I had</p><div><div><pre><code><span>expect</span><span>(</span><span>fooMethod</span><span>()).</span><span>toEqual</span><span>(</span><span>10</span><span>);</span>
</code></pre></div></div><p>I’d end up with this, after changing <code>fooMethod</code> to return an Either object:</p><div><div><pre><code><span>expect</span><span>(</span><span>fooMethod</span><span>().</span><span>unsafeCoerce</span><span>()).</span><span>toEqual</span><span>(</span><span>10</span><span>);</span>
</code></pre></div></div><p>This is not great. <a href="https://gigobyte.github.io/purify/adts/Either#instance-unsafeCoerce"><code>unsafeCoerce</code></a> will throw an ugly exception of <code>fooMethod</code>’s result is not success, and it’s cluttering my tests. Hence, I wrote some <a href="https://gist.github.com/tmcw/ff9758bca84d1470386588866c18c133">test helpers for Jest + Purify-ts</a> that might be of help to other folks: they let me write this test like</p><div><div><pre><code><span>expect</span><span>(</span><span>fooMethod</span><span>()).</span><span>toEqualRight</span><span>(</span><span>10</span><span>);</span>
</code></pre></div></div><p>And if <code>fooMethod</code> fails, the test produces a readable report. My short time in the land of Ruby on Rails spoiled me for tests - with gems like <a href="https://github.com/thoughtbot/shoulda-matchers">shoulda</a> and even with <a href="https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers">rspec’s core assertions</a> you could get really nice test reports and succinct tests by keeping boilerplate out of your testing code. From then on, I decided to try and get the same experience in other languages.</p><p>The other thing is <em>serialization</em>. For a lot of methods, I could serialize their return values - for example, to send them to a WebWorker. I can’t do that with Either values. That said, thankfully I’m using <a href="https://github.com/GoogleChromeLabs/comlink">Comlink</a> to abstract around WebWorkers, and it has a a spectacularly cool system of <a href="https://github.com/GoogleChromeLabs/comlink#transfer-handlers-and-event-listeners">transfer handlers</a> that let you manually serialize &amp; deserialize certain values. Hence, a <a href="https://gist.github.com/tmcw/32a2800d9ab0c67435ba5a42fd90ec7d">purify-ts/Comlink transfer handler</a> lets my WebWorkers seamlessly receive &amp; return Either values.</p><h3 id="uuids">UUIDs</h3><p>I recently transitioned Placemark’s IDs for features to UUIDs - specifically, UUIDv1. This was a weird and tough decision, and I collected some assorted resources for anyone else going down the same rabbit hole:</p><ul><li><a href="https://www.are.na/tom-macwright/the-uuid-discourse">The UUID Discourse</a></li><li><a href="https://www.are.na/tom-macwright/shorter-uuid-encodings">Shorter UUID Encodings</a></li></ul><p>Frankly, this decision was premature optimization. I haven’t experienced index bloat in my database, but I’ve <a href="https://www.informit.com/articles/article.aspx?p=25862">read</a> of <a href="https://www.2ndquadrant.com/en/blog/sequential-uuid-generators/">it enough</a> to fear it. Also, I was switching away from <a href="https://github.com/ai/nanoid">nanoid</a>, a lovely module but one that produces 21-character IDs that aren’t compatible with the UUID format. Braindump thoughts below:</p><ul><li>The <a href="https://www.postgresql.org/docs/13/datatype-uuid.html">Postgres UUID type</a> has very efficient internal storage, and kludgy long (36 or 32-character) string encodings.</li><li>So, nanoid IDs are shorter when you’re dealing with them as strings, but longer, and less efficient, when they’re stored in the database or part of an index.</li><li>The UUIDv1 specification has some rough edges - it <em>technically</em> encodes a MAC address in each ID. It doesn’t practically do that, though. The <a href="https://github.com/uuidjs/uuid#uuidv1options-buffer-offset">uuid module</a> just uses a random id instead.</li><li>Updating to UUIDv7 (or any other UUID version) in the future should be seamless. Though you can technically extract and validate data in a UUID, practically there’s no reason to. If you can represent it as a 32-character hex string, Postgres will store it as a UUID.</li><li>The best of both worlds would be UUID storage in the database, sequential values with the <a href="https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format">proposed draft v7</a>, and a short encoding like <a href="https://github.com/tonsky/compact-uuids">compact-uuids</a>. For now, I’m not spending time on a short encoding, which means I’m paying about 6 extra bytes of storage wherever a UUID is, in the JavaScript context.</li><li>I’m using UUIDs because it’s core to the multiplayer + offline-capable paradigm, but my thinking about them has stayed the same: if you have a simpler, non-realtime-collaborative, non-distributed system, just use those beautiful, simple autoincrementing ints.</li></ul><h3 id="finding-dependencies">Finding dependencies</h3><p>A quick note on finding libraries - npm modules - for your project.</p><p>There are a lot of npm modules. If you have a need, like input validation or color parsing or whatever, a raw GitHub search for what you want will probably bring up some junk. It can be hard to tell which modules are good and which are bad. There’s a <a href="https://openbase.com/">startup</a> aiming to solve this problem, but until they do, here are some things I think about:</p><ul><li>Pick modules from the ones you already have. If you’re working on a project that’s based on <a href="https://nextjs.com/">Next</a> or <a href="http://expressjs.com/">express</a> or any other high-level framework, that framework <em>itself</em> has dependencies, and they’re probably good ones. So crack open your <code>yarn.lock</code> or <code>package-lock.json</code> file, read it - it’s long, but readable - and see if you already have a solution at hand.</li><li>Know the people. Through experience I can know that modules made by <a href="https://github.com/sindresorhus/">Sindre Sorhus</a> or <a href="https://github.com/wooorm">Titus</a> or <a href="https://github.com/lukeed">Luke Edwards</a> will be quality. The same goes for a long list of people whose code I’ve relied on. So, when you’re looking through things, pay attention to the people. An informal trust component can really clarify decisions.</li></ul></div></div>
  </body>
</html>
