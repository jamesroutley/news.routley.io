<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/presentations/arcticdb/">Original</a>
    <h1>ArcticDB: Why a Hedge Fund Built Its Own Database</h1>
    
    <div id="readability-page-1" class="page"><div>
                        <div>
                            
                                <div id="presentationNotes">
                                    <h2>Transcript</h2>

<p>Munro: I&#39;m James Munro. I&#39;m going to talk about why a hedge fund built its own database technology. I run ArcticDB at Man Group. Man Group is the asset manager. I was a physicist originally. Spent some time doing plasma physics, electron molecule scattering, things like this. That ended up being useful to do simulations of plasmas for semiconductor processing. This is marginally relevant to a later bit in the talk.</p>

<p>Eventually, I gave that up, joined Man AHL, which is a very systematic quantitative hedge fund manager, mostly hedge fund manager. I worked as a Quant Dev on a bunch of their asset classes, team, strategies, and portfolio management. Became manager in 2016, then CTO in 2018. Then really, that&#39;s where I feel like a lot of what I&#39;m going to talk about starts to come in where I&#39;m focusing on particular things for Man AHL. I did that for 5 years, before becoming head of ArcticDB. I actually moved from being the biggest user of ArcticDB, running the team that was using ArcticDB, and demanding features left, right, and center, to being the owner of it, which is an interesting twist.</p>

<h2>Technology Empowered Asset Manager</h2>

<p>I&#39;m going to give some context to sketch out the story, and then talk about the real whys of building your own database technology. Man Group is a large alternative asset manager. Alternative means not the usual massive markets, but alternative investments designed to give uncorrelated returns. We&#39;re quite large for that, so over $160 billion of assets under management. We&#39;ve been doing that for a while, 35 years.</p>

<p>Actually, Man&#39;s much older. It&#39;s named after someone called James Man, who founded it in 1783. It&#39;s a very old company, and has been doing brokerage and merchanting and stuff for most of its history. For the last 35 years, it&#39;s been predominantly asset management. Lots of clients. Mostly sophisticated clients. In fact, you have to legally be a sophisticated client for most of the stuff. Things like pension funds who are looking for other sources of alpha for the people with those pensions. This is a really broad range of investment strategies.</p>

<p>Things like macro funds, trend following funds, multi-strategy things, discretionary things, credit, loans, all sorts of things, real assets. There&#39;s a whole diversity of things going on. Anything in alternative asset management has been something that Man Group&#39;s interested in. All of that has now been supported by the single technology and operating platform. That&#39;s where the story starts to get interesting for us, I think. Because of the size, there&#39;s a scale challenge immediately. We trade an awfully large amount for an asset manager, so $6 trillion or more a year. It depends on the vol of the markets, the level of risk we&#39;re taking, but that kind of scale.</p>

<p>How do you get from $160-odd billion to $6 trillion? That seems like quite a lot of a jump. Actually, the several-fold comes from leverage. If you&#39;re running hedge funds, you&#39;re normally running leverage. That&#39;s the first factor. The other several-fold from a trillion to $6 trillion or $7 trillion, is actually because you&#39;re an active asset manager. You&#39;re using data and information on the markets to decide whether you should be long, short, which markets you should hold.</p>

<p>It&#39;s that that you&#39;re using to trade. That means you have to be coming in and out of positions. You&#39;re doing that several times a year, on average. That&#39;s where that scale comes from. Then, we&#39;re looking for a whole diverse range of ways to find alpha for our clients. That&#39;s where you need to trade lots of markets. Anything liquid we will trade basically. Then we&#39;ve got all these different customers with different problems. We&#39;re trying to design it for all of them as well. This is real alpha at scale challenge. Then, trading, you&#39;ve got to do this cheaply, you&#39;ve got to do it efficiently. It&#39;s a real drag on this activity if you&#39;re not getting into the markets really cheaply.</p>

<h2>Ten Years of Investment and Refinement</h2>

<p>Another little bit of context is about the story for Arctic itself, so just at a high level. This is something we actually started back in about 2011 when we were looking at Python as a platform as well, and we were looking for data solutions that would work for us for that. We built a first version of Arctic. I&#39;m going to try and explain the why for both simultaneously, so this won&#39;t come up that much again. We made a first version of this Arctic database, actually purely in Python. It was backed by Mongo at the time, which is a fast document storage database. We did that.</p>

<p>Then we actually open sourced that in 2015, which got reasonably good usage by our peers in the financial industry. That was first half of the story. Really, we started to hit limits with that. Mongo became a bit of a scaling obstacle for us. We were running hundreds of Mongo servers. Apparently, we had the second largest Mongo solution for a while. We needed another way to level up on the performance as well, so we rewrote the core in C++. We actually got rid of the separate database layer completely, and now it connects just to storage. That&#39;s one of the stories I&#39;m going to talk about. This was a way therefore that, by changing the way we do storage, so connecting directly to object stores like S3, we could get better performance and better scale.</p>

<p>Then also, by changing the runtime C++ instead of Python, we could get better performance, what we&#39;re doing there as well. That was a way to many times our performance level on our scale. That now is used almost for everything at Man Group, in the front office at least, so for the market data and all the data we use to predict markets, or risk, or whatever we&#39;re doing, or cost, and for all of the AUM that Man Group trades. It&#39;s also used across finance now by banks, other asset managers, data providers.</p>

<h2>Why Build a Database?</h2>

<p>Let&#39;s get into the why. Why build a database? At one level, it sounds crazy. There are thousands of databases out there, and they&#39;ve already been built by people who want to make a successful database for some reason. Is it really the case that none of them fit what you&#39;re trying to do? That&#39;s like a core of the question. At some level, this sounds a bit crazy. It reminded me of this quote, the distance between insanity and genius is measured only by success, which after a bit of Googling I found out was made by someone called Bruce Feirstein, who apparently wrote some of the James Bond stories, an American author.</p>

<p>This is the DALL·E interpretation of that. You&#39;ve got the slightly crazy person on the left and then maybe the more genius person on the right. That was the way around I had it in my head anyway. A younger looking Bruce Feirstein in the middle, and he&#39;s measuring his head size for some reason. I got it. Then you get these weird things like the arm coming in from the left on the table. I don&#39;t really understand. Is it crazy? I don&#39;t think it really is because, for one thing, there&#39;s some level of specialism here. We&#39;re dealing with a lot of high frequency data. I&#39;m going to talk to you about shapes and sizes of data too. That&#39;s a normal thing for people to go and solve with specialist tools. There are proprietary databases you can buy for tick data.</p>

<p>You&#39;ll find that most, at least tier-1 banks have built their own proprietary database solutions for tick data for similar reasons that I&#39;m going to talk about. There&#39;s a specialism story there. Actually, we built something that&#39;s quite general. I think another part of that is most of those thousand databases out there already have been built for a purpose. There are very few databases that are built in a vacuum and then address the purpose. Actually, you should really consider it normal that when there&#39;s a breeding ground for some innovation that someone comes up with something that&#39;s a little bit different.</p>

<p>Getting into the why, I wanted to try and connect the dots from what Man Group is trying to achieve with this alpha at scale story. Back to the technology pressure for doing something like ArcticDB. This is quite a nice way to explain it. This is an economic article from American Economic Review in 2020, where they were looking at research productivity. You might think that maybe low latency trading systems are the real challenge of running a systematic quant hedge fund. Turns out, not really.</p>

<p>We&#39;re not a high frequency trader. That&#39;s one element of it where that would be more of a pressure. Although the performance of that does matter, and the technology you need to solve high frequency trading, a really good execution does matter. Actually, you&#39;ll find that a lot of the time you&#39;re competing on this research productivity, for the trade ideas themselves, and how you manage risk and optimize portfolios, rather than the low latency aspects of it. I&#39;ll explain that a bit more. One step back from generating the alpha itself is actually the research to generate the alpha on the data. It&#39;s the research productivity for your quant team that you&#39;re focused on, for those ideas and for that portfolio construction. This chart is of that for Moore&#39;s Law. This felt familiar for me, because I&#39;ve been working on semiconductor processing in the mid-2000s there.</p>

<p>I&#39;m a little part of that green line. What it shows is that for Moore&#39;s Law, in that sector, at least, we know the semiconductor densities doubled every couple of years. Somehow that&#39;s 35% compound growth rate, according to the economics, but I didn&#39;t quite get that. That&#39;s been an exponential growth rate for the computing industry. It&#39;s been a massive revolution: the IT revolution, the technology revolution. The cost of doing that research has been going up steadily. I was definitely acutely aware of that, because of the level of detail of simulating those plasmas, etching those semiconductors that I was doing. It was atomic level simulation, back in the mid-2000s.</p>

<p>That was very much at the tail end of the concerns. The number of people just to eke out smaller feature sizes on these things was just getting huge. That works when your payoff is exponential. It doesn&#39;t work in every market. If that was one person in 1971, it&#39;s now like 18 people in 2014, it&#39;s probably a lot more now. Research productivity is a key challenge in that sector. The paper&#39;s conclusion is it&#39;s a key challenge across sectors. Some of those sectors don&#39;t have those exponential payoffs. It&#39;s a key challenge in quant as well for markets. For one thing, you&#39;ve got more data coming in. Another thing is you&#39;ve got competition, and you&#39;ve got market efficiency going up. These edges become harder to find. This research productivity ends up being your biggest challenge.</p>

<h2>What is Alt Data?</h2>

<p>Data&#39;s going up, no need to explain that. In asset management, in finance, generally, though, it&#39;s been a slightly more nuanced story. High frequency data, low latency market data ticks, that frequency, that&#39;s been going up. You can collect trillions of rows per day, if you want. Billions of rows per day is typical for asset managers like ours. Also, there&#39;s been another part to the story, which is all this other data starting to get used to predict markets and risk. Generally, we refer to that as alt data or alternative data.</p>

<p>That&#39;s all the data that consumers are generating, and people are generating, which is all sorts of different types. It could be weather data, images, could be data on how green you are. All of this stuff. This stuff&#39;s been growing. There&#39;s a dual sided story here where the volume of this data has been growing. This plot here is by a data like catalog company.</p>

<p>They basically go and index datasets for people to try and connect you to the valuable data you might need, called Eagle Alpha. They&#39;ve got these nice plots of all the datasets in their catalog over time. Actually, it&#39;s also diversity of data challenge for a place like us where you&#39;re dealing with all sorts of different data types. You just really need to be able to get through that as a process really quickly, as well. You need agility with data, not just the ability to handle it performantly.</p>

<h2>Choosing Python for Data Science in 2011</h2>

<p>Then, another part is I wanted to place this story in time as well, because if I think back in 2011, when I joined Man Group, they were just beginning a move to Python. I want to use this Python for data science now. Anyone is choosing at this point. People might be on other languages at the moment. Anyone who is choosing is choosing Python for data science. That&#39;s what you get taught at school and everything. That wasn&#39;t really the case in 2011. I think that if you&#39;re in a quant hedge fund in 2011, you&#39;re looking at other languages like R, or things like MATLAB, sometimes C++ if you&#39;re doing lots of data.</p>

<p>These were the typical choices. These were the skills that people had in the building. Python wasn&#39;t the obvious choice for data science at that point. Also, you were presented with the challenge of wanting something you could use in prod. It wasn&#39;t really a choice for that at the time either. Obviously, lots of people have been choosing Python since then. You can see that this is a Stack Overflow language popularity chart. You can see lots of people chose Python, and it became very popular on Stack Overflow, and obviously very popular globally. Back then, also, Python 2 was like normal, Python 3 was out but it was like hard, still a pain.</p>

<p>TensorFlow didn&#39;t exist. PyTorch didn&#39;t exist. Lots of tools weren&#39;t that popular yet. pandas really got popular mid-teens. It was open sourced originally in 2008. This was still a pushy choice. You&#39;re going to move everything into Python. You&#39;re going to do all these data science there. We spent time supporting that community, particularly PyData in London, and working on our tooling on top of what was available, including ArcticDB.</p>

<h2>Conceptual Journey</h2>

<p>I want to explain another part of the conceptual journey, which is that even if you&#39;re an individual, and you&#39;re managing your investment portfolio, this is the process you follow. Even if you&#39;re a very sophisticated asset manager, this is the process you follow, whether you like it or not. You&#39;re bringing data in, as an individual might just look at my phone, for a price of something. I might be bringing in billions of market data ticks. You&#39;re trying to get on board that data. You&#39;re coming up with some decision, some idea about what to trade.</p>

<p>Then you need to decide how to trade it, this portfolio construction. Maybe it&#39;s not the only position you hold. A simple example is you want to hold American stocks, but maybe you don&#39;t want to be exposed to the dollar, so you might need to hedge something. In a complicated case, you&#39;ve got to decide on your weighting tool, the assets you might hold. Then you want to trade it cheaply. That might affect the instrument you trade, but also how you trade. This is whether you&#39;re an individual, or whether you&#39;re a global corporation, this is the process you follow. I think the other parts of the story is that, this just really gets complicated extremely quickly. I mentioned the thousands of datasets that Eagle Alpha had indexed there.</p>

<p>There&#39;s a variety of data as well. You might be looking at company reports, like documents. You&#39;ve got tick data. You might be looking at consumer transactions. You might be looking at environmental, social things. You&#39;re also doing all sorts of statistical methods. It&#39;s not like you&#39;re choosing one machine learning algorithm that&#39;s on trend. You&#39;re doing basic statistical and science. You might be doing deep learning.</p>

<p>You might be using ChatGPT. You&#39;re almost using every method under the sun and you&#39;re getting hands-on. You need the tools that let you do that. You need to be doing all sorts of portfolio construction. I mentioned that we&#39;ve got lots of solutions. You need to be doing risk. You need to also do the high frequency end of execution, and you need to do that well. You&#39;ve just got this really diverse set of problems, and almost teams devoted to all of them. There are hundreds of quants within Man Group, for instance, and they all want to be solving different problems. If you&#39;re all solving the same problem, you&#39;re probably doing something wrong.</p>

<h2>DataFrame Use-Cases Across a Systematic Trading System</h2>

<p>Now we&#39;re getting into the nuts of it, I think the detail of it. If you&#39;re a systematic trader, which means that you designed an algorithm that&#39;s going to do the work for you, you&#39;re not choosing stocks yourself. You&#39;re designing the algorithm, and you&#39;re probably very automated, so from data through to execution. I think this is the architecture for the ages called the lambda architecture. Invariably, you invent this lambda architecture, where you have streaming data pipeline, and a batch data pipeline. Streaming data is all about the high frequency stuff.</p>

<p>You&#39;re bringing in tick data. You&#39;re saving it into tables or DataFrames. You&#39;re also going to be downsampling it into bars, typically one-minute bars, could be lower frequency, higher frequency, and doing analytics on it for later use. Also, you don&#39;t want to do the kind of work that requires and connecting to non-streaming APIs for everything else. You&#39;ve got a batch workflow. That&#39;s the other side of the lambda architecture, where you&#39;re bringing in either fundamental or alternative data for all the things that you care about. You&#39;re putting that into DataFrames or tables. You need to catalog that because there&#39;s thousands of things. We&#39;ve got this internal datalake architecture we call codex.</p>

<p>The goal is to bring this stuff into your model, your strategy, where your algorithm is going to execute, and it&#39;s going to use this. It&#39;s going to be able to do backtests to tell you how this thing evolves over time. It&#39;s going to do a portfolio risk and trade optimization. That&#39;s where the science is focused on building that algorithm. Then you&#39;ll send that instruction out to trading, the eventual decision. That could happen in a variety of ways.</p>

<p>Then you&#39;re going to need to do analytics on that. You&#39;re going to need to do analytics on all of this to see what&#39;s going on. You&#39;re bringing this stuff into tables. What&#39;s happened at Man Group, and actually at many alternative asset managers is the table has become the DataFrame. The DataFrame&#39;s become the unit of moving data around, almost like a document, in that you care about the unit as a whole. You&#39;re reading and writing new ones every day. You&#39;re just shuffling an awful amount of data around and you&#39;re doing analytics on all of it every day. That&#39;s a key story that your unit of operation is the whole DataFrame.</p>

<h2>Scalable and Accessible</h2>

<p>Then from the technology side, back in 2011, but this is still something we care about, we were thinking about how to get past the server bottlenecks, all of this stuff causes. We tried a number of proprietary databases and open source databases at the time. We found all of that required often just creating hundreds of these servers. I talked about the Mongo story a bit. The reality is that a single user can generate enough load with some of these data science models to swamp your entire system, to swamp potentially dozens of servers, which is the inverse of a relationship you might have with a website where you&#39;ve got thousands, potentially millions of users for a single server.</p>

<p>That&#39;s a huge cost and a huge operating burden as well, just the cognitive load, and the work required to maintain that, even in a modern serverless setup. Then, also, we were moving to Python. That was a decision we had made. We wanted to make a really trivial API for people. We wanted to just make it as easy as possible to work with this data, and DataFrames as a unit. Something that is almost like OneDrive now where you can just share data trivially, and work on it like that. Also, was a high-performance time series database. This kind of like not having an idiosyncratic tool for this but simple Python API that let people work with data like this. All of these things coalescing drove us in this direction.</p>

<h2>Real-World Data</h2>

<p>Then, is there anything that could have still managed to not make us build our own database? I&#39;ll explain a bit of that now, with some of the real-world data challenges, and my opinions on it. Time for a DALL·E picture. Shapes that are too wide, too long, or ragged. I wasn&#39;t liking the images, so I did cubism on the end, try and get a cubist image. I&#39;m not sure this is cubism but it&#39;s got cubes in it. Here&#39;s someone struggling with real-world data. A real example, bond data. I think it&#39;s an interesting example, because people might not be so familiar with it.</p>

<p>Bonds are actually a bigger market than equities, like multiple times, three times globally as of when I pulled this data in, and actually a higher amount in the U.S. because most bond trading is done in the U.S. It&#39;s a huge market, actually, but it&#39;s a lot less liquid than equities. We all know about equity trading. It&#39;s credit, basically. It&#39;s much slower and harder to trade as OTC market. This has been fertile ground for quant, this is because it&#39;s less liquid, but really big, it&#39;s something that&#39;s hard to do. It&#39;s something hard to get right. It&#39;s a really good thing to be on the front edge of.</p>

<p>The data behind this ends up being somewhat challenging as well. I&#39;ve got at the top like how you might think about normalized data typically. Then I&#39;ve got at the bottom, one of the ways we actually work with this data. In fact, we have many shapes for all the things we do. At the top, this is Python pandas DataFrame. Then I&#39;m pulling out the bond data. I&#39;ve got dates on the left, so it&#39;s like time series. I&#39;ve also got IDs of the bonds. Those are the Cusips and ISINs, the common IDs. You&#39;ve got things like price, but you&#39;ve got lots of measures for the bonds, that&#39;s the fundamental data, things like duration. This is a normalized way of bringing in data. This is how you often get data. It&#39;s not actually how you want to work with data. That&#39;s one of the steps I think you&#39;ve got to take.</p>

<p>At the bottom is a pivot of that. You&#39;re just pulling out price now. It&#39;s one measure. You&#39;re just working with one measure, because you want to do calculations on price. If you do a calculation on price, it&#39;s not the same calculation you&#39;re going to do on volume. You got IDs along the top, and you got times down the left still. Now you can do time series analytics. If that&#39;s stored in a columnar fashion, then that&#39;s incredibly fast. Also, you&#39;ve arranged your data naturally for doing cross-sectional analysis, because everything&#39;s a portfolio now.</p>

<p>Trading one asset rarely makes sense. You&#39;re really arranging yourself for the kind of work you want to do on this data. This ends up being 400,000 historically tradable bonds from this dataset, which is many gigabytes. It&#39;s five rows, because I pulled the tail out. It&#39;s a few thousand rows in total of daily data, but it&#39;s many gigabytes of data. Wouldn&#39;t fit on this laptop, for instance, in RAM. You also need the tools to deal with this. You need something which is happy to have that many columns, which is not a typical SQL schema. It&#39;s more like something you need to treat as a block.</p>

<p>This is really the story of the normalization tradeoffs, and maybe personal opinion as well. Generally, people have been taught to design schemas on the left. I&#39;m not saying they&#39;re wrong, but I&#39;m saying you need to think. Schemas on the left are typically normalized. The reason you&#39;re doing that is because you&#39;re looking at the way the data is structured, and you realize not every timestamp exists. You realize that sometimes assets come and go. Apple didn&#39;t exist forever. Many companies go bust.</p>

<p>Measures change, because the scheme of your data often changes, so you&#39;ve got to normalize it all, because you think that&#39;s the right thing to do. It&#39;s the thing you get taught to do at university, if you do computer science. Actually, your users care about something else, often. I don&#39;t want to be too generalistic. Here, I&#39;ve given another case where it&#39;s not like assets IDs along the top, but it&#39;s like, you&#39;ve broken up your problem into assets. Because, typically, maybe you&#39;ve got an application where people are just pulling in individual assets. You don&#39;t actually want the performance cost of building the table on the left, but also the performance cost of scanning the whole table every time you want one asset out of it. Suddenly, you want the columnar storage on an asset.</p>

<p>Two, your measures might change, or you might have something else, you might be doing calculations producing the columns, but you want that stuff aligned. You don&#39;t want that to be distributed across your large table. Actually, go to where the user is, as much as possible, and then do the normalization you think is appropriate for that. That&#39;s a real part of it, and has made us design it for the flexibility of DataFrames that are the shapes the user want to be.</p>

<p>Two aspects of that, it&#39;s just like, one, we can have big tables, but let&#39;s make sure those tables are columnar on the things that people want to read. That could be billions of rows, it could be trillions of rows per tick data, or it could just be decades of daily data. Also, users are going to want to do cross-sectional things, and so support hundreds of thousands of columns. We have a user on ArcticDB doing a million columns. Make sure it works for that.</p>

<p>Then, rather than rely on your normalization to deal with missing data, just accept the missing data. Let your data be ragged. Let your data be sparse in places. Build a tool that&#39;s performant for that. Again, just an example, because you&#39;re going to have many use cases, but this is asset IDs on the top. Then the idea is that some of these assets have gone away, maybe they went bust, and new ones are coming along. If it&#39;s bonds, they&#39;ve expired, and new bonds are being issued, or maybe it was missing data because the server went down. Just build a tool that lets you work with that, because that&#39;s how the quants are going to work with it. I think that&#39;s actually probably actually quite true of a lot of data science as well.</p>

<h2>Architecture</h2>

<p>If you believe the why, why build a database, a new one, then how do you go about solving for all this? Time for another DALL·E picture. Our mascot, the polar bear is looking for a way through a complex architecture. My take on this is you can give up one of the ACID mostly. We know atomicity is the idea that either something happens, or it doesn&#39;t happen, like it fails completely or happens completely. Renaming a file on a file system is a common example of that. Consistency, all the versions are good versions.</p>

<p>You don&#39;t see half complete versions or things which break, things we expect to be immutable. Durability, so there&#39;s copies of the data. You&#39;ve got good uptime. One hundred percent, you need these things. The one that&#39;s missing is isolation. If you want to give up anything for the sake of agility and performance, I think you can do a lot by giving up on some of the isolation. Isolation means that you&#39;re helping the user coordinate transactions, and they might be doing it from multiple places. A very classic example of this is your shopping basket. You&#39;ve got stock. You&#39;re buying something online.</p>

<p>That shop has stock of that thing, and it can&#39;t sell it twice so it needs to check in order when it puts things into shopping baskets, so it doesn&#39;t oversell it. In trading, this matters. I&#39;ve got positions in something, I need to know that the last person who wants to change that table, me, if I want to change that table saw that value, and no one else is operating based on that value until I&#39;ve done my change. That&#39;s the serializability of individual users transacting on the database. If you&#39;re moving to a world where you&#39;re actually doing analytics and data science, instead of trying to operate an order book in a trading system, then that&#39;s something you can easily give up, because you&#39;re actually asking the user who&#39;s already got millions of these DataFrames, so like documents to the user.</p>

<p>Just to think about how they change that DataFrame, rather than trying to write to it from multiple places. Really, the point here is that isolation needs coordination. That can be a serious cost problem, maintenance problem, because suddenly you need databases, because you need a queue, or locks, or you&#39;re limiting yourself to these obscure data types that are eventually consistent. You can do this without separate database servers. You could implement this on AWS S3, but it would be really slow and inefficient, because you&#39;re really asking a lot of the abstraction. You could implement a queue. You can implement locks. There are many databases out here that do this without giving up the database server. If you&#39;re happy to implement a lock-aware system, then you can do a lot with performance and flexibility, and efficiency of running a database without servers.</p>

<p>Actually, this is not a new idea. There was a 2008 paper on building a database on S3. AWS S3 came out in 2006. Just a couple years after and people are already excited about the technology. The author looks at how you could implement databases on S3, and what you&#39;d have to give up, given the constraints of you&#39;re being reasonably efficient. You can see the diagram on the left is basically offering up the chance to run it without a service, because although there&#39;s a line between the client and the database logic, the record manager and the page manager, that line can go away.</p>

<p>You could run it, all the database logic in the client. The conclusion is that it&#39;s shown atomicity and all client-side consistency levels can be achieved, whereas isolation as strict consistency cannot. What they mean by strict consistency here is that writes follow reads. It&#39;s the same challenge of having your write be due to the data you just read. In SQL language, this would be select for update. You&#39;re locking the read until you&#39;ve updated. That level of strict consistency is a challenge to do performantly. The one that&#39;s really just below that, which is that writes follow reads, which is that, if you&#39;ve done a write and that write is complete, that everyone gets the data at that point, is possible in AWS S3 and many S3 implementations, and lets you do a lot.</p>

<p>This is not really rocket science, once you&#39;re happy to take this approach. It&#39;s stuff that we probably all know about a little bit. A little bit about how this is achieved in ArcticDB with its data structures. If we&#39;re going to respect the atomicity and consistency, and just delegate durability to the storage, like not even worry about that, just use good storage technologies, then we need a data structure that&#39;s going to support that. Ideally, like an immutable data structure, where you just add versions, rather than modifying previous versions.</p>

<p>User 1 is reading version 5, and then you&#39;re making an update. Actually, what you need to do is create a new version of the data. Then you need to reference, so you&#39;ve got some symbolic link here. I&#39;m pretending that you&#39;ve got a piece of data called Apple. You&#39;re symbolically linking that to the new version as an atomic operation, after you&#39;ve completely written version 6. Then any new users are getting version 6. You can start to build database semantics on top of this.</p>

<p>Beyond having a reference name for things and a versioning structure, you&#39;re going to have some indexes in your database. You&#39;re going to have some data. I&#39;ll come to that. Really, I&#39;ve said this a number of times, but no database servers. They&#39;re all gone. No job queues. Everyone can operate independently on the storage system, but that&#39;s shared storage. It could be a shared file system, could be S3, and people are able therefore to work together. As long as they figure out how to update DataFrames together, individual DataFrames. Typically, there&#39;s an ownership here, because there&#39;s millions of DataFrames and thousands of libraries.</p>

<p>What does this mean for your concerns in your database? I think this is an important point, because it&#39;s really not just about isolation, but it&#39;s about where you put your concerns. The things you care about, where do they sit? Traditionally, APIs, normally like quite a light API, because a lot of the work is happening on your database server, the security is definitely happening there, executing your queries, managing your transactions, building your indexes, updating your indexes is a lot of the work.</p>

<p>Then you&#39;ve got to split responsibility on the capacity, both for performance and how much data you&#39;ve got between the servers and the storage. The resiliency, the durability is split up across both. You don&#39;t have any single point of failure in a modern distributed system. What happens when you make this truly serverless, where you&#39;re given up a little bit on transactions, but just with that isolation concern. You do have a heavier weight client. The API is simple, but it&#39;s doing a lot. That&#39;s actually doing the indexing and the execution of your queries. Then the security and capacity, resiliency all delegated to your storage. If you&#39;re using a world class storage system, like many of the S3 ones, you&#39;ve got incredibly featured capacity, scalability possibilities, and security possibilities, and incredible resiliency. That stuff just works.</p>

<p>Then, you don&#39;t have to worry about these database servers. Then the other nice feature, which you might think is a bad feature, but I think it&#39;s actually a good feature at an organizational level, is that the work you&#39;re doing at your database scales with your clients. If this is a web server, that would seem like a terrible idea. Like, I&#39;m doing all my work in my web browser. If I&#39;m trying to do data science, then the reality is the users doing the most work are running on the biggest machines, and they can afford the most database work as well. You&#39;re actually naturally scaling your workload with your user&#39;s workload, which is not just about reading or writing data, but the science in the middle. You&#39;ve got your S3 caring about everything else.</p>

<h2>Benefits</h2>

<p>Another way to look at the benefits is that you end up with something, because you&#39;re not running up these servers, and not having to care about your servers in the normal meaning of serverless is probably a good trend. Not having them seems like an even better option. Just have somewhere to store your data. In this case, my example, AWS S3, make an S3 bucket. Then configure your credentials. Install ArcticDB as your path in client. It&#39;s incredibly simple to set up an almost infinitely scalable database.</p>

<p>Then connect to it. That&#39;s much the same as you might connect to any database, just a slightly different API. Then you&#39;ve got database semantics on top of that. You&#39;re reading and writing and updating and deleting data from DataFrames. A win on the back of this is that because you&#39;re using these immutable data structures, I&#39;m allowing for deletes, but even deletes create new versions. Even though you based your design on immutability, you&#39;ve got the ability to change things.</p>

<p>You&#39;ve also got the ability to rewind time because all these old versions still exist normally. You get this nice feature, this actually ends up being really critical for data science as well, because you need to go back to different models all around. You need to look at how the data changed. You need to look at how your outputs changed, and how that related to the model you&#39;re running to do good science. This ends up being a necessary and nice output of this architecture.</p>

<h2>Summary</h2>

<p>For all the reasons discussed, we ended up with this fully client-side database machine that does all the work of deduplicating data, compressing, tiling, indexing, working with the storage system to create a fully featured shared database infrastructure on what could be shared file systems, cloud storage, or it could be very performant flash drives in your local data center, which is the way we run it. I said there was more to the data structures, but, obviously, you&#39;re building your indexes, and you&#39;re compressing what might be tick data, what are the alternative data, and so columnar storage in your data layer, and you&#39;re chunking it. In this way, you can use the indexes to format the bits you want.</p>

<h2>Demo</h2>

<p>I actually VPN&#39;d into the corporate infrastructure here, so I&#39;m just going to do some imports, and then explain a few terms. This is the idea of the namespaces, the bucket level in S3 parlance. You&#39;ve made some storage bucket that you&#39;ve got permissions for. Then there&#39;s the dataset level we call libraries. You might put your U.S. equity data in one and your European equity data in another, or your weather data in another. Then you&#39;ve got lots of DataFrames in there, could be millions, for all the things you individually care about.</p>

<p>Each of those items is a DataFrame. Connect to the research cluster here, so 30,000 libraries in the research cluster. There&#39;s a separate production cluster where we run our stuff in real life for trading. Then I&#39;m going to get our toy example to show you how things work. I&#39;m getting a library. I&#39;m going to read from one library and write to another. There&#39;s a source library and a library. I&#39;m listing the symbols. These are the DataFrames in the library, this is 4.</p>

<p>It&#39;s tiny examples, just so you can see what&#39;s happening. Basically, you read and write DataFrames. I&#39;ll read Amazon 1. I&#39;ll write Amazon, and I added in bits of metadata, just so I can keep track of things. You&#39;ve got some database functionality, so there&#39;s not just a document store. You can append data. Let&#39;s do that. I&#39;ve made my DataFrame a bit longer. I&#39;ve read a piece there. I&#39;ve written it, appended it to Amazon. There&#39;s the slightly longer DataFrame.</p>

<p>You can update the middle, and it will be updating the indexing and the versions for all of this. When I did the original write, you can see that I&#39;ve run this demo a few times, version 625. Here, I&#39;ll do an update in the middle of the data. If you&#39;ve been watching very carefully, very quickly, you can see that the middle of the data has changed. Also, the time travel. All of these things are new versions. I can get the last version. Then I can go back to a version number, or I can put in a timestamp and you just find a version at a time. That was the original version. All these are toy examples.</p>

<p>This is running in a JupyterHub notebook. It&#39;s two virtual cores. It&#39;s actually very small. I&#39;m not doing myself any favors by running on a tiny VM. I&#39;m going to get an example with lots of floats in, 100,000 columns, 100,000 rows. I&#39;m just going to pluck out three columns, and a few months of data. That&#39;s the turn of the DataFrame there. Then it works with tick data as a clear use case. Here, this is actually Bloomberg data. Level 1, that means like Bid and Ask data from Bloomberg.</p>

<p>Our level 1 dataset there for equities has 66,000 equities. I&#39;ll pull out some columns, just one day of data. It took about a third of a second, 1.3 million rows, just to prove the data came back. Then there&#39;s query functionality. This is the classic New York taxi dataset for yellow cabs. Here, I&#39;m trying to find out who are the really heavy hitters. This is like pandas star query functionality. Where are people tipped so much that it&#39;s 95% of the total amount? They&#39;ve tipped $100 in a $5 fare? There are those, people do that. There you go. It feels and works like pandas, which is the skills that people have learned in Python, to work with data.</p>

<p>Just to give you a little bit of a feel for how ArcticDB works in practice for users. This is used in [inaudible 00:47:45]. Here, I&#39;m running 40 gigabytes per second, out of this flash storage on the right, no database servers, straight to Python users. Typically, they&#39;re running clusters of machines to do their calculations. If using a fast networking of like 40 Gigabit E like networking, then that&#39;s like over 10 of those. You&#39;re using a lot of networking to do this. This is just like every day. This is multiple days sustained. It&#39;s like billions of rows per second. It works.</p>

<p>Quick shoutout to D-Tale, which is a nice pandas visualizer, and actually our most popular open source tool. We&#39;re not doing this alone. Bloomberg have been helping us with this. They&#39;re a user of it in BQuant which is their quant data science Python tool they sell, which has data already in it. QuantStack which are a French company, who&#39;ve done a lot of work on Jupyter and conda-forge, mamba, micromamba, things like this. They&#39;re a pretty cool open source focused company. With their help, we&#39;re building this out.</p>

<h2>Questions and Answers</h2>

<p>Participant 1: What&#39;s the optimization happening on the pandas DataFrames, which we obviously know are not very good at scaling up to billions of rows? How are you doing that? On the pandas DataFrames, what kind of optimizations are you running under the hood? Are you doing some Spark?</p>

<p>Munro: The general pattern we have internally and the users have, is that your returning pandas DataFrames are usable. They&#39;re fitting in memory. You&#39;re doing the querying, so it&#39;s like, limit your results to that. Then, once people have got their DataFrame back, they might choose another technology like Polars, DuckDB to do their analytics, depending on if they don&#39;t like pandas or they think it&#39;s too slow.</p>

<p>Participant 1: Or they are stored in a single node of the cluster or they&#39;re distributed across?</p>

<p>Munro: They&#39;re distributed across the storage, which is your storage provider&#39;s problem, and something they&#39;re actually pretty good at solving. Generally, actually AWS will dynamically distribute your data, to make sure it&#39;s meeting demand.</p>




<p><big><strong>See more <a href="https://www.infoq.com/transcripts/presentations/">presentations with transcripts</a></strong></big></p>



                                </div>
                            
                        </div>
                        
                            







                        
                        
                        
                            
                                
                                
                                
                                
                                    
                                    
                                
                                
                                    
                                
                            
                        
                        
                    </div></div>
  </body>
</html>
