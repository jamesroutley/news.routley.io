<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/code-and-let-live/">Original</a>
    <h1>Code and Let Live</h1>
    
    <div id="readability-page-1" class="page"><article>
         <dl>
             <dt>Author</dt>
             <dd>
                 <img alt="Kurt Mackey" src="https://unplannedobsolescence.com/static/images/kurt.webp"/>
               <dl>
                 <dt>Name</dt>
                 <dd>
                   Kurt Mackey
                 </dd>
                  <dt>@mrkurt</dt>
                  <dd>
                    <a href="https://twitter.com/mrkurt" target="_blank">
                      @mrkurt
                    </a>
                  </dd>
               </dl>
             </dd>
         </dl>

        <section>
            <figure>
                <img src="https://unplannedobsolescence.com/blog/code-and-let-live/assets/sprites.jpg" alt=""/>
                <figcaption>
                  <span>Image by</span>
                  
<svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd">
  <g buffered-rendering="static">
    <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path>
  </g>
</svg>

                    <a href="https://annieruygtillustration.com/" target="_blank">
                      Annie Ruygt
                    </a>
                </figcaption>
            </figure>
          <p>The state of the art in agent isolation is a read-only sandbox. At Fly.io, we’ve been selling that story for years, and we’re calling it: ephemeral sandboxes are obsolete. Stop killing your sandboxes every time you use them.</p>
<p>My argument won’t make sense without showing you something new we’ve built. We’re all adults here, this is a company, we talk about what we do. Here goes.</p>

<p>So, I want to run some code. So what I do is, I run <code>sprite create</code>. While it operates, I’ll explain what’s happening behind the—</p>
<div>
  <div>
    <pre><code id="code-j7bwc7lv">✓ Created demo-123 sprite <span>in </span>1.0s
● Connecting to console...
sprite@sprite:~#
</code></pre>
  </div>
</div>
<p>Shit, it’s already there.</p>

<p>That’s a root shell on a Linux computer we now own. It came online in about the same amount of time it would take to <code>ssh</code> into a host that already existed. We call these things “Sprites”.</p>

<p>Let’s install FFmpeg on our Sprite:</p>
<div>
  <div>
    <pre><code id="code-vs9glohc"><span>sudo </span>apt-get <span>install</span> <span>-y</span> ffmpeg <span>&gt;</span>/dev/null 2&gt;&amp;1
</code></pre>
  </div>
</div>
<p>Unlike creating the Sprite in the first place, installing <code>ffmpeg</code> with <code>apt-get</code> is dog slow. Let’s try not to have to do that again:</p>
<div>
  <div>
    <pre><code id="code-plnqfk4">sprite@sprite:~# sprite-env checkpoints create
<span># ...</span>
<span>{</span><span>&#34;type&#34;</span>:<span>&#34;complete&#34;</span>,<span>&#34;data&#34;</span>:<span>&#34;Checkpoint v1 created successfully&#34;</span>,
<span>&#34;time&#34;</span>:<span>&#34;2025-12-22T22:50:48.60423809Z&#34;</span><span>}</span>
</code></pre>
  </div>
</div>
<p>This completes instantly. Didn’t even bother to measure.</p>

<p>I step away to get coffee. Time passes. The Sprite, noticing my inactivity, goes to sleep. I meet an old friend from high school at the coffee shop. End up spending the day together. More time passes. Days even. Returning later:</p>
<div>
  <div>
    <pre><code id="code-4yuiqgnc"><span>&gt;</span> <span>$ </span>sprite console 
sprite@sprite:~# ffmpeg
ffmpeg version 7.1.1-1ubuntu1.3 Copyright <span>(</span>c<span>)</span> 2000-2025 the FFmpeg developers
Use <span>-h</span> to get full <span>help </span>or, even better, run <span>&#39;man ffmpeg&#39;</span>
sprite@sprite:~#
</code></pre>
  </div>
</div>
<p>Everything’s where I left it. Sprites are durable. 100GB capacity to start, no ceremony. Maybe I’ll keep it around a few more days, maybe a few months, doesn’t matter, just works.</p>

<p>Say I get an application up on its legs. Install more packages. Then: disaster. Maybe an ill-advised global <code>pip3 install</code> . Or <code>rm -rf $HMOE/bin</code>. Or <code>dd if=/dev/random of=/dev/vdb</code>. Whatever it was, everything’s broken. So:</p>
<div>
  <div>
    <pre><code id="code-j0542wkg"><span>&gt;</span> <span>$ </span>sprite checkpoint restore v1
Restoring from checkpoint v1...
Container components started successfully
Restore from v1 <span>complete</span>

<span>&gt;</span> <span>$ </span>sprite console
sprite@sprite:~#
</code></pre>
  </div>
</div>
<p>Sprites have first-class checkpoint and restore. You can’t see it in text, but that restore took about one second. It’s fast enough to use casually, interactively. Not an escape hatch. Rather: an intended part of the ordinary course of using a Sprite. Like <code>git</code>, but for the whole system.</p>
<div><p>If you’re asking how this is any different from an EC2 instance, good. That’s what we’re going for, except:</p>

<ul>
<li>I can <strong>casually create hundreds of them</strong> (without needing a Docker container), each  appearing in 1-2 seconds. 
</li><li>They <strong>go idle and stop metering automatically</strong>, so it’s cheap to have lots of them. I use dozens.
</li><li>They’re <strong>hooked up to our Anycast</strong> network, so I can get an HTTPS URL.
</li><li>Despite all that, <strong>they’re fully durable</strong>. They don’t die until I tell them to.
</li></ul>

<p>This combination of attributes isn’t common enough to already have a name, so we decided we get to name them “Sprites”. Sprites are like BIC disposable cloud computers.</p>
</div>
<p>That’s what we built. You can <a href="https://sprites.dev/" title="">go try it yourself</a>. We wrote another 1000 words about how they work, but I cut them out because I want to stop talking about our products now and get to my point.</p>
<h2 id="claude-doesnt-want-a-stateless-container"><a href="#claude-doesnt-want-a-stateless-container" aria-label="Anchor"></a><span>Claude Doesn’t Want A Stateless Container</span></h2>
<p>For years, we’ve been trying to serve two very different users with the same abstraction. It hasn’t worked.</p>

<p>Professional software developers are trained to build stateless instances. Stateless deployments, where persistent data is confined to database servers, buys you simplicity, flexible scale-out, and reduced failure blast radius. It’s a good idea, so popular that most places you can run code in the cloud look like stateless containers. Fly Machines, our flagship offering, look like stateless containers.</p>

<p>The problem is that Claude isn’t a pro developer. Claude is a hyper-productive five-year-old savant. It’s uncannily smart, wants to stick its finger in every available electrical socket, and works best when you find a way to let it zap itself.</p>
<p>(sometimes by escaping the container!)</p>
<p>If you force an agent to, it’ll work around containerization and do work . But you’re not helping the agent in any way by doing that. They don’t want  containers. They don’t want “sandboxes”. They want computers.</p>
<p>Someone asked me about this the other day and wanted to know if I was saying that agents needed sound cards and USB ports. And, maybe? I don’t know. Not today.</p>
<p>In a moment, I’ll explain why. But first I probably need to explain what the hell I mean by a “computer”. I think we all agree:</p>

<ul>
<li>A computer doesn’t necessarily vanish after a single job is completed, <em>and</em> 
</li><li>it has durable storage. 
</li></ul>

<p>Since current agent sandboxes have neither of these, I can stop the definition right there and get back to my point.</p>
<h2 id="simple-wins"><a href="#simple-wins" aria-label="Anchor"></a><span>Simple Wins</span></h2>
<p>Start here: with an actual computer, Claude doesn’t have to rebuild my entire development environment every time I pick up a PR.</p>

<p>This seems superficial but rebuilding stuff like <code>node_modules</code> is such a monumental pain in the ass that the industry is spending tens of millions of dollars figuring out how to snapshot and restore ephemeral sandboxes.</p>

<p>I’m not saying those problems are intractable. I’m saying they’re unnecessary. Instead of figuring them out, just use an actual computer. Work out a PR, review and push it, then just start on the next one. Without rebooting.</p>

<p>People will rationalize why it’s a good thing that they start from a new build environment every time they start a changeset. Stockholm Syndrome. When you start a feature branch on your own, do you create an entirely new development environment to do it?</p>

<p>The reason agents waste all this effort is that nobody saw them coming. Read-only ephemeral sandboxes were the only tool we had hanging on the wall to help use them sanely.</p>
<p>Have you ever had to set up actual infrastructure to give an agent access to realistic data? People do this. Because they know they’re dealing with a clean slate every time they prompt their agent, they arrange for S3 buckets, Redis servers, or even RDS instances outside the sandbox for their agents to talk to.  They’re building infrastructure to work around the fact that they can’t just write a file and trust it to stay put. Gross.</p>
<p>Ephemerality means time limits. Providers design sandbox systems to handle the expected workloads agents generate. Most things agents do today don’t take much time; in fact, they’re often limited only by the rate at which frontier models can crunch tokens. Test suites run quickly. The 99th percentile sandboxed agent run probably needs less than 15 minutes.</p>

<p>But there are feature requests where compute and network time swamp token crunching. I built the documentation site for the Sprites API by having a Claude Sprite interact with the code and our API, building and testing examples for the API one at a time. There are APIs where the client interaction time alone would blow sandbox budgets.</p>

<p>You see the limits of the current approach in how people round-trip state through “plan files”, which are ostensibly prose but often really just egregiously-encoded key-value stores.</p>

<p>An agent running on an actual computer can exploit the whole lifecycle of the application. We saw this when Chris McCord built <a href="https://phoenix.new/" title="">Phoenix.new</a>. The agent behind a Phoenix.new app runs on a Fly Machine where it can see the app logs from the Phoenix app it generated. When users do things that generate exceptions, Phoenix.new notices and gets to work figuring out what happened.</p>

<p>It took way too much work for Chris to set that up, and he was able to do it in part because he wrote his own agent. You can do it with Claude today with an MCP server or some other arrangement to haul logs over. But all you really need is to just not shoot your sandbox in the head when the agent finishes writing code.</p>
<h2 id="galaxy-brain-win"><a href="#galaxy-brain-win" aria-label="Anchor"></a><span>Galaxy Brain Win</span></h2>
<p>Here’s where I lose you. I know this because it’s also where I lose my team, most of whom don’t believe me about this.</p>

<p>The nature of software development is changing out from under us, and I think we’re kidding ourselves that it’s going to end with just a reconfiguration of how professional developers ship software.</p>

<p>I have kids. They have devices. I wanted some control over them. So I did what many of you would do in my situation: I vibe-coded an MDM.</p>

<p><img src="https://unplannedobsolescence.com/blog/code-and-let-live/assets/kurtmdm.png?1/2&amp;card&amp;center"/></p>

<p>I built this thing with Claude. It’s a SQLite-backed Go application running on a Sprite. The Anycast URL my Sprite exports works as an MDM registration URL. Claude also worked out all the APNS Push Certificate drama for me. It all just works.</p>
<p>“Editing PHP files over FTP: we weren’t wrong,  just ahead of our time!”</p>
<p>I’ve been running this for a month now, still on a Sprite, and see no reason ever to stop. It is a piece of software that solves an important real-world problem for me. It might evolve as my needs change, and I tell Claude to change it. Or it might not.  For this app, dev is prod, prod is dev.</p>

<p>For reasons we’ll get into when we write up how we built these things, you wouldn’t want to ship an app to millions of people on a Sprite. But most apps don’t want to serve millions of people. The most important day-to-day apps disproportionately won’t have million-person audiences. There are some important million-person apps, but most of them just destroy civil society, melt our brains, and arrange chauffeurs for  individual cheeseburgers.</p>

<p>Applications that solve real problems for people will be owned by the people they solve problems for. And for the most part, they won’t need a professional guild of software developers to gatekeep feature development for them. They’ll just ask for things and get them.</p>

<p>The problem we’re all working on is bigger than safely accelerating pro software developers. Sandboxes are holding us back.</p>
<h2 id="fuck-ephemeral-sandboxes"><a href="#fuck-ephemeral-sandboxes" aria-label="Anchor"></a><span>Fuck Ephemeral Sandboxes</span></h2>
<p>Obviously, I’m trying to sell you something here. But that doesn’t make me wrong. The argument I’m making is the reason we built the specific thing I’m selling.</p>
<figure>
  <figcaption>
    
    <p>You can create a couple dozen Sprites right now if you want. It’ll only take a second.</p>
      <a href="https://sprites.dev/">
        Make a Sprite.  <span>→</span>
      </a>
  </figcaption>
  <p><img src="https://unplannedobsolescence.com/static/images/cta-cat.webp" srcset="/static/images/cta-cat@2x.webp 2x" alt=""/>
  </p>
</figure>


<p>It took us a long time to get here. We spent years kidding ourselves. We built a platform for horizontal-scaling production applications with micro-VMs that boot so quickly that, if you hold them in exactly the right way, you can do a pretty decent code sandbox with them. But it’s always been a square peg, round hole situation.</p>

<p>We have a lot to say about how Sprites work. They’re related to Fly Machines but sharply different in important ways. They have an entirely new storage stack. They’re orchestrated differently. No Dockerfiles.</p>

<p>But for now, I just want you to think about what I’m saying here. Whether or not you ever boot a Sprite, ask: if you could run a coding agent anywhere, would you want it to look more like a read-only sandbox in a K8s cluster in the cloud, or like an entire EC2 instance you could summon in the snap of a finger?</p>

<p>I think the answer is obvious. The age of sandboxes is over. The time of the disposable computer has come.</p>

          
        </section>
        <dl>
            <dt>
              Previous post  ↓
            </dt>
            <dd>
              <a href="https://unplannedobsolescence.com/blog/litestream-vfs/">
                Litestream VFS
              </a>
            </dd>
        </dl>
      </article></div>
  </body>
</html>
