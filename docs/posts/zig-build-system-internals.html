<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mitchellh.com/zig/build-internals">Original</a>
    <h1>Zig build system internals</h1>
    
    <div id="readability-page-1" class="page"><div><details open=""><summary>Table of Contents</summary></details>
<p>Zig has a built-in build system for building projects. It runs on every platform Zig supports and is capable of building everything from simple executables and libraries to complex, multi-artifact, multi-step projects. This page will dive into how the internals of the Zig build system works.</p>
<p>Build systems are an extremely important detail of any software project. When they work, they can feel like magic: you execute a command, and after a series of potentially complicated steps, a working binary (or other artifact) is produced! When they don’t work, they can feel like confusing, non-transparent roadblocks that you wish didn’t exist. This is typical for any powerful tool: magic or a headache depending on the day and the task.</p>
<p>Understanding the internals of the build system are a way to remove that “magic” and make it easier to get things done. This page aims to go one level deep so that Zig users can understand how <code>zig build</code> works so they can hopefully be more productive everyday.</p>


<p>Before diving into details, we’ll describe the Zig build system at a zoomed-out level.</p>
<p>The Zig build system uses the <code>build.zig</code> file for configuration and the <code>zig build</code> CLI for execution. Within the <code>build.zig</code> file, developers must implement a build function (something like <code>fn build() void</code>). The build function has access to a builder API (<code>std.build.Builder</code>) for defining steps, dependencies, artifacts, etc. It is a mostly declarative API that the build system uses to determine what to execute and in what order.</p>
<p>If you’ve used <code>zig build</code> before to build a Zig project, you’ve probably noticed that it seems to sometimes compile twice; you see the output for semantic analysis and codegen twice. This is because on an uncached project, it <em>does</em> compile twice: it first compiles a build binary and then that build binary subsequently compiles your project code.</p>
<p>As just noted, the <code>zig build</code> CLI begins by compiling the <code>build.zig</code> file into a <em>build binary</em> for the running system and then subprocesses this binary to perform the actual build. The build binary benefits from the Zig cache system so that unless <code>build.zig</code> (or any imports) are modified, subsequent <code>zig build</code> commands do not have the recompilation cost.</p>
<p>The build binary is then executed which determines and runs the necessary steps to build the project. The build binary does not embed a Zig compiler; it further subprocesses to the Zig compiler to build individual artifacts as necessary.</p>
<p>A diagram of the high level steps is shown below:</p>
<div><pre><code><span>                                   ┌────────────────────┐
</span><span>                                   │                    │
</span><span>                                   │     zig build      │
</span><span>                                   │                    │
</span><span>                                   └────────────────────┘
</span><span>                                              │
</span><span>        ┌────────────────────┐                │
</span><span>        │                    │                ▼
</span><span>        │     build.zig      │──┐  ┌────────────────────┐
</span><span>        │                    │  │  │                    │
</span><span>        └────────────────────┘  ├─▶│    build binary    │
</span><span>        ┌────────────────────┐  │  │                    │
</span><span>        │  lib/std/special/  │  │  └────────────────────┘
</span><span>        │  build_runner.zig  │──┘             │
</span><span>        │                    │                │
</span><span>        └────────────────────┘                ▼
</span><span>        ┌────────────────────┐     ┌────────────────────┐┌───────┐
</span><span>        │                    │     │                    ││       │
</span><span>        │    source files    │────▶│   zig build-exe    ││  ...  │
</span><span>        │                    │     │                    ││       │
</span><span>        └────────────────────┘     └────────────────────┘└───────┘
</span><span>                                              │
</span><span>                                              │
</span><span>                                              ▼
</span><span>                                   ┌────────────────────┐
</span><span>                                   │    artifact(s)     │
</span><span>                                   │ (exe, libs, etc.)  │
</span><span>                                   │                    │
</span><span>                                   └────────────────────┘
</span></code></pre></div>

<p>The <code>zig build</code> process does only two things: (1) build the <em>build binary</em> and (2) execute the build binary as a child process. The first step — building the <em>build binary</em> — uses the <code>build.zig</code> file as input but doesn’t yet <em>execute</em> the <code>build</code> function.</p>
<p>The source for <code>zig build</code> can be found in <code>src/main.zig</code> and is implemented in the function <code>cmdBuild</code>. It isn’t an overly complex function and I recommend reading it through. There is an initial block that builds the build binary, and then a subsequent set of logic that subprocesses to it.</p>
<p>The build binary uses <code>lib/std/special/build_runner.zig</code> as the main entrypoint for the build. If you look at this file you’ll see a <code>pub fn main</code>. This is the main entrypoint for the actual build binary.</p>
<p>The entrypoint file imports <code>@build</code>, this is a special package that <code>cmdBuild</code> defines to point to your <code>build.zig</code> file. This is how the build runner eventually executes the <code>build</code> function in your <code>build.zig</code> file.</p>
<p>The final build binary is not installed anywhere. It is stored in the Zig cache directory (usually <code>zig-cache</code> relative to your <code>build.zig</code> file). You can prove to yourself the build binary exists by looking for it:</p>
<div><pre><code><span><span><span>$</span> <span><span>find</span> ./zig-cache -type f -name <span>&#39;build&#39;</span></span></span>
</span><span><span>./zig-cache/o/c4c75a71df444bff10945728759e174c/build
</span></span></code></pre></div>
<h2 id="finding-build_runnerzig"><a href="#finding-build_runnerzig" aria-hidden="true" tabindex="-1"><span></span></a>Finding “build_runner.zig”</h2>
<p>How does <code>zig build</code> know where <code>lib/std/special/build_runner.zig</code> is on your system?</p>
<p>There is a file <code>src/introspect.zig</code> that has an API that is used to find the Zig installation. It works by starting at the directory of the current executable and traversing upwards until it finds either <code>lib/zig/std/std.zig</code> or <code>lib/std/std.zig</code>. When you execute <code>zig build</code>, it starts at the directory where the <code>zig</code> binary is and begins looking for these files.</p>
<div><p><strong>NOTE:</strong> This is also how <code>@import(&#34;std&#34;)</code> is resolved in projects. Specifically, the <code>std</code> package is defined ahead of time to point to <code>std.zig</code> using the introspection API from the <code>zig</code> CLI during the build process.</p></div>
<p>The implementation of the function that looks for the stdlib is shown below. From this directory, you can get any file in a standard Zig installation.</p>
<div><pre><code><span><span>fn</span> <span>testZigInstallPrefix</span><span>(</span>base_dir<span>:</span> <span>fs<span>.</span>Dir</span><span>)</span> <span><span>?</span>Compilation<span>.</span>Directory</span> <span>{</span>
</span><span>    <span>const</span> test_index_file <span>=</span> <span>&#34;std&#34;</span> <span>++</span> fs<span>.</span>path<span>.</span>sep_str <span>++</span> <span>&#34;std.zig&#34;</span><span>;</span>
</span><span>
</span><span>    <span>zig_dir</span><span>:</span> <span>{</span>
</span><span>        
</span><span>        <span>const</span> lib_zig <span>=</span> <span>&#34;lib&#34;</span> <span>++</span> fs<span>.</span>path<span>.</span>sep_str <span>++</span> <span>&#34;zig&#34;</span><span>;</span>
</span><span>        <span>var</span> test_zig_dir <span>=</span> base_dir<span>.</span><span>openDir</span><span>(</span>lib_zig<span>,</span> <span>.</span><span>{</span><span>}</span><span>)</span> <span>catch</span> <span>break</span> <span>:</span><span>zig_dir</span><span>;</span>
</span><span>        <span>const</span> file <span>=</span> test_zig_dir<span>.</span><span>openFile</span><span>(</span>test_index_file<span>,</span> <span>.</span><span>{</span><span>}</span><span>)</span> <span>catch</span> <span>{</span>
</span><span>            test_zig_dir<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</span><span>            <span>break</span> <span>:</span><span>zig_dir</span><span>;</span>
</span><span>        <span>}</span><span>;</span>
</span><span>        file<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</span><span>        <span>return</span> <span>Compilation<span>.</span>Directory</span><span>{</span> <span>.</span>handle <span>=</span> test_zig_dir<span>,</span> <span>.</span>path <span>=</span> lib_zig <span>}</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    
</span><span>    <span>var</span> test_zig_dir <span>=</span> base_dir<span>.</span><span>openDir</span><span>(</span><span>&#34;lib&#34;</span><span>,</span> <span>.</span><span>{</span><span>}</span><span>)</span> <span>catch</span> <span>return</span> <span>null</span><span>;</span>
</span><span>    <span>const</span> file <span>=</span> test_zig_dir<span>.</span><span>openFile</span><span>(</span>test_index_file<span>,</span> <span>.</span><span>{</span><span>}</span><span>)</span> <span>catch</span> <span>{</span>
</span><span>        test_zig_dir<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</span><span>        <span>return</span> <span>null</span><span>;</span>
</span><span>    <span>}</span><span>;</span>
</span><span>    file<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>return</span> <span>Compilation<span>.</span>Directory</span><span>{</span> <span>.</span>handle <span>=</span> test_zig_dir<span>,</span> <span>.</span>path <span>=</span> <span>&#34;lib&#34;</span> <span>}</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<h2 id="manually-building-the-build-binary"><a href="#manually-building-the-build-binary" aria-hidden="true" tabindex="-1"><span></span></a>Manually Building the Build Binary</h2>
<p>To further remove any magic, let’s build the build binary manually. Later on this page, we’ll execute this binary manually, but we’ll start with just building it.</p>
<p>For our example, we’ll build the <code>build.zig</code> file for the Zig compiler itself. Clone the <a target="_blank" rel="noopener noreferrer" href="https://github.com/ziglang/zig/">Zig source code</a> and have <code>zig</code> installed (ideally a version compiled from the source you check out, but any recent version should work). Next, from the checkout directory, we can build the build binary:</p>
<div><pre><code><span><span><span>$</span> <span>zig build-exe <span>\</span>
</span></span></span><span><span><span>    --pkg-begin <span>&#39;@build&#39;</span> build.zig <span>\</span>
</span></span></span><span><span><span>    --pkg-end <span>\</span>
</span></span></span><span><span><span>    -femit-bin<span>=</span>custom-builder <span>\</span>
</span></span></span><span><span><span>    lib/std/special/build_runner.zig</span></span>
</span></code></pre></div>
<p>That’s it! After running the command, the <code>custom-builder</code> executable should exist. This is identical to the executable that is created when <code>zig build</code> is called.</p>
<p>The command-line invocation helps make it really clear that our main package is the <code>build_runner.zig</code> file from the standard library and that our <code>build.zig</code> file is exposed as the <code>@build</code> package.</p>
<p>This is half of what <code>zig build</code> does under the covers.</p>

<p>After the build binary is built, <code>zig build</code> spawns a child process and immediately executes it.</p>
<p>The binary expects four positional arguments in the following order:</p>
<ol>
<li>Path to the Zig compiler</li>
<li>Path to the build root where <code>build.zig</code> is — although importantly it does <em>not</em> need access to the <code>build.zig</code> file anymore. It uses this only to resolve build-relative paths from your <code>build.zig</code> code that was already compiled into the binary.</li>
<li>Path to the local cache directory (does not have to exist).</li>
<li>Path to the global cache directory (does not have to exist).</li>
</ol>
<p>The <code>zig build</code> implementation automatically populates these arguments then forwards any additional arguments to the build binary and executes it. This binary performs the actual project build.</p>
<div><p>As a reminder, the <code>main</code> entrypoint function for the build binary is defined in <code>lib/std/special/build_runner.zig</code>. It isn’t complicated and I recommend you read the file. The actual builder API (<code>std.build.Builder</code>) gets more complicated so I recommend starting by just reading the <code>build_runner.zig</code> file to understand the high-level control flow.</p></div>
<h2 id="manually-invoking-the-build-binary"><a href="#manually-invoking-the-build-binary" aria-hidden="true" tabindex="-1"><span></span></a>Manually Invoking the Build Binary</h2>
<p>If you created the <code>custom-builder</code> binary from the previous section, you can now manually invoke it to perform a full build of the Zig compiler.</p>
<p>As a reminder, in practice <strong>you never have to do this</strong> because <code>zig build</code> does this. We’re only manually executing the build binary to illustrate how <code>zig build</code> works internally.</p>
<div><pre><code><span><span><span>$</span> <span>./custom-builder <span><span>$(</span><span>which</span> zig<span>)</span></span> <span>.</span> ./cache ./global-cache</span></span>
</span></code></pre></div>
<p>We used the Zig compiler as our example, but this same pattern would work for any project that uses the Zig build system.</p>
<h2 id="supported-arguments-and-flags"><a href="#supported-arguments-and-flags" aria-hidden="true" tabindex="-1"><span></span></a>Supported Arguments and Flags</h2>
<p>The build binary supports almost every flag <code>zig build</code> supports. In fact, <code>zig build</code> blindly copies all arguments directly to the build binary child process except for a limited set that directly control the build binary building process.</p>
<p>You can see this in action by executing the build binary with the <code>--help</code> flag (along with the four required positional arguments). If you manually built the build binary from the previous section, you can try it now:</p>
<div><pre><code><span><span><span>$</span> <span>./custom-builder <span><span>$(</span><span>which</span> zig<span>)</span></span> <span>.</span> ./cache ./global-cache --help</span></span>
</span></code></pre></div>
<p>The four positional arguments assume that <code>zig</code> is on your PATH and that your current working directory is the build root where the <code>build.zig</code> file exists.</p>
<p>The help will look pretty much identical to <code>zig build --help</code> because it is! <code>zig build --help</code> builds the build binary first, then forward the <code>--help</code> flag to the child process. The output should exactly match.</p>
<h2 id="invoking-the-build-function"><a href="#invoking-the-build-function" aria-hidden="true" tabindex="-1"><span></span></a>Invoking the Build Function</h2>
<p>Something I found really interesting was how the build runner invokes the
<code>build</code> function in the <code>build.zig</code> file. The build runner uses Zig&#39;s
<a target="_blank" rel="noopener noreferrer" href="https://ziglang.org/documentation/master/#comptime">comptime capabilities</a>
to introspect on the function signature of the <code>build</code> function in order
to support multiple function signatures.</p>
<p>The <code>runBuild</code> function from <code>build_runner.zig</code> is reproduced below to
show this in action:</p>
<div><pre><code><span><span>fn</span> <span>runBuild</span><span>(</span>builder<span>:</span> <span><span>*</span>Builder</span><span>)</span> <span><span>anyerror</span><span>!</span><span>void</span></span> <span>{</span>
</span><span>    <span>switch</span> <span>(</span><span>@typeInfo</span><span>(</span><span>@typeInfo</span><span>(</span><span>@TypeOf</span><span>(</span>root<span>.</span>build<span>)</span><span>)</span><span>.</span>Fn<span>.</span>return_type<span>.?</span><span>)</span><span>)</span> <span>{</span>
</span><span>        <span>.</span>Void <span>=&gt;</span> root<span>.</span><span>build</span><span>(</span>builder<span>)</span><span>,</span>
</span><span>        <span>.</span>ErrorUnion <span>=&gt;</span> <span>try</span> root<span>.</span><span>build</span><span>(</span>builder<span>)</span><span>,</span>
</span><span>        <span>else</span> <span>=&gt;</span> <span>@compileError</span><span>(</span><span>&#34;expected return type of build to be &#39;void&#39; or &#39;!void&#39;&#34;</span><span>)</span><span>,</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>This allows the <code>build</code> function signature to be both:</p>
<ul>
<li><code>fn build(*std.build.Builder) void</code></li>
<li><code>fn build(*std.build.Builder) !void</code> (note the <code>!void</code>)</li>
</ul>
<p>And more specifically, the error union case (the second case) can be any
error union. It can be an inferred error union like in the list above or
it can be an explicitly defined error union.</p>
<p>In terms of understanding how the build system works, this is not a very
important detail, but this is an example of a cool inner working you can discover
by studying the implementation of tools. It also showed me a cool comptime
use case.</p>

<p>We’ve seen how <code>zig build</code> creates a dedicated build binary using the <code>build.zig</code> file and how that build binary can be executed to build your project, but <em>what is the build binary actually doing and how does it relate to the <code>build.zig</code> file?</em></p>
<p>The build binary invokes the user-defined <code>build</code> function from the <code>build.zig</code> file. This build function is given a pointer to a <code>std.build.Builder</code> as an argument which is used to declaratively define the available flags, targets, target dependencies, etc. of the build. Finally, the build runner (<code>build_runner.zig</code>) executes the steps in dependency order for the given target.</p>
<h2 id="defining-a-step"><a href="#defining-a-step" aria-hidden="true" tabindex="-1"><span></span></a>Defining a Step</h2>
<p>The <code>Builder</code> argument has a lot of functionality but it’s core goal is to build up a set of steps.</p>
<p>A “top level step” is a special distinction made for steps that can be invoked by name, i.e. <code>zig build &lt;name&gt;</code>. There are two predefined top level steps: “install” and “uninstall”. Additional top level steps can be created with the <code>step</code> function. Beyond having a designated invokable name, a top level step is functionally equivalent to any other step. The <code>Builder</code> maintains the set of top level steps in an <code>ArrayList</code>.</p>
<p>All steps can have zero or more dependencies specified by calling the <code>dependOn</code> function on a <code>Step</code>. This maintains the dependencies in a simple <code>ArrayList</code>.</p>
<h2 id="invoking-a-top-level-step"><a href="#invoking-a-top-level-step" aria-hidden="true" tabindex="-1"><span></span></a>Invoking a Top Level Step</h2>
<p>One or more top level steps is invoked by calling the <code>make</code> function on <code>Builder</code>. This internally calls <code>makeOneStep</code> which makes a single top level step. <code>makeOneStep</code> is really simple and the entire implementation is shown below:</p>
<div><pre><code><span><span>fn</span> <span>makeOneStep</span><span>(</span>self<span>:</span> <span><span>*</span>Builder</span><span>,</span> s<span>:</span> <span><span>*</span>Step</span><span>)</span> <span><span>anyerror</span><span>!</span><span>void</span></span> <span>{</span>
</span><span>    <span>if</span> <span>(</span>s<span>.</span>loop_flag<span>)</span> <span>{</span>
</span><span>        <span>warn</span><span>(</span><span>&#34;Dependency loop detected:\n  {s}\n&#34;</span><span>,</span> <span>.</span><span>{</span>s<span>.</span>name<span>}</span><span>)</span><span>;</span>
</span><span>        <span>return</span> <span>error</span><span>.</span>DependencyLoopDetected<span>;</span>
</span><span>    <span>}</span>
</span><span>    s<span>.</span>loop_flag <span>=</span> <span>true</span><span>;</span>
</span><span>
</span><span>    <span>for</span> <span>(</span>s<span>.</span>dependencies<span>.</span>items<span>)</span> <span>|</span>dep<span>|</span> <span>{</span>
</span><span>        self<span>.</span><span>makeOneStep</span><span>(</span>dep<span>)</span> <span>catch</span> <span>|</span>err<span>|</span> <span>{</span>
</span><span>            <span>if</span> <span>(</span>err <span>==</span> <span>error</span><span>.</span>DependencyLoopDetected<span>)</span> <span>{</span>
</span><span>                <span>warn</span><span>(</span><span>&#34;  {s}\n&#34;</span><span>,</span> <span>.</span><span>{</span>s<span>.</span>name<span>}</span><span>)</span><span>;</span>
</span><span>            <span>}</span>
</span><span>            <span>return</span> err<span>;</span>
</span><span>        <span>}</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    s<span>.</span>loop_flag <span>=</span> <span>false</span><span>;</span>
</span><span>
</span><span>    <span>try</span> s<span>.</span><span>make</span><span>(</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<p><code>makeOneStep</code> goes through one dependency at a time in the order they were added and invokes <code>makeOneStep</code> recursively. The <code>loop_flag</code> on each step is used to detect cycles (instead of building a graph structure or something more fancy). Finally, the step itself is invoked via <code>make</code>.</p>
<h2 id="anatomy-of-a-step"><a href="#anatomy-of-a-step" aria-hidden="true" tabindex="-1"><span></span></a>Anatomy of a Step</h2>
<p>The <code>Step</code> structure is a relatively simple interface-like structure with some state attached to it. The unique logic for a step is encapsulated in the <code>makeFn</code> function pointer while the rest of the fields are shared state.</p>
<div><pre><code><span><span>pub</span> <span>const</span> <span>Step</span> <span>=</span> <span>struct</span> <span>{</span>
</span><span>    id<span>:</span> <span>Id</span><span>,</span>
</span><span>    name<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span>
</span><span>    makeFn<span>:</span> <span>fn</span> <span>(</span>self<span>:</span> <span><span>*</span>Step</span><span>)</span> <span>anyerror</span><span>!</span><span>void</span><span>,</span>
</span><span>    dependencies<span>:</span> <span>ArrayList</span><span>(</span><span>*</span>Step<span>)</span><span>,</span>
</span><span>    loop_flag<span>:</span> <span><span>bool</span></span><span>,</span>
</span><span>    done_flag<span>:</span> <span><span>bool</span></span><span>,</span>
</span><span>
</span><span>    
</span><span><span>}</span><span>;</span>
</span></code></pre></div>
<p>The <code>name</code> is used for debugging purposes only, unless this is a top level step. The <code>loop_flag</code> and <code>dependencies</code> were already covered previously. The <code>done_flag</code> makes it so that a step executes exactly ones. Subsequent execution is a noop.</p>
<p>With this knowledge in hand, it should be directionally clear how one could go about creating a custom step. The built-in steps provide all the functionality necessary for building most projects.</p>
<h2 id="declarative-vs-imperative"><a href="#declarative-vs-imperative" aria-hidden="true" tabindex="-1"><span></span></a>Declarative vs. Imperative</h2>
<p>The <code>build</code> function defines the set of steps and their dependencies, but <em>does not execute them</em>. One way to describe this would be that the <code>build.zig</code> file declaratively defines the build steps. This is an important concept to understand to avoid some common pitfalls I’ve seen people make with build systems in general, including Zig.</p>
<p>Because the steps are declaratively defined, you must be thoughtful to understand when and where logic actually occurs. If you have a step that reads a file that is generated by a previous step, then that must be done using a custom step with the <code>makeFn</code>. You can’t create the step and then read the file in the <code>build</code> function because <em>it hasn’t yet executed.</em></p>
<p>On the other hand, if you’re trying to programmatically create a series of steps for a set of files that exist prior to any build steps running, you can (and likely should) do that directly in the <code>build</code> function so that the steps are fully defined. You can’t dynamically define steps at build execution time.</p>
<div><p><strong>Advanced note:</strong>  You can’t dynamically define steps at execution time <em>into the existing step graph</em>. But, you could create a custom step that dynamically creates other steps and executes them directly.</p></div>

<p>It is now understood how <code>build.zig</code> defines steps, how those steps are
structured, and how they&#39;re invoked. The Zig <code>Builder</code> structure has high-level
helpers for building executables, objects, etc. Let&#39;s take a deeper look at
how that works.</p>
<p>All compilation-related functionality shares a single implementation as
the <code>LibExeObjStep</code>. An executable, library, or other object tpe is built depending
on the field values for the step structure. The details of this are usually
hidden behind helpers such as <code>addExecutable</code> or <code>addSharedLibrary</code>.</p>
<p>The implementation for <code>LibExeObjStep</code> can be found in <code>lib/std/build.zig</code>.
The step has a rich set of functionality and is such an important part of the
build process that I highly recommend studying the full step, although it is
a relatively large number of lines of code.</p>
<p>The step implementation works by subprocessing back out to the <code>zig</code> compiler.
The <code>make</code> implementation takes the configuration on the step and builds up
a set of command-line arguments and then invokes <code>zig build-exe</code> or <code>zig build-obj</code>
or some other Zig command. Recall that the path to the Zig CLI is the first
required positional argument for the build binary; this is the primary
use case for that argument.</p>
<p>Importantly, this means that the build binary does not embed the full Zig
compiler. Further, the build binary can point to different versions of Zig
if you wanted to!</p>

<p>My primary takeaway from studying the internals of the Zig build system is that <em>its just Zig</em>. You can do anything you want in the <code>build.zig</code> file because it is compiled into a fully fledged executable for your current system. Zig gives you an opinionated structure and set of built-in steps, but you have the full power of Zig available to build your project.</p>
<p>I deeply believe that understanding the layer beneath the tools we use everyday makes us better tool users. It eliminates any mystery by exposing the machines inner workings, and I tend to find the inner workings are always simpler than I expected. The next time you’re wondering if you can do something with the build system or why the build system isn’t working the way you want, hopefully this deeper knowledge can help get you to an answer more quickly.</p></div></div>
  </body>
</html>
