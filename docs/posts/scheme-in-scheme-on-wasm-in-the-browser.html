<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spritely.institute/news/scheme-in-scheme-on-wasm-in-the-browser.html">Original</a>
    <h1>Scheme in Scheme on WASM in the Browser</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="http://tinylogger.com/static/images/blog/hoot-meta-repl.gif" alt="Hoot metacircular evaluator demo recording"/></p><p>Hey, folks!  Today we want to talk about the wonderful
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">read-eval-print-loop
(REPL)</a>.
Thanks to WebAssembly (Wasm), it&#39;s becoming increasingly common for
programming language websites to embed a REPL in which passersby can
easily evaluate code and get a feel for the language without having to
install anything on their computer.  We&#39;d like to do the same thing
for our language of choice, <a href="https://gnu.org/software/guile">Guile
Scheme</a>, using <a href="http://tinylogger.com/hoot">Guile Hoot</a>.</p><p>Guile Hoot is a Scheme-to-Wasm compiler that leverages the <a href="https://developer.chrome.com/blog/wasmgc">Wasm
garbage collection (GC)
extension</a> that has been
rolling out to major browsers recently.  Wasm GC has finally made it
possible to use <a href="https://en.wikipedia.org/wiki/Dynamic_programming_language">dynamic
languages</a>
<em>besides JavaScript</em> on the client-side web, but it will still take
some additional effort to bring our favorite tools along for the ride.
In this post, we&#39;ll walk through building a tiny Scheme interpreter
with a simple user interface and explain what&#39;s in store for the
future.</p><p>To learn more about Hoot, check out the <a href="http://tinylogger.com/news/guile-hoot-v020-released.html">0.2.0 release
announcement</a> from a couple of
weeks ago!</p><h3>The case of the missing REPL</h3><p>For Scheme programmers (and Lisp programmers in general), the REPL is
at the core of our development workflow.  We modify some code in our
text editor, evaluate it in the REPL, inspect the output or enter a
debugger, and repeat the process until the program behaves the way we
want.</p><p>We&#39;re used to having a native REPL process running directly on our
operating system, but since Hoot is putting Scheme on the web, we&#39;d
really like a REPL available in the browser, too.  A web REPL would be
convenient for seasoned Schemers and newcomers alike.  However, at
this early stage in Hoot&#39;s development, a fully-featured Scheme REPL
is not yet possible.  We don&#39;t have access to the macro expander,
interpreter, etc. from the comfort of our Wasm runtime... yet.</p><p>We&#39;ll have these things eventually, but what can we have now?</p><p>Well, we could implement an interpreter for a small subset of
Scheme... in Scheme!  Sounds pretty recursive, and if you know
anything about Schemers you know we love recursion (and also, that we
love recursion), so let&#39;s give it a shot!</p><h3>Scheme in Scheme</h3><p>In Chapter 4 of the classic computer science textbook <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-25.html#%_chap_4">Structure and
Interpretation of Computer
Programs</a>
(SICP), Gerald Sussman and Hal Abelson walk through building a small
Scheme interpreter embedded in Scheme.  They called this the
&#34;metacircular evaluator&#34;, meaning that it&#39;s an interpreter written in
the language that it is interpreting.</p><p>This sounds pretty fancy — the kind of task reserved for MIT
professors that write iconic textbooks — but implementing a Scheme
interpreter is simpler than one might think!  For one thing, since
Scheme can manipulate its own syntax by design, we don&#39;t need to spend
any time parsing, a notoriously complex subject in its own right.  We
can skip directly to the fun part instead: evaluation!</p><p>Spritely&#39;s own <a href="https://spritely.institute/static/papers/scheme-primer.html">Scheme
Primer</a>
distills SICP&#39;s interpreter into a much simpler form intended for
people who are brand new to Scheme.  The code examples in the rest of
this post are derived from the &#34;Scheme in Scheme&#34; section of the
Primer.  If you&#39;re completely new to Scheme and want to better
understand the code in this post, consider working through our Primer
sometime!</p><p><img src="http://tinylogger.com/static/images/blog/eval-apply.png" alt="eval/apply diagram from Andres Raba&#39;s unofficial SICP, licensedunder Creative Commons Attribution-ShareAlike 4.0 InternationalLicense"/></p><p>The metacircular evaluator is composed of two main components: <code>eval</code>
and <code>apply</code>:</p><ul><li><code>eval</code> processes an expression in the context of an environment.</li><li><code>apply</code> calls a procedure (function) with a list of arguments.</li></ul><p>The output of <code>eval</code> is fed to <code>apply</code>, which may feed more input to
<code>eval</code>, and this mutually recursive cycle continues until the program
runs out of expressions to evaluate.</p><p>In order to implement <code>eval</code>, we first need a way to represent
environments.  An environment maps variable names to their bound
values.  We&#39;ll use <a href="https://en.wikipedia.org/wiki/Association_list">association
lists</a> for our
environments.</p><p>An empty environment with no variable bindings is represented by the
empty list <code>&#39;()</code>.</p><p>The first bit of code from the metacircular evaluator we&#39;ll cover is
the <code>extend-env</code> procedure, which creates a new environment by
extending an existing one:</p><pre><code><span>(</span><span>define</span> <span>(</span><span>extend-env</span> <span>env</span> <span>names</span> <span>vals</span><span>)</span>
  <span>;; If there are no more variables to add to env, return env.
</span>  <span>(</span><span>if</span> <span>(</span><span>null?</span> <span>names</span><span>)</span>
      <span>env</span>
      <span>;; Otherwise, add the first binding to the recursive
</span>      <span>;; extension of env with the rest of the bindings.
</span>      <span>(</span><span>cons</span> <span>(</span><span>cons</span> <span>(</span><span>car</span> <span>names</span><span>)</span> <span>(</span><span>car</span> <span>vals</span><span>)</span><span>)</span>
            <span>(</span><span>extend-env</span> <span>env</span> <span>(</span><span>cdr</span> <span>names</span><span>)</span> <span>(</span><span>cdr</span> <span>vals</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>We can extend the empty environment to make a new environment that
includes the variable <code>foo</code>:</p><pre><code><span>(</span><span>extend-env</span> <span>&#39;</span><span>(</span><span>)</span> <span>&#39;</span><span>(</span><span>foo</span><span>)</span> <span>&#39;</span><span>(</span><span>1</span><span>)</span><span>)</span> <span>; =&gt; ((foo . 1))</span></code></pre><p>We can further extend that environment to make a new environment that
includes the variable <code>bar</code>:</p><pre><code><span>(</span><span>extend-env</span> <span>&#39;</span><span>(</span><span>(</span><span>foo</span> <span>.</span> <span>1</span><span>)</span><span>)</span> <span>&#39;</span><span>(</span><span>bar</span><span>)</span> <span>&#39;</span><span>(</span><span>2</span><span>)</span><span>)</span> <span>; =&gt; ((bar . 2) (foo . 1))</span></code></pre><p>Note that environment manipulation is implemented in a
<a href="https://en.wikipedia.org/wiki/Functional_programming">functional</a>
style.  Extending an environment does not mutate the original one.
This is because mutating the original environment would propagate the
new bindings to other evaluation contexts, potentially breaking
Scheme&#39;s <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">lexical scoping
rules</a>.</p><p>We can look up a variable&#39;s value using the <code>env-lookup</code> procedure:</p><pre><code><span>(</span><span>define</span> <span>(</span><span>env-lookup</span> <span>env</span> <span>name</span><span>)</span>
  <span>;; Lookup name in association list.
</span>  <span>(</span><span>match</span> <span>(</span><span>assq</span> <span>name</span> <span>env</span><span>)</span>
    <span>;; Success: return the bound value.
</span>    <span>(</span><span>(</span><span>_</span> <span>.</span> <span>val</span><span>)</span> <span>val</span><span>)</span>
    <span>;; Failure: throw an error.
</span>    <span>(</span><span>#f</span> <span>(</span><span>error</span> <span>&#34;Variable unbound:&#34;</span> <span>name</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>Example:</p><pre><code><span>(</span><span>env-lookup</span> <span>&#39;</span><span>(</span><span>(</span><span>foo</span> <span>.</span> <span>1</span><span>)</span><span>)</span> <span>&#39;foo</span><span>)</span> <span>; =&gt; 1</span></code></pre><p>And now for the rest of the owl.  Our toy <code>eval</code> supports:</p><ul><li>booleans</li><li>numbers</li><li>strings</li><li>quoted expressions</li><li>conditionals</li><li>procedures as values</li><li>procedure calls</li></ul><pre><code><span>(</span><span>define</span> <span>(</span><span>eval</span> <span>expr</span> <span>env</span><span>)</span>
  <span>(</span><span>match</span> <span>expr</span>
    <span>;; Booleans, numbers, strings
</span>    <span>(</span><span>(</span><span>or</span> <span>(</span><span>?</span> <span>boolean?</span><span>)</span> <span>(</span><span>?</span> <span>number?</span><span>)</span> <span>(</span><span>?</span> <span>string?</span><span>)</span><span>)</span>
     <span>expr</span><span>)</span>
    <span>;; Quoted expressions
</span>    <span>(</span><span>(</span><span>&#39;quote</span> <span>quoted-expr</span><span>)</span>
     <span>quoted-expr</span><span>)</span>
    <span>;; Variable lookup
</span>    <span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>name</span><span>)</span>
     <span>(</span><span>env-lookup</span> <span>env</span> <span>name</span><span>)</span><span>)</span>
    <span>;; Conditionals
</span>    <span>(</span><span>(</span><span>&#39;if</span> <span>test</span> <span>consequent</span> <span>alternate</span><span>)</span>
     <span>(</span><span>if</span> <span>(</span><span>eval</span> <span>test</span> <span>env</span><span>)</span>
         <span>(</span><span>eval</span> <span>consequent</span> <span>env</span><span>)</span>
         <span>(</span><span>eval</span> <span>alternate</span> <span>env</span><span>)</span><span>)</span><span>)</span>
    <span>;; Procedures
</span>    <span>(</span><span>(</span><span>&#39;lambda</span> <span>args</span> <span>body</span><span>)</span>
     <span>(</span><span>lambda</span> <span>vals</span>
       <span>(</span><span>eval</span> <span>body</span> <span>(</span><span>extend-env</span> <span>env</span> <span>args</span> <span>vals</span><span>)</span><span>)</span><span>)</span><span>)</span>
    <span>;; Procedure application
</span>    <span>(</span><span>(</span><span>proc-expr</span> <span>.</span> <span>arg-exprs</span><span>)</span>
     <span>;; Recursively evaluate the procedure expression and all
</span>     <span>;; argument expressions, then apply the procedure with the
</span>     <span>;; arguments.
</span>     <span>(</span><span>apply</span> <span>(</span><span>eval</span> <span>proc-expr</span> <span>env</span><span>)</span>
            <span>;; Recursively evaluate the arguments.
</span>            <span>(</span><span>map</span> <span>(</span><span>lambda</span> <span>(</span><span>arg-expr</span><span>)</span>
                   <span>(</span><span>eval</span> <span>arg-expr</span> <span>env</span><span>)</span><span>)</span>
                 <span>arg-exprs</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>Fortunately, we don&#39;t need to implement <code>apply</code> ourselves.  Since
<code>lambda</code> forms in our interpreter evaluate to regular Scheme
procedures, we can just use Scheme&#39;s built-in <code>apply</code> to pass
arguments to them.  Calling a procedure will recursively call <code>eval</code>
on the procedure&#39;s body expression.</p><p>Example:</p><pre><code><span>(</span><span>eval</span> <span>&#39;</span><span>(</span><span>+</span> <span>1</span> <span>2</span> <span>3</span><span>)</span> <span>`</span><span>(</span><span>(</span><span>+</span> <span>.</span> <span>,+</span><span>)</span><span>)</span><span>)</span> <span>; =&gt; 6</span></code></pre><p>Incidentally, we&#39;ve created a
<a href="https://en.wikipedia.org/wiki/Capability-based_security">capability-secure</a>
system reminiscent of <a href="https://webassembly.github.io/spec/core/intro/introduction.html#security-considerations">Wasm&#39;s security
model</a>!
The program <code>(+ 1 2 3)</code> only has access to the <code>+</code> procedure from our
Scheme runtime.  Aside from creating unbounded loops, a devious
developer can&#39;t do any harm if their code is evaluated in this
restricted environment.  Neat!</p><h3>Scheme in Scheme on Wasm</h3><p>Now that we have a simple evaluator, we can compile it with Hoot to
run it inside a web browser.  But to actually use it, we need a user
interface.  To make one, we can borrow the React-like rendering code
we walked through in our previous tutorial on rendering web pages with
Wasm, <a href="http://tinylogger.com/news/building-interactive-web-pages-with-guile-hoot.html">&#34;Building interactive web pages with Guile
Hoot&#34;</a>!</p><p>For simplicity, we&#39;ll go for a minimalist design reminiscent of a
terminal.  As for the REPL output log, we can store it as a list of
strings.  Let&#39;s pre-populate it with a friendly welcome message:</p><pre><code><span>(</span><span>define</span> <span>*log*</span>
  <span>&#39;</span><span>(</span><span>&#34;Welcome to the Hoot metacircular evaluator demo!

This is a miniature Scheme interpreter written in Scheme that&#39;s been
compiled to WebAssembly, and is running directly in the browser!  Its
UI is also written in Scheme, and uses the Hoot FFI to render itself
to the DOM.

&#34;</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>log-append!</span> <span>.</span> <span>lines</span><span>)</span>
  <span>(</span><span>set!</span> <span>*log*</span> <span>(</span><span>append</span> <span>*log*</span> <span>lines</span><span>)</span><span>)</span><span>)</span></code></pre><p>Here&#39;s the rendering template, which prints all the log lines, and
appends the classic <code>&gt;</code> prompt and a <code>textarea</code> to the bottom so the
user can write some Scheme code:</p><pre><code><span>(</span><span>define</span> <span>prompt</span> <span>&#34;&gt; &#34;</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>render</span><span>)</span>
  <span>`</span><span>(</span><span>div</span> <span>(</span><span>@</span> <span>(</span><span>class</span> <span>&#34;container&#34;</span><span>)</span><span>)</span>
        <span>(</span><span>h1</span> <span>&#34;Hoot REPL&#34;</span><span>)</span>
        <span>(</span><span>div</span> <span>(</span><span>@</span> <span>(</span><span>id</span> <span>&#34;repl&#34;</span><span>)</span>
                <span>(</span><span>class</span> <span>&#34;repl repl-text&#34;</span><span>)</span><span>)</span>
             <span>(</span><span>div</span> <span>(</span><span>@</span> <span>(</span><span>class</span> <span>&#34;log&#34;</span><span>)</span><span>)</span> <span>,@*log*</span><span>)</span>
             <span>(</span><span>div</span> <span>(</span><span>@</span> <span>(</span><span>class</span> <span>&#34;prompt&#34;</span><span>)</span><span>)</span>
                  <span>,prompt</span>
                  <span>(</span><span>textarea</span> <span>(</span><span>@</span> <span>(</span><span>id</span> <span>&#34;expression&#34;</span><span>)</span>
                               <span>(</span><span>class</span> <span>&#34;repl-text&#34;</span><span>)</span>
                               <span>(</span><span>placeholder</span> <span>&#34;(+ 1 2 3)&#34;</span><span>)</span>
                               <span>(</span><span>keyup</span> <span>,maybe-eval</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>Every time the user presses a key while focused on the <code>textarea</code>, we
call the <code>maybe-eval</code> procedure shown below.  When the user presses
the Enter key, the REPL</p><ul><li>evaluates their code</li><li>clears the <code>textarea</code></li><li>appends any new output</li><li>scrolls to the bottom of the log to keep the terminal screen up to
date</li></ul><pre><code><span>(</span><span>define</span> <span>(</span><span>maybe-eval</span> <span>event</span><span>)</span>
  <span>;; Get the event&#39;s key.
</span>  <span>(</span><span>let</span> <span>(</span><span>(</span><span>key</span> <span>(</span><span>keyboard-event-key</span> <span>event</span><span>)</span><span>)</span><span>)</span>
    <span>;; Evaluate user code when Enter is pressed, but not when
</span>    <span>;; Shift is being held so the user can edit across multiple
</span>    <span>;; lines.
</span>    <span>(</span><span>when</span> <span>(</span><span>and</span> <span>(</span><span>string-=?</span> <span>key</span> <span>&#34;Enter&#34;</span><span>)</span>
               <span>(</span><span>not</span> <span>(</span><span>keyboard-event-shift?</span> <span>event</span><span>)</span><span>)</span><span>)</span>
      <span>;; Get the text within the expression textarea.
</span>      <span>(</span><span>let*</span> <span>(</span><span>(</span><span>input</span> <span>(</span><span>get-element-by-id</span> <span>&#34;expression&#34;</span><span>)</span><span>)</span>
             <span>(</span><span>exp</span> <span>(</span><span>element-value</span> <span>input</span><span>)</span><span>)</span><span>)</span>
        <span>;; If the textarea is empty, do nothing.
</span>        <span>(</span><span>unless</span> <span>(</span><span>string-=?</span> <span>exp</span> <span>&#34;&#34;</span><span>)</span>
          <span>;; Clear the textarea.
</span>          <span>(</span><span>set-element-value!</span> <span>input</span> <span>&#34;&#34;</span><span>)</span>
          <span>;; Evaluate and append output to log.
</span>          <span>(</span><span>eval!</span> <span>exp</span><span>)</span>
          <span>;; Update UI.
</span>          <span>(</span><span>refresh!</span><span>)</span>
          <span>;; Scroll the log to show the next output.
</span>          <span>(</span><span>scroll-to-bottom!</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>At the bottom, you&#39;ll notice <code>maybe-eval</code> uses a new procedure we&#39;ve
called <code>eval!</code> (how exciting).  <code>eval!</code> is <code>eval</code> + <code>read</code> — it parses
the user&#39;s text using Scheme&#39;s built-in <code>read</code> procedure, calls
<code>eval</code>, and prints the output to the log:</p><pre><code><span>(</span><span>define</span> <span>(</span><span>eval!</span> <span>str</span><span>)</span>
  <span>;; Parse user input.
</span>  <span>(</span><span>let</span> <span>(</span><span>(</span><span>exp</span> <span>(</span><span>read</span> <span>(</span><span>open-input-string</span> <span>str</span><span>)</span><span>)</span><span>)</span>
        <span>;; Open output port.
</span>        <span>(</span><span>output</span> <span>(</span><span>open-output-string</span><span>)</span><span>)</span><span>)</span>
    <span>;; Redirect all output to our output port.
</span>    <span>(</span><span>parameterize</span> <span>(</span><span>(</span><span>current-output-port</span> <span>output</span><span>)</span><span>)</span>
      <span>;; Echo the prompt and user code.
</span>      <span>(</span><span>display</span> <span>prompt</span><span>)</span>
      <span>(</span><span>display</span> <span>str</span><span>)</span>
      <span>;; Invoke the interpreter.
</span>      <span>(</span><span>call-with-values</span> <span>(</span><span>lambda</span> <span>(</span><span>)</span> <span>(</span><span>eval</span> <span>exp</span> <span>init-env</span><span>)</span><span>)</span>
        <span>;; Display each returned value on its own line.
</span>        <span>(</span><span>lambda</span> <span>vals</span>
          <span>(</span><span>if</span> <span>(</span><span>null?</span> <span>vals</span><span>)</span>
              <span>(</span><span>display</span> <span>&#34;\n&#34;</span><span>)</span>
              <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>val</span><span>)</span>
                          <span>(</span><span>unless</span> <span>(</span><span>unspecified?</span> <span>val</span><span>)</span>
                            <span>(</span><span>display</span> <span>&#34;=&gt; &#34;</span><span>)</span>
                            <span>(</span><span>write</span> <span>val</span><span>)</span><span>)</span>
                          <span>(</span><span>newline</span><span>)</span><span>)</span>
                        <span>vals</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
    <span>;; Append output to log.
</span>    <span>(</span><span>log-append!</span> <span>(</span><span>get-output-string</span> <span>output</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>(Note how, thanks to <code>read</code>, we&#39;ve elided the messy work of parsing.)</p><p>Expressions are evaluated within the context of the following
environment that provides capabilities for basic arithmetic, lists,
multiple value return, and printing:</p><pre><code><span>(</span><span>define</span> <span>init-env</span>
  <span>`</span><span>(</span><span>(</span><span>+</span> <span>.</span> <span>,+</span><span>)</span>
    <span>(</span><span>-</span> <span>.</span> <span>,-</span><span>)</span>
    <span>(</span><span>*</span> <span>.</span> <span>,*</span><span>)</span>
    <span>(</span><span>/</span> <span>.</span> <span>,/</span><span>)</span>
    <span>(</span><span>=</span> <span>.</span> <span>,=</span><span>)</span>
    <span>(</span><span>cons</span> <span>.</span> <span>,cons</span><span>)</span>
    <span>(</span><span>car</span> <span>.</span> <span>,car</span><span>)</span>
    <span>(</span><span>cdr</span> <span>.</span> <span>,cdr</span><span>)</span>
    <span>(</span><span>list</span> <span>.</span> <span>,list</span><span>)</span>
    <span>(</span><span>pair?</span> <span>.</span> <span>,pair?</span><span>)</span>
    <span>(</span><span>null?</span> <span>.</span> <span>,null?</span><span>)</span>
    <span>(</span><span>values</span> <span>.</span> <span>,values</span><span>)</span>
    <span>(</span><span>display</span> <span>.</span> <span>,display</span><span>)</span>
    <span>(</span><span>newline</span> <span>.</span> <span>,newline</span><span>)</span><span>)</span><span>)</span></code></pre><p>The initial environment describes the primitive functionality of our
interpreter.  Primitives are simple things that the programmer can
take for granted.  This environment doesn&#39;t provide much, but it&#39;s
enough to have a bit of fun.</p><p>And...</p><p>🥁</p><p>🥁</p><p>🥁</p><p>...here&#39;s the finished program!</p><p>Some expressions you could try:</p><p>Greet the world:</p><pre><code><span>(</span><span>display</span> <span>&#34;Hello, world!&#34;</span><span>)</span></code></pre><p>Make a list of the veggies you want on your sandwich:</p><pre><code><span>&#39;</span><span>(</span><span>lettuce</span> <span>tomato</span> <span>onion</span> <span>pepper</span> <span>pickles</span><span>)</span></code></pre><p>Display all your favorite pets as multiple return values:</p><pre><code><span>(</span><span>values</span> <span>&#39;cat</span> <span>&#39;dog</span> <span>&#39;chicken</span><span>)</span></code></pre><p>Apply a procedure that squares numbers:</p><pre><code><span>(</span><span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>*</span> <span>x</span> <span>x</span><span>)</span><span>)</span> <span>4</span><span>)</span></code></pre><p>Recursively apply a procedure to compute the nth Fibonacci number:</p><pre><code><span>(</span><span>(</span><span>lambda</span> <span>(</span><span>f</span> <span>x</span><span>)</span> <span>(</span><span>f</span> <span>f</span> <span>x</span><span>)</span><span>)</span>
 <span>(</span><span>lambda</span> <span>(</span><span>fib</span> <span>n</span><span>)</span>
   <span>(</span><span>if</span> <span>(</span><span>=</span> <span>n</span> <span>0</span><span>)</span>
       <span>0</span>
       <span>(</span><span>if</span> <span>(</span><span>=</span> <span>n</span> <span>1</span><span>)</span>
           <span>1</span>
           <span>(</span><span>+</span> <span>(</span><span>fib</span> <span>fib</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span><span>)</span>
              <span>(</span><span>fib</span> <span>fib</span> <span>(</span><span>-</span> <span>n</span> <span>2</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
 <span>10</span><span>)</span></code></pre><p>Whoa, that last one was kinda wild, huh?  That&#39;s because our little
interpreter lacks even the ability to bind variables outside of
<code>lambda</code>.  There is no <code>let</code> nor <code>define</code>, so recursive code gets
weird fast!  Talk about minimalism...</p><h3>Scheming ahead</h3><p>The interpreter we&#39;ve shown here is just a toy, but in the coming
months we expect to add support for the <a href="https://small.r7rs.org/attachment/r7rs.pdf">R7RS-small
standard</a>&#39;s <code>eval</code>, taking
our REPL from toy to full Scheme interpreter.</p><p>Once we do so, we could embed Scheme REPLs directly into documents
like the <em>Scheme Primer</em>, further reducing the activation energy
required to get started with Scheme.  And who knows what exciting
integrations our community will come up with?</p><p>In the meantime, if you&#39;d like to start immediately hacking on the
REPL demo, you can find the complete source code on
<a href="https://gitlab.com/spritely/guile-hoot-meta-repl">GitLab</a>.  If you&#39;re
into homework assignments, try adding support for more Scheme syntax
such as <code>let</code>, or adding more procedures to the environment to grant
more power to the interpreter.</p><p>And be sure to show off what you build with Hoot in our <a href="https://community.spritely.institute">community
forum</a>!  (Use OCAPN2023 for the
invite code when you join.)</p><p>Happy hooting! 🦉</p></div></div>
  </body>
</html>
