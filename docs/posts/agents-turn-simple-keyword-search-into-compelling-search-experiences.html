<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://softwaredoug.com/blog/2025/09/22/reasoning-agents-need-bad-search">Original</a>
    <h1>Agents turn simple keyword search into compelling search experiences</h1>
    
    <div id="readability-page-1" class="page"><div>
	  <p>A traditional RAG system often looks like the search we’ve built for years. An LLM calls a search API. We have query understanding and reranking functionality under the hood. All optimized for user engagement.</p>

<p>This thick-daddy search API does quite a bit, as shown below:</p>

<p><img src="https://softwaredoug.com/assets/media/reasoning-agents-need-bad-search/image.png" alt="image.png"/></p>

<p>With small modifications (chunking, a focus on vector retrieval) the RAG implementations look familiar.</p>

<p>Agents, however, come with the ability to reason. And like human users, they might try a query, see the results, adjust their query, and zero-in on the best search terms to find what they want.</p>

<p>Like human users, the agent can build a “mental model” of how the search tool works. If there’s a clear, predictable correspondence between stimulus and output, the agent will figure it out. However, a large, complex system might not be as transparent.</p>

<p>Because of this, <strong>I’d argue the traditional, thick search APIs are counterproductive to being used by agents.</strong> They may be too complex for agents to reason about effectively.</p>

<p>So lately, I’ve tried a rather stupid search backend. More like this image:</p>

<p><img src="https://softwaredoug.com/assets/media/reasoning-agents-need-bad-search/image%201.png" alt="image.png"/></p>

<p>In the furniture search examples I use in my <a href="http://maven.com/softwaredoug/cheat-at-search">Cheat at Search course</a>, I tried this out.</p>

<p>Instead of a big, complex search system, I tell the agent about this dumb thing it can use to search. It then applies its own intelligence to use the tool correctly.</p>

<div><div><pre><code><span>def</span> <span>search_products</span><span>(</span><span>query</span><span>:</span> <span>str</span><span>,</span> <span>top_k</span><span>:</span> <span>int</span> <span>=</span> <span>5</span><span>)</span> <span>-&gt;</span> <span>List</span><span>[</span><span>Dict</span><span>]:</span>
    <span>&#34;&#34;&#34;</span><span>
    Search for furniture products.

    This is direct keyword search, no synonyms, only BM25 scoring on product name 
    and description and basic snowball tokenization of query and document.

    Args:
        query: The search query string.
        top_k: The number of top results to return.

    Returns:
        A list of dictionaries containing product information.
    </span><span>&#34;&#34;&#34;</span>
   <span>...</span>
</code></pre></div></div>

<p><em>( the doc string here becomes part of the prompt, see the <a href="https://github.com/softwaredoug/cheat-at-search/blob/main/cheat_at_search/agent/chat.py">source code</a>)</em></p>

<p>I slimmed the search down to fairly simple keyword search, and told GPT-5 exactly how it works. It behaves predictably, if stupidly.</p>

<p>And that’s a good thing.</p>

<p>I’m fairly surprised how well it works at solving user queries. Albeit slowly.</p>

<p>Here I am finding couches that would be good for a vampire.</p>

<div><div><pre><code><span>User</span><span>:</span> <span>A</span> <span>couch</span> <span>fit</span> <span>for</span> <span>a</span> <span>vampire</span>

<span>...</span>

<span>Assistant</span><span>:</span> <span>Here</span> <span>are</span> <span>some</span> <span>dramatically</span> <span>tufted</span><span>,</span> <span>velvet</span><span>/</span><span>chesterfield</span> <span>options</span> <span>with</span> <span>a</span> <span>suitably</span> <span>vampiric</span> <span>vibe</span><span>:</span>

<span>Chesterfield</span><span>-</span><span>style</span> <span>sofas </span><span>(</span><span>timeless</span><span>,</span> <span>tufted</span><span>,</span> <span>dramatic</span> <span>arms</span><span>/</span><span>back</span><span>)</span>
<span>-</span> <span>Porter</span> <span>80</span><span>&#34;</span><span> Velvet Rolled Arm Chesterfield Sofa (ID 4306)
- Rolled Arm Chesterfield Sofa (ID 28854)
- Quitaque 88</span><span>&#34;</span> <span>Rolled</span> <span>Arm</span> <span>Chesterfield</span> <span>Sofa </span><span>(</span><span>ID</span> <span>17093</span><span>)</span>

<span>Velvet</span> <span>sofas</span> <span>with</span> <span>luxe</span> <span>flair</span>
<span>-</span> <span>85</span><span>&#34;</span><span> Velvet Tuxedo Arm Sofa (ID 29613) — velvet with nailhead trim
- Camren 72</span><span>&#34;</span> <span>Velvet</span> <span>Round</span> <span>Arm</span> <span>Sofa </span><span>(</span><span>ID</span> <span>40049</span><span>)</span>
<span>-</span> <span>112</span><span>&#34;</span><span> Wide Velvet Sofa &amp; Chaise (ID 27546)

Chaise lounges (fainting-couch energy)
- Rosemead Velvet Chaise Lounge (ID 40626)
- Avondale Velvet Chaise Lounge (ID 6452)
- Brighouse Chaise Lounge (ID 6392)
- Tilstone Chaise Lounge (ID 18643) — velvet with silver nailhead accents
</span></code></pre></div></div>

<p>Or asking for the ugliest chair</p>

<div><div><pre><code><span>User</span><span>:</span> <span>ugliest</span> <span>chair</span> <span>in</span> <span>the</span> <span>catalog</span>

<span>Assistant</span><span>:</span> <span>I</span> <span>ran</span> <span>several</span> <span>targeted</span> <span>searches</span> <span>to</span> <span>surface</span> <span>the</span> <span>most</span> <span>over</span><span>-</span><span>the</span><span>-</span><span>top</span>
<span>chairs</span><span>.</span> <span>Here</span> <span>are</span> <span>the</span> <span>top</span> <span>contenders</span> <span>for</span> <span>“</span><span>ugliest</span> <span>chair</span><span>”</span> <span>in</span> <span>our</span> <span>catalog</span><span>:</span>

<span>-</span> <span>Zebra</span> <span>Arm</span> <span>Chair </span><span>(</span><span>ID</span> <span>18587</span><span>)</span> <span>—</span> <span>bold</span> <span>zebra</span> <span>upholstery</span><span>,</span> <span>statement</span> <span>piece</span> <span>energy</span>
<span>-</span> <span>Toby</span> <span>Cow</span> <span>Print</span> <span>Task</span> <span>Chair </span><span>(</span><span>ID</span> <span>5002</span><span>)</span> <span>—</span> <span>desk</span> <span>chair</span> <span>in</span> <span>full</span> <span>cow</span> <span>print</span>
<span>-</span> <span>Gaudy</span> <span>47</span><span>&#34;</span><span> Wide Chenille Armchair (ID 8921) — it literally says “Gaudy” in the name
- The Abbey Gothic Revival 19</span><span>&#34;</span> <span>Wide</span> <span>Side</span> <span>Chair </span><span>(</span><span>ID</span> <span>36608</span><span>)</span> <span>—</span> <span>ornate</span><span>,</span> <span>carved</span> <span>gothic</span> <span>look</span>
</code></pre></div></div>

<h2 id="helping-the-agent-remember-as-it-goes">Helping the agent remember as it goes</h2>

<p>The agent can track how well a tool call works as it goes. In my code, the agent stores its evaluation of each tool’s results. Essentially “LLM-as-a-judge as you go”.  The next time a search happens, the agent can recall what it liked / didn’t like last time.</p>

<div><div><pre><code>system_prompt = &#34;&#34;&#34;
    You take user search queries and use a search tool to find furniture products.
    
    Look at the search tools you have, their limitations, how they work, etc when forming your plan.

    Before searching you MUST use the &#34;get_past_queries&#34; to get similar, past queries
    the user has made

    Remember every tool usage you make. After searching with a tool, evaluate the results,
    then save the interaction (immediately after tool usage) with the &#34;save_queries_used&#34; tool
&#34;&#34;&#34;

</code></pre></div></div>

<p>Below are search tool queries my code saved after I searched for the <code>ugliest chair in the catalog</code></p>

<p>You see the user’s query, along with the query used at the tool (ie <code>cow print chair</code> ):</p>

<div><div><pre><code><span>Saved</span> <span>interaction</span><span>:</span> <span>user_query</span><span>=</span><span>&#39;</span><span>ugliest chair in the catalog</span><span>&#39;</span> 
<span>search_tool_name</span><span>=</span><span>&#39;</span><span>mcp_search-server.search_products</span><span>&#39;</span> 
<span>search_tool_query</span><span>=</span><span>&#39;</span><span>cow print chair</span><span>&#39;</span>
<span>quality</span><span>=</span><span>&#39;</span><span>good</span><span>&#39;</span>
<span>reasoning</span><span>=</span><span>&#34;</span><span>Returned an adult </span><span>&#39;</span><span>cow print task chair</span><span>&#39;</span><span> that clearly fits a loud/novelty aesthetic; strong candidate for </span><span>&#39;</span><span>ugliest chair</span><span>&#39;</span><span> request.</span><span>&#34;</span>

<span>Saved</span> <span>interaction</span><span>:</span> <span>user_query</span><span>=</span><span>&#39;</span><span>ugliest chair in the catalog</span><span>&#39;</span>
<span>search_tool_name</span><span>=</span><span>&#39;</span><span>mcp_search-server.search_products</span><span>&#39;</span> 
<span>search_tool_query</span><span>=</span><span>&#39;</span><span>patchwork accent chair</span><span>&#39;</span>
<span>quality</span><span>=</span><span>&#39;</span><span>meh</span><span>&#39;</span>
<span>reasoning</span><span>=</span><span>&#34;</span><span>Found a kids patchwork chair; adult options not surfaced. Only tangentially relevant to </span><span>&#39;</span><span>ugliest chair</span><span>&#39;</span><span> intent.</span><span>&#34;</span>

<span>Saved</span> <span>interaction</span><span>:</span> <span>user_query</span><span>=</span><span>&#39;</span><span>ugliest chair in the catalog</span><span>&#39;</span> 
<span>search_tool_name</span><span>=</span><span>&#39;</span><span>mcp_search-server.search_products</span><span>&#39;</span>
<span>search_tool_query</span><span>=</span><span>&#39;</span><span>skull chair</span><span>&#39;</span>
<span>quality</span><span>=</span><span>&#39;</span><span>bad</span><span>&#39;</span>
<span>reasoning</span><span>=</span><span>&#39;</span><span>No chair products matched; results were decor and textiles unrelated to chairs.</span><span>&#39;</span>

</code></pre></div></div>

<p>I’ll be able to recall what worked well for this query. I could even remember these expansions later if I build a normal site search without LLMs.</p>

<p>Semantic caching gives us another bonus. Later, when I search for a similar query, say <code>ugly chair</code> , I can take <code>ugly chair</code> and find past queries most similar to this query, like below.</p>

<p>The agent can see what’s worked well / hasn’t worked well for friends of <code>ugly chair</code>:</p>

<div><div><pre><code><span>Getting</span> <span>past</span> <span>queries</span> <span>for</span><span>:</span> <span>ugly</span> <span>chair</span>

<span>Matched</span> <span>query</span><span>:</span> 
  <span>ugliest</span> <span>chair</span> <span>in</span> <span>the</span> <span>catalog</span><span>,</span> 
  <span>similarity</span><span>:</span> <span>0.8236806392669678</span><span>,</span> 
  <span>interaction</span><span>:</span> <span>user_query</span><span>=</span><span>&#39;</span><span>ugliest chair in the catalog</span><span>&#39;</span> 
  <span>search_tool_name</span><span>=</span><span>&#39;</span><span>mcp_search-server.search_products</span><span>&#39;</span>
  <span>search_tool_query</span><span>=</span><span>&#39;</span><span>novelty chair</span><span>&#39;</span>
  <span>quality</span><span>=</span><span>&#39;</span><span>meh</span><span>&#39;</span> <span>reasoning</span><span>=</span><span>&#34;</span><span>Found novelty chairs but primarily for kids; may not match adult seating requestfor </span><span>&#39;</span><span>ugliest chair</span><span>&#39;</span><span>.</span><span>&#34;</span>
<span>Matched</span> <span>query</span><span>:</span> <span>ugliest</span> <span>chair</span> <span>in</span> <span>the</span> <span>catalog</span><span>,</span> 
  <span>similarity</span><span>:</span> <span>0.8236806392669678</span><span>,</span> <span>interaction</span><span>:</span> <span>user_query</span><span>=</span><span>&#39;</span><span>ugliest chair in the catalog</span><span>&#39;</span> <span>search_tool_name</span><span>=</span><span>&#39;</span><span>mcp_search-server.search_products</span><span>&#39;</span> <span>search_tool_query</span><span>=</span><span>&#39;</span><span>weird chair</span><span>&#39;</span>
  <span>quality</span><span>=</span><span>&#39;</span><span>bad</span><span>&#39;</span>
  <span>reasoning</span><span>=</span><span>&#34;</span><span>Keyword </span><span>&#39;</span><span>weird</span><span>&#39;</span><span> mostly matched non-chair textiles and generic chair listings; not  helpful for surfacing intentionally odd or gaudy chairs.</span><span>&#34;</span>
<span>Matched</span> <span>query</span><span>:</span> <span>ugliest</span> <span>chair</span> <span>in</span> <span>the</span> <span>catalog</span><span>,</span> 
  <span>similarity</span><span>:</span> <span>0.8236806392669678</span><span>,</span>
  <span>interaction</span><span>:</span> <span>user_query</span><span>=</span><span>&#39;</span><span>ugliest chair in the catalog</span><span>&#39;</span>
  <span>search_tool_name</span><span>=</span><span>&#39;</span><span>mcp_search-server.search_products</span><span>&#39;</span>
  <span>search_tool_query</span><span>=</span><span>&#39;</span><span>zebra accent chair</span><span>&#39;</span>
  <span>quality</span><span>=</span><span>&#39;</span><span>good</span><span>&#39;</span>
  <span>reasoning</span><span>=</span><span>&#34;</span><span>Surfaced a </span><span>&#39;</span><span>zebra arm chair</span><span>&#39;</span><span> (animal print) that fits an intentionally loud/gaudy aesthetic often perceived as ugly; results include a clear adult armchair option.</span><span>&#34;</span>
</code></pre></div></div>

<p>As the agent searches, it’s little vector lookup of user queries turns into a knowledge graph. User queries connected to other user queries via similarity. And each with notes on what’s worked / not worked when calling the search tool.</p>

<p>It’s the ultimate learning machine.</p>

<p>At least as far as its own preferences.</p>

<h2 id="only-as-good-as-the-agents-ability-to-evaluate-results">Only as good as the agent’s ability to evaluate results</h2>

<p>The LLM must be able to evaluate the results that come back. It needs to be a reasonable LLM judge. That means:</p>

<ul>
  <li>Did we return useful metadata for the agent to use in its evaluation? (Here we use product / description). But should we return images? Any other metadata?</li>
  <li>Does the LLM actually have domain expertise to evaluate the results? (Note above it returns a brand “Gaudy”, which is not the adjective “gaudy” — as in ugly)</li>
</ul>

<p>Finally the big one:</p>

<h3 id="what-about-the-users-input">What about the user’s input?</h3>

<p>The agent’s judgment is bound to be flawed / limited. Even in an ideal setting, it will <em>always</em> be disjoint from what users want. Lack of user clickstream feedback is a <a href="https://softwaredoug.com/blog/2025/05/16/rags-big-blindspot">huge gap in RAG</a> that continues here.</p>

<p>We can’t expect LLMs to have any idea of the crazy, insane things, humans do when nobody is watching. I’ve seen users do all sorts of things:</p>

<ul>
  <li>Users often click black / boring colors, not loud ones</li>
  <li>Users click on spicy topics or images that have nothing to do with their query</li>
  <li>Users get what they need from the search page, and never click anything</li>
  <li>Users click because of the relationship between an image and its neighbor</li>
  <li>Click data itself is sparse and noisy, and may require a lot in aggregate to make sense of</li>
</ul>

<p>There are dozens of biases cataloged in user clickstream interactions with search results.</p>

<p>The search field has spent decades interpreting clickstream data, and the RAG world continues to lack good answers to getting that data back into the agent.</p>

<p>Maybe you’ve seen good research here? Please share!</p>

<h2 id="are-reasoners-actually-actively-harmful-rankers">Are reasoners actually actively harmful rankers?</h2>

<p>Reasoning involves taking a base set of facts and deriving a solution. This, however, is different from directly optimizing for what users want (as expressed through clickstream data). We don’t have the technology for an LLM or agent to churn over millions of user sessions to become a better judge of search result quality.</p>

<p>Even if we gave the agent an oracle - labeled each result with user engagement data, could it make sense of latent patterns? Or would it simply be confused at the strange inconsistent behavior of humans that don’t act like math proofs or programming conpetitions?</p>

<p>Any ranking model optimized to engagement would more likely be implemented outside the agent: In a classic, thick search stack. The agent’s inner LLM judge, might look at model-ranked results and assume they’re bad. Why would users want such bland products? Why would the search have interpreted “Gaudy” to be a brand name, when its obviously “ugly”?</p>

<p>In short, users’ chaotic, implicit search expectations — as expressed in their clickstream — go against the agent’s orderly, explicit reasoning + judgment. An agent may issue a search and think “oh this result set was meh” when in reality, its the most engaging search results for that query.</p>

<p>Reasoning about search tool output might be very dangerous if the agent discards actually relevant results.</p>

<p>So take this article with this big grain of salt and be careful.</p>

<p>But still, it’s pretty fun.</p>

      


	  </div><p>I hope you join me at <a href="https://maven.com/softwaredoug/cheat-at-search">Cheat at Search with LLMs</a> to learn how to apply LLMs to search applications. Check out <a href="https://github.com/softwaredoug/softwaredoug.com/edit/master/_includes/post.html">this post</a> for a sneak preview.

		</p></div>
  </body>
</html>
