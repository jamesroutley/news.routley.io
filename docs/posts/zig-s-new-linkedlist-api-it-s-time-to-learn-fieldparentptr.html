<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/Zigs-New-LinkedList-API/">Original</a>
    <h1>Zig&#39;s new LinkedList API (it&#39;s time to learn fieldParentPtr)</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  
  
<p>In a recent, post-Zig 0.14 commit, Zig&#39;s <code>SinglyLinkedList</code> and <code>DoublyLinkedList</code> saw <a href="https://github.com/ziglang/zig/commit/1639fcea43549853f1fded32aa1d711d21771e1c">significant changes</a>.</p>

<p>The previous version was a generic and, with all the methods removed, looked like:</p>

<pre><code><span>pub</span> <span>fn</span> <span>SinglyLinkedList</span><span>(</span><span>comptime</span> T<span>:</span> <span><span>type</span></span><span>)</span> <span><span>type</span></span> <span>{</span>
  <span>return</span> <span>struct</span> <span>{</span>
    first<span>:</span> <span><span>?</span><span>*</span>Node</span> <span>=</span> <span>null</span><span>,</span>

    <span>pub</span> <span>const</span> <span>Node</span> <span>=</span> <span>struct</span> <span>{</span>
      next<span>:</span> <span><span>?</span><span>*</span>Node</span> <span>=</span> <span>null</span><span>,</span>
      data<span>:</span> <span>T</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span></code></pre>

<p>The new version isn&#39;t generic. Rather, you embed the linked list node with your data. This is known as an intrusive linked list and tends to perform better and require fewer allocations. Except in trivial examples, the data that we store in a linked list is typically stored on the heap. Because an intrusive linked list has the linked list node embedded in the data, it doesn&#39;t need its own allocation. Before we jump into an example, this is what the new structure looks like, again, with all methods removed:</p>

<pre><code><span>pub</span> <span>const</span> <span>SinglyLinkedList</span> <span>=</span> <span>struct</span> <span>{</span>
  first<span>:</span> <span><span>?</span><span>*</span>Node</span> <span>=</span> <span>null</span><span>,</span>

  <span>pub</span> <span>const</span> <span>Node</span> <span>=</span> <span>struct</span> <span>{</span>
    next<span>:</span> <span><span>?</span><span>*</span>Node</span> <span>=</span> <span>null</span><span>,</span>
  <span>}</span><span>;</span>
<span>}</span><span>;</span></code></pre>

<p>Much simpler, and, notice that this has no link or reference to any of our data. Here&#39;s a working example that shows how you&#39;d use it:</p>

<pre><code><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>
<span>const</span> SinglyLinkedList <span>=</span> std<span>.</span>SinglyLinkedList<span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    
    
    <span>var</span> gpa<span>:</span> std<span>.</span>heap<span>.</span><span>DebugAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span> <span>=</span> <span>.</span>init<span>;</span>
    <span>const</span> allocator <span>=</span> gpa<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>

    <span>var</span> list<span>:</span> <span>SinglyLinkedList</span> <span>=</span> <span>.</span><span>{</span><span>}</span><span>;</span>

    <span>const</span> user1 <span>=</span> <span>try</span> allocator<span>.</span><span>create</span><span>(</span>User<span>)</span><span>;</span>
    <span>defer</span> allocator<span>.</span><span>destroy</span><span>(</span>user1<span>)</span><span>;</span>
    user1<span>.*</span> <span>=</span> <span>.</span><span>{</span>
        <span>.</span>id <span>=</span> <span>1</span><span>,</span>
        <span>.</span>power <span>=</span> <span>9000</span><span>,</span>
        <span>.</span>node <span>=</span> <span>.</span><span>{</span><span>}</span><span>,</span>
    <span>}</span><span>;</span>
    list<span>.</span><span>prepend</span><span>(</span><span>&amp;</span>user1<span>.</span>node<span>)</span><span>;</span>

    <span>const</span> user2 <span>=</span> <span>try</span> allocator<span>.</span><span>create</span><span>(</span>User<span>)</span><span>;</span>
    <span>defer</span> allocator<span>.</span><span>destroy</span><span>(</span>user2<span>)</span><span>;</span>
    user2<span>.*</span> <span>=</span> <span>.</span><span>{</span>
        <span>.</span>id <span>=</span> <span>2</span><span>,</span>
        <span>.</span>power <span>=</span> <span>9001</span><span>,</span>
        <span>.</span>node <span>=</span> <span>.</span><span>{</span><span>}</span><span>,</span>
    <span>}</span><span>;</span>
    list<span>.</span><span>prepend</span><span>(</span><span>&amp;</span>user2<span>.</span>node<span>)</span><span>;</span>

    <span>var</span> node <span>=</span> list<span>.</span>first<span>;</span>
    <span>while</span> <span>(</span>node<span>)</span> <span>|</span>n<span>|</span> <span>{</span>
        std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;{any}\n&#34;</span><span>,</span> <span>.</span><span>{</span>n<span>}</span><span>)</span><span>;</span>
        node <span>=</span> n<span>.</span>next<span>;</span>
    <span>}</span>
<span>}</span>

<span>const</span> <span>User</span> <span>=</span> <span>struct</span> <span>{</span>
    id<span>:</span> <span><span>i64</span></span><span>,</span>
    power<span>:</span> <span><span>u32</span></span><span>,</span>
    node<span>:</span> <span>SinglyLinkedList<span>.</span>Node</span><span>,</span>
<span>}</span><span>;</span></code></pre>

<p>To run this code, you&#39;ll need a nightly release from within the last week. What do you think the output will be? You should see something like:</p>

<pre><code>SinglyLinkedList.Node{ .next = SinglyLinkedList.Node{ .next = null } }
SinglyLinkedList.Node{ .next = null }</code></pre>

<p>We&#39;re only getting the nodes, and, as we can see here and from the above skeleton structure of the new <code>SinglyLinkedList</code>, there&#39;s nothing about our users. Users have nodes, but there&#39;s seemingly nothing that links a node back to its containing user. Or is there?</p>

<p>In the past, we&#39;ve described how <a href="https://www.openmymind.net/learning_zig/pointers/">the compiler uses the type information</a> to figure out how to access fields. For example, when we execute <code>user1.power</code>, the compiler knows that:</p>

<ol>
  <li><code>id</code> is +0 bytes from the start of the structure,
  </li><li><code>power</code> is +8 bytes from the start of the structure (because id is an i64), and
  </li><li><code>power</code> is an i32
</li></ol>

<p>With this information, the compiler knows how to access <code>power</code> from <code>user1</code> (i.e. jump forward 8 bytes, read 4 bytes and treat it as an i32). But if you think about it, that logic is simple to reverse. If we know the address of <code>power</code>, then the address of <code>user</code> has to be <code>address_of_power - 8</code>. We can prove this:</p>

<pre><code><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> user <span>=</span> <span>User</span><span>{</span>
        <span>.</span>id <span>=</span> <span>1</span><span>,</span>
        <span>.</span>power <span>=</span> <span>9000</span><span>,</span>
    <span>}</span><span>;</span>
    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;address of user: {*}\n&#34;</span><span>,</span> <span>.</span><span>{</span><span>&amp;</span>user<span>}</span><span>)</span><span>;</span>

    <span>const</span> address_of_power <span>=</span> <span>&amp;</span>user<span>.</span>power<span>;</span>
    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;address of power: {*}\n&#34;</span><span>,</span> <span>.</span><span>{</span>address_of_power<span>}</span><span>)</span><span>;</span>

    <span>const</span> power_offset <span>=</span> <span>8</span><span>;</span>
    <span>const</span> also_user<span>:</span> <span><span>*</span>User</span> <span>=</span> <span>@ptrFromInt</span><span>(</span><span>@intFromPtr</span><span>(</span>address_of_power<span>)</span> <span>-</span> power_offset<span>)</span><span>;</span>
    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;address of also_user: {*}\n&#34;</span><span>,</span> <span>.</span><span>{</span>also_user<span>}</span><span>)</span><span>;</span>

    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;also_user: {}\n&#34;</span><span>,</span> <span>.</span><span>{</span>also_user<span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>User</span> <span>=</span> <span>struct</span> <span>{</span>
    id<span>:</span> <span><span>i64</span></span><span>,</span>
    power<span>:</span> <span><span>u32</span></span><span>,</span>
<span>}</span><span>;</span></code></pre>

<p>The magic happens here:</p>

<pre><code><span>const</span> power_offset <span>=</span> <span>8</span><span>;</span>
<span>const</span> also_user<span>:</span> <span><span>*</span>User</span> <span>=</span> <span>@ptrFromInt</span><span>(</span><span>@intFromPtr</span><span>(</span>address_of_power<span>)</span> <span>-</span> power_offset<span>)</span><span>;</span></code></pre>

<p>We&#39;re turning the address of our user&#39;s power field, <code>&amp;user.power</code> into an integer, subtracting 8 (8 bytes, 64 bits), and telling the compiler that it should treat that memory as a <code>*User</code>. This code will <em>probably</em> work for you, but it isn&#39;t safe. Specifically, unless we&#39;re using a packed or extern struct, Zig makes no guarantees about the layout of a structure. It could put <code>power</code> BEFORE <code>id</code>, in which case our <code>power_offset</code> should be 0. It could add padding after every field. It can do anything it wants. To make this code safer, we use the <code>@offsetOf</code> builtin to get the actual byte-offset of a field with respect to its struct:</p>

<pre><code><span>const</span> power_offset <span>=</span> <span>@offsetOf</span><span>(</span>User<span>,</span> <span>&#34;power&#34;</span><span>)</span><span>;</span></code></pre>

<p>Back to our linked list, given that we have the address of a <code>node</code> and we know that it is part of the <code>User</code> structure, we <em>are</em> able to get the <code>User</code> from a node. Rather than use the above code though, we&#39;ll use the <em>slightly</em> friendlier <code>@fieldParentPtr</code> builtin. Our <code>while</code> loop changes to:</p>

<pre><code><span>while</span> <span>(</span>node<span>)</span> <span>|</span>n<span>|</span> <span>{</span>
  <span>const</span> user<span>:</span> <span><span>*</span>User</span> <span>=</span> <span>@fieldParentPtr</span><span>(</span><span>&#34;node&#34;</span><span>,</span> n<span>)</span><span>;</span>
  std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;{any}\n&#34;</span><span>,</span> <span>.</span><span>{</span>user<span>}</span><span>)</span><span>;</span>
  node <span>=</span> n<span>.</span>next<span>;</span>
<span>}</span></code></pre>

<p>We give <code>@fieldParentPtr</code> the name of the field, a pointer to that field as well as a return type (which is inferred above by the assignment to a <code>*User</code> variable), and it gives us back the instance that contains that field.</p>

<p>Performance aside, I have mixed feelings about the new API. My initial reaction is that I dislike exposing, what I consider, a complicated builtin like <code>@fieldParentPtr</code> for something as trivial as using a linked list. However, while <code>@fieldParentPtr</code> seems esoteric, it&#39;s quite useful and developers should be familiar with it because it can help solve problems which are otherwise problematic.</p>

</article></div>
  </body>
</html>
