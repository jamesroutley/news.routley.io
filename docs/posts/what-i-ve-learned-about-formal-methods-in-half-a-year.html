<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakob.space/blog/what-ive-learned-about-formal-methods.html">Original</a>
    <h1>What I&#39;ve Learned About Formal Methods in Half a Year</h1>
    
    <div id="readability-page-1" class="page"><div id="text-orgdfc40be">
<p>
I had originally set out to prove the correctness of the meta-circular evaluator presented in <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer Programs</a> for my final project, but after finishing my final for cryptography, I had about three restless evenings left to work on the project and I was nowhere near that, so I just submitted an interpreter in Lean and a proof that a program correctly computes the factorial function according to the some semantics for a subset of Scheme.
</p>

<p>
Most Scheme implementations used today are either R5RS, R6RS, or R7RS, which are far more comprehensive than what my semantics considered. Namely: lambda expressions and evaluations, basic lexical environments, basic control flow, integers and integer arithmetic, symbols, and lists. Notably: no continuations, conditions, strings, or arbitrary-precision arithmetic.
</p>

<p>
I avoided non-integer numbers because real numbers (shallowly-encoded in Lean) can&#39;t really be used in computations (the mathematical definition of a real number encodes an infinite amount of information). Even though the set of integers has infinite cardinality, they&#39;re much easier to use and reason about in Lean. Lean 4 has support for floating numbers but, again, we used Lean 3 for this class, so I stuck with Integers.
</p>

<p>
What follows is a lot of Lean code with minimal commentary. I&#39;ve had this project tucked away for a couple of months and to explain it like I did the Alloy example would require at least a couple days of refreshing my memory – and I expect the resulting explanation would be incredibly lengthy if I explained everything in as much detail. Don&#39;t feel bad about skimming, or skipping to the end entirely. You aren&#39;t missing too much if you do. I include this mostly to satisfy any curiosities.
</p>

<p>
…
</p>

<p>
Returning to the idea of Lean as a general-purpose programming language… while we can write proofs about the semantics of Lisp without a mechanical parser, I think it&#39;s a simple enough example to show off some concepts in Lean. Let&#39;s start with a lexical analyzer for s-expressions. Obviously, we&#39;ll need some sort of data structure for representing tokens, and Lean fortunately supports inductive (or algebraic, or enumerated) data types.
</p>

<div>
<pre><span>inductive</span> <span>token</span> : <span>Type</span>
| eof     : token
| lparen  : token
| rparen  : token
| quot    : token
| numeral : <span>ℕ</span> <span>→</span> token
| symbol  : string <span>→</span> token
</pre>
</div>

<p>
They&#39;re introduced with <code>inductive</code>. Each name to the left of the <code>:</code> is the constructor (or case) name, and the right-hand side is the type. Like an <code>enum</code> in Rust, inductive data types can contain no information (<code>token</code>) or they can contain some associated data like an integer (<code>ℤ → token</code>) or a string (<code>string → token</code>).
</p>

<p>
We&#39;ll probably also want to be able to print our token streams.
</p>

<div>
<pre><span>def</span> <span>token.repr</span> : token <span>→</span> string
| (token.eof)       <span>:=</span> <span>&#34;EOF&#34;</span>
| (token.lparen)    <span>:=</span> <span>&#34;LPAREN&#34;</span>
| (token.rparen)    <span>:=</span> <span>&#34;RPAREN&#34;</span>
| (token.quot)      <span>:=</span> <span>&#34;QUOT&#34;</span>
| (token.numeral n) <span>:=</span> <span>&#34;NUMBER &#34;</span> <span>++</span> (to_string n)
| (token.symbol s)  <span>:=</span> <span>&#34;SYMBOL &#34;</span> <span>++</span> s
<span>instance</span> <span>:</span> has_repr token <span>:=</span> ⟨token.repr⟩
</pre>
</div>

<p>
<code>has_repr</code> is like the <code>Show</code> typeclass in Haskell. It specifies an interface for displaying an object as a string. It&#39;s a single method in Lean. Here&#39;s some pretty awful Lean code for converting a string into a token stream.
</p>

<div>
<pre><span>meta</span> <span>def</span> <span>take_numeric_helper</span> : list char <span>→</span> list char <span>×</span> list char
| (list.cons x rest) <span>:=</span>
  <span>if</span> x.is_digit <span>then</span>
    <span>let</span> result <span>:=</span> take_numeric_helper rest <span>in</span>
      (list.cons x result.fst, result.snd)
  <span>else</span> ([], (list.cons x rest))
| <span>_</span> <span>:=</span> ([], [])
<span>meta</span> <span>def</span> <span>take_numeric</span> (s : list char) : (token <span>×</span> list char) <span>:=</span>
<span>let</span> result <span>:=</span> take_numeric_helper s <span>in</span>
  (token.numeral (string.to_nat (string.join (list.map char.to_string result.fst))),
   result.snd)

<span>meta</span> <span>def</span> <span>take_symbol_helper</span> : list char <span>→</span> list char <span>×</span> list char
| (list.cons x rest) <span>:=</span>
  <span>if</span> (<span>¬</span> (x.is_whitespace <span>∨</span> x <span>=</span> &#39;)&#39;)) <span>then</span>
    <span>let</span> result <span>:=</span> take_symbol_helper rest <span>in</span>
      (list.cons x result.fst, result.snd)
  <span>else</span> ([], (list.cons x rest))
| <span>_</span> <span>:=</span> ([], [])
<span>meta</span> <span>def</span> <span>take_symbol</span> (s : list char) : (token <span>×</span> list char) <span>:=</span>
<span>let</span> result <span>:=</span> take_symbol_helper s <span>in</span>
  (token.symbol (string.join (list.map char.to_string result.fst)),
   result.snd)

<span>meta</span> <span>def</span> <span>tokenize_internal</span> : list char <span>→</span> list token
| (list.cons &#39;(&#39; rest) <span>:=</span> list.cons token.lparen (tokenize_internal rest)
| (list.cons &#39;)&#39; rest) <span>:=</span> list.cons token.rparen (tokenize_internal rest)
| (list.cons &#39;\&#39;&#39; rest) <span>:=</span> list.cons token.quot (tokenize_internal rest)
| (list.cons x rest)   <span>:=</span> <span>if</span> char.is_digit x <span>then</span>
                            <span>let</span> result <span>:=</span> take_numeric (list.cons x rest) <span>in</span>
                              list.cons result.fst (tokenize_internal result.snd)
                          <span>else</span> <span>if</span> (<span>¬</span> char.is_whitespace x) <span>then</span>
                            <span>let</span> result <span>:=</span> take_symbol (list.cons x rest) <span>in</span>
                              list.cons result.fst (tokenize_internal result.snd)
                          <span>else</span>
                            tokenize_internal rest
|                    <span>_</span> <span>:=</span> [token.eof]

<span>meta</span> <span>def</span> <span>tokenize</span> (s : string) : list token <span>:=</span> tokenize_internal (string.to_list s)

<span>#eval</span> tokenize <span>&#34;(define (list-of-values exps env)</span>
<span>  (if (no-operands? exps)</span>
<span>    &#39;()</span>
<span>    (cons (eval (first-operand exps) env)</span>
<span>          (list-of-values (rest-operands exps) env))))&#34;</span>
</pre>
</div>

<p>
These are all &#34;<code>meta</code>&#34; functions because I don&#39;t want to have to prove to Lean that they&#39;re well-founded and always terminate. <code>meta</code> functions can be evaluated, but they can&#39;t be used in proofs, so they&#39;re useful for auxiliary automation and not much else.
</p>

<p>
Of course, a lexical analyzer is just a step toward building a parser, so we&#39;ll model the things we&#39;d like to parse and reason about.
</p>

<div>
<pre><span>inductive</span> <span>atom</span> : <span>Type</span>
| undefined : atom
| boolean : bool <span>→</span> atom
| number : <span>ℤ</span> <span>→</span> atom
| primitive_procedure : string <span>→</span> atom
| compound_procedure : (string <span>→</span> option atom) <span>→</span> list string <span>→</span> atom <span>→</span> atom
| symbol : string <span>→</span> atom
| list : list atom <span>→</span> atom
| cell : atom <span>→</span> atom <span>→</span> atom

<span>instance</span> <span>atom_inhabited</span> : inhabited atom <span>:=</span>
  inhabited.mk (atom.undefined)
</pre>
</div>

<p>
The <code>atom</code> type will be useful in specifying the semantics as well as the parser. I&#39;m bastardizing the term somewhat since &#34;atom&#34; has a pretty specific meaning in Lisp that is distinct from how I&#39;m using it here.
</p>

<p>
<code>inhabited</code> is another typeclass which tells us that an instance of <code>atom</code> can actually be constructed (which isn&#39;t true of all types you might want to deal with in Lean.)
</p>

<p>
We can also write some automation to pretty-print atoms.
</p>

<div>
<pre><span>meta</span> <span>def</span> <span>atom.repr</span> : atom <span>→</span> string
| (atom.undefined)                      <span>:=</span> <span>&#34;&lt;undefined&gt;&#34;</span>
| (atom.boolean bool)                   <span>:=</span> <span>if</span> bool <span>then</span> <span>&#34;#t&#34;</span> <span>else</span> <span>&#34;#f&#34;</span>
| (atom.number n)                       <span>:=</span> (to_string n)
| (atom.primitive_procedure sym)        <span>:=</span> <span>&#34;&lt;primitive-procedure: &#34;</span> <span>++</span> sym <span>++</span> <span>&#34;&gt;&#34;</span>
| (atom.compound_procedure <span>_</span> args body) <span>:=</span> <span>&#34;(λ (&#34;</span> <span>++</span> string.intercalate <span>&#34; &#34;</span> args <span>++</span> <span>&#34;) &#34;</span> <span>++</span> (atom.repr body) <span>++</span> <span>&#34;)&#34;</span>
| (atom.symbol sym)                     <span>:=</span> sym
| (atom.list lst)                       <span>:=</span> <span>&#34;(&#34;</span> <span>++</span> string.intercalate <span>&#34; &#34;</span> (list.map atom.repr lst) <span>++</span> <span>&#34;)&#34;</span>
| (atom.cell car cdr)                   <span>:=</span> <span>&#34;(&#34;</span> <span>++</span> atom.repr car <span>++</span> <span>&#34; . &#34;</span> <span>++</span> atom.repr cdr <span>++</span> <span>&#34;)&#34;</span>
<span>meta</span> <span>instance</span> <span>:</span> has_repr atom <span>:=</span> ⟨atom.repr⟩
</pre>
</div>

<p>
The parser is fairly simple, too, but we have to deal with mutual recursion.
</p>

<div>
<pre><span>meta</span> <span>def</span> <span>parse_until_rparen</span> : <span>ℤ</span> <span>→</span> list token <span>→</span> option (list token <span>×</span> list token)
| <span>0</span> (list.cons (token.rparen) rest) <span>:=</span> some ([], rest)
| n (list.cons (token.rparen) rest) <span>:=</span>
  <span>match</span> parse_until_rparen (n <span>-</span> <span>1</span>) rest <span>with</span>
  | none <span>:=</span> none
  | some result <span>:=</span> some (list.cons token.rparen result.fst, result.snd)
  <span>end</span>
| n (list.cons (token.lparen) rest) <span>:=</span>
  <span>match</span> parse_until_rparen (n <span>+</span> <span>1</span>) rest <span>with</span>
  | none <span>:=</span> none
  | some result <span>:=</span> (list.cons token.lparen result.fst, result.snd)
  <span>end</span>
| n (list.cons tok rest) <span>:=</span>
  <span>match</span> parse_until_rparen n rest <span>with</span>
  | none <span>:=</span> none
  | some result <span>:=</span> some (list.cons tok result.fst, result.snd)
  <span>end</span>
| n (list.nil) <span>:=</span> none

<span>meta</span> <span>mutual</span> <span>def</span> <span>parse_one,</span> parse
<span>with</span> parse_one : list token <span>→</span> option (atom <span>×</span> list token)
| (list.cons token.lparen rest) <span>:=</span>
  <span>match</span> parse_until_rparen <span>0</span> rest <span>with</span>
  | none <span>:=</span> none
  | some result <span>:=</span> some (atom.list (parse result.fst), result.snd)
  <span>end</span>
| (list.cons token.quot rest) <span>:=</span>
  <span>match</span> parse_one rest <span>with</span>
  | none <span>:=</span> none
  | some result <span>:=</span> some (atom.list [(atom.symbol <span>&#34;quote&#34;</span>), result.fst], result.snd)
  <span>end</span>
| (list.cons (token.numeral n) rest)   <span>:=</span> some (atom.number n, rest)
| (list.cons (token.symbol <span>&#34;#t&#34;</span>) rest) <span>:=</span> some (atom.boolean tt, rest)
| (list.cons (token.symbol <span>&#34;#f&#34;</span>) rest) <span>:=</span> some (atom.boolean ff, rest)
| (list.cons (token.symbol sym) rest)  <span>:=</span> some (atom.symbol sym, rest)
| <span>_</span> <span>:=</span> none
<span>with</span> parse : list token <span>→</span> list atom
| (list.nil) <span>:=</span> []
| stream <span>:=</span> <span>match</span> parse_one stream <span>with</span>
| none <span>:=</span> []
| some (result, (list.nil)) <span>:=</span> [result]
| some (result, rest) <span>:=</span> (list.cons result (parse rest))
<span>end</span>

<span>#eval</span> list.map atom.repr (parse (tokenize <span>&#34;(+ 2 4)&#34;</span>))
<span>#eval</span> list.map atom.repr (parse (tokenize <span>&#34;(define (list-of-values exps env)</span>
<span>  (if (no-operands? exps)</span>
<span>    &#39;()</span>
<span>    (cons (eval (first-operand exps) env)</span>
<span>          (list-of-values (rest-operands exps) env))))&#34;</span>))
</pre>
</div>

<p>
The evaluator has a notion of errors, whereas the language semantics doesn&#39;t, so we&#39;ll introduce a type for that as well.
</p>

<div>
<pre><span>inductive</span> <span>lisp_error</span> : <span>Type</span>
| expected_number     : lisp_error
| expected_symbol     : lisp_error
| expected_list       : lisp_error
| no_such_variable    : string <span>→</span> lisp_error
| bad_lambda          : lisp_error
| bad_begin           : lisp_error
| bad_if              : lisp_error
| bad_define          : lisp_error
| bad_arity           : lisp_error
| excessive_recursion : lisp_error
| unknown_form        : lisp_error

<span>def</span> <span>lisp_error.repr</span> : lisp_error <span>→</span> string
| (lisp_error.expected_number)      <span>:=</span> <span>&#34;Expected number&#34;</span>
| (lisp_error.expected_symbol)      <span>:=</span> <span>&#34;Expected symbol&#34;</span>
| (lisp_error.expected_list)        <span>:=</span> <span>&#34;Expected list&#34;</span>
| (lisp_error.no_such_variable sym) <span>:=</span> <span>&#34;No such variable: &#34;</span> <span>++</span> sym
| (lisp_error.bad_lambda)           <span>:=</span> <span>&#34;Bad lambda form&#34;</span>
| (lisp_error.bad_begin)            <span>:=</span> <span>&#34;Bad begin form&#34;</span>
| (lisp_error.bad_if)               <span>:=</span> <span>&#34;Bad if form&#34;</span>
| (lisp_error.bad_define)           <span>:=</span> <span>&#34;Bad define form&#34;</span>
| (lisp_error.bad_arity)            <span>:=</span> <span>&#34;Compound procedure called with wrong number of arguments&#34;</span>
| (lisp_error.excessive_recursion)  <span>:=</span> <span>&#34;Maximum recursion depth exceeded&#34;</span>
| (lisp_error.unknown_form)         <span>:=</span> <span>&#34;Unknown form&#34;</span>
<span>instance</span> <span>:</span> has_repr lisp_error <span>:=</span> ⟨lisp_error.repr⟩

<span>def</span> <span>lisp_result</span> (α : <span>Type</span>) <span>:=</span> except lisp_error α

<span>meta</span> <span>def</span> <span>lisp_result_atom.repr</span> : lisp_result atom <span>→</span> string
| (except.ok result) <span>:=</span> atom.repr result
| (except.error err) <span>:=</span> <span>&#34;ERROR: &#34;</span> <span>++</span> lisp_error.repr err


<span>meta</span> <span>def</span> <span>lisp_result.repr</span> {α : <span>Type</span>} : lisp_result (atom <span>×</span> α) <span>→</span> string
| (except.ok (result, <span>_</span>)) <span>:=</span> atom.repr result
| (except.error err) <span>:=</span> <span>&#34;ERROR: &#34;</span> <span>++</span> lisp_error.repr err
</pre>
</div>

<p>
Now, we also need a notion of &#34;state&#34; and &#34;frame.&#34;
</p>

<div>
<pre><span>def</span> <span>state</span> : <span>Type</span> <span>:=</span> string <span>→</span> option atom
<span>instance</span> <span>state_inhabited</span> : inhabited state <span>:=</span>
inhabited.mk (<span>λ</span> x, none)

<span>def</span> <span>state.update</span> (name : string) (val : atom) (s : state) : state <span>:=</span>
<span>λ</span>name&#39;, <span>if</span> name&#39; <span>=</span> name <span>then</span> some val <span>else</span> s name&#39;

<span>notation</span> s `{` name ` ↦ ` val `}` <span>:=</span> state.update name val s

<span>def</span> <span>lookup_var</span> : string <span>→</span> list state <span>→</span> option atom
| var (list.nil) <span>:=</span> none
| var (list.cons s rest) <span>:=</span>
  <span>match</span> s var <span>with</span>
  | some result <span>:=</span> some result
  | none <span>:=</span> lookup_var var rest
  <span>end</span>




<span>lemma</span> <span>lookup_head</span> (x : string) (y : state) (ys : list state) (z : atom) :
  y x <span>=</span> some z <span>→</span> lookup_var x (y :: ys) <span>=</span> some z <span>:=</span>
<span>begin</span>
  intro h,
  simp [h, lookup_var],
<span>end</span>

<span>def</span> <span>set_var</span> : string <span>→</span> atom <span>→</span> list state <span>→</span> lisp_result (list state)
| place new_value (list.nil) <span>:=</span> except.error (lisp_error.no_such_variable place)
| place new_value (list.cons s rest) <span>:=</span>
  <span>match</span> s place <span>with</span>
  | (some <span>_</span>) <span>:=</span> except.ok (list.cons (s{place ↦ new_value}) rest)
  | none <span>:=</span>
    <span>match</span> set_var place new_value rest <span>with</span>
    | (except.ok rest&#39;) <span>:=</span> except.ok (list.cons s rest&#39;)
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  <span>end</span>


<span>def</span> <span>new_frame</span> : list string <span>→</span> list atom <span>→</span> state
| (list.cons name rest₁) (list.cons value rest₂) <span>:=</span> (new_frame rest₁ rest₂){name ↦ value}
| <span>_</span> <span>_</span> <span>:=</span> <span>λ</span> <span>_</span>, none
</pre>
</div>

<p>
And, finally, we can get into the implementation of evaluation. First, we&#39;ll implement evaluation of procedures. Either the procedure is primitive (or built-in), like <code>+</code>, it&#39;s a named compound procedure, it&#39;s a lambda form, or the name doesn&#39;t exist in the environment.
</p>

<div data-name="primitive procedures and construction of compound procedures">

<div>
<pre><span>def</span> <span>collect_params</span> : atom <span>→</span> option (list string)
| (atom.list (list.cons (atom.symbol param) rest)) <span>:=</span>
  <span>match</span> collect_params (atom.list rest) <span>with</span>
  | some rest&#39; <span>:=</span> some (list.cons param rest&#39;)
  | none <span>:=</span> none
  <span>end</span>
| (atom.list (list.nil)) <span>:=</span> some []
| <span>_</span> <span>:=</span> none

<span>#eval</span> collect_params (atom.list [atom.symbol <span>&#34;x&#34;</span>])
<span>#eval</span> collect_params (atom.list [atom.symbol <span>&#34;x&#34;</span>, atom.symbol <span>&#34;y&#34;</span>])

<span>def</span> <span>mk_compound_procedure</span>
      (closure_env : list state)
      (paramlist : atom)
      (body : list atom)
    : lisp_result atom <span>:=</span>
<span>match</span> collect_params paramlist <span>with</span>
| some params <span>:=</span>
  except.ok
    (atom.compound_procedure
      (<span>λ</span> x, lookup_var x closure_env)
      params
      (atom.list (list.cons (atom.symbol <span>&#34;begin&#34;</span>) body)))
| none <span>:=</span> except.error (lisp_error.bad_lambda)
<span>end</span>

<span>#eval</span> lisp_result_atom.repr
        (mk_compound_procedure
          [(<span>λ</span> <span>_</span>, none)]
          (atom.list [atom.symbol <span>&#34;x&#34;</span>])
          [(atom.symbol <span>&#34;+&#34;</span>), (atom.number <span>2</span>), (atom.number <span>4</span>)])

<span>def</span> <span>symbol_name</span> : atom <span>→</span> option string
| (atom.symbol name) <span>:=</span> some name
| <span>_</span> <span>:=</span> none

<span>def</span> <span>is_primitive_procedure</span> (name : string) : bool <span>:=</span>
  name ∈ [<span>&#34;+&#34;</span>, <span>&#34;-&#34;</span>, <span>&#34;*&#34;</span>, <span>&#34;/&#34;</span>, <span>&#34;=&#34;</span>, <span>&#34;car&#34;</span>, <span>&#34;cdr&#34;</span>, <span>&#34;cons&#34;</span>, <span>&#34;null?&#34;</span>, <span>&#34;eqv?&#34;</span>]

<span>@[simp]</span>
<span>lemma</span> <span>add_is_primitive</span> : is_primitive_procedure <span>&#34;+&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>sub_is_primitive</span> : is_primitive_procedure <span>&#34;-&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>mul_is_primitive</span> : is_primitive_procedure <span>&#34;*&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>div_is_primitive</span> : is_primitive_procedure <span>&#34;/&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>eq_is_primitive</span> : is_primitive_procedure <span>&#34;=&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>car_is_primitive</span> : is_primitive_procedure <span>&#34;car&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>cdr_is_primitive</span> : is_primitive_procedure <span>&#34;cdr&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>cons_is_primitive</span> : is_primitive_procedure <span>&#34;cons&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>null_is_primitive</span> : is_primitive_procedure <span>&#34;null?&#34;</span> <span>:=</span> <span>by</span> exact rfl
<span>@[simp]</span>
<span>lemma</span> <span>eqv_is_primitive</span> : is_primitive_procedure <span>&#34;eqv?&#34;</span> <span>:=</span> <span>by</span> exact rfl

<span>def</span> <span>fold_maybe_numeric</span> : (<span>ℤ</span> <span>→</span> <span>ℤ</span> <span>→</span> <span>ℤ</span>) <span>→</span> <span>ℤ</span> <span>→</span> list atom <span>→</span> option <span>ℤ</span>
| op nil (list.cons (atom.number n) rest) <span>:=</span>
  <span>do</span> {
    rest_sum ← fold_maybe_numeric op nil rest,
    pure (op n rest_sum) }
| op nil (list.nil) <span>:=</span> some nil
| <span>_</span> <span>_</span> <span>_</span> <span>:=</span> none

<span>def</span> <span>primitive_add</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> fold_maybe_numeric (<span>λ</span> x y, x <span>+</span> y) <span>0</span> args <span>with</span>
| some result <span>:=</span> except.ok (atom.number result)
| none <span>:=</span> except.error lisp_error.expected_number
<span>end</span>

<span>def</span> <span>primitive_sub</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> fold_maybe_numeric (<span>λ</span> x y, x <span>-</span> y) <span>0</span> args <span>with</span>
| some result <span>:=</span> except.ok (atom.number result)
| none <span>:=</span> except.error lisp_error.expected_number
<span>end</span>

<span>def</span> <span>primitive_mul</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> fold_maybe_numeric (<span>λ</span> x y, x <span>*</span> y) <span>1</span> args <span>with</span>
| some result <span>:=</span> except.ok (atom.number result)
| none <span>:=</span> except.error lisp_error.expected_number
<span>end</span>

<span>def</span> <span>primitive_div</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> fold_maybe_numeric (<span>λ</span> x y, x <span>/</span> y) <span>1</span> args <span>with</span>
| some result <span>:=</span> except.ok (atom.number result)
| none <span>:=</span> except.error lisp_error.expected_number
<span>end</span>

<span>def</span> <span>attach_state</span> : lisp_result atom <span>→</span> list state <span>→</span> lisp_result (atom <span>×</span> list state)
| (except.ok result) s <span>:=</span> except.ok (result, s)
| (except.error e) <span>_</span> <span>:=</span> except.error e


<span>def</span> <span>primitive_eq</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> args <span>with</span>
| (list.cons (atom.number x) (list.cons (atom.number y) <span>_</span>)) <span>:=</span>
  except.ok (<span>if</span> x <span>=</span> y <span>then</span> atom.boolean tt <span>else</span> atom.boolean ff)
| <span>_</span> <span>:=</span> except.error lisp_error.expected_number
<span>end</span>


<span>def</span> <span>primitive_car</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> args <span>with</span>
| (list.cons (atom.cell car cdr) <span>_</span>) <span>:=</span> except.ok car
| (list.cons car cdr) <span>:=</span> except.ok car
| <span>_</span> <span>:=</span> except.error lisp_error.expected_list
<span>end</span>

<span>def</span> <span>primitive_cdr</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> args <span>with</span>
| (list.cons (atom.cell car cdr) <span>_</span>) <span>:=</span> except.ok cdr
| (list.cons car cdr) <span>:=</span> except.ok (atom.list cdr)
| <span>_</span> <span>:=</span> except.error lisp_error.expected_list
<span>end</span>

<span>def</span> <span>primitive_cons</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> args <span>with</span>
| (list.cons car (list.cons (atom.list cdr) <span>_</span>)) <span>:=</span> except.ok (atom.list (list.cons car cdr))
| (list.cons car (list.cons cdr <span>_</span>)) <span>:=</span> except.ok (atom.cell car cdr)
| <span>_</span> <span>:=</span> except.error lisp_error.expected_list
<span>end</span>

<span>def</span> <span>primitive_null</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> args <span>with</span>
| (list.cons (atom.list (list.nil)) <span>_</span>) <span>:=</span> except.ok (atom.boolean tt)
| (list.cons (atom.list <span>_</span>) <span>_</span>) <span>:=</span> except.ok (atom.boolean ff)
| <span>_</span> <span>:=</span> except.error lisp_error.expected_list
<span>end</span>

<span>def</span> <span>primitive_eqv</span> (args : list atom) : lisp_result atom <span>:=</span>
<span>match</span> args <span>with</span>
| (list.cons (atom.symbol x) (list.cons (atom.symbol y) <span>_</span>)) <span>:=</span> except.ok (<span>if</span> x <span>=</span> y <span>then</span> atom.boolean tt <span>else</span> atom.boolean ff)
| <span>_</span> <span>:=</span> except.error lisp_error.expected_symbol
<span>end</span>
</pre>
</div>

</div>

<p>
We can&#39;t actually encode a &#34;proper&#34; Scheme implementation in Lean because there&#39;a possibility that we write a program that doesn&#39;t terminate. If we cap the maximum evaluation depth, though, we can prove that the evaluator is well-founded. This more accurately models the real world, anyway, since computers have a finite amount of memory. So we have an <code>evaluation_state</code> which maintains the current <code>stack_depth</code>, and we&#39;ll use that as both a guardrail that allows us to prove that our recursive <code>eval</code> function eventually terminates.
</p>

<div data-name="evaluator for a Scheme subset in Lean">

<div>
<pre><span>structure</span> <span>evaluation_state</span> <span>:=</span>
(stack_depth : <span>ℕ</span>)
(environment : list state)
(form        : atom)

<span>def</span> <span>evaluation_state_measure</span> : psum evaluation_state (psum evaluation_state evaluation_state) <span>→</span> <span>ℕ</span>
| (psum.inl state) <span>:=</span> state.stack_depth
| (psum.inr (psum.inl state)) <span>:=</span> state.stack_depth
| (psum.inr (psum.inr state)) <span>:=</span> state.stack_depth

<span>mutual</span> <span>def</span> <span>eval,</span> apply, eval_param_list

<span>with</span> eval : evaluation_state <span>→</span> lisp_result (atom <span>×</span> list state)
| (evaluation_state.mk <span>0</span> <span>_</span> <span>_</span>) <span>:=</span>
  except.error (lisp_error.excessive_recursion)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.undefined)) <span>:=</span>
  except.ok (atom.undefined, s)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.boolean bool)) <span>:=</span>
  except.ok (atom.boolean bool, s)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.number n)) <span>:=</span>
  except.ok (atom.number n, s)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.cell car cdr)) <span>:=</span>
  except.ok (atom.cell car cdr, s)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.primitive_procedure name)) <span>:=</span>
  except.ok (atom.primitive_procedure name, s)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.compound_procedure closure_env paramlist body)) <span>:=</span>
  except.ok (atom.compound_procedure closure_env paramlist body, s)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.symbol sym)) <span>:=</span>
  <span>if</span> sym <span>=</span> <span>&#34;+&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;+&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;-&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;-&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;*&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;*&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;/&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;/&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;=&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;=&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;car&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;car&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;cdr&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;cdr&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;cons&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;cons&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;null?&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;null?&#34;</span>, s)
  <span>else</span> <span>if</span> sym <span>=</span> <span>&#34;eqv?&#34;</span> <span>then</span>
    except.ok (atom.primitive_procedure <span>&#34;eqv?&#34;</span>, s)
  <span>else</span> <span>match</span> (lookup_var sym s) <span>with</span>
  | none <span>:=</span> except.error (lisp_error.no_such_variable sym)
  | some value <span>:=</span> except.ok (value, s)
  <span>end</span>
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.list (list.cons func rest))) <span>:=</span>
  <span>if</span> symbol_name func <span>=</span> some <span>&#34;quote&#34;</span> <span>then</span>
    except.ok (list.head rest, s)
  <span>else</span> <span>if</span> symbol_name func <span>=</span> some <span>&#34;lambda&#34;</span> <span>then</span>
    <span>match</span> mk_compound_procedure s (list.head rest) (list.tail rest) <span>with</span>
    | (except.ok lambda) <span>:=</span> except.ok (lambda, s)
    | (except.error err) <span>:=</span> except.error err
    <span>end</span>
  <span>else</span> <span>if</span> symbol_name func <span>=</span> some <span>&#34;begin&#34;</span> <span>then</span>
    <span>match</span> rest <span>with</span>
    | (list.cons head (list.nil)) <span>:=</span>
      eval (evaluation_state.mk stack_depth s head)
    | (list.cons head tail) <span>:=</span>
      <span>match</span> eval (evaluation_state.mk stack_depth s head) <span>with</span>
      | (except.ok (result, s&#39;)) <span>:=</span>
        eval (evaluation_state.mk stack_depth s&#39; (atom.list (list.cons (atom.symbol <span>&#34;begin&#34;</span>) tail)))
      | (except.error e) <span>:=</span> (except.error e)
      <span>end</span>
    | <span>_</span> <span>:=</span> (except.error lisp_error.bad_begin)
    <span>end</span>
  <span>else</span> <span>if</span> symbol_name func <span>=</span> some <span>&#34;set!&#34;</span> <span>then</span>
    <span>match</span> rest <span>with</span>
    | (list.cons (atom.symbol place) (list.cons value <span>_</span>)) <span>:=</span>
      <span>match</span> set_var place value s <span>with</span>
      | (except.ok s&#39;) <span>:=</span> except.ok (atom.undefined, s&#39;)
      | (except.error e) <span>:=</span> except.error e
      <span>end</span>
    | <span>_</span> <span>:=</span> except.error lisp_error.bad_arity
    <span>end</span>
  <span>else</span> <span>if</span> symbol_name func <span>=</span> some <span>&#34;if&#34;</span> <span>then</span>
    <span>match</span> rest <span>with</span>
    | (list.cons cond (list.cons ite_true (list.nil))) <span>:=</span>
      <span>match</span> eval (evaluation_state.mk stack_depth s cond) <span>with</span>
      | except.ok ((atom.boolean ff), s&#39;) <span>:=</span> except.ok (atom.undefined, s&#39;)
      | except.ok (<span>_</span>, s&#39;) <span>:=</span>
        <span>match</span> eval (evaluation_state.mk stack_depth s ite_true) <span>with</span>
        | except.ok (result, s&#39;&#39;) <span>:=</span> except.ok (result, s&#39;&#39;)
        | except.error e <span>:=</span> except.error e
        <span>end</span>
      | except.error e <span>:=</span> except.error e
      <span>end</span>
    | (list.cons cond (list.cons ite_true (list.cons ite_false <span>_</span>))) <span>:=</span>
      <span>match</span> eval (evaluation_state.mk stack_depth s cond) <span>with</span>
      | except.ok ((atom.boolean ff), s&#39;) <span>:=</span>
        <span>match</span> eval (evaluation_state.mk stack_depth s ite_false) <span>with</span>
        | except.ok (result, s&#39;&#39;) <span>:=</span> except.ok (result, s&#39;&#39;)
        | except.error e <span>:=</span> except.error e
        <span>end</span>
      | except.ok (<span>_</span>, s&#39;) <span>:=</span>
        <span>match</span> eval (evaluation_state.mk stack_depth s ite_true) <span>with</span>
        | except.ok (result, s&#39;&#39;) <span>:=</span> except.ok (result, s&#39;&#39;)
        | except.error e <span>:=</span> except.error e
        <span>end</span>
      | except.error e <span>:=</span> except.error e
      <span>end</span>
    | <span>_</span> <span>:=</span> except.error lisp_error.bad_if
    <span>end</span>
  <span>else</span> <span>if</span> symbol_name func <span>=</span> some <span>&#34;define&#34;</span> <span>then</span>
  <span>match</span> rest <span>with</span>
    
    | (list.cons (atom.list (list.cons (atom.symbol name) args)) body) <span>:=</span>
      <span>match</span> mk_compound_procedure s (atom.list args) body <span>with</span>
      | (except.ok procedure) <span>:=</span> except.ok (atom.undefined, list.cons ((list.head s){name ↦ procedure}) (list.tail s))
      | (except.error e) <span>:=</span> except.error e
      <span>end</span>
    | (list.cons (atom.symbol name) body) <span>:=</span>
      <span>match</span> eval (evaluation_state.mk stack_depth s (list.head body)) <span>with</span>
      | (except.ok (result, <span>_</span>)) <span>:=</span> except.ok (atom.undefined, list.cons ((list.head s){name ↦ result}) (list.tail s))
      | (except.error e) <span>:=</span> except.error e
      <span>end</span>
    | <span>_</span> <span>:=</span> except.error lisp_error.bad_define
  <span>end</span>
  <span>else</span> apply (evaluation_state.mk stack_depth s (atom.list (list.cons func rest)))
| <span>_</span> <span>:=</span> except.error lisp_error.unknown_form

<span>with</span> apply : evaluation_state <span>→</span> lisp_result (atom <span>×</span> list state)
| (evaluation_state.mk <span>0</span> <span>_</span> <span>_</span>) <span>:=</span>
  except.error (lisp_error.excessive_recursion)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.list (list.cons func args))) <span>:=</span>
  <span>let</span> func&#39; <span>:=</span> eval (evaluation_state.mk stack_depth s func),
      args_evaluated <span>:=</span> eval_param_list (evaluation_state.mk stack_depth s (atom.list args)) <span>in</span>
  <span>match</span> func&#39; <span>with</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;+&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_add args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;-&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_sub args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;*&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_mul args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;/&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_div args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;=&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_eq args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;car&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_car args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;cdr&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_cdr args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;cons&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_cons args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;null?&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_null args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure <span>&#34;eqv?&#34;</span>), <span>_</span>)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span> attach_state (primitive_eqv args&#39;) s
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.ok ((atom.primitive_procedure name), <span>_</span>)) <span>:=</span>
    except.error (lisp_error.no_such_variable name)
  | (except.ok ((atom.compound_procedure closure_env paramlist body), s&#39;)) <span>:=</span>
    <span>match</span> args_evaluated <span>with</span>
    | (except.ok (args&#39;, s&#39;)) <span>:=</span>
      <span>let</span> s&#39;&#39; <span>:=</span> (list.cons (new_frame paramlist args&#39;) (list.cons closure_env s&#39;)) <span>in</span>
        eval (evaluation_state.mk stack_depth s&#39;&#39; body)
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | <span>_</span> <span>:=</span> except.error (lisp_error.unknown_form)
  <span>end</span>
| <span>_</span> <span>:=</span> except.error lisp_error.unknown_form

<span>with</span> eval_param_list : evaluation_state <span>→</span> lisp_result (list atom <span>×</span> list state)
| (evaluation_state.mk <span>0</span> <span>_</span> <span>_</span>) <span>:=</span>
  except.error (lisp_error.excessive_recursion)
| (evaluation_state.mk stack_depth s (atom.list (list.nil))) <span>:=</span>
  except.ok ([], s)
| (evaluation_state.mk (stack_depth <span>+</span> <span>1</span>) s (atom.list (list.cons elt rest))) <span>:=</span>
  <span>match</span> eval (evaluation_state.mk stack_depth s elt) <span>with</span>
  | (except.ok (result_head, s&#39;)) <span>:=</span>
    <span>match</span> eval_param_list (evaluation_state.mk stack_depth s&#39; (atom.list rest)) <span>with</span>
    | except.ok (result_rest, s&#39;&#39;) <span>:=</span> except.ok (list.cons result_head result_rest, s&#39;&#39;)
    | (except.error e) <span>:=</span> except.error e
    <span>end</span>
  | (except.error e) <span>:=</span> except.error e
  <span>end</span>
| <span>_</span> <span>:=</span> except.error lisp_error.unknown_form

<span>using_well_founded</span> {rel_tac <span>:=</span> <span>λ</span> <span>_</span> <span>_</span>, `[exact ⟨<span>_</span>, measure_wf evaluation_state_measure⟩]}
</pre>
</div>

</div>

<p>
I found the evaluation state structure to actually be quite convenient in reasoning about things like whether or not an evaluation is finite.
</p>

<div>
<pre><span>lemma</span> <span>finite_implies_nonzero_stack_depth</span>
  (form result : atom)
  (environment environment&#39; : list state)
  (stack_depth : <span>ℕ</span>)
  (h_finite : <span>¬</span> (eval (evaluation_state.mk stack_depth environment form) <span>=</span> except.error (lisp_error.excessive_recursion))) :
  stack_depth <span>&gt;</span> <span>0</span> <span>:=</span>
<span>begin</span>
  by_contra&#39;,
  apply h_finite,
  simp [le_of_eq] <span>at</span> <span>this</span>,
  simp [<span>this</span>, eval],
<span>end</span>
</pre>
</div>

<p>
The approach I&#39;ve taken for the program semantics is to compile the expression to a &#34;statement&#34; type, and then reason about the big step semantics of those statements.
</p>

<p>
At the beginning, I was doing small step semantics, until I realized that it was really hard to reason about a language where everything is an expression without being able to assume hypotheses about the transitive nature of small steps, which Lean didn&#39;t like at all. Something about nesting inductive predicates.
</p>

<div data-name="big step semantics for the Scheme subset">

<div>
<pre><span>inductive</span> <span>stmt</span> : <span>Type</span>
| expr   : atom <span>→</span> stmt                
| var    : string <span>→</span> stmt              
| seq    : stmt <span>→</span> stmt <span>→</span> stmt         
| assign : string <span>→</span> stmt <span>→</span> stmt       
| define : string <span>→</span> stmt <span>→</span> stmt       
| ite    : stmt <span>→</span> stmt <span>→</span> stmt <span>→</span> stmt  
| app    : stmt <span>→</span> list stmt <span>→</span> stmt    

<span>meta</span> <span>def</span> <span>stmt.repr</span> : stmt <span>→</span> string
| (stmt.expr expr)                 <span>:=</span> <span>&#34;(expr &#34;</span> <span>++</span> atom.repr expr <span>++</span> <span>&#34;)&#34;</span>
| (stmt.var name)                  <span>:=</span> <span>&#34;(deref &#34;</span> <span>++</span> name <span>++</span> <span>&#34;)&#34;</span>
| (stmt.seq car cdr)               <span>:=</span> <span>&#34;(seq &#34;</span> <span>++</span> stmt.repr car <span>++</span> <span>&#34; &#34;</span> <span>++</span> stmt.repr cdr <span>++</span> <span>&#34;)&#34;</span>
| (stmt.assign place rhs)          <span>:=</span> <span>&#34;(assign &#34;</span> <span>++</span> place <span>++</span> <span>&#34; &#34;</span> <span>++</span> stmt.repr rhs <span>++</span> <span>&#34;)&#34;</span>
| (stmt.define place rhs)          <span>:=</span> <span>&#34;(define &#34;</span> <span>++</span> place <span>++</span> <span>&#34; &#34;</span> <span>++</span> stmt.repr rhs <span>++</span> <span>&#34;)&#34;</span>
| (stmt.ite cond if_true if_false) <span>:=</span> <span>&#34;(if &#34;</span> <span>++</span> stmt.repr cond <span>++</span> <span>&#34; &#34;</span> <span>++</span> stmt.repr if_true <span>++</span> <span>&#34; &#34;</span> <span>++</span> stmt.repr if_false <span>++</span> <span>&#34;)&#34;</span>
| (stmt.app func args)             <span>:=</span> <span>&#34;(application &#34;</span> <span>++</span> stmt.repr func <span>++</span> <span>&#34; &#34;</span> <span>++</span> string.intercalate <span>&#34; &#34;</span> (list.map stmt.repr args) <span>++</span> <span>&#34;)&#34;</span>

<span>instance</span> <span>stmt_inhabited</span> : inhabited stmt <span>:=</span>
inhabited.mk (stmt.expr (atom.undefined))

<span>def</span> <span>is_some</span> {α : <span>Type</span>} : option α <span>→</span> <span>Prop</span>
| (some <span>_</span>) <span>:=</span> true
| <span>_</span>        <span>:=</span> false

<span>def</span> <span>is_lambda</span> : atom <span>→</span> <span>Prop</span>
| (atom.list (list.cons (atom.symbol <span>&#34;lambda&#34;</span>) <span>_</span>)) <span>:=</span> true
| <span>_</span>        <span>:=</span> false

<span>def</span> <span>seq_from_list_stmt</span> : list stmt <span>→</span> stmt
| (list.nil) <span>:=</span> stmt.expr atom.undefined
| (list.cons head (list.nil)) <span>:=</span> head
| (list.cons head tail) <span>:=</span> stmt.seq head (seq_from_list_stmt tail)

<span>mutual</span> <span>def</span> <span>compile_stmt,</span> compile_stmt_list
<span>with</span> compile_stmt : atom <span>→</span> option stmt

| (atom.list (list.cons func (list.nil))) <span>:=</span>
  <span>do</span> {
    result ← compile_stmt func,
    pure (stmt.app result []) }

| (atom.list (list.cons func (list.cons rest (list.nil)))) <span>:=</span>
  <span>match</span> func <span>with</span>
  | (atom.symbol <span>&#34;begin&#34;</span>) <span>:=</span> compile_stmt rest
  | (atom.symbol <span>&#34;quote&#34;</span>) <span>:=</span> some (stmt.expr rest)
  | <span>_</span> <span>:=</span> <span>do</span> {
    result₁ ← compile_stmt func,
    result₂ ← compile_stmt rest,
    pure (stmt.app result₁ [result₂]) }
  <span>end</span>

| (atom.list (list.cons func (list.cons place (list.cons rhs (list.nil))))) <span>:=</span>
  <span>match</span> func <span>with</span>
  | (atom.symbol <span>&#34;begin&#34;</span>) <span>:=</span>
    <span>do</span> {
      result₁ ← compile_stmt func,
      result₂ ← compile_stmt place,
      result₃ ← compile_stmt rhs,
      pure (stmt.seq result₂ result₃) }
  | (atom.symbol <span>&#34;set!&#34;</span>) <span>:=</span>
    <span>match</span> place <span>with</span>
    | (atom.symbol place) <span>:=</span>
       <span>do</span> {
        rhs_result ← compile_stmt rhs,
        pure (stmt.assign place rhs_result) }
    | <span>_</span> <span>:=</span> none
    <span>end</span>
  
  
  
  | (atom.symbol <span>&#34;lambda&#34;</span>) <span>:=</span> some (stmt.expr (atom.list [func, place, rhs]))
  | (atom.symbol <span>&#34;define&#34;</span>) <span>:=</span>
    <span>match</span> place <span>with</span>
    
    | (atom.list (list.cons (atom.symbol func_name) params)) <span>:=</span>
      some (stmt.expr
             (atom.list ([
               (atom.symbol <span>&#34;lambda&#34;</span>),
               (atom.list params),
               (atom.list [(atom.symbol <span>&#34;begin&#34;</span>), rhs])])))
    | (atom.symbol place) <span>:=</span>
       <span>do</span> {
        rhs_result ← compile_stmt rhs,
        pure (stmt.define place rhs_result) }
    | <span>_</span> <span>:=</span> none
    <span>end</span>
  | <span>_</span> <span>:=</span> <span>do</span> {
    result₁ ← compile_stmt func,
    result₂ ← compile_stmt place,
    result₃ ← compile_stmt rhs,
    pure (stmt.app result₁ [result₂, result₃]) }
  <span>end</span>

| (atom.list (list.cons func (list.cons rest_head (list.cons rest_tail₁ (list.cons rest_tail₂ (list.nil)))))) <span>:=</span>
<span>match</span> func <span>with</span>
  | (atom.symbol <span>&#34;if&#34;</span>) <span>:=</span>
      <span>do</span> {
      result₁ ← compile_stmt rest_head,
      result₂ ← compile_stmt rest_tail₁,
      result₃ ← compile_stmt rest_tail₂,
      pure (stmt.ite result₁ result₂ result₃)}
  | (atom.symbol <span>&#34;begin&#34;</span>) <span>:=</span>
      <span>do</span> {
      result₁ ← compile_stmt rest_head,
      result₂ ← compile_stmt rest_tail₁,
      result₃ ← compile_stmt rest_tail₂,
      pure (stmt.seq result₁ (stmt.seq result₂ result₃))}
  | <span>_</span> <span>:=</span> <span>do</span> {
    result₁ ← compile_stmt func,
    result₂ ← compile_stmt rest_head,
    result₃ ← compile_stmt rest_tail₁,
    result₄ ← compile_stmt rest_tail₂,
    pure (stmt.app result₁ [result₂, result₃, result₄])}
  <span>end</span>

| (atom.list (list.cons func (list.cons rest_head (list.cons rest_tail₁ rest_tail₂)))) <span>:=</span>
  <span>match</span> func <span>with</span>
  | (atom.symbol <span>&#34;begin&#34;</span>) <span>:=</span>
      <span>do</span> {
      result₁ ← compile_stmt rest_head,
      result₂ ← compile_stmt rest_tail₁,
      result₃ ← compile_stmt_list rest_tail₂,
      pure (stmt.seq result₁ (stmt.seq result₂ (seq_from_list_stmt result₃)))}
  
  
  | (atom.symbol <span>&#34;lambda&#34;</span>) <span>:=</span> some (stmt.expr (atom.list (list.cons func (list.cons rest_head (list.cons rest_tail₁ rest_tail₂)))))
  
  
  | (atom.symbol <span>&#34;define&#34;</span>) <span>:=</span>
    <span>match</span> rest_head <span>with</span>
    | (atom.list (list.cons (atom.symbol func_name) params)) <span>:=</span>
      some (stmt.expr
             (atom.list ([
               (atom.symbol <span>&#34;lambda&#34;</span>),
               (atom.list params),
               (atom.list ([(atom.symbol <span>&#34;begin&#34;</span>)] <span>++</span> (list.cons rest_tail₁ rest_tail₂)))])))
    | <span>_</span> <span>:=</span> none
    <span>end</span>
  | <span>_</span> <span>:=</span> <span>do</span> {
    result₁ ← compile_stmt func,
    result₂ ← compile_stmt_list (list.cons rest_head (list.cons rest_tail₁ rest_tail₂)),
    pure (stmt.app result₁ result₂) }
  <span>end</span>
| (atom.list (list.nil)) <span>:=</span> none
| (atom.symbol sym) <span>:=</span>
  <span>if</span> is_primitive_procedure sym <span>then</span>
    some (stmt.expr (atom.primitive_procedure sym))
  <span>else</span> some (stmt.var sym)
| e <span>:=</span> some (stmt.expr e)

<span>with</span> compile_stmt_list : list atom <span>→</span> option (list stmt)
| (list.cons head rest) <span>:=</span>
  <span>match</span> compile_stmt head <span>with</span>
  | (some result) <span>:=</span>
    <span>match</span> (compile_stmt_list rest) <span>with</span>
    | some result_rest <span>:=</span> some (list.cons result result_rest)
    | none <span>:=</span> none
    <span>end</span>
  | none <span>:=</span> none
  <span>end</span>
| (list.nil) <span>:=</span> some []

<span>def</span> <span>unwrap_option</span> {α : <span>Type</span>} [inhabited α] : option α <span>→</span> α
| (some x) <span>:=</span> x
| <span>_</span>        <span>:=</span> inhabited.default

<span>mutual</span> <span>inductive</span> <span>args_step,</span> big_step
<span>with</span> args_step : list stmt <span>×</span> list state <span>→</span> list atom <span>×</span> list state <span>→</span> <span>Prop</span>
| nil {s} :
  args_step
    ((list.nil), s)
    ((list.nil), s)

| cons {S T s s&#39; s&#39;&#39; u r}
  (hstep : big_step (S, s) (u, s&#39;))
  (hrest : args_step (T, s&#39;) (r, s&#39;&#39;)) :
  args_step
    (list.cons S T, s)
    (list.cons u r, s&#39;&#39;)

<span>with</span> big_step : stmt <span>×</span> list state <span>→</span> atom <span>×</span> list state <span>→</span> <span>Prop</span>



| drop_frame {expr u s s&#39; f rest}
  (heval_in_frame : big_step (expr, s) (u, s&#39;))
  (h_has_frame : s <span>=</span> list.cons f rest) :
  big_step (expr, s) (u, rest)

| self_evaluating {expr s}
  (h_not_lambda : <span>¬</span> is_lambda expr):
  big_step
    (stmt.expr expr, s)
    (expr, s)

| construct_compound_procedure {args body closure s}
  (h_well_formed : mk_compound_procedure s args body <span>=</span> except.ok closure):
  big_step
    (stmt.expr (atom.list ([(atom.symbol <span>&#34;lambda&#34;</span>), args] <span>++</span> body)), s)
    (closure, s)

| var_deref {x u s}
  (h_lookup_var : lookup_var x s <span>=</span> some u):
  big_step
    (stmt.var x, s)
    (u, s)

| seq {S S&#39; T s t t&#39; u}
  (hS : big_step (S, s) (S&#39;, t))
  (hT : big_step (T, t) (u, t&#39;)) :
  big_step
    (stmt.seq S T, s)
    (u, t&#39;)

| assign {x rhs rhs_expr s s&#39; s&#39;&#39;}
  (h_rhs_eval : big_step (rhs, s) (rhs_expr, s&#39;))
  (h_var_exists : set_var x rhs_expr s&#39; <span>=</span> except.ok s&#39;&#39;) :
  big_step
    (stmt.assign x rhs, s)
    (atom.undefined, s&#39;&#39;)

| define {x rhs rhs_expr s s&#39;}
  (h_rhs_eval : big_step (rhs, s) (rhs_expr, s&#39;)) :
  big_step
    (stmt.define x rhs, s)
    (atom.undefined, list.cons ((list.head s&#39;){x ↦ rhs_expr}) (list.tail s&#39;))

| ite_true {b S T s s&#39; t u}
  (hcond : big_step (b, s) ((atom.boolean tt), s&#39;))
  (heval : big_step (S, s&#39;) (u, t)) :
  big_step
    (stmt.ite b S T, s)
    (u, t)

| ite_false {b S T s s&#39; t u}
  (hcond : big_step (b, s) ((atom.boolean ff), s&#39;))
  (heval : big_step (T, s&#39;) (u, t)) :
  big_step
    (stmt.ite b S T, s)
    (u, t)

| application {closed func params body body&#39; args args&#39; expr s s&#39; s&#39;&#39; s&#39;&#39;&#39;}
  (h_func : big_step (func, s) ((atom.compound_procedure closed params body), s&#39;))
  (h_args : args_step (args, s&#39;) (args&#39;, s&#39;&#39;))
  (h_well_formed : compile_stmt body <span>=</span> some body&#39;)
  (heval : big_step (body&#39;,
                    (list.cons (new_frame params args&#39;)
                               (list.cons closed s&#39;)))
                    (expr, s&#39;&#39;)) :
  big_step
    (stmt.app func args, s)
    (expr, s&#39;&#39;&#39;)

| application_primitive_add {s s&#39; args args&#39; n}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_add args&#39; <span>=</span> except.ok (atom.number n)):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;+&#34;</span>))
      args, s)
    (atom.number n, s)

| application_primitive_sub {s s&#39; args args&#39; n}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_sub args&#39; <span>=</span> except.ok (atom.number n)):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;-&#34;</span>))
      args, s)
    (atom.number n, s)

| application_primitive_mul {s s&#39; args args&#39; n}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_mul args&#39; <span>=</span> except.ok (atom.number n)):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;*&#34;</span>))
      args, s)
    (atom.number n, s)

| application_primitive_div {s s&#39; args args&#39; n}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_div args&#39; <span>=</span> except.ok (atom.number n)):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;/&#34;</span>))
      args, s)
    (atom.number n, s)

| application_primitive_eq {s s&#39; args args&#39; b}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_eq args&#39; <span>=</span> except.ok (atom.boolean b)):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;=&#34;</span>))
      args, s)
    (atom.boolean b, s)

| application_primitive_car {s s&#39; args args&#39; u}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_car args&#39; <span>=</span> except.ok u):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;car&#34;</span>))
      args, s)
    (u, s)

| application_primitive_cdr {s s&#39; args args&#39; u}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_cdr args&#39; <span>=</span> except.ok u):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;cdr&#34;</span>))
      args, s)
    (u, s)

| application_primitive_cons {s s&#39; args args&#39; u}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_cons args&#39; <span>=</span> except.ok u):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;cons&#34;</span>))
      args, s)
    (u, s)

| application_primitive_null {s s&#39; args args&#39; u}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_null args&#39; <span>=</span> except.ok u):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;null?&#34;</span>))
      args, s)
    (u, s)

| application_primitive_eqv {s s&#39; args args&#39; u}
  (h_args : args_step (args, s) (args&#39;, s&#39;))
  (heval: primitive_null args&#39; <span>=</span> except.ok u):
  big_step
    (stmt.app
      (stmt.expr (atom.primitive_procedure <span>&#34;eqv?&#34;</span>))
      args, s)
    (u, s)
</pre>
</div>

</div>

<p>
This is the simplest program I could think of to show that the program semantics are at least usable.
</p>

<div>
<pre><span>lemma</span> <span>var_lookup</span> :
  big_step
    (stmt.var <span>&#34;x&#34;</span>, [(<span>λ</span> x, none){<span>&#34;x&#34;</span> ↦ atom.number <span>1</span>}])
    ((atom.number <span>1</span>), [(<span>λ</span> x, none){<span>&#34;x&#34;</span> ↦ atom.number <span>1</span>}]) <span>:=</span>
<span>begin</span>
  apply big_step.var_deref,
  <span>let</span> my_state <span>:=</span> [(<span>λ</span> x, none){<span>&#34;x&#34;</span> ↦ atom.number <span>1</span>}],
  apply lookup_head,
  simp [state.update],
<span>end</span>
</pre>
</div>

<p>
This is a much more involved proof: that the factorial program at the top of this file is &#34;correct,&#34; in the sense that it computes <code>int.factorial</code>.
</p>

<p>
As you&#39;ll see, my approach to proving this statement involved many obligations, and ended up being very tedious. It&#39;s effectively the &#34;intro to algorithms&#34; proof of correctness for factorial, except that we&#39;re appealing to the big-step semantics above. By which I mean – we&#39;re doing a rather poor job of leveraging the mathematical tools we just spent pages of code developing. Had I more time to work on this assignment, I might have naturally come to one of the refinement-based solutions, but I chose to be stubborn and just press forward.
</p>

<div data-name="a lengthy proof about some code for evaluating the factorial function">

<div>
<pre><span>def</span> <span>nat.factorial</span> : <span>ℕ</span> <span>→</span> <span>ℤ</span>
| <span>0</span> <span>:=</span> <span>1</span>
| (n <span>+</span> <span>1</span>) <span>:=</span> (n <span>+</span> <span>1</span>) <span>*</span> (nat.factorial n)

<span>def</span> <span>int.factorial</span> : <span>ℤ</span> <span>→</span> <span>ℤ</span>
| (int.of_nat n)          <span>:=</span> nat.factorial n
| (int.neg_succ_of_nat n) <span>:=</span> nat.factorial (n <span>+</span> <span>1</span>)


<span>lemma</span> <span>sub1_cast</span> (n : <span>ℕ</span>) : 
  primitive_sub [atom.number (↑n <span>+</span> <span>1</span>), atom.number <span>1</span>] <span>=</span> except.ok (atom.number ↑n) <span>:=</span>
<span>sorry</span>


<span>lemma</span> <span>primitive_mul_fact</span> (n : <span>ℕ</span>) : 
  primitive_mul [atom.number (↑n <span>+</span> <span>1</span>), atom.number (int.factorial ↑n)] <span>=</span> except.ok (atom.number (int.factorial ↑(nat.succ n))) <span>:=</span>
<span>sorry</span>


<span>lemma</span> <span>factorial_program_compile_inner</span> :
  (compile_stmt
    (atom.list
         [atom.symbol <span>&#34;if&#34;</span>, atom.list [atom.symbol <span>&#34;=&#34;</span>, atom.number <span>0</span>, atom.symbol <span>&#34;x&#34;</span>], atom.number <span>1</span>, atom.list
             [atom.symbol <span>&#34;*&#34;</span>, atom.symbol <span>&#34;x&#34;</span>, atom.list
                 [atom.symbol <span>&#34;factorial&#34;</span>, atom.list [atom.symbol <span>&#34;-&#34;</span>, atom.symbol <span>&#34;x&#34;</span>, atom.number <span>1</span>]]]])) <span>=</span>
  some
    (stmt.ite (stmt.app (stmt.expr (atom.primitive_procedure <span>&#34;=&#34;</span>))
                        [stmt.expr (atom.number <span>0</span>), stmt.var <span>&#34;x&#34;</span>])
              (stmt.expr (atom.number <span>1</span>))
              (stmt.app (stmt.expr (atom.primitive_procedure <span>&#34;*&#34;</span>))
                        [stmt.var <span>&#34;x&#34;</span>,
                         stmt.app (stmt.var <span>&#34;factorial&#34;</span>)
                                  [stmt.app (stmt.expr (atom.primitive_procedure <span>&#34;-&#34;</span>))
                                            [stmt.var <span>&#34;x&#34;</span>, stmt.expr (atom.number <span>1</span>)]]])) <span>:=</span>
<span>sorry</span>



<span>def</span> <span>define_factorial</span> (s : list state) : list state <span>:=</span>
list.cons ((<span>λ</span> <span>_</span>, none){<span>&#34;factorial&#34;</span> ↦
  (atom.compound_procedure (<span>λ</span> x, none) [<span>&#34;x&#34;</span>]
    (atom.list [
      (atom.symbol <span>&#34;if&#34;</span>),
      (atom.list [(atom.symbol <span>&#34;=&#34;</span>), (atom.number <span>0</span>), (atom.symbol <span>&#34;x&#34;</span>)]),
      (atom.number <span>1</span>),
      (atom.list [
        (atom.symbol <span>&#34;*&#34;</span>),
        (atom.symbol <span>&#34;x&#34;</span>),
        (atom.list [
          (atom.symbol <span>&#34;factorial&#34;</span>),
          (atom.list [
            (atom.symbol <span>&#34;-&#34;</span>),
            (atom.symbol <span>&#34;x&#34;</span>),
            (atom.number <span>1</span>)])])])]))}) s

<span>lemma</span> <span>factorial_program_correct</span> (n : <span>ℕ</span>) (s : list state) (arg : stmt)
  (h_eval_to_n : big_step
                   (arg, define_factorial s)
                   (atom.number n, define_factorial s)) :
  big_step
    (stmt.app (stmt.var <span>&#34;factorial&#34;</span>) [arg], define_factorial s)
    (atom.number (int.factorial n), define_factorial s) <span>:=</span>
<span>begin</span>
  <span>let</span> fundef <span>:=</span>
    (atom.compound_procedure (<span>λ</span> x, none) [<span>&#34;x&#34;</span>]
      (atom.list [
        (atom.symbol <span>&#34;if&#34;</span>),
        (atom.list [(atom.symbol <span>&#34;=&#34;</span>), (atom.number <span>0</span>), (atom.symbol <span>&#34;x&#34;</span>)]),
        (atom.number <span>1</span>),
        (atom.list [
          (atom.symbol <span>&#34;*&#34;</span>),
          (atom.symbol <span>&#34;x&#34;</span>),
          (atom.list [
            (atom.symbol <span>&#34;factorial&#34;</span>),
            (atom.list [
              (atom.symbol <span>&#34;-&#34;</span>),
              (atom.symbol <span>&#34;x&#34;</span>),
              (atom.number <span>1</span>)])])])])),
  <span>have</span> h_lookup_factorial : lookup_var <span>&#34;factorial&#34;</span> (define_factorial s) <span>=</span> some fundef, <span>by</span>
  <span>begin</span>
    simp [define_factorial],
    apply lookup_head,
    simp [state.update],
  <span>end</span>,
  induction&#39; n,
  { apply big_step.application,
    { apply big_step.var_deref,
      simp [h_lookup_factorial, fundef],
      apply and.intro,
      { refl, },
      { apply and.intro,
        { refl, },
        { refl, }}},
    { apply args_step.cons,
      { apply h_eval_to_n, },
      { apply args_step.nil, }},
    { exact factorial_program_compile_inner, },
    { apply big_step.ite_true,
      { apply big_step.application_primitive_eq,
        { apply args_step.cons,
          { apply big_step.self_evaluating, simp [is_lambda], },
          { apply args_step.cons,
            { apply big_step.var_deref,
              simp [new_frame],
              apply lookup_head,
              simp [state.update], },
            { apply args_step.nil, }}},
        { unfold primitive_eq, simp, }},
      { apply drop_two_frames,
        apply big_step.self_evaluating,
        simp [is_lambda], }}},
  { apply big_step.application,
    { apply big_step.var_deref,
      simp [h_lookup_factorial, fundef],
      apply and.intro,
      { refl, },
      { apply and.intro,
        { refl, },
        { refl, }}},
    { apply args_step.cons,
      { apply h_eval_to_n, },
      { apply args_step.nil, }},
    { exact factorial_program_compile_inner, },
    { apply big_step.ite_false,
      { apply big_step.application_primitive_eq,
        { apply args_step.cons,
          { apply big_step.self_evaluating, simp [is_lambda], },
          { apply args_step.cons,
            { apply big_step.var_deref,
              simp [new_frame],
              apply lookup_head,
              simp [state.update], },
            { apply args_step.nil, }}},
        { unfold primitive_eq,
          norm_cast, }},
      { apply drop_two_frames,
        apply big_step.application_primitive_mul,
        { apply args_step.cons,
          { apply big_step.var_deref,
            simp [new_frame, state.update],
            apply lookup_head,
            simp, },
          { apply args_step.cons,
            { <span>have</span> hsimp : <span>∀</span> (arg : stmt) (u : atom) (s : list state),
                big_step (arg, new_frame [<span>&#34;x&#34;</span>] [atom.number ↑(nat.succ n)] :: (<span>λ</span> (x : string), none) :: define_factorial s)
                         (u, new_frame [<span>&#34;x&#34;</span>] [atom.number ↑(nat.succ n)] :: (<span>λ</span> (x : string), none) :: define_factorial s) <span>↔</span>
                big_step (arg, define_factorial (new_frame [<span>&#34;x&#34;</span>] [atom.number ↑(nat.succ n)] :: (<span>λ</span> (x : string), none) :: define_factorial s))
                         (u, define_factorial (new_frame [<span>&#34;x&#34;</span>] [atom.number ↑(nat.succ n)] :: (<span>λ</span> (x : string), none) :: define_factorial s)),
              <span>by</span> <span>sorry</span>, 
              rw hsimp,
              apply ih,
              { exact h_lookup_factorial, },
              { apply big_step.application_primitive_sub,
                { apply args_step.cons,
                  { <span>have</span> hsimp₂ : lookup_var <span>&#34;x&#34;</span>
                      (define_factorial
                        (new_frame [<span>&#34;x&#34;</span>] [atom.number ↑(nat.succ n)] :: (<span>λ</span> (x : string), none) :: define_factorial s)) <span>=</span>
                      lookup_var <span>&#34;x&#34;</span> (new_frame [<span>&#34;x&#34;</span>] [atom.number ↑(nat.succ n)] :: (<span>λ</span> (x : string), none) :: define_factorial s),
                    <span>by</span> <span>sorry</span>, 
                    apply big_step.var_deref,
                    rw hsimp₂,
                    simp [new_frame, state.update],
                    apply lookup_head,
                    simp, },
                  { apply args_step.cons,
                    { apply big_step.self_evaluating,
                      simp [is_lambda], },
                    { apply args_step.nil, }}},
                { apply sub1_cast, }}},
            { apply args_step.nil, }}},
        apply primitive_mul_fact, }}}
<span>end</span>
</pre>
</div>

</div>

<p>
The <code>sorry</code> keyword lets you pretend to be Pierre de Fermat and say &#34;this should be provable but I don&#39;t want to write the proof down.&#34; It&#39;s helpful in making some progress when you&#39;re working towards a deadline, but it completely violates the soundness of Lean&#39;s logic.
</p>

<p>
I&#39;m not sure how enlightening any of this is, but I think it does highlight how much goes into using these sorts of tools for program verification compared to the ease with which we used Alloy to check my answer to a homework problem.
</p>
</div></div>
  </body>
</html>
