<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.ulisp.com/show?2L0C">Original</a>
    <h1>Lisp Badge</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>The Lisp Badge is a self-contained computer with its own display and keyboard, based on an ATmega1284, that you can program in uLisp:</p>
<p><img src="http://www.ulisp.com/pictures/3j/lispbadgehand.jpg" alt="LispBadgeHand.jpg" width="720" height="462"/></p>
<p>You can use it to run programs that interface to components such as LEDs and push-buttons via the I/O pins, read the analogue inputs, and operate external devices via the I2C and SPI interfaces. It has a greyscale OLED display that gives 8 lines of 42 characters, and an integrated 45-key keyboard optimised for Lisp.</p>
<p>For details of how to build one see <a href="http://www.technoblogy.com/show?2AEE" target="_blank">Lisp Badge</a> on Technoblogy.</p>
<p>Get the latest firmware from <a href="https://github.com/technoblogy/lisp-badge" target="_blank">Lisp Badge</a> on GitHub. </p>
<h4>Updates</h4>
<p>10th July 2020: The Lisp Badge firmware has now been updated to Version 3, which adds the following improvements: uLisp is now updated to uLisp AVR Version 3.3a; three additional plotting extensions have been added, <strong>fill-screen</strong>, <strong>plot-pixel</strong>, and <strong>glyph-pixel</strong>; the keyboard now supports entering three additional characters needed by Lisp; and the piezo speaker can now be used with the <strong>note</strong> function to play tunes. These improvements are described in greater detail below.</p>
<p>23rd January 2022: The Lisp Badge firmware has now been updated to Version 4.1a. This adds a <strong>register</strong> function that allows you to read the values of 8-bit peripheral registers, or write values to the registers. It allows you to control the peripherals in the processor from a Lisp program, or interactively experiment with the peripherals by giving commands at the uLisp prompt; see the examples below.</p>
<p>22nd September 2022: The Lisp Badge firmware is now at Version 4.3, which adds support for arrays, and built-in documentation.</p>
<h3><span>Specification</span></h3>
<p><strong>Size:</strong> 107mm x 61mm (4.2&#34; x 2.4&#34;).</p>
<p><strong>Display</strong>: 42 characters x 8 lines.</p>
<p><strong>Keyboard:</strong> Integrated 45-key keyboard providing upper and lower-case characters, digits, and the symbols required by uLisp. Three additional characters can be entered using SHIFT: &#39;~&#39; (SHIFT-ESC), &#39;%&#39; (SHIFT-DEL), and &#39;:&#39; (SHIFT-Enter).</p>
<p><strong>Memory available</strong>: 2816 Lisp cells (11264 bytes).</p>
<p><strong>EEPROM</strong>: 1024 Lisp cells (4096 bytes), allows you to save the Lisp workspace using <strong>save-image</strong>.</p>
<p><strong>Processor:</strong> ATmega1284P</p>
<p><strong>Clock speed:</strong> 16 MHz.</p>
<p><strong>Current consumption:</strong> Approx. 20 mA.</p>
<h4><strong>Language</strong></h4>
<p>uLisp, a subset of Common Lisp, with 155 Lisp functions and special forms. For a full definition see <a href="http://www.ulisp.com/show?3L" target="_blank">uLisp Language Reference</a>.</p>
<p>The language includes four graphics extensions: <strong>fill-screen</strong> for clearing the screen, <strong>plot-pixel</strong> for plotting pixels, and <strong>plot</strong> and <strong>plot3d</strong>, for plotting graphs and 3d functions. For more information see <a href="#plotting-extensions">Plotting extensions</a> below.</p>
<p><strong>Types supported</strong>: list, symbol, integer, character, string, and stream.</p>
<p>An integer is a sequence of digits, optionally prefixed with &#34;+&#34; or &#34;-&#34;. Integers can be between -32768 and 32767. You can enter numbers in hexadecimal, octal, or binary with the notations #x2A, #o52, or #b101010, all of which represent 42.</p>
<p>User-defined symbol names can have arbitrary names. Any sequence that isn&#39;t an integer can be used as a symbol; so, for example, 12a is a valid symbol.</p>
<p>There is one namespace for functions and variables; in other words, you cannot use the same name for a function and a variable.</p>
<p>Includes a mark and sweep garbage collector. Garbage collection takes 5 msec.</p>
<h4><strong>Interfaces</strong></h4>
<p>These interfaces are brought to headers at the edge of the Lisp Badge board. The numbers in brackets refer to Arduino pin numbers:</p>
<ul>
<li>Four analogue input pins using <strong>analogread</strong>: A0 to A3 (24 to 27) plus VCC and GND.</li>
<li>Two analogue outputs using <strong>analogwrite</strong>: MISO (6), and SCK (7).</li>
<li>Digital input and output using <strong>pinmode</strong>, <strong>digitalread</strong>, and <strong>digitalwrite</strong>: MOSI (5), MISO (6), SCK (7), RX0 (8), TX0 (9), SCL (16), SDA (17), and A0 to A3 (24 to 27)</li>
<li>I2C interface using <strong>with-i2c</strong> and <strong>restart-i2c</strong>: SCL (16) and SDA (17).</li>
<li>SPI interface using <strong>with-spi</strong>: MOSI (5), MISO (6), and SCK (7).</li>
<li>Serial interface (FTDI) using <strong>with-serial</strong>: RX0 (8) and TX0 (9).</li>
</ul>
<p>The shift key can be used as a digital input: SHIFT (23).</p>
<p>SCK (7) is connected to an LED on the front panel. This is an analogue output pin, so you can vary the brightness of the LED.</p>
<p>A piezo speaker is connected to pin 4. It is used for the #\Bell character, and can be used to play tunes with the uLisp <strong>note</strong> function.</p>
<h3>Playing tunes</h3>
<p>The uLisp <strong>note</strong> functions can now be used to play tunes on the Lisp Badge piezo speaker, which is on pin 4. For example, the following function <strong>scale</strong> plays the scale of C:</p>
<pre>(defun scale () 
  (mapc 
   (lambda (n) (note 4 n 4) (delay 500))
   &#39;(0 2 4 5 7 9 11 12)) 
  (note))</pre>
<p>Thanks to Thomas Fitzsimmons for developing the modifications to the Lisp Badge that enable <strong>note</strong> to work correctly.</p>
<h3>Plotting extensions</h3>
<p>The Lisp Badge contains the following five plotting extensions, designed to allow plotting to the greyscale graphics display.</p>
<p>After generating a plot, <strong>plot</strong> and <strong>plot3d</strong> wait for the ESC key to be pressed before displaying the uLisp prompt.</p>
<h3>fill-screen <span>function</span></h3>
<p><strong>Syntax:</strong> <code>(fill-screen [<em>pixel</em>])</code></p>
<p>Clears the screen to black, or fills it with a specified pixel value.</p>
<p>For example, the following command fills the screen with 50% grey:</p>
<pre>(fill-screen #x77)</pre>
<h3>plot-pixel <span>function</span></h3>
<p><strong>Syntax:</strong> <code>(plot-pixel x y [<em>pixel</em>])</code></p>
<p>Plots a pixel to the specified x,y coordinates, where x should be 0 to 127 and y should be 0 to 63.</p>
<p>Because of the way that the display memory is mapped to the display, <strong>plot-pixel</strong> plots two adjacent pixels with an x resolution of 128. The third parameter <strong>pixel</strong> specified the colours of the two pixels; if omitted it defaults to #xFF which gives two adjacent white pixels.</p>
<p>For example, to plot a 2x1 white pixel to the top right-hand corner of the screen give the command:</p>
<pre>(plot-pixel 127 63)</pre>
<p>To plot a 1x1 grey pixel to the top right-hand corner of the screen give the command:</p>
<pre>(plot-pixel 127 63 #x07)</pre>
<h3>glyph-pixel <span>function</span></h3>
<p><strong>Syntax:</strong> <code>(glyph-pixel char x y)</code></p>
<p>Returns the pixel value from the 6x8 bitmap for character <strong>char</strong>, where x can be from 0 to 5 and y can be from 0 to 7.</p>
<p>For example, the following function prints a character pixel by pixel:</p>
<pre>(defun test (ch)
  (dotimes (y 8) 
    (dotimes (x 6)
      (princ (if (= (glyph-pixel ch x (- 7 y)) 15) #\* #\space)))
    (terpri)))</pre>
<p>Trying it out:</p>
<pre>&gt; (test #\R)
****  
*   * 
*   * 
****  
* *   
*  *  
*   * </pre>
<p>The glyph-pixel function lets you plot giant characters on the display. For example, the following demo uses <strong>glyph-pixel</strong> and <strong>plot3d</strong> to display a banner in characters four times the normal size:</p>
<pre>(defun message (x y)
  (let* ((text &#34;Hello from Lisp Badge &#34;)
         (c (+ (truncate x 24) (* 11 (truncate (- 63 y) 32))))
         (ch (char text c))
         (px (mod (truncate x 4) 6))
         (py (mod (truncate (- 63 y) 4) 8)))
    (glyph-pixel ch px (- 7 py))))</pre>
<p>Entering:</p>
<pre>(plot3d message)</pre>
<p>will plot:</p>
<p><img src="http://www.ulisp.com/pictures/3j/lisphello.jpg" alt="LispHello.jpg" width="600" height="211"/></p>
<h3>plot <span>function</span></h3>
<p><strong>Syntax:</strong> <code>(plot [<em>x-intercept y-intercept</em>] [<em>function</em>]...)</code></p>
<p>Plots up to four functions on the same graph, optionally with axes.</p>
<p>Each function should be a function of one parameter, the x coordinate, and it will be called with each value of x from 0 to 255. The function should return the y value, from 0 to 63.</p>
<p>If <em>x-intercept</em> and <em>y-intercept</em> are specified, <strong>plot3d</strong> draws axes through those intercepts.</p>
<p>For example, defining:</p>
<pre>(defun sine ()
  (let ((x 0) (y 2045))
    (lambda (n) 
      n
      (incf x (/ (* y 16) 163))
      (decf y (/ (* x 16) 163))
    (+ 32 (ash x -6)))))</pre>
<p>the following command:</p>
<pre>(plot 0 32 (sine))</pre>
<p>will plot:</p>
<p><img src="http://www.ulisp.com/pictures/3j/lispsine.jpg" alt="LispSine.jpg" width="600" height="211"/></p>
<h4 id="plot3d">Plotting multiple functions</h4>
<p>The following example plots the voltages on the analogue inputs 0 to 3 once a second on a single plot. First define:</p>
<pre>(defun adc (n) (lambda (x) (delay 250) (/ (analogread n) 8)))</pre>
<p>Then give the command:</p>
<pre>(plot 0 0 (adc 0) (adc 1) (adc 2) (adc 3))</pre>
<h3>plot3d <span>function</span></h3>
<p><strong>Syntax:</strong> <code>(plot3d [<em>x-intercept y-intercept</em>] [<em>function</em>])</code></p>
<p>The function should be a function of two parameters, the x and y coordinates, and it will be called with each value of x from 0 to 255 and y from 0 to 63. The function should return the greyscale value to be plotted, from 0 to 15.</p>
<p>If <em>x-intercept</em> and <em>y-intercept</em> are specified, <strong>plot3d</strong> draws axes through those intercepts.</p>
<p>For example, defining:</p>
<pre>(defun p (x y) 
  (let ((a (/ (- x 128) 2))
        (b (- y 32))) 
    (min (abs (- (logand (/ (+ (* a a) (* b b) (* a b)) 16) 31) 15)) 15)))</pre>
<p>the following command:</p>
<pre>(plot3d 128 32 p)</pre>
<p>will plot:</p>
<p><img src="http://www.ulisp.com/pictures/3j/lispellipses.jpg" alt="LispEllipses.jpg" width="600" height="211"/></p>
<h3>Programming peripheral registers</h3>
<p>The Version 4.1a of uLisp includes a <strong>register</strong> function that allows you to read the values of 8-bit peripheral registers, or write values to the registers. It allows you to control the peripherals in the processor from a Lisp program, or interactively experiment with the peripherals by giving commands at the uLisp prompt.</p>
<p>Here are some examples of its use on the Lisp badge.</p>
<h4>Blinking an LED</h4>
<p>For the first example we will blink the built-in LED on the Arduino Uno board by directly accessing the port it&#39;s connected to, without using the usual <strong>pinmode</strong> and <strong>digitalwrite</strong> functions.</p>
<p>The LED on the Lisp Badge is connected to bit 7 in port B, so the code is as follows:</p>
<pre>(defun blink ()
  (let ((led (ash 1 7)))
    (register :ddrb (logior (register :ddrb) led))
    (loop
     (register :portb (logior (register :portb) led))
     (delay 1000)
     (register :portb (logand (register :portb) (lognot led)))
     (delay 1000))))</pre>
<p>Run it by typing:</p>
<pre>(blink)</pre>
<p>Exit from the program by entering ~.</p>
<h4>Controlling a timer</h4>
<p>The next example programs a timer to flash an LED once a second. We will use the ATmega1284P Timer/Counter3, which fortuitously can generate waveforms on the I/O pin connected to the Lisp Badge LED. The example is essentially the same as the one described here in <a href="http://www.ulisp.com/show?3QQB#controlling-a-timer">Programming AVR registers</a>, except using Timer/Counter3 rather than Timer/Counter1.</p>
<p>Here&#39;s the code for the Lisp Badge:</p>
<pre>(defvar *tccr3a* #x90)
(defvar *tccr3b* #x91)
(defvar *ocr3al* #x98)
(defvar *ocr3ah* #x99)
(defvar *divisor* 15624)

(defun timer ()
  (register :ddrb (logior (register :ddrb) #b10000000))
  (register *tccr3a* #b00010000)
  (register *tccr3b* #b00001101)
  (register *ocr3ah* (ash *divisor* -8))
  (register *ocr3al* (logand *divisor* #xff)))</pre>
<p>Program the timer by typing:</p>
<pre>(timer)</pre>
<p>Unlike in the previous <strong>blink</strong> example, the LED will continue flashing independently of what your Lisp program is doing until you reset the processor.</p>
<p>The <strong>register</strong> function allows you to interactively experiment with the peripherals by giving commands at the uLisp prompt. For example, try the effect of changing the Timer/Counter1 prescaler to 256 with:</p>
<pre>(register *tccr3b* #b00001100)</pre>
<p>To turn off the LED evaluate:</p>
<pre>(register *tccr3a* 0)</pre>
</div></div>
  </body>
</html>
