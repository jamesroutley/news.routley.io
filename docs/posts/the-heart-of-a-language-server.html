<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rust-analyzer.github.io//blog/2023/12/26/the-heart-of-a-language-server.html">Original</a>
    <h1>The Heart of a Language Server</h1>
    
    <div id="readability-page-1" class="page"><div id="preamble">
<div>
<p>In this post, I want to expand on one curious comment from rust-analyzer code base.
You can find the comment <a href="https://github.com/rust-lang/rust-analyzer/blob/34cffbf1d75fb6b5cb6bc68a9854b20dc74f135d/crates/hir/src/semantics/source_to_def.rs#L3-L4">here</a>.</p>
<p>It describes a curious recursive algorithm that is repeated across different language-server-shaped thing:
I’ve seen it implemented for Kotlin and C#, and implemented it myself for Rust.</p>
<p>Here’s a seemingly random grab bag of IDE features:</p>
<div>
<ul>
<li>
<p>Go to definition</p>
</li>
<li>
<p>Code completion</p>
</li>
<li>
<p>Run test at the cursor</p>
</li>
<li>
<p>Extract variable</p>
</li>
</ul>
</div>
<p>What’s common among them all?
All these features are relative to the <em>current position</em> of the cursor!
The input is not only the state of the code at a given point in time, but a specific location in the source of a project, like <code>src/main.rs:90:2</code>.</p>
<p>And the first thing a language server needs to do for any of the above features is to understand what is located at the given offset, semantically speaking.
Is it an operator, like <code>+</code>?
Is it a name, like <code>foo</code>?
If it is a name, in what context a name is used --- does it <em>define</em> an entity named <code>foo</code> or does it <em>refer</em> to a pre-existing entity?
If it is a reference, then <em>what</em> entity is referenced?
What type is it?</p>
<p>The first step here is determining a node in the syntax tree which covers the offset.
This is relatively straightforward:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>fn</span> <span>node_at_offset</span><span>(</span><span>node</span><span>:</span> <span>SyntaxNode</span><span>,</span> <span>offset</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>SyntaxNode</span> <span>{</span>
    <span>assert</span><span>!</span><span>(</span><span>node</span><span>.text_range</span><span>()</span><span>.contains</span><span>(</span><span>offset</span><span>));</span>
    <span>node</span><span>.children</span><span>()</span>
        <span>.find</span><span>(|</span><span>it</span><span>|</span> <span>it</span><span>.text_range</span><span>()</span><span>.contains</span><span>(</span><span>offset</span><span>))</span>
        <span>.map</span><span>(|</span><span>it</span><span>|</span> <span>node_at_offset</span><span>(</span><span>it</span><span>,</span> <span>offset</span><span>))</span>
        <span>.unwrap_or</span><span>(</span><span>node</span><span>)</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>But the syntax tree by itself doesn’t contain enough information to drive IDE features.
Semantic analysis is required.</p>
<p>But the problem with semantic analysis is that it usually involves several layers of intermediate representations, which are only indirectly related to the syntax tree.
While the syntax tree is relatively uniform, and it is possible to implement a generic traversal like the one above,
semantic information is usually stored in a menagerie of ad-hoc data structures: trees, graphs, and plain old hash tables.</p>
<p>Traditional compilers attach source span information to semantic elements, which could look like this:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td><pre><span>struct</span> <span>Span</span> <span>{</span>
    <span>file</span><span>:</span> <span>PathBuf</span><span>,</span>
    <span>line</span><span>:</span> <span>u32</span><span>,</span>
    <span>column</span><span>:</span> <span>u32</span><span>,</span>
<span>}</span>

<span>struct</span> <span>LocalVariable</span> <span>{</span>
    <span>name</span><span>:</span> <span>InternedString</span><span>,</span>
    <span>mutability</span><span>:</span> <span>Mutability</span><span>,</span>
    <span>ty</span><span>:</span> <span>Type</span><span>,</span>
    <span>span</span><span>:</span> <span>Span</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>With line information in place, it <em>is</em> possible for a language server to find an appropriate semantic element for a given cursor position:
just iterate all semantic elements there are, and find the one with the smallest span which still contains the cursor.</p>
<p>This approach works, but has two drawbacks.</p>
<p>The <em>first</em> drawback is that it’s too slow.
To iterate over all semantic elements, an entire compilation unit must be analyzed, and that’s too slow, even if done incrementally.
The core trick of a performant language server is that it avoids any analysis unless <em>absolutely</em> necessary.
The server knows everything about the function currently on the screen, and knows almost nothing about other functions.</p>
<p>The <em>second</em> drawback is more philosophical --- using text spans <em>erases</em> information about the underlying syntax trees.
A <code>LocalVariable</code> didn’t originate from a particular <code>span</code> of text, it was created using a specific node in the concrete syntax tree.
For features like &#34;go to definition&#34;, which need to go from syntax to semantics, the approximation turns out to be good enough.
But for refactors, it is often convenient to go in the opposite direction --- from semantics to syntax.
To change a tuple enum to a record enum, a language server needs to find all usages of the enum in the semantic model, but then it needs to modify the syntax tree.
And going from a <code>Span</code> back to the <code>SyntaxNode</code> is not straightforward: different syntax nodes might have the same span!</p>
<p>For example, a <code>foo</code> is a:</p>
<div>
<ul>
<li>
<p>name token</p>
</li>
<li>
<p>a reference</p>
</li>
<li>
<p>a trivial path (<code>foo::bar</code>)</p>
</li>
<li>
<p>and a path expression</p>
</li>
</ul>
</div>
<div>
<div>
<pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre>PATH_EXPR@20..23
  PATH@20..23
    PATH_SEGMENT@20..23
      NAME_REF@20..23
        IDENT@20..23 &#34;foo&#34;
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div><div>
<h2 id="iterative-recursive-analysis"><a href="#iterative-recursive-analysis"></a>Iterative Recursive Analysis</h2>
<div>
<p>So, how can a language server map syntax nodes to corresponding semantic elements, so that the mapping is precise and can be computed lazily?</p>
<p>First, every semantic element gets a <code>source_syntax</code> method that returns the original syntax node:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>impl</span> <span>LocalVariable</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>source_syntax</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>SyntaxNode</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>The method is implemented differently for different types.
Sometimes, storing a reference to a syntax node is appropriate:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>struct</span> <span>LocalVariable</span> <span>{</span>
    <span>source_syntax</span><span>:</span> <span>SyntaxNodeId</span><span>,</span>
<span>}</span>

<span>impl</span> <span>LocalVariable</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>source_syntax</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>SyntaxNode</span> <span>{</span>
        <span>node_id_to_node</span><span>(</span><span>self</span><span>.source_syntax</span><span>)</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Alternatively, the syntax might be computed on demand.
For example, for local variables we might store a reference to the parent function, and the ordinal number of this local variable:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>struct</span> <span>LocalVariable</span> <span>{</span>
    <span>parent</span><span>:</span> <span>Function</span><span>,</span>
    <span>ordinal</span><span>:</span> <span>usize</span>
<span>}</span>

<span>impl</span> <span>LocalVariable</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>source_syntax</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>SyntaxNode</span> <span>{</span>
        <span>let</span> <span>parent_function_syntax</span> <span>=</span> <span>self</span><span>.parent</span><span>.source_syntax</span><span>()</span>
        <span>parent_function_syntax</span>
            <span>.descendants</span><span>()</span>
            <span>.filter</span><span>(|</span><span>it</span><span>|</span> <span>{</span>
                <span>it</span><span>.kind</span> <span>==</span> <span>SyntaxNodeKind</span><span>::</span><span>LocalVariable</span>
            <span>})</span>
            <span>.nth</span><span>(</span><span>self</span><span>.ordinal</span><span>)</span>
            <span>.unwrap</span><span>()</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Yet another pattern is to get this information from a side table:</p>
<div>
<div>
<pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>type SyntaxMapping = HashMap&lt;LocalVariable, SyntaxNode&gt;
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>In rust-analyzer all three approaches are used in various places.</p>
<p>This solves the problem going from a semantic element to a syntax, but what we’ve started with is the opposite: from an offset like <code>main.rs:80:20</code> we go to a <code>SyntaxNode</code>, and then we need to discover the semantic element.
The trick is to use the same solution in <em>both</em> directions:</p>
<p>To find a semantic element for a given piece of syntax:</p>
<div>
<ol>
<li>
<p>Look at the <em>parent</em> syntax node.</p>
</li>
<li>
<p>If there is no parent, then the current syntax node corresponds to an entire file, and the appropriate semantic element is the module.</p>
</li>
<li>
<p>Otherwise, <em>recursively</em> lookup semantics for the parent.</p>
</li>
<li>
<p>Among all parent’s children (our siblings), find the one whose source syntax is the node we started with</p>
</li>
</ol>
</div>
<p>Or, in pseudocode:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td><pre><span>fn</span> <span>semantics_for_syntax</span><span>(</span><span>node</span><span>:</span> <span>SyntaxNode</span><span>)</span> <span>-&gt;</span> <span>SemanticElement</span> <span>{</span>
    <span>match</span> <span>node</span><span>.parent</span><span>()</span> <span>{</span>
        <span>None</span> <span>=&gt;</span> <span>module_for_file</span><span>(</span><span>node</span><span>.source_file</span><span>),</span>
        <span>Some</span><span>(</span><span>parent</span><span>)</span> <span>=&gt;</span> <span>{</span>

            <span>// Recursive call</span>
            <span>let</span> <span>parent_semantics</span> <span>=</span> <span>semantics_for_syntax</span><span>(</span><span>parent</span><span>);</span>

            <span>for</span> <span>sibling</span> <span>in</span> <span>parent_semantics</span><span>.children</span><span>()</span> <span>{</span>
                <span>if</span> <span>sibling</span><span>.source_syntax</span><span>()</span> <span>==</span> <span>node</span> <span>{</span>
                    <span>return</span> <span>sibling</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>In this formulation, a language server needs to just enough analysis to drill down to a specific node.</p>
<p>Consider this example:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>struct</span> <span>RangeIter</span> <span>{</span>
    <span>lo</span><span>:</span> <span>u32</span><span>,</span>
    <span>hi</span><span>:</span> <span>u32</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Iterator</span> <span>for</span> <span>RangeIter</span> <span>{</span>
    <span>type</span> <span>Item</span> <span>=</span> <span>u32</span><span>;</span>

    <span>fn</span> <span>next</span><span>(</span><span>&amp;</span><span>mut</span> <span>RangeIter</span><span>)</span> <span>-&gt;</span> <span>Item</span> <span>{</span>
                            <span>//  ^ Cursor here</span>

    <span>}</span>
<span>}</span>

<span>impl</span> <span>RangeIter</span> <span>{</span>
    <span>...</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Starting from the <code>Item</code> syntax node, the language server will consider:</p>
<div>
<ul>
<li>
<p>the return type of the function <code>next</code>,</p>
</li>
<li>
<p>the function itself,</p>
</li>
<li>
<p>the <code>impl Iterator</code> block,</p>
</li>
<li>
<p>the entire file.</p>
</li>
</ul>
</div>
<p>Just enough semantic analysis will be executed to learn that a file has a struct declaration and two impl blocks, but the <em>contents</em> of the struct and the second impl block won’t be inspected at all.
That is a huge win --- typically, source files are much more wide than they are deep.</p>
<p>This recursion-and-loop structure is present in many language servers.
For rust-analyzer, see the <a href="https://github.com/rust-lang/rust-analyzer/blob/34cffbf1d75fb6b5cb6bc68a9854b20dc74f135d/crates/hir/src/semantics/source_to_def.rs#L3-L4"><code>source_to_def</code></a> module,
with many functions that convert syntax (<code>ast::</code> types) to semantics (unqualified types).</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>fn</span> <span>type_alias_to_def</span><span>(</span>
    <span>&amp;</span><span>mut</span> <span>self</span><span>,</span>
    <span>src</span><span>:</span> <span>InFile</span><span>&lt;</span><span>ast</span><span>::</span><span>TypeAlias</span><span>&gt;</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>TypeAliasId</span><span>&gt;</span> <span>{</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>For Roslyn, one entry point to the machinery is <a href="https://github.com/dotnet/roslyn/blob/36a0c338d6621cc5fe34b79d414074a95a6a489c/src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs#L1403-L1429"><code>GetDeclaredType</code></a> function.
<code>BaseTypeDeclarationSyntax</code> is, well, syntax, while the return type <code>NamedTypeSymbol</code> is the semantic info.
First, Roslyn looks up semantic info for syntactic parent, using <a href="https://github.com/dotnet/roslyn/blob/36a0c338d6621cc5fe34b79d414074a95a6a489c/src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs#L1423"><code>GetDeclaredTypeMemberContainer</code></a>.
Then, in <a href="https://github.com/dotnet/roslyn/blob/36a0c338d6621cc5fe34b79d414074a95a6a489c/src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs#L1783"><code>GetDeclaredMember</code></a> it iterates semantic siblings and finds the one with the matching text range.</p>
<p>For Kotlin, the entry is <a href="https://github.com/JetBrains/kotlin/blob/a288b8b00e4754a1872b164999c6d3f3b8c8994a/idea/idea-frontend-fir/idea-fir-low-level-api/src/org/jetbrains/kotlin/idea/fir/low/level/api/FirModuleResolveStateImpl.kt#L93-L125"><code>findSourceFirDeclarationByExpression</code></a>.
This function starts with a syntax node (<code>KtExpression</code> is syntax, like all <code>Kt</code> nodes), and returns a declaration.
It uses <code>getNonLocalContainingOrThisDeclaration</code> to get syntactic container for a current node.
Then, <code>findSourceNonLocalFirDeclaration</code> gets <code>Fir</code> for this parent.
Finally, <code>findElementIn</code> function traverses <code>Fir</code> children to find one with the same source we originally started with.</p>
</div>
</div><div>
<h2 id="limitations"><a href="#limitations"></a>Limitations</h2>
<div>
<p>There are two properties of the underlying languages which make this approach work:</p>
<div>
<ol>
<li>
<p>Syntactic nesting must match semantic nesting.
Looking at parent’s sibling makes sense only if the current element should be among the siblings.</p>
</li>
<li>
<p>Getting sematic element for an entire file is trivial.</p>
</li>
</ol>
</div>
<p>The second one is actually less true in Rust than it is in Kotlin or C#!
In those languages, each file starts with a package declaration, which immediately mounts the file at the appropriate place in the semantic model.</p>
<p>For Rust, a file <code>foo.rs</code> only exists semantically if some parent file includes it via <code>mod foo;</code> declaration!
And, in general, it’s impossible to locate the parent file automatically.
<em>Usually</em>, for <code>src/bar/foo.rs</code> the parent would be <code>src/bar.rs</code>, but, due to <code>#[path]</code> attributes which override this default, this might not be true.
So rust-analyzer has to be less lazy than ideal here --- on every change, it reconstructs the entire module tree for a crate looking at every file, even if only a single file is currently visible.</p>
<p>Here’s another interesting example:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>mod</span> <span>ast</span> <span>{</span>
    <span>generate_ast_from_grammar!</span><span>(</span><span>&#34;FooLang.grm&#34;</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Here, we have a hypothetical procedural macro, which reads a grammar definition from an external file, and presumably generates a bunch of Rust types for the AST described by the grammar.
One could dream of an IDE where, without knowing anything specific about <code>.grammar</code>, it can still find usages of AST nodes defined therein, using the span information from the procedural macro.
This works in theory: when the macro creates Rust token trees, it can manufacture spans that point inside <code>FooLang.grm</code>, which connects Rust source with the grammar.</p>
<p>Where this breaks down is laziness.
When a user invokes &#34;find usages&#34; inside <code>FooLang.grm</code>, the IDE has no way of knowing, up-front, that the <code>generate_ast_from_grammar!(&#34;FooLang.grm&#34;)</code> macro call needs to be expanded.
The only way this could work if the IDE conservatively expands all macros all the time.</p>
</div>
</div></div>
  </body>
</html>
