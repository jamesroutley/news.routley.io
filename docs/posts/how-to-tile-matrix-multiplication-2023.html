<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alvinwan.com/how-to-tile-matrix-multiplication/">Original</a>
    <h1>How to tile matrix multiplication (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <section>
                <header>
                    <a href="https://alvinwan.com">
                        <svg width="52" height="27" viewBox="0 0 52 27" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M32.8611 0.701299L24.9167 0.701299V0L32.8611 1.76849e-07V0.701299Z" fill="black"></path>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M15.8889 0.701299L7.94445 0.701299V0L15.8889 1.76849e-07L15.8889 0.701299Z" fill="black"></path>
                            <path d="M14.8331 0.0677783L8.40305 0.0677781L21.1742 26.8241L24.5557 19.9792L14.8331 0.0677783Z" fill="black"></path>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M42.2078 19.0996L40.0411 23.0605L39.4033 22.7315L41.57 18.7706L42.2078 19.0996Z" fill="black"></path>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M6.09902 16.9913L4.00465 20.9522L3.36217 20.6319L5.45654 16.671L6.09902 16.9913Z" fill="black"></path>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M48.4948 6.92404L46.5446 10.6774L45.8998 10.3615L47.85 6.60815L48.4948 6.92404Z" fill="black"></path>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M25.2332 19.1038L22.9943 23.0647L22.3611 22.7272L24.6001 18.7663L25.2332 19.1038Z" fill="black"></path>
                            <path d="M31.7078 0.0677717L25.2778 0.0677721L38.049 26.8241L41.5277 20.1987L31.7078 0.0677717Z" fill="black"></path>
                            <path d="M5.18547 17.1818L10.8333 27H0L5.18547 17.1818Z" fill="black"></path>
                            <path d="M46.8145 10.1688L41.1667 0.350647L52 0.350648L46.8145 10.1688Z" fill="black"></path>
                        </svg>
                    </a>
                    <nav>
                        <ul>
                            <!-- <li><a href="/projects"><span>projects</span></a></li> -->
                            <li><a href="https://alvinwan.com/guides"><span>Guides</span></a></li>
                            <li><a href="https://alvinwan.com/blog"><span>blog</span></a></li>
                        </ul>
                    </nav>
                </header>
                <div id="post-body">
                    <p><i>from</i> <a href="https://alvinwan.com/ml">Guide to Machine Learning</a> <i>on Apr 30, 2023</i></p>
                    
<p><em>Matrix multiplication is a staple of deep learning and a well-studied, well-optimized operation. One of the most common optimizations for matrix multiplication is called &#34;tiling,&#34; but as common and important as it is, it&#39;s a bit confusing to understand.</em></p>

<p>Tiling matrix multiplication is a valuable technique that optimizes resource utilization in multiple dimensions, including power, memory, and compute. Critically, tiling then reduces overall latency, making this vital for models heavily reliant on dense matrix multiplication. </p>
<p>One such example is transformers and their associated Large Language Models; their heavy reliance on dense matrix multiplies for inference makes tiling an important concept to understand — and to leverage.</p>

<p>In this post, we&#39;ll break down how tiling for matrix multiplication works, again by conveying intuition primarily through illustrations.</p>
<h2 id="how-does-tiling-work"><a href="#how-does-tiling-work"><i></i>How does tiling work?</a></h2>
<p>I&#39;ll start with a description of how to tile a single matrix multiply. Here we only cover the most salient parts at a high level.</p>
<p>Let&#39;s multiply two matrices $A$ and $B$ normally. To do so, we take the inner product of all the rows in $A$ and the columns in $B$. We illustrate this below.</p>

<p>Here&#39;s what that process looks like in more detail:</p>
<ol>
<li>Fetch the first row $A_{0,:}$ (8 fetches).</li>
<li>Fetch the first column $B_{:,0}$ (8 fetches).</li>
<li>Take the inner product to get one value in our output $O_{0,0}$. Repeat this for all 64 output values.</li>
</ol>
<p>For each of the 64 values in our output, we need to fetch a total of 16 values: 8 values from $A$ and 8 values from $B$. This means we need $64 \times 16 = 1024$ total fetches.</p>
<p>For our first step, we can simply reuse the first row of $A$. This is pictured below, where we fetch one row of $A$ to compute the entire first row of output.</p>

<p>Here&#39;s that process in more detail:</p>
<ol>
<li>Fetch row $A_{0,:}$ (8 fetches) and column $B_{:,0}$ (8 fetches).</li>
<li>Compute inner product for $A_{0,:}$ and $B_{:,0}$ to get $O_{0,0}$ like before.</li>
<li>Now, reuse $A_{0,:}$ from before (0 fetches). Fetch the next column $B_{:,1}$ (8 fetches).</li>
<li>Compute inner product for $A_{0,:}$ and $B_{:,1}$ to get $O_{0,1}$.</li>
<li>Repeat this for all $B_{:,c}$ columns to get the first of outputs $O_{0,:}$. Repeat this for all rows $A_{r,:}$.</li>
</ol>

<p>For the example above, </p>
<ul>
<li>Each row now costs a total of $16 + 8(7) = 72$ fetches: 16 fetches for the first value, and 8 for all the subsequent ones.</li>
<li>The whole matrix multiply requires $72 \times 8 = 576$ fetches, nearly halving the number of fetches needed.</li>
</ul>
<p>However, notice that each column from $B$ is only used to generate 1 output. This makes our fetches relatively inefficient.</p>
<p>For our next step, change the order we generate output values in. Instead of generating the first row, we generate values in the top-left quadrant.</p>

<p>Now, each row in $A$ is used to generate 4 outputs, and every column in $B$ is used to generate 4 outputs. This once again lowers the number of fetches we need:</p>
<ul>
<li>Now, every block of 4x4 values requires only 4 rows and 4 columns, which is $(4 + 4) \times 8 = 64$ fetches.</li>
<li>The output contains 4 of such 4x4 blocks, so we need a total of $64 \times 4 = 256$ fetches.</li>
</ul>

<p>This completes our matrix multiplication! To summarize:</p>
<ol>
<li>We started with </li>
<li>Reusing rows from $A$ reduced that cost to 576 fetches.</li>
<li>Generating outputs by block instead of by row reduced the cost to 256 fetches.</li>
</ol>
<p>That&#39;s a reduction of 4x, from 1024 to 256 fetches — a much more efficient matrix multiply.</p>
<h2 id="how-effective-is-tiling"><a href="#how-effective-is-tiling"><i></i>How effective is tiling?</a></h2>
<p>Above, we noted that tiled matrix multiplication reduced memory accesses by 4x, with a block size of 4x4 — from 1024 to 256 fetches. We <em>also</em> noted previously that we reduce memory accesses by 2x, with a block size of 2x2 — from 1024 to 512 fetches.</p>
<p>Notice the pattern? For every block size $b \times b$, we reduce the number of fetches by $b$. Here&#39;s the intuition: In the original matrix multiplication, every row and column vector is used to generate only one output value, every time it is fetched. In the tiled matrix multiplication, every row and column vector is used to generate $b$ output values, every time it is fetched. This is why we reduce the number of total number of fetches by $b$, intuitively.</p>
<p>To make this more concrete, let&#39;s count the number of fetches with general matrix dimensions. Say $A \in \mathbb{R}^{m \times k}, B \in \mathbb{R}^{k \times n}$. Then,</p>
<ol>
<li>Our original matrix multiplication costs $k + k$ fetches for every one of the $mn$ outputs. This makes $2mnk$ fetches.</li>
<li>Say our block size is $b$. Our tiled matrix multiplication uses $b$ rows of $k$ values each and $b$ columns of $k$ values each. That makes $2bk$ fetches for each $b \times b$ block, where there are $(\frac{m}{b})(\frac{n}{b}) = \frac{mn}{b^2}$ total blocks. This makes $2bk\frac{mn}{b^2} = \frac{2mnk}{b}$ fetches.</li>
</ol>
<p>Notice this cost for tiled matrix multiplication is exactly the original matrix multiply&#39;s cost $2mnk$ divided by $b$, proving what we had empirically noticed above. <strong>A block size of</strong> $b$ <strong>will reduce the total number of memory accesses by</strong> $b$. The bigger the block, the better.</p>
<h2 id="why-tiling-is-so-fast"><a href="#why-tiling-is-so-fast"><i></i>Why &#34;tiling&#34; is so fast</a></h2>
<p>Tiling leverages several principles to make matrix multiplication run really fast:</p>
<ol>
<li><strong>Parallelization</strong>: We can calculate the results of each output block independently, so if there are 4 blocks like in our example, we can run 4 threads concurrently.</li>
<li><strong>Better memory management</strong>: We saw a small snippet of this above — tiling matrix multiplication reduces the number of memory accesses. As we&#39;ll see below, there are more than one ways tiling actually improves speed, however.</li>
</ol>
<p>Before diving into auxiliary benefits for tiling, let&#39;s understand why memory fetches are so important for latency:</p>
<ul>
<li>A V100 features 900 GB/s memory bandwidth and 112 tFLOPs<sup id="fnref:3"><a href="#fn:3">2</a></sup> compute bandwidth.</li>
<li>Say we have 100 4096x4096 matrices stored in half-precision (a.k.a., 2 bytes per value)<sup id="fnref:4"><a href="#fn:4">3</a></sup>. That&#39;s a total of $100 \times 4096 \times 4096 \times 2 = 3.4 \times 10^9$ or 3.4 GB of weights, which takes $3.4 / 900 = 3.8 \times 10^{-3}$ or 3.8ms to move.</li>
<li>By contrast, even the naive matrix multiplication would only take $2mnk = 2\times4096^3 = 137 \times 10^9$ or 137 gFLOPs; that takes $137 / 112,000 = 1.2 \times 10^{-3}$ or 1.2ms to compute.</li>
</ul>
<p>So, 3.8ms to <em>move</em> the weights and 1.2ms to actually <em>compute</em> using the weights. Knowing this, memory bandwidth is the bottleneck<sup id="fnref:5"><a href="#fn:5">4</a></sup>.</p>
<p>Now, here&#39;s how tiling a matrix multiplication helps. If we use a block size of 4, we could reduce the number of memory accesses by 4x, reducing the time spent on <em>moving</em> weights from 3.8ms to 0.95ms. With that said, we can now also parallelize computation across blocks, so time spent computing would also decrease.</p>
<p>We can continue to increase the block size arbitrarily to keep reducing latency. However, you might then wonder: What stops us from increasing the block size indefinitely? This is where memory constraints come in.</p>
<h2 id="why-theres-a-limit-to-tiling"><a href="#why-theres-a-limit-to-tiling"><i></i>Why there&#39;s a limit to tiling</a></h2>
<p>In short, your hardware may not be able to store all the weights you need in memory.</p>
<p>For example, let&#39;s say you&#39;re operating on the same 4096x4096 matrices from before, now with output block size 8x8. To compute a single output block, we need 8 rows of 4096 values and 8 columns of 4096 values. Altogether, this is $(4096 \times 8 + 4096 \times 8) \times 2 = 131072$ or 131KB of data. Unfortunately, the V100 only has 96 KB of shared memory at maximum<sup id="fnref:6"><a href="#fn:6">5</a></sup>. We now have two options:</p>
<ol>
<li>We can reduce the output block size from 8x8 to 4x4. This requires just $(4096 \times 4 + 4096 \times 4) \times 2 = 65536$ or 66KB, which fits in shared memory. However, this increases the number of memory accesses by 2x.</li>
<li>We can take the loss, accepting that our fetched values don&#39;t fit in 96 KB shared memory and will now sit in the 6MB L2 cache. However, L2 cache load speed is 2 TB/s, which is 6x slower than shared memory load speed at 13 TB/s<sup id="fnref:7"><a href="#fn:7">6</a></sup>.</li>
</ol>
<p>Neither option is very desirable, so in effect, shared memory size limits our output block size. Fortunately, we have one more trick.</p>
<h2 id="how-to-sidestep-tiling-limits"><a href="#how-to-sidestep-tiling-limits"><i></i>How to sidestep tiling limits</a></h2>
<p>Let&#39;s consider the limits that shared memory imposes. Let&#39;s go back to our original example with 4x4 output blocks, for an 8x8 matrix. Here&#39;s a visual representation of our tiled matrix multiplication, which we introduced before.</p>

<p>Notice we need to simultaneously hold values from several matrices in shared memory: 32 values from $A$, 32 values from $B$ and 16 values of the output $O$. If all our values are in FP16, this is $(32 + 32 + 16) \times 2 = 160B$. This isn&#39;t bad at all, but let&#39;s say that our shared memory can only hold a little more than half as much — just 96B.</p>
<p>To accommodate this stricter memory constraint, we can fetch only <em>part</em> of a row and only <em>part</em> of a column.</p>
<ol>
<li>Fetch only the <em>first half</em> of each row and column. This gives us 4x4 subsets of $A$ and $B$. Take the matrix product to obtain a 4x4 output $O$. However, we haven&#39;t yet fully computed the outputs.</li>
<li>Fetch the <em>second</em> half of each row and column, which are again 4x4 subsets of $A$ and $B$. Take the matrix product to obtain a 4x4 output $O$. Add these 4x4 outputs to the 4x4 outputs from the previous step.</li>
</ol>
<p>Here is the process visualized.</p>

<p>Here&#39;s the process in more detail.</p>
<ol>
<li>Fetch the top-left quadrant for both matrices, $A_{:4,:4}$ and $B_{:4,:4}$. There are only 32 values used for computation, which is 64B.</li>
<li>Perform a naive matrix multiply on this pair of 4x4 matrices to obtain a 4x4 output, which we store in $O_{:4,:4}$. this is 16 values or 32B of outputs. Notice at this point that although each output value is filled, it isn&#39;t &#34;complete&#34;. For example, if we look at the top-left output, its value is $A_{0,0}B_{0,0} + A_{0,1}B_{1,0} + A_{0,2}B_{2,0} + A_{0,3}B_{3,0}$. In other words, it&#39;s missing &#34;half&#34; of its value, which is $A_{0,4}B_{4,0} + A_{0,5}B_{5,0} + A_{0,6}B_{6,0} + A_{0,7}B_{7,0}$. We compute this other &#34;half&#34; next.</li>
<li>Fetch the top-right quadrant for our first matrix $A_{:4,4:}$ and the bottom-left quadrant for our second matrix $B_{4:,:4}$. There are again only 32 values used for computation, which is 64B.</li>
<li>Perform a naive matrix multiply on this pair of 4x4 matrices to obtain a 4x4 output, which we <em>accumulate</em> in the <em>same</em> block of output, $O_{:4,:4}$. <em>Now</em>, that block of output is complete.</li>
</ol>
<p>Notice that at any point, we used only at maximum 96B, 32 input values taking 64B and 16 output values taking 32B. This satisfies our constraint for fitting into shared memory. We can continue to repeat this process for all blocks in the output to complete our matrix multiplication.</p>

<p>In short, <em>reading</em> block by block allowed us to compute with fewer inputs, meaning lower memory requirements, while still preserving the same number of fetches. In summary:</p>
<ol>
<li>We started with requiring 160B of shared memory, storing 64 total input values and 16 total output values, and 16 writes.</li>
<li>By blocking the input, we require just 96B of shared memory, storing only 32 total input values and 16 output values at any given time, but use 32 writes.</li>
</ol>
<p>More generally, if we again assume $A \in \mathbb{R}^{m \times k}, B \in \mathbb{R}^{k \times n}$. Then,</p>
<ol>
<li>We started with $b$ rows of $k$ values and $b$ columns of $k$ values, making $2bk$ input values. We also stored $b^2$ outputs. This is $b(2k + b)$ values or $2b(2k + b)$ total bytes, assuming half-precision.</li>
<li>If we block the input into chunks of $b \times \ell$, then we have $2b\ell$ input values and still $b^2$ outputs. This is $b(2\ell + b)$ values or $2b(2\ell + b)$ bytes.</li>
</ol>
<p>Notice the only difference is we exchanged $k$ for $\ell$ in our memory consumption.</p>
<p>We have another natural question then: Why not make use smaller and smaller input block sizes indefinitely? The only limitation is the number of writes. Namely, with block size $b \times \ell$, you incur $\frac{k}{\ell}$ writes.</p>
<h2 id="conclusion"><a href="#conclusion"><i></i>Conclusion</a></h2>
<p>There are several moving pieces here for actually configuring and using tiling in practice; we mentioned these factors above:</p>
<ol>
<li><strong>Memory subsystems</strong>: There are several memory subsystems, each level gets larger but slower. On a V100, we have 96KB of shared memory with load speed of 13TB/s, 6MB L2 cache at 2.2TB/s, 32GB of global memory<sup id="fnref:9"><a href="#fn:9">8</a></sup> at 900GB/s or 1 TB of CPU RAM<sup id="fnref:8"><a href="#fn:8">7</a></sup> at 94GB/s. Each level gets 6-10x slower but also 60-5000x larger in size.</li>
<li><strong>Block sizes</strong>: In theory, our input matrices $A$ and $B$ sit in global memory to start, which is relatively slow to read from. As a result, since the output block size linearly decreases the number of memory accesses, we want large output block sizes. Simultaneously, to accommodate memory constraints (ideally to fit our block into shared memory), we want small input block sizes. Note that smaller input block sizes will incur more writes.</li>
</ol>
<p>There are also several values we computed, related to tile matrix multiplies. Let $A \in \mathbb{R}^{m \times k}, B \in \mathbb{R}^{k \times n}$:</p>
<ul>
<li>Naive matrix multiplication requires $2mnk$ memory accesses, but tiled matrix multiplies require $\frac{2mnk}{b}$ memory accesses, for output block size $b$.</li>
<li>Total memory consumption for the baseline tiled matrix multiplication would be $2b(2k + b)$ bytes for half-precision. If you tile the inputs into blocks of $b \times \ell$, then memory consumption is $2b(2\ell + b)$.</li>
</ul>
<p>This leads us to our final takeaway: <strong>Tiling matrix multiplications reduces memory accesses and memory usage by blocking outputs and inputs respectively; this ultimately results latency overall for a memory-bandwidth limited operation.</strong></p>
<p>This concludes our discussion on tiling matrix multiplies. To generalize to more matrix multiplies, see <a href="https://alvinwan.com/when-to-tile-two-matrix-multiplies">When to tile two matrix multiplies</a>.</p>
<p>To see an implementation of tiling in action, see <a href="https://triton-lang.org/main/getting-started/tutorials/03-matrix-multiplication.html">Triton&#39;s matrix multiplication</a> tutorial, where you&#39;ll build a custom CUDA kernel from the comfort of Python. There are also many other <a href="https://penny-xu.github.io/blog/tiled-matrix-multiplication">well-written</a> <a href="https://learn.microsoft.com/en-us/cpp/parallel/amp/walkthrough-matrix-multiplication">resources</a> <a href="https://lumetta.web.engr.illinois.edu/408-S19/slide-copies/ece408-lecture5-S19-ZJUI.pdf">on this topic</a>, if you&#39;d like to explore alternative explanations.</p>

                    
                    
                    
                    
                    
                    
                    <p><a href="https://alvinwan.com/ml">← <i>back to</i> Guide to Machine Learning</a></p>
                    </div>
            </section>
            
        </div></div>
  </body>
</html>
