<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frontendmastery.com/posts/the-evolution-of-scalable-css/">Original</a>
    <h1>The Evolution of Scalable CSS</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
          <h2 id="introduction">Introduction</h2><p>How we write and think about CSS has changed significantly since the web’s beginning.</p><p>We’ve come a long way from table-based layouts, to responsive web design, and now into a new era of adaptive layouts powered by modern CSS features.</p><p>Managing and organizing CSS has always been challenging, where consensus is hard to find.</p><p>In this post, we’ll develop a deeper understanding of CSS by diving into the underlying issues that make it difficult to scale.</p><p>We’ll understand the evolution of the various CSS best practices that have emerged and changed over time.</p><p>By the end, we’ll have a good grasp on past approaches to scaling CSS on large projects, and how popular tools like Tailwind and a range of others address these issues in counter-intuitive ways.</p><h2 id="the-time-before-css">The time before CSS</h2><p>In the very beginning, the web only had HTML. We wrote it in all caps, and we styled pages using properties directly on markup:</p><pre><code><span><span>  &lt;</span><span>BODY</span><span>&gt;</span></span>
<span><span>    &lt;</span><span>P</span><span> </span><span>SIZE</span><span>=</span><span>&#34;8&#34;</span><span> </span><span>COLOR</span><span>=</span><span>&#34;RED&#34;</span><span>&gt;LOUD NOISES&lt;/</span><span>P</span><span>&gt;</span></span>
<span><span>  &lt;/</span><span>BODY</span><span>&gt;</span></span></code></pre><p>These were dark times for those wanting stylish pages.</p><p>Besides the limited number of styles available, a clear limitation was all the duplication needed.</p><p>A quintessential example of the web around this time was the good old <a href="https://www.spacejam.com/1996/">Space Jam</a> website.</p><p>Now some might be thinking “that looks like the props I pass into my component library.” As we’ll see later, things often come full circle with a twist in the cycle of innovation.</p><h2 id="stylesheets-and-separation-of-concerns">Stylesheets and separation of concerns</h2><p>CSS entered the game, and like many innovations born from previous pain points, we could now remove all that duplication.</p><p>Stylesheets enabled us to style pages declaratively, affecting vast swaths of elements with very little code:</p><pre><code><span><span>p</span><span> {</span></span>
<span><span>  </span><span>color</span><span>: </span><span>red</span><span>;</span></span>
<span><span>}</span></span></code></pre><p>We could now think about the structure of our content and its visual appearance and layout separately. Moving layout concerns from HTML using tables into CSS instead.</p><p>CSS was minimal initially, heavily inspired by physical desktop publishing, with terms like “float” that supported formatting columns of text.</p><p>As time progressed, we started collecting examples on a site called <a href="http://www.csszengarden.com/">CSS Zen Garden</a>.</p><p>CSS Zen garden became a hub for showing how people could use CSS creatively. People could submit CSS files that re-styled the same HTML in interesting and unique ways.</p><p>This was very influential in spreading the idea of <strong>separating content from its styling</strong>, re-stylable HTML, and thinking about applying themable “skins” to a core skeleton.</p><h3 id="figuring-out-best-practices">Figuring out best practices</h3><p>We started building more complex sites and applications, putting new demands on CSS to evolve.</p><p>Any new technology often takes a few cycles of different approaches before best practices emerge.</p><p>We saw tools like <a href="https://lesscss.org/">Less</a> and <a href="https://sass-lang.com/">Sass</a> pop up that extended native CSS capabilities. Giving us things like variables and calc functions, greatly improving the developer experience.</p><p>As we spent more time in these stylesheets, we sought ways to organize all these rules and selectors.</p><p>Many different patterns for scaling CSS cropped up. These tried to strike a balance between maintenance, performance, and readability and are called “CSS architectures”.</p><p>Before we dive into these architectures, let’s first understand why managing CSS on large-scale projects gets complicated quickly.</p><h2 id="why-css-hard-to-manage-at-scale">Why CSS hard to manage at scale</h2><p>“At scale” refers to the intersection of multiple things, including people, tools, processes, and performance.</p><p>Scaling effectively requires us to carefully manage the growth of complexity. So as the system grows, it’s still understandable, changeable, and performant. Where the cost of adding new code remains as low as possible, and people are confident changing and deleting old code.</p><p>The cascade (the C in CSS) originates from the web’s early days.
Browsers could apply default styles to these new electronic documents. Document authors could then provide their own styles, which could be overridden by individual user preferences.</p><p>This image of cascading rules is central to understanding CSS. The same properties that make CSS powerful also make it hard to achieve those scaling properties in large projects. In particular, its <strong>global namespace</strong>, <strong>cascading rules</strong>, and <strong>selector specificity</strong>.</p><h3 id="the-global-namespace">The global namespace</h3><p>The global CSS namespace can be powerful if leveraged carefully. But on large projects, it’s often a curse.</p><p>When everything is global, anything can unexpectedly affect something else. Either now or sometime in the future when things change.</p><p>This becomes problematic pretty quickly. There are reasons we don’t put everything in a global namespace in other languages. As more code gets added, things become way less predictable and challenging to maintain.</p><p>It’s worth noting that <a href="https://www.smashingmagazine.com/2022/01/introduction-css-cascade-layers/">CSS cascade layers</a> is an up-and-coming feature that can help address this problem natively.</p><h3 id="naming-things-is-hard">Naming things is hard</h3><p>Creating a series of semantic class names often feels like a chore without much benefit when iterating quickly with CSS.</p><p>Coming up with useful names is hard because we’re attempting to compress a bunch of info into a precise label. Getting this right becomes even more important when everything is global.</p><p>Naming things too early is a form of premature abstraction. Because often the things we’re naming still need to be fully formed and are not yet reusable.</p><p>Design changes are common in the frontend, and these labels regularly become outdated and require refactoring of both styles and markup.</p><h3 id="refactoring-css-is-hard">Refactoring CSS is hard</h3><p>Both design and modern software development are highly iterative. We often only start to develop a clear picture after a few iterations have stacked up.</p><p>This requires us to regularly re-evaluate our understanding of the problem we’re solving. In code, this means refactoring as our understanding changes and solidifies.</p><p>Refactoring can be challenging, but it’s a tried and true method for arriving at good abstractions over time based on actual requirements rather than theory.</p><p>In CSS it’s pretty hard. Without solid visual regression testing, many CSS failures are “silent,” where it’s easy to create unforeseen bugs and side effects. This leads to a couple of common scenarios.</p><ol>
<li>
<p><strong>Append only stylesheets</strong></p>
<p>Projects start with stylesheets that feel manageable. But it’s common for new code to get stuck on the end of files after a few iterations and bug fixes later.</p>
<p>Knowing when we can safely change or delete a rule is hard. So we override what came before in the cascade at the end of the file.</p>
<p>This is the cause of <strong>specificity battles</strong>. We’ve all probably had the experience of needing to override some other styles. It’s an easy road into the dark arts, where <code>!important</code>’s start cropping up, deepening the maintenance burden.</p>
</li>
<li>
<p><strong>Dead code</strong></p>
<p>In practice, we often use the same CSS properties repeatedly. It’s usually much safer to continually duplicate rules, rather than take on the risk of refactoring large amounts of CSS in a global namespace.</p>
<p>This often leads to a lot of unused CSS that’s hard to know if something is relying on it. Which ends up bloating CSS spread out over various files.</p>
</li>
</ol><h3 id="debugging-css-is-hard">Debugging CSS is hard</h3><p>A big part of debugging is simulating what the computer does in our heads.</p><p>Debugging is hard with complex CSS because we’re mentally computing the cascade and calculating the final rules while considering source order.</p><p>Particularly with CSS’s many nuances around positioning, alignment, stacking contexts, margins, and height. Without a systematic approach, a common CSS debugging workflow often involves tweaking some values to see what happens. Refreshing the page, and absolutely nothing has changed. Or something has completely broken.</p><p>This is particularly challenging when working with code you don’t control or browser-specific bugs.</p><h2 id="taming-complexity-with-css-architectures">Taming complexity with CSS architectures</h2><p>CSS has a simple model, but it’s easy for things to get messy quickly. We eventually started looking to apply software engineering principles to help us manage.</p><p>These architectures are more like high-level blueprints for organizing CSS files and their rules and selectors.</p><p>Let’s get a quick overview of some of the more influential and popular CSS architectures and their main ideas.</p><h3 id="oocss-object-orientated-css">OOCSS: Object Orientated CSS</h3><p>OOCSS distinguished the different types of CSS we write in practice. CSS that does layout, and CSS that themes or “skins” HTML, like colors, fonts, etc.</p><p>An “object” in OOCSS is a <a href="http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/">repeating visual pattern</a> that can be abstracted and reused. The idea is to identify common visual patterns and extract duplicated code blocks into reusable classes.</p><p>One of the most widely used CSS frameworks that leverage these ideas is <a href="https://getbootstrap.com/">Bootstrap</a>.</p><h3 id="smacss-scalable-and-modular-css">SMACSS: Scalable and Modular CSS</h3><p>In practice, large single-file CSS files quickly become unmanageable and hard to debug.</p><p>SMCASS was a guide to categorizing the different types of CSS and was compatible with approaches like OOCSS.</p><p>The main idea was to take all these class names, and organize them into separate buckets, and provide some much-needed <a href="http://smacss.com/book/categorizing">structure to our CSS files</a>. In addition to some conventions around naming classes.</p><h3 id="bem-block-element-modifier">BEM: Block, Element, Modifier</h3><p>BEM is a model for how to think about breaking things down into components, their sub-elements, and their various discrete states.</p><p>Originally <a href="https://en.bem.info/methodology/history/">created at Yandex</a>, it provides a systematic naming convention that avoids specificity battles by keeping all selectors flat (no descendant selectors), where every element that gets styled, gets its own class name.</p><p>BEM gelled well with popular CSS pre-processors like Sass with nested rules that would compile down to flat CSS selectors:</p><pre><code><span><span>.nav {</span></span>
<span><span>  // block styles</span></span>
<span><span>	&amp;__link {</span></span>
<span><span>    // element styles that depend on the parent block</span></span>
<span><span>		&amp;--active {</span></span>
<span><span>          // modifer styles</span></span>
<span><span>		}</span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre><h3 id="itcss-inverted-triangle">ITCSS: Inverted Triangle</h3><p>One of the main ideas behind ITCSS is thinking about our style sheets through the lens of layering to help tame the cascade.</p><p>ITCSS is a like “meta-framework” for CSS, compatible with other systems.</p><p>The idea is to tame the chaos of everything overriding each other unpredictably by providing explicit layers of increasing specificity.</p><p>“Inverted triangle” comes from each progressive layer forming an inverted pyramid shape.</p><p>It’s an influential methodology for managing CSS files on large-scale projects. To dive deeper, you can check out <a href="https://www.youtube.com/watch?v=1OKZOV-iLj4&amp;ab_channel=DaFED">a talk given by its creator</a>.</p><h3 id="cube-css">Cube CSS</h3><p>Cube CSS works with the global namespace and cascade rather than trying to work around it.</p><p>Cube CSS provides a set of well-defined buckets that categorize CSS. These form the cube acronym: Composition, Utility, Block, Exception.</p><p>The docs do a great job <a href="https://cube.fyi/principles.html#progressive-enhancement">explaining the principles</a>. It’s a loose methodology that is like a mental model for organizing CSS.</p><p>Similar to ITCSS, it’s an influential “meta CSS framework”, compatible with various approaches.</p><h2 id="rethinking-separation-of-concerns">Rethinking separation of concerns</h2><p>With the rise of SPAs and <a href="https://www.componentdriven.org/">component-driven development</a> we started seeing new approaches to CSS.</p><p>In this world, managing CSS became even harder, because components now load asynchronously, with no guarantees on source order.</p><p>A common issue is when some element on the page looks different when doing an SPA transition from page A to B, but looks fine if you directly load to B. Leading to some interesting debugging sessions.</p><p>We started looking for more concrete solutions to managing CSS that gelled with this new component-centric approach to structuring our frontends.</p><p>These tools often broke many of the established best practices we had been building up and thinking about so far. Let’s understand them.</p><h3 id="inline-styles">Inline styles</h3><p>The shift to component-based frameworks often saw styles applied inline inside components. In frameworks like React, we pass a Javascript object to the <code>style</code> prop, converting it to inline styles.</p><p>This causes a visceral reaction for many because it’s like we’re going back to the very start when we didn’t have external stylesheets, throwing away existing best practices.</p><p>In the context of components, inline styles don’t face the original problem of massive duplication because it’s encapsulated inside the component. The fact that styles only affect the element they’re on is a nice way to add and modify CSS safely in components.</p><p>The main problem with inline styles is the lack of access to more powerful CSS features, like pseudo selectors and media queries. In addition to the difficulty of leveraging shared design tokens, caching, static analysis, and pre-processing.</p><h3 id="css-in-js">CSS in JS</h3><p>In the early days of React, <a href="https://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html">Veujx gave a talk</a> on Facebook’s approach to CSS. On the surface, this looked a lot like inline styles but with access to the power of stylesheets.</p><p>This talk led to a proliferation of open-source libraries that took a Javascript-driven approach to CSS.</p><p><strong>The first wave of CSS in JS</strong> libraries became popular with libraries like <a href="https://styled-components.com/">Styled Components</a>, <a href="https://emotion.sh/docs/introduction">Emotion</a>, and a whole range of others in the React ecosystem.</p><p>These solved most of the problems vanilla CSS had on large projects using components, making working with dynamic values from JS incredibly easy.</p><p>The problem was the performance tax end users were paying. There were server-side rendering inefficiencies, issues around caching, and client runtime costs.</p><p>This exacerbated slow app start-up times, requiring multiple re-renders once the Javascript had hydrated. A lot of work added up quickly for large apps.</p><p>A more recent <strong>second wave of CSS in JS</strong> libraries aim to give the best of the developer experience without the runtime cost.</p><p>Tools like <a href="https://vanilla-extract.style/">Vanilla extract</a>, <a href="https://linaria.dev/">Linaria</a>, and <a href="https://compiledcssinjs.com/">Compiled</a> extract stylesheets out from components in a compile step. This moves much of what happens at runtime on users’ browsers to compile time.</p><p>CSS is often compiled into Atomic CSS (a CSS architecture we’ll touch on in a bit) to avoid bloated CSS files and is a lot more cacheable compared to dynamic runtime style sheets.</p><h3 id="css-modules">CSS Modules</h3><p>CSS modules strike a balance between writing regular CSS (or Sass) and hitting many of the scaling properties we’re looking for.</p><p>CSS modules allow you to use CSS’s full power and control without worrying about styles bleeding out across components, while keeping things localized within a component directory.</p><p>Particularly with the first wave of CSS in JS libraries, tying CSS to a particular view library was a step too far for some, where CSS modules was a great alternative. However some may consider this a form of CSS in JS because it depends on a bundler like Webpack to generate and ensure selectors are scoped.</p><p>Regardless, CSS modules are a great middle-ground between the regular CSS world and fully component-centric approaches like CSS in JS. Coming up with names is still required and compatible with conventions like BEM.</p><h2 id="challenging-css-best-practices">Challenging CSS Best Practices</h2><p>Meanwhile, outside the world of component-based SPA’s, the original CSS Zen Garden influenced best practices were <a href="https://www.smashingmagazine.com/2013/10/challenging-css-best-practices-atomic-approach/">challenged on another front</a>.</p><p><strong>Atomic CSS</strong> was born in the darkness of managing CSS on large projects. Molded by it.</p><p>Its initial motivation was entirely pragmatic - enable styling without having to edit or append rules to an existing stylesheet. Avoiding all the issues that come with that.</p><p>It was on the other end of the spectrum compared to other CSS architectures like OOCSS, BEM, and SMACSS, and completely counterintuitive.</p><p>Atomic CSS went a level lower than “blocks” and “objects,” focusing on single-purpose atoms. Going directly against established best practices even outlined in the <a href="https://html.spec.whatwg.org/multipage/dom.html#classes">HTML spec</a> on how not to name CSS classes.</p><p>It has become a popular productivity-boosting approach for teams on projects where it feels too risky to modify existing CSS. Some popular CSS libraries included <a href="https://acss.io/">ACSS</a>, <a href="https://tachyons.io/">Tachyons</a>, <a href="https://windicss.org/">WindiCSS</a>, and many others.</p><p>According to the <a href="https://stateofcss.com/en-us/">state of CSS</a>, one of the most popular implementations of this CSS architecture that makes it accessible today is the <a href="https://tailwindcss.com/">Tailwind</a> CSS framework.</p><h2 id="the-rise-of-tailwind">The rise of Tailwind</h2><p>Tailwind has been rapidly gaining popularity since its release in 2017. A typical testimonial of Tailwind is that it increases productivity by making CSS more accessible to non-experts while leading to more maintainable CSS. Frequently the advice is to “just try it, and you won’t go back”.</p><h2 id="principles-powering-tailwind">Principles powering Tailwind</h2><p>To understand its popularity, let’s examine the underlying principles behind Tailwind’s method.</p><p>Despite seemingly throwing out established best practices, we’ll see underneath it’s a collection of pragmatic principles that work in practice.</p><h3 id="defer-naming-things">Defer naming things</h3><p>Not having to continually name things is one reason Tailwind feels so productive. This workflow is backed by the idea of composing single-purpose atoms bottom-up.</p><p>From a maintainability perspective, it’s a great way to <a href="https://kentcdodds.com/blog/aha-programming#aha-">avoid hasty abstractions</a>.</p><p>Never namings things at all harms the readability of code. Often leading to a soup of atomic classes (or components) without clear boundaries.</p><p>This is a valid criticism. But in practice, it’s surprising how far this can go before being a legitimate pain point. It’s often the right trade-off in code bases subject to regular changes or with many people.</p><p>This is a powerful workflow in a component model. You already have a semantic name for the component you are working in, and so you end up building up towards that, with styles contained to the component.</p><p>This is the same higher-level principle outlined in <a href="https://frontendmastery.com/posts/building-future-facing-frontend-architectures/">Building future-facing frontends</a>. It’s not about never creating abstractions, but not creating them prematurely.</p><h3 id="abstract-when-the-times-right">Abstract when the time’s right</h3><p>When operating iteratively, the ability to easily delete and change code vastly overshadows the cost of duplication.</p><p>A common pain point when writing CSS is that making things overly DRY or optimized up front often feels like a waste when things are hard to change later.</p><p>It’s much easier to DRY up repeated code behind a common abstraction than it is to work around overly abstracted code and make it work for your new use case.</p><p>Tailwind offers two techniques to abstract at the right time, either by creating a shared CSS class representing a block (similar to OOCSS).</p><p>Or more encouraged when using component-based frameworks, is to extract the duplicated classes into a reusable (React, Vue, Solid, Svelte, etc.) component and share that.</p><h3 id="have-confidence-refactoring">Have confidence refactoring</h3><p>Because classes are localized to the markup they are on, we can confidently refactor these without worrying about affecting other elements or components elsewhere.</p><p>This works for both mental models of the web as a document and component-centric models. This leads to the feeling that Tailwind can scale up and down depending on the type of site or application you are building.</p><h3 id="avoid-dead-code">Avoid dead code</h3><p>Tailwind and CSS in JS libraries that pre-compile to Atomic CSS solve the problems of bloated CSS files full of duplicated rules.</p><p>With Atomic CSS, the growth of CSS is tied to the number of unique styles used, not the amount of features developers are shipping.</p><p>For example, it’s common to reuse certain properties like <code>flex</code> everywhere. Rather than have these duplicated in stylesheets under different class names, we only pay that cost once. This is true for each property/value combination.</p><h2 id="bridging-the-design-gap">Bridging the design gap</h2><p>Let’s take a break from all these principles and architectures, and remember that CSS is ultimately about implementing visual designs.</p><p>A big reason CSS feels hard for many developers is the fact that design is hard.</p><p>Getting the fundamentals right goes a long way. In the case of visual design, some key elements are alignment, spacing, consistency, sizing, typography, and color.</p><p>In CSS, for any given property like <code>font-size</code>, <code>color</code> or <code>padding</code>, there are multiple ways to implement values.</p><p>Often we do so in an ad-hoc way, leading to a proliferation of slightly different font sizes, spacing, and color inconsistencies that add up to an unpolished look and feel.</p><p>A key part of scaling CSS is bridging this design gap by having a solid bedrock of sharable primitives that define values for spacing, font-sizing, colors, break-points, etc.</p><p>These are often called <strong>design tokens</strong> and form the foundation of a design system. Without this foundation, things can feel very arbitrary and chaotic.</p><p>One aspect that is key to Tailwind’s popularity is providing a set of pre-thought foundational design primitives you can use off the shelf. This eliminates a huge amount of decision-making that often gets done ad-hoc with inconsistency.</p><p>Another great open-source option for a solid foundation is <a href="https://open-props.style/">Open Props</a>, compatible with whatever CSS approach you take, and provides a ton of great pre-baked variables and tokens.</p><h2 id="concluding-thoughts">Concluding thoughts</h2><blockquote>
<p>Absorb what is useful, discard what is useless, and add what is specifically your own</p>
</blockquote><p>No tool is perfect, and every project and team is different. Whatever approach is taken, establishing foundations that bridge the design gap is a key element to scaling CSS.</p><p>Focussing on the primitives that get composed and built on top of also goes a long way. This also applies to large component-based applications using component libraries. Providing composable component layout primitives like <code>Box</code>, <code>Stack</code>, <code>Inline</code> etc, is a great way to manage CSS without developers having to write any CSS.</p><p>Recently there have been an impressive number of features shipped to evergreen browsers that address many of the pain points that make CSS hard to scale. Newer features like cascade layers, container queries, sub-grid, <code>has</code>, and many more will likely change how we think about and leverage CSS in the future.</p><p>Success in scaling CSS is less about dogmatic adherence to particular principles or best practices and more about defining what you need based on real-world constraints and doing what works sustainably and performantly to get the job done.</p><h2 id="references--resources">References &amp; resources</h2><ul>
<li><a href="https://web.dev/learn/css/">Learn CSS</a></li>
<li><a href="https://adamwathan.me/css-utility-classes-and-separation-of-concerns/">CSS Utility Classes and “Separation of Concerns”</a></li>
<li><a href="https://nicolasgallagher.com/about-html-semantics-front-end-architecture/">About HTML semantics and front-end architecture</a></li>
<li><a href="https://web.dev/state-of-css-2022/">State of CSS 2022</a></li>
<li><a href="https://piccalil.li/blog/i-used-tailwind-for-the-u-in-cube-css-and-i-liked-it/">I used Tailwind for the U in CUBE CSS and I liked it</a></li>
<li><a href="https://every-layout.dev/">Every Layout</a></li>
</ul>
        </article>
</div></div>
  </body>
</html>
