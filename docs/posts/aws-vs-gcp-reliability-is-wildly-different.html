<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://freeman.vc/notes/aws-vs-gcp-reliability-is-wildly-different">Original</a>
    <h1>AWS vs. GCP reliability is wildly different</h1>
    
    <div id="readability-page-1" class="page"><div>
            <h3><center>Or: why I burned $150 on GPUs for science.</center></h3>
<p>Cloud compute is usually seen as an ethereal resource. You launch VMs and spin them down, billed to the second. The billing and the mental model make it seem like these resources are limitless. That&#39;s typically one of the selling points versus on-prem compute. They can scale responsively to your load so you&#39;re not paying for excess compute that you don&#39;t need but it&#39;s there when you want it.</p>
<p>Of course, in reality they&#39;re not limitless. Cloud compute is backed by physical servers. And with the chip shortage of CPUs and GPUs those resources are more limited than ever. This is particularly true for GPUs, which are uniquely squeezed by COVID shutdowns, POW mining, and growing deep learning models. This can lead to resource availability issues when you need to spin up boxes on-demand, like for training and heavy inference load. And resource availability constraints mean you can&#39;t count on them being around when you need them.</p>
<p>After encountering some reliability issues with on-demand provisioning of GPU resources on Google Cloud, I put together a benchmarking harness to test AWS vs. GCP availability. It spins up GPUs at random times of the day to account for on-demand usage with unknown forecasts. We also expect that GCP and AWS will have different loads throughout the day as customers are doing different intensive jobs.</p>
<p>In total it scaled up about 3,000 T4 GPUs per platform over the course of two weeks. The y axis here measures duration that it took to successfully spin up the box, where negative results were requests that timed out after 200 seconds. The results are pretty staggering</p>
<p><img alt="" src="https://freeman.vc/images/aws-vs-gcp-reliability-is-wildly-different-chart-preview.png"/></p>
<p>AWS consistently spawned a new GPU in under 15 seconds (average of 11.4s). GCP on the other hand took closer to 45 seconds (average of 42.6s). AWS encountered one valid launch error in these two weeks whereas GCP had 84. Some caveats are below, but the takeaway was:</p>
<p><strong>AWS beat GCP in launch time by 66% and by errors by 84x.</strong></p>
<p>These differences are so extreme they made me double check the process. Are the &#34;states&#34; of completion different between the two clouds? Is an AWS &#34;Ready&#34; premature compared to GCP? It anecdotally appears not; I was able to ssh into an instance right after AWS became ready, and it took as long as GCP indicated before I was able to login to one of theirs. You&#39;ll also notice there are some instances where AWS takes longer to spawn; they&#39;re just few and far between the fast launches. This also gives some support to the experimental procedure.</p>
<p>The offerings between the two cloud vendors are also not the same, which might relate to their differing response times. GCP allows you to attach a GPU to an arbitrary VM as a hardware accelerator - you can separately configure quantity of the CPUs as needed. AWS only provisions defined VMs that have GPUs attached - the <code>g4dn.x</code> series of hardware here. Each of these instances are fixed in their CPU allocation, so if you want one particular varietal of GPU you are stuck with the associated CPU configuration.</p>
<p>Quantile breakdowns of response times, when they succeeded -</p>
<table>
<thead>
<tr>
<th></th>
<th>GCP</th>
<th>(GCP Support)</th>
<th>AWS</th>
<th>(AWS Support)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mean</td>
<td>42.66</td>
<td>3103</td>
<td>11.44</td>
<td>3485</td>
</tr>
<tr>
<td>25% Quantile</td>
<td>29.86</td>
<td>2264</td>
<td>10.38</td>
<td>2613</td>
</tr>
<tr>
<td>50% Quantile</td>
<td>37.76</td>
<td>1510</td>
<td>10.68</td>
<td>1742</td>
</tr>
<tr>
<td>75% Quantile</td>
<td>47.56</td>
<td>755</td>
<td>11.09</td>
<td>871</td>
</tr>
<tr>
<td>90% Quantile</td>
<td>70.38</td>
<td>302</td>
<td>11.33</td>
<td>349</td>
</tr>
<tr>
<td>99% Quantile</td>
<td>111.8</td>
<td>31</td>
<td>30.44</td>
<td>35</td>
</tr>
</tbody>
</table>
<p>These error codes broke down as follows -</p>
<p>GCP (84 total)</p>
<ul>
<li>74x - 409 Conflict</li>
<li>5x Operation timeout, GPU not available in 200 seconds</li>
</ul>
<p>AWS (1 total)</p>
<ul>
<li>1x - Instance did not reach break condition</li>
</ul>
<p><em>A note on 409 Conflicts</em>: This one was a weird error. It doesn&#39;t usually indicate capacity issues (ie. GCP did not report being out of GPUs) but there wasn&#39;t another good explanation. The error coming back from the API was vague about a conflict, but requests were spawned with unique identifiers based on clock time. So there shouldn&#39;t have been a conflict, especially not on the order of magnitude that was experienced here.</p>
<p>Even disregarding 409 errors, GCP fails to create GPUs more frequently - and has a higher spin up time across the board when they do succeed. Assuming you need on-demand boxes to succeed <em>right when you need them</em>, the consensus seems to clearly point to AWS. If you can stand to wait or be redundant to spawn failures, maybe Google&#39;s hardware acceleration customizability can win the day.</p>
<p>The entire testing harness is <a href="https://github.com/piercefreeman/cloud-gpu-reliability">open source</a> and I encourage you to run your own analysis - on different GPU configurations, spot instances, etc.</p>
        </div></div>
  </body>
</html>
