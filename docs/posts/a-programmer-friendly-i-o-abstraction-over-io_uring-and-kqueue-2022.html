<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2022-11-23-a-friendly-abstraction-over-iouring-and-kqueue/">Original</a>
    <h1>A programmer-friendly I/O abstraction over io_uring and kqueue (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Consider this tale of I/O and performance. We’ll start with blocking
I/O, explore io_uring and kqueue, and take home an event loop very
similar to some software you may find familiar.</p>
<p>This is a twist on King’s talk at <a href="https://www.youtube.com/watch?v=Ul8OO4vQMTw">Software You Can Love
Milan ’22</a>.</p>
<h2 id="classical-approach"><a href="#classical-approach" aria-hidden="true">Classical approach</a></h2>
<p>When you want to read from a file you might <code>open()</code> and
then call <code>read()</code> as many times as necessary to fill a
buffer of bytes from the file. And in the opposite direction, you call
<code>write()</code> as many times as needed until everything is
written. It’s similar for a TCP client with sockets, but instead of
<code>open()</code> you first call <code>socket()</code> and then
<code>connect()</code> to your server. Fun stuff.</p>
<p>In the real world though you can’t always read everything you want
immediately from a file descriptor. Nor can you always write everything
you want immediately to a file descriptor.</p>
<p>You can <a href="https://stackoverflow.com/questions/12773509/read-is-not-blocking-in-socket-programming/12775464#12775464">switch
a file descriptor into non-blocking mode</a> so the call won’t block
while data you requested is not available. But system calls are still
expensive, incurring context switches and cache misses. In fact,
networks and disks have become so fast that these costs can start to
approach the cost of doing the I/O itself. For the duration of time a
file descriptor is unable to read or write, you don’t want to waste time
continuously retrying read or write system calls.</p>
<h2 id="batching-and-readiness"><a href="#batching-and-readiness" aria-hidden="true">Batching and readiness</a></h2>
<p>So you switch to io_uring on Linux or kqueue on FreeBSD/macOS. (I’m
skipping the generation of epoll/select users.) These APIs let you
submit requests to the kernel to learn about readiness: when a file
descriptor is ready to read or write. You can send readiness requests in
batches (also referred to as queues). Completion events, one for each
submitted request, are available in a separate queue.</p>
<p>Being able to batch I/O like this is especially important for TCP
servers that want to multiplex reads and writes for multiple connected
clients.</p>
<p>However in io_uring, you can even go one step further. Instead of
having to call <code>read()</code> or <code>write()</code> in userland
after a readiness event, you can request that the kernel do the
<code>read()</code> or <code>write()</code> itself with a buffer you
provide. Thus almost all of your I/O is done in the kernel, amortizing
the overhead of system calls.</p>
<p>If you haven’t seen io_uring or kqueue before, you’d probably like an
example! Consider this code: a simple, minimal, not-production-ready TCP
echo server.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>const</span> std <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>const</span> os <span>=</span> std<span>.</span>os;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>const</span> linux <span>=</span> os<span>.</span>linux;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>const</span> allocator <span>=</span> std<span>.</span>heap<span>.</span>page_allocator;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>const</span> State <span>=</span> <span>enum</span>{ accept<span>,</span> recv<span>,</span> send };</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>const</span> Socket <span>=</span> <span>struct</span> {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    handle<span>:</span> os<span>.</span>socket_t<span>,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    buffer<span>:</span> [<span>1024</span>]<span>u8</span><span>,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    state<span>:</span> State<span>,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> main() <span>!</span><span>void</span> {</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span>const</span> entries <span>=</span> <span>32</span>;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span>const</span> flags <span>=</span> <span>0</span>;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span>var</span> ring <span>=</span> <span>try</span> linux<span>.</span>IO_Uring<span>.</span>init(entries<span>,</span> flags);</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span>defer</span> ring<span>.</span>deinit();</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span>var</span> server<span>:</span> Socket <span>=</span> <span>undefined</span>;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    server<span>.</span>handle <span>=</span> <span>try</span> os<span>.</span>socket(os<span>.</span>AF<span>.</span>INET<span>,</span> os<span>.</span>SOCK<span>.</span>STREAM<span>,</span> os<span>.</span>IPPROTO<span>.</span>TCP);</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span>defer</span> os<span>.</span>closeSocket(server<span>.</span>handle);</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span>const</span> port <span>=</span> <span>12345</span>;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span>var</span> addr <span>=</span> std<span>.</span>net<span>.</span>Address<span>.</span>initIp4(<span>.</span>{<span>127</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span>}<span>,</span> port);</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span>var</span> addr_len<span>:</span> os<span>.</span>socklen_t <span>=</span> addr<span>.</span>getOsSockLen();</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span>try</span> os<span>.</span>setsockopt(server<span>.</span>handle<span>,</span> os<span>.</span>SOL<span>.</span>SOCKET<span>,</span> os<span>.</span>SO<span>.</span>REUSEADDR<span>,</span> <span>&amp;</span>std<span>.</span>mem<span>.</span>toBytes(<span>@as</span>(<span>c_int</span><span>,</span> <span>1</span>)));</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span>try</span> os<span>.</span>bind(server<span>.</span>handle<span>,</span> <span>&amp;</span>addr<span>.</span>any<span>,</span> addr_len);</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span>const</span> backlog <span>=</span> <span>128</span>;</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span>try</span> os<span>.</span>listen(server<span>.</span>handle<span>,</span> backlog);</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    server<span>.</span>state <span>=</span> <span>.</span>accept;</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    _ <span>=</span> <span>try</span> ring<span>.</span>accept(<span>@ptrToInt</span>(<span>&amp;</span>server)<span>,</span> server<span>.</span>handle<span>,</span> <span>&amp;</span>addr<span>.</span>any<span>,</span> <span>&amp;</span>addr_len<span>,</span> <span>0</span>);</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span>while</span> (<span>true</span>) {</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        _ <span>=</span> <span>try</span> ring<span>.</span>submit_and_wait(<span>1</span>);</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        <span>while</span> (ring<span>.</span>cq_ready() <span>&gt;</span> <span>0</span>) {</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>            <span>const</span> cqe <span>=</span> <span>try</span> ring<span>.</span>copy_cqe();</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span>var</span> client <span>=</span> <span>@intToPtr</span>(<span>*</span>Socket<span>,</span> <span>@intCast</span>(<span>usize</span><span>,</span> cqe<span>.</span>user_data));</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            <span>if</span> (cqe<span>.</span>res <span>&lt;</span> <span>0</span>) std<span>.</span>debug<span>.</span>panic(<span>&#34;{}({}): {}&#34;</span><span>,</span> <span>.</span>{</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>                client<span>.</span>state<span>,</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>                client<span>.</span>handle<span>,</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>                <span>@intToEnum</span>(os<span>.</span>E<span>,</span> <span>-</span>cqe<span>.</span>res)<span>,</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>            });</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            <span>switch</span> (client<span>.</span>state) {</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>                <span>.</span>accept <span>=&gt;</span> {</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>                    client <span>=</span> <span>try</span> allocator<span>.</span>create(Socket);</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>                    client<span>.</span>handle <span>=</span> <span>@intCast</span>(os<span>.</span>socket_t<span>,</span> cqe<span>.</span>res);</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                    client<span>.</span>state <span>=</span> <span>.</span>recv;</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>                    _ <span>=</span> <span>try</span> ring<span>.</span>recv(<span>@ptrToInt</span>(client)<span>,</span> client<span>.</span>handle<span>,</span> <span>.</span>{<span>.</span>buffer <span>=</span> <span>&amp;</span>client<span>.</span>buffer}<span>,</span> <span>0</span>);</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>                    _ <span>=</span> <span>try</span> ring<span>.</span>accept(<span>@ptrToInt</span>(<span>&amp;</span>server)<span>,</span> server<span>.</span>handle<span>,</span> <span>&amp;</span>addr<span>.</span>any<span>,</span> <span>&amp;</span>addr_len<span>,</span> <span>0</span>);</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>                }<span>,</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>                <span>.</span>recv <span>=&gt;</span> {</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>                    <span>const</span> read <span>=</span> <span>@intCast</span>(<span>usize</span><span>,</span> cqe<span>.</span>res);</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>                    client<span>.</span>state <span>=</span> <span>.</span>send;</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>                    _ <span>=</span> <span>try</span> ring<span>.</span>send(<span>@ptrToInt</span>(client)<span>,</span> client<span>.</span>handle<span>,</span> client<span>.</span>buffer[<span>0</span><span>.</span><span>.</span>read]<span>,</span> <span>0</span>);</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>                }<span>,</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>                <span>.</span>send <span>=&gt;</span> {</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>                    os<span>.</span>closeSocket(client<span>.</span>handle);</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>                    allocator<span>.</span>destroy(client);</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>                }<span>,</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This is a great, minimal example. But notice that this code ties
io_uring behavior directly to business logic (in this case, handling
echoing data between request and response). It is fine for a small
example like this. But in a large application you might want to do I/O
throughout the code base, not just in one place. You might not want to
keep adding business logic to this single loop.</p>
<h2 id="central-io-dispatch"><a href="#central-io-dispatch" aria-hidden="true">Central I/O dispatch</a></h2>
<p>Instead, you might want to be able to schedule I/O and pass a
callback (and sometimes with some application context) to be called when
the event is complete.</p>
<p>The interface might look like:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>io_dispatch<span>.</span>dispatch({</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>// some big struct/union with relevant fields for all event types</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>}<span>,</span> my_callback);</span></code></pre></div>
<p>This is great! Now your business logic can schedule and handle I/O no
matter where in the code base it is.</p>
<p>Under the hood it can decide whether to use io_uring or kqueue
depending on what kernel it’s running on. The dispatch can also batch
these individual calls through io_uring or kqueue to amortize system
calls. The application no longer needs to know the details.</p>
<p>Additionally, we can use this wrapper to stop thinking about
readiness events, just I/O completion. That is, if we dispatch a read
event, the io_uring implementation would actually ask the kernel to read
data into a buffer. Whereas the kqueue implementation would send a
“read” readiness event, do the read back in userland, and then call our
callback.</p>
<p>And finally, now that we’ve got this central dispatcher, we don’t
need spaghetti code in a loop switching on every possible submission and
completion event.</p>
<h2 id="interacting-with-the-submission-and-completion-queue"><a href="#interacting-with-the-submission-and-completion-queue" aria-hidden="true">Interacting with the submission and
completion queue</a></h2>
<p>Every time we call io_uring or kqueue we both submit event requests
and poll for completion events. The io_uring and kqueue APIs tie these
two actions together in the same system call.</p>
<p>To sync our requests to io_uring or kqueue we’ll build a
<code>flush</code> function that submits requests and polls for
completion events. (In the next section we’ll talk about how the user of
the central dispatch learns about completion events.)</p>
<p>To make <code>flush</code> more convenient, we’ll build a nice
wrapper around it so that we can submit as many requests (and process as
many completion events) as possible. To avoid accidentally blocking
indefinitely we’ll also introduce a time limit. We’ll call the wrapper
<code>run_for_ns</code>.</p>
<p>Finally we’ll put the user in charge of setting up a loop to call
this <code>run_for_ns</code> function, independent of normal program
execution.</p>
<p>This is now your traditional event loop.</p>
<h2 id="callbacks-and-context"><a href="#callbacks-and-context" aria-hidden="true">Callbacks and context</a></h2>
<p>You may have noticed that in the API above we passed a callback. The
idea is that after the requested I/O has completed, our callback should
be invoked. But the question remains: how to track this callback between
the submission and completion queue?</p>
<p>Thankfully, io_uring and kqueue events have user data fields. The
user data field is opaque to the kernel. When a submitted event
completes, the kernel sends a completion event back to userland
containing the user data value from the submission event.</p>
<p>We can store the callback in the user data field by setting it to the
callback’s pointer casted to an integer. When the completion for a
requested event comes up, we cast from the integer in the user data
field back to the callback pointer. Then, we invoke the callback.</p>
<h2 id="getting-more-expressive"><a href="#getting-more-expressive" aria-hidden="true">Getting more expressive</a></h2>
<p>As described above, the struct for <code>io_dispatch.dispatch</code>
could get quite large handling all the different kinds of I/O events and
their arguments. We could make our API a little more expressive by
creating wrapper functions for each event type.</p>
<p>So if we wanted to schedule a read function we could call:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>io_dispatch<span>.</span>read(fd<span>,</span> <span>&amp;</span>buf<span>,</span> nBytesToRead<span>,</span> callback);</span></code></pre></div>
<p>Or to write, similarly:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>io_dispatch<span>.</span>write(fd<span>,</span> buf<span>,</span> nBytesToWrite<span>,</span> callback);</span></code></pre></div>
<h2 id="overflow"><a href="#overflow" aria-hidden="true">Overflow</a></h2>
<p>One more thing we need to worry about is that the batch we pass to
io_uring or kqueue has a fixed size (technically, kqueue allows any
batch size but using that might introduce unnecessary allocations). So
we’ll build our own queue on top of our I/O abstraction to keep track of
requests that we could not immediately submit to io_uring or kqueue.</p>
<blockquote>
<p>To keep this API simple we could allocate for each entry in the
queue. Or we could modify the <code>io_dispatch.X</code> calls slightly
to accept a struct that can be used in an <a href="https://www.data-structures-in-practice.com/intrusive-linked-lists/">intrusive
linked list</a> to contain all request context, including the callback.
The latter is <a href="https://github.com/tigerbeetle/tigerbeetle/blob/d15acc663f8882cb02413129e8351bf3238335e6/src/io/linux.zig#L665">what
we do in TigerBeetle</a>.</p>
</blockquote>
<p>Put another way: every time code calls <code>io_dispatch</code>,
we’ll try to immediately submit the requested event to io_uring or
kqueue. But if there’s no room, we store the event in an overflow
queue.</p>
<p>The overflow queue needs to be processed eventually, so we update our
<code>flush</code> function (described in <a href="#callbacks-and-context">Callbacks and context</a> above) to pull
as many events from our overflow queue before submitting a batch to
io_uring or kqueue.</p>
<h2 id="a-step-back"><a href="#a-step-back" aria-hidden="true">A step back</a></h2>
<p>We’ve now built something similar to <a href="https://github.com/libuv/libuv">libuv</a>, the I/O library that
Node.js uses. And if you squint, it is basically TigerBeetle’s I/O
library! (And interestingly enough, TigerBeetle’s I/O code was <a href="https://github.com/oven-sh/bun/blob/e14a3af491ece8d1b0309e76ae3022b4fad91f16/src/io/io_linux.zig#L704">adopted</a>
into Bun! Open-source for the win!)</p>
<p>Let’s check out how the <a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/darwin.zig#L436">Darwin
version</a> of TigerBeetle’s I/O library (with kqueue) differs from the
<a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/linux.zig#L656">Linux
version</a>. As mentioned, the complete <code>send</code> call in the
Darwin implementation waits for file descriptor readiness (through
kqueue). Once ready, the actual <code>send</code> call is made back in
userland:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> send(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span>self</span><span>:</span> <span>*</span>IO<span>,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span>comptime</span> Context<span>:</span> <span>type</span><span>,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    context<span>:</span> Context<span>,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span>comptime</span> callback<span>:</span> <span>fn</span> (</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        context<span>:</span> Context<span>,</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        completion<span>:</span> <span>*</span>Completion<span>,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        result<span>:</span> SendError<span>!</span><span>usize</span><span>,</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    ) <span>void</span><span>,</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    completion<span>:</span> <span>*</span>Completion<span>,</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    socket<span>:</span> os<span>.</span>socket_t<span>,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    buffer<span>:</span> []<span>const</span> <span>u8</span><span>,</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>) <span>void</span> {</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span>self</span><span>.</span>submit(</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        context<span>,</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        callback<span>,</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        completion<span>,</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span>.</span>send<span>,</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span>.</span>{</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            <span>.</span>socket <span>=</span> socket<span>,</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span>.</span>buf <span>=</span> buffer<span>.</span>ptr<span>,</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span>.</span>len <span>=</span> <span>@intCast</span>(<span>u32</span><span>,</span> buffer_limit(buffer<span>.</span>len))<span>,</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span>struct</span> {</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            <span>fn</span> do_operation(op<span>:</span> <span>anytype</span>) SendError<span>!</span><span>usize</span> {</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                <span>return</span> os<span>.</span>send(op<span>.</span>socket<span>,</span> op<span>.</span>buf[<span>0</span><span>.</span><span>.</span>op<span>.</span>len]<span>,</span> <span>0</span>);</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Compare this to the <a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/linux.zig#L656">Linux
version</a> (with io_uring) where the kernel handles everything and
there is no send system call in userland:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> send(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>self</span><span>:</span> <span>*</span>IO<span>,</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>comptime</span> Context<span>:</span> <span>type</span><span>,</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    context<span>:</span> Context<span>,</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span>comptime</span> callback<span>:</span> <span>fn</span> (</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        context<span>:</span> Context<span>,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        completion<span>:</span> <span>*</span>Completion<span>,</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        result<span>:</span> SendError<span>!</span><span>usize</span><span>,</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    ) <span>void</span><span>,</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    completion<span>:</span> <span>*</span>Completion<span>,</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    socket<span>:</span> os<span>.</span>socket_t<span>,</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    buffer<span>:</span> []<span>const</span> <span>u8</span><span>,</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>) <span>void</span> {</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    completion<span>.*</span> <span>=</span> <span>.</span>{</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span>.</span>io <span>=</span> <span>self</span><span>,</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span>.</span>context <span>=</span> context<span>,</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span>.</span>callback <span>=</span> <span>struct</span> {</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            <span>fn</span> wrapper(ctx<span>:</span> <span>?*</span><span>anyopaque</span><span>,</span> comp<span>:</span> <span>*</span>Completion<span>,</span> res<span>:</span> <span>*</span><span>const</span> <span>anyopaque</span>) <span>void</span> {</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>                callback(</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                    <span>@intToPtr</span>(Context<span>,</span> <span>@ptrToInt</span>(ctx))<span>,</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                    comp<span>,</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                    <span>@intToPtr</span>(<span>*</span><span>const</span> SendError<span>!</span><span>usize</span><span>,</span> <span>@ptrToInt</span>(res))<span>.*,</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                );</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        }<span>.</span>wrapper<span>,</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span>.</span>operation <span>=</span> <span>.</span>{</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            <span>.</span>send <span>=</span> <span>.</span>{</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>                <span>.</span>socket <span>=</span> socket<span>,</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>                <span>.</span>buffer <span>=</span> buffer<span>,</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>            }<span>,</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span>// Fill out a submission immediately if possible, otherwise adds to overflow buffer</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span>self</span><span>.</span>enqueue(completion);</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Similarly, take a look at <code>flush</code> on <a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/linux.zig#L66">Linux</a>
and <a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/darwin.zig#L75">macOS</a>
for event processing. Look at <code>run_for_ns</code> on <a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/linux.zig#L66]">Linux</a>
and <a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/darwin.zig#L75">macOS</a>
for the public API users must call. And finally, look at what puts this
all into practice, the loop calling <code>run_for_ns</code> in
src/main.zig.</p>
<h2 id="windows-and-iocp"><a href="#windows-and-iocp" aria-hidden="true">Windows and IOCP</a></h2>
<p>We’ve come this far and you might be wondering — what about
cross-platform support for Windows? The good news is that Windows also
has a completion based system similar to io_uring but without batching,
called <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">IOCP</a>.
And for bonus points, TigerBeetle provides the <a href="https://github.com/tigerbeetle/tigerbeetle/blob/9d3552ba137a773d4b81106739e56cba6cd32a03/src/io/windows.zig">same
I/O abstraction over it</a>! But it’s enough to cover just Linux and
macOS in this post. :)</p>
<h2 id="beyond-a-single-thread"><a href="#beyond-a-single-thread" aria-hidden="true">Beyond a single thread</a></h2>
<p>In both this blog post and in TigerBeetle, we implemented a
single-threaded event loop. Keeping I/O code single-threaded in
userspace is beneficial (whether or not I/O processing is
single-threaded in the kernel is not our concern). It’s the simplest
code and best for workloads that are not embarrassingly parallel. It is
also best for determinism, which is integral to the design of
TigerBeetle because it enables us to do Deterministic Simulation
Testing</p>
<p>But there are other valid architectures for other workloads.</p>
<p>For workloads that are embarrassingly parallel, like many web
servers, you could instead use multiple threads where each thread has
its own queue. In optimal conditions, this architecture has the highest
I/O throughput possible.</p>
<p>But if each thread has its own queue, individual threads can become
starved if an uneven amount of work is scheduled on one thread. In the
case of dynamic amounts of work, the better architecture would be to
have a single queue but multiple worker threads doing the work made
available on the queue.</p>
<h2 id="standalone-cross-platform-evented-io-library"><a href="#standalone-cross-platform-evented-io-library" aria-hidden="true">Standalone cross-platform evented I/O
library?</a></h2>
<p>Hey, maybe we’ll split this out so you can use it too. It’s written
in Zig so we can easily expose a C API. Any language with a C foreign
function interface (i.e. every language) should work well with it. Keep
an eye on <a href="https://github.com/tigerbeetle">our GitHub</a>.
:)</p>
<p>Additional resources:</p>
<ul>
<li><a href="https://www.usenix.org/system/files/conference/hotos15/hotos15-paper-mcsherry.pdf">https://www.usenix.org/system/files/conference/hotos15/hotos15-paper-mcsherry.pdf</a></li>
<li><a href="https://github.com/ziglang/zig/issues/8224">https://github.com/ziglang/zig/issues/8224</a></li>
<li><a href="https://www.youtube.com/watch?v=lZU6RK0oazM">https://www.youtube.com/watch?v=lZU6RK0oazM</a></li>
<li><a href="https://unixism.net/loti/">https://unixism.net/loti/</a></li>
</ul>
  </div></div>
  </body>
</html>
