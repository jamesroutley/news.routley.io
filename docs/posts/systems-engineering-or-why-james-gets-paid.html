<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cohost.org/jamesmunns/post/167078-systems-engineering">Original</a>
    <h1>Systems Engineering, or &#34;why james gets paid&#34;</h1>
    
    <div id="readability-page-1" class="page"><div data-post-body="true"><div><p>Writing intros are hard, so lets cut to the executive summary.<!-- --></p>
<!-- --><p>I work as a consultant. I usually work on projects that involve hardware (electronics and mechanical parts), but I usually help on the software side, from microcontroller code, up to desktop stuff, to server stuff sometimes.<!-- --></p>
<!-- --><p>Sometimes I get brought in to implement specific things, like drivers or proof of concepts. Sometimes I get brought in when people are looking to move to Rust. Sometimes I get brought in when people are looking to turn a &#34;prototype&#34; into a &#34;product&#34;.<!-- --></p>
<!-- --><p>Usually, what I end up spending the most time helping people with are the fundamentals of systems engineering.<!-- --></p>
<!-- --><p>Maybe this is a case of &#34;when the tool you have is a hammer, all problems look like nails&#34;. Maybe I&#39;ve overdrank the Systems Engineering kool-aid.<!-- --></p>
<!-- --><p>That being said, it keeps working and being helpful, so I&#39;m going to keep swinging that hammer.<!-- --></p>
<!-- --><p>I might want to write a book on this some day, but here&#39;s the start of some unsorted thoughts in the mean time.<!-- --></p>
<!-- --><p>I have nothing to sell you (yet), and I promise there are no magic bullets in these writings. Just some things to think about that might help you or your projects.<!-- --></p>
<!-- --><p>I am also <!-- --><strong>not<!-- --></strong> a process purist, or religiously tied to the concept of systems engineering. Sometimes doing a little of this work goes a long way. Sometimes (especially if you are doing something safety critical) you need to do everything to the full extent. Do what feels right. If it stops helping, find something else to do. Ideally, all of the concepts I&#39;ll describe should start paying dividends almost immediately.<!-- --></p>
<!-- --><h2>What is Systems Engineering?<!-- --></h2>
<!-- --><p>I dunno, NASA or someone probably has a better definition, but to me, it covers the domains of:<!-- --></p>
<!-- --><ol>
<!-- --><li><strong>Be explicit about what you are building<!-- --></strong></li>
<!-- --><li><strong>Be explicit about how you are building it<!-- --></strong></li>
<!-- --></ol>
<!-- --><p>That seems simple, right? Well, sometimes it is.<!-- --></p><hr/>
<!-- --><h3>Where do things fall down?<!-- --></h3>
<!-- --><p>Once your project has multiple people working on it, sometimes with widely different experiences (e.g. the &#39;software folks&#39; and the &#39;hardware folks&#39; and the &#39;manager folks&#39; and the &#39;product folks&#39; and so on), the concepts of &#34;what are you building&#34; and &#34;how are you building it&#34; seem to get away from teams and organizations.<!-- --></p>
<!-- --><p>Or, your project gets a little bigger than the last one, or you need to tackle some new domain you aren&#39;t super familiar with. Things that felt simple start getting complicated very quickly, and despite working very hard, the finish line doesn&#39;t get any closer.<!-- --></p>
<!-- --><p>Like many other &#34;best practices&#34; - you can usually power through on smaller projects or with smaller teams without running into any problems.<!-- --></p>
<!-- --><p>But the problems in this domain are like a sneaky <!-- --><code>O(n^2)<!-- --></code> term. It&#39;ll be fine at first, until one day, things get exponential, and your schedule slips a month, or three, or twelve.<!-- --></p>
<!-- --><h3>Why aren&#39;t more people doing &#34;systems engineering&#34;?<!-- --></h3>
<!-- --><p>Your mileage may vary, but I&#39;ve found that software folks have very little formal training in tackling these topics. They might think about breaking a problem down in to parts as an individual engineer solving problems, but don&#39;t have a lot of tools for breaking down &#34;team sized problems&#34;.<!-- --></p>
<!-- --><p>&#34;Classical engineering&#34; folks in electrical and mechanical domains tend to have seen some of the processes and formality around systems engineering before, but haven&#39;t necessarily internalized why certain approaches exist.<!-- --></p>
<!-- --><p>If your organization doesn&#39;t already have a &#34;culture&#34; of systems engineering, there&#39;s usually no one to introduce it! This is usually where I get brought in<!-- --></p>
<!-- --><p>That being said: Things don&#39;t have to get to an emergency state to benefit from a little systems engineering. Sometimes it&#39;s nice to just have a more predictable development process, with fewer surprises.<!-- --></p>
<!-- --><h3>James, your definition of system engineering is still super vague<!-- --></h3>
<!-- --><p>Yeah. I was trying to be succinct. Let&#39;s expand a little bit.<!-- --></p>
<!-- --><h4>Be explicit about what you are building<!-- --></h4>
<!-- --><p>Formally, this typically covers the topics of <!-- --><strong>requirements<!-- --></strong>, <!-- --><strong>specifications<!-- --></strong>, <!-- --><strong>architecture<!-- --></strong>, and/or <!-- --><strong>acceptance criteria<!-- --></strong>. There is a lot more to explain about what I mean on those topics, but that&#39;s for a later day.<!-- --></p>
<!-- --><p>Informally, this means <!-- --><strong>&#34;everyone who is working on your project should unambiguously know what it is supposed to do&#34;<!-- --></strong>.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>NOTE: I&#39;ll use &#34;specification&#34; and &#34;requirements&#34; somewhat interchangeably here. In this section, I mean it to generally
describe &#34;what your system is supposed to do&#34;.<!-- --></p>
<!-- --></blockquote>
<!-- --><p>I&#39;m going to say this a lot, but <!-- --><strong>if information isn&#39;t written down, it doesn&#39;t exist<!-- --></strong>.<!-- --></p>
<!-- --><ul>
<!-- --><li>You never know if two people have the same mental model. This gets even worse with more than two people.<!-- --></li>
<!-- --><li>You never know if YOUR mental model is consistent. Sometimes things make sense in your head, but when you write it down, it&#39;s self-contradicting.<!-- --></li>
<!-- --><li>You can&#39;t guarantee your understand doesn&#39;t change over time, or you forget parts of the mental model.<!-- --></li>
<!-- --></ul>
<!-- --><p>The solution to this is that you <!-- --><strong>must<!-- --></strong> write down what your project (code, hardware, whatever) is supposed to do. It doesn&#39;t have to be super formal or anything.<!-- --></p>
<!-- --><p>Use a markdown document. Use a word document. Use an excel spreadsheet. Use whatever, but write it down. It&#39;s always easier to move from one text medium to another, than it is to capture all the information in the first place.<!-- --></p>
<!-- --><p>But whatever you use, this brings me to the next point: <!-- --><strong>your whole team must know where the source of truth is, how to view it, and have access to it at all times<!-- --></strong>.<!-- --></p>
<!-- --><p>If you keep the definition in a git repo, and the project managers don&#39;t have access to it (or don&#39;t know how to view it), <!-- --><em>then your specification is useless to them<!-- --></em>. If your company uses a fancy requirements tool, but doesn&#39;t have licenses for everyone to view it, <!-- --><em>then your specification is useless to everyone<!-- --></em>.<!-- --></p>
<!-- --><p>This specification is <!-- --><strong>only<!-- --></strong> useful when someone can say, &#34;wait, how does this work?&#34;, and look up the information in less time than it takes to guess wrong.<!-- --></p>
<!-- --><p>This specification is <!-- --><strong>only<!-- --></strong> useful when two people disagree on how things are <!-- --><em>supposed to work<!-- --></em>, and they can look it up, instead of having an argument, or needing to schedule a meeting &#34;to get on the same page&#34;.<!-- --></p>
<!-- --><p>For this bet to pay off, we hit the next rule: <!-- --><strong>your specification must be accurate<!-- --></strong>.<!-- --></p>
<!-- --><p>This gets a little weird in the time between &#34;the requirements say what the system <!-- --><em>will do<!-- --></em>&#34;, and &#34;the requirements say what the system <!-- --><em>does do<!-- --></em>&#34;. That&#39;s a longer topic for another day.<!-- --></p>
<!-- --><p>But, at all times, your requirements/specification must be accurate.<!-- --></p>
<!-- --><p>If the requirements say &#34;the system does X&#34;, the electrical engineers must be free to use this assumption, without talking to the software engineers. The sales people must be able to put this in the marketing docs, without having to guess.<!-- --></p>
<!-- --><p>If two (or more) people ever disagree on what the system should do, the requirements should be the tie breaker.<!-- --></p>
<!-- --><p>I don&#39;t have a good segue for this, but <!-- --><strong>your specification should be easy to read, search, and get information from<!-- --></strong>.<!-- --></p>
<!-- --><p>Some folks track &#34;what their system does&#34; in things like JIRA or GitHub tickets. But often these are written over a long period of time. How do you know which ones are relevant? How do you know which ones changed later? If you have a question like &#34;how many whatevers can my system handle at one time&#34;, how will you find an answer to this?<!-- --></p>
<!-- --><p>For this reason, I strongly recommend keeping a single document up to date.<!-- --></p>
<!-- --><p>If the requirements are <!-- --><em>unclear<!-- --></em>, or just plain <!-- --><em>wrong<!-- --></em>, <!-- --><strong>everyone should know how to update the requirements<!-- --></strong>.<!-- --></p>
<!-- --><p>Requirements <!-- --><em>should<!-- --></em> be a living document. Even if you subscribe to the &#34;waterfall process&#34; sort of thing, your understanding of the system will change over time. People might require new features. You might realize certain performance goals aren&#39;t possible or necessary.<!-- --></p>
<!-- --><p>We&#39;ll get into <!-- --><em>how<!-- --></em> you should change requirements later, but whatever you choose, everyone should know how to &#34;fix&#34; or &#34;improve&#34; the requirements when necessary.<!-- --></p>
<!-- --><p>Finally, <!-- --><strong>you should be able to prove your system matches its requirement/specification<!-- --></strong>.<!-- --></p>
<!-- --><p>This might mean testing, this might mean review, but basically: you should be able to &#34;gut check&#34; every part of your requirements/specification, so you know if it is accurate or not. More on that later.<!-- --></p>
<!-- --><p><strong>TL;DR: To be explicit about what you are building:<!-- --></strong></p>
<!-- --><ol>
<!-- --><li>You should write down what your system should do<!-- --></li>
<!-- --><li>It should be in a single, living document, that is kept updated
<!-- --><ul>
<!-- --><li>It should be as complete as possible (you can do it incrementally!), BUT<!-- --></li>
<!-- --><li>It should ALWAYS be accurate<!-- --></li>
<!-- --></ul>
<!-- --></li>
<!-- --><li>Everyone should know where to find it, how to read it, and it should be easy to find answers from<!-- --></li>
<!-- --><li>Everyone should know how to change it, if/when things are incomplete or inaccurate<!-- --></li>
<!-- --><li>You should be able to prove your system does what you say it should<!-- --></li>
<!-- --></ol>
<!-- --><h4>Be explicit about how you are building it<!-- --></h4>
<!-- --><p>Formally, this covers topics like <!-- --><strong>System/Software Development Plans<!-- --></strong>, <!-- --><strong>System/Software Verification Plans<!-- --></strong>, <!-- --><strong>Design/Coding Standards<!-- --></strong>, <!-- --><strong>Review Standards<!-- --></strong>, and <!-- --><strong>Document Control<!-- --></strong>.<!-- --></p>
<!-- --><p>Informally, this means <!-- --><strong>&#34;everyone who is working on your project should unambiguously know how they are expected to work&#34;<!-- --></strong>.<!-- --></p>
<!-- --><p>There is... a lot going on here with respect to process. How you design or verify a system, how you capture requirements, down to little details like how code is formatted. This is the sum total of things that someone like a new hire will need to learn to be productive as a member of your team.<!-- --></p>
<!-- --><p>I&#39;m going to repeat this, <!-- --><strong>if information isn&#39;t written down, it doesn&#39;t exist<!-- --></strong>.<!-- --></p>
<!-- --><p>In the ideal world, you should be able to:<!-- --></p>
<!-- --><ul>
<!-- --><li>Have someone come in for their first day<!-- --></li>
<!-- --><li>Know what they need access to, before they start<!-- --></li>
<!-- --><li>Point them at one document (which might link to other ones)<!-- --></li>
<!-- --><li>They should be able to read this document<!-- --></li>
<!-- --><li>They should know generally how to start working with your team<!-- --></li>
<!-- --></ul>
<!-- --><p>Again, you can capture this information however you want. Markdown documents work great. Internal wiki pages are just fine. These documents end up acting a bit like &#34;process requirements&#34;:<!-- --></p>
<!-- --><ul>
<!-- --><li>They should be a living document over time<!-- --></li>
<!-- --><li>Everyone should know where to find them<!-- --></li>
<!-- --><li>If there&#39;s a disagreement, the &#34;process requirements&#34; should have the answer, or if it doesn&#39;t, you should come to a decision and write it down<!-- --></li>
<!-- --><li>Incomplete is okay (but improve it as you go!), BUT<!-- --></li>
<!-- --><li>Inaccurate is never okay<!-- --></li>
<!-- --></ul>
<!-- --><p><strong>You don&#39;t need to legislate your process to death<!-- --></strong>. Most teams don&#39;t need safety-critical-formal process definitions. But if you do something every day (like make PRs, or review code, or design circuit boards), maybe capture some of that &#34;process how-to&#34;, so it&#39;s easier to onboard the next person.<!-- --></p>
<!-- --><p>If you have two people disagree on &#34;how to do X&#34;, sit down as a team, make a decision, and write it down. Then don&#39;t argue about it, unless there&#39;s a good reason to change it again in the future.<!-- --></p>
<!-- --><p>At the end of the day, <!-- --><strong>having a written process helps you be consistent<!-- --></strong>. Consistency is great, because it means people spend less time being confused how to do something, and spend more time solving the actual problem.<!-- --></p>
<!-- --><p><strong>TL;DR: Write down how you do stuff.<!-- --></strong></p>
<!-- --><p>At some point in the future, I&#39;ll write down certain ways of doing things that you might want to use as a &#34;reasonable default&#34;, but honestly, do whatever works for your team. And write it down, so everyone is on the same page.<!-- --></p>
<!-- --><h2>Summary<!-- --></h2>
<!-- --><p>Systems Engineering helps you with the &#34;meta&#34; of solving problems. If you have a big team, or a big problem, it&#39;s worth sitting down and &#34;solving the problem of how to define and solve a problem&#34;.<!-- --></p>
<!-- --><p>If you can, spend some time BEFORE you start working, to make sure everyone is ready to solve the same project, and everyone knows what they are supposed to do. If you&#39;ve already started, it&#39;s not too late, you still might catch problems earlier than you would have otherwise.<!-- --></p>
<!-- --><p>You don&#39;t need formal training (but if you want help with this, <!-- --><a href="https://cohost.org/cdn-cgi/l/email-protection#781219151d0b3817161d0e190a11191a141d561b1715">send me an email!<!-- --></a>). Just start writing things down, and make sure everyone is on the same page.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>The Only Difference Between Screwing Around and Science Is Writing It Down<!-- --></p>
<!-- --></blockquote>
<!-- --><p>If you have questions, feel free to leave a comment here, or shoot me an email. Hopefully I&#39;ll get motivation to write more soon.<!-- --></p></div></div></div>
  </body>
</html>
