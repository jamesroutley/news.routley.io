<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jupiter-ace.co.uk/Forth_general_practical_computing8108.html">Original</a>
    <h1>As you learn Forth, it learns from you (1981)</h1>
    
    <div id="readability-page-1" class="page"><div>
     <div id="faux">
<p>Practical Computing August 1981 page 92   </p>

 <div> <!-- Start Column_Continer-->

   <!-- Page 92 start -->
   <p>As you learn Forth, it learns
from you</p>
    <div>
   <p> LIKE ANY computer language, Forth has a vocabulary - but this vocabulary can be broadened by the programmer. Each new word added is defined in terms of older words already known to the system. Thus, increasingly-powerful words can be formed in hierarchical fashion. In this sense, Forth bears a strong resemblance to human knowledge.</p>
<p>As we all know, the single most popular language today is Basic. The reason for this is not just that Basic is a powerful programming language but is mainly due to the fact that Basic is a complete programming system. A Basic program can be constructed and made to work in a fraction of the time taken by compiling languages such as Fortran or Pascal. </p>
<p>The big problem is that the system never learns anything from your Basic program. Each program line has to be interpreted by the system and if a line is encountered again and again, it must be interpreted again and again. Thus programming speed is obtained at the expense of execution speed. </p>
<p>Machine code</p>
<p>Forth, on the other hand, is both an interpreter and a compiler - but not the kind of compiler which produces massive amounts of machine code. Each word compiled into Forth is, in fact, a compact list of subroutines. Each of these subroutines will be a list of more subroutines and so on, down the tree, until machine code is encountered.</p>
<p>The resulting structure, called &#34;Threaded code&#34;, is not as fast as pure machine code, but is constructed quickly and easily. When you are familiar with Forth, it is just as quick to write as Basic, just as easy to debug, yet runs between 10 to 20 times as quickly.  </p>
<p>Basic does not stand alone in its class; there have been similar languages such as Focal. Likewise, there are other self-extending languages, like Forth, but which do not necessarily use exactly the same words or exactly the same syntax. They are called Threaded Interpretative Languages or TILs. Forth is the original threaded language and was developed originally by Charles Moore.  </p>
<p>The impetus to investigate Forth arose from the August 1980 issue of Byte which was completely dedicated to articles about the language. I understand that particular issue of Byte is completely sold out and highly sought-after. I then whetted my appetite with the Pet version of Forth called FullForth.</p></div>


<div>

<p> The quintessence of Forth is that it learns from its master - Forth is extensible. David Sands reports. </p>

<div>
<p>Keen to try something more serious, 1 obtained a copy of Stackworks Forth called SL5, running under CP/M for  </p>
<p> North Star. This Forth is some 10 times faster than North Star Basic. For example the quick test:</p>
<div><p>
10 FOR X = 0 to 10000: NEXT</p></div>
<p>takes about eight seconds in North star Basic. A corresponding code for Forth is DECIMAL    </p>

<p>This runs in about 0.8 seconds in SL5.    </p>
<p>As the full potential of Forth became apparent, I became dissatisfied also with my Stackworks SL5. One of the major advantages Forth will bring to the microcomputer industry is the ability to write ROMable code for such applications as automatic testing, or process control. It can write this code quickly and, therefore, cheaply without undue run-time penalty.  </p>
<p>However, Stackworks has obviously had some difficulty in making its Forth produce ROMable code. The main obstacle was the CP/M under which SL5 runs. I decided I needed a Forth to run under North Star DOS. This may surprise CP/M enthusiasts, but North Star DOS, although primitive compared to CP/M, has many advantages, for the following reasons:  </p>
<p>• 
<span>The sophistication of CP/M is achieved with more code and more disc activity and so takes longer to run. Equivalent disc activity under North Star DOS is approximately twice as fast as CP/M.</span>
</p>
<p>• <span>With North Star DOS, it is possible to take snapshots of any part of memory and put them on any part of the disc and vice versa. This is not possible with CP/M where one is forced to use the text-processing area and the indexed self-arranging disc allocation. </span>   </p>
<p>• <span>With North Star DOS, is is also possible to keep more than one program in RAM at the same time and to jump back and forth between them without unnecessary disc activity.</span>     </p>
<p>• <span>Because of the requirement in CP/M for a text processing area at 100 Hex and a small CP/M jump table in the first page of memory, it is very difficult to write ROMable code which starts from zero. Z-80 and 8080 microprocessors re-set to zero, so it is most important to have all ROMable code at the beginning of memory space.</span>  </p>
<p>• <span>North Star DOS can be re-located anywhere in memory so as not to interfere with the new system generated.</span></p>
<p>• <span>Stackworks Forth uses the CP/M text editor. This text editor is far from brilliant and text produced must be stored on disc and Forth reloaded before the text can be tested. When one is working interactively with a computer, perhaps trying to debug</span></p>
</div>


<div>
 <p> something tricky, these delays are intolerable. It is essential to have rapid communication between the program-generation and the program-testing parts of a system - otherwise you might as well stay with Basic.</p>
<p>In addition to all these reasons was the nagging awareness of the fact that Stackworks SL5, CP/M and indeed North Star Basic are all written in 8080 code and so fail to use some of the powerful features of the Z-80 microporcessor. So, when I laid my hands on a copy of the Byte book, Threaded Interpretative Languages by R G Loeliger, I had no excuse not to write my own version of Forth to run under North Star DOS.</p>
<p>This I accomplished in a matter of days using Allen Ashley&#39;s excellent PDS assembly-language development system, which includes a superb text editor and macro assembler, and a debugging utility which must be the finest available anywhere for the Z-80 microprocessor. The system also runs under North Star DOS.
Loeliger clearly had no idea how to write arithmetic routines - particularly division - so I borrowed some very neat arithmetic from Tiny Basic. I also changed many routines to comply with popular Forth practice and added some of the features of Stackworks SL5.</p>
<p>I would not advise anyone with a faint heart to tackle the same task but one advantage of being left completely at sea is that you are forced to understand fully what you are doing. The final result of all these labours is an implementation of Forth in true Z-80 language, using all the Z-80 registers.  </p>
<p>It runs twice as fast as Stackworks Forth performing the quick test in 0.4 seconds - 20 times faster than North Star Basic. Disc access is also quicker between two and three times faster than CP/M SL5. On top of all that, the editor - which is Allen Ashley&#39;s text editor from the PDS development system Forth, DOS and a machine-code monitor can all be co-resident in the computer at the same time.     </p>
<p>I can build a program in the editor, jump quickly to the threaded interpreter to test it, and then jump straight back into the text editor to make alterations or additions finding the text completely intact and all text pointers in their original positions. </p>
<p>The borderline between the Forth program area and RAM area is clearly defined and the finished, extended Forth program can be saved en bloc on disc and impressed in EPROM at a moment&#39;s notice. </p>
</div></div>



  </div> <!-- end Column_Continer-->
  <!-- Page 92 end -->
  <!-- end Column_Continer-->

  


    <!-- end Column_Continer-->

   

 

     </div><!-- end faux -->
    </div></div>
  </body>
</html>
