<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://digest.browsertech.com/archive/browsertech-digest-figma-is-a-file-editor/">Original</a>
    <h1>Figma Is a File Editor</h1>
    
    <div id="readability-page-1" class="page"><div>

                

                
                    
                        <p>Hey folks, welcome to the digest! Today’s issue is about a pain point developers encounter when shipping desktop-class apps to the browser.</p>
<h2>File editors and database apps</h2>
<p>Most desktop applications are what I call <strong>file editors</strong>.</p>
<p>By file editor, I mean that the user selects a file on disk, and the program loads it into memory. User changes are applied in-memory and periodically saved back to disk.</p>
<p>Most <em>web</em> apps, by contrast, are what I call <strong>database apps</strong>.</p>
<p>Instead of loading a whole file into memory upfront, database apps render views of the data by fetching data from a database as needed to render the UI. When the user makes changes to the data, those changes are persisted back to the database via API calls.</p>
<p>Database apps are a good fit for “<a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a>” tools like calendars, todo lists, and tools with three-letter acronyms containing “manager” (<a href="https://en.wikipedia.org/wiki/Content_management_system" target="_blank">CMS</a>, <a href="https://en.wikipedia.org/wiki/Customer_relationship_management" target="_blank">CRM</a>, <a href="https://en.wikipedia.org/wiki/Product_information_management" target="_blank">PIM</a>).</p>
<p>One of the challenges of writing desktop-class software that runs in the browser is that file editors do not translate as naturally to the architecture of the web as database apps do.</p>
<p>To understand why these apps work differently, let&#39;s look at one.</p>
<h2>Figma is a file editor</h2>
<p>The design tool <a href="https://figma.com" target="_blank">Figma</a> is a good example of a file editor that runs in the browser.</p>
<p>When you open a Figma design, your browser downloads (over WebSocket) a “Fig file” corresponding to that design. The file contains binary data serialized with <a href="https://github.com/evanw/kiwi/tree/master" target="_blank">kiwi</a>. Kiwi is a binary format similar to Google’s <a href="https://en.wikipedia.org/wiki/Protocol_Buffers" target="_blank">Protobuf</a>, open-sourced by former Figma CTO Evan Wallace.</p>
<p>You can think of a kiwi file essentially as compressed JSON. Officially, the kiwi schema used by Figma is <a href="https://forum.figma.com/t/inquiry-about-the-fig-file-format/6351/2" target="_blank">undocumented</a>, but there have been some <a href="https://github.com/liaobinbin/fig-to-json/tree/main" target="_blank">attempts to reverse-engineer</a> it, and <a href="https://blog.photopea.com/photopea-4-6-open-figma-files.html" target="_blank">at least one third-party tool</a> supports it.</p>
<p>Translated to JSON by a third-party tool, it looks something like this:</p>
<p><img alt="image.png" src="https://buttondown.imgix.net/images/f751c5c0-e72e-4d9f-b855-752ff4a0627d.png?w=960&amp;fit=max"/></p>
<h2>S3 as a filesystem</h2>
<p>Figma persists these Fig files to Amazon S3.</p>
<p>A naive approach would have been for the client to treat S3 like a <a href="https://en.wikipedia.org/wiki/Network_File_System" target="_blank">network file system</a> and use it the same way a desktop app would use its local file system. This would have two problems:</p>
<ul>
<li>The whole file would have to be sent for every change, which is a waste of bandwidth as files get large.</li>
<li>Figma supports multiple concurrent users per document. If every change caused the entire document to be rewritten, race conditions from concurrent edits would cause data loss.</li>
</ul>
<p>Figma avoids both of these problems by taking a <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/" target="_blank">more sophisticated approach</a>. When you open a Fig file, it’s actually loaded in two places: in your browser, and on a server.</p>
<p>Instead of writing back the entire file on each change, clients stream back only the changed data. The server applies those changes to its own in-memory copy to keep it synchronized.</p>
<p>The tricky part is that when multiple users open the same Fig file concurrently, Figma’s infrastructure needs to ensure that they are all connected to the same server. That server can then be the sole authority on the state of that document, and write to it without race conditions.</p>
<h2>Why not use a database?</h2>
<p>Figma <a href="https://www.figma.com/blog/how-figma-scaled-to-multiple-databases/" target="_blank">stores file metadata</a> in a Postgres database. Instead of going to the trouble of using S3 too, they could have also used the database for document data, in one of two ways:</p>
<ol>
<li>They could stuff the whole document into a binary blob or json(b) column next to the metadata.</li>
<li>They could represent the document itself as rows and tables in a relational database.</li>
</ol>
<p>#1 is essentially (ab)using the database as a file system, <a href="https://www.brentozar.com/archive/2021/07/store-files-in-a-file-system-not-a-relational-database/" target="_blank">which is bad</a>.</p>
<p>#2 at least has the aura of using the database <em>as a database</em>, but it adds a bunch of complexity to the application layer, which needs to be able to translate between a document representation in memory and a relational representation in the database.</p>
<p>In either case, another consideration at scale is that S3 can be 10-100x cheaper byte-for-byte than a database. The query capabilities available in a database come at the cost of computational overhead, and it’s a waste to pay that overhead when you have a known, file-like access pattern.</p>
<h2>Durability</h2>
<p>Writing the whole document to S3 is relatively slow, so Figma only does it every 30-60 seconds. But if the system responsible for writing those checkpoints fails (say, the power goes out), Figma doesn’t want to lose 30-60 seconds worth of changes. So they <a href="https://www.figma.com/blog/making-multiplayer-more-reliable/" target="_blank">buffer changes</a> at a higher frequency by saving them to DynamoDB, as a <a href="https://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank">write-ahead log</a>.</p>
<h2>Generalizing Figma’s approach</h2>
<p>This post came out of research we’ve been doing towards building an open-source document database that takes a similar approach.</p>
<p>Recently, we introduced <a href="https://docs.jamsocket.com/locking-a-backend-to-a-resource/" target="_blank">“locking”</a> into Jamsocket and <a href="https://plane.dev/" target="_blank">Plane</a>, which can guarantee that at most one backend runs per document, motivated by desire for a Figma-like data architecture.</p>
<p>If these problems resonate with problems you’ve experienced building browser-based apps, please drop me a line by replying to this email, I’d love to learn more about the problems you’ve encountered.</p>
<p>Until next time,</p>
<p>Paul</p>
                    
                

                
            </div></div>
  </body>
</html>
