<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://anthonynsimon.com/blog/one-man-saas-architecture/">Original</a>
    <h1>The Architecture Behind a One-Person Tech Startup (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>This is a long-form post breaking down the setup I use to run a SaaS. From load balancing to cron job monitoring to payments and subscriptions. There&#39;s a lot of ground to cover, so buckle up!</p>
<p>As grandiose as the title of this article might sound, I should clarify we’re talking about a low-stress, one-person company that I run from my flat. It&#39;s fully self-funded, and I like to take things slow. It&#39;s probably not what most people imagine when I say &#34;tech startup&#34;.</p>
<p>For context, I run a one-man SaaS, and this is a more detailed version of my post on <a href="https://anthonynsimon.com/blog/tech-stack/" rel="noopener">my tech stack</a>. I use Kubernetes on AWS, but don’t fall into the trap of thinking you need this. I learned these tools over several years mentored by a very patient team. These tools work well for me, but they might not be the right fit for you.</p>
<p>By the way, I drew inspiration for the format of this post from <a href="https://www.listennotes.com/blog/the-boring-technology-behind-a-one-person-23/" rel="noopener" target="_blank">Wenbin Fang’s blog post</a>. I really enjoyed reading his article, and you might want to check it out too!</p>
<p>With that said, let&#39;s jump right into the tour.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#a-birds-eye-view" rel="noopener">A bird’s eye view</a></li>
<li><a href="#automatic-dns-ssl-and-load-balancing" rel="noopener">Automatic DNS, SSL, and Load Balancing</a></li>
<li><a href="#automated-rollouts-and-rollbacks" rel="noopener">Automated rollouts and rollbacks</a></li>
<li><a href="#let-it-crash" rel="noopener">Let it crash</a></li>
<li><a href="#horizontal-autoscaling" rel="noopener">Horizontal autoscaling</a></li>
<li><a href="#static-assets-cached-by-cdn" rel="noopener">Static assets cached by CDN</a></li>
<li><a href="#application-data-caching" rel="noopener">Application data caching</a></li>
<li><a href="#per-endpoint-rate-limiting" rel="noopener">Per endpoint rate-limiting</a></li>
<li><a href="#app-administration" rel="noopener">App administration</a></li>
<li><a href="#running-scheduled-jobs" rel="noopener">Running scheduled jobs</a></li>
<li><a href="#app-configuration" rel="noopener">App configuration</a></li>
<li><a href="#keeping-secrets" rel="noopener">Keeping secrets</a></li>
<li><a href="#relational-data-postgres" rel="noopener">Relational data: Postgres</a></li>
<li><a href="#columnar-data-clickhouse" rel="noopener">Columnar data: ClickHouse</a></li>
<li><a href="#dns-based-service-discovery" rel="noopener">DNS-based service discovery</a></li>
<li><a href="#version-controlled-infrastructure" rel="noopener">Version-controlled infrastructure</a></li>
<li><a href="#terraform-for-cloud-resources" rel="noopener">Terraform for cloud resources</a></li>
<li><a href="#kubernetes-manifests-for-app-deployments" rel="noopener">Kubernetes manifests for app deployments</a></li>
<li><a href="#subscriptions-and-payments" rel="noopener">Subscriptions and Payments</a></li>
<li><a href="#logging" rel="noopener">Logging</a></li>
<li><a href="#monitoring-and-alerting" rel="noopener">Monitoring and alerting</a></li>
<li><a href="#error-tracking" rel="noopener">Error tracking</a></li>
<li><a href="#profiling-and-other-goodies" rel="noopener">Profiling and other goodies</a></li>
<li><a href="#thats-all-folks" rel="noopener">That&#39;s all folks</a></li>
</ul>
<h2 id="a-birds-eye-view">A bird’s eye view</h2>
<p>My infrastructure handles multiple projects at once, but to illustrate things I’ll use my most recent SaaS, a <a href="https://panelbear.com/" rel="noopener" target="_blank">web performance and traffic analytics tool</a>, as a real-world example of this setup in action.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-performance-chart.png" alt="Panelbear&#39;s performance monitoring feature" width="100%" height="auto" loading="lazy"/></span>
<em>Browser Timings chart in Panelbear, the example project I&#39;ll use for this tour.</em></p>
<p>From a technical point of view, this SaaS processes a large amount of requests per second from anywhere in the world, and stores the data in an efficient format for real time querying.</p>
<p>Business-wise it&#39;s still in its infancy (<del>I launched six months ago</del> update: it&#39;s been <a href="https://anthonynsimon.com/blog/panelbear-and-cronitor" rel="noopener">acquired</a>), but it has grown rather quickly for my own expectations, especially as I originally built it for myself as a Django app using SQLite on a single tiny VPS. For my goals at the time, it worked just fine and I could have probably pushed that model quite far.</p>
<p>However, I grew increasingly frustrated having to reimplement a lot of the tooling I was so accustomed to: zero downtime deploys, autoscaling, health checks, automatic DNS / TLS / ingress rules, and so on. Kubernetes spoiled me, I was used to dealing with higher level abstractions, while retaining control and flexibility.</p>
<p>Fast forward six months, a couple of iterations, and even though my current setup is still a Django monolith, I&#39;m now using Postgres as the app DB, ClickHouse for analytics data, and Redis for caching. I also use Celery for scheduled tasks, and a custom event queue for buffering writes. I run most of these things on a managed Kubernetes cluster (EKS).</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/one-man-saas-architecture.png" alt="SaaS AWS architecture diagram" width="100%" height="auto" loading="lazy"/></span>
<em>A high-level overview of the architecture.</em></p>
<p>It may sound complicated, but it&#39;s practically an old-school monolithic architecture running on Kubernetes. Replace Django with Rails or Laravel and you know what I&#39;m talking about. The interesting part is how everything is glued together and automated: autoscaling, ingress, TLS certificates, failover, logging, monitoring, and so on.</p>
<p>It&#39;s worth noting I use this setup across multiple projects, which helps keep my costs down and launch experiments really easily (write a Dockerfile and git push). And since I get asked this a lot: contrary to what you might be thinking, I actually spend very little time managing the infrastructure, usually 0-2 hours per month total. Most of my time is spent developing features, doing customer support, and growing the business.</p>
<p>That said, these are the tools I’ve been using for several years now and I’m pretty familiar with them. I consider my setup simple for what it’s capable of, but it took many years of production fires at my day job to get here. So I won’t say it’s all sunshine and roses.</p>
<p>I don&#39;t know who said it first, but what I tell my friends is: &#34;Kubernetes makes the simple stuff complex, but it also makes the complex stuff simpler&#34;.</p>
<h2 id="automatic-dns-ssl-and-load-balancing">Automatic DNS, SSL, and Load Balancing</h2>
<p>Now that you know I have a managed Kubernetes cluster on AWS and I run various projects in it, let&#39;s make the first stop of the tour: how to get traffic into the cluster.</p>
<p>My cluster is in a private network, so you won’t be able to reach it directly from the public internet. There’s a couple of pieces in between that control access and load balance traffic to the cluster.</p>
<p>Essentially, I have Cloudflare proxying all traffic to an NLB (AWS L4 Network Load Balancer). This Load Balancer is the bridge between the public internet and my private network. Once it receives a request, it forwards it to one of the Kubernetes cluster nodes. These nodes are in private subnets spread across multiple availability zones in AWS. It&#39;s all managed by the way, but more on that later.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/cloudflare-aws-ingress-kubernetes.png" alt="SaaS ingress diagram" width="100%" height="auto" loading="lazy"/></span>
<em>Traffic gets cached at the edge, or forwarded to the AWS region where I operate.</em></p>
<p>&#34;But how does Kubernetes know which service to forward the request to?&#34; - That’s where <a href="https://github.com/kubernetes/ingress-nginx" rel="noopener" target="_blank">ingress-nginx</a> comes in. In short: it&#39;s an NGINX cluster managed by Kubernetes, and it&#39;s the entrypoint for all traffic inside the cluster.</p>
<p>NGINX applies rate-limiting and other traffic shaping rules I define before sending the request to the corresponding app container. In Panelbear’s case, the app container is Django being served by <a href="https://www.uvicorn.org/" rel="noopener" target="_blank">Uvicorn</a>.</p>
<p>It&#39;s not much different from a traditional nginx/gunicorn/Django in a VPS approach, with added horizontal scaling benefits and an automated CDN setup. It’s also a “setup once and forget” kind of thing, mostly a few files between Terraform/Kubernetes, and it’s shared by all deployed projects.</p>
<p>When I deploy a new project, it’s essentially 20 lines of ingress configuration and that’s it:</p>
<pre><div><pre><code><span>apiVersion</span><span>:</span><span> networking.k8s.io/v1beta1
</span><span></span><span>kind</span><span>:</span><span> Ingress
</span><span></span><span>metadata</span><span>:</span><span>
</span><span> </span><span>namespace</span><span>:</span><span> example
</span><span> </span><span>name</span><span>:</span><span> example</span><span>-</span><span>api
</span><span></span><span>annotations</span><span>:</span><span>
</span><span> </span><span>kubernetes.io/ingress.class</span><span>:</span><span> </span><span>&#34;nginx&#34;</span><span>
</span><span> </span><span>nginx.ingress.kubernetes.io/limit-rpm</span><span>:</span><span> </span><span>&#34;5000&#34;</span><span>
</span><span> </span><span>cert-manager.io/cluster-issuer</span><span>:</span><span> </span><span>&#34;letsencrypt-prod&#34;</span><span>
</span><span> </span><span>external-dns.alpha.kubernetes.io/cloudflare-proxied</span><span>:</span><span> </span><span>&#34;true&#34;</span><span>
</span><span></span><span>spec</span><span>:</span><span>
</span><span></span><span>tls</span><span>:</span><span>
</span><span></span><span>-</span><span> </span><span>hosts</span><span>:</span><span>
</span><span>   </span><span>-</span><span> api.example.com
</span><span> </span><span>secretName</span><span>:</span><span> example</span><span>-</span><span>api</span><span>-</span><span>tls
</span><span></span><span>rules</span><span>:</span><span>
</span><span></span><span>-</span><span> </span><span>host</span><span>:</span><span> api.example.com
</span><span> </span><span>http</span><span>:</span><span>
</span><span>   </span><span>paths</span><span>:</span><span>
</span><span>     </span><span>-</span><span> </span><span>path</span><span>:</span><span> /
</span><span>       </span><span>backend</span><span>:</span><span>
</span><span>         </span><span>serviceName</span><span>:</span><span> example</span><span>-</span><span>api
</span><span>         </span><span>servicePort</span><span>:</span><span> http</span></code></pre></div></pre>
<p>Those annotations describe that I want a DNS record, with traffic proxied by Cloudflare, a TLS certificate via letsencrypt, and that it should rate-limit the requests per minute by IP before forwarding the request to my app.</p>
<p>Kubernetes takes care of making those infra changes to reflect the desired state. It’s a little verbose, but it works well in practice.</p>
<h2 id="automated-rollouts-and-rollbacks">Automated rollouts and rollbacks</h2>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/ci-pipeline.png" alt="GitOps CI pipeline" width="100%" height="auto" loading="lazy"/></span>
<em>The chain of actions that occur when I push a new commit.</em></p>
<p>Whenever I push to master one of my projects, it kicks off a CI pipeline on GitHub Actions. This pipeline runs some codebase checks, end-to-end tests (using Docker compose to setup a complete environment), and once these checks pass it builds a new Docker image that gets pushed to ECR (the Docker registry in AWS).</p>
<p>As far as the application repo is concerned, a new version of the app has been tested and is ready to be deployed as a Docker image:</p>
<pre><div><pre><code><span>panelbear/panelbear-webserver:6a54bb3</span></code></pre></div></pre>
<p>&#34;So what happens next? There’s a new Docker image, but no deploy?&#34; - My Kubernetes cluster has a component called <a href="https://fluxcd.io/" rel="noopener" target="_blank">flux</a>. It automatically keeps in sync what is currently running in the cluster and the latest image for my apps.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/flux-autorelease.png" alt="Fluxcd release commit" width="100%" height="auto" loading="lazy"/></span>
<em>Flux automatically keeps track of new releases in my infrastructure monorepo.</em></p>
<p>Flux automatically triggers an incremental rollout when there’s a new Docker image available, and keeps record of these actions in an &#34;Infrastructure Monorepo&#34;.</p>
<p>I want version controlled infrastructure, so that whenever I make a new commit on this repo, between Terraform and Kubernetes, they will make the necessary changes on AWS, Cloudflare and the other services to synchronize the state of my repo with what is deployed.</p>
<p>It’s all version-controlled with a linear history of every deployment made. This means less stuff for me to remember over the years, since I have no magic settings configured via clicky-clicky on some obscure UI.</p>
<p>Think of this monorepo as deployable documentation, but more on that later.</p>
<h2 id="let-it-crash">Let it crash</h2>
<p>A few years ago I used the Actor model of concurrency for various company projects, and fell in love with many of the ideas around its ecosystem. One thing led to another and soon I was reading books about Erlang, and its philosophy around <a href="https://stackoverflow.com/questions/4393197/erlangs-let-it-crash-philosophy-applicable-elsewhere" rel="noopener" target="_blank">letting things crash</a>.</p>
<p>I might be stretching the idea too much, but in Kubernetes I like to think of liveliness probes and automatic restarts as a means to achieve a similar effect.</p>
<p>From the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener" target="_blank">Kubernetes documentation</a>:
“The kubelet uses liveness probes to know when to restart a container. For example, liveness probes could catch a deadlock, where an application is running, but unable to make progress. Restarting a container in such a state can help to make the application more available despite bugs.”</p>
<p>In practice this has worked pretty well for me. Containers and nodes are meant to come and go, and Kubernetes will gracefully shift the traffic to healthy pods while healing the unhealthy ones (more like killing). Brutal, but effective.</p>
<h2 id="horizontal-autoscaling">Horizontal autoscaling</h2>
<p>My app containers auto-scale based on CPU/Memory usage. Kubernetes will try to pack as many workloads per node as possible to fully utilize it.</p>
<p>In case there’s too many Pods per node in the cluster, it will automatically spawn more servers to increase the cluster capacity and ease the load. Similarly, it will scale down when there’s not much going on.</p>
<p>Here’s what a Horizontal Pod Autoscaler might look like:</p>
<pre><div><pre><code><span>apiVersion</span><span>:</span><span> autoscaling/v1
</span><span></span><span>kind</span><span>:</span><span> HorizontalPodAutoscaler
</span><span></span><span>metadata</span><span>:</span><span>
</span><span> </span><span>name</span><span>:</span><span> panelbear</span><span>-</span><span>api
</span><span> </span><span>namespace</span><span>:</span><span> panelbear
</span><span></span><span>spec</span><span>:</span><span>
</span><span> </span><span>scaleTargetRef</span><span>:</span><span>
</span><span>   </span><span>apiVersion</span><span>:</span><span> apps/v1
</span><span>   </span><span>kind</span><span>:</span><span> Deployment
</span><span>   </span><span>name</span><span>:</span><span> panelbear</span><span>-</span><span>api
</span><span> </span><span>minReplicas</span><span>:</span><span> </span><span>2</span><span>
</span><span> </span><span>maxReplicas</span><span>:</span><span> </span><span>8</span><span>
</span><span> </span><span>targetCPUUtilizationPercentage</span><span>:</span><span> </span><span>50</span></code></pre></div></pre>
<p>In this example, it will automatically adjust the number of <code>panelbear-api</code> pods based on the CPU usage, starting at 2 replicas but capping at 8.</p>
<h2 id="static-assets-cached-by-cdn">Static assets cached by CDN</h2>
<p>When defining the ingress rules for my app, the annotation <code>cloudflare-proxied: &#34;true&#34;</code> is what tells the Kubernetes that I want to use Cloudflare for DNS, and to proxy all requests via it’s CDN and DDoS protection too.</p>
<p>From then on, it’s pretty easy to make use of it. I just set standard HTTP cache headers in my applications to specify which requests can be cached, and for how long.</p>
<pre><div><pre><code><span># Cache this response for 5 minutes</span><span>
</span><span>response</span><span>[</span><span>&#34;Cache-Control&#34;</span><span>]</span><span> </span><span>=</span><span> </span><span>&#34;public, max-age=300&#34;</span></code></pre></div></pre>
<p>Cloudflare will use those response headers to control the caching behavior at the edge servers. It works amazingly well for such a simple setup.</p>
<p>I use <a href="https://github.com/evansd/whitenoise" rel="noopener" target="_blank">Whitenoise</a> to serve static files directly from my app container. That way I avoid needing to upload static files to Nginx/Cloudfront/S3 on each deployment. It has worked really well so far, and most requests will get cached by the CDN as it gets filled. It&#39;s performant, and keeps things simple.</p>
<p>I also use NextJS for a few static websites, such as the landing page of <a href="http://panelbear.com/" rel="noopener" target="_blank">Panelbear</a>. I could serve it via Cloudfront/S3 or even Netlify or Vercel, but it was easy to just run it as a container in my cluster and let Cloudflare cache the static assets as they are being requested. There’s zero added cost for me to do this, and I can re-use all tooling for deployment, logging and monitoring.</p>
<h2 id="application-data-caching">Application data caching</h2>
<p>Besides static file caching, there&#39;s also application data caching (eg. results of heavy calculations, Django models, rate-limiting counters, etc...).</p>
<p>On one hand I leverage an in-memory <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noopener" target="_blank">Least Recently Used (LRU) cache</a> to keep frequently accessed objects in memory, and I’d benefit from zero network calls (pure Python, no Redis involved).</p>
<p>However, most endpoints just use the in-cluster Redis for caching. It&#39;s still fast and the cached data can be shared by all Django instances, even after re-deploys, while an in-memory cache would get wiped.</p>
<p>Here&#39;s a real-world example:</p>
<p>My Pricing Plans are based on analytics events per month. For this some sort of metering is necessary to know how many events have been consumed within the current billing period and enforce limits. However, I don&#39;t interrupt the service immediately when a customer crosses the limit. Instead a &#34;Capacity depleted&#34; email is automatically sent, and a grace period is given to the customer before the API starts rejecting new data.</p>
<p>This is meant to give customers enough time to decide if an upgrade makes sense for them, while ensuring no data is lost. For example during a traffic spike in case their content goes viral or if they&#39;re just enjoying the weekend and not checking their emails. If the customer decides to stay in the current plan and not upgrade, there is no penalty and things will go back to normal once usage is back within their plan limits.</p>
<p>So for this feature I have a function that applies the rules above, which require several calls to the DB and ClickHouse, but get cached 15 minutes to avoid recomputing this on every request. It&#39;s good enough and simple. Worth noting: the cache gets invalidated on plan changes, otherwise it might take 15 minutes for an upgrade to take effect.</p>
<pre><div><pre><code><span>@cache</span><span>(</span><span>ttl</span><span>=</span><span>60</span><span> </span><span>*</span><span> </span><span>15</span><span>)</span><span>
</span><span></span><span>def</span><span> </span><span>has_enough_capacity</span><span>(</span><span>site</span><span>:</span><span> Site</span><span>)</span><span> </span><span>-</span><span>&gt;</span><span> </span><span>bool</span><span>:</span><span>
</span><span> </span><span>&#34;&#34;&#34;
</span><span> Returns True if a Site has enough capacity to accept incoming events,
</span><span> or False if it already went over the plan limits, and the grace period is over.
</span><span> &#34;&#34;&#34;</span></code></pre></div></pre>
<h2 id="per-endpoint-rate-limiting">Per endpoint rate-limiting</h2>
<p>While I enforce global rate limits at the nginx-ingress on Kubernetes, I sometimes want more specific limits on a per endpoint/method basis.</p>
<p>For that I use the excellent <a href="https://django-ratelimit.readthedocs.io/en/stable/" rel="noopener" target="_blank">Django Ratelimit</a> library to easily declare the limits per Django view. It&#39;s configured to use Redis as a backend for keeping track of the clients making the requests to each endpoint (it stores a hash based on the client key, and not the IP).</p>
<p>For example:</p>
<pre><div><pre><code><span>class</span><span> </span><span>MySensitiveActionView</span><span>(</span><span>RatelimitMixin</span><span>,</span><span> LoginRequiredMixin</span><span>)</span><span>:</span><span>
</span><span> ratelimit_key </span><span>=</span><span> </span><span>&#34;user_or_ip&#34;</span><span>
</span><span> ratelimit_rate </span><span>=</span><span> </span><span>&#34;5/m&#34;</span><span>
</span><span> ratelimit_method </span><span>=</span><span> </span><span>&#34;POST&#34;</span><span>
</span><span> ratelimit_block </span><span>=</span><span> </span><span>True</span><span>
</span>
<span> </span><span>def</span><span> </span><span>get</span><span>(</span><span>)</span><span>:</span><span>
</span><span>   </span><span>.</span><span>.</span><span>.</span><span>
</span>
<span> </span><span>def</span><span> </span><span>post</span><span>(</span><span>)</span><span>:</span><span>
</span><span>   </span><span>.</span><span>.</span><span>.</span></code></pre></div></pre>
<p>In the example above, if the client attempts to POST to this particular endpoint more than 5 times per minute, the subsequent call will get rejected with a <code>HTTP 429 Too Many Requests</code> status code.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-rate-limited.png" alt="Rate limited HTTP error" width="100%" height="auto" loading="lazy"/></span>
<em>The friendly error message you&#39;d get when being rate-limited.</em></p>
<h2 id="app-administration">App administration</h2>
<p>Django gives me an admin panel for all my models for free. It’s built-in, and It’s pretty handy for inspecting data for customer support work on the go.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-staff.png" alt="Django admin panel" width="100%" height="auto" loading="lazy"/></span>
<em>Django&#39;s built-in admin panel is very useful for doing customer support on the go.</em></p>
<p>I added actions to help me manage things from the UI. Things like blocking access to suspicious accounts, sending out announcement emails, and approving full account deletion requests (first a soft delete, and within 72 hours a full destroy).</p>
<p>Security-wise: only staff users are able to access the panel (me), and I’m planning to add 2FA for extra security on all accounts.</p>
<p>Additionally every time a user logs in, I send an automatic security email with details about the new session to the account’s email. Right now I send it on every new login, but I might change it in the future to skip known devices. It’s not a very “MVP feature”, but I care about security and it was not complicated to add. At least I’d be warned if someone logged in to my account.</p>
<p>Of course, there&#39;s a lot more to hardening an application than this, but that&#39;s out of the scope of this post.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-security-email.png" alt="Panelbear security email notification" width="100%" height="auto" loading="lazy"/></span>
<em>Example security activity email you might receive when logging in.</em></p>
<h2 id="running-scheduled-jobs">Running scheduled jobs</h2>
<p>Another interesting use case is that I run a lot of different scheduled jobs as part of my SaaS. These are things like generating daily reports for my customers, calculating usage stats every 15 minutes, sending staff emails (I get a daily email with the most important metrics) and whatnot.</p>
<p>My setup is actually pretty simple, I just have a few Celery workers and a Celery beat scheduler running in the cluster. They are configured to use Redis as the task queue. It took me an afternoon to set it up once, and luckily I haven’t had any issues so far.</p>
<p>I want to get notified via SMS/Slack/Email when a scheduled task is not running as expected. For example when the weekly reports task is stuck or significantly delayed. For that I use <a href="https://cronitor.io/" rel="noopener" target="_blank">Cronitor.io</a>.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/cron-job-monitoring.png" alt="Cronitor.io cron job monitoring dashboard" width="100%" height="auto" loading="lazy"/></span>
<em>The cron job monitoring dashboard from Cronitor.io</em></p>
<p>The <a href="https://github.com/cronitorio/cronitor-python" rel="noopener" target="_blank">celery monitoring integration</a> makes it super easy to instrument my scheduled tasks:</p>
<pre><div><pre><code><span># Auto-discovers celery beat tasks</span><span>
</span>
<span></span><span>import</span><span> cronitor</span><span>.</span><span>celery
</span><span></span><span>from</span><span> celery </span><span>import</span><span> Celery
</span>
<span>app </span><span>=</span><span> Celery</span><span>(</span><span>)</span><span>
</span><span>cronitor</span><span>.</span><span>celery</span><span>.</span><span>initialize</span><span>(</span><span>app</span><span>,</span><span> api_key</span><span>=</span><span>&#34;super-secret&#34;</span><span>,</span><span> celerybeat_only</span><span>=</span><span>True</span><span>)</span></code></pre></div></pre>
<h2 id="app-configuration">App configuration</h2>
<p>All my applications are configured via environment variables, old school but portable and well supported. For example, in my Django <code>settings.py</code> I’d setup a variable with a default value:</p>
<pre><div><pre><code><span>INVITE_ONLY </span><span>=</span><span> env</span><span>.</span><span>str</span><span>(</span><span>&#34;INVITE_ONLY&#34;</span><span>,</span><span> default</span><span>=</span><span>False</span><span>)</span></code></pre></div></pre>
<p>And use it anywhere in my code like this:</p>
<pre><div><pre><code><span>from</span><span> django</span><span>.</span><span>conf </span><span>import</span><span> settings
</span>
<span></span><span># If invite-only, then disable account creation endpoints</span><span>
</span><span></span><span>if</span><span> settings</span><span>.</span><span>INVITE_ONLY</span><span>:</span><span>
</span><span> </span><span>.</span><span>.</span><span>.</span></code></pre></div></pre>
<p>I can override the environment variable in my Kubernetes <code>configmap</code>:</p>
<pre><div><pre><code><span>apiVersion</span><span>:</span><span> v1
</span><span></span><span>kind</span><span>:</span><span> ConfigMap
</span><span></span><span>metadata</span><span>:</span><span>
</span><span> </span><span>namespace</span><span>:</span><span> panelbear
</span><span> </span><span>name</span><span>:</span><span> panelbear</span><span>-</span><span>webserver</span><span>-</span><span>config
</span><span></span><span>data</span><span>:</span><span>
</span><span> </span><span>INVITE_ONLY</span><span>:</span><span> </span><span>&#34;True&#34;</span><span>
</span><span> </span><span>DEFAULT_FROM_EMAIL</span><span>:</span><span> </span><span>&#34;The Panelbear Team &lt;support@panelbear.com&gt;&#34;</span><span>
</span><span> </span><span>SESSION_COOKIE_SECURE</span><span>:</span><span> </span><span>&#34;True&#34;</span><span>
</span><span> </span><span>SECURE_HSTS_PRELOAD</span><span>:</span><span> </span><span>&#34;True&#34;</span><span>
</span><span> </span><span>SECURE_SSL_REDIRECT</span><span>:</span><span> </span><span>&#34;True&#34;</span></code></pre></div></pre>
<h2 id="keeping-secrets">Keeping secrets</h2>
<p>The way secrets are handled is pretty interesting: I want to also commit them to my infrastructure repo, alongside other config files, but secrets should be encrypted.</p>
<p>For that I use <a href="https://github.com/bitnami-labs/sealed-secrets" rel="noopener" target="_blank">kubeseal</a> in Kubernetes. This component uses asymmetric crypto to encrypt my secrets, and only a cluster authorized to access the decryption keys can decrypt them.</p>
<p>For example this is what you might find in my infrastructure repo:</p>
<pre><div><pre><code><span>apiVersion</span><span>:</span><span> bitnami.com/v1alpha1
</span><span></span><span>kind</span><span>:</span><span> SealedSecret
</span><span></span><span>metadata</span><span>:</span><span>
</span><span> </span><span>name</span><span>:</span><span> panelbear</span><span>-</span><span>secrets
</span><span> </span><span>namespace</span><span>:</span><span> panelbear
</span><span></span><span>spec</span><span>:</span><span>
</span><span> </span><span>encryptedData</span><span>:</span><span>
</span><span>   </span><span>DATABASE_CONN_URL</span><span>:</span><span> AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq</span><span>...</span><span>
</span><span>   </span><span>SESSION_COOKIE_SECRET</span><span>:</span><span> oi7ySY1ZA9rO43cGDEq+ygByri4OJBlK</span><span>...</span><span>
</span><span>   </span><span>...</span></code></pre></div></pre>
<p>The cluster will automatically decrypt the secrets and pass them to the corresponding container as an environment variable:</p>
<pre><div><pre><code><span>DATABASE_CONN_URL</span><span>=</span><span>&#39;postgres://user:pass@my-rds-db:5432/db&#39;</span><span>
</span><span>SESSION_COOKIE_SECRET</span><span>=</span><span>&#39;this-is-supposed-to-be-very-secret&#39;</span></code></pre></div></pre>
<p>To protect the secrets within the cluster, I use AWS-managed encryption keys via <a href="https://aws.amazon.com/kms/" rel="noopener" target="_blank">KMS</a>, which are rotated regularly. This is a single setting when creating the Kubernetes cluster, and it&#39;s fully managed.</p>
<p>Operationally what this means is that I write the secrets as environment variables in a Kubernetes manifest, I then run a command to encrypt them before committing, and push my changes.</p>
<p>The secrets are deployed within a few seconds, and the cluster will take care of automatically decrypting them before running my containers.</p>
<h2 id="relational-data-postgres">Relational data: Postgres</h2>
<p>For experiments I run a vanilla Postgres container within the cluster, and a Kubernetes cronjob that does daily backups to S3. This helps keep my costs down, and it’s pretty simple for just starting out.</p>
<p>However, as a project grows, like Panelbear, I move the database out of the cluster into RDS, and let AWS take care of encrypted backups, security updates and all the other stuff that’s no fun to mess up.</p>
<p>For added security, the databases managed by AWS are still deployed within my private network, so they’re unreachable via the public internet.</p>
<h2 id="columnar-data-clickhouse">Columnar data: ClickHouse</h2>
<p>I rely on <a href="https://clickhouse.tech/" rel="noopener" target="_blank">ClickHouse</a> for efficient storage and (soft) real-time queries over the analytics data in Panelbear. It’s a fantastic columnar database, incredibly fast and when you structure your data well you can achieve high compression ratios (less storage costs = higher margins).</p>
<p>I currently self-host a ClickHouse instance within my Kubernetes cluster. I use a StatefulSet with encrypted volume keys managed by AWS. I have a Kubernetes CronJob that periodically backups up all data in an efficient columnar format to S3. In case of disaster recovery, I have a couple of scripts to manually backup and restore the data from S3.</p>
<p>ClickHouse has been rock-solid so far, and it’s an impressive piece of software. It’s the only tool I wasn’t already familiar with when I started my SaaS, but thanks to their docs I was able to get up and running pretty quickly.</p>
<p>I think there’s a lot of low hanging fruit in case I wanted to squeeze out even more performance (eg. optimizing the field types for better compression, pre-computing materialized tables and tuning the instance type), but it’s good enough for now.</p>
<h2 id="dns-based-service-discovery">DNS-based service discovery</h2>
<p>Besides Django, I also run containers for Redis, ClickHouse, NextJS, among other things. These containers have to talk to each other somehow, and that somehow is via the built-in service discovery in Kubernetes.</p>
<p>It’s pretty simple: I define a Service resource for the container and Kubernetes automatically manages DNS records within the cluster to route traffic to the corresponding service.</p>
<p>For example, given a Redis service exposed within the cluster:</p>
<pre><div><pre><code><span>apiVersion</span><span>:</span><span> v1
</span><span></span><span>kind</span><span>:</span><span> Service
</span><span></span><span>metadata</span><span>:</span><span>
</span><span> </span><span>name</span><span>:</span><span> redis
</span><span> </span><span>namespace</span><span>:</span><span> weekend</span><span>-</span><span>project
</span><span></span><span>labels</span><span>:</span><span>
</span><span> </span><span>app</span><span>:</span><span> redis
</span><span></span><span>spec</span><span>:</span><span>
</span><span> </span><span>type</span><span>:</span><span> ClusterIP
</span><span> </span><span>ports</span><span>:</span><span>
</span><span>   </span><span>-</span><span> </span><span>port</span><span>:</span><span> </span><span>6379</span><span>
</span><span> </span><span>selector</span><span>:</span><span>
</span><span>   </span><span>app</span><span>:</span><span> redis</span></code></pre></div></pre>
<p>I can access this Redis instance anywhere from my cluster via the following URL:</p>
<pre><div><pre><code><span>redis://redis.weekend-project.svc.cluster:6379</span></code></pre></div></pre>
<p>Notice the service name and the project namespace is part of the URL. That makes it really easy for all your cluster services to talk to each other, regardless of where in the cluster they run.</p>
<p>For example, here’s how I’d configure Django via environment variables to use my in-cluster Redis:</p>
<pre><div><pre><code><span>apiVersion</span><span>:</span><span> v1
</span><span></span><span>kind</span><span>:</span><span> ConfigMap
</span><span></span><span>metadata</span><span>:</span><span>
</span><span> </span><span>name</span><span>:</span><span> panelbear</span><span>-</span><span>config
</span><span> </span><span>namespace</span><span>:</span><span> panelbear
</span><span></span><span>data</span><span>:</span><span>
</span><span> </span><span>CACHE_URL</span><span>:</span><span> </span><span>&#34;redis://redis.panelbear.svc.cluster:6379/0&#34;</span><span>
</span><span> </span><span>ENV</span><span>:</span><span> </span><span>&#34;production&#34;</span><span>
</span><span> </span><span>...</span></code></pre></div></pre>
<p>Kubernetes will automatically keep the DNS records in-sync with healthy pods, even as containers get moved across nodes during autoscaling. The way this works behind the scenes is pretty interesting, but out of the scope of this post. <a href="https://medium.com/google-cloud/understanding-kubernetes-networking-services-f0cb48e4cc82" rel="noopener" target="_blank">Here’s a good explanation</a> in case you find it interesting.</p>
<h2 id="version-controlled-infrastructure">Version-controlled infrastructure</h2>
<p>I want version-controlled, reproducible infrastructure that I can create and destroy with a few simple commands.</p>
<p>To achieve this, I use Docker, Terraform and Kubernetes manifests in a monorepo that contains all-things infrastructure, even across multiple projects. And for each application/project I use a separate git repo, but this code is not aware of the environment it will run on.</p>
<p>If you’re familiar with <a href="https://12factor.net/" rel="noopener" target="_blank">The Twelve-Factor App</a> this separation may ring a bell or two. Essentially, my application has no knowledge of the exact infrastructure it will run on, and is configured via environment variables.</p>
<p>By describing my infrastructure in a git repo, I don’t need to keep track of every little resource and configuration setting in some obscure UI. This enables me to restore my entire stack with a single command in case of disaster recovery.</p>
<p>Here’s an example folder structure of what you might find on the infra monorepo:</p>
<pre><div><pre><code><span># Cloud resources
</span>terraform/
<!-- -->aws/
<!-- --> rds.tf
<!-- --> ecr.tf
<!-- --> eks.tf
<!-- --> lambda.tf
<!-- --> s3.tf
<!-- --> roles.tf
<!-- --> vpc.tf
<!-- -->cloudflare/
<!-- --> projects.tf
<!-- -->
<!-- --># Kubernetes manifests
<!-- -->manifests/
<!-- --> cluster/
<!-- -->   ingress-nginx/
<!-- -->   external-dns/
<!-- -->   certmanager/
<!-- -->   monitoring/
<!-- -->
<!-- --> apps/
<!-- -->   panelbear/
<!-- -->     webserver.yaml
<!-- -->     celery-scheduler.yaml
<!-- -->     celery-workers.yaml
<!-- -->     secrets.encrypted.yaml
<!-- -->     ingress.yaml
<!-- -->     redis.yaml
<!-- -->     clickhouse.yaml
<!-- -->   another-saas/
<!-- -->   my-weekend-project/
<!-- -->   some-ghost-blog/
<!-- -->
<!-- --># Python scripts for disaster recovery, and CI
<!-- -->tasks/
<!-- --> ...
<!-- -->
<!-- --># In case of a fire, some help for future me
<!-- -->README.md
<!-- -->DISASTER.md
<!-- -->TROUBLESHOOTING.md</code></pre></div></pre>
<p>Another advantage of this setup is that all the moving pieces are described in one place. I can configure and manage reusable components like centralized logging, application monitoring, and encrypted secrets to name a few.</p>
<h2 id="terraform-for-cloud-resources">Terraform for cloud resources</h2>
<p>I use <a href="https://www.terraform.io/" rel="noopener" target="_blank">Terraform</a> to manage most of the underlying cloud resources. This helps me document, and keep track of the resources and configuration that makes up my infrastructure. In case of disaster recovery, I can spin up and rollback resources with a single command.</p>
<p>For example, here&#39;s one of my Terraform files for creating a private S3 bucket for encrypted backups which expire after 30 days:</p>
<pre><div><pre><code><span>resource </span><span>&#34;aws_s3_bucket&#34;</span><span> </span><span>&#34;panelbear_app&#34;</span><span> </span><span>{</span><span>
</span><span> bucket </span><span>=</span><span> </span><span>&#34;panelbear-app&#34;</span><span>
</span><span> acl    </span><span>=</span><span> </span><span>&#34;private&#34;</span><span>
</span>
<span> tags </span><span>=</span><span> </span><span>{</span><span>
</span><span>   </span><span>Name</span><span>        </span><span>=</span><span> </span><span>&#34;panelbear-app&#34;</span><span>
</span><span>   </span><span>Environment</span><span> </span><span>=</span><span> </span><span>&#34;production&#34;</span><span>
</span><span> </span><span>}</span><span>
</span>
<span> lifecycle_rule </span><span>{</span><span>
</span><span>   id      </span><span>=</span><span> </span><span>&#34;backups&#34;</span><span>
</span><span>   enabled </span><span>=</span><span> </span><span>true</span><span>
</span><span>   prefix  </span><span>=</span><span> </span><span>&#34;backups/&#34;</span><span>
</span>
<span>   expiration </span><span>{</span><span>
</span><span>     days </span><span>=</span><span> </span><span>30</span><span>
</span><span>   </span><span>}</span><span>
</span><span> </span><span>}</span><span>
</span>
<span> server_side_encryption_configuration </span><span>{</span><span>
</span><span>   rule </span><span>{</span><span>
</span><span>     apply_server_side_encryption_by_default </span><span>{</span><span>
</span><span>       sse_algorithm     </span><span>=</span><span> </span><span>&#34;AES256&#34;</span><span>
</span><span>     </span><span>}</span><span>
</span><span>   </span><span>}</span><span>
</span><span> </span><span>}</span><span>
</span><span></span><span>}</span></code></pre></div></pre>
<h2 id="kubernetes-manifests-for-app-deployments">Kubernetes manifests for app deployments</h2>
<p>Similarly, all my Kubernetes manifests are described in YAML files in the infrastructure monorepo. I have split them into two directories: <code>cluster</code> and <code>apps</code>.</p>
<p>Inside the <code>cluster</code> directory I describe all cluster-wide services and configuration, things like the nginx-ingress, encrypted secrets, prometheus scrapers, and so on. Essentially the reusable bits.</p>
<p>On the other hand, the <code>apps</code> directory contains one namespace per project, describing what is needed to deploy it (ingress rules, deployments, secrets, volumes, and so on).</p>
<p>One of the cool things about Kubernetes, is that you can customize almost everything about your stack. So for example, if I wanted to use encrypted SSD volumes that can be resized, I could define a new “StorageClass&#39;&#39; in the cluster. Kubernetes and in this case AWS will coordinate and make the magic happen for me. For example:</p>
<pre><div><pre><code><span>apiVersion</span><span>:</span><span> storage.k8s.io/v1
</span><span></span><span>kind</span><span>:</span><span> StorageClass
</span><span></span><span>metadata</span><span>:</span><span>
</span><span> </span><span>name</span><span>:</span><span> encrypted</span><span>-</span><span>ssd
</span><span> </span><span>provisioner</span><span>:</span><span> kubernetes.io/aws</span><span>-</span><span>ebs
</span><span></span><span>parameters</span><span>:</span><span>
</span><span> </span><span>type</span><span>:</span><span> gp2
</span><span> </span><span>encrypted</span><span>:</span><span> </span><span>&#34;true&#34;</span><span>
</span><span> </span><span>reclaimPolicy</span><span>:</span><span> Retain
</span><span> </span><span>allowVolumeExpansion</span><span>:</span><span> </span><span>true</span><span>
</span><span> </span><span>volumeBindingMode</span><span>:</span><span> WaitForFirstConsumer</span></code></pre></div></pre>
<p>I can now go ahead and attach this type of persistent storage for any of my deployments, and Kubernetes will manage the requested resources for me:</p>
<pre><div><pre><code><span># Somewhere in the ClickHouse StatefulSet configuration</span><span>
</span><span></span><span>...</span><span>
</span><span></span><span>storageClassName</span><span>:</span><span> encrypted</span><span>-</span><span>ssd
</span><span></span><span>resources</span><span>:</span><span>
</span><span> </span><span>requests</span><span>:</span><span>
</span><span>   </span><span>storage</span><span>:</span><span> 250Gi
</span><span></span><span>...</span></code></pre></div></pre>
<h2 id="subscriptions-and-payments">Subscriptions and Payments</h2>
<p>I use <a href="https://stripe.com/payments/checkout" rel="noopener" target="_blank">Stripe Checkout</a> to save all the work in handling payments, creating checkout screens, handling 3D secure requirements from credit cards, and even the customer billing portal.</p>
<p>I do not have access to the payment information itself, which is a huge relief and enables me to focus on my product instead of highly sensitive topics like credit card handling and <a href="https://stripe.com/radar" rel="noopener" target="_blank">fraud prevention</a>.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-billing-portal-stripe.png" alt="Panelbear&#39;s Customer Billing Portal" width="100%" height="auto" loading="lazy"/></span>
<em>An example Customer Billing Portal in Panelbear.</em></p>
<p>All I have to do is create a new customer session and redirect the customer to one of Stripe&#39;s hosted pages. I then listen for webhooks about whether the customer upgraded/downgraded/cancelled and update my database accordingly.</p>
<p>Of course there&#39;s a few important parts like validating that the webhook really came from Stripe (you have to validate the request signature with a secret), but Stripe&#39;s documentation covers all the points really well.</p>
<p>I only have a few plans, so it&#39;s pretty easy for me to manage them in my codebase. I essentially have something like:</p>
<pre><div><pre><code><span># Plan constants</span><span>
</span><span>FREE </span><span>=</span><span> Plan</span><span>(</span><span>
</span><span>  code</span><span>=</span><span>&#39;free&#39;</span><span>,</span><span>
</span><span>  display_name</span><span>=</span><span>&#39;Free Plan&#39;</span><span>,</span><span>
</span><span>  features</span><span>=</span><span>{</span><span>&#39;abc&#39;</span><span>,</span><span> </span><span>&#39;xyz&#39;</span><span>}</span><span>,</span><span>
</span><span>  monthly_usage_limit</span><span>=</span><span>5e3</span><span>,</span><span>
</span><span>  max_alerts</span><span>=</span><span>1</span><span>,</span><span>
</span><span>  stripe_price_id</span><span>=</span><span>&#39;...&#39;</span><span>,</span><span>
</span><span></span><span>)</span><span>
</span>
<span>BASIC </span><span>=</span><span> Plan</span><span>(</span><span>
</span><span>  code</span><span>=</span><span>&#39;basic&#39;</span><span>,</span><span>
</span><span>  display_name</span><span>=</span><span>&#39;Basic Plan&#39;</span><span>,</span><span>
</span><span>  features</span><span>=</span><span>{</span><span>&#39;abc&#39;</span><span>,</span><span> </span><span>&#39;xyz&#39;</span><span>}</span><span>,</span><span>
</span><span>  monthly_usage_limit</span><span>=</span><span>50e3</span><span>,</span><span>
</span><span>  max_alerts</span><span>=</span><span>5</span><span>,</span><span>
</span><span>  stripe_price_id</span><span>=</span><span>&#39;...&#39;</span><span>,</span><span>
</span><span></span><span>)</span><span>
</span>
<!-- -->
<span>PREMIUM </span><span>=</span><span> Plan</span><span>(</span><span>
</span><span>  code</span><span>=</span><span>&#39;premium&#39;</span><span>,</span><span>
</span><span>  display_name</span><span>=</span><span>&#39;Premium Plan&#39;</span><span>,</span><span>
</span><span>  features</span><span>=</span><span>{</span><span>&#39;abc&#39;</span><span>,</span><span> </span><span>&#39;xyz&#39;</span><span>,</span><span> </span><span>&#39;special-feature&#39;</span><span>}</span><span>,</span><span>
</span><span>  monthly_usage_limit</span><span>=</span><span>250e3</span><span>,</span><span>
</span><span>  max_alerts</span><span>=</span><span>25</span><span>,</span><span>
</span><span>  stripe_price_id</span><span>=</span><span>&#39;...&#39;</span><span>,</span><span>
</span><span></span><span>)</span><span>
</span>
<span></span><span># Helpers for easy access</span><span>
</span><span>ALL_PLANS </span><span>=</span><span> </span><span>[</span><span>FREE</span><span>,</span><span> BASIC</span><span>,</span><span> PREMIUM</span><span>]</span><span>
</span><span>PLANS_BY_CODE </span><span>=</span><span> </span><span>{</span><span>p</span><span>.</span><span>code</span><span>:</span><span> p </span><span>for</span><span> p </span><span>in</span><span> ALL_PLANS</span><span>}</span></code></pre></div></pre>
<p>I can then use it in any API endpoint, cron job and admin task to determine which limits/features apply for a given customer. The current plan for a given customer is a column called <code>plan_code</code> on a <code>BillingProfile</code> model. I separate the user from the billing information since I&#39;m planning to add organizations/teams at some point, and that way I can easily migrate the BillingProfile to the account owner / admin user.</p>
<p>Of course this model won&#39;t scale if you&#39;re offering thousands of individual products in an e-commerce shop, but it works pretty well for me since a SaaS usually only has a few plans.</p>
<h2 id="logging">Logging</h2>
<p>I don’t need to instrument my code with any logging agent or anything like that. I simply log to stdout and Kubernetes automatically collects, and rotates logs for me. I could also automatically ship those logs to something like Elasticsearch/Kibana using <a href="https://fluentbit.io/" rel="noopener" target="_blank">FluentBit</a>, but I don’t do that yet to keep things simple.</p>
<p>To inspect the logs I use <a href="https://github.com/wercker/stern" rel="noopener" target="_blank">stern</a>, a tiny CLI tool for Kubernetes that makes it super easy to tail application logs across multiple pods.
For example, <code>stern -n ingress-nginx</code> would tail the access logs for my nginx pods even across multiple nodes.</p>
<h2 id="monitoring-and-alerting">Monitoring and alerting</h2>
<p>In the beginning I used a self-hosted Prometheus / Grafana to automatically monitor my cluster and application metrics. However, I didn’t feel comfortable self-hosting my monitoring stack, because if something went wrong in the cluster, my alerting system would go down with it too (not great).</p>
<p>If there’s one thing that should never go down is your monitoring system, otherwise you’re essentially flying without instruments. That’s why I swapped my monitoring / alerting system with a hosted service (<a href="http://newrelic.com/" rel="noopener" target="_blank">New Relic</a>).</p>
<p>All my services have a Prometheus integration that automatically records and forwards the metrics to a compatible backend, such as Datadog, New Relic, Grafana Cloud or a self-hosted Prometheus instance (what I used to do). To migrate to New Relic, all I had to do was to use their Prometheus Docker image, and shutdown the self-hosted monitoring stack.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-newrelic-monitoring.png" alt="Panelbear New Relic Dashboard" width="100%" height="auto" loading="lazy"/></span>
<em>Example New Relic dashboard with a summary of the most important stats.</em></p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-newrelic-uptime.png" alt="Panelbear New Relic Uptime Monitoring" width="100%" height="auto" loading="lazy"/></span>
<em>I also monitor uptime around the world using New Relic&#39;s probes.</em></p>
<p>The migration from a self-hosted Grafana/Loki/Prometheus stack to New Relic reduced my operational surface. More importantly, I&#39;d still get alerted even if my AWS region is down.</p>
<p>You might be wondering how I expose metrics from my Django app. I leverage the excellent <a href="https://github.com/korfuri/django-prometheus" rel="noopener" target="_blank">django-prometheus</a> library, and simply register a new counter/gauge in my application:</p>
<pre><div><pre><code><span>from</span><span> prometheus_client </span><span>import</span><span> Counter
</span>
<span>EVENTS_WRITTEN </span><span>=</span><span> Counter</span><span>(</span><span>
</span><span> </span><span>&#34;events_total&#34;</span><span>,</span><span>
</span><span> </span><span>&#34;Total number of events written to the eventstore&#34;</span><span>
</span><span></span><span>)</span><span>
</span>
<span></span><span># We can increment the counter to record the number of events</span><span>
</span><span></span><span># being written to the eventstore (ClickHouse)</span><span>
</span><span>EVENTS_WRITTEN</span><span>.</span><span>incr</span><span>(</span><span>count</span><span>)</span></code></pre></div></pre>
<p>It will expose this and other metrics in the <code>/metrics</code> endpoint of my server (only reachable within my cluster). Prometheus will automatically scrape this endpoint every minute and forward the metrics to New Relic.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/prometheus-metric-in-newrelic.png" alt="Prometheus metrics" width="100%" height="auto" loading="lazy"/></span>
<em>The metric automatically shows up in New Relic thanks to the Prometheus integration.</em></p>
<h2 id="error-tracking">Error tracking</h2>
<p>Everyone thinks they don’t have errors in their application, until they start error tracking. It’s too easy for an exception to get lost in logs, or worse you’re aware of it but unable to reproduce the problem due to lack of context.</p>
<p>I use <a href="https://sentry.io" rel="noopener" target="_blank">Sentry</a> to aggregate and notify me about errors across my applications. Instrumenting my Django apps is very simple:</p>
<pre><div><pre><code><span>SENTRY_DSN </span><span>=</span><span> env</span><span>.</span><span>str</span><span>(</span><span>&#34;SENTRY_DSN&#34;</span><span>,</span><span> default</span><span>=</span><span>None</span><span>)</span><span>
</span>
<span></span><span># Init Sentry if configured</span><span>
</span><span></span><span>if</span><span> SENTRY_DSN</span><span>:</span><span>
</span><span> sentry_sdk</span><span>.</span><span>init</span><span>(</span><span>
</span><span>   dsn</span><span>=</span><span>SENTRY_DSN</span><span>,</span><span>
</span><span>   integrations</span><span>=</span><span>[</span><span>DjangoIntegration</span><span>(</span><span>)</span><span>,</span><span> RedisIntegration</span><span>(</span><span>)</span><span>,</span><span> CeleryIntegration</span><span>(</span><span>)</span><span>]</span><span>,</span><span>
</span><span>   </span><span># Do not send user PII data to Sentry</span><span>
</span><span>   </span><span># See also inbound rules for special patterns</span><span>
</span><span>   send_default_pii</span><span>=</span><span>False</span><span>,</span><span>
</span><span>   </span><span># Only sample a small amount of performance traces</span><span>
</span><span>   traces_sample_rate</span><span>=</span><span>env</span><span>.</span><span>float</span><span>(</span><span>&#34;SENTRY_TRACES_SAMPLE_RATE&#34;</span><span>,</span><span> default</span><span>=</span><span>0.008</span><span>)</span><span>,</span><span>
</span><span> </span><span>)</span></code></pre></div></pre>
<p>It’s been very helpful because it automatically collects a bunch of contextual information about what happened when the exception occurred:</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-sentry-error-tracking.png" alt="Panelbear Sentry error tracking" width="100%" height="auto" loading="lazy"/></span>
<em>Sentry aggregates and notifies me in case of exceptions.</em></p>
<p>I use a Slack <code>#alerts</code> channel to centralize all my alerts: downtime, cron job failures, security alerts, performance regressions, application exceptions, and whatnot. It&#39;s great because I can often correlate issues when multiple services ping me around the same time, on seemingly unrelated problems.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-slack-alerts-channel.png" alt="Panelbear Slack alerts channel" width="100%" height="auto" loading="lazy"/></span>
<em>Example Slack alert due to a CDN endpoint being down in Sydney, Australia.</em></p>
<h2 id="profiling-and-other-goodies">Profiling and other goodies</h2>
<p>When I need to deep dive, I also use tools like <a href="https://docs.python.org/3/library/profile.html" rel="noopener" target="_blank">cProfile</a> and <a href="https://jiffyclub.github.io/snakeviz/" rel="noopener" target="_blank">snakeviz</a> to better understand allocations, number of calls and other stats about my app’s performance. Sounds fancy but they’re pretty easy to use tools, and have helped me identify various issues in the past that made my dashboards slow from seemingly unrelated code.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-cprofile-snakeviz.jpeg" alt="Panelbear New Relic Uptime Monitoring" width="100%" height="auto" loading="lazy"/></span>
<em>cProfile and snakeviz are great tools to profile your Python code locally.</em></p>
<p>I also use the <a href="https://django-debug-toolbar.readthedocs.io/en/latest/" rel="noopener" target="_blank">Django debug toolbar</a> on my local machine to easily inspect the queries that a view triggers, preview outgoing emails during development, and many other goodies.</p>
<p><span><img src="https://anthonynsimon.com/img/blog/one-man-saas-architecture/panelbear-django-debug-toolbar.png" alt="Panelbear New Relic Uptime Monitoring" width="100%" height="auto" loading="lazy"/></span>
<em>Django&#39;s Debug Toolbar is great for inspecting stuff in local dev, and previewing transactional emails.</em></p>
<h2 id="thats-all-folks">That&#39;s all folks</h2>
<p>I hope you enjoyed this post if you&#39;ve made it this far. It ended up being a lot longer than I originally intended as there was a lot of ground to cover.</p>
<p>If you&#39;re not already familiar with these tools consider using a managed platform first, for example Render or Railway. This might help you focus on your product, and still gain many of the benefits I talk about here.</p>
<p>&#34;Do you use Kubernetes for everything?&#34; - No, different projects, different needs. For example this blog is hosted on <a href="https://vercel.com" rel="noopener" target="_blank">Vercel</a>.</p>
<p>That said, I do intend to write more follow up posts on specific tips and tricks, and share more lessons learned along the way.</p></div></div></div>
  </body>
</html>
