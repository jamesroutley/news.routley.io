<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nick.scialli.me/blog/why-im-skeptical-of-low-code/">Original</a>
    <h1>I&#39;m skeptical of low-code</h1>
    
    <div id="readability-page-1" class="page"><div id="skip">
			


<ul>
	<li><time datetime="2023-12-30">30 December 2023</time></li>
	<li><a href="https://nick.scialli.me/tags/low-code/">low-code</a></li>
</ul>

<p>I’m skeptical of low-code.</p>
<p>When I was doing some software consulting, I would get clients who had been drawn to low-code all the time for the promise of fast development time and low maintenance cost. The client ended up not being happy for one of a few reasons:</p>
<p><strong>They wanted <em>truly custom</em> functionality that the low-code solution could not handle.</strong> A lot of low-code solutions seem to hit about 80% of a company’s requirement. But then there’s 20% the tool cannot do out of the box. Low-code tool marketers are pretty good at convincing executives that the tool can knock out the remaining 20% with ease (usually just by saying &#34;the tool can knock out the remaining 20% with ease&#34;). The reality ends up being that the remaining 20% requires significant and potentially-impossible customization. Companies are then forced to choose: is the tool’s out-of-the-box functionality close enough, or are we going to try to hack the tool up to make it fit our exact use case?</p>
<p><strong>They implemented a bunch of custom functionality in a product-specific or even proprietary language and now their pool of potential developer talent is tiny.</strong> Often, companies will opt to try to hack a low-code tool up to match 100% of its requirements. What they end up with is a bunch of custom code in a bespoke language that a very small number of people understand. Now, rather than being to recruit from a large pool of ubiquitous, open-source language developers, the company has to find maintainers who are very specialized in this tool.</p>
<p><strong>Upgrades to the low-code platform would break their custom implementation.</strong> Upgrading software without breaking things that interface with it is hard. Low-code tools have to do this with <em>arbitrary code</em> accomplishing use cases for which the low-code tool was never designed. This <em>should</em> be doable by having a strict API contract, but in practice I have seen a lot of tools that just kind of let the custom code do all sorts of shenanigans under the hood.</p>
<p><strong>The underlying database structure was an absolute mess, especially after a bunch of incremental modifications.</strong> I have seen companies use low-code tools for processes where precise analytics of the underlying data is critical. But then, when viewing the underlying data model, come to find that it’s inscrutable: what does <code>user_attribute_47</code> mean? I moved a field from page 1 to page 2 of the application and now the data are in separate fields?</p>
<p>This is not a &#34;low-code bad&#34; article but rather a recommendation to treat these tools with a healthy amount of skepticism. Anecdotally I have heard they can work great for the right use cases, but empirically I have found them to have a lot of &#34;gotchas.&#34;</p>

<ul><li>Previous: <a href="https://nick.scialli.me/blog/testing-observations-and-recommendations/">Software testing observations and recommendations</a></li>
</ul>

		</div></div>
  </body>
</html>
