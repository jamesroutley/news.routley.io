<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://icode4.coffee/?p=1081">Original</a>
    <h1>Hacking the Xbox 360 Hypervisor Part 2: The Bad Update Exploit</h1>
    
    <div id="readability-page-1" class="page"><div>
									
									
<p>Welcome to part 2 of the Hacking the Xbox 360 Hypervisor blog series. In this part I’ll cover how I found and exploited bugs in the Xbox 360 hypervisor to get full code execution and create the “Bad Update” exploit. If you haven’t already, I highly recommend you read (or at least skim through) <a href="https://icode4.coffee/?p=1047" data-type="post" data-id="1047" target="_blank" rel="noreferrer noopener">part 1</a> as this post will reference a lot of the material discussed there.</p>



<p>As I mentioned in part 1, I consider the Xbox 360 hypervisor to be one of the most secure pieces of code Microsoft has ever written, with only one software bug to date that was likely the result of a compiler issue. I spent a lot of time in the past looking for vulnerabilities in the hypervisor but never found anything of significance. Since then, I’ve spent 7 years working as a security engineer professionally and had developed a whole new mindset for how I analyze targets and find bugs. I was very motivated to put my new skills to the test and see if I could finally hack the Xbox 360 hypervisor. This is what I considered “the final boss” of my journey as a game console hacker.</p>



<h2>Testing Environment</h2>



<p>My goal was to exploit a game save bug I found in <a href="https://icode4.coffee/?p=954#xbox-36-exploit" data-type="post" data-id="954" target="_blank" rel="noreferrer noopener">Tony Hawk’s American Wasteland</a> to start an exploit chain that would hopefully end with me getting hypervisor mode code execution. My testing environment for doing this research consisted of an already modified Xbox 360 console that had full debugging capabilities. This allowed me to write exploit tests in C code which I could run and debug on the console, while also being able to introspect the internal state of the hypervisor. I wanted to focus my efforts on determining if any bugs I found were actually exploitable, and writing the exploit tests in C code that I could debug was the fastest way to do this. Once I had a viable exploit I could worry about triggering it from the Tony Hawk game save bug.</p>



<h2>Analyzing Attack Surface</h2>



<p>In part 1 I talked a bit about the <a href="https://icode4.coffee/?p=1047#system-calls" data-type="post" data-id="1047" target="_blank" rel="noreferrer noopener">system call attack surface</a> the hypervisor exposes to kernel mode. I looked through many of the system calls nearly 15 years ago when I first started researching the console but never found anything noteworthy. However, now that I had a new mindset for bug hunting it was time to look through all of the available attack surface starting fresh. Due to how little attack surface there is in the Xbox 360 hypervisor I decided on “code review” for my method of finding bugs. It didn’t really make sense to try and write a fuzzer or emulation harness and would have been way more work than just doing code review anyway. I say “code review” here because I don’t actually have access to the source code and what I’m really doing is reverse engineering/analyzing the disassembly of the hypervisor binary in IDA.</p>



<p>In my first pass of “code review” I’d be looking for “trivial” bugs, things like out of bounds reads/writes, race conditions/lack of locking, time of check/time of use bugs, integer overflows/underflows, missed validation of parameters, etc. I call these “trivial” because many of these can be exploitable without any additional primitives and don’t require a complex attack scenario.</p>



<h3>System Calls</h3>



<p>At launch the hypervisor had 65 system calls which increased to 120 by the end of its lifecycle, nearly doubling the amount of attack surface it exposed to kernel mode. The hypervisor system calls can be called by any code in kernel mode at any time and provide a range of functionality to support the console OS. The system call attack surface is very secure and has thorough validation of all parameters, only operates on data in protected memory and performs signature checks on most forms of data that involve parsing logic. While there were a few system calls that had notable or interesting behavior (things like cache flushing primitives, arbitrary writes to unprotected memory, etc.) I didn’t find anything that could be used to try and attack the hypervisor itself.</p>



<h3>XeKeysExecute Payloads</h3>



<p>There’s a special system call called <code>HvxKeysExecute</code> that’s used for running small pieces of ad-hoc code in hypervisor mode. This system call takes in a XeKeysExecute (XKE) payload which is a small piece of code signed by Microsoft that the hypervisor will load and execute dynamically. These payloads typically perform a single operation like update or validate some encrypted security file or provide a way for Microsoft to ship anti-cheat payloads through Xbox Live. XKE payloads are good attack surface because they perform non-standard ad-hoc operations, typically take in parameters and data from kernel mode to operate on, and typically have no version or runtime checks that prevent you from running them out of band. Put simply: any executable (game, dashboard, or otherwise) can typically run these at any time on any system software version.</p>



<p>These payloads are most commonly used by system update executables to perform additional security operations when updating the console. I leveraged this to my advantage and downloaded around ~85 system update packages I <a href="https://digiex.net/forums/dashboard-system-updates.62/">found online</a> to help build a collection of payloads for analysis. After writing some scripts to extract the update files and scan them for XKE payloads I had around 25 XKE payloads for analysis. Unfortunately, I didn’t find any trivial bugs in them. There was one payload that stood out as having some interesting behavior that could be exploitable but required I had a way to attack <a href="https://icode4.coffee/?p=1047#encrypted-memory" data-type="post" data-id="1047" target="_blank" rel="noreferrer noopener">encrypted memory</a>. Since I didn’t have any way to do this just yet I made note of the payload and moved on.</p>



<h3>Findings (none)</h3>



<p>I wasn’t hopeful I would find any fruitful results in this first pass and to be honest I would’ve been disappointed if I did. After a few days of code review on the attack surface available I had found nothing notable, which was to be expected. However, this did allow me to learn more about how encrypted and protected memory worked which gave me a few ideas for possible attack vectors. Faced with a lack of attack surface it was time to think outside the box and see if I could “create” more attack surface.</p>







<p>With no bugs found the next thing I turned to was trying to attack encrypted memory as this would allow me to try and attack the notable XKE payload I found earlier. Since encrypted memory doesn’t have any CRC checksums it can be modified from outside of the hypervisor, but I’d need to find a way to craft the ciphertext for data I wanted to write. Encrypted memory is typically used in a “write-only” fashion by the hypervisor. It’s clear Microsoft was aware it could be modified by kernel mode and therefore almost never read back from encrypted memory and operate on it. However, this notable XKE payload was doing just that and seemed like it could lead to some exploitable bugs in hypervisor mode.</p>



<p>Attacking this notable XKE payload was going to be difficult so I decided it would be best to first find an easier target and prove I could successfully attack encrypted memory without worrying about extraneous variables. There are only a few things that are stored in encrypted memory, mainly all kernel mode code, as well as some security related data that’s shared between the hypervisor and kernel (revocation lists, kernel mode RNG state, etc.). Attacking the encrypted memory for some kernel mode code seemed like a good test candidate as I could overwrite it with my own assembly code to do something like change the console’s LED colors, thus proving the attack worked.</p>



<h2>Encrypted Memory Allocations</h2>



<p>Both the protected and encrypted memory pathways perform encryption by mixing together a 10-bit whitening value, a per-boot per-pathway encryption key, and the address of cache line containing the memory being accessed. This prevents attackers from trying ciphertext manipulation attacks such:</p>



<ul>
<li>Using ciphertext from address A at address B where A != B.</li>



<li>Using ciphertext from the protected pathway with the encrypted pathway (or vice versa).</li>



<li>Using ciphertext across resets/reboots of the CPU.</li>
</ul>



<p>The hypervisor manages a table of values that I’ll refer to as the “page whitening table” which tracks encrypted pages of memory (on a 64KB granularity) and what whitening values have already been used on those pages. Every time the hypervisor allocates a page of memory for the encrypted pathway it’ll call a function I’ve named “HvpSetPageWhiteningBits”. This function will check the page whitening table to determine the next whitening value to use for the page. When the console boots, all entries are initialized to 0 and each time a page of encrypted memory is allocated the whitening value will be incremented by 1 until it reaches 1024 (the point at which a 10-bit integer would overflow). At this point an overflow bit will be set which indicates all possible whitening values have been used exactly once. Any allocation of the page thereafter will use a randomly generated number for the whitening value. The pseudo code for this function can be seen below:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a91103714941017540" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p></div>
				</td>
						<td><div><p><span>struct</span><span> </span><span>PAGE_WHITENING_TABLE_ENTRY</span></p><p><span>{</span></p><p><span>	</span><span>WORD</span><span> </span><span>WhiteningValue</span><span> </span><span>:</span><span> </span><span>10</span><span>;</span></p><p><span>	</span><span>WORD</span><span> </span><span>WhiteningOverflow</span><span> </span><span>:</span><span> </span><span>1</span><span>;</span></p><p><span>	</span><span>WORD</span><span> </span><span>Valid</span><span> </span><span>:</span><span> </span><span>1</span><span>;</span></p><p><span>}</span><span>;</span></p><p><span>DWORD </span><span>HvpSetPageWhiteningBits</span><span>(</span><span>PAGE_WHITENING_TABLE_ENTRY</span><span>*</span><span> </span><span>pPageAllocationTablePtr</span><span>,</span><span> </span><span>DWORD </span><span>pageNumber</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>WORD</span><span> </span><span>whiteningValue</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>// Get the whitening entry for the page.</span></p><p><span>	</span><span>PAGE_WHITENING_TABLE_ENTRY</span><span>*</span><span> </span><span>pPageEntry</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>pPageWhiteningTablePtr</span><span>[</span><span>pageNumber</span><span>]</span><span>;</span></p><p><span>	</span><span>// Check if the whitening values have all been used at least once.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pPageEntry</span><span>-&gt;</span><span>WhiteningOverflow</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Use the next whitening value until overflow is triggered.</span></p><p><span>		</span><span>whiteningValue</span><span> </span><span>=</span><span> </span><span>pPageEntry</span><span>-&gt;</span><span>WhiteningBits</span><span>++</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>else</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Randomize the whitening value.</span></p><p><span>		</span><span>XeCryptRandom</span><span>(</span><span>&amp;</span><span>whiteningValue</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>whiteningValue</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Isolate and return the 10-bit whitening value.</span></p><p><span>	</span><span>return</span><span> </span><span>whiteningValue</span><span> </span><span>&amp;</span><span> </span><span>0x3FF</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0019 seconds] -->
</div>



<p>The purpose of this function is to introduce entropy into the encryption used across allocations of the same page of memory. Each time the page is allocated the ciphertext will change even if the plaintext data doesn’t.</p>



<h3>A Hypothetical Attack Scenario</h3>



<p>While it may seem like all the per-boot/per-pathway/per-page encryption feeds make it difficult to perform ciphertext attacks this is actually quite easy to defeat. Sure we could just change the ciphertext arbitrarily and the resulting plaintext would change as well. But this doesn’t give us any control over what the resulting plaintext data will be and trying to brute force out even 16 bytes of random data that happens to give us some 16 bytes of plaintext data we want isn’t really feasible. </p>



<p>However, say we have some way to get the ciphertext for arbitrary plaintext data even though we don’t know what whitening value was used to create the ciphertext. For any given address there’s only 1024 possible ciphertext values for any constant plaintext data because the only entropy into the memory encryption will be the 10-bit whitening value. 10-bits is a very small search space and could easily be brute forced through in seconds to minutes if we had some primitive to cycle the whitening value and encrypt some known plaintext data.</p>



<p>Consider the following attack scenario:</p>



<ol>
<li>Choose some 64KB page of memory at address A such that A falls within the executable region for some executable file (could be a game executable or dll).</li>



<li>Get the ciphertext for all possible whitening values for the plaintext data we want to write into memory at address A (this would be our kernel mode shell code). There will be exactly 1024 different ciphertext values.</li>



<li>Load a game executable or dll into memory (a dll is easier because it can be loaded in a suspended state).</li>



<li>Loop for 1024 times and perform the following:
<ol>
<li>Write the next block of ciphertext to memory and flush CPU cache. This can be done using a DMA operation from another device such as the GPU or southbridge (remember this memory is read-only in kernel mode from the CPU’s perspective).</li>



<li>Read back the plaintext data using the encrypted pathway (basically just perform a normal memory read from kernel mode) and check it matches the expected plaintext data. </li>



<li>If the whitening value currently being used for the page of memory doesn’t match the whitening value used to generate the ciphertext then the resulting plaintext data will be garbage. Only once the whitening values match will the plaintext data be correct (i.e.: data was decrypted successfully).</li>



<li>Once the plaintext data is valid we have successfully overwritten encrypted memory with our own arbitrary data. Since we’re overwriting kernel mode code we can now execute this memory in kernel mode and run small amounts of our own arbitrary code.</li>
</ol>
</li>
</ol>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a9110f3a6&#34;}" data-wp-interactive="core/image"><img fetchpriority="high" decoding="async" width="1116" height="393" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/kernel_code_exec_attack-4.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/kernel_code_exec_attack-4.png 1116w, https://icode4.coffee/wp-content/uploads/kernel_code_exec_attack-4-300x106.png 300w, https://icode4.coffee/wp-content/uploads/kernel_code_exec_attack-4-768x270.png 768w" sizes="(max-width: 1116px) 100vw, 1116px"/><figcaption>Figure 1: Kernel mode code execution attack scenario</figcaption></figure></div>


<p>The only missing primitive here is a way to generate ciphertext for some arbitrary plaintext data.</p>



<h2>Crafting Ciphertext</h2>



<p>The primary source of ciphertext for the encrypted pathway is kernel mode code which must be RSA signed by Microsoft. However, tracing all the references to the <code>HvpSetPageWhiteningBits</code> function I found another code path that would work in my favor. The hypervisor implements three system calls that can be used to reserve, encrypt, and release an allocation in encrypted memory at an arbitrary address called <code>HvxEncryptedReserveAllocation</code>, <code>HvxEncryptedEncryptAllocation</code>, and <code>HvxEncryptedReleaseAllocation</code>.</p>



<p>The hypervisor enforces that all executable code is encrypted at runtime and the only memory that’s not encrypted is kernel mode data. This is mostly because data allocations may be used with external devices such as the GPU, southbridge, audio encoder, etc. which have no ability to perform decryption on the data. However, Microsoft wanted to give developers the ability to store data in encrypted memory and created the HvxEncrypted* API set. I’m not entirely sure what the attack scenario would be where one would want to use these APIs, presumably to hide some game data (cryptographic keys maybe?) at runtime from anyone who could dump the contents of RAM from outside the CPU. I can’t really think of any data that would justify the need for these APIs and I honestly don’t know if any game ever used them, but they certainly came in handy for exploitation.</p>



<p>The HvxEncrypted* APIs are pretty simple to use, you start by making a physical memory allocation using the unprotected pathway at the physical memory location you want to generate ciphertext for. Next you pass this address to <code>HvxEncryptedReserveAllocation</code> which marks the pages as in-use, followed by a call to <code>HvxEncryptedEncryptAllocation</code> which sets the page whitening bits and flushes CPU cache. At this point you now have two “views” of the same physical memory location, one through the unprotected pathway using the physical memory allocation address, and one through the encrypted pathway using a virtual address mapped by <code>HvxEncryptedReserveAllocation</code>.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a9110fa3f&#34;}" data-wp-interactive="core/image"><img decoding="async" width="785" height="246" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/multiple_pathways-4.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/multiple_pathways-4.png 785w, https://icode4.coffee/wp-content/uploads/multiple_pathways-4-300x94.png 300w, https://icode4.coffee/wp-content/uploads/multiple_pathways-4-768x241.png 768w" sizes="(max-width: 785px) 100vw, 785px"/><figcaption>Figure 2: Multiple pathways to the same memory location</figcaption></figure></div>


<p>Using these APIs we can craft the ciphertext for arbitrary data by simply writing our plaintext data using the encrypted address, flushing CPU cache, and reading back from the unprotected address. We won’t know what whitening value was used for the encryption but that doesn’t matter. We can simply generate the ciphertext for the data we plan to overwrite and use it as an indicator to know when the whitening value currently in use matches the whitening value used to generate our malicious ciphertext. I’ll hereby refer to this indicator data as our “oracle” data (not to be confused with an oracle machine) as it’s essentially guiding us to finding a whitening value collision.</p>



<h2>Overwriting Read-Only Memory</h2>



<p>The memory we want to overwrite with our malicious ciphertext is executable code which is marked read-only in kernel mode, so we’ll need to find a way to work around this. There are a couple different techniques I’ve used to overwrite arbitrary memory while ignoring page permissions:</p>



<ul>
<li>Southbridge DMA operations
<ul>
<li>The CPU communicates with peripheral devices such as the disc drive, HDD, and network port through the southbridge. By setting up Direct Memory Access (DMA) operations with a peripheral device the southbridge can read and write to any location in RAM as specified by the request.</li>
</ul>
</li>



<li>GPU shaders
<ul>
<li>The Xbox 360 uses a unified memory model which means the GPU doesn’t have dedicated VRAM, and instead accesses main RAM directly. The GPU also implements a feature called “memory export shaders” which are similar to modern day geometry shaders. These shaders allow the GPU to write back to RAM to create vertex, index, or texture buffers dynamically. By crafting a special shader it’s possible to use it as a memcpy primitive to read and write to anywhere in RAM.</li>
</ul>
</li>



<li>Hypervisor APIs
<ul>
<li>There are a few places where the hypervisor will perform reads and writes to unprotected memory addresses in order to read/write input and output parameters for certain system calls. By finding some APIs that can be used together you can craft a memcpy primitive by calling the APIs in a loop to copy data between two unprotected memory addresses.</li>
</ul>
</li>
</ul>



<p>I’ll cover each of these techniques in-depth in part 3, but for now I’m going to focus on the hypervisor APIs technique as this is what I used for the exploit.</p>



<h3>Hypervisor Key Storage</h3>



<p>When running in hypervisor mode all memory is considered read-write-execute. If you can find one or more APIs that work as a “read from address A write to address B” primitive you can have the hypervisor do the memcpy operation for you. There are a few places where the hypervisor will perform reads and writes to memory addresses provided by kernel mode using the unprotected pathway. However, I only found two particular APIs that would actually work for a viable memcpy operation: <code>HvxKeysExGetKey</code> and <code>HvxKeysExSetKey</code>.</p>



<p>These two APIs are used to get and set keys in the extended key store that the hypervisor manages. Almost all of the keys in the normal and extended key stores are not accessible to kernel mode and the ones that are accessible are typically read-only. However, the extended key store has a couple keys that are both accessible and writable from kernel mode. I’m not sure what the key slots are supposed to be used for (perhaps IP-TV keys/certificates) but the slot is writable and that’s all that matters.</p>



<p>By calling <code>HvxKeysExSetKey</code> we can store the data we want to write into the extended key store, and call <code>HvxKeysExGetKey</code> to retrieve it. When the retrieval happens the hypervisor will write the key value to the memory address provided by kernel mode using the unprotected pathway. As long as the memory address is outside of the hypervisor address space it’ll write to any memory location you specify. By putting these two APIs into a loop you can create an arbitrary memcpy primitive:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a9110371d804829283" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>MemcpyCipherText</span><span>(</span><span>ULONG </span><span>DstPhys</span><span>,</span><span> </span><span>ULONG </span><span>SrcPhys</span><span>,</span><span> </span><span>ULONG </span><span>size</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>while</span><span> </span><span>(</span><span>size</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Setup next block size.</span></p><p><span>		</span><span>ULONG </span><span>copySize</span><span> </span><span>=</span><span> </span><span>min</span><span>(</span><span>size</span><span>,</span><span> </span><span>2048</span><span>)</span><span>;</span></p><p><span>		</span><span>*</span><span>(</span><span>ULONG</span><span>*</span><span>)</span><span>pSizeScratch</span><span> </span><span>=</span><span> </span><span>copySize</span><span>;</span></p><p><span>		</span><span>// Store the next block to the key store and read it back to the target address.</span></p><p><span>		</span><span>ULONG </span><span>result</span><span> </span><span>=</span><span> </span><span>HvxKeysExSetKey</span><span>(</span><span>0x102</span><span>,</span><span> </span><span>SrcPhys</span><span>,</span><span> </span><span>copySize</span><span>)</span><span>;</span></p><p><span>		</span><span>result</span><span> </span><span>=</span><span> </span><span>HvxKeysExGetKey</span><span>(</span><span>0x102</span><span>,</span><span> </span><span>DstPhys</span><span>,</span><span> </span><span>SizeScratchPhysAddr</span><span>)</span><span>;</span></p><p><span>		</span><span>SrcPhys</span><span> </span><span>+=</span><span> </span><span>copySize</span><span>;</span></p><p><span>		</span><span>DstPhys</span><span> </span><span>+=</span><span> </span><span>copySize</span><span>;</span></p><p><span>		</span><span>size</span><span> </span><span>-=</span><span> </span><span>copySize</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<h2>Getting Kernel Mode Code Execution</h2>



<p>Now that we have a way to generate ciphertext for arbitrary data and write it to read-only memory it’s time to put everything together and get some arbitrary kernel mode code execution. Since I was testing this on an already hacked console I was able to write the poc for this in C code which I’ve included below. The steps I used for this attack are slightly different than the ones I outlined above but ultimately arrives at the same result.</p>



<p>First we’ll need an executable file we can load and unload dynamically. I chose to use the boot animation dll because it’s stored in system flash (so it exists on every console), can be loaded in a suspended state, and doesn’t terminate the executable that’s currently running. Then I chose the address of some executable code in the dll, <code>0x98030000</code>, to overwrite with my shell code. The address of any 64KB page of executable code will work.</p>



<h3>Getting the Oracle Data</h3>



<p>Next we’ll need to get some 16 bytes of plaintext data from the boot animation at the chosen target address (<code>0x98030000</code>), which we’ll use to create our oracle ciphertext data. We’ll also get the physical memory address our target address maps to which we’ll need later on.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a9110372c072623517" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>// Load the boot animation so we can get the physical address of the last code segment.</span></p><p><span>DWORD </span><span>result</span><span> </span><span>=</span><span> </span><span>XexLoadImage</span><span>(</span><span>&#34;Flash:\\bootanim.xex&#34;</span><span>,</span><span> </span><span>0x40000009</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>&amp;</span><span>hBootAnim</span><span>)</span><span>;</span></p><p><span>// Get the physical address of the last code segment.</span></p><p><span>DWORD </span><span>codePhysAddr</span><span> </span><span>=</span><span> </span><span>MmGetPhysicalAddress</span><span>(</span><span>(</span><span>void</span><span>*</span><span>)</span><span>0x98030000</span><span>)</span><span>;</span></p><p><span>// Copy the data at this address to use as our whitening oracle.</span></p><p><span>memcpy</span><span>(</span><span>abOracleData</span><span>,</span><span> </span><span>(</span><span>void</span><span>*</span><span>)</span><span>0x98030000</span><span>,</span><span> </span><span>16</span><span>)</span><span>;</span></p><p><span>// Unload the boot animation so we can reclaim the memory.</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>XexUnloadImage</span><span>(</span><span>hBootAnim</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<h3>Generating Our Ciphertext</h3>



<p>Next we loop 1024 times and allocate encrypted memory at the chosen target address. This will exhaust the whitening values for the chosen 64KB page and cause the overflow bit to get set such that each subsequent allocation of the page will use a random whitening value. For each iteration we’ll have two addresses to the same physical memory location, an unprotected address which just fetches whatever data is in RAM, and an encrypted address which will encrypt/decrypt data from RAM on access.</p>



<p>After ~50% of the search space has been used (so around i=512) we’ll write the plaintext oracle data to the encrypted address and read back the corresponding ciphertext from the unprotected address. We’ll do the same operation again for the shell code we want to write to memory and capture the corresponding ciphertext. We now have the ciphertext for the oracle data, and the ciphertext for our shell code at virtual address <code>0x98030000</code> for some unknown whitening value (presumably it’s 513 but it doesn’t really matter).</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a91103730990045855" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p></div>
				</td>
						<td><div><p><span>bool</span><span> </span><span>GetPayloadCipherText</span><span>(</span><span>DWORD </span><span>TargetPhysicalAddr</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Arbitrary virtual address that will get mapped through the encrypted pathway to TargetPhysicalAddr.</span></p><p><span>	</span><span>BYTE</span><span> </span><span>*</span><span>pEncryptedAddress</span><span> </span><span>=</span><span> </span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>0x8D000000</span><span>;</span></p><p><span>	</span><span>// Allocate physical memory (through the unprotected pathway) for the target address we want to encrypt data at.</span></p><p><span>	</span><span>BYTE</span><span>*</span><span> </span><span>pUnprotectedAddress</span><span> </span><span>=</span><span> </span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>XPhysicalAlloc</span><span>(</span><span>0x10000</span><span>,</span><span> </span><span>(</span><span>ULONG_PTR</span><span>)</span><span>TargetPhysicalAddr</span><span>,</span><span> </span><span>0x10000</span><span>,</span><span> </span><span>PAGE_READWRITE</span><span> </span><span>|</span><span> </span><span>MEM_LARGE_PAGES</span><span>)</span><span>;</span></p><p><span>	</span><span>// Loop and exhaust all possible whitening values for the memory address.</span></p><p><span>	</span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>1024</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Allocate encrypted memory.</span></p><p><span>		</span><span>DWORD </span><span>result</span><span> </span><span>=</span><span> </span><span>HvxEncryptedReserveAllocation</span><span>(</span><span>(</span><span>DWORD</span><span>)</span><span>pEncryptedAddress</span><span>,</span><span> </span><span>TargetPhysicalAddr</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>		</span><span>result</span><span> </span><span>=</span><span> </span><span>HvxEncryptedEncryptAllocation</span><span>(</span><span>(</span><span>DWORD</span><span>)</span><span>pEncryptedAddress</span><span>)</span><span>;</span></p><p><span>		</span><span>// Wait until we exhaust ~50% of the whitening space before capturing cipher text.</span></p><p><span>		</span><span>if</span><span> </span><span>(</span><span>i</span><span> </span><span>==</span><span> </span><span>1024</span><span> </span><span>/</span><span> </span><span>2</span><span>)</span></p><p><span>		</span><span>{</span></p><p><span>			</span><span>// Pass 1: copy the oracle data that will be loaded at this address when bootanim.xex is loaded.</span></p><p><span>			</span><span>memcpy</span><span>(</span><span>pEncryptedAddress</span><span>,</span><span> </span><span>abOracleData</span><span>,</span><span> </span><span>16</span><span>)</span><span>;</span></p><p><span>			</span><span>// Flush cache and read back ciphertext.</span></p><p><span>			</span><span>KeFlushCacheRange</span><span>(</span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>pEncryptedAddress</span><span>,</span><span> </span><span>0x80</span><span>)</span><span>;</span></p><p><span>			</span><span>KeFlushCacheRange</span><span>(</span><span>pUnprotectedAddress</span><span>,</span><span> </span><span>0x80</span><span>)</span><span>;</span></p><p><span>			</span><span>memcpy</span><span>(</span><span>pPayloadCipherText</span><span>,</span><span> </span><span>pUnprotectedAddress</span><span>,</span><span> </span><span>16</span><span>)</span><span>;</span></p><p><span>			</span><span>// Pass 2: copy our shell code to the target address we want to overwrite.</span></p><p><span>			</span><span>memset</span><span>(</span><span>pEncryptedAddress</span><span>,</span><span> </span><span>0x41</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>			</span><span>ReadFile</span><span>(</span><span>&#34;game:\\shell_code.bin&#34;</span><span>,</span><span> </span><span>pEncryptedAddress</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>			</span><span>// Flush cache and read back ciphertext.</span></p><p><span>			</span><span>KeFlushCacheRange</span><span>(</span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>pEncryptedAddress</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>			</span><span>KeFlushCacheRange</span><span>(</span><span>pUnprotectedAddress</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>			</span><span>memcpy</span><span>(</span><span>pPayloadCipherText</span><span> </span><span>+</span><span> </span><span>0x80</span><span>,</span><span> </span><span>pUnprotectedAddress</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>		</span><span>}</span></p><p><span>		</span><span>// Free the encrypted allocation.</span></p><p><span>		</span><span>result</span><span> </span><span>=</span><span> </span><span>HvxEncryptedReleaseAllocation</span><span>(</span><span>(</span><span>DWORD</span><span>)</span><span>pEncryptedAddress</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>XPhysicalFree</span><span>(</span><span>pUnprotectedAddress</span><span>)</span><span>;</span></p><p><span>	</span><span>return</span><span> </span><span>true</span><span>;</span></p><p><span>}</span></p><p><span>// Allocate physical memory for the shell code cipher text.</span></p><p><span>pPayloadCipherText</span><span> </span><span>=</span><span> </span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>XPhysicalAlloc</span><span>(</span><span>0x10080</span><span>,</span><span> </span><span>MAXULONG_PTR</span><span>,</span><span> </span><span>0x80</span><span>,</span><span> </span><span>PAGE_READWRITE</span><span> </span><span>|</span><span> </span><span>MEM_LARGE_PAGES</span><span>)</span><span>;</span></p><p><span>// Get the physical address of the shell code cipher text buffer.</span></p><p><span>PayloadCipherTextPhysAddr</span><span> </span><span>=</span><span> </span><span>MmGetPhysicalAddress</span><span>(</span><span>pPayloadCipherText</span><span>)</span><span>;</span></p><p><span>// Find the cipher text for the data we want to overwrite.</span></p><p><span>GetPayloadCipherText</span><span>(</span><span>codePhysAddr</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0013 seconds] -->
</div>



<h3>Finding a Whitening Value Collision</h3>



<p>Finally, in an infinite loop we’ll load the boot animation dll and check the ciphertext for our chosen target address <code>0x98030000</code>. If it matches our oracle ciphertext we know the 64KB page was encrypted using the same whitening value that was used to generate our malicious ciphertext, and we can now write the ciphertext for our shell code to memory. If the oracle data doesn’t match it means a different whitening value was used and we’ll unload the boot animation dll and try again. Once we get a hit we can use the hypervisor extended key store memcpy technique to copy the ciphertext for our shell code to the 64KB executable page which is marked read-only. Then we just jump to the address <code>0x98030000</code> and our shell code will execute.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a91103731033816328" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p></div>
				</td>
						<td><div><p><span>// Loop and load the boot animation until we find the correct whitening bits.</span></p><p><span>DWORD </span><span>count</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>while</span><span> </span><span>(</span><span>true</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Load the boot animation.</span></p><p><span>	</span><span>result</span><span> </span><span>=</span><span> </span><span>XexLoadImage</span><span>(</span><span>&#34;Flash:\\bootanim.xex&#34;</span><span>,</span><span> </span><span>0x40000009</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>&amp;</span><span>hBootAnim</span><span>)</span><span>;</span></p><p><span>	</span><span>// Get the cipher text for the target address.</span></p><p><span>	</span><span>MemcpyCipherText</span><span>(</span><span>PayloadCipherTextPhysAddr</span><span> </span><span>+</span><span> </span><span>16</span><span>,</span><span> </span><span>codePhysAddr</span><span>,</span><span> </span><span>16</span><span>)</span><span>;</span></p><p><span>	</span><span>KeFlushCacheRange</span><span>(</span><span>pPayloadCipherText</span><span>,</span><span> </span><span>0x80</span><span>)</span><span>;</span></p><p><span>	</span><span>// Check if the ciphertext in memory matches the oracle ciphertext we generated earlier.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>pPayloadCipherText</span><span>,</span><span> </span><span>pPayloadCipherText</span><span> </span><span>+</span><span> </span><span>16</span><span>,</span><span> </span><span>16</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Overwrite the boot animation code with our shell code ciphertext and flush cache.</span></p><p><span>		</span><span>MemcpyCipherText</span><span>(</span><span>codePhysAddr</span><span>,</span><span> </span><span>PayloadCipherTextPhysAddr</span><span> </span><span>+</span><span> </span><span>0x80</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>		</span><span>KeFlushCacheRange</span><span>(</span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>0x98030000</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>		</span><span>HvxFlushDCacheRange</span><span>(</span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>codePhysAddr</span><span>,</span><span> </span><span>0x10000</span><span>)</span><span>;</span></p><p><span>		</span><span>// Call our payload.</span></p><p><span>		</span><span>ULONG</span><span> </span><span>(</span><span>__stdcall</span><span> </span><span>*</span><span>pPayloadFunc</span><span>)</span><span>(</span><span>)</span><span> </span><span>=</span><span> </span><span>(</span><span>ULONG</span><span>(</span><span>__stdcall</span><span>*</span><span>)</span><span>(</span><span>)</span><span>)</span><span>0x98030000</span><span>;</span></p><p><span>		</span><span>result</span><span> </span><span>=</span><span> </span><span>pPayloadFunc</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Unload the boot animation.</span></p><p><span>	</span><span>result</span><span> </span><span>=</span><span> </span><span>XexUnloadImage</span><span>(</span><span>hBootAnim</span><span>)</span><span>;</span></p><p><span>	</span><span>count</span><span>++</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
</div>



<p>With everything in place I wrote a small piece of assembly code that would set the console’s ring of light to full orange to know when it executed. I ran the exploit and after 30 seconds to a minute it was able to find a whitening value collision and my assembly code ran. I captured a view of the code from a debugger which you can see here:</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a9111045a&#34;}" data-wp-interactive="core/image"><img decoding="async" width="670" height="539" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/image.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/image.png 670w, https://icode4.coffee/wp-content/uploads/image-300x241.png 300w" sizes="(max-width: 670px) 100vw, 670px"/><figcaption>Figure 3: Kernel mode shell code as seen by the debugger</figcaption></figure></div>


<p>Now that I had a way to attack encrypted memory it was time to loop back to the notable XKE payload and see if attacking it was feasible.</p>



<figure><div>
<blockquote data-width="470" data-dnt="true"><p lang="en" dir="ltr">I can now get up to 64kb of arbitrary kernel mode code execution on 360 but still no hv code exec. I&#39;m starting to run out of unhinged attack ideas…</p>— Ryan M (@Grimdoomer) <a href="https://twitter.com/Grimdoomer/status/1832178471881282035?ref_src=twsrc%5Etfw">September 6, 2024</a></blockquote>
</div></figure>







<p>This notable XKE payload that I’ll refer to as the “bootloader update payload” is used during system updates when the 2nd stage bootloader (2bl) needs to be updated. The reason this payload is interesting is because it reads in data from kernel mode and performs LZX decompression on it. The decompression process requires a scratch buffer to store the LZX decoder context structure which contains various pointers that the hypervisor will use when decompressing data. This scratch buffer is provided by kernel mode and relocated to <strong>encrypted memory</strong>, which means it doesn’t have any integrity checks and we can attack it from kernel mode asynchronously.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a91103735845964163" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p></div>
				</td>
						<td><div><p><span>typedef</span><span> </span><span>struct</span></p><p><span>{</span></p><p><span>	</span><span>/* pointer to beginning of window buffer */</span></p><p><span>	</span><span>byte</span><span>*</span><span>				</span><span>dec_mem_window</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>/* input (compressed) data pointers */</span></p><p><span>	</span><span>byte</span><span>*</span><span>				</span><span>dec_input_curpos</span><span>;</span></p><p><span>	</span><span>byte</span><span>*</span><span>				</span><span>dec_end_input_pos</span><span>;</span></p><p><span>	</span><span>/* output (uncompressed) data pointer */</span></p><p><span>	</span><span>byte</span><span>*</span><span>				</span><span>dec_output_buffer</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>/* memory allocation functions */</span></p><p><span>	</span><span>PFNALLOC			</span><span>dec_malloc</span><span>;</span></p><p><span>	</span><span>PFNFREE				</span><span>dec_free</span><span>;</span></p><p><span>	</span><span>long</span><span>*</span><span>				</span><span>dec_memory</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span><span> </span><span>t_decoder_context</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Looking at the decoder context structure there’s a couple juicy pointers we could try and attack. The <code>dec_malloc</code> and <code>dec_free</code> pointers are function pointers so overwriting these would result in the hypervisor jumping directly to some shell code we control. The <code>dec_output_buffer</code> pointer contains the address where decompressed data should be written to, so overwriting this pointer would result in data being written to any real mode address we choose (such as hypervisor code or data). All we need to do is generate the ciphertext for the address we want to write into the decoder context structure and the hypervisor will gladly use any real mode address we put there, whether it points to protected, encrypted, or unprotected memory. So why would Microsoft store this data in encrypted memory and not protected memory if they knew it could be modified asynchronously by kernel mode?</p>



<h2>Analyzing the Payload</h2>



<p>When the system update process is running and the 2nd stage bootloader needs to be updated, the updater application can have the hypervisor run this XKE payload and it’ll build an updated boot chain for the console in memory. The way this is supposed to work is kernel mode creates one large memory allocation in unprotected memory (around 700-800 KB) that gets divided up into different regions. These regions include a header, update data, decompressed bootloader data, LZX scratch buffer, and a region for the newly updated boot chain.</p>



<p>When the payload starts running it’ll relocate these regions in-place to either encrypted or protected memory depending on the size of the region. The header and compressed update data are relocated to protected memory as both regions are smaller than 64KB, and the decompressed bootloader data, LZX scratch buffer, and updated boot chain are relocated to encrypted memory as each region is too large to fit into a single slot of protected memory (64KB). Technically speaking each region could fit into protected memory if it spanned more than one slot but because a change in slot means a change in the upper 32-bits of a real mode address you’d have to handle this address break in code. You can’t just roll off the end of the 64KB page for slot N and into slot N+1 as even though the memory may be physically contiguous the addresses for each slot are not.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a91110a8b&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="1144" height="720" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/working_buffer_layout.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/working_buffer_layout.png 1144w, https://icode4.coffee/wp-content/uploads/working_buffer_layout-300x189.png 300w, https://icode4.coffee/wp-content/uploads/working_buffer_layout-768x483.png 768w, https://icode4.coffee/wp-content/uploads/working_buffer_layout-110x70.png 110w" sizes="auto, (max-width: 1144px) 100vw, 1144px"/><figcaption>Figure 4: Layout of the working buffer</figcaption></figure></div>


<p>Once the memory is relocated the payload will process the update data which is a compressed, encrypted, RSA signed blob that contains every possible 2nd stage bootloader for all the different hardware revisions of the console. The payload will first verify the RSA signature (that only Microsoft can sign) is valid, then decrypt the data, and then decompress it into the decompressed data region. Next the payload will scan a lookup table in the header of the compressed blob that contains a listing of every bootloader in the blob, what CPU, GPU, and HANA chip they match to, and try to match one of the entries to the console. If a match is found and the blob contains an updated 2nd stage bootloader for the console, the payload will craft a new boot chain and store it in the final region of the data buffer.</p>



<p>The size of the LZX scratch buffer is calculated as <code>sizeof(LZX_DECODER_CTX) + 2 * window_size</code>, where <code>window_size</code> is the block size of data to be compressed. In other words, the input data is processed in blocks of <code>window_size</code> bytes and compressed. To decompress a block you’ll need a buffer of <code>window_size</code> bytes to hold the decompressed data. In the case of this payload the window size chosen was 0x8000 bytes (32KB), thus the size of the scratch buffer is <code>sizeof(LZX_DECODER_CTX) + 0x10000</code> and won’t fit into a single slot of protected memory. Had the window size been slightly smaller the scratch buffer would have been able to fit into protected memory. Fortunately for us this works to our advantage because we can attack the encrypted memory for the scratch buffer using the techniques discussed earlier.</p>



<h2>Attacking LZX: Attempt 1</h2>



<p>In order to attack one of the pointers in the LZX decoder context structure we’ll need the ciphertext for some oracle data to check for a whitening value collision, and the ciphertext for the malicious pointer we want to write into the structure. Using the technique described above the attack would look something like this:</p>



<ol>
<li>Obtain the ciphertext for the oracle data and malicious pointer we want to write. For this attack we’ll target the <code>dec_malloc</code> function pointer in the LZX decoder structure. The pointer should be a real mode address that points to some shell code we setup in unprotected memory.</li>



<li>Create two threads:
<ul>
<li>Thread A will be the payload thread and continuously run the bootloader update payload in a loop.</li>



<li>Thread B will be the attack thread which continuously monitors the input data for the oracle ciphertext. Once the payload relocates the input data to encrypted memory we can observe the ciphertext for it by accessing the memory from kernel mode using the unprotected pathway. Once the ciphertext observed matches our oracle ciphertext we know a whitening value collision was hit and it’s safe to overwrite the LZX decoder structure.</li>
</ul>
</li>



<li>Once a whitening collision is observed, thread B will overwrite the <code>dec_malloc</code> pointer in the LZX decoder structure with the pre-computed ciphertext for our malicious pointer (which points to our shell code).</li>



<li>If we win the race between thread B overwriting the pointer and thread A using the pointer from hypervisor mode, then the hypervisor should jump to our shell code and we’ll get full hypervisor code execution.</li>
</ol>



<p>For the oracle data I chose to use the ciphertext for the first 16 bytes of LZX decoder structure with values of all 00s. When the payload does the in-place relocation of the LZX scratch buffer it’ll zero-initialize it afterwards. By capturing the ciphertext for 16 bytes of 00s at the same address I can use the zero-initialization of the scratch buffer as a start indicator to know when to hammer the decoder structure with the ciphertext for our malicious function pointer. This is the earliest point in time we can detect a whitening value collision and we’re gonna need as much time as we can get to win the race condition.</p>



<h3>Cache Rules Everything Around Me</h3>



<p>Unfortunately attacking the <code>dec_malloc</code> pointer isn’t feasible and the reason is that the CPU L2 cache is just too big for the data containing the decoder structure to age out of cache in the time frame we need. When the XKE payload goes to decompress the input data it’ll call <code>LDICreateDecompression</code> which takes in either two function pointers (one for <code>dec_malloc</code> and one for <code>dec_free</code>) or a pointer to a pre-allocated scratch buffer. In the case of this payload the function pointers are always null and a pointer to the LZX scratch buffer region is provided instead. Regardless of which you provide, the <code>dec_malloc</code> pointer will always be set to the value provided in the function arguments.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a91111141&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="583" height="724" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/ldi_create_decompression_pfma-1.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/ldi_create_decompression_pfma-1.png 583w, https://icode4.coffee/wp-content/uploads/ldi_create_decompression_pfma-1-242x300.png 242w" sizes="auto, (max-width: 583px) 100vw, 583px"/><figcaption>Figure 5: Disassembly of dec_malloc being set to NULL</figcaption></figure></div>


<p>Immediately after the <code>dec_malloc</code> function pointer is set to NULL <code>LDICreateDecompression</code> calls <code>sub_2668</code> which will initialize some more of the decoder structure and then try to use the <code>dec_malloc</code> pointer if it’s non-NULL.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a911115aa&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="768" height="793" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/ldi_init_use_pfma-4-768x793.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/ldi_init_use_pfma-4-768x793.png 768w, https://icode4.coffee/wp-content/uploads/ldi_init_use_pfma-4-290x300.png 290w, https://icode4.coffee/wp-content/uploads/ldi_init_use_pfma-4-1045x1080.png 1045w, https://icode4.coffee/wp-content/uploads/ldi_init_use_pfma-4.png 1055w" sizes="auto, (max-width: 768px) 100vw, 768px"/><figcaption>Figure 6: Disassembly of dec_malloc being used</figcaption></figure></div>


<p>This means we need our malicious ciphertext to be committed to memory by thread B before it’s accessed in <code>_dec_mem_alloc</code>, AND we need the cache line containing the <code>dec_malloc</code> pointer to either age out or be evicted from L2 cache of thread A. Unfortunately, there’s less than 300 instructions between these two operations and the L2 cache is too large for the data to age out or be evicted in this time frame. It’s also not possible to attack the <code>dec_free</code> pointer because the decompression routine never calls <code>LDIDestroyDecompression</code> so the <code>dec_free</code> pointer will never be checked and called. There are some additional things I did to try and put pressure on the CPU L2 cache which I’ll dig into in part 3, but as it stands attacking the <code>dec_malloc</code>/<code>dec_free</code> pointers is a no-go.</p>



<h2>Attacking LZX: Attempt 2</h2>



<p>Next attempt was trying to attack the <code>dec_output_buffer</code> pointer. When the decompression routine is run the compressed input buffer is decompressed in blocks. Each block will result in a call to <code>LDIDecompress</code> which decompresses the block and copies the decompressed data to the output buffer specified by the <code>dec_output_buffer</code> pointer. The goal for this attack was to successfully overwrite the <code>dec_output_buffer</code> pointer and get the decompressed data copied an address we specify.</p>



<p>This attempt would work mostly the same as the previous attempt except I’d be hammering the <code>dec_output_buffer</code> pointer to point into the last segment of the hypervisor. This particular area doesn’t contain any important code or data so I can freely trash it and observe the ciphertext for it from kernel mode without impacting stability of the hypervisor. Once the ciphertext changes I’ll know I won the race and got the XKE payload to use my malicious <code>dec_output_buffer</code> pointer to overwrite part of the hypervisor. This attack wouldn’t get me hypervisor code execution directly but instead I’d get a write to an arbitrary real mode address from hypervisor context. I’d need to find a way to turn this write into code execution but first I needed to prove the attack worked and that I wouldn’t be blocked by CPU L2 cache.</p>



<p>Since I was focused on determining if the attack was possible and doing all my testing on a console that was already hacked, I decided to modify the XKE payload and make a slight change that would improve my odds of winning the race condition. Each time the XKE payload runs it’ll use a random whitening value for the in-place memory relocation of the LZX scratch buffer. I modified the payload to instead use a constant value of 0x111. This would allow me to skip checking for a whitening value collision and just hammer the ciphertext for the <code>dec_output_buffer</code> pointer continuously in a loop. If the poc worked and the attack was possible then I could worry about winning the race condition later on.</p>



<p>After deploying the poc and modified XKE payload to my hacked console I let it run and got the debug spew that the race condition had been won. The ciphertext for the last segment of the hypervisor had changed which meant this attack was (most likely) feasible. At the very least I had somewhat of an arbitrary write primitive from hypervisor context and now I needed to find a way to turn it into code execution.</p>



<p>Ignoring that I still needed to win the race condition without my static whitening value patch in place, the write primitive I now have is hardly ideal. Every time the write primitive is triggered it’s going to write 0x8000 bytes of data (the size of the block after being decompressed) that I don’t control the contents of. I made a couple attempts to try and get control of the decompressed data before it gets copied to the <code>dec_output_buffer</code> pointer but had no luck in doing so. In most cases it would cause the console to hang or the <code>LDIDecompress</code> function to fail and return early without copying any data. This was a really crappy write primitive but I knew I’d probably never find another one and this could be the only bug I ever end up finding on the console. I accepted the challenge and decided I <em>had</em> to find a way to make it work.</p>



<figure><p>
https://twitter.com/Grimdoomer/status/1833974721010151669
</p></figure>



<h2>Failure Is Not An Option</h2>



<p>The next step is to turn this 0x8000 byte write primitive into something useful. My first train of thought was to use it to perform some memory corruption on other hypervisor data that I could turn into code execution or a more controlled write primitive. I began looking through the data segment of the hypervisor for anything that could be interesting to corrupt such as pointers to other code/data, RSA public keys for code authentication, or internal data structures used by the hypervisor. I found a number of interesting targets and even found some side channels I could use to figure out exactly what data was written to memory. But as I started to conceptualize various attack vectors I quickly realized this wasn’t going to work.</p>



<p>All of the interesting bits of data I was trying to attack were sitting in a minefield of spinlocks the hypervisor uses for acquiring thread safe access to data. My plan of attack depended on specific values within the decompressed data overwriting specific variables in the hypervisor data segment. If I overwrote a spinlock with a non-zero value the hypervisor would never be able to acquire it again, and trying to acquire it would result in that thread getting stuck indefinitely in the spinlock. Some of the spinlocks didn’t matter since they were for functionality that wasn’t important. However, the spinlock that was sitting after all of the interesting data I had found was the spinlock for running XKE payloads. If I overwrote that spinlock I’d never be able to run another XKE payload and I’d basically be locked out from running the write primitive again.</p>



<p>All of the variables I was targeting depended on winning the race condition on a specific block of data. This meant I would need to run the write primitive multiple times until the right block was written, and if I could only run the write primitive once before being locked out then this wasn’t going to work. I tried to find some other variables I could attack with a single write from any decompressed block but I had no such luck in finding any. I spent a few days digging through the data segment over and over but kept coming to the same conclusion: I can’t overwrite anything in the hypervisor data segment that will work to my advantage.</p>



<h3 id="update-data-side-channel">Thinking Outside the Box</h3>



<p>After scoping out several other pieces of hypervisor data in different locations with no success I decided to think outside of the box. The data being decompressed was bootloader code (i.e. valid PPC instructions), so I could in theory execute it if I overwrite some other hypervisor code such as a system call function. But I didn’t have any way to determine which block of decompressed bootloader code was written when I won the race condition. However, side channels come in all shapes and sizes. I realized that all of the decompressed blocks had the same size <em>except</em> for the last block. If I observed the ciphertext for the hypervisor code I overwrite I could determine when I won the race on the last block by seeing that the ciphertext changed for less than 0x8000 bytes. Simply observe at two locations such that the second location is greater than the size of the last block but less than 0x8000.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a91111c8c&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="1201" height="274" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/hypervisor_code_block_write-2.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/hypervisor_code_block_write-2.png 1201w, https://icode4.coffee/wp-content/uploads/hypervisor_code_block_write-2-300x68.png 300w, https://icode4.coffee/wp-content/uploads/hypervisor_code_block_write-2-768x175.png 768w" sizes="auto, (max-width: 1201px) 100vw, 1201px"/><figcaption>Figure 7: How to identify the last block</figcaption></figure></div>


<p>Now that I had a side channel to determine when the last block was written I needed to find some convenient instructions in this block that I could utilize. The idea is to overwrite some hypervisor code such that the first instructions for some hypervisor function get overwritten with some convenient instruction sequence I find in the bootloader data. To make it more complicated the only segment of hypervisor code I could overwrite was the last segment because it’s the only segment that doesn’t contain code for system critical functions which could cause the console to crash if corrupted. Most of this code was for things like IP-TV decryption and DVD drive anti-piracy routines, things that aren’t going to get executed in the background while the system is running.</p>



<p>On top of that only about 12% (or less than 0x2000 bytes) of the last hypervisor segment is code, the rest is just unused. This means any convenient instruction sequence I found in the decompressed bootloader data had to be in the first ~0x2000 bytes or I wouldn’t be able to position it such that it could overwrite the function in the hypervisor segment. The odds weren’t looking good but I began searching through the bootloader code in IDA looking for any instruction sequence I could use. After searching for a bit I found an instruction sequence that was exactly what I was looking for and at an offset that would work:</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a91112112&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="405" height="100" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/block_14_instruction_sequence.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/block_14_instruction_sequence.png 405w, https://icode4.coffee/wp-content/uploads/block_14_instruction_sequence-300x74.png 300w" sizes="auto, (max-width: 405px) 100vw, 405px"/><figcaption>Figure 8: Convenient instruction sequence</figcaption></figure></div>


<p>This instruction sequence will store the bottom byte of r4 to the memory location pointed to by r6+2 and then return. Simply put these two instructions will act as a fully controlled single byte arbitrary write. As an added bonus it has a low offset which makes placing this instruction sequence over some useless system call function in the last hypervisor segment easy. With this final piece of the puzzle I should now be able to write a full exploit chain to get hypervisor code execution.</p>







<p>There are many steps in this exploit chain but the flow will go something like this:</p>



<ol>
<li>Obtain the ciphertext for the oracle data and malicious pointer we want to write over the <code>dec_output_buffer</code> pointer. The malicious pointer will point into the last segment of the hypervisor such that the offset of the stb/blr instruction sequence (0xFA8) in the last block of bootloader data will fall at the start of a system call. I chose <code>HvxFlushUserModeTb</code> because it’s the last system call in the segment.</li>



<li>Create two threads:
<ul>
<li>Thread A will be the XKE payload thread that will continuously run the bootloader update payload in a loop.</li>



<li>Thread B will be the attack thread and continuously monitor the XKE input data for the oracle ciphertext. Once the payload relocates the input data to encrypted memory we can observe the ciphertext for it by using the unprotected pathway. Once the ciphertext observed matches our oracle ciphertext we know a whitening value collision was hit and it’s safe to overwrite the LZX decoder structure.</li>
</ul>
</li>



<li>Once a whitening collision is hit thread B will overwrite the <code>dec_output_buffer</code> pointer in the LZX decoder structure with the ciphertext for our malicious pointer.</li>



<li>We’ll know if the race was won because we can observe the ciphertext for the last segment of the hypervisor and see that it changed after the XKE payload was run. By observing the ciphertext in two locations we can determine if less than 0x8000 bytes of data was written which indicates the last block was written.</li>



<li>Once the race has been won on the last block the instructions for the <code>HvxFlushUserModeTb</code> system call will be replaced with the stb/blr instruction pair. We can now execute this system call from kernel mode and use it as an arbitrary write primitive.</li>



<li>Using the <code>HvxFlushUserModeTb</code> write primitive overwrite an entry in the system call dispatch table to point to an instruction sequence that will get us code execution. For this I chose an instruction sequence that will jump to the address in r4, and overwrote the system call entry for <code>HvxPostOutput</code>.</li>



<li>Set r4 to point to some shell code we create and call <code>HvxPostOutput</code> from kernel mode which will cause the hypervisor to jump to r4 and execute our code. For testing I wrote some assembly code to set the console’s ring of light to full orange and return the value 0x41414141.</li>
</ol>



<p>After coding this up and deploying it to my hacked console I let the exploit run. After a minute or two I got the debug spew that the race had been won on the last block and the exploit ran. I could see the console’s ring of light was lit full orange and the shell code returned 0x41414141 back to kernel mode.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a911127b7&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="412" height="199" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/race_hit_payload_ran.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/race_hit_payload_ran.png 412w, https://icode4.coffee/wp-content/uploads/race_hit_payload_ran-300x145.png 300w" sizes="auto, (max-width: 412px) 100vw, 412px"/><figcaption>Figure 9: Debug output from the exploit</figcaption></figure></div>


<p>At this point I should be good to go, just port this over to work on a non-hacked console and we’re done, hypervisor hacked, right? There’s one thing I forgot when running the last few poc’s and that was the patch I made to the XKE payload to use a static whitening value. I kept this patch in to test the poc with the best possible conditions for winning the race, which is why the exploit triggered in 1-2 minutes. Once I remove this patch the payload will use a random whitening value every time it runs. This means not only do we have to wait for a whitening value collision but we also have to win the race condition which we’re going to fail at many times. </p>



<p>After I removed the patch and reran the exploit I wasn’t even getting debug spew that the race condition was being won for any block, even after 30 minutes there was still nothing. It was starting to seem like this attack wasn’t going to work but I wasn’t ready to give up yet.</p>



<h2>Introducing Thread Feng Shui</h2>



<p>To try and get a better idea of what was going on I wrote some code/patches to record timestamps for each thread as the XKE payload was running. This gave me timestamps in microseconds for when the XKE payload relocated the LZX scratch buffer to encrypted memory, when it started to decompress each block of input data, and when the attack thread would start/stop hammering the LZX decoder structure. From the timing data I was able to see that by the time the attack thread was able to observe the whitening value collision the payload thread had already decompressed most of the input data. Which meant that by the time the attack thread got the malicious ciphertext flushed to RAM the XKE payload was already done running.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;67c6a91112cd0&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="400" height="477" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://icode4.coffee/wp-content/uploads/cpu_threads.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/cpu_threads.png 400w, https://icode4.coffee/wp-content/uploads/cpu_threads-252x300.png 252w" sizes="auto, (max-width: 400px) 100vw, 400px"/><figcaption>Figure 10: Die shot of the Xbox 360 CPU</figcaption></figure></div>


<p>When you create a software thread on the Xbox 360 you can specify which physical hardware thread you want it to run on. I speculated that what hw thread I ran the software threads on actually mattered, and that perhaps the distance to the FSB/L2 cache or inner logic of the L2 crossbar made a difference in how fast the operations completed. To test this I tried a number of different configurations of placing the software threads on different hardware threads and eventually found a configuration that allowed me to win the race condition. I suspected that putting the payload thread as far away from the FSB/L2 cache as possible and the attack thread as close as possible would have had the best results, however, this wasn’t the case.</p>



<p>The configuration with the best results was running the attack thread on hw thread 0 and the payload thread on hw thread 1. It seemed like scheduling them on different CPU cores actually hurt the odds of winning the race condition, and they had to be on the same core. Core 0 also had the best results compared to putting both threads on core 1 or 2. I know basically nothing about how CPUs work at a hardware level, or the inner workings of L1/2 cache and memory transactions. But what I suspect is happening is that each CPU core has its own load/store queues for performing memory transactions. Putting both threads on the same CPU core causes the memory transactions to be queued onto the L2 crossbar together when they would otherwise be queued separately if run on different cores. Put simply, running on the same core batches the loads/stores from both threads when they would otherwise be performed individually, and this significantly reduces the transaction times.</p>



<figure><p>
https://twitter.com/Grimdoomer/status/1835754498318606378
</p></figure>



<h2>Abusing the CPU for Fun and <s>Profit</s> Cache</h2>



<p>Now that I was able to win the race condition with an unmodified version of the XKE payload I at least knew the attack was theoretically possible. However, the rate at which the race condition was being won was abysmal, and it appeared that the race was only being won during the first half of the decompression process. This meant there was a slim chance of winning the race when the last block was being decompressed. Starting with the race condition success rate I knew this was largely due to how big the L2 cache was. Because the payload thread was more likely to fetch data from cache instead of RAM it meant more missed opportunities for it to fetch my malicious ciphertext from RAM. So if I could find a way to thrash L2 cache the race condition success rate should improve.</p>



<p>The Xbox 360 CPU has a 1MB, 8 way associative L2 cache, meaning each of the 8 pathways can map to 128KB of cache space. One of the interesting features of the Xbox 360 is that you can lock access to sections of L2 cache (as well as the pathways) and map it to a virtual address that the GPU can access. Yes, the GPU can read directly from the CPU’s L2 cache. The idea is that instead of having the CPU write data to RAM and then the GPU read it, you can put the data in L2 cache and have the GPU read it directly. This reduces the number of memory transactions from 2 to 1. There are some other performance benefits to this feature, but what it means for us is we have a way to reduce the amount of L2 cache the CPU can use. After figuring out how to use the <code>XLockL2</code> kernel API I was able to write the following helper function:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a91103739979382595" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>LockAndThrashL2</span><span>(</span><span>int</span><span> </span><span>index</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Allocate a block of 256kb cachable physical memory that will be used to lock the L2 range.</span></p><p><span>	</span><span>BYTE</span><span>*</span><span> </span><span>pPhysMemoryPtr</span><span> </span><span>=</span><span> </span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>XPhysicalAlloc</span><span>(</span><span>256</span><span> </span><span>*</span><span> </span><span>1024</span><span>,</span><span> </span><span>MAXULONG_PTR</span><span>,</span><span> </span><span>256</span><span> </span><span>*</span><span> </span><span>1024</span><span>,</span><span> </span><span>PAGE_READWRITE</span><span> </span><span>|</span><span> </span><span>MEM_LARGE_PAGES</span><span>)</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pPhysMemoryPtr</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>DbgPrint</span><span>(</span><span>&#34;Failed to allocate memory for L2 cache lock\n&#34;</span><span>)</span><span>;</span></p><p><span>		</span><span>DbgBreakPoint</span><span>(</span><span>)</span><span>;</span></p><p><span>		</span><span>VdDisplayFatalError</span><span>(</span><span>0x12400</span><span> </span><span>|</span><span> </span><span>ERR_LOCKL2_OOM</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Reserve L2 cache and lock 2 of the available pathways.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>XLockL2</span><span>(</span><span>index</span><span>,</span><span> </span><span>pPhysMemoryPtr</span><span>,</span><span> </span><span>256</span><span> </span><span>*</span><span> </span><span>1024</span><span>,</span><span> </span><span>XLOCKL2_LOCK_SIZE_2_WAYS</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span>==</span><span> </span><span>FALSE</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>DbgPrint</span><span>(</span><span>&#34;Failed to reserve L2 cache range\n&#34;</span><span>)</span><span>;</span></p><p><span>		</span><span>DbgBreakPoint</span><span>(</span><span>)</span><span>;</span></p><p><span>		</span><span>VdDisplayFatalError</span><span>(</span><span>0x12400</span><span> </span><span>|</span><span> </span><span>ERR_LOCKL2_RESERVE</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Fill the cache with trash data.</span></p><p><span>	</span><span>memset</span><span>(</span><span>pPhysMemoryPtr</span><span>,</span><span> </span><span>0x41</span><span>,</span><span> </span><span>256</span><span> </span><span>*</span><span> </span><span>1024</span><span>)</span><span>;</span></p><p><span>	</span><span>// Commit the L2 cache range and prevent it from being replaced.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>XLockL2</span><span>(</span><span>index</span><span>,</span><span> </span><span>pPhysMemoryPtr</span><span>,</span><span> </span><span>256</span><span> </span><span>*</span><span> </span><span>1024</span><span>,</span><span> </span><span>XLOCKL2_LOCK_SIZE_2_WAYS</span><span>,</span><span> </span><span>XLOCKL2_FLAG_SUSPEND</span><span>_</span>REPLACEMENT<span> </span><span>)</span><span> </span><span>==</span><span> </span><span>FALSE</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>DbgPrint</span><span>(</span><span>&#34;Failed to commmit L2 cache range\n&#34;</span><span>)</span><span>;</span></p><p><span>		</span><span>DbgBreakPoint</span><span>(</span><span>)</span><span>;</span></p><p><span>		</span><span>VdDisplayFatalError</span><span>(</span><span>0x12400</span><span> </span><span>|</span><span> </span><span>ERR_LOCKL2_COMMIT</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
</div>



<p>The way this works is we first allocate a block of 256KB of physical memory that will be used to back the L2 lock. Then we reserve a portion of L2 cache that’s the same size as the physical memory allocation and fill it with data. When the CPU sees any reads and writes to this memory region it’ll redirect them to the reserved region of L2 cache. Finally, we commit the lock which prevents that region of L2 cache from being evicted. This function can be used to lock up to 512KB of L2 cache and 4 of the available pathways for an overall reduction of 50% of L2 cache. This will put a lot of pressure on the remaining L2 cache which will cause an increase in cache misses, thus increasing the likelihood of the payload thread fetching the malicious ciphertext from RAM.</p>



<p>After modifying the poc to use the <code>LockAndThrashL2</code> function I was happy to see the success rate of the race condition had gone from hitting once every 10-15 minutes down to once every 2-3 minutes. This was a huge increase and the L2 thrashing was working great. </p>



<h2>Offsetting the Race Timing</h2>



<p>The next issue to deal with was the race timing. The race was typically being won during the first half of the decompression process and since we’re targeting the last block of compressed data, I needed to find a way to shift the window of opportunity to the last half of the decompression process. Initially I tried adding a delay between when the attack thread observes the oracle ciphertext and when it starts hammering the LZX decoder structure. However, no matter how much I tweaked the length of the delay I wasn’t able to get anything consistent enough to slide the attack window to the second half of the decompression process. So I decided to take a different approach.</p>



<p>Currently the oracle data (which was 16 bytes of 00s) was based on when the XKE payload did the in-place relocation of the LZX scratch buffer to encrypted memory and zero-initialized it. After the XKE payload initializes this memory it would verify the RSA signature on the compressed input data and decrypt it, before finally calling <code>LDICreateDecompression</code> which would fill the first 16 bytes of the LZX decoder structure with data. This gave a pretty large window of opportunity to observe the ciphertext for the oracle data but led to the attack window happening too early. I decided to change the oracle data to be the first 16 bytes of the LZX decoder structure after it was initialized by <code>LDICreateDecompression</code>, in hopes it would shift the attack window to the latter half of the decompression process.</p>



<p>The first 16 bytes of the LZX decoder structure is just a header with some constant values based on the parameters provided to <code>LDICreateDecompression</code>, so I could easily change the poc to generate the ciphertext for this data. You can see this change in lines 4-6 below:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a9110374a815448852" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>// Get the cipher text for the expected header data in the LZX decoder context. This acts as our</span></p><p><span>// &#34;oracle&#34; to know when to start the race attack.</span></p><p><span>memset</span><span>(</span><span>pMemoryAddress</span><span> </span><span>+</span><span> </span><span>ScratchOffset</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>16</span><span>)</span><span>;</span></p><p><span>*</span><span>(</span><span>ULONG</span><span>*</span><span>)</span><span>(</span><span>pMemoryAddress</span><span> </span><span>+</span><span> </span><span>ScratchOffset</span><span> </span><span>+</span><span> </span><span>0</span><span>)</span><span> </span><span>=</span><span> </span><span>0x4349444c</span><span>;</span><span>		</span><span>// signature = &#39;CIDL&#39;</span></p><p><span>*</span><span>(</span><span>ULONG</span><span>*</span><span>)</span><span>(</span><span>pMemoryAddress</span><span> </span><span>+</span><span> </span><span>ScratchOffset</span><span> </span><span>+</span><span> </span><span>4</span><span>)</span><span> </span><span>=</span><span> </span><span>0x8000</span><span>;</span><span>			</span><span>// windows size = 0x8000</span></p><p><span>*</span><span>(</span><span>ULONG</span><span>*</span><span>)</span><span>(</span><span>pMemoryAddress</span><span> </span><span>+</span><span> </span><span>ScratchOffset</span><span> </span><span>+</span><span> </span><span>8</span><span>)</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>				</span><span>// cpu type = 1</span></p><p><span>__dcbst</span><span>(</span><span>ScratchOffset</span><span>,</span><span> </span><span>pMemoryAddress</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>With the change in place I re-ran the poc a number of times and saw that the attack window had shifted to the latter half of the decompression process, and in some cases was winning the race on the last block of data. The poc was nearing completion, however, it was about this time that a new issue had popped up.</p>



<h2>Dirty Cache</h2>



<p>When testing the previous change there were a number of iterations where the race was supposedly won on the last block but the console would crash when trying to patch the hypervisor system call table. This could only happen if the block that was written to memory wasn’t the last block in the input file and the data being written over the <code>HvxFlushUserModeTb</code> system call wasn’t our stb/blr instruction sequence.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a9110374d459958169" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p></div>
				</td>
						<td><div><p><span>DWORD </span><span>RunUpdatePayloadThreadProc</span><span>(</span><span>THREAD_ARGS</span><span>*</span><span> </span><span>pArgs</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>// Get the cipher text at the location we want to overwrite and at an offset that is &gt; the size of block 14. This allows</span></p><p><span>	</span><span>// us to determine when we win the race on block 14 (smallest block in the file) vs any other block.</span></p><p><span>	</span><span>DWORD</span><span>*</span><span> </span><span>pCipherTextPtr1</span><span> </span><span>=</span><span> </span><span>(</span><span>DWORD</span><span>*</span><span>)</span><span>(</span><span>0xA0030000</span><span> </span><span>+</span><span> </span><span>HV_SEG3_OVERWRITE_OFFSET</span><span>)</span><span>;</span></p><p><span>	</span><span>DWORD</span><span>*</span><span> </span><span>pCipherTextPtr2</span><span> </span><span>=</span><span> </span><span>(</span><span>DWORD</span><span>*</span><span>)</span><span>(</span><span>0xA0030000</span><span> </span><span>+</span><span> </span><span>(</span><span>HV_SEG3_OVERWRITE_OFFSET</span><span> </span><span>-</span><span> </span><span>BLOCK_14_TARGET_OFFSET</span><span>)</span><span> </span><span>+</span><span> </span><span>BLOCK_14_SIZE</span><span> </span><span>+</span><span> </span><span>0x80</span><span>)</span><span>;</span></p><p><span>	</span><span>DWORD </span><span>cipherValue1</span><span> </span><span>=</span><span> </span><span>*</span><span>pCipherTextPtr1</span><span>;</span></p><p><span>	</span><span>DWORD </span><span>cipherValue2</span><span> </span><span>=</span><span> </span><span>*</span><span>pCipherTextPtr2</span><span>;</span></p><p><span>	</span><span>// Loop and hammer the payload until we hopefully get code exec.</span></p><p><span>	</span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>.</span><span>.</span><span>.</span></p><p><span>		</span><span>// Execute the payload.</span></p><p><span>		</span><span>DWORD </span><span>result</span><span> </span><span>=</span><span> </span><span>HvxKeysExecute</span><span>(</span><span>pArgs</span><span>-&gt;</span><span>PayloadPhys</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>PayloadSize</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>UpdateDataPhys</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>UpdateDataSize</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>NULL</span><span>)</span><span>;</span></p><p><span>		</span><span>// Flush cache on the cipher text pointers.</span></p><p><span>		</span><span>__dcbf</span><span>(</span><span>0</span><span>,</span><span> </span><span>pCipherTextPtr1</span><span>)</span><span>;</span></p><p><span>		</span><span>__dcbf</span><span>(</span><span>0</span><span>,</span><span> </span><span>pCipherTextPtr2</span><span>)</span><span>;</span></p><p><span>		</span><span>// Check if we got a block overwrite and if it appears to be block 14.</span></p><p><span>		</span><span>DWORD </span><span>test1</span><span> </span><span>=</span><span> </span><span>*</span><span>pCipherTextPtr1</span><span>;</span></p><p><span>		</span><span>if</span><span> </span><span>(</span><span>cipherValue1</span><span> </span><span>!=</span><span> </span><span>test1</span><span>)</span></p><p><span>		</span><span>{</span></p><p><span>			</span><span>// We got a block overwrite, check if it was block 14.</span></p><p><span>			</span><span>DWORD </span><span>test2</span><span> </span><span>=</span><span> </span><span>*</span><span>pCipherTextPtr2</span><span>;</span></p><p><span>			</span><span>if</span><span> </span><span>(</span><span>cipherValue2</span><span> </span><span>==</span><span> </span><span>test2</span><span>)</span></p><p><span>			</span><span>{</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34;Block 14 overwrite hit!\n&#34;</span><span>)</span><span>;</span></p><p><span>				</span><span>// Overwrite the syscall function pointer for HvxPostOutput to point to a gadget that will jump to an arbitrary address.</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34; * Patching hv syscall table\n&#34;</span><span>)</span><span>;</span></p><p><span>				</span><span>HvWriteULONG</span><span>(</span><span>HV_SYSCALL_POST_OUTPUT_ADDRESS</span><span>,</span><span> </span><span>HV_CALL_R4_GADGET_ADDRESS</span><span>)</span><span>;</span></p><p><span>				</span><span>// Try to execute our shell code which will restore the data we trashed in the last hypervisor segment and patch out</span></p><p><span>				</span><span>// the RSA signature checks on executable files.</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34; * Running payload\n&#34;</span><span>)</span><span>;</span></p><p><span>				</span><span>result</span><span> </span><span>=</span><span> </span><span>HvxPostOutputExploit</span><span>(</span><span>0</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>ShellCodePhysAddress</span><span>)</span><span>;</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34; * Payload returned 0x%08x\n&#34;</span><span>,</span><span> </span><span>result</span><span>)</span><span>;</span></p><p><span>				</span><span>DbgBreakPoint</span><span>(</span><span>)</span><span>;</span></p><p><span>			</span><span>}</span></p><p><span>			</span><span>else</span></p><p><span>			</span><span>{</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34;Race hit: 0x%08x\n&#34;</span><span>,</span><span> </span><span>test1</span><span>)</span><span>;</span></p><p><span>			</span><span>}</span></p><p><span>			</span><span>// Save the latest block hit values.</span></p><p><span>			</span><span>cipherValue1</span><span> </span><span>=</span><span> </span><span>test1</span><span>;</span></p><p><span>			</span><span>cipherValue2</span><span> </span><span>=</span><span> </span><span>test2</span><span>;</span></p><p><span>		</span><span>}</span></p><p><span>	</span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
</div>



<p>After doing some introspection on my hacked console I was able to confirm that the block being written wasn’t the last block in the input file and that the ciphertext read from the <code>pCipherTextPtr2</code> pointer was stale. This basically meant that the latter portion of data being written to hypervisor memory was getting stuck in L2 cache and not being committed to RAM where it could be observed from kernel mode. This wasn’t a huge issue, it simply meant I had to find a cache flush primitive I could use to get this data committed to RAM.</p>



<h3>Finding a Cache Flush Primitive</h3>



<p>Finding a cache flush primitive isn’t too difficult, you mainly need to find a function that will process some data and cause what’s currently in L2 cache to age out. Any hypervisor function that meets the following criteria will work:</p>



<ul>
<li>Runs in hypervisor context. Kernel mode cannot flush cache lines that were allocated by hypervisor mode.</li>



<li>Runs with caching enabled. The hypervisor normally runs with caching disabled so we’ll need to find a function that enables caching before processing the data. Any function that operates on data using the encrypted pathway will do this.</li>



<li>Touches as much data as possible while also performing as little validation as possible.</li>
</ul>



<p>After looking through all the hypervisor functions that operate on encrypted memory I came across a system call called <code>HvxRevokeUpdate</code> that met the above criteria. This function is used to encrypt a console certificate revocation list using a per-console key. These revocation lists are used to blacklist console certificates that have been considered “compromised”. For example, if someone hacked their console and used their console certificate to sign malicious game saves (for hacking the console or cheating online), Microsoft could blacklist the console certificate used to sign them by adding it to the revocation list and distributing it over Xbox Live or in system updates. After it’s been revoked any game save signed by that console certificate will show up as “corrupted” and can’t be loaded.</p>



<p>For us this function is a great cache flush primitive because it operates on an input buffer up to 0x20000 bytes large in encrypted memory and performs no validation on the input data. We simply provide it an empty input buffer and once the hypervisor enables caching and touches this data from the encrypted pathway it’ll cause old data in L2 cache to be evicted. After including the cache flush primitive into the exploit poc I ended up with the following:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.38 -->

		<div id="urvanov-syntax-highlighter-67c6a91103750900302190" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p></div>
				</td>
						<td><div><p><span>DWORD </span><span>RunUpdatePayloadThreadProc</span><span>(</span><span>THREAD_ARGS</span><span>*</span><span> </span><span>pArgs</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Allocate a scratch buffer to help with flushing L2 cache in hypervisor context.</span></p><p><span>	</span><span>BYTE</span><span>*</span><span> </span><span>pCacheFlushBuffer</span><span> </span><span>=</span><span> </span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>XPhysicalAlloc</span><span>(</span><span>0x20000</span><span>,</span><span> </span><span>MAXULONG_PTR</span><span>,</span><span> </span><span>0x10000</span><span>,</span><span> </span><span>PAGE_READWRITE</span><span> </span><span>|</span><span> </span><span>MEM_LARGE_PAGES</span><span>)</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pCacheFlushBuffer</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>DbgPrint</span><span>(</span><span>&#34;Failed to allocate memory for cache flush buffer\n&#34;</span><span>)</span><span>;</span></p><p><span>		</span><span>DbgBreakPoint</span><span>(</span><span>)</span><span>;</span></p><p><span>		</span><span>VdDisplayFatalError</span><span>(</span><span>0x12400</span><span> </span><span>|</span><span> </span><span>ERR_CACHE_FLUSH_BUFFER_OOM</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>ULONG </span><span>CacheFlushBufferPhys</span><span> </span><span>=</span><span> </span><span>MmGetPhysicalAddress</span><span>(</span><span>pCacheFlushBuffer</span><span>)</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>// Loop and hammer the payload until we hopefully get code exec.</span></p><p><span>	</span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>.</span><span>.</span><span>.</span></p><p><span>		</span><span>// Execute the payload.</span></p><p><span>		</span><span>DWORD </span><span>result</span><span> </span><span>=</span><span> </span><span>HvxKeysExecute</span><span>(</span><span>pArgs</span><span>-&gt;</span><span>PayloadPhys</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>PayloadSize</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>UpdateDataPhys</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>UpdateDataSize</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>NULL</span><span>)</span><span>;</span></p><p><span>		</span><span>// Flush cache on the cipher text pointers.</span></p><p><span>		</span><span>__dcbf</span><span>(</span><span>0</span><span>,</span><span> </span><span>pCipherTextPtr1</span><span>)</span><span>;</span></p><p><span>		</span><span>// Check if we got a block overwrite and if it appears to be block 14.</span></p><p><span>		</span><span>DWORD </span><span>test1</span><span> </span><span>=</span><span> </span><span>*</span><span>pCipherTextPtr1</span><span>;</span></p><p><span>		</span><span>if</span><span> </span><span>(</span><span>cipherValue1</span><span> </span><span>!=</span><span> </span><span>test1</span><span>)</span></p><p><span>		</span><span>{</span></p><p><span>			</span><span>// Flush cache on the secondary cipher text pointer. This one MUST be thorough or else we risk fetching stale data</span></p><p><span>			</span><span>// and trying to execute the post-block-write part of the exploit which will cause the console to hang.</span></p><p><span>			</span><span>HvxRevokeUpdate</span><span>(</span><span>CacheFlushBufferPhys</span><span>,</span><span> </span><span>0x20000</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>			</span><span>__dcbf</span><span>(</span><span>0</span><span>,</span><span> </span><span>pCipherTextPtr2</span><span>)</span><span>;</span></p><p><span>			</span><span>// We got a block overwrite, check if it was block 14.</span></p><p><span>			</span><span>DWORD </span><span>test2</span><span> </span><span>=</span><span> </span><span>*</span><span>pCipherTextPtr2</span><span>;</span></p><p><span>			</span><span>if</span><span> </span><span>(</span><span>cipherValue2</span><span> </span><span>==</span><span> </span><span>test2</span><span>)</span></p><p><span>			</span><span>{</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34;Block 14 overwrite hit!\n&#34;</span><span>)</span><span>;</span></p><p><span>				</span><span>// Overwrite the syscall function pointer for HvxPostOutput to point to a gadget that will jump to an arbitrary address.</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34; * Patching hv syscall table\n&#34;</span><span>)</span><span>;</span></p><p><span>				</span><span>HvWriteULONG</span><span>(</span><span>HV_SYSCALL_POST_OUTPUT_ADDRESS</span><span>,</span><span> </span><span>HV_CALL_R4_GADGET_ADDRESS</span><span>)</span><span>;</span></p><p><span>				</span><span>// Try to execute our shell code which will restore the data we trashed in the last hypervisor segment and patch out</span></p><p><span>				</span><span>// the RSA signature checks on executable files.</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34; * Running payload\n&#34;</span><span>)</span><span>;</span></p><p><span>				</span><span>result</span><span> </span><span>=</span><span> </span><span>HvxPostOutputExploit</span><span>(</span><span>0</span><span>,</span><span> </span><span>pArgs</span><span>-&gt;</span><span>ShellCodePhysAddress</span><span>)</span><span>;</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34; * Payload returned 0x%08x\n&#34;</span><span>,</span><span> </span><span>result</span><span>)</span><span>;</span></p><p><span>				</span><span>DbgBreakPoint</span><span>(</span><span>)</span><span>;</span></p><p><span>			</span><span>}</span></p><p><span>			</span><span>else</span></p><p><span>			</span><span>{</span></p><p><span>				</span><span>DbgPrint</span><span>(</span><span>&#34;Race hit: 0x%08x\n&#34;</span><span>,</span><span> </span><span>test1</span><span>)</span><span>;</span></p><p><span>			</span><span>}</span></p><p><span>			</span><span>// Save the latest block hit values.</span></p><p><span>			</span><span>cipherValue1</span><span> </span><span>=</span><span> </span><span>test1</span><span>;</span></p><p><span>			</span><span>cipherValue2</span><span> </span><span>=</span><span> </span><span>test2</span><span>;</span></p><p><span>		</span><span>}</span></p><p><span>	</span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0013 seconds] -->
</div>



<p>Running the updated poc showed the cache flush primitive was working and the console was no longer crashing on false positives due to stale data in RAM. The only thing left to do now was assemble all the pieces of this exploit into a single chain that I would trigger using my favorite game exploit, Tony Hawk’s Pro Strcpy.</p>







<p>To turn this into an end-to-end exploit and get hypervisor code execution I’d use my <a href="https://icode4.coffee/?p=954" data-type="post" data-id="954">Tony Hawk’s Pro Strcpy</a> bug as an entry point and combine it with the techniques I developed for attacking this bootloader update XKE payload. Putting all of the pieces of the exploit together the full exploit chain would look like so:</p>



<ol>
<li>Stage 1
<ul>
<li>Using a modified game save file I would trigger the gap name strcpy bug in Tony Hawk’s American Wasteland (you can read about this bug in the <a href="https://icode4.coffee/?p=954" data-type="post" data-id="954">Tony Hawk’s Pro Strcpy</a> post) and get a ROP chain executing in kernel mode. This ROP chain would load a much larger ROP chain (stage 2) from a file on the HDD and pivot execution to it.</li>
</ul>
</li>



<li>Stage 2
<ul>
<li>The larger ROP chain would perform the operations needed to get arbitrary kernel mode code execution, and load stage 3 from a file on the HDD into the region of executable kernel memory.</li>
</ul>
</li>



<li>Stage 3
<ul>
<li>Stage 3 is the C code I wrote to run and attack the bootloader update XKE payload. This will perform the attack on the LZX decompression process to try and overwrite some hypervisor code and create an arbitrary write primitive. Using the arbitrary write primitive we’ll further modify hypervisor memory to get hypervisor code execution and run the stage 4 code in hypervisor mode.</li>
</ul>
</li>



<li>Stage 4
<ul>
<li>Stage 4 is assembly code I wrote that will undo all the memory corruption done to the hypervisor in stage 3 so it’s in a clean and stable state. After that it’ll patch out the RSA signature checks the hypervisor does on executable code so that unsigned executables can be run on the console.</li>



<li>Once complete stage 4 will return back to kernel mode and run an unsigned executable from the HDD thus proving the exploit worked.</li>
</ul>
</li>
</ol>



<p>While all the major pieces were already proven to work I still needed to chain them all together into a top-down exploit.</p>



<h2>A ROP Chain for the Record Books</h2>



<p>The technique I developed for getting arbitrary kernel mode code execution was done in C code that I could deploy and run on my hacked console. This code would need to be recreated in a ROP chain, and while the code itself wasn’t very complex doing it all in ROP wasn’t easy. It took about a week to rewrite the C code in ROP and the final chain consisted of 20-30 unique ROP gadgets and just over 28,000 links in the chain. I wrote many parts of the chain in reusable macros and split it across several source files to simplify the process, but even then the complexity of the chain is quite high.</p>



<figure><div>
<blockquote data-width="470" data-dnt="true"><p lang="en" dir="ltr">Almost out of ROP chain hell… Currently have 20 unique gadgets and 27,716 links in the chain. I implemented common functionality in macros which makes writing more complex aspects of the chain easier. Another day or so and I can move on to the third stage of the exploit (in C) <a href="https://t.co/uNpLKtlMGP">pic.twitter.com/uNpLKtlMGP</a></p>— Ryan M (@Grimdoomer) <a href="https://twitter.com/Grimdoomer/status/1838187355037167943?ref_src=twsrc%5Etfw">September 23, 2024</a></blockquote>
</div></figure>



<h2>The Grand Finale</h2>



<p>With everything in place there was one last thing to do. If you read my <a href="https://icode4.coffee/?p=954" data-type="post" data-id="954">Tony Hawk’s Pro Strcpy</a> blog post you might remember I used a homebrew <a href="https://www.youtube.com/watch?v=2yJgwwDcgV8">nyan cat</a> executable to test my exploits. It has since become somewhat of a signature for my exploits and while I had a version of this for the Xbox 360 ready to go, I decided to give it a small upgrade. After copying all the exploit files to a USB stick I booted up Tony Hawk’s American Wasteland, loaded my hacked game save, and waited. I knew from test runs on my hacked console that the exploit had a low success rate (around 35%) and could take upwards of 30 minutes to trigger, but I was ecstatic when it triggered on the first attempt in only a few minutes time. I now had an end-to-end hypervisor exploit that worked on the latest system software (version 17559) and could be triggered using software only methods.</p>



<figure><p>
<iframe loading="lazy" title="Xbox 360 Bad Update Exploit Demo" width="470" height="264" src="https://www.youtube.com/embed/WgmrW0Pfgl4?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</p></figure>



<figure><div>
<blockquote data-width="470" data-dnt="true"><p lang="en" dir="ltr">As of today I have a fully working software only hypervisor exploit for the latest xbox 360 retail dashboard 17559 (should work on almost any software version though). Here&#39;s what you need to know…</p>— Ryan M (@Grimdoomer) <a href="https://twitter.com/Grimdoomer/status/1847497275289063676?ref_src=twsrc%5Etfw">October 19, 2024</a></blockquote>
</div></figure>



<p>Full source code and files for the exploit can be found on GitHub: <a href="https://github.com/grimdoomer/Xbox360BadUpdate" target="_blank" rel="noreferrer noopener">Xbox360BadUpdate</a>.</p>



<h2>Exploit F.A.Q.</h2>



<p>There are a couple questions I know people will be asking about the current state of the exploit, if a softmod is available, and how it compares to things like the RGH hack. I’ve provided answers to a few of these here.</p>



<ul>
<li><strong>What Xbox 360 software/kernel version does this exploit work on?</strong>
<ul>
<li>The exploit works on all software versions up to/through 17559, though there’s some version specific information that would need to be updated for any version other than 17559. At the time of writing this post I have reported the vulnerability to Microsoft but I don’t know if it will be patched in a future software update or not.</li>
</ul>
</li>



<li><strong>Does this mean a “softmod” is now available?</strong>
<ul>
<li>While the exploit is software only (no additional hardware or opening of the console required) it’s not persistent. You’ll need to rerun the exploit every time you turn the console on. Once the exploit runs your console will be in a hacked state until it’s rebooted/powered off. It works much the same as a tethered iOS jailbreak.</li>
</ul>
</li>



<li><strong>Can this be turned into a softmod/made persistent?</strong>
<ul>
<li>It’s theoretically possible to turn this into a persistent “softmod” but it wouldn’t be an ideal experience. The Xbox 360 boot chain is well protected and the only viable way to trigger the exploit on boot would be by finding a bug in the Xbox 360 dashboard, which may require additional input to trigger (ex: wait for dashboard to load, navigate to games list, scroll down, exploit triggers). </li>
</ul>
</li>



<li><strong>Why does the exploit take so long to trigger/can it be made faster/more reliable?</strong>
<ul>
<li>The exploit takes a while to trigger because it has to exploit a race condition under very specific circumstances. It may be possible to improve the timing/reliability but I don’t think it’ll ever be good enough to try and turn into a persistent hack.</li>
</ul>
</li>



<li><strong>Should I use this instead of the RGH hack?</strong>
<ul>
<li>No, this exploit does not provide a good user experience for those wanting to hack their Xbox 360 consoles. RGH is, and always will be the defacto boot-to-hacked-state exploit for the console.</li>
</ul>
</li>
</ul>







<p>This exploit took around two and half months to research, develop, and finish but it felt like an eternity. There were many times I thought I hit a dead end and had no path forward, only to spend a day or two thinking and coming up with something new to try. Finding and developing this exploit pushed my abilities as a security researcher, from understanding how the console worked, to finding ways to create attack surface when there otherwise wasn’t any, to using anything and everything I possibly could to help win the race condition and (quite literally) beat the CPU into submission. The constant need to think outside the box and turn nothing into something is part of what I love about being a security researcher, but it’s also exhausting.</p>



<p>Now that I’ve completed this exploit I’m going to retire from game console hacking (at least for the foreseeable future). I’ve learned all I wanted to learn and hacked all I wanted hacked, now it’s time I explore some new avenues. I want to give a big shout out to everyone who encouraged me to continue working on this through all the ups and downs, doom, “x”, and the Seabards for listening to all my rambling about L2 cache fuckery and the numerous times I thought I hit a dead end. Once again, a big thank you to everyone who read through this wall of text. Even though it’s quite long this blog post doesn’t even begin to capture all the work that made this exploit possible.</p>



<p>For anyone who wants to read more about the Xbox 360 inner workings I plan to write a part 3 where I’ll (briefly) cover some of my failed attempts at exploiting the console, and other interesting behavior/techniques I developed along the way. However, this part won’t be written for several months time so don’t count on it any time soon.</p>




									
																		
								</div></div>
  </body>
</html>
