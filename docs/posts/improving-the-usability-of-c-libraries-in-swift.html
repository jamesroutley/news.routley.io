<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.swift.org/blog/improving-usability-of-c-libraries-in-swift/">Original</a>
    <h1>Improving the usability of C libraries in Swift</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>There are many interesting, useful, and fun C libraries in the software ecosystem. While one could go and rewrite these libraries in Swift, usually there is no need, because Swift provides direct interoperability with C. With a little setup, you can directly use existing C libraries from your Swift code.</p>

<p>When you use a C library directly from Swift, it will look and feel similar to using it from C. That can be useful if you’re following sample code or a tutorial written in C, but it can also feel out of place. For example, here’s a small amount of code using a C API:</p>

<div><div><pre><code>  <span>var</span> <span>instanceDescriptor</span> <span>=</span> <span>WGPUInstanceDescriptor</span><span>()</span>
  <span>let</span> <span>instance</span> <span>=</span> <span>wgpuCreateInstance</span><span>(</span><span>&amp;</span><span>instanceDescriptor</span><span>)</span>
  <span>var</span> <span>surfaceDescriptor</span> <span>=</span> <span>WGPUSurfaceDescriptor</span><span>()</span>
  <span>let</span> <span>surface</span> <span>=</span> <span>wgpuInstanceCreateSurface</span><span>(</span><span>instance</span><span>,</span> <span>&amp;</span><span>surfaceDescriptor</span><span>)</span>
  <span>if</span> <span>wgpuSurfacePresent</span><span>(</span><span>&amp;</span><span>surface</span><span>)</span> <span>==</span> <span>WGPUStatus_Error</span> <span>{</span>
      <span>// report error</span>
  <span>}</span>
  <span>wgpuSurfaceRelease</span><span>(</span><span>surface</span><span>)</span>
  <span>wgpuInstanceRelease</span><span>(</span><span>instance</span><span>)</span>
</code></pre></div></div>

<p>The C library here that Swift is using comes from the <a href="https://github.com/webgpu-native/webgpu-headers">webgpu-headers project</a>, which vends a C header (<code>webgpu.h</code>) that is used by several implementations of <a href="https://www.w3.org/TR/webgpu/">WebGPU</a>. WebGPU  is a technology that enables web developers to use the system’s GPU (Graphics Processing Unit) from the browser. For the purposes of this post, you don’t really need to know anything about WebGPU: I’m using it as an example of a typical C library, and the techniques described in this blog post apply to lots of other well-designed C libraries.</p>

<p>The Swift code above has a very “C” feel to it. It has global function calls with prefixed names like <code>wgpuInstanceCreateSurface</code> and global integer constants like <code>WGPUStatus_Error</code>. It pervasively uses unsafe pointers, some of which are managed with explicit reference counting, where the user provides calls to <code>wpuXYZAddRef</code> and <code>wgpuXYZRelease</code> functions. It works, but it doesn’t feel like Swift, and inherits various safety problems of C.</p>

<p>Fortunately, we can improve this situation, providing a safer and more ergonomic interface to WebGPU from Swift that feels like it belongs in Swift. More importantly, we can do so without changing the WebGPU implementation: Swift provides a suite of annotations that you can apply to C headers to improve the way in which the C APIs are expressed in Swift. These annotations describe common conventions in C that match up with Swift constructs, projecting a more Swift-friendly interface on top of the C code.</p>

<p>In this post, I’m going to use these annotations to improve how Swift interacts with the WebGPU C code. By the end, we’ll be able to take advantage of Swift features like argument labels, methods, enums, and automatic reference counting, like this:</p>

<div><div><pre><code>  <span>var</span> <span>instanceDescriptor</span> <span>=</span> <span>WGPUInstanceDescriptor</span><span>()</span>
  <span>let</span> <span>instance</span> <span>=</span> <span>WGPUInstance</span><span>(</span><span>descriptor</span><span>:</span> <span>&amp;</span><span>instanceDescriptor</span><span>)</span>
  <span>var</span> <span>surfaceDescriptor</span> <span>=</span> <span>WGPUSurfaceDescriptor</span><span>()</span>
  <span>let</span> <span>surface</span> <span>=</span> <span>instance</span><span>.</span><span>createSurface</span><span>(</span><span>descriptor</span><span>:</span> <span>&amp;</span><span>surfaceDescriptor</span><span>)</span>
  <span>if</span> <span>surface</span><span>.</span><span>present</span><span>()</span> <span>==</span> <span>.</span><span>error</span> <span>{</span>
      <span>// report error</span>
  <span>}</span>
  <span>// Swift automatically deallocates the instance and surface when we&#39;re done</span>
</code></pre></div></div>

<p>These same annotations can be used for any C library to provide a safer, more ergonomic development experience in Swift without changing the C library at all.</p>

<blockquote>
  <p><strong>Note</strong>: Some of what is covered in this post requires bug fixes that first became available in Swift 6.2.3.</p>
</blockquote>



<p>A <a href="https://clang.llvm.org/docs/Modules.html">module map</a> is a way of layering a Swift-friendly modular structure on top of C headers. You can create a module map for the WebGPU header by writing the following to a file <code>module.modulemap</code>:</p>

<div><div><pre><code><span>module</span> <span>WebGPU</span> <span>{</span>
  <span>header</span> <span>&#34;webgpu.h&#34;</span>
  <span>export</span> <span>*</span>
<span>}</span>
</code></pre></div></div>

<p>The easiest thing to do is to put <code>module.modulemap</code> alongside the header itself. For my experiment here, I put it in the root directory of my <code>webgpu-headers</code> checkout. If you’re in a Swift package, put it into its own target with this layout:</p>

<div><div><pre><code><span>├──</span> <span>Package</span><span>.</span><span>swift</span>
<span>└──</span> <span>Sources</span>
    <span>└──</span> <span>WebGPU</span>
        <span>├──</span> <span>include</span>
        <span>│</span>   <span>├──</span> <span>webgpu</span><span>.</span><span>h</span>
        <span>│</span>   <span>└──</span> <span>module</span><span>.</span><span>modulemap</span>
        <span>└──</span> <span>WebGPU</span><span>.</span><span>c</span> <span>(</span><span>empty</span> <span>file</span><span>)</span>
</code></pre></div></div>

<p>If you reference this <code>WebGPU</code> target from elsewhere in the package, you can <code>import WebGPU</code> to get access to the C APIs.</p>



<p>There are a few ways to see what the Swift interface for a C library looks like.</p>

<ul>
  <li>The <code>swift-synthesize-interface</code> tool in Swift 6.2+ prints the Swift interface to the terminal.</li>
  <li>Xcode’s “Swift 5 interface” counterpart to the <code>webgpu.h</code> header will show how the header has been mapped into Swift.</li>
</ul>

<p>Let’s do it from the command line, using <code>swift-synthesize-interface</code>. From the directory containing <code>webgpu.h</code> and <code>module.modulemap</code>, run:</p>

<div><div><pre><code><span>xcrun</span> <span>swift</span><span>-</span><span>synthesize</span><span>-</span><span>interface</span> <span>-</span><span>I</span> <span>.</span> <span>-</span><span>module</span><span>-</span><span>name</span> <span>WebGPU</span> <span>-</span><span>target</span> <span>arm64</span><span>-</span><span>apple</span><span>-</span><span>macos15</span> <span>-</span><span>sdk</span> <span>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/</span><span>MacOSX26</span><span>.</span><span>0</span><span>.</span><span>sdk</span>
</code></pre></div></div>

<p>The leading <code>xcrun</code> and the <code>-sdk</code> argument with the path is only needed on macOS; on other platforms, make sure <code>swift-synthesize-interface</code> is in your path. The <code>-target</code> operation is the triple provided if you run <code>swiftc -print-target-info</code>. It looks like this:</p>

<div><div><pre><code><span>{</span><span>
  </span><span>&#34;compilerVersion&#34;</span><span>:</span><span> </span><span>&#34;Apple Swift version 6.2 (swiftlang-6.2.2.15.4 clang-1700.3.15.2)&#34;</span><span>,</span><span>
  </span><span>&#34;target&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;triple&#34;</span><span>:</span><span> </span><span>&#34;arm64-apple-macosx15.0&#34;</span><span>,</span><span>
    </span><span>&#34;unversionedTriple&#34;</span><span>:</span><span> </span><span>&#34;arm64-apple-macosx&#34;</span><span>,</span><span>
    </span><span>&#34;moduleTriple&#34;</span><span>:</span><span> </span><span>&#34;arm64-apple-macos&#34;</span><span>,</span><span>
    </span><span>&#34;compatibilityLibraries&#34;</span><span>:</span><span> </span><span>[</span><span> </span><span>],</span><span>
    </span><span>&#34;librariesRequireRPath&#34;</span><span>:</span><span> </span><span>false</span><span>
  </span><span>},</span><span>
  </span><span>&#34;paths&#34;</span><span>:</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div></div>

<p>The output of <code>swift-synthesize-interface</code> is the Swift API for the WebGPU module, directly translated from C. For example, this code from the WebGPU header:</p>

<div><div><pre><code><span>typedef</span> <span>enum</span> <span>WGPUAdapterType</span> <span>{</span>
    <span>WGPUAdapterType_DiscreteGPU</span> <span>=</span> <span>0x00000001</span><span>,</span>
    <span>WGPUAdapterType_IntegratedGPU</span> <span>=</span> <span>0x00000002</span><span>,</span>
    <span>WGPUAdapterType_CPU</span> <span>=</span> <span>0x00000003</span><span>,</span>
    <span>WGPUAdapterType_Unknown</span> <span>=</span> <span>0x00000004</span><span>,</span>
    <span>WGPUAdapterType_Force32</span> <span>=</span> <span>0x7FFFFFFF</span>
<span>}</span> <span>WGPUAdapterType</span> <span>WGPU_ENUM_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>is translated into:</p>

<div><div><pre><code><span>public</span> <span>struct</span> <span>WGPUAdapterType</span> <span>:</span> <span>Hashable</span><span>,</span> <span>Equatable</span><span>,</span> <span>RawRepresentable</span> <span>{</span>
    <span>public</span> <span>init</span><span>(</span><span>_</span> <span>rawValue</span><span>:</span> <span>UInt32</span><span>)</span>
    <span>public</span> <span>init</span><span>(</span><span>rawValue</span><span>:</span> <span>UInt32</span><span>)</span>
    <span>public</span> <span>var</span> <span>rawValue</span><span>:</span> <span>UInt32</span>
<span>}</span>

<span>public</span> <span>var</span> <span>WGPUAdapterType_DiscreteGPU</span><span>:</span> <span>WGPUAdapterType</span> <span>{</span> <span>get</span> <span>}</span>
<span>public</span> <span>var</span> <span>WGPUAdapterType_IntegratedGPU</span><span>:</span> <span>WGPUAdapterType</span> <span>{</span> <span>get</span> <span>}</span>
<span>public</span> <span>var</span> <span>WGPUAdapterType_CPU</span><span>:</span> <span>WGPUAdapterType</span> <span>{</span> <span>get</span> <span>}</span>
<span>public</span> <span>var</span> <span>WGPUAdapterType_Unknown</span><span>:</span> <span>WGPUAdapterType</span> <span>{</span> <span>get</span> <span>}</span>
<span>public</span> <span>var</span> <span>WGPUAdapterType_Force32</span><span>:</span> <span>WGPUAdapterType</span> <span>{</span> <span>get</span> <span>}</span>
</code></pre></div></div>

<p>and there are lots of global functions like this:</p>

<div><div><pre><code><span>public</span> <span>func</span> <span>wgpuComputePipelineGetBindGroupLayout</span><span>(</span><span>_</span> <span>computePipeline</span><span>:</span> <span>WGPUComputePipeline</span><span>!</span><span>,</span> <span>_</span> <span>groupIndex</span><span>:</span> <span>UInt32</span><span>)</span> <span>-&gt;</span> <span>WGPUBindGroupLayout</span><span>!</span>
<span>public</span> <span>func</span> <span>wgpuComputePipelineSetLabel</span><span>(</span><span>_</span> <span>computePipeline</span><span>:</span> <span>WGPUComputePipeline</span><span>!</span><span>,</span> <span>_</span> <span>label</span><span>:</span> <span>WGPUStringView</span><span>)</span>
<span>public</span> <span>func</span> <span>wgpuComputePipelineAddRef</span><span>(</span><span>_</span> <span>computePipeline</span><span>:</span> <span>WGPUComputePipeline</span><span>!</span><span>)</span>
<span>public</span> <span>func</span> <span>wgpuComputePipelineRelease</span><span>(</span><span>_</span> <span>computePipeline</span><span>:</span> <span>WGPUComputePipeline</span><span>!</span><span>)</span>
</code></pre></div></div>

<p>It’s a starting point! You can absolutely write Swift programs using these WebGPU APIs, and they’ll feel a lot like writing them in C. Let’s see what we can do to make it better.</p>



<p>C enums can be used for several things. Sometimes they really represent a choice among a number of alternatives. Sometimes they represent flags in a set of options, from which you can choose several. Sometimes they’re just a convenient way to create a bunch of named constants. Swift conservatively imports enum types as wrappers over the underlying C type used to store values of the enum (e.g., <code>WGPUAdapterType</code> wraps a <code>UInt32</code>) and makes the enumerators into global constants. It covers all of the possible use cases, but it isn’t <em>nice</em>.</p>

<p>The <code>WGPUAdapterType</code> enum really is a choice among one of several options, which would be best represented as an <code>enum</code> in Swift. If we were willing to modify the header, we could apply the <a href="https://clang.llvm.org/docs/AttributeReference.html#enum-extensibility"><code>enum_extensibility</code> attribute</a> to the enum, like this:</p>

<div><div><pre><code><span>typedef</span> <span>enum</span> <span>__attribute__</span><span>((</span><span>enum_extensibility</span><span>(</span><span>closed</span><span>)))</span> <span>WGPUAdapterType</span> <span>{</span>
    <span>WGPUAdapterType_DiscreteGPU</span> <span>=</span> <span>0x00000001</span><span>,</span>
    <span>WGPUAdapterType_IntegratedGPU</span> <span>=</span> <span>0x00000002</span><span>,</span>
    <span>WGPUAdapterType_CPU</span> <span>=</span> <span>0x00000003</span><span>,</span>
    <span>WGPUAdapterType_Unknown</span> <span>=</span> <span>0x00000004</span><span>,</span>
    <span>WGPUAdapterType_Force32</span> <span>=</span> <span>0x7FFFFFFF</span>
<span>}</span> <span>WGPUAdapterType</span> <span>WGPU_ENUM_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>This works, and results in a much nicer Swift API:</p>

<div><div><pre><code><span>@frozen</span> <span>public</span> <span>enum</span> <span>WGPUAdapterType</span> <span>:</span> <span>UInt32</span><span>,</span> <span>@unchecked</span> <span>Sendable</span> <span>{</span>
    <span>case</span> <span>discreteGPU</span> <span>=</span> <span>1</span>
    <span>case</span> <span>integratedGPU</span> <span>=</span> <span>2</span>
    <span>case</span> <span>CPU</span> <span>=</span> <span>3</span>
    <span>case</span> <span>unknown</span> <span>=</span> <span>4</span>
    <span>case</span> <span>force32</span> <span>=</span> <span>2147483647</span>
<span>}</span>
</code></pre></div></div>

<p>Now, we get an <code>enum</code> that we can switch over, and nice short case names, e.g.,</p>

<div><div><pre><code><span>switch</span> <span>adapterType</span> <span>{</span>
  <span>case</span> <span>.</span><span>discreteGPU</span><span>,</span> <span>.</span><span>integratedGPU</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;definitely a GPU&#34;</span><span>)</span>
  <span>default</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;not so sure&#34;</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>That’s great, but I already broke my rule: no header modifications unless I have to!</p>



<p>The problem of needing to layer information on top of existing C headers is not a new one. As noted earlier, Swift relies on a Clang feature called <a href="https://clang.llvm.org/docs/APINotes.html">API notes</a> to let us express this same information in a separate file, so we don’t have to edit the header. In this case, we create a file called <code>WebGPU.apinotes</code> (the name <code>WebGPU</code> matches the module name from <code>module.modulemap</code>), which is a YAML file describing the extra information. We’ll start with one that turns <code>WGPUAdapterType</code> into an <code>enum</code>:</p>

<div><div><pre><code><span>---</span>
<span>Name</span><span>:</span> <span>WebGPU</span>
<span>Tags</span><span>:</span>
<span>-</span> <span>Name</span><span>:</span> <span>WGPUAdapterType</span>
  <span>EnumExtensibility</span><span>:</span> <span>closed</span>
</code></pre></div></div>

<p><code>Tags</code> here is a term used in the C and C++ standard to refer to enum, struct, union, or class types. Any information about those types in the API notes file will go into that section.</p>

<p>Put <code>WebGPU.apinotes</code> alongside the <code>module.modulemap</code>, and now <code>WGPUAdapterType</code> gets mapped into a <code>Swift</code> enum. For a package, the structure will look like this:</p>

<div><div><pre><code><span>├──</span> <span>Package</span><span>.</span><span>swift</span>
<span>└──</span> <span>Sources</span>
    <span>└──</span> <span>WebGPU</span>
        <span>├──</span> <span>include</span>
        <span>│</span>   <span>├──</span> <span>webgpu</span><span>.</span><span>h</span>
        <span>│</span>   <span>├──</span> <span>WebGPU</span><span>.</span><span>apinotes</span>
        <span>│</span>   <span>└──</span> <span>module</span><span>.</span><span>modulemap</span>
        <span>└──</span> <span>WebGPU</span><span>.</span><span>c</span> <span>(</span><span>empty</span> <span>file</span><span>)</span>
</code></pre></div></div>

<p>We’ll be adding more to this API notes file as we keep digging through the interface.</p>



<p>The WebGPU header has a number of “object” types that are defined like this:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>WGPUBindGroupImpl</span><span>*</span> <span>WGPUBindGroup</span> <span>WGPU_OBJECT_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>This gets imported into Swift as an alias for an opaque pointer type, which is… not great:</p>

<div><div><pre><code><span>public</span> <span>typealias</span> <span>WGPUBindGroup</span> <span>=</span> <span>OpaquePointer</span>
</code></pre></div></div>

<p>WebGPU object types are reference counted, and each object type has corresponding <code>AddRef</code> and <code>Release</code> functions to increment and decrement the reference count, like this:</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>void</span> <span>wgpuBindGroupAddRef</span><span>(</span><span>WGPUBindGroup</span> <span>bindGroup</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
<span>WGPU_EXPORT</span> <span>void</span> <span>wgpuBindGroupRelease</span><span>(</span><span>WGPUBindGroup</span> <span>bindGroup</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>Of course, you can use these functions in Swift exactly how you do in C, making sure to balance out calls to <code>AddRef</code> and <code>Release</code>, but then it would be every bit as unsafe as C.</p>

<p>We can do better with <a href="https://www.swift.org/documentation/cxx-interop/#shared-reference-types"><code>SWIFT_SHARED_REFERENCE</code></a>. It’s a macro (defined in the <code>&lt;swift/bridging&gt;</code> header) that can turn a reference-counted C type like the above into an automatically reference-counted <code>class</code> in Swift. Here’s how we would use it in the header:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>SWIFT_SHARED_REFERENCE</span><span>(</span><span>wgpuBindGroupAddRef</span><span>,</span> <span>wgpuBindGroupRelease</span><span>)</span> <span>WGPUBindGroupImpl</span><span>*</span> <span>WGPUBindGroup</span> <span>WGPU_OBJECT_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>Now, <code>WGPUBindGroup</code> gets imported like this:</p>

<div><div><pre><code><span>public</span> <span>class</span> <span>WGPUBindGroupImpl</span> <span>{</span> <span>}</span>
<span>public</span> <span>typealias</span> <span>WGPUBindGroup</span> <span>=</span> <span>WGPUBindGroupImpl</span>
</code></pre></div></div>

<p>The extra typealias is a little unexpected, but overall this is a huge improvement: Swift is treating <code>WGPUBindGroup</code> as a class, meaning that it automatically manages retains and releases for you! This is both an ergonomic win (less code to write) and a safety win, because it’s eliminated the possibility of mismanaging these instances.</p>

<p>There’s one more thing: when dealing with reference-counting APIs, you need to know whether a particular function that returns an object is expecting you to call “release” when you’re done. In the WebGPU header, this information is embedded in a comment:</p>

<div><div><pre><code><span>/**
 * @returns
 * This value is @ref ReturnedWithOwnership.
 */</span>
<span>WGPU_EXPORT</span> <span>WGPUBindGroup</span> <span>wgpuDeviceCreateBindGroup</span><span>(</span><span>WGPUDevice</span> <span>device</span><span>,</span> <span>WGPUBindGroupDescriptor</span> <span>const</span> <span>*</span> <span>descriptor</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>“ReturnedWithOwnership” here means that the result of the call has already been retained one extra time, and the caller is responsible for calling “release” when they are done with it. The <code>&lt;swift/bridging&gt;</code> header has a <code>SWIFT_RETURNS_RETAINED</code> macro that expresses this notion. One can use it like this:</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>WGPUBindGroup</span> <span>wgpuDeviceCreateBindGroup</span><span>(</span><span>WGPUDevice</span> <span>device</span><span>,</span> <span>WGPUBindGroupDescriptor</span> <span>const</span> <span>*</span> <span>descriptor</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span> <span>SWIFT_RETURNS_RETAINED</span><span>;</span>
</code></pre></div></div>

<p>Now, Swift will balance out the retain that <code>wgpuDeviceCreateBindGroup</code> has promised to do by performing the extra release once you’re done using the object. Once these annotations are done, we’re all set with a more ergonomic and memory-safe API for this C library. There’s no need to ever call <code>wgpuBindGroupRelease</code> or <code>wgpuBindGroupAddRef</code> yourself.</p>

<p>We’ve hacked up our header again, so let’s undo that and move all of this out to API notes. To turn a type into a foreign reference type, we augment the <code>Tags</code> section of our API notes with the same information, but in YAML form:</p>

<div><div><pre><code><span>-</span> <span>Name</span><span>:</span> <span>WGPUBindGroupImpl</span>
  <span>SwiftImportAs</span><span>:</span> <span>reference</span>
  <span>SwiftReleaseOp</span><span>:</span> <span>wgpuBindGroupRelease</span>
  <span>SwiftRetainOp</span><span>:</span> <span>wgpuBindGroupAddRef</span>
</code></pre></div></div>

<p>That makes <code>WGPUBindGroupImpl</code> import as a class type, with the given retain and release functions. We can express the “returns retained” behavior of the <code>wgpuDeviceCreateBindGroup</code> function like this:</p>

<div><div><pre><code><span>Functions</span><span>:</span>
<span>-</span> <span>Name</span><span>:</span> <span>wgpuDeviceCreateBindGroup</span>
  <span>SwiftReturnOwnership</span><span>:</span> <span>retained</span>
</code></pre></div></div>

<p>That’s enums and classes, so now let’s tackle… functions.</p>



<p>A typical function from <code>webgpu.h</code>, like this:</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>void</span> <span>wgpuQueueWriteBuffer</span><span>(</span>
    <span>WGPUQueue</span> <span>queue</span><span>,</span> <span>WGPUBuffer</span> <span>buffer</span><span>,</span> <span>uint64_t</span> <span>bufferOffset</span><span>,</span> 
    <span>void</span> <span>const</span> <span>*</span> <span>data</span><span>,</span> <span>size_t</span> <span>size</span>
<span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>will come into Swift like this:</p>

<div><div><pre><code><span>public</span> <span>func</span> <span>wgpuQueueWriteBuffer</span><span>(</span><span>_</span> <span>queue</span><span>:</span> <span>WGPUQueue</span><span>!</span><span>,</span> <span>_</span> <span>buffer</span><span>:</span> <span>WGPUBuffer</span><span>!</span><span>,</span> <span>_</span> <span>bufferOffset</span><span>:</span> <span>UInt64</span><span>,</span> <span>_</span> <span>data</span><span>:</span> <span>UnsafeRawPointer</span><span>!</span><span>,</span> <span>_</span> <span>size</span><span>:</span> <span>Int</span><span>)</span>
</code></pre></div></div>

<p>Note that <code>_</code> on each parameter, which means that we won’t use argument labels for anything when we call it:</p>

<div><div><pre><code><span>wgpuQueueWriteBuffer</span><span>(</span><span>myQueue</span><span>,</span> <span>buffer</span><span>,</span> <span>position</span><span>,</span> <span>dataToWrite</span><span>,</span> <span>bytesToWrite</span><span>)</span>
</code></pre></div></div>

<p>That matches C, but it isn’t as clear as it could be in Swift. Let’s clean this up by providing a better name in Swift that includes argument labels. We can do so using <code>SWIFT_NAME</code> (also in <code>&lt;swift/bridging&gt;</code>), like this:</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>void</span> <span>wgpuQueueWriteBuffer</span><span>(</span>
      <span>WGPUQueue</span> <span>queue</span><span>,</span> <span>WGPUBuffer</span> <span>buffer</span><span>,</span> <span>uint64_t</span> <span>bufferOffset</span><span>,</span>
      <span>void</span> <span>const</span> <span>*</span> <span>data</span><span>,</span> <span>size_t</span> <span>size</span>
  <span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span> 
    <span>SWIFT_NAME</span><span>(</span><span>&#34;wgpuQueueWriteBuffer(_:buffer:bufferOffset:data:size:)&#34;</span><span>);</span>
</code></pre></div></div>

<p>Within the parentheses, we have each of the argument labels that we want (or <code>_</code> meaning “no label”), each followed by a <code>:</code>. This is how one describes a full function name in Swift. Once we’ve made this change to the Swift name, the C function comes into Swift with argument labels, like this:</p>

<div><div><pre><code><span>public</span> <span>func</span> <span>wgpuQueueWriteBuffer</span><span>(</span><span>_</span> <span>queue</span><span>:</span> <span>WGPUQueue</span><span>!</span><span>,</span> <span>buffer</span><span>:</span> <span>WGPUBuffer</span><span>!</span><span>,</span> <span>bufferOffset</span><span>:</span> <span>UInt64</span><span>,</span> <span>data</span><span>:</span> <span>UnsafeRawPointer</span><span>!</span><span>,</span> <span>size</span><span>:</span> <span>Int</span><span>)</span>
</code></pre></div></div>

<p>That makes the call site more clear and self-documenting:</p>

<div><div><pre><code><span>wgpuQueueWriteBuffer</span><span>(</span><span>myQueue</span><span>,</span> <span>buffer</span><span>:</span> <span>buffer</span><span>,</span> <span>offset</span><span>:</span> <span>position</span><span>,</span> <span>data</span><span>:</span> <span>dataToWrite</span><span>,</span> <span>size</span><span>:</span> <span>bytesToWrite</span><span>)</span>
</code></pre></div></div>



<p>There is more usable structure in this API. Note that the <code>wgpuQueueWriteBuffer</code> function takes, as its first argument, an instance of <code>WGPUQueue</code>. Most of the C functions in <code>WebGPU.h</code> are like this, because these are effectively functions that operate on their first argument. In a language that has methods, they would be methods. Swift has methods, so let’s make them methods!</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>void</span> <span>wgpuQueueWriteBuffer</span><span>(</span>
      <span>WGPUQueue</span> <span>queue</span><span>,</span> <span>WGPUBuffer</span> <span>buffer</span><span>,</span> <span>uint64_t</span> <span>bufferOffset</span><span>,</span> <span>void</span> <span>const</span> <span>*</span> <span>data</span><span>,</span> <span>size_t</span> <span>size</span><span>)</span> 
  <span>WGPU_FUNCTION_ATTRIBUTE</span> <span>SWIFT_NAME</span><span>(</span><span>&#34;WGPUQueueImpl.writeBuffer(self:buffer:bufferOffset:data:size:)&#34;</span><span>);</span>
</code></pre></div></div>

<p>There are three things to notice about this <code>SWIFT_NAME</code> string:</p>

<ul>
  <li>It starts with <code>WGPUQueueImpl.</code>, which tells Swift to make this function a member inside <code>WGPUQueueImpl</code>.</li>
  <li>Let’s change the function name to <code>writeBuffer</code>, because we no longer need the <code>wgpuQueue</code> prefix to distinguish it from other “write buffer” operations on other types.</li>
  <li>The name of the first argument in parentheses is <code>self</code>, which indicates that the <code>self</code> argument (in Swift) should be passed as that positional argument to the C function. The other arguments are passed in-order.</li>
</ul>

<p>Note that this also requires <code>WGPUQueue(Impl)</code> to be imported as a <code>class</code>, as we did earlier for <code>WGPUBindGroupImpl</code>. Once we’ve done so, we get a much-nicer Swift API:</p>

<div><div><pre><code><span>extension</span> <span>WGPUQueueImpl</span> <span>{</span>
  <span>/**
   * Produces a @ref DeviceError both content-timeline (`size` alignment) and d
evice-timeline
   * errors defined by the WebGPU specification.
   */</span>
  <span>public</span> <span>func</span> <span>writeBuffer</span><span>(</span><span>buffer</span><span>:</span> <span>WGPUBuffer</span><span>!</span><span>,</span> <span>bufferOffset</span><span>:</span> <span>UInt64</span><span>,</span> <span>data</span><span>:</span> <span>UnsafeRawPointer</span><span>!</span><span>,</span> <span>size</span><span>:</span> <span>Int</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>We’ve hacked up the header again, but didn’t have to. In <code>WebGPU.apinotes</code>, you can put a <code>SwiftName</code> attribute on any entity. For <code>wgpuQueueWriteBuffer</code>, it would look like this (in the <code>Functions</code> section):</p>

<div><div><pre><code><span>-</span> <span>Name</span><span>:</span> <span>wgpuQueueWriteBuffer</span>
  <span>SwiftName</span><span>:</span> <span>WGPUQueueImpl.writeBuffer(self:buffer:bufferOffset:data:size:)</span>
</code></pre></div></div>



<p><code>WebGPU.h</code> has a number of <code>Get</code> functions that produce information about some aspect of a type. Here are two for the <code>WGPUQuerySet</code> type:</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>uint32_t</span> <span>wgpuQuerySetGetCount</span><span>(</span><span>WGPUQuerySet</span> <span>querySet</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
<span>WGPU_EXPORT</span> <span>WGPUQueryType</span> <span>wgpuQuerySetGetType</span><span>(</span><span>WGPUQuerySet</span> <span>querySet</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>With the <code>SWIFT_NAME</code> tricks above, we can turn these into “get” methods on <code>WGPUQuerySet</code>, like this:</p>

<div><div><pre><code><span>extension</span> <span>WGPUQuerySetImpl</span> <span>{</span>
    <span>public</span> <span>func</span> <span>getCount</span><span>()</span> <span>-&gt;</span> <span>UInt32</span>
    <span>public</span> <span>func</span> <span>getType</span><span>()</span> <span>-&gt;</span> <span>WGPUQueryType</span>
<span>}</span>
</code></pre></div></div>

<p>That’s okay, but it’s not what you’d do in Swift. Let’s go one step further and turn them into read-only computed properties. To do so, use the <code>getter:</code> prefix on the Swift name we define. We’ll skip ahead to the YAML form that goes into API notes:</p>

<div><div><pre><code><span>-</span> <span>Name</span><span>:</span> <span>wgpuQuerySetGetCount</span>
  <span>SwiftName</span><span>:</span> <span>getter:WGPUQuerySetImpl.count(self:)</span>
<span>-</span> <span>Name</span><span>:</span> <span>wgpuQuerySetGetType</span>
  <span>SwiftName</span><span>:</span> <span>getter:WGPUQuerySetImpl.type(self:)</span>
</code></pre></div></div>

<p>And now, we arrive at a nice Swift API:</p>

<div><div><pre><code><span>extension</span> <span>WGPUQuerySetImpl</span> <span>{</span>
    <span>public</span> <span>var</span> <span>count</span><span>:</span> <span>UInt32</span> <span>{</span> <span>get</span> <span>}</span>
    <span>public</span> <span>var</span> <span>type</span><span>:</span> <span>WGPUQueryType</span> <span>{</span> <span>get</span> <span>}</span>
<span>}</span>
</code></pre></div></div>



<p><code>SWIFT_NAME</code> can also be used to import a function that returns a new instance as a Swift initializer. For example, this function creates a new <code>WGPUInstance</code> (which we assume is getting imported as a <code>class</code> like we’ve been doing above):</p>

<div><div><pre><code><span>/**
 * Create a WGPUInstance
 *
 * @returns
 * This value is @ref ReturnedWithOwnership.
 */</span>
<span>WGPU_EXPORT</span> <span>WGPUInstance</span> <span>wgpuCreateInstance</span><span>(</span><span>WGPU_NULLABLE</span> <span>WGPUInstanceDescriptor</span> <span>const</span> <span>*</span> <span>descriptor</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>We can turn this into a Swift initializer, which is used to create a new object, using the same <code>SWIFT_NAME</code> syntax but where the method name is <code>init</code>. Here is the YAML form that goes into API notes:</p>

<div><div><pre><code><span>-</span> <span>Name</span><span>:</span> <span>wgpuCreateInstance</span>
  <span>SwiftReturnOwnership</span><span>:</span> <span>retained</span>
  <span>SwiftName</span><span>:</span> <span>WGPUInstanceImpl.init(descriptor:)</span>
</code></pre></div></div>

<p>and here is the resulting Swift initializer:</p>

<div><div><pre><code><span>extension</span> <span>WGPUInstanceImpl</span> <span>{</span>
    <span>/**
     * Create a WGPUInstance
     *
     * @returns
     * This value is @ref ReturnedWithOwnership.
     */</span>
    <span>public</span> <span>/*not inherited*/</span> <span>init</span><span>!</span><span>(</span><span>descriptor</span><span>:</span> <span>UnsafePointer</span><span>&lt;</span><span>WGPUInstanceDescriptor</span><span>&gt;!</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>Now, one can create a new <code>WGPUInstance</code> with the normal object-creation syntax, e.g.,</p>

<div><div><pre><code><span>let</span> <span>instance</span> <span>=</span> <span>WGPUInstance</span><span>(</span><span>descriptor</span><span>:</span> <span>myDescriptor</span><span>)</span>
</code></pre></div></div>



<p>The WebGPU header defines its own Boolean type. I wish everyone would use C99’s <code>_Bool</code> and be done with it, but alas, here are the definitions for WebGPUs Boolean types:</p>

<div><div><pre><code><span>#define WGPU_TRUE (UINT32_C(1))
#define WGPU_FALSE (UINT32_C(0))
</span><span>typedef</span> <span>uint32_t</span> <span>WGPUBool</span><span>;</span>
</code></pre></div></div>

<p>This means that <code>WGPUBool</code> will come in to Swift as a <code>UInt32</code>. The two macros aren’t available in Swift at all: they’re “too complicated” to be recognized as integral constants. Even if they were available in Swift, it still wouldn’t be great because we want to use <code>true</code> and <code>false</code> for Boolean values in Swift, not <code>WGPU_TRUE</code> and <code>WGPU_FALSE</code>.</p>

<p>To make <code>WGPUBool</code> easier to use from Swift, we’re first going to map that typedef to its own <code>struct</code> that stores the underlying <code>UInt32</code>, giving it an identity separate from <code>UInt32</code>. We can do this using a <code>SwiftWrapper</code> API note within the <code>Typedefs</code> section of the file, like this:</p>

<div><div><pre><code><span>-</span> <span>Name</span><span>:</span> <span>WGPUBool</span>
  <span>SwiftWrapper</span><span>:</span> <span>struct</span>
</code></pre></div></div>

<p>Now, we get <code>WGPUBool</code> imported like this:</p>

<div><div><pre><code><span>public</span> <span>struct</span> <span>WGPUBool</span> <span>:</span> <span>Hashable</span><span>,</span> <span>Equatable</span><span>,</span> <span>RawRepresentable</span> <span>{</span>
    <span>public</span> <span>init</span><span>(</span><span>_</span> <span>rawValue</span><span>:</span> <span>UInt32</span><span>)</span>
    <span>public</span> <span>init</span><span>(</span><span>rawValue</span><span>:</span> <span>UInt32</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>To be able to use <code>true</code> and <code>false</code> literals with this new <code>WGPUBool</code>, we can write a little bit of Swift code that makes this type conform to the <a href="https://developer.apple.com/documentation/swift/expressiblebybooleanliteral"><code>ExpressibleByBooleanLiteral</code></a> protocol, like this:</p>

<div><div><pre><code><span>extension</span> <span>WGPUBool</span><span>:</span> <span>ExpressibleByBooleanLiteral</span> <span>{</span>
  <span>init</span><span>(</span><span>booleanLiteral</span> <span>value</span><span>:</span> <span>Bool</span><span>)</span> <span>{</span>
    <span>self</span><span>.</span><span>init</span><span>(</span><span>rawValue</span><span>:</span> <span>value</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>That’s it! Better type safety (you cannot confuse a <code>WGPUBool</code> with any other integer value) and the convenience of Boolean literals in Swift.</p>



<p><code>webgpu.h</code> describes a set of flags using a <code>typedef</code> of the <code>WGPUFlags</code> type (a 64-bit unsigned integer) along with a set of global constants for the different flag values. For example, here is the <code>WGPUBufferUsage</code> flag type and some of its constants:</p>

<div><div><pre><code><span>typedef</span> <span>WGPUFlags</span> <span>WGPUBufferUsage</span><span>;</span>
<span>static</span> <span>const</span> <span>WGPUBufferUsage</span> <span>WGPUBufferUsage_MapRead</span> <span>=</span> <span>0x0000000000000001</span><span>;</span>
<span>static</span> <span>const</span> <span>WGPUBufferUsage</span> <span>WGPUBufferUsage_MapWrite</span> <span>=</span> <span>0x0000000000000002</span><span>;</span>
<span>static</span> <span>const</span> <span>WGPUBufferUsage</span> <span>WGPUBufferUsage_CopySrc</span> <span>=</span> <span>0x0000000000000004</span><span>;</span>
<span>static</span> <span>const</span> <span>WGPUBufferUsage</span> <span>WGPUBufferUsage_Index</span> <span>=</span> <span>0x0000000000000010</span><span>;</span>
</code></pre></div></div>

<p>Similar to what we saw with <code>WGPUBool</code>, <code>WGPUBufferUsage</code> is a <code>typedef</code> of a <code>typedef</code> of a <code>uint64_t</code>. There’s no type safety in this C API, and one could easily mix up these flags with, say, those of <code>WGPUMapMode</code>:</p>

<div><div><pre><code><span>typedef</span> <span>WGPUFlags</span> <span>WGPUMapMode</span><span>;</span>
<span>static</span> <span>const</span> <span>WGPUMapMode</span> <span>WGPUMapMode_Read</span> <span>=</span> <span>0x0000000000000001</span><span>;</span>
<span>static</span> <span>const</span> <span>WGPUMapMode</span> <span>WGPUMapMode_Write</span> <span>=</span> <span>0x0000000000000002</span><span>;</span>
</code></pre></div></div>

<p>We can do better, by layering more structure for the Swift version of this API using the same <code>SwiftWrapper</code> approach from <code>WGPUBool</code>. This goes into the <code>Typedefs</code> section of API notes:</p>

<div><div><pre><code><span>Typedefs</span><span>:</span>
<span>-</span> <span>Name</span><span>:</span> <span>WGPUBufferUsage</span>
  <span>SwiftWrapper</span><span>:</span> <span>struct</span>
</code></pre></div></div>

<p>Now, <code>WGPUBufferUsage</code> comes in as its own <code>struct</code>:</p>

<div><div><pre><code><span>public</span> <span>struct</span> <span>WGPUBufferUsage</span> <span>:</span> <span>Hashable</span><span>,</span> <span>Equatable</span><span>,</span> <span>RawRepresentable</span> <span>{</span>
    <span>public</span> <span>init</span><span>(</span><span>_</span> <span>rawValue</span><span>:</span> <span>WGPUFlags</span><span>)</span>
    <span>public</span> <span>init</span><span>(</span><span>rawValue</span><span>:</span> <span>WGPUFlags</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>The initializers let you create a <code>WGPUBufferUsage</code> from a <code>WGPUFlags</code> value, and there is also a <code>rawValue</code> property to get a <code>WGPUFlags</code> value out of a <code>WGPUBufferInstance</code>, so the raw value is always there… but the default is to be type safe. Additionally, those global constants will come in as members of <code>WGPUBufferUsage</code>, like this:</p>

<div><div><pre><code><span>extension</span> <span>WGPUBufferUsage</span> <span>{</span>
    <span>/**
     * The buffer can be *mapped* on the CPU side in *read* mode (using @ref WGPUMapMode_Read).
     */</span>
    <span>public</span> <span>static</span> <span>var</span> <span>_MapRead</span><span>:</span> <span>WGPUBufferUsage</span> <span>{</span> <span>get</span> <span>}</span>

    <span>/**
     * The buffer can be *mapped* on the CPU side in *write* mode (using @ref WGPUMapMode_Write).
     *
     * @note This usage is **not** required to set `mappedAtCreation` to `true` in @ref WGPUBufferDescriptor.
     */</span>
    <span>public</span> <span>static</span> <span>var</span> <span>_MapWrite</span><span>:</span> <span>WGPUBufferUsage</span> <span>{</span> <span>get</span> <span>}</span>

    <span>/**
     * The buffer can be used as the *source* of a GPU-side copy operation.
     */</span>
    <span>public</span> <span>static</span> <span>var</span> <span>_CopySrc</span><span>:</span> <span>WGPUBufferUsage</span> <span>{</span> <span>get</span> <span>}</span>

    <span>/**
     * The buffer can be used as the *destination* of a GPU-side copy operation.
     */</span>
    <span>public</span> <span>static</span> <span>var</span> <span>_CopyDst</span><span>:</span> <span>WGPUBufferUsage</span> <span>{</span> <span>get</span> <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This means that, if you’re passing a value of type <code>WPUBufferUsage</code>, you can use the shorthand “leading dot” syntax. For example:</p>

<div><div><pre><code><span>func</span> <span>setBufferUsage</span><span>(</span><span>_</span> <span>usage</span><span>:</span> <span>WGPUBufferUsage</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>

<span>setBufferUsage</span><span>(</span><span>.</span><span>_MapRead</span><span>)</span>
</code></pre></div></div>

<p>Swift has dropped the common <code>WPUBufferUsage</code> prefix from the constants when it made them into members. However, the resulting names aren’t great. We can rename them by providing a <code>SwiftName</code> in the API notes file within the <code>Globals</code> section:</p>

<div><div><pre><code><span>Globals</span><span>:</span>
<span>-</span> <span>Name</span><span>:</span> <span>WGPUBufferUsage_MapRead</span>
  <span>SwiftName</span><span>:</span> <span>WGPUBufferUsage.mapRead</span>
<span>-</span> <span>Name</span><span>:</span> <span>WGPUBufferUsage_MapWrite</span>
  <span>SwiftName</span><span>:</span> <span>WGPUBufferUsage.mapWrite</span>
</code></pre></div></div>

<p>We can go one step further by making the <code>WGPUBufferUsage</code> type conform to Swift’s <a href="https://developer.apple.com/documentation/swift/optionset"><code>OptionSet</code></a> protocol. If we revise the API notes like this:</p>

<div><div><pre><code><span>Typedefs</span><span>:</span>
<span>-</span> <span>Name</span><span>:</span> <span>WGPUBufferUsage</span>
  <span>SwiftWrapper</span><span>:</span> <span>struct</span>
  <span>SwiftConformsTo</span><span>:</span> <span>Swift.OptionSet</span>
</code></pre></div></div>

<p>Now, we get the nice option-set syntax we expect in Swift:</p>

<div><div><pre><code><span>let</span> <span>usageFlags</span><span>:</span> <span>WGPUBufferUsage</span> <span>=</span> <span>[</span><span>.</span><span>mapRead</span><span>,</span> <span>.</span><span>mapWrite</span><span>]</span>
</code></pre></div></div>



<p>Throughout <code>webgpu.h</code>, the <code>WGPU_NULLABLE</code> macro is used to indicate pointers that can be NULL. The implication is that any pointer that is not marked with <code>WGPU_NULLABLE</code> cannot be NULL. For example, here is the definition of <code>wgpuCreateInstance</code> we used above:</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>WGPUInstance</span> <span>wgpuCreateInstance</span><span>(</span><span>WGPU_NULLABLE</span> <span>WGPUInstanceDescriptor</span> <span>const</span> <span>*</span> <span>descriptor</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>The <code>WGPU_NULLABLE</code> indicates that it’s acceptable to pass a NULL pointer in as the <code>descriptor</code> parameter. Clang already has <a href="https://clang.llvm.org/docs/AttributeReference.html#nullability-attributes">nullability specifiers</a> to express this information. We could alter the declaration in the header to express that this parameter is nullable but the result type is never NULL, like this:</p>

<div><div><pre><code><span>WGPU_EXPORT</span> <span>WGPUInstance</span> <span>_Nonnull</span> <span>wgpuCreateInstance</span><span>(</span><span>WGPU_NULLABLE</span> <span>WGPUInstanceDescriptor</span> <span>const</span> <span>*</span> <span>_Nullable</span> <span>descriptor</span><span>)</span> <span>WGPU_FUNCTION_ATTRIBUTE</span><span>;</span>
</code></pre></div></div>

<p>This eliminates the implicitly-unwrapped optionals (<code>!</code>) from the signature of the initializer, so we end up with one that explicitly accepts a <code>nil</code> descriptor argument and always returns a new instance (never <code>nil</code>):</p>

<div><div><pre><code><span>extension</span> <span>WGPUInstanceImpl</span> <span>{</span>
    <span>/**
     * Create a WGPUInstance
     *
     * @returns
     * This value is @ref ReturnedWithOwnership.
     */</span>
    <span>public</span> <span>/*not inherited*/</span> <span>init</span><span>(</span><span>descriptor</span><span>:</span> <span>UnsafePointer</span><span>&lt;</span><span>WGPUInstanceDescriptor</span><span>&gt;</span><span>?)</span>
<span>}</span>
</code></pre></div></div>

<p>Now, I did cheat by hacking the header. Instead, we can express this with API notes on the parameters and result type by extending the entry we already have for <code>wgpuCreateInstance</code> like this:</p>

<div><div><pre><code><span>-</span> <span>Name</span><span>:</span> <span>wgpuCreateInstance</span>
  <span>SwiftReturnOwnership</span><span>:</span> <span>retained</span>
  <span>SwiftName</span><span>:</span> <span>WGPUInstanceImpl.init(descriptor:)</span>
  <span>Parameters</span><span>:</span>
  <span>-</span> <span>Position</span><span>:</span> <span>0</span>
    <span>Nullability</span><span>:</span> <span>O</span>
  <span>ResultType</span><span>:</span> <span>&#34;</span><span>WGPUInstance</span><span> </span><span>_Nonnull&#34;</span>
</code></pre></div></div>

<p>To specific nullability of pointer parameters, one can identify them by position (where 0 is the first parameter to the function) and then specify whether the parameter should come into Swift as optional (<code>O</code>, corresponds to <code>_Nullable</code>), non-optional (<code>N</code>, corresponds to <code>_Nonnull</code>) or by left unspecified as an implicitly-unwrapped optional (<code>U</code>, corresponds to <code>_Null_unspecified</code>). For the result type, it’s a little different: we specified the result type along with the nullability specifier, i.e., <code>WGPUInstance _Nonnull</code>. The end result of these annotations is the same as the modified header, so we can layer nullability information on top of the header.</p>



<p><code>webgpu.h</code> is about 6,400 lines long, and is regenerated from a database of the API as needed. Each of the WebGPU implementations seems to augment or tweak the header a bit. So, rather than grind through and manually do annotations, I wrote a little Swift script to “parse” <code>webgpu.h</code>, identify its patterns, and generate <code>WebGPU.apinotes</code> for most of what is discussed in this post. The entirety of the script is <a href="https://punchagan.muse-amuse.in/assets/blog/improving-usability-of-c-libraries-in-swift/webgpu_apinotes.swift">here</a>. It reads <code>webgpu.h</code> from standard input and prints <code>WebGPU.apinotes</code> to standard output.</p>

<p>Because <code>webgpu.h</code> is generated, it has a very regular structure that we can pick up on via regular expressions. For example:</p>

<div><div><pre><code><span>// Enum definitions, marked by WGPU_ENUM_ATTRIBUTE.</span>
<span>let</span> <span>enumMatcher</span> <span>=</span> <span>/} (?&lt;name&gt;\w+?) WGPU_ENUM_ATTRIBUTE/</span>

<span>// Object definitions, marked by WGPU_OBJECT_ATTRIBUTE.</span>
<span>let</span> <span>objectMatcher</span> <span>=</span> <span>/typedef struct (?&lt;implName&gt;\w+?)\* (?&lt;name&gt;\w+?) WGPU_OBJECT_ATTRIBUTE;/</span>

<span>// Function declarations, marked by WGPU_FUNCTION_ATTRIBUTE</span>
<span>let</span> <span>functionMatcher</span> <span>=</span> <span>/WGPU_EXPORT (?&lt;nullableResult&gt;WGPU_NULLABLE ?)?(?&lt;resultType&gt;\w+?) (?&lt;name&gt;\w+?)\((?&lt;parameters&gt;.*\)?) WGPU_FUNCTION_ATTRIBUTE;/</span>
<span>let</span> <span>parameterMatcher</span> <span>=</span> <span>/(?&lt;type&gt;[^),]+?) (?&lt;name&gt;\w+?)[),]/</span>
</code></pre></div></div>

<p>That’s enough to identify all of the enum types (so we can emit the <code>EnumExtensibility: closed</code> API notes), object types (to turn them into shared references), and functions (which get nicer names and such). The script is just a big <code>readLine</code> loop that applies the regexes to capture all of the various types and functions, then does some quick classification before printing out the API notes. The resulting API notes are <a href="https://punchagan.muse-amuse.in/assets/blog/improving-usability-of-c-libraries-in-swift/WebGPU.apinotes">in WebGPU.apinotes</a>, and the generated Swift interface after these API notes are applied is <a href="https://punchagan.muse-amuse.in/assets/blog/improving-usability-of-c-libraries-in-swift/WebGPU.swiftinterface">here</a>. You can run it with, e.g.,</p>

<div><div><pre><code>swift <span>-enable-bare-slash-regex</span> webgpu_apinotes.swift &lt; webgpu.h
</code></pre></div></div>

<p>This script full of regular expressions is, admittedly, a bit of a hack. A better approach for an arbitrary C header would be to use <a href="https://clang.llvm.org/docs/LibClang.html"><code>libclang</code></a> to properly parse the headers. For WebGPU specifically, the webgpu-headers project contains a database from which the header is generated, and one could also generate API notes directly from that header. Regardless of how you get there, many C libraries have well-structured headers with conventions that can be leveraged to create safer, more ergonomic projections in Swift.</p>



<p>The techniques described in this post can be applied to just about any C library. To do so, I recommend setting up a small package like the one described here for WebGPU, so you can iterate quickly on example code to get a feel for how the Swift projection of the C API will work. The annotations might not get you all the way to the best Swift API, but they are a lightweight way to get most of the way there. Feel free to also extend the C types to convenience APIs that make sense in Swift, like I did above to make <code>WGPUBool</code> conform to <code>ExpressibleByBooleanLiteral</code>.</p>

<p>A little bit of annotation work on your favorite C library can make for a safer, more ergonomic, more Swifty experience of working with that library.</p>



<p>The regular structure of <code>webgpu.h</code> helped considerably when trying to expose the API nicely in Swift. That said, there are a few ways in which <code>webgpu.h</code> could be improved to require less annotation for this purpose:</p>

<ul>
  <li>
    <p><code>WGPU_ENUM_ATTRIBUTE</code> would be slightly nicer if placed on the <code>enum</code> itself, rather than on the <code>typedef</code>. If it were there, we could use</p>

    <div><div><pre><code><span>#define WGPU_ENUM_ATTRIBUTE __attribute__((enum_extensibility(closed)))
</span></code></pre></div>    </div>

    <p>and not have to generate any API notes to bring these types in as proper enums in Swift.</p>
  </li>
  <li>
    <p><code>WGPU_OBJECT_ATTRIBUTE</code> could provide the names of the retain and release operations and be placed on the <code>struct</code> itself. If it were there, we could use</p>

    <div><div><pre><code><span>#define WGPU_OBJECT_ATTRIBUTE(RetainFn,ReleaseFn) SWIFT_SHARED_REFERENCE(RetainFn,ReleaseFn)
</span></code></pre></div>    </div>

    <p>and not have to generate any API notes to bring these types in as classes in Swift.</p>
  </li>
  <li>
    <p><code>WGPU_NULLABLE</code> could be placed on the pointer itself (i.e., after the <code>*</code>) rather than at the beginning of the type, to match the position of <a href="https://clang.llvm.org/docs/AttributeReference.html#nullability-attributes">Clang’s nullability attributes</a>. If it were placed there, then</p>

    <div><div><pre><code><span>#define WGPU_NULLABLE _Nullable
</span></code></pre></div>    </div>

    <p>would work with Clangs’ longstanding nullable-types support. Swift would then import such pointers as optional types (with <code>?</code>). Moreover, if some macros <code>WGPU_ASSUME_NONNULL_BEGIN</code> and <code>WGPU_ASSUME_NONNULL_END</code> were placed at the beginning and end of the header, they could be mapped to Clang’s pragmas to assume that any pointer not marked “nullable” is always non-null:</p>
    <div><div><pre><code><span>#define WGPU_ASSUME_NONNULL_BEGIN #pragma clang assume_nonnull begin
#define WGPU_ASSUME_NONNULL_END #pragma clang assume_nonnull end
</span></code></pre></div>    </div>

    <p>This would eliminate all of the implicitly unwrapped optionals (marked <code>!</code> in the Swift interface), making it easier to use safely.</p>
  </li>
</ul>
 
      
      

      

      

      <hr/>

      <h2>Continue Reading</h2>

      
      <nav>
        <div>
          <ul>
            
            <li>
              <div>
                <h3>What&#39;s new in Swift: December 2025 Edition</h3>
                <p><time pubdate="" datetime="2026-01-22T08:00:00-04:00">December 19, 2025</time></p><p>
                  Welcome to the latest digest of news from the Swift project.

                </p>
                <p><a href="https://punchagan.muse-amuse.in/blog/whats-new-in-swift-december-2025/" rel="prev"> More </a>
              </p></div>
            </li>
             
          </ul>
        </div>
      </nav>
      
    </div></div>
  </body>
</html>
