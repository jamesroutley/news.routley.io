<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chan.co.za/how-fateful">Original</a>
    <h1>Using Google Maps history to see if my boyfriend and I could have met earlier</h1>
    
    <div id="readability-page-1" class="page"><p>Before we jump right into transforming and cleaning the data it’s
necessary to set some boundaries around time frames and accuracy so that
we don’t spend time processing unnecessary records.</p><div id="distance-margin">
<h4>Distance margin</h4>
<p>This table displays how the distance accuracy measures relate to each
other.</p>
<table>
<colgroup>
<col width="22%"/>
<col width="17%"/>
<col width="18%"/>
<col width="20%"/>
<col width="21%"/>
</colgroup>
<thead>
<tr>
<th>accuracy.level</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>decimal places</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>accuracy (m)</td>
<td>111</td>
<td>11.1</td>
<td>1.11</td>
<td>0.111</td>
</tr>
<tr>
<td>coordinates</td>
<td>+/- 00.000</td>
<td>+/- 00.0000</td>
<td>+/- 00.00000</td>
<td>+/- 00.000000</td>
</tr>
</tbody>
</table>
<p>The data has two types of accuracy indicators. The GPS coordinates
have differing numbers of decimal places depending on the specificity of
the location. There is also a reported accuracy measurement based on the
strength of the signal of the GPS at the time which is reported in
meters.</p>
<p>These accuracy measures define the margin of error in the distance
for any of the conclusions that we draw. That is when we potentially
conclude that he and I did cross paths, did we come into tens, hundreds,
or thousands of meters from each other? I initially chose 11.1m, related
to coordinates with 4 decimal places (+/- 00.0000), because I thought
that even in dense urban areas the length of a telephone pole had a
tantalizingly high probability of being within sight. However, the
quality of the data (see below) limited the records too much, forcing me
to use a distance accuracy of 111m instead.</p>
<p>I’ve paired together the two types of accuracy measures so that the
distance accuracy is standardised for all our insights. Coordinates with
more than the stated number of decimal places are rounded. This means
that we’re dividing the world into bigger blocks and moving any of the
points in the middle of a block to its nearest corner. Then, any of the
reported accuracy measurements with distances less than the related
distance in meters are filtered out of the data set.</p>
<pre><code>#Distance margin
accuracy_level &lt;- 1</code></pre>
</div><div id="time-margins">
<h4>Time margins</h4>
<p>We also need to define the time boundaries of the two data sets. The
first date is the earliest possible date that we had any real
probability of having come into contact. This could also be set to the
minimum date in either of the two sets if there’s no clear probable
contact time like moving to the same city.</p>
<pre><code>## [1] &#34;Chan &#39;s earliest record is 2014-10-11&#34;</code></pre>
<pre><code>## [1] &#34;Dan &#39;s earliest record is 2015-01-13&#34;</code></pre>
<pre><code>## [1] &#34;Use 2015-01-13 or first_intersect_date to start at earliest intersecting dates.&#34;</code></pre>
<pre><code>start_looking_from &lt;- as.POSIXct(first_intersect_date) #Start date to start analysing data from</code></pre>
<p>There is also an end date to the time set. That is the date and time
that we’re definitely certain that our GPS coordinates would have
matched up for the first time.</p>
<pre><code>best_day &lt;- as.POSIXct(&#34;2020/08/08 1:00:00&#34;) #The confirmed first meeting &lt;3</code></pre>
<p>Similarly to distance margins, it’s also helpful to set time
intervals to group coordinates into. This is because when considering a
scale of meters people just don’t tend to move fast enough across the
surface of the earth on a day-to-day basis for it to be necessary to
record our location many times a second, however, the data is stored
down to millisecond time stamps.</p>
<p>I chose 10 minutes because it was also a margin, I was happy with
having on either side of my insights, i.e., we may have sat on the same
bench 10 minutes apart.</p>
<pre><code>#Time margins
time_accuracy &lt;- &#34;10 mins&#34; #The granularity of time buckets. Use ?round_date to see time categories available.</code></pre>
<p>The tree-style lists I’ve converted the JSON files from are still
unrefined. Currently, each data set is made up of hundreds of thousands
of observations, each of which is in a listed format with the below
structure:</p>
<pre><code>## List of 7
##  $ latitudeE7 : num -2.59e+08
##  $ longitudeE7: num 2.92e+08
##  $ accuracy   : num 2459
##  $ activity   :List of 2
##  $ source     : chr &#34;CELL&#34;
##  $ deviceTag  : num 1.44e+09
##  $ timestamp  : chr &#34;2014-10-11T14:39:52.645Z&#34;</code></pre>
<p>By the time we’re complete transforming the data we would like to
have two data frames, one for each person, with the following
structure:</p>
<table>
<colgroup>
<col width="12%"/>
<col width="12%"/>
<col width="12%"/>
<col width="12%"/>
<col width="12%"/>
<col width="12%"/>
<col width="12%"/>
<col width="12%"/>
</colgroup>
<thead>
<tr>
<th>index</th>
<th>timestamp</th>
<th>latitude</th>
<th>longitude</th>
<th>accuracy</th>
<th>person</th>
<th>coordinates</th>
<th>source</th>
</tr>
</thead>
<tbody>
<tr>
<td>1:nrows</td>
<td>POSIXct time</td>
<td>dd coords</td>
<td>dd coords</td>
<td>m radius</td>
<td>name</td>
<td>lat, long</td>
<td>signal source</td>
</tr>
</tbody>
</table>
<p>To do that we’ll run the following function on both data sets:</p>
<pre><code>transform_maps_data &lt;-
  function(x,
           person,
           time_accuracy,
           distance_accuracy) {
    
    # Extracting the variables that we&#39;re interested in and dropping all the information related to whether Google thinks we were in a vehicle or sitting still.
    
    timestamp &lt;-
      lapply(x, pluck, &#34;timestamp&#34;) %&gt;% unlist() %&gt;% data.frame()
    latitude &lt;-
      lapply(x, pluck, &#34;latitudeE7&#34;) %&gt;% unlist() %&gt;% data.frame()
    longitude &lt;-
      lapply(x, pluck, &#34;longitudeE7&#34;) %&gt;% unlist() %&gt;% data.frame()
    accuracy &lt;-
      lapply(x, pluck, &#34;accuracy&#34;) %&gt;% unlist() %&gt;% data.frame()
    source &lt;- lapply(x, pluck, &#34;source&#34;) %&gt;% unlist() %&gt;% data.frame()
    
    # Setting an index
    index &lt;- 1:nrow(timestamp)
    
    # Combining each of the variables into a data frame as columns with clear names.
    
    records_df &lt;-
      cbind(timestamp, latitude, longitude, accuracy, source)
    rownames(records_df) &lt;- index
    colnames(records_df) &lt;-
      c(&#34;timestamp&#34;, &#34;latitude&#34;, &#34;longitude&#34;, &#34;accuracy&#34;, &#34;source&#34;)
    
    # Adjusting the formatting and adding some key columns.
    output &lt;- records_df %&gt;%
      
      # Formatting the time stamps so that they are POSIXct objects in the system timezone and rounding them off into the given accuracy limits
      mutate(timestamp_utc = as.POSIXct(timestamp, format = &#34;%Y-%m-%dT%H:%M:%S&#34;, tz = &#34;UTC&#34;)) %&gt;%
      mutate(timestamp = with_tz(timestamp_utc, tzone = Sys.timezone())) %&gt;%
      select(-timestamp_utc) %&gt;%
      mutate(timestamp = round_date(timestamp, unit = time_accuracy)) %&gt;%
      
      # Adding a column with the name of the individual who the records belong to
      mutate(person = person) %&gt;%
      
      # Latitude and longitude are in a suitable format to allow for quick copy and pasting into Google Maps, and are filtered within the distance.accuracy number of decimal points
      
      mutate(latitude = round((latitude / 10000000), distance_accuracy)) %&gt;%
      mutate(longitude = round((longitude / 10000000), distance_accuracy)) %&gt;%
      
      # Adding a column for combined coordinates
      mutate(coordinates = paste(latitude, longitude, sep = &#34;, &#34;)) %&gt;%
      
      # Filtering our any records outside of reported accuracy
      filter(accuracy &lt;= google_reported_accuracy) %&gt;%
      filter(accuracy &gt;= 0) %&gt;%
      
      # Filtering our any records before or after start and end dates
      filter(timestamp &gt;= start_looking_from) %&gt;%
      filter(timestamp &lt;= best_day) %&gt;%
      
      # Removing unknown sources for integrity
      filter(source != &#34;UNKNOWN&#34;) %&gt;%
      
      # Removing duplicates
      unique()
    
  }

#Running the function on the two data sets or otherwise loading data we&#39;ve already saved before.

if (file.exists(&#34;X_Google_Maps_history.RData&#34;)) {
  load(&#34;X_Google_Maps_history.RData&#34;)
} else{
  x_records &lt;-
    transform_maps_data(
      records_data_x,
      person = x,
      time_accuracy = time_accuracy,
      distance_accuracy = distance_accuracy
    )
}

if (file.exists(&#34;Y_Google_Maps_history.RData&#34;)) {
  load(&#34;Y_Google_Maps_history.RData&#34;)
} else{
  y_records &lt;-
    transform_maps_data(
      records_data_y,
      person = y,
      time_accuracy = time_accuracy,
      distance_accuracy = distance_accuracy
    )
}</code></pre>
<p>At the end of our transform step we have two data frames with the
following structure:</p>
<pre><code>##             timestamp latitude longitude accuracy source person    coordinates
## 1 2015-01-13 02:00:00   -25.89    29.252       12   CELL   Chan -25.89, 29.252
## 3 2015-01-13 02:04:00   -25.89    29.252       12   CELL   Chan -25.89, 29.252
## 4 2015-01-13 02:06:00   -25.89    29.252       12   CELL   Chan -25.89, 29.252
## 5 2015-01-13 02:10:00   -25.89    29.252       12   CELL   Chan -25.89, 29.252
## 7 2015-01-13 02:12:00   -25.89    29.252       27   CELL   Chan -25.89, 29.252
## 8 2015-01-13 02:14:00   -25.89    29.252       27   CELL   Chan -25.89, 29.252</code></pre>
</div></div>
  </body>
</html>
