<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://donnywinston.com/posts/hierarchies-heterarchies-and-agent-memory/">Original</a>
    <h1>Hierarchies, Heterarchies, and Agent Memory</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p><time>April 10, 2022</time></p><div>
<p>In a hierarchy, each agent only acts on behalf of one other agent:</p>
<div><pre tabindex="0"><code data-lang="python"><span>from</span> rdflib <span>import</span> Graph
<span>from</span> rdflib.namespace <span>import</span> RDF, PROV

<span>def</span> <span>hierarchy</span>(graph):
    <span>return</span> all(
        len(set(graph<span>.</span>objects(agent, PROV<span>.</span>actedOnBehalfOf))) <span>&lt;=</span> <span>1</span>
        <span>for</span> agent <span>in</span> graph<span>.</span>subjects(RDF<span>.</span>type, PROV<span>.</span>Agent)
    )

hierarchy(Graph()<span>.</span>parse(data<span>=</span><span>&#34;&#34;&#34;
</span><span>@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
</span><span>@prefix :     &lt;http://example.com/&gt; .
</span><span>
</span><span>:doc
</span><span>    a prov:Agent;
</span><span>.
</span><span>
</span><span>:sleepy
</span><span>    a prov:Agent;
</span><span>    prov:actedOnBehalfOf :doc;
</span><span>.
</span><span>
</span><span>:sneezy
</span><span>    a prov:Agent;
</span><span>    prov:actedOnBehalfOf :doc;
</span><span>.
</span><span>
</span><span>&#34;&#34;&#34;</span>)) <span># True</span>
</code></pre></div><p>Hierarchies do not always work. Sometimes, for example, agents need to use each otherâ€™s skills:</p>
<div><pre tabindex="0"><code data-lang="python"><span>def</span> <span>heterarchy</span>(graph):
    <span>return</span> <span>not</span> hierarchy(graph)

heterarchy(Graph()<span>.</span>parse(data<span>=</span><span>&#34;&#34;&#34;
</span><span>@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
</span><span>@prefix :     &lt;http://example.com/&gt; .
</span><span>
</span><span>:doc
</span><span>    a prov:Agent;
</span><span>.
</span><span>
</span><span>:sleepy
</span><span>    a prov:Agent;
</span><span>    prov:actedOnBehalfOf :sneezy, :doc;
</span><span>.
</span><span>
</span><span>:sneezy
</span><span>    a prov:Agent;
</span><span>    prov:actedOnBehalfOf :sleepy, :doc;
</span><span>.
</span><span>
</span><span>&#34;&#34;&#34;</span>)) <span># True</span>
</code></pre></div><p>In heterarchies, per-agent working memory becomes critical: an agent must keep track of what next to do in a job A if it starts a job B before A is done. In hierarchies, priority and preemption can straightforwardly waterfall down from the top supervisor.</p>
<p><small>
This post was adapted from a note sent to my email list on Machine-Centric Science.
</small>
</p>

</div>




</div></div>
  </body>
</html>
