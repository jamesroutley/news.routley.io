<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ludocode.com/blog/onramp-can-compile-doom">Original</a>
    <h1>Show HN: Onramp Can Compile Doom</h1>
    
    <div id="readability-page-1" class="page">

<a href="https://ludocode.com/">← ludocode.com</a>





<p>
2024-12-29
</p>
<p>After two years of late nights and weekends, <a href="https://github.com/ludocode/onramp">Onramp</a> can finally compile
Doom. Check it out:</p>



<figure>
<video controls="" width="685" height="669">
<source src="../assets/blog/onramp-doom-cli.mp4" type="video/mp4"/>
</video>
</figure>



<p>The above is running on an out-of-the-box x86_64 Alpine Linux. It has
no compilers, no libc headers, no build tools of any kind. The only
things I’ve added are the source code to Onramp and Doom and a DOOM.WAD
file (the art assets for the game.)</p>
<p>Onramp <a href="https://github.com/ludocode/onramp/blob/develop/docs/bootstrap-path.md">bootstraps
itself</a> out of <em>pure handwritten source code</em>. It starts from
a simple virtual machine in commented hexadecimal <a href="https://github.com/ludocode/onramp/blob/develop/platform/vm/x86_64-linux/">x86_64
machine code</a>. In the VM bytecode I wrote a tiny <a href="https://github.com/ludocode/onramp/blob/develop/core/ld/0-global">linker</a>;
in object code I wrote an <a href="https://github.com/ludocode/onramp/tree/develop/core/as/0-basic">assembler</a>;
in assembly I wrote a <a href="https://github.com/ludocode/onramp/tree/develop/core/cci/0-omc">small
C compiler</a>; and so on up to a C17 compiler, assembler, linker, libc
and other tools.</p>
<p>Onramp does not support graphics so I wrote a command-line frontend
to Doom called <a href="https://github.com/ludocode/doom-cli">doom-cli</a>. It renders
with Unicode <a href="https://en.wikipedia.org/wiki/Box-drawing_characters#Symbols_for_Legacy_Computing">block
sextant characters</a> and ANSI terminal color escape sequences. It
heuristically determines key repeat delay to simulate key release
events.</p>
<h2 id="performance">Performance</h2>
<p>Onramp bytecode is, for now, extremely slow. <a href="https://github.com/nfinit/ansibench/tree/master/coremark">CoreMark</a>
on Onramp runs about 500x slower than when natively compiled and
optimized with GCC. I estimate the VM adds a 10x-20x performance penalty
and the poor bytecode emitted by the Onramp compiler causes the
remaining 25x-50x. This is not a major limitation since Onramp is
intended for non-interactive bootstrapping. Still, I have plans to
improve the compiler output later.</p>
<p>When I first got Doom compiling with Onramp, it ran at about 2 FPS on
the fastest VM, taking around 460 ms per frame. About 200 ms was
doomgeneric’s code to convert the paletted framebuffer to full color,
and another 200 ms was in my doom-cli code to convert the framebuffer to
unicode characters. Only 60 ms was the original Doom code rendering its
entire frame. It is astonishing how efficient the Doom source code is,
even when compiled with an awful compiler on a primitive VM some 30
years after Doom was written. John Carmack and co are undeniably
geniuses.</p>
<h2 id="trusting-trust">Trusting Trust</h2>
<p>Onramp’s bootstrap sequence is similar in concept to the <a href="https://github.com/oriansj/stage0">stage0</a> project. The
difference is that Onramp is as platform independent as possible.
</p>
<p>The
goal is to have an entire implementation of C that sits on top of a
simple virtual machine, one that can be trivially implemented by anyone
on anything. To bootstrap C on a new platform, you just need to
implement an Onramp VM in a few hundred lines of whatever language is
available on that platform. If nothing is available (or nothing can be
trusted), the VM is simple enough to be written directly in machine
code.</p>
<p>The bootstrap process does not rely on any binaries aside from those
that already exist on the platform, in this case the kernel and
coreutils. This makes the entire process auditable.</p>
<p>Onramp currently still depends on a hosted environment with a
filesystem. It doesn’t have to be anything like UNIX, but it does need a
concept of named files and folders with arbitrary contents. This is of
course a major “trusting trust” vulnerability. (It also currently needs
a POSIX shell because the <a href="https://github.com/ludocode/onramp/tree/develop/core/sh">Onramp
shell</a> tool is not done yet.)</p>
<p>A long-term goal is to implement the filesystem within Onramp. It
should be possible to boot directly into an Onramp VM, compile a native
kernel and chainboot into it. The stage0/live-bootstrap team have
already accomplished this for a few present-day architectures. With
Onramp I hope to greatly reduce the platform dependence, supporting
architectures both future and past with minimal porting effort.</p>
<p>Rob Landley once tried to make the <a href="https://youtu.be/MkJkyMuBm3g?t=723">minimum possible system</a>
that could rebuild itself within itself. He got it down to four
tarballs:</p>
<ul>
<li>Linux, the kernel;</li>
<li>uClibc, the libc;</li>
<li>Busybox, the shell and coreutils;</li>
<li>TinyCC, the compiler.</li>
</ul>
<p>With just one more tarball, this system could actually boot from
source. We would have a full compilation environment bootstrappable from
a minimal set of pure source tarballs. This is another long-term goal of
Onramp.</p>
<h2 id="alien-computers">Alien Computers</h2>


<figure>
<img src="https://ludocode.com/assets/blog/aliens.jpg" width="320" height="280"/>
</figure>

<p>Doom is the first major milestone for Onramp. The next step is
getting it to build TinyCC and other compilers, which might actually
make Onramp useful for something. There aren’t too many missing features
but a big one is floating point support. This will be a bit of a
challenge because it needs to be software emulated.</p>
<p>Why software emulated? The short answer is, Onramp is a tool for
<strong>xenocomputing</strong>. I want humanity to preserve and share
documentaries like <a href="https://en.wikipedia.org/wiki/Planet_Earth_(2006_TV_series)">Planet
Earth</a> with far future archaeologists and alien civilizations. To do
that, we need to make it possible to run contemporary codecs and
compression algorithms on hardware we can’t even conceive of. I believe
the best way to accomplish this is to give them the original source for
our decoders as well as the tools to compile and run them on anything.
Onramp is one of these tools.</p>
<p>Would aliens have access to unsigned binary arithmetic? Almost
certainly! Would they have IEEE 754 floating point? Highly improbable,
so we have to emulate it. This principle has guided the design of
Onramp.</p>
<p>With a bit more effort, Onramp should soon be able to compile and run
things like ffmpeg and DOSBox. This would allow us to preserve and
transmit huge parts of our culture and computing history far into the
future.</p>







    


</div>
  </body>
</html>
