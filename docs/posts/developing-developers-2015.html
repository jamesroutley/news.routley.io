<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://felleisen.org/matthias/Thoughts/Developing_Developers.html">Original</a>
    <h1>Developing Developers (2015)</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><span>8.15.0.6</span></p><h3><a name="(part._.Developing_.Developers)"></a><span>Developing Developers</span><span><a href="#(part._.Developing_.Developers)" title="Link to here">üîó</a><span> </span></span></h3><blockquote><blockquote><blockquote><p>8 Sep 2015</p></blockquote></blockquote></blockquote><h4><a name="(part._.Abstract)"></a>Abstract<span><a href="#(part._.Abstract)" title="Link to here">üîó</a><span> </span></span></h4><p>Northeastern offers a unique <span><span><span>But see <a href="#%28part._unique%29" data-pltdoc="x">P.S. Uniqueness</a>.</span></span></span> curriculum on programming.  Instead of the
currently fashionable programming language, it focuses on <span>explicit
and systematic approaches to program design</span>.  To bring this idea across to
the full range of Northeastern freshmen, the first course uses a simple
teaching language that is tailored to our goals.  Follow-up courses explain
how to apply the design principles to industrial programming languages, how
they enable logical reasoning about code, and why they matter when
programmers deal with large and complex software.</p><p>In parallel, these core courses on programming insist on presenting
programming as a people discipline. Students find out that people write
programs to inform other people of ideas. Working with compilers and
interpreters also teaches them that these tools provide only shallow
feedback. For true insight, they must turn to other people. Hence, students
work in pairs from the very first day in class. Pair programming forces
them to articulate their thoughts so that they can converse about
programs. Downstream courses also teach students how to present their ideas
to large groups and how to listen and evaluate such presentations.</p><p><span>Acknowledgments</span> Corky Cartwright, Bruce Duba, Robby Findler, Kathi
Fisler, Matthew Flatt, Dan Friedman, Gregor Kiczales, Shriram
Krishnamurthi, and Mitch Wand helped me hone this vision over 25
years. Many Northeastern colleagues have taught these core courses and
their feedback improved my initial vision: Amal Ahmed, Will Clinger, Pete
Manolios, Viera Proulx, Olin Shivers, Sam Tobin-Hochstadt, Jesse Tov, David Van Horn,
and Thomas Wahl. Dale Vaillancourt and Carl Eastlund, former PhD students,
were critical to my first attempt at <span>Logic in Computer Science</span>.  Larry Finkelstein and
Richard Rasala put in place a playground where I could easily influence the
shape of the core courses.</p><p>Changed in version 1.0: Wed Sep 16 15:07:49 EDT 2015: initial release </p><h4>1<tt>¬†</tt><a name="(part._.Explicit_and_.Systematic_.Program_.Design)"></a>Explicit and Systematic Program Design<span><a href="#(part._.Explicit_and_.Systematic_.Program_.Design)" title="Link to here">üîó</a><span> </span></span></h4><p>Ninety-percent or more of the College‚Äôs graduates will end up engineering
software for the first few years out of college. The College‚Äî<wbr/>which is us,
all the professors and instructors‚Äî<wbr/>owe them a solid preparation for this
task. Well-prepared students will stand out in industry and thus strengthen
our reputation. Bit by bit, they may also improve the currently sad state
of affairs of engineering software systems.</p><p>In response to this challenge, our College has developed a unique approach
to teaching over the past 12 years. The core curriculum radically differs
from traditional approaches in how it trains students as programmers and
problem solvers. The purpose of this essay is to sketch the ideas behind
the approach (this section) and its organization into courses (the next
one).</p><p>When these courses are taught properly, they not only improve the
preparation of our students for their first job as creators of software.
They also lay the foundation for the students‚Äô careers as project leaders,
managers of software teams, CTOs, CEOs, entrepreneurs, medical doctors, and
wherever else systematic problem solving matters.</p><h5>1.1<tt>¬†</tt><a name="(part._.Traditional_.Programming_.Courses)"></a>Traditional Programming Courses<span><a href="#(part._.Traditional_.Programming_.Courses)" title="Link to here">üîó</a><span> </span></span></h5><p> The vast majority of courses
on programming employ a ‚Äútinker until it works‚Äù approach. Instructors
tend to pick a currently fashionable programming language and then proceed
in a rather old-fashioned manner, dating back to the days of Fortran IV.
At the beginning, instructors show some version of a ‚Äúhello world‚Äù
program (console or GUI based), followed by simplistic input modes (again
console or GUI based), variable declarations and assignments, arrays and
loops.  Still further down the road, these courses may also introduce
functions, methods, and classes.</p><div><blockquote><blockquote><blockquote><p><span>Q</span> What‚Äôs the biggest lie in computing?
<span>A</span> ‚ÄúIt works.‚Äù</p></blockquote></blockquote></blockquote></div><p>What students learn in such courses, is to mimic their instructors. In
classes and labs, they see code snippets that introduce new syntactic
constructs and spell out their pragmatics. Homework assignments ask them to
solve similar problems. A typical student will copy the snippets of code
from class and modify them until the program seems to work. Over the course
of a semester, the distance between the code snippets from class and those
needed to solve homework problems grows to test students‚Äô ability to
generalize.</p><p>In sum, traditional programming courses teach programming
<span>implicitly</span>, with students picking it up via mimicking and
experimenting. This approach may appeal to students who love to tinker with
gadgets and video games, but it also turns off many others who might be
equally talented for engineering actual software or benefit to the same
extent from a properly taught course on programming and problem solving.</p><blockquote><blockquote><blockquote><p><img src="https://felleisen.org/matthias/Thoughts/pict.png" alt="image" width="458.53721923828124" height="424.8478759765625"/></p></blockquote></blockquote><p><span><span><a name="(counter._(figure._fig~3adr))" x-target-lift="Figure"></a>Figure¬†1: </span>Courses on program design</span></p></blockquote><h5>1.2<tt>¬†</tt><a name="(part._.Explicit_.Design_.Rules)"></a>Explicit Design Rules<span><a href="#(part._.Explicit_.Design_.Rules)" title="Link to here">üîó</a><span> </span></span></h5><p><a href="https://www.htdp.org/"></a><span>How to Design Programs</span>
 is the first text book on programming that explicitly spells out how to
 construct programs in a systematic manner. One half focuses on
 <span>structural design</span>, the other on <span>design and use of
abstractions</span>, <span>generative recursion</span> (‚Äúdivide and conquer‚Äù), and
 <span>accumulators</span> (‚Äúloop variables‚Äù).</p><p><a href="#%28counter._%28figure._fig~3adr%29%29" data-pltdoc="x">Figure¬†<span>1</span></a> displays the <span>design recipe</span> used for structural
 design. It consists of two dimensions: the <span>y</span> axis specifies a
 six-step problem-solving process, the <span>x</span> axis enumerates (some of)
 the forms of data with which programmers represent information, in
 increasing complexity.</p><p>The <span>vertical direction</span> presents a six-step process that prompts students to
</p><div><ol><li><p>read the problem statement, figure out the data that is needed to
represent the information of interest, and illustrate their insight with
concrete examples;</p></li><li><p>articulate a purpose statement that concisely describes what the
function or program is supposed to compute, including a signature;</p></li><li><p>work through functional examples, that is, explain what the function
or program is supposed to produce when given certain inputs, based on steps
1 and 2;</p></li><li><p>create an outline of the program, based on steps 1 and 2;</p></li><li><p>fill in the outline from step 4, using steps 2 and 3; and</p></li><li><p>turn the examples from step 2 into a test suite for the program from step 5.</p></li></ol></div><p>Every step of the design process generates a well-defined outcome. When
 students ask for help, instructors can inspect these outcomes and thus
 diagnose the students‚Äô problems. To get students unstuck, every step also
 comes with a question-and-answer ‚Äúgame‚Äù that somewhat depends on the
 column of the design recipe but is ‚Äúparametric‚Äù with respect to the
 actual problem. Instructors can use this ‚Äúgame‚Äù to help students along
 <span>without</span> giving one-off hints for the specific problem at hand.
 Eventually students realize that this process exists so that they can
 learn to help themselves.</p><p>The <span>horizontal direction</span> of the structural design recipe expands
 students‚Äô understanding of data. Roughly speaking, every language comes
 with a sub-language for data, and programmers choose certain forms of data
 to represent information from the domain of interest (‚Äúthe
 world‚Äù). Atomic data is drawn from this domain, and processing atomic
 data demands domain knowledge. Because traditional programming courses
 often focus on processing atomic data (especially numbers), they rely on
 domain knowledge and thus fail to show how much computing and programming
 can contribute to systematic problem solving and design.  Every step along
 the horizontal axis increases students‚Äô knowledge of the world of data,
 taking them all the way to trees, forests, graphs, and so on. Also at each
 step, they must re-interpret the six steps from the design
 process. <span><span><span><a href="https://felleisen.org/matthias/OnHtDP/turing_is_useless.html">Turing is Useless</a> spells out this
idea in more detail.</span></span></span>  Conversely, this organization implies that
 <span>instructors may assign only homework problems that are within the
<span>convex hull</span> of students‚Äô <span>design knowledge</span></span> for a specific
 stage in their design development.</p><p>A design-process approach guides students all the way through the
 composition of well-designed functions into complete programs, the
 creation of programming abstractions; the coding of ‚Äúdivide-and-conquer‚Äù
 recursive algorithms; and the creation of algorithms that maintain
 invariants across iterations (‚Äúaccumulators‚Äù).</p><p>Once students understand each of these design recipes, they also learn to
 choose among alternatives that produce equivalent functionality. For
 example, structural design naturally yields insertion sort algorithms,
 while generative recursion yields quick sort or merge sort algorithms.
 To make an informed choice, students need to learn about designing under
 constraints and, in computing, about big-O.</p><h5>1.3<tt>¬†</tt><a name="(part._.The_.Design_.Process_is_.General)"></a>The Design Process is General<span><a href="#(part._.The_.Design_.Process_is_.General)" title="Link to here">üîó</a><span> </span></span></h5><p>Teaching explicit and systematic design introduces students to a general
 problem-solving approach that applies to many more domains than
 programming. A journalist can use it to plan a story. The first step calls
 for developing the background. Next comes the articulation of the thesis,
 the collection of illustrative examples, the creation of an outline based
 on facts, the writing, and the final fact-checking step. It is equally
 obvious that
 businessmen can tackle logistical problems in this manner,
 engineers must follow a similar approach,
 lawyers may analyze a case with it,
 scientists perform lab work in this way,
and
 surgeons are able to conduct operations with a systematic process.</p><blockquote><blockquote><blockquote><p>Unsafe languages, such as C, C++, and Objective C, increase
the number of dependencies and thus put an extra burden on the programmer
when it comes to the inevitable search for, and elimination of,
mistakes. A safe language is therefore a superior introductory language.</p></blockquote></blockquote></blockquote><h5>1.4<tt>¬†</tt><a name="(part._.Programming_is_a_.People_.Discipline)"></a>Programming is a People Discipline<span><a href="#(part._.Programming_is_a_.People_.Discipline)" title="Link to here">üîó</a><span> </span></span></h5><p> The design-oriented approach
 gradually introduces students to the idea that programming is about coping
 with <span>complexity</span> in software‚Äî<wbr/>which roughly corresponds to the
 number of dependencies among modules, classes, functions, methods,
 expressions, and statements. Without logical reasoning about designs,
 programmers quickly get lost in the thicket of dependencies.</p><p>Compilers, interpreters, and other IDE tools provide almost no help with
 controlling complexity; ACL2 and its relatives are too expensive for
 general programming problems.  Hence, programmers who need help (normally)
 turn to other programmers because they are people who can think.  It is
 therefore imperative that students develop the skill to converse about
 program designs, meaning they must learn to articulate their thoughts in
 all kinds of ways. The best way to do so, is to present programming as a
 discipline that is not about nerds sitting in a cubicle but people helping
 other people creating beautiful and well-designed artifacts.</p><h4>2<tt>¬†</tt><a name="(part._.Organizing_the_.Idea_into_.Courses)"></a>Organizing the Idea into Courses<span><a href="#(part._.Organizing_the_.Idea_into_.Courses)" title="Link to here">üîó</a><span> </span></span></h4><p><a href="#%28counter._%28figure._fig~3apc%29%29" data-pltdoc="x">Figure¬†<span>2</span></a> presents a concise summary of the College‚Äôs core
 programming courses in the form of a dependence graph.  Students majoring
 in computer science ought to have covered these courses by the time they start
 their second co-op. Students who just want a taste of programming and
 systematic problem solving take <span>Fundamentals I</span>. The following subsections spell out
 how these courses line up with the idea of teaching ‚Äúexplicit, systematic
 design‚Äù and the ‚Äúpeople skills‚Äù that go with them.</p><blockquote><blockquote><blockquote><p><img src="https://felleisen.org/matthias/Thoughts/pict_2.png" alt="image" width="673.5720703124999" height="605.25"/></p></blockquote></blockquote><p><span><span><a name="(counter._(figure._fig~3apc))" x-target-lift="Figure"></a>Figure¬†2: </span>Courses on program design</span></p></blockquote><h5>2.1<tt>¬†</tt><a name="(part._.Fundamentals_.I__.Designing_with_.Teaching_.Languages)"></a>Fundamentals I: Designing with Teaching Languages<span><a href="#(part._.Fundamentals_.I__.Designing_with_.Teaching_.Languages)" title="Link to here">üîó</a><span> </span></span></h5><p> The goals of the
first course are to
</p><div><ul><li><p>introduce novice programmers to the systematic and explicit design of programs</p></li><li><p>expose students with prior programming experience to design.</p></li></ul></div><p>All students‚Äî<wbr/>including those who never take another course on
programming‚Äî<wbr/>ought to appreciate (1) the idea of systematic problem
solving and (2) the complexities of creating well-engineered software.</p><p>When it comes to choosing a language for the first course, we must take
into account the above goals and two relevant theorems:
</p><div><blockquote><p><span>Theorem 1</span> Novice programmers make mistakes.</p></blockquote></div><div><blockquote><p><span>Theorem 2</span> A compiler and the run-time system articulate error
messages under the assumption that the programmer knows the entire language.</p></blockquote></div><p>These theorems have three immediate consequences relevant to <span>Fundamentals I</span>:
</p><div><blockquote><p><span>Corollary 1</span> An introductory course cannot serve a wide spectrum of
complete novices if it uses an off-the-shelf (industrial) language.</p><p>Examples of ill-suited languages include C++, Java, JavaScript, Python,
Racket, and Scheme‚Äî<wbr/>even though they are, or were, used for
first courses. Pascal is also too large, even though Wirth explicitly
motivated Pascal as a ‚Äúsmall teaching language.‚Äù</p></blockquote></div><blockquote><p><span>Corollary 2</span> Reducing the size of the language improves its error messages.</p></blockquote><blockquote><p><span>Corollary 3</span> An introductory course needs <span>a series of small
languages</span> that suffice to illustrate the design recipes.</p></blockquote><p><a href="#%28counter._%28figure._fig~3asteps%29%29" data-pltdoc="x">Figure¬†<span>3</span></a> summarizes this little excursion into the land of
social theorems with two simple graphs. The graph on the left shows how an
‚Äúoff-the-shelf‚Äù language may have a gentle curve for a short period, but
then poses a steep (learning) curve for every novice. The blue line in the
graph suggests how smooth the curve ought to be instead. The graph on the
right shows how to approximate the blue line with a step function‚Äî<wbr/>a
necessity because language technology is discrete.</p><blockquote><blockquote><blockquote><blockquote><p><img src="https://felleisen.org/matthias/Thoughts/pict_3.png" alt="image" width="200.0" height="200.0"/> <span>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</span> <img src="https://felleisen.org/matthias/Thoughts/pict_4.png" alt="image" width="200.0" height="200.0"/></p></blockquote></blockquote></blockquote><p><span><span><a name="(counter._(figure._fig~3asteps))" x-target-lift="Figure"></a>Figure¬†3: </span>Languages: steep walls vs continuous growth</span></p></blockquote><p><span>Fundamentals I</span> uses four (out of five) steps, aka, teaching languages, collectively
known as <span>*SL</span>. The first one (<span>Beginning Student Language</span>
or <span>BSL</span>) codifies students‚Äô notation from pre-algebra courses in
high school: function definitions, conditional function definitions, and
function applications. It extends this small set with conventional
(numbers, booleans) and unconventional (images) atomic data plus structure
definitions.  The downstream languages expand the expressive power of this
first language with compact notations for lists, local definitions, and
higher-order functions.</p><p>As for <span>people skills</span>, <span>Fundamentals I</span> introduces students to the idea of
<span>pair programming</span>. Students work in pairs for all homework
assignments. A pair consists of a ‚Äúpilot‚Äù and a ‚Äúco-pilot.‚Äù The former
is in control of the keyboard and the design process. To inform the latter,
the pilot explains the design aloud; the co-pilot checks the evolving
design against the question-and-answer game from the design recipe and
questions any deviations from the recipe. It is the task of the co-pilot to
engage the pilot in conversation. Partners switch roles on a regular basis.</p><p>Pair programming also helps students who are paired with partners of
unequal knowledge and skills. In the context of <span>Fundamentals I</span>, these roles are
often non-obvious. Students who ‚Äúhave always programmed‚Äù tend to find
themselves in the role of misguided hack, who must be pushed back to the
ways of explicit design by the seemingly less knowledgeable partner.
<span><span><span>Teaching greatly enhances learning.</span></span></span>
Even if experience with programming helps one of the partners, both
benefit: one by becoming a teacher, the other by having someone to talk to
even when no teaching assistants are around.</p><p>The course switches partnerships on a regular basis so that students get to
know other people and different ways of interacting with distinct
personalities.</p><h5>2.2<tt>¬†</tt><a name="(part._trinity)"></a>A Note on the Trinity<span><a href="#(part._trinity)" title="Link to here">üîó</a><span> </span></span></h5><p>The trinity of design, teaching languages, and pedagogic IDE‚Äî<wbr/>in our case
DrRacket‚Äî<wbr/>smoothly takes students from plain pre-algebra courses to
full-fledged programming. Explicit design overcomes their fear of word
problems in algebra and eases them into the world of complex programs, all
the way to distributed communicating programs. The teaching language
presents a familiar language and gently move students up the slope. <span>Fundamentals I</span>
uses the DrRacket IDE for the teaching languages, which eliminates all
clutter that Eclipse, IntelliJ, and similar products come with. In essence,
DrRacket relates to the latter the way a single-engine teaching airplane
relates to a JumboJet; pilots always fly the former before they get into
the cockpit of the latter.</p><p>Time and again people react negatively to my presentations of this trinity
and the teaching languages.  One common objection is that explicit design
must work in all languages and therefore we might as well indulge students,
parents, chairmen, deans, and egos by teaching the currently hot ‚Äúthing.‚Äù
On one hand, they are correct. Explicit design works for all languages; if
it didn‚Äôt, we would be wasting our students‚Äô time in <span>Fundamentals I</span> and fail them at
a massive scale. Indeed, it would not enable <span>Fundamentals II</span>. On the other hand,
objectors fail to see that the introduction of explicit design calls for a
careful composition of all the pieces that make for a novice-friendly
environment: accessible error messages from the chosen language and a
pedagogic IDE without clutter. Anyone who wishes to replace one element of
this trinity must consider the other two, too.</p><h5>2.3<tt>¬†</tt><a name="(part._.Fundamentals_.I.I__.Designing_with_.Java)"></a>Fundamentals II: Designing with Java<span><a href="#(part._.Fundamentals_.I.I__.Designing_with_.Java)" title="Link to here">üîó</a><span> </span></span></h5><p>The goals of <span>Fundamentals II</span> are to show students how to
</p><div><ul><li><p>systematically design programs in the context of a real-world language</p></li><li><p>incorporate existing libraries into design.</p></li></ul></div><p>The course must therefore use a language that is currently used in industry
and comes with significant libraries.</p><p>With regard to <span>design</span>, the course has three concrete goals:
</p><div><ul><li><p>add type checking</p></li><li><p>cover object-oriented programming, and</p></li><li><p>incorporate the idea of ‚Äúprogramming via composition of existing
building blocks.‚Äù</p></li></ul></div><p>While the design concepts from <span>Fundamentals I</span> heavily rely on types in several
different ways, they do not assume type checking. The rationale behind this
choice is twofold. On one hand, in this day and age, many (if not most) of
our students will use a dynamically typed language like *SL for their first
co-op. They need a systematic process even more than those who end up with
a statically checked language. On the other hand, type checking just adds
another formal layer to the practice of programming, that is, adding error
messages to those from the reader, parse, and run-time system just adds to
the confusion about layers that affects novice programmers. Most mainstream
programming languages come with an explicit static type system, however,
and our students deserve to see how type checking jives with design.</p><div><blockquote><blockquote><blockquote><p>The same people eventually recognized that C++ is <span>not</span> a
proper object-oriented language because it does not allow programmers to focus
on objects as run-time values. A better terminology would have been
‚Äúvalue-oriented programming‚Äù but this choice would conflict with the
narrow-minded use of ‚Äúvalue‚Äù in the object-oriented community.</p></blockquote></blockquote></blockquote></div><p>Similarly industrial programmers have known for a while that
‚Äúobject-oriented programming won.‚Äù What they mean with this statement, is
that languages introduced as object-oriented with classes and/or objects
dominate the world of engineering software. Examples are C#, Java,
JavaScript, Python, and Ruby [on Rails]. Fortunately, as Gregor Kiczales
said after adopting our approach at UBC, ‚Äú<a href="https://www.htdp.org/">How to Design Programs</a> [meaning <span>Fundamentals I</span>] is the
best introduction to proper object-oriented programming.‚Äù  We cannot
expect our students to make this transition on their own,
however. Therefore <span>Fundamentals II</span> spends about 60% of the second semester on
explaining how the design concepts from <span>Fundamentals I</span> apply to Java-based
programming and on adapting the design concepts for abstractions‚Äî<wbr/>both
their creation and their use‚Äî<wbr/>to an object-oriented context.</p><p>The latter is also crucial for constructing programs from libraries and
frameworks. While real programmers spend some time creating components from
scratch, a lot of their work is to find frameworks or libraries that
provide part of the functionality and to plug those together. Our explicit
design approach covers this idea as the use of existing abstractions, but
<span>additional research is needed to formulate useful design recipes</span>.</p><p><span>Notes</span> (1) Real-world languages such as Java obstruct proper design. For
example, both our approach to program design as well as the gang of four‚Äôs
well-known design patterns lead to identical code for processing sequential
or tree-shaped data structures. Unfortunately, Java‚Äôs failure to properly
implement tail-calls then forces programmers to reformulate the properly
designed pieces of code with <span>while</span> and <span>for</span> loops.</p><p>(2) Sam Tobin-Hochstadt and David Van Horn implemented <a href="https://arxiv.org/abs/1306.4713v2">teaching languages for <span>Fundamentals II</span></a> to bridge the gap between <span>Fundamentals I</span> and <span>Fundamentals II</span>
and used them to teach honors sections of the latter. The teaching
languages gradually introduced the concepts from object-oriented languages,
starting from a functional approach and matching the design concepts. If a
computer science unit has the luxury to spend an additional semester on
preparing their students for real-world programming, this approach is
highly commendable. <span>End of Notes</span></p><p>With regard to <span>people skills</span>, <span>Fundamentals II</span> is like <span>Fundamentals I</span> and adds a first
taste of code reviews. That is, <span>Fundamentals II</span> continues to have students program in
pairs. In addition, <span>Fundamentals II</span> provides the proper context to request a first code
review from students. One possibility is to assign a small project toward the
end of the course and to have students present an overview to the
instructor. An alternative is to have students present pieces from their
homework portfolio.</p><h5>2.4<tt>¬†</tt><a name="(part._.Logic__.Reasoning_about_.Well-designed_.Code)"></a>Logic: Reasoning about Well-designed Code<span><a href="#(part._.Logic__.Reasoning_about_.Well-designed_.Code)" title="Link to here">üîó</a><span> </span></span></h5><blockquote><blockquote><blockquote><p>People often use the term ‚Äútype-safe‚Äù languages. The term is
vague because untyped languages also come with sound prediction systems, and
‚Äúsafety‚Äù has no universal definition.</p></blockquote></blockquote></blockquote><p>Logic is to programming what analysis is to engineering. Engineers use
 analytic mathematics to make predictions about the robustness and behavior
 of their blueprints. Programmers continuously predict the behavior of the
 phrases they write down and compose. As programming language researchers
 have shown over the past 50 years, logic provides the proper foundation
 for programmers‚Äô predictions and logical meta-theory explains the validity
 of making predictions. More precisely, predictions correspond to theorems,
 validations for predictions are proofs, and program executions map to
 models. It is thus proper to call a validation system <span>sound</span> if
 its predictions are always true statements about executions; an
 <span>unsound</span> system makes correct and <span>incorrect</span> predictions.</p><blockquote><blockquote><blockquote><p>If a programmer is lucky, the bad array reference in C/C++
causes a seg fault.</p></blockquote></blockquote></blockquote><p>Consider arrays in a typed language. Roughly speaking, an array <span>a</span> of
 type <span>T</span> is a function that maps an index in some prefix of the natural
 numbers to instances of <span>T</span>. Programmers can thus predict that applying
 <span>a</span> to <span>i</span>‚Äî<wbr/>often written as <span>a[i]</span>‚Äî<wbr/>yields (bits that
 represent) some <span>T</span> if the control flow reaches the point beyond the
 array reference. In a sound language such as Java or ML, this claim
 always holds; it roughly corresponds to the <span>modus ponens</span> rule of
 classical logic. In C or C++, this claim is wrong. If <span>i</span> is out of
 bounds, the array reference produces whatever random bits it finds and
 interprets them as elements of <span>T</span>‚Äî<wbr/>even if doing so makes no sense.</p><p>When programmers create code, they continuously make, and rely on,
 predictions‚Äî<wbr/>consciously or subconsciously. This is simply how programming
 works, even if programmers do not design code but ‚Äútinker until it works.‚Äù
 The logical term for making predictions is ‚Äúreasoning about programs.‚Äù The
 predictions correspond to <span>theorems</span> and the arguments in their
 support are <span>proofs</span>.  In typed languages, for example, function types
 are theorems, the function definition is a proof, and the type checker
 ensures that the proof supports the theorem. If a function has a well-chosen
 name, other programmers can use the function based on its type and name.</p><p>Given this background, the goals of <span>Logic in Computer Science</span> are to
</p><div><ul><li><p>make reasoning about programs explicit</p></li><li><p>introduce students to tools that assist programmers with this task.</p></li></ul></div><p>Students thus get a first taste of how it works, and they experience how much
 easier it is to reason about well-designed programs.</p><p><span>Logic in Computer Science</span> realizes the first goal with an introduction of classical
(propositional and first-order) logic, heavily emphasizing structural
induction as a proof method for establishing theorems about functions and
programs. Structural induction is dual to the design recipe of <span>Fundamentals I</span>‚Äî<wbr/>by
design‚Äî<wbr/>and therefore works particularly well.</p><p>The course motivates the second goal by applying logic to sizable
programs. Logical reasoning applied to such programs requires the
management of large number of details. Software is well-suited for managing
numerous details, so students <span>Logic in Computer Science</span> uses a proof assistant for the task
of scaling proofs to complete programs.</p><p>ACL2, the chosen proof assistant, encapsulates a logic that closely
corresponds to the design recipe of <span>Fundamentals I</span>. If students properly design the
desired functions in <span>Fundamentals I</span>, ACL2 can often prove the desired theorems
easily. If students tinker their way to a complete function, the proof
assistant tends to fail. In short, ACL2 naturally reinforces the explicit
design rules of <span>Fundamentals I</span>.</p><h5>2.5<tt>¬†</tt><a name="(part._.O.O.D__.Scaling_.It_.Up)"></a>OOD: Scaling It Up<span><a href="#(part._.O.O.D__.Scaling_.It_.Up)" title="Link to here">üîó</a><span> </span></span></h5><p>The primary goal of <span>OOD</span> is to deepen students‚Äô practical programming
 skills by scaling up the complexity of the projects, without changing the
 programming language from <span>Fundamentals II</span>. Instead of complete, but relatively
 small programs, students are expected to design program components and
 glue components together. Designing components also introduces the
 challenge of creating interfaces and protocols and, conversely, of using
 existing interfaces and protocols.</p><p>Interfaces and protocols often come with logical assertions that partly
 explain the implementations‚Äô behavior. A classical assertion may restrict the
 kinds of arguments a method can cope with, e.g., only positive integers or
 only an array of integers that add up to 100. A temporal assertion in an
 interface may require that an <span>open</span> method is called before a
 <span>read</span> method.</p><p>While <span>Logic in Computer Science</span> shows how logical reasoning formally works on small
 functions and programs, <span>OOD</span> focuses on stating and exploiting such
 assertions during the informal prediction process that takes place when
 programmers design interfaces and code. Until formal methods researchers
 make formal reasoning affordable, this informal mode of thinking will
 inform the best designers in the field.</p><p>As feasible, <span>OOD</span> also scales up students‚Äô communication skills. Instead
 of presenting their designs and code to an instructor, students may present
 their work to the entire class. Instructors should encourage the class to
 comment on the content of the presentation.</p><h5>2.6<tt>¬†</tt><a name="(part._.Software_.Development__.Putting_it_.All_.Together)"></a>Software Development: Putting it All Together<span><a href="#(part._.Software_.Development__.Putting_it_.All_.Together)" title="Link to here">üîó</a><span> </span></span></h5><p><span>Software Dev</span> is basically a capstone of our core courses.  The ideal <span>Software Dev</span>
student has taken <span>OOD</span>, completed the first co-op, and explored the
landscape of programming languages. What this student needs, is a chance to
get involved in the maintenance of code. More than any other task in the
realm of software, maintaining code shows why design matters, why logical
reasoning matters, and why people skills matter.</p><p>To emphasize these points, <span>Software Dev</span> instructors ought to allow students to
choose their favorite programming language for the course project(s). The
students should not perceive the chosen language as a constraint, though
they will necessarily find out that it is one. If they don‚Äôt, instructors
have chosen the wrong project.</p><p>Since the ideal <span>Software Dev</span> student is <span>not</span> able to manage a large project,
instructors ought to introduce students to this aspect of engineering
software <span>explicitly</span>‚Äî<wbr/>that is, not via ‚Äúmimic and modify.‚Äù One way
to accomplish this goal is to have students design parts of the projects
each week, to expose the weaknesses of their designs during code review, and
to then provide good versions of these designs later in the semester.</p><p>The key to <span>Software Dev</span> is that students must revisit code that they or their
peers created weeks ago and that the overall project is complex and large
(say more than 5,000 lines of code in any language) that this maintenance
task becomes non-trivial.  This step may take the form of fixing bugs,
adding features, replacing features, and even subtracting them. To complete
such tasks, students must reconstruct the thoughts that the creators of the
code had‚Äî<wbr/>and often did not write down as assertions or other validated
statements. Hence, if code repositories are rotated among the students,
this task drives home most clearly why (1) such additional assertions and
comments matter and (2) pair programming leaves behind residue of design
knowledge.</p><p><span>Software Dev</span> also expands the <span>people skills</span> that go with engineering
software. Students continue to program in pairs to hone their interpersonal
communication skills. In addition students must get a chance to present
several times to their peers in class to improve their presentation
skills. Finally, <span>Software Dev</span> is also the ideal point for introducing students to
the act of reviewing their peers‚Äô code.  One way to achieve this goal is to
follow the IBM ‚Äúwhite room‚Äù practice of code reviews, which over years of
experimentation suggests that
</p><div><ul><li><p>code reviews benefit from a general familiarity with the task;</p></li><li><p>the result of code reviews does <span>not</span> depend on prior attempts
to read designs or code;</p></li><li><p>the ideal code review panel consists of three panelists: (1) a head
reader who guides the panel‚Äôs interaction with the presenters, (2) a
secondary reader, and (3) a secretary who primarily focuses on writing down
the issues revealed during the review and suggestions made.</p></li></ul></div><p>Instructors can inform panelists of their performance and can judge the
secretary‚Äôs work by editing the review memo before it goes from the panel
to the presenters.</p><p><span>Note</span> Instructors get a lot of respect in this course if <span>they
implement</span> the project and are willing to present <span>their own code</span> at
any point in time. <span>End of Note</span></p><h4>3<tt>¬†</tt><a name="(part._.What_s_.Missing_)"></a>What‚Äôs Missing?<span><a href="#(part._.What_s_.Missing_)" title="Link to here">üîó</a><span> </span></span></h4><p>The College‚Äôs core curriculum has stood the test of time. Our co-op
employers recruit our students in good and bad times, and many are put to
work on actual programming projects. It has also become clear that our
students are still missing out on some skills that they need to become
well-rounded engineers of software.</p><p><span>Independent Exploration</span> Programming is like playing an instrument.
The more we practice, the better we get at it. Programming is also like
science. Constantly pushing the boundaries of our knowledge is key. What I
often find, however, is that our students do not seem to understand that
programming <span>beyond the classroom</span> is essential to their growth. Why
do our students lack incentives to explore on their own? What can we do to
provide incentives?</p><div><blockquote><blockquote><blockquote><p>Companies are clearly recognizing that tricky coding questions
about algorithms knowledge do not identify the best developers.</p></blockquote></blockquote></blockquote></div><p><span>Performance Debugging</span> Students also have a hard time connecting
 knowledge from algorithms to program design. While regurgitable knowledge
 from our algorithms course might currently help with job interviews,
 developing software needs a specific skill set from algorithms that
 colleges in general fail to teach:
</p><div><ul><li><p>use a performance debugger to identify hot spots in programs,</p></li><li><p>analyze hotspots and their surroundings,</p></li><li><p>create alternative solutions, and</p></li><li><p>set up relevant performance test suites to easily compare different solutions.</p></li></ul></div><p>A course based on the above cycle would motivate the dry material of a
 standard algorithms course and turn homework problems into hands-on
 assignments, which might make the course more accessible than a pure
 theory course. Creating such a course on performance debugging would
 further set apart our curriculum as novel and innovative.</p><blockquote><blockquote><blockquote><p>See <a href="https://felleisen.org/matthias/Cplusplus/">the course charter</a> that Peter D., Alan M.,
Magy S., Abutalib A., and myself worked out.</p></blockquote></blockquote></blockquote><p><span>Unsafe Programming</span> For better or worse, the world now has a software
infrastructure built in unsound (unsafe) languages, such as C, C++, or
Objective C. Over the past decade or so, people have recognized this
problem and have smothered the infrastructure software with layers created
in safe languages. One approach is to use (reasonably) safe scripting
languages that allow easy access to the unsafe layer as needed. Python
scripting is a prime example for this mode of work.</p><p>When programmers work in a mixed context they encounter entirely new
problems: seg faults, core dumps, or programs that output implausible
results. Our students must learn to write code in this world, pinpoint
bugs, and debugging techniques that take into account lack of soundness.
The College has finally created a course along these lines; time will tell
whether it accomplishes its mission.</p><p><span>Software Engineering</span> Once students know how to develop programs
systematically, they may wish to explore some of the software engineering
topics in depth. Three topics stand out in my mind:
</p><div><ul><li><p><span>testing</span>‚Äî<wbr/>While all five core courses heavily emphasize unit
testing, our students would greatly benefit from a course that exposes them
to the wider topic‚Äî<wbr/>regression testing, black-box and white-box testing,
etc.‚Äî<wbr/>as well as the currently most widely used testing methods‚Äî<wbr/>random
testing and mutation testing.</p></li><li><p><span>programming in a team</span>‚Äî<wbr/>None of the five core courses are
suitable for true team programming, which is quite different from pair
programming. Most of our graduates will end up working in teams and
preparing them for this style of work seems critical.</p></li><li><p><span>software modeling</span> ‚Äì Software engineers benefit from
‚Äúexecutable‚Äù models of their plans as much as architects like to simulate
3D walk-throughs of blueprints. Mapping such a model to constraint solvers
may reveal oversights, conflicts, hidden constraints and other issues that
become expensive to fix if they are not discovered in time. Researchers
like Daniel Jackson and Emina Torlak have clearly demonstrated the value of
modeling software blueprints and have made some effort to turn their
insights into courses. Perhaps it is time for Northeastern to catch up.</p></li></ul></div><p>In addition to these topics, the College must also pay attention to
emerging domains where software will play a critical role. No matter what
courses are offered though, the instruction should emphasize explicit ideas
over ‚Äúmimic and learn implicitly.‚Äù</p><h4>4<tt>¬†</tt><a name="(part._unique)"></a>P.S. Uniqueness<span><a href="#(part._unique)" title="Link to here">üîó</a><span> </span></span></h4><p>Our College is no longer the only computer science unit that teaches an
explicit and systematic approach to programming. A number of colleagues
have adapted our approach to their special needs and contexts:
</p><div><ul><li><p><span>Brown</span> teaches two versions of a like-minded first-year
curriculum. One covers explicit and systematic design in untyped and typed
functional (teaching) language as well as Java. Krishnamurthi‚Äôs alternative
introduction synthesizes our freshman course with an algorithmic course
based on
<a href="https://www.amazon.com/Introduction-Algorithms-A-Creative-Approach/dp/0201120372">Udi
Manber‚Äôs excellent book</a>.</p></li><li><p>Kathi Fisler mapped out an adaptation of our first-year curriculum at
<span>WPI</span>. Her adaptation improved on several aspects of <span>Fundamentals II</span>; her
‚Äúhonors‚Äù variant of <span>Fundamentals I</span> actually deserves the name.</p></li><li><p>Prabhakar Ragde at <span>Waterloo</span> has created three flavors of
courses similar to our <span>Fundamentals I</span>: ‚Äúregular,‚Äù ‚Äúnon-major,‚Äù and ‚Äúadvanced.‚Äù
All second-semester versions move into the design of imperative programs
inspired by the remaining material of HtDP/1e. Logic is covered in the
‚Äúadvanced‚Äù track using Haskell.</p></li><li><p>Gregor Kiczales at <span>British Columbia</span> offers several different
tracks for the last few weeks of the first course. Each shows students how
to apply explicit design in a range of scripting languages, tailored to
certain majors. He also created a Coursera version of the course, dubbed
<span>Systematic Programming</span>; this on-line version has attracted several
brilliant young high school students to the Racket community.</p></li><li><p>At the <span>University of Chile</span>, √âric Tanter uses Python to teach
HtDP.</p></li><li><p>Mike Sperber merged <span>Fundamentals I</span> and <span>Logic in Computer Science</span> into a single course at
<span>Tuebingen</span>, developed appropriate variations of our teaching
languages, and published a popular text book in German on the course.</p></li><li><p>Kenichi Asai from <span>Ochanomizu University</span> has
<a href="https://www.is.ocha.ac.jp/~asai/papers/tfpie2015.pdf">ported the GUI framework</a> for teaching <span>Fundamentals I</span> to OCaml and
experimented with a functionally typed course in the third semester. His
department also offers a regular version of <span>Fundamentals I</span>.</p></li></ul></div><p>A fair number of other universities (e.g. Chicago, Delaware, Northwestern,
Utah) and colleges (e.g., Boston College, Vassar) teach other variations on the
first and second course, but I am not familiar with all of their
improvements and variations.</p></div></div></div>
  </body>
</html>
