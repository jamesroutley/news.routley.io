<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/">Original</a>
    <h1>The Expression Problem and its solutions</h1>
    
    <div id="readability-page-1" class="page"><div>
                <div>
                    <div>
<!-- /.post-info -->                    </div>
                </div>
                <p>The craft of programming is almost universally concerned with different types of
data and operations/algorithms that act on this data <a href="#footnote-1" id="footnote-reference-1">[1]</a>. Therefore, it&#39;s
hardly surprising that designing abstractions for data types and operations has
been on the mind of software engineers and programming-language designers
since... forever.</p>
<p>Yet I&#39;ve only recently encountered a name for a software design problem which I
ran into multiple times in my career. It&#39;s a problem so fundamental that I was
quite surprised that I haven&#39;t seen it named before. Here is a quick problem
statement.</p>
<p>Imagine that we have a set of data types and a set of operations that act on
these types. Sometimes we need to add more operations and make sure they work
properly on all types; sometimes we need to add more types and make sure all
operations work properly on them. Sometimes, however, we need to add both - and
herein lies the problem. Most of the mainstream programming languages don&#39;t
provide good tools to add both new types and new operations to an existing
system without having to change existing code. This is called the &#34;expression
problem&#34;. Studying the problem and its possible solutions gives great insight
into the fundamental differences between object-oriented and functional
programming and well as concepts like interfaces and multiple dispatch.</p>
<div id="a-motivating-example">
<h2>A motivating example</h2>
<p>As is my wont, my example comes from the world of compilers and interpreters.
To my defense, this is also the example used in some of the seminal historic
sources on the expression problem, as the historical perspective section below
details.</p>
<p>Imagine we&#39;re designing a simple expression evaluator. Following the standard
<a href="https://eli.thegreenplace.net/2016/on-the-composite-and-interpreter-design-patterns">interpreter design pattern</a>, we have
a tree structure consisting of expressions, with some operations we can do on
such trees. In C++ we&#39;d have an interface every node in the expression tree
would have to implement:</p>
<div><pre><span></span><span>class</span><span> </span><span>Expr</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>virtual</span><span> </span><span>std</span><span>::</span><span>string</span><span> </span><span>ToString</span><span>()</span><span> </span><span>const</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>  </span><span>virtual</span><span> </span><span>double</span><span> </span><span>Eval</span><span>()</span><span> </span><span>const</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>This interface shows that we currently have two operations we can do on
expression trees - evaluate them and query for their string representations.
A typical leaf node expression:</p>
<div><pre><span></span><span>class</span><span> </span><span>Constant</span><span> </span><span>:</span><span> </span><span>public</span><span> </span><span>Expr</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>Constant</span><span>(</span><span>double</span><span> </span><span>value</span><span>)</span><span> </span><span>:</span><span> </span><span>value_</span><span>(</span><span>value</span><span>)</span><span> </span><span>{}</span><span></span>

<span>  </span><span>std</span><span>::</span><span>string</span><span> </span><span>ToString</span><span>()</span><span> </span><span>const</span><span> </span><span>{</span><span></span>
<span>    </span><span>std</span><span>::</span><span>ostringstream</span><span> </span><span>ss</span><span>;</span><span></span>
<span>    </span><span>ss</span><span> </span><span>&lt;&lt;</span><span> </span><span>value_</span><span>;</span><span></span>
<span>    </span><span>return</span><span> </span><span>ss</span><span>.</span><span>str</span><span>();</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>double</span><span> </span><span>Eval</span><span>()</span><span> </span><span>const</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>value_</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>

<span>private</span><span>:</span><span></span>
<span>  </span><span>double</span><span> </span><span>value_</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>And a typical composite expression:</p>
<div><pre><span></span><span>class</span><span> </span><span>BinaryPlus</span><span> </span><span>:</span><span> </span><span>public</span><span> </span><span>Expr</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>BinaryPlus</span><span>(</span><span>const</span><span> </span><span>Expr</span><span>&amp;</span><span> </span><span>lhs</span><span>,</span><span> </span><span>const</span><span> </span><span>Expr</span><span>&amp;</span><span> </span><span>rhs</span><span>)</span><span> </span><span>:</span><span> </span><span>lhs_</span><span>(</span><span>lhs</span><span>),</span><span> </span><span>rhs_</span><span>(</span><span>rhs</span><span>)</span><span> </span><span>{}</span><span></span>

<span>  </span><span>std</span><span>::</span><span>string</span><span> </span><span>ToString</span><span>()</span><span> </span><span>const</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>lhs_</span><span>.</span><span>ToString</span><span>()</span><span> </span><span>+</span><span> </span><span>&#34; + &#34;</span><span> </span><span>+</span><span> </span><span>rhs_</span><span>.</span><span>ToString</span><span>();</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>double</span><span> </span><span>Eval</span><span>()</span><span> </span><span>const</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>lhs_</span><span>.</span><span>Eval</span><span>()</span><span> </span><span>+</span><span> </span><span>rhs_</span><span>.</span><span>Eval</span><span>();</span><span></span>
<span>  </span><span>}</span><span></span>

<span>private</span><span>:</span><span></span>
<span>  </span><span>const</span><span> </span><span>Expr</span><span>&amp;</span><span> </span><span>lhs_</span><span>;</span><span></span>
<span>  </span><span>const</span><span> </span><span>Expr</span><span>&amp;</span><span> </span><span>rhs_</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>Until now, it&#39;s all fairly basic stuff. How extensible is this design? Let&#39;s
see... if we want to add new expression types (&#34;variable reference&#34;, &#34;function
call&#34; etc.), that&#39;s pretty easy. We just define additional classes inheriting
from <tt>Expr</tt> and implement the <tt>Expr</tt> interface (<tt>ToString</tt> and <tt>Eval</tt>).</p>
<p>However, what happens if we want to add new <em>operations</em> that can be applied to
expression trees? Right now we have <tt>Eval</tt> and <tt>ToString</tt>, but we may want
additional operations like &#34;type check&#34; or &#34;serialize&#34; or &#34;compile to
machine code&#34; or whatever.</p>
<p>It turns out that adding new operations isn&#39;t as easy as adding new types. We&#39;d
have to change the <tt>Expr</tt> interface, and consequently change every existing
expression type to support the new method(s). If we don&#39;t control the original
code or it&#39;s hard to change it for other reasons, we&#39;re in trouble.</p>
<p>In other words, we&#39;d have to violate the venerable <em>open-closed principle</em>,
one of the <a href="https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29">main principles of object-oriented design</a>, defined
as:</p>
<blockquote>
software entities (classes, modules, functions, etc.) should be open for
extension, but closed for modification</blockquote>
<p>The problem we&#39;re hitting here is called the <em>expression problem</em>, and the
example above shows how it applies to object-oriented programming.</p>
<p>Interestingly, the expression problem bites functional programming languages as
well. Let&#39;s see how.</p>
</div>
<div id="the-expression-problem-in-functional-programming">
<h2>The expression problem in functional programming</h2>
<p><strong>Update 2018-02-05:</strong> <a href="https://eli.thegreenplace.net/2018/more-thoughts-on-the-expression-problem-in-haskell/">a new post</a>
discusses the problem and its solutions in Haskell in more depth.</p>
<p>Object-oriented approaches tend to collect functionality in objects (types).
Functional languages cut the cake from a different angle, usually preferring
types as thin data containers, collecting most functionality in functions
(operations) that act upon them. Functional languages don&#39;t escape the
expression problem - it just manifests there in a different way.</p>
<p>To demonstrate this, let&#39;s see how the expression evaluator / stringifier looks
in Haskell. Haskell is a good poster child for functional programming since its
pattern matching on types makes such code especially succinct:</p>
<div><pre><span></span><span>module</span><span> </span><span>Expressions</span><span> </span><span>where</span><span></span>

<span>data</span><span> </span><span>Expr</span><span> </span><span>=</span><span> </span><span>Constant</span><span> </span><span>Double</span><span></span>
<span>          </span><span>|</span><span> </span><span>BinaryPlus</span><span> </span><span>Expr</span><span> </span><span>Expr</span><span></span>

<span>stringify</span><span> </span><span>::</span><span> </span><span>Expr</span><span> </span><span>-&gt;</span><span> </span><span>String</span><span></span>
<span>stringify</span><span> </span><span>(</span><span>Constant</span><span> </span><span>c</span><span>)</span><span> </span><span>=</span><span> </span><span>show</span><span> </span><span>c</span><span></span>
<span>stringify</span><span> </span><span>(</span><span>BinaryPlus</span><span> </span><span>lhs</span><span> </span><span>rhs</span><span>)</span><span> </span><span>=</span><span> </span><span>stringify</span><span> </span><span>lhs</span><span></span>
<span>                                </span><span>++</span><span> </span><span>&#34; + &#34;</span><span></span>
<span>                                </span><span>++</span><span> </span><span>stringify</span><span> </span><span>rhs</span><span></span>

<span>evaluate</span><span> </span><span>::</span><span> </span><span>Expr</span><span> </span><span>-&gt;</span><span> </span><span>Double</span><span></span>
<span>evaluate</span><span> </span><span>(</span><span>Constant</span><span> </span><span>c</span><span>)</span><span> </span><span>=</span><span> </span><span>c</span><span></span>
<span>evaluate</span><span> </span><span>(</span><span>BinaryPlus</span><span> </span><span>lhs</span><span> </span><span>rhs</span><span>)</span><span> </span><span>=</span><span> </span><span>evaluate</span><span> </span><span>lhs</span><span> </span><span>+</span><span> </span><span>evaluate</span><span> </span><span>rhs</span><span></span>
</pre></div>
<p>Now let&#39;s say we want to add a new operation - type checking. We simply have
to add a new function <tt>typecheck</tt> and define how it behaves for all known
kinds of expressions. No need to modify existing code.</p>
<p>On the other hand, if we want to add a new type (like &#34;function call&#34;), we get
into trouble. We now have to modify all existing functions to handle this new
type. So we hit exactly the same problem, albeit from a different angle.</p>
</div>
<div id="the-expression-problem-matrix">
<h2>The expression problem matrix</h2>
<p>A visual representation of the expression problem can be helpful to appreciate
how it applies to OOP and FP in different ways, and how a potential solution
would look.</p>
<p>The following 2-D table (a &#34;matrix&#34;) has types in its rows and operations in its
columns. A matrix cell <tt>row, col</tt> is checked when the operation <tt>col</tt> is
implemented for type <tt>row</tt>:</p>
<p><img alt="Basic expression problem matrix demonstarting the starting point" src="https://eli.thegreenplace.net/images/2016/expr-problem-matrix.png"/></p><p>In object-oriented languages, it&#39;s easy to add new types but difficult to add
new operations:</p>
<p><img alt="OOP expression problem matrix" src="https://eli.thegreenplace.net/images/2016/expr-problem-oop.png"/></p><p>Whereas in functional languages, it&#39;s easy to add new operations but difficult
to add new types:</p>
<p><img alt="FP expression problem matrix" src="https://eli.thegreenplace.net/images/2016/expr-problem-fp.png"/>
</p></div>
<div id="a-historical-perspective">
<h2>A historical perspective</h2>
<p>The expression problem isn&#39;t new, and has likely been with us since the early
days; it pops its head as soon as programs reach some not-too-high level of
complexity.</p>
<p>It&#39;s fairly certain that the name <em>expression problem</em> comes from <a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">an email</a> sent
by <a href="https://en.wikipedia.org/wiki/Philip_Wadler">Philip Wadler</a> to a mailing
list deailing with adding generics to Java (this was back in the 1990s).</p>
<p>In that email, Wadler points to the paper <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/">&#34;Synthesizing Object-Oriented and
Functional Design to Promote Re-Use&#34;</a> by
Krishnamurthi, Felleisen and Friedman as an earlier work describing the problem
and proposed solutions. This is a great paper and I highly recommend reading it.
Krishnamurthi et.al., in their references, point to papers from as early as 1975
describing variations of the problem in Algol.</p>
</div>
<div id="flipping-the-matrix-with-the-visitor-pattern">
<h2>Flipping the matrix with the visitor pattern</h2>
<p>So far the article has focused on the expression <em>problem</em>, and I hope it&#39;s
clear by now. However, the title also has the word <em>solution</em> in it, so let&#39;s
turn to that.</p>
<p>It&#39;s possible to kinda solve (read on to understand why I say &#34;kinda&#34;) the
expression problem in object-oriented languages; first, we have to look at how
we can flip the problem on its side using the visitor pattern. The visitor
pattern is very common for this kind of problems, and for a good reason. It lets
us reformulate our code in a way that makes it easier to change in some
dimensions (though harder in others).</p>
<p>For the C++ sample shown above, rewriting it using the visitor pattern means
adding a new &#34;visitor&#34; interface:</p>
<div><pre><span></span><span>class</span><span> </span><span>ExprVisitor</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>virtual</span><span> </span><span>void</span><span> </span><span>VisitConstant</span><span>(</span><span>const</span><span> </span><span>Constant</span><span>&amp;</span><span> </span><span>c</span><span>)</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>  </span><span>virtual</span><span> </span><span>void</span><span> </span><span>VisitBinaryPlus</span><span>(</span><span>const</span><span> </span><span>BinaryPlus</span><span>&amp;</span><span> </span><span>bp</span><span>)</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>And changing the <tt>Expr</tt> interface to be:</p>
<div><pre><span></span><span>class</span><span> </span><span>Expr</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>virtual</span><span> </span><span>void</span><span> </span><span>Accept</span><span>(</span><span>ExprVisitor</span><span>*</span><span> </span><span>visitor</span><span>)</span><span> </span><span>const</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>Now expression types defer the actual computation to the visitor, as
follows:</p>
<div><pre><span></span><span>class</span><span> </span><span>Constant</span><span> </span><span>:</span><span> </span><span>public</span><span> </span><span>Expr</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>Constant</span><span>(</span><span>double</span><span> </span><span>value</span><span>)</span><span> </span><span>:</span><span> </span><span>value_</span><span>(</span><span>value</span><span>)</span><span> </span><span>{}</span><span></span>

<span>  </span><span>void</span><span> </span><span>Accept</span><span>(</span><span>ExprVisitor</span><span>*</span><span> </span><span>visitor</span><span>)</span><span> </span><span>const</span><span> </span><span>{</span><span></span>
<span>    </span><span>visitor</span><span>-&gt;</span><span>VisitConstant</span><span>(</span><span>*</span><span>this</span><span>);</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>double</span><span> </span><span>GetValue</span><span>()</span><span> </span><span>const</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>value_</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>

<span>private</span><span>:</span><span></span>
<span>  </span><span>double</span><span> </span><span>value_</span><span>;</span><span></span>
<span>};</span><span></span>

<span>// ... similarly, BinaryPlus would have</span>
<span>//</span>
<span>//    void Accept(ExprVisitor* visitor) const {</span>
<span>//      visitor-&gt;VisitBinaryPlus(*this);</span>
<span>//    }</span>
<span>//</span>
<span>// ... etc.</span>
</pre></div>
<p>A sample visitor for evaluation would be <a href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<div><pre><span></span><span>class</span><span> </span><span>Evaluator</span><span> </span><span>:</span><span> </span><span>public</span><span> </span><span>ExprVisitor</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>double</span><span> </span><span>GetValueForExpr</span><span>(</span><span>const</span><span> </span><span>Expr</span><span>&amp;</span><span> </span><span>e</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>value_map_</span><span>[</span><span>&amp;</span><span>e</span><span>];</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>void</span><span> </span><span>VisitConstant</span><span>(</span><span>const</span><span> </span><span>Constant</span><span>&amp;</span><span> </span><span>c</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>value_map_</span><span>[</span><span>&amp;</span><span>c</span><span>]</span><span> </span><span>=</span><span> </span><span>c</span><span>.</span><span>GetValue</span><span>();</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>void</span><span> </span><span>VisitBinaryPlus</span><span>(</span><span>const</span><span> </span><span>BinaryPlus</span><span>&amp;</span><span> </span><span>bp</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>bp</span><span>.</span><span>GetLhs</span><span>().</span><span>Accept</span><span>(</span><span>this</span><span>);</span><span></span>
<span>    </span><span>bp</span><span>.</span><span>GetRhs</span><span>().</span><span>Accept</span><span>(</span><span>this</span><span>);</span><span></span>
<span>    </span><span>value_map_</span><span>[</span><span>&amp;</span><span>bp</span><span>]</span><span> </span><span>=</span><span> </span><span>value_map_</span><span>[</span><span>&amp;</span><span>(</span><span>bp</span><span>.</span><span>GetLhs</span><span>())]</span><span> </span><span>+</span><span> </span><span>value_map_</span><span>[</span><span>&amp;</span><span>(</span><span>bp</span><span>.</span><span>GetRhs</span><span>())];</span><span></span>
<span>  </span><span>}</span><span></span>

<span>private</span><span>:</span><span></span>
<span>  </span><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>const</span><span> </span><span>Expr</span><span>*</span><span>,</span><span> </span><span>double</span><span>&gt;</span><span> </span><span>value_map_</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>It should be obvious that for a given set of data types, adding new visitors is
easy and doesn&#39;t require modifying any other code. On the other hand, adding new
types is problematic since it means we have to update the <tt>ExprVisitor</tt>
interface with a new abstract method, and consequently update all the visitors
to implement it.</p>
<p>So it seems that we&#39;ve just turned the expression problem on its side: we&#39;re
using an OOP language, but now it&#39;s hard to add types and easy to add ops, just
like in the functional approach. I find it extremely interesting that we can do
this. In my eyes this highlights the power of different abstractions and
paradigms, and how they enable us to rethink a problem in a completely different
light.</p>
<p>So we haven&#39;t solved anything yet; we&#39;ve just changed the nature of the problem
we&#39;re facing. Worry not - this is just a stepping stone to an actual solution.</p>
</div>
<div id="extending-the-visitor-pattern">
<h2>Extending the visitor pattern</h2>
<p>The following is code excerpts from a C++ solution that follows the extended
visitor pattern proposed by Krishnamurthi et. al. in their paper; I strongly
suggest reading the paper (particularly section 3) if you want to understand
this code on a deep level. A complete code sample in C++ that compiles and runs
is <a href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/c%2B%2B/visitor-extended.cpp">available here</a>.</p>
<p>Adding new visitors (ops) with the visitor pattern is easy. Our challenge is to
add a new <em>type</em> without upheaving too much existing code. Let&#39;s see how it&#39;s
done.</p>
<p>One small design change that we should make to the original visitor pattern is
use <tt>virtual</tt> inheritance for <tt>Evaluator</tt>, for reasons that will soon become
obvious:</p>
<div><pre><span></span><span>class</span><span> </span><span>Evaluator</span><span> </span><span>:</span><span> </span><span>virtual</span><span> </span><span>public</span><span> </span><span>ExprVisitor</span><span> </span><span>{</span><span></span>
<span>  </span><span>// .. the rest is the same</span>
<span>};</span><span></span>
</pre></div>
<p>Now we&#39;re going to add a new type - <tt>FunctionCall</tt>:</p>
<div><pre><span></span><span>// This is the new (&#34;extended&#34;) expression we&#39;re adding.</span>
<span>class</span><span> </span><span>FunctionCall</span><span> </span><span>:</span><span> </span><span>public</span><span> </span><span>Expr</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>FunctionCall</span><span>(</span><span>const</span><span> </span><span>std</span><span>::</span><span>string</span><span>&amp;</span><span> </span><span>name</span><span>,</span><span> </span><span>const</span><span> </span><span>Expr</span><span>&amp;</span><span> </span><span>argument</span><span>)</span><span></span>
<span>      </span><span>:</span><span> </span><span>name_</span><span>(</span><span>name</span><span>),</span><span> </span><span>argument_</span><span>(</span><span>argument</span><span>)</span><span> </span><span>{}</span><span></span>

<span>  </span><span>void</span><span> </span><span>Accept</span><span>(</span><span>ExprVisitor</span><span>*</span><span> </span><span>visitor</span><span>)</span><span> </span><span>const</span><span> </span><span>{</span><span></span>
<span>    </span><span>ExprVisitorWithFunctionCall</span><span>*</span><span> </span><span>v</span><span> </span><span>=</span><span></span>
<span>        </span><span>dynamic_cast</span><span>&lt;</span><span>ExprVisitorWithFunctionCall</span><span>*&gt;</span><span>(</span><span>visitor</span><span>);</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>v</span><span> </span><span>==</span><span> </span><span>nullptr</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;Fatal: visitor is not ExprVisitorWithFunctionCall</span><span>\n</span><span>&#34;</span><span>;</span><span></span>
<span>      </span><span>exit</span><span>(</span><span>1</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>v</span><span>-&gt;</span><span>VisitFunctionCall</span><span>(</span><span>*</span><span>this</span><span>);</span><span></span>
<span>  </span><span>}</span><span></span>

<span>private</span><span>:</span><span></span>
<span>  </span><span>std</span><span>::</span><span>string</span><span> </span><span>name_</span><span>;</span><span></span>
<span>  </span><span>const</span><span> </span><span>Expr</span><span>&amp;</span><span> </span><span>argument_</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>Since we don&#39;t want to modify the existing visitors, we create a new one,
extending <tt>Evaluator</tt> for function calls. But first, we need to extend the
<tt>ExprVisitor</tt> interface to support the new type:</p>
<div><pre><span></span><span>class</span><span> </span><span>ExprVisitorWithFunctionCall</span><span> </span><span>:</span><span> </span><span>virtual</span><span> </span><span>public</span><span> </span><span>ExprVisitor</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>virtual</span><span> </span><span>void</span><span> </span><span>VisitFunctionCall</span><span>(</span><span>const</span><span> </span><span>FunctionCall</span><span>&amp;</span><span> </span><span>fc</span><span>)</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>Finally, we write the new evaluator, which extends <tt>Evaluator</tt> and supports
the new type:</p>
<div><pre><span></span><span>class</span><span> </span><span>EvaluatorWithFunctionCall</span><span> </span><span>:</span><span> </span><span>public</span><span> </span><span>ExprVisitorWithFunctionCall</span><span>,</span><span></span>
<span>                                  </span><span>public</span><span> </span><span>Evaluator</span><span> </span><span>{</span><span></span>
<span>public</span><span>:</span><span></span>
<span>  </span><span>void</span><span> </span><span>VisitFunctionCall</span><span>(</span><span>const</span><span> </span><span>FunctionCall</span><span>&amp;</span><span> </span><span>fc</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;Visiting FunctionCall!!</span><span>\n</span><span>&#34;</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>
<span>};</span><span></span>
</pre></div>
<p>Multiple inheritance, virtual inheritance, dynamic type checking... that&#39;s
pretty hard-core C++ we have to use here, but there&#39;s no choice. Unfortunately,
multiple inheritance is the only way C++ lets us express the idea that a class
implements some interface while at the same time deriving functionality from
another class. What we want to have here is an evaluator
(<tt>EvaluatorWithFunctionCall</tt>) that inherits all functionality from
<tt>Evaluator</tt>, and also implements the <tt>ExprVisitorWithFunctionCall</tt>
interface. In Java, we could say something like:</p>
<div><pre><span></span><span>class</span> <span>EvaluatorWithFunctionCall</span><span> </span><span>extends</span><span> </span><span>Evaluator</span><span> </span><span>implements</span><span> </span><span>ExprVisitor</span><span> </span><span>{</span><span></span>
<span>  </span><span>// ...</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>But in C++ virtual multiple inheritance is the tool we have. The virtual part of
the inheritance is essential here for the compiler to figure out that the
<tt>ExprVisitor</tt> base underlying both <tt>Evaluator</tt> and
<tt>ExprVisitorWithFunctionCall</tt> is the same and should only appear once in
<tt>EvaluatorWithFunctionCall</tt>. Without virtual, the compiler would complain that
<tt>EvaluatorWithFunctionCall</tt> doesn&#39;t implement the <tt>ExprVisitor</tt> interface.</p>
<p>This is a solution, alright. We kinda added a new type <tt>FunctionCall</tt> and can
now visit it without changing existing code (assuming the virtual inheritance
was built into the design from the start to anticipate this approach). Here I
am using this &#34;kinda&#34; word again... it&#39;s time to explain why.</p>
<p>This approach has multiple flaws, in my opinion:</p>
<ol>
<li>Note the <tt>dynamic_cast</tt> in <tt><span>FunctionCall::Accept</span></tt>. It&#39;s fairly ugly that
we&#39;re forced to mix in dynamic checks into this code, which should supposedly
rely on static typing and the compiler. But it&#39;s just a sign of a larger
problem.</li>
<li>If we have an instance of an <tt>Evaluator</tt>, it will no longer work on the
whole extended expression tree since it has no understanding of
<tt>FunctionCall</tt>. It&#39;s easy to say that all new evaluators should rather be
<tt>EvaluatorWithFunctionCall</tt>, but we don&#39;t always control this. What about
code that was already written? What about <tt>Evaluator</tt>s created in
third-party or library code which we have no control of?</li>
<li>The virtual inheritance is not the only provision we have to build into the
design to support this pattern. Some visitors would need to create new,
recursive visitors to process complex expressions. But we can&#39;t anticipate
in advance which dynamic type of visitor needs to be created. Therefore,
the visitor interface should also accept a &#34;visitor factory&#34; which extended
visitors will supply. I know this sounds complicated, and I don&#39;t want to
spend more time on this here - but the Krishnamurthi paper addresses this
issue extensively in section 3.4</li>
<li>Finally, the solution is unwieldy for realistic applications. Adding one
new type looks manageable; what about adding 15 new types, gradually over
time? Imagine the horrible zoo of <tt>ExprVisitor</tt> extensions and dynamic
checks this would lead to.</li>
</ol>
<p>Yeah, programming is hard. I could go on and on about the limitations of
classical OOP and how they surface in this example <a href="#footnote-3" id="footnote-reference-3">[3]</a>. Instead, I&#39;ll just
present how the expression problem can be solved in a language that supports
multiple dispatch and separates the defintion of methods from the bodies of
types they act upon.</p>
</div>
<div id="solving-the-expression-problem-in-clojure">
<h2>Solving the expression problem in Clojure</h2>
<p>There are a number of ways the expression problem as displayed in this article
can be solved in Clojure using the language&#39;s built-in features. Let&#39;s start
with the simplest one - multi-methods.</p>
<p>First we&#39;ll define the types as records:</p>
<div><pre><span></span><span>(</span><span>defrecord </span><span>Constant</span><span> </span><span>[</span><span>value</span><span>])</span><span></span>
<span>(</span><span>defrecord </span><span>BinaryPlus</span><span> </span><span>[</span><span>lhs</span><span> </span><span>rhs</span><span>])</span><span></span>
</pre></div>
<p>Then, we&#39;ll define <tt>evaluate</tt> as a multimethod that dispatches upon the type
of its argument, and add method implementations for <tt>Constant</tt> and
<tt>BinaryPlus</tt>:</p>
<div><pre><span></span><span>(</span><span>defmulti </span><span>evaluate</span><span> </span><span>class</span><span>)</span><span></span>

<span>(</span><span>defmethod </span><span>evaluate</span><span> </span><span>Constant</span><span></span>
<span>  </span><span>[</span><span>c</span><span>]</span><span> </span><span>(</span><span>:value</span><span> </span><span>c</span><span>))</span><span></span>

<span>(</span><span>defmethod </span><span>evaluate</span><span> </span><span>BinaryPlus</span><span></span>
<span>  </span><span>[</span><span>bp</span><span>]</span><span> </span><span>(</span><span>+ </span><span>(</span><span>evaluate</span><span> </span><span>(</span><span>:lhs</span><span> </span><span>bp</span><span>))</span><span> </span><span>(</span><span>evaluate</span><span> </span><span>(</span><span>:rhs</span><span> </span><span>bp</span><span>))))</span><span></span>
</pre></div>
<p>Now we can already evaluate expressions:</p>
<div><pre><span></span><span>user=&gt;</span><span> </span><span>(</span><span>use</span><span> </span><span>&#39;expression.multimethod</span><span>)</span><span></span>
<span>nil</span><span></span>
<span>user=&gt;</span><span> </span><span>(</span><span>evaluate</span><span> </span><span>(</span><span>-&gt;BinaryPlus</span><span> </span><span>(</span><span>-&gt;Constant</span><span> </span><span>1.1</span><span>)</span><span> </span><span>(</span><span>-&gt;Constant</span><span> </span><span>2.2</span><span>)))</span><span></span>
<span>3.3000000000000003</span><span></span>
</pre></div>
<p>Adding a new operation is easy. Let&#39;s add <tt>stringify</tt>:</p>
<div><pre><span></span><span>(</span><span>defmulti </span><span>stringify</span><span> </span><span>class</span><span>)</span><span></span>

<span>(</span><span>defmethod </span><span>stringify</span><span> </span><span>Constant</span><span></span>
<span>  </span><span>[</span><span>c</span><span>]</span><span> </span><span>(</span><span>str </span><span>(</span><span>:value</span><span> </span><span>c</span><span>)))</span><span></span>

<span>(</span><span>defmethod </span><span>stringify</span><span> </span><span>BinaryPlus</span><span></span>
<span>  </span><span>[</span><span>bp</span><span>]</span><span></span>
<span>  </span><span>(</span><span>clojure.string/join</span><span> </span><span>&#34; + &#34;</span><span> </span><span>[(</span><span>stringify</span><span> </span><span>(</span><span>:lhs</span><span> </span><span>bp</span><span>))</span><span></span>
<span>                              </span><span>(</span><span>stringify</span><span> </span><span>(</span><span>:rhs</span><span> </span><span>bp</span><span>))]))</span><span></span>
</pre></div>
<p>Testing it:</p>
<div><pre><span></span><span>user=&gt;</span><span> </span><span>(</span><span>stringify</span><span> </span><span>(</span><span>-&gt;BinaryPlus</span><span> </span><span>(</span><span>-&gt;Constant</span><span> </span><span>1.1</span><span>)</span><span> </span><span>(</span><span>-&gt;Constant</span><span> </span><span>2.2</span><span>)))</span><span></span>
<span>&#34;1.1 + 2.2&#34;</span><span></span>
</pre></div>
<p>How about adding new types? Suppose we want to add <tt>FunctionCall</tt>. First,
we&#39;ll define the new type. For simplicity, the <tt>func</tt> field of
<tt>FunctionCall</tt> is just a Clojure function. In real code it could be some sort
of function object in the language we&#39;re interpreting:</p>
<div><pre><span></span><span>(</span><span>defrecord </span><span>FunctionCall</span><span> </span><span>[</span><span>func</span><span> </span><span>argument</span><span>])</span><span></span>
</pre></div>
<p>And define how <tt>evaluate</tt> and <tt>stringify</tt> work for <tt>FunctionCall</tt>:</p>
<div><pre><span></span><span>(</span><span>defmethod </span><span>evaluate</span><span> </span><span>FunctionCall</span><span></span>
<span>  </span><span>[</span><span>fc</span><span>]</span><span> </span><span>((</span><span>:func</span><span> </span><span>fc</span><span>)</span><span> </span><span>(</span><span>evaluate</span><span> </span><span>(</span><span>:argument</span><span> </span><span>fc</span><span>))))</span><span></span>

<span>(</span><span>defmethod </span><span>stringify</span><span> </span><span>FunctionCall</span><span></span>
<span>  </span><span>[</span><span>fc</span><span>]</span><span> </span><span>(</span><span>str </span><span>(</span><span>clojure.repl/demunge</span><span> </span><span>(</span><span>str </span><span>(</span><span>:func</span><span> </span><span>fc</span><span>)))</span><span></span>
<span>            </span><span>&#34;(&#34;</span><span></span>
<span>            </span><span>(</span><span>stringify</span><span> </span><span>(</span><span>:argument</span><span> </span><span>fc</span><span>))</span><span></span>
<span>            </span><span>&#34;)&#34;</span><span>))</span><span></span>
</pre></div>
<p>Let&#39;s take it for a spin (the full code <a href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/clojure/expression/src/expression/multimethod.clj">is here</a>):</p>
<div><pre><span></span><span>user=&gt;</span><span> </span><span>(</span><span>def </span><span>callexpr</span><span> </span><span>(</span><span>-&gt;FunctionCall</span><span> </span><span>twice</span><span> </span><span>(</span><span>-&gt;BinaryPlus</span><span> </span><span>(</span><span>-&gt;Constant</span><span> </span><span>1.1</span><span>)</span><span></span>
<span>                                                         </span><span>(</span><span>-&gt;Constant</span><span> </span><span>2.2</span><span>))))</span><span></span>
<span>#</span><span>&#39;user/callexpr</span><span></span>
<span>user=&gt;</span><span> </span><span>(</span><span>evaluate</span><span> </span><span>callexpr</span><span>)</span><span></span>
<span>6.6000000000000005</span><span></span>
<span>user=&gt;</span><span> </span><span>(</span><span>stringify</span><span> </span><span>callexpr</span><span>)</span><span></span>
<span>&#34;expression.multimethod/twice@52e29c38(1.1 + 2.2)&#34;</span><span></span>
</pre></div>
<p>It should be evident that the expression problem matrix for Clojure is:</p>
<p><img alt="Expression problem matrix in Clojure" src="https://eli.thegreenplace.net/images/2016/expr-problem-clojure.png"/></p><p>We can add new ops without touching any existing code. We can also add new types
without touching any existing code. The code we&#39;re adding is <em>only</em> the new code
to handle the ops/types in question. The existing ops and types could come from
a third-party library to which we don&#39;t have source access. We could still
extend them for our new ops and types, without ever having to touch (or even
see) the original source code <a href="#footnote-4" id="footnote-reference-4">[4]</a>.</p>
</div>
<div id="is-multiple-dispatch-necessary-to-cleanly-solve-the-expression-problem">
<h2>Is multiple dispatch necessary to cleanly solve the expression problem?</h2>
<p>I&#39;ve written about <a href="https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-4">multiple dispatch in Clojure</a>
before, and in the previous section we see another example of how to use the
language&#39;s <tt>defmulti</tt>/<tt>defmethod</tt> constructs. But is it multiple dispatch at
all? No! It&#39;s just <em>single</em> dispatch, really. Our ops (<tt>evaluate</tt> and
<tt>stringify</tt>) dispatch on a <em>single</em> argument - the expression type) <a href="#footnote-5" id="footnote-reference-5">[5]</a>.</p>
<p>If we&#39;re not really using multiple dispatch, what <em>is</em> the secret sauce that
lets us solve the expression problem so elegantly in Clojure? The answer is -
open methods. Note a crucial difference between how methods are defined in
C++/Java and in Clojure. In C++/Java, methods have to be part of a class and
defined (or at least declared) in its body. You cannot add a method to a class
without changing the class&#39;s source code.</p>
<p>In Clojure, you can. In fact, since data types and multimethods are orthogonal
entities, this is by design. Methods simply live outside types - they are first
class citizens, rather than properties of types. We don&#39;t add methods <em>to a
type</em>, we add new methods that <em>act upon the type</em>. This doesn&#39;t require
modifying the type&#39;s code in any way (or even having access to its code).</p>
<p>Some of the other popular programming languages take a middle way. In languages
like Python, Ruby and JavaScript methods belong to types, but we can dynamically
add, remove and replace methods in a class even after it was created. This
technique is lovingly called <em>monkey patching</em>. While initially enticing, it
can lead to big maintainability headaches in code unless we&#39;re very careful.
Therefore, if I had to face the expression problem in Python I&#39;d prefer to roll
out some sort of <a href="https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-2">multiple dispatch mechanism</a>
for my program rather than rely on monkey patching.</p>
</div>
<div id="another-clojure-solution-using-protocols">
<h2>Another Clojure solution - using protocols</h2>
<p>Clojure&#39;s multimethods are very general and powerful. So general, in fact, that
their performance may not be optimal for the most common case - which is single
dispatch based on the type of the sole method argument; note that this is
exactly the kind of dispatch I&#39;m using in this article. Therefore, starting with
Clojure 1.2, user code gained the ability to define and use <em>protocols</em> - a
language feature that was previously restricted only to built-in types.</p>
<p>Protocols leverage the host platform&#39;s (which in Clojure&#39;s case is mostly Java)
ability to provide quick virtual dispatch, so using them is a very efficient way
to implement runtime polymorphism. In addition, protocols retain enough of
the flexibility of multimethods to elegantly solve the expression problem.
Curiously, this was on the mind of Clojure&#39;s designers right from the start. The
Clojure <a href="http://clojure.org/reference/protocols">documentation page about protocols</a> lists this as one of their
capabilities:</p>
<blockquote>
[...] Avoid the &#39;expression problem&#39; by allowing independent extension of the
set of types, protocols, and implementations of protocols on types, by
different parties. [...] do so without wrappers/adapters</blockquote>
<p>Clojure protocols are an interesting topic, and while I&#39;d like to spend some
more time on them, this article is becoming too long as it is. So I&#39;ll leave
a more thorough treatment for some later time and for now will just show how
protocols can also be used to solve the expression problem we&#39;re discussing.</p>
<p>The type definitions remain the same:</p>
<div><pre><span></span><span>(</span><span>defrecord </span><span>Constant</span><span> </span><span>[</span><span>value</span><span>])</span><span></span>
<span>(</span><span>defrecord </span><span>BinaryPlus</span><span> </span><span>[</span><span>lhs</span><span> </span><span>rhs</span><span>])</span><span></span>
</pre></div>
<p>However, instead of defining a multimethod for each operation, we now define
a <em>protocol</em>. A protocol can be thought of as an interface in a language like
Java, C++ or Go - a type implements an interface when it defines the set of
methods declared by the interface. In this respect, Clojure&#39;s protocols are more
like Go&#39;s interfaces than Java&#39;s, as we don&#39;t have to say a-priori which
interfaces a type implements when we define it.</p>
<p>Let&#39;s start with the <tt>Evaluatable</tt> protocol, that consists of a single method
- <tt>evaluate</tt>:</p>
<div><pre><span></span><span>(</span><span>defprotocol </span><span>Evaluatable</span><span></span>
<span>  </span><span>(</span><span>evaluate</span><span> </span><span>[</span><span>this</span><span>]))</span><span></span>
</pre></div>
<p>Another protocol we&#39;ll define is <tt>Stringable</tt>:</p>
<div><pre><span></span><span>(</span><span>defprotocol </span><span>Stringable</span><span></span>
<span>  </span><span>(</span><span>stringify</span><span> </span><span>[</span><span>this</span><span>]))</span><span></span>
</pre></div>
<p>Now we can make sure our types implement these protocols:</p>
<div><pre><span></span><span>(</span><span>extend-type</span><span> </span><span>Constant</span><span></span>
<span>  </span><span>Evaluatable</span><span></span>
<span>    </span><span>(</span><span>evaluate</span><span> </span><span>[</span><span>this</span><span>]</span><span> </span><span>(</span><span>:value</span><span> </span><span>this</span><span>))</span><span></span>
<span>  </span><span>Stringable</span><span></span>
<span>    </span><span>(</span><span>stringify</span><span> </span><span>[</span><span>this</span><span>]</span><span> </span><span>(</span><span>str </span><span>(</span><span>:value</span><span> </span><span>this</span><span>))))</span><span></span>

<span>(</span><span>extend-type</span><span> </span><span>BinaryPlus</span><span></span>
<span>  </span><span>Evaluatable</span><span></span>
<span>    </span><span>(</span><span>evaluate</span><span> </span><span>[</span><span>this</span><span>]</span><span> </span><span>(</span><span>+ </span><span>(</span><span>evaluate</span><span> </span><span>(</span><span>:lhs</span><span> </span><span>this</span><span>))</span><span> </span><span>(</span><span>evaluate</span><span> </span><span>(</span><span>:rhs</span><span> </span><span>this</span><span>))))</span><span></span>
<span>  </span><span>Stringable</span><span></span>
<span>    </span><span>(</span><span>stringify</span><span> </span><span>[</span><span>this</span><span>]</span><span></span>
<span>      </span><span>(</span><span>clojure.string/join</span><span> </span><span>&#34; + &#34;</span><span> </span><span>[(</span><span>stringify</span><span> </span><span>(</span><span>:lhs</span><span> </span><span>this</span><span>))</span><span></span>
<span>                                  </span><span>(</span><span>stringify</span><span> </span><span>(</span><span>:rhs</span><span> </span><span>this</span><span>))])))</span><span></span>
</pre></div>
<p>The <tt><span>extend-type</span></tt> macro is a convenience wrapper around the more general
<tt>extend</tt> - it lets us implement multiple protocols for a given type.
A sibling macro named <tt><span>extend-protocol</span></tt> lets us implement the same protocol
for multiple types in the same invocation <a href="#footnote-6" id="footnote-reference-6">[6]</a>.</p>
<p>It&#39;s fairly obvious that adding new data types is easy - just as we did above,
we simply use <tt><span>extend-type</span></tt> for each new data type to implement our current
protocols. But how do we add a new protocol and make sure all existing data
types implement it? Once again, it&#39;s easy because we don&#39;t have to modify any
existing code. Here&#39;s a new protocol:</p>
<div><pre><span></span><span>(</span><span>defprotocol </span><span>Serializable</span><span></span>
<span>  </span><span>(</span><span>serialize</span><span> </span><span>[</span><span>this</span><span>]))</span><span></span>
</pre></div>
<p>And this is its implementation for the currently supported data types:</p>
<div><pre><span></span><span>(</span><span>extend-protocol</span><span> </span><span>Serializable</span><span></span>
<span>  </span><span>Constant</span><span></span>
<span>    </span><span>(</span><span>serialize</span><span> </span><span>[</span><span>this</span><span>]</span><span> </span><span>[(</span><span>type</span><span> </span><span>this</span><span>)</span><span> </span><span>(</span><span>:value</span><span> </span><span>this</span><span>)])</span><span></span>
<span>  </span><span>BinaryPlus</span><span></span>
<span>    </span><span>(</span><span>serialize</span><span> </span><span>[</span><span>this</span><span>]</span><span> </span><span>[(</span><span>type</span><span> </span><span>this</span><span>)</span><span></span>
<span>                       </span><span>(</span><span>serialize</span><span> </span><span>(</span><span>:lhs</span><span> </span><span>this</span><span>))</span><span></span>
<span>                       </span><span>(</span><span>serialize</span><span> </span><span>(</span><span>:rhs</span><span> </span><span>this</span><span>))]))</span><span></span>
</pre></div>
<p>This time, extending a single protocol for multiple data types -
<tt><span>extend-protocol</span></tt> is the more convenient macro to use.</p>
</div>
<div id="small-interfaces-are-extensibility-friendly">
<h2>Small interfaces are extensibility-friendly</h2>
<p>You may have noted that the protocols (interfaces) defined in the Clojure
solution are very small - consisting of a single method. Since adding methods to
an existing protocol is much more problematic (I&#39;m not aware of a way to do this
in Clojure), keeping protocols small is a good idea. This guideline comes up in
other contexts as well; for example, it&#39;s good practice to keep interfaces in Go
very minimal.</p>
<p>In our C++ solution, splitting the <tt>Expr</tt> interface could also be a good idea,
but it wouldn&#39;t help us with the expression problem, since we can&#39;t modify which
interfaces a class implements after we&#39;ve defined it; in Clojure we can.</p>
<hr/>
<table id="footnote-1">
<colgroup><col/><col/></colgroup>
<tbody>
<tr><td><a href="#footnote-reference-1">[1]</a></td><td>&#34;Types of data&#34; and &#34;operations&#34; are two terms that should be fairly
obvious to modern-day programmers. Philip Wadler, in his discussion of
the expression problem (see the &#34;historical perspective&#34; section of the
article) calls them &#34;datatypes&#34; and &#34;functions&#34;. A famous quote from Fred
Brooks&#39;s <em>The Mythical Man Month</em> (1975) is &#34;Show me your flowcharts and
conceal your tables, and I shall continue to be mystified. Show me your
tables, and I won’t usually need your flowcharts; they’ll be obvious.&#34;</td></tr>
</tbody>
</table>
<table id="footnote-2">
<colgroup><col/><col/></colgroup>
<tbody>
<tr><td><a href="#footnote-reference-2">[2]</a></td><td><p>Note the peculiar way in which data is passed between <tt>Visit*</tt> methods
in a <tt>Expr* <span>-&gt;</span> Value</tt> map kept in the visitor. This is due to our
inability to make <tt>Visit*</tt> methods return different types in different
visitors. For example, in <tt>Evaluator</tt> we&#39;d want them to return
<tt>double</tt>, but in <tt>Stringifier</tt> they&#39;d probably return
<tt><span>std::string</span></tt>. Unfortunately C++ won&#39;t let us easily mix templates and
virtual functions, so we have to resort to either returning <tt>void*</tt> the
C way or the method I&#39;m using here.</p>
<p>Curiously, in their paper Krishnamurthi et.al. run into the same issue in
the dialect of Java they&#39;re using, and propose some language extensions
to solve it. Philip Wadler uses proposed Java generics in <em>his</em> approach.</p>
</td></tr>
</tbody>
</table>
<table id="footnote-3">
<colgroup><col/><col/></colgroup>
<tbody>
<tr><td><a href="#footnote-reference-3">[3]</a></td><td>I can&#39;t resist, so just in brief: IMHO inheritance is only good for a
very narrow spectrum of uses, but languages like C++ hail it as the main
extension mechanism of types. But inheritance is deeply
flawed for many other use cases, such as implementations of
interfaces. Java is a bit better in this regard, but in the end the
primacy of classes and their &#34;closed-ness&#34; make a lot of tasks - like the
expression problem - very difficult to express in a clean way.</td></tr>
</tbody>
</table>
<table id="footnote-4">
<colgroup><col/><col/></colgroup>
<tbody>
<tr><td><a href="#footnote-reference-4">[4]</a></td><td>In fact, there are plenty of examples in which the Clojure implementation
and the standard library provide protocols that can be extended by the
user for user-defined types. Extending user-written protocols and
multimethods for built-in types is trivial. As an exercise, add an
<tt>evaluate</tt> implementation for <tt>java.lang.Long</tt>, so that built-in
integers could participate in our expression trees without requiring
wrapping in a <tt>Constant</tt>.</td></tr>
</tbody>
</table>
<table id="footnote-5">
<colgroup><col/><col/></colgroup>
<tbody>
<tr><td><a href="#footnote-reference-5">[5]</a></td><td>FWIW, we <em>can</em> formulate a multiple dispatch solution to the expression
problem in Clojure. The key idea is to dispatch on two things: type and
operation. Just for fun, I coded a prototype that does this which you can
see <a href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/clojure/expression/src/expression/multidispatch.clj">here</a>.
I think the approach presented in the article - each operation being its
own multimethod - is preferable, though.</td></tr>
</tbody>
</table>
<table id="footnote-6">
<colgroup><col/><col/></colgroup>
<tbody>
<tr><td><a href="#footnote-reference-6">[6]</a></td><td>The sharp-eyed reader will notice a cool connection to the expression
problem matrix. <tt><span>extend-type</span></tt> can add a whole new row to the matrix,
while <tt><span>extend-protocol</span></tt> adds a column. <tt>extend</tt> adds just a single
cell.</td></tr>
</tbody>
</table>
</div>

            </div></div>
  </body>
</html>
