<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tailscale.com/blog/ssh-console/">Original</a>
    <h1>Making an SSH client the hard way</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p><strong>Today, we‚Äôre launching a web-based SSH client: Tailscale SSH Console.</strong></p>
<p>From the Tailscale admin console, admins will now see a little ‚ÄúSSH‚Ä¶‚Äù button to connect to devices running <a href="https://www.core77.com/kb/1193/tailscale-ssh/">Tailscale SSH</a>. Click this, and you‚Äôll pop open an SSH client, right in your browser. Tailscale SSH Console is now available in beta.</p>

    
    

<figure>
        <img src="https://tailscale.com/blog/ssh-console/ssh-console.gif" alt="Animation of selecting a username to start a Tailscale SSH Console session."/>
    
    <figcaption>
        <p>To start a Tailscale SSH Console session, click ‚ÄúSSH‚Äù on the device, select the username you want to connect as, and reauthenticate.</p>
    </figcaption>
</figure>

<p>Web-based SSH clients aren‚Äôt new. Nearly every VPS and cloud provider already lets you connect to your VMs from the web ‚Äî so how is this different? With Tailscale SSH Console, your browser <em>becomes</em> a Tailscale client, and joins your <a href="https://www.core77.com/kb/1136/tailnet/">tailnet</a> in the same way as <a href="https://www.core77.com/blog/how-tailscale-works/">any other device that you run Tailscale on</a>. To make this possible, we ported the following to <a href="https://webassembly.org/">WebAssembly</a>: the Tailscale client, <a href="https://www.wireguard.com/">WireGuard¬Æ</a>, a complete <a href="https://gvisor.dev/docs/user_guide/networking/">userspace network stack</a> (from <a href="https://gvisor.dev/">gVisor</a>), and an SSH client.</p>
<p>When you click the ‚ÄúSSH‚Ä¶‚Äù button, we create an <a href="https://www.core77.com/kb/1111/ephemeral-nodes/">ephemeral</a> <a href="https://www.core77.com/kb/1085/auth-keys/">auth key</a> in the Tailscale coordination server, and then give that auth key to a Tailscale client loaded by your browser, which starts a node with that key. The client then creates an in-memory-only WireGuard keypair and starts to communicate with the Tailscale coordination server (to discover the rest of your tailnet) and <a href="https://www.core77.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp">DERP relays</a> (to be able to connect to other nodes). Like other clients that use DERP, the traffic that passes through the relays is encrypted and not visible to Tailscale.</p>
<p>And because this uses Tailscale SSH, which authenticates each packet based on its <a href="https://www.core77.com/kb/1193/tailscale-ssh/#how-does-it-work">WireGuard cryptographic identity</a>, we don‚Äôt need to ask you for a password, or have you upload a public key, or have you manage an <code>authorized_keys</code> file. Just click ‚ÄúSSH‚Ä¶‚Äù <em>and you‚Äôre in</em> ü™Ñ.</p>
<h3 id="one-year-earlier">One year earlier</h3>
<p>Tailscale SSH Console started out as <a href="https://twitter.com/bradfitz/status/1450916922288005122">Brad‚Äôs vacation hack</a> to see if <a href="https://github.com/golang/go/wiki/WebAssembly">Go‚Äôs WebAssembly support</a> was good enough to allow the Tailscale client to be compiled for the browser. After some <a href="https://github.com/tailscale/tailscale/pull/3155">hacking</a> <a href="https://github.com/tailscale/tailscale/pull/3195">and</a> <a href="https://github.com/tailscale/tailscale/pull/4709">slashing</a> to fix build errors (including changes <a href="https://git.zx2c4.com/wireguard-go/commit/?id=82e0b734e5d28f96205de65fd2179e08fd91b1db">to wireguard-go</a>), we had a binary that would load in the browser ‚Äî but it couldn‚Äôt connect to anything.</p>

    
    

<figure>
        <img src="https://tailscale.com/blog/ssh-console/ssh-console-architecture.png" alt="Architecture diagram for Tailscale SSH Console. Key exchange uses the Tailscale coordination server, and SSH traffic goes through DERP relays."/>
    
    <figcaption>
        <p>Tailscale SSH Console connects your browser to another node running Tailscale SSH.</p>
    </figcaption>
</figure>

<p>Tailscale tries really hard to establish connections, and if a direct path is not available, it will use <a href="https://www.core77.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp">a DERP relay server</a> to forward packets. However, a browser is an even more inhospitable environment than normal, and the DERP HTTP client <a href="https://github.com/tailscale/tailscale/blob/7cf8ec8108f4e26092bf07f698c8c5ce70d27d13/derp/derphttp/derphttp_client.go#L231-L362">reaching into connection internals</a> was not compatible with the <code><a href="https://github.com/golang/go/blob/1f068f0dc7bc997446a7aac44cfc70746ad918e0/src/net/http/roundtrip_js.go">fetch()-based HTTP transport</a></code> that ends up being used by Go when targeting WebAssembly. Like all problems in computer science, it could be solved with a layer of indirection. We added WebSockets <a href="https://github.com/tailscale/tailscale/pull/3165">as another transport</a> for DERP, and then wrapped a WebSocket connection into something that‚Äôs close enough to a <code>net.Conn</code> for the rest of the DERP code to use with no modifications. We were lucky that the <a href="https://github.com/nhooyr/websocket">Go WebSockets library</a> that we use (and <a href="https://github.com/orgs/tailscale/sponsoring">sponsor</a>) already had <a href="https://github.com/nhooyr/websocket/pull/142">good WebAssembly support</a>, and only needed <a href="https://github.com/nhooyr/websocket/pull/350">a small tweak</a>. We would later use this same <a href="https://github.com/tailscale/tailscale/pull/4781">‚Äútunnel it through WebSockets‚Äù approach</a> for the <a href="https://www.core77.com/blog/how-tailscale-works/#the-control-plane-key-exchange-and-coordination">coordination server</a> protocol.</p>
<p>Though we had a working WebAssembly binary, it was rather‚Ä¶large. While this is <a href="https://github.com/golang/go/wiki/WebAssembly#reducing-the-size-of-wasm-files">unavoidable</a> to some degree when building Go for WebAssembly, there was surely some low-hanging fruit. A friend had recently released <a href="https://github.com/evmar/weave">Weave</a>, a <code>.wasm</code> viewer, and we <a href="https://github.com/evmar/weave/pull/5">extended it with a tree view</a> to make it easier to see which packages and files were contributing to the binary size the most. We found a few <a href="https://github.com/tailscale/tailscale/pull/4802">unnecessary</a> <a href="https://github.com/tailscale/tailscale/pull/4813">dependencies</a>, and together with <a href="https://github.com/tailscale/tailscale/blob/9d04ffc7823dbd5fb18d5e5e9dea462846128969/cmd/tsconnect/common.go#L197-L207">some build settings tweaks</a> we were able to shave off a few megabytes. However, there‚Äôs still <a href="https://github.com/tailscale/tailscale/issues/5142">more work</a> to be done here.</p>
<h2 id="building-a-product">Building a product</h2>
<p>Just being able to have a Tailscale client run in the browser is cool in and of itself, but there was still the question of ‚ÄúOK, but what would you use it for?‚Äù. This occurred while we were developing <a href="https://www.core77.com/kb/1193/tailscale-ssh/">Tailscale SSH</a>, and we saw a natural application ‚Äî using this new capability to create a secure, in-browser, SSH client. We could have a client that let you browse through the devices on your tailnet that were accessible to you, made use of the <a href="https://www.core77.com/kb/1193/tailscale-ssh/#ensure-tailscale-ssh-is-permitted-in-acls">policy to let you pick a username</a> on the host, and integrated with <a href="https://www.core77.com/kb/1193/tailscale-ssh/#configure-tailscale-ssh-with-check-mode">check mode</a>.</p>
<p>The most natural place for this SSH client would be Tailscale‚Äôs <a href="https://login.tailscale.com/admin">admin console</a>, but that is part of the <a href="https://www.core77.com/blog/opensource/#why-our-coordination-server-is-closed-source">closed source coordination server</a>. We liked the idea of the WebAssembly client being open source, but we needed a way to reuse it in our closed source repo. We ended up making <a href="https://www.npmjs.com/package/@tailscale/connect">an NPM package</a> to allow this, which was a bit of a novelty in our Go-centric world. Though this package was developed for internal use, we want to support <a href="https://leaningtech.com/webvm-virtual-machine-with-networking-via-tailscale/">other interesting applications</a> ‚Äî so please <a href="https://github.com/tailscale/tailscale/issues/new/choose">get in touch</a> if you have something in mind.</p>
<p>Adding the ability to create SSH sessions from our admin panel led to some interesting user experience discussions. Would these sessions be transient, just open for a few minutes to check on something, or longer affairs? Would the user want to have multiple sessions running concurrently? As we pondered adding tabs to the panel, and possibly making things draggable and minimizable, it became apparent that we were effectively creating <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">a bug-ridden, informally-specified</a> implementation of half a window manager.</p>
<p>Rather than get into that business, we decided we should use real windows, and thus allow the user to have the same flexibility that they would with a real terminal. To make these windows fast, they are ‚Äúchild‚Äù windows that the main admin panel opens and uses as rendering surfaces ‚Äì all of the logic and state still remains in the parent window. This approach has good performance characteristics, but did require <a href="https://github.com/xtermjs/xterm.js/pull/4069">some</a> <a href="https://github.com/radix-ui/primitives/pull/1677">changes</a> to our frontend dependencies. To make it easier to iterate on these interface changes, we recreated <a href="https://blog.persistent.info/2016/01/static-resource-grafting.html">some tooling</a> to allow us to use in-development code with our prod tailnet, so that we could try out more realistic scenarios.</p>
<figure>
  <iframe width="100%" height="360" src="https://www.youtube.com/embed/3PkjPiN06Rc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
  <figcaption>Maya demonstrates how to use Tailscale SSH Console.</figcaption>
</figure>
<p>To try out Tailscale SSH Console: first, <a href="https://www.core77.com/kb/1193/tailscale-ssh/#configure-tailscale-ssh">enable Tailscale SSH</a> on the device you‚Äôre trying to connect to. Then, from the <a href="https://login.tailscale.com/admin/machines">machines tab</a> of the admin console, select ‚ÄúSSH‚Ä¶‚Äù to connect to any machine that your access controls allow you to connect to. Re-authenticate, and you‚Äôre in. <a href="https://www.core77.com/kb/1216/tailscale-ssh-console/">See the documentation</a> to learn more.</p>
    </div></div>
  </body>
</html>
