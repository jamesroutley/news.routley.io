<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nim-lang.org/araq/nimony.html">Original</a>
    <h1>Nimony (Nim 3.0) Design Principles</h1>
    
    <div id="readability-page-1" class="page"><div id="main" role="main">
  
<p><em>2025-05-03</em></p>
<p><em>Minor edits: 2025-05-10</em></p>
<p><a href="https://github.com/nim-lang/nimony">Nimony</a> is a new compiler for a variant of Nim which will become Nim 3.0, eventually. However, Nim is a big language so replicating what it does will take its time.</p>
<p>While we wait for this to happen, it turns out Nimony implements a streamlined, beautiful language useful in its own right! This article aims to describe this language here.</p>
<p>Following Nim&#39;s evolution, we aim to support hard real-time and embedded systems with a (mostly) memory safe language. The primary reason for the choice of this domain is generality: If you can run well on embedded systems you run well on everything else.</p>
<p>WCET (&#34;worst case execution time&#34;) is an important consideration: Operations should take a fixed amount of time and the produced machine code should be predictable. This rules out just-in-time compilers and tracing garbage collectors. The primitive types like <tt><span>int</span></tt> and <tt><span>char</span></tt> directly map to machine words and bytes. Complex types are formed without indirections: An object with fields <tt><span>a, b: float</span></tt> takes up <tt><span>2 * sizeof(float)</span></tt> bytes and is inlined directly into a stack frame or an embedding structure. (This is nothing new, Nim 2 does all of that already.)</p>

<h2 id="automatic-memory-management">Automatic memory management</h2><p>Automatic memory management (MM) is crucial for safety: If memory is not freed explicitly then it cannot be used after it has been freed! There are other solutions that offer both explicit MM and safety but Nim focuses on concise code. Implicit is good.</p>
<p>Like Nim 2.0, Rust and C++, Nimony offers scope-based MM based on destructors and move semantics. Unlike Nim 2.0 the plethora of <tt><span>mm</span></tt> switches is gone, only <tt><span>mm:atomicArc</span></tt> is offered. There is a novel cycle collection algorithm in development but it&#39;s unclear if or when it will be ready for production. In any case, objects involved in potential cycles need to be annotated with the new <tt><span>.cyclic</span></tt> pragma, as <tt><span>.acyclic</span></tt> is the new default.</p>
<p>MM based on destructors has the tremendous advantage that it actually <strong>composes</strong>: A <tt><span>seq</span></tt> of channels which require OS resource deallocation simply works. No other MM system offers this: Neither GCs with their unpredictable finalizers nor region-based MM which tends to keep objects around for much longer than necessary.</p>
<p>In other words, Nim 2&#39;s way of doing it is basically perfect and we simply reimplemented it.</p>

<h2 id="error-handling">Error handling</h2><p>&#34;Modern&#34; languages try to avoid exceptions by using sum types and pattern matching plus lots of sugar to make this bearable. I personally dislike both exceptions and its emulation via sum types. The &#34;early returns&#34; can get in the way no matter how you write them: <tt><span>for x in collection: ?destroy(x)</span></tt> admittedly makes the problem easier to spot (&#34;if an error occurs, not everything is destroyed&#34;) but even a single <tt><span>?</span></tt> can get in the way: An expression like <tt><span>fib(n-1) + fib(n-2)</span></tt> could hypothetically become something like <tt><span>?fib(n -? 1) +? ?fib(n -? 2)</span></tt>, or a more complex language rule like &#34;<tt><span>?</span></tt> is applied to all nested call expressions&#34; needs to be introduced.</p>
<p>I personally prefer to make the error state part of the objects: Streams can be in an error state, floats can be NaN and integers should be <tt><span>low(int)</span></tt> if they are invalid (<tt><span>low(int)</span></tt> is a pointless value anyway as it has no positive equivalent).</p>
<p>If such an object is not available, a thread-local error variable can be used as a side channel to signal errors. One can easily attach a stack trace to such an error and it can be checked whenever convenient.</p>
<p>Nevertheless Nimony offers Nim&#39;s traditional exception handling, but with a twist: A routine that can raise an exception must always be annotated with <tt><span>{.raises.}</span></tt>. It is not possible to say which exceptions are possible as the important aspect here is that the call of the routine introduces hidden control flow.</p>

<h3 id="error-codes">Error codes</h3><p>There is one programming construct that I have never regretted using: Nim&#39;s type-safe <tt><span>enum</span></tt>. It is simple, offers optimal performance and forces me to enumerate and handle all possible cases. Consequently Nimony allows to raise the new <tt><span>ErrorCode</span></tt> enum in addition to the ordinary exceptions (which are based on inheritance):</p>
<pre><span>import</span> <span>std</span><span>/</span><span>errorcodes</span>

<span>proc</span> <span>p</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>)</span> <span>{</span><span>.</span><span>raises</span><span>.</span><span>}</span> <span>=</span>
  <span>if</span> <span>x</span> <span>&lt;</span> <span>0</span><span>:</span>
    <span>raise</span> <span>ErrorCode</span><span>.</span><span>RangeError</span>
  <span>use</span> <span>x</span></pre>
<p>I hope that the <tt><span>ErrorCode</span></tt> enum will give us a unified way to propagate errors between different libraries. How <tt><span>ErrorCode</span></tt> is mapped from and to POSIX errno values, Windows API errors and HTTP status codes was a core consideration of its design. My vision is that Nim based services correctly report e.g. HTTP status code 507 (the disk is full), without any effort as it was encouraged by the language and its standard library.</p>
<p>As another nice benefit we get error handling based on <tt><span>raise</span></tt> that does not need to use heap allocations. OOM can be propagated without having to preallocate the OOM exception object.</p>

<h3 id="out-of-memory-oom">Out of memory (OOM)</h3><p>OOM is a misnomer that obfuscates the real problem: The system is not able to fulfill <em>one</em> particular request of a specific size. This size can be large and other smaller sizes might still be available. The prevalent wisdom of &#34;die on OOM instead of limping along&#34; is the result of laziness or rather a tradeoff between development effort and robustness. With effort one can treat OOM as yet another possible error state and continue execution, even if only to map it to a 507 HTTP error code properly.</p>
<p>In any case, it is very telling that the supposedly &#34;superior&#34; solutions to exception handling usually fall short in this regard and leave little options to handle OOM gracefully.</p>
<p>Nimony&#39;s solution to OOM is quite unique: Containers that fail to allocate memory call an overridable <tt><span>oomHandler</span></tt>. The default handler remembers the size of the failing request and then execution continues. One can then query for this case via <tt><span>threadOutOfMem()</span></tt>. Of course, one can set the <tt><span>oomHandler</span></tt> to a custom proc that simply tears down the application.</p>
<p>Nim&#39;s <tt><span>ref</span></tt> object construction (either by <tt><span>new</span></tt> or by <tt><span>ObjectRef(...)</span></tt>) can also fail. Thus it can return <tt><span>nil</span></tt>. Nimony will make a <tt><span>nil</span></tt> bug a thing of the past, enforcing that it is dealt with in the code like an <tt><span>Option</span></tt> type. This can become tedious for object construction which can be very frequent. An elegant solution here is to map the <tt><span>nil</span></tt> value to <tt><span>ErrorCode.OutOfMemError</span></tt> automatically if the proc was annotated with <tt><span>.raises</span></tt>:</p>
<pre><span>proc</span> <span>constructTree</span><span>(</span><span>payload</span><span>:</span> <span>sink</span> <span>string</span><span>)</span><span>:</span> <span>Node</span> <span>{</span><span>.</span><span>raises</span><span>.</span><span>}</span> <span>=</span>
  <span>result</span> <span>=</span> <span>Node</span><span>(</span><span>)</span>
  
  <span>result</span><span>.</span><span>field</span> <span>=</span> <span>payload</span></pre>
<p>In other words, general pointer checking is done with <tt><span>nil</span></tt> / <tt><span>not nil annotations</span></tt> plus static analysis that enforces you got it right. But for <tt><span>new</span></tt> its return type is polymorphic:</p>
<ul><li>In a <tt><span>.raises</span></tt> routine we already have a channel for OOM propagation so the return type is <tt><span>ref T not nil</span></tt>.</li>
<li>In a routine that has no <tt><span>.raises</span></tt> annotation the return type is <tt><span>nilable ref T</span></tt> so you are forced to check for nil before you can deref the pointer.</li>
</ul>
<p>This design to handle OOM does not depend on exceptions but can be used in combination with them. Experience with it will tell us whether it holds up well for realistic systems or not.</p>

<h2 id="generic-code">Generic code</h2><p>Static type checking is the biggest productivity boost that I know of. It is also an incredible tool to get reliable performance out of primitive language implementations. A static type system is incomplete without generics. Generics are a hard requirement for custom containers like sequences, tables and trees. And once custom containers work sufficiently well, the need for built-in containers diminishes! So Nimony&#39;s <tt><span>seq</span></tt> is a pure library implementation and <tt><span>string</span></tt> only has very little compiler magic so that string literals are of type <tt><span>string</span></tt>.</p>
<p>Nimony improves on Nim&#39;s generics by performing complete type checking on generic code, not merely on generic instantiations. This allows to catch errors early and to provide better error messages, but most importantly it allows an IDE to provide precise completion suggestions. Nim&#39;s <tt><span>concepts</span></tt> are essential for type checking generic code:</p>
<pre><span>type</span>
  <span>Fibable</span> <span>=</span> <span>concept</span>
    <span>proc</span> <span>`</span><span>&lt;=</span><span>`</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>Self</span><span>)</span><span>:</span> <span>bool</span>
    <span>proc</span> <span>`</span><span>+</span><span>`</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>:</span> <span>Self</span><span>)</span><span>:</span> <span>Self</span>
    <span>proc</span> <span>`</span><span>-</span><span>`</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>:</span> <span>Self</span><span>)</span><span>:</span> <span>Self</span>

<span>proc</span> <span>fib</span><span>[</span><span>T</span><span>:</span> <span>Fibable</span><span>]</span><span>(</span><span>a</span><span>:</span> <span>T</span><span>)</span><span>:</span> <span>T</span> <span>=</span>
  <span>if</span> <span>a</span> <span>&lt;=</span> <span>2</span><span>:</span>
    <span>result</span> <span>=</span> <span>1</span>
  <span>else</span><span>:</span>
    <span>result</span> <span>=</span> <span>fib</span><span>(</span><span>a</span><span>-</span><span>1</span><span>)</span> <span>+</span> <span>fib</span><span>(</span><span>a</span><span>-</span><span>2</span><span>)</span></pre>
<p>Without declaring that <tt><span>T</span></tt> must be <tt><span>Fibable</span></tt> the compiler rejects <tt><span>proc fib</span></tt>. A generic parameter can always be used in assignments though, otherwise code like <tt><span>let x = y</span></tt> would need to be rejected only to discover later that <tt><span>y</span></tt> should have been moved anyway. Move analysis happens later after type checking so some compromises are necessary.</p>

<h2 id="concurrency-amp-parallelism">Concurrency &amp; Parallelism</h2><p>Nimony unifies async and multi-threaded programming. There is only one construct for both written as <tt><span>spawn</span></tt>. Whether this runs on the same thread or a different one is decided at runtime by a scheduler. This means that in <tt><span>spawn f(args)</span></tt> the restrictions for <tt><span>args</span></tt> must always enforce thread safety. This is a good thing as the concurrency that is provided by asynchronous programming introduces many of the same pitfalls as multi-threaded programming.</p>
<p>Nimony&#39;s concurrency model will be based on continuations. The compiler will transform the program into continuation passing style (CPS). The programmer does not notice much, however. The exposed interface is via a <tt><span>scheduler</span></tt> module and its <tt><span>spawn</span></tt> operation. <tt><span>scheduler.spawn f(args)</span></tt> is the core of the design.</p>
<p>Parallelism is fundamentally simpler to implement than concurrency: The reason is that <tt><span>spawn f(args)</span></tt> can be translated to <tt><span>threadpool.send toTask(f, args)</span></tt> which is a <em>local</em> transformation. The rest of the function does not have to be transformed. No CPS is needed. However, a high performance thread pool implementation can also benefit from CPS so again the unification of <tt><span>await</span></tt> and <tt><span>spawn</span></tt> does not hurt.</p>

<h2 id="pure-parallelism">Pure parallelism</h2><p>When writing <a href="https://github.com/araq/malebolgia">Malebolgia</a> there was something that bugged me about the typical parallel Fibonacci example:</p>
<pre><span>proc</span> <span>fib</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span><span>:</span> <span>int</span> <span>=</span>
  <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span> <span>return</span> <span>n</span>
  <span>parallel</span><span>:</span>
    <span>let</span> <span>a</span> <span>=</span> <span>spawn</span> <span>fib</span><span>(</span><span>n</span><span>-</span><span>1</span><span>)</span>
    <span>let</span> <span>b</span> <span>=</span> <span>spawn</span> <span>fib</span><span>(</span><span>n</span><span>-</span><span>2</span><span>)</span> 
  <span>return</span> <span>a</span> <span>+</span> <span>b</span></pre>
<p>can also be written as</p>
<pre><span>proc</span> <span>fib</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span><span>:</span> <span>int</span> <span>=</span>
  <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span> <span>return</span> <span>n</span>
  <span>parallel</span><span>:</span>
    <span>let</span> <span>a</span> <span>=</span> <span>spawn</span> <span>fib</span><span>(</span><span>n</span><span>-</span><span>1</span><span>)</span>
    <span>let</span> <span>b</span> <span>=</span> <span>fib</span><span>(</span><span>n</span><span>-</span><span>2</span><span>)</span> 
  <span>return</span> <span>a</span> <span>+</span> <span>b</span></pre>
<p>The asymmetry of the recursive <tt><span>fib</span></tt> invocations is ugly.</p>
<p>Usually there are also non-obvious rules about when <tt><span>a</span></tt> and <tt><span>b</span></tt> can be read from. These issues, as minor as they might seem, do not exist with a <tt><span>parallel for</span></tt> loop:</p>
<pre><span>proc</span> <span>fib</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span><span>:</span> <span>int</span> <span>=</span>
  <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span> <span>return</span> <span>n</span>
  <span>var</span> <span>a</span><span>:</span> <span>array</span><span>[</span><span>2</span><span>,</span> <span>int</span><span>]</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>||</span> <span>1</span><span>:</span> 
    <span>a</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>fib</span><span>(</span><span>n</span><span>-</span><span>i</span><span>-</span><span>1</span><span>)</span>
  <span>return</span> <span>a</span><span>[</span><span>0</span><span>]</span> <span>+</span> <span>a</span><span>[</span><span>1</span><span>]</span></pre>
<p>The last iteration of a parallel loop can always be run on the calling thread but it&#39;s neither necessary nor possible to write this out.</p>
<p>In a parallel for loop we know by design that the induction variable <tt><span>i</span></tt> creates a disjoint set of locations for <tt><span>a[i]</span></tt>. We also know that after the loop all the parallelism is over, it produces exactly the kind of &#34;structured&#34; parallelism that Malebolgia provides.</p>
<p>So Nimony should offer <tt><span>parallel for</span></tt> loops. With these we can write parallel array processing programs without flow vars! This is important as much of scientific computing and GPU programming is done with <tt><span>Matrix[float]</span></tt> and not <tt><span>Matrix[FlowVar[float]]</span></tt>.</p>

<p>The <tt><span>spawn</span></tt> construct is in reality not built into the language but implemented as a compiler plugin. Plugins are the final evolved form of Nim&#39;s macros:</p>
<ol><li>They are compiled to machine code so that every language feature can be used, including low-level unsafe constructs.</li>
<li>They usually run after type-checking, in Nim&#39;s terms they use <tt><span>typed</span></tt> parameters. This means complete type information is available for introspection.</li>
<li>There will be more convenient APIs available for plugin development. Thanks to NIF many transformations become simpler and can be done without recursions.</li>
<li>They run incrementally and in parallel just like the rest of the compilation pipeline.</li>
</ol>
<p>For a simple example we will write a plugin that does the same as this simple template:</p>
<pre><span>template</span> <span>generateEcho</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>)</span> <span>=</span> <span>echo</span> <span>s</span></pre>
<p>A plugin is a template that lacks a body. Instead it has a <tt><span>{.plugin.}</span></tt> pragma listing the Nim program that implements the plugin:</p>
<pre><span>import</span> <span>std</span> <span>/</span> <span>syncio</span>

<span>template</span> <span>generateEcho</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>)</span> <span>{</span><span>.</span><span>plugin</span><span>:</span> <span>&#34;deps/mplugin1&#34;</span><span>.</span><span>}</span>

<span>generateEcho</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>)</span></pre>
<p>In &#34;deps/mplugin1.nim&#34; we write the implementation:</p>
<pre><span>import</span> <span>std</span> <span>/</span> <span>os</span>

<span>include</span> <span>lib</span> <span>/</span> <span>nifprelude</span>
<span>import</span> <span>nimony</span> <span>/</span> <span>nimony_model</span>

<span>proc</span> <span>tr</span><span>(</span><span>n</span><span>:</span> <span>Cursor</span><span>)</span><span>:</span> <span>TokenBuf</span> <span>=</span>
  <span>result</span> <span>=</span> <span>createTokenBuf</span><span>(</span><span>)</span>
  <span>let</span> <span>info</span> <span>=</span> <span>n</span><span>.</span><span>info</span>
  <span>var</span> <span>n</span> <span>=</span> <span>n</span>
  <span>if</span> <span>n</span><span>.</span><span>stmtKind</span> <span>==</span> <span>StmtsS</span><span>:</span> <span>inc</span> <span>n</span>
  <span>result</span><span>.</span><span>addParLe</span> <span>StmtsS</span><span>,</span> <span>info</span>
  <span>result</span><span>.</span><span>addParLe</span> <span>CallS</span><span>,</span> <span>info</span>
  <span>result</span><span>.</span><span>addIdent</span> <span>&#34;echo&#34;</span>
  <span>result</span><span>.</span><span>takeTree</span> <span>n</span>
  <span>result</span><span>.</span><span>addParRi</span><span>(</span><span>)</span>
  <span>result</span><span>.</span><span>addParRi</span><span>(</span><span>)</span>

<span>let</span> <span>input</span> <span>=</span> <span>os</span><span>.</span><span>paramStr</span><span>(</span><span>1</span><span>)</span>
<span>let</span> <span>output</span> <span>=</span> <span>os</span><span>.</span><span>paramStr</span><span>(</span><span>2</span><span>)</span>
<span>var</span> <span>inp</span> <span>=</span> <span>nifstreams</span><span>.</span><span>open</span><span>(</span><span>input</span><span>)</span>
<span>var</span> <span>buf</span> <span>=</span> <span>fromStream</span><span>(</span><span>inp</span><span>)</span>

<span>let</span> <span>outp</span> <span>=</span> <span>tr</span><span>(</span><span>beginRead</span> <span>buf</span><span>)</span>

<span>writeFile</span> <span>output</span><span>,</span> <span>toString</span><span>(</span><span>outp</span><span>)</span></pre>
<p>As there is currently no API for plugins, we have to import parts of the Nimony compiler and the code is a bit ugly. But it works!</p>
<p>Plugins that are attached to a template receive only the code that is related to the template invocation. But <tt><span>.plugin</span></tt> can also be a statement of its own, then it is a so called &#34;module plugin&#34;.</p>

<h3 id="module-plugins">Module plugins</h3><p>A module plugin receives the full code of a module. It needs to output back the complete module with some of its transformations locally applied.</p>
<p>To implement <tt><span>spawn</span></tt> as a plugin more than the <tt><span>.plugin</span></tt> annotation is required. To see why consider that the continuation of <tt><span>let x = spawn f(args); cont</span></tt> is the <tt><span>; cont</span></tt> part and that is what an async scheduler is interested in running later. So <tt><span>; cont</span></tt> must be turned into a function of its own. But like a macro <tt><span>spawn</span></tt> as a plugin <strong>cannot see</strong> the rest of a proc! Some top-level annotation like <tt><span>.async</span></tt> would be required. The module plugin is a new feature that allows us to leave out an <tt><span>.async</span></tt> annotation:</p>
<pre><span>type</span>
  <span>Scheduler</span><span>*</span> <span>=</span> <span>object</span>
    <span>tasks</span><span>:</span> <span>seq</span><span>[</span><span>Task</span><span>]</span>

<span>template</span> <span>spawn</span><span>*</span><span>[</span><span>T</span><span>]</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>Scheduler</span><span>;</span> <span>call</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>{</span><span>.</span><span>plugin</span><span>:</span> <span>&#34;stdplugins/cps&#34;</span><span>.</span><span>}</span>
  <span>s</span><span>.</span><span>enqueue</span> <span>toTask</span><span>(</span><span>call</span><span>)</span></pre>
<p>When <tt><span>spawn</span></tt> is called/expanded the compiler remembers that the full module should be passed to a <tt><span>cps</span></tt> plugin.</p>
<p>Since iterators are expanded much like templates a <tt><span>.plugin</span></tt> statement is lazily applied here too. The outlined parallel for loop iterator <tt><span>||</span></tt> can be written as:</p>
<pre><span>iterator</span> <span>`</span><span>||</span><span>`</span><span>*</span><span>[</span><span>T</span><span>:</span> <span>Ordinal</span><span>]</span><span>*</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>T</span><span>)</span><span>:</span> <span>T</span> <span>=</span>
  <span>{</span><span>.</span><span>plugin</span><span>:</span> <span>&#34;stdplugins/parfor&#34;</span><span>.</span><span>}</span>
  <span>var</span> <span>i</span> <span>=</span> <span>a</span>
  <span>while</span> <span>i</span> <span>&lt;=</span> <span>b</span><span>:</span>
    <span>yield</span> <span>i</span>
    <span>inc</span> <span>i</span></pre>
<p>Module plugins can also be attached to a nominal type (or a generic type that becomes a nominal type after instantiation). These plugins are invoked for every module that uses the type. This mechanism can replace Nim&#39;s &#34;term rewriting macros&#34;:</p>
<pre><span>type</span>
  <span>Matrix</span> <span>{</span><span>.</span><span>plugin</span><span>:</span> <span>&#34;avoidtemps&#34;</span><span>.</span><span>}</span> <span>=</span> <span>object</span>
    <span>a</span><span>:</span> <span>array</span><span>[</span><span>4</span><span>,</span> <span>array</span><span>[</span><span>4</span><span>,</span> <span>float</span><span>]</span><span>]</span>

<span>proc</span> <span>`</span><span>*=</span><span>`</span><span>(</span><span>x</span><span>:</span> <span>var</span> <span>Matrix</span><span>;</span> <span>y</span><span>:</span> <span>Matrix</span><span>)</span> <span>=</span> <span>...</span>
<span>proc</span> <span>`</span><span>+=</span><span>`</span><span>(</span><span>x</span><span>:</span> <span>var</span> <span>Matrix</span><span>;</span> <span>y</span><span>:</span> <span>Matrix</span><span>)</span> <span>=</span> <span>...</span>
<span>proc</span> <span>`</span><span>-=</span><span>`</span><span>(</span><span>x</span><span>:</span> <span>var</span> <span>Matrix</span><span>;</span> <span>y</span><span>:</span> <span>Matrix</span><span>)</span> <span>=</span> <span>...</span>

<span>proc</span> <span>`</span><span>*</span><span>`</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>:</span> <span>Matrix</span><span>)</span><span>:</span> <span>Matrix</span> <span>=</span>
  <span>result</span> <span>=</span> <span>x</span><span>;</span> <span>result</span> <span>*=</span> <span>y</span>
<span>proc</span> <span>`</span><span>+</span><span>`</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>:</span> <span>Matrix</span><span>)</span><span>:</span> <span>Matrix</span> <span>=</span>
  <span>result</span> <span>=</span> <span>x</span><span>;</span> <span>result</span> <span>+=</span> <span>y</span>
<span>proc</span> <span>`</span><span>-</span><span>`</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>:</span> <span>Matrix</span><span>)</span><span>:</span> <span>Matrix</span> <span>=</span>
  <span>result</span> <span>=</span> <span>x</span><span>;</span> <span>result</span> <span>-=</span> <span>y</span></pre>
<p>Code like <tt><span>let e = a*b + c - d</span></tt> is then rewritten to:</p>
<pre><span>var</span> <span>e</span> <span>=</span> <span>a</span>
<span>e</span> <span>*=</span> <span>b</span>
<span>e</span> <span>+=</span> <span>c</span>
<span>e</span> <span>-=</span> <span>d</span></pre>
<p>Avoiding the creation of temporary matrices entirely.</p>
<p>While the code for the avoidtemps plugin is beyond the scope of this article, this is a classical compiler transformation; especially the x86 architecture with its 2 operand instructions requires it too.</p>

<h2 id="conclusion">Conclusion</h2><p>Nimony represents an ambitious evolution of the Nim programming language, incorporating lessons learned from years of practical experience with Nim, while introducing novel approaches to error handling and meta-programming. As a work in progress, Nimony is being actively developed with a target release date in autumn 2025.</p>
<p>If you want to help us with development, the <a href="https://deepwiki.com/nim-lang/nimony">deepwiki AI</a> produced an excellent overview of our compiler architecture.</p>
<p>If you want to support us, please contribute to <a href="https://opencollective.com/nim">https://opencollective.com/nim</a>! Stay tuned for updates and early preview releases as we progress toward this milestone. </p>



</div></div>
  </body>
</html>
