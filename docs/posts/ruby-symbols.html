<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tech.stonecharioteer.com/posts/2025/ruby-symbols/">Original</a>
    <h1>Ruby Symbols</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="symbols-and-why-you-should-care">Symbols and Why You Should Care</h2>
<p>I should start, aptly, with <a href="https://ruby-doc.org/3.4.1/Symbol.html">the manual.</a></p>
<blockquote>
<p>A <code>Symbol</code> object represents a named identifier inside the Ruby interpreter.</p></blockquote>
<p>Okay, it’s a token of a sort, I think.</p>
<p>I’ve been befuddled when seeing <code>:name</code> instead of <code>name</code> and I didn’t know what it was at first.
I spent some time reading Michael Hartl’s Learn Enough Ruby and I cannot really say I understood Symbols,
so I wanted to RTFM.</p>
<blockquote>
<p>The same <code>Symbol</code> object will be created for a given name or string for the duration of a program’s execution,
regardless of the context or meaning of that name. Thus, if <code>Fred</code> is a constant in one context , a method in another,
and a class in a third, the <code>Symbol</code> <code>:Fred</code> will be the same object in all three contexts.</p></blockquote>





  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>module</span> <span>One</span>
</span></span><span><span>  <span>class</span> <span>Fred</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span>  <span>$f1</span> <span>=</span> <span>:Fred</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>Two</span>
</span></span><span><span>  <span>Fred</span> <span>=</span> <span>1</span>
</span></span><span><span>  <span>$f2</span> <span>=</span> <span>:Fred</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>Three</span>
</span></span><span><span>  <span>def</span> <span>Fred</span><span>()</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span>  <span>$f3</span> <span>=</span> <span>:Fred</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>puts</span> <span>$f1</span><span>.</span><span>object_id</span>
</span></span><span><span><span>puts</span> <span>$f2</span><span>.</span><span>object_id</span>
</span></span><span><span><span>puts</span> <span>$f3</span><span>.</span><span>object_id</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div>

<p>Running this code shows:</p>
<pre tabindex="0"><code>18152204
18152204
18152204
</code></pre><p>All three symbols have the <strong>exact same object_id</strong>, proving they’re the same object in memory despite <code>Fred</code>
being a class, a constant, and a method in different contexts.</p>
<p>Does that mean all three symbols are the exact same object? At first glance, <code>:Fred</code> seems to be the thing that identifies
the class, variable or the method. But let’s expand our example to version 2, where each module has a method that uses
the symbol <code>:Fred</code> to interact with whatever <code>Fred</code> means in that context.</p>





  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>module</span> <span>One</span>
</span></span><span><span>  <span>class</span> <span>Fred</span>
</span></span><span><span>    <span>def</span> <span>greet</span>
</span></span><span><span>      <span>&#34;Hello from Fred the class!&#34;</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span>
</span></span><span><span>  <span>def</span> <span>self</span><span>.</span><span>use_fred_symbol</span>
</span></span><span><span>    <span># Use the symbol :Fred to get the class</span>
</span></span><span><span>    <span>klass</span> <span>=</span> <span>const_get</span><span>(</span><span>:Fred</span><span>)</span>
</span></span><span><span>    <span>instance</span> <span>=</span> <span>klass</span><span>.</span><span>new</span>
</span></span><span><span>    <span>puts</span> <span>&#34;In module One, using symbol :Fred to get the class&#34;</span>
</span></span><span><span>    <span>puts</span> <span>&#34;const_get(:Fred) returns: </span><span>#{</span><span>klass</span><span>.</span><span>class</span><span>}</span><span>&#34;</span>
</span></span><span><span>    <span>puts</span> <span>&#34;Creating instance: </span><span>#{</span><span>instance</span><span>.</span><span>greet</span><span>}</span><span>&#34;</span>
</span></span><span><span>    <span>:Fred</span>  <span># Return the symbol</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>Two</span>
</span></span><span><span>  <span>Fred</span> <span>=</span> <span>42</span>  <span># Fred is a constant</span>
</span></span><span><span>
</span></span><span><span>  <span>def</span> <span>self</span><span>.</span><span>use_fred_symbol</span>
</span></span><span><span>    <span># Use the symbol :Fred to get the constant</span>
</span></span><span><span>    <span>value</span> <span>=</span> <span>const_get</span><span>(</span><span>:Fred</span><span>)</span>
</span></span><span><span>    <span>result</span> <span>=</span> <span>value</span> <span>*</span> <span>2</span>
</span></span><span><span>    <span>puts</span> <span>&#34;In module Two, using symbol :Fred to get the constant&#34;</span>
</span></span><span><span>    <span>puts</span> <span>&#34;const_get(:Fred) returns: </span><span>#{</span><span>value</span><span>.</span><span>class</span><span>}</span><span> with value </span><span>#{</span><span>value</span><span>}</span><span>&#34;</span>
</span></span><span><span>    <span>puts</span> <span>&#34;Calculating </span><span>#{</span><span>value</span><span>}</span><span> * 2 = </span><span>#{</span><span>result</span><span>}</span><span>&#34;</span>
</span></span><span><span>    <span>:Fred</span>  <span># Return the symbol</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>Three</span>
</span></span><span><span>  <span>def</span> <span>self</span><span>.</span><span>Fred</span><span>()</span>  <span># Fred is a method</span>
</span></span><span><span>    <span>&#34;I&#39;m the Fred method!&#34;</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span>
</span></span><span><span>  <span>def</span> <span>self</span><span>.</span><span>use_fred_symbol</span>
</span></span><span><span>    <span># Use the symbol :Fred to call the method</span>
</span></span><span><span>    <span>result</span> <span>=</span> <span>send</span><span>(</span><span>:Fred</span><span>)</span>
</span></span><span><span>    <span>puts</span> <span>&#34;In module Three, using symbol :Fred to call the method&#34;</span>
</span></span><span><span>    <span>puts</span> <span>&#34;send(:Fred) returns: </span><span>#{</span><span>result</span><span>}</span><span>&#34;</span>
</span></span><span><span>    <span>:Fred</span>  <span># Return the symbol</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>puts</span> <span>&#34;=== Using the symbol :Fred in different contexts ===&#34;</span>
</span></span><span><span><span>puts</span>
</span></span><span><span><span>sym1</span> <span>=</span> <span>One</span><span>.</span><span>use_fred_symbol</span>
</span></span><span><span><span>puts</span> <span>&#34;Returned symbol object_id: </span><span>#{</span><span>sym1</span><span>.</span><span>object_id</span><span>}</span><span>&#34;</span>
</span></span><span><span><span>puts</span>
</span></span><span><span>
</span></span><span><span><span>sym2</span> <span>=</span> <span>Two</span><span>.</span><span>use_fred_symbol</span>
</span></span><span><span><span>puts</span> <span>&#34;Returned symbol object_id: </span><span>#{</span><span>sym2</span><span>.</span><span>object_id</span><span>}</span><span>&#34;</span>
</span></span><span><span><span>puts</span>
</span></span><span><span>
</span></span><span><span><span>sym3</span> <span>=</span> <span>Three</span><span>.</span><span>use_fred_symbol</span>
</span></span><span><span><span>puts</span> <span>&#34;Returned symbol object_id: </span><span>#{</span><span>sym3</span><span>.</span><span>object_id</span><span>}</span><span>&#34;</span>
</span></span><span><span><span>puts</span>
</span></span><span><span>
</span></span><span><span><span>puts</span> <span>&#34;=== The symbol :Fred is the same everywhere ===&#34;</span>
</span></span><span><span><span>puts</span> <span>&#34;All three object_ids match: </span><span>#{</span><span>sym1</span><span>.</span><span>object_id</span> <span>==</span> <span>sym2</span><span>.</span><span>object_id</span> <span>&amp;&amp;</span> <span>sym2</span><span>.</span><span>object_id</span> <span>==</span> <span>sym3</span><span>.</span><span>object_id</span><span>}</span><span>&#34;</span>
</span></span><span><span><span>puts</span> <span>&#34;sym1.equal?(sym2): </span><span>#{</span><span>sym1</span><span>.</span><span>equal?</span><span>(</span><span>sym2</span><span>)</span><span>}</span><span>&#34;</span>
</span></span><span><span><span>puts</span> <span>&#34;sym2.equal?(sym3): </span><span>#{</span><span>sym2</span><span>.</span><span>equal?</span><span>(</span><span>sym3</span><span>)</span><span>}</span><span>&#34;</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div>

<p>Running this shows:</p>
<pre tabindex="0"><code>=== Using the symbol :Fred in different contexts ===

In module One, using symbol :Fred to get the class
const_get(:Fred) returns: Class
Creating instance: Hello from Fred the class!
Returned symbol object_id: 18152204

In module Two, using symbol :Fred to get the constant
const_get(:Fred) returns: Integer with value 42
Calculating 42 * 2 = 84
Returned symbol object_id: 18152204

In module Three, using symbol :Fred to call the method
send(:Fred) returns: I&#39;m the Fred method!
Returned symbol object_id: 18152204

=== The symbol :Fred is the same everywhere ===
All three object_ids match: true
</code></pre><p>What is even going on here? <code>:Fred</code> has the same <code>object_id</code> but when we consume it, it calls different things.
I originally assumed <code>:Fred</code> was like atoms in Erlang, which I have a bare understanding of. But that doesn’t seem
to be the case.</p>
<p>To <em>reiterate</em> if you haven’t understood, <code>:Fred</code> is a <code>Symbol</code> object. It doesn’t <em>directly</em> reference the actual
method, class or variable that we are seeing in these code snippets, but it’s pointing to the name of these objects
itself. In a real-world setting, you could conceptualize <code>:Fred</code> as a name tag itself with “Fred” written on it.
In one situation, <code>Fred</code> could be the key in a dictionary that you could look up. In another it could be a name in a
contacts app, or a name in a class roster at university. The symbol <code>:Fred</code> is the word itself, not what it points to.</p>
<p>It’s Ruby’s way of turning identifiers into first-class objects. In <a href="https://tech.stonecharioteer.com/posts/2025/ruby-loops/">the loops post</a>,
I’ve written about <code>.send(:times)</code>. Ruby makes this possible <em>because</em> <code>:times</code> is the method name as an object.</p>
<p>In Python, you’d need to use strings for this purpose. There’s no sense of meaning in the string other than the context
that tells someone reading your code that you’re trying to get a method or attribute. And even that is a frail way of
expressing intent in my opinion.</p>
<table>
  <thead>
      <tr>
          <th>Python</th>
          <th>Ruby</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>getattr(obj, &#34;method_name&#34;)</code></td>
          <td><code>obj.send(:method_name)</code></td>
      </tr>
      <tr>
          <td><code>&#34;method_name&#34;</code> is a string - could be data or an identifier</td>
          <td><code>:method_name</code> is a symbol - explicitly an identifier</td>
      </tr>
  </tbody>
</table>
<p>I’ve written before about <a href="https://tech.stonecharioteer.com/posts/2025/ruby-loops/">Ruby’s preference for protocol over syntax</a>.
This falls perfectly in line with that.</p>
<p>I want to understand symbols a lot better though. What drove this design choice?</p>
<p>Smalltalk method names are symbols, message dispatch is a symbol-based lookup. That’s yet another thing Ruby inherited
from it. Lisp/Scheme have symbols as first-class citizens. All function names are symbols. Clojure has <code>:keyword</code> style
symbols just like Ruby. The dispatch mechanics are also very similar.</p>
<p>When I first started learning Ruby last month, I looked at the <code>:symbol</code> syntax and my brain immediately thought of
Erlang’s <strong>atoms.</strong> Erlang calls them <code>atom</code>, and Elixir (which runs on the Erlang VM) uses the more familiar <code>:atom</code>
syntax.</p>
<p>Erlang though, has atoms rooted even more deeply into its syntax. Consider the following Elixir code:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="elixir"><span><span>
</span></span><span><span><span># booleans are atoms</span>
</span></span><span><span><span>true</span> <span># actually :true</span>
</span></span><span><span><span>false</span> <span># actually :false</span>
</span></span><span><span>
</span></span><span><span><span># return valules are tagged with atoms</span>
</span></span><span><span><span>{</span><span>:ok</span><span>,</span> <span>result</span><span>}</span>
</span></span><span><span><span>{</span><span>:error</span><span>,</span> <span>result</span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># Pattern matching uses atoms as tags</span>
</span></span><span><span><span>case</span> <span>File</span><span>.</span><span>read</span><span>(</span><span>&#34;data.txt&#34;</span><span>)</span> <span>do</span>
</span></span><span><span>  <span>{</span><span>:ok</span><span>,</span> <span>contents</span><span>}</span> <span>-&gt;</span> <span>process</span><span>(</span><span>contents</span><span>)</span>
</span></span><span><span>  <span>{</span><span>:error</span><span>,</span> <span>reason</span><span>}</span> <span>-&gt;</span> <span>handle_error</span><span>(</span><span>reason</span><span>)</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span># module and function names are atoms</span>
</span></span><span><span>
</span></span><span><span><span>:lists</span><span>.</span><span>map</span><span>(</span><span>fn</span> <span>x</span> <span>-&gt;</span> <span>x</span> <span>*</span> <span>2</span> <span>end</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>])</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Erlang’s atoms are designed for its actor model. They are used to tag messages and data structures for pattern matching
in concurrent systems. Using <code>:ok</code> or <code>:error</code> isn’t just convention, it’s how Erlang allows communication between processes.</p>
<p>Ruby’s symbols are designed for metaprogramming. With symbols, identifiers become objects you can manipulate at runtime.
<code>send(:method_name)</code> or <code>define_method(:foo)</code> would not work without symbols as first-class citizens.</p>
<p>Interestingly, Both languages share a historical bug: creating symbols/atoms dynamically from user input could exhaust memory,
since the symbol/atom table was never garbage collected.
<a href="https://erlang.org/documentation/doc-5.8.4/doc/efficiency_guide/advanced.html">Erlang still warns about this in its efficiency guide</a>,
as atoms remain permanent for the VM’s lifetime. Ruby <a href="https://bugs.ruby-lang.org/issues/7791">fixed this in version 2.2</a>
by adding garbage collection for dynamically created symbols.</p>
<h2 id="symbols-in-ruby">Symbols in Ruby</h2>
<p>I think the first place you’d see symbols in Ruby are in hashmaps.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>user</span> <span>=</span> <span>{</span> <span>&#34;name&#34;</span> <span>=&gt;</span> <span>&#34;Alice&#34;</span><span>,</span> <span>&#34;age&#34;</span> <span>=&gt;</span> <span>30</span> <span>}</span>  <span># String keys</span>
</span></span><span><span><span>user</span> <span>=</span> <span>{</span> <span>:name</span> <span>=&gt;</span> <span>&#34;Alice&#34;</span><span>,</span> <span>:age</span> <span>=&gt;</span> <span>30</span> <span>}</span>    <span># Symbol keys</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>These are two ways to create hash objects with different key types. But when you’re writing software that
<em>indicates intent</em>, there’s a glaring difference between the two.</p>
<p><code>:name</code> is a stronger indication of what you want to do than <code>&#39;name&#39;</code>.</p>
<p>Modern ruby forgoes the arrow syntax to allow you to use symbols like this.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>user</span> <span>=</span> <span>{</span> <span>name</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span> <span>age</span><span>:</span> <span>30</span> <span>}</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>That uses symbols for <code>:name</code> and <code>:age</code> internally.</p>
<p>Symbols aren’t interchangeable though.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>user</span> <span>=</span> <span>{</span> <span>name</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span> <span>age</span><span>:</span> <span>30</span> <span>}</span>
</span></span><span><span><span>puts</span> <span>user</span><span>[</span><span>:name</span><span>]</span> <span># Alice</span>
</span></span><span><span><span>puts</span> <span>user</span><span>[</span><span>&#34;name&#34;</span><span>]</span> <span># nil</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>But where they’re really powerful is when you <em>reuse the keys</em>.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>1000</span><span>.</span><span>times</span> <span>{</span> <span>{</span> <span>&#34;name&#34;</span> <span>=&gt;</span> <span>&#34;Alice&#34;</span> <span>}</span> <span>}</span>  <span># Creates 1000 &#34;name&#34; strings</span>
</span></span><span><span><span>1000</span><span>.</span><span>times</span> <span>{</span> <span>{</span> <span>name</span><span>:</span> <span>&#34;Alice&#34;</span> <span>}</span> <span>}</span>      <span># Uses the same :name symbol</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Remember what I said about the symbol reusing the same memory space?
The second example uses only one instance of <code>:name</code>, while the first one
creates <code>&#34;name&#34;</code> 1000 times.</p>
<h3 id="metaprogramming-101">Metaprogramming 101</h3>
<p>Another example of how symbols empower Ruby is with the helper methods I use
within a class.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>class</span> <span>Person</span>
</span></span><span><span>  <span>attr_accessor</span> <span>:name</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>This is equivalent of writing:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>class</span> <span>Person</span>
</span></span><span><span>  <span>def</span> <span>name</span>
</span></span><span><span>    <span>@name</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span>
</span></span><span><span>  <span>def</span> <span>name</span><span>=</span><span>(</span><span>value</span><span>)</span>
</span></span><span><span>    <span>@name</span> <span>=</span> <span>value</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>In this example, Ruby uses the symbol <code>:name</code> to dynamically create getter and setter methods at runtime.</p>
<p><code>attr_accessor</code> is a class method that takes a symbol and uses metaprogramming to define methods.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>class</span> <span>Module</span>
</span></span><span><span>  <span>def</span> <span>attr_accessor</span><span>(</span><span>name</span><span>)</span> <span># name is a symbol here</span>
</span></span><span><span>    <span># define getter method</span>
</span></span><span><span>    <span>define_method</span><span>(</span><span>name</span><span>)</span> <span>do</span>
</span></span><span><span>      <span>instance_variable_get</span><span>(</span><span>&#34;@</span><span>#{</span><span>name</span><span>}</span><span>&#34;</span><span>)</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span># define setter method</span>
</span></span><span><span>    <span>define_method</span><span>(</span><span>&#34;</span><span>#{</span><span>name</span><span>}</span><span>=&#34;</span><span>)</span> <span>do</span> <span>|</span><span>value</span><span>|</span>
</span></span><span><span>      <span>instance_variable_set</span><span>(</span><span>&#34;@</span><span>#{</span><span>name</span><span>}</span><span>&#34;</span><span>,</span> <span>value</span><span>)</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>I’m hand-waving a lot of the details there, but this is a very clean example of
how powerful symbols are.</p>
<p>While it is easy to think of <code>attr_accessor</code> as special syntax, it <em>is just a method
that takes symbols</em> as arguments and writes code at runtime.</p>
<h3 id="fun-with-symbols">Fun with Symbols</h3>
<p>I felt I still didn’t understand the power of symbols over strings and accessing
attributes with them so I spun up <code>irb</code> and decided to write some Ruby.</p>
<h4 id="symbols-are-callable">Symbols are callable</h4>
<p>I’ve seen this before:</p>
<p>I didn’t think much of it, but now I understand that this calls <code>:to_s</code> on these
items. That’s cool, but what else can I use this way?</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>add_one</span> <span>=</span> <span>:+</span><span>.</span><span>to_proc</span>
</span></span><span><span><span>add_one</span><span>.</span><span>call</span><span>(</span><span>5</span><span>,</span><span>1</span><span>)</span> <span># 6</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>I knew that operators are methods, we can do <code>5.+(3)</code> instead of <code>5 + 3</code>, which is why this works. I understood that but seeing it like this… <em>is so <strong>cool!</strong></em></p>
<p>The <code>&amp;</code> operator calls <code>.to_proc</code> on the symbol, which returns a proc that calls the method: <code>{ |obj, arg| obj.send(:+, arg) }</code></p>
<p>Am I rambling? I’m certain I am, but let’s go on.</p>
<h4 id="can-i-chain-symbols">Can I chain symbols?</h4>
<p>I’ve done stuff like this:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>[</span><span>&#34;hello&#34;</span><span>,</span> <span>&#34;world&#34;</span><span>].</span><span>map</span><span>(</span><span>&amp;</span><span>:upcase</span><span>)</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:reverse</span><span>)</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>But we can also do this.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>[</span><span>&#34;hello&#34;</span><span>,</span> <span>&#34;world&#34;</span><span>].</span><span>map</span> <span>{</span> <span>|</span><span>s</span><span>|</span> <span>s</span><span>.</span><span>upcase</span><span>.</span><span>reverse</span> <span>}</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Then does that mean we can do this?</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span>
</span></span><span><span><span>users</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:name</span><span>)</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:upcase</span><span>)</span> <span># This works</span>
</span></span><span><span><span>users</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>u</span><span>|</span> <span>u</span><span>.</span><span>name</span><span>.</span><span>upcase</span> <span>}</span> <span># This is more efficient though</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>It’s always nice to ask ourselves if we <em>should</em>, just because we <em>could</em>.</p>
<h4 id="more-operator-foo">More Operator Foo</h4>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span>
</span></span><span><span><span>5</span><span>.</span><span>send</span><span>(</span><span>:+</span><span>,</span> <span>3</span><span>)</span>
</span></span><span><span><span>10</span><span>.</span><span>send</span><span>(</span><span>:*</span><span>,</span> <span>2</span><span>)</span>
</span></span><span><span><span>[</span><span>1</span><span>,</span><span>2</span><span>].</span><span>send</span><span>(</span><span>:&lt;&lt;</span><span>,</span> <span>3</span><span>)</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>But wait…</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span>operators</span> <span>=</span> <span>[</span><span>:+</span><span>,</span> <span>:-</span><span>,</span> <span>:*</span><span>,</span> <span>:/</span><span>]</span>
</span></span><span><span><span>operators</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>op</span><span>|</span> <span>10</span><span>.</span><span>send</span><span>(</span><span>op</span><span>,</span> <span>2</span><span>)}</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Well, if I see code like that in a PR, I’m going to call DHH personally. I don’t have his number though.</p>
<h4 id="wait-where-are-the-enums">Wait, where are the enums?</h4>
<p>I have been wondering, where are the Enums in Ruby? Rust loves Enums, and
any good python code needs to leverage it.</p>
<p>I think I’ve seen enums in Rails, and yes I know I haven’t touched that yet in my posts but I’m going to, soon.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span># without rails</span>
</span></span><span><span>
</span></span><span><span><span>status</span> <span>=</span> <span>:pending</span> <span># or :active, or :completed</span>
</span></span><span><span>
</span></span><span><span><span># In Rails</span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>User</span> <span>&lt;</span> <span>ApplicationRecord</span>
</span></span><span><span>  <span>enum</span> <span>status</span><span>:</span> <span>[</span><span>:pending</span><span>,</span> <span>:active</span><span>,</span> <span>:suspended</span><span>,</span> <span>:deleted</span><span>]</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>user</span><span>.</span><span>status</span> <span># :pending</span>
</span></span><span><span><span>user</span><span>.</span><span>pending?</span> <span># true</span>
</span></span><span><span><span>user</span><span>.</span><span>active!</span> <span># Changes status to active</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>I just had to check the <a href="https://api.rubyonrails.org/v7.2.2/classes/ActiveRecord/Enum.html">Rails source code to see if it was actually a new
type or…</a></p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ruby"><span><span><span># File activerecord/lib/active_record/enum.rb, line 216</span>
</span></span><span><span><span>def</span> <span>enum</span><span>(</span><span>name</span> <span>=</span> <span>nil</span><span>,</span> <span>values</span> <span>=</span> <span>nil</span><span>,</span> <span>**</span><span>options</span><span>)</span>
</span></span><span><span>  <span>if</span> <span>name</span>
</span></span><span><span>    <span>values</span><span>,</span> <span>options</span> <span>=</span> <span>options</span><span>,</span> <span>{}</span> <span>unless</span> <span>values</span>
</span></span><span><span>    <span>return</span> <span>_enum</span><span>(</span><span>name</span><span>,</span> <span>values</span><span>,</span> <span>**</span><span>options</span><span>)</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span>
</span></span><span><span>  <span>definitions</span> <span>=</span> <span>options</span><span>.</span><span>slice!</span><span>(</span><span>:_prefix</span><span>,</span> <span>:_suffix</span><span>,</span> <span>:_scopes</span><span>,</span> <span>:_default</span><span>,</span> <span>:_instance_methods</span><span>)</span>
</span></span><span><span>  <span>options</span><span>.</span><span>transform_keys!</span> <span>{</span> <span>|</span><span>key</span><span>|</span> <span>:&#34;</span><span>#{</span><span>key</span><span>[</span><span>1</span><span>..-</span><span>1</span><span>]</span><span>}</span><span>&#34;</span> <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>definitions</span><span>.</span><span>each</span> <span>{</span> <span>|</span><span>name</span><span>,</span> <span>values</span><span>|</span> <span>_enum</span><span>(</span><span>name</span><span>,</span> <span>values</span><span>,</span> <span>**</span><span>options</span><span>)</span> <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>ActiveRecord</span><span>.</span><span>deprecator</span><span>.</span><span>warn</span><span>(</span><span>&lt;&lt;~</span><span>MSG</span><span>)</span>
</span></span><span><span>    <span>Defining</span> <span>enums</span> <span>with</span> <span>keyword</span> <span>arguments</span> <span>is</span> <span>deprecated</span> <span>and</span> <span>will</span> <span>be</span> <span>removed</span>
</span></span><span><span>    <span>in</span> <span>Rails</span> <span>8</span><span>.</span><span>0</span><span>.</span> <span>Positional</span> <span>arguments</span> <span>should</span> <span>be</span> <span>used</span> <span>instead</span><span>:</span>
</span></span><span><span>
</span></span><span><span>    <span>#{definitions.map { |name, values| &#34;enum :#{name}, #{values}&#34; }.join(&#34;\n&#34;)}</span>
</span></span><span><span>  <span>MSG</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Dang it, Ruby. You never cease to amaze me!</p>
<p>That’s a <em>method!</em> This is so cool. I was just thinking how cool
it would be to define an Enum in ruby so that I could give it a list of accepted
values as symbols and it would then say something is not a valid option, and
this exists. So cool!</p>
<h2 id="symbols-and-what-they-mean">Symbols and what they mean</h2>
<p>You don’t have to be Robert Langdon to appreciate symbols in Ruby. I could spend
so much more time on them, writing about <code>Symbols.all_symbols</code> (Ruby’s internal symbol table), method introspection (with <code>method()</code>, <code>.respond_to?</code>), and runtime reflection. I am sure I’ll have more to say about symbols in the future, once I start writing about metaprogramming. Can you tell I’m excited about that post already?</p>
<hr/>
<h2 id="other-posts-in-this-series">Other Posts in This Series</h2>
<ul>
<li><a href="https://tech.stonecharioteer.com/posts/2025/ruby/">Ruby</a></li>
<li><a href="https://tech.stonecharioteer.com/posts/2025/ruby-block-return/">Returning from Ruby Blocks, Procs and Lambdas</a></li>
<li><a href="https://tech.stonecharioteer.com/posts/2025/ruby-blocks/">Ruby Blocks</a></li>
<li><a href="https://tech.stonecharioteer.com/posts/2025/ruby-loops/">Some Smalltalk about Ruby Loops</a></li>
</ul>


  </div></div>
  </body>
</html>
