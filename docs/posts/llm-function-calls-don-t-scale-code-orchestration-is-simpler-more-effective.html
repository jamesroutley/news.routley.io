<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jngiam.bearblog.dev/mcp-large-data/">Original</a>
    <h1>LLM function calls don&#39;t scale; code orchestration is simpler, more effective</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-05-20T15:25Z">
                    20 May, 2025
                </time>
            </i>
        </p>
    

    <p><em>TL;DR: Giving LLMs the full output of tool calls is costly and slow. Output schemas will enable us to get structured data, so we can let the LLM orchestrate processing with generated code. Tool calling in code is simplifying and effective.</em></p>
<hr/>
<p>One common practice for working with MCP tools calls is to put the outputs from a tool back into the LLM as a message, and ask the LLM for the next step. The hope here is that the model figures out how to interpret the data, and identify the correct next action to take.</p>
<p>This can work beautifully when the amount of data is small, but we found that when we tried MCP servers with real-world data, it quickly breaks down.</p>
<h3 id="mcp-in-the-real-world">MCP in the real-world</h3><p>We use Linear and Intercom at our company. We connected to their latest official MCP servers released last week to understand how they were returning tool calls.</p>
<p>It turns out that both servers returned large JSON blobs in their text content. These appeared to be similar to their APIs, with the exception that the text content did not come with any pre-defined schemas. This meant that the only reasonable way to parse them was to have the LLM interpret the data.</p>
<p><img src="https://storage.googleapis.com/lutra-2407-public/42067e56d7b5238d3d7432718f1224679a1a449711a2e406295a3aeb98108e63.png" alt="Linear MCP returns list of issues as a big JSON blob"/></p>
<p>These JSON blobs are huge! When we asked Linear&#39;s MCP to list issues in our project, the tool call defaulted to returning only 50 issues, ~70k characters corresponding to ~25k tokens.</p>
<p><img src="https://storage.googleapis.com/lutra-2407-public/dda9436e83214ae28c73b19ca4fdc43d81f5c1613a45ada3160dc4aaa048f07d.png" alt="ID fields become lots of tokens"/></p>
<p>The JSON contains lots of <code>id</code> fields that take up many tokens, and are not semantically meaningful.</p>
<p>When using Claude with MCPs, it seems that the entire JSON blob gets sent back to the model verbatim.</p>
<p>This approach quickly runs into issues. For example, if we wanted to get the AI to sort all the issues by due date and display them, it would need to reproduce all the issues verbatim as output tokens! It&#39;d be slow, costly, and could potentially miss data.</p>
<p>The data in our issues also often contained a lot of distracting information: steps to reproduce an issue, errors, maybe even prompts a user used, or instructions to follow up with a user. The model could fail to emit some of these data accurately, or even worse, deviate from the original instructions.</p>
<h3 id="data-vs-orchestration">Data vs Orchestration</h3><p>The core problem here is that we&#39;re confounding orchestration and data processing together in the same chat thread.</p>
<p>The &#34;multi-agent&#34; approach tries to address this by spinning up another chat thread (&#34;agent&#34;) to focus only on the data processing piece. It performs better when carefully tuned, but it&#39;s still awkward when our data is already well structured.</p>
<p>If the MCP servers are already returning data in a JSON format, it seems much more natural to parse the data, and instead operate on the structured data. Back to our sorting example, rather than asking the LLM to reproduce the outputs directly, we could instead run a <code>sort</code> operation on the data, and return the new array. No hallucinations and this scales to any size of inputs.</p>
<h3 id="code-execution-as-data-processing">Code execution as data processing</h3><p>This sounds oddly familiar as we already have code interpreters with AI. When we start to bring code execution as a fundamental way to process data from MCP tools (<a href="https://machinelearning.apple.com/research/codeact">Code Act</a>, <a href="https://huggingface.co/blog/smolagents">Smol Agents</a>), this opens the door to scalable ways for AI models to work.</p>
<p><strong>Variables as memory.</strong> Instead of having an external memory system, the LLM can use variables (system memory) to store any data. Storing a memory is assigning a value to a variable, peeking at the variable is printing it, and the model can choose to pass the variable as an argument when calling another function. Even better, if the language used is well-typed, the model also leverages the schema.</p>
<p><strong>Tool chaining.</strong> Code can orchestrate multiple function calls: performing them in parallel or taking the outputs from one or more calls and using them as inputs into another. The dependencies between the function calls are implicitly represented via the computation graph the code represents. Importantly, the LLM is not required to regurgitate the data, and we have guarantees of completeness.</p>
<p><strong>Scalable processing.</strong> Transforming large amounts of data is naturally possible with code. The model can choose to use loops, or lean on libraries such as NumPy or pandas for large data transformations.</p>
<p>Code can also call other LLMs under the hood: you can have the LLM write code that calls LLMs for unstructured data processing (LLM-inception).</p>
<h3 id="is-mcp-ready">Is MCP ready?</h3><p>MCP specs already define input schemas, and theyâ€™ve just introduced  <a href="https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371">output schemas</a>.</p>
<p>Once output schemas are widespread, we expect them to unlock use cases on large datasets: building custom dashboards, creating weekly reports on tickets completed, or having the autonomous agents monitor and nudge stalled issues forward.</p>
<h3 id="what-makes-code-execution-hard">What makes code execution hard?</h3><p>The challenge now shifts to the MCP client side. Most execution environments today run in a tightly controlled sandbox; security is paramount as we&#39;re dealing with user-/AI-generated code.</p>
<p>Allowing an execution environment to also access MCPs, tools, and user data requires careful design to where API keys are stored, and how tools are exposed.</p>
<p>In our designs, we created sandboxed environments that are keyed with specific API access, the models are provided with documentation on how to call these APIs such that they are able send/retrieve information without ever seeing secrets.</p>
<p>Most execution environments are stateful (e.g., they may rely on running Jupyter kernels for each user session). This is hard to manage and expensive if users expect to be able to come back to AI task sessions later. A stateless-but-persistent execution environment is paramount for long running (multi-day) task sessions.</p>
<p>These constraints are creating what we think is a new category of runtimes - &#34;AI runtimes&#34; that use LLMs to orchestrate and perform tasks. We&#39;re still in the early phases of working out all the details for this code-execution approach, and we&#39;d love feedback from anyone tackling similar problems. If you&#39;re interested in our approach, you can head to <a href="https://lutra.ai">Lutra</a> to give it a try.</p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
