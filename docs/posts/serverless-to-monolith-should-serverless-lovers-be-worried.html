<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://beabetterdev.com/2023/05/20/serverless-to-monolith-should-serverless-lovers-be-worried/">Original</a>
    <h1>Serverless to monolith – Should serverless lovers be worried?</h1>
    
    <div id="readability-page-1" class="page"><div><p>Amazon’s Prime Video Tech blog recently released <a href="https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90">an article</a> that has gotten some internet attention. The article examines a team that was able to reduce their infrastructure cost by up to 90% by moving from a serverless to “monolithic” architecture.</p><p>It’s not every day you hear about moving from Serverless <strong>to</strong> Monolith. So rightfully, this article has gotten quite a few second glances. Some of the takes though are dubious at best claiming “See, even Amazon is saying serverless sucks!”.</p><p>That’s…. not what they’re saying it all, and shouldn’t be your main takeaway. So let’s dig into this article and understand why its making such a fuss.</p><p>In this post, we’ll examine:</p><ol><li>The problem the team was trying to solve &amp; the initial serverless based approach</li><li>The second iteration that adopted a “monolith” architecture.</li><li>Why going from serverless to “monolith” in this case was the right move</li></ol><p>Notice I’m putting monolith in quotes here. More on that in part 3.</p><p>If you prefer a video format, check out my YouTube channel on this topic here:</p><figure><div><p><iframe title="How and Why Prime Video Tech Switched From Serverless to &#34;Monolith&#34;" width="1200" height="675" src="https://www.youtube.com/embed/xflakXiwkD0?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></p></div></figure><h2 id="the-problem">The Problem</h2><p>For some background, Prime Video is a real time streaming service that offers over 100 channels to watch for Amazon Prime subscribers. The Prime Video Quality and Analysis team wanted to ensure that video streams being served to customers are high quality and free from any video or audio hiccups such as video artifacts (pixelation), audio-video sync issues, and others. The team wanted to develop a mechanism to continuously monitor each stream in the service to automatically evaluate and detect any quality issues.</p><p>Initially, the team decided to leverage a previously developed <strong>diagnostic tool</strong>. This tool primarily leveraged AWS Step Functions, Lambda, and S3 to break apart each stream’s audio/video content into 1 second chunks so they can be more easily managed and evaluated for anomalies.</p><p>This tool worked by running continuously against each channel/stream and evaluating it in one second segments. For every segment, a Step Function Workflow was launched. The step function workflow had multiple state transitions which performed extraction, analysis and aggregation steps before saving the results to S3.</p><p>For those of you that have worked with Step Functions in the past, you may know that it can get <strong>very</strong> <strong>expensive</strong>. The main cost contributor is state transitions. That is, each time your step function moves from one state to another, you’re charged a certain amount.</p><p>In Prime Video’s case, a Step Function was being launched <strong>every one second</strong> <strong>for every single stream</strong>. This Step Function contained multiple different state transitions to perform its tasks. Ontop of that, intermediary frames and audio buffers were being converted and stored in S3, requiring Lambdas within the step function to continuously make network calls into S3 to grab the relevant data.</p><p>There were two main issues with this architecture: cost and scalability.</p><p>On the cost side, the number of state transitions and network calls made this architecture infeasible to maintain. Based on my conservative napkin math assessment, the Step Functions cost alone would amount to over $4000 USD per month. Note that this assessment was <em>very</em> conservative due to the lack of detail in the article and the cost was likely much more. This doesn’t even factor in the read and write costs to S3 which would have amplified this number even more.</p><p>On the scalability side, Step Functions have two important limits: 1) the number of concurrently running step function workflows, and 2) the number of state transitions per second across all of your state machines. These two limits in combination made it impossible for the solution to scale to the 100+ streams it needed to constantly evaluate. The Prime Video team very quickly hit the maximum concurrency limit and only ended up being able handle <strong>5% of the expected load</strong>. Pretty sad.</p><p>The diagram below is from the Prime Video article and provides an overview of the architecture and the multiple steps involved in processing a single stream.</p><div><figure><img decoding="async" loading="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAP+KeNJXAAAAAXRSTlMAQObYZgAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII=" alt="" width="556" height="441" data-pk-sizes="auto" data-ls-sizes="(max-width: 556px) 100vw, 556px" data-pk-src="https://www.beabetterdev.com/wp-content/uploads/2023/05/image-1024x813.png" data-pk-srcset="https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?resize=1024%2C813&amp;ssl=1 1024w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?resize=300%2C238&amp;ssl=1 300w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?resize=768%2C610&amp;ssl=1 768w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?resize=1536%2C1220&amp;ssl=1 1536w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?resize=380%2C302&amp;ssl=1 380w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?resize=800%2C635&amp;ssl=1 800w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?resize=1160%2C921&amp;ssl=1 1160w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image.png?w=2022&amp;ssl=1 2022w"/><figcaption><em>Initial Prime Video architecture leveraging Step Functions for orchestration, S3 for compute, and S3 for intermediary data storage. The result was…. expensive. </em></figcaption></figure></div><p>Given these cost and scaling bottlenecks, the team re-evaluated their architecture for something a bit simpler that would optimize for cost &amp; scale by shying away from distributed workload components. Let’s examine that now.</p><h2 id="second-iteration-designing-for-scale">Second Iteration – Designing For Scale</h2><p>After careful evaluation, the VQA team realized that Step Functions weren’t a good fit for this problem at this particular scale. They decided to opt for a simpler solution that relied on provisioned infrastructure using <a href="https://www.beabetterdev.com/2021/08/22/aws-elastic-container-service-ecs-overview/">Elastic Container Service (ECS)</a> as the compute tier.</p><p>For intermerdiary storage, S3 was also nixed due to the high cost of making multiple hops (both read and write) to the service. Again, this wasn’t adding much to the overall architecture.</p><p>The solution involved running chunk extraction and analysis locally within an ECS task. This way, instead of relying on a Step Function to orchestrate the tasks via a workflow, it was done serially from within a specific ECS task.</p><p>The task would first perform the media conversion, and then analyze each 1s chunk by running the content through multiple detectors for quality analysis. Each detector is kind of unique in that it uses a different method to analyze quality issues with the stream.</p><p>With this architecture, intermediary data no longer needed to be stored in S3 and fetched at a particular point in the workflow. It was all being stored locally in memory on the ECS task and used/discarded as needed. This, ontop of moving away from Step Functions really helped drive down the costs of running the service.</p><p>Finally, after the detectors performed their task on a chunk of content, results for each detector were aggregated in the ECS task and saved to S3 using one write operation.</p><p>A diagram of the revised architecture can be seen below:</p><div><figure><img decoding="async" loading="lazy" width="1024" height="640" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAKAAQMAAAA4s5giAAAAA1BMVEUAAP+KeNJXAAAAAXRSTlMAQObYZgAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAGZJREFUeNrtwQEBAAAAgiD/r25IQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7wZCjwABDPVGjAAAAABJRU5ErkJggg==" alt="" data-pk-sizes="auto" data-ls-sizes="(max-width: 1024px) 100vw, 1024px" data-pk-src="https://www.beabetterdev.com/wp-content/uploads/2023/05/image-1-1024x640.png" data-pk-srcset="https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=1024%2C640&amp;ssl=1 1024w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=300%2C187&amp;ssl=1 300w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=768%2C480&amp;ssl=1 768w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=1536%2C960&amp;ssl=1 1536w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=2048%2C1280&amp;ssl=1 2048w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=380%2C237&amp;ssl=1 380w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=800%2C500&amp;ssl=1 800w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?resize=1160%2C725&amp;ssl=1 1160w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-1.png?w=2516&amp;ssl=1 2516w, https://i0.wp.com/beabetterdev.com/wp-content/uploads/2023/05/image-1.png?w=2400&amp;ssl=1 2400w"/><figcaption><em>A second iteration relying on ECS Tasks to run the compute. </em></figcaption></figure></div><p>A keen observer may notice that this architecture carries a scaling bottleneck with the <strong>detectors</strong> component. Imagine that the PV team wants to leverage some new method to detect audio/video degradation. In this architecture, that would mean adding one more detector and serially running it (in addition to the other ones) for each chunk of content.</p><p>If there are too many detectors to be run for a single task, the duration it takes to run the content through the multiple detectors will increase. If too many are added and the <strong>sum of operations across the detectors</strong> exceeds 1 second (the chunk parsing rate), the entire workflow will begin falling behind and not be able to recover.</p><p>In the Prime Video case, there really <em>was</em> a need for multiple detectors but falling behind on processing wasn’t an option. To mitigate this, the team decided to paramaterize each ECS task so that each one was dedicated to running a handful of the detectors. Then, the team could launch multiple ECS tasks in parallel with each task only executing a couple of the detectors. This allowed them to horizontally scale by breaking apart the workload into separate units and run them concurrently.</p><p>The revised architecture looked like this:</p><div><figure><img decoding="async" loading="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAP+KeNJXAAAAAXRSTlMAQObYZgAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII=" alt="" width="556" height="617" data-pk-sizes="auto" data-ls-sizes="(max-width: 556px) 100vw, 556px" data-pk-src="https://www.beabetterdev.com/wp-content/uploads/2023/05/image-2-922x1024.png" data-pk-srcset="https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?resize=922%2C1024&amp;ssl=1 922w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?resize=270%2C300&amp;ssl=1 270w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?resize=768%2C853&amp;ssl=1 768w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?resize=1383%2C1536&amp;ssl=1 1383w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?resize=380%2C422&amp;ssl=1 380w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?resize=800%2C888&amp;ssl=1 800w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?resize=1160%2C1288&amp;ssl=1 1160w, https://i0.wp.com/www.beabetterdev.com/wp-content/uploads/2023/05/image-2.png?w=1450&amp;ssl=1 1450w"/><figcaption><em>Extending the solution to add detector parallelization for increased scale</em></figcaption></figure></div><p>By using this revised architecture, the PV team now had a scalable and cost effective solution to monitor their feeds. All in all, they were able to save 90% of their costs when compared with the initial serverless iteration.</p><p>So that’s the story that took the internet by storm. But why is everyone freaking out? Is this move from serverless to monolith a new trend of the industry? Should serverless lovers be worried? I say no, for reasons laid out in the next section.</p><h2 id="why-going-from-serverless-to-monolith-was-the-right-move">Why Going From Serverless to “Monolith” Was The Right Move</h2><p>First things first, this architecture <strong>is not</strong> a monolith and this is part of the reason the internet is angry. When I think of a monolith, I think of a giant service that has many different responsibilities. Maybe it has APIs, SQS pollers, does multiple things for different use cases, you get the picture. But is the architecture laid out above a monolith? Hardly. It’s a small microservice for heaven’s sake! So right off the bat, the whole fuss folks are making about monoliths coming back into style is a moot point.</p><p>Secondly, the original architecture was based on a <strong>tool</strong> that was not designed for scale. Based on the article, it read as if this tool was used for diagnostics to perform ad-hoc assessments of stream quality. This means it likely wasn’t designed for scale or put through the pressure tests of a formal design document / review. If that were to happen, any run of the mill Software Engineer would have been able to recognize the obvious scaling / cost bottlenecks that would be encountered.</p><p>Finally, I think the PV team made all the right moves by switching to provisioned infratructure. They identified an existing tool that could have been a potential solution. They attempted to leverage it before realizing it had some real scaling / cost bottlenecks. After assessing the situation, they pivoted and re-designed for a more robust solution that happened to use provisioned infrastructure. <strong>This is what the software development process is all about</strong>.</p><p>In terms of the whole Serverless vs Monolith/Microservice debate — why are we still having this argument in 2023? Serverless isn’t a catch-all that is ideal for every single problem, and the same applies for monoliths or provisioned infrastructure. Both have a place and its up to us to pick the right tool for the job.</p><p>If you’re a developer building modern cloud based applications, remember to carefully analyze the characteristics of your workload and decide on an infrastructure that best fits. Don’t get pigeon holed into using a particular infrastructure or technique just because its popular – pick what makes sense and is applicable for your use case.</p><p>So that’s my rant. I’m eager to hear what other folks think of the article and the internet debate that ensued. Let me know what you think in the comments below.</p><ol><li></li></ol></div></div>
  </body>
</html>
