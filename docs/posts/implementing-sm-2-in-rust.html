<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://borretti.me/article/implementing-sm2-in-rust">Original</a>
    <h1>Implementing SM-2 in Rust</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>I’ve been on a <a href="https://borretti.me/article/effective-spaced-repetition">spaced repetition</a> (SR) kick as of late. <a href="https://mochi.cards/">Mochi</a>, the SR software I use, uses a modified version of the <a href="https://en.wikipedia.org/wiki/SuperMemo">SuperMemo</a> <a href="https://super-memory.com/english/ol/sm2.htm">SM-2</a> algorithm to schedule cards. The differences are:</p>

<ol>
  <li>The ease factor (EF) of the cards is not adjusted in response to performance, but can be changed manually. The justification is this avoids a purported problem with SM-2 called <a href="https://web.archive.org/web/20201127173107/https://massimmersionapproach.com/table-of-contents/anki/low-key-anki/the-ease-factor-problem/">“ease hell”</a>.</li>
  <li>When you fail a card, the interval to the next review is not reset but <em>halved</em>.</li>
</ol>

<p>The interval halving I dislike, because sometimes I’ll remember a card for the first couple months, then forget it, and enter this weird limbo state where the reviews are not frequent enough for me to re-learn the card, so I start alternately recalling it and failing it.</p>

<p>But I didn’t understand the implications of the change to the ease factor. So I decided to look into the algorithm. And, since what I do not create, I do not understand, I wrote a simple implementation of it in Rust.</p>

<p>Without further ado, the code is <a href="https://github.com/eudoxia0/sm2">here</a>. What follows is an explanation.</p>



<p>Why do we need an algorithm? We could drill every card every day, but this would be a living nightmare, and you could not have more than ~200 flashcards. The scheduler acts as a simple, quantitative model of human memory. The better the model, the more we can commit to long-term memory, and the less time we have to spend studying.</p>

<p>An <strong>item</strong> is an atomic piece of knowledge, represented as a flashcard: a question-answer pair that tests the existence of that knowledge. An item’s state is represented by:</p>

<ol>
  <li>The <strong>easing factor</strong> $EF$, which is the dual of difficulty. This is a real number in the range $[1.3, +\infty]$. The initial value is $2.5$.</li>
  <li>The number of <strong>repetitions</strong> $n$, which is the number of times the card has been recalled correctly in a row.</li>
</ol>

<p>From a card’s state, we can calculate its <strong>interval</strong>: the number of days after the most recent test when the item should be reviewed again. The interval calculation is defined by a recurrence relation on the number of repetitions:</p>

\[\begin{align*}
I(0) &amp;= 0 \\
I(1) &amp;= 1 \\
I(2) &amp;= 6 \\
I(n) &amp;= I(n-1) \times \text{EF}
\end{align*}\]

<p>The closed-form expression is:</p>

\[I(n) = 6 \times \text{EF}^{(n-2)}\]

<p>As a function of correct repetitions and EF:</p>

<p><img src="https://borretti.me/assets/content/implementing-sm2-in-rust/interval.png" alt="A plot of showing how an item&#39;s interval evolves as a function of the number of correct repetitions, for different values of EF. Higher EF values grow faster."/></p>

<p>To test an item, the user is shown the question, then they mentally recall the answer, and reveal the actual answer. Then the user rates their performance by selecting the <strong>quality</strong> of their response from this list:</p>

<ul>
  <li>0 = Blackout. No recall.</li>
  <li>1 = Incorrect response; but the answer, once revealed, was remembered.</li>
  <li>2 = Incorrect response; but the answer seemed easy to recall.</li>
  <li>3 = Recalled with difficulty.</li>
  <li>4 = Recalled with hesitation.</li>
  <li>5 = Recalled perfectly.</li>
</ul>

<p>Quality values in $[0,2]$ represent <strong>forgetting</strong>.</p>

<p>When an item is tested, and we have a quality, the item’s state has to be updated.</p>

<p>If the user forgot the answer, the repetition count is set to zero. This means the interval, too, is reset: you have to relearn the card from scratch.</p>

\[n&#39;(n, q) = \begin{cases}
0   &amp; q \in [0,2] \\
n+1 &amp; \text{otherwise}
\end{cases}\]

<p>The EF is updated by adding a magnitude proportional to the response quality:</p>

\[\text{EF}&#39;(\text{EF}, q) = min(1.3, \text{EF} + f(q))\]

<p>Where:</p>

\[f(q) = -0.8 + 0.28q - 0.02*q^2\]

<p>Qualitatively, $f(q)$ looks like this:</p>

<p><img src="https://borretti.me/assets/content/implementing-sm2-in-rust/ef.png" alt="A plot showing the magnitude of change to the EF as a function of quality. At q&lt;4, the magnitude is negative, but a minimum change of -0.8 at q=0. At q=4, the magnitude is zero. At q=5, the magnitude is 0.1."/></p>

<p>So for anything less than perfect recall the EF decreases (and so the next interval is shorter), and only perfect recall makes a card less difficult.  At $q=4$ nothing changes.</p>

<p>And so we get ease hell: it is much easier to push EF down, or keep it the same, than to push it up.</p>

<p>The final piece of the algorithm is that, at the end of a review session, all items with quality in $[0, 3]$ should be tested again until all of them have a recall quality in $[4,5]$.</p>



<p>Scalar types:</p>

<div><div><pre><code><span>pub</span> <span>type</span> <span>Repetitions</span> <span>=</span> <span>u32</span><span>;</span>
<span>pub</span> <span>type</span> <span>Ease</span> <span>=</span> <span>f32</span><span>;</span>
<span>pub</span> <span>type</span> <span>Interval</span> <span>=</span> <span>u32</span><span>;</span>
</code></pre></div></div>

<p>Normally I would use newtypes with smart constructors to represent types with ranges (e.g. EF has a minimum value of 1.3). But this would make the code uglier, so instead I just wrote:</p>

<div><div><pre><code><span>pub</span> <span>const</span> <span>INITIAL_EF</span><span>:</span> <span>Ease</span> <span>=</span> <span>2.5</span><span>;</span>
<span>const</span> <span>MIN_EF</span><span>:</span> <span>Ease</span> <span>=</span> <span>1.3</span><span>;</span>

<span>fn</span> <span>min</span><span>(</span><span>ef</span><span>:</span> <span>Ease</span><span>)</span> <span>-&gt;</span> <span>Ease</span> <span>{</span>
    <span>if</span> <span>ef</span> <span>&lt;</span> <span>MIN_EF</span> <span>{</span>
        <span>MIN_EF</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>ef</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Quality is naturally represented as an enum:</p>

<div><div><pre><code><span>#[derive(Debug,</span> <span>Copy,</span> <span>Clone,</span> <span>PartialEq)]</span>
<span>pub</span> <span>enum</span> <span>Quality</span> <span>{</span>
    <span>/// Complete blackout.</span>
    <span>Blackout</span> <span>=</span> <span>0</span><span>,</span>
    <span>/// Incorrect response; the correct one remembered.</span>
    <span>Incorrect</span> <span>=</span> <span>1</span><span>,</span>
    <span>/// Incorrect response; where the correct one seemed easy to recall.</span>
    <span>IncorrectEasy</span> <span>=</span> <span>2</span><span>,</span>
    <span>/// Correct response recalled with serious difficulty.</span>
    <span>Hard</span> <span>=</span> <span>3</span><span>,</span>
    <span>/// Correct response after a hesitation.</span>
    <span>Good</span> <span>=</span> <span>4</span><span>,</span>
    <span>/// Perfect response.</span>
    <span>Perfect</span> <span>=</span> <span>5</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>With two predicates, to test whether this quality value implies the forgetting, and whether the item needs to be repeated at the end of the session:</p>

<div><div><pre><code><span>impl</span> <span>Quality</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>forgot</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>bool</span> <span>{</span>
        <span>match</span> <span>self</span> <span>{</span>
            <span>Self</span><span>::</span><span>Blackout</span>
            <span>|</span> <span>Self</span><span>::</span><span>Incorrect</span>
            <span>|</span> <span>Self</span><span>::</span><span>IncorrectEasy</span> <span>=&gt;</span> <span>true</span><span>,</span>
            <span>Self</span><span>::</span><span>Hard</span> <span>|</span> <span>Self</span><span>::</span><span>Good</span> <span>|</span> <span>Self</span><span>::</span><span>Perfect</span> <span>=&gt;</span> <span>{</span>
                <span>false</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>repeat</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>bool</span> <span>{</span>
        <span>match</span> <span>self</span> <span>{</span>
            <span>Self</span><span>::</span><span>Blackout</span>
            <span>|</span> <span>Self</span><span>::</span><span>Incorrect</span>
            <span>|</span> <span>Self</span><span>::</span><span>IncorrectEasy</span>
            <span>|</span> <span>Self</span><span>::</span><span>Hard</span> <span>=&gt;</span> <span>true</span><span>,</span>
            <span>Self</span><span>::</span><span>Good</span> <span>|</span> <span>Self</span><span>::</span><span>Perfect</span> <span>=&gt;</span> <span>false</span><span>,</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>An item’s state is just its values of $n$ and $\text{EF}$ (exact due date timestamps would be implemented outside the system):</p>

<div><div><pre><code><span>pub</span> <span>struct</span> <span>Item</span> <span>{</span>
    <span>n</span><span>:</span> <span>Repetitions</span><span>,</span>
    <span>ef</span><span>:</span> <span>Ease</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>Given an item, we can calculate its interval:</p>

<div><div><pre><code><span>impl</span> <span>Item</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>interval</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Interval</span> <span>{</span>
        <span>let</span> <span>r</span> <span>=</span> <span>self</span><span>.n</span><span>;</span>
        <span>let</span> <span>ef</span> <span>=</span> <span>self</span><span>.ef</span><span>;</span>
        <span>match</span> <span>self</span><span>.n</span> <span>{</span>
            <span>0</span> <span>=&gt;</span> <span>0</span><span>,</span>
            <span>1</span> <span>=&gt;</span> <span>1</span><span>,</span>
            <span>2</span> <span>=&gt;</span> <span>6</span><span>,</span>
            <span>_</span> <span>=&gt;</span> <span>{</span>
                <span>let</span> <span>r</span> <span>=</span> <span>r</span> <span>as</span> <span>f32</span><span>;</span>
                <span>let</span> <span>i</span> <span>=</span> <span>6.0</span> <span>*</span> <span>ef</span><span>.powf</span><span>(</span><span>r</span> <span>-</span> <span>2.0</span><span>);</span>
                <span>let</span> <span>i</span> <span>=</span> <span>i</span><span>.ceil</span><span>();</span>
                <span>i</span> <span>as</span> <span>u32</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>Item::review</code> method consumes an item and, given a quality rating, updates its state:</p>

<div><div><pre><code><span>impl</span> <span>Item</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>review</span><span>(</span><span>self</span><span>,</span> <span>q</span><span>:</span> <span>Quality</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Self</span> <span>{</span>
            <span>n</span><span>:</span> <span>np</span><span>(</span><span>self</span><span>.n</span><span>,</span> <span>q</span><span>),</span>
            <span>ef</span><span>:</span> <span>efp</span><span>(</span><span>self</span><span>.ef</span><span>,</span> <span>q</span><span>),</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Where:</p>

<div><div><pre><code><span>fn</span> <span>np</span><span>(</span><span>n</span><span>:</span> <span>Repetitions</span><span>,</span> <span>q</span><span>:</span> <span>Quality</span><span>)</span> <span>-&gt;</span> <span>Repetitions</span> <span>{</span>
    <span>if</span> <span>q</span><span>.forgot</span><span>()</span> <span>{</span>
        <span>0</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>n</span> <span>+</span> <span>1</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>efp</span><span>(</span><span>ef</span><span>:</span> <span>Ease</span><span>,</span> <span>q</span><span>:</span> <span>Quality</span><span>)</span> <span>-&gt;</span> <span>Ease</span> <span>{</span>
    <span>let</span> <span>ef</span> <span>=</span> <span>min</span><span>(</span><span>ef</span><span>);</span>
    <span>let</span> <span>q</span> <span>=</span> <span>(</span><span>q</span> <span>as</span> <span>u8</span><span>)</span> <span>as</span> <span>f32</span><span>;</span>
    <span>let</span> <span>ef</span> <span>=</span> <span>ef</span> <span>-</span> <span>0.8</span> <span>+</span> <span>0.28</span> <span>*</span> <span>q</span> <span>-</span> <span>0.02</span> <span>*</span> <span>q</span> <span>*</span> <span>q</span><span>;</span>
    <span>min</span><span>(</span><span>ef</span><span>)</span>
<span>}</span>
</code></pre></div></div>


  </article></div>
  </body>
</html>
