<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fusectore.dev/2022/09/25/github-actions-pitfalls.html">Original</a>
    <h1>GitHub Actions Pitfalls</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>During one of my assignments, I worked with GitHub Actions pretty much every day.
I implemented workflows, created new actions, and helped people migrate their projects from jenkins to actions.</p>

<p>As much as I like actions ‚Äì and I like them a lot ‚Äì there are some things that caught me off guard.
I have collected some of these things, both for other people to let them know, and for myself as a future reference.</p>

<p>How well do you know actions?
Can you answer all of these questions correctly?</p>

<p>‚ÑπÔ∏è Assume that all YAML and code is valid/compiles</p>

<h2 id="output-from-a-previous-job">Output from a previous job</h2>

<p>What does the following print?</p>

<div><div><pre><code><span>jobs</span><span>:</span>
  <span>jobOne</span><span>:</span>
    <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
    <span>outputs</span><span>:</span>
      <span>foo</span><span>:</span>  <span>${{ steps.foo.outputs.foo }}</span> 
    <span>steps</span><span>:</span>
      <span>-</span> <span>run</span><span>:</span> <span>echo &#39;::set-output name=foo::bar&#39;</span>
        <span>id</span><span>:</span> <span>foo</span>
      
  <span>jobTwo</span><span>:</span>
    <span>needs</span><span>:</span> <span>jobOne</span>
    <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>run</span><span>:</span> <span>echo hello</span>
        
  <span>jobThree</span><span>:</span>
    <span>needs</span><span>:</span> <span>jobTwo</span>
    <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>run</span><span>:</span> <span>echo  ${{ needs.jobOne.outputs.foo }}</span> 
</code></pre></div></div>

<p>Solution:
It prints an empty line, because if you want to access an output from a job, you need to list it as a dependency.
Outputs from transitive dependencies cannot be accessed.</p>

<p>To fix this, make the third job depend on the first job explicitly <code>needs: [jobOne, jobTwo]</code></p>

<h2 id="exec-explodes">Exec explodes</h2>

<p>GitHub provides action developers with a <a href="https://github.com/actions/toolkit">toolkit</a> to develop actions in JavaScript.
One of the functions in there is called <code>exec</code> and can be used to run a command.
Here‚Äôs its <a href="https://github.com/actions/toolkit/blob/main/packages/exec/src/exec.ts#L17">signature</a>:</p>

<div><div><pre><code><span>/**
 * Exec a command.
 * Output will be streamed to the live console.
 * Returns promise with return code
 *
 * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
 * @param     args               optional arguments for tool. Escaping is handled by the lib.
 * @param     options            optional exec options.  See ExecOptions
 * @returns   Promise&lt;number&gt;    exit code
 */</span>
<span>export</span> <span>async</span> <span>function</span> <span>exec</span><span>(</span>
  <span>commandLine</span><span>:</span> <span>string</span><span>,</span>
  <span>args</span><span>?:</span> <span>string</span><span>[],</span>
  <span>options</span><span>?:</span> <span>ExecOptions</span>
<span>):</span> <span>Promise</span><span>&lt;</span><span>number</span><span>&gt;</span>
</code></pre></div></div>

<p>In an action, you might use it like so:</p>

<div><div><pre><code><span>const</span> <span>returnCode</span> <span>=</span> <span>await</span> <span>exec</span><span>.</span><span>exec</span><span>(</span><span>&#39;</span><span>node</span><span>&#39;</span><span>,</span> <span>[</span><span>&#39;</span><span>index.js</span><span>&#39;</span><span>]);</span>
<span>if</span> <span>(</span><span>returnCode</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>error</span><span>(</span><span>&#39;</span><span>Uh! Something did not quite work :(</span><span>&#39;</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>Do you see any problems with that code?</p>

<p>The problem is that <code>exec</code> does not return a non-zero return code if the command fails.
Instead, it returns a rejected promise.</p>

<p>So if you want to handle the error case, you need to wrap it in a try-catch block.</p>

<p>While this behavior can be changed by passing <a href="https://github.com/actions/toolkit/blob/main/packages/exec/src/interfaces.ts#L28">ignoreReturnCode</a> as the third argument <code>ExecOptions</code>, the default behavior is very surprising.
I have seen many examples of people checking the return code without knowing how this function really behaves.</p>

<p>Nevertheless, I still think throwing an error by default is probably not a bad choice, given that (A) many people ignore error handling and (B) you probably want to abort on error.</p>

<h2 id="push-for-all">Push for all?</h2>

<p>Say you‚Äôre working on your open source project, and you just started using actions to make sure the build always passes:</p>

<div><div><pre><code><span>on</span><span>:</span> <span>push</span>

<span>jobs</span><span>:</span>
  <span>build</span><span>:</span>
    <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> <span>actions/checkout@v3</span>
      <span># etc..</span>
</code></pre></div></div>

<p>The <code>push</code> trigger seems to do the trick in all cases:
You can push to a branch (or pull request) and the build runs.
You can push to the main branch and the build runs.</p>

<p>But there‚Äôs a scenario where it won‚Äôt run. Do you know when?</p>

<p>Solution: If I fork your project and create a pull request, then <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull-request-events-for-forked-repositories-2">push won‚Äôt trigger</a>.
If you want the PRs of external contributors to be validated with your workflows as well, you need to use the trigger <code>pull_request</code>.
And once you do that, you also need to make sure the <code>push</code> only triggers on main, because otherwise your own pull requests will trigger the workflow twice (both from <code>push</code> and <code>pull_request</code>):</p>

<div><div><pre><code><span>on</span><span>:</span>
  <span>pull_request</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span> <span>[</span><span>main</span><span>]</span>
</code></pre></div></div>

<p>When talking about running actions from contributors, it is important to mention that:</p>

<ul>
  <li>You can control how actions are triggered in pull requests from forks by <a href="https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks">Approving workflow runs from public forks</a></li>
  <li>Secrets are generally not available in PRs from forks, except for <code>$GITHUB_TOKEN</code>, which is read-only.
There‚Äôs a trigger called <code>pull_request_target</code> to work around that, but you need to be <a href="https://securitylab.github.com/research/github-actions-preventing-pwn-requests/">careful</a> as this open up the gates for potential vulnerabilities.</li>
</ul>

<h2 id="too-much-information-github">Too much information, GitHub</h2>

<p>Say I have an open pull request based on a branch called <code>my-feature</code>, and the following workflow is triggered.
What does it print?</p>

<div><div><pre><code><span>on</span><span>:</span> <span>pull_request</span>

<span>jobs</span><span>:</span>
  <span>branch</span><span>:</span>
    <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>run</span><span>:</span> <span>echo  ${{ github.ref_name }}</span> 
</code></pre></div></div>

<p>I‚Äôll even give you the docs on <a href="https://docs.github.com/en/actions/learn-github-actions/contexts#github-context"><code>github.ref_name</code></a>:</p>

<blockquote>
  <p>The short ref name of the branch or tag that triggered the workflow run. This value matches the branch or tag name shown on GitHub. For example, <code>feature-branch-1</code>.</p>
</blockquote>

<p>I‚Äôm going to guess you said <code>my-feature</code>, but unfortunately you‚Äôre wrong.</p>

<p>It is going to print the PR number followed by <code>/merge</code>.
For example, it would print <code>18/merge</code> for the 18th pull request in your repository.</p>

<p>Why is that? ü§î</p>

<p>The simple explanation is that when you create a pull request on GitHub, they create some additional internal(!) branches to make it easier for them to manage your pull request and tell you how it compares to the branch you want to merge into.
As a result of that, when you run a workflow on a <code>pull_request</code> event, it runs on one of these ‚Äúinternal‚Äù branches rather than the one you just pushed.
In terms of contents on your branch, this doesn‚Äôt make a difference ‚Äì you‚Äôre still running your builds and tests on your contents ‚Äì it‚Äôs just the branch name that is different.</p>

<p>Unfortunately, this implementation detail is exposed here.</p>

<p>Please see this <a href="https://stackoverflow.com/a/63595981/1080523">answer on stackoverflow</a> for more information.</p>

<p><em>Note that <code>$GITHUB_SHA</code> is <a href="https://github.com/orgs/community/discussions/26325">not what you‚Äôd expect</a> either</em></p>

<p>So how can you access the name of your branch in a pull request?
It‚Äôs in the payload from the event:</p>

<div><div><pre><code><span>on</span><span>:</span> <span>pull_request</span>

<span>jobs</span><span>:</span>
  <span>branch</span><span>:</span>
    <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>run</span><span>:</span> <span>echo  ${{ github.event.pull_request.head.ref }}</span> 
</code></pre></div></div>

<h2 id="bonus-am-i-there-or-not">Bonus: Am I there or not?</h2>

<p>Consider this reusable workflow:</p>

<div><div><pre><code><span>on</span><span>:</span>
  <span>workflow_call</span><span>:</span>
    <span>inputs</span><span>:</span>
      <span>my-input</span><span>:</span>
        <span>description</span><span>:</span> <span>optional input</span>
        <span>required</span><span>:</span> <span>false</span>
        <span>type</span><span>:</span> <span>string</span>

<span>jobs</span><span>:</span>
  <span>greet</span><span>:</span>
    <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> <span>my/action@v1</span>
        <span>with</span><span>:</span>
          <span>my-input</span><span>:</span>  <span>${{ inputs.my-input }}</span>  
</code></pre></div></div>

<p>Let‚Äôs say the action <code>my/action@v1</code> has an optional input <code>my-input</code> which has a default value <code>my-value</code>.
Now if you were to call the reusable workflow as shown in the following example, what value would be passed to <code>my/action@v1</code>?
Would the default be used?</p>

<div><div><pre><code><span>jobs</span><span>:</span>
  <span>jobA</span><span>:</span>
    <span>uses</span><span>:</span> <span>org/repo/.github/workflows/workflow.yml@v1</span>
</code></pre></div></div>

<p>Solution: An empty string is passed to <code>my/action@v1</code> as <code>my-input</code>.</p>

<p>The way this works is that if no value is passed to the reusable workflow, then the input <code>my-input</code> is still passed to the action, but it‚Äôs passed as an empty string.
And even though we usually see an empty string as ‚Äúno value passed‚Äù, the default value is not used here, because we did pass <em>something</em>.</p>

<p>If you wanted to use the default value if no input was passed, then you‚Äôd have to invoke the action differently based on whether the input was passed to the reusable workflow.</p>

<div><div><pre><code><span>steps</span><span>:</span>
  <span>-</span> <span>uses</span><span>:</span> <span>my/action@v1</span>
    <span>if</span><span>:</span> <span>inputs.my-input</span>
    <span>with</span><span>:</span>
        <span>my-input</span><span>:</span>  <span>${{ inputs.my-input }}</span> 
  <span>-</span> <span>uses</span><span>:</span> <span>my/action@v1</span>
    <span>if</span><span>:</span> <span>inputs.my-input == &#39;&#39;</span>
</code></pre></div></div>

<p>This has been a <a href="https://github.com/actions/runner/issues/924">long-standing issue</a> in the runner, but there‚Äôs likely no easy solution that does not break existing workflows.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
