<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://asherfalcon.com/blog/posts/5">Original</a>
    <h1>I built my own CityMapper</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div><p><span>live public transport routing</span></p></div><div><p>We&#39;ve all used a public transit router to find a quick route from A to B, such as Google Maps or CityMapper, but how do they actually work? In this post I will discuss how I tried to build my own public transport routing system for London that supports buses, tubes and trains.</p></div><p>To limit the scope of the project, I decided to only support buses, tubes and trains in London and surrounding areas. This still, however leaves a lot of data to process, and the main goal of the project is to use live arrivals data so we know the actual time the next bus, tube or train will arrive, which needs to be updated frequently. To get an idea of the scope of these modes in London, the following table summarizes the details of each:</p><p><img alt="Map of London" loading="lazy" width="1000" height="1000" decoding="async" data-nimg="1" src="https://asherfalcon.com/img14.png"/></p><p>Anyone that&#39;s studied Graph Theory would look at a problem like this and quickly recognise that each stop/station could be a node and each journey could be an edge, and to get the fastest routes we could update the edges in real time and use Dijkstra&#39;s algorithm to find the shortest path. This would work fine in a small network, but when you have lots of edges it can take a while, and it won&#39;t optimise for the amount of transfers you take, for example it might prefer for you to take three or four buses instead of one train even if it&#39;s only a few minutes quicker, where it is obviously wildly less convenient.</p><p>The solution I decided to use is an algorithm called <a target="_blank" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2012/01/raptor_alenex.pdf">RAPTOR</a>, which was introduced by Microsoft Research in 2012. RAPTOR optimises for the amount of transfers you take whilst minimising the time taken for the journey by running in rounds, where round <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span></span> searches for routes with <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span></span> transfers. It works similarly to Djikstra with how it stores the shortest time to arrive at each node, but it takes advantage of the fact that you can group the edges into the same vehicle or trip and traverse all the way to the end. You initiate the algorithm by setting the arrival time for each stop to <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∞</span></span></span></span></span>, except the start node which you set to zero, or in my implementation I chose to use unix timestamps, so I set it to the current time in milliseconds. The algorithm will then repeat the following process for each round:</p><p><img alt="RAPTOR algorithm" loading="lazy" width="600" height="100" decoding="async" data-nimg="1" src="https://asherfalcon.com/img16.png"/></p><p>This process repeats for each round, so if you are going from A to B a direct route would be found in the first round, and then a route that might require a walk before a bus or two buses where you transfer at the exact same stop would come up in the second round. I&#39;ll now move on to one of the most difficult parts of this project, which is getting the live data. I&#39;ll start with the rail data, as it was by far the easiest to get. I got the data from the <a target="_blank" href="https://raildata.org.uk">Rail Data Marketplace</a>, which sounds terribly official but it&#39;s basically just a developer portal for national rail. I believe various companies sell custom data on there, but you can get all the data you need for this project for free. Creating an account was straightforward, and once I was in I found the endpoint I needed, the <a target="_blank" href="https://raildata.org.uk/dashboard/dataProduct/P-2eec03eb-4d53-4955-8a96-0314964a4e9e/overview">Live Arrival and Departure Boards</a>. You just supply a CRS code, which is a unique identifier for each train station, and you get a response containing the scheduled and estimated times for each train. Before I could make use of this however, I needed to know the CRS codes for all the stations and to get their coordinates which would be necessary for calculating walking times further down the line. The rail data site had an easy to use dataset for this which I hacked together a python script to parse each station and store it in a local sqlite database. Below you can see an interactive sample of the data we get in response when asking for the arrivals and departures for London Victoria:</p><p><code><span>{</span><span><span>9<!-- --> Items</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M12.473 5.806a.666.666 0 0 0-.946 0L8.473 8.86a.667.667 0 0 1-.946 0L4.473 5.806a.667.667 0 1 0-.946.94l3.06 3.06a2 2 0 0 0 2.826 0l3.06-3.06a.667.667 0 0 0 0-.94Z"></path></svg></span><div><div><p><span>trainServices</span>:</p><!-- --> <p><span>[</span><span>]</span><span>10<!-- --> Items</span></p></div><div><p><span>generatedAt</span>:</p><!-- --> <p><span>&#34;<!-- -->2025-10-26T18:20:36.2627696+00:00<!-- -->&#34;</span></p></div><div><p><span>locationName</span>:</p><!-- --> <p><span>&#34;<!-- -->London Victoria<!-- -->&#34;</span></p></div><div><p><span>areServicesAvailable</span>:</p><!-- --> <p><span>true</span></p></div></div><span>}</span></code></p><p>After playing around with a few requests, I realised that the <span>serviceID</span> field for each train service has two parts, for example the first train service shown above is <span>1971893VICTRIC_</span>, where the first part (the number) uniquely identifies the specific train. Using this, we can form together our unique trips to be used in the RAPTOR algorithm, and add in the time it will arrive at each stop. I couldn&#39;t find an endpoint to get this for every station, so for now the algorithm sends out requests for a few hundred stations to make sure it doesn&#39;t miss any trains, and then pieces them together.</p><p>The next part was getting the bus data. If you remember from the table before, there are thousands of buses running at a time, and the scale of the data was made apparent when I hit the TFL bus arrivals endpoint and it took over 15 seconds to load. After parsing it, I found it had over 108,000 arrival times, where each arrival time is a object with a bus stop id and a bus route, see an example of one of these objects below:</p><p><code><span>[</span><span><span>1<!-- --> Items</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M12.473 5.806a.666.666 0 0 0-.946 0L8.473 8.86a.667.667 0 0 1-.946 0L4.473 5.806a.667.667 0 1 0-.946.94l3.06 3.06a2 2 0 0 0 2.826 0l3.06-3.06a.667.667 0 0 0 0-.94Z"></path></svg></span><div><div><p><span>{</span><span><span>21<!-- --> Items</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M12.473 5.806a.666.666 0 0 0-.946 0L8.473 8.86a.667.667 0 0 1-.946 0L4.473 5.806a.667.667 0 1 0-.946.94l3.06 3.06a2 2 0 0 0 2.826 0l3.06-3.06a.667.667 0 0 0 0-.94Z"></path></svg></span></p><div><div><p><span>stationName</span>:</p><!-- --> <p><span>&#34;<!-- -->Walpole Road<!-- -->&#34;</span></p></div><div><p><span>destinationName</span>:</p><!-- --> <p><span>&#34;<!-- -->Wimbledon<!-- -->&#34;</span></p></div><div><p><span>timestamp</span>:</p><!-- --> <p><span>&#34;<!-- -->2025-10-26T18:57:03.618Z<!-- -->&#34;</span></p></div><div><p><span>towards</span>:</p><!-- --> <p><span>&#34;<!-- -->South Wimbledon<!-- -->&#34;</span></p></div><div><p><span>expectedArrival</span>:</p><!-- --> <p><span>&#34;<!-- -->2025-10-26T18:56:49Z<!-- -->&#34;</span></p></div><div><p><span>timeToLive</span>:</p><!-- --> <p><span>&#34;<!-- -->1970-01-01T00:00:00Z<!-- -->&#34;</span></p></div></div><p><span>}</span></p></div></div><span>]</span></code></p><p>Like with the trains, we can piece together unique trips for each route using the vehicleId to group together the arrival times for the same bus, and add in the time it will arrive at each stop. The process for the London Underground was extremely similar, however you have to be careful because the vehicleId for the underground isn&#39;t unique, as each line could have multiple trains with the same vehicleId, e.g. a train on the Victoria line could have the same vehicleId as a train on the District line. To get around this, I added in the line name to the vehicleId, so now each train has a unique vehicleId like <span>circle/234</span>. Now I have all the trips for each mode, but something&#39;s missing - walking. Walking is crucial for two main reasons: firstly, it massively increases the number of route combinations you can take. For example, you might take a bus to a stop that&#39;s a 5-minute walk from a tube station, which could save you 20 minutes compared to staying on the bus. Secondly, it&#39;s essential for connecting stops that are technically different but practically the same - like two bus stops with identical names on opposite sides of the street, which have completely different stop IDs in the TfL system. Without walking transfers, the algorithm wouldn&#39;t even know these stops are related.</p><p>At first I considered using some public API to compute the walking times, but after doing the math I realised I could need more than a million requests, and even using servers that support batch requests could end up taking ages, but I came across an open source project called <a target="_blank" href="https://project-osrm.org">OSRM</a> which is a routing engine for walking, driving and cycling. I downloaded the OpenStreetMap data for England because it was the smallest available dataset that covered London, and set it up on my machine. It took around 20 minutes to load all the data and then it was ready - I could send two coordinates to the endpoint and it would immediately return the walking time between them. Between trains, tubes and buses there are over 33,500 unique stops, so for each one to limit the number of requests I only queried the walking times for stops within a few kilometers. Surprisingly, it was able to calculate over 1.8M walking distances in less than 15 minutes, and the end result was a json file that was 55MB! I&#39;m sure I could have optimised the storage format but it wasn&#39;t large enough to be a serious issue.</p><p>To account for walking between stops, I just considered the walk from one stop to another to be a transfer and ran RAPTOR like normal. Hacking together a quick backend to allow searching for stops to pick as the start and end points and using the raptor algorithm to find the fastest route, I was able to get a working prototype. A simple frontend was then added to allow searching for routes and displaying the results. One thing I was unable to do with this project was show on the frontend the route trace for trains and tubes. For buses I could get a geoJson list of coordinates of the route the bus took and then cut it down for the stops you board and get off at, but for trains and tubes I struggled to find a reliable way of getting the route it took across the rail network, and just ended up making it draw straight lines.</p><p>I&#39;ve chosen not to deploy this project publicly as I found the number of requests it has to make to stay up to date and accurate is too high for the utility it would provide, however I have recorded (and sped up) some footage of it in action below:</p><p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/9TRtHZlRWHg?si=IEVvKqsCz48KIxdL" title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen"></iframe></p><p>The code for this project is available on a git repo <a target="_blank" href="https://github.com/ashfn/london-raptor">here</a>, and as always thanks for reading, and feel free to reach out to me <a href="https://asherfalcon.com/contact">here</a> if you have any questions or comments.</p></div></div></div></div></div>
  </body>
</html>
