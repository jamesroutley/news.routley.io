<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antocuni.eu/2025/10/29/inside-spy-part-1-motivations-and-goals/">Original</a>
    <h1>SPy: An interpreter and compiler for a fast statically typed variant of Python</h1>
    
    <div id="readability-page-1" class="page"><div data-md-component="container">
      
      
        
          
        
      
      <main data-md-component="main">
        <div>
          
            
              
                
              
              
            
            
              
                
              
              
            
          
          
  <div data-md-component="content">
    
    <article>
      
        
  


  <nav>
    
      
      
      
        <a href="https://antocuni.eu/tags/#tag:spy">spy</a>
      
    
  </nav>




<p>This is the first of a series of posts in which I will try to give a deep explanation of
<a href="https://github.com/spylang/spy">SPy</a>, including motivations, goals, rules of the
language, differences with Python and implementation details.</p>
<p>This post focuses primarily on <strong>the problem space</strong>: why Python is fundamentally hard
to optimize, what trade-offs existing solutions require, and where current approaches
fall short. Subsequent posts in this series will explore the solutions in depth. For
now, let&#39;s start with the essential question: what is SPy?</p>
<p>Before diving in, I want to express my gratitude to my employer,
<a href="https://www.anaconda.com/">Anaconda</a>, for giving me the opportunity to dedicate
100% of my time to this open-source project.</p>
<!-- more -->

<h2 id="what-is-spy">What is SPy?<a href="#what-is-spy" title="Permanent link">¶</a></h2>
<p>There are multiple answers to that, depending on the point of view. The most technically
accurate is:</p>
<blockquote>
<p>SPy is an interpreter <em>and</em> a compiler for a <strong>statically typed variant</strong> of Python,
with focus on performance.</p>
</blockquote>
<p>I think it&#39;s very important to be clear and honest since the beginning: SPy is not a
&#34;compiler for Python&#34;. There are features of the Python language which will never be
supported by SPy by design. Don&#39;t expect to compile Django or FastAPI with SPy.</p>
<p>A small corollary is that for now I decided that SPy programs live in <code>*.spy</code> files, to
make the distinction between the two worlds very clear.</p>
<p>Whilst compiling 100% of Python is not a goal, SPy still aims to have a very tight
integration with the existing Python ecosystem.  It is possible to <code>import</code> Python
libraries from SPy, and SPy modules from Python.</p>
<div>
<p>The myth of 100% compatibility</p>
<p>The vast majority of &#34;compilers for Python&#34; which exists or existed in the past are
not &#34;100% compatible&#34;. They don&#39;t support the full language even when they claim
so. SPy prefers to be more explicit and honest about it.</p>
</div>
<div>
<p>Current Status</p>
<p>SPy is still very work-in-progress and there are many things which are part of the
plan and the design, but they are currently not there.</p>
<p>To make reading easier in this series I always use the present tense when talking
about SPy capabilities -- even when they are not implemented -- and defer a more
detailed explanation to these &#34;Current Status&#34; boxes.</p>
<p>At this point, SPy is still not usable for anything bigger than demos. The most
complex piece of code written in SPy is probably the
<a href="https://github.com/spylang/demos/tree/main/raytracing">raytracing example</a>, which is
<strong>200x faster than CPython</strong>.</p>
</div>
<div>
<p>Current Status: Python integration</p>
<p>At the moment of writing, SPy cannot import Python libraries yet.  The plan is to
support this use case by embedding <code>libpython.so</code> (only if and when needed!) but to
do that we need a way to call C from SPy, which we haven&#39;t yet implemented.</p>
<p>The other direction is partially supported: the SPy compiler can generate CFFI-based
extensions which can be imported by CPython.  This is useful for experimentation and
for early testing, but it exposes only a partial and low-level API.  Eventually, the
SPy compiler will be able to generate fully fledged CPython extensions, similar to
what Cython does.</p>
</div>
<p>Another possible answer is the following:</p>
<blockquote>
<p>SPy is a thought experiment to determine how much dynamicity we can remove from Python
while still feeling Pythonic.</p>
</blockquote>
<p>During the years there have been many attempts to improve Python speed; generally they
fall into two categories:</p>
<ol>
<li>
<p>Implement &#34;full Python&#34;. To be able to support all dynamic features and be fast,
     they usually employ a Just In Time (JIT) compiler. Examples are
     <a href="https://pypy.org/">PyPy</a>, <a href="https://www.graalvm.org/python/">GraalPy</a>,
     <a href="https://github.com/pyston/pyston">Pyston</a>, and
     <a href="https://github.com/python/cpython/tree/v3.14.0/Tools/jit">CPython&#39;s own JIT</a>.</p>
</li>
<li>
<p>Implement a &#34;subset of Python&#34; or &#34;variant of Python&#34;, either as an Ahead of Time
     (AOT) or JIT compiler which is able to produce fast code. The usual approach here
     is to remove many (if not all) of the dynamic features which make Python hard to
     compile.  Examples are <a href="https://rpython.readthedocs.io/en/latest/">RPython</a>,
     <a href="https://github.com/mypyc/mypyc">Mypyc</a>, <a href="https://cython.org/">Cython</a> and
     <a href="https://numba.pydata.org/">Numba</a>.</p>
</li>
</ol>
<p>The problem of &#34;full Python&#34; JIT compilers is that sometimes they work very well and
produce huge speedups, other times they don&#39;t produce any speedup at all, or might even
introduce slowdowns, or they might use too much memory, or they are slow to &#34;warm up&#34;.</p>
<p>The problem of the subset/variant approach is that by removing the dynamic features of
Python, you end up with something which does not feel <em>pythonic</em>, and in which many
typical and idiomatic Python patterns just don&#39;t work.  You often end up with &#34;Java with
Python syntax&#34; (nothing in particular against Java, but I hope it gives an idea of what
I mean).</p>
<p>SPy does something different: on one hand, it removes the dynamic features which make
Python &#34;slow&#34;, but on the other hand it introduces <em>new</em> features which make it
possible to implement and use the same pythonic patterns which we like.  How to achieve
this result is not possible to explain in a few sentences, that&#39;s why we need a full
series of posts :).</p>
<div>
<p>Subset vs Variant</p>
<p>If a compiler implements a <strong>subset</strong> of Python, then all programs which can be
compiled can also run on top of CPython. If the compiler also add new features which
are not available on CPython, then it&#39;s a <strong>variant</strong>.</p>
<p>For example according to this definition, RPython is a subset and Cython is a
variant.  SPy is also a variant because it offers unique features, as we will see
later.</p>
</div>
<h2 id="the-zen-of-spy">The Zen of SPy<a href="#the-zen-of-spy" title="Permanent link">¶</a></h2>
<p>As mentioned above, 100% compatibility with Python is explicitly not a goal.</p>
<p>If you are a &#34;language nerd&#34; (like me :)) who knows the inner details of the
<a href="https://antocuni.eu/2025/08/25/inside-cpythons-attribute-lookup/">attribute lookup logic</a> or when Python invokes
<code>__add__</code> or <code>__radd__</code> in case of inheritance from builtin types, then SPy is
definitely <strong>not Python</strong>, and doesn&#39;t even try to be.</p>
<p><strong>However</strong>, I expect that for a large fraction of Python users, it will not
matter. There are many users who mainly consume complex libraries written by others and
write &#34;straightforward&#34; Python code: for them, writing SPy should be as easy as writing
Python.</p>
<p>The following is a list of goals and design guidelines of SPy:</p>
<ol>
<li>
<p><strong>Easy to use and implement</strong>. The language is easy to understand. Moreover, it
     must be possible to implement SPy without huge engineering teams.</p>
</li>
<li>
<p>We have an <strong>interpreter</strong> for ease of development and debugging.</p>
</li>
<li>
<p>We have a <strong>compiler</strong> for deployment and performance. The interpreter and the
     compiler are guaranteed to produce the exact same results at runtime.</p>
</li>
<li>
<p><strong>Static typing</strong>. Type annotations are enforced by the language and checked by
     both the interpreter and the compiler.</p>
</li>
<li>
<p><strong>Performance matters</strong>. SPy aims to have performance comparable to low level
     languages such as C and Rust.</p>
</li>
<li>
<p><strong>Predictable performance</strong>. We should be able to reason about the performance
     characteristics of a piece of code, without relying on a &#34;magical optimizer&#34; which
     we don&#39;t fully understand, and without having &#34;performance cliffs&#34; in which
     modifying a line of code makes everything 10x slower.</p>
</li>
<li>
<p><strong>Rich metaprogramming capabilities</strong>. SPy has 1st class support for
     metaprogramming, although the precise spelling and characteristics might deviate
     from Python.  For example, it would totally be possible to recreate something like
     FastAPI or SQLAlchemy in SPy.</p>
</li>
<li>
<p><strong>Zero cost abstractions</strong>. SPy supports things like decorators, <code>**kwargs</code>, the
     descriptor protocol, <code>__getattr__</code>, etc. without extra runtime costs.</p>
</li>
<li>
<p><strong>Opt-in dynamism</strong>. Some of the dynamic features of Python are off by default, but
     it&#39;s still possible to opt-in explicitly, when needed.  As an example, SPy provides
     a <code>dynamic</code> type which provides full dynamic dispatch.</p>
</li>
<li>
<p><strong>One language, two levels</strong>. SPy supports the low-level capabilities of C, C++,
     Rust, etc., as well as the high-level abstractions and expressivity of Python. For
     example, SPy&#39;s own
     <a href="https://github.com/spylang/spy/blob/9b3bbf42a8a1426008de14c884536451f2ae9025/stdlib/_list.spy">list</a>
     and
     <a href="https://github.com/spylang/spy/blob/9b3bbf42a8a1426008de14c884536451f2ae9025/stdlib/_dict.spy">dict</a>
     types are written in SPy.</p>
</li>
</ol>
<div>
<p>Current Status: <code>**kwargs</code> and <code>dynamic</code></p>
<p>At the time of writing, <code>**kwargs</code> and keyword arguments are not implemented yet.
The <code>dynamic</code> type works in the interpreter, but not yet in the compiler.</p>
</div>
<h2 id="motivations-and-background">Motivations and background<a href="#motivations-and-background" title="Permanent link">¶</a></h2>
<p>There are several factors which motivated me to start such an ambitious project. Some of
them come directly from my first hand experience as a PyPy core dev in the last ~20
years.  Others come from insights which I gained while doing my professional activity,
which for years consisted in trying to optimize real world Python code used in
production.  Finally, some come from observing how Python is actually used in practice.</p>
<p>Throughout this post, we&#39;ll see variations on a theme: Python developers already write
in constrained subsets of the language (for readability, for the JIT, for the type
checker), but these subsets are informal and poorly specified. SPy formalizes these
constraints and gives you powerful tools in return.</p>
<h3 id="why-python-is-slow">Why Python is slow<a href="#why-python-is-slow" title="Permanent link">¶</a></h3>
<p>Thanks to my work on PyPy, I came to the conclusion that Python is fundamentally
impossible to optimize to the level of performance which I aim for.  There are some
features of the language which make Python &#34;intrinsically slow&#34;: I have talked about it
extensively in my EuroPython talk <strong>Myths and fairy tales around Python performance</strong>
(<a href="https://www.youtube.com/watch?v=X3QbMaEIpt0">video</a>,
<a href="https://antocuni.eu/talk/2025/07/europython-myths-and-fairy-tales/">slides</a> and
<a href="https://lwn.net/Articles/1031707/">LWN write-up</a>).</p>
<div>
<p>Levels of performance</p>
<p>When comparing two different languages and implementations, it doesn&#39;t make sense to
say &#34;X is Nx faster than Y&#34;: the precise number can vary a lot depending on the
benchmark and on the hardware.</p>
<p>Neverthelss, we can at least write down the order of magnitude of the expected
speeups in the average and best case scenarios:</p>
<ul>
<li>
<p>CPython&#39;s JIT aims to be 10% - 50% faster than CPython&#39;s interpreter</p>
</li>
<li>
<p>PyPy&#39;s JIT aims to be 2x - 10x faster than CPython</p>
</li>
<li>
<p>SPy aims to be 10x - 100x faster than CPython.</p>
</li>
</ul>
</div>
<p>The first problem is that Python is <strong>extremely dynamic</strong>. I&#39;m not talking only about
dynamic typing, but also about the fact that in a given Python process, the &#34;world&#34; is a
moving target and &#34;everything can change at any time&#34;.  For example, <code>import</code> statements
are resolved dynamically at runtime and it&#39;s impossible to reliably determine them
statically. Modules and classes are mutable: their content can change at any time, and a
compiler must be defensive about it.  The <code>__class__</code> of an object can change, etc.</p>
<p>On top of that, <strong>operation dispatch</strong> is also very dynamic. Most syntactical constructs
like <code>.</code>, <code>+</code>, <code>[]</code>, etc., trigger
<a href="https://antocuni.eu/talk/2025/07/europython-myths-and-fairy-tales/#/15/0/0">very complex</a>
lookup logic which must be resolved at runtime.  And even knowing the type of an object
is not enough to predict its behavior, because you can have per-instance attributes
which overrides class behavior.</p>
<p>A JIT compiler <strong>can solve</strong> these two problems, and PyPy proves it. However, an
approach based on JIT compilation introduces its own unique problems, as we will see in
the dedicated section.</p>
<p>Finally, we have a problem which cannot be solved even by a JIT (as far as I
know). Python semantics makes it intrinsically <strong>cache unfriendly</strong>.  In Python
<del>everything is an object</del> everything is a pointer, and objects are mutable by default.
In CPython object references are implemented as <code>PyObject *</code> in C, which means that any
time we do an attribute and/or item lookup we need to dereference a pointer.  It is not
uncommon to have to dereference 4 or 5 pointers to execute just a single line code: this
is called <a href="https://en.wikichip.org/wiki/pointer_chasing">Pointer Chasing</a> and in short,
it&#39;s Very Bad™ for performance because it destroys
<a href="https://en.wikipedia.org/wiki/Locality_of_reference#Hierarchical_memory">memory locality</a>. Take
the classical example of a <code>Rect</code> which has two <code>Points</code>:</p>
<div><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span>@dataclass</span>
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span>class</span><span> </span><span>Point</span><span>:</span>
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>    <span>x</span><span>:</span> <span>float</span>
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>    <span>y</span><span>:</span> <span>float</span>
<a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>
<a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a><span>@dataclass</span>
<a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a><span>class</span><span> </span><span>Rect</span><span>:</span>
<a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a>    <span>a</span><span>:</span> <span>Point</span>
<a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a>    <span>b</span><span>:</span> <span>Point</span>
<a id="__codelineno-0-10" name="__codelineno-0-10" href="#__codelineno-0-10"></a>
<a id="__codelineno-0-11" name="__codelineno-0-11" href="#__codelineno-0-11"></a><span>r</span> <span>=</span> <span>Rect</span><span>(</span><span>Point</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>),</span> <span>Point</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>))</span>
<a id="__codelineno-0-12" name="__codelineno-0-12" href="#__codelineno-0-12"></a><span>width</span> <span>=</span> <span>abs</span><span>(</span><span>r</span><span>.</span><span>b</span><span>.</span><span>x</span> <span>-</span> <span>r</span><span>.</span><span>a</span><span>.</span><span>x</span><span>)</span>
<a id="__codelineno-0-13" name="__codelineno-0-13" href="#__codelineno-0-13"></a><span>height</span> <span>=</span> <span>abs</span><span>(</span><span>r</span><span>.</span><span>b</span><span>.</span><span>y</span> <span>-</span> <span>r</span><span>.</span><span>a</span><span>.</span><span>y</span><span>)</span>
</code></pre></div>
<p>We can use the excellent <a href="https://pythontutor.com/render.html#code=class%20Point%3A%0A%20%20%20%20def%20__init__%28self,%20x,%20y%29%3A%0A%20%20%20%20%20%20%20%20self.x%20%3D%20x%0A%20%20%20%20%20%20%20%20self.y%20%3D%20y%0A%20%20%20%20%0Aclass%20Rect%3A%20%20%20%20%0A%20%20%20%20def%20__init__%28self,%20a,%20b%29%3A%0A%20%20%20%20%20%20%20%20self.a%20%3D%20a%0A%20%20%20%20%20%20%20%20self.b%20%3D%20b%0A%0A%0Ar%20%3D%20Rect%28Point%281,%202%29,%20Point%282,%203%29%29%0A%0Awidth%20%3D%20abs%28r.b.x%20-%20r.a.x%29%0Aheight%20%3D%20abs%28r.b.y%20-%20r.a.y%29&amp;cumulative=false&amp;curInstr=15&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">PyTutor</a> to visualize a simplified version of the memory layout of a <code>Rect</code>:</p>
<p><a data-type="image" data-width="auto" data-height="auto" href="https://antocuni.eu/2025/10-spy-motivations-and-goals/rect-point.png" data-title="Memory layout of a Rect instance" data-desc-position="bottom"><img alt="Memory layout of a Rect instance" src="https://antocuni.eu/2025/10-spy-motivations-and-goals/rect-point.png"/></a></p>
<p>Each arrow is a pointer, and following an arrow means that we have a chance to do a
&#34;cache miss&#34;.  A better memory layout for this precise case would be to store the 4
<code>float</code>s in a contiguous area of memory, but doing so would violate some property which
the language guarantees (e.g. <code>id(r.a) == id(r.a)</code>, or that <code>r.a</code> doesn&#39;t make a copy),
so a compliant Python implementation cannot do that.</p>
<div>
<p>About CPUs, cache and RAM</p>
<p>Modern CPUs are very complex beasts, thus the following is a simplified explanation.</p>
<p>The cost of loading values from RAM is very slow compared to the cost of computation
itself. If you want to add two numbers which are already in CPU registers, you can
do that in 1 cycle, but if you need to fetch those values from memory, the CPU must
sit idle for <strong>hundreds</strong> of cycles while it waits for the data to be loaded.</p>
<p>Since loading from RAM is so slow, CPUs store frequently used data into a
&#34;cache&#34;. Loading from the cache is much faster, and thus CPUs can execute many more
instructions per second when they operate on cached data. Normally on modern systems
we have three levels of cache: L1, L2 and L3. L1 is the smallest and fastest, then
each level is bigger and slower than the previous; the RAM is the slowest.  Loading
an address of memory which is in the cache is a <strong>cache hit</strong>, else it&#39;s a <strong>cache
miss</strong>.</p>
<p>For multiple reasons which I cannot explain in this box, if the address <code>A</code> is in
cache, then also all the values which are &#34;close&#34; to <code>A</code> are in cache. That&#39;s why
having a good memory locality increases the chance of cache hits. On the other hand,
when we follow a pointer there is a high risk of landing in a &#34;far&#34; region of the
memory, and thus each pointer dereference is a potential cache miss.</p>
<p>This <a href="https://antocuni.eu/talk/2025/07/europython-myths-and-fairy-tales/#/44">video</a>
gives a visual intuition of the relative performance of each level. Compared to L1,
RAM is super slow, and that&#39;s why each cache miss is a disaster for performance.</p>
</div>
<h3 id="realpython-is-a-subset-of-python">RealPython is a subset of Python<a href="#realpython-is-a-subset-of-python" title="Permanent link">¶</a></h3>
<p>In the previous section we saw how Python allows a great deal of dynamism. However, in
practice this doesn&#39;t happen so often.</p>
<p>We run applications in very well defined environments, with locked set of
dependencies. But the interpreter doesn&#39;t know and must rediscover at every single run
that <code>import numpy</code> actually imports the same version of numpy from the same directory
again and again.</p>
<p>Moreover, during the years, as a community we understood that certain patterns are
&#34;good&#34;, while others are detrimental to readability and maintainability: we tend to have
functions which operate on well defined types, creating attributes outside of <code>__init__</code>
is a bad practice, monkey-patching is permitted only in certain contexts (e.g. testing),
we never change the <code>__class__</code> of an object, and so on.</p>
<p>De facto, we are <strong>already using a subset of Python</strong>, which I&#39;d like to call
<code>RealPython</code>, but it&#39;s a subset which is not formally specified and is slightly
different from case to case.  The interpreter cannot take advantage of it because it
needs to be ready to handle the 0.1% of the cases in which these things actually happen.</p>
<p>But at the same time, we cannot just remove dynamism and metaprogramming from the
language: it&#39;s what makes it possible to have some of the most powerful and rich
libraries in the ecosystem!</p>
<h3 id="static-typing-in-python">Static Typing in Python<a href="#static-typing-in-python" title="Permanent link">¶</a></h3>
<p>In the recent years, static typing and type checkers have become more and more popular
in the Python community.  Let&#39;s be clear: I think that <strong>given the constraints</strong>, the
Python typing story is good enough and well designed. I wouldn&#39;t be able to do it
better.  But still, Python is not a language designed for static typing and, in absolute
terms, the current situation leaves a lot to be desired.</p>
<p>The static-vs-dynamic typing debate has been going on for decades. Let&#39;s try to examine
the typical pros&amp;cons of each.</p>
<p>The first typical advantage of static typing is that the typecheker can <strong>prove</strong> (in the
mathematical sense) that <strong>a certain class of bugs cannot happen</strong> in your
program. Unfortunately, this doesn&#39;t happen in Python.</p>
<p>The interpreter just ignores type annotations. The typechecker tries its best, but there
are cases in which it just doesn&#39;t understand the full semantics of Python and/or
deliberately ignores it and thus has a wrong view on what&#39;s actually happening.  The
following silly example happily passes <code>mypy</code>, although it&#39;s clearly wrong and raises
<code>AttributeError</code> at runtime:</p>
<div><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span>class</span><span> </span><span>Point</span><span>:</span>
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>    <span>x</span><span>:</span> <span>int</span>
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>    <span>y</span><span>:</span> <span>int</span>
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span>p</span> <span>=</span> <span>Point</span><span>()</span>
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span>print</span><span>(</span><span>p</span><span>.</span><span>x</span><span>)</span>
</code></pre></div>
<p>As such, we need to treat Python type checkers more like linters than actual theorem
provers -- which is still better than nothing, but very far from having the advantages
of an actual sound type system.</p>
<p>The second typical advantage of static typing is that the compiler can emit <strong>more
efficient code</strong>.  But since we cannot actually be sure that types are correct, we
cannot use them to guide compilation.  There are projects like <code>mypyc</code> which go in this
direction, but by doing so they break compatibility and limit dynamism, so we are back
to the category of &#34;compiler for a subset/variant of Python&#34;.</p>
<p>Finally, another advantage of static typing is that <strong>IDEs and tooling</strong> can use type
knowledge to assist development. I think this is actually a great success in Python and
I suspect this plays a big role in the enthusiasm around the Python typing system.</p>
<p>On the other hand, the typical advantage of dynamic typing is that it allows more
flexibility. This is another pain point of Python typing: I often find cases in which
there are patterns which would make my code &#34;better&#34;, but they cannot be understood by
the typechecker even if they are totally correct.  The part of the language which is
type-checkable is <em>another</em> subset of Python: this time it&#39;s better specified, although
very far from being a formal specification.</p>
<p>I am aware that what I&#39;m going to say it&#39;s a bit of exaggeration, it wants to be
provocative.  But, from some point of view, by using static typing in Python we get
<strong>the worst of both worlds</strong>: zero guarantees, still slow, and it prevents patterns
where dynamic typing is actually useful.</p>
<p>Wouldn&#39;t it be better to have static typing in such a way which is safe, fast <strong>and</strong>
still allows pythonic patterns?</p>
<h3 id="about-pypy-and-jit-compilers">About PyPy and JIT compilers<a href="#about-pypy-and-jit-compilers" title="Permanent link">¶</a></h3>
<p>In the section &#34;Why Python is slow&#34;, we listed three problems:</p>
<ol>
<li>
<p>mutable world</p>
</li>
<li>
<p>dynamic &amp; complex dispatch</p>
</li>
<li>
<p>cache unfriendliness</p>
</li>
</ol>
<p>The PyPy JIT actually solves (1) and (2) very well, by taking advantage of what we
realized in <a href="#real-python-is-a-subset-of-python">RealPython is a subset of Python</a>: a
lot of the &#34;crazy things&#34; don&#39;t actually happen in practice, or happen very rarely. The
essence is that it speculatively assumes conditions such as:</p>
<ul>
<li>
<p>the types of variables in a given piece of code are stable</p>
</li>
<li>
<p>the <code>__dict__</code> of classes and modules doesn&#39;t change</p>
</li>
<li>
<p>the <code>__class__</code> of an object doesn&#39;t change</p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
<p>Then it generates code which is very fast <strong>as long as those assumptions
hold</strong>. Moreover, it generates extra code and guards to check that the assumptions are
still valid, and deoptimize when they are not.</p>
<p>This high-level overview is correct not only for PyPy, but for all Python JIT compilers
that I know of, although then the actual low-level details can vary <strong>a lot</strong> depending
on the implementation.</p>
<p>The main drawback of this strategy is that the code is fast only as long as the
heuristics are correct. We can easily find cases in which by modifying a single line of
code the generated code becomes 2x, 5x or even 10x slower, because the JIT is no longer
able to optimize it correctly.  What is infuriating is that in those cases the JIT
<strong>perfectly knows why it cannot optimize</strong>, but it just doesn&#39;t tell us.  We could
probably try to emit warnings in those cases, but from the point of view of the JIT is
hard to distinguish the cases in which a warning makes sense from those in which it
doesn&#39;t.</p>
<p>If you want maximum performance, you need to <strong>write code which complies with the
heuristics</strong>: it&#39;s yet another subset of Python, but this time it is very loosely
specified and often requires deep knowledge of the JIT internals to know exactly what
you can and cannot do; let&#39;s call this <code>JITPython</code>. It becomes very hard to reason about
performance and to predict whether a given piece of code will be fast or slow.</p>
<p>Moreover, there are other problems with JITs. In random order:</p>
<ul>
<li>
<p>the implementation is much more complex. It&#39;s harder to contribute, and it requires
    lot of engineering power.</p>
</li>
<li>
<p>No matter how advanced a JIT is, there will always be cases which it fails to
    optimize.</p>
</li>
<li>
<p>Guards and checks have a runtime cost.</p>
</li>
<li>
<p>Even when everything goes well, the quality of the generated code is worse than an
    AOT compiler, because the JIT cannot spend too much time on optimizations.</p>
</li>
<li>
<p>There is a warmup phase before reaching peak performance.</p>
</li>
<li>
<p>They tend to use more memory.</p>
</li>
<li>
<p>For the specific case of <strong>tracing JITs</strong> like PyPy and CPython&#39;s own JIT, there are
    other kinds of problems which I discuss in full details
    <a href="https://antocuni.eu/2025/09/24/tracing-jits-in-the-real-world--cpython-core-dev-sprint/">here</a>.</p>
</li>
</ul>
<h3 id="c-api">C API<a href="#c-api" title="Permanent link">¶</a></h3>
<p>There is another problem with JIT compilers: the C API is completely opaque to any JIT.</p>
<p>Huge parts of the Python ecosystem are written in compiled languages (C, C++, Rust,
Cython, ...) and they communicate with the Python interpreter through the C API.  As
soon as the JIT needs to call into a C extension, it loses track of what&#39;s going on and
has to assume that &#34;everything changed&#34;, which often needs to deoptimize and/or do
expensive sanity checks.</p>
<p>In an ideal world, we would like to have an optimizer which is able to see the whole
program across the language boundary and e.g. to inline a C function called from Python
or viceversa.  This is something which happens almost for free when using AOT compiled
language with Link Time Optimization (LTO), but which is just impossible to get with
Python.</p>
<h3 id="rpython">RPython<a href="#rpython" title="Permanent link">¶</a></h3>
<p>RPython is an implementation detail of PyPy, but a very interesting one. It stands for
&#34;Restricted Python&#34;, it&#39;s a subset of Python which is compilable to C, and it&#39;s the
language in which the PyPy interpreter is written in:</p>
<div><pre><span></span><code>PyPy : RPython = CPython : C
</code></pre></div>
<p>RPython programs can usually run <strong>unmodified</strong> on CPython, and you get the same results
as with the compiled version.  This means that you can use the CPython interpreter for
development and debugging, and the RPython compiler for deployment -- the best of both
worlds.  This pattern is used heavily to develop PyPy.</p>
<p>Another interesting feature of RPython is its metaprogramming capabilities, which come
directly from the way it is implemented.  The RPython compiler is written in Python, and
it works by first <strong>importing the entry point</strong> of the target program inside CPython,
then analyzing the bytecode of the live function objects recursively referenced by the
entry point.</p>
<p>The interesting part is that the initial <code>import</code> happens entirely inside CPython: at
&#34;import time&#34; the RPython program can use the full power of Python to do
metaprogramming, including using decorators, metaclasses, code generation, etc.  This
works because the RPython compiler kicks in only <em>after</em> this phase ends.</p>
<p>Inside PyPy, RPython is just a tool to be able to write the &#34;full Python&#34; which we
give the end users. RPython was never meant to be used by final users, and thus its
ergonomics is very bad: it happens quite often that if you try to compile an RPython
program which contains a type error, you end up with an <code>AssertionError</code> inside the
compiler itself, or with an obscure error message.</p>
<p>Despite those shortcomings, the combination of:</p>
<ul>
<li>
<p>possibility to use an interpreter for development and debugging</p>
</li>
<li>
<p>full metaprogramming capabilities at &#34;compile time&#34;</p>
</li>
<li>
<p>static typing at runtime</p>
</li>
</ul>
<p>proved to be very nice and enjoyable to use in practice.</p>
<p>SPy takes a lot of inspiration from that. From many points of view, it can be considered
&#34;RPython 2.0&#34;. After all, the <code>S</code> stands for &#34;Static&#34; but it&#39;s also the letter after <code>R</code>
:).</p>
<h2 id="spy-putting-it-all-together">SPy: Putting It All Together<a href="#spy-putting-it-all-together" title="Permanent link">¶</a></h2>
<p>SPy aims to solve all the issues explained in the previous sections. It does so in part
by formalizing the limitations of the various &#34;subsets of Python&#34; which we saw above,
and in part by adding novel features which hopefully are as powerful as the ones which we
removed, but more suitable to performance oriented compilation.</p>
<p>The next posts of this series will cover all in great detail, but for now let&#39;s give a
hint of the main characteristics of SPy.</p>
<h3 id="static-typing-in-spy">Static typing in SPy<a href="#static-typing-in-spy" title="Permanent link">¶</a></h3>
<p>SPy&#39;s type system is designed with different goals in mind and it is more limited
compared to e.g. <code>mypy</code>, although it tries to be compatible when it makes sense. For
many of the common cases, the final user won&#39;t see any noticeable difference.</p>
<p>Types are actively enforced by the interpreter. If you try to assign a value to a
variable of an incompatible type, you get a <code>TypeError</code>.  You can opt-in and use the
<code>dynamic</code> type, but any assignment or cast to a more precise type inserts a runtime
check.</p>
<p>The typesystem is sound and if a program passes the type checker it is guaranteed not to
have <code>TypeError</code> at runtime.  The compiler can use this knowledge to generate more
efficient code.  It is guaranteed that the interpreter and the compiler produce the
exact same output.</p>
<p>This alone is an improvement over <a href="#static-typing-in-python">Static Typing in Python</a>,
as now it&#39;s guaranteed that our programs are free of type errors, and they are much
faster.  But if SPy had <strong>only</strong> a static type system, it wouldn&#39;t be much different than all the
other &#34;Python compilers&#34;.  What makes the difference are the features which <strong>enable
metaprogramming</strong> and other &#34;pythonic&#34; patterns <strong>in a type safe way</strong>.</p>
<h3 id="import-time-vs-runtime">Import time vs runtime<a href="#import-time-vs-runtime" title="Permanent link">¶</a></h3>
<p>Before launching a program SPy analyzes the source code and <strong>statically determines the
set of modules</strong> which will be imported.</p>
<p>After that, we enter what we call the <strong>import time</strong> phase and we import all the needed
modules. Things such as decorators, metaclasses and module-level initialization run in this
phase and the world is &#34;mutable as usual&#34;.</p>
<p>Then we <strong>freeze</strong> the world: all global constants are frozen and become immutable,
including modules and classes.</p>
<p>Finally, at <strong>runtime</strong> the program runs &#34;as usual&#34;, inside an immutable world.</p>
<p>This is clearly similar to what RPython does. The big difference is that RPython uses
CPython as its &#34;Import time&#34; interpreter, while SPy uses its own interpreter. A lot of
Python metaprogramming patterns fit very well in this scheme, and the experience of the
PyPy team with RPython validates this claim.</p>
<p>This is basically a formalization of some of the rules of both <code>RealPython</code> and
<code>JITPython</code>: the big advantage is that if you violate the rule you get a very clear
error message instead of a subtle slowdown.</p>
<h3 id="redshifting">Redshifting<a href="#redshifting" title="Permanent link">¶</a></h3>
<p>The other fundamental concept in SPy is <strong>redshifting</strong>.</p>
<p>Each expression is given a color:</p>
<ul>
<li>
<p><code>blue</code> expressions are those which can safely be evaluated ahead of time, because they
    don&#39;t have side effects and all operands are statically known.</p>
</li>
<li>
<p><code>red</code> expressions are those which needs to be evaluated at runtime.</p>
</li>
</ul>
<p>During <strong>redshifting</strong> we eagerly evaluate all the <code>blue</code> parts of the code: it&#39;s a form
of partial evaluation.  This process plays very well with the freezing that we discussed
above, because a lot of operations on frozen data become automatically blue: for
example, if we statically know the type of an object, the logic to look up a method
inside the frozen class hierarchy is a blue operation and it&#39;s optimized away, leaving
just a direct call as a result.</p>
<p>So far, this is not different than usual constant folding, with the difference that it&#39;s
guaranteed to happen.  What makes it more powerful is the ability to mark some functions
as <code>@blue</code>.</p>
<p>Calling a <code>@blue</code> function is always a blue operation, and the function body is executed
during redshifting. This is in a way similar to what you do with e.g. C++ templates,
with the important difference that the language that you use for metaprogramming is
exactly the same language that you use at runtime.  Moreover, the <code>@blue</code> functions are
executed by the familiar SPy interpreter, so they are much easier to debug, e.g. by
using <code>breakpoint()</code>.</p>
<p>Generics are just a special case of <code>@blue</code> functions operating on types. The syntax
<code>MyList[T]</code> is just syntax sugar over this:</p>
<div><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span>@blue</span>
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span>def</span><span> </span><span>MyList</span><span>(</span><span>T</span><span>):</span>
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>    <span>class</span><span> </span><span>_MyList</span><span>:</span>
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>        <span>items</span><span>:</span> <span>array</span><span>[</span><span>T</span><span>]</span>  <span># fictional example</span>
<a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a>        <span>...</span>
<a id="__codelineno-2-6" name="__codelineno-2-6" href="#__codelineno-2-6"></a>    <span>return</span> <span>_MyList</span>
</code></pre></div>
<div>
<p>Current status: generics</p>
<p>The syntax sugar <code>Type[T]</code> is not implemented yet, but writing generic types in
<code>@blue</code> function totally works and it&#39;s how SPy implement its own <code>list</code>, <code>dict</code> and
<code>array</code> types.</p>
</div>
<div>
<p>Zig <code>comptime</code></p>
<p>SPy <code>@blue</code> functions have <strong>lot</strong> in common to Zig&#39;s
<a href="https://ziglang.org/documentation/master/#comptime">comptime</a> feature.</p>
<p>When I originally designed SPy I didn&#39;t know about Zig (I swear!), but after showing
the initial ideas about <code>@blue</code> code, someone pointed me to Zig: I was pleasantly
surprised to see it already implemented in a very different context, because it was
an important validation that my ideas made sense.</p>
<p>Very recently I had the pleasure to meet <a href="https://andrewkelley.me/">Andrew Kelly</a>,
Zig&#39;s inventor and BDFL. We discussed details of both systems and we agreed that
they are basically equivalent, apart from some minor differences.</p>
</div>
<h3 id="static-dispatch">Static dispatch<a href="#static-dispatch" title="Permanent link">¶</a></h3>
<p>When you do <code>a + b</code> in Python, the interpreter must execute complex logic at runtime to
determine which method to call.  In SPy we do almost the same logic, but at compile
time.  Operators are implemented as a two-phase mechanism:</p>
<ol>
<li>
<p>first, we <strong>lookup the implementation</strong> by examining the information which is
     available at compile time: in particular, the <strong>static type</strong> of the operands.</p>
</li>
<li>
<p>Then, we call the implementation which we got at point (1).</p>
</li>
</ol>
<p>The trick is that phase (1) is entirely <code>blue</code>, and it&#39;s completely optimized away by
the redshifter. For example, take this code:</p>
<div><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span>def</span><span> </span><span>foo</span><span>(</span><span>x</span><span>:</span> <span>float</span><span>,</span> <span>y</span><span>:</span> <span>float</span><span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>    <span>return</span> <span>x</span> <span>+</span> <span>y</span>
</code></pre></div>
<p>After redshifting it becomes:
</p><div><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span>def</span><span> </span><span>foo</span><span>(</span><span>x</span><span>:</span> <span>float</span><span>,</span> <span>y</span><span>:</span> <span>float</span><span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>    <span>return</span> <span>`</span><span>operator</span><span>::</span><span>f64_add</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span><span>`</span>
</code></pre></div>
<p>This is a big departure from Python semantics, because we operate on the <strong>static
type</strong> of the operands, as opposed to the actual types at runtime. I believe this covers
the majority of use cases. For those cases in which you really need full dynamic
dispatch, you can opt-in by using the type <code>dynamic</code>.</p>
<p>Custom types can still override <code>__add__</code> &amp; co. and participate to this &#34;blue time&#34;
lookup logic. The details will be explained in a later post.</p>
<h2 id="conclusion">Conclusion<a href="#conclusion" title="Permanent link">¶</a></h2>
<p>Python&#39;s dynamic nature and expressivity plays a big part of why it became so popular:
it allowed power users to write all the incredible libraries with very intuitive and
high level APIs which we love.  However, such expressivity comes with many problems in
terms of performance, type safety and so on.</p>
<p>SPy attempts to fix those problems by constraining the dynamicity into well defined
places, without hurting performance.</p>
<p>In the next posts of this series, we&#39;ll dive deep into how this actually works: the type
system, the blue/red evaluation model, static dispatch, and the implementation of both
the interpreter and the compiler. We&#39;ll see concrete examples of SPy code and explore
how features like zero-cost abstractions are achieved in practice.</p>
<p><strong>Want to explore SPy yourself?</strong> Visit the <a href="https://github.com/spylang/spy">SPy repository on
GitHub</a> to see the code, try out examples, and follow
the project&#39;s development. If you have questions, want to discuss design decisions, or
are interested in contributing, join us on the <a href="https://discord.gg/wRb29FGZpP">SPy Discord
server</a>.  SPy is still early in development, and this is a
great time to get involved and help shape its future.</p>







  
  



  


  







      
    </article>
  </div>

          

        </div>
        
          
        
      </main>
      
        
      
    </div></div>
  </body>
</html>
