<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://koaning.io/posts/giving-mojo-a-spin/">Original</a>
    <h1>Python can run Mojo now</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><a href="https://www.nondot.org/sabre/">Chris Lattner</a> <a href="https://www.youtube.com/watch?v=04_gN-C9IAo&amp;list=PLWEAb1SXhjlfkEF_PxzYHonU_v5LPMI8L&amp;index=1">mentioned</a> that Python can actually call Mojo code now. I love this idea (!) as I&#39;m definitely in the market for a simple compiled language that can offer Python some really fast functions. So I gave it a quick spin</p>
<h2>Setup</h2>
<p>The setup is much simpler than I remember it, you can use <code>uv</code> for it now.</p>
<pre><code>uv pip install modular --index-url https://dl.modular.com/public/nightly/python/simple/
</code></pre>
<p>After that you can declare a <code>.mojo</code> file that looks like this:</p>
<pre><code># mojo_module.mojo
from python import PythonObject
from python.bindings import PythonModuleBuilder
import math
from os import abort

@export
fn PyInit_mojo_module() -&gt; PythonObject:
    try:
        var m = PythonModuleBuilder(&#34;mojo_module&#34;)
        m.def_function[factorial](&#34;factorial&#34;, docstring=&#34;Compute n!&#34;)
        return m.finalize()
    except e:
        return abort[PythonObject](String(&#34;error creating Python Mojo module:&#34;, e))

fn factorial(py_obj: PythonObject) raises -&gt; PythonObject:
    # Raises an exception if `py_obj` is not convertible to a Mojo `Int`.
    var n = Int(py_obj)

    var result = 1
    for i in range(1, n + 1):
        result *= i

    return result
</code></pre>
<p>And you can then load it from Python via:</p>
<pre><code># main.py
import max.mojo.importer
import os
import sys
import time 
import math
sys.path.insert(0, &#34;&#34;)

import mojo_module

start = time.time()
print(mojo_module.factorial(10))
end = time.time()
print(f&#34;Time taken: {end - start} seconds for mojo&#34;)


start = time.time()
print(math.factorial(10))
end = time.time()
print(f&#34;Time taken: {end - start} seconds for python&#34;)
</code></pre>
<p>This was the output:</p>
<pre><code>3628800
Time taken: 3.0279159545898438e-05 seconds for mojo
3628800
Time taken: 5.0067901611328125e-06 seconds for python
</code></pre>
<p>This all works, but at the time of making this blogpost I was able to spot some rough edges. If I increase the factorial number to 100 then the output changes.</p>
<pre><code>0
Time taken: 2.7894973754882812e-05 seconds for mojo
188267717688892609974376770249160085759540364871492425887598231508353156331613598866882932889495923133646405445930057740630161919341380597818883457558547055524326375565007131770880000000000000000000000000000000
Time taken: 9.298324584960938e-06 seconds for python
</code></pre>
<p>This is probably because of some overflow issues on the modular side. The docs mention that this whole stack is pretty early, and I guess this is a sign of that.</p>
<h2>Another example</h2>
<p>Given that the overflow is probably the issue here, I figured I&#39;d run one extra example just to see if we could measure a speed increase. So I went with a naive prime number counting example. This is the mojo code:</p>
<pre><code>from python import PythonObject
from python.bindings import PythonModuleBuilder
import math
from os import abort

@export
fn PyInit_mojo_module() -&gt; PythonObject:
    try:
        var m = PythonModuleBuilder(&#34;mojo_module&#34;)
        m.def_function[count_primes](&#34;count_primes&#34;, docstring=&#34;Count primes up to n&#34;)
        return m.finalize()
    except e:
        return abort[PythonObject](String(&#34;error creating Python Mojo module:&#34;, e))

fn count_primes(py_obj: PythonObject) raises -&gt; PythonObject:
    var n = Int(py_obj)
    var count: Int = 0
    for i in range(2, n + 1):
        var is_prime: Bool = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            count += 1
    return count
</code></pre>
<p>This is the Python code, note that I also added a numpy implementation for comparison.</p>
<pre><code>import numpy as np
import max.mojo.importer
import os
import sys
import time 
import math
sys.path.insert(0, &#34;&#34;)

import mojo_module

def count_primes(n):
    count = 0
    for i in range(2, n + 1):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            count += 1
    return count


def count_primes_numpy(n):
    if n &lt; 2:
        return 0
    
    candidates = np.arange(2, n + 1)
    is_prime_mask = np.ones(len(candidates), dtype=bool)
    
    # For each position in our candidates array
    for idx, candidate in enumerate(candidates):
        if candidate == 2:  # 2 is prime
            continue
            
        # Create divisors array [2, 3, ..., candidate-1]
        divisors = np.arange(2, candidate)
        
        # Vectorized divisibility check
        has_divisor = np.any(candidate % divisors == 0)
        
        if has_divisor:
            is_prime_mask[idx] = False
    
    return np.sum(is_prime_mask)

n = 20_000

start = time.time()
print(count_primes(n))
end = time.time()
print(f&#34;Time taken: {end - start} seconds for python&#34;)

start = time.time()
print(count_primes_numpy(n))
end = time.time()
print(f&#34;Time taken: {end - start} seconds for numpy&#34;)

start = time.time()
print(mojo_module.count_primes(n))
end = time.time()
print(f&#34;Time taken: {end - start} seconds for mojo&#34;)
</code></pre>
<p>The results look promising!</p>
<pre><code>2262
Time taken: 0.44585609436035156 seconds for python
2262
Time taken: 0.25995898246765137 seconds for numpy
2262
Time taken: 0.011101961135864258 seconds for mojo
</code></pre>
<p>There are better algorithms for prime counting compared to what I am doing here, so take this with a truck of salt, but this is <em>very</em> exciting. Mojo is a lot easier to learn than Rust, but I seem to get the function speedup that I want (need).</p>
<p>At the time of writing the main downside is that the modular stack is still <a href="https://docs.modular.com/mojo/manual/python/mojo-from-python/#known-limitations">early</a>, but there also seems to be light support for <a href="https://docs.modular.com/mojo/manual/python/mojo-from-python/#building-mojo-extension-modules">building these extensions</a>.</p>
<p>In short: it&#39;s not ready for prime-time just yet, but I&#39;m more optimistic now that the dream is getting within reach!</p>
</div></div>
  </body>
</html>
