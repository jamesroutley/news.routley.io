<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evalapply.org/posts/dismal-arithmetic-dyalog-apl-clojure/">Original</a>
    <h1>Dismal Arithmetic in Dyalog APL and Clojure</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<p>Throwback: Jan 2018.</p>
<p>I learned of something called <em><a href="https://arxiv.org/abs/1107.1130">Dismal Arithmetic</a></em>. As the linked paper describes it:</p>
<blockquote>
<p>Dismal arithmetic is just like the arithmetic you learned in school, only
simpler: there are no carries, when you add digits you just take the largest,
and when you multiply digits you take the smallest. This paper studies basic
number theory in this world, including analogues of the primes, number of
divisors, sum of divisors, and the partition function.</p>
</blockquote>
<p>I thought it might be fun to implement it in APL for kicks, but I wrote it in
Clojure first, because I wasn’t sure of my APL-fu. And I’m glad I wrote the
Dyalog APL version because I learned something about trains, and also because
I stumbled on the idea of “inverse of a function” which melted my mind a bit.</p>
<ul>
<li><a href="#examples-of-dismal-addition-and-multiplication">Examples of Dismal Addition and Multiplication</a></li>
<li><a href="#dismal-arithmetic-in-clojure">Dismal Arithmetic in Clojure</a></li>
<li><a href="#dismal-arithmetic-in-dyalog-apl">Dismal Arithmetic in Dyalog APL</a></li>
<li><a href="#addendum-the-of-inverse">Addendum: The ⍣ of inverse</a></li>
</ul>
<hr/>
<h2 id="examples-of-dismal-addition-and-multiplication">Examples of Dismal Addition and Multiplication<a href="#examples-of-dismal-addition-and-multiplication" arialabel="Anchor">⌗</a> </h2>
<p>OK, so first, a disclaimer. The code doesn’t explore all of the paper, just
addition, multiplication along with commutative, associative, distributive
properties thereof, because that’s all the Mathematics I understand :) I had
fun struggling through the paper anyway mainly because of the funny name.
(More papers should have more wryness and less dryness.)</p>
<p>Anyway, the rules of the game are:</p>
<ul>
<li>arithmetic as in school, except that</li>
<li>there there are no carries,</li>
<li>when you add digits you just take the largest,</li>
<li>and when you multiply digits you take the smallest</li>
</ul>
<p>Dismal addition: 169 + 248 = 269, because…</p>
<div><pre tabindex="0"><code data-lang="text">  1 6 9
+ 2 4 8
-------
  2 6 9
</code></pre></div><p>Dismal Multiplication: 169 * 248 = 12468, because…</p>
<div><pre tabindex="0"><code data-lang="text">   1 6 9
 x 2 4 8
---------
   1 6 8
  1 4 4
1 2 2
---------
1 2 4 6 8
</code></pre></div><p>The tasks:</p>
<ul>
<li>Write function for dismal addition
<ul>
<li>Takes two positive integer returns dismal sum</li>
</ul>
</li>
<li>Write function for dismal multiplication
<ul>
<li>Takes two positive integer returns dismal multiplication</li>
</ul>
</li>
</ul>
<h2 id="dismal-arithmetic-in-clojure">Dismal Arithmetic in Clojure<a href="#dismal-arithmetic-in-clojure" arialabel="Anchor">⌗</a> </h2>
<p>Here I explored the basic properties of addition and multiplication. Yeah,
sorry got to slog through some encoding/decoding prerequisites first.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>ns </span>dismal-arithmetic)

(<span>defn </span>n-&gt;digits
  <span>&#34;Really dismal :sobbing:
</span><span>   Will turn the number 12345 into the sequence (1 2 3 4 5).&#34;</span>
  [n]
  (<span>loop </span>[n n
         xs (<span>list</span>)]
    (<span>if </span>(&lt; n <span>10</span>) <span>; ensure we split 10 also, into 1 and 0</span>
      (conj xs (-&gt; n Math/floor Math/round))
      (<span>recur</span> (/ n <span>10</span>)
             (conj xs
                   (-&gt; n (rem <span>10</span>) Math/floor Math/round))))))

<span>;; Check...</span>
<span>#</span>_(map n-&gt;digits [<span>169</span> <span>248</span> <span>100</span> <span>10</span> <span>1</span> <span>0</span>])


(<span>defn </span>digits-&gt;n
  <span>&#34;Will turn the sequence (1 2 3 4 5) into the number 12345.&#34;</span>
  [dxs]
  (reduce (<span>fn </span>[r dx] (+ (* r <span>10</span>) dx))
          dxs))


(<span>defn </span>dismal-add
  <span>&#34;x and y can have any number of digits&#34;</span>
  [x y]
  (<span>let </span>[nxs (<span>n-&gt;digits</span> x)
        nys (<span>n-&gt;digits</span> y)
        cxs (count nxs)
        cys (count nys)
        dxys (<span>Math/abs</span> (- cxs cys))
        dzs (repeat dxys <span>0</span>)
        [nxs nys] (<span>if </span>(&gt; cxs cys)
                    [nxs            (concat dzs nys)]
                    [(concat dzs nxs) nys])]
    (<span>-&gt;&gt;</span> nys
         (map max nxs)
         digits-&gt;n)))


(<span>defn </span>dismal-mul
  <span>&#34;Like politics and war, multiplication is just addition
</span><span>   by other means. No?&#34;</span>
  [x y]
  (<span>let </span>[nxs (<span>n-&gt;digits</span> x)
        nys (<span>n-&gt;digits</span> y)
        diagonal-summable
        (reduce (<span>fn </span>[rs y]
                  (conj rs (map <span>#</span>(min y %) nys)))
                []
                nxs)
        transpose-matrix (<span>fn </span>[matrix]
                           (into []
                                 (apply map vector matrix)))
        summable-matrix (<span>transpose-matrix</span> diagonal-summable)
        summables (reverse (map digits-&gt;n summable-matrix))
        summables (<span>map-indexed</span> (<span>fn </span>[idx x]
                                 (* x (<span>Math/round</span> (<span>Math/pow</span> <span>10</span> idx))))
                               summables)]
    (reduce dismal-add summables)))


(<span>comment</span>
  <span>;; Given test cases:</span>
  (= (<span>dismal-add</span> <span>169</span> <span>248</span>)
     <span>269</span>)

  (= (<span>dismal-mul</span> <span>169</span> <span>248</span>)
     <span>12468</span>)

  <span>;; Other numbers:</span>
  (<span>dismal-add</span> <span>123</span> <span>45678</span>)
  (<span>dismal-mul</span> <span>123</span> <span>45678</span>)


  <span>;; Associative?</span>

  (= (<span>dismal-add</span> <span>169</span> (<span>dismal-add</span> <span>248</span> <span>100</span>))
     (<span>dismal-add</span> (<span>dismal-add</span> <span>169</span> <span>248</span>) <span>100</span>))

  (= (<span>dismal-mul</span> <span>169</span> (<span>dismal-mul</span> <span>248</span> <span>100</span>))
     (<span>dismal-mul</span> (<span>dismal-mul</span> <span>169</span> <span>248</span>) <span>100</span>))


  <span>;; Commutative?</span>

  (= (reduce dismal-add [<span>169</span> <span>248</span> <span>12345</span>])
     (reduce dismal-add [<span>248</span> <span>12345</span> <span>169</span>])
     (reduce dismal-add [<span>12345</span> <span>169</span> <span>248</span>]))

  (= (reduce dismal-mul [<span>169</span> <span>248</span> <span>12345</span>])
     (reduce dismal-mul [<span>248</span> <span>12345</span> <span>169</span>])
     (reduce dismal-mul [<span>12345</span> <span>169</span> <span>248</span>]))


  <span>;; Distributive?</span>

  (= (<span>dismal-mul</span> <span>100</span>
                 (<span>dismal-add</span> <span>169</span> <span>248</span>))

     (<span>dismal-add</span> (<span>dismal-mul</span> <span>100</span> <span>169</span>)
                 (<span>dismal-mul</span> <span>100</span> <span>248</span>)))
  )
</code></pre></div><h2 id="dismal-arithmetic-in-dyalog-apl">Dismal Arithmetic in Dyalog APL<a href="#dismal-arithmetic-in-dyalog-apl" arialabel="Anchor">⌗</a> </h2>
<p>Here, I managed to implement addition, discovered how to write “inverse of a
function” and my mind melted.</p>
<pre tabindex="0"><code data-lang="dyalog">      da ← 10⊥(⌈/10⊥⍣¯1⊢)
      da 169 248
269
</code></pre><p>Yes, that’s the entire solution to dismal addition. <code>⍣¯1</code> is APL for “inverse”.
Here is the solution explained in parts. I first did it with dfns, because my
brain is stuck inside Lisp / traditional functional programming style.</p>
<p>Apart from built-in support for numeric encoding/decoding, notice the automatic
zero-padding.</p>
<pre tabindex="0"><code data-lang="dyalog">      {10(⊤⍣¯1)⍵}∘{⌈/⍵}∘{10(⊥⍣¯1)⍵}⊢ 100000 10000 1000 100 10 1
111111

      {10(⊤⍣¯1)⍵}∘{⌈/⍵}∘{10(⊥⍣¯1)⍵}⊢ 1 10 100 1000 10000 100000
111111

      da ← 10⊥(⌈/10⊥⍣¯1⊢)

      da 1 10 100 1000 10000 100000
111111
</code></pre><p><em>However</em>, there is something deeply unsatisfying about using dfns in APL, when
you know trains exist.</p>
<p>So I muddled about and managed to express the whole idea as a single unit, viz.
this lovely little expression <code>10⊥(⌈/10⊥⍣¯1⊢)</code> which says “Dismal Arithmetic”
in fewer characters than the name <em>and is also</em> a working partial implementation.
Here is how it breaks down in my FP-addled brain:</p>
<pre tabindex="0"><code data-lang="dyalog">decode ← 10(⊥⍣¯1)⊢

reducemax ← ⌈/

encode ← 10(⊤⍣¯1)⊢

encode reducemax decode 169 248
269
</code></pre><h2 id="addendum-the-of-inverse">Addendum: The ⍣ of inverse<a href="#addendum-the-of-inverse" arialabel="Anchor">⌗</a> </h2>
<p>Aaaron Hsu helped me understand what was going on, and wrote about
“<a href="https://www.sacrideo.us/decoding-inverses/">Decoding Inverses</a>” at his blog.</p>
</div></div></div>
  </body>
</html>
