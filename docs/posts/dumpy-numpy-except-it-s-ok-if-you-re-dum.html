<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dynomight.net/dumpy/">Original</a>
    <h1>DumPy: NumPy except it&#39;s OK if you&#39;re dum</h1>
    
    <div id="readability-page-1" class="page"><div>
  
    
  <section>
    <p>What I want from an array language is:</p>

<ol>
  <li>Don’t make me think.</li>
  <li>Run fast on GPUs.</li>
  <li>Really, do not make me think.</li>
  <li>Do <em>not</em>.</li>
</ol>

<p>I say NumPy misses on three of these. So I’d like to propose a “fix” that—I claim—eliminates 90% of unnecessary thinking, with no loss of power. It would also fix all the things based on NumPy, for example every machine learning library.</p>

<p>I know that sounds grandiose. Quite possibly you’re thinking that good-old dynomight has finally lost it. So I warn you now: My solution is utterly non-clever. If anything is clever here, it’s my single-minded rejection of cleverness.</p>

<p>To motivate the fix, let me give my story for how NumPy went wrong. It started as a nice little library for array operations and linear algebra. When everything has two or fewer dimensions, it’s great. But at some point, someone showed up with some higher-dimensional arrays. If loops were fast in Python, NumPy would have said, “Hello person with ≥3 dimensions, please call my ≤2 dimensional functions in a loop so I can stay nice and simple, xox, NumPy.”</p>

<p>But since loops are slow, NumPy instead took all the complexity that would <em>usually</em> be addressed with loops and pushed it down into individual functions. I think this was a disaster, because <em>every time</em> you see some function call like <code>np.func(A,B)</code>, you have to think:</p>

<ol>
  <li>OK, what shapes do all those arrays have?</li>
  <li>And what does <code>np.func</code> do when it sees those shapes?</li>
</ol>

<p>Different functions have different rules. Sometimes they’re bewildering. This means constantly thinking and constantly moving dimensions around to appease the whims of particular functions. It’s the <em>functions</em> that should be appeasing <em>your</em> whims!</p>

<p>Even simple-looking things like <code>A*B</code> or <code>A[B,C]</code> do quite different things depending on the starting shapes. And those starting shapes are often themselves the output of <em>previous</em> functions, so the complexity spirals.</p>

<p>Worst of all, if you write a new ≤2 dimensional function, then high-dimensional arrays are your problem. <em>You</em> need to decide what rules to obey, and then <em>you</em> need to re-write your function in a much more complex way to—</p>

<p><strong>Voice from the back</strong>: Python sucks! If you used a real language, loops would be fast! This problem is stupid!</p>

<p>That was a strong argument, ten years ago. But now everything is GPU, and GPUs hate loops. Today, array packages are cheerful interfaces that <em>look</em> like Python (or whatever) but are actually embedded languages that secretly compile everything into special GPU instructions that run on whole arrays in parallel. With big arrays, you need GPUs. So I think the speed of the host language doesn’t matter so much anymore.</p>

<p>Python’s slowness may have paradoxically turned out to be an <em>advantage</em>, since it forced everything to be designed to work without loops even before GPUs took over.</p>

<p>Still, thinking is bad, and NumPy makes me think, so <a href="https://dynomight.net/numpy/">I don’t like NumPy</a>.</p>

<h2 id="so-whats-the-fix">So what’s the fix?</h2>

<p>Here’s my extremely non-clever idea: Let’s just admit that loops were better. In high dimensions, no one has yet come up with a notation that beats loops and indices. So, let’s do this:</p>

<ol>
  <li>Bring back the syntax of loops and indices.</li>
  <li>But don’t actually <em>execute</em> the loops. Just take the syntax and secretly compile it into vectorized operations.</li>
  <li>Also, let’s get rid of all the insanity that’s been added to NumPy because loops were slow.</li>
</ol>

<p>That’s basically the whole idea. If you take those three bullet-points, you could probably re-derive everything I do below. I told you this wasn’t clever.</p>

<h2 id="what-does-it-look-like">What does it look like?</h2>

<p>Suppose that <code>X</code> and <code>Y</code> are 2D arrays, and <code>A</code> is a 4D array. And suppose you want to find a 2D array <code>Z</code> such that <code>Z<sub>ij</sub> = (Y<sub>j</sub>)<sup>T</sup> (A<sub>ij</sub>)<sup>-1</sup> X<sub>i</sub></code>. If you could write loops, this would be easy:</p>

<div><div><pre><code><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>Z</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>],</span> <span>Y</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]))</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]):</span>
    <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>Y</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]):</span>
        <span>Z</span><span>[</span><span>i</span><span>,</span><span>j</span><span>]</span> <span>=</span> <span>Y</span><span>[</span><span>j</span><span>]</span> <span>@</span> <span>np</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>A</span><span>[</span><span>i</span><span>,</span><span>j</span><span>],</span> <span>X</span><span>[</span><span>i</span><span>])</span>
</code></pre></div></div>

<p>That’s not pretty. It’s not short or fast. But it <em>is</em> easy!</p>

<p>Meanwhile, how do you do this efficiently in NumPy? Like this:</p>

<div><div><pre><code><span>AiX</span> <span>=</span> <span>np</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>A</span><span>.</span><span>transpose</span><span>(</span><span>1</span><span>,</span><span>0</span><span>,</span><span>2</span><span>,</span><span>3</span><span>),</span>
                      <span>X</span><span>[</span><span>None</span><span>,...,</span><span>None</span><span>])[...,</span><span>0</span><span>]</span>
<span>Z</span> <span>=</span> <span>np</span><span>.</span><span>sum</span><span>(</span><span>AiX</span> <span>*</span> <span>Y</span><span>[:,</span><span>None</span><span>],</span> <span>axis</span><span>=-</span><span>1</span><span>).</span><span>T</span>
</code></pre></div></div>

<p>If you’re not a NumPy otaku, that may look like outsider art. Rest assured, it looks like that to me too, and I just wrote it. Why is it so confusing? At a high level, it’s because <code>np.linalg.solve</code> and <code>np.sum</code> and multiplication (<code>*</code>) have complicated rules and weren’t designed to work together to solve this particular problem nicely. That would be impossible, because there are an infinite number of problems. So you need to mash the arrays around a lot to make those functions happy.</p>

<p>Without further ado, here’s how you solve this problem with <strong>DumPy</strong> (ostensibly <strong>D</strong>ynomight N<strong>umPy</strong>):</p>

<div><div><pre><code><span>import</span> <span>dumpy</span> <span>as</span> <span>dp</span>
<span>A</span> <span>=</span> <span>dp</span><span>.</span><span>Array</span><span>(</span><span>A</span><span>)</span>
<span>X</span> <span>=</span> <span>dp</span><span>.</span><span>Array</span><span>(</span><span>X</span><span>)</span>
<span>Y</span> <span>=</span> <span>dp</span><span>.</span><span>Array</span><span>(</span><span>Y</span><span>)</span>
<span>Z</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>Z</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>]</span> <span>=</span> <span>Y</span><span>[</span><span>&#39;j&#39;</span><span>,:]</span> <span>@</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>A</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>,:,:],</span> <span>X</span><span>[</span><span>&#39;i&#39;</span><span>,:])</span>
</code></pre></div></div>

<p>Yes! If you prefer, you can also use this equivalent syntax:</p>

<div><div><pre><code><span>Z</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>])</span> <span>as</span> <span>i</span><span>:</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>Y</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>])</span> <span>as</span> <span>j</span><span>:</span>
        <span>Z</span><span>[</span><span>i</span><span>,</span><span>j</span><span>]</span> <span>=</span> <span>Y</span><span>[</span><span>j</span><span>,:]</span> <span>@</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>A</span><span>[</span><span>i</span><span>,</span><span>j</span><span>,:,:],</span> <span>X</span><span>[</span><span>i</span><span>,:])</span>
</code></pre></div></div>

<p>Those are both fully vectorized. No loops are executed behind the scenes. They’ll run on a GPU if you have one.</p>

<h2 id="but-how">But how?</h2>

<p>While it looks magical, the way this actually works is fairly simple:</p>

<ol>
  <li>
    <p>If you index a DumPy array with a string (or a <code>dp.Range</code> object), it creates a special “mapped” array that pretends to have fewer dimensions.</p>
  </li>
  <li>
    <p>When a DumPy function is called (e.g. <code>dp.linalg.solve</code> or <code>dp.matmul</code> (called with <code>@</code>)), it checks if any of the arguments have mapped dimensions. If so, it automatically vectorizes the computation, matching up mapped dimensions that share labels.</p>
  </li>
  <li>
    <p>When you assign an array with “mapped” dimensions to a <code>dp.Slot</code>, it “unmaps” them into the positions you specify.</p>
  </li>
</ol>

<p>No evil meta-programming abstract syntax tree macro bytecode interception is needed. When you run this code:</p>

<div><div><pre><code><span>Z</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>Z</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>]</span> <span>=</span> <span>Y</span><span>[</span><span>&#39;j&#39;</span><span>,:]</span> <span>@</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>A</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>,:,:],</span> <span>X</span><span>[</span><span>&#39;i&#39;</span><span>,:])</span>
</code></pre></div></div>

<p>This is what happens behind the scenes:</p>

<div><div><pre><code><span>a</span> <span>=</span> <span>A</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>,</span> <span>1</span><span>],</span> <span>[</span><span>&#39;i&#39;</span><span>,</span> <span>&#39;j&#39;</span><span>])</span>
<span>x</span> <span>=</span> <span>X</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>],</span> <span>[</span><span>&#39;i&#39;</span><span>])</span>
<span>y</span> <span>=</span> <span>Y</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>],</span> <span>[</span><span>&#39;j&#39;</span><span>])</span>
<span>z</span> <span>=</span> <span>y</span> <span>@</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>a</span><span>,</span> <span>x</span><span>)</span>
<span>Z</span> <span>=</span> <span>z</span><span>.</span><span>unmap</span><span>(</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>)</span>
</code></pre></div></div>

<details>
  <summary>
(Click here for a version with a million asserts and comments.)
</summary>

  <div><div><pre><code><span># first map A
</span><span>a</span> <span>=</span> <span>A</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>,</span> <span>1</span><span>],</span> <span>[</span><span>&#39;i&#39;</span><span>,</span> <span>&#39;j&#39;</span><span>])</span>
<span>assert</span> <span>A</span><span>.</span><span>ndim</span> <span>==</span> <span>4</span>
<span>assert</span> <span>a</span><span>.</span><span>ndim</span> <span>==</span> <span>2</span>             <span># pretends to have fewer dims
</span><span>assert</span> <span>a</span><span>.</span><span>data</span><span>.</span><span>shape</span> <span>==</span> <span>A</span><span>.</span><span>shape</span>          <span># secret mapped data
</span><span>assert</span> <span>a</span><span>.</span><span>axes</span> <span>==</span> <span>(</span><span>&#39;i&#39;</span><span>,</span> <span>&#39;j&#39;</span><span>,</span> <span>None</span><span>,</span> <span>None</span><span>)</span> <span># secret mapped axes
</span><span>assert</span> <span>a</span><span>.</span><span>shape</span> <span>==</span> <span>(</span><span>a</span><span>.</span><span>data</span><span>.</span><span>shape</span><span>[</span><span>2</span><span>],</span> <span>a</span><span>.</span><span>data</span><span>.</span><span>shape</span><span>[</span><span>3</span><span>])</span>
                <span># shape determined by non-mapped (None) axes
</span>
<span># now map X
</span><span>x</span> <span>=</span> <span>X</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>],</span> <span>[</span><span>&#39;i&#39;</span><span>])</span>
<span>assert</span> <span>X</span><span>.</span><span>ndim</span> <span>==</span> <span>2</span>
<span>assert</span> <span>x</span><span>.</span><span>ndim</span> <span>==</span> <span>1</span>
<span>assert</span> <span>x</span><span>.</span><span>data</span><span>.</span><span>shape</span> <span>==</span> <span>X</span><span>.</span><span>shape</span>
<span>assert</span> <span>x</span><span>.</span><span>axes</span> <span>==</span> <span>(</span><span>&#39;i&#39;</span><span>,</span> <span>None</span><span>)</span>
<span>assert</span> <span>x</span><span>.</span><span>shape</span> <span>==</span> <span>(</span><span>x</span><span>.</span><span>data</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>],</span> <span>)</span>

<span># now map Y
</span><span>y</span> <span>=</span> <span>Y</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>],</span> <span>[</span><span>&#39;j&#39;</span><span>])</span>
<span>assert</span> <span>Y</span><span>.</span><span>ndim</span> <span>==</span> <span>2</span>
<span>assert</span> <span>y</span><span>.</span><span>ndim</span> <span>==</span> <span>1</span>
<span>assert</span> <span>y</span><span>.</span><span>shape</span> <span>==</span> <span>(</span><span>Y</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>],)</span>
<span>assert</span> <span>y</span><span>.</span><span>axes</span> <span>==</span> <span>(</span><span>&#39;j&#39;</span><span>,</span> <span>None</span><span>)</span>
<span>assert</span> <span>y</span><span>.</span><span>data</span><span>.</span><span>shape</span> <span>==</span> <span>Y</span><span>.</span><span>shape</span>
<span>assert</span> <span>y</span><span>.</span><span>shape</span> <span>==</span> <span>(</span><span>y</span><span>.</span><span>data</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>],)</span>

<span># Actually do the computation. It happens that the &#39;j&#39;
# dimension is stored first because its found first (in y).
# But you never need to think about that!
</span><span>z</span> <span>=</span> <span>y</span> <span>@</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>a</span><span>,</span> <span>x</span><span>)</span>
<span>assert</span> <span>z</span><span>.</span><span>ndim</span> <span>==</span> <span>0</span>
<span>assert</span> <span>z</span><span>.</span><span>shape</span> <span>==</span> <span>()</span>
<span>assert</span> <span>z</span><span>.</span><span>axes</span> <span>==</span> <span>(</span><span>&#39;j&#39;</span><span>,</span><span>&#39;i&#39;</span><span>)</span>
<span>assert</span> <span>z</span><span>.</span><span>data</span><span>.</span><span>shape</span> <span>==</span> <span>(</span><span>Y</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>],</span> <span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>])</span>

<span># unmap the mapped axes
</span><span>Z</span> <span>=</span> <span>z</span><span>.</span><span>unmap</span><span>(</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>)</span>
<span>assert</span> <span>Z</span><span>.</span><span>ndim</span> <span>==</span> <span>2</span>
<span>assert</span> <span>Z</span><span>.</span><span>shape</span> <span>==</span> <span>(</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>],</span> <span>Y</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>])</span>
</code></pre></div>  </div>

</details>

<h2 id="wait-but-how">Wait, but <em>how</em>?</h2>

<p>It might seem like I’ve skipped the hard part. How does <code>dp.linalg.solve</code> know how to vectorize over any combination of input dimensions? Don’t I need to do that for every single function that DumPy includes? Isn’t that hard?</p>

<p>It <em>is</em> hard, but <a href="https://docs.jax.dev/en/latest/_autosummary/jax.vmap.html"><code>jax.vmap</code></a> did it already. This takes a function defined using (<a href="https://github.com/jax-ml/jax">JAX</a>’s version of) NumPy and vectorizes it over <em>any</em> set of input dimensions. DumPy relies on this to do all the actual vectorization. (If you prefer your <code>vmap</code> janky and broken, I heartily recommend PyTorch’s <a href="https://docs.pytorch.org/docs/stable/generated/torch.vmap.html"><code>torch.vmap</code></a>.)</p>

<p>But hold on. If <code>vmap</code> already exists, then why do we need DumPy? Here’s why:</p>

<div><div><pre><code><span>import</span> <span>jax</span>
<span>from</span> <span>jax</span> <span>import</span> <span>numpy</span> <span>as</span> <span>jnp</span>
<span>Z</span> <span>=</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span>
        <span>jax</span><span>.</span><span>vmap</span><span>(</span>
            <span>lambda</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>a</span><span>:</span> <span>y</span> <span>@</span> <span>jnp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>a</span><span>,</span> <span>x</span><span>),</span>
            <span>in_axes</span><span>=</span><span>[</span><span>None</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span>
        <span>),</span>
        <span>in_axes</span><span>=</span><span>[</span><span>0</span><span>,</span> <span>None</span><span>,</span> <span>0</span><span>]</span>
    <span>)(</span><span>X</span><span>,</span> <span>Y</span><span>,</span> <span>A</span><span>)</span>
</code></pre></div></div>

<p>That’s how you solve the same problem with <code>vmap</code>. (It’s also basically what DumPy does behind the scenes.)</p>

<p>I think <code>vmap</code> is one of the best parts of the NumPy ecosystem. I think the above code is genuinely better than the base NumPy version. But it still involves a lot of thinking! Why put <code>in_axes=[None, 0, 0]</code> in the inner <code>vmap</code> and <code>in_axes=[0, None, 0]</code> in the outer one? Why are all the axes <code>0</code> even though you need to vectorize over the second dimension of <code>A</code>? There are answers, but they require thinking. Loops and indices are better.</p>

<h2 id="a-tiny-bit-of-cleverness">A tiny bit of cleverness</h2>

<p>OK, I did do one thing that’s a <em>little</em> clever. Say you want to create a <a href="https://en.wikipedia.org/wiki/Hilbert_matrix">Hilbert matrix</a> with <code>H<sub>ij</sub> = 1/(1+i+j)</code>. In base NumPy you’d have to do this:</p>

<div><div><pre><code><span>X</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>1</span> <span>+</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>5</span><span>)[:,</span><span>None</span><span>]</span> <span>+</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>5</span><span>)[</span><span>None</span><span>,:])</span> <span># hurr?
</span></code></pre></div></div>

<p>In DumPy, you can just write:</p>

<div><div><pre><code><span>X</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>5</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>5</span><span>)</span> <span>as</span> <span>j</span><span>:</span>
        <span>X</span><span>[</span><span>i</span><span>,</span><span>j</span><span>]</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>i</span> <span>+</span> <span>j</span> <span>+</span> <span>1</span><span>)</span>
</code></pre></div></div>

<p>Yes! That works! It works because a <code>dp.Range</code> acts <em>both</em> like a string and like an array mapped along that string. So the above code is roughly equivalent to:</p>

<div><div><pre><code><span>I</span> <span>=</span> <span>dp</span><span>.</span><span>Array</span><span>([</span><span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>])</span>
<span>J</span> <span>=</span> <span>dp</span><span>.</span><span>Array</span><span>([</span><span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>])</span>
<span>X</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>X</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>]</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>1</span> <span>+</span> <span>I</span><span>[</span><span>&#39;i&#39;</span><span>]</span> <span>+</span> <span>J</span><span>[</span><span>&#39;j&#39;</span><span>])</span>
</code></pre></div></div>

<details>
  <summary>See? Still no magic.</summary>

  <p>In reality, the <code>dp.Range</code> choose random strings. (The class maintains a stack of active ranges to prevent collisions.) So in more detail, the above code becomes something like this:</p>

  <div><div><pre><code><span>I</span> <span>=</span> <span>dp</span><span>.</span><span>Array</span><span>([</span><span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>])</span>
<span>J</span> <span>=</span> <span>dp</span><span>.</span><span>Array</span><span>([</span><span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>])</span>
<span>i</span> <span>=</span> <span>I</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>],</span><span>&#39;range_EZaW&#39;</span><span>)</span>
<span>j</span> <span>=</span> <span>J</span><span>.</span><span>map_axes</span><span>([</span><span>0</span><span>],</span><span>&#39;range_ailw&#39;</span><span>)</span>
<span>x</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>1</span> <span>+</span> <span>i</span> <span>+</span> <span>j</span><span>)</span> <span># vectorized
</span><span>X</span> <span>=</span> <span>x</span><span>.</span><span>unmap</span><span>(</span><span>&#39;range_EZaW&#39;</span><span>,</span><span>&#39;range_ailw&#39;</span><span>)</span>
</code></pre></div>  </div>
</details>

<h2 id="ok-but-is-it-actually-better">OK but is it actually better?</h2>

<p>To test if DumPy is actually better in practice, I took six problems of increasing complexity and implemented each of them using loops, Numpy, JAX (with <code>vmap</code>), and DumPy.</p>

<details>
  

  <p>Note that in these examples, I always assume the input arrays are in the class of the system being used. If you try running them, you’ll need to add some conversions with <code>np.array</code> / <code>jnp.array</code> / <code>dp.Array</code>.</p>

  <div><div><pre><code><span># loops
</span><span>H</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>N</span><span>,</span> <span>N</span><span>))</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>N</span><span>):</span>
    <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>N</span><span>):</span>
        <span>H</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>]</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>i</span> <span>+</span> <span>j</span> <span>+</span> <span>1</span><span>)</span>

<span># NumPy
</span><span>i</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>N</span><span>)</span>
<span>j</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>N</span><span>)</span>
<span>H</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>i</span><span>[:,</span> <span>None</span><span>]</span> <span>+</span> <span>j</span><span>[</span><span>None</span><span>,</span> <span>:]</span> <span>+</span> <span>1</span><span>)</span>

<span># JAX
</span><span>indices</span> <span>=</span> <span>jnp</span><span>.</span><span>arange</span><span>(</span><span>N</span><span>)</span>
<span>H</span> <span>=</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span>
        <span>jax</span><span>.</span><span>vmap</span><span>(</span>
            <span>lambda</span> <span>i</span><span>,</span> <span>j</span><span>:</span> <span>1</span> <span>/</span> <span>(</span><span>i</span> <span>+</span> <span>j</span> <span>+</span> <span>1</span><span>),</span>
            <span>[</span><span>0</span><span>,</span> <span>None</span><span>]),</span>
        <span>[</span><span>None</span><span>,</span> <span>0</span><span>]</span>
    <span>)(</span><span>indices</span><span>,</span> <span>indices</span><span>)</span>

<span># DumPy
</span><span>H</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>N</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>N</span><span>)</span> <span>as</span> <span>j</span><span>:</span>
        <span>H</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>]</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>i</span> <span>+</span> <span>j</span> <span>+</span> <span>1</span><span>)</span> <span># Yes! This works!
</span></code></pre></div>  </div>
</details>

<details>
  

  <div><div><pre><code><span># Loops
</span><span>C</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>((</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>],</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>],</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>]))</span>
<span>for</span> <span>n</span> <span>in</span> <span>range</span><span>(</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]):</span>
    <span>C</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>np</span><span>.</span><span>cov</span><span>(</span><span>X</span><span>[</span><span>n</span><span>])</span>

<span># NumPy
</span><span>mu</span> <span>=</span> <span>np</span><span>.</span><span>mean</span><span>(</span><span>X</span><span>,</span> <span>axis</span><span>=</span><span>2</span><span>)[:,</span> <span>:,</span> <span>None</span><span>]</span>    <span># hurr?
</span><span>C</span> <span>=</span> <span>np</span><span>.</span><span>sum</span><span>((</span><span>X</span> <span>-</span> <span>mu</span><span>)[:,</span> <span>None</span><span>,</span> <span>:,</span> <span>:]</span> <span>*</span>
           <span>(</span><span>X</span> <span>-</span> <span>mu</span><span>)[:,</span> <span>:,</span> <span>None</span><span>,</span> <span>:],</span>
           <span>axis</span><span>=</span><span>3</span><span>)</span> <span>/</span> <span>(</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>2</span><span>]</span> <span>-</span> <span>1</span><span>)</span>  <span># hurrr??
</span>
<span># JAX
</span><span>C</span> <span>=</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span><span>jnp</span><span>.</span><span>cov</span><span>)(</span><span>X</span><span>)</span>

<span># DumPy
</span><span>C_dumpy</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>X</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>])</span> <span>as</span> <span>n</span><span>:</span>
    <span>C_dumpy</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span> <span>=</span> <span>dp</span><span>.</span><span>cov</span><span>(</span><span>X</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:])</span>

<span># DumPy (alternate)
</span><span>C</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>C</span><span>[</span><span>&#39;n&#39;</span><span>,:,:]</span> <span>=</span> <span>dp</span><span>.</span><span>cov</span><span>(</span><span>X</span><span>[</span><span>&#39;n&#39;</span><span>,:,:])</span>
</code></pre></div>  </div>

</details>

<details>
  

  <p>(Pretending <a href="https://numpy.org/devdocs/reference/generated/numpy.lib.stride_tricks.html"><code>numpy.lib.stride_tricks</code></a> doesn’t exist.)</p>

  <div><div><pre><code><span># Loops
</span><span>B</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>(</span><span>N</span> <span>-</span> <span>window</span> <span>+</span> <span>1</span><span>)</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>N</span> <span>-</span> <span>window</span> <span>+</span> <span>1</span><span>):</span>
    <span>B</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>np</span><span>.</span><span>mean</span><span>(</span><span>A</span><span>[</span><span>i</span><span>:</span><span>i</span> <span>+</span> <span>window</span><span>])</span>

<span># NumPy
</span><span>i</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>N</span> <span>-</span> <span>window</span> <span>+</span> <span>1</span><span>)[:,</span> <span>None</span><span>]</span>
<span>j</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>window</span><span>)[</span><span>None</span><span>,</span> <span>:]</span> 
<span>B</span> <span>=</span> <span>np</span><span>.</span><span>mean</span><span>(</span><span>A</span><span>[</span><span>i</span><span>+</span><span>j</span><span>],</span> <span>axis</span><span>=-</span><span>1</span><span>)</span>

<span># JAX
</span><span>idx</span> <span>=</span> <span>jnp</span><span>.</span><span>arange</span><span>(</span><span>window</span><span>)</span>
<span>B</span> <span>=</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span>
        <span>lambda</span> <span>i</span><span>:</span> <span>jnp</span><span>.</span><span>mean</span><span>(</span><span>A</span><span>[</span><span>i</span><span>+</span><span>idx</span><span>]),</span>
    <span>)(</span><span>jnp</span><span>.</span><span>arange</span><span>(</span><span>N</span> <span>-</span> <span>window</span> <span>+</span> <span>1</span><span>))</span>

<span># DumPy
</span><span>windowed</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>B</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>N</span> <span>-</span> <span>window</span> <span>+</span> <span>1</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>window</span><span>)</span> <span>as</span> <span>j</span><span>:</span>
        <span>windowed</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>]</span> <span>=</span> <span>A</span><span>[</span><span>i</span> <span>+</span> <span>j</span><span>]</span>
    <span>B</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>dp</span><span>.</span><span>mean</span><span>(</span><span>windowed</span><span>[</span><span>i</span><span>,</span> <span>:])</span>
    <span># Note: B[i] = dp.mean(A[i:i+window])
</span>    <span># would not work because dp.Range can&#39;t be used in slice
</span></code></pre></div>  </div>

</details>

<details>
  

  <p>The goal is to create <code>E</code> with</p>

  <p>  <code>E[i1, i2, :, i3] = A[B[i1], C[i1, i2], ::2, D[i2, i3]]</code>.</p>

  <div><div><pre><code><span># Setup
</span><span>K</span> <span>=</span> <span>4</span>
<span>L</span> <span>=</span> <span>5</span>
<span>M</span> <span>=</span> <span>6</span>
<span>N</span> <span>=</span> <span>7</span>

<span>A</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>K</span><span>,</span> <span>L</span><span>,</span> <span>M</span><span>,</span> <span>N</span><span>)</span>
<span>B</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>K</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>9</span><span>,))</span>
<span>C</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>L</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>9</span><span>,</span> <span>10</span><span>))</span>
<span>D</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>N</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>10</span><span>,</span> <span>11</span><span>))</span>

<span># Loops
</span><span>E</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>9</span><span>,</span> <span>10</span><span>,</span> <span>M</span> <span>//</span> <span>2</span><span>,</span> <span>11</span><span>))</span>
<span>for</span> <span>i1</span> <span>in</span> <span>range</span><span>(</span><span>9</span><span>):</span>
    <span>for</span> <span>i2</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
        <span>for</span> <span>i3</span> <span>in</span> <span>range</span><span>(</span><span>11</span><span>):</span>
            <span>E</span><span>[</span><span>i1</span><span>,</span><span>i2</span><span>,:,</span><span>i3</span><span>]</span> <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>i1</span><span>],</span><span>C</span><span>[</span><span>i1</span><span>,</span> <span>i2</span><span>],::</span><span>2</span><span>,</span><span>D</span><span>[</span><span>i2</span><span>,</span> <span>i3</span><span>]]</span>

<span># NumPy
</span><span>E</span> <span>=</span> <span>A</span><span>[</span><span>B</span><span>[:,</span> <span>None</span><span>,</span> <span>None</span><span>],</span>
      <span>C</span><span>[:,</span> <span>:,</span> <span>None</span><span>],</span>
      <span>::</span><span>2</span><span>,</span>
      <span>D</span><span>[</span><span>None</span><span>,</span> <span>:,</span> <span>:]</span>
    <span>].</span><span>transpose</span><span>((</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>))</span>

<span># JAX
</span><span>E</span> <span>=</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span>
        <span>jax</span><span>.</span><span>vmap</span><span>(</span>
            <span>jax</span><span>.</span><span>vmap</span><span>(</span>
                <span>lambda</span> <span>b</span><span>,</span> <span>c</span><span>,</span> <span>d</span><span>:</span> <span>A</span><span>[</span><span>b</span><span>,</span> <span>c</span><span>,</span> <span>::</span><span>2</span><span>,</span> <span>d</span><span>],</span>
                <span>in_axes</span><span>=</span><span>[</span><span>None</span><span>,</span><span>None</span><span>,</span><span>0</span><span>]),</span>
            <span>in_axes</span><span>=</span><span>[</span><span>None</span><span>,</span><span>0</span><span>,</span><span>0</span><span>]),</span>
        <span>in_axes</span><span>=</span><span>[</span><span>0</span><span>,</span><span>0</span><span>,</span><span>None</span><span>]</span>
    <span>)(</span><span>B</span><span>,</span><span>C</span><span>,</span><span>D</span><span>).</span><span>transpose</span><span>(</span><span>0</span><span>,</span><span>1</span><span>,</span><span>3</span><span>,</span><span>2</span><span>)</span>

<span># DumPy
</span><span>E</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>9</span><span>)</span> <span>as</span> <span>i1</span><span>:</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>10</span><span>)</span> <span>as</span> <span>i2</span><span>:</span>
        <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>11</span><span>)</span> <span>as</span> <span>i3</span><span>:</span>
            <span>E</span><span>[</span><span>i1</span><span>,</span><span>i2</span><span>,:,</span><span>i3</span><span>]</span> <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>i1</span><span>],</span><span>C</span><span>[</span><span>i1</span><span>,</span> <span>i2</span><span>],::</span><span>2</span><span>,</span><span>D</span><span>[</span><span>i2</span><span>,</span> <span>i3</span><span>]]</span>

<span># DumPy (alternative)
</span><span>E</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>E</span><span>[</span><span>&#39;i1&#39;</span><span>,</span><span>&#39;i2&#39;</span><span>,:,</span><span>&#39;i3&#39;</span><span>]</span> <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>&#39;i1&#39;</span><span>],</span> <span>C</span><span>[</span><span>&#39;i1&#39;</span><span>,</span><span>&#39;i2&#39;</span><span>],</span> <span>::</span><span>2</span><span>,</span> <span>D</span><span>[</span><span>&#39;i2&#39;</span><span>,</span><span>&#39;i3&#39;</span><span>]]</span>

</code></pre></div>  </div>
</details>

<details>
  

  <p>The goal of this problem is, given a list of vectors and a list of <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">Gaussians</a> parameters, and arrays mapping each vector to a list of parameters, evaluate each corresponding vector/parameter combination. Formally, given 2D <code>X</code>, <code>B</code>, <code>C</code>, and <code>means</code> and 3D <code>covs</code>, the goal is to create <code>A</code> with</p>

  <p>  <code>A<sub>ij</sub> = log N( X<sub>i</sub> | means<sub>B<sub>ij</sub></sub>, covs<sub>C<sub>ij</sub></sub>) </code>.</p>

  <div><div><pre><code><span># Setup
</span><span>ndims</span> <span>=</span> <span>3</span>
<span>ndata</span> <span>=</span> <span>10</span>
<span>neval</span> <span>=</span> <span>5</span>
<span>ndist</span> <span>=</span> <span>7</span>

<span>X</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>ndata</span><span>,</span> <span>ndims</span><span>)</span>
<span>B</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>ndist</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>ndata</span><span>,</span> <span>neval</span><span>))</span>
<span>C</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>ndist</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>ndata</span><span>,</span> <span>neval</span><span>))</span>
<span>means</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>ndist</span><span>,</span> <span>ndims</span><span>)</span>
<span>scales</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>(</span><span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>ndist</span><span>,</span> <span>ndims</span><span>,</span> <span>ndims</span><span>))</span>
<span>covs</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>scale</span> <span>@</span> <span>scale</span><span>.</span><span>T</span> <span>for</span> <span>scale</span> <span>in</span> <span>scales</span><span>])</span>
</code></pre></div>  </div>

  <div><div><pre><code><span># Loops
</span><span>def</span> <span>log_prob</span><span>(</span><span>x</span><span>,</span> <span>mean</span><span>,</span> <span>cov</span><span>):</span>
    <span>diff</span> <span>=</span> <span>x</span> <span>-</span> <span>mean</span>
    <span>y</span> <span>=</span> <span>np</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>cov</span><span>,</span> <span>diff</span><span>)</span>
    <span>quad</span> <span>=</span> <span>diff</span> <span>@</span> <span>y</span>
    <span>logdet</span> <span>=</span> <span>np</span><span>.</span><span>linalg</span><span>.</span><span>slogdet</span><span>(</span><span>2</span> <span>*</span> <span>np</span><span>.</span><span>pi</span> <span>*</span> <span>cov</span><span>)[</span><span>1</span><span>]</span>
    <span>return</span> <span>-</span><span>0.5</span> <span>*</span> <span>(</span><span>quad</span> <span>+</span> <span>logdet</span><span>)</span>

<span>A</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>ndata</span><span>,</span> <span>neval</span><span>))</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>ndata</span><span>):</span>
    <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>neval</span><span>):</span>
        <span>A</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>]</span> <span>=</span> <span>log_prob</span><span>(</span><span>X</span><span>[</span><span>i</span><span>,</span> <span>:],</span>
                           <span>means</span><span>[</span><span>B</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>],</span> <span>:],</span>
                           <span>covs</span><span>[</span><span>C</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>],</span> <span>:,</span> <span>:])</span>

<span># NumPy
</span><span>diff</span> <span>=</span> <span>X</span><span>[:,</span> <span>None</span><span>,</span> <span>:]</span> <span>-</span> <span>means</span><span>[</span><span>B</span><span>]</span>
<span>y</span> <span>=</span> <span>np</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>covs</span><span>[</span><span>C</span><span>],</span> <span>diff</span><span>[...,</span> <span>None</span><span>])</span>
<span>quad</span> <span>=</span> <span>np</span><span>.</span><span>sum</span><span>(</span><span>diff</span> <span>*</span> <span>y</span><span>[...,</span> <span>0</span><span>],</span> <span>axis</span><span>=-</span><span>1</span><span>)</span>
<span>logdet</span> <span>=</span> <span>np</span><span>.</span><span>linalg</span><span>.</span><span>slogdet</span><span>(</span><span>2</span> <span>*</span> <span>np</span><span>.</span><span>pi</span> <span>*</span> <span>covs</span><span>[</span><span>C</span><span>])[</span><span>1</span><span>]</span>
<span>A</span> <span>=</span> <span>-</span><span>0.5</span> <span>*</span> <span>(</span><span>quad</span> <span>+</span> <span>logdet</span><span>)</span>

<span># JAX
</span><span>A</span> <span>=</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span>
        <span>jax</span><span>.</span><span>vmap</span><span>(</span>
            <span>log_prob_gauss</span><span>,</span>
            <span>in_axes</span><span>=</span><span>[</span><span>None</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span>
        <span>),</span>
    <span>)(</span><span>X</span><span>,</span> <span>means</span><span>[</span><span>B</span><span>],</span> <span>covs</span><span>[</span><span>C</span><span>])</span>

<span># DumPy
</span><span>def</span> <span>log_prob</span><span>(</span><span>x</span><span>,</span> <span>mean</span><span>,</span> <span>cov</span><span>):</span>
    <span>diff</span> <span>=</span> <span>x</span> <span>-</span> <span>mean</span>
    <span>quad</span> <span>=</span> <span>diff</span> <span>@</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>cov</span><span>,</span> <span>diff</span><span>)</span>
    <span>logdet</span> <span>=</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>slogdet</span><span>(</span><span>2</span> <span>*</span> <span>jnp</span><span>.</span><span>pi</span> <span>*</span> <span>cov</span><span>)[</span><span>1</span><span>]</span>

<span>A</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>ndata</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>neval</span><span>)</span> <span>as</span> <span>j</span><span>:</span>
        <span>A</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>]</span> <span>=</span> <span>log_prob</span><span>(</span><span>X</span><span>[</span><span>i</span><span>,:],</span>
                           <span>means</span><span>[</span><span>B</span><span>[</span><span>i</span><span>,</span><span>j</span><span>],:],</span>
                           <span>covs</span><span>[</span><span>C</span><span>[</span><span>i</span><span>,</span><span>j</span><span>],:,:])</span>

<span># DumPy (alternate)
</span><span>A</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
<span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>ndata</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>neval</span><span>)</span> <span>as</span> <span>j</span><span>:</span>
        <span>mean</span> <span>=</span> <span>means</span><span>[</span><span>B</span><span>[</span><span>i</span><span>,</span><span>j</span><span>],:]</span>
        <span>cov</span> <span>=</span> <span>covs</span><span>[</span><span>C</span><span>[</span><span>i</span><span>,</span><span>j</span><span>],:,:]</span>
        <span>diff</span> <span>=</span> <span>X</span><span>[</span><span>i</span><span>,:]</span> <span>-</span> <span>mean</span>
        <span>quad</span> <span>=</span> <span>diff</span> <span>@</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>cov</span><span>,</span> <span>diff</span><span>)</span>
        <span>logdet</span> <span>=</span> <span>dp</span><span>.</span><span>linalg</span><span>.</span><span>slogdet</span><span>(</span><span>2</span> <span>*</span> <span>jnp</span><span>.</span><span>pi</span> <span>*</span> <span>cov</span><span>)[</span><span>1</span><span>]</span>
        <span>A</span><span>[</span><span>i</span><span>,</span><span>j</span><span>]</span> <span>=</span> <span>-</span><span>0.5</span> <span>*</span> <span>(</span><span>quad</span> <span>+</span> <span>logdet</span><span>)</span>
</code></pre></div>  </div>

</details>

<details>
  

  <p>See also the discussion in the <a href="https://dynomight.net/numpy/#attention-please">previous post</a>.</p>

  <div><div><pre><code><span># Setup
</span><span>input_dim</span> <span>=</span> <span>4</span>
<span>seq_len</span> <span>=</span> <span>4</span>
<span>d_k</span> <span>=</span> <span>5</span>
<span>d_v</span> <span>=</span> <span>input_dim</span>
<span>n_head</span> <span>=</span> <span>2</span>
<span>X</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>seq_len</span><span>,</span> <span>input_dim</span><span>)</span>
<span>W_q</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>n_head</span><span>,</span> <span>input_dim</span><span>,</span> <span>d_k</span><span>)</span>
<span>W_k</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>n_head</span><span>,</span> <span>input_dim</span><span>,</span> <span>d_k</span><span>)</span>
<span>W_v</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>n_head</span><span>,</span> <span>input_dim</span><span>,</span> <span>d_v</span><span>)</span>
<span>W_o</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randn</span><span>(</span><span>n_head</span><span>,</span> <span>d_v</span><span>,</span> <span>input_dim</span> <span>//</span> <span>n_head</span><span>)</span>

<span># Loops
</span><span>def</span> <span>softmax_numpy</span><span>(</span><span>x</span><span>,</span> <span>axis</span><span>=-</span><span>1</span><span>):</span>
    <span>e_x</span> <span>=</span> <span>np</span><span>.</span><span>exp</span><span>(</span><span>x</span> <span>-</span> <span>np</span><span>.</span><span>max</span><span>(</span><span>x</span><span>,</span> <span>axis</span><span>=</span><span>axis</span><span>,</span> <span>keepdims</span><span>=</span><span>True</span><span>))</span>
    <span>return</span> <span>e_x</span> <span>/</span> <span>np</span><span>.</span><span>sum</span><span>(</span><span>e_x</span><span>,</span> <span>axis</span><span>=</span><span>axis</span><span>,</span> <span>keepdims</span><span>=</span><span>True</span><span>)</span>

<span>def</span> <span>attention</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>):</span>
    <span>Q</span> <span>=</span> <span>X</span> <span>@</span> <span>W_q</span>
    <span>K</span> <span>=</span> <span>X</span> <span>@</span> <span>W_k</span>
    <span>V</span> <span>=</span> <span>X</span> <span>@</span> <span>W_v</span>
    <span>scores</span> <span>=</span> <span>Q</span> <span>@</span> <span>K</span><span>.</span><span>T</span> <span>/</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>d_k</span><span>)</span>
    <span>attention_weights</span> <span>=</span> <span>softmax_numpy</span><span>(</span><span>scores</span><span>,</span> <span>axis</span><span>=-</span><span>1</span><span>)</span>
    <span>output</span> <span>=</span> <span>attention_weights</span> <span>@</span> <span>V</span>
    <span>return</span> <span>output</span>

<span>def</span> <span>multi_head_attention_loops</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>,</span> <span>W_o</span><span>):</span>
    <span>projected</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>n</span> <span>in</span> <span>range</span><span>(</span><span>n_head</span><span>):</span>
        <span>my_output</span> <span>=</span> <span>attention</span><span>(</span><span>X</span><span>,</span>
                                <span>W_q</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:],</span>
                                <span>W_k</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:],</span>
                                <span>W_v</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:])</span>
        <span>my_proj</span> <span>=</span> <span>my_output</span> <span>@</span> <span>W_o</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span>
        <span>projected</span><span>.</span><span>append</span><span>(</span><span>my_proj</span><span>)</span>
    <span>projected</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>(</span><span>projected</span><span>)</span>

    <span>final</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>seq_len</span><span>):</span>
        <span>my_final</span> <span>=</span> <span>np</span><span>.</span><span>ravel</span><span>(</span><span>projected</span><span>[:,</span> <span>i</span><span>,</span> <span>:])</span>
        <span>final</span><span>.</span><span>append</span><span>(</span><span>my_final</span><span>)</span>
    <span>return</span> <span>np</span><span>.</span><span>array</span><span>(</span><span>final</span><span>)</span>

<span># NumPy
</span><span>def</span> <span>softmax_numpy</span><span>(</span><span>x</span><span>,</span> <span>axis</span><span>=-</span><span>1</span><span>):</span> <span># repeat
</span>    <span>e_x</span> <span>=</span> <span>np</span><span>.</span><span>exp</span><span>(</span><span>x</span> <span>-</span> <span>np</span><span>.</span><span>max</span><span>(</span><span>x</span><span>,</span> <span>axis</span><span>=</span><span>axis</span><span>,</span> <span>keepdims</span><span>=</span><span>True</span><span>))</span>
    <span>return</span> <span>e_x</span> <span>/</span> <span>np</span><span>.</span><span>sum</span><span>(</span><span>e_x</span><span>,</span> <span>axis</span><span>=</span><span>axis</span><span>,</span> <span>keepdims</span><span>=</span><span>True</span><span>)</span>

<span>def</span> <span>multi_head_attention_numpy</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>,</span> <span>W_o</span><span>):</span>
    <span>Q</span> <span>=</span> <span>np</span><span>.</span><span>einsum</span><span>(</span><span>&#39;si,hij-&gt;hsj&#39;</span><span>,</span> <span>X</span><span>,</span> <span>W_q</span><span>)</span>
    <span>K</span> <span>=</span> <span>np</span><span>.</span><span>einsum</span><span>(</span><span>&#39;si,hik-&gt;hsk&#39;</span><span>,</span> <span>X</span><span>,</span> <span>W_k</span><span>)</span>
    <span>V</span> <span>=</span> <span>np</span><span>.</span><span>einsum</span><span>(</span><span>&#39;si,hiv-&gt;hsv&#39;</span><span>,</span> <span>X</span><span>,</span> <span>W_v</span><span>)</span>
    <span>scores</span> <span>=</span> <span>Q</span> <span>@</span> <span>K</span><span>.</span><span>transpose</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>)</span> <span>/</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>d_k</span><span>)</span>
    <span>weights</span> <span>=</span> <span>softmax_numpy</span><span>(</span><span>scores</span><span>,</span> <span>axis</span><span>=-</span><span>1</span><span>)</span>
    <span>output</span> <span>=</span> <span>weights</span> <span>@</span> <span>V</span>
    <span>projected</span> <span>=</span> <span>np</span><span>.</span><span>einsum</span><span>(</span><span>&#39;hsv,hvd-&gt;hsd&#39;</span><span>,</span> <span>output</span><span>,</span> <span>W_o</span><span>)</span>
    <span>return</span> <span>projected</span><span>.</span><span>transpose</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>).</span><span>reshape</span><span>(</span>
        <span>seq_len</span><span>,</span> <span>input_dim</span><span>)</span>

<span># JAX
</span><span>def</span> <span>softmax_jax</span><span>(</span><span>x</span><span>,</span> <span>axis</span><span>=-</span><span>1</span><span>):</span>
    <span>e_x</span> <span>=</span> <span>jnp</span><span>.</span><span>exp</span><span>(</span><span>x</span> <span>-</span> <span>jnp</span><span>.</span><span>max</span><span>(</span><span>x</span><span>,</span> <span>axis</span><span>=</span><span>axis</span><span>,</span> <span>keepdims</span><span>=</span><span>True</span><span>))</span>
    <span>return</span> <span>e_x</span> <span>/</span> <span>jnp</span><span>.</span><span>sum</span><span>(</span><span>e_x</span><span>,</span> <span>axis</span><span>=</span><span>axis</span><span>,</span> <span>keepdims</span><span>=</span><span>True</span><span>)</span>

<span>def</span> <span>attention_jax</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>):</span>
    <span>d_k</span> <span>=</span> <span>W_k</span><span>.</span><span>shape</span><span>[</span><span>-</span><span>1</span><span>]</span>
    <span>Q</span> <span>=</span> <span>X</span> <span>@</span> <span>W_q</span>
    <span>K</span> <span>=</span> <span>X</span> <span>@</span> <span>W_k</span>
    <span>V</span> <span>=</span> <span>X</span> <span>@</span> <span>W_v</span>
    <span>scores</span> <span>=</span> <span>Q</span> <span>@</span> <span>K</span><span>.</span><span>T</span> <span>/</span> <span>jnp</span><span>.</span><span>sqrt</span><span>(</span><span>d_k</span><span>)</span>
    <span>attention_weights</span> <span>=</span> <span>softmax_jax</span><span>(</span><span>scores</span><span>,</span> <span>axis</span><span>=-</span><span>1</span><span>)</span>
    <span>output</span> <span>=</span> <span>attention_weights</span> <span>@</span> <span>V</span>
    <span>return</span> <span>output</span>

<span>def</span> <span>multi_head_attention_jax</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>,</span> <span>W_o</span><span>):</span>
    <span>def</span> <span>myfun</span><span>(</span><span>X</span><span>,</span> <span>w_q</span><span>,</span> <span>w_k</span><span>,</span> <span>w_v</span><span>,</span> <span>w_o</span><span>):</span>
        <span>return</span> <span>attention_jax</span><span>(</span><span>X</span><span>,</span> <span>w_q</span><span>,</span> <span>w_k</span><span>,</span> <span>w_v</span><span>)</span> <span>@</span> <span>w_o</span>

    <span>projected</span> <span>=</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span><span>myfun</span><span>,</span>
                            <span>in_axes</span><span>=</span><span>[</span><span>None</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span>
                <span>)(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>,</span> <span>W_o</span><span>)</span>

    <span>return</span> <span>jax</span><span>.</span><span>vmap</span><span>(</span><span>jnp</span><span>.</span><span>ravel</span><span>,</span> <span>in_axes</span><span>=</span><span>1</span><span>)(</span><span>projected</span><span>)</span>

<span># DumPy
</span><span>def</span> <span>softmax_dumpy</span><span>(</span><span>x</span><span>):</span>
    <span>assert</span> <span>x</span><span>.</span><span>ndim</span> <span>==</span> <span>1</span> <span># no need to think about dimensions!
</span>    <span>e_x</span> <span>=</span> <span>dp</span><span>.</span><span>exp</span><span>(</span><span>x</span> <span>-</span> <span>dp</span><span>.</span><span>max</span><span>(</span><span>x</span><span>))</span>
    <span>return</span> <span>e_x</span> <span>/</span> <span>dp</span><span>.</span><span>sum</span><span>(</span><span>e_x</span><span>)</span>

<span>@</span><span>dp</span><span>.</span><span>wrap</span> <span># needed to make functions with Slots auto-vectorizing
</span><span>def</span> <span>attention_dumpy</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>):</span>
    <span>Q</span> <span>=</span> <span>X</span> <span>@</span> <span>W_q</span>
    <span>K</span> <span>=</span> <span>X</span> <span>@</span> <span>W_k</span>
    <span>V</span> <span>=</span> <span>X</span> <span>@</span> <span>W_v</span>
    <span>scores</span> <span>=</span> <span>Q</span> <span>@</span> <span>K</span><span>.</span><span>T</span> <span>/</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>d_k</span><span>)</span>
    <span>attention_weights</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>seq_len</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
        <span>attention_weights</span><span>[</span><span>i</span><span>,</span> <span>:]</span> <span>=</span> <span>softmax_dumpy</span><span>(</span><span>scores</span><span>[</span><span>i</span><span>,</span> <span>:])</span>
    <span>output</span> <span>=</span> <span>attention_weights</span> <span>@</span> <span>V</span>
    <span>return</span> <span>output</span>

<span>def</span> <span>multi_head_attention_dumpy</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>,</span> <span>W_o</span><span>):</span>
    <span>output</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
    <span>projected</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
    <span>final</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>n_head</span><span>)</span> <span>as</span> <span>n</span><span>:</span>
        <span>output</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span> <span>=</span> <span>attention_dumpy</span><span>(</span><span>X</span><span>,</span>
                                          <span>W_q</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:],</span>
                                          <span>W_k</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:],</span>
                                          <span>W_v</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:])</span>
        <span>projected</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span> <span>=</span> <span>output</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span> <span>@</span> <span>W_o</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>seq_len</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
        <span>final</span><span>[</span><span>i</span><span>,</span> <span>:]</span> <span>=</span> <span>dp</span><span>.</span><span>ravel</span><span>(</span><span>projected</span><span>[:,</span> <span>i</span><span>,</span> <span>:])</span>
    <span>return</span> <span>final</span>

<span># DumPy (alternate)
</span><span>def</span> <span>multi_head_attention</span><span>(</span><span>X</span><span>,</span> <span>W_q</span><span>,</span> <span>W_k</span><span>,</span> <span>W_v</span><span>,</span> <span>W_o</span><span>):</span>
    <span>attn_weights</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
    <span>projected</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
    <span>final</span> <span>=</span> <span>dp</span><span>.</span><span>Slot</span><span>()</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>n_head</span><span>)</span> <span>as</span> <span>n</span><span>:</span>
        <span>Q</span> <span>=</span> <span>X</span> <span>@</span> <span>W_q</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span>
        <span>K</span> <span>=</span> <span>X</span> <span>@</span> <span>W_k</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span>
        <span>V</span> <span>=</span> <span>X</span> <span>@</span> <span>W_v</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span>
        <span>scores</span> <span>=</span> <span>Q</span> <span>@</span> <span>K</span><span>.</span><span>T</span> <span>/</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>d_k</span><span>)</span>
        <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>seq_len</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
            <span>attn_weights</span><span>[</span><span>n</span><span>,</span> <span>i</span><span>,</span> <span>:]</span> <span>=</span> <span>softmax_dumpy</span><span>(</span><span>scores</span><span>[</span><span>i</span><span>,</span> <span>:])</span>
        <span>projected</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span> <span>=</span> <span>attn_weights</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span> <span>@</span> <span>V</span> <span>@</span> <span>W_o</span><span>[</span><span>n</span><span>,</span> <span>:,</span> <span>:]</span>
    <span>with</span> <span>dp</span><span>.</span><span>Range</span><span>(</span><span>seq_len</span><span>)</span> <span>as</span> <span>i</span><span>:</span>
        <span>final</span><span>[</span><span>i</span><span>,</span> <span>:]</span> <span>=</span> <span>dp</span><span>.</span><span>ravel</span><span>(</span><span>projected</span><span>[:,</span> <span>i</span><span>,</span> <span>:])</span>
    <span>return</span> <span>final</span>
</code></pre></div>  </div>

</details>

<p>I gave each implementation a subjective “goodness” score on a 1-10 scale. I always gave the best implementation for each problem 10 points, and then took off points from the others based on how much thinking they required.</p>

<table>
  <thead>
    <tr>
      <th>Problem</th>
      <th>Loops</th>
      <th>Numpy</th>
      <th>JAX (vmap)</th>
      <th>DumPy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Hilbert matrices</td>
      <td>10</td>
      <td>7</td>
      <td>7</td>
      <td>10</td>
    </tr>
    <tr>
      <td>Covariance</td>
      <td>9</td>
      <td>4</td>
      <td>10</td>
      <td>9</td>
    </tr>
    <tr>
      <td>Moving Ave.</td>
      <td>10</td>
      <td>6</td>
      <td>6</td>
      <td>8</td>
    </tr>
    <tr>
      <td>Indexing</td>
      <td>10</td>
      <td>5</td>
      <td>4</td>
      <td>10</td>
    </tr>
    <tr>
      <td>Gaussians</td>
      <td>10</td>
      <td>3</td>
      <td>6</td>
      <td>10</td>
    </tr>
    <tr>
      <td>Attention</td>
      <td>10</td>
      <td>1</td>
      <td>8</td>
      <td>10</td>
    </tr>
    <tr>
      <td><strong>Mean</strong></td>
      <td><strong>9.8</strong></td>
      <td><strong>4.3</strong></td>
      <td><strong>6.8</strong></td>
      <td><strong>9.5</strong></td>
    </tr>
  </tbody>
</table>

<p>According to this dubious methodology and these made-up numbers, DumPy is 96.93877% as good as loops! Knowledge is power! But seriously, while subjective, I don’t think my scores should be <em>too</em> controversial. The most debatable one is probably JAX’s attention score.</p>

<h2 id="what-to-remove">What to remove?</h2>

<p>The only thing DumPy adds to NumPy is some nice notation for indices. That’s it.</p>

<p>What I think makes DumPy good is it also <em>removes</em> a lot of stuff. Roughly speaking, I’ve tried to remove anything that is confusing and exists because NumPy doesn’t have loops. I’m not sure that I’ve drawn the line in exactly the right place, but I do feel confident that I’m on the right track.</p>

<h3 id="1-goodbye-broadcasting">1. Goodbye broadcasting</h3>

<p>In NumPy, <code>A*B</code> works if <code>A</code> and <code>B</code> are both scalar. Or if <code>A</code> is <code>5×1×6</code> and <code>B</code> is <code>5×1×6×1</code>. But not if <code>A</code> is <code>1×5×6</code> and <code>B</code> is <code>1×5×6×1</code>. Huh?</p>

<p>In truth, the <a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">broadcasting rules</a> aren’t <em>that</em> complicated for scalar operations like multiplication. But still, I don’t like it, because <em>every time</em> you see <code>A*B</code>, you have to worry about what shapes those have and what the computation might be doing.</p>

<p>So, I removed it. In DumPy you can only do <code>A*B</code> if one of <code>A</code> or <code>B</code> is scalar or <code>A</code> and <code>B</code> have exactly the same shape. That’s it, anything else raises an error. Instead, use indices, so it’s clear what you’re doing. Instead of this:</p>

<div><div><pre><code><span>C</span> <span>=</span> <span>A</span><span>[...,</span><span>None</span><span>]</span> <span>*</span> <span>B</span><span>[</span><span>None</span><span>]</span>
</code></pre></div></div>

<p>write this:</p>

<div><div><pre><code><span>C</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>,</span><span>&#39;k&#39;</span><span>]</span> <span>=</span> <span>A</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>]</span> <span>*</span> <span>B</span><span>[</span><span>&#39;j&#39;</span><span>,</span><span>&#39;k&#39;</span><span>]</span>
</code></pre></div></div>

<h3 id="2-goodbye-fancy-indexing">2. Goodbye fancy indexing</h3>

<p>Indexing in NumPy is <a href="https://dynomight.net/numpy/#i-dont-like-numpy-indexing">absurdly complicated</a>. When you write <code>A[B,C,D]</code> that could do <em>many</em> different things depending on what all the shapes are. I considered going cold-turkey and only allowing scalar indices in DumPy. That wouldn’t have been <em>so</em> bad, since you can still do advanced stuff using loops. But it’s quite annoying to not be able to write <code>A[B]</code> when <code>A</code> and <code>B</code> are just simple 1D arrays.</p>

<p>So I’ve tentatively decided to be more pragmatic. In DumPy, you can index with integers, or slices, or (possibly mapped) <code>Array</code>s. <strong>But only one <code>Array</code> index can be non-scalar</strong>. I settled on this because it’s the most general syntax that doesn’t require thinking.</p>

<p>Let me show you what I mean. If you see this:</p>

<div><div><pre><code><span>A</span><span>[</span><span>1</span><span>,</span> <span>1</span><span>:</span><span>6</span><span>,</span> <span>C</span><span>,</span> <span>2</span><span>:</span><span>10</span><span>]</span> <span># legal in both numpy and dumpy
</span></code></pre></div></div>

<p>It’s “obvious” what the output shape will be. (First the shape of <code>1:6</code>, then the shape of <code>C</code>, then the shape of <code>2:10</code>). Simple enough. But as soon as you have <em>two</em> multidimensional array inputs like this:</p>

<div><div><pre><code><span>A</span><span>[</span><span>B</span><span>,</span> <span>1</span><span>:</span><span>6</span><span>,</span> <span>C</span><span>,</span> <span>2</span><span>:</span><span>10</span><span>]</span> <span># legal in numpy, verboten in dumpy
</span></code></pre></div></div>

<p>Suddenly all hell breaks loose. You need to think about broadcasting between <code>A</code> and <code>B</code>, orthogonal vs. pointwise indices, slices behaving differently than arrays, and quirks for where the output dimensions go. So DumPy forbids this. Instead, you need to write one of these:</p>

<div><div><pre><code><span>D</span><span>[</span><span>&#39;i&#39;</span><span>,:,:]</span>     <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>&#39;i&#39;</span><span>],</span>     <span>1</span><span>:</span><span>6</span><span>,</span> <span>C</span><span>[</span><span>&#39;i&#39;</span><span>],</span>     <span>2</span><span>:</span><span>10</span><span>]</span> <span># (1)
</span><span>D</span><span>[:,:,</span><span>&#39;i&#39;</span><span>]</span>     <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>&#39;i&#39;</span><span>],</span>     <span>1</span><span>:</span><span>6</span><span>,</span> <span>C</span><span>[</span><span>&#39;i&#39;</span><span>],</span>     <span>2</span><span>:</span><span>10</span><span>]</span> <span># (2)
</span><span>D</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>,:,:]</span> <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>&#39;i&#39;</span><span>],</span>     <span>1</span><span>:</span><span>6</span><span>,</span> <span>C</span><span>[</span><span>&#39;j&#39;</span><span>],</span>     <span>2</span><span>:</span><span>10</span><span>]</span> <span># (3)
</span><span>D</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>,:,:]</span> <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>],</span> <span>1</span><span>:</span><span>6</span><span>,</span> <span>C</span><span>[</span><span>&#39;i&#39;</span><span>],</span>     <span>2</span><span>:</span><span>10</span><span>]</span> <span># (4)
</span><span>D</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>,:,:]</span> <span>=</span> <span>A</span><span>[</span><span>B</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>],</span> <span>1</span><span>:</span><span>6</span><span>,</span> <span>C</span><span>[</span><span>&#39;i&#39;</span><span>,</span><span>&#39;j&#39;</span><span>],</span> <span>2</span><span>:</span><span>10</span><span>]</span> <span># (5)
</span></code></pre></div></div>

<p>They all do exactly what they look like they do.</p>

<p>Oh, and one more thing! In DumPy, you <strong>must index all dimensions</strong>. In NumPy, if <code>A</code> has three dimensions, then <code>A[2]</code> is equivalent to <code>A[2,:,:]</code>. This is sometimes nice, but it means that <em>every time</em> you see <code>A[2]</code>, you have to worry about how many dimensions <code>A</code> has. In DumPy, every time you index an array or assign to a <code>dp.Slot</code>, it checks that all indices have been included. So when you see option (4) above, you <em>know</em> that:</p>

<ul>
  <li><code>A</code> has 4 dimensions</li>
  <li><code>B</code> has 2 dimensions</li>
  <li><code>C</code> has 1 dimension</li>
  <li><code>D</code> has 4 dimensions</li>
</ul>

<p>Always, always, <em>always</em>. No cases, no thinking.</p>

<h3 id="3-goodbye-complicated-functions">3. Goodbye complicated functions</h3>

<p>Again, many NumPy functions have complex conventions for vectorization. <a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html"><code>np.linalg.solve</code></a> sort of says, “If the inputs have ≤2 dimensions, do the obvious thing. Otherwise, do some extremely confusing broadcasting stuff.” DumPy removes the confusing broadcasting stuff. When you see <code>dp.linalg.solve(A,B)</code>, you know that <code>A</code> and <code>B</code> have no more than two dimensions, so nothing tricky is happening.</p>

<p>Similarly, in NumPy, <code>A @ B</code> is equivalent to <a href="https://numpy.org/doc/stable/reference/generated/numpy.matmul.html"><code>np.matmul</code></a><code>(A,B)</code>. When both inputs have ≤2 or fewer dimensions, this does the “obvious thing”. (Either an inner-product or some kind of matrix/vector multiplication.) Otherwise, it broadcasts or vectorizes or something? I can never remember. In DumPy you don’t have that problem, because it restricts <code>A @ B</code> to arrays with one or two dimensions only.</p>

<p>If you need more dimensions, no problem: Use indices.</p>

<h3 id="why-remove">Why remove?</h3>

<p>It might seem annoying to remove features, but I’m telling you: <em>Just try it</em>. If you program this way, a wonderful feeling of calmness comes over you, as class after class of possible errors disappear.</p>

<p>Put another way, why remove all the fancy stuff, instead of leaving it optional? Because optional implies thinking! I want to program in a simple way. I don’t want to worry that I’m accidentally triggering some confusing broadcasting insanity, because that would be a mistake. I want the computer to help me catch mistakes, not silently do something weird that I didn’t intend.</p>

<p>In principle, it would be OK if there was a <code>evil_solve</code> method that preserves all the confusing batching stuff. If you <em>really</em> want that, you can make it yourself:</p>

<div><div><pre><code><span>evil_solve</span> <span>=</span> <span>dp</span><span>.</span><span>MappedFunction</span><span>(</span><span>jnp</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>)</span> <span># not recommended
</span></code></pre></div></div>

<p>You can use that same wrapper to convert any JAX NumPy function to work with DumPy.</p>

<h2 id="discussion">Discussion</h2>

<p>Think about math: In two or fewer dimensions, coordinate-free linear algebra notation is wonderful. But for higher dimensional <a href="https://en.wikipedia.org/wiki/Tensor">tensors</a>, there are just too many cases, so most physicists just use coordinates.</p>

<p>So this solution seems pretty obvious to me. Honestly, I’m a little confused why it isn’t already standard. Am I missing something?</p>

<h3 id="what-about-apl">What about APL?</h3>

<p>When I complain about NumPy, many people often suggest looking into <a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a>-type languages, like A, J, K, or Q. (All single-letter languages are APL-like, except C, D, F, R, T, X, and many others. Convenient, right?) The obvious disadvantages of these are that:</p>

<ol>
  <li>They’re unfamiliar.</li>
  <li>The code looks like gibberish.</li>
  <li>They don’t usually provide autodiff or GPU execution.</li>
</ol>

<p>None of those bother me. If the languages are better, we should learn to use them and make them do autodiff on GPUs. But I’m not convinced they <em>are</em> better. When you actually learn these languages, what you figure out is that the symbol gibberish basically amounts to doing the same kind of dimension mashing that we saw earlier in NumPy:</p>

<div><div><pre><code><span>AiX</span> <span>=</span> <span>np</span><span>.</span><span>linalg</span><span>.</span><span>solve</span><span>(</span><span>A</span><span>.</span><span>transpose</span><span>(</span><span>1</span><span>,</span><span>0</span><span>,</span><span>2</span><span>,</span><span>3</span><span>),</span>
                      <span>X</span><span>[</span><span>None</span><span>,...,</span><span>None</span><span>])[...,</span><span>0</span><span>]</span>
<span>Z</span> <span>=</span> <span>np</span><span>.</span><span>sum</span><span>(</span><span>AiX</span> <span>*</span> <span>Y</span><span>[:,</span><span>None</span><span>],</span> <span>axis</span><span>=-</span><span>1</span><span>).</span><span>T</span>
</code></pre></div></div>

<p>The reason is that, just like NumPy and <code>vmap</code>, these languages choose align dimensions by <em>positions</em>, rather than by names. If I <em>have</em> to mash dimensions, I want to use the best tool. But I’d prefer not to mash dimensions at all.</p>

<h3 id="what-about-named-dimensions">What about named dimensions?</h3>

<p>People also often suggest “NumPy with named dimensions” as in <a href="https://docs.xarray.dev/en/stable/index.html">xarray</a>. (PyTorch also has a <a href="https://docs.pytorch.org/docs/stable/named_tensor.html">half-hearted implementation</a>.) Of course, DumPy also uses named dimensions, but there’s a critical difference. In xarray, they’re part of the arrays themselves, while in DumPy, they live outside the arrays.</p>

<p>In some cases, permanent named dimensions are very nice. But for linear algebra, they’re confusing. For example, suppose <code>A</code> is 2-D with named dimensions <code>&#34;cat&#34;</code> and <code>&#34;dog&#34;</code>. Now, what dimensions should <code>A<sup>T</sup>A</code> have? (<code>&#34;dog&#34;</code> twice?) Or say you take a singular value decomposition like <code>U, S, Vh = svd(A)</code>. What name should the inner dimensions have? Does the user have to specify it?</p>

<p>I haven’t seen a nice solution. xarray doesn’t focus on linear algebra, so it’s not much of an issue there. A theoretical “DumPy with permanent names” <em>might</em> be very nice, but I’m not how it should work. This is worth thinking about more.</p>

<h3 id="what-about-julia-or-other-language">What about Julia or [other language]</h3>

<p>I like <a href="https://julialang.org/">Julia</a>! Loops are fast in Julia! But again, I don’t think fast loops matter that much, because I want to move all the loops to the GPU. So even if I was using Julia, I think I’d want to use a DumPy-type solution.</p>

<p>I think Julia might well be a better host language than Python, but it wouldn’t be because of fast loops, but because it offers much more powerful meta-programming capabilities. I built DumPy on top of JAX just because JAX is very mature and good at calling the GPU, but I’d love to see the same idea used in Julia (“Dulia”?) or other languages.</p>

<h2 id="prototype">Prototype</h2>

<p>OK, I promised a link to my prototype, so here it is: <a href="https://blog.plover.com/img/dumpy/dumpy.py"><code>dumpy.py</code></a></p>

<p>It’s just a single file with around 700 lines. I’m leaving it as a single file because I want to stress that <strong>this is just something I hacked together in the service of this rant</strong>. I wanted to show that I’m not totally out of my mind, and that doing all this is actually pretty easy.</p>

<p>I stress that I don’t really intend to update or improve this. (Unless someone gives me a lot of money?) So please do not attempt to use it for “real work”, and do not make fun of my code.</p>

<p><em>PS</em> DumPy works out of the box with both <a href="https://docs.jax.dev/en/latest/_autosummary/jax.jit.html"><code>jax.jit</code></a> and <a href="https://docs.jax.dev/en/latest/_autosummary/jax.grad.html"><code>jax.grad</code></a>. For gradients, you need to either cast the output to a JAX scalar or use the <code>dp.grad</code> wrapper.</p>

  </section>
  <section>
    
    
  
</section>
</div></div>
  </body>
</html>
