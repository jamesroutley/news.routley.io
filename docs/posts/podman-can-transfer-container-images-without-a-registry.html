<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.redhat.com/sysadmin/podman-transfer-container-images-without-registry">Original</a>
    <h1>Podman can transfer container images without a registry</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    

      
            <div property="schema:text"><p>The newly released <a href="https://podman.io/releases/2022/02/22/podman-release-v4.0.0.html" target="_blank">Podman 4.0</a> includes the new <a href="https://docs.podman.io/en/latest/markdown/podman-image-scp.1.html" target="_blank"><code>podman image scp</code></a> command, a useful command to help you manage and transfer container images.</p>


<p>Have you ever built an image only to realize that you actually need it on a user account other than root, requiring you to rebuild the image again in rootless mode?</p>

<p>Or have you built an image on one machine but run containers on the image using multiple different machines? Now you need to set up an account on a registry, push the image to the registry, Secure Shell (SSH) to each device you want to run the image on, and then pull the image.</p>

<p>The <code>podman image scp</code> command solves both of these annoying scenarios as quickly as they occur.</p>

<p>You can copy a root image to a non-root account like this:</p>

<pre><code>$ podman image scp root@localhost::IMAGE USER@localhost::</code></pre>

<p>Or copy an image from one machine to another with this command:</p>

<pre><code>$ podman image scp me@192.168.68.122::IMAGE you@192.168.68.128::</code></pre>

<p>Transferring images between local machines has traditionally involved an image registry like Quay.io, connecting to the internet, and pushing and pulling the image.</p>

<p><em><strong>[ You might also be interested in learning <a href="https://www.redhat.com/sysadmin/podman-features-1" target="_blank">5 handy flags</a> that make the Podman user experience better. ]</strong></em></p>

<p>With Podman&#39;s <code>podman image scp</code>, you can transfer images between local and remote machines without requiring an image registry.</p>

<p>Podman takes advantage of its SSH support to copy images between machines, and it also allows for local transfer. Registryless image transfer is useful in a couple of key scenarios:</p>

<ol><li>Doing a local transfer between users on one system</li>
	<li>Sharing images over the network</li>
</ol><p>The next sections cover these examples in more detail.</p>

<h2>1. Do local transfer between users on a system</h2>

<p>You can use the <code>podman image scp</code> command to transfer images between local users by using this command:</p>

<pre><code>$ podman image scp USERNAME@localhost::$IMAGE root@localhost::</code></pre>

<p>Specifying the destination is actually optional. If root is specified in the source, the default <code>$USER</code> is assumed as the destination. If a user is specified and validated, root is assumed as the destination. For example, this transfers <code>$IMAGE</code> to root:</p>

<pre><code>$ podman image scp USERNAME@localhost::$IMAGE</code></pre>


<p>This feature allows users to build images using either rootful or rootless permissions and transfer them seamlessly wherever they are needed. The command does not require <code>sudo</code> to execute but prompts for validation midcommand if your user is not included in <code>/etc/sudoers</code>.</p>

<p>You can also copy an image from root to a user account:</p>

<pre><code># podman image scp $IMAGE USERNAME@localhost::</code></pre>

<p>Alternately, use <code>sudo</code> with a specific source and destination:</p>

<pre><code>$ sudo podman image scp root@localhost::$IMAGE USERNAME@localhost::</code></pre>

<p>Here&#39;s an example:</p>

<pre><code>$ cat Containerfile
FROM registry.fedoraproject.org/fedora:35
RUN dnf install -y podman
CMD [&#34;podman&#34;, &#34;run&#34;, &#34;-dt&#34;, &#34;alpine&#34;]</code></pre>

<p>This simple Containerfile still takes some time to process if you run it for multiple user accounts. The <code>dnf</code> command alone takes a long time to process.</p>

<pre><code>$ podman build –file=Containerfile
	...
	...
	Complete!
--&gt; 18a64048b45
STEP 3/3: CMD [&#34;podman&#34;, &#34;run&#34;, &#34;-dt&#34;, &#34;alpine&#34;]
COMMIT
--&gt; fbf02ebb4eb
Fbf02ebb4eb454abf76715e6a7b0200c9e9a0add086cfb7a60eeed47a9b4e1c9</code></pre>

<p>Oops, you realize you just built this on the wrong user. You meant to build it again as root:</p>

<pre><code>$ sudo podman build –file=Containerfile</code></pre>

<p>Or you could push the image, become root, and pull it from the registry, like this:</p>

<pre><code>$ podman push \
fbf02ebb4eb454abf76715e6a7b0200c9e9a0add086cfb7a60eeed47a9b4e1c9 \ 	dir:/tmp/scpimg
	Getting image source signatures
Copying blob a4220bc9b4f9 done  
Copying blob ea810b5c3ace done  
Copying config fbf02ebb4e done  
Writing manifest to image destination
Storing signatures
	
$ sudo podman pull dir:/tmp/scpimg
	Getting image source signatures
Copying blob a4220bc9b4f9 done  
Copying blob ea810b5c3ace done  
Copying config fbf02ebb4e done  
Writing manifest to image destination
Storing signatures
Fbf02ebb4eb454abf76715e6a7b0200c9e9a0add086cfb7a60eeed47a9b4e1c9</code></pre>

<p>Both of these options are time-consuming and potentially require a third-party registry.</p>

<p>The <code>podman image scp</code> command simply copies the image between users:</p>

<pre><code>$ podman image scp \
fbf02ebb4eb454abf76715e6a7b0200c9e9a0add086cfb7a60eeed47a9b4e1c9 \
root@localhost::
Copying blob a4220bc9b4f9 done  
Copying blob ea810b5c3ace done  
Copying config fbf02ebb4e done  
Writing manifest to image destination
Storing signatures
Getting image source signatures
Copying blob ea810b5c3ace skipped: already exists  
Copying blob a4220bc9b4f9 skipped: already exists  
Copying config fbf02ebb4e done  
Writing manifest to image destination
Storing signatures
Loaded image(s): sha256:fbf02ebb4eb454abf76715e6a7b0200c9e9a0add086cfb7a60eeed47a9b4e1c9</code></pre>

<p>This one command eliminates the need for a registry to temporarily store the image.</p>

<p><strong><em>[ Keep key commands at your fingertips. Download the <a href="https://developers.redhat.com/cheat-sheets/intermediate-linux-cheat-sheet?intcmp=701f20000012ngPAAQ" target="_blank">Intermediate Linux cheat sheet</a>. ]</em></strong></p>

<h2>2. Share images between machines over the network</h2>

<p>You can also use the <code>podman image scp</code> command remotely. For example, to copy an image from a remote machine to your local system, type:</p>

<pre><code>podman image scp USER@CONNECTION::$IMAGE</code></pre>

<p>Or, to copy an image from your local machine to a remote machine, run:</p>

<pre><code>$ podman image scp $IMAGE USERNAME@CONNECTION::</code></pre>

<p>This example copies the image from a remote machine to a different remote machine:</p>

<pre><code>podman image scp USER1@CONNECTION1::$IMAGE USER2@CONNECTION2::</code></pre>

<p>Building an image on a machine and then distributing it to many systems can be even more laborious. You need to push the image to a registry, then SSH into each box you want the image on, and finally pull it back to that system. Given that you probably already have SSH configured to connect to the remote machines, just use <code>podman image scp</code> to copy the image to each machine instead. All that&#39;s required is to configure the SSH connections using the <code>podman system connection add</code> command. Execute the following:</p>

<pre><code>$ podman system connection list
Name     URI                                       Identity                  Default
ubuntu   ssh://myuser@192.168.68.[...]podman.sock  /home/tux/.ssh/id_ubuntu  true

$ podman image scp \ 
fbf02ebb4eb454abf76715e6a7b0200c9e9a0add086cfb7a60eeed47a9b4e1c9 \
ubuntu::
Copying blob 72e830a4dff5 done   
Copying config 85f9dc67c7 done   
Writing manifest to image destination
Storing signatures
Loaded image(s): sha256:fbf02ebb4eb454abf76715e6a7b0200c9e9a0add086cfb7a60eeed47a9b4e1c9</code></pre>

<p>This single command has the same effect as pushing to and pulling from a remote registry without any of the related complications.</p>

<h2>An example</h2>

<p>First, create a new SSH key using <code>ssh-keygen</code>, send that key over to the remote SSH directory using <code>ssh-copy-id</code>, and place that new key in the <code>authorized_keys</code> file on the remote machine. Next, create a new connection using the following command:</p>

<pre><code>$ ssh-copy-id -i &lt;.pub file&gt; -o IdentitiesOnly=yes REMOTE_USER_NAME@192.168.122.1</code></pre>

<p>Next, create the connection using the <code>podman system connection add</code> command:</p>

<pre><code>$ podman system connection add CONNECTION -i ~/.ssh/id_ed25519 \      
REMOTE_USER_NAME@192.168.122.1:22/run/user/1000/podman/podman.sock</code></pre>

<p>Podman names the new connection <code>CONNECTION</code> and uses the recently created SSH key. You need to specify the Podman socket on the remote machine so that the program knows where to execute commands.</p>

<p>Adding this connection allows you to refer to this address as <code>CONNECTION</code>. Say you have an image named <code>my_image</code> you want to send to this remote machine. Executing <code>podman image scp my_image CONNECTION::</code> results in:</p>

<pre><code>$ podman image scp my_image CONNECTION::
Copying blob 72e830a4dff5 done   
Copying config 85f9dc67c7 done   
Writing manifest to image destination
Storing signatures
Loaded image(s): my_image:latest</code></pre>

<p>Podman copies <code>my_image</code> to the remote <code>CONNECTION</code>. You can also retrieve an image from your newly established remote machine by executing:</p>

<pre><code>$ podman image scp CONNECTION::my_image
Copying blob 72e830a4dff5 done   
Copying config 85f9dc67c7 done   
Writing manifest to image destination
Storing signatures
Loaded image(s): my_image:latest</code></pre>

<p>Finally, the image does not even have to be located locally. Put two connections into the command, one as a source and the other as a destination. In this example, you previously set up two additional connections, one named <code>ONE</code> and the second called <code>TWO</code>.</p>

<pre><code>$ podman image scp ONE::my_image TWO::
Copying blob 72e830a4dff5 done   
Copying config 85f9dc67c7 done   
Writing manifest to image destination
Storing signatures
Loaded image(s): my_image:latest</code></pre>

<h2>How it works</h2>

<p>Podman creates two new processes that utilize either a <a href="https://docs.podman.io/en/latest/markdown/podman-save.1.html" target="_blank"><code>podman image save</code></a> or <a href="https://docs.podman.io/en/latest/markdown/podman-load.1.html" target="_blank"><code>podman image load</code></a>. Here is a simple example:</p>

<pre><code>$ podman image scp root@localost::$IMAGE $USER@localhost::</code></pre>

<p>The first new process is forked off the main <code>podman</code> process, executing a <code>sudo podman image save</code>. Then a second process is started by running the <code>podman image load</code> command. The alternative command is:</p>

<pre><code>$ podman image scp $USER@localost::$IMAGE root@localhost::</code></pre>


<p>This transfers from user storage to root storage. Transferring between rootful and rootless storage is possible because <code>image scp</code> does not enter the Podman namespace until it executes the proper load and saves commands. Not entering the Podman namespace allows <code>podman image scp</code> to act as a wrapper function when performing local tasks.</p>

<h2>Copy images</h2>

<p>The <code>podman image scp</code> command circumvents retrieval of images from a traditional registry by utilizing <a href="https://linux.die.net/man/8/sshd" target="_blank">sshd</a><strong> </strong>and executing new Podman processes. The ability to transfer images between users or networks allows more flexibility in sharing images with different machines. This feature&#39;s use in edge and secure environments are interesting to consider, as are the everyday uses.</p>
</div>
      
  
  </div></div>
  </body>
</html>
