<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/zsh-line-editor-configuration-mouseless/">Original</a>
    <h1>A Guide to the Zsh Line Editor with Examples</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2022/zle/zle.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/zle/zle.jpg" alt="The Zsh Line Editor ZLE"/></picture><p>This article is part of a series about Zsh:</p><p>Like every morning, you switch on your computer, launch your terminal, and begin to type weakly the first commands of the day. With a sigh of despair, you launch the 12938 docker containers of your 29374 coupled microservices with a simple <code>docker compose up</code>. Your misery accentuating your tiredness, you mistype the command three times, going back and forth between the NORMAL and INSERT Vi mode of your Zsh instance.</p><p>Did you ever ask yourself how the Zsh editor was able to give you an Emacs or a Vi mode? Have you ever wonder how to customize the editor to ease your tedious work? Well, me neither, for a long time. But we’ll fix that together: in this article, we’ll explore the capabilities of the Zsh Line Editor (ZLE), and how to customize it to increase our efficiency.</p><p>More precisely, we’ll see:</p><ul><li>What’s ZLE and its keymaps.</li><li>How to bind any keystroke to any Zsh widget.</li><li>A glimpse of the TTY subsystem and why binding special keys can be such a challenge.</li><li>Some interesting Zsh built-in widgets.</li><li>How to create your own widgets.</li></ul><p>I encourage you to fire Zsh while reading this article, and try the different commands we’ll discuss. It’s time: are you ready to uncover the veil of mystery surrounding the Zsh Line Editor?</p><h2 id="whats-the-zsh-line-editor">What’s the Zsh Line Editor?</h2><p>The Zsh Line Editor (ZLE) is simply your command prompt. It’s your interface to the shell interpreter, allowing you to write and edit your mind-blowing commands.</p><p>It also allows you to use keystrokes to execute ZLE commands, more commonly called <em>widgets</em>. That’s great, because the term “command” is so overloaded that it doesn’t mean anything anymore. Like “scalable”, and of course “<a href="https://www.reddit.com/r/AskScienceFiction/comments/3wgrj8/futurama_in_what_circumstances_does_bender_say/" target="_blank" rel="noopener">daffodil</a>”.</p><p>We’ve already seen some of the ZLE built-in widgets in the <a href="https://thevaluable.dev/zsh-install-configure-mouseless/">first part of this series of article</a>, like <code>vi-backward</code> for example.</p><h2 id="zsh-keymaps">Zsh Keymaps</h2><p>To understand how ZLE works, we first need to understand the concept of keymap.</p><p>A keymap is a set of keystrokes executing ZLE widgets. For each keymap, the mapping of keystrokes to widgets can be completely different.</p><p>Here are the most interesting keymaps available:</p><ul><li><code>emacs</code> - Emacs emulation</li><li><code>viins</code> - Vi mode - INSERT mode</li><li><code>vicmd</code> - Vi mode - NORMAL mode (also confusingly called COMMAND mode)</li><li><code>viopp</code> - Vi mode - OPERATOR-PENDING mode</li><li><code>visual</code> - Vi mode - VISUAL mode</li></ul><p>For example, the ZLE widget <code>vi-join</code> (to join the current line with the next one) is bound to the keystroke <code>CTRL+x CTRL+j</code> in the <code>emacs</code> keymap, and to <code>J</code> in the <code>vicmd</code> keymap.</p><p>When we use our prompt, we use the <em>global keymap</em>. This is the current keymap loaded, for us to use its delightful keystrokes. This global keymap is often aliased to the <em>main keymap</em>, which is the keymap Zsh load by default when it launches. If you didn’t specify any main keymap in your configuration, it will use the <code>emacs</code> one.</p><p>As a Vim Missionary, I would qualify this choice as “unforgivable heresy”. Fortunately, We can alias this main keymap to <code>viins</code> (Vi INSERT mode) instead. We’ll see how below.</p><p>Some other keymaps are sometimes used in specific Zsh modes. In that case, they are called <em>local keymaps</em>. For example, we’ve seen <a href="https://thevaluable.dev/zsh-install-configure-mouseless/">in the first article</a> of this series how to bind keystrokes to the local keymap <code>menuselect</code>. It’s only available when selecting something in a list, like selecting a completion for example.</p><p>If we define the same keystroke both in a local and in a global keymap, the first overwrite the second.</p><p>That’s nice to have many keymaps to choose from, but it’s not enough. How do we bind custom keystrokes to these Zsh widgets?</p><h3 id="managing-the-bindings">Managing the Bindings</h3><p>To manage our custom keystrokes, we need to use the <code>bindkey</code> command. First, let’s see how we can display what was already bound by using:</p><ul><li><code>bindkey</code> - Output all the key bindings for the global keymap.</li><li><code>bindkey &lt;keystroke&gt;</code> - Output the widgets bound to a specific keystroke <code>&lt;keystroke&gt;</code> in the global keymap. For example: <code>bindkey &#39;^l&#39;</code>.</li><li><code>bindkey -r &lt;keystroke&gt;</code> - Delete the binding mapped to the keystroke <code>&lt;keystroke&gt;</code>. For example: <code>bindkey -r &#39;^l&#39;</code></li></ul><p>If you find that your keystroke is bound to the widget <code>undefined-key</code>, it means that it won’t have any effect. This widget is the incarnation of pure void. When you gaze long into the <code>undefined-key</code>, the <code>undefined-key</code> also gazes into you.</p><p>The two keys <code>CTRL</code> and <code>ALT</code> are often used for keystrokes; therefore, it’s useful to know how to tell Zsh to use one or the other in our key binding:</p><ul><li><code>^</code> - Represent the <code>CTRL</code> key. For example: <code>^c</code> for <code>CTRL+c</code>.</li><li><code>\e</code> - Represent the <code>ALT</code> key. For example: <code>\ec</code> for <code>ALT+c</code>.</li></ul><p>Note that it’s true for most modern terminals out there, but not all. We’ll come back to the joys of the escape characters soon.</p><p>One of the most common use of <code>bindkey</code> is, of course, to bind some custom keystrokes to some widget. To do so, you can follow this syntax:</p><div><pre><code data-lang="zsh">bindkey &lt;keystroke&gt; &lt;widget&gt;
</code></pre></div><p>For example, if we want to clear the screen with <code>CTRL+g</code>, we would need to bind the widget <code>clear-screen</code> as follows:</p><div><pre><code data-lang="zsh">bindkey <span>&#39;^g&#39;</span> clear-screen
</code></pre></div><p>We don’t have to bind keystrokes to widgets, however. We can bind them to whole series of keystrokes, as we were typing them in ZLE. To do so, we can use the bindkey’s option <code>-s</code>.</p><p>For example, if we want to bind <code>ALT+h</code> to the series of keystrokes <code>CTRL+L</code> (which clear the screen by default) and then writes “hello” because we’re excessively polite, we can run the following:</p><div><pre><code data-lang="zsh">bindkey -s <span>&#39;\eh&#39;</span> <span>&#39;^l hello&#39;</span>
</code></pre></div><p>How lovely!</p><h3 id="using-bindkey-with-specific-keymaps">Using bindkey with Specific Keymaps</h3><p>What if you want to manage the bindings for precise keymaps? Here’s a bunch of commands to do so:</p><ul><li><code>bindkey -l</code> - Output the <code>l</code>ist of all available keymaps.</li><li><code>bindkey -M &lt;keymap&gt;</code> - Output all the keybindings for the keymap <code>&lt;keymap&gt;</code>. For example: <code>bindkey -M viins</code>.</li><li><code>bindkey -M &lt;keymap&gt; &lt;keystroke&gt;</code> - Output the widget bound to the keystroke <code>&lt;keystroke&gt;</code> for the keymap <code>&lt;keymap&gt;</code>. For example: <code>bindkey -M vicmd u</code>.</li><li><code>bindkey -M &lt;keymap&gt; -r &lt;keystroke&gt;</code> - Delete the binding mapped to the keystroke <code>&lt;keystroke&gt;</code> for the keymap <code>&lt;keymap&gt;</code>. For example: <code>bindkey -M vicmd -r &#39;^l&#39;</code></li></ul><p>What about aliasing the main keymap, for Zsh to launch with the one you want to use by default? Here are two handy commands you can use:</p><ul><li><code>bindkey -e</code> - Alias the main keymap to the <code>emacs</code> keymap (the default).</li><li><code>bindkey -v</code> - Alias the main keymap to the <code>viins</code> keymap.</li></ul><p>These commands are aliases; they are respectively equivalent to the following commands:</p><ul><li><code>bindkey -A emacs main</code></li><li><code>bindkey -A viins main</code></li></ul><p>Note that you can’t bind the main keymap to the <code>vicmd</code> keymap, the equivalent of Vi NORMAL mode.</p><p>You can also uses <code>bindkey -lL main</code> to find out what keymap is aliased to the main one.</p><p>Fun fact: the <code>viins</code> keymap (Vi INSERT mode) has the keystroke <code>ESC</code> bound to the widget <code>vi-cmd-mode</code>. In this context, when you hit <code>ESC</code>, you’ll switch the global keymap from <code>viins</code> to <code>vicmd</code> (Vi NORMAL mode). That’s how you get the Zsh Vi mode.</p><p>Even funnier fact: the <code>emacs</code> keymap has also the keystroke <code>CTRL+x CTRL+v</code> (<code>^X^V</code>) bound to <code>vi-cmd-mode</code>. You can switch to Vi NORMAL mode from the <code>emacs</code> keymap! It finally proves, without any doubt, the superiority of Vi (and, by extension, Vim and Neovim) against Emacs.</p><h2 id="binding-all-the-keys">Binding All The Keys!</h2><p>We’ve seen quickly how to represent the special key <code>CTRL</code> or <code>ALT</code> to use them in our keystrokes. But what about the others?</p><h3 id="terminal-and-escape-sequence">Terminal and Escape Sequence</h3><p>If you use the <code>emacs</code> keymap, you’ll have most special keys bound to some sensible widgets, like the <code>HOME</code> key bound to <code>beginning-of-line</code>, or the <code>END</code> key bound to <code>end-of-line</code>. But, if you’re a Vim Believer like I am, you’ll reject this keymap with all the strength of your soul.</p><p>A question arise, then: how to bound these special keys to these widgets for the <code>viins</code> keymap? Or to other widgets, if we want to? How to represent these special keys for ZLE to know what we want to do?</p><p>It’s where we enter the muddy swamp of the TTY subsystem. I don’t want to drown us into too many details, so I’ll try to keep it brief. You can always play with my sanity by asking me to write an article about that in the comment section, at the end of this article.</p><p>When you type some special keys, like <code>BACKSPACE</code>, <code>HOME</code>, or <code>ENTER</code> for example, the terminal receives a <a href="https://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="noopener">control character (or escape sequence)</a>. This is how the terminal “see” the key you’ve harshly hit.</p><p>The good news: most modern terminal emulators out there will translate your keystrokes with the same control characters (or escape sequence), which mean that we could directly bind these representations to the widgets we want.</p><p>In practice, for you to display these sequences and use them in your bindings, you can use <code>CTRL+v</code> in your terminal followed by the special key you want to bind. It will output verbatim the control character sent, without interpreting it.</p><p>For example:</p><ol><li>When I hit <code>CTRL+v</code> in my terminal followed by the <code>HOME</code> key, I get the delightful escape sequence <code>^[[7~</code> (I would love to have that on a T-shirt, by the way).</li><li>I then bind it to the widget <code>beginning-of-line</code> for the keymap <code>viins</code> as follows: <code>bindkey -M viins &#39;^[[7~&#39; beginning-of-line</code>.</li></ol><p>Now, when I hit the <code>HOME</code> key in Zsh while using the <code>viins</code> keymap, my cursor moves at the beginning of the line. Incredible feat the world will remember!</p><p>If you want to display multiple escape sequences without having to hit <code>CTRL+v</code> again and again, you can also run <code>cat &gt; /dev/null</code> and hit whatever keystrokes you like.</p><p>This approach has one major drawback. Even if it’s true that most modern terminal emulators receive the same escape sequences, the world is not only made with modern terminal emulators. These sequences might differ for:</p><ul><li>Your TTYs (what you open when you hit <code>CTRL+ALT+&lt;FKEY&gt;</code> in Linux, <code>&lt;FKEY&gt;</code> being the keys from <code>F1</code> to <code>F12</code>).</li><li>Your terminal multiplexer (like <a href="https://thevaluable.dev/tmux-config-mouseless/">tmux</a> or screen).</li></ul><p>Because of these differences, there is another approach praised by many out there (even advised by the venerable <a href="https://wiki.archlinux.org/title/zsh#Key_bindings" target="_blank" rel="noopener">Arch Linux Wiki</a>): using terminfo.</p><h3 id="a-common-terminal-interface">A Common Terminal Interface</h3><p>This “terminfo” is a common database aimed to provide an unified interface between the different terminals available. It’s often used by CLIs to intercept the different escape sequences and perform some action. For example, Vi uses terminfo under the hood.</p><p>There is a problem with this approach, however: to use terminfo, we need to switch ZLE to “application mode”, only used normally by some CLIs and TUIs running in the shell (but not all). Since the command line editor of ZSH does not run in application mode by default, we need to switch to it before using terminfo.</p><p>It means that any CLI running in the terminal will run in this application mode too. If some of these CLIs are not meant to run in this mode, some keystrokes might not work.</p><p>Because it feels more like a hack than a proper solution, I personally try to avoid this method.</p><h3 id="automatically-mapping-escape-sequences-with-zkbd">Automatically Mapping Escape Sequences with zkbd</h3><p>We can also use “zkbd” from Zsh contrib. You can do so by following this workflow:</p><ol><li>Autoload zkbd by adding <code>autoload -Uz zkbd</code> to your <code>zshrc</code>.</li><li>Start a new Zsh process and run <code>zkbd</code> in your shell.</li><li>Answer the questions.</li></ol><p>After answering all questions, <code>zkbd</code> will create a bunch of files with all the escape sequences bound to the good widgets. I never really used <code>zkbd</code> to be honest, but it might help to get you started.</p><h3 id="personal-configuration">Personal Configuration</h3><p><a href="https://github.com/Phantas0s/.dotfiles/blob/master/zsh/bindings.zsh" target="_blank" rel="noopener">I’ve written a piece of configuration</a> showing both solutions proposed above (the one involving terminfo is commented out because I don’t use it). You can try it, I’m pretty sure it will work quite well if you don’t use some exotic terminal.</p><p>A last advice: if you use <a href="https://thevaluable.dev/tmux-config-mouseless/">tmux</a>, make sure that you have the line <code>set -g default-terminal &#34;tmux-256color&#34;</code> in your tmux configuration file for this config to work.</p><p>We’ve spoken a lot about keymaps and keybindings. What about the other side of the equation, the Zsh widgets themselves?</p><h3 id="built-in-widgets">Built-in Widgets</h3><p>There are many built-in widgets you can bind with the keystrokes of your dreams. Here are the different ways to get a complete list of these widgets:</p><ol><li>You can run <code>zle -la</code> in your shell.</li><li>You can look at the manual page for ZLE by running <code>man zshzle</code>. Search for “Standard Widgets”.</li><li>You can install the package <code>zsh-doc</code> and use a command for each widget, to find out its powers. For example: <code>info zsh beginning-of-line</code>.</li><li>You can <a href="https://zsh.sourceforge.io/Doc/Release/Zsh-Line-Editor.html#Standard-Widgets" target="_blank" rel="noopener">look online</a>.</li></ol><p>But reading is cheap, trying is the way to enlightenment. How to try a widget directly, to see what it does?</p><p>To call the widget <code>&lt;widget&gt;</code>, we need to use the command <code>zle &lt;widget&gt;</code>. You can try to run <code>zle end-of-line</code> for example, to see that it doesn’t work. How deceitful!</p><p>You’ll be indeed rewarded with a voluptuous <code>zle: widgets can only be called when ZLE is active</code>. It means that widgets can be called only when you write and edit your commands in the editor, not when you send them to your TTY by hitting <code>ENTER</code>.</p><p>As a result, we can call widgets inside widgets, because widgets are always called when ZLE is available. And since we can call widgets using specific keystrokes, what about a widget which can run any widget? That’s exactly the purpose of <code>execute-named-cmd</code>. It’s bound by default to the keystrokes <code>ESC x</code> for the <code>emacs</code> keymap and <code>:</code> for the <code>vicmd</code> keymap (Vi NORMAL mode).</p><p>If you hit the good keystrokes depending of the global keymap you’re using, a new prompt will appear. There, you can call any widget you want; they will act on whatever command you’ve began to type in your editor, if any. Even better: you can complete the widget’s name you want to run in this new prompt by using <code>TAB</code>, as always.</p><p>Using <code>execute-named-cmd</code>, you can then run two other useful widgets if you want to know what widget is bound to what keystroke (and vice-versa):</p><ul><li><code>where-is</code> - Open yet another prompt where you can type the name of a widget. It will then output its keybinding (if any).</li><li><code>describe-key-briefly</code> - Open yet another prompt where you can hit a keystroke. It will then output the widget bound to that keystroke (if any).</li></ul><h3 id="widgets-from-zsh-user-contributions">Widgets from Zsh User Contributions</h3><p>There are also more widgets available via Zsh contrib (<code>man zshcontrib</code>), like the wonderful <code>edit-command-line</code>, allowing you to edit your commands in <del>Vim</del> your favorite editor, or <code>select-quoted</code>, useful to create Vi text-object representing quoted substring. More on that below.</p><p>I’ve covered many of these widgets in the <a href="https://thevaluable.dev/zsh-install-configure-mouseless/">first article of this series</a>. Don’t forget that you need to autoload them before using them. They are not always documented, but you can directly look at what you can use on the <a href="https://github.com/zsh-users/zsh/tree/master/Functions/Zle" target="_blank" rel="noopener">Zsh mirror repository</a>.</p><p>For example, if you want to use the widget <code>incarg</code> from Zsh contrib to increment a number using a keystroke, you can add to your <code>zshrc</code>:</p><div><pre><code data-lang="zsh">autoload -Uz incarg
zle -N incarg
bindkey -M vicmd <span>&#39;^a&#39;</span> incarg
</code></pre></div><p>Now, when your cursor is on a number and you hit <code>CTRL+a</code>, it will be incremented by the power of your spirit.</p><h3 id="writing-your-own-widget">Writing your Own Widget</h3><p>Using built-in widgets is definitely useful, but we can push the customization even further: what about widgets designed by your talented creativity?</p><h4 id="executing-a-command-while-writing-another">Executing A Command While Writing Another</h4><p>As we saw just above, we can create our own widget using <code>zle -N &lt;shell_function&gt;</code>. If an existing widget has already the same name, it will be overwritten. That’s why built-in widgets have two names: one with a dot <code>.</code> prefix, and one without. If you overwrite the built-in widget <code>end-of-line</code> for example, you can still access the original one by using <code>.end-of-line</code>. As a result, it’s considered good practice to never prefix your own widgets with a dot; it should be reserved to the most important widgets, the built-in ones.</p><p>Enough rambling. Let’s build our first widget!</p><p>We can imagine that you’re writing a command in your shell, and suddenly you wonder what you’ve modified in your project. The best would be to:</p><ol><li>Run <code>git diff</code>.</li><li>Go back to the command you were writing.</li></ol><p>Here’s the widget:</p><div><pre><code data-lang="zsh"><span>function</span> _git-diff <span>{</span>
    zle .kill-whole-line
    zle -U <span>&#34;git diff
</span><span></span><span>$CUTBUFFER</span><span>&#34;</span>
<span>}</span>

zle -N _git-diff
bindkey <span>&#39;^Xd&#39;</span> _git-diff
</code></pre></div><p>What happens in there?</p><ol><li>We use <code>zle</code> to run the widget <code>.kill-whole-line</code> (we use the dot-prefixed name in case <code>kill-whole-line</code> was overwritten somewhere else). It will remove the command you were crafting with enthusiasm and love.</li><li>We run <code>zle -U</code>. This command inserts some string in ZLE, exactly like you would type them in the editor.</li><li>We declare the function <code>_git-diff</code> as a widget. We can run it in ZLE by hitting <code>CTRL+x</code> and then <code>d</code>.</li></ol><p>It’s worthwhile to explain further the second point:</p><ul><li>The character between <code>git diff</code> and <code>$CUTBUFFER</code> is actually a carriage return, the control character <code>^M</code>. I’ve made it by hitting <code>CTRL+v</code> and then <code>ENTER</code>.</li><li>The variable <code>$CUTBUFFER</code> contains whatever was deleted when using a widget beginning with <code>kill-</code>. It allows us to bring back the command previously deleted with <code>.kill-whole-line</code>.</li></ul><p>The underscore <code>_</code> prefixing the function’s name indicates that the function is a widget. It’s just a personal convention to know what shell function is a widget, and what isn’t; you don’t have to do the same with your widgets.</p><p>And voila! We’ve our first marvelous and useless little widget.</p><p>It’s not the only implementation possible: we could try to run <code>git diff</code> first, and then bring back the command deleted as follows:</p><div><pre><code data-lang="zsh">zle -U <span>&#34;git diff&#34;</span>
zle -U <span>&#34;</span><span>$CUTBUFFER</span><span>&#34;</span>
</code></pre></div><p>I’m afraid I’ve to deceive you once again; at the point, it’s a miracle you’re sill reading this article. The commands above won’t do what we want them to do.</p><p>In fact, <code>zle -U</code> put strings on the stack of ZLE, and pull them back in the editor <em>when the widget terminates</em>. And since it’s a stack (LIFO, Last In, First Out), <code>$CUTBUFFER</code> would be inserted in the editor <em>before</em> <code>git diff</code>! To fix that, you could swap the two declarations above, but it makes the widget more difficult to understand.</p><p>Here’s another, cleaner solution:</p><div><pre><code data-lang="zsh"><span>function</span> _git-diff <span>{</span>
    zle push-line
    <span>BUFFER</span><span>=</span><span>&#34;git diff&#34;</span>
    zle accept-line
<span>}</span>

zle -N _git-diff
bindkey <span>&#39;^Xd&#39;</span> _git-diff
</code></pre></div><p>What happens there?</p><ol><li>We use the widget <code>push-line</code>. It pushes the command on the edit buffer stack, and pull it back the next time ZLE is available.</li><li>We change the current buffer to <code>git diff</code>.</li><li>We use the widget <code>accept-line</code> which runs whatever command written in ZLE (in that case, <code>git diff</code>).</li><li>The widget <code>push-line</code> pull back the command from the buffer stack. It even keeps the cursor position!</li></ol><h4 id="a-widget-to-prefix-your-commands">A Widget to Prefix Your Commands</h4><p>Let’s take another example. Let’s say that you want a widget to prepend “vim” to any command. A noble idea! Here’s a possible solution:</p><div><pre><code data-lang="zsh"><span>function</span> _vim <span>{</span>
    <span>[[</span> ! <span>$BUFFER</span> <span>=</span>~ <span>&#39;^vi.*&#39;</span> <span>]]</span> <span>&amp;&amp;</span> <span>BUFFER</span><span>=</span><span>&#34;vim </span><span>$BUFFER</span><span>&#34;</span> <span>&amp;&amp;</span> zle end-of-line
<span>}</span>

zle -N _vim
bindkey -M vicmd <span>&#39;^Xv&#39;</span> _vim
</code></pre></div><p>If the regular expression <code>^vi.*</code> is not matched, it:</p><ol><li>Inserts <code>vim</code> at the beginning of the command.</li><li>Moves the cursor to the end of the line.</li></ol><p>Quite easy, isn’t it?</p><h4 id="managing-surrounding">Managing Surrounding</h4><p>I mentioned, <a href="https://thevaluable.dev/zsh-install-configure-mouseless/">in the first article of this series</a>, a way to create new Vi text-objects and bind them to some specific widgets with the following commands:</p><div><pre><code data-lang="zsh">autoload -Uz <span>select</span>-bracketed <span>select</span>-quoted
zle -N <span>select</span>-quoted
zle -N <span>select</span>-bracketed
<span>for</span> km in viopp visual<span>;</span> <span>do</span>
  <span>for</span> c in <span>{</span>a,i<span>}</span><span>${</span><span>(s..)^</span><span>:-</span><span>\&#39;\&#34;\`\|</span><span>,./:;=+@</span><span>}</span><span>;</span> <span>do</span>
    bindkey -M <span>$km</span> -- <span>$c</span> <span>select</span>-quoted
  <span>done</span>
  <span>for</span> c in <span>{</span>a,i<span>}</span><span>${</span><span>(s..)^</span><span>:-</span><span>&#39;()[]{}&lt;&gt;bB&#39;</span><span>}</span><span>;</span> <span>do</span>
    bindkey -M <span>$km</span> -- <span>$c</span> <span>select</span>-bracketed
  <span>done</span>
<span>done</span>
</code></pre></div><p>We’re now able to understand what’s going on in there:</p><ol><li>We loop through the two keymaps <code>viopp</code> (Vi OPERATOR-PENDING mode) and <code>visual</code> (Vi VISUAL mode).</li><li>We loop through a whole bunch of signs we want to consider as quotes (or brackets), and we add to each of them the prefix <code>i</code> or <code>a</code> (for <code>i</code>nside and <code>a</code>round, respectively).</li><li>We use the <code>bindkey</code> command to bind these new text-objects to both keymaps.</li></ol><p>If you’re not sure what’s the Vi OPERATOR-PENDING mode, I’ve written about it in <a href="https://thevaluable.dev/vim-expert/" target="_blank" rel="noopener">this article about Vim</a>. It’s can be used to create new text-objects. Here are the ones we bind to the <code>select-bracketed</code> widget: <code>a(</code>,<code>i(</code>,<code>a)</code>,<code>i)</code>,<code>a[</code>,<code>i[</code>,<code>a]</code>,<code>i]</code>,<code>a{</code>,<code>i{</code>,<code>a}</code>,<code>i}</code>,<code>a&lt;</code>,<code>i&lt;</code>,<code>a&gt;</code>,<code>i&gt;</code>,<code>ab</code>,<code>ib</code>,<code>aB</code>,<code>iB</code>.</p><p>If you want to know exactly what text-objects are created, you can add <code>echo $c</code> in both nested loops before the command <code>bindkey</code>.</p><h2 id="the-power-of-the-zsh-line-editor">The Power of the Zsh Line Editor</h2><p>Well, that was quite a trip! Thanks to custom keybidings and widgets, the Zsh Line Editor is a valuable tool, allowing us to make our shell experience an effective one.</p><p>What did we see in this article?</p><ul><li>The Zsh Line Editor (ZLE) is the command prompt where you can write and edit your commands.</li><li>The main keymap is the set of keystrokes which is loaded by default when Zsh is launched.</li><li>The global keymap is the one used to edit commands in Zsh. Local keymaps can be used in some specific Zsh modes, like selecting elements in a list.</li><li>A widget is a shell function which can be executed after hitting specific keystrokes. They can call other widgets, and they have access to special variables to manipulate the line editor.</li><li>We can look at the keystrokes already bound, and bind new ones to specific widgets with the <code>bindkey</code> command.</li><li>The terminal will interpret special keys with specific escape sequences. We can map them directly to some widgets, or use terminfo in application mode.</li><li>We can create our own widgets to customize even more what we can do in ZLE.</li></ul><p>When you’re annoyed by some functionalities which should be implemented while typing your commands in Zsh, it’s a good opportunity to write a widget to answer your need. That’s how you create a <a href="https://themouseless.dev" target="_blank" rel="noopener">highly customized Mouseless Development Environment</a>: by solving one little problem at a time.</p></section></article></div></div>
  </body>
</html>
