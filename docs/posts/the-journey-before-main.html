<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://amit.prasad.me/blog/before-main">Original</a>
    <h1>The Journey Before main()</h1>
    
    <div id="readability-page-1" class="page"><div><p>A while back, I worked on a <a href="https://github.com/AmitPr/RISCuit" rel="nofollow">RISC-V-based userspace simulator</a> for fun. In doing so, taught myself a lot more than I wanted to know about what happens in-between when the Kernel is asked to run a program, and when the first line of our program’s <code>main</code> function is actually executed. Here’s a summary of that rabbit hole.</p> <h2>In the beginning…</h2> <p>First question: When is the OS kernel actually asked to run any program? The answer, at least on Linux, is the <code>execve</code> system call (“syscall”). Let’s take a quick look at that:</p> <!----><pre tabindex="0"><code><span><span>int</span><span> execve</span><span>(</span><span>const</span><span> char</span><span> *</span><span>filename</span><span>,</span><span> char</span><span> *</span><span>const</span><span> argv</span><span>[]</span><span>,</span><span> char</span><span> *</span><span>const</span><span> envp</span><span>[]</span><span>)</span><span>;</span></span></code></pre><!----> <p>This is actually quite straightforward! We pass the name of the exectuable file, a list of arguments, and a list of environment variables. This signals to the kernel where, and how, to start loading the program.</p> <p>Many programming languages provide an interface to execute commands that eventually call <code>execve</code> under the hood. For example, in Rust, we have:</p> <!----><pre tabindex="0"><code><span><span>use</span><span> std</span><span>::</span><span>process</span><span>::</span><span>Command</span><span>;</span></span>
<span></span>
<span><span>Command</span><span>::</span><span>new</span><span>(</span><span>&#34;ls&#34;</span><span>)</span><span>.</span><span>arg</span><span>(</span><span>&#34;-l&#34;</span><span>)</span><span>.</span><span>spawn</span><span>();</span></span></code></pre><!----> <p>In these higher-level wrappers, the language’s standard library often handles translation of the command name to a full path, acting similarly to how a shell would resolve the command via the <code>PATH</code> environment variable. The kernel itself, however, expects a proper path to an executable file.</p> <blockquote><p>A note on interpreters: If the executable file starts with a shebang (<code>#!</code>), the kernel will use the shebang-specified interpreter to run the program. For example, <code>#!/usr/bin/python3</code> will run the program using the Python interpreter, <code>#!/bin/bash</code> will run the program using the Bash shell, etc.</p></blockquote> <h2>ELF</h2> <p>What does an executable file look like? On Linux, it’s <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="nofollow">ELF</a>, which the kernel knows how to parse. Other operating systems have different formats (e.g. Mach-O on MacOS, PE on Windows), but ELF is the most common format on Linux. I won’t go into too much detail here, to keep things brief, but ELF files have grown out of the original <code>a.out</code> format, and are expressive enough to support pretty much every program you’ll ever write. Here’s what the header of an ELF file looks like:</p> <!----><pre tabindex="0"><code><span><span>%</span><span> readelf</span><span> -h</span><span> main</span><span> # main is an ELF file</span></span>
<span><span>ELF</span><span> Header:</span></span>
<span><span>  Magic:</span><span>   7f</span><span> 45</span><span> 4c</span><span> 46</span><span> 01</span><span> 01</span><span> 01</span><span> 03</span><span> 00</span><span> 00</span><span> 00</span><span> 00</span><span> 00</span><span> 00</span><span> 00</span><span> 00</span></span>
<span><span>  Class:</span><span>                             ELF32</span></span>
<span><span>  Data:</span><span>                              2</span><span>&#39;s complement, little endian</span></span>
<span><span>  Version:                           1 (current)</span></span>
<span><span>  OS/ABI:                            UNIX - GNU</span></span>
<span><span>  ABI Version:                       0</span></span>
<span><span>  Type:                              EXEC (Executable file)</span></span>
<span><span>  Machine:                           RISC-V</span></span>
<span><span>  Version:                           0x1</span></span>
<span><span>  Entry point address:               0x10358</span></span>
<span><span>  Start of program headers:          52 (bytes into file)</span></span>
<span><span>  Start of section headers:          675776 (bytes into file)</span></span>
<span><span>  Flags:                             0x1, RVC, soft-float ABI</span></span>
<span><span>  Size of this header:               52 (bytes)</span></span>
<span><span>  Size of program headers:           32 (bytes)</span></span>
<span><span>  Number of program headers:         7</span></span>
<span><span>  Size of section headers:           40 (bytes)</span></span>
<span><span>  Number of section headers:         32</span></span>
<span><span>  Section header string table index: 31</span></span></code></pre><!----> <p>The important parts here are:</p> <ol><li>The “ELF Magic” bytes, which tell the kernel that this is, indeed, an ELF file. <code>45 4c 46</code> is ASCII for “ELF”!</li> <li>“Class” tells us we’re dealing with a 32-bit executable.</li> <li>“Start of …” tells us <em>where</em> things are in the file, and “Size of …” tells us how big they are; The kernel is effectively given a map of the file.</li> <li>“Entry point address” — Relatively self-explanatory! But we’ll be coming back to this.</li></ol> <p>Other ELF files will have different entries and specific values, but the general structure is what we’re after here.</p> <blockquote><p>As you can see by the numerous mentions to “RISC-V”, this is an ELF file I compiled and linked targeting the RV32 architecture (which the aforementioned emulator is built for), hence the “32” in “ELF32”, the “RVC” flag, and the “RISC-V” machine type.</p></blockquote> <h3>More than just a header</h3> <p>ELF files contain everything our program needs to run, including the code, data, symbols, and more. We can see this again with the <code>readelf</code> command with the <code>-a</code> flag. Here’s what we care about:</p> <!----><pre tabindex="0"><code><span><span>Section Headers:</span></span>
<span><span>  [Nr] Name              Type            Addr     Off    Size</span></span>
<span><span>  [ 0]                   NULL            00000000 000000 000000</span></span>
<span><span>  [ 1] .note.ABI-tag     NOTE            00010114 000114 000020</span></span>
<span><span>  [ 2] .rela.plt         RELA            00010134 000134 00000c</span></span>
<span><span>  [ 3] .plt              PROGBITS        00010140 000140 000010</span></span>
<span><span>  [ 4] .text             PROGBITS        00010150 000150 03e652</span></span>
<span><span>  [ 5] .rodata           PROGBITS        0004e7b0 03e7b0 01b208</span></span>
<span><span>  ...</span></span>
<span><span>  [16] .data             PROGBITS        0007a008 069008 000dec</span></span>
<span><span>  [17] .sdata            PROGBITS        0007adf4 069df4 000004</span></span>
<span><span>  [18] .bss              NOBITS          0007adf8 069df8 002b6c</span></span>
<span><span>  ...</span></span>
<span><span>  [29] .symtab           SYMTAB          00000000 095124 009040</span></span>
<span><span>  [30] .strtab           STRTAB          00000000 09e164 006d10</span></span></code></pre><!----> <p>These sections contain code (<code>.text</code>), data (<code>.data</code>), space for global variables (<code>.bss</code>), shims for accessing shared library functions (<code>.plt</code>), and quite a bit more (including symbol tables for debugging, relocation tables, etc.), most of which we won’t be discussing.</p> <p>So evidently, there’s some code that we care about in the <code>.text</code> section, so we copy that and call it a day? Not quite. There’s a massive amount of machinery inside the kernel to make all sorts of programs under all sorts of conditions run.</p> <p>For example, the “PLT” (Procedure Linkage Table) is a section that allows us to call functions in “shared libraries”, for example, <code>libc</code>, without having to package them alongside our program (“dynamically” vs “statically linking”). The ELF file contains a dynamic section which tells the kernel which shared libraries to load, and another section which tells the kernel to dynamically “relocate” pointers to those functions, so everything checks out.</p> <blockquote><p><code>libc</code> is the C standard library, which contains all the “useful” functions: <code>printf</code>, <code>malloc</code>, etc. Various flavors implementing the <code>libc</code> interfaces exist, most commonly <code>glibc</code> and <code>musl</code>. Most of the binaries that are discussed in this post are compiled and linked against <code>musl</code>, since it’s much easier to statically link.</p></blockquote> <p>The symbol table looks something like this:</p> <!----><pre tabindex="0"><code><span><span>Symbol table &#39;.symtab&#39; contains 2308 entries:</span></span>
<span><span>   Num:    Value  Size Type    Bind   Vis      Ndx Name</span></span>
<span><span>     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span>
<span><span>     1: 00010114     0 SECTION LOCAL  DEFAULT    1 .note.ABI-tag</span></span>
<span><span>     2: 00010134     0 SECTION LOCAL  DEFAULT    2 .rela.plt</span></span>
<span><span>     3: 00010140     0 SECTION LOCAL  DEFAULT    3 .plt</span></span>
<span><span>     4: 00010150     0 SECTION LOCAL  DEFAULT    4 .text</span></span>
<span><span>     ...</span></span>
<span><span>     1782: 00010358    30 FUNC    GLOBAL HIDDEN     4 _start</span></span>
<span><span>     ...</span></span>
<span><span>     1917: 00010430    52 FUNC    GLOBAL DEFAULT    4 main</span></span>
<span><span>     2201: 00010506   450 FUNC    GLOBAL HIDDEN     4 __libc_start_main</span></span>
<span><span>     ...</span></span></code></pre><!----> <p>You may ask: “Wow! <code>2308</code> looks like a lot, right? What behemoth of a program could possibly need that many symbols?“.</p> <p>Good question! Here’s the behemoth:</p> <!----><pre tabindex="0"><code><span><span>#include</span><span> &lt;stdio.h&gt;</span></span>
<span></span>
<span><span>int</span><span> main</span><span>() {</span></span>
<span><span>  printf</span><span>(</span><span>&#34;Hello, World!</span><span>\n</span><span>&#34;</span><span>)</span><span>;</span></span>
<span><span>  return</span><span> 0</span><span>;</span></span>
<span><span>}</span></span></code></pre><!----> <p>Yeah, that’s it. Now, <code>2308</code> may be <em>slightly</em> bloated because we link against <code>musl</code> instead of <code>glibc</code>, but the point still stands: There’s <em>a lot</em> of stuff going on behind the scenes here.</p> <p>The kernel’s job here is to iterate over each section, loading those marked as “loadable”. Some security mitigations start to become relevant here, such as moving sections around in memory (ASLR — Address Space Layout Randomization), marking sections as non-executable (NX bit — hardware-level security), etc. But ultimately, the kernel loads the code and data into memory, sets up the stack, and prepares to jump to the entry point of the program.</p> <h2>The stack</h2> <p>Ah yes, the infamous stack! Fortunately for most of us, the stack is something we take for granted. Unfortunately for the kernel, the stack is not some omnipotent magical space that just exists — it needs to be set up properly before our program can run.</p> <p>As a reminder: stack space is typically used for variables, function arguments, “frames” (to keep track of function-local variables, call trees, etc), and a variety of other things, depending on what, and how your program is running.</p> <p>Hypothetically, if we simplify a bit and say that the ELF file is loaded into memory starting at the zero address, the stack is typically placed at the “opposite end” of the memory, from a high address, and grows “downwards” towards the lower addresses, with the space in-between used as heap space, and for other data (shared libraries, mmapped files, etc). This is a simplification, but in fairness, there is significant ambiguity as much of the semantics here depend on the program itself.</p> <p>The stack is also something that is non-empty! Remember <code>argv</code> and <code>envp</code> from the <code>execve</code> call above? Those are passed to the program via the stack. In most programming languages we frequently access these via the various <code>args</code> and <code>env</code> utilities, whether that be directly, like in C, or more indirectly, like in Rust (<code>std::env</code>) or Python (<code>sys.argv</code>).</p> <p>The kernel also stores something called the “ELF auxiliary vector” in the nascent stack. This “auxv” contains information about the environment, such as the memory page size, metadata from the ELF file, and other system information. These are important! For example, <code>musl</code> uses the “page size” entry of the auxv so that <code>malloc</code> can request and manage memory more optimally. There are over 30 entries in the auxiliary vectors, but not all of them are used by every program (and some may not be defined by the kernel).</p> <p>Let’s pretend we’re the kernel. Here’s a simplified version of how we might setup the stack of a new process (taken and simplified from my RISC-V emulator, which also emulates parts of the kernel):</p> <!----><pre tabindex="0"><code><span><span>// Choose an arbitrary high address for the stack</span></span>
<span><span>let</span><span> mut</span><span> sp </span><span>=</span><span> 0xCFFF_F000</span><span>u32</span><span>; </span><span>// sp = &#34;stack pointer&#34;</span></span>
<span><span>let</span><span> mut</span><span> stack_init</span><span>:</span><span> Vec</span><span>&lt;</span><span>u32</span><span>&gt; </span><span>=</span><span> vec!</span><span>[]; </span><span>// The stack begins empty.</span></span>
<span></span>
<span><span>stack_init</span><span>.</span><span>push</span><span>(args</span><span>.</span><span>len</span><span>()); </span><span>// argc: number of arguments</span></span>
<span><span>for</span><span> &amp;</span><span>arg </span><span>in</span><span> args</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>rev</span><span>() {</span></span>
<span><span>    // Copy each argument to the stack</span></span>
<span><span>    sp </span><span>-=</span><span> arg</span><span>.</span><span>len</span><span>() </span><span>// move &#34;downwards&#34; in address space</span></span>
<span><span>    mem</span><span>.</span><span>copy_to</span><span>(sp, arg);</span></span>
<span></span>
<span><span>    // Keep track of the arg pointer in the init vector</span></span>
<span><span>    stack_init</span><span>.</span><span>push</span><span>(sp);</span></span>
<span><span>}</span></span>
<span><span>stack_init</span><span>.</span><span>push</span><span>(</span><span>0</span><span>); </span><span>// argv NULL terminator</span></span>
<span></span>
<span><span>// Environment variables are similar:</span></span>
<span><span>for</span><span> &amp;</span><span>e </span><span>in</span><span> env</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>rev</span><span>() {</span></span>
<span><span>    sp </span><span>-=</span><span> e</span><span>.</span><span>len</span><span>();</span></span>
<span><span>    mem</span><span>.</span><span>copy_to</span><span>(sp, e);</span></span>
<span></span>
<span><span>    stack_init</span><span>.</span><span>push</span><span>(sp);</span></span>
<span><span>}</span></span>
<span><span>stack_init</span><span>.</span><span>push</span><span>(</span><span>0</span><span>); </span><span>// envp NULL terminator</span></span>
<span></span>
<span><span>// Setup the auxiliary vector</span></span>
<span><span>stack_init</span><span>.</span><span>push</span><span>(</span><span>libc_riscv32</span><span>::</span><span>AT_PAGESZ</span><span>); </span><span>// Keys for auxv</span></span>
<span><span>stack_init</span><span>.</span><span>push</span><span>(</span><span>0x1000</span><span>); </span><span>// Values for auxv; this specifies a 4 KiB page size</span></span>
<span><span>stack_init</span><span>.</span><span>push</span><span>(</span><span>libc_riscv32</span><span>::</span><span>AT_ENTRY</span><span>);</span></span>
<span><span>stack_init</span><span>.</span><span>push</span><span>(</span><span>self</span><span>.</span><span>pc); </span><span>// N.B.: We&#39;ll be coming back to this</span></span>
<span><span>// ...</span></span>
<span></span>
<span><span>// Copy the stack init vector, with all the pointers, to the stack</span></span>
<span><span>sp </span><span>-=</span><span> (stack_init</span><span>.</span><span>len</span><span>() </span><span>*</span><span> 4</span><span>);</span></span>
<span></span>
<span><span>mem</span><span>.</span><span>copy_to</span><span>(sp, </span><span>&amp;</span><span>stack_init)</span></span></code></pre><!----> <p>A diagram might help illustrate what the address space looks like at this point:</p> <!----> <h2>Entrypoint</h2> <p>Finally, we get to the “entry point” address, mentioned at several points. This is the address of the first instruction to run in the process. Typically, this is under a function called <code>_start</code>. Both glibc and musl provide implementations of <code>_start</code>, but it’s also possible to write your own. Again, here’s a Rust example:</p> <!----><pre tabindex="0"><code><span><span>// Disable the language runtime, we&#39;re DIYing it.</span></span>
<span><span>#![no_std]</span></span>
<span><span>#![no_main]</span></span>
<span></span>
<span><span>#[panic_handler]</span></span>
<span><span>fn</span><span> panic</span><span>(_info</span><span>:</span><span> &amp;</span><span>core</span><span>::</span><span>panic</span><span>::</span><span>PanicInfo</span><span>) </span><span>-&gt;</span><span> !</span><span> {</span></span>
<span><span>    loop</span><span> {}</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[no_mangle]</span></span>
<span><span>pub</span><span> extern</span><span> &#34;C&#34;</span><span> fn</span><span> _start</span><span>() </span><span>-&gt;</span><span> !</span><span> {</span></span>
<span><span>    // Instead of &#34;waiting&#34; for main, we can immediately start execution.</span></span>
<span><span>    loop</span><span> {}</span></span>
<span><span>}</span></span></code></pre><!----> <p>Depending on your program, <code>_start</code> may be the only thing between the entrypoint and your main function, but most languages have some sort of runtime that needs to be initialized first. For example, Rust has <code>std::rt::lang_start</code>. It’s at this part that things like global constructors, thread-local storage, and other language-specific features are set up.</p> <p>Here, our journey comes to an end — things become much more language-specific from this point on. Most languages will set up their own runtimes (yes, even C and C++ have a “runtime”!), and eventually call the standard <code>main</code> function we’re normally familiar with.</p> <p>In Rust, the generated code ends up looking like the following:</p> <!----><pre tabindex="0"><code><span><span>// the user defined main function</span></span>
<span><span>fn</span><span> main</span><span>() { </span><span>println!</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>); }</span></span>
<span></span>
<span><span>// the generated _start function</span></span>
<span><span>fn</span><span> _start</span><span>() </span><span>-&gt;</span><span> {</span></span>
<span><span>    let</span><span> argc </span><span>=</span><span> ...</span><span>; </span><span>// get argc from stack</span></span>
<span><span>    let</span><span> argv </span><span>=</span><span> ...</span><span>; </span><span>// get argv from stack</span></span>
<span><span>    let</span><span> envp </span><span>=</span><span> ...</span><span>; </span><span>// get envp from stack</span></span>
<span><span>    let</span><span> main_fn </span><span>=</span><span> main; </span><span>// pointer to user main function</span></span>
<span><span>    std</span><span>::</span><span>rt</span><span>::</span><span>lang_start</span><span>(argc, argv, main_fn);</span></span>
<span><span>}</span></span></code></pre><!----> <p>With the <code>lang_start</code> function (defined here)[https://github.com/rust-lang/rust/blob/04ff05c9c0cfbca33115c5f1b8bb20a66a54b799/library/std/src/rt.rs#L199] and taking care of the rest.</p> <p>C and C++ have similar, minimal setups. Languages that are traditionally thought to have “heavier” runtimes, such as Java or Python, work the same way, but with the <code>std::rt::lang_start</code> equivalent doing far more than the Rust/C/C++ runtimes.</p> <p>And there you have it! I’m missing lots of detail here, but hopefully this gives a rough idea of what happens before <code>main()</code> gets called. I’ve left out complexity that is mostly internal to “real” linux kernels, such as how the kernel sets up address space, the process tables, various group semantics, and et cetera, but I hope this still serves as a decent primer.</p> <p>Feel free to reach out to me with any questions or corrections!</p><!----></div></div>
  </body>
</html>
