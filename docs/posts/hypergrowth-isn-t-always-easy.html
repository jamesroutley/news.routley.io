<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tailscale.com/blog/hypergrowth-isnt-always-easy">Original</a>
    <h1>Hypergrowth isn’t always easy</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>A <a target="" rel="noreferrer" href="https://www.reddit.com/r/Tailscale/comments/1qesb9f/comment/o00he2c/">recent Reddit thread</a> noted that Tailscale&#39;s uptime has been, uh, shakier than usual in the last month or so, which included the holiday season. I can&#39;t deny it. We believe in transparency, so we have our uptime history available on our <a target="" rel="noreferrer" href="https://status.tailscale.com/history">status page</a> that will confirm it for you.</p><p>We are committed to visibility which is why we maintain this public uptime history page. But one challenge of maintaining visibility is it can leave our status updates open to a wide range of interpretations or assumptions. When we say, &#34;coordination server performance issues,&#34; is that an outage, or is it just slow? Does it affect everyone or just some people? If Tailscale&#39;s coordination service is down, does that mean my connections are broken? And when you say &#34;coordination server&#34; … wait ... surely we run more than one server?</p><p>Great questions, and the answers are all kind of tied together. Let&#39;s go through them. We don&#39;t get enough chances to talk about our system architecture, anyway.</p><p>First of all, the history section of the status page actually has more detail than it seems at a glance. Despite the lack of visual affordances, you can click on each incident to get more details. For example, this <a target="" rel="noreferrer" href="https://status.tailscale.com/incidents/01KE717PRRK3H9PTNHDS7BZECH">incident from Jan 5</a>:</p><figure id=""><img _type="asset" video="[object Object]" alt="Screenshot from Tailscale&#39;s status page. At bottom, &#34;Identified: Due to planned maintenance, a small number of tailnets will be unable to access the admin console or carry out actions relying on the coordination server. Other tailnets may see increased tendencies and errors during this maintenance window.&#34; At top: &#34;Resolved: The coordination server is healthy and this incident has been resolved.&#34;" loading="lazy" width="1025" height="504" decoding="async" data-nimg="1" srcset="https://cdn.sanity.io/images/w77i7m8x/production/b98256852d73cc9023869b6beb93463e36ca5bf2-1025x504.png?w=1080&amp;q=75&amp;fit=clip&amp;auto=format 1x, https://cdn.sanity.io/images/w77i7m8x/production/b98256852d73cc9023869b6beb93463e36ca5bf2-1025x504.png?w=3840&amp;q=75&amp;fit=clip&amp;auto=format 2x" src="https://cdn.sanity.io/images/w77i7m8x/production/b98256852d73cc9023869b6beb93463e36ca5bf2-1025x504.png?w=3840&amp;q=75&amp;fit=clip&amp;auto=format"/></figure><p>Looks like whatever happened took 24 minutes, and affected a small number of tailnets, but it still caused increased latency and prevented some people from carrying out actions. That’s disruptive, and we’re sorry. If you’re wondering why there wasn’t an advance notification, here’s the context. We detected an internal issue early, before it caused user-visible impact, and intervened to repair it. Part of that repair required briefly taking a shard offline, which created a short period of customer impact.</p><p>Part of engineering is measuring, writing down what went wrong, and making a list of improvements so it doesn’t go wrong next time. <a target="" rel="noreferrer" href="https://en.wikipedia.org/wiki/Kaizen">Continuous improvement</a>, basically.</p><p>To be clear: this was an outage, and we’re not trying to downplay it. The difference here is in the shape of the failure. Thanks to many person-years of work, it was planned rather than accidental, limited to a small number of tailnets, and for most other tailnets primarily showed up as increased latency rather than broader unavailability. We also resolved it faster than similar incidents in the past. Continuous improvement means measuring blast radius, severity, and time to recovery, and steadily improving them, even as we continue to scale.</p><h2 id="tailscales-architecture"><a href="#tailscales-architecture">Tailscale&#39;s architecture<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2><p>We probably should stop referring to a &#34;coordination server&#34; and start calling it a &#34;coordination service.&#34; Once upon a time, it was indeed just one big server in the sky. True story: that one big server in the sky hit over a million simultaneously connected nodes before we finally succeeded in <em>sharding</em> it, or spreading the load across multiple servers. As computer science students quickly learn, there are only three numbers: 0, 1, and more than 1. No servers running, one big server, or lots of servers. So now we have lots of servers.</p><p>But, unlike many products where each stateless server instance can serve any customer, on Tailscale, every tailnet still sits on exactly one coordination server at any given moment (but can live migrate from one to another). That&#39;s because, as we realized maybe five years into the game, a coordination server is not really a server in the classic sense. It&#39;s a message bus. And the annoying thing about message buses is they are annoyingly hard to scale without making them orders of magnitude slower.</p><p>That thing in Tailscale where you change your ACLs, and they&#39;re reflected everywhere on your tailnet, no matter how many nodes you have, usually in less than a second? That&#39;s a message bus that was designed for <em>speed</em>. Compared to classic firewalls that need several minutes and a reboot to (hopefully) change settings, it&#39;s pretty freakin&#39; awesome. But, that high-speed centralized (per tailnet anyway) message bus design has consequences. One of the consequences is, when the bus eventually has any amount of downtime, no <em>control plane </em>messages are getting passed, for the nodes connected to that instance.</p><p>We knew this when we started, so we designed around it. No matter how resilient or distributed or <a target="" rel="noreferrer" href="https://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a> or Unbreakable or “Nobody Ever Got Fired For” your architecture is, sooner or later your <em>client devices</em> get disconnected from it. Maybe they fall off the internet temporarily. Maybe your home Wi-Fi router reboots. Maybe your DNS server goes down. Or yes, maybe the coordination server instance you&#39;re assigned to has an outage. Speaking of CAP theorem, that&#39;s the “P”: network <em>partitioning</em>, i.e. the client and the server can&#39;t talk to each other.</p><p>When that happens, most SaaS products just stop working. If you&#39;re lucky, they pop up an error message that blames you for not being online or whatever. What does Tailscale do? In steady state: nothing special. Every Tailscale node caches its node state in memory, and its list of peers, and the list of locations of the peers, and their DERP servers. If the coordination server goes down, that cache can&#39;t be updated. But all your existing connections keep working, and also all the other parts of the data plane keep working. (There&#39;s also one element of <a target="" rel="noreferrer" href="https://tailscale.com/kb/1115/high-availability#regional-routing">regional routing</a> failover that requires the control server right now; we&#39;re working on removing that dependency.)</p><p>The only things that don&#39;t work when the bus is down are adding/removing/changing nodes and packet filters. That&#39;s what we mean by &#34;actions relying on the coordination server.&#34; Control plane stuff. Want to change your network? Coordination server. Want to use it? No coordination server.</p><p>If your home Internet goes down but your home Wi-Fi is still working, your phone and your computers at home can still talk to each other over Tailscale. They can&#39;t reach the control server, but the data plane keeps on going.</p><p>The upside of our architecture is that many incidents don’t break existing connections: the data plane usually keeps flowing even if the control plane is having trouble. The downside is that the people who do hit the control plane at that moment—trying to log in to the admin console, approve a device, or change an ACL—can be blocked entirely, and that’s a big deal.</p><p>With millions of users, even a limited-scope incident will show up quickly: someone runs into it, checks the status page, and posts about it. That doesn’t mean it’s “just noise”, it means the impact is real for a subset of customers, and we need to treat it that way while we keep shrinking both the blast radius and the duration.</p><p>(As they grow, companies often split their status dashboard so that individual customers can see when they were affected. We&#39;re at that awkward size where we&#39;re mature enough to track the outages, but not so big that splitting it makes sense yet.)</p><h2 id="continuous-improvement"><a href="#continuous-improvement">Continuous improvement<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2><p>It’s true that many outages don’t sever existing connections—that’s a deliberate part of the design. But if you happen to need the control plane during those minutes, you feel the outage at full force.</p><p>That’s not acceptable. Tailscale is critical infrastructure for a lot of organizations, and we have to earn that trust by making these incidents rarer and shorter.</p><p>So what are we going to do about it? Well, a few things.</p><p>First of all, there&#39;s a limitation in Tailscale nodes&#39; ability to work when their coordination server is offline. That limitation is, if your Tailscale client software stops and then restarts, it forgets its network map and falls off the network. This counts as &#34;adding or removing a node,&#34; which is one of those <em>actions</em> you can&#39;t do. But we&#39;ve found a way around it. We&#39;re working on a feature that caches the network map between runs. That way, if Tailscale restarts, you&#39;re right back where you were. As a bonus, even when the control server is working fine, this caching can shave a few tens or hundreds of milliseconds off your time to first packet in highly dynamic situations like CI/CD and <a target="" rel="noreferrer" href="https://tailscale.com/kb/1244/tsnet">tsnet</a> apps.</p><p>Second, we&#39;re evolving our sharded coordination service to reduce disruption. Hot spares, better isolation, auto-rebalancing, live migrations, that sort of thing. A control plane for our control plane.</p><p>Third, we’re investing in better multi-tailnet sharing. This is a longer-term piece of the roadmap, but it matters for reliability because it lets you structure networks around geography without losing the ability to share resources cleanly. For example, if you have a lot of nodes in AWS us-east-1, you might want their coordination close by to reduce the chance of a network partition. But if you also have a lot of nodes in us-west-1, hmm, you wish the coordination server were there too. And, and … and, this will work if you slice your tailnets by region, if only you could share nodes en masse between tailnets. That&#39;s coming, over time. When it does, we&#39;re really going to see why this “centralized” message-bus architecture is so good.</p><p>Fourth, we’re just plain making the software better and more mature every day. More quality gates, more automated testing, more integration testing, more stress testing. Fewer and fewer reasons to have downtime in the first place. As we keep scaling, this kind of work never really stops; it’s a continuous investment in making the system more resilient.</p><h2 id="lets-keep-growing"><a href="#lets-keep-growing">Let&#39;s keep growing<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2><p>I&#39;m not gonna lie to you. None of us are proud of having (counts on fingers) nine periods of (partial) downtime (or maybe slowness) in one month. Even though almost all were resolved in less than an hour. Even though your data plane kept going. Because, well, that&#39;s who we are. And who we are is a team that would rather over-communicate than under-communicate. Even when an incident is brief or affects only some customers, we want it to be visible and explained.</p><p>We&#39;re going to keep counting every single small outage and measuring it and fracturing it into two smaller outages and eventually obliterating it, one improvement at a time. That&#39;s just how it&#39;s done.</p><p>If you notice an outage, please report it using <a target="" rel="noreferrer" href="https://tailscale.com/contact/support">this form</a>. We hope there isn’t one, but your report helps us improve Tailscale. And if reading posts like this makes you think “I want to help fix that,” we’re hiring; <a target="" rel="noreferrer" href="https://tailscale.com/careers">our careers page is here</a>.</p></div></div></div>
  </body>
</html>
