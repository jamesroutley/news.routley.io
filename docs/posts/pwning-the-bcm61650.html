<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.xilokar.info/pwning-the-bcm61650.html">Original</a>
    <h1>Pwning the Bcm61650</h1>
    
    <div id="readability-page-1" class="page"><div id="left-side">
          <section id="content">

    

        <p>written on lun. 04 avril 2022
            by </p>

    <div>
        <p>The percello prc6000, also known as bcm61650 after Broadcom bought the company, is a chip used in 3g femtocells (Home-nodeB).</p>
<p><img alt="" src="https://blog.xilokar.info/medias/bootloader_serial.png"/></p><p>Here is a summary writeup of how I achieved to bypass its secure ROM to run arbitrary firmwares.</p>

<div id="intro">
<h2>Intro</h2>
<p>The bcm61650 is present in a femtocell of a large french operator. It allows you to have a small 3g tower in your house over your dsl/fiber line. It&#39;s an optional box you plug in your dsl box, with what looks like a pcie connector.</p>
</div>
<div id="from-pcie-in-box-to-standalone-ethernet">
<h2>From PCIe in box to standalone Ethernet</h2>
<p>When pluged in, the board present itself as a pci ethernet chip, that performs a bootp and load its firmware over tftp and then connects to an hardcoded IP to establish an ipsec tunnel to the core network (I won&#39;t cover this part). In order to fully use the femtocell for playing with osmocom, I decided to try get rid of the hardcoded parts.</p>
<p>To ease debugging, I decided to try to tweak it into a standalone, ethernet based, board, in order to be able to start, stop or reboot the board without having to mess with pci scanning and hotplug.</p>
<p>Desoldering the link between the pci ethernet chip and the bcm61650</p>
<p><img alt="" src="https://blog.xilokar.info/medias/standalone01.jpg"/></p><p>And with a few probes, managing to get the board powered and booting.</p>
<p><img alt="" src="https://blog.xilokar.info/medias/standalone02.jpg"/></p><p>With uart output.</p>
<pre>Node-H FM-loader v1.2
booting in ******* mode
changing CPU frequency... done
image verification success
copying initrd at 0X8F6C8000...
copying kernel...
bytes: 3338752
booting kernel...
</pre>
<p>Hum... <tt>image verification</tt></p>
</div>
<div id="first-glimpses">
<h2>First glimpses</h2>
<p>The firmware loaded over tftp is 11Mb.</p>
<p>binwalk output:</p>
<pre>DECIMAL       HEXADECIMAL     DESCRIPTION
---------------------------------------------------------------------
123953        0x1E431         Copyright string: &#34;Copyright (c) MIPS
                              Technologies, Inc. All rights reserved.
125092        0x1E8A4         CRC32 polynomial table, little endian
126181        0x1ECE5         Copyright string: &#34;Copyright (c) MIPS
                              Technologies, Inc. All rights reserved.
128416        0x1F5A0         SHA256 hash constants, little endian
131224        0x20098         uImage header, header size: 64 bytes,
                              header CRC: 0x8ACC835E, image name:
                              &#34;Linux-2.6.31.12-Percello-1.12-9&#34;
131288        0x200D8         gzip compressed data, has original file
                              name: &#34;vmlinux.bin&#34;
1740800       0x1A9000        Squashfs filesystem
</pre>
<p>So, a bunch of unkown stuff at the start, then kernel and root filesystem.</p>
<p>Trying a simple change in the kernel/rootfs:</p>
<pre>Node-H FM-loader v1.2
booting in ******* mode
changing CPU frequency... done
image verification failed
failed to boot: halt
</pre>
<p>Yeah, obviously</p>
<p>Some string a the start of the binary blob:</p>
<pre>Percello bootloader version 0.6 (from
Silicon type:
, silicon ver:
, feature ver:
, ROM ver:
Boot block
not found
FM signature has invalid length
</pre>
<p>Did not see the <tt>Percello bootloader version 0.6</tt> during boot. And the <tt>FM signature</tt> suggests we surely have a chain of bootloaders until linux (which is expected).</p>
<p>Trying to change a string in the bootloader completly blocks the boot, so bootloaders are either checksumed or a signature is checked.</p>
<p>Where to go from now ?</p>
</div>
<div id="got-root">
<h2>Got root ?</h2>
<p>Extract initrd with binwalk, check /etc/password</p>
<p>Long story short: empty root password.</p>
<p>side-note: from now on, I will always check for empty password <em>before</em> trying to build an hashcat rule</p>
</div>
<div id="got-dump">
<h2>Got Dump ?</h2>
<pre>dd if=/dev/mem  bs=4k | nc
</pre>
<p>With luck, the memory used during boot time will not (yet) be overwritten by linux.</p>
<p>Using the strings in the firmware and in the location of the matchings strings in the memory dump, we can find the location in ram of the bootloader, and thus adjust the load offset of the binary in our favorite RE tool.</p>
<p>After a few hours of digging things out:</p>
<ul>
<li>The percello bootloader is loaded at <tt>0x83fe0000</tt>
It then loads the FM loader</li>
<li>The FM loader is loaded at <tt>0x83f80000</tt>
he is responsible for loading kernel and initrd</li>
</ul>
<p>Both use code from ROM (<tt>0x9fc00xxx</tt>), for signature verification.</p>
<p>Time to go further down in our analysis.</p>
</div>
<div id="got-rom">
<h2>Got Rom ?</h2>
<p>The dd approach to dump rom does not seems to work:</p>
<pre># dd if=/dev/mem bs=1 skip=$((0x9fc00000)) count=10
dd: /dev/mem: Bad address
#
</pre>
<p>Not a surprise, the rom is surely not mapped in linux. But hey, we are root, and we can load modules!</p>
<p>So grab a linux-2.6.31.12 archive, try to build a close enough kernel (did I mentionned it was mips based ?) play with symbol versioning <em>and voila</em></p>
<div><pre><span></span><span>#include</span> <span>&lt;linux/module.h&gt;</span><span></span>
<span>#include</span> <span>&lt;linux/kernel.h&gt;</span><span></span>
<span>#include</span> <span>&lt;linux/init.h&gt;</span><span></span>

<span>void</span> <span>dump_mem</span><span>(</span><span>unsigned</span> <span>char</span> <span>*</span><span>start</span><span>,</span> <span>unsigned</span> <span>char</span> <span>*</span><span>end</span><span>)</span> <span>{</span>
   <span>unsigned</span> <span>char</span> <span>*</span><span>p</span> <span>=</span> <span>start</span><span>;</span>
   <span>int</span> <span>i</span><span>,</span><span>v</span><span>;</span>
   <span>printk</span><span>(</span><span>&#34;Dumping: %08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>(</span><span>unsigned</span> <span>int</span><span>)</span><span>start</span><span>);</span>
   <span>v</span> <span>=</span> <span>p</span><span>[</span><span>i</span><span>];</span>
   <span>for</span><span>(</span><span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span><span>&lt;</span> <span>(</span><span>int</span><span>)(</span><span>end</span> <span>-</span> <span>start</span><span>);</span><span>i</span><span>++</span><span>)</span> <span>{</span>
     <span>printk</span><span>(</span><span>&#34;DUMP:%08x: %02x</span><span>\n</span><span>&#34;</span><span>,</span>
             <span>i</span> <span>+</span> <span>(</span><span>unsigned</span> <span>int</span><span>)</span><span>start</span><span>,</span> <span>p</span><span>[</span><span>i</span><span>]);</span>
   <span>}</span>
<span>}</span>


<span>static</span> <span>int</span> <span>__init</span> <span>dump_init</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
   <span>printk</span><span>(</span><span>&#34;Dump init</span><span>\n</span><span>&#34;</span><span>);</span>
   <span>// dump rom ?</span>
   <span>dump_mem</span><span>((</span><span>unsigned</span> <span>char</span><span>*</span><span>)</span><span>0x9fc00000</span><span>,</span>
            <span>(</span><span>unsigned</span> <span>char</span><span>*</span><span>)</span><span>0x9fd00000</span><span>);</span>
   <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>static</span> <span>void</span> <span>__exit</span> <span>dump_exit</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
   <span>printk</span><span>(</span><span>&#34;Dump exit</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>

<span>module_init</span><span>(</span><span>dump_init</span><span>);</span>
<span>module_exit</span><span>(</span><span>dump_exit</span><span>);</span>

<span>MODULE_AUTHOR</span><span>(</span><span>&#34;Xilokar&#34;</span><span>);</span>
<span>MODULE_DESCRIPTION</span><span>(</span><span>&#34;Dump driver&#34;</span><span>);</span>
<span>MODULE_LICENSE</span><span>(</span><span>&#34;GPL&#34;</span><span>);</span>
</pre></div>
<!--  -->
<p>(do not pay attention to code)</p>
<p>grab kernel messages from console, grep, sed, xxd and we have our ROM dump.</p>
<p><em>more time digging things out</em></p>
</div>
<div id="hello-rsa-my-old-friend">
<h2>Hello RSA my old friend</h2>
<p>Remember the functions from ROM used in both percello bootloader and FM-loader ? Without surprise, they are also used in the ROM code, to check the percello bootloader signature.</p>
<div><pre><span></span><span>log</span><span>(</span><span>&#34;s_Secured_device_-_OTP2:_verificat_9fc0dda8&#34;</span><span>);</span>

<span>iVar1</span> <span>=</span> <span>FUN_9fc0d15c</span><span>(</span><span>DAT_bf400888</span><span>,</span><span>DAT_bf400880</span><span>,</span>
                     <span>&amp;</span><span>DAT_bf400ae8</span><span>,</span><span>&amp;</span><span>DAT_bf40088c</span><span>);</span>
<span>if</span> <span>(</span><span>iVar1</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
   <span>log</span><span>(</span><span>&#34;s_FAILED_9fc0e364&#34;</span><span>);</span>
   <span>return</span><span>;</span>
<span>}</span>
</pre></div>
<div><pre><span></span><span>void</span> <span>FUN_9fc0d15c</span><span>(</span><span>undefined4</span> <span>param_1</span><span>,</span><span>undefined4</span> <span>param_2</span><span>,</span>
                  <span>undefined4</span> <span>param_3</span><span>,</span><span>undefined4</span> <span>param_4</span><span>)</span>
<span>{</span>
   <span>undefined</span> <span>auStack152</span> <span>[</span><span>20</span><span>];</span>
   <span>undefined</span> <span>auStack132</span> <span>[</span><span>108</span><span>];</span>

   <span>FUN_9fc0c380</span><span>(</span><span>auStack132</span><span>);</span>
   <span>FUN_9fc0c96c</span><span>(</span><span>auStack132</span><span>,</span><span>param_1</span><span>,</span><span>param_2</span><span>);</span>
   <span>FUN_9fc0d020</span><span>(</span><span>auStack132</span><span>,</span><span>auStack152</span><span>);</span>
   <span>FUN_9fc0ccc0</span><span>(</span><span>auStack152</span><span>,</span><span>param_3</span><span>,</span><span>param_4</span><span>);</span>
   <span>return</span><span>;</span>
<span>}</span>
</pre></div>
<p>Probably, <tt>FUN_9fc0c380</tt> is hash init, <tt>FUN_9fc0c96c</tt> hash process and <tt>FUN_9fc0d020</tt> hash finalize.
The hash size is 160,</p>
<div><pre><span></span><span>void</span> <span>FUN_9fc0c380</span><span>(</span><span>undefined4</span> <span>*</span><span>param_1</span><span>)</span>

<span>{</span>
   <span>*</span><span>param_1</span> <span>=</span> <span>0x67452301</span><span>;</span>
   <span>param_1</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>0xefcdab89</span><span>;</span>
   <span>param_1</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>0x98badcfe</span><span>;</span>
   <span>param_1</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>0x10325476</span><span>;</span>
   <span>param_1</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>0xc3d2e1f0</span><span>;</span>
   <span>param_1</span><span>[</span><span>0x19</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
   <span>param_1</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
   <span>param_1</span><span>[</span><span>6</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
   <span>param_1</span><span>[</span><span>0x17</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
   <span>param_1</span><span>[</span><span>0x18</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
   <span>return</span><span>;</span>
<span>}</span>
</pre></div>
<p>And we have good old Sha constants, so hash is surely sha1</p>
<p>The last function (<tt>FUN_9fc0ccc0</tt>) builds a <tt>0x80</tt> long structure</p>
<pre>00000000  00 01 ff ff ff ff ff ff  ff ff ff ff ff ff ff ff
00000010  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff
*
00000050  ff ff ff ff ff ff ff ff  ff ff ff ff 00 30 21 30
00000060  09 06 05 2b 0e 03 02 1a  05 00 04 14 00 00 00 00
00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</pre>
<p>and copy the sha1 at offset <tt>0x6c</tt>. (yes PKCS1 scheme).</p>
<p>It then rsa-decode the passed <tt>0x80</tt> long signature with an hardcoded public key and memcompare the result to the built structure.
No asn1 parsing of the provided signature, so no chance to find a pkcs bleichenbacher like attack...</p>
</div>
<div id="back-to-basis">
<h2>Back to basis</h2>
<p>At this point, It was like a deja vu:</p>
<p><img alt="" src="https://blog.xilokar.info/medias/rsa.png"/></p><p>(sha1 this time, but hey, even if sha1 collision are real, not preimage attacks)</p>
<p>But after more digging:</p>
<div><pre><span></span><span>void</span> <span>probably_load_header</span><span>(</span><span>void</span><span>)</span>

<span>{</span>
  <span>bootloader_header</span> <span>local_60</span><span>;</span>

  <span>DAT_bf400888</span> <span>=</span> <span>0xa0500000</span><span>;</span>
  <span>memcpy</span><span>(</span><span>&amp;</span><span>local_60</span><span>,</span><span>0xa0500000</span><span>,</span><span>0x4c</span><span>);</span>
  <span>memcpy</span><span>(</span><span>&amp;</span><span>DAT_bf40088c</span><span>,</span><span>local_60</span><span>.</span><span>percello_sig</span> <span>+</span> <span>0xa0500000</span><span>,</span>
         <span>local_60</span><span>.</span><span>percello_sg_len</span><span>);</span>
  <span>memcpy</span><span>(</span><span>&amp;</span><span>DAT_bf40090c</span><span>,</span><span>local_60</span><span>.</span><span>fm_sig</span> <span>+</span> <span>0xa0500000</span><span>,</span>
         <span>local_60</span><span>.</span><span>fm_sig_len</span><span>);</span>
  <span>DAT_bf400880</span> <span>=</span> <span>local_60</span><span>.</span><span>percello_sig</span><span>;</span>
  <span>DAT_bf400884</span> <span>=</span> <span>local_60</span><span>.</span><span>fm_sig</span><span>;</span>
  <span>return</span><span>;</span>
<span>}</span>
</pre></div>
<p><tt>0xa0500000</tt> is probably the location of the tftp-loaded image. So this function maps the file header and...</p>
<p>Wait ! memcpy a user provided buffer (<tt>fm_sig</tt> at a known location (<tt>0xbf40090c</tt>), with a user provided length (<tt>fm_sig_len</tt>)?</p>
<p>And below the stack (<tt>0xbf403ff0</tt>) ?</p>
<div><pre><span></span><span># init stack pointer</span>
<span>lui</span>        <span>t0</span><span>,</span><span>0xbf40</span>
<span>ori</span>        <span>t0</span><span>,</span><span>t0</span><span>,</span><span>0x3ff0</span>
<span>addiu</span>      <span>sp</span><span>,</span><span>t0</span><span>,</span><span>0x0</span>
</pre></div>
<p>Time for a good old stack smashing (for fun and profit)!</p>
<p>After a few time, found the right len to smash <tt>ra</tt> in the memcpy call on the stack, and jump just after the signature verification. Also needed to keep some values in ram, so my buffer overflow was not only full of <tt>0xff</tt> and I was able to successfully jump to the percello bootloader, without signature verification.</p>
<pre>Node-H FM-loader v1.2
booting in ******* mode
changing CPU frequency... done
image verification bypass!
copying initrd at 0X8F6C8000...
</pre>
<p>Then all was left was patching percello bootloader to skip FM-loader verification:</p>
<pre>Node-H FM-loader v1.2
booting in Xilokar mode
changing CPU frequency... done
image verification success
copying initrd at 0X8F6C8000...
copying kernel...
bytes: 3338752
</pre>
<p>And then patching FM-loader to allow for arbitrary kernels and initrd:</p>
<pre>Node-H FM-loader v1.2
booting in Xilokar mode
changing CPU frequency... done
image verification bypass!
copying initrd at 0X8F6C8000...
copying kernel...
bytes: 3338752
booting kernel...
[    0.000000] Linux version 2.6.31.12-Percello-1.12-9
...
[    1.633762] Freeing unused kernel memory: 152k freed

==================================================================
Welcome to Percello Root File System Version R2.4  (not so) Secure
Pwned by Xilokar
==================================================================
---- Mounting proc file system
Sat Aug  1 00:00:00 UTC 2015
---- Mounting ramdisk with size 32M
---- Remounting /dev/root
---- Starting syslogd
---- Mounting sysfs
---- Mounting devpts
---- Creating loopback device
---- Activating Ethernet device
</pre>
<p>(I realize I did not talk about understanding firmware image structure)</p>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>Unpatchable (ROM) secure boot bypass on bcm61650.</p>
</div>

    </div>

        


          </section>
       </div></div>
  </body>
</html>
