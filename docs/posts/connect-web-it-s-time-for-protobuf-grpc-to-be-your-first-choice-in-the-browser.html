<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buf.build/blog/connect-web-protobuf-grpc-in-the-browser">Original</a>
    <h1>Connect-Web: It&#39;s time for Protobuf/gRPC to be your first choice in the browser</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div><p>Today we&#39;re releasing <code><a href="https://www.npmjs.com/package/@bufbuild/connect-web">connect-web</a></code>, an idiomatic TypeScript
library for calling RPC servers from web browsers. If you&#39;ve been unimpressed
by gRPC and Protobuf on the web before, now&#39;s the time to take another look:
<code>connect-web</code> generates modern TypeScript that&#39;s just as ergonomic as a
hand-written REST client. Clients work seamlessly with the gRPC ecosystem, and
they also support Connect&#39;s more browser-friendly protocol.
<strong><code><a href="https://www.npmjs.com/package/@bufbuild/connect-web">connect-web</a></code> is available now under an Apache 2 open source
license, and both documentation and a sample app are available on
<a href="https://connect.build">connect.build</a>.</strong> One layer at a time, we&#39;re making Protobuf the best choice
for API development throughout your stack <!-- -->—<!-- --> from browsers and phones all
the way into your backend services.</p><h2 id="rpc-as-awesome-as-the-web">RPC as awesome as the web<a href="#rpc-as-awesome-as-the-web" aria-label="rpc as awesome as the web permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>TypeScript and Protocol Buffers might seem like a natural pairing, but the gRPC
ecosystem has treated the web platform as a distant afterthought. Google&#39;s <code>grpc-web</code>
made an early attempt to solve gRPC on the web, but developing with <code>grpc-web</code> is
miserable: TypeScript support is a half-hearted
experiment, there&#39;s no support for JSON or ECMAScript modules, the generated
JavaScript looks more like decade-old Java, and bundles are enormous. Every
response has a <code>200 OK</code> status and an opaque binary body, so the network
inspector is nearly unusable, and just sending requests to a gRPC backend
requires a proxy. It&#39;s no surprise that most web developers continue to
write REST clients by hand.</p><p>The web deserves better. <code>connect-web</code> finally unlocks the potential of
Protobuf and TypeScript: fully generated, type-safe clients with the ergonomics
of hand-crafted code.</p><ul><li>From top to bottom, the <code>connect-web</code> runtime and generated code are idiomatic
TypeScript <!-- -->—<!-- --> no setters, getters, or other Java-isms. Our <a href="https://github.com/bufbuild/protobuf-es">Protobuf
implementation</a> passes the full suite of conformance tests, so
serialized data is compatible with Protobuf implementations in dozens of
languages.</li><li>The runtime and generated code support Protobuf&#39;s standard JSON mapping, so
you can send human-readable data over the network.</li><li><code>connect-web</code> clients support two RPC protocols: gRPC-Web and the Connect
ecosystem&#39;s own protocol. The two clients have the same interface, so
swapping protocols is as simple as changing constructors. Calling our live
demo service is a type-safe one-liner:<pre><code>const answer = await client.say({sentence: &#34;I feel happy.&#34;});
console.log(answer);
// {sentence: &#39;When you feel happy, what do you do?&#39;}
</code></pre></li><li>The <a href="https://connect.build/docs/protocol">Connect protocol</a> is a simple, POST-only protocol that
works over HTTP/1.1 or HTTP/2. It takes the best portions of gRPC and
gRPC-Web, including streaming, and packages them into a protocol that&#39;s
simple enough to debug with the network inspector. If your backends are built
with <code><a href="https://github.com/bufbuild/connect-go">connect-go</a></code>, you can use the Connect protocol to call them
directly <!-- -->—<!-- --> no proxy required. We could hand-write the call above using
<code>fetch</code>:<pre><code>const res = await fetch(&#34;https://demo.connect.build/buf.connect.demo.eliza.v1.ElizaService/Say&#34;, {
  method: &#34;POST&#34;,
  headers: {&#34;content-type&#34;: &#34;application/json&#34;},
  body: `{&#34;sentence&#34;: &#34;I feel happy.&#34;}`
});
const answer = res.json();
console.log(answer);
// {sentence: &#39;When you feel happy, what do you do?&#39;}
</code></pre></li><li><code>connect-web</code> clients also support the full gRPC-Web protocol, including
server streaming and error details. <code>connect-go</code> and <code>Grpc.AspNetCore</code>
servers speak the gRPC-Web protocol natively, and Envoy <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_web_filter">can proxy requests</a>
to any other gRPC backend. We validate our gRPC-Web implementation using an
<a href="https://github.com/bufbuild/connect-crosstest">extended version</a> of gRPC&#39;s own compatibility test suite.</li><li>Clients offer both promise- and callback-based APIs, so they <a href="https://github.com/bufbuild/connect-web-integration">integrate
easily</a> with React, Angular, Svelte, and other UI
frameworks. With promises, consuming a server stream is as simple as a <code>for
await</code> loop.</li><li>Despite all these features, tree-shaking and the web platform&#39;s more modern APIs
keeps <code>connect-web</code> bundles small. Our demo service&#39;s bundle shrank by <a href="https://github.com/bufbuild/connect-web/blob/main/packages/connect-web-bench/README.md">80%
smaller</a> when we switched away from <code>grpc-web</code>, and larger APIs
benefit even more.</li></ul><p>In the <a href="https://buf.build">Buf Schema Registry</a> and our other products, we&#39;ve completely
replaced <code>grpc-web</code> with <code>connect-web</code>. For the first time, using Protobuf in
our frontend doesn&#39;t feel like a compromise: we get the simplicity and
ergonomics of a well-written REST client without any of the drudgery.</p><p><code>connect-web</code> is currently in beta: our products rely on it, but we may make a
few changes as we gather feedback from early adopters. We take semantic
versioning <em>very</em> seriously: we&#39;re planning to release a <code>v1.0</code> in a few
months, after which we&#39;ll never break your builds.</p><h2 id="coming-soon-nodejs-android-and-ios">Coming soon: Node.js, Android, and iOS<a href="#coming-soon-nodejs-android-and-ios" aria-label="coming soon nodejs android and ios permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>Along with <code>connect-go</code> and <code>connect-web</code>, we&#39;ve been working on a Connect
implementation for server-side TypeScript. We&#39;re still testing out the Web
Streams API in Node.js, but we anticipate having an early release ready in
a few months.</p><p>More broadly, working on <code>connect-web</code> highlighted just how poor the client
experience is for Protobuf-based APIs <!-- -->—<!-- --> not just on the web, but also on
Android and iOS. Our business thrives when companies can use Protobuf
ubiquitously, so we&#39;re beginning to work on Connect for Kotlin and Swift too.</p><h2 id="get-involved">Get involved!<a href="#get-involved" aria-label="get involved permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>We&#39;d love to hear what you think of Connect: check out the <a href="https://connect.build/docs/web/getting-started">Getting Started
guide</a>, try Connect in your next project, poke through the
<a href="https://github.com/bufbuild/connect-demo">live demonstration project</a> or the various <a href="https://github.com/bufbuild/connect-web-integration">framework-specific
examples</a>, and please <a href="https://github.com/bufbuild/connect-web/issues">file issues</a> or chat
with us in the <a href="https://join.slack.com/t/bufbuild/shared_invite/zt-f5k547ki-VDs_iC4TblNCu7ubhRD17w">Buf Slack</a> if something doesn&#39;t work as you expect.</p></div></div></div></div></div></div>
  </body>
</html>
