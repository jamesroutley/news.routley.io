<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2023/01/reverse-engineering-intel-8086.html">Original</a>
    <h1>Reverse-engineering the Intel 8086 processor&#39;s HALT circuits</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-861830249857923940" itemprop="description articleBody">


<p>The 8086 processor was introduced in 1978 and has greatly influenced modern computing through the x86 architecture.
One unusual instruction in this processor is HLT, which stops the processor and puts it in a halt state.
In this blog post, I explain in detail how the halt circuitry is implemented and how it interacts with the 8086&#39;s architecture.</p>
<p>The die photo below shows the 8086 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles memory accesses, while the Execution Unit (EU) executes instructions.
Both are stopped by a halt instruction.</p>
<p><a href="https://static.righto.com/images/8086-halt/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." height="624" src="https://static.righto.com/images/8086-halt/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.</p>
<h2>Halt processing in the Execution Unit</h2>
<p>In this section, I&#39;ll explain how the HLT instruction is decoded and handled in the Execution Unit.
The 8086 uses a combination of lookup ROMs, logic, and microcode to implement instructions.
The process starts with the loader, a state machine that provides synchronization between the prefetch queue and
the decoding circuitry.
When an instruction byte is available, the loader provides a signal called First Clock that loads the instruction into the Instruction Register and starts the instruction decoding process.</p>
<p>Before microcode gets involved, the Group Decode ROM classifies instructions by producing about 15 signals, indicating
properties such as instructions with a Mod R/M byte, instructions with a byte/word bit, instructions that always
act on a byte, and so forth.
For the HLT instruction, the Group Decode ROM provides two important signals. 
The first is one-byte logic (1BL), indicating that the instruction is one byte long and is implemented with logic
circuitry rather than microcode.<span id="fnref:logic"><a href="#fn:logic">1</a></span> The second signal is produced for the HLT instruction specifically and generates the
internal HALT signal.
This signal travels to various parts of the 8086 to halt the processor.</p>
<p><a href="https://static.righto.com/images/8086-halt/group-rom.jpg"><img alt="The Group Decode ROM. The yellow rectangle detects the HLT instruction, with an output at the bottom. The red rectangle generates the 1BL (one-byte logic) signal." height="470" src="https://static.righto.com/images/8086-halt/group-rom-w500.jpg" title="The Group Decode ROM. The yellow rectangle detects the HLT instruction, with an output at the bottom. The red rectangle generates the 1BL (one-byte logic) signal." width="500"/></a></p><p>The Group Decode ROM. The yellow rectangle detects the HLT instruction, with an output at the bottom. The red rectangle generates the 1BL (one-byte logic) signal.</p>
<p>In the Execution Unit, the HALT signal blocks the reading of new instructions from the prefetch queue.
This causes the loader to wait indefinitely and stops execution of new instructions.
Since no new instruction replaces HLT, the Group Decode ROM continues to generate the HALT signal.
The HALT signal also blocks most of the other outputs from the Group Decode ROM, preventing other decoding actions.</p>
<p>Thus, the Execution Unit sits idle as a result of the HLT instruction, unable to start a new instruction.
Modern processors often have low-power halt modes, where part of the processor is shut down or a clock domain is
stopped to reduce power consumption.
The 8086, however, doesn&#39;t do anything clever to minimize power consumption in the halt mode, since this wasn&#39;t
a concern for processors in the 1970s.</p>
<h2>Halt processing in the Bus Interface Unit</h2>
<p>Memory and I/O devices are connected to the 8086 chip through a bus that transmits address, data, and control information.
The 8086&#39;s Bus Interface Unit handles reads and writes over this bus, running independently from the Execution Unit.
A complete bus cycle for a read or write takes four clock periods, called T1, T2, T3, and T4,<span id="fnref:Tw"><a href="#fn:Tw">2</a></span>
with specific signals on the bus for each time state.</p>
<p>A HLT instruction stops the Bus Interface Unit, but this takes several steps.
First, the Bus Interface Unit must complete any currently-running bus cycle. Any new bus cycle must be blocked.
Finally, 
the processor indicates the HALT state to any devices on the bus by issuing a special T1 cycle over the bus.</p>
<p>The main HALT control signal inside the Bus Interface Unit is something I call <code>halt-not-hold</code>, indicating a HALT is active,
but not a HOLD. (Ignore the HOLD part for now.)
This signal is activated by the HLT instruction signal from the Group Decode ROM, except it is blocked by
any bus operations in progress. Once any current bus operation reaches T2, <code>halt-not-hold</code> gets activated and
starts the halt process while the current bus cycle finishes up.</p>
<p>To prevent new bus activity,
the <code>halt-not-hold</code> signal blocks new prefetch requests.
The only other source of bus activity is an instruction that performs reads or writes.
But the current instruction is HLT, so it won&#39;t generate any bus traffic.
Thus, the Bus Interface Unit will remain idle.</p>
<p><a href="https://static.righto.com/images/8086-halt/mem-ctrl.jpg"><img alt="The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon." height="424" src="https://static.righto.com/images/8086-halt/mem-ctrl-w500.jpg" title="The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon." width="500"/></a></p><p>The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.</p>
<p>The circuitry to control the bus cycle is complicated with many flip-flops and logic gates;
the diagram above shows the flip-flops.
I plan to write about the bus cycle circuitry in detail later, but for now, I&#39;ll give an extremely simplified description.
Internally, there is a T0 state before T1 to provide a cycle to set up the bus operation.
The bus timing states are controlled by a chain of flip-flops configured like
a shift register with additional logic:
the output from the T0 flip-flop is connected to the input of the T1 flip-flop and likewise with T2 and T3, forming
a chain.
A bus cycle is started by putting a 1 into the input of the T0 flip-flop.<span id="fnref:inverted"><a href="#fn:inverted">3</a></span>
When the CPU&#39;s clock transitions, the
flip-flop latches this signal, indicating the (internal) T0 bus state.
On the next clock cycle, this 1 signal goes from the T0 flip-flop to the T1 flip-flop, creating the externally-visible
T1 state.
Likewise, the signal passes to the T2 and T3 flip-flops in sequence, creating the bus cycle.</p>
<p>A slightly different path is used to generate the special T1 signal that indicates a HALT.
Once any bus activity is completed, the <code>halt-not-hold</code> signal puts a 1 into the T1 flip-flop through some gates.
This generates the T1 signal, bypassing T0.
Moreover, this signal does not propagate to the T2 flip-flop because it is blocked by <code>halt-not-hold</code> and some gates.
Another flip-flop blocks this T1 cycle after the first cycle so <code>halt-not-hold</code> doesn&#39;t repeately trigger it.
Overall, this special HALT T1 state looks like a special case that was hacked into the circuitry.</p>
<p>One complication is the bus hold feature.
The 8086 supports complex bus configurations, where external devices may take control of the bus.
For instance, peripherals may use the bus for
direct memory access, bypassing the CPU.
A device can request control of the bus, a &#34;bus hold&#34;, through the 8086&#39;s HOLD pin.<span id="fnref:hold"><a href="#fn:hold">4</a></span>
This causes the 8086 to electrically stop putting signals on the bus
(i.e. a high-impedance, tri-state off state). This allows another device to use the bus until it releases HOLD.</p>
<p>Even when the CPU is halted, the CPU still has &#34;ownership&#34; of the bus and drives the bus with idle signals.<span id="fnref:floating"><a href="#fn:floating">5</a></span>
If a device requests a bus hold when the CPU is halted, the <code>halt-not-hold</code> signal is blocked.
When the device releases the hold, <code>halt-not-hold</code> is unblocked.
This causes the 8086 to go through the special T1 cycle again, using the same flip-flop process described above.
This lets listeners on the bus know that the CPU is still halted.</p>
<h2>Exiting the halt state</h2>
<p>The processor exits the halt state when it receives a reset, interrupt, or non-maskable interrupt.
To implement this, an interrupt unblocks the instruction decoder by overriding the queue-unavailable signal.
This causes the loader, which controls instruction decoding, to move into the First Clock state.
Meanwhile, the interrupt causes the microcode address register to be loaded with the hardcoded microcode address
of the appropriate interrupt routine.
Thus, the microcode engine starts running the interrupt handler microcode.</p>
<p>The Instruction Register holds the 8-bit opcode that is currently being processed.
It has a ninth bit that indicates if an interrupt is being processed.
The Instruction Register (including the interrupt bit) is loaded on First Clock (described above).
It outputs the instruction and interrupt bit to the Group Decode ROM one clock cycle later.
The interrupt bit blocks regular instruction decoding by the Group Decode ROM.
In particular, the HLT instruction will no longer be decoded, dropping the HALT signal throughout the CPU.
In the Execution Unit, this reactivates the prefetch queue. This will allow instruction execution once
the microcode finishes executing the interrupt handling code.
In the Bus Interface Unit, dropping the HALT signal causes <code>halt-not-hold</code> to drop.
This enables bus activity from the Bus Interface Unit.<span id="fnref:prefetch"><a href="#fn:prefetch">6</a></span></p>
<h2>History of HALT and x86</h2>
<p>Historically, computers usually had some sort of &#34;stop&#34; or &#34;wait&#34; instruction to stop execution at the end of a program.
This goes back to the electromechanical Harvard Mark I (1944), EDSCAC (1949), and Univac I (1951), among other machines.
Most (but not all) mainframes and minicomputers continued this approach.<span id="fnref:blaauw"><a href="#fn:blaauw">7</a></span></p>
<!-- https://bitsavers.org/pdf/datapoint/2200/2200_Programmers_Man_Aug71.pdf p1-18 -->

<p>The HLT instruction in the 8086, like many other features, derives from the Datapoint 2200, and there&#39;s an
interesting story behind that.
The Datapoint 2200 was a desktop computer announced in 1970, and sold as a &#34;programmable terminal&#34;.
The processor of the Datapoint 2200 was implemented with a board of TTL integrated circuits,
since this was before microprocessors.
The Datapoint manufacturer talked to Intel and Texas Instruments about replacing the board of
chips with a single processor chip.
Texas Instruments produced the <a href="https://www.righto.com/2015/05/the-texas-instruments-tmx-1795-first.html">TMX 1795</a> microprocessor chip and Intel produced the 8008 shortly after,<span id="fnref:4004"><a href="#fn:4004">8</a></span> both copying the Datapoint 2200&#39;s architecture and instruction set.
Datapoint didn&#39;t like the performance of these chips and decided to stick with a TTL-based processor.
Texas Instruments couldn&#39;t find a customer for the TMX 1795 and abandoned it.
Intel, on the other hand, sold the 8008 as an 8-bit microprocessor, creating the microprocessor market in the process.
Intel improved the 8008 to create the popular 8080 microprocessor (1974). Zilog produced the more powerful Z80 (1976), backward-compatible
with the 8080.</p>
<p><a href="https://static.righto.com/images/8086-halt/datapoint-2200.jpg"><img alt="The Datapoint 2200. This is the later Model II with an improved TTL processor using the 74181 ALU chip." height="439" src="https://static.righto.com/images/8086-halt/datapoint-2200-w600.jpg" title="The Datapoint 2200. This is the later Model II with an improved TTL processor using the 74181 ALU chip." width="600"/></a></p><p>The Datapoint 2200. This is the later Model II with an improved TTL processor using the 74181 ALU chip.</p>
<p>Intel started designing the iAPX 432 in 1975 to be their high-end 32-bit processor, a &#34;micromainframe&#34; that supported garbage
collection and objects in the processor. 
The iAPX 432 was too complex for the time and as the schedule slipped, Intel decided to produce a stopgap 16-bit
processor to compete with Zilog and Motorola:
this processor became the 8086.
To make it easier for Intel customers to move to the 8086, the processor was designed for compatibility with 8080 assembly language so it inherited much of the architecture and instruction set, although extended from 8 bits to 16 bits.<span id="fnref:translation"><a href="#fn:translation">9</a></span></p>
<p>The consequence of this history is that the 8086 inherited many features from the Datapoint 2200.
The Datapoint 2200 used cheaper shift-register memory so it had a serial processor
that operated on one bit at a time.
This required the Datapoint 2200 to be little-endian, a feature that lives on in the x86 architecture.
Since the Datapoint 2200 was marketed as a programmable terminal, it had parity calculation built into the hardware.
Thus, the 8008 and descendants have a parity flag, in contrast to contemporary processors such as the 6800 and 6502 that omitted this moderately complex feature.
The use of I/O ports instead of memory-mapped I/O is another feature of the Datapoint 2200 that persists in the x86, but was not used in the 6800 and 6502 and their descendants.
The opcodes of the Datapoint 2200 were based on octal 3-bit fields for hardware reasons. The x86 instructions are still <a href="https://gist.github.com/seanjensengrey/f971c20d05d4d0efc0781f2f3c0353da">designed around octal</a>, but the usual hexadecimal display obscures their structure.
Finally, the Datapoint 2200&#39;s HALT instruction was exactly copied by the 8008<span id="fnref:datapoint"><a href="#fn:datapoint">10</a></span> and persists in x86.</p>
<h2>Conclusions</h2>
<p>The HLT instruction seems like a simple function, but its implementation touches many parts of the 8086.
It is implemented in logic circuitry, completely bypassing the microcode.
The implementation became more complicated because of the 8086&#39;s four-step bus protocol, as well as interaction between halting
and the bus hold feature.
This illustrates how complexity creates more complexity, something the RISC processors of the 1980s tried to counter.</p>
<p>I&#39;ve written multiple <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="8de2e1e9eff4f9e8fea3fefdeceee8cde6e8e3fee5e4ffffe4ebeb">[email protected]</span></a>.
Thanks to monocasa for suggesting this topic.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
