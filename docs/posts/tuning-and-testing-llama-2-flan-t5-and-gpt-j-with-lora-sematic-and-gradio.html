<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sematic.dev/blog/tuning-and-testing-llama-2-flan-t5-and-gpt-j-with-lora-sematic-and-gradio">Original</a>
    <h1>Tuning and Testing Llama 2, Flan-T5, and GPT-J with LoRA, Sematic, and Gradio</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>In recent months, it’s been hard to miss all the news about Large Language Models and the rapidly developing set of technologies around them. Although proprietary, closed-source models like GPT-4 have drawn a lot of attention, there has also been an explosion in open-source models, libraries, and tools. With all these developments, it can be hard to see how all the pieces fit together. One of the best ways to learn is by example, so let’s set ourselves a goal and see what it takes to accomplish it. We’ll summarize the technology and key ideas we use along the way. Whether you’re a language model newbie or a seasoned veteran, hopefully you can learn something as we go. Ready? Let’s dive in!</p><h2>The Goal</h2><p>Let&#39;s set a well-defined goal for ourselves: building a tool that can summarize information into a shorter representation. Summarization is a broad topic, with different properties for models that would be good at summarizing news stories, academic papers, software documentation, and more. Rather than focusing on a specific domain, let&#39;s create a tool that can be used for various summarization tasks, while being willing to invest computing power to make it work better in a given subdomain.</p><p>Let’s set a few more criteria. Our tool should:</p><ul role="list"><li>Be able to pull from a variety of kinds of data to improve performance on a specific sub-domain of summarization</li><li>Run on our own devices (including possibly VMs in the cloud that we’ve specified)</li><li>Allow us to experiment using only a single machine</li><li>Put us on the path to scale up to a cluster when we’re ready</li><li>Be capable of leveraging state-of-the-art models for a given set of compute constraints</li><li>Make it easy to experiment with different configurations so we can search for the right setup for a given domain</li><li>Enable us to export our resulting model for usage in a production setting</li></ul><p>Sounds intimidating? You might be surprised how far we can get if we know where to look!</p><h2>Fine-tuning</h2><p>Looking at our goal of being able to achieve good performance on a specific sub-domain, there are a few options that might occur to you. We could:</p><ul role="list"><li>Train our own model from scratch</li><li>Use an existing model “off the shelf”</li><li>Take an existing model and “tweak” it a bit for our custom purposes</li></ul><p>Training a “near state of the art” model from scratch can be complex, time consuming, and costly. So that option is likely not the best. Using an existing model “off the shelf” is far easier, but might not perform as well on our specific subdomain. We might be able to mitigate that somewhat by being clever with our prompting or combining multiple models in ingenious ways, but let’s take a look at the third option. This option, referred to as “fine-tuning,” offers the best of both worlds: we can leverage an existing powerful model, while still achieving solid performance on our desired task.</p><p>Even once we’ve decided to fine-tune, there are multiple choices for how we can perform the training:</p><ul role="list"><li>Make the entire model “flexible” during training, allowing it to explore the full parameter space that it did for its initial training</li><li>Train a smaller number of parameters than were used in the original model</li></ul><p>While it might seem like we might need to do the first to achieve full flexibility, it turns out that the latter can be both far cheaper (in terms of time and resource costs) and just as powerful as the former. Training a smaller number of parameters is generally referred to by the name “Parameter Efficient Fine Tuning,” or “PEFT” for short.</p><h3>LoRA</h3><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b563420dc7d83b6b63c309_lora.png" loading="lazy" alt=""/></p><figcaption>A visual representation of LoRA, courtesy of <a href="https://lightning.ai/pages/community/article/lora-llm/">this article</a></figcaption></figure><p>There are several mechanisms for PEFT, but one method that seems to achieve some of the best overall performance as of this writing is referred to as “Low Rank Adaptation,” or LoRA. If you’d like a detailed description, <a href="https://lightning.ai/pages/community/article/lora-llm/">here’s a great explainer</a>. Or if you’re academically inclined, you can go straight to <a href="https://arxiv.org/abs/2106.09685">the original paper on the technique</a>.</p><p>Modern language models have many layers that perform different operations. Each one takes the the output tensors of the previous layers to produce the output tensors for the layers that follow. Many (though not all) of these layers have one or more trainable matrices that control the specific transformation they will apply. Considering just a single such layer with one trainable matrix <strong>W</strong>, we can consider our fine-tuning to be looking for a matrix we can add to the original, 𝚫<strong>W</strong> , to get the weights for the final model: <strong>W’ = W +</strong> 𝚫<strong>W</strong>.</p><p>If we just looked to find 𝚫<strong>W</strong> directly, we’d have to use just as many parameters as were in the original layer. But if we instead define 𝚫<strong>W</strong> as the product of two smaller matrices 𝚫<strong>W = A</strong> <em>X</em> <strong>B</strong>, we can potentially have far fewer parameters to learn. To see how the numbers work out, let’s say 𝚫<strong>W</strong> is an <em>NxN</em> matrix. Given the rules of matrix multiplication, <strong>A</strong> must have <strong>N</strong> rows, and <strong>B</strong> must have <strong>N</strong> columns. But we get to choose the number of columns in <strong>A</strong> and the number of rows in <strong>B</strong> as we see fit (so long as they match up!). So <strong>A</strong> is an <em>Nxr</em> matrix and <strong>B</strong> is an <em>rxN</em> matrix. The number of parameters in 𝚫<strong>W</strong> is <em>N²</em>, but the number of parameters in <strong>A</strong> &amp; <strong>B</strong> is <em>Nr + rN = 2Nr</em>. By choosing an <em>r</em> that’s much less than <em>N</em>, we can reduce the number of parameters we need to learn significantly!</p><p>So why not just always choose <em>r=1</em>? Well, the smaller <em>r</em> is, the less “freedom” there is for what 𝚫<strong>W</strong> can look like (formally, the less independent the parameters of 𝚫<strong>W</strong> will be). So for very small <em>r</em> values, we might not be able to capture the nuances of our problem domain. In practice, we can typically achieve significant reductions in learnable parameters without sacrificing performance on our target problem.</p><p>As one final aside down this technical section (no more math after this, I promise!), you could imagine that after tuning we might want to actually represent 𝚫<strong>W</strong> as 𝚫<strong>W</strong> <strong>=</strong> <em>⍺</em>**(AXB)**, with <em>⍺</em> as a scaling factor for our decomposed weights. Setting it to 1 would leave us with the same ratio of “original model” behavior to “tuned model” behavior as we had during training. But we might want to amplify or suppress these behaviors relative to one another in prod.</p><p>The above should help give you some intuition for what you’re doing as you play around with the hyperparameters for LoRA, but to summarize at a high level, LoRA will require the following hyperparameters that will have to be determined via experimentation:</p><ul role="list"><li><em>r</em>: the free dimension for decomposing the weight matrices into smaller factors. Higher values will increase the generalization of the fine-tuning, but at the cost of increasing the computational resources (compute, memory, and storage) required for the tuning. In practice, values as low as 1 can do the trick, and values greater than around 64 generally seem to add little to the final performance.</li><li><em>layer selection</em>: as mentioned, not all layers can be tuned at all, nor do all layers have a 2d tensor (aka a matrix) as their parameters. Even for the layers that do meet our requirements, we may or may not want/need to fine-tune all of them.</li><li><em>⍺:</em> a factor controlling how much of the tuned behavior will be amplified or suppressed once our model is done training and ready to perform evaluation.</li></ul><h2>Selecting a Model</h2><p>Now that we’ve decided to fine-tune an existing model using LoRA, we need to choose which model(s) we will be tuning. In our goals, we mentioned working with different compute constraints. We also decided that we would be focusing on summarization tasks.  Rather than simply extending a sequence of text (so called “causal language modeling,” the default approach used by the GPT class of models), this task looks more like taking one input sequence (the thing to summarize) and producing one output sequence (the summary). Thus we might require less fine-tuning if we pick a model designed for “sequence to sequence” language modeling out of the box. However, many of the most powerful language models available today use Causal Language Modeling, so we might want to consider something using that approach and rely on fine-tuning and clever prompting to teach the model that we want it to produce an output sequence that relates to the input one.</p><h3>FLAN-T5</h3><p>Google has released a language model known as <a href="https://huggingface.co/google/flan-t5-base">FLAN-T5</a> that:</p><ul role="list"><li>Is trained on a variety of sequence-to-sequence tasks</li><li>Comes in a variety of sizes, from something that comfortably runs on an M1 Mac to something large enough to score well on competitive benchmarks for complex tasks</li><li>Is licensed for open-source usage (Apache 2)</li><li>Has achieved “state-of-the-art performance on several benchmarks” (<a href="https://arxiv.org/pdf/2210.11416.pdf">source</a>)</li></ul><p>It looks like a great candidate for our goals.</p><h3>Llama 2</h3><p>While this model is a causal language model, and thus might require more fine-tuning, it:</p><ul role="list"><li>Has ranked at the top of many benchmarks for models with comparable numbers of parameters</li><li>Is licensed for open-source usage (Apache 2)</li><li>Comes in a variety of sizes, to suit different use cases and constraints</li></ul><p>Let’s give it a shot too.</p><h3>GPT-J 6B</h3><p>This model is another causal language model. It:</p><ul role="list"><li>comes from the well-known GPT class of models</li><li>has achieved solid performance on benchmarks</li><li>and has a number of parameters that puts it solidly in the class of <em>large</em> language models while remaining small enough to play around with on a single cloud VM without breaking the bank</li></ul><p>Let’s give it a shot too.</p><h2>Selecting some frameworks</h2><p>Now that we have all the academic stuff out of the way, its time for the rubber to meet the road with some actual tooling. Our goals cover a lot of territory. We need to find tools that help us:</p><ul role="list"><li>Manage (retrieve, store, track) our models</li><li>Interface with hardware</li><li>Perform the fine-tuning</li><li>Perform some experimentation as we go through the fine-tuning process. This might include:</li><li>tracking the experiments we’ve performed</li><li>visualizing the elements of our experiments</li><li>keeping references between our configurations, models, and evaluation results</li><li>allowing for a rapid “try a prompt and get the output” loop</li><li>Prepare us for productionizing the process that produces our final model</li></ul><p>As it turns out, there are three tool suites we can combine with ease to take care of all these goals. Let’s take a look at them one-by-one.</p><h3>Hugging Face</h3><p>The biggest workhorse in our suite of tools will be <a href="https://huggingface.co/">Hugging Face</a>. They have been in the language modeling space since long before “LLM” was on everyone’s lips, and they’ve put together a suite of interoperable libraries that have continued to evolve along with the cutting edge.</p><h4>The Hub</h4><p>One of Hugging Face’s most central products is the Hugging Face Hub. What GitHub is for source code, Hugging Face Hub is for <a href="https://huggingface.co/models">models</a>, <a href="https://huggingface.co/datasets">datasets</a>, and <a href="https://huggingface.co/spaces">more</a>. Indeed, it actually uses git (plus <a href="https://git-lfs.com/">git-lfs</a>) to store the objects it tracks. It takes the familiar concepts of repositories, repository owners, and even pull-requests, and uses them in the context of datasets and models. Here’s the <a href="https://huggingface.co/google/flan-t5-base/tree/main">repository tree for the base FLAN-T5 model</a>, for example. Many state-of-the-art models and datasets are hosted on this hub.</p><h4>Transformers</h4><p>Another keystone in the Hugging Face suite is their <a href="https://huggingface.co/docs/transformers/index">transformers</a> library. It provides a suite of abstractions around downloading and using pre-trained models from their hub. It wraps lower-level modeling frameworks like PyTorch, TensorFlow, and JAX, and can provide interoperability between them.</p><h4>Accelerate</h4><p>The next piece of the Hugging Face toolkit we’ll be using is their <a href="https://huggingface.co/docs/accelerate/index">Accelerate</a> library, which will help us be able to effectively leverage the resource provided by different hardware configurations without too much extra configuration. If you’re interested, accelerate can also be used to enable distributed training when starting from non-distributed PyTorch code.</p><h4>PEFT</h4><p>A new kid on the proverbial Hugging Face block is <a href="https://huggingface.co/docs/peft/index">PEFT</a>. Recall this acronym for “Parameter Efficient Fine Tuning” from above? This library will allow us to work with LoRA for fine tuning, and treat the matrices that generate the weight deltas as models (sometimes referred to as adaptors) in their own right. That means we can upload them to the Hugging Face Hub once we’re satisfied with the results. It also supports other fine-tuning methods, but for our purposes we’ll stick with LoRA.</p><h3>Sematic</h3><p>Sematic will help us track &amp; visualize our experiments, keep references between our configurations/models/evaluation results, and prepare us for productionization. Sematic not only handles experiment management, but is also <a href="https://docs.sematic.dev/onboarding/readme">a fully-featured cloud orchestration engine</a> targeted at ML use cases. If we start with it for our local development, we can move our train/eval/export pipeline to the cloud once we’re ready to do so without much overhead.</p><h3>Gradio</h3><p>There’s still one piece missing: ideally once we’ve trained a model and gotten some initial evaluation results, we’d like to be able to interactively feed the model inputs and see what it produces. <a href="https://www.gradio.app/">Gradio</a> is ideally suited for this task, as it will allow us to develop a simple app hooked up to our model with just a few lines of python.</p><h2>Tying it all together</h2><p>Armed with this impressive arsenal of tooling, how do we put it all together? We can use Sematic to define and chain together the steps in our workflow just using regular python functions, decorated with the <em>@sematic.func</em> decorator.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b5642226860f844ba26cf9_code.png" loading="lazy" alt=""/></p><figcaption>The Sematic code for defining our pipeline. The rest of the code defining the steps in our workflow can be found <a href="https://github.com/sematic-ai/sematic/blob/main/sematic/examples/summarization_finetune/pipeline.py">here</a>.</figcaption></figure><p>This will give us:</p><ul role="list"><li>A graph view to monitor execution of the experiment as it progresses through the various steps</li></ul><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b564439d50991decf3c729_dag.jpeg" loading="lazy" alt=""/></p><figcaption>Sematic’s graph view for the above pipeline, for a completed execution. Live, Sematic will visualize the progress through the steps.</figcaption></figure><ul role="list"><li>A dashboard to keep track of our experiments, notes, inputs, outputs, source code, and more. This includes links to the resources we’re using/producing on Hugging Face Hub, navigable configuration &amp; result displays. Sematic EE users can get access to even more, like live metrics produced during training and evaluation.</li></ul><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b5646310665731cf6f4d66_rundetails.png" loading="lazy" alt=""/></p><figcaption>A section of the Sematic dashboard for our pipeline. 🤗 buttons link to the corresponding resources on Hugging Face Hub. Input and output displays are available for the overall pipeline, as well as all of the steps within it.</figcaption></figure><ul role="list"><li>A search UI to track down specific experiments we might be interested in</li></ul><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b5649aa2a000c183f67ffa_runsearch.png" loading="lazy" alt=""/></p><figcaption>We can search for runs using tags, free text search, status, and more.</figcaption></figure><ul role="list"><li>The basic structure we need to scale our pipeline up to cloud scale. When we’re ready, we can even add distributed inference using Sematic’s integration with <a href="https://docs.sematic.dev/integrations/ray">Ray</a>.</li></ul><p>After defining our basic pipeline structure with Sematic, we need to define the Hugging Face code with transformers &amp; PEFT.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b564baa2cb57e472195b92_peft.png" loading="lazy" alt=""/></p><figcaption>One of the key portions of the training code to fine tune with Hugging Face’s PEFT library.</figcaption></figure><p>This requires a bit more effort than the Sematic setup, but it’s still quite a manageable amount of code given the power of what we’re doing. The full source can be found <a href="https://github.com/sematic-ai/sematic/blob/main/sematic/examples/summarization_finetune/train_eval.py">here</a>. Luckily, usage of the “accelerate” library comes essentially for free once you have installed it alongside transformers &amp; PEFT.</p><p>Finally, we need to hook up Gradio. It just takes a few lines of python to define our Gradio app:</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b564d8b59ceea72d55e065_gradioCode.png" loading="lazy" alt=""/></p></figure><p>This app will have a text input, a text output, a run button (to invoke the model and get a summary using the context), and a stop button (to close the Gradio app and allow the Sematic pipeline to continue). We’ll keep track of all the input contexts and output summaries in a history object (essentially just a list of prompt/response pairs) to be visualized in the dashboard for the Sematic pipeline. This way we can always go back to a particular pipeline execution later and see a transcript of our interactive trials. The interactive app will look like this:</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b564f59d50991decf48de9_gradioSample.png" loading="lazy" alt=""/></p></figure><p>The transcript will be displayed as the output of the <em>launch_interactively</em> step in our pipeline.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b565134c819db7f4929757_Screenshot%202023-07-07%20at%2010.36.05%20AM.png" loading="lazy" alt=""/></p></figure><h2>Results</h2><p>We’ve set up this script so that via the command line we use to launch, we can change:</p><ul role="list"><li>The model (selecting from one of the FLAN-T5 variants or GPT-J 6B)</li><li>The training hyperparameters</li><li>The dataset used</li><li>The Hugging Face repo to export the result to, if we even want to export the result</li></ul><p>Let’s take a look at some of the results we get.</p><h3>CNN Daily Mail Article Summarization</h3><p>The default dataset used by our pipeline is <a href="https://huggingface.co/datasets/cnn_dailymail">cnn_dailymail</a>, from Hugging Face. This contains some articles from CNN paired with summaries of those articles. Using FLAN-T5 large variant, we were able to produce some good summaries, such as the one below.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b5653b4c819db7f492ceda_cnn.png" loading="lazy" alt=""/></p></figure><p>Not all results were perfect though. For example, the one below contains some repetition and misses some key information in the summary (like the name of the headliners).</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b56561880589a87ae234eb_promptresponse.png" loading="lazy" alt=""/></p></figure><h3>Amazon Review Headline Suggestion</h3><p>To demonstrate the flexibility that can be achieved with fine-tuning, we also used a fairly different use case for our second tuning. This time we leveraged the <a href="https://huggingface.co/datasets/amazon_us_reviews">amazon_us_reviews</a> dataset, pairing a review with the review’s headline, which could be considered a summary of the review’s content.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/64126b88611c756552a4a568/64b5657f95979a5476cdaffa_amazon.png" loading="lazy" alt=""/></p></figure><h2>Try it out yourself!</h2><p>Think this example might actually be useful to you? It’s free and open-source! All you need to do to use it is install Sematic 0.32.0</p><div><pre><p><code>$ pip install sematic
$ sematic start
$ sematic run examples/summarization_finetune -- --help</code></p></pre></div><p>Then follow the instructions <a href="https://github.com/sematic-ai/sematic/blob/main/sematic/examples/summarization_finetune/README.md">here</a>.</p><p>You can fine tune any of the supported models on any Hugging Face dataset with two text columns (where one column contains the summaries of the other). Tuning the large FLAN variants, Llama 2 models, or GPT-J may require machines with at least 24 GB of GPU memory. However, the small and base FLAN variants have been successfully tuned on M1 Macbooks. Hop on our <a href="https://discord.gg/4KZJ6kYVax">Discord</a> if you have any suggestions or requests, or even if you just want to say hi!</p></div></div></div>
  </body>
</html>
