<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jackcook.com/2023/09/08/predictive-text.html">Original</a>
    <h1>Apple’s new Transformer-powered predictive text model</h1>
    
    <div id="readability-page-1" class="page"><div>
  <section id="post">
  
  <p>
    New York, NY — September 08, 2023
  </p>
  <p>At WWDC earlier this year, Apple announced that upcoming versions of iOS and macOS would ship with a new feature powered by “<a href="https://www.apple.com/newsroom/2023/06/ios-17-makes-iphone-more-personal-and-intuitive/">a Transformer language model</a>” that will give users “predictive text recommendations inline as they type.”</p>

<p>Upon hearing this announcement, I was pretty curious about how this feature works.
Apple hasn’t deployed many language models of their own, despite most of their competitors going all-in on large language models over the last couple years.
I see this as a result of Apple generally priding themselves on polish and perfection, while language models are fairly unpolished and imperfect.</p>

<p>As a result, this may be one of the first Transformer-based models that Apple will ship in one of its operating systems, or at least one of the first that they’ve acknowledged publicly.
This left me with some questions about the feature, notably:</p>

<ul>
  <li>What underlying model is powering this feature?</li>
  <li>What is its architecture?</li>
  <li>What data was used to train the model?</li>
</ul>

<p>After spending some time with these questions, I was able to find some answers, but many of the details still remain unclear.
If you’re able to get any further than I could, please get in touch!</p>

<h2 id="how-does-the-feature-work">How does the feature work?</h2>

<p>After installing the macOS beta, I immediately opened the Notes app and started typing.
Despite trying many different sentence structures, the feature generally appeared less often than I expected it to.
It mostly completes individual words.</p>

<figure>
<img src="https://jackcook.com/img/blog/predictive-text/individual-word-2.png"/>
<figcaption>Predictive text completing one word at a time.</figcaption>
</figure>

<p>The feature will occasionally suggest more than one word at a time, but this is generally limited to instances where the upcoming words are extremely obvious, similar to the autocomplete in Gmail.</p>

<figure>
<img src="https://jackcook.com/img/blog/predictive-text/multiple-words.jpeg"/>
<figcaption>Predictive text completing two words at a time.</figcaption>
</figure>

<h2 id="can-we-dig-deeper">Can we dig deeper?</h2>

<p>Finding the model itself was a little tough, but I eventually found the model being used by <code>AppleSpell</code>, an internal macOS application that checks for spelling and grammar mistakes as you type.
With the help of <a href="https://github.com/hot3eed/xpcspy"><code>xpcspy</code></a>, I wrote a Python script that snoops on <code>AppleSpell</code> activity and streams the most probable suggestions from the predictive text model as you type in any application.</p>

<figure>
<video controls="" src="/img/blog/predictive-text/script-demo.mov" type="video/mov"></video>
<figcaption>My “predictive spy” script in action.</figcaption>
</figure>

<p>Unfortunately, I wrote this script earlier in the summer, on the first macOS Sonoma beta.
In one of the subsequent betas (I’m not sure which), Apple removed the unused completions from the XPC messages sent by AppleSpell.
I wasn’t able to glean too much about the model’s behavior from these completions, but it was still a cool find.</p>

<h2 id="where-is-the-model">Where is the model?</h2>

<p>After some more digging, I’m pretty sure I found the predictive text model in <code>/System/Library/LinguisticData/RequiredAssets_en.bundle/AssetData/en.lm/unilm.bundle</code>.
The bundle contains multiple Espresso model files that are used while typing (Espresso <a href="https://machinethink.net/blog/peek-inside-coreml/">appears to be</a> the internal name for the part of CoreML that runs inference on models).
I wasn’t ultimately able to reverse-engineer the model, but I’m fairly confident this is where the predictive text model is kept.
Here’s why:</p>

<ol>
  <li>Many of the files in <code>unilm.bundle</code> don’t exist on macOS Ventura (13.5), but they do exist on the macOS Sonoma beta (14.0). And the files that do exist in both versions have all been updated in Sonoma.</li>
  <li><code>sp.dat</code>, one of the files in <code>unilm.bundle</code>, exists on Ventura, but it’s been updated in the Sonoma beta. In the updated version of the file, I found what looks pretty clearly like a set of tokens for a tokenizer.</li>
  <li>The number of tokens in <code>sp.dat</code> matches the shape of the output layer in both <code>unilm_joint_cpu.espresso.shape</code> and <code>unilm_joint_ane.espresso.shape</code> (ANE = Apple Neural Engine), two files in <code>unilm.bundle</code> that describe the shapes of layers in an Espresso/CoreML model. This is what we would expect to see for a model that is trained to predict the next token.</li>
</ol>

<h2 id="the-predictive-text-models-tokenizer">The predictive text model’s tokenizer</h2>

<p>I found a set of 15,000 tokens in <code>unilm.bundle/sp.dat</code> that pretty clearly look like they form the vocabulary set for a large language model.
I wrote a script that you can use to see this vocabulary file for yourself, which you can check out <a href="https://github.com/jackcook/predictive-spy">on GitHub</a>.</p>

<p>The vocabulary starts with <code>&lt;pad&gt;</code>, <code>&lt;s&gt;</code>, <code>&lt;/s&gt;</code>, and <code>&lt;unk&gt;</code> tokens, which are all fairly common special tokens (<code>roberta-base</code> and <code>t5-base</code> are two popular language models):</p>

<pre><code>&gt;&gt;&gt; from transformers import AutoTokenizer</code>
<code>&gt;&gt;&gt;</code>
<code>&gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(&#34;roberta-base&#34;)</code>
<code>&gt;&gt;&gt; tokenizer.convert_ids_to_tokens([0, 1, 2, 3])</code>
<code>[&#39;&lt;s&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;/s&gt;&#39;, &#39;&lt;unk&gt;&#39;]</code>
<code>&gt;&gt;&gt;</code>
<code>&gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(&#34;t5-base&#34;)</code>
<code>&gt;&gt;&gt; tokenizer.convert_ids_to_tokens([0, 1, 2])</code>
<code>[&#39;&lt;pad&gt;&#39;, &#39;&lt;/s&gt;&#39;, &#39;&lt;unk&gt;&#39;]</code>
</pre>

<p>Next come the following sequences:</p>

<ul>
  <li>20 special tokens, named <code>UniLMCTRL0</code> through <code>UniLMCTRL19</code></li>
  <li>79 contractions (I’d, couldn’t, you’ve…)</li>
  <li>1 special <code>_U_CAP_</code> token</li>
  <li>20 special tokens, named <code>_U_PRE0_</code> through <code>_U_PRE19_</code></li>
  <li>60 special tokens, named <code>_U_NT00_</code> through <code>_U_NT59_</code></li>
  <li>100 emojis</li>
</ul>

<p>And then comes a more normal-looking list of 14,716 tokens, most of which are followed by the special character ▁ (U+9601), which is commonly used in byte-pair encoding (BPE) tokenizers, such as the GPT-2 tokenizer, to denote a space.</p>

<p>I have to say that this vocabulary file strikes me as pretty unique, but it’s definitely not out of the question for a language model deployed in this setting.
I’ve personally never seen emojis featured so prominently in a language model’s tokenizer, but <a href="https://arxiv.org/abs/2007.15779">existing</a> <a href="https://arxiv.org/abs/2303.17564">research</a> has shown that domain-specific models and tokenizers can drastically improve downstream model performance.
So it makes sense that a model trained for use in things like text messages, in which emojis and contractions will be used a lot, would prioritize them.</p>

<h2 id="model-architecture">Model architecture</h2>

<p>Based on the contents of the <code>unilm_joint_cpu</code> model from earlier, we can make some assumptions about the predictive text network.
Despite sharing the name of Microsoft’s <a href="https://www.microsoft.com/en-us/research/publication/unified-language-model-pre-training-for-natural-language-understanding-and-generation/">UniLM</a> from 2019, it looks more to me like a model based on <a href="https://openai.com/research/better-language-models">GPT-2</a>.</p>

<p>GPT-2 has four main parts: token embeddings, positional encodings, a series of 12-48 decoder blocks, and an output layer.
The network described by <code>unilm_joint_cpu</code> appears to be the same, except with only 6 decoder blocks.
Most of the layers within each decoder block have names like <code>gpt2_transformer_layer_3d</code>, which would also seem to suggest it’s based on a GPT-2 architecture.</p>

<p>From my calculations based on sizes of each layer, Apple’s predictive text model appears to have about 34 million parameters, and it has a hidden size of 512 units.
This makes it much smaller than even the smallest version of GPT-2.</p>

<table>
  <thead>
    <tr>
      <th>Model</th>
      <th>Decoder Blocks</th>
      <th>Parameters</th>
      <th>Hidden Size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Apple’s predictive text model</td>
      <td>6</td>
      <td>34M</td>
      <td>512</td>
    </tr>
    <tr>
      <td>gpt2</td>
      <td>12</td>
      <td>117M</td>
      <td>768</td>
    </tr>
    <tr>
      <td>gpt2-medium</td>
      <td>24</td>
      <td>345M</td>
      <td>1024</td>
    </tr>
    <tr>
      <td>gpt2-large</td>
      <td>36</td>
      <td>762M</td>
      <td>1280</td>
    </tr>
    <tr>
      <td>gpt2-xl</td>
      <td>48</td>
      <td>1542M</td>
      <td>1600</td>
    </tr>
  </tbody>
</table>

<p>For the limited scope of the predictive text feature, this makes sense to me.
Apple wants a model that can run very quickly and very frequently, without draining much of your device’s battery.
When I was testing the predictive text feature, suggestions appeared almost instantly as I typed, making for a great user experience.
While the model’s limited size means it wouldn’t be very good at writing full sentences or paragraphs, when it exhibits very high confidence in the next word or two, they’re likely to be good enough to suggest to the user.</p>

<p>However, with my script that snoops on activity from <code>AppleSpell</code>, we can get the model to write full sentences anyway.
If I type “Today” as the first word of my sentence and take the model’s top suggestion each time, here’s what I get (<a href="https://jackcook.com/img/blog/predictive-text/longer-demo.mov">video</a>):</p>

<blockquote>
  <p>Today is the day of the day and the day of the week is going to be a good thing I have to do is get a new one for the next couple weeks and I think I have a lot of…</p>
</blockquote>

<p>Not very inspiring.
We can compare this with the output from the smallest GPT-2 model:</p>

<blockquote>
  <p>Today, the White House is continuing its efforts against Iran to help the new President, but it will also try to build new alliances with Iran to make more…</p>
</blockquote>

<p>Or the largest GPT-2 model:</p>

<blockquote>
  <p>Today, the U.S. Department of Justice has filed a lawsuit against the city of Chicago, the Chicago Police Department, and the city’s Independent Police Review Authority, alleging that the police department and the Independent Police Review Authority engaged in a pattern or practice…</p>
</blockquote>

<p>Pretty cool seeing the effects of all those extra parameters!
It’ll be interesting to see how this feature grows and evolves in the future, and whether Apple decides to keep its scope fairly narrow or someday expand its abilities.</p>

<p>If you’re interested in trying any of this out for yourself, all of my code is on <a href="https://github.com/jackcook/predictive-spy">GitHub</a>.</p>
 
  
  
  
</section>





</div></div>
  </body>
</html>
