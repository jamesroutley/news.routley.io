<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.assemblyai.com/blog/differentiable-programming-a-simple-introduction/">Original</a>
    <h1>Differentiable Programming â€“ A Simple Introduction</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
                </section>
    <section>
      <p><strong>Differentiable Programming</strong> is a relatively new term that is often conflated with Deep Learning. While Deep Learning indeed overlaps with Differentiable Programming, Deep Learning is a <em>subset </em>of Differentiable Programming.</p><p>In this article we&#39;ll explain what Differentiable Programming is and how it differs from Deep Learning, in particular with reference to its greater generality. We&#39;ll learn through example by solving a physics-based problem in three (progressively smarter) ways. Let&#39;s get started!</p><h2 id="introduction-to-differentiable-programming">Introduction to Differentiable Programming</h2><p>Many Machine Learning techniques at their core boil down to minimizing some loss function to learn a model that is well-suited to solve some problem. Deep Learning builds on top of this central idea by imposing two requirements on the model itself - a <strong>network architecture </strong>and training via <strong>automatic differentiation.</strong> In contrast, <strong>Differentiable Programming</strong> demands only <em>one</em> of these requirements - training via automatic differentiation.</p><p>Differentiable Programming refers to utilizing automatic differentiation in some way that allows a program to optimize its parameters in order to get better at some task. It requires only three things:</p><ol><li>A <strong>parameterized function </strong>/ method / model to be optimized</li><li>A <strong>loss</strong> that is suitable to measure performance, and</li><li>(Automatic)<strong> differentiability</strong> of the object to be optimized</li></ol><p>While Deep Learning certainly checks these boxes, it is not the only field that does. Differentiable Programming can be applied to a <a href="https://www.assemblyai.com/blog/differentiable-programming-a-simple-introduction#final-words">wide variety of tasks in other areas</a>, including probabilistic programming, Bayesian inference, robotics, and physics.</p><h2 id="the-problem-aiming-a-cannon">The Problem: Aiming a Cannon</h2><p>We&#39;ll explore the topic of Differentiable Programming by considering the following question: </p><blockquote><em>Given a target at a known distance, how can we adjust a cannon&#39;s angle and ejection velocity in order to hit the target?</em></blockquote><p>We&#39;ll solve this problem in three ways - first using a <strong>purely Deep Learning</strong> approach, second using a <strong>purely Newtonian </strong>approach, and finally using a <strong>hybrid Newtonian Deep Learning </strong>approach.</p><h2 id="neural-network-approach">Neural Network Approach</h2><p>We&#39;ll first approach this problem using only neural networks, working under the assumption that we don&#39;t know anything about physics. Instead, we just have a cannon that we can shoot many, many times in order to collect a lot of data, recoding the launch angle, ejection velocity, and corresponding landing distance for each datum. Our goal is to understand <strong>how we can exploit this empirical data in order to go in the <em>other</em> direction</strong>, namely mapping <em>from </em>a target distance <em>to </em>suitable control parameters that will land our projectile at the desired target.</p><p>We might think at a first glance that this problem is easy. We want to input distances and output control parameters, so we can just train a model to perform this mapping using all of the data that we collected.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/02/d_to_control_2.png" alt="" loading="lazy" width="524" height="386"/><figcaption>A first attempt at solving this problem might involve creating a Neural Network to map from distances to corresponding control parameters</figcaption></figure><p>Unfortunately, this approach will not work because <strong>we do not know how to measure loss</strong>. We can input a target distance and get hypothesized control parameters, but <em>how do we determine if these are &#34;good&#34; control parameters</em>? Is the average MAE between the hypothesized and true control parameters suitable? What if there are multiple solutions (which there are, in this case)? Remember that we don&#39;t know anything about physics in this scenario!</p><p>Instead, we map in the <strong>other direction</strong>, <em>from </em>control parameters <em>to </em>resulting distance, because the loss is easy to calculate - we simply measure the difference between our predicted distance and true difference (and square it for differentiability)<sup>[<a href="https://www.assemblyai.com/blog/differentiable-programming-a-simple-introduction#footnotes">1</a>]</sup>. </p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/02/control_to_d_2.png" alt="" loading="lazy" width="514" height="381"/><figcaption>Mapping instead from control parameters to the resulting projectile distance provides a simple and intuitive way to measure loss</figcaption></figure><p>Let&#39;s train such a neural network. Below you can see the results of training on 1,000 data points, where the blue surface is the true underlying function that we are trying to replicate.</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/NN_fitting.mp4" poster="https://img.spacergif.org/v1/1600x1200/0a/spacer.png" width="1600" height="1200" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Neural Network learning on data (green) to approximate the true underlying function (blue) over 100 epochs</figcaption></figure><p><strong>After training, we have a neural network which has learned to map from control parameters to the resulting distance.</strong> Let&#39;s see how the loss surface changes as we vary the target distance in the plot below. The <em>x</em>-axis is the initial velocity of the projectile (ranging from <em>0</em> to max of <em>10 m/s</em>), the <em>y</em>-axis is the angle of the shot (ranging from 0 to pi/2 radians, exclusive), and the<em> z</em>-axis is the MSE between the resulting distance and target distance.</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/nn_loss_anim.mp4" poster="https://img.spacergif.org/v1/2400x1800/0a/spacer.png" width="2400" height="1800" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>The empirical loss surface (as a function of initial velocity and launch angle) changes form depending on target distance</figcaption></figure><p>Now that we have a neural network that approximates the mapping <em>from </em>control parameters <em>to </em>resulting distance, how are we to get suitable control parameters for a given target distance? Remember we want to <em>input</em> a target distance and <em>output </em>control parameters, but our neural network maps in the other direction. </p><p>As we can see in the above plot, we have a loss surface which is a function of the control parameters and whose shape is parameterized by our target distance; therefore, we can simply use <strong>gradient descent</strong><sup>[<a href="https://www.assemblyai.com/blog/differentiable-programming-a-simple-introduction#footnotes">2</a>]</sup>! While we first used gradient descent in order to <em>learn</em> an approximation of the control parameters to distances mapping, we are now using gradient descent to <em>minimize</em> the corresponding loss surface of this mapping as parameterized by our input target distance. Let&#39;s perform this gradient descent now:</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/nn_grad_desc_rotation.mp4" poster="https://img.spacergif.org/v1/1600x1200/0a/spacer.png" width="1600" height="1200" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Path of gradient descent towards empirical loss function minimum curve</figcaption></figure><p>We started with an initial guess and successfully learned better control parameters that got us closer to our target. Below you can see an animation of different trajectories during the descent, which took several hundred iterations in total.</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/nn_trajectories.mp4" poster="https://img.spacergif.org/v1/800x600/0a/spacer.png" width="800" height="600" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>During gradient descent, the landing spot tends towards the target</figcaption></figure><p>I said the learned control parameters are <em>better</em>, not <em>correct, </em>intentionally. Remember, although we are minimizing our loss with gradient descent (and may in fact reach a loss of zero), this loss is with respect to the approximate form of the true underlying function which defines the relationship between control parameters and resulting distance. Although we <em>probably </em>learn better control parameters, we don&#39;t know that they&#39;re perfect or <em>even sufficient</em>. In fact, the final trajectory in the animation above has a <strong>20-centimeter </strong>error from the target even though we set our gradient descent to have a maximum of a <strong>5-centimeter</strong> error. The error is at most 5 centimeters with respect to the <em>approximate </em>model, but is technically unbounded with respect to the <em>true </em>model. </p><p>In order to bound the error, we would need to input a target, use gradient descent (on the fixed neural model) to learn control parameters, use these control parameters to run experiments and collect the <em>true </em>resulting distance, and then compare this distance to the input target distance, performing some statistical analysis over large amounts of data.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/02/NN_approach-1.png" alt="" loading="lazy" width="960" height="540" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/02/NN_approach-1.png 600w, https://www.assemblyai.com/blog/content/images/2022/02/NN_approach-1.png 960w" sizes="(min-width: 720px) 720px"/><figcaption>Gradient descent to optimize the control parameters happens with respect to the empirical model - to determine its performance, the results need to be compared to real experimentation.</figcaption></figure><p>While this whole process seems labor-intensive and insufficient, especially given the unboundedness of the difference between predicted performance and true performance, it truly is the best we can do in this scenario (save training the neural network on more data). How can we improve our approach?</p><h2 id="newtonian-approach">Newtonian Approach</h2><p>By now you will have noticed the glaringly obvious problem with our above approach - we are not taking advantage of the hundreds of years of physics that provides us with insight into the problem at hand, insight which is conveniently encapsulated in the form of mathematical relationships which we can exploit. </p><p>Above, we were approximating the mapping from control parameters to the resulting projectile distance, but if we know the laws of motion <em>why would we approximate this function with a neural network</em>? In this case, a quite simple kinematic analysis provides us with the true underlying mapping, which in turn gives us the true loss surface, again as a function of initial velocity and ejection angle and parameterized by the target distance. Let&#39;s again take a look at how this loss surface changes as the target distance parameter is varied.</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/loss_evolution.mp4" poster="https://img.spacergif.org/v1/2400x1800/0a/spacer.png" width="2400" height="1800" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>How the <em>true </em>loss surface (which our Neural Network sought to approximate in the last section) changes as parameterized by target distance</figcaption></figure><p>The easily observed difference in form between the true loss surface and approximate-model loss surface helps us highlight the issue with the previous method - minimizing a perturbed loss surface can yield imperfect control parameters. You&#39;ll notice that, despite the fact that the surfaces trend the same way, the <strong>parabola which defines the minimum curve in the real model</strong> (blue) <strong>is not identical to the minimum curve of the neural model</strong> (green). That is, even if we properly minimize on the empirical loss surface, the resulting control parameters may not lie on the true solution curve. </p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/03/comparison.mp4" poster="https://img.spacergif.org/v1/2400x1800/0a/spacer.png" width="2400" height="1800" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Gradient descent on the empirical loss surface compared to the true loss surface. Note that the projections of the minimum curves of the empirical and true loss surfaces onto the control parameter plane would not perfectly align.</figcaption></figure><p>Given our true loss surface, we can perform gradient descent just as before. You can see the gradient descent path in the plot below.</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/grad_path.mp4" poster="https://img.spacergif.org/v1/1600x1200/0a/spacer.png" width="1600" height="1200" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Path of gradient descent on true loss function</figcaption></figure><p>If we examine the trajectories of the projectile during the descent, we can see a slow-but-steady tuning to sufficient control parameters.</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/output.mp4" poster="https://img.spacergif.org/v1/800x600/0a/spacer.png" width="800" height="600" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Gradient descent of the true loss function takes fewer iterations to reach suitable control parameters</figcaption></figure><p>The true loss surface has the benefit of being globally smoother, yielding fewer iterations and a more robust descent. Also, we don&#39;t have to worry about ill-conditioning in contrast to the empirical loss surface, where if we initialized in the top right-hand corner (red arrow) our descent would&#39;ve resulted in wildly incorrect control parameters. Relating to this, using the true loss surface has the benefit of ensuring that found solutions are actually correct (insofar as our physical model actually reflects reality, but this is the scope of science and not Machine Learning).</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/03/Screenshot-2022-02-28-1.png" alt="" loading="lazy" width="1539" height="618" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/03/Screenshot-2022-02-28-1.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/03/Screenshot-2022-02-28-1.png 1000w, https://www.assemblyai.com/blog/content/images/2022/03/Screenshot-2022-02-28-1.png 1539w" sizes="(min-width: 720px) 720px"/><figcaption>The true loss surface (blue, left) is globally smooth and provides more robust and accurate gradient descent when compared to the empirical (green, right) loss surface</figcaption></figure><p>At this point you may be wondering <em>why we even brought up neural networks in the first place</em>. If we can simply perform gradient descent on the true loss function, why would we not just do this in the first place? The answer is that the <em>best</em> method actually combines the two previous methods yielding a hybrid Newtonian Neural Network approach, which is precisely the <strong>Differentiable Programming</strong> approach.</p><h2 id="differentiable-programming-approach">Differentiable Programming Approach</h2><p>In either of the two cases above, we needed to perform gradient descent. This means that if we were to deploy such a model, we would have to worry about unknown runtimes, poorly tuned learning rates, getting stuck in local minima, etc. The need for gradient based optimization resulted ultimately from our inability to devise a way to measure <strong>loss </strong>with respect to output control parameters:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/03/unknown_loss_2.png" alt="" loading="lazy" width="657" height="405" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/03/unknown_loss_2.png 600w, https://www.assemblyai.com/blog/content/images/2022/03/unknown_loss_2.png 657w"/><figcaption>Previously, in our physics-blind method, we did not know how to measure loss with respect to output control parameters</figcaption></figure><p>This inability to devise a suitable loss resulted in us flipping the inputs and outputs, giving us a sensible loss as the MSE between target distance and predicted distance, and then performing gradient descent to get sufficient control parameters. While we can exploit our knowledge of physics to optimize the true loss surface in this way, we can do better by <strong>using the physical model to generate a sensible loss function</strong>. </p><p>The result is a <strong>Differentiable Programming approach </strong>where we are mapping <em>from</em> a target distance <em>to</em> corresponding control parameters and then <em>to</em> the true distance resulting from these parameters. The result is <strong>effectively an autoencoding network</strong> in which the neural network learns the &#34;inverse&#34;<sup>[<a href="https://www.assemblyai.com/blog/differentiable-programming-a-simple-introduction#footnotes">3</a>]</sup> of the physical model which maps from control parameters to resulting distances:</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/02/model_transitions.mp4" poster="https://img.spacergif.org/v1/1280x720/0a/spacer.png" width="1280" height="720" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>We incorporate prior domain-specific knowledge to create an &#34;autoencoding&#34; network which we can backpropagate through to train our approximation network</figcaption></figure><p>Since our physical model constitutes a composition of differentiable functions, we can backpropagate through the network and update the parameters of the neural network to learn.</p><p>The result is a prediction network which maps <strong>from target distances to suitable control parameters</strong>, which was our goal all along. Once we use it to generate predicted control parameters, the physical model can then be used to <em>verify </em>that the control parameters yield a landing distance that is within the allowed error of our target distance.</p><p>If the landing distance is not suitably close, we can once again <strong>perform gradient descent </strong>on the true model, but this time <strong>using the predicted control parameters as a starting point rather than a random initialization</strong>. Therefore, with a Differentiable Programming approach, we have:</p><ol><li>A <strong>pre-trained</strong><em> </em>neural model that can quickly provide control parameters estimates given a target distance</li><li>A method of <strong>verifying </strong>that these control parameters will indeed land the projectile sufficiently close to the target, and </li><li>A fast way of <strong>adjusting </strong>the control parameters if they are <em>not </em>sufficient (requiring far fewer iterations on average than a random initialization).</li></ol><p>We can see the total system in the chart below:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/03/0---diffp-2.png" alt="" loading="lazy" width="768" height="1079" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/03/0---diffp-2.png 600w, https://www.assemblyai.com/blog/content/images/2022/03/0---diffp-2.png 768w" sizes="(min-width: 720px) 720px"/><figcaption>Complete schematic of the Differentiable Programming approach to solving the Cannon Problem</figcaption></figure><!--kg-card-begin: html--><!--kg-card-end: html--><h2 id="final-words">Final Words</h2><p>While we provide a simple, high-level use case of Differentiable Programming for hybrid neural-physical models, its applications far exceed this example. Some areas that utilize Differentiable Programming<sup>[<a href="https://www.assemblyai.com/blog/differentiable-programming-a-simple-introduction/#footnotes">4</a>]</sup> to inject their projects with Artificial Intelligence are:</p><!--kg-card-begin: html--><!--kg-card-end: html--><p>For those interested in more advanced use cases, the team at the <a href="https://julialang.org/">Julia Programming Language</a> has some great resources on Differentiable Programming<sup>[<a href="https://www.assemblyai.com/blog/differentiable-programming-a-simple-introduction#footnotes">4</a>]</sup>.</p><ol><li>Note here that we are doing pure Machine Learning - we could know nothing about the situation at hand, viewing the data only as 3 columns of numbers <em>a, b, </em>and c, and still the train model successfully as long as we are told that MSE is an appropriate loss function.</li><li>It should be noted here that, even if the underlying true model is not differentiable or even continuous, the approximate model is <em>guaranteed</em> to be differentiable, so we can be sure that gradient descent is a viable method of optimization. This guarantee stems from the fact that a neural network is a composition of differentiable functions, therefore itself being globally differentiable.</li><li>This is not a true inverse in the mathematical sense because the forward mapping from control parameters to resulting distances is not injective. It is simply an inverse in the sense that it finds a path through the minimizing level curves of the forward mapping as a function of the target distance.</li><li>A lecture covering these topics can be found <a href="https://www.youtube.com/watch?v=rF2QAJLM730">here</a> and was the inspiration for the cannon problem in this article.</li></ol>
    </section>
  </div></div>
  </body>
</html>
