<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.crunchydata.com/blog/postgres-indexes-for-newbies">Original</a>
    <h1>Postgres Indexes for Newbies</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<div data-widget-type="blog_content" data-x="0" data-w="12">
<div>
  <div>
    
    <p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p> If you’ve read <a href="https://blog.crunchydata.com/blog/five-tips-for-a-healthier-postgres-database-in-the-new-year" rel="noopener" target="_blank"><span>Crunchy blogs</span></a> recently you probably noticed by now that we’re all big fans of indexing. Indexing is key to optimizing your database workloads and reducing query times. Postgres now supports <a href="https://www.postgresql.org/docs/current/indexes-types.html" rel="noopener" target="_blank"><span>quite a few types</span></a> of indexes and knowing the basics is a key part of working with Postgres. </p>
<p>The role of database indexes is similar to the index section at the back of a book. A database index stores information on where a data row is located in a table so the database doesn&#39;t have to scan the entire table for information. When the database has a query to retrieve, it goes to the index first and then uses that information to retrieve the requested data.</p>
<p>Indexes are their own data structures and they’re part of the Postgres data definition language (the DDL). They&#39;re stored on disk along with data tables and other objects. </p>
<!--more-->
<ul>
<li><span>B-tree indexes</span> are the most common type of index and would be the default if you create an index and don’t specify the type. B-tree indexes are great for general purpose indexing on information you frequently query. </li>
<li><span>BRIN indexes</span> <span>are block range indexes, specially targeted at very large datasets where the data you’re searching is in blocks, like timestamps and date ranges. They are known to be very performant and space efficient.</span></li>
<li><span>GIST indexes</span> build a search tree inside your database and are most often used for spatial databases and full-text search use cases. </li>
<li><span>GIN indexes</span> are useful when you have multiple values in a single column which is very common when you’re storing array or json data. </li>
</ul>
<p>I did all my testing on <a href="https://www.crunchydata.com/products/crunchy-bridge/" rel="noopener" target="_blank"><span>Crunchy Bridge</span></a> with a hobby instance, which is very nice for this kind of quick data load and testing work. I have some samples available alongside this post if you want to follow along with the data I used. You can also use Crunchy&#39;s <a href="https://learn.crunchydata.com/" rel="noopener" target="_blank">learning portal</a> to do an <a href="https://learn.crunchydata.com/postgresql-devel/courses/basics/introindex" rel="noopener" target="_blank">indexing tutorial</a>. </p>
<h2>Using <span>Explain Analyze</span></h2>
<p>You almost never talk about Postgres indexing without referring to the <a href="https://www.postgresql.org/docs/current/sql-explain.html" rel="noopener" target="_blank"><span>Explain</span></a> feature. This is just one of those Postgres Swiss Army knife tools that you need to have in your pocket at all times. <a href="https://blog.crunchydata.com/blog/get-started-with-explain-analyze" rel="noopener" target="_blank"><span>Explain analyze</span></a> will give you information like query plan, execution time, and other useful info for any query. So as you’re working with indexes, you’ll be checking the indexes using explain analyze to review the query path and query time. </p>
<p>You&#39;ll see that the query plan indicates a &#34;Seq Scan,&#34; or a sequential scan. This means that it scans each data row in the table to see if it matches the query condition. You might be able to guess that for larger tables, a sequential scan could take up quite a bit of time so that’s where the index saves your database workload. </p>
<pre><code>Seq Scan on weather (cost=0.00..168.00 rows=496 width=102) (actual time=0.011..0.181 rows=100 loops=1)</code></pre>
<p>If you’re using an index, you’ll see an index scan in your Explain results. </p>
<pre><code>Bitmap Index Scan on idx_weather_type  (cost=0.00..8.00 rows=496 width=0) (actual time=0.027..0.027 rows=496 loops=1</code></pre>
<h2><span>Analyze</span> Database</h2>
<p>The <span>ANALYZE</span> command collects information about the tables or database which are used by the internal query planner. There are some cases where you might want to run this before or after adding an index so that the database uses the most up to date query plan. In my testing, this seems to affect larger databases. </p>
<h2>B-Tree Sample</h2>
<p>For the B-Tree samples I’ve used some open weather data with data events by type, damage, time and location<a href="#fn1" rel="noopener"><sup>1</sup></a>. For just a very basic index, I’m going to find everything for winter storms. Once I add this index, this means that to get this data, the database doesn&#39;t have to scan all the weather events to get me additional data about severe weather events, it already knows where to look for those. </p>
<p><strong>Starting query </strong></p>
<pre><code><span>SELECT</span> <span>* <br/></span><span><strong>FROM</strong></span><span> weather <br/></span><span><strong>where</strong></span><span> event_type=</span><span>&#39;Winter Storm&#39;</span></code></pre>
<p><strong>Before index explain analyze</strong></p>
<pre><code>Seq Scan on weather  (cost=0.00..9204.64 rows=3158 width=853) (actual time=0.008..27.619 rows=3182 loops=1)
Execution Time: 27.778 ms
</code></pre>
<p><strong>Index</strong></p>
<pre><code><span>CREATE INDEX</span> idx_weather_type ON weather(event_type);</code></pre>
<p><strong>After index explain analyze</strong></p>
<pre><code>Bitmap Index Scan on idx_weather_type  (cost=0.00..35.98 rows=3158 width=0) (actual time=0.247..0.247 rows=3182 loops=1)
Execution Time: 3.005 ms
</code></pre>
<p>Look at that drop in query time, cool! </p>
<h4>Multicolumn B-Tree Indexes</h4>
<p>Indexes aren&#39;t always created for single columns only - Postgres also supports multicolumn indexes. These can be useful if you know that you&#39;ll be querying a lot on multiple columns at once.</p>
<p><strong>Starting query</strong></p>
<pre><code><span>SELECT</span> * </code></pre>
<p><strong>Before index explain analyze</strong></p>
<pre><code>Seq Scan on weather  (cost=0.00..9402.36 rows=2586 width=853) (actual time=0.007..67.365 rows=2896 loops=1)
Execution Time: 67.499 ms
</code></pre>
<p><strong>Multi-column Index for severity and type</strong></p>
<pre><code><span>CREATE INDEX</span> idx_storm_crop ON weather(event_type,damage_crops);</code></pre>
<p>After Index Explain Analyze</p>
<pre><code>Bitmap Index Scan on idx_storm_crop  (cost=0.00..38.15 rows=2586 width=0) (actual time=0.339..0.339 rows=2896 loops=1)
Execution Time: 2.204 ms</code></pre>
<p>Reduction in query time again, yay!</p>
<p>Oh …. And if you get lost with all your creating indexes and need to see what you’ve got, this will show you all indexes on a particular table:</p>
<pre><code><span>SELECT</span> indexname, indexdef </code></pre>
<p><code>Drop index indexname</code> will delete it if you want to test again. </p>
<h2>BRIN Index Sample</h2>
<p>BRIN is often very helpful when using large datasets and specifically something with time series or time stamped data. I used a sample from an IoT dataset<a href="#fn2" rel="noopener"><sup>2</sup></a> for this with thousands of data rows per day. </p>
<p>Starting query</p>
<pre><code><span>SELECT</span> device, humidity </code></pre>
<p>Explain Analyze before</p>
<pre><code>Parallel Seq Scan on iot  (cost=0.00..10363.95 rows=896 width=28) (actual time=12.710..42.080 rows=16707 loops=3)
Execution Time: 67.851 ms</code></pre>
<p>Index</p>
<pre><code><span>CREATE INDEX</span> iot_time ON iot USING brin(ts);</code></pre>
<p>Explain Analyze after</p>
<pre><code>Bitmap Index Scan on iot_time  (cost=0.00..12.26 rows=54025 width=0) (actual time=0.046..0.047 rows=10240 loops=1)
Execution Time: 10.513 ms</code></pre>
<p>You will often hear that BRIN indexes are very space efficient. So as you&#39;re working through indexes, you might want to query the size of the actual index. For example:</p>
<pre><code>pg_size_pretty(pg_relation_size(&#39;iot_time&#39;));</code></pre>
<h2>Basic Spatial Index with GIST</h2>
<p>If you’re using spatial data in your database, you probably have a lot of data and indexing can be crucial. For spatial indexing I used data and examples from the <a href="https://postgis.net/workshops/postgis-intro/" rel="noopener" target="_blank">PostGIS tutorial</a><a href="#fn3" rel="noopener"><sup>3</sup></a>. If you’re just starting to work with spatial data, I highly recommend this tutorial in general. </p>
<p><strong>SQL query</strong></p>
<pre><code><span>SELECT</span> count(blocks.blkid)
<span>FROM</span> nyc_census_blocks blocks
<span>JOIN</span> nyc_subway_stations subways
<span>ON</span> ST_Contains(blocks.geom, subways.geom)
 <span>WHERE</span> subways.name <span>LIKE</span> &#39;B%&#39;;</code></pre>
<p><strong>Beginning explain analyze</strong></p>
<pre><code>Timing: Generation 4.364 ms, Inlining 360.628 ms, Optimization 615.663 ms, Emission 559.573 ms, Total 1540.227 ms
Execution Time: 1467.916 ms</code></pre>
<p>Sample spatial GIST index</p>
<pre><code><span>CREATE INDEX</span> nyc_census_blocks_geom_idx
  ON nyc_census_blocks
  USING GIST (geom);</code></pre>
<p><strong>After indexing explain analyze</strong></p>
<pre><code>Execution Time: 7.575 ms</code></pre>
<p>Wowza! You see what I mean? Spatial indexes can have a huge impact. </p>
<h2>GIN Index For JSON</h2>
<p>JSON data has quite a wide adoption for Postgres users and the Postgres core project has embraced the adoption of the <a href="https://blog.crunchydata.com/blog/better-json-in-postgres-with-postgresql-14" rel="noopener" target="_blank"><span>JSON data types with extensive features</span></a>. There’s some indexing types that can really help if you’ve got data that’s listing several objects inside each field. The GIN index type is commonly used for this. For this example I used a json file from NASA that has meteor location information<a href="#fn4" rel="noopener"><sup>4</sup></a>. </p>
<p><strong>SQL query</strong></p>
<pre><code><span>SELECT</span> data -&gt; &#39;name&#39; as name </code></pre>
<p><strong>Explain analyze before indexing</strong></p>
<pre><code>Parallel Seq Scan on meteors  (cost=0.00..23926.28 rows=4245 width=32) (actual time=0.065..114.114 rows=1024 loops=3)
Execution Time: 123.698 ms</code></pre>
<p><strong>Index </strong></p>
<pre><code><span>CREATE INDE</span>X gin_test ON meteors USING gin(data)</code></pre>
<p><strong>Explain analyze after indexing</strong></p>
<pre><code>Bitmap Index Scan on gin_test  (cost=0.00..116.40 rows=10187 width=0) (actual time=12.164..12.164 rows=3072 loops=1)
Execution Time: 22.017 ms</code></pre>
<h2>Finding the Right Fit With Indexes</h2>
<p>You shouldn&#39;t create an index on the fly as you&#39;re about to run a one-off query. A good index plan requires planning and testing. Indexes are stored on disk and so they also take up space so that’s a consideration as well. For each new data row inserted or existing data row updated, index entries are updated automatically by the database. Indexes can absolutely also have an impact on the performance of database write operations, so be sure to research some of that. Just like <a href="https://blog.crunchydata.com/blog/author/craig-kerstiens" rel="noopener" target="_blank">Craig</a> said recently, everyone needs to find their <a href="https://blog.crunchydata.com/blog/five-tips-for-a-healthier-postgres-database-in-the-new-year" rel="noopener" target="_blank"><span>Goldilocks of indexes:</span></a> not too big, not too small but just right. </p>
<p><strong>Footnotes:</strong></p>
<a id="fn1" data-hs-anchor="true"></a>
<p><span>1 B-Tree Index Data Sample. <a href="https://www.ncei.noaa.gov/pub/data/swdi/stormevents/csvfiles/">https://www.ncei.noaa.gov/pub/data/swdi/stormevents/csvfiles/</a></span><span>, file StormEvents_details-ftp_v1.0_d2011_c20220107.csv.gz</span><span>. </span></p>
<a id="fn2" data-hs-anchor="true"></a>
<p><span></span><span>2 BRIN Index Data Sample. <a href="https://www.kaggle.com/garystafford/environmental-sensor-data-132k">https://www.kaggle.com/garystafford/environmental-sensor-data-132k</a></span></p>
<a id="fn3" data-hs-anchor="true"></a>
<p><span></span><span>3 PostGIS Data Sample. </span><span><a href="http://s3.cleverelephant.ca/postgis-workshop-2020.zip">http://s3.cleverelephant.ca/postgis-workshop-2020.zip</a>.</span></p>
<a id="fn4" data-hs-anchor="true"></a>
<p><span>4 JSON Data Sample. </span><span><a href="https://data.nasa.gov/resource/y77d-th95.json">https://data.nasa.gov/resource/y77d-th95.json. </a></span></p>
</span>
      
    </p>
    
  </div>
</div></div>

</div><!--end row-->
</div></div>
  </body>
</html>
