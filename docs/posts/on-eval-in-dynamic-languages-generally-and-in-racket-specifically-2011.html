<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.racket-lang.org/2011/10/on-eval-in-dynamic-languages-generally.html">Original</a>
    <h1>On eval in dynamic languages generally and in Racket specifically (2011)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <header>
  
  </header>

<p><em>posted by Matthew Flatt</em></p>

<p>The <code>eval</code> function is at the heart of a dynamic language, and it strikes many newcomers as an amazingly powerful tool. At the same time, experienced programmers avoid <code>eval</code>, because unnecessary use creates trouble. It’s not easy to explain why <code>eval</code> should be avoided or when it&#34;s appropriate to use <code>eval</code>, but I’ll take another stab at it here.</p>

<h2 id="what-is-eval">What is <code>eval</code>?</h2>

<p>Consider the following “program” in English prose:</p>

<blockquote>
 <p>Assume that your favorite color is red. Now imagine a balloon that is  your favorite color. Paint a canvas the same color as the balloon.</p></blockquote>

<p>As English goes, that’s a fairly clear program with a fairly well-defined result. When I follow those instructions, at least, I will always produce a red canvas (assuming that I have a canvas and some red paint, but a potential lack of art supplies is not the point here).</p>

<p>I would come up with a red canvas even if I read the instructions when surrounded by people who speak only Chinese, obviously, since I’m the one reading the instructions. Furthermore, it would be straightforward to translate the program to Chinese, and then a person who reads Chinese would produce a red canvas.</p>

<p>A translator might even take the liberty of simplifying the program to just</p>

<blockquote>
 <p>Paint a canvas red.</p></blockquote>

<p>The translation loses some of the poetry of the original, but the result is the same.</p>

<p>In Racket terms, the paragraph corresponds to a module. It can be compiled (i.e., translated) and optimized (i.e., simplified). A program can be made up of multiple modules that are written in different languages, but since each module can be reliably translated, they can all be compiled into some common language to run the program.</p>

<p>Here’s a different program:</p>

<blockquote>
 <p>Tell the person next to you “Assume that your favorite color is red.” Tell the person “Now, imagine a balloon that is your favorite color.” Tell the person “Paint canvas the same color as the balloon.”</p></blockquote>

<p>Getting a red canvas back may be a little trickier in this case. If the person next to me speaks only Chinese, then my program may fail with a message-not-understood error.</p>

<p>If I want to translate the program to Chinese, then it’s not clear whether the parts in quotes should be translated. Maybe I mean for a person who can read Chinese but only sound out English to run the program when surrounded by English speakers, or maybe I mean for a Chinese person to run the program when surrounded by Chinese people. Either way, I have to be a lot more specific to a translator. For more complex programs, the instructions to the translator can become complex and fragile.</p>

<p>Finally, a translator probably won’t feel comfortable simplifying the program to</p>

<blockquote>
 <p>Tell the person next to you “Paint a canvas red.”</p></blockquote>

<p>because there could be all sorts of environmental conditions that make the result different—such as people who are willing to paint but unwilling to accept assumptions about their favorite colors.</p>

<p>The paragraph with “tell the person…” is a program that uses <code>eval</code>. It can’t be compiled and optimized as well as the earlier paragraph, and the language context in which it is run may change the result. The quotes around sentences correspond to the quote in front of an expression passed to <code>eval</code> in Racket; there’s no particular reason that the language for <code>eval</code> will match the language of the program that has the quoted text. The issues become even more complex if you try to implement different parts of the program in different languages.</p>

<p>If the analogy to multiple spoken languages seems strange—maybe your language is Javascript, period—the problem of translation to another language is really a proxy for program understanding. There’s a direct connection to performance and optimization (i.e., translation to efficient machine code), but using <code>eval</code> also makes a program more difficult to understand for the same reasons that it makes the program more difficult to translate. For example, a reader of your program may not be able to tell whether “assume your favorite color is red” is just a rhetorical device to get to a red canvas or whether some new instructions will arrive that will ask for your favorite color.</p>

<h2 id="when-is-eval-good">When is <code>eval</code> Good?</h2>

<p>The program with “tell the person next to you” above uses <code>eval</code> in a bad way. The task could just as well be performed by the person reading the instructions, instead of getting another nearby person involved.</p>

<p>Some other uses <code>eval</code> are both good and necessary. For example, consider the following program:</p>

<blockquote>
 <p>Ask the construction manager for instructions. Walk to the building  site and convey those instructions to the construction crew.</p></blockquote>

<p>This program uses <code>eval</code> when it conveys instructions to the construction crew, but no quoted forms appear in the program. The absence of quoted code is one sign that <code>eval</code> may be appropriate. Note that the program could work no matter what language the manager and crew speak, although there is an implicit (and sometimes non-trivial) assumption that the manager and crew speak the same language.</p>

<p>Here’s another example:</p>

<blockquote>
 <p>Go outside, and tell each member of the construction crew “take a  lunch break, now.”</p></blockquote>

<p>There’s a quoted program in this case, but it’s crucial to ask other people to run the quoted program, instead of just taking the lunch break yourself. That is, <code>eval</code> is really necessary. The implementor of this program takes on the burden of making sure that the instructions are in a suitable language, however, and may need to parameterize the quoted program by an explicit action to translate it to a language understood by the construction crew.</p>

<p>Here’s one more reasonable example:</p>

<blockquote>
 <p>Ask the construction manager for instructions. Follow them.</p></blockquote>

<p>In this case, it’s the construction manager’s problem to give you instructions in a language that you understand.</p>

<p>Here’s a questionable example:</p>

<blockquote>
 <p>Decide how long to work before lunch, say N hours, and write a note  to yourself to work N hours. Add to the note by telling yourself to  take a lunch break afterward.</p></blockquote>

<p>If you could really write that program without quotes, then it’s probably ok. The example is misleading, though, because languages don’t usually support</p>

<blockquote>
 <p>write a note to yourself to work N hours</p></blockquote>

<p>You’d have to write instead</p>

<blockquote>
 <p>write a note to yourself that says “work” followed by the number N  and then “hours”</p></blockquote>

<p>and the quote marks are where the problem comes in. If you translate the program to Chinese, then you have to be careful to somehow translate “work” and “hours” to Chinese, too.</p>

<p>The point here is not that programs without quoted text are clearly good or that programs with quoted text are clearly bad. The real point is that a programmer has to be especially careful about passing around instructions and using quoted instructions. Using <code>eval</code> means accepting the burden of using instructions will make sense by the time they are delivered. That burdened is best avoided, which is why experienced programmers avoid <code>eval</code>, but some of the examples illustrate cases where the burden is not avoidable or where the actions enabled by <code>eval</code> make the burden worthwhile.</p>

<h2 id="using-eval-in-racket">Using <code>eval</code> in Racket</h2>

<p>In the context of Racket, the multiple-language analogy is relatively accurate, because Racket is about having many programming languages work together and allowing programmers to define ever better languages and language constructs. In Racket, it’s especially likely that a library written in one language is used in a context where another language is the default.</p>

<p>Newcomers to Racket sometimes stumble over the fact that</p>



<p>or even</p>

<div>
 <div>
  <pre><span></span><span> </span><span>#lang </span><span>racket</span><span></span>
<span> </span><span>(</span><span><a href="http://docs.racket-lang.org/reference/eval.html#(def._((quote._~23~25kernel)._eval))">eval</a></span><span> </span><span>&#39;</span><span>(</span><span><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))">+</a></span><span> </span><span>1</span><span> </span><span>2</span><span>))</span><span></span>
</pre></div>

</div>

<p>does not work at all, and yet if the program</p>



<p>is loaded into a read-eval-print loop—for example, by clicking the “Run” button in DrRacket and then typing into the lower interactions panel—then</p>



<p>works as expected.</p>

<p>DrRacket’s interactions window has to use <code>eval</code> in the sense that it reads an expression to evaluate and then passes it on to the interpreter for an answer. More generally, to make various pieces of the environment fit together, DrRacket sets <code>eval</code> globally to use the module’s language while evaluating expressions in the interactions window. In Racket terminology, DrRacket sets the <code>current-namespace</code> parameter to the module’s namespace when it initializes the interactions window. In contrast, while the module body is being evaluated, <code>eval</code> treats expressions as being in the language that is empty by default, which is why <code>eval</code> during the module evaluation produces a different result from <code>eval</code> during the interactions windows.</p>

<p>You may wonder why DrRacket doesn’t initialize the namespace of <code>eval</code> to be the module’s namespace from the start, so that in-module uses of <code>eval</code> and the interactions window behave the same. In a program that is implemented by multiple modules, which module’s language should be used? In particular, if the language it’s always the main module’s language, then a module may behave differently on its own than as part of a larger program. In the process of developing Racket and DrRacket, we’ve seen many such problems, and so Racket now arranges for the default language to be empty (which is different from any useful language) to help programmers remember that there’s a language issue to consider whenever <code>eval</code> is used.</p>

<p>The Racket Guide’s chapter 15 covers in more depth the issues and namespace tools of Racket for harnessing the power of <code>eval</code>:</p>

<p> <a href="http://docs.racket-lang.org/guide/reflection.html">http://docs.racket-lang.org/guide/reflection.html</a></p>

<p>Think of <code>eval</code> as a power tool. For some tasks, there’s no real substitute, and so we want <code>eval</code> around. At the same time, <code>eval</code> should be used with care. In dynamic languages generally, that means a reluctant and targeted use <code>eval</code>. In Racket specifically, it means knowing the namespace toolbox and being as explicit as possible about the intended context for dynamic evaluation.</p>
<!-- more-->

<hr/>

<p>Coming from a security analysis background, I appreciate the arguments about analyzability.</p>

<p>You might be interested in my related response to “What do you wish language designers paid attention to?”. The bit excerpted below touches on the same points — quoting confusion is hard, eval can be bounded, the environment in which the evaled code should be run is often not the environment in which eval is invoked.</p>

<p>&#34;&#34;&#34;</p>

<p>Please make your language analyzable/auditable for computer security people.</p>

<p>…</p>

<p>Limit the authority of embedded scripting languages</p>

<p>A lot of useful systems are organized as a static core that kicks off a lot of code written in dynamic (even functional) languages.</p>

<p>And embedding scripting languages can make a system much more extensible.</p>

<p>But a scripting language shouldn’t have the full authority of the VM.</p>

<p>If you choose to allow embedded scripting languages, make it easy for the invoker to limit what they can do. An object-capabilities model (see comment on Newspeak above) is very appropriate here ; so when evaluating code in a scripting language, the caller should pass in the code to execute and all the global variables for that code.</p>

<p>Treat eval as a language embedding itself as a scripting language</p>

<p>If your language can invoke its own compiler to turn a string into code, then allow it to be sandboxed the same as you would any embedded scripting language.</p>

<p>…</p>

<p>Don’t encourage quoting confusion</p>

<p>&#34;&#34;&#34;</p>

<p>cheers</p>

<p>— <em>Mike Samuel, 19 October 2011</em></p>

<hr/>

<p>Typo:</p>

<p>I think there’s a problem with the following sentence:</p>

<p>Using eval means accepting the burden of using instructions will make sense by the time they are delivered</p>

<p>Perhaps the word “that” between “instructions” and “will”?</p>

<p>— <em>Hendrik Boom, 27 April 2014</em></p>

<hr/>
<col-2>

</col-2></div></div>
  </body>
</html>
