<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://compcert.org/compcert-C.html">Original</a>
    <h1>The CompCert C Compiler</h1>
    
    <div id="readability-page-1" class="page"><div id="mainbar">





<p>CompCert C is a compiler for the C programming language.  Its intended
use is the compilation of life-critical and mission-critical software
written in C and meeting high levels of assurance.  It accepts
most of the ISO C 99 language, with some exceptions
and a few extensions.  It produces machine code for the PowerPC,
ARM, RISC-V and x86 (32 and 64 bits) architectures.  Performance of the
generated code is decent but not outstanding: on PowerPC, about 90%
of the performance of GCC version 4 at optimization level 1.</p>

<p>What sets CompCert C apart from any other production compiler, is that
it is <em>formally verified</em>, using machine-assisted mathematical
proofs, to be exempt from <em>miscompilation</em> issues.  In other
words, the executable code it produces is proved to behave exactly as
specified by the semantics of the source C program.  This level of
confidence in the correctness of the compilation process is
unprecedented and contributes to meeting the highest levels of
software assurance.  In particular, using the CompCert C compiler is a
natural complement to applying formal verification techniques (static
analysis, program proof, model checking) at the source code level: the
correctness proof of CompCert C guarantees that all safety properties
verified on the source code automatically hold as well for the generated
executable.</p>

<h2><a name="subset"></a>The subset of C supported</h2>

<p>CompCert C supports all of ISO C 99, with the following exceptions:</p>
<ul>
<li>
By default, <code>switch</code> statements must be structured as in MISRA-C.
Support for unstructured <code>switch</code>, as in Duff&#39;s device, can
be activated via the command-line
option <code>-funstructured-switch</code>.
</li><li> <code>longjmp</code> and <code>setjmp</code> are not guaranteed to work.
</li><li> Variable-length arrays are not supported.
</li></ul>

<p>Consequently, CompCert supports all of the MISRA-C 2004 subset of C,
plus many features excluded by MISRA (such as recursive functions and
dynamic heap memory allocation).</p>

<p>A number of ISO C 2011 features are also supported:</p>
<ul>
<li> The <code>_Alignof</code> operator and the <code>_Alignas</code>
attribute.
</li><li> Anonymous structures and unions.
</li><li> <code>_Static_assert</code> statements and <code>_Generic</code> expressions.
</li><li> Unicode string literals and character constants.
</li></ul>

<p>CompCert also supports some extensions to ISO C taken from the GNU and Diab compilers:
</p><ul>
<li> Pragmas and attributes to control alignment and section
  placement of global variables.
</li><li> Attributes to control struct packing, function inlining, etc.
</li><li> Built-in functions to give access to some processor-specific instructions.
</li><li> Inline assembly code with GNU-style arguments.
</li></ul>

<h2><a name="archi"></a>Architecture of the compiler</h2>

<p><strong>Part 1: Parsing, type-checking, and pre-simplifications.</strong>
This first part converts C source code into abstract syntax trees of the CompCert C language.  Some constructs not natively supported by CompCert C are expanded away.  For example, block-scoped local variables are renamed and lifted to function-local scope; and unstructured <code>switch</code> statements are rewritten to structured <code>switch</code> statements with <code>goto</code> statements.  Some other unsupported constructs, such as variable-length arrays, are rejected.</p>

<p>This part of CompCert (transformation of C source text to CompCert C
abstract syntax trees) is not formally verified.  However, CompCert C is a
subset of C, and the compiler can output the generated
CompCert C code in C concrete syntax (flag <code>-dc</code>),
therefore the result of this transformation can be manually inspected.
Moreover, most static analysis and program verification tools for C
operate on a simplified C language similar to CompCert C.  By conducting
the analysis or the program verification directly on the CompCert C form,
bugs potentially introduced by this first part of the compiler can be
detected.</p>

<p><strong>Part 2: Compilation of CompCert C AST to assembly AST.</strong>
This part is the bulk of the compiler and the one that is proved
correct in Coq.  It is structured in 16 passes and uses 10 intermediate
language, as depicted on the following diagram.</p>

<p><img src="https://compcert.org/passes.png" alt="CompCert compiler passes"/></p><p>All intermediate languages are given formal semantics, and each of the
transformation passes is proved to preserve semantics.</p>

<p><strong>Part 3: Assembling and linking.</strong>
The abstract syntax tree for PowerPC or ARM or RISC-V or x86 assembly language
produced by part 2 is printed in concrete assembly syntax.  The
system&#39;s assembler and linker are then called to produce object files
and executable files, respectively.  This part is not yet formally
verified.  A benefit of using the standard assembler and linker is
that object files produced by CompCert can be linked with existing
libraries compiled with <code>gcc</code>.  This is convenient for
testing, although the formal guarantees of semantic preservation apply
only to whole programs that have been compiled as a whole by CompCert
C.</p>

<h2><a name="usage"></a>Using the compiler</h2>

<p>The executable for CompCert C is called <code>ccomp</code>.
It has the standard command-line interface for a Unix C compiler.  
For instance, to compile the single-file program <code>src.c</code>
and create an executable called <code>exec</code>, just do</p>
<pre>       ccomp -o exec src.c
</pre>
<p>To compile a two-file program <code>src1.c</code> and <code>src2.c</code>, do</p>
<pre>       ccomp -c src1.c
       ccomp -c src2.c
       ccomp -o exec src1.o src2.o
</pre>
<p>To see the CompCert C code and the assembly code generated for
<code>src1.c</code>, do</p>
<pre>       ccomp -dc -S src1.c
</pre>
<p>The generated assembly code is left in file <code>src1.s</code>
and the generated CompCert C code in file <code>src1.compcert.c</code>.
</p>

<p>For more details, see the <a href="https://compcert.org/man/">CompCert C user&#39;s manual</a>.</p>

<h2><a name="perfs"></a>Performance of the generated code</h2>

<p>On PowerPC and ARM, the code generated by CompCert runs at least twice
as fast as the code generated by GCC without optimizations 
(<code>gcc -O0</code>), and approximately 10% slower than GCC 4 at optimization
level 1 (<code>gcc -O1</code>), 15% slower at optimization level 2 
(<code>gcc -O2</code>) and 20% slower at optimization level 3 (<code>gcc -O3 </code>).  These numbers were obtained on the homemade benchmark mix shown in
the graph below.  By lack of aggressive loop optimizations,
performance is lower on HPC codes involving lots of matrix
computations.</p>

<p><img src="https://compcert.org/man/manual002.png" alt="CompCert benchmark results"/></p><p>
(The sources for the test programs are available in the
<code>test/c</code> subdirectory of the CompCert distribution.
Measurements were done on an IBM Power7 running Linux.)</p>
 
</div></div>
  </body>
</html>
