<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fitzgeraldnick.com/2019/11/01/always-bump-downwards.html">Original</a>
    <h1>Always Bump Downwards (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>When writing a bump allocator, always bump downwards. That is, allocate from
high addresses, down towards lower addresses by decrementing the bump
pointer. Although it is perhaps less natural to think about, it is more
efficient than incrementing the bump pointer and allocating from lower addresses
up to higher ones.</p>

<h3 id="what-is-bump-allocation">What is Bump Allocation?</h3>

<p>Bump allocation is a super fast method for allocating objects. We have a chunk
of memory, and we maintain a “bump pointer” within that memory. Whenever we
allocate an object, we do a quick test that we have enough capacity left in the
chunk, and then, assuming we have enough room, we move the bump pointer over by
<code>sizeof(object)</code> bytes and return the pointer to the space we just reserved for
the object within the chunk.</p>

<p>That’s it!</p>

<p>Here is some pseudo-code showing off the algorithm:</p>

<figure><pre><code data-lang="js"><span>bump</span><span>(</span><span>size</span><span>):</span>
    <span>if</span> <span>our</span> <span>capacity</span> <span>&lt;</span> <span>size</span><span>:</span>
        <span>fail</span>
    <span>else</span>
        <span>self</span><span>.</span><span>ptr</span> <span>=</span> <span>move</span> <span>self</span><span>.</span><span>ptr</span> <span>over</span> <span>by</span> <span>size</span> <span>bytes</span>
        <span>return</span> <span>pointer</span> <span>to</span> <span>the</span> <span>freshly</span> <span>allocated</span> <span>space</span></code></pre></figure>

<p>The trade off with bump allocation is that we can’t deallocate individual
objects in the general case. We can deallocate all of them en mass by resetting
the bump pointer back to its initial location. We can deallocate in a LIFO,
stack order by moving the bump pointer in reverse. But we can’t deallocate an
arbitrary object in the middle of the chunk and reclaim its space for new
allocations.</p>

<p>Finally, notice that the chunk of memory we are bump allocating within is always
split in two: the side holding allocated objects and the side with free
memory. The bump pointer separates the two sides. Furthermore, note that I
haven’t defined which side of the bump pointer is free or allocated space, and
I’ve carefully avoided saying whether the bump pointer is incremented or
decremented.</p>

<h3 id="bumping-upwards">Bumping Upwards</h3>

<p>First, let’s consider what we <em>shouldn’t</em> do: bump upwards by initializing the
bump pointer at the low end of our memory chunk and incrementing the bump
pointer on each allocation.</p>

<p>We begin with a <code>struct</code> that holds the start and end addresses of our chunk of
memory, as well as our current bump pointer:</p>

<figure><pre><code data-lang="rust"><span>pub</span> <span>struct</span> <span>BumpUp</span> <span>{</span>
    <span>// A pointer to the first byte of our memory chunk.</span>
    <span>start</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
    <span>// A pointer to the last byte of our memory chunk.</span>
    <span>end</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
    <span>// The bump pointer. At all times, we maintain the</span>
    <span>// invariant that `start &lt;= ptr &lt;= end`.</span>
    <span>ptr</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
<span>}</span></code></pre></figure>

<p>Constructing our upwards bump allocator requires giving it the <code>start</code> and <code>end</code>
pointers, and it will initialize its bump pointer to the <code>start</code> address:</p>

<figure><pre><code data-lang="rust"><span>impl</span> <span>BumpUp</span> <span>{</span>
    <span>pub</span> <span>unsafe</span> <span>fn</span> <span>new</span><span>(</span>
        <span>start</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
        <span>end</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
    <span>)</span> <span>-&gt;</span> <span>BumpUp</span> <span>{</span>
        <span>assert!</span><span>(</span><span>start</span> <span>as</span> <span>usize</span> <span>&lt;=</span> <span>end</span> <span>as</span> <span>usize</span><span>);</span>
        <span>let</span> <span>ptr</span> <span>=</span> <span>start</span><span>;</span>
        <span>BumpUp</span> <span>{</span> <span>start</span><span>,</span> <span>end</span><span>,</span> <span>ptr</span> <span>}</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>To allocate an object, we will begin by grabbing the current bump pointer, and
saving it in a temporary variable: this is going to be the pointer to the newly
allocated space. Then we increment the bump pointer by the requested size, and
check if it is still less than <code>end</code>. If so, then we have capacity for the
allocation, and can commit the new bump pointer to <code>self.ptr</code> and return the
temporary pointing to the freshly allocated space.</p>

<p>But first, there is one thing that the pseudo-code ignored, but which a real
implementation cannot: alignment. We need to round up the initial bump pointer
to a multiple of the requested alignment before we compute the new bump pointer
by adding the requested size.</p>

<p>Put all that together, and it looks like this:</p>

<figure><pre><code data-lang="rust"><span>impl</span> <span>BumpUp</span> <span>{</span>
    <span>pub</span> <span>unsafe</span> <span>fn</span> <span>alloc</span><span>(</span>
        <span>&amp;</span><span>mut</span> <span>self</span><span>,</span>
        <span>size</span><span>:</span> <span>usize</span><span>,</span>
        <span>align</span><span>:</span> <span>usize</span><span>,</span>
    <span>)</span> <span>-&gt;</span> <span>*</span><span>mut</span> <span>u8</span> <span>{</span>
        <span>debug_assert!</span><span>(</span><span>align</span> <span>&gt;</span> <span>0</span><span>);</span>
        <span>debug_assert!</span><span>(</span><span>align</span><span>.is_power_of_two</span><span>());</span>

        <span>let</span> <span>ptr</span> <span>=</span> <span>self</span><span>.ptr</span> <span>as</span> <span>usize</span><span>;</span>

        <span>// Round the bump pointer up to the requested</span>
        <span>// alignment. See the footnote for details.</span>
        <span>let</span> <span>aligned</span> <span>=</span> <span>(</span><span>ptr</span> <span>+</span> <span>align</span> <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> <span>!</span><span>(</span><span>align</span> <span>-</span> <span>1</span><span>);</span>

        <span>let</span> <span>new_ptr</span> <span>=</span> <span>aligned</span> <span>+</span> <span>size</span><span>;</span>

        <span>let</span> <span>end</span> <span>=</span> <span>self</span><span>.end</span> <span>as</span> <span>usize</span><span>;</span>
        <span>if</span> <span>new_ptr</span> <span>&gt;</span> <span>end</span> <span>{</span>
            <span>// Didn&#39;t have enough capacity!</span>
            <span>return</span> <span>std</span><span>::</span><span>ptr</span><span>::</span><span>null_mut</span><span>();</span>
        <span>}</span>

        <span>self</span><span>.ptr</span> <span>=</span> <span>new_ptr</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>;</span>
        <span>aligned</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>If we compile this allocation routine to x86-64 with optimizations, we get the
following code, which I’ve lightly annotated:</p>

<figure><pre><code data-lang="nasm"><span>; Incoming arguments:</span>
<span>;   * `rdi`: pointer to `BumpUp`</span>
<span>;   * `rsi`: The allocation&#39;s `size`</span>
<span>;   * `rdx`: The allocation&#39;s `align`</span>
<span>; Outgoing result:</span>
<span>;   * `rax`: the pointer to the allocation or null</span>
<span>alloc_up:</span>
    <span>mov</span> <span>rax</span><span>,</span> <span>rdx</span>
    <span>mov</span> <span>rcx</span><span>,</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x10</span><span>]</span>
    <span>add</span> <span>rcx</span><span>,</span> <span>rdx</span>
    <span>add</span> <span>rcx</span><span>,</span> <span>0xffffffffffffffff</span>
    <span>neg</span> <span>rax</span>
    <span>and</span> <span>rax</span><span>,</span> <span>rcx</span>
    <span>add</span> <span>rsi</span><span>,</span> <span>rax</span>
    <span>cmp</span> <span>rsi</span><span>,</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x8</span><span>]</span>
    <span>ja</span>  <span>.return_null</span>
    <span>mov</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x10</span><span>],</span> <span>rsi</span>
    <span>ret</span>

<span>.return_null:</span>
    <span>xor</span> <span>eax</span><span>,</span> <span>eax</span>
    <span>ret</span></code></pre></figure>

<p>I’m not going to explain each individual instruction. What’s important to
appreciate here is that this is just a small handful of fast instructions with
only a single branch to handle the not-enough-capacity case. This is what makes
bump allocation so fast — great!</p>

<p>But before we get too excited, there is another practicality to consider: to
maintain memory safety, we must handle potential integer overflows in the
allocation procedure, or else we could have bugs where we return pointers
outside the bounds of our memory chunk. No good!</p>

<p>There are two opportunities for overflow we must take care of:</p>

<ol>
  <li>
    <p>If the requested allocation’s size is large enough, <code>aligned + size</code> can
overflow.</p>
  </li>
  <li>
    <p>If the requested allocation’s alignment is large enough, the <code>ptr + align -
1</code> sub-expression we use when rounding up to the alignment can overflow.</p>
  </li>
</ol>

<p>To handle both these cases, we will use checked addition and return a null
pointer if either addition overflows. Here is the new Rust source code:</p>

<figure><pre><code data-lang="rust"><span>// Try and unwrap an `Option`, returning a null pointer</span>
<span>// if the option is `None`.</span>
<span>macro_rules!</span> <span>try_null</span> <span>{</span>
    <span>(</span> <span>$e:expr</span> <span>)</span> <span>=&gt;</span> <span>{</span>
        <span>match</span> <span>$e</span> <span>{</span>
            <span>None</span> <span>=&gt;</span> <span>return</span> <span>std</span><span>::</span><span>ptr</span><span>::</span><span>null_mut</span><span>(),</span>
            <span>Some</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>e</span><span>,</span>
        <span>}</span>
    <span>};</span>
<span>}</span>

<span>impl</span> <span>BumpUp</span> <span>{</span>
    <span>pub</span> <span>unsafe</span> <span>fn</span> <span>alloc</span><span>(</span>
        <span>&amp;</span><span>mut</span> <span>self</span><span>,</span>
        <span>size</span><span>:</span> <span>usize</span><span>,</span>
        <span>align</span><span>:</span> <span>usize</span><span>,</span>
    <span>)</span> <span>-&gt;</span> <span>*</span><span>mut</span> <span>u8</span> <span>{</span>
        <span>debug_assert!</span><span>(</span><span>align</span> <span>&gt;</span> <span>0</span><span>);</span>
        <span>debug_assert!</span><span>(</span><span>align</span><span>.is_power_of_two</span><span>());</span>

        <span>let</span> <span>ptr</span> <span>=</span> <span>self</span><span>.ptr</span> <span>as</span> <span>usize</span><span>;</span>

        <span>// Round the bump pointer up to the requested</span>
        <span>// alignment.</span>
        <span>let</span> <span>aligned</span> <span>=</span>
            <span>try_null!</span><span>(</span><span>ptr</span><span>.checked_add</span><span>(</span><span>align</span> <span>-</span> <span>1</span><span>))</span> <span>&amp;</span> <span>!</span><span>(</span><span>align</span> <span>-</span> <span>1</span><span>);</span>

        <span>let</span> <span>new_ptr</span> <span>=</span> <span>try_null!</span><span>(</span><span>aligned</span><span>.checked_add</span><span>(</span><span>size</span><span>));</span>

        <span>let</span> <span>end</span> <span>=</span> <span>self</span><span>.end</span> <span>as</span> <span>usize</span><span>;</span>
        <span>if</span> <span>new_ptr</span> <span>&gt;</span> <span>end</span> <span>{</span>
            <span>// Didn&#39;t have enough capacity!</span>
            <span>return</span> <span>std</span><span>::</span><span>ptr</span><span>::</span><span>null_mut</span><span>();</span>
        <span>}</span>

        <span>self</span><span>.ptr</span> <span>=</span> <span>new_ptr</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>;</span>
        <span>aligned</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>Now that we’re handling overflows in addition to the alignment requirements,
let’s take a look at the x86-64 code that <code>rustc</code> and LLVM produce for the
function now:</p>

<figure><pre><code data-lang="nasm"><span>; Incoming arguments:</span>
<span>;   * `rdi`: pointer to `BumpUp`</span>
<span>;   * `rsi`: The allocation&#39;s `size`</span>
<span>;   * `rdx`: The allocation&#39;s `align`</span>
<span>; Outgoing result:</span>
<span>;   * `rax`: the pointer to the allocation or null</span>
<span>alloc_up:</span>
    <span>lea</span> <span>rax</span><span>,</span> <span>[</span><span>rdx</span><span>-</span><span>0x1</span><span>]</span>
    <span>add</span> <span>rax</span><span>,</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x10</span><span>]</span>
    <span>jb</span>  <span>.return_null</span>
    <span>neg</span> <span>rdx</span>
    <span>and</span> <span>rax</span><span>,</span> <span>rdx</span>
    <span>add</span> <span>rsi</span><span>,</span> <span>rax</span>
    <span>jb</span>  <span>.return_null</span>
    <span>cmp</span> <span>rsi</span><span>,</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x8</span><span>]</span>
    <span>ja</span>  <span>.return_null</span>
    <span>mov</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x10</span><span>],</span> <span>rsi</span>
    <span>ret</span>

<span>.return_null:</span>
    <span>xor</span> <span>eax</span><span>,</span> <span>eax</span>
    <span>ret</span></code></pre></figure>

<p>Now there are three conditional branches rather than one. The two new branches
are from those two new overflow checks that we added. Less than ideal.</p>

<p>Can bumping downwards do better?</p>

<h3 id="bumping-downwards">Bumping Downwards</h3>

<p>Now let’s implement a bump allocator where the bump pointer is initialized at
the end of the memory chunk and is decremented on allocation, so that it moves
downwards towards the start of the memory chunk.</p>

<p>The <code>struct</code> is identical to the previous version:</p>

<figure><pre><code data-lang="rust"><span>#[repr(C)]</span>
<span>pub</span> <span>struct</span> <span>BumpDown</span> <span>{</span>
    <span>// A pointer to the first byte of our memory chunk.</span>
    <span>start</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
    <span>// A pointer to the last byte of our memory chunk.</span>
    <span>end</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
    <span>// The bump pointer. At all times, we have the</span>
    <span>// invariant that `start &lt;= ptr &lt;= end`.</span>
    <span>ptr</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
<span>}</span></code></pre></figure>

<p>Constructing a <code>BumpDown</code> is similar to constructing a <code>BumpUp</code> except we
initialize the <code>ptr</code> to <code>end</code> rather than <code>start</code>:</p>

<figure><pre><code data-lang="rust"><span>impl</span> <span>BumpDown</span> <span>{</span>
    <span>pub</span> <span>unsafe</span> <span>fn</span> <span>new</span><span>(</span><span>start</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span> <span>end</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>)</span> <span>-&gt;</span> <span>BumpDown</span> <span>{</span>
        <span>assert!</span><span>(</span><span>start</span> <span>as</span> <span>usize</span> <span>&lt;=</span> <span>end</span> <span>as</span> <span>usize</span><span>);</span>
        <span>let</span> <span>ptr</span> <span>=</span> <span>end</span><span>;</span>
        <span>BumpDown</span> <span>{</span> <span>start</span><span>,</span> <span>end</span><span>,</span> <span>ptr</span> <span>}</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>When we were allocating by incrementing the bump pointer, the original bump
pointer value before it was incremented pointed at the space that was about to
be reserved for the allocation. When we are allocating by decrementing the bump
pointer, the original bump pointer is pointing at either the end of the memory
chunk, or at the last allocation we made. What we want to return is the value of
the bump pointer <em>after</em> we decrement it down, at which time it will be pointing
at our allocated space.</p>

<p>First we subtract the allocation size from the bump pointer. This subtraction
might overflow, so we check for that and return a null pointer if that is the
case, just like we did in the previous, upward-bumping function. Then, we round
that down to the nearest multiple of <code>align</code> to ensure that the allocated space
has the object’s alignment. At this point, we check if we are down past the
start of our memory chunk, in which case we don’t have the capacity to fulfill
this allocation, and we return null. Otherwise, we update the bump pointer to
its new value and return the pointer!</p>

<figure><pre><code data-lang="rust"><span>impl</span> <span>BumpDown</span> <span>{</span>
    <span>pub</span> <span>unsafe</span> <span>fn</span> <span>alloc</span><span>(</span>
        <span>&amp;</span><span>mut</span> <span>self</span><span>,</span>
        <span>size</span><span>:</span> <span>usize</span><span>,</span>
        <span>align</span><span>:</span> <span>usize</span><span>,</span>
    <span>)</span> <span>-&gt;</span> <span>*</span><span>mut</span> <span>u8</span> <span>{</span>
        <span>debug_assert!</span><span>(</span><span>align</span> <span>&gt;</span> <span>0</span><span>);</span>
        <span>debug_assert!</span><span>(</span><span>align</span><span>.is_power_of_two</span><span>());</span>

        <span>let</span> <span>ptr</span> <span>=</span> <span>self</span><span>.ptr</span> <span>as</span> <span>usize</span><span>;</span>

        <span>let</span> <span>new_ptr</span> <span>=</span> <span>try_null!</span><span>(</span><span>ptr</span><span>.checked_sub</span><span>(</span><span>size</span><span>));</span>

        <span>// Round down to the requested alignment.</span>
        <span>let</span> <span>new_ptr</span> <span>=</span> <span>new_ptr</span> <span>&amp;</span> <span>!</span><span>(</span><span>align</span> <span>-</span> <span>1</span><span>);</span>

        <span>let</span> <span>start</span> <span>=</span> <span>self</span><span>.start</span> <span>as</span> <span>usize</span><span>;</span>
        <span>if</span> <span>new_ptr</span> <span>&lt;</span> <span>start</span> <span>{</span>
            <span>// Didn&#39;t have enough capacity!</span>
            <span>return</span> <span>std</span><span>::</span><span>ptr</span><span>::</span><span>null_mut</span><span>();</span>
        <span>}</span>

        <span>self</span><span>.ptr</span> <span>=</span> <span>new_ptr</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>;</span>
        <span>self</span><span>.ptr</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>And here is the x86-64 code generated for this downward-bumping allocation
routine!</p>

<figure><pre><code data-lang="nasm"><span>; Incoming arguments:</span>
<span>;   * `rdi`: pointer to `BumpDown`</span>
<span>;   * `rsi`: The allocation&#39;s `size`</span>
<span>;   * `rdx`: The allocation&#39;s `align`</span>
<span>; Outgoing result:</span>
<span>;   * `rax`: the pointer to the allocation or null</span>
<span>alloc_down:</span>
    <span>mov</span> <span>rax</span><span>,</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x10</span><span>]</span>
    <span>sub</span> <span>rax</span><span>,</span> <span>rsi</span>
    <span>jb</span>  <span>.return_null</span>
    <span>neg</span> <span>rdx</span>
    <span>and</span> <span>rax</span><span>,</span> <span>rdx</span>
    <span>cmp</span> <span>rax</span><span>,</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>]</span>
    <span>jb</span>  <span>.return_null</span>
    <span>mov</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rdi</span><span>+</span><span>0x10</span><span>],</span> <span>rax</span>
    <span>ret</span>

<span>.return_null:</span>
    <span>xor</span> <span>eax</span><span>,</span> <span>eax</span>
    <span>ret</span></code></pre></figure>

<p>Because rounding down doesn’t require an addition or subtraction operation, it
doesn’t have an associated overflow check. That means one less conditional
branch in the generated code, and downward bumping only has two conditional
branches versus the three that upward bumping has.</p>

<p>Additionally, because we don’t need to save the original bump pointer value,
this version uses fewer registers than the upward-bumping version. Bump
allocation functions are designed to be fast paths that are inlined into
callers, which means that downward bumping is creating less register pressure at
every call site.</p>

<p>Finally, this downwards-bumping version is implemented with eleven instructions,
while the upwards-bumping version requires thirteen instructions. In general,
fewer instructions implies a shorter run time.</p>

<h3 id="benchmarks">Benchmarks</h3>

<p>I recently switched <a href="https://github.com/fitzgen/bumpalo">the <code>bumpalo</code> crate</a> from bumping upwards to
bumping downwards. It has a nice, little micro-benchmark suite that is written
with the excellent, statistics-driven <a href="https://github.com/bheisler/criterion.rs">Criterion.rs benchmarking
framework</a>. With Criterion’s built-in support for defining a baseline
measurement and comparing an alternate implementation of the code against it, I
compared the new, downwards-bumping implementation against the original,
upwards-bumping implementation.</p>

<p>The new, downwards-bumping implementation has <strong>up to 19% better allocation
throughput</strong> than the original, upwards-bumping implementation! We’re down to
2.7 nanoseconds per allocation.</p>

<p>The plot below shows the probability of allocating 10,000 small objects taking a
certain amount of time. The red curve represents the old, upwards-bumping
implementation, while the blue curve shows the new, downwards-bumping
implementation. The lines represent the mean time.</p>





<p>You can view the complete, nitty-gritty benchmark results <a href="https://github.com/fitzgen/bumpalo/pull/37">in the pull
request</a>.</p>

<h4 id="the-one-downside-losing-a-realloc-fast-path">The One Downside: Losing a <code>realloc</code> Fast Path</h4>

<p><code>bumpalo</code> doesn’t only provide an allocation method, it also provides a
<code>realloc</code> method to resize an existing allocation. <code>realloc</code> is <em>O(n)</em> because
in the worst-case scenario it needs to allocate a whole new region of memory and
copy the data from the old to the new region. But the old, upwards-bumping
implementation had a fast path for growing the last allocation: it would add the
delta size to the bump pointer, leaving the allocation in place and avoiding
that copy. The new, downwards-bumping implementation also has a fast path for
resizing the last allocation , but even if we reuse that space, the start of the
allocated region of memory has shifted, and so we can’t avoid the data copy.</p>

<p>The loss of that fast path leads to a 4% slow down in our <code>realloc</code> benchmark
that formats a string into a bump-allocated buffer, triggering a number of
<code>realloc</code>s as the string is constructed. We felt that this was worth the trade
off for faster allocation.</p>

<h3 id="less-work-with-more-alignment">Less Work with More Alignment?</h3>

<p>It is rare for types to require more than word alignment. We could enforce a
minimum alignment on the bump pointer at all times that is greater than or equal
to the vast majority of our allocations’ alignment requirements. If our
allocation routine is monomorphized for the type of the allocation it’s making,
or it is aggressively inlined — and it definitely should be — then
we should be able to completely avoid generating any code to align the bump
pointer in most cases, including the conditional branch on overflow if we are
rounding up for upwards bumping.</p>

<figure><pre><code data-lang="rust"><span>impl</span> <span>BumpDown</span> <span>{</span>
    <span>pub</span> <span>unsafe</span> <span>fn</span> <span>alloc</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>*</span><span>mut</span> <span>MaybeUninit</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>ptr</span> <span>=</span> <span>self</span><span>.ptr</span> <span>as</span> <span>usize</span><span>;</span>

        <span>// Ensure we always always keep the bump pointer</span>
        <span>// `MIN_ALIGN`-aligned by rounding the size up. This</span>
        <span>// should be boiled away into a constant by the compiler</span>
        <span>// after monomorphization.</span>
        <span>let</span> <span>size</span> <span>=</span>
            <span>(</span><span>size_of</span><span>::</span><span>&lt;</span><span>T</span><span>&gt;</span><span>()</span> <span>+</span> <span>MIN_ALIGN</span> <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> <span>!</span><span>(</span><span>MIN_ALIGN</span> <span>-</span> <span>1</span><span>);</span>

        <span>let</span> <span>new_ptr</span> <span>=</span> <span>try_null!</span><span>(</span><span>ptr</span><span>.checked_sub</span><span>(</span><span>size</span><span>));</span>

        <span>// If necessary, round down to the requested alignment.</span>
        <span>// Again, this `if`/`else` should be boiled away by the</span>
        <span>// compiler after monomorphization.</span>
        <span>let</span> <span>new_ptr</span> <span>=</span> <span>if</span> <span>align_of</span><span>::</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>&gt;</span> <span>MIN_ALIGN</span> <span>{</span>
            <span>new_ptr</span> <span>&amp;</span> <span>!</span><span>(</span><span>align_of</span><span>::</span><span>&lt;</span><span>T</span><span>&gt;</span><span>()</span> <span>-</span> <span>1</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>new_ptr</span>
        <span>};</span>

        <span>let</span> <span>start</span> <span>=</span> <span>self</span><span>.start</span> <span>as</span> <span>usize</span><span>;</span>
        <span>if</span> <span>new_ptr</span> <span>&lt;</span> <span>start</span> <span>{</span>
            <span>// Didn&#39;t have enough capacity!</span>
            <span>return</span> <span>std</span><span>::</span><span>ptr</span><span>::</span><span>null_mut</span><span>();</span>
        <span>}</span>

        <span>self</span><span>.ptr</span> <span>=</span> <span>new_ptr</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>;</span>
        <span>self</span><span>.ptr</span> <span>as</span> <span>*</span><span>mut</span> <span>_</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>The trade off is extra memory overhead from introducing wasted space between
small allocations that don’t require that extra alignment.</p>

<h3 id="conclusion">Conclusion</h3>

<p>If you are writing your own bump allocator, you should bump downwards:
initialize the bump pointer to the end of the chunk of memory you are allocating
from within, and decrement it on each allocation so that it moves down towards
the start of the memory chunk. Downwards bumping requires fewer registers, fewer
instructions, and fewer conditional branches. Ultimately, that makes it faster
than bumping upwards.</p>

<p>The one exception is if, for some reason, you frequently use <code>realloc</code> to grow
the last allocation you made, in which case you <em>might</em> get more out of a fast
path for growing the last allocation in place without copying any data. And if
you do decide to bump upwards, then you should strongly consider enforcing a
minimum alignment on the bump pointer to recover some of the performance that
you’re otherwise leaving on the table.</p>

<p>Finally, I’d like to thank <a href="https://www.red-bean.com/~jimb/">Jim Blandy</a>, <a href="https://github.com/alexcrichton">Alex
Crichton</a>, <a href="https://jeenalee.com/">Jeena Lee</a>,
and <a href="https://jorendorff.blogspot.com/">Jason Orendorff</a> for reading an early
draft of this blog post, for discussing these ideas with me, and for being
super friends :)</p>

<hr/>

<p><small> The simple way to round <code>n</code> up to a multiple of
<code>align</code> is</small></p>

<pre><small><code>(n + align - 1) / align * align</code></small></pre>

<p><small>Consider the numerator: <code>n + align - 1</code>. This is ensuring that if there
is any remainder for <code>n / align</code>, then the result of the division sub-expression
is one greater than <code>n / align</code>, and that otherwise we get exactly the same
result as <code>n / align</code> due to integer division rounding off the remainder. In
other words, we only round up if <code>n</code> is not aligned to <code>align</code>.</small></p>

<p><small>However, we know <code>align</code> is a power of two, and therefore <code>anything /
align</code> is equivalent to <code>anything &gt;&gt; log2(align)</code> and <code>anything * align</code> is
equivalent to <code>anything &lt;&lt; log2(align)</code>. We can therefore rewrite our expression
into:</small></p>

<pre><small><code>(n + align - 1) &gt;&gt; log2(align) &lt;&lt; log2(align)</code></small></pre>

<p><small>But shifting a value right by some number of bits <code>b</code> and then shifting
it left by that same number of bits <code>b</code> is equivalent to clearing the bottom <code>b</code>
bits of the number. We can clear the bottom <code>b</code> bits of a number by bit-wise
and’ing the number with the bit-wise not of <code>2^b - 1</code>.  Plugging this into our
equation and simplifying, we get:</small></p>

<pre><small><code>  (n + align - 1) &gt;&gt; log2(align) &lt;&lt; log2(align)
= (n + align - 1) &amp; !(2^log2(align) - 1)
= (n + align - 1) &amp; !(align - 1)</code></small></pre>

<p><small>And now we have our final version of rounding up to a multiple of a power
of two!</small></p>

<p><small>If you find these bit twiddling hacks fun, definitely find yourself a
copy of <a href="https://www.goodreads.com/book/show/276079.Hacker_s_Delight">Hacker’s
Delight</a>. It’s a
wonderful book! <a href="#back-foot-0">↩</a></small></p>


  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
