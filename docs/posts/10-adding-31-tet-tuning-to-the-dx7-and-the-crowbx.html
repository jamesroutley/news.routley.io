<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0010-microtuning-dx7-crowbx/">Original</a>
    <h1>10. Adding 31-tet tuning to the DX7 and the CrowBX</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2023-11-28</p>

<p>Most modern Western music uses the <a href="https://en.wikipedia.org/wiki/12_equal_temperament">12-tone equal temperament</a> tuning system. My curiosity about different tunings was recently rekindled by two things. (1) I read in interviews that Aphex Twin likes using microtunings. (2) I was playing my Prophet 10, which needs quite some time to warm up and get in tune after you turn it on, and I liked how it sounded while still out of tune.</p>

<p>The Prophet 10 has a nice selection of built in alternate tuning tables so once it was warmed up it allowed me to try different ones. I decided I&#39;m drawn to equal temperament tunings because they should save me the hassle of defining a new tuning table for each piece of music I write (assuming I end up using alternate tunings sometimes). The equal temperament offerings in the Prophet 10 are 12-tet (i.e. standard tuning), 19-tet, 24-tet and 31-tet. I liked <a href="https://en.wikipedia.org/wiki/31_equal_temperament">31-tet</a> the best.</p>

<p>I don&#39;t see myself writing entire pieces in an alternate tuning. But I wonder if it will work to combine 12-tet monophonic parts, if necessary with pitch bend adjustments per note, with some 31-tet polyphonic parts. It would be nice if I have more synths with 31-tet tuning.</p>

<p>I use a DX7 and I already knew it has a &#34;microtuning&#34; feature. It does not include 31-tet among its built-in tables but it lets you upload custom tables. It seems that <a href="https://huygens-fokker.org/scala/">Scala</a> is a popular tool for defining alternate tunings but it felt better to me to create the tables myself.</p>

<details><summary>Here is a C program that generates 31-tet tables for the DX7.</summary>

<pre>/* 31tet.c */

#include &lt;stdarg.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

char progname[] = &#34;31tet&#34;;
char msg[266 + 6 + 2];

void fatal(char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(1);
}

void fail_usage(void) {
  fatal(&#34;Usage: %s [-d DEVICE_NUMBER] [-t TRANSPOSE_SEMITONES] [-s &#34;
        &#34;MICRO_TUNING_SLOT]\n&#34;,
        progname);
}

int main(int argc, char **argv) {
  int data, i, message_size = sizeof(msg) - 6 - 2;
  int ch, transpose = 0, device_number = 0, slot = 0;
  uint8_t checksum;
  enum { lowest = 938, notes = 31, octave = 1024, max = 10794 };

  while ((ch = getopt(argc, argv, &#34;d:t:s:&#34;)) != -1) {
    switch (ch) {
    case &#39;d&#39;:
      device_number = atoi(optarg);
      if (device_number &gt;&gt; 4)
        fatal(&#34;error: invalid device number: %d\n&#34;, device_number);
      break;
    case &#39;t&#39;:
      transpose = atoi(optarg);
      break;
    case &#39;s&#39;:
      slot = atoi(optarg);
      if (slot &lt; 0 || slot &gt; 1)
        fatal(&#34;error: invalid slot number: %d\n&#34;, slot);
      break;
    default:
      fail_usage();
      break;
    }
  }

  if (optind != argc)
    fail_usage();

  snprintf(msg, 6 + 1, &#34;\xf0\x43%c\x7e%c%c&#34;, device_number, message_size &gt;&gt; 7,
           message_size &amp; 0x7f);
  snprintf(msg + 6, 10 + 1, &#34;LM  MCRYM%c&#34;, slot);

  for (i = 0; i &lt; 128; i++) {
    data = (i / notes) * octave + (i % notes) * (octave / notes) + lowest +
           (((float)transpose / 12.0) * (float)octave);
    if (data &gt; max)
      data = max;
    msg[16 + 2 * i] = data &gt;&gt; 7;
    msg[16 + 2 * i + 1] = data &amp; 0x7f;
  }

  checksum = 0;
  for (i = 6; i &lt; sizeof(msg) - 2; i++)
    checksum += msg[i];
  msg[sizeof(msg) - 2] = (0x80 - checksum) &amp; 0x7f;

  msg[sizeof(msg) - 1] = 0xf7;

  fwrite(msg, 1, sizeof(msg), stdout);
  return 0;
}
</pre>

</details>

<p>Writing the DX7 31-tet generator was straightforward once I figured out that the synth splits the octave in 1024 equal steps. Because 1024 does not divide by 31 I &#34;resynchronize&#34; every octave: the first 30 notes are 33 steps apart and the 31rd note is 34 steps above the 30th. Repeat for each octave. You can only fit 4 octaves of 31-tet notes into the 128-note MIDI keyboard and all my controller keyboards are only 61 notes wide, which is just under 2 octaves. To make this playable I added a transpose function to the table generator.</p>

<p>The CrowBX used to have a different octave scale factor for each voice because each of the 8 pitch CV outputs has a slightly different scale value, probably due to resistor and opamp tolerances. But looking at the number I decided it&#39;s not worth making the distinction: the octave values ranged from 8380 to 8383. I think the error introduced by assuming the octave is 8381.5 across all values is less than the natural instability of the analog circuits that respond to the pitch CV.</p>

<p>I refactored the firmware to use a singe scale across all 8 voices. The pitch CV DAC has 16-bit accuracy so for 128 voices I need <code>128*2=256</code> bytes to store a tuning table. This is no problem on the microcontroller I&#39;m using (AtMega328P). If I need to squeeze space at some point I can probably calculate them using fewer bytes of instructions because the tables are so regular. In the end I made a generator program <code>gen_scale.c</code> that gets called by <code>make</code> to create <code>scale.h</code> which contains the actual tables. I don&#39;t store <code>scale.h</code> itself in Git because it can be generated quickly at build time.</p>

<p>The changes for the CrowBX are in this <a href="https://gitlab.com/jacobvosmaer/crowbx/-/compare/62ee76b7b732423215e8608683c0e82c6ef7b6cb...d0a3df45da08d06d34f812397ec6a090aa2d3dbc?from_project_id=6223968&amp;straight=false">commit series</a>.</p>
<p>Tags:
<a href="https://blog.jacobvosmaer.nl/music.html">music</a>
<a href="https://blog.jacobvosmaer.nl/crowbx.html">crowbx</a>
<a href="https://blog.jacobvosmaer.nl/dx7.html">dx7</a>
</p><p>Revisions:</p><table>
<tbody><tr><td>2023-12-08</td><td></td><td>Remove embedded dates in favor of meta.json</td></tr>
<tr><td>2023-12-08</td><td></td><td>Add dates to header</td></tr>
<tr><td>2023-12-07</td><td></td><td>Add atom.xml</td></tr>
<tr><td>2023-12-07</td><td></td><td>0010: add tag</td></tr>
<tr><td>2023-11-28</td><td></td><td>Add 0011 crowbx</td></tr>
<tr><td>2023-11-28</td><td></td><td>Add 0010</td></tr>
</tbody></table><a href="https://blog.jacobvosmaer.nl/">Back</a>
</div></div>
  </body>
</html>
