<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/954018/">Original</a>
    <h1>Modern C for Fedora (and the World)</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>

<div>
<center>
           <div><b>This article brought to you by LWN subscribers</b><p>Subscribers to LWN.net made this article — and everything that
       surrounds it — possible.  If you appreciate our content, please
       <a href="https://lwn.net/subscribe/">buy a subscription</a> and make the next
       set of articles possible.</p></div>
           </center>
           <p>
It can be instructive to pull down the dog-eared copy of the first edition
of <i>The C Programming Language</i> that many of us still have on our
bookshelves; the language has changed considerably since that book was
published.  Many &#34;features&#34; of early C have been left behind, usually for
good reasons, but there is still a lot of code in the wild that is still
using those features.  A concerted effort is being made in both the Fedora
and GCC communities to fix that old code and enable some new errors in the
GCC 14 release (which is <a href="https://lwn.net/ml/gcc/nycvar.YFH.7.77.849.2311200815190.8772@jbgna.fhfr.qr/">in
stage 3</a> of its development cycle and likely to be released by
mid-2024), but a fair amount of work remains to be done.
</p><p>
There are a number of constructs that were normal in 1980s C, but
which are seen as a breeding ground for bugs now.  These include:
</p><ul>
<li> <b>Implicit function declarations</b>: if code calls <tt>function()</tt>
     without having first included a declaration for that function, the
     compiler implicitly declares it as taking no parameters and returning
     an <tt>int</tt> value.  That may not be how the function is actually
     defined, opening up possibilities for all kinds of confusion.
</li><li> <b>Implicit integer declarations</b>: a variable declared with just a
     storage class (<tt>static</tt>, for example) is implicitly deemed to
     be an <tt>int</tt>.  C++ has already adopted type inference, where the
     compiler figures out what the appropriate type for the variable should
     be from how it is used, in this case.  There are <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2953.htm">schemes</a>
     afoot to add a similar feature to C, but type inference is
     incompatible with implicit <tt>int</tt>.
</li><li> <b>Conversions between pointers and integers</b>: original C played
     fast and loose with pointer values, allowing them to be converted to
     and from <tt>int</tt> values at will.  Whether such constructions
     actually work on current architectures (where a pointer is likely to
     be 64 bits and an <tt>int</tt> 32 bits) is a matter of
     chance.
</li><li> <b>Inconsistent <tt>return</tt> statements</b>: old-style C paid little
     attention to whether a function returned a value or not; a function
     declared <tt>int</tt> could do a bare <tt>return</tt> (or just fall
     off the end with no <tt>return</tt> statement at all), and
     <tt>void</tt> functions could attempt to return a value without
     complaint.  Good things will not happen if a function fails to return
     a value that the caller is expecting.
</li><li> <b>Missing parameter types in function definitions</b>: C would accept such
     definitions, assigning no type to the parameter at all.  That means
     that typos in a function prototype (such as &#34;<tt>f(ant)</tt>&#34; instead
     of <tt>f(int)</tt>&#34;)can give surprising results.
</li><li> <b>Assignments between incompatible pointer types</b>: continuing in
     the &#34;fast and loose with pointers&#34; theme, early C had no objections to
     assigning a pointer value to an incompatible type without even a cast.
     Sometimes a developer writing such an assignment knew what they were
     doing; other times not.  </li></ul>
<p>
Current GCC versions will issue warnings for the above constructs, but will
proceed to compile the code anyway.  Florian Weimer, though, would like to
change that situation; at the end of November, he posted <a href="https://lwn.net/ml/gcc/87ttp3tek1.fsf@oldenburg.str.redhat.com/">an update</a> on
work toward turning the warnings for obsolete C constructs into hard errors
instead.  This would seem like a sensible thing to do; those constructs
have been deprecated for ages; they can hide bugs or prevent the adoption
of new language features and should not be appearing in modern code.

</p><p>
There is only one little problem: a lot of code in the free-software world
is not modern.  Simply turning all of those warnings into errors has the
potential to break the compilation of numerous packages — an outcome that
is not likely to be universally welcomed.  To address this problem, the
Fedora project has been working on a <a href="https://fedoraproject.org/wiki/Changes/PortingToModernC">&#34;porting to
modern C&#34; project</a> since at least late 2022.  The idea is to find the
packages in Fedora that fail to build with the new errors and fix them,
sending those fixes upstream whenever possible.  Once Fedora builds
correctly, chances are that the amount of old code that remains will be
relatively small.
</p><p>
Weimer has also <a href="https://lwn.net/ml/fedora-devel/87jzpztbfg.fsf@oldenburg.str.redhat.com/">posted an
update on the Fedora work</a>.  There are, it seems, still a number of
packages (out of about 15,000 tested) that generate errors indicating the
presence of old code:
</p><blockquote>
<table>
<tbody><tr><td>Implicit function definition</td><td>53</td></tr>
<tr><td>Implicit integer declaration</td><td>2</td></tr>
<tr><td>Integer conversion</td><td>99</td></tr>
<tr><td>Return mismatch</td><td>13</td></tr>
<tr><td>Missing parameter type</td><td>0</td></tr>
<tr><td>Pointer assignment</td><td>374</td></tr>
</tbody></table>
</blockquote>
<p>
While quite a bit of progress has been made toward the goal of building
Fedora with the new errors, Weimer points out that the job is not yet done:
</p><blockquote>
	As you can see, the incompatible-pointer-types issues are a bit of
	a problem.  We fixed over 800 packages during the first round, and
	now it looks like we are only two thirds done.
<p>
	It is unlikely that I will be able to work on all these issues
	myself or with help from the people around me.  I just suggested to
	GCC upstream that we may have to reconsider including this change
	in the GCC 14 release.
</p></blockquote>
<p>
Weimer included a separate column for programs that may be miscompiled
because <tt>autoconf</tt> may be confused by the new errors.  For example,
many of its checks don&#39;t bother to declare <tt>exit()</tt>; they will fail
to compile if the error for implicit function definitions is enabled,
causing <tt>autoconf</tt> to conclude that the feature it is checking for
is absent.  There are also seemingly problems with the <a href="https://vala.dev/">Vala language</a>, which compiles to
obsolete C.  Vala has not been under active development for some time
and is unlikely to be fixed.
</p><p>
The current plan is to continue this work, focusing mostly on the Fedora
Rawhide development distribution.  Efforts will be made to deal with the
<tt>autoconf</tt> problem and to put some sort of hack into Vala, but that
still leaves hundreds of packages needing further attention.  If they
cannot be fixed in time, it may not be possible to enable all of those
errors in the GCC 14 release.
</p><p>
Part of the problem, perhaps, is that it appears to have fallen on Fedora
and GCC developers to make these fixes.  In many cases, this may be the
result of the lack of a viable upstream for many packages; we are probably
all using more unmaintained code than we like to think.  At its best, this
work might shine a light on some of those packages and, in a truly
optimistic world, bring out developers who can pick up that maintenance and
modernize the code.  In many cases, it should be a relatively
straightforward task and a reasonable entry point into maintainership.
With enough help, perhaps we can finally leave archaic C code behind.<br clear="all"/></p><hr/><p>
           (<a href="https://lwn.net/Login/?target=/Articles/954018/">Log in</a> to post comments)
           </p></div> <!-- ArticleText -->






















</div> <!-- middlecolumn -->

</div></div>
  </body>
</html>
