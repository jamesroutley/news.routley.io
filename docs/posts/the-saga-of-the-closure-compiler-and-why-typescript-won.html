<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://effectivetypescript.com/2023/09/27/closure-compiler/">Original</a>
    <h1>The saga of the Closure compiler, and why TypeScript won</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><img src="https://effectivetypescript.com/images/240px-Closure_logo.svg.png" title="Closure Tools Logo" width="100" height="100"/>Here&#39;s something that makes me feel old: in just six months, Gmail will celebrate its 20th anniversary. If you weren&#39;t actively developing web sites at the time, it&#39;s hard to capture just how revolutionary it was. This was a time when JavaScript was held in almost universally low regard. The idea that you could build a sophisticated web app using it was mind-boggling. But it clearly worked and it heralded the dawn of the single-page web app (SPA).</p>
<p>Behind this application was an exciting new tool that Google had built for creating large JavaScript applications: the <a target="_blank" rel="noopener" href="https://github.com/google/closure-compiler" onclick="return trackOutboundLink(&#39;the saga of the closure compiler and why typescript won&#39;, &#39;https://github.com/google/closure-compiler&#39;, event);">Closure Tools</a> (that&#39;s Closure with an &#39;s&#39;, not Clojure with a &#39;j&#39;, which is a different thing). This included the <a target="_blank" rel="noopener" href="https://developers.google.com/closure/compiler/" onclick="return trackOutboundLink(&#39;the saga of the closure compiler and why typescript won&#39;, &#39;https://developers.google.com/closure/compiler/&#39;, event);">Closure Compiler</a> (CC), a JavaScript source-to-source compiler that did type checking. Sound familiar?</p>
<p>Unless you&#39;ve worked on frontend at Google at some point in the past 20 years, it&#39;s unlikely that you&#39;ve ever encountered the Closure Compiler. It occupied a similar niche to TypeScript, but TypeScript has absolutely, definitively won.</p>
<p>Still, it&#39;s interesting to revisit CC for a few reasons:</p>
<ol>
<li>By looking at a system that made different high-level design decisions than TypeScript, we can gain a deeper appreciation of TypeScript&#39;s design.</li>
<li>It shows us missing features from TypeScript that it might not have even occurred to us to want.</li>
<li>It&#39;s an interesting case study in the history of JavaScript.</li>
</ol>
<p>In other words, the saga of the Closure Compiler gives us some perspective. TypeScript has become so ubiquitous that it&#39;s sometimes hard to imagine any other way of adding a type checker to JavaScript. The Closure Compiler shows us that the design space was larger than it looks in retrospect.</p>
<p>I wrote Closure-style JavaScript at Google most heavily from 2012–14. This post reflects Closure as it existed at that point. I&#39;m much less familiar with how it&#39;s evolved since then.</p>
<h2 id="What-is-the-Closure-Compiler"><a href="#What-is-the-Closure-Compiler" title="What is the Closure Compiler?"></a>What is the Closure Compiler?</h2><p>TypeScript&#39;s motto is &#34;TypeScript is a superset of JavaScript&#34;. Closure code, on the other hand, <em>is</em> JavaScript. It doesn&#39;t add any new syntax to the language.</p>
<p>If you&#39;ve ever used <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#checkJs" onclick="return trackOutboundLink(&#39;what is the closure compiler&#39;, &#39;https://www.typescriptlang.org/tsconfig#checkJs&#39;, event);">TypeScript with <code>--checkJs</code></a>, it&#39;s a similar idea. Rather than adding types to JavaScript through new syntax, you add them via JSDoc-style comments.</p>
<p>Compare this TypeScript:</p>
<figure><div><pre><code><span><span>function</span> <span>max</span>(<span>a: <span>number</span>, b: <span>number</span></span>): <span>number</span> </span>{</code></pre></div></figure>

<p>to the equivalent Closurized JavaScript:</p>
<figure><div><pre><code></code></pre></div></figure>

<p>An invalid invocation of <code>max</code> will result in an error:</p>
<figure><div><pre><code>&gt; google-closure-compiler &#34;--warning_level&#34; &#34;VERBOSE&#34; &#34;max.js&#34;</code></pre></div></figure>

<p>This is similar to what <code>tsc</code> does in some ways but different in others. Just like <code>tsc</code>, it reports type errors in your code. And just like <code>tsc</code>, it outputs JavaScript (the last line). At a high level, type checking and JS emit are also the two things that TypeScript does.</p>
<p>There are some interesting differences, too. The Closure Compiler reports that our code is &#34;100.0% typed&#34;. Using TypeScript terminology, this is a measure of how many <code>any</code> types you have. (<a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink(&#39;what is the closure compiler&#39;, &#39;https://amzn.to/3HIrQN6&#39;, event);"><em>Effective TypeScript</em></a> discusses using the <a target="_blank" rel="noopener" href="https://github.com/plantain-00/type-coverage" onclick="return trackOutboundLink(&#39;what is the closure compiler&#39;, &#39;https://github.com/plantain-00/type-coverage&#39;, event);">type-coverage</a> tool to get this information in Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety.)</p>
<p>The other interesting difference is that the output is minified. This gets us the fundamental design goal of the Closure Compiler: producing the smallest JavaScript possible.</p>
<h2 id="Minification-as-Design-Goal"><a href="#Minification-as-Design-Goal" title="Minification as Design Goal"></a>Minification as Design Goal</h2><p>When Gmail came out back in 2004, network speeds were much, much slower than they are today. The Gmail team found that runtime JavaScript performance was almost irrelevant compared to download times. If you wanted to make your page load faster, you needed to make your JavaScript bundle smaller. So this is the central goal of the Closure Compiler and its &#34;advanced optimizations&#34; mode.</p>
<p>To see how this works, let&#39;s look at some code to fetch and process data from the network.</p>
<p>Here&#39;s an &#34;externs&#34; file (the CC equivalent of a type declarations file) that defines a type and declares a function:</p>
<figure><div><pre><code></code></pre></div></figure>

<p>Some interesting things to note here:</p>
<ul>
<li>Types are introduced via <code>@typedef</code> in a JSDoc comment. The <code>APIResponse</code> symbol exists at runtime but is not particularly useful. Just because CC is JavaScript doesn&#39;t mean that the JavaScript always makes sense.</li>
<li>The declaration of <code>fetchData</code> includes an empty implementation. TypeScript would use <code>declare function</code> here, but this is not JS syntax. So CC uses an empty function body.</li>
</ul>
<p>Here&#39;s some more code that fetches data and processes it:</p>
<figure><div><pre><code></code></pre></div></figure>

<p>Because it&#39;s just JavaScript, this code can be executed directly, presumably via a <code>&lt;script&gt;</code> tag (CC predates Node.js). No build step is required and your iteration cycle is very tight.</p>
<p>Let&#39;s look at what happens when you compile this:</p>
<figure><div><pre><code>&gt; google-closure-compiler &#34;--warning_level&#34; &#34;VERBOSE&#34; &#34;--externs&#34; &#34;api-externs.js&#34; &#34;api.js&#34;</code></pre></div></figure>

<p>Here&#39;s what that looks like when we unminify it:</p>
<figure><div><pre><code><span>let</span> ProcessedData;</code></pre></div></figure>

<p>Just like TypeScript, compilation here mostly consists of stripping out type information (in this case JSDoc comments).</p>
<p>Now look at what happens when we turn on &#34;advanced optimizations&#34;:</p>
<figure><div><pre><code>&gt; google-closure-compiler &#34;--compilation_level&#34; &#34;ADVANCED&#34; &#34;--warning_level&#34; &#34;VERBOSE&#34; &#34;--externs&#34; &#34;api-externs.js&#34; &#34;api.js&#34;</code></pre></div></figure>

<p>The output is <em>much</em> shorter. Here&#39;s what it looks like unminified:</p>
<figure><div><pre><code><span>var</span> a, b = fetchData();</code></pre></div></figure>

<p>This is a radical transformation of our original code. In addition to mangling our variable names (<code>apiData</code> became <code>b</code>, <code>processedData</code> became <code>a</code>), the Closure Compiler has mangled property names on <code>ProcessedData</code> (<code>longPropertyName</code>→<code>h</code>, <code>anotherLongName</code>→<code>g</code>) and inlined the call to <code>processData</code>, which let it remove that function entirely.</p>
<p>The results are dramatic. Whereas the minified code with simple optimizations was 231 bytes, the code with advanced optimizations is only 62 bytes!</p>
<p>Notice that CC has preserved some symbols: the <code>fetchData</code> function and the <code>foo</code> and <code>bar</code> property names. The rule is that symbols in an &#34;externs&#34; file are externally visible and cannot be changed, whereas the symbols elsewhere are internal and can be mangled or inlined as CC sees fit.</p>
<p>This is fundamentally unlike anything that TypeScript does. TypeScript does not rename symbols when it emits JavaScript nor does it attempt to minify your code. Even if you run your generated JavaScript through a minifier, it won&#39;t do anything nearly this radical. It&#39;s hard (or impossible) for a minifier to know which symbols or property names are part of an external API. So mangling property names is generally unsafe. You&#39;re unlikely to get anything smaller than the 231 byte &#34;simple optimizations&#34; output with TypeScript.</p>
<p>These results generally hold up well after gzip compression, and in larger projects as well. I <a target="_blank" rel="noopener" href="https://github.com/danvk/dygraphs/pull/267" onclick="return trackOutboundLink(&#39;minification as design goal&#39;, &#39;https://github.com/danvk/dygraphs/pull/267&#39;, event);">ported a JavaScript library to Closure</a> in 2013 and shrank my bundle by 40% vs. uglifyjs.</p>
<p>This is great stuff! So why didn&#39;t the Closure Compiler take off?</p>
<h2 id="The-Problems-with-Minification-as-a-Design-Goal"><a href="#The-Problems-with-Minification-as-a-Design-Goal" title="The Problems with Minification as a Design Goal"></a>The Problems with Minification as a Design Goal</h2><p>The externs file was critical to correct minification. Without it, CC would have mangled the <code>fetchData</code> function name and the <code>foo</code> and <code>bar</code> properties, too, which would have resulted in runtime errors. Omitting a symbol from an externs file would result in incorrect runtime behavior that could be extremely difficult to track down. In other words, this was a really bad developer experience (DX).</p>
<p>CC introduced some extralinguistic conventions to deal with this. For example, in JS (and TS) there&#39;s no distinction between using dot notation and square braces to access a property on an object:</p>
<figure><div><pre><code><span>const</span> a = obj.property;</code></pre></div></figure>

<p>This is not true with the Closure Compiler. Its convention is that quoted property access is preserved whereas dotted can be mangled. Here&#39;s how that code comes through the minifier with advanced optimizations:</p>
<figure><div><pre><code><span>console</span>.log(obj.g,obj.property);<br/></code></pre></div></figure>

<p>Note how the property names have diverged. In other words, while Closurized JavaScript is just JavaScript, it also kind of isn&#39;t.</p>
<p>There&#39;s another big problem with advanced optimizations: in order to consistently mangle a property name, CC needs to have access to all the source code that might use it. For this to be maximally effective, all the code you import must also be written with the Closure Compiler in mind, as must all the code that <em>that</em> code imports, etc.</p>
<p>In the context of npm in 2023, this would be impossible. In most projects, at least 90+% of the lines of code are third-party. For this style of minification to be effective, all of that code would have to be written with the Closure Compiler in mind and compiled by it as a unit.</p>
<p>On the other hand at Google in 2004, or 2012, or perhaps even today, that <em>is</em> quite realistic. At huge companies, the first- to third-party code ratio tends to be flipped. Using third-party code is more painful because there are legal and security concerns that come with it, as well as a loss of control. TypeScript&#39;s <a target="_blank" rel="noopener" href="https://yarnpkg.com/package?name=typescript&amp;file=%2Fpackage.json" onclick="return trackOutboundLink(&#39;the problems with minification as a design goal&#39;, &#39;https://yarnpkg.com/package?name=typescript&amp;file=%2Fpackage.json&#39;, event);">zero runtime dependencies</a> are a good example of this.</p>
<p>All of Google&#39;s JavaScript was written with the Closure Compiler in mind and the vast majority of it is first-party. So advanced optimizations works beautifully. But the rest of the JS world doesn&#39;t operate that way. As soon as you pull in any dependencies like React or Lodash that aren&#39;t written with Closure Compiler in mind, it starts to lose its value.</p>
<p>Contrast this with TypeScript. It only needs to know about the <em>types</em> of existing libraries. This is all that&#39;s needed for type checking. The DefinitelyTyped project has been a monumental undertaking but it does mean that, generally speaking, you can get TypeScript types for almost any JS library. (There&#39;s a similar, though much smaller, set of <a target="_blank" rel="noopener" href="https://github.com/google/closure-compiler/blob/929ba03a950b1dfcd60762f954e4833f433cc1d4/contrib/externs/jquery-1.12_and_2.2.js#L184" onclick="return trackOutboundLink(&#39;the problems with minification as a design goal&#39;, &#39;https://github.com/google/closure-compiler/blob/929ba03a950b1dfcd60762f954e4833f433cc1d4/contrib/externs/jquery-1.12_and_2.2.js#L184&#39;, event);">externs</a> to get type checking for popular JS libraries for the Closure Compiler.)</p>
<p>Stating it more directly: advanced optimizations requires that the compiler understand a library&#39;s implementation, not just its types, and that&#39;s simply infeasible given the enormous diversity of the JavaScript ecosystem.</p>
<!-- Mention my desire to use D3? -->

<h2 id="Timing-Is-Everything"><a href="#Timing-Is-Everything" title="Timing Is Everything"></a>Timing Is Everything</h2><p><img src="https://effectivetypescript.com/images/closure-definitive-guide.jpg" title="Cover of Closure: The Definitive Guide (2010)" width="133" height="174"/></p><p>Google developed Closure c. 2004 but it wasn&#39;t open sourced until <a target="_blank" rel="noopener" href="http://googlecode.blogspot.com/2009/11/introducing-closure-tools.html" onclick="return trackOutboundLink(&#39;timing is everything&#39;, &#39;http://googlecode.blogspot.com/2009/11/introducing-closure-tools.html&#39;, event);">late 2009</a>. An O&#39;Reilly book on it, <a target="_blank" rel="noopener" href="https://www.amazon.com/Closure-Definitive-Guide-Google-JavaScript/dp/1449381871" onclick="return trackOutboundLink(&#39;timing is everything&#39;, &#39;https://www.amazon.com/Closure-Definitive-Guide-Google-JavaScript/dp/1449381871&#39;, event);">Closure: The Definitive Guide</a>, came out in 2010.</p>
<p>In retrospect this timing was terrible. In 2010, JavaScript was just entering its period of maximum churn. <a target="_blank" rel="noopener" href="https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" onclick="return trackOutboundLink(&#39;timing is everything&#39;, &#39;https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742&#39;, event);"><em>JavaScript: The Good Parts</em></a> came out in 2008 and ES5 codified many of its recommendations in a new &#34;strict&#34; mode in 2009. Node.js was first released in 2009 and npm followed hot on its heels in 2010, creating the ecosystem of JavaScript packages we know today. npm grew significantly more powerful and useful when <a target="_blank" rel="noopener" href="https://browserify.org/" onclick="return trackOutboundLink(&#39;timing is everything&#39;, &#39;https://browserify.org/&#39;, event);">browserify</a> made it applicable to client-side code starting in 2011.</p>
<p>And finally, <a target="_blank" rel="noopener" href="https://coffeescript.org/" onclick="return trackOutboundLink(&#39;timing is everything&#39;, &#39;https://coffeescript.org/&#39;, event);">CoffeeScript</a> was released in 2010. It normalized the idea of compiling an &#34;improved&#34; JavaScript down to regular JavaScript, as well having a build step. All of these influenced the direction of JavaScript, with ES2015 bringing some of the best elements of CoffeeScript into the language itself.</p>
<p>The Closure Compiler was developed in the era when JavaScript was a &#34;bad&#34; language that was to be avoided. CC itself is implemented in Java, which made it harder to integrate into an all-JS toolchain. And it attempted to add missing parts to JavaScript. Since it couldn&#39;t add new syntax, it used special functions: <code>goog.provide</code> and <code>goog.require</code> provided a module system and <code>goog.inherits</code> <a target="_blank" rel="noopener" href="https://developers.google.com/closure/library/docs/introduction#oop" onclick="return trackOutboundLink(&#39;timing is everything&#39;, &#39;https://developers.google.com/closure/library/docs/introduction#oop&#39;, event);">smoothed out the process</a> of creating class hierarchies. These were real JavaScript functions that did something at runtime. If memory serves, <code>goog.require</code> might inject a <code>&lt;script&gt;</code> tag!</p>
<p>There were a few problems with this. One was that all the <code>goog</code> functions reinforced the idea that this was a tool primarily built for Google. Putting company names in your packages is common in Java, so presumably it felt natural for the Closure developers. But it&#39;s not in JavaScript. We just <code>import &#39;react&#39;</code>, not &#34;facebook/react&#34;.</p>
<p>Second, it made it awkward when JavaScript itself gained a module system and <code>class</code> keyword. TypeScript faced some of these problems in its early days, too. It used to have its own module system and class system, but in the interests of ecosystem coherence it deprecated them in favor of the native solutions. TypeScript now lets JavaScript be JavaScript and innovates only in the type system.</p>
<p>This transition happened early in TypeScript&#39;s history, but late in the Closure Compiler&#39;s. Presumably adaptation was harder.</p>
<h2 id="Why-TypeScript-won"><a href="#Why-TypeScript-won" title="Why TypeScript won"></a>Why TypeScript won</h2><p>TypeScript came along at a better time and has been able to adapt to the changes in JavaScript and its ecosystem over the past decade. It&#39;s self-hosted (<code>tsc</code> is written in TypeScript) and distributed with npm.</p>
<p>TypeScript also won by focusing more on developer tooling. The Closure Compiler is an offline system: you run a command, it checks your program for errors, then you edit and repeat. I&#39;m not aware of any standard Closure language service. There&#39;s no equivalent of inspecting a symbol in your editor to see what CC thinks its type is. TypeScript, on the other hand, places as much emphasis on <code>tsserver</code> as <code>tsc</code>. Especially with Visual Studio Code, which is written in TypeScript and came out in 2015, TypeScript is a joy to use. TypeScript uses types to make you more productive whereas Closure used them to point out your mistakes. No wonder developers preferred TypeScript!</p>
<p>(Google engineers are no exception to this. In the past decade they&#39;ve <a target="_blank" rel="noopener" href="https://neugierig.org/software/blog/2018/09/typescript-at-google.html" onclick="return trackOutboundLink(&#39;why typescript won&#39;, &#39;https://neugierig.org/software/blog/2018/09/typescript-at-google.html&#39;, event);">adopted TypeScript</a> and migrated to it en masse. You can read about one team&#39;s experience <a target="_blank" rel="noopener" href="https://developer.chrome.com/blog/migrating-to-typescript/" onclick="return trackOutboundLink(&#39;why typescript won&#39;, &#39;https://developer.chrome.com/blog/migrating-to-typescript/&#39;, event);">porting Chrome Devtools from Closure to TypeScript</a>).</p>
<p>TypeScript did a better job of engaging the JavaScript community. TypeScript is developed and planned in the open on GitHub. They respond to bug reports from anyone and treat non-Microsoft users as important customers. The Closure Tools, on the other hand, were very much an open source release of an internal Google tool. Google was always the primary consumer and external users were mostly on their own. The <code>goog</code> namespacing reinforced this.</p>
<p>Closure&#39;s idea of &#34;it&#39;s just JavaScript&#34; was appealing because it let you avoid a build step. This remains appealing in 2023: some TypeScript users still prefer to use JSDoc-style type annotations and <code>--checkJs</code>. But using JSDoc for all types is awkward and noisy. Ergonomics do matter and TypeScript&#39;s are undeniably better.</p>
<p>Finally, TypeScript&#39;s central idea of &#34;JavaScript + Types&#34; has held up better than the Closure Tools&#39; idea of &#34;minification&#34; and &#34;it&#39;s just JavaScript&#34;. While shaving bytes off your bundle was all the rage in 2008, our connections are much faster now and, while bundle size still matters, it is not as critical as it was back then. Closure forced a uniform system on you and all your dependencies in order to achieve extreme minification. We&#39;ve given up that goal in exchange for more flexibility.</p>
<p>There&#39;s a general principle here. I&#39;m reminded of Michael Feathers&#39;s 2009 blog post <a target="_blank" rel="noopener" href="https://michaelfeathers.silvrback.com/10-papers-every-developer-should-read-at-least-twice" onclick="return trackOutboundLink(&#39;why typescript won&#39;, &#39;https://michaelfeathers.silvrback.com/10-papers-every-developer-should-read-at-least-twice&#39;, event);">10 Papers Every Developer Should Read at Least Twice</a> which discusses D.L. Parnas&#39;s classic 1972 paper &#34;On the criteria to be used in decomposing systems into modules&#34;:</p>
<blockquote>
<p>Another thing I really like in the paper is his comment on the KWIC system which he used as an example. He mentioned that it would take a good programmer a week or two to code. Today, it would take practically no time at all. Thumbs up for improved skills and better tools. We have made progress.</p>
</blockquote>
<p>The KWIC system basically sorts a text file. So are we correct to laud our progress as software developers? This would be a one-liner today:</p>
<figure><div><pre><code><span>console</span>.log(</code></pre></div></figure>

<p>But think about what makes this possible:</p>
<ul>
<li>We&#39;re assuming that the entire file fits in memory, which almost certainly would not have been true in 1972.</li>
<li>We&#39;re using a garbage collected language, which would have been a rarity back then.</li>
<li>We have an enormous library at our fingertips via node built-ins and npm.</li>
<li>We have great text editors and operating systems.</li>
<li>We have the web and StackOverflow: no need to consult a reference manual!</li>
</ul>
<p>All of these things are thanks to advances in hardware. The hardware people give us extra transistors and the software people take most of those for ourselves to get a nicer development process. So it is with faster network speeds and the Closure Compiler. We&#39;ve taken back some of that bandwidth in exchange for a more flexible development process and ecosystem.</p>
<h2 id="Conclusions"><a href="#Conclusions" title="Conclusions"></a>Conclusions</h2><p>There were discussions of <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/8" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://github.com/microsoft/TypeScript/issues/8&#39;, event);">adding minification to TypeScript</a> in the early days but now optimized output is an explicit <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://github.com/microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals&#39;, event);">non-goal</a> for the language. If you&#39;ve ever thought that type-driven minification would be a beautiful thing, the Closure Compiler is a fascinating data point. It can be tremendously effective, but it also comes at an enormous cost to the ecosystem.</p>
<p>The Closure Compiler as a standalone external tool seems mostly dead (the <a target="_blank" rel="noopener" href="https://closure-compiler.appspot.com/home" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://closure-compiler.appspot.com/home&#39;, event);">closure playground</a> is badly broken and says &#34;Copyright 2009&#34;!). But it still lives on at Google. Since they&#39;ve adopted TypeScript, they can use the Closure Compiler for just what it does best: minification. To make this work, Google has built a tool, <a target="_blank" rel="noopener" href="https://github.com/angular/tsickle" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://github.com/angular/tsickle&#39;, event);">tsickle</a>, that makes TypeScript produce Closurized JavaScript. True to form, this tool is open source but pretty inscrutable to an outsider. It may be used by Angular but I couldn&#39;t tell.</p>
<p>Hopefully this was an interesting lesson in JavaScript history! The Closure Compiler represents an alternative path that the JavaScript ecosystem could have taken, with different principles and different tradeoffs.</p>

          </div></div>
  </body>
</html>
