<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/">Original</a>
    <h1>Lisp as the Maxwell’s Equations of Software</h1>
    
    <div id="readability-page-1" class="page"><div>
										<p>On my first day of physics graduate school, the professor in my class on electromagnetism began by stepping to the board, and wordlessly writing four equations:</p>
<p><img src="https://s0.wp.com/latex.php?latex=+%5Cnabla+%5Ccdot+E+%3D+%5Cfrac%7B%5Crho%7D%7B%5Cepsilon_0%7D+%5Chspace%7B2cm%7D+%5Cnabla+%5Ctimes+E%2B%5Cfrac%7B%5Cpartial+B%7D%7B%5Cpartial+t%7D+%3D+0++&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt=" \nabla \cdot E = \frac{\rho}{\epsilon_0} \hspace{2cm} \nabla \times E+\frac{\partial B}{\partial t} = 0  " title=" \nabla \cdot E = \frac{\rho}{\epsilon_0} \hspace{2cm} \nabla \times E+\frac{\partial B}{\partial t} = 0  "/>
<img src="https://s0.wp.com/latex.php?latex=+%5Cnabla+%5Ccdot+B+%3D+0+%5Chspace%7B1.1cm%7D+%5Cnabla+%5Ctimes+B-%5Cmu_0+%5Cepsilon_0+%5Cfrac%7B%5Cpartial+E%7D%7B%5Cpartial+t%7D+%3D+%5Cmu_0+j+&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt=" \nabla \cdot B = 0 \hspace{1.1cm} \nabla \times B-\mu_0 \epsilon_0 \frac{\partial E}{\partial t} = \mu_0 j " title=" \nabla \cdot B = 0 \hspace{1.1cm} \nabla \times B-\mu_0 \epsilon_0 \frac{\partial E}{\partial t} = \mu_0 j "/></p><p>He stepped back, turned around, and said something like [1]: “These are Maxwell’s equations.  Just four compact equations.  With a little work it’s easy to understand the basic elements of the equations – what all the symbols mean, how we can compute all the relevant quantities, and so on.  But while it’s easy to understand the elements of the equations, understanding all their consequences is another matter.  Inside these equations is all of electromagnetism – everything from antennas to motors to circuits.  If you think you understand the consequences of these four equations, then you may leave the room now, and you can come back and ace the exam at the end of semester.”</p>
<p><a href="http://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a> has <a href="http://queue.acm.org/detail.cfm?id=1039523">famously described</a> Lisp as the “Maxwell’s equations of software”.  He describes the revelation he experienced when, as a graduate student, he was studying the <a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">LISP 1.5 Programmer’s Manual</a> and realized that “the half page of code on the bottom of page 13… was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.”</p>
<p>Here’s the half page of code that Kay saw in that manual:</p>
<p><a href="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png"><img src="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png" alt="" title="Lisp_Maxwells_Equations" width="480" srcset="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png 555w, https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations-291x300.png 291w" sizes="(max-width: 555px) 100vw, 555px"/></a></p>
<p>What we’re going to do in this essay is understand what that half page of code means, and what it means that Lisp is the Maxwell’s equations of software.  However, we won’t literally work through the half page of code above.  Instead, we’ll do something much more informative: we’ll create a modern, <em>fully executable</em> equivalent of the code above.  Furthermore, to make this essay accessible, I won’t assume that you know Lisp.  Instead, I’ll teach you the basic elements of Lisp.</p>
<p>That perhaps sounds over-ambitious, but the good news is that it’s easy to learn the basic elements of Lisp.  Provided you have a little facility with computer programming and comfort with mathematics, you can learn how Lisp works in just a few minutes.  Frankly, it’s much easier than understanding the elements of Maxwell’s equations!  And so I’ll start by explaining a subset of the Lisp programming language, and getting you to write some Lisp code.</p>
<p>But I won’t stop with just showing you how to write some Lisp.  Once we’ve done that we’re going to write an <em>interpreter</em> for Lisp code.  In particular, we’ll create a interpreter based on a <a href="http://norvig.com/lispy.html">beautiful Lisp interpreter</a> written by <a href="http://norvig.com/">Peter Norvig</a>, which contains just 90 lines of Python code.  Our interpreter will be a little more complex, due mostly to the addition of a few conveniences absent from Norvig’s interpreter.  The code is still simple and easy to understand, provided you’re comfortable reading Python code.  As we’ll see, the benefit of writing the interpreter is not just that it gives us a running interpreter (although that’s no small thing).  It’s that writing an interpreter also deepens our understanding of Lisp.  It does that by taking what would otherwise be some rather abstract concepts in our description of Lisp, and giving them concrete, tangible representations in terms of Python code and data structures. By making concrete what was formerly abstract, the code for our Lisp interpreter gives us a new way of understanding how Lisp works.</p>
<p>With our Python Lisp interpreter up and running, we’ll then write a modern equivalent to the code on the bottom of page 13 of the LISP 1.5 Programmer’s Manual.  But while our code will be essentially the same as the code from page 13, it will have the considerable advantage that it’s also executable.  We can, if we wish, play with the code, modify it, and improve it.  In other words, it’s a living version of the Maxwell’s equations of software!  Furthermore, with our new understanding it becomes an easy and fun exercise to understand all the details on page 13 of the LISP Manual.  </p>
<p>This second part of the essay is based primarily on two sources: the first chapter of the LISP 1.5 Manual, of course, but also an <a href="http://lib.store.yahoo.net/lib/paulgraham/jmc.ps">essay by Paul   Graham</a> (postscript) in which he explains some of the early ideas behind Lisp.  Incidentally, “LISP” is the capitalization used in the LISP Manual, but otherwise I’ll use the modern capitalization convention, and write “Lisp”.</p>
<p>The great Norwegian mathematician <a href="http://en.wikipedia.org/wiki/Niels_Henrik_Abel">Niels Henrik   Abel</a> was once asked how he had become so good at mathematics.  He replied that it was <a href="http://scienceworld.wolfram.com/biography/Abel.html">“by   studying the masters, not their pupils”</a>.  The current essay is motivated by Abel’s admonishment.  As a programmer, I’m a beginner (and almost completely new to Lisp), and so this essay is a way for me to work in detail through ideas from masters such as Alan Kay, Peter Norvig, and Paul Graham.  Of course, if one takes Abel at his word, then you should stop reading this essay, and instead go study the works of Kay, Norvig, Graham, and the like!  I certainly recommend taking the time to study their work, and at the end of the essay I make some recommendations for further reading.  However, I hope that this essay has a distinct enough point of view to be of interest in its own right.  Above all, I hope the essay makes thinking about Lisp (and programming) fun, and that it raises some interesting fundamental questions.  Of course, as a beginner, the essay may contain some misunderstandings or errors (perhaps significant ones), and I’d welcome corrections, pointers, and discussion.</p>
<h3>Some elements of Lisp</h3>
<p>In this and the next two sections we’ll learn the basic elements of Lisp – enough to develop our own executable version of what Alan Kay saw on page 13 of the LISP Manual.  We’ll call the dialect of Lisp we develop “tiddly Lisp”, or just tiddlylisp for short.  Tiddlylisp is based on a subset of the programming language Scheme, which is one of the most popular modern dialects of Lisp. </p>
<p>While I can show you a bunch of examples of Lisp, you’ll learn much more if you type in the examples yourself, and then play around with them, modifying them and trying your own ideas.  So I want you to download the file <a href="https://raw.github.com/mnielsen/tiddlylisp/master/tiddlylisp.py">tiddlylisp.py</a> to your local machine.  Alternately, if you’re using <tt>git</tt>, you can just clone the entire <a href="https://github.com/mnielsen/tiddlylisp">code repository</a> associated to this essay.  The file tiddlylisp.py is the Lisp interpreter whose design and code we’ll work through later in the essay.  On Linux and Mac you can start the tiddlylisp interpreter by typing <tt>python tiddlylisp.py</tt> from the command line.  You should see a prompt: </p>
<pre>tiddlylisp&gt;
</pre>
<p> That’s where you’re going to type in the code from the examples – it’s an interactive Lisp interpreter.  You can exit the interpreter at any time by hitting <tt>Ctrl-C</tt>.  Note that the interpreter isn’t terribly complete – as we’ll see, it’s only 153 lines! – and one way it’s incomplete is that the error messages aren’t very informative.  Don’t spend a lot of time worrying about the errors, just try again.</p>
<p>If you’re on Windows, and don’t already have Python installed, you’ll need to <a href="http://www.python.org/download/releases/2.7.2/">download   it</a> (I suggest Python 2.7 for this code), before starting the interpreter by running <tt>python tiddlylisp.py</tt>.  Note that I’ve only tested the interpreter on Ubuntu Linux, not on Windows or the Mac.</p>
<p>As our first example, type the following code into the tiddlylisp interpreter: </p>
<pre>tiddlylisp&gt; (+ 2 3)
5
</pre>
<p> In the <em>expression</em> you typed in, <tt>+</tt> is a built-in <em>procedure</em>, which represents the addition operation.  It’s being applied to two <em>arguments</em>, in this case the numbers <tt>2</tt> and <tt>3</tt>.  The interpreter <em>evaluates</em> the result of applying <tt>+</tt> to <tt>2</tt> and <tt>3</tt>, i.e., of adding <tt>2</tt> and <tt>3</tt> together, <em>returning the value</em> <tt>5</tt>, which it then <em>prints</em>.</p>
<p>That first example was extremely simple, but it contains many of the concepts we need to understand Lisp: expressions, procedures, arguments, evaluation, returning a value, and printing.  We’ll see many more illustrations of these ideas below.</p>
<p>Here’s a second example, illustrating another built-in procedure, this time the multiplication procedure, <tt>*</tt>: </p>
<pre>tiddlylisp&gt; (* 3 4)
12
</pre>
<p> It’s the same basic story: <tt>*</tt> is a built-in procedure, this time representing multiplication, and is here being applied to the numbers <tt>3</tt> and <tt>4</tt>.  The interpreter evaluates the expression, and prints the value returned, which is <tt>12</tt>.</p>
<p>One potentially confusing thing about the first two examples is that I’ve called <tt>+</tt> and <tt>*</tt> “procedures”, yet in many programming languages procedures don’t return a value, only functions do.  I’m using this terminology because it’s the standard terminology in the programming language Scheme, which is the dialect of Lisp that tiddlylisp is based on.  In fact, in some modern dialects of Lisp – such as Common Lisp – operations such as <tt>+</tt> and <tt>*</tt> would be called “functions”.  But we’ll stick with Scheme’s useage, and talk only of procedures.</p>
<p>Another example, illustrating a slightly different type of procedure: </p>
<pre>tiddlylisp&gt; (&lt; 10 20)
True
</pre>
<p> Here, the built-in procedure <tt>&lt;</tt> represents the comparison operator.  And so tiddlylisp prints the result of evaluating an expression which compares the constants <tt>10</tt> and <tt>20</tt>.  The result is <tt>True</tt>, since <tt>10</tt> is less than <tt>20</tt>.  By contrast, we have </p>
<pre>tiddlylisp&gt; (&lt; 17 12)
False
</pre>
<p> since <tt>17</tt> is not less than <tt>12</tt>.</p>
<p>Many Lisp beginners are initially confused by this way of writing basic numerical operations.  We&#39;re so familiar with expressions such as <tt>2 + 3</tt> that the changed order in <tt>(+ 2 3)</tt> appears strange and unfamiliar. And yet our preference for the infix notation <tt>2 + 3</tt> over the prefix notation <tt>(+ 2 3)</tt> is more a historical accident than a consequence of anything fundamental about arithmetic.  Unfortunately, this has the consequence that some people back away from Lisp, simply because they dislike thinking in this unfamiliar way.</p>
<p>In this essay we won&#39;t get deep enough into Lisp to see in a lot of concrete detail why the prefix notation is a good idea.  However, we will get one hint: our tiddlylisp interpreter will be much simpler for using the same (prefix) style for all procedures.  If you really strongly dislike the prefix notation, then I challenge you to rewrite tiddlylisp so that it uses infix notation for some operations, and prefix notation for others.  What you&#39;ll find is that the interpreter becomes quite a bit more complex.  And so there is a sense in which using the same prefix style everywhere makes Lisp simpler.</p>
<p>Another useful thing Lisp allows us to do is to nest expressions: </p>
<pre>tiddlylisp&gt; (&lt; (* 11 19) (* 9 23))
False
</pre>
<p> To compute the value of this expression, tiddlylisp evaluates the nested expressions, returning <tt>209</tt> from <tt>(* 11 19)</tt>, and <tt>207</tt> from <tt>(* 9 23)</tt>.  The output from the outer expression is then just the result of evaluating <tt>(&lt; 209 207)</tt>, which of course is <tt>False</tt>.</p>
<p>We can use tiddlylisp to define variables: </p>
<pre>tiddlylisp&gt; (define x 3)
tiddlylisp&gt; (* x 2)
6
</pre>
<p> <tt>define</tt> is used to define <em>new</em> variables; we can also assign a value to a variable which has previously been defined: </p>
<pre>tiddlylisp&gt; (set! x 4)
tiddlylisp&gt; x
4
</pre>
<p> One question you may have here is about the slightly unusual syntax: <tt>set!</tt>.  You might wonder whether the exclamation mark means something special - maybe <tt>set!</tt> is some type of hybrid procedure or something.  Actually, there&#39;s no such complexity: <tt>set!</tt> is just a single keyword, just like <tt>define</tt>, nothing special about it at all.  It&#39;s just that tiddlylisp allows exclamation marks in keyword names.  So there&#39;s nothing special going on indicated by the exclamation mark.</p>
<p>A deeper question is why we don&#39;t simply eleminate <tt>define</tt>, and make it so <tt>set!</tt> checks whether a variable has been <tt>define</tt>d already, and if not, does so.  I&#39;ll explain a little bit later why we don&#39;t do this; for now, you should just note the distinction.</p>
<p>We can use <tt>define</tt> to define new procedures in a way similar to how we use it to define variables.  Here&#39;s an example showing how to define a procedure named <tt>square</tt>.  I&#39;ll unpack what&#39;s going on below, but first, here&#39;s the code, </p>
<pre>tiddlylisp&gt; (define square (lambda (x) (* x x)))
tiddlylisp&gt; (square 7)
49
</pre>
<p> Ignore the first of the lines above for now.  You can see from the second line what the procedure <tt>square</tt> does: it takes a single number as input, and returns the square of the number.</p>
<p>What about the first line of code above?  We already know enough to guess quite a bit about how this line works: a procedure named <tt>square</tt> is being defined, and is assigned the value of the expression <tt>(lambda (x) (* x x))</tt>, whatever that value might be. What&#39;s new, and what we need to understand, is what the value of the expression <tt>(lambda (x) (* x x))</tt> is.  To understand this, let&#39;s break the expression into three pieces: <tt>lambda</tt>, <tt>(x)</tt>, and <tt>(* x x)</tt>.  We&#39;ll understand the three pieces separately, and then put them back together.</p>
<p>The first piece of the expression - the <tt>lambda</tt> - simply tells the tiddlylisp interpreter that this expression is defining a procedure.  I must admit that when I first encountered the <tt>lambda</tt> notation I found this pretty confusing [2] - I thought that <tt>lambda</tt> must be a variable, or an argument, or something like that.  But no, it&#39;s just a big fat red flag to the tiddlylisp interpreter saying &#34;Hey, this is a procedure definition&#34;.  That&#39;s all <tt>lambda</tt> is.</p>
<p>The second part of the expression - the <tt>(x)</tt> - tells tiddlylisp that this is a procedure with a single argument, and that we&#39;re going to use the temporary name <tt>x</tt> for that argument, for the purposes of defining the procedure.  If the procedure definition had started instead with <tt>(lambda (x y) ...)</tt> that would have meant that the procedure had two arguments, temporarily labelled <tt>x</tt> and <tt>y</tt> for the purposes of defining the procedure.</p>
<p>The third part of the expression - the <tt>(* x x)</tt> - is the meat of the procedure definition.  It&#39;s what we evaluate and return when the procedure is called, with the actual values for the arguments of the procedure substituted in place of <tt>x</tt>.</p>
<p>Taking it all together, then, the value of the expresion <tt>(lambda (x) (* x x))</tt> is just a procedure with a single input, and returning the square of that input.  This procedure is <em>anonymous</em>, i.e., it doesn&#39;t have a name.  But we can give it a name by using <tt>define</tt>, and so the line </p>
<pre>tiddlylisp&gt; (define square (lambda (x) (* x x)))
</pre>
<p> tells tiddlylisp to define something called <tt>square</tt>, whose value is a procedure (because of the <tt>lambda</tt>) with a single argument (because of the <tt>(x)</tt>), and what that procedure returns is the square of its argument (because of the <tt>(* x x)</tt>).</p>
<p>An important point about the variables used in defining procedures is that they&#39;re dummy variables.  Suppose we wanted to define a procedure <tt>area</tt> which would return the area of a triangle, with arguments the base of the triangle and the height.  We could do this using the following procedure definition: </p>
<pre>tiddlylisp&gt; (define area (lambda (b h) (* 0.5 (* b h))))
tiddlylisp&gt; (area 3 5)
7.5
</pre>
<p> But what would have happened if we&#39;d earlier defined a variable <tt>h</tt>, e.g.: </p>
<pre>tiddlylisp&gt; (define h 11)
tiddlylisp&gt; (define area (lambda (b h) (* 0.5 (* b h))))
</pre>
<p> It probably won&#39;t surprise you to learn that inside the procedure definition, i.e., immediately after the <tt>lambda (b h)</tt>, the <tt>h</tt> is treated as a dummy variable, and is entirely different from the <tt>h</tt> outside the procedure definition.  It has what&#39;s called a different <em>scope</em>.  And so we can continue the above with the following </p>
<pre>tiddlylisp&gt; (area 3 h)
16.5
</pre>
<p> that is, the area is just 0.5 times 3 times the value of <tt>h</tt> set earlier, outside the procedure definition.  At that point the value of <tt>h</tt> was 11, and so <tt>(area 3 h)</tt> returns 16.5.</p>
<p>There&#39;s a variation on the above that you might wonder about, which is what happens when you use variables defined <em>outside</em> a procedure <em>inside</em> that procedure definition?  For instance, suppose we have: </p>
<pre>tiddlylisp&gt; (define x 3)
tiddlylisp&gt; (define foo (lambda (y) (* x y)))
</pre>
<p> What happens now if we evaluate <tt>foo</tt>?  Well, tiddlylisp does the sensible thing, and interprets <tt>x</tt> as it was defined outside the procedure definition, so we have: </p>
<pre>tiddlylisp&gt; (foo 4)
12
</pre>
<p> What happens to our procedure if we next change the value of <tt>x</tt>? In fact, this changes <tt>foo</tt>: </p>
<pre>tiddlylisp&gt; (set! x 5)
tiddlylisp&gt; (foo 4)
20
</pre>
<p> In other words, in the procedure definition <tt>lambda (y) (* x y)</tt> the <tt>x</tt> really does refer to the variable <tt>x</tt>, and not to the particular value <tt>x</tt> might have at any given point in time.</p>
<p>Let&#39;s dig down a bit more into how tiddlylisp handles scope and dummy variables.  Let&#39;s look at what happens when we define a variable: </p>
<pre>tiddlylisp&gt; (define x 5)
tiddlylisp&gt; x
5
</pre>
<p> The way the interpreter handles this internally is that it maintains what&#39;s called an <em>environment</em>: a dictionary whose keys are the variable names, and whose values are the corresponding variable values.  So what the interpeter does when it sees the first line above is add a new key to the environment, &#34;<tt>x</tt>&#34;, with value <tt>5</tt>.  When the interpreter sees the second line, it consults the environment, looks up the key <tt>x</tt>, and returns the corresponding value.  You can, if you like, think of the environment as the interpreter&#39;s memory or data store, in which it stores all the details of the variables defined to date.</p>
<p>All this is pretty simple.  We can go along defining and changing variables, and the interpreter just keeps consulting and modifying the environment as necessary.  But when you define a new procedure using <tt>lambda</tt> the interpreter treats the variables used in the definition slightly differently.  Let&#39;s look at an example: </p>
<pre>tiddlylisp&gt; (define h 5)
tiddlylisp&gt; (define area (lambda (b) (* b h)))
tiddlylisp&gt; (area 2)
10
</pre>
<p> What I want to concentrate on here is the procedure definition <tt>(lambda (b) (* b h))</tt>.  Up to this point the interpreter had been chugging along, modifying its environment as appropriate.  What happens when it sees the <tt>(lambda ...)</tt>, though, is that the <em>interpreter creates a new environment</em>, an environment called an <em>inner</em> environment, as distinguished from the <em>outer</em> environment, which is what the interpreter has been operating in until it reached the <tt>(lambda ...)</tt> statement.  The inner environment is a new dictionary, whose keys initially are just the arguments to the procedure - in this case a single key, <tt>b</tt> - and whose values will be supplied when the procedure is called.</p>
<p>To recap, what the interpreter does when it sees <tt>(lambda (b) (* b h))</tt> is create a new inner environment, with a key <tt>b</tt> whose value will be set when the procedure is called. When evaluating the expression <tt>(* b h)</tt> (which defines the result returned from the procedure) what the interpreter does is first consult the inner environment, where it finds the key <tt>b</tt>, but not the key <tt>h</tt>.  When it fails to find <tt>h</tt>, it looks instead for <tt>h</tt> in the outer environment, where the key <tt>h</tt> has indeed been defined, and retrieves the appropriate value.</p>
<p>I&#39;ve described a simple example showing how environments work, but tiddlylisp also allows us to have procedure definitions nested inside procedure definitions, nested inside procedure definitions (and so on).  To deal with this, the top-level tiddlylisp interpreter operates inside a <em>global environment</em>, and each procedure definition creates a new inner environment, perhaps nested inside a previously created inner environment, if that&#39;s appropriate.</p>
<p>If all this talk about inner and outer environments has left you confused, fear not.  At this stage it really <em>is</em> important to have gotten the gist of how environments work, but you shouldn&#39;t worry if the details still seem elusive.  In my opinion, the best way to understand those details is not through abstract discussion, but instead by looking at the working code for tiddlylisp.  We&#39;ll get to that shortly, but for now can move onwards armed with a general impression of how environments work.</p>
<p>The procedure definitions I&#39;ve described so far evaluate and return the value from just a single expression.  We can use such expressions to achieve suprisingly complex things, because of the ability to nest expressions.  Still, it would be convenient to have a way of chaining together expressions that doesn&#39;t involve nesting.  A way of doing this is to use the <tt>begin</tt> keyword.  <tt>begin</tt> is especially helpful in defining complex procedures, and so I&#39;ll give an example in that context: </p>
<pre>tiddlylisp&gt; (define area (lambda (r) (begin (define pi 3.14) (* pi (* r r)))))
</pre>
<p> This line is defining a procedure called <tt>area</tt>, with a single argument <tt>r</tt>, and where the value of <tt>(area r)</tt> is just the value of the expression </p>
<pre>(begin (define pi 3.14) (* pi (* r r)))
</pre>
<p> with the appropriate value for <tt>r</tt> substituted.  The way tiddlylisp evaluates the <tt>begin</tt> expression above is that it evaluates all the separate sub-expressions, consecutively in the order they appear, and then returns the value of the <em>final</em> sub-expression, in this case the sub-expression <tt>(* pi (* r r))</tt>. So, for example, we get </p>
<pre>tiddlylisp&gt; (area 3)
28.26
</pre>
<p> which is just the area of a circle with radius <tt>3</tt>.  </p>
<p>Now, in a simple example such as this you might argue that it makes more sense to avoid defining <tt>pi</tt>, and just put <tt>3.14</tt> straight into the later expression.  However, doing so will make the intent of the code less clear, and I trust you will find it easy to imagine more complex cases where it makes even more sense to use multi-part <tt>begin</tt> expressions.  This is especially the case since it is permissible to split Lisp expressions over multiple lines, so the above procedure definition could have been written: </p>
<pre>(define area (lambda (r)
  (begin (define pi 3.14)
         (* pi (* r r)))))
</pre>
<p> Now, I should mention that if you enter the above into the tiddlylisp interpreter, you&#39;ll get errors.  This is because the tiddlylisp interpreter is so stripped down that it doesn&#39;t allow multi-line inputs.  However, tiddlylisp will allow you to load multi-line expressions from a file - try saving the above three lines in a file named <tt>area.tl</tt>, and then running that file with <tt>python tiddlylisp.py area.tl</tt>.  Tiddlylisp will execute the code, defining the <tt>area</tt> procedure, and then leave you in the interpreter, where you can type things like: </p>
<pre>tiddlylisp&gt; (area 3)
28.26
</pre>
<p>A second advantage of using <tt>begin</tt> in the above code is that the variable <tt>pi</tt> is only defined in the inner environment associated to the <tt>lambda</tt> expression.  If, for some reason, you want to define <tt>pi</tt> differently outside that scope, you can do so, and it won&#39;t be affected by the definition of <tt>area</tt>.  Consider, for example, the following sequence of expressions: </p>
<pre>tiddlylisp&gt; (define pi 3)
tiddlylisp&gt; pi
3
tiddlylisp&gt; (define area (lambda (r) (begin (define pi 3.14) (* pi (* r r)))))
tiddlylisp&gt; (area 1)
3.14
tiddlylisp&gt; pi
3
</pre>
<p> In other words, the value of the final <tt>pi</tt> is returned from the outer (global) environment, not the inner environment created during the definition of the procedure <tt>area</tt>.</p>
<p>Earlier, we discussed <tt>define</tt> and <tt>set!</tt>, and wondered whether there was really any essential difference.  Consider now the following example, where we modify <tt>area</tt> by using <tt>set!</tt> instead of <tt>define</tt>: </p>
<pre>tiddlylisp&gt; (define pi 3)
tiddlylisp&gt; pi
3
tiddlylisp&gt; (define area (lambda (r) (begin (set! pi 3.14) (* pi (* r r)))))
tiddlylisp&gt; (area 1)
3.14
tiddlylisp&gt; pi
3.14
</pre>
<p> As you can see by comparing the final line of this example to our earlier example, there really is a significant difference between <tt>define</tt> and <tt>set!</tt>.  In particular, when we define <tt>area</tt> in this example, what <tt>set!</tt> does is check to see whether the inner environment contains a variable named <tt>pi</tt>. Since it doesn&#39;t, it checks the outer environment, where it does find such a variable, and that&#39;s what <tt>set!</tt> updates. If we&#39;d used <tt>define</tt> instead it would have created a completely new variable named <tt>pi</tt> in the inner environment, while leaving <tt>pi</tt> in the outer environment untouched, so the final line would have returned <tt>3</tt> instead.  So having both <tt>define</tt> and <tt>set!</tt> gives us quite a bit of flexibility and control over which environment is being used, at the expense of a complication in syntax.</p>
<p>As our final piece of Lisp before putting what we&#39;ve learnt together to construct a nontrivial example, tiddlylisp includes a keyword <tt>if</tt> that can be used to test conditions, and conditionally return the value of different expressions.  Here&#39;s an example showing the use of <tt>if</tt> to evaluate the absolute value of a variable: </p>
<pre>tiddlylisp&gt; (define x -2)
tiddlylisp&gt; (if (&gt; x 0) x (- 0 x))
2
</pre>
<p> We can use the same idea to define a procedure <tt>abs</tt> which returns the absolute value of a number: </p>
<pre>tiddlylisp&gt; (define abs (lambda (x) (if (&gt; x 0) x (- 0 x))))
tiddlylisp&gt; (abs -2)
2
</pre>
<p> The general form for <tt>if</tt> expressions is <tt>(if </tt><em>cond   result alt</em><tt>)</tt>, where we evaluate the expression <em>cond</em>, and if the value is <tt>True</tt>, return the value of <em>result</em>, otherwise return the value of <em>alt</em>.  Note that in the expression <tt>(if </tt><em>cond result alt</em><tt>)</tt>, the <em>cond</em>, <em>result</em> and <em>alt</em> of course shouldn&#39;t be read literally. Rather, they are placeholders for other expressions, as we saw in the absolute value example above.  Through the remainder of this essay I will use use italics to indicate such placeholder expressions.</p>
<p>Let me conclude this section by briefly introducing two important Lisp concepts.  The first is the concept of a <em>special form</em>.  In this section we discussed several built-in procedures, such as <tt>+</tt> and <tt>*</tt>, and also some user-defined procedures.  Calls to such procedures always have the form <tt>(</tt><em>proc exp1   exp2...</em><tt>)</tt>, where <em>proc</em> is the procedure name, and the other arguments are expressions.  Such expressions are evaluated by evaluating each individual expression <em>exp1, exp2...</em>, and then passing those values to the procedure.  However, not all Lisp expressions are procedure calls.  Consider the expression <tt>(define pi 3.14)</tt>.  This isn&#39;t evaluated by calling some procedure <tt>define</tt> with arguments given by the value of <tt>pi</tt> and the value of <tt>3.14</tt>.  It can&#39;t be evaluated this way because <tt>pi</tt> doesn&#39;t have a value yet!  So <tt>define</tt> isn&#39;t a procedure.  Instead, <tt>define</tt> is an example of what is known as a <em>special form</em>.  Other examples of special forms include <tt>lambda</tt>, <tt>begin</tt>, and <tt>if</tt>, and a few more which we&#39;ll meet later.  Like <tt>define</tt>, none of these is a procedure, but instead each special forms has its own special rule for evaluation.</p>
<p>The second concept I want to briefly introduce is that of a list.  The list is one of the basic data structures used in Lisp, and even gives the language its name - Lisp is short for &#34;list processing&#34;.  In fact, most of the Lisp expressions we&#39;ve seen up to now are lists: an expression such as <tt>(abs 2)</tt> is a two-element list, with elements <tt>abs</tt> and <tt>2</tt>, delimited by spaces and parentheses.  A more complex expression such as <tt>(define abs (lambda (x) (if (&gt; x 0) x (- 0 x))))</tt> is also a list, in this case with the first two elements being <tt>define</tt> and <tt>abs</tt>.  The third element, <tt>(lambda (x) (if (&gt; x 0) x (- 0 x)))</tt>, is a sublist which in turn has sublists (and subsublists) of its own.  Later we&#39;ll see how to use Lisp to do manipulations with such lists.</p>
<h3>A nontrivial example: square roots using only elementary   arithmetic</h3>
<p>Let&#39;s put together the ideas above to do something nontrivial.  We&#39;ll write a short tiddlylisp program to compute square roots, using only the elementary arithmetical operations (addition, subtraction, multiplication, and division).  The idea behind the program is to use <a href="http://en.wikipedia.org/wiki/Newton&#39;s_method">Newton&#39;s method</a>. Although Newton&#39;s method is interesting in its own right, I&#39;m not including this example because of its algorithmic elegance.  Instead, I&#39;m including it as a simple and beautiful example of a Lisp program. The example comes from Abelson and Sussman&#39;s book on the <a href="http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262011530">Structure   and Interpretation of Computer Programs</a>.</p>
<p>Here&#39;s how Newton&#39;s method for computing square roots works.  Suppose we have a (positive) number <tt>x</tt> whose square root we wish to compute.  Then we start by making a <em>guess</em> at the square root, <tt>guess</tt>.  We&#39;re going to start by arbitrarily choosing <tt>1.0</tt> as our initial value for <tt>guess</tt>; in principle, any positive number will do.  According to Newton&#39;s method, we&#39;ll get an improved guess by computing <tt>(guess+x/guess)/2</tt>, i.e., by taking the average of <tt>guess</tt> and <tt>x/guess</tt>.  If we repeat this averaging process enough times, we&#39;ll converge to a good estimate of the square root.</p>
<p>Let&#39;s express these ideas in Lisp code.  We&#39;ll do it from the top down, starting at a high level, and gradually filling in the details of all the procedures we need.  We start at the absolute top level, </p>
<pre>(define sqrt (lambda (x) (sqrt-iter 1.0 x)))
</pre>
<p> Here, <tt>(sqrt-iter guess x)</tt> is the value of a to-be-defined procedure <tt>sqrt-iter</tt> that takes a guess <tt>guess</tt> at the square root of <tt>x</tt>, and keeps improving that guess over and over until it&#39;s a good enough estimate of the square root.  As I mentioned above, we start by arbitrarily choosing <tt>guess = 1.0</tt>.</p>
<p>The core of the algorithm is the definition of <tt>sqrt-iter</tt>: </p>
<pre>(define sqrt-iter 
    (lambda (guess x) 
      (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))))
</pre>
<p> What <tt>sqrt-iter</tt> does is takes the <tt>guess</tt> and checks to see whether it&#39;s yet a <tt>good-enough?</tt> approximation to the square root of <tt>x</tt>, in a sense to be made precise below.  If it is, then <tt>sqrt-iter</tt> is done, and returns <tt>guess</tt>, otherwise it applies <tt>sqrt-iter</tt> to the improved guess <tt>(improve guess x)</tt> supplied by applying Newton&#39;s method.</p>
<p>Incidentally, the way I&#39;ve written <tt>sqrt-iter</tt> above it&#39;s another example of a multi-line tiddlylisp expression, and so it&#39;s not possible to enter in the tiddlylisp interpreter.  However, you can enter it as part of a file, <tt>sqrt.tl</tt>, along with the definition of <tt>sqrt</tt>, and other procedures which we&#39;ll define below.  We&#39;ll later use tiddlylisp to execute the file <tt>sqrt.tl</tt>.</p>
<p>To fill out the details of the above, we need to understand how <tt>good-enough?</tt> and <tt>improve</tt> work.  Let&#39;s start with <tt>good-enough?</tt>, which simply checks whether the absolute value of the square of <tt>guess</tt> is within 0.00001 of <tt>x</tt>: </p>
<pre> 
(define good-enough? 
    (lambda (guess x) (&lt; (abs (- x (square guess))) 0.00001)))
</pre>
<p> Here, we have defined the absolute value procedure <tt>abs</tt> and the squaring procedure <tt>square</tt> as: </p>
<pre> 
(define abs (lambda (x) (if (&lt; 0 x) x (- 0 x))))
(define square (lambda (x) (* x x)))
</pre>
<p> That&#39;s all the code we need for <tt>good-enough?</tt>.  For <tt>improve</tt> we simply implement Newton&#39;s method, </p>
<pre>(define improve (lambda (guess x) (average guess (/ x guess))))
</pre>
<p> where <tt>average</tt> is defined in the obvious way: </p>
<pre>(define average (lambda (x y) (* 0.5 (+ x y))))
</pre>
<p> We can write out the whole program as follows: </p>
<pre>(define average (lambda (x y) (* 0.5 (+ x y))))
(define improve (lambda (guess x) (average guess (/ x guess))))
(define square (lambda (x) (* x x)))
(define abs (lambda (x) (if (&lt; 0 x) x (- 0 x))))
(define good-enough? 
    (lambda (guess x) (&lt; (abs (- x (square guess))) 0.00001)))
(define sqrt-iter 
    (lambda (guess x) 
      (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))))
(define sqrt (lambda (x) (sqrt-iter 1.0 x)))
</pre>
<p> Save these lines to the file <tt>sqrt.tl</tt>, and then run it using <tt>python tiddlylisp.py sqrt.tl</tt>.  Tiddlylisp will execute the code, defining all the above procedures, and then leave you in an interpreter, where you can type: </p>
<pre>tiddlylisp&gt; (sqrt 2.0)
1.41421568627
</pre>
<p> This is, indeed, a pretty good approximation to the true square root: <tt>1.4142135...</tt>.</p>
<p>In writing out the overall program <tt>sqrt.tl</tt>, I&#39;ve reversed the order of the lines, compared to my initial explanation.  The reason I&#39;ve done this is worth discussing.  You see, the program <tt>sqrt.tl</tt> was actually the first piece of Lisp code I ever worked though in detail. The natural way to think through the problem of computing square roots with Newton&#39;s method is in the order I explained, working in a top-down fashion, starting from the broad problem, and gradually breaking our attack on that problem down into parts.  But the first time I wrote the code out I assumed that I needed to explain these ideas to Lisp in a bottom-up fashion, defining procedures like <tt>average</tt> before <tt>improve</tt> and so on, so that procedure definitions only include previously defined procedures. That meant reversing the order of the code, as I&#39;ve shown above.</p>
<p>Taking this approach bugged me. It doesn&#39;t seem like the most natural way to think about implementing Newton&#39;s method.  At least for this problem a top-down approach seems more natural, and if you were just doing exploratory programming you&#39;d start by defining <tt>sqrt</tt>, then <tt>sqrt-iter</tt>, and so on.  As an experiment, I decided to reverse the order of the progam, so it reflects the natural &#34;thinking order&#34;: </p>
<pre>(define sqrt (lambda (x) (sqrt-iter 1.0 x)))
(define sqrt-iter 
    (lambda (guess x) 
      (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))))
(define good-enough? 
    (lambda (guess x) (&lt; (abs (- x (square guess))) 0.00001)))
(define abs (lambda (x) (if (&lt; 0 x) x (- 0 x))))
(define square (lambda (x) (* x x)))
(define improve (lambda (guess x) (average guess (/ x guess))))
(define average (lambda (x y) (* 0.5 (+ x y))))
</pre>
<p> Somewhat to my surprise, this ran just fine !  (Actually, my code was slightly different, since I was using Common Lisp at that point, not tiddlylisp, but tiddlylisp works as well.)  It&#39;s apparently okay to define a procedure in terms of some other procedure which isn&#39;t defined until later.  Now, upon close examination of the code for tiddlylisp it turns out that this makes perfect sense.  But it came as a surprise to me.  Later, when we examine the code for tiddlylisp, I&#39;ll set a problem asking you to explain why it&#39;s okay to re-order the code above.</p>
<p>I think this program for the square root is a very beautiful program. Of course, in most programming languages the square root is built in, and so it&#39;s not exactly notable to have an elegant program for it! Indeed, the square root is built in to most version of Lisp, and it&#39;s trivially possible to add the square root to tiddlylisp.  But what I like about the above is that it&#39;s such a simple and natural expression of Newton&#39;s method.  As <a href="http://en.wikipedia.org/wiki/L._Peter_Deutsch">Peter Deutsch</a> has <a href="http://en.wikiquote.org/wiki/Lisp_programming_language">said</a>, Lisp programs come close to being &#34;executable mathematics&#34;.</p>
<h3>Problems for the author</h3>
<ul>
<li> As a general point about programming language design it seems   like it would often be helpful to be able to define procedures in   terms of other procedures which have not yet been defined.  Which   languages make this possible, and which do not?  What advantages   does it bring for a programming language to be able to do this?  Are   there any disadvantages? </li></ul>
<h3>A few more elements of Lisp</h3>
<p>I began my introduction to Lisp by focusing on elementary arithmetical operations, and how to put them together.  I did that so I could give you a concrete example of Lisp in action - the square root example in the last section - which is a good way of getting a feel for how Lisp works.  But if we&#39;re going to understand Lisp as &#34;the Maxwell&#39;s equations of software&#34; then we also need to understand more about how Lisp deals with expressions and with lists. I&#39;ll describe those operations in this section.</p>
<p>Before I describe those operations, I want to discuss a distinction that I haven&#39;t drawn much attention to until now.  That&#39;s the distinction between an <em>expression</em> such as <tt>(+ 1 2)</tt> and the <em>value</em> of that expression, which in this case is <tt>3</tt>. When we feed a (valid) tiddlylisp expression to the tiddlylisp interpreter, it evaluates the expression, and returns its value.  </p>
<p>When I was first learning Lisp I&#39;d often get myself in trouble because I failed to keep myself clear on the distinction between an expression and its value.  Let me give you an example of the kind of confusion I&#39;d get myself into.  There is a built-in Lisp procedure called <tt>atom?</tt>, defined so that <tt>(atom? </tt><em>exp</em><tt>)</tt> returns <tt>True</tt> if the value of the expression <em>exp</em> is atomic - a number, for example, or anything which isn&#39;t a list - and returns <tt>False</tt> otherwise.  (Note that <em>exp</em> is a placeholder expression, as we discussed earlier, and shouldn&#39;t be read literally as the identifier <tt>exp</tt>.)  Now, I&#39;d look at an example like <tt>(atom? 5)</tt> and have no trouble figuring out that it evaluated to <tt>True</tt>.  But where I&#39;d get into trouble is with an expression like <tt>(atom? (+ 1 2))</tt>.  I&#39;d look at it and think it must return <tt>False</tt>, because the expression <tt>(+ 1 2)</tt> is not atomic, it&#39;s a list.  Unfortunately, while it&#39;s true that the expression <tt>(+ 1 2)</tt> is not atomic, it&#39;s irrelevant, because the value of <tt>(atom?  </tt><em>exp</em><tt>)</tt> is determined by whether the <em>value</em> of <em>exp</em> is atomic - which it is, since the value of <tt>(+ 1 2)</tt>) is <tt>3</tt>.  You&#39;ll be a much happier Lisper if you always keep very clear on the distinction between expressions and the value of expressions.</p>
<p>Now, of course, this distinction between expressions and their values appears in most other programming languages.  For this reason, I felt foolish when I understood what was causing my confusion.  But what makes it so easy to make this kind of mistake is that in Lisp both expressions and the value of those expressions can be lists.  And that&#39;s why when I write something like <tt>(atom? (+ 1 2))</tt> there&#39;s a real question: is <tt>atom?</tt> checking whether the expression <tt>(+ 1 2)</tt> is atomic (no, it&#39;s not, it&#39;s a list), or whether the value of the expression - <tt>3</tt> - is atomic (yes, it is).  So you need to be pretty careful to keep clear on which is meant.  To help with this, I&#39;ll be pretty pedantic about the distinction in what follows, writing out &#34;the value of <em>exp</em>&#34; explicitly, to distinguish the value from the expression itself.  Note, however, that it&#39;s quite common for people to be less pedantic and more informal, so that something like <tt>(+ x 2)</tt> may well be described as &#34;adding the variable <tt>x</tt> to the variable <tt>y</tt>&#34;, not the more explicit &#34;adding the value of the variable <tt>x</tt> to the value of the variable <tt>y</tt>.&#34;</p>
<p>Alright, with that admonishment out of the way, let&#39;s turn our attention to defining the final set of elementary operations we&#39;ll need in tiddlylisp.</p>
<p><strong>Returning an expression as a value:</strong> <tt>(quote </tt><em>exp</em><tt>)</tt> returns the expression <em>exp</em> as its value, <em>without</em> evaluating <em>exp</em>.  This is most clearly demonstrated by an example, </p>
<pre>tiddlylisp&gt; (quote (+ 1 2))
(+ 1 2)
</pre>
<p> as opposed to the value of <tt>(+ 1 2)</tt>, which of course is <tt>3</tt>.  Another example, just to reinforce the point that <tt>quote</tt> returns an expression literally, without evaluating it, </p>
<pre>tiddlylisp&gt; (define x 3)
tiddlylisp&gt; (quote x)
x
</pre>
<p> not the value of <tt>x</tt>, which of course is <tt>3</tt>.  Note also that quoting doesn&#39;t evaluate nested subexpressions, e.g., </p>
<pre>tiddlylisp&gt; (quote ((+ 1 2) 3))
((+ 1 2) 3)
</pre>
<p> <tt>quote</tt> can also be used to return lists which aren&#39;t valid Lisp expressions at all, e.g., </p>
<pre>tiddlylisp&gt; (quote (1 2 3))
(1 2 3)
</pre>
<p> It&#39;s worth emphasizing that <tt>(1 2 3)</tt> isn&#39;t a valid Lisp expression, since <tt>1</tt> is neither a procedure nor a special form - if you enter <tt>(1 2 3)</tt> into the tiddlylisp interpreter, it will give an error. But what <tt>quote</tt> lets us do is use the list <tt>(1 2 3)</tt> as data.  For example, we could use it to store the <tt>(1 2 3)</tt> in a variable, </p>
<pre>tiddlylisp&gt; (define x (quote (1 2 3)))
tiddlylisp&gt; x
(1 2 3)
</pre>
<p> In this way, <tt>quote</tt> lets us work with lists as data structures.</p>
<p>Why does Lisp have <tt>quote</tt>?  Most other computer programming languages don&#39;t have anything like it.  The reason Lisp has it is because Lisp allows you to treat code as data, and data as code.  So, for example, an object such as <tt>(+ 1 2)</tt> can be treated as code, i.e., as a Lisp expression to be evaluated, which is what we&#39;ve been doing up until the current discussion.  But <tt>(+1 2)</tt> can also potentially be treated as data, i.e., as a list of three objects. This ability to treat code and data on the same footing is a wonderful thing, because it means you can write programs to manipulate programs. But it also creates a problem, which is that we need to be able to distinguish when an expression should be treated as data, and when it should be treated as code.  <tt>quote</tt> is a way of distinguishing between the two.  It&#39;s similar to the way most languages use escape characters to deal with special strings such as &#34;.  <tt>quote</tt> is a way of saying &#34;Hey, what follows should be treated as data, not evaluated as Lisp code&#34;.  And so <tt>quote</tt> lets us escape Lisp code, so we can take an expression such as <tt>(+ 1 2)</tt> and turn it into data: <tt>(quote (+ 1 2)</tt>.  In this way, <tt>quote</tt> allows us to define Lisp expressions whose values are arbitrary Lisp expressions.</p>
<p>Up until now we&#39;ve been focused on using Lisp to do simple arithmetic operations, and as a result we haven&#39;t needed <tt>quote</tt>.  But when we get to Lisp-as-Maxwell&#39;s-equations we&#39;re going to be increasingly focused on using Lisp to manipulate Lisp code, and as a result we&#39;ll be making frequent use of <tt>quote</tt>.  For this reason it&#39;s helpful to introduce shorthand for <tt>quote</tt>.  In most Lisps, the conventional shorthand is to use <tt>&#39;</tt><em>exp</em> to denote <tt>(quote </tt><em>exp</em><tt>)</tt>, i.e. if <em>exp</em> is some Lisp expression, then the value of <tt>&#39;</tt><em>exp</em> is just the expression <em>exp</em> itself.  Unfortunately, using the shorthand <tt>&#39;</tt><em>exp</em> complicated the parsing in the tiddlylisp interpreter more than I wanted.  So I decided to instead use a different (and, I emphasize, unconventional) shorthand for <tt>(quote </tt><em>exp</em><tt>)</tt>, namely <tt>(q </tt><em>exp</em><tt>)</tt>. So our examples of <tt>quote</tt> above can be shortened to, </p>
<pre>tiddlylisp&gt; (q (+ 1 2))
(+ 1 2)
tiddlylisp&gt; (define x 3)
tiddlylisp&gt; (q x)
x
tiddlylisp&gt; (q ((+ 1 2) 3))
((+ 1 2) 3)
</pre>
<p><strong>Testing whether the value of an expression is atomic:</strong> As I noted above, <tt>(atom? </tt><em>exp</em><tt>)</tt> returns <tt>True</tt> if the value of the expression <em>exp</em> is atomic, and otherwise returns <tt>False</tt>.  We&#39;ve already discussed the following example, </p>
<pre>tiddlylisp&gt; (atom? (+ 1 2))
True
</pre>
<p> but it&#39;s illuminating to see it in tandem with the following example, which illustrates also the use of <tt>quote</tt>, </p>
<pre>tiddlylisp&gt; (atom? (q (+ 1 2)))
False
</pre>
<p> As above, the first example returns <tt>True</tt> because while <tt>(+ 1 2)</tt> is not atomic, its value, <tt>3</tt>, is.  But the second example returns <tt>False</tt> because the value of <tt>(q (+ 1 2))</tt> is just <tt>(+ 1 2)</tt>, which is a list, and thus not atomic.</p>
<p>By the way, I should mention that <tt>atom?</tt> is not a built-in procedure in the dialect of Lisp that tiddlylisp based on, Scheme. I&#39;ve built <tt>atom?</tt> into tiddlylisp because, as we&#39;ll see, the analogous operation is used many times in the code on page 13 of the LISP 1.5 Programmer&#39;s Manual.  Of course, an <tt>atom?</tt> procedure is easily defined in Scheme, but for the purposes of understanding the code on page 13 it seemed most direct to simply include <tt>atom?</tt> as a built-in in tiddlylisp.</p>
<p><strong>Testing whether two expressions both evaluate to the same atom   (or the empty list):</strong> <tt>(eq? </tt><em>exp1 exp2</em><tt>)</tt> returns <tt>True</tt> if the values of <em>exp1</em> and <em>exp2</em> are both the same atom, or both the empty list, <tt>()</tt>.  <tt>(eq? </tt><em>exp1   exp2</em><tt>)</tt> returns <tt>False</tt> otherwise.  Note that if <em>exp1</em> and <em>exp2</em> have the same value, but are not atomic or the empty list, then <tt>(eq? </tt><em>exp1 exp2</em><tt>)</tt> returns <tt>False</tt>.  For example, </p>
<pre>tiddlylisp&gt; (eq? 2 (+ 1 1))
True
tiddlylisp&gt; (eq? 3 (+ 1 1))
False
tiddlylisp&gt; (eq? (q (1 2)) (q (1 2)))
False
</pre>
<p> As for <tt>atom?</tt> my explanation of <tt>eq?</tt> is not quite the same as in standard Scheme, but instead more closely matches the function <tt>eq</tt> defined in the LISP 1.5 Programmer&#39;s Manual.</p>
<p><strong>Getting the first item of a list:</strong> <tt>(car </tt><em>exp</em><tt>)</tt> returns the first element of the value of <em>exp</em>, provided the value of <em>exp</em> is a list.  Otherwise <tt>(car </tt><em>exp</em><tt>)</tt> is undefined.  For example, </p>
<pre>tiddlylisp&gt; (car (q (+ 2 3)))
+
tiddlylisp&gt; (car (+ 2 3))
<error message,="" which="" i've="" elided="">
</error></pre>
<p> The first of these two behaves as expected: the value of <tt>(q (+ 2 3)</tt> is just the list <tt>(+ 2 3)</tt>, and so <tt>car</tt> returns the first element, which is <tt>+</tt>.  In the second, though, <tt>car</tt> is not defined, and tiddlylisp returns an error message, which I&#39;ve elided.  The reason it returns an error message is because the value of <tt>(+ 2 3)</tt> is <tt>5</tt>, which is not a list, and so <tt>car</tt> is undefined.  In a similar way, suppose we try </p>
<pre>tiddlylisp&gt; (car (1 2 3))
<error message="">
</error></pre>
<p> Again, we get an error message.  The reason is that <tt>car</tt> is being applied to the <em>value</em> of <tt>(1 2 3)</tt>, considered as a Lisp expression.  And, of course, that value is undefined, since <tt>1</tt> is neither a procedure nor a special form.  The right way to do the above is to <tt>quote</tt> the list first, </p>
<pre>tiddlylisp&gt; (car (q (1 2 3)))
1
</pre>
<p> Once again, we see how <tt>quote</tt> is used to make it clear to tiddlylisp that we&#39;re dealing with data, not code to be evaluated.</p>
<p><strong>Getting the rest of a list:</strong> <tt>(cdr </tt><em>exp</em><tt>)</tt> returns a list containing all but the first element of the value of <em>exp</em>.  Of course, the value of <em>exp</em> must be a list, otherwise <tt>(cdr </tt><em>exp</em><tt>)</tt> is undefined.  For example, </p>
<pre>tiddlylisp&gt; (cdr (q (1 2 3)))
(2 3)
</pre>
<p> According to <a href="http://en.wikipedia.org/wiki/CAR_and_CDR#Etymology">Wikipedia</a> the names <tt>car</tt> and <tt>cdr</tt> have their origin in some pretty esoteric facts about the early implementations of Lisp.  The details don&#39;t much matter here - <tt>car</tt> stands for &#34;contents of address part of register&#34;, while <tt>cdr</tt> stands for &#34;contents of decrement part of register&#34; - I just wanted to make the point that you could reasonably be wondering &#34;Where on Earth did those names come from?!&#34;  A mnemonic I find useful in distinguishing the two is to focus on the difference between the names of the two procedures, which of course is just the middle letter - <tt>a</tt> or <tt>d</tt> - and to keep in mind that <tt>a</tt> comes <em>before</em> <tt>d</tt> in the alphabet, just as <tt>car</tt> extracts the element of a list that comes <em>before</em> the remainder of the list, as given to us by <tt>cdr</tt>. Your taste in mnemonics may vary - if you don&#39;t like mine, it&#39;s still worth taking a minute or two to come up with some trick for remembering and distinguishing <tt>car</tt> and <tt>cdr</tt>.  Of course, after a little practice you get used to them, and you won&#39;t need the mnemonic any more, but at first it&#39;s helpful.</p>
<p><strong>Appending an item at the start of a list:</strong> Provided the value of <em>exp2</em> is a list, then <tt>(cons </tt><em>exp1 exp2</em><tt>)</tt> returns a list containing the value of <em>exp1</em> as its first element, followed by all the elements of the value of <em>exp2</em>. For example, </p>
<pre>tiddlylisp&gt; (cons 1 (q (2 3)))
(1 2 3)
</pre>
<p><strong>Testing whether an expression evaluates to the empty list:</strong> <tt>(null? </tt><em>exp</em><tt>)</tt> returns <tt>True</tt> if <em>exp</em> evaluates to the empty list, <tt>()</tt>, and otherwise returns <tt>False</tt>.  For example, </p>
<pre>tiddlylisp&gt; (null? (cdr (q (1))))
True
</pre>
<p> since <tt>(cdr (q (1)))</tt> returns the empty list.</p>
<p><strong>Conditionals:</strong> <tt>(cond (</tt><em>p1 e1</em><tt>)...(</tt><em>pn   en</em><tt>))</tt>: This starts by evaluating the expression <em>p1</em>. If <em>p1</em> evaluates to <tt>True</tt>, then evaluate the expression <em>e1</em>, and return that value.  If not, evaluate <em>p2</em>, and if it is <tt>True</tt>, return the value of <em>e2</em>, and so on.  If none of the <em>pj</em> evaluates to <tt>True</tt>, then the <tt>(cond ...)</tt> expression is undefined.</p>
<p>That&#39;s all the Lisp we&#39;re going to need to write our version of Lisp-as-Maxwell&#39;s-equations, i.e., our version of the code on page 13 of the LISP Manual!  In fact, as we&#39;ll see shortly, it&#39;s more than we need - I included a few extra features so that we could work through examples like <tt>sqrt</tt>, and also simply for fun, to make tiddlylisp a richer and more interesting language to play with.  Of course, what I&#39;ve described is merely a subset (with some variations) of our chosen dialect of Lisp (Scheme), and there are important missing ideas.  To learn more about Lisp or Scheme, please consult the suggestions for further reading at the end of this essay.</p>
<h3>An interpreter for Lisp</h3>
<p>Now that we&#39;ve worked through the basic elements of Lisp, let&#39;s write a simple Lisp interpreter, using Python.  The interpreter we&#39;ll write is based on <a href="http://norvig.com/">Peter Norvig</a>&#39;s lispy interpreter, and I highly recommend you read through <a href="http://norvig.com/lispy.html">his explanation</a>.  I&#39;ve given the program we&#39;ll discuss a separate name - tiddlylisp - so as to make it easy to refer to separately from Norvig&#39;s interpreter, but please keep in mind that most of the code we&#39;re discussing is Norvig&#39;s. However, we&#39;re going to examine the code from a different angle than Norvig: we&#39;re going to take a bit more of a bottom-up computer&#39;s-eye view, looking at how the code executes.</p>
<p>We&#39;ll look at the code piece by piece, before putting it all together. Let&#39;s start with the interactive interpreter, which is run when you start up.  We implement this with a Python procedure called <tt>repl</tt>, meaning to <em>r</em>ead some input, <em>e</em>valuate the expression, <em>p</em>rint the result of the evaluation, and then <em>l</em>oop back to the beginning.  This is also know as the read-eval-print loop, or REPL.  Here&#39;s the <tt>repl</tt> procedure, together with a procedure for handling errors when they occur: </p>
<pre>import traceback

def repl(prompt=&#39;tiddlylisp&gt; &#39;):
    &#34;A prompt-read-eval-print loop.&#34;
    while True:
        try:
            val = eval(parse(raw_input(prompt)))
            if val is not None: print to_string(val)
        except KeyboardInterrupt:
            print &#34;\nExiting tiddlylisp\n&#34;
            sys.exit()
        except:
            handle_error()

def handle_error():
    &#34;&#34;&#34;
    Simple error handling for both the repl and load.
    &#34;&#34;&#34;
    print &#34;An error occurred.  Here&#39;s the Python stack trace:\n&#34;
    traceback.print_exc()
</pre>
<p> The core of <tt>repl</tt> is in the <tt>try</tt> clause, and we&#39;ll get to how that works shortly.  Before we look at that, note that if the user presses <tt>Ctrl-C</tt>, it raises the <tt>KeyboardInterrupt</tt> exception, which causes the program to exit.  If an error occurs during the <tt>try</tt> block -- say, due to a syntax error in the Lisp expression being parsed, or due to a bug in tiddlylisp itself - then some other exception will be raised.  Tiddlylisp doesn&#39;t deal very well with errors - it simply announces that an error has occurred, and prints the Python stack trace, which may give you a few hints about what&#39;s gone wrong, but which is obviously a long way short of truly informative error handling!  After printing the stack trace, tiddlylisp simply returns to the prompt.  This type of error handling could easily be improved, but we&#39;re not going to invest any effort in this direction.</p>
<p>Let&#39;s look at the <tt>try</tt> clause.  It begins by taking input at the <tt>prompt</tt>, and then passing it to the function <tt>parse</tt>, which converts the string entered by the user into an <em>internal   representation</em>, i.e., a data structure that&#39;s more convenient for our Python program to work with than a string.  Here&#39;s an example which shows how it works: </p>
<pre>parse(&#34;(* (+ 7 12) (- 8 6))&#34;) = [&#34;*&#34;, [&#34;+&#34;, 7, 12], [&#34;-&#34;, 8, 6]]
</pre>
<p> In other words, nested Lisp lists become Python sublists, and things like procedures and numbers become elements in a Python list.</p>
<p>We&#39;ll look shortly at how <tt>parse</tt> is implemented.  For now, let&#39;s finish understanding how <tt>repl</tt> works.  The output of <tt>parse</tt> is passed to the function <tt>eval</tt>, which evaluates the internal representation of the expression entered by the user. Provided no error occurs, the result is returned in <tt>val</tt>. However, <tt>val</tt> is in the format of the internal representation, and so we need to convert it from that internal representation back into a printable Lisp expression, using <tt>to_string</tt>.</p>
<p>At this point, we&#39;ve got three functions to understand the details of: <tt>parse</tt>, <tt>eval</tt> and <tt>to_string</tt>.  I&#39;ll explain them out of order, starting with <tt>parse</tt> and <tt>to_string</tt>, since they&#39;re extremely similar.  Then we&#39;ll get to <tt>eval</tt>.</p>
<p>Alright, let&#39;s understand how <tt>parse</tt> works.  Without further ado, here&#39;s the code; for the explanation, see below: </p>
<pre>Symbol = str

def parse(s):
    &#34;Parse a Lisp expression from a string.&#34;
    return read_from(tokenize(s))

def tokenize(s):
    &#34;Convert a string into a list of tokens.&#34;
    return s.replace(&#39;(&#39;,&#39; ( &#39;).replace(&#39;)&#39;,&#39; ) &#39;).split()

def read_from(tokens):
    &#34;Read an expression from a sequence of tokens.&#34;
    if len(tokens) == 0:
        raise SyntaxError(&#39;unexpected EOF while reading&#39;)
    token = tokens.pop(0)
    if &#39;(&#39; == token:
        L = []
        while tokens[0] != &#39;)&#39;:
            L.append(read_from(tokens))
        tokens.pop(0) # pop off &#39;)&#39;
        return L
    elif &#39;)&#39; == token:
        raise SyntaxError(&#39;unexpected )&#39;)
    else:
        return atom(token)

def atom(token):
    &#34;Numbers become numbers; every other token is a symbol.&#34;
    try: return int(token)
    except ValueError:
        try: return float(token)
        except ValueError:
            return Symbol(token)
</pre>
<p> The parsing is easy to understand.  <tt>tokenize</tt> first inserts spaces on either side of any parentheses, and then splits the string around spaces, returning a list of tokens, i.e., the non-space substrings.  <tt>read_from</tt> takes that list and removes the parentheses, instead nesting sublists as indicated by the original parenthesis structure.  And, finally, <tt>atom</tt> turns tokens into Python <tt>int</tt>s, <tt>float</tt>s or <tt>Symbol</tt>s (strings, by definition), as appropriate.</p>
<p>That&#39;s all there is to <tt>parse</tt>.  If tiddlylisp were a little more powerful then <tt>parse</tt> would need to be more complex.  For example, if we allowed strings as first-class objects in the language, then it would not work to tokenize by splitting around spaces, since that would risk splitting a string into separate tokens.  This is the kind of thing that&#39;d be fun to include in an extended version of tiddlylisp (and I&#39;ve included it as a problem later in this section), but which we don&#39;t need in a first version.</p>
<p>Let&#39;s look now at how <tt>to_string</tt> works.  It&#39;s much simpler, quickly undoing the steps taken in parsing: </p>
<pre>isa = isinstance

def to_string(exp):
    &#34;Convert a Python object back into a Lisp-readable string.&#34;
    if not isa(exp, list):
        return str(exp)
    else:
        return &#39;(&#39;+&#39; &#39;.join(map(to_string, exp))+&#39;)&#39;
</pre>
<p> In other words, if the internal representation of the expression is not a list, then return an appropriate stringified version (this takes care of the fact that we may have <tt>int</tt>s, <tt>float</tt>s and, as we shall see, <tt>Boolean</tt>s in the internal representation).  If it is a list, then return whatever we get by applying <tt>to_string</tt> to all the elements of that list, with appropriate delimiting by whitespace and parentheses.</p>
<p>At this point, the main thing we need to complete tiddlylisp is the <tt>eval</tt> function.  Actually, that&#39;s not quite true: as we discussed earlier, tiddlylisp also keeps track of a global environment (and possibly one or more inner environments), to store variable and procedure names, and their values.  <tt>eval</tt> is going to make heavy use of the environments, and so it helps to look first at how environments are defined.  They&#39;re pretty simple: an environment has a bunch of keys, representing the names of the variables and procedures in that environment, and corresponding values for those keys, which are just the values for the variables or procedures.  An environment also keeps track of its outer environment, with the caveat that the global environment has an outer environment set to Python&#39;s <tt>None</tt>.  Such environments are easily implemented as a subclass of Python dictionaries: </p>
<pre>class Env(dict):
    &#34;An environment: a dict of {&#39;var&#39;:val} pairs, with an outer Env.&#34;

    def __init__(self, params=(), args=(), outer=None):
        self.update(zip(params, args))
        self.outer = outer

    def find(self, var):
        &#34;Find the innermost Env where var appears.&#34;
        return self if var in self else self.outer.find(var)
</pre>
<p> As you can see, the only modifications of the dictionary class are that: (1) an environment also keeps track of its own outer environment; and (2) an environment can determine whether a variable or procedure name appears in its list of keys, and if it doesn&#39;t, then it looks to see if it&#39;s in its outer environment.  As a result, the <tt>find</tt> method returns the innermost environment where the variable or procedure name appears.  </p>
<p>Note, incidentally, that the environment doesn&#39;t distinguish between variable and procedure names.  Indeed, as we&#39;ll see, tiddlylisp treats user-defined procedures and variables in the same way: a procedure is a variable which just happens to take the value of a <tt>lambda</tt> expression as its value.</p>
<p>Tiddlylisp starts off operating in a particular global environment, and this too must be defined by our program.  We&#39;ll do this by creating an instance of the class <tt>Env</tt>, and calling a function to add some built-in procedure definitions and variables: </p>
<pre>def add_globals(env):
    &#34;Add some built-in procedures and variables to the environment.&#34;
    import operator
    env.update(
        {&#39;+&#39;: operator.add,
         &#39;-&#39;: operator.sub, 
         &#39;*&#39;: operator.mul, 
         &#39;/&#39;: operator.div, 
         &#39;&gt;&#39;: operator.gt, 
         &#39;&lt;&#39;: operator.lt, 
         &#39;&gt;=&#39;: operator.ge, 
         &#39;&lt;=&#39;: operator.le, 
         &#39;=&#39;: operator.eq
         })
    env.update({&#39;True&#39;: True, &#39;False&#39;: False})
    return env

global_env = add_globals(Env())
</pre>
<p> Incidentally, in tiddlylisp&#39;s version of <tt>add_globals</tt> I decided to strip out many of the built-in procedures which Norvig includes in lispy&#39;s global environment - it&#39;s instructive to look at <a href="http://norvig.com/lis.py">Norvig&#39;s code</a> for <tt>add_globals</tt> to see just how easy it is to add more built-in procedures to tiddlylisp.  If you want to do some exploratory programming with tiddlylisp then you should probably copy some of Norvig&#39;s additional built-in procedures (and perhaps add some of your own).  For us, though, the above procedures are enough.</p>
<p>One notable feature of the global environment is the variables named <tt>True</tt> and <tt>False</tt>, which evaluate to Python&#39;s Boolean <tt>True</tt> and <tt>False</tt>, respectively.  This isn&#39;t standard in Scheme (or most other Lisps), but I&#39;ve done it because it ensures that we can use the strings <tt>True</tt> and <tt>False</tt>, and get the appropriate internal representation.</p>
<p>With the global environment set up, we can now understand how <tt>eval</tt> works.  The code is extremely simple, simply enumerating the different types of expressions we might be evaluating, and reading from or modifying the environment, as appropriate.  It&#39;s worth reading (and rereading) the code in detail, until you understand exactly how <tt>eval</tt> works.  I also have a few comments at the end.  Here&#39;s the code: </p>
<pre>isa = isinstance

def eval(x, env=global_env):
    &#34;Evaluate an expression in an environment.&#34;
    if isa(x, Symbol):              # variable reference
        return env.find(x)[x]
    elif not isa(x, list):          # constant literal
        return x                
    elif x[0] == &#39;quote&#39; or x[0] == &#39;q&#39;: # (quote exp), or (q exp)
        (_, exp) = x
        return exp
    elif x[0] == &#39;atom?&#39;:           # (atom? exp)
        (_, exp) = x
        return not isa(eval(exp, env), list)
    elif x[0] == &#39;eq?&#39;:             # (eq? exp1 exp2)
        (_, exp1, exp2) = x
        v1, v2 = eval(exp1, env), eval(exp2, env)
        return (not isa(v1, list)) and (v1 == v2)
    elif x[0] == &#39;car&#39;:             # (car exp)
        (_, exp) = x
        return eval(exp, env)[0]
    elif x[0] == &#39;cdr&#39;:             # (cdr exp)
        (_, exp) = x
        return eval(exp, env)[1:]
    elif x[0] == &#39;cons&#39;:            # (cons exp1 exp2)
        (_, exp1, exp2) = x
        return [eval(exp1, env)]+eval(exp2,env)
    elif x[0] == &#39;cond&#39;:            # (cond (p1 e1) ... (pn en))
        for (p, e) in x[1:]:
            if eval(p, env): 
                return eval(e, env)
    elif x[0] == &#39;null?&#39;:           # (null? exp)
        (_, exp) = x
        return eval(exp,env) == []
    elif x[0] == &#39;if&#39;:              # (if test conseq alt)
        (_, test, conseq, alt) = x
        return eval((conseq if eval(test, env) else alt), env)
    elif x[0] == &#39;set!&#39;:            # (set! var exp)
        (_, var, exp) = x
        env.find(var)[var] = eval(exp, env)
    elif x[0] == &#39;define&#39;:          # (define var exp)
        (_, var, exp) = x
        env[var] = eval(exp, env)
    elif x[0] == &#39;lambda&#39;:          # (lambda (var*) exp)
        (_, vars, exp) = x
        return lambda *args: eval(exp, Env(vars, args, env))
    elif x[0] == &#39;begin&#39;:           # (begin exp*)
        for exp in x[1:]:
            val = eval(exp, env)
        return val
    else:                           # (proc exp*)
        exps = [eval(exp, env) for exp in x]
        proc = exps.pop(0)
        return proc(*exps)
</pre>
<p> Mostly this is self-explanatory.  But allow me to draw your attention to how Norvig deals with anonymous procedure definitions using <tt>lambda</tt>.  When I first examined his code I wondered how he&#39;d cope with this, and expected it would be quite complex.  But as you can see, it is extremely simple: <tt>lambda</tt> expressions evaluate to the appropriate anonymous Python function, with a new environment modified by the addition of the appropriate variable keys, and their values.  Beautiful!</p>
<p>Tiddlylisp is essentially complete at this point.  It&#39;s convenient to finish off the program by providing two ways of running tiddlylisp: either in an interactive interpreter mode, i.e., the REPL, or by loading a tiddlylisp program stored in a separate file.  To start the REPL, we&#39;ll simply run <tt>python tiddlylisp.py</tt>.  To load and execute a file, we&#39;ll run <tt>python tiddlylisp.py </tt><em>filename</em>. After execution, we&#39;d like to be dropped into the REPL so we can inspect results and do further experiments.  The main complication in doing this is the need to load tiddlylisp code which is split over multiple lines.  We do this by merging lines until the number of opening and closing parentheses match.  Here&#39;s the code - it&#39;s best to start at the bottom, with the code immediately after <tt>if __name__ == &#34;__main__&#34;</tt>: </p>
<pre>import sys

def load(filename):
    &#34;&#34;&#34;
    Load the tiddlylisp program in filename, execute it, and start the
    repl.  If an error occurs, execution stops, and we are left in the
    repl.  Note that load copes with multi-line tiddlylisp code by
    merging lines until the number of opening and closing parentheses
    match.
    &#34;&#34;&#34;
    print &#34;Loading and executing 
    f = open(filename, &#34;r&#34;)
    program = f.readlines()
    f.close()
    rps = running_paren_sums(program)
    full_line = &#34;&#34;
    for (paren_sum, program_line) in zip(rps, program):
        program_line = program_line.strip()
        full_line += program_line+&#34; &#34;
        if paren_sum == 0 and full_line.strip() != &#34;&#34;:
            try:
                val = eval(parse(full_line))
                if val is not None: print to_string(val)
            except:
                handle_error()
                print &#34;\nThe line in which the error occurred:\n
                break
            full_line = &#34;&#34;
    repl()

def running_paren_sums(program):
    &#34;&#34;&#34;
    Map the lines in the list program to a list whose entries contain
    a running sum of the per-line difference between the number of &#39;(&#39;
    parentheses and the number of &#39;)&#39; parentheses.
    &#34;&#34;&#34;
    count_open_parens = lambda line: line.count(&#34;(&#34;)-line.count(&#34;)&#34;)
    paren_counts = map(count_open_parens, program)
    rps = []
    total = 0
    for paren_count in paren_counts:
        total += paren_count
        rps.append(total)
    return rps

if __name__ == &#34;__main__&#34;:
    if len(sys.argv) &gt; 1: 
        load(sys.argv[1])
    else: 
        repl()
</pre>
<p>That completes the code for tiddlylisp!  A grand total of 153 lines of non-comment, non-whitespace code.  Here it all is, in one big block (commented and slightly reordered), so you can see how the pieces fit together: </p>
<pre>#### tiddlylisp.py
#
# Based on Peter Norvig&#39;s lispy (http://norvig.com/lispy.html),
# copyright by Peter Norvig, 2010.
#
# Adaptations by Michael Nielsen.  See
# https://michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/

import sys
import traceback

#### Symbol, Env classes

Symbol = str

class Env(dict):
    &#34;An environment: a dict of {&#39;var&#39;:val} pairs, with an outer Env.&#34;

    def __init__(self, params=(), args=(), outer=None):
        self.update(zip(params, args))
        self.outer = outer

    def find(self, var):
        &#34;Find the innermost Env where var appears.&#34;
        return self if var in self else self.outer.find(var)

def add_globals(env):
    &#34;Add some built-in procedures and variables to the environment.&#34;
    import operator
    env.update(
        {&#39;+&#39;: operator.add,
         &#39;-&#39;: operator.sub, 
         &#39;*&#39;: operator.mul, 
         &#39;/&#39;: operator.div, 
         &#39;&gt;&#39;: operator.gt, 
         &#39;&lt;&#39;: operator.lt, 
         &#39;&gt;=&#39;: operator.ge, 
         &#39;&lt;=&#39;: operator.le, 
         &#39;=&#39;: operator.eq
         })
    env.update({&#39;True&#39;: True, &#39;False&#39;: False})
    return env

global_env = add_globals(Env())

isa = isinstance

#### eval

def eval(x, env=global_env):
    &#34;Evaluate an expression in an environment.&#34;
    if isa(x, Symbol):              # variable reference
        return env.find(x)[x]
    elif not isa(x, list):          # constant literal
        return x                
    elif x[0] == &#39;quote&#39; or x[0] == &#39;q&#39;: # (quote exp), or (q exp)
        (_, exp) = x
        return exp
    elif x[0] == &#39;atom?&#39;:           # (atom? exp)
        (_, exp) = x
        return not isa(eval(exp, env), list)
    elif x[0] == &#39;eq?&#39;:             # (eq? exp1 exp2)
        (_, exp1, exp2) = x
        v1, v2 = eval(exp1, env), eval(exp2, env)
        return (not isa(v1, list)) and (v1 == v2)
    elif x[0] == &#39;car&#39;:             # (car exp)
        (_, exp) = x
        return eval(exp, env)[0]
    elif x[0] == &#39;cdr&#39;:             # (cdr exp)
        (_, exp) = x
        return eval(exp, env)[1:]
    elif x[0] == &#39;cons&#39;:            # (cons exp1 exp2)
        (_, exp1, exp2) = x
        return [eval(exp1, env)]+eval(exp2,env)
    elif x[0] == &#39;cond&#39;:            # (cond (p1 e1) ... (pn en))
        for (p, e) in x[1:]:
            if eval(p, env): 
                return eval(e, env)
    elif x[0] == &#39;null?&#39;:           # (null? exp)
        (_, exp) = x
        return eval(exp,env) == []
    elif x[0] == &#39;if&#39;:              # (if test conseq alt)
        (_, test, conseq, alt) = x
        return eval((conseq if eval(test, env) else alt), env)
    elif x[0] == &#39;set!&#39;:            # (set! var exp)
        (_, var, exp) = x
        env.find(var)[var] = eval(exp, env)
    elif x[0] == &#39;define&#39;:          # (define var exp)
        (_, var, exp) = x
        env[var] = eval(exp, env)
    elif x[0] == &#39;lambda&#39;:          # (lambda (var*) exp)
        (_, vars, exp) = x
        return lambda *args: eval(exp, Env(vars, args, env))
    elif x[0] == &#39;begin&#39;:           # (begin exp*)
        for exp in x[1:]:
            val = eval(exp, env)
        return val
    else:                           # (proc exp*)
        exps = [eval(exp, env) for exp in x]
        proc = exps.pop(0)
        return proc(*exps)

#### parsing

def parse(s):
    &#34;Parse a Lisp expression from a string.&#34;
    return read_from(tokenize(s))

def tokenize(s):
    &#34;Convert a string into a list of tokens.&#34;
    return s.replace(&#39;(&#39;,&#39; ( &#39;).replace(&#39;)&#39;,&#39; ) &#39;).split()

def read_from(tokens):
    &#34;Read an expression from a sequence of tokens.&#34;
    if len(tokens) == 0:
        raise SyntaxError(&#39;unexpected EOF while reading&#39;)
    token = tokens.pop(0)
    if &#39;(&#39; == token:
        L = []
        while tokens[0] != &#39;)&#39;:
            L.append(read_from(tokens))
        tokens.pop(0) # pop off &#39;)&#39;
        return L
    elif &#39;)&#39; == token:
        raise SyntaxError(&#39;unexpected )&#39;)
    else:
        return atom(token)

def atom(token):
    &#34;Numbers become numbers; every other token is a symbol.&#34;
    try: return int(token)
    except ValueError:
        try: return float(token)
        except ValueError:
            return Symbol(token)

def to_string(exp):
    &#34;Convert a Python object back into a Lisp-readable string.&#34;
    if not isa(exp, list):
        return str(exp)
    else:
        return &#39;(&#39;+&#39; &#39;.join(map(to_string, exp))+&#39;)&#39;         

#### Load from a file and run

def load(filename):
    &#34;&#34;&#34;
    Load the tiddlylisp program in filename, execute it, and start the
    repl.  If an error occurs, execution stops, and we are left in the
    repl.  Note that load copes with multi-line tiddlylisp code by
    merging lines until the number of opening and closing parentheses
    match.
    &#34;&#34;&#34;
    print &#34;Loading and executing 
    f = open(filename, &#34;r&#34;)
    program = f.readlines()
    f.close()
    rps = running_paren_sums(program)
    full_line = &#34;&#34;
    for (paren_sum, program_line) in zip(rps, program):
        program_line = program_line.strip()
        full_line += program_line+&#34; &#34;
        if paren_sum == 0 and full_line.strip() != &#34;&#34;:
            try:
                val = eval(parse(full_line))
                if val is not None: print to_string(val)
            except:
                handle_error()
                print &#34;\nThe line in which the error occurred:\n
                break
            full_line = &#34;&#34;
    repl()

def running_paren_sums(program):
    &#34;&#34;&#34;
    Map the lines in the list program to a list whose entries contain
    a running sum of the per-line difference between the number of &#39;(&#39;
    parentheses and the number of &#39;)&#39; parentheses.
    &#34;&#34;&#34;
    count_open_parens = lambda line: line.count(&#34;(&#34;)-line.count(&#34;)&#34;)
    paren_counts = map(count_open_parens, program)
    rps = []
    total = 0
    for paren_count in paren_counts:
        total += paren_count
        rps.append(total)
    return rps

#### repl

def repl(prompt=&#39;tiddlylisp&gt; &#39;):
    &#34;A prompt-read-eval-print loop.&#34;
    while True:
        try:
            val = eval(parse(raw_input(prompt)))
            if val is not None: print to_string(val)
        except KeyboardInterrupt:
            print &#34;\nExiting tiddlylisp\n&#34;
            sys.exit()
        except:
            handle_error()

#### error handling

def handle_error():
    &#34;&#34;&#34;
    Simple error handling for both the repl and load.
    &#34;&#34;&#34;
    print &#34;An error occurred.  Here&#39;s the Python stack trace:\n&#34;
    traceback.print_exc()

#### on startup from the command line

if __name__ == &#34;__main__&#34;:
    if len(sys.argv) &gt; 1: 
        load(sys.argv[1])
    else: 
        repl()
</pre>
<h3>Problems</h3>
<ul>
<li> Modify tiddlylisp so that the <tt>+</tt> procedure can be applied to   any number of arguments, e.g., so that <tt>(+ 1 2 3)</tt> evaluates to   <tt>6</tt>.
</li><li> Earlier we implemented a square root procedure in tiddlylisp.   Can you add it directly to tiddlylisp, using the Python <tt>math</tt>   module&#39;s <tt>sqrt</tt> function?
</li><li> In our earlier implementation of the <tt>sqrt</tt> procedure we   discussed the ordering of the lines of code, and whether it&#39;s okay   to define a procedure in terms of some other yet-to-be-defined   procedure.  Examine the code for tiddlylisp, and explain why it&#39;s   okay for a procedure such as <tt>sqrt</tt> to be defined in terms of a   procedure such as <tt>sqrt-iter</tt> which isn&#39;t defined until later.   Try doing the same thing with variables, e.g., try running   <tt>(define x y)</tt> followed by <tt>(define y 1)</tt>.  Does this   work?  If so, why?  If not, why not?
</li><li> Modify tiddlylisp so that when applied to one argument the   <tt>-</tt> procedure simply negates it, e.g., <tt>(- 2)</tt> returns   <tt>-2</tt>, while <tt>-</tt> still computes differences when applied to   two arguments.
</li><li> Is it possible to write a pure tiddlylisp procedure <tt>minus</tt> so   that <tt>(minus x)</tt> returns <tt>-x</tt>, while <tt>(minus x y)</tt>   returns <tt>x-y</tt>?
</li><li> In the discussion where we introduced <tt>cond</tt> I stated that   <tt>(cond (</tt><em>p1 e1</em><tt>)...(</tt><em>pn en</em><tt>))</tt> is   undefined when none of the expressions <em>p1...pn</em> evaluate to   <tt>True</tt>.  What does Tiddlylisp return in this case?  Can you   think of a better way of dealing with this situation?
</li><li> Can you add support for strings to tiddlylisp?
</li></ul>
<p>When I first examined Norvig&#39;s code for lispy, I was surprised by just how much I learned from his code.  Of course, I expected to learn quite a bit - I am just a beginner at Lisp - but what I learned greatly exceeded my expectations.  Why might writing an interpreter deepen our understanding of a programming language?  I think the answer has to do with how we understand abstractions.  Consider the way I first explained the concept of Lisp environments, early in this essay: I gave a general discussion of the concept, and then related it to several of the examples we were working through.  This is the usual way we cope with abstractions when learning (or teaching) a language: we make those abstractions concrete by working through code examples that illustrates the consequences of those abstractions.  The problem is that although I can show you examples, the abstraction itself remains ephemeral.</p>
<p>Writing an interpreter is a way of making a programming language&#39;s abstractions concrete.  I can show you a million examples illustrating consequences of the Lisp environment, but none will have quite the same concrete flavour as the code for our Python Lisp interpreter. That code shows explicitly how the environment can be represented as a data structure, how it is manipulated by commands such as <tt>define</tt>, and so on.  And so writing an interpreter is a way of reifying abstractions in the programming language being interpreted.</p>
<h3>Problems</h3>
<ul>
<li> I gave the example of the environment as a Lisp abstraction   which is made more concrete when you understand the code for the   interpreter.  Another example of an abstraction is errors in code.   Can you improve tiddlylisp&#39;s error handling so that we get something   more informative than a Python stack trace when something goes   wrong?  One suggestion for how to do this is to identify two (or   more) classes of error that may occur in tiddlylisp programs, and to   modify the interpreter so it catches and gracefully handles those   error classes, printing informative error messages. </li></ul>
<p>On Peter Norvig&#39;s webpage describing his interpreter, a few commenters take him to task for writing his interpreter in Python.  Here&#39;s an <a href="http://norvig.com/lispy.html#comment-359244302">example</a> to give you the flavour of these comments: </p>
<blockquote><p>   This code looks very nice, but i think that implementing a Lisp   Interpreter in Python is some kind of cheating. Python is a   high-level language, so you get very much for free. </p></blockquote>
<p> Norvig <a href="http://norvig.com/lispy.html#comment-359339548">replies</a>: </p>
<blockquote><p>   You are right -- we are relying on many features of Python: call   stack, data types, garbage collection, etc. The next step would be   to show a compiler to some sort of assembly language.  I think   either the Java JVM or the Python byte code would be good targets.   We&#39;d also need a runtime system with GC. I show the compiler in my   <a href="http://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910">PAIP     [Paradigms of Artificial Intelligence] book</a>. </p></blockquote>
<p> The commenter and Norvig are right, in some sense.  But there&#39;s also a sense in which the Python interpreter achieves something that would not be achieved by a program that compiled Lisp to the Java JVM, or to assembler, or some other target closer to the bare metal.  That&#39;s because of all programming languages, Python is one of the closest to an ordinary human language.  And so writing a Lisp interpreter in Python is an exceptionally clear way of explaining how Lisp works to a human who doesn&#39;t yet understand the core concepts of Lisp.  Insofar as I can guess at Norvig&#39;s intention, I believe the code for his interpreter is primarily intended to be read by humans, and the fact that it can also be read by a computer is a design constraint, not the fundamental purpose [3].</p>
<p>It seems to me that the kind of comment above arises because there are really three natural variations on the question &#34;How to explain Lisp?&#34;.  All three variations are interesting, and worth answering; all three have different answers.  The first variation is how to explain Lisp to a person who doesn&#39;t yet know Lisp.  As I&#39;ve just argued, a good answer to this question is to work through some examples, and then to write a simple Python interpreter.  The second variation is how to explain Lisp to a machine.  That&#39;s the question the commenter on Norvig&#39;s blog is asking, and to answer that question nothing beats writing a Lisp interpreter (or compiler) that works close to the bare metal, say in assembler, requiring you to deal explicitly with memory allocation, garbage collection, and so on.</p>
<p>But there&#39;s also a third variation on the question.  And that&#39;s how best to explain Lisp to someone who <em>already</em> understands the core concepts of Lisp.  That sounds paradoxical: doesn&#39;t such a person, by definition, already understand Lisp?  But it&#39;s not paradoxical at all.  Consider the following experience which many people have when learning (or teaching) mathematics.  The best way to explain a mathematical idea to someone new to the idea is using their old language and their old way of looking at the world.  This is like explaining Lisp by writing a Python interpreter.  But once the person has grasped a transformative new mathematical idea, they can often deepen their understanding by re-examining that idea within their new way of looking at the world.  That re-examination can help crystallize a deeper understanding.  In a similar way, while writing a Lisp interpreter in Python may be a good way of explaining Lisp to a person who doesn&#39;t yet understand Lisp, someone who grasps the core ideas of Lisp may find the Python interpreter a little clunky.  How should we explain Lisp within the framework of Lisp itself?  One answer to that question is to use Lisp to write a Lisp interpreter.  It&#39;s to that task that we now turn.</p>
<h3>Lisp in Lisp</h3>
<p>How should we write a Lisp interpreter in Lisp?  Let&#39;s think back to what Alan Kay saw at the bottom of page 13 of the LISP Manual:</p>
<p><a href="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png"><img src="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png" alt="" title="Lisp_Maxwells_Equations" width="480" srcset="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png 555w, https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations-291x300.png 291w" sizes="(max-width: 555px) 100vw, 555px"/></a></p>
<p>Although it&#39;s written in a different notation than we&#39;ve used, this is Lisp code.  In fact, it&#39;s the core of a Lisp interpreter written in Lisp: the procedure <tt>evalquote</tt> takes a Lisp expression as input, and then returns the value of that expression.  In this section we&#39;re going to use tiddlylisp to write an analogue to <tt>evalquote</tt> (we&#39;ll change the name to <tt>eval</tt>).  Of course, such a procedure is not really a full interpreter - we won&#39;t have a read-eval-print loop, for one thing - but it&#39;s not difficult to extend our code to a full interpreter (it requires a few additions to tiddlylisp, too). For this reason, in what follows I&#39;ll refer to our <tt>eval</tt> procedure as an &#34;interpreter&#34;, even though it&#39;s more accurate to say that it&#39;s the core of an interpreter.  I haven&#39;t made the extension to a full interpreter here, partly because I don&#39;t want to lengthen an already long essay, but mostly because I want to stick to the theme of the &#34;Maxwell&#39;s equations of software&#34;.  For the same reasons, I&#39;ve also limited our <tt>eval</tt> to interpreting only a subset of tiddlylisp, omitting the arithmetical operations and concentrating instead on procedures for manipulating lists.</p>
<p>My treatment in this section is based on a beautiful <a href="http://lib.store.yahoo.net/lib/paulgraham/jmc.ps">essay</a> (postscript) by Paul Graham, in which he explains what the original designer of Lisp, John McCarthy, was up to in <a href="http://www-formal.stanford.edu/jmc/recursive.html">the paper</a> where he introduced Lisp.  In his essay, Graham writes a fully executable Lisp interpreter in one of the modern dialects of Lisp, Common Lisp, and I&#39;ve based much of my code on Graham&#39;s.  Perhaps the main difference in my treatment is that while Graham&#39;s <tt>eval</tt> is written to be run under Common Lisp, our <tt>eval</tt> is executable in tiddlylisp, an interpreter for Lisp that we&#39;ve written ourselves (with lots of help from Peter Norvig!)  So even though the code is very similar, the perspective is quite diferent, and I think we gain something from this different perspective.</p>
<p>The code we&#39;ll write is longer than what you see on page 13 of the LISP Manual.  The reason is that the code on page 13 was not actually self-contained, but made use of several procedures defined earlier in the LISP Manual, and we need to include those procedures.  The final result is still only a little over a page of code.  Let&#39;s start by defining a few of those helper procedures.</p>
<p><tt>(not </tt><em>exp</em><tt>)</tt> returns <tt>True</tt> if the expression <em>exp</em> evaluates to <tt>False</tt>, and otherwise returns <tt>False</tt>.  For example, </p>
<pre>tiddlylisp&gt; (not (atom? (q (1 2))))
True
tiddlylisp&gt; (not (eq? 1 (- 2 1)))
False
</pre>
<p> Here&#39;s the tiddlylisp code for <tt>not</tt>: </p>
<pre>(define not (lambda (x) (if x False True)))
</pre>
<p><tt>(append </tt><em>exp1 exp2</em><tt>)</tt> takes expressions <em>exp1</em> and <em>exp2</em> both of whose values are lists, and returns the list formed by concatenating those lists.  For example, </p>
<pre>tiddlylisp&gt; (append (q (1 2 3)) (q (4 5)))
(1 2 3 4 5)
</pre>
<p> Here&#39;s the tiddlylisp code for <tt>append</tt>: </p>
<pre>(define append (lambda (x y)
		 (if (null? x) y (cons (car x) (append (cdr x) y)))))
</pre>
<p><tt>(pair </tt><em>exp1 exp2</em><tt>)</tt> returns a two-element list whose elements are the value of <em>exp1</em> and the value of <em>exp2</em>: </p>
<pre>tiddlylisp&gt; (pair 1 2)
(1 2)
tiddlylisp&gt; (pair (+ 1 2) 1)
(3 1)
</pre>
<p> Here&#39;s the tiddlylisp code for <tt>pair</tt>: </p>
<pre>(define pair (lambda (x y) (cons x (cons y (q ()) ))))
</pre>
<p> Note that my use of <tt>pair</tt> is somewhat unconventional - the more usual approach in Lisp is to use <tt>(list </tt><em>exp1 exp2   exp3...</em><tt>)</tt> to construct a list whose values are just the values of the respective expressions.  The reason I haven&#39;t done this is because tiddlylisp doesn&#39;t allow us to define Lisp procedures with a variable number of arguments.  Note also that the procedure <tt>pair</tt> that I&#39;ve defined should not be confused with one of Scheme&#39;s standard procedures, <tt>pair?</tt>, which has a different purpose, and which we won&#39;t use in the current essay.</p>
<h3>Problems</h3>
<ul>
<li> Can you modify tiddlylisp so that <tt>(list </tt><em>exp1 exp2     exp3...</em><tt>)</tt> does indeed return a list whose values are just   the values of the respective expressions? </li></ul>
<p>I&#39;ll now introduce a class of helper procedures which are concatenations of two or more applications of <tt>car</tt> or <tt>cdr</tt>.  An example is the procedure <tt>cdar</tt>, which applies <tt>car</tt> first, followed by <tt>cdr</tt>, that is, <tt>(cdar </tt><em>exp</em><tt>)</tt> has the same value as <tt>(cdr (car </tt><em>exp</em><tt>))</tt>.  The notation <tt>cdar</tt> is a mnemonic, whose key elements are the middle two letters, <tt>d</tt> and <tt>a</tt>, indicating that <tt>cdar</tt> is what you get when you apply (in reverse order) <tt>cdr</tt> and <tt>car</tt>.  You might wonder why it&#39;s reverse order - the answer is that reverse order corresponds to the visual syntactic order, that is, the order from left-to-right that the procedures appear in the expression <tt>(cdr (car </tt><em>exp</em><tt>))</tt>.</p>
<p>As another example, the procedure <tt>caar</tt> is defined so that <tt>(caar </tt><em>exp</em><tt>)</tt> has the same value as <tt>(car (car </tt><em>exp</em><tt>))</tt>.  In our <tt>eval</tt> it&#39;ll be helpful to use several such procedures: </p>
<pre>(define caar (lambda (x) (car (car x))))
(define cadr (lambda (x) (car (cdr x))))
(define cadar (lambda (x) (cadr (car x))))
(define caddr (lambda (x) (cadr (cdr x))))
(define caddar (lambda (x) (caddr (car x))))
</pre>
<p>Our next helper procedure is called <tt>pairlis</tt>. <tt>(pairlis</tt><em> exp1 exp2</em><tt>)</tt> takes expressions <em>exp1</em> and <em>exp2</em> whose values are lists of the same length, and returns a list which is formed by pairing the values of corresponding elements.  For example, </p>
<pre>tiddlylisp&gt; (pairlis (q (1 2 3)) (q (4 5 6)))
((1 4) (2 5) (3 6))
</pre>
<p> Here&#39;s the tiddlylisp code for <tt>pairlis</tt>: </p>
<pre>(define pairlis 
    (lambda (x y)
      (if (null? x)
	  (q ())
	  (cons (pair (car x) (car y)) (pairlis (cdr x) (cdr y))))))
</pre>
<p>We&#39;ll call a list of pairs such as that produced by <tt>pairlis</tt> an <em>association list</em>.  It gets this name from our final helper procedure, the <tt>assoc</tt> procedure, which takes an association list and treats it as a lookup dictionary.  The easiest way to explain what this means is through an example, </p>
<pre>tiddlylisp&gt; (define a (pairlis (q (1 2 3)) (q (4 5 6))))
tiddlylisp&gt; a
((1 4) (2 5) (3 6))
tiddlylisp&gt; (assoc 2 a)
5
</pre>
<p> In other words, <tt>assoc</tt> looks for the key <tt>2</tt> as the first entry in one of the pairs in the list which is the value of <tt>a</tt>. Once it finds such a pair, it returns the second element in the pair.</p>
<p>Stated more abstractly, suppose the expression <em>exp1</em> has a value which appears as the first entry in one of the pairs in the association list which is the value of <em>exp2</em>.  Then <tt>(assoc </tt><em>exp1 exp2</em><tt>)</tt> returns the second entry of that pair.</p>
<p>After all that explanation, the code for <tt>assoc</tt> is extremely simple, simpler even than <tt>pairlis</tt>: </p>
<pre>(define assoc (lambda (x y)
		(if (eq? (caar y) x) (cadar y) (assoc x (cdr y)))))
</pre>
<p> I won&#39;t explain how <tt>assoc</tt> works, but if you&#39;re looking for a good exercise in applying <tt>caar</tt> and similar procedures, then it&#39;s worth spending some time to carefully understand how <tt>assoc</tt> works.</p>
<p>With all these helper procedures in place, we can now write our equivalent to the code on page 13 of the LISP Manual.  This includes both the core procedure, <tt>eval</tt>, together with a couple of extra helper procedures, <tt>evcon</tt> and <tt>evlis</tt>.  Here&#39;s the code: </p>
<pre>(define eval 
    (lambda (e a)
      (cond
	((atom? e) (assoc e a))
	((atom? (car e))
	 (cond
	   ((eq? (car e) (q car))   (car (eval (cadr e) a)))
	   ((eq? (car e) (q cdr))   (cdr (eval (cadr e) a)))
	   ((eq? (car e) (q cons))  (cons (eval (cadr e) a) (eval (caddr e) a)))
	   ((eq? (car e) (q atom?)) (atom? (eval (cadr e) a)))
	   ((eq? (car e) (q eq?))   (eq? (eval (cadr e) a) (eval (caddr e) a)))
	   ((eq? (car e) (q quote)) (cadr e))
	   ((eq? (car e) (q q))     (cadr e))
	   ((eq? (car e) (q cond))  (evcon (cdr e) a))
	   (True                   (eval (cons (assoc (car e) a) (cdr e)) a))))
	((eq? (caar e) (q lambda))
	 (eval (caddar e) (append (pairlis (cadar e) (evlis (cdr e) a)) a))))))

(define evcon 
    (lambda (c a)
      (cond ((eval (caar c) a) (eval (cadar c) a))
	    (True              (evcon (cdr c) a)))))

(define evlis 
    (lambda (m a)
      (cond ((null? m) (q ()))
	    (True     (cons (eval (car m) a) (evlis (cdr m) a))))))
</pre>
<p> Before we examine how <tt>eval</tt> works, I want to give you some examples of <tt>eval</tt> in action.  If you want, you can follow along with the examples by first loading the program defining <tt>eval</tt> into tiddlylisp (the full source is below), and then typing the examples into the interpreter.</p>
<p>To understand how to use <tt>eval</tt> in examples, we need to be clear about the meaning of its arguments.  <tt>e</tt> is a Lisp expression whose value is the Lisp expression that we want to evaluate with <tt>eval</tt>.  And <tt>a</tt> is a Lisp expression whose value is an association list, representing the environment.  In particular, the first element of each pair in <tt>a</tt> is the name of a variable or procedure, and the second element is the value of that variable or procedure.  I&#39;ll often refer to <tt>a</tt> just as the environment.</p>
<p>Suppose, for example, that we wanted to use <tt>eval</tt> to evaluate the expression <tt>(car (q (1 2)))</tt>.  We&#39;ll assume that we&#39;re evaluating it in the empty environment, that is, no variables or extra procedures have been defined.  Then we&#39;d need to pass <tt>eval</tt> expressions with values <tt>(car (q (1 2)))</tt> and <tt>()</tt>.  We can do this by quoting those values: </p>
<pre>tiddlylisp&gt; (eval (q (car (q (1 2)))) (q ()))
1
</pre>
<p> As you can see, we get the right result: <tt>1</tt>.</p>
<p>I explained in detail how to build up the expression <tt>(eval (q (car...)</tt> evaluated above.  But if we hadn&#39;t gone through that explanation, then the expression would have appeared quite of complicated, with lots of quoting going on.  The reason is that <tt>eval</tt> is evaluating an expression which is itself the value of another expression.  With so much evaluation going on it&#39;s no wonder there&#39;s many <tt>q</tt>&#39;s floating around!  But after working carefully through a few examples it all becomes transparent.</p>
<p>Here&#39;s an example showing how to use variables in the environment: </p>
<pre>tiddlylisp&gt; (eval (q (cdr x)) (q ((x (1 2 3)))))
(2 3)
</pre>
<p> Unpacking the quoting, we see that it&#39;s evaluating the expression <tt>(cdr x)</tt> in an environment with a variable <tt>x</tt> whose value is <tt>(1 2 3)</tt>.  The result is, of course, <tt>(2 3)</tt>.</p>
<p>Here&#39;s an example showing how to use a procedure which has been defined in the environment: </p>
<pre>tiddlylisp&gt; (eval (q (cddr (q (1 2 3 4 5)))) (q ((cddr (lambda (x) (cdr (cdr x)))))))
(3 4 5)
</pre>
<p> In other words, the environment stores a procedure <tt>cddr</tt> whose value is <tt>(lambda (x) (cdr (cdr x)))</tt>, and <tt>eval</tt> returns the result of applying <tt>cddr</tt> to an expression whose value is <tt>(1 2 3 4 5)</tt>.  Of course, this is just <tt>(3 4 5)</tt>.</p>
<p>We can also use <tt>eval</tt> to define and evaluate an anonymous procedure, in this case one that has the same effect as <tt>cadr</tt>: </p>
<pre>tiddlylisp&gt; (eval (q ((lambda (x) (car (cdr x))) (q (1 2 3 4)))) (q ()))
2
</pre>
<p>A significant drawback of <tt>eval</tt> is that it has a pretty limited Lisp vocabulary.  You can see this by running: </p>
<pre>tiddlylisp&gt; (eval (q (eq? 1 1)) (q (())))
<error message="">
</error></pre>
<p> The first line looks like perfectly valid Lisp - in fact, it is perfectly valid Lisp.  The problem is that <tt>eval</tt> doesn&#39;t recognize <tt>1</tt> - at the level of sophistication we&#39;re working it really only understands lists, variables, and procedures.  So what it tries to do is treat <tt>1</tt> as a variable or procedure to look up in the environment, <tt>a</tt>.  But <tt>1</tt> isn&#39;t in the environment, which is why there&#39;s an error message.</p>
<p>Fixing this problem by modifying <tt>eval</tt> isn&#39;t terribly difficult [4].  However, to stay close to the LISP Manual, I&#39;ll leave this as is.  A kludge to get around this issue is to add <tt>1</tt> as a key in the environment.  For example, we can use: </p>
<pre>tiddlylisp&gt; (eval (q (eq? 1 1)) (q ((1 1))))
True
tiddlylisp&gt; (eval (q (eq? 1 2)) (q ((1 1) (2 2))))
False
</pre>
<p> This is exactly as expected.  We didn&#39;t see this problem in our earlier examples of <tt>eval</tt>, simply because they involved list manipulations which didn&#39;t require us to evaluate numbers such as <tt>1</tt>.  Incidentally, here&#39;s an amusing variation on the above kludge: </p>
<pre>tiddlylisp&gt; (eval (q (eq? 1 2)) (q ((1 1) (2 1))))
True
</pre>
<p> In other words, if we tell our interpreter emphatically enough that <tt>1 = 2</tt> then it will start to believe it!  </p>
<p>Just to put <tt>eval</tt> through its paces, let&#39;s add a bundle of tests of basic functionality.  It&#39;s not an exhaustive test suite, but at least checks that the basic procedures are working as we expect.  You don&#39;t need to read through the following test code in exhaustive detail, although you should read at least the first few lines, to get a feeling for what&#39;s going on.  Note that in a few of the lines we need to add something like <tt>1</tt> or <tt>2</tt> to the environment, in order that <tt>eval</tt> be able to evaluate it, as occurred in the example just above. </p>
<pre>(define assert-equal (lambda (x y) (= x y)))

(define assert-not-equal (lambda (x y) (not (assert-equal x y))))

(assert-equal (eval (q x) (q ((x test-value))))
	      (q test-value))
(assert-equal (eval (q y) (q ((y (1 2 3)))))
	      (q (1 2 3)))
(assert-not-equal (eval (q z) (q ((z ((1) 2 3)))))
		  (q (1 2 3)))
(assert-equal (eval (q (quote 7)) (q ()))
	      (q 7))
(assert-equal (eval (q (atom? (q (1 2)))) (q ()))
	      False)
(assert-equal (eval (q (eq? 1 1)) (q ((1 1))))
	      True)
(assert-equal (eval (q (eq? 1 2)) (q ((1 1) (2 2))))
	      False)
(assert-equal (eval (q (eq? 1 1)) (q ((1 1))))
	      True)
(assert-equal (eval (q (car (q (3 2)))) (q ()))
	      (q 3))
(assert-equal (eval (q (cdr (q (1 2 3)))) (q ()))
	      (q (2 3)))
(assert-not-equal (eval (q (cdr (q (1 (2 3) 4)))) (q ()))
		  (q (2 3 4)))
(assert-equal (eval (q (cons 1 (q (2 3)))) (q ((1 1)(2 2)(3 3))))
	      (q (1 2 3)))
(assert-equal (eval (q (cond ((atom? x) (q x-atomic)) 
			     ((atom? y) (q y-atomic)) 
			     ((q True) (q nonatomic)))) 
		    (q ((x 1)(y (3 4)))))
	      (q x-atomic))
(assert-equal (eval (q (cond ((atom? x) (q x-atomic)) 
			     ((atom? y) (q y-atomic)) 
			     ((q True) (q nonatomic)))) 
		    (q ((x (1 2))(y 3))))
	      (q y-atomic))
(assert-equal (eval (q (cond ((atom? x) (q x-atomic)) 
			     ((atom? y) (q y-atomic)) 
			     ((q True) (q nonatomic)))) 
		    (q ((x (1 2))(y (3 4)))))
	      (q nonatomic))
(assert-equal (eval (q ((lambda (x) (car (cdr x))) (q (1 2 3 4)))) (q ()))
	      2)
</pre>
<p> In tiddlylisp, perhaps the easiest way to use this test code is to append it at the bottom of the file where we define <tt>eval</tt>. Then, when we load that file into memory, the tests run automatically. If everything is working properly, then all the tests should evaluate to <tt>True</tt>.</p>
<p>How does <tt>eval</tt> work?  Looking back at the code, we see that it&#39;s just a big <tt>cond</tt> statement, whose value is determined by which of various conditions evaluate to <tt>True</tt>.  The <tt>cond</tt> statement starts off: </p>
<pre>      (cond
	((atom? e) (assoc e a))
        ...
</pre>
<p> To understand what this accomplishes, it is helpful to remember that what we&#39;re most interested in is <em>the value</em> of <tt>e</tt>, not <tt>e</tt> itself.  Let&#39;s use <tt>e&#39;</tt> to denote the value of <tt>e</tt>, i.e., <tt>e&#39;</tt> is the Lisp expression that we actually want to evaluate using <tt>eval</tt>.  Then what the condition above does is check whether <tt>e&#39;</tt> is atomic, and if so it returns the value of the corresponding variable or procedure in the environment, exactly as we&#39;d expect.</p>
<p>Let&#39;s look at the next line in the big outer conditional statement: </p>
<pre>	((atom? (car e))
</pre>
<p> At this stage, we know that <tt>e&#39;</tt> isn&#39;t atomic, since we already checked for that, and so <tt>e&#39;</tt> must be a list.  This line checks to see whether the first element of <tt>e&#39;</tt> is itself an atom.  If it is, then there are multiple possibilities: it could be a special form, such as <tt>quote</tt>, or a built-in procedure, such as <tt>car</tt>, or else a procedure that&#39;s defined in the environment.  To check which of these possibilities is the case, we evaluate another (nested) conditional statement.  This just checks off the different cases, for instance the first line of the nested conditional checks to see if we&#39;re applying the procedure <tt>car</tt>, and if so proceeds appropriately, </p>
<pre>	   ((eq? (car e) (q car))   (car (eval (cadr e) a)))
</pre>
<p> In other words, if the first symbol in <tt>e&#39;</tt> is <tt>car</tt>, then extract whatever expression is being passed to <tt>car</tt>, using <tt>(cadr e)</tt>, then evaluate that expression using <tt>(eval (cadr e) a)</tt>, and finally extract the first element, using <tt>(car (eval...))</tt>.  That&#39;s exactly what we&#39;d expect <tt>car</tt> to do.  Most of the rest of this nested conditional statement works along similar lines, as you can check yourself.  The final line is interesting, and deserves comment: </p>
<pre>	   (True                   (eval (cons (assoc (car e) a) (cdr e)) a))))
</pre>
<p> This line is evaluated when the expression <tt>e&#39;</tt> does not start with a special form or built-in procedure, but instead starts with the name of a procedure defined in the environment.  To understand what is returned, note that <tt>(car e)</tt> retrieves the name of the procedure, so <tt>(assoc (car e) a)</tt> can retrieve the procedure from the environment, and then <tt>(cons (assoc (car e) a) (cdr e))</tt> appends the arguments to the procedure.  The whole thing is then evaluated.  It&#39;s all quite simple and elegant!</p>
<p>Moving back into the outer <tt>cond</tt> statement, the final condition is as follows: </p>
<pre>	((eq? (caar e) (q lambda))
	 (eval (caddar e) (append (pairlis (cadar e) (evlis (cdr e) a)) a))))))
</pre>
<p> This occurs when evaluating a quoted expression of the form <tt>((lambda (</tt><em>x...</em>|<tt>) </tt><em>exp</em><tt>)</tt>.  The first line simply checks that we are, indeed, seeing a <tt>lambda</tt> expression.  The <tt>caddar e</tt> extracts the expression <em>exp</em> from the body of the <tt>lambda</tt> expression.  We evaluate this in the context of an environment which has modified by <tt>append</tt>ing some new variable names (extracted with <tt>cadar e</tt>), using <tt>pairlis</tt> to pair them with their values, which are evaluated using <tt>evlis</tt> (which you can work through yourself).  Once again, it&#39;s all quite simple and neat - a fact which speaks to the marvellous elegance of the design presented in the LISP Manual (and, ultimately, due to John McCarthy).</p>
<p>It won&#39;t have escaped your attention that our Lisp <tt>eval</tt> is very similar to the <tt>eval</tt> we wrote earlier in Python.  Tiddlylisp is somewhat different to the dialect of Lisp our <tt>eval</tt> interprets, but the implementation is recognizably similar.  It is a matter of taste, but I think the Lisp implementation is more elegant.  It&#39;s true that the Lisp code is superficially a little more complex - it relies more on concepts outside our everyday experience, such as the procedures <tt>caar</tt>, <tt>cadar</tt>, and so on.  But it makes up for that by possessing a greater conceptual economy, in that we are using concepts such as <tt>car</tt>, <tt>cdr</tt> and <tt>cond</tt> to write an interpreter which understands those very same concepts.</p>
<p>Here&#39;s the full code for our Lisp interpreter in tiddlylisp.  You should append the test code given above, and save it all as a single file, <tt>eval.tl</tt>.   </p>
<pre>(define caar (lambda (x) (car (car x))))
(define cadr (lambda (x) (car (cdr x))))
(define cadar (lambda (x) (cadr (car x))))
(define caddr (lambda (x) (cadr (cdr x))))
(define caddar (lambda (x) (caddr (car x))))

(define not (lambda (x) (if x False True)))

(define append (lambda (x y)
		 (if (null? x) y (cons (car x) (append (cdr x) y)))))

(define pair (lambda (x y) (cons x (cons y (q ()) ))))

(define pairlis 
    (lambda (x y)
      (if (null? x)
	  (q ())
	  (cons (pair (car x) (car y)) (pairlis (cdr x) (cdr y))))))

(define assoc (lambda (x y)
		(if (eq? (caar y) x) (cadar y) (assoc x (cdr y)))))

(define eval 
    (lambda (e a)
      (cond
	((atom? e) (assoc e a))
	((atom? (car e))
	 (cond
	   ((eq? (car e) (q car))   (car (eval (cadr e) a)))
	   ((eq? (car e) (q cdr))   (cdr (eval (cadr e) a)))
	   ((eq? (car e) (q cons))  (cons (eval (cadr e) a) (eval (caddr e) a)))
	   ((eq? (car e) (q atom?)) (atom? (eval (cadr e) a)))
	   ((eq? (car e) (q eq?))   (eq? (eval (cadr e) a) (eval (caddr e) a)))
	   ((eq? (car e) (q quote)) (cadr e))
	   ((eq? (car e) (q q))     (cadr e))
	   ((eq? (car e) (q cond))  (evcon (cdr e) a))
	   (True                   (eval (cons (assoc (car e) a) (cdr e)) a))))
	((eq? (caar e) (q lambda))
	 (eval (caddar e) (append (pairlis (cadar e) (evlis (cdr e) a)) a))))))

(define evcon 
    (lambda (c a)
      (cond ((eval (caar c) a) (eval (cadar c) a))
	    (True              (evcon (cdr c) a)))))

(define evlis 
    (lambda (m a)
      (cond ((null? m) (q ()))
	    (True     (cons (eval (car m) a) (evlis (cdr m) a))))))
</pre>
<p>It&#39;s instructive to compare our <tt>eval</tt> to what Kay saw on page 13 of the LISP 1.5 Programmer&#39;s Manual:</p>
<p><a href="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png"><img src="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png" alt="" title="Lisp_Maxwells_Equations" width="480" srcset="https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations.png 555w, https://michaelnielsen.org/ddi/wp-content/uploads/2012/04/Lisp_Maxwells_Equations-291x300.png 291w" sizes="(max-width: 555px) 100vw, 555px"/></a></p>
<p>Obviously, what we&#39;ve written is longer than that half-page!  However, as I mentioned earlier, that half-page omitted the code for helper procedures such as <tt>caar</tt>, <tt>append</tt>, and so on, which were defined earlier in the LISP Manual. A more direct comparison is to our code for the <tt>eval, evcon</tt> and <tt>evlis</tt> procedures.</p>
<p>If you compare our code to the LISP Manual, a few differences jump out.  The most obvious is that the LISP Manual&#39;s <tt>evalquote, apply</tt> and <tt>eval</tt> have all been combined into one procedure.  This is a form of organization I adopted from Paul Graham&#39;s <tt>eval</tt>, and it makes it much easier to see what is going on, in the outer <tt>cond</tt>.  In particular, the outer <tt>cond</tt> has a very simple structure: (1) if the expression we&#39;re tring to evaluate is an atom, return its value; otherwise (2) the expression must be a list, so check to see if the first element is an atom, in which case it must be a special form or procedure, and should be evaluated appropriately (this is the inner <tt>cond</tt>); and otherwise (3) we must be dealing with a <tt>lambda</tt> expression.</p>
<p>Condition (3) is interesting.  With the syntax we&#39;re using, the condition in step (3) could simply be expressed as <tt>True</tt>, not <tt>(eq? (caar e) (q lambda)</tt>, since it&#39;s the only remaining possibility.  This would, in some sense, simplify (and speed up) the code.  However, it would also make it harder to understand the intent of the code.  </p>
<p>Something that you may note was present in the LISP Manual but which is missing from our <tt>eval</tt> is the special form <tt>label</tt>. <tt>label</tt> was used in the LISP Manual to give names to procedures, and so that procedure definitions could refer recursively to themselves.  It&#39;s only a couple of lines to add back in, but I haven&#39;t done so.  If you&#39;d like, it&#39;s a fun challenge to add this functionality back in, and so I&#39;ve given this as a problem below.</p>
<h3>Problems</h3>
<ul>
<li> How could you add a facility to <tt>eval</tt> so that procedure   definitions can refer to themselves?  If you&#39;re having trouble with   this problem, you can get a hint by looking at the code from page 13   of the LISP Manual. A complete solution to the problem may be found   in Paul Graham&#39;s   <a href="http://lib.store.yahoo.net/lib/paulgraham/jmc.ps">essay about     the roots of Lisp</a>. </li></ul>
<p>This is a nice little interpreter.  However, it has many limitations, even when compared to tiddlylisp.  It can&#39;t do basic arithmetic, doesn&#39;t cope with integers, much less more complicated data types, it doesn&#39;t even have a way of <tt>define</tt>ing variables (after all, it doesn&#39;t return a modified environment).  Still, it already contains many of the core concepts of Lisp, and it really is an executable counterpart to what Alan Kay saw on page 13 of the LISP 1.5 Manual.</p>
<p>What can we learn from this interpreter for Lisp in Lisp?  As an intellectual exercise, it&#39;s cute, but beyond that, so what?  Let&#39;s think about the analogous question for Python, i.e., writing a Python function that can return the value of Python expressions.  In some sense, solving this problem is a trivial one-liner, since Python has a built-in function called <tt>eval</tt> that is capable of evaluating Python expressions.</p>
<p>What if, however, we eliminated <tt>eval</tt> (and similar functions) from Python?  What then?  Well, a Python version of <tt>eval</tt> would be much more complicated than our Lisp <tt>eval</tt>.  Python is much less regular language than Lisp, and this makes it much more complicated for it to deal with Python code.  By contrast, Lisp has an extremely simple syntax, and is designed to manipulate its own code as data.  This is all reflected in the simplicity of the interpreter above. </p>
<p>Beyond this, the code for <tt>eval</tt> is a beautiful expression of the core ideas of Lisp, written in Lisp.  It&#39;s true that our <tt>eval</tt> implements a very incomplete version of Lisp, but with just a little elaboration we can add support for arithmetic, more advanced control structures, and so on - everything needed to make this an essentially complete basic Lisp.  And so we need only a little poetic license to say that, just as with Maxwell&#39;s equations and electromagnetism, there is a sense in which if you can look at this compact little program and understand all its consequences, then you understand all that Lisp can do.  And because Lisp is universal, that means that inside these few lines of code is all a computer can do - everything from Space Invaders to computer models of climate to the Google search engine.  In that sense this elegant little program really is the Maxwell&#39;s equations of software.</p>
<h3>Problems</h3>
<ul>
<li> Outline a proof that <tt>(eval (q (</tt><em>exp</em><tt>)) a)</tt>   returns the value of <em>exp</em> in the environment <tt>a</tt> for all   expressions <em>exp</em> and environments <tt>a</tt> if and only if the   underlying Lisp interpreter is correct.  This little theorem can be   considered a formal way of stating that <tt>eval</tt> contains all of   Lisp.  The reason I ask for an outline proof only is that various   elements in the statement aren&#39;t defined as well as they need to be   to make this a rigorous result; still, a compelling outline proof is   possible.
</li><li> Extend the code given for <tt>eval</tt> so that you can implement   a full read-eval-print loop.  This will require you to extend   tiddlylisp so that it can cope with input and output, and (perhaps)   some sort of looping.
</li><li> Having worked through <tt>eval.tl</tt>, it should now be easy to   work through the first chapter of the LISP 1.5 Programmer&#39;s Manual.   <a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">Download the LISP manual</a> and work through the first chapter, including the   code on page 13. </li></ul>
<h3>Problems for the author</h3>
<ul>
<li> Is it possible to modify the above Lisp-in-Lisp so that it   interprets all of tiddlylisp?  Note that this will require   modification of tiddlylisp. </li></ul>
<h3>Acknowledgements</h3>
<p>Thanks to <a href="http://jendodd.com">Jen Dodd</a> for many helpful discussions.</p>
<h3>Footnote</h3>
<p>[1] I&#39;m paraphrasing, since this was 17 years ago, but I believe I&#39;ve reported the essence of the comments correctly.  I&#39;ve taken one liberty, which is in supplying my own set of examples (antennas, motors, and circuits), since I don&#39;t recall the examples he gave. Incidentally, his comments contain a common error that took me several years to sort out in my own thinking: Maxwell&#39;s equations actually don&#39;t completely specify electromagnetism.  For that, you need to augment them with one extra equation, the <a href="http://en.wikipedia.org/wiki/Lorentz_force">Lorentz force law</a>. It is, perhaps, unfair to characterize this as an error, since it&#39;s a common useage to equate Maxwell&#39;s equations with electromagnetism, and I&#39;ve no doubt my professor was aware of the nuance.  Nonetheless, while the useage is common, it&#39;s not correct, and you really do need the Lorentz force law as well.  This nuance creates a slight quandary for me in this essay.  As the title of the essay suggests, it explores a famous remark made by Alan Kay about what he called &#34;the Maxwell&#39;s equations of software&#34;, and I presume that in making this remark Kay was following the common useage of equating the consequences of Maxwell&#39;s equations with the whole of electromagnetism.  My quandary is this: on the one hand I don&#39;t wish to perpetuate this useage; on the other hand I think Kay&#39;s formulation is stimulating and elegant. So I&#39;ll adopt the same useage, but with the admonishment that you should read &#34;Maxwell&#39;s equations&#34; as synonomous with &#34;Maxwell&#39;s equations plus the Lorentz force law&#34;.  That set of five equations really does specify the whole of (classical) electromagnetism.</p>
<p>[2] I first encountered <tt>lambda</tt> in Python, not Lisp, but I believe I would have been perplexed for the same reason even if I&#39;d first encountered it in Lisp.</p>
<p>[3] With a hat tip to Abelson and Sussman, who <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-7.html#%_chap_Temp_4">famously wrote</a> &#34;programs must be written for people to read, and only incidentally for machines to execute&#34;.</p>
<p>[4] The simplest solutions I can think of are: (1) to give <tt>eval</tt> the ability to determine when some key is not in the environment; or (2) to give <tt>eval</tt> the ability to recognize numbers.  Both approaches seem to also require making some modifications to tiddlylisp.</p>
<h3>Further reading</h3>
<p>Much of Alan Kay&#39;s writing may be found at the website of the <a href="http://vpri.org/html/writings.php">Viewpoints Research   Institute</a>.  I also recommend browsing his <a href="http://www.squeakland.org/resources/books/readingList.jsp">list   of recommended reading</a>.</p>
<p>Lisp enjoys a plethora of insightful and beautifully written books and essays, many of them freely available online.  This essay is, of course, based principally on Peter Norvig&#39;s essay on his <a href="http://norvig.com/lispy.html">basic Lisp interpreter, lispy</a>. I&#39;ve also drawn a few ideas from a followup essay of Norvig&#39;s which describes a <a href="http://norvig.com/lispy2.html">more sophisticated   Lisp interpreter</a>.  Both essays (and the accompanying code) are marvellously elegant, and well worth working through.  Norvig&#39;s <a href="http://norvig.com/">other works</a> are also worth your time.  The first three chapters of Norvig&#39;s book <a href="http://www.amazon.com/exec/obidos/ASIN/1558601910">Paradigms of   Artificial Intelligence Programming</a> are an excellent introduction to Common Lisp.</p>
<p>The other principal inspiration for the current essay is Paul Graham&#39;s essay <a href="http://lib.store.yahoo.net/lib/paulgraham/jmc.ps">The   Roots of Lisp</a> (postscript file), where he explains John McCarthy&#39;s early ideas about Lisp.  My essay may be viewed as an attempt to remix the ideas in Norvig&#39;s and Graham&#39;s essays, in an attempt to better understand Alan Kay&#39;s remark about Lisp-as-Maxwell&#39;s-Equations.  I also recommend Graham&#39;s book &#34;On Lisp&#34;, which contains an excellent discussion of Lisp macros and many other subjects.  The book seems to be out of print, but thanks to Graham and the publisher Prentice Hall the text of the entire book is <a href="http://www.paulgraham.com/onlisptext.html">freely available   online</a>.  Note that I am still working through &#34;On Lisp&#34;, I have not yet read it to completion.  The same is true of the books I mention below, by Seibel, and by Abelson and Sussmann.</p>
<p>Although &#34;On Lisp&#34; is a marvellous book, it&#39;s not written for people new to Lisp.  To gain familiarity, I suggest working through the first three chapters of Norvig&#39;s book, mentioned above.  If that&#39;s not available, then you should take a look at <a href="http://www.gigamonkeys.com/">Peter Seibel</a>&#39;s book <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>.  It&#39;s freely available at the link, and gives an easily readable introduction to Common Lisp.</p>
<p>Finally, I must recommend the wonderful book by Abelson and Sussman on the <a href="http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262011530">Structure   and Interpretation of Computer Programs</a>.  Among other things, it&#39;s an introduction to the Scheme dialect of Lisp, but it&#39;s about much more than that; it&#39;s about how to think about programming.  It&#39;s a famous book, but for a long time I avoided looking at it, because I&#39;d somehow picked up the impression that it was a little dry.  I started reading, and found this impression was completely false: I was utterly gripped.  Much of &#34;On Lisp&#34; and &#34;Paradigms of Artificial Intelligence Programming&#34; also have this quality.  Abelson and Sussmann&#39;s book is <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html">freely   available online</a>.  </p>
<p>  <em>Interested in more?  Please <a href="https://michaelnielsen.org/ddi/feed/">subscribe to this blog</a>, or <a href="http://twitter.com/\#!/michael_nielsen">follow me on Twitter</a>.  You may also enjoy reading my new book about  open science, <a href="http://www.amazon.com/Reinventing-Discovery-New-Networked-Science/dp/product-description/0691148902">Reinventing Discovery</a>. </em> </p>
														</div></div>
  </body>
</html>
