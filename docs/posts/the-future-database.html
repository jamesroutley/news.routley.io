<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://principles.planetscale.com/">Original</a>
    <h1>The Future Database</h1>
    
    <div id="readability-page-1" class="page"><div><section id="1-easy-to-operate"><h2><span>1<!-- -->.</span><a href="#1-easy-to-operate">Easy to operate: Built for mere mortals<span aria-label="Permalink to this section">#</span></a></h2><div><p>The most exciting advancements in DevOps have been those that freed developers from complex operations that overwhelmed their day-to-days. This has revolutionized development workflows. Engineering teams are now built around product and business goals, not maintenance and servicing. But databases have not caught up. Product teams still need to wait on the experts to perform overly complicated database operations tasks.</p><p>The Future Database has to fit into everyone’s DevOps workflows. It must be usable by any developer and leveraged by every team within a technical org. It won’t be gated or ‘hands-off’ but built with cross-functionality in mind. How? With a user experience fluid enough to be understood by casual data consumers and mastered by data admins. The database needs to be safe enough to be operable by everyone, and do the right thing when something goes wrong - swap 2 AM pages for more rollbacks and errors caught as part of the standard workflow.</p><p>With the Future Database, database admins will no longer be required to certify their knowledge in backups and capacity planning, or worry over disaster recovery. Developer-friendly features like database branching, database developer environments, autoscaling, and usage-based billing will just be commonplace.</p></div></section><section id="2-fundamentally-reliable"><h2><span>2<!-- -->.</span><a href="#2-fundamentally-reliable">Fundamentally reliable<span aria-label="Permalink to this section">#</span></a></h2><div><p>Some database companies are focused on building future databases around ease-of-use and translatability from Javascript. Those are enticing features. But some of those solutions sacrifice reliability and safety to do that. As billions of people around the world do more, businesses are grappling with how to process the unprecedented increase in transactions.</p><p>Apps that worked fine a few years ago are hitting new scaling limits. The databases that will fuel the next era of digital transactions must be battle-tested and proven at ridiculously high demands. A database is nothing without trust. With engineers being asked to guarantee uptime as their apps quickly scale, there might be a temptation to make concessions around reliability. But you shouldn’t have to choose. Future databases should respect ACID, be biased towards consistency over translatability and put trustworthiness at the forefront.</p><p>SQL languages will continue to win over converts as their interfaces become slicker. They’ll also become more powerful in the future as innovations like cross-shard transactions, query replication and safety rankings become standard trade.</p></div></section><section id="3-serverless-by-default"><h2><span>3<!-- -->.</span><a href="#3-serverless-by-default">Serverless by default<span aria-label="Permalink to this section">#</span></a></h2><div><p>Given the demands on the Future Database, there’s only one way to ensure it’s easy to operate while being fundamentally reliable. Make it serverless by default. Serverless is currently going through a redefinition from “functions in the cloud” and is becoming the standard for fast-paced development teams. Teams that don’t want to worry about vCPUs or node pools, but delivering outcomes.</p><p>That’s not surprising. Teams want to pay only for what they use. They want their cloud infrastructure to be available when a user needs it, scaling linearly as needed.  In the future, teams won’t have to worry about capacity planning or have a machine always running in the background at a fixed instance size. Developers of the future can expect transparency in their tools. Or at least to be told what is being abstracted. Serverless gives developers this highly tuned experience – while also giving them well-designed escape hatches.</p></div></section><section id="4-interoperable"><h2><span>4<!-- -->.</span><a href="#4-interoperable">Interoperable: Consumable by any client<span aria-label="Permalink to this section">#</span></a></h2><div><p>It’s a given that Future Databases will be accessed by every imaginable client – from toasters to fleets of autonomous drones. But this client-agnostic approach requires Future Databases to plan for many more transactions and connections. More than many existing databases could ever serve simultaneously.</p><p>In the future, it will be standard for databases to handle unlimited connections with smart connection pooling, query replication, and intelligent query routing. Databases will also need to serve a broad array of connection types and clients. Already, we’re seeing the exciting prospect of many more databases offering web APIs and new connection types. As these get tested at scale, we will see them adopted and used to power the next generation of applications.</p></div></section><section id="5-distributed-globally"><h2><span>5<!-- -->.</span><a href="#5-distributed-globally">Distributed globally, locally available<span aria-label="Permalink to this section">#</span></a></h2><div><p>Most businesses and applications today do not need a global database. It often just introduces more complexity and expense, but there are many reasons the future database will need to be globally distributed.</p><p>Being compliance-ready with regionally stored data allows you to scale rapidly to new regions. It gives your users a great experience by serving them locally available data quickly. Mobile games and other high-transaction, low-latency applications already need this. Expect more companies to require it in the future.</p><p>There’s just one caveat: global data distribution cannot break Rule 1; being easy to operate. The tools enabling this will need to be elegant and have clear interfaces. After all, their goal is to make operations easier, not harder.</p></div></section><section id="6-learning-optimizing"><h2><span>6<!-- -->.</span><a href="#6-learning-optimizing">Learning, optimizing: Intelligent<span aria-label="Permalink to this section">#</span></a></h2><div><p>The Future Database will be intelligent. It will learn and optimize processes for its developers. Imagine a database that routes queries automatically based on connection locations. Or a database that shards based on geography and will even suggest which tables to shard and where.</p><p>A future engineer will be able to optimize queries, improve database performance and even make adjustments intelligently based on recommendations from a database that  learns behavior. A database designed to always do the right thing for the developer is coming.</p></div></section><section id="7-linearly-horizontally-scalable"><h2><span>7<!-- -->.</span><a href="#7-linearly-horizontally-scalable">Linearly horizontally scalable<span aria-label="Permalink to this section">#</span></a></h2><p>We saved the best for last. The Future Database will first and foremost need to be prepared for future scale. Only a handful of companies on the planet have hit a scale that tests the limits of current technologies. YouTube serves an unimaginable number of queries, but, in the future, many more applications will need to scale past current records. They’ll do that by scaling both vertically and horizontally within seconds and without a human turning a knob. As it stands, many current databases require a maintenance window, replication, and a failover before they can be scaled up or out (horizontally). That downtime is unacceptable. Scale should not come at the cost of performance.  And it doesn’t have to. The Future Database will scale intelligently and without a blip on the status page.</p></section></div><section id="closing"><p>At <a href="https://planetscale.com"><svg fill="currentColor" height="16" viewBox="0 0 44 44" width="16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 22C1.03435e-06 9.84973 9.84974 -1.03435e-06 22 0C30.9336 7.80998e-07 38.6235 5.3248 42.069 12.9737L12.9737 42.069C11.7252 41.5066 10.5385 40.8311 9.42689 40.0555L27.4824 22H22L6.44366 37.5563C2.46244 33.5751 -5.31105e-07 28.0751 0 22Z"></path><path d="M44 22.0076L22.0076 44C34.1518 43.9959 43.9959 34.1518 44 22.0076Z"></path></svg> <span>PlanetScale</span></a>, it’s our goal to build the Future Database. We envision a day where every company can get out of the infrastructure business and focus on their business. We want development teams taking back control over their development workflow. We’re focused on making using a database as easy as writing code.</p><p>This is our vision of the Future Database. But it’s an open ended one — a future we are building in dialogue with you. If we’ve missed something, tell us about it. Just visit our <a href="https://github.com/planetscale/discussion/discussions">discussion board <svg width="13" height="13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="m6.5 6.5 5-5M6 2.984H2a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1V7M12 5V1.5a.5.5 0 0 0-.5-.5H8" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg></a> and make suggestions.</p></section></div>
  </body>
</html>
