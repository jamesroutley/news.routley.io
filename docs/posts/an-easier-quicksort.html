<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zachahn.com/posts/1710350863">Original</a>
    <h1>An easier quicksort</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      
      <p>Embarrassing story—I implemented a bunch of sorting algorithms for an assignment a long time ago, but quicksort ended up being one of the slowest ones I wrote.</p>
<p>I’m redoing that exercise now, and I’m happy to say I have a better understanding of it. But I’m writing this because I think it’s a slightly novel variation. At least, it’s not an implementation I’ve ever seen before. I doubt it’s faster, but I find it easier to reason about. (Spoiler, it’s not faster!)</p>
<h2>The basics</h2>
<p>Quicksort is a recursive sorting algorithm. On average, it’s one of the faster
sorting algorithms. It’s composed of two main ideas: partitioning the list into
two halves, and “quicksorting” each of the two halves. I find that partitioning
is the hard part; the recursive aspect is pretty straightforward as long as we
remember to define the base case.</p>
<p>I’ll really just be focusing on the <code>partition</code> function. We input the array of numbers and a range for the function to focus on. We expect it to return the position of a number. We expect everything (<em>everything</em>) to the left of that position to be smaller than the number; we expect everything to the right of that position to be larger than that number. The number itself is called the “pivot”. Numbers that are equal to the pivot can be in either half.</p>
<p>Typically, the pivot is the rightmost element of the range. But it can be any
number in the range—just swap the number you choose with the rightmost number,
then proceed as normal.</p>
<p>Here’s an example where we run <code>partition</code> once on a full array, just the inputs
and result. We’re using zero-based indexes.</p>
<div><pre><code>Input: Indexes 0 to 6
-----------------------------
[ 6   5   2   7   0   8   4 ]
                    Pivot ↑

Result:
-----------------------------
[ 2   0   4   7   5   8   6 ]
          ↑
Returns `2`, the position of the pivot
</code></pre></div>
<p>The array is not sorted at all, but pivot is in the right place. Once every
element has its turn being the pivot element, the array will end up having been
sorted.</p>
<p>Here’s another example where we run <code>partition</code> on a sublist.</p>
<div><pre><code>Input: Indexes 3 to 6
-----------------------------
  2   0   4 [ 7   5   8   6 ]
                    Pivot ↑

Result:
-----------------------------
  2   0   4 [ 5   6   8   7 ]
                  ↑
Returns `4`, the position of the pivot
</code></pre></div>
<h2>Understanding partitioning</h2>
<p>A single round of partitioning has a few phases:</p>
<ol>
<li>Moving all the numbers lesser than the pivot to the left part of the list.</li>
<li>Moving all the numbers greater than the pivot to the right part of the list.</li>
<li>Moving the pivot in between those parts.</li>
<li>Returning the position of the pivot.</li>
</ol>
<p>I always found it hard to convert those rules into code. We’ll see in a bit, but
there are a lot of array indexes to keep track of, and these are weird ones, and
even without the weirdness, array indexes are bug prone.</p>
<p>We can use a line to keep track of things. Everything to the right of the line
is unprocessed or greater than the pivot. Everything to the right of the line
must be lesser than the pivot.</p>
<div><pre><code>| ↓ Current element
| 6   5   2   7   0   8   4
| ← The line        Pivot ↑
</code></pre></div>
<p>Looking at the example above, the first time we need to put anything to the
right of the line is on array index <code>2</code>.</p>
<div><pre><code>First element smaller than pivot
|         ↓
| 6   5   2   7   0   8   4
| ← The line        Pivot ↑
</code></pre></div>
<p>In quicksort, we move elements by swapping elements rather than sliding them.
We’ll swap the 6 and the 2—and move the line by one step to the right.</p>
<div><pre><code>  First: Swap 6 and 2
  ↓ |     ↓
  2 | 5   6   7   0   8   4
 →→ |
Second: Move the line to the right
</code></pre></div>
<p>We don’t have to re-process the 6 that we just moved. We iterate through the
elements until we come across 0, which is lesser than 4. Again, we swap and move
the line.</p>
<div><pre><code>      First: Swap 5 and 0
      ↓ |         ↓
  2   0 | 6   7   5   8   4
     →→ | 
Second: Move the line to the right
</code></pre></div>
<p>The 8 is larger, so we don’t have to do anything. We don’t have to compare the
pivot with itself, but we do always need to move the pivot directly to the right
of the line.</p>
<div><pre><code>          Swap 6 and 4
        | ↓               ↓
  2   0 | 4   7   5   8   6
        | ↑
Return new position of pivot
</code></pre></div>
<h3>Small edge case: First element is smaller than pivot</h3>
<div><pre><code>Input: Indexes 0 to 2
-------------
|
| 3   5   8
|
</code></pre></div>
<p>Since the 3 is directly to the right of the line, we swap the three with itself.
Then we move the line. Wasted operations, but nothing too crazy.</p>
<div><pre><code>  ↕ |
  3 | 5   8
 →→ |
</code></pre></div>
<p>This specific scenario is kinda funny since it’s already sorted. The 5 also gets
swapped with itself, then the 8 gets swapped with itself.</p>
<h3>Small edge case: Single-element and empty lists</h3>
<p>Both single-element and empty lists are always sorted, since there’s nothing
to compare.</p>
<p>This isn’t really related to partitioning; this is the base case of our
recursion.</p>
<h2>The traditional algorithm</h2>
<p>I’m always confused by quicksort because the “line” we talked about starts off
out of bounds of the sublist. When we start off, the line is <em>before</em> the first
element—array index <code>-1</code>. We always swap to the right of the line, so we add <code>1</code>
to it, which gets us back within the range. But this, to me, is really
confusing.</p>
<h2>My algorithm</h2>
<p>I have a much easier time thinking about the size of a list rather than the
positions of the list. In other words, instead of subtracting from the left
boundary, I realized I can keep track of the number of elements to the left of
the line.</p>
<div><pre><code><span># It&#39;s hard to think about indexes</span>
<span>line_position</span> <span>=</span> <span>left_index</span> <span>-</span> <span>1</span>

<span># It&#39;s easy to count</span>
<span>lesser_length</span> <span>=</span> <span>0</span>
</code></pre></div>
<p>Here’s the full algorithm with a bunch of comments. It’s in Ruby, but even if
you’re unfamiliar with it, I hope it reads close enough to pseudocode for it to
be helpful.</p>
<div><pre><code><span>class</span> <span>Quick</span>
  <span>##</span>
  <span># A convenience method for invoking quicksort.</span>
  <span>#</span>
  <span># == Parameters</span>
  <span>#</span>
  <span># numbers::   An Array of numbers to be sorted.</span>
  <span>#</span>
  <span># == Returns</span>
  <span>#</span>
  <span># The array, sorted. Note that the array is sorted in-place.</span>
  <span>def</span> <span>self</span><span>.</span><span>sort</span><span>(</span><span>numbers</span><span>)</span>
    <span>quicksort</span><span>(</span><span>numbers</span><span>,</span> <span>0</span><span>,</span> <span>numbers</span><span>.</span><span>size</span> <span>-</span> <span>1</span><span>)</span>
    <span>numbers</span>
  <span>end</span>

  <span>##</span>
  <span># Quicksort only sorts subsections of a list.</span>
  <span>#</span>
  <span># == Parameters</span>
  <span>#</span>
  <span># numbers::      Array&lt;Numeric&gt;. The full array to be sorted.</span>
  <span># left_index::   Integer. The leftmost boundary to sort.</span>
  <span># right_index::  Integer. The rightmost boundary to sort.</span>
  <span>#</span>
  <span># == Returns</span>
  <span>#</span>
  <span># Nothing useful!</span>
  <span>def</span> <span>self</span><span>.</span><span>quicksort</span><span>(</span><span>numbers</span><span>,</span> <span>left_index</span><span>,</span> <span>right_index</span><span>)</span>
    <span># Empty lists and single-value lists are sorted by default.</span>
    <span># Both `[]` and `[1]` are both fully sorted. This is our base case.</span>
    <span>return</span> <span>if</span> <span>left_index</span> <span>&gt;=</span> <span>right_index</span>

    <span># The item at `mid_index` is at the correct position.</span>
    <span>mid_index</span> <span>=</span> <span>partition</span><span>(</span><span>numbers</span><span>,</span> <span>left_index</span><span>,</span> <span>right_index</span><span>)</span>

    <span># Separately sort the items that are to the left and right of `mid_index`</span>
    <span>quicksort</span><span>(</span><span>numbers</span><span>,</span> <span>left_index</span><span>,</span> <span>mid_index</span> <span>-</span> <span>1</span><span>)</span>
    <span>quicksort</span><span>(</span><span>numbers</span><span>,</span> <span>mid_index</span> <span>+</span> <span>1</span><span>,</span> <span>right_index</span><span>)</span>
  <span>end</span>

  <span>##</span>
  <span># The main logic. This differs from a traditional partitioning algorithm</span>
  <span># since it keeps track of the number of values that are lesser than the</span>
  <span># pivot rather than keeping track of the position of the &#34;line&#34;.</span>
  <span>#</span>
  <span># == Parameters</span>
  <span>#</span>
  <span># numbers::      The full array to be sorted.</span>
  <span># left_index::   The leftmost boundary to consider.</span>
  <span># right_index::  The rightmost boundary to consider.</span>
  <span>#</span>
  <span># == Returns</span>
  <span>#</span>
  <span># The position of the pivot. The pivot is correctly sorted, but values to</span>
  <span># the left and right may not be.</span>
  <span>def</span> <span>self</span><span>.</span><span>partition</span><span>(</span><span>numbers</span><span>,</span> <span>left_index</span><span>,</span> <span>right_index</span><span>)</span>
    <span>pivot_value</span> <span>=</span> <span>numbers</span><span>[</span><span>right_index</span><span>]</span>
    <span>lesser_length</span> <span>=</span> <span>0</span>

    <span># Iterate through the list, but no need to compare the pivot itself since</span>
    <span># we always have to move the pivot value.</span>
    <span>current_index</span> <span>=</span> <span>left_index</span>
    <span>while</span> <span>current_index</span> <span>&lt;</span> <span>right_index</span>
      <span>current_value</span> <span>=</span> <span>numbers</span><span>[</span><span>current_index</span><span>]</span>
      <span>if</span> <span>current_value</span> <span>&lt;=</span> <span>pivot_value</span>
        <span># The current value is lesser than (or equal to) the pivot, so we want</span>
        <span># to move the current value to the left of the &#34;line&#34;.</span>
        <span>#</span>
        <span># Another way to think about it is that we swap the first value</span>
        <span># directly to the right of the line with the current value, then we</span>
        <span># bump up the length of the list of lesser values to absorb it.</span>
        <span>swap_index</span> <span>=</span> <span>left_index</span> <span>+</span> <span>lesser_length</span>
        <span>temp</span> <span>=</span> <span>numbers</span><span>[</span><span>current_index</span><span>]</span>
        <span>numbers</span><span>[</span><span>current_index</span><span>]</span> <span>=</span> <span>numbers</span><span>[</span><span>swap_index</span><span>]</span>
        <span>numbers</span><span>[</span><span>swap_index</span><span>]</span> <span>=</span> <span>temp</span>
        <span># As mentioned, we have a new lesser value, so increment the length</span>
        <span>lesser_length</span> <span>+=</span> <span>1</span>
      <span>end</span>
      <span>current_index</span> <span>+=</span> <span>1</span>
    <span>end</span>

    <span># Always swap the pivot to the direct right of the line</span>
    <span>swap_index</span> <span>=</span> <span>left_index</span> <span>+</span> <span>lesser_length</span>
    <span>temp</span> <span>=</span> <span>numbers</span><span>[</span><span>current_index</span><span>]</span>
    <span>numbers</span><span>[</span><span>current_index</span><span>]</span> <span>=</span> <span>numbers</span><span>[</span><span>swap_index</span><span>]</span>
    <span>numbers</span><span>[</span><span>swap_index</span><span>]</span> <span>=</span> <span>temp</span>

    <span># Return the new index of the pivot</span>
    <span>swap_index</span>
  <span>end</span>
<span>end</span>

<span>Quick</span><span>.</span><span>sort</span><span>([</span><span>6</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>,</span> <span>7</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>4</span><span>])</span>
<span># =&gt; [0, 2, 4, 5, 6, 7, 8]</span>
</code></pre></div>
<p>I hope this explanation helps! I’m curious if this variation on partitioning exists elsewhere, please let me know.</p>
<p>In my testing, I found that the method described here is roughly 5% slower than the traditional method. This makes sense to me, since we have to do slightly more addition here to compute the <code>swap_index</code>—in the traditional, this is cached across iterations.</p>

    </div>
  </div></div>
  </body>
</html>
