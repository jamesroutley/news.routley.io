<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martypc.blogspot.com/2024/02/the-complete-bus-logic-of-intel-8088.html">Original</a>
    <h1>The Complete Bus Logic of the Intel 8088</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-4671265851781872483">
<p>In a <a href="https://martypc.blogspot.com/2023/08/the-8088-prefetch-algorithm.html" target="_blank">previous article</a>, I described a simple state machine to explain the prefetch behavior and miscellaneous observed bus delays of the Intel 8088. I now believe that the model I described there - although successful in modelling the 8088&#39;s behavior - was unnecessarily complex. There are in fact far fewer legitimate bus &#34;delays&#34;, and they do not relate to internal state transitions. I have also slightly revised my description of the BIU&#39;s prefetching logic - I now believe that the prefetching decision happens at the end of T2, instead of the beginning of T3. There may not be much of a distinction between the end of one cycle and the beginning of the next, but it lines up better in our new diagrams.</p><h2>Introduction</h2><p>If you were interested enough to click on this article, you are probably already familiar with the 8088&#39;s bus cycle timings. A single bus cycle on the 8088 takes a minimum of 4 CPU cycles, consisting of 4 T-states numbered T1, T2, T3 and T4. Wait states (Tw) can be inserted between T3 and T4 via manipulation of the CPU&#39;s READY line to accommodate access to slower devices, but in general, the 4 T-states have been the demonstrable model of the 8088 for decades.  </p><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhOceW4Sxc2KnRrGvt_Q9_w908BZ680kiykVlXgiERdjH5-7G1_jGh0ra6Rz7vxD-ECQh23K5diZYCq9MTdc4ecPA5sBHaOrTHmzbsa3mLqYC5KnQ3FP6aqwc-hGg0p6a2jDwX4dJYf-Tb7tzJhY2urTDsQp-EXe7KeoX1utl4U08bzhLZeOW3Fv8Q-b7aX/s1098/bus_cycle-4-8_01.png"><img data-original-height="165" data-original-width="1098" height="96" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhOceW4Sxc2KnRrGvt_Q9_w908BZ680kiykVlXgiERdjH5-7G1_jGh0ra6Rz7vxD-ECQh23K5diZYCq9MTdc4ecPA5sBHaOrTHmzbsa3mLqYC5KnQ3FP6aqwc-hGg0p6a2jDwX4dJYf-Tb7tzJhY2urTDsQp-EXe7KeoX1utl4U08bzhLZeOW3Fv8Q-b7aX/w640-h96/bus_cycle-4-8_01.png" width="640"/></a></td></tr><tr><td><p><i>iAPX 86/88 User&#39;s Manual, pg 4-5</i></p></td></tr></tbody></table><p>Diagrams such as the above have appeared in innumerable manuals, web references and computer science textbooks. It is no surprise then that emulator authors attempted to construct the logic and timings of their emulators around a 4-cycle bus cycle time. Unfortunately, this is an incomplete picture. For whatever reason, Intel was averse to advertising the true bus cycle time of the 8088 in their official documentation, and so this incomplete model has persisted to this day.</p><p>Ken Shirriff, in his analysis of the 8086&#39;s silicon, was the first to document this, to my knowledge, on his blog entry, <a href="https://www.righto.com/2023/07/8086-pins.html" target="_blank">Reverse-engineering the 8086 processor&#39;s address and data pin circuits</a>.</p><p>He states,</p><blockquote><b>There [are] two undocumented T states that are important to the bus cycle. The physical address is computed in the two clock cycles before T1 so the address will be available in T1. I give these &#34;invisible&#34; T states the names TS (start) and T0.</b></blockquote><p>I originally missed the significance of this - it&#39;s casually mentioned as if it were an interesting, but ultimately trivial internal detail. However these cycles are fundamental to the timing and operation of the 8088. They are not quite &#34;invisible&#34; after all!</p><p>It seems farfetched at first - we know that we can execute NOPs back to back at the speed at which the opcodes can be fetched - that is 4 cycles for each byte-sized NOP opcode. So that would disprove this theory right out of the gate.  The key that makes it possible is that the BIU is actually <i>pipelined. </i></p><p>The Intel iAPX manual gave us a hint, even if it only mentioned the four conventional T-states:</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjTfqwNkJdcmAXUwzjZhih_aRzNjEwH0P0F8ckSwyOest2EIeE28XwS21dqV6sIEsafuocDWpsMPqRaROKSskWh2vSgu5Uf98oKXux6c2AtyjByDCldYoO_t4EJJl6pn0troU4fxfGbiBbI6YWjlPUOrgBPca78XZZ4phtaNH8i1cGstbcJzN04nHAgBzYA/s1362/iAPX%20user&#39;s%20manual%20pg2-3.png"><img data-original-height="501" data-original-width="1362" height="148" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjTfqwNkJdcmAXUwzjZhih_aRzNjEwH0P0F8ckSwyOest2EIeE28XwS21dqV6sIEsafuocDWpsMPqRaROKSskWh2vSgu5Uf98oKXux6c2AtyjByDCldYoO_t4EJJl6pn0troU4fxfGbiBbI6YWjlPUOrgBPca78XZZ4phtaNH8i1cGstbcJzN04nHAgBzYA/w400-h148/iAPX%20user&#39;s%20manual%20pg2-3.png" width="400"/></a></p></div></div>
  </body>
</html>
