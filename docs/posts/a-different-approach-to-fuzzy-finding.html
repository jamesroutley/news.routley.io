<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nathancraddock.com/blog/2023/a-different-approach-to-fuzzy-finding/">Original</a>
    <h1>A different approach to fuzzy finding</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>After growing frustrated by various fuzzy finders not being as accurate as I expected, I designed a new <a href="https://github.com/natecraddock/zf">fuzzy finder called zf</a>. I have mentioned zf in passing many times, but until now I haven’t taken the time to write about it in detail. In short, zf is a new terminal fuzzy finder with <strong>a ranking algorithm designed specifically for filtering filepaths</strong>. It has been rewarding to develop and use, and perhaps you will enjoy it too!</p>
<p>The rest of this post describes what motivated me to create zf, what makes zf different from other fuzzy finders, and some things I learned along the way.</p>
<p>But first, a short demo video of zf in action:</p>

    <video controls="" muted="" width="100%" src="/videos/zf-demo.mp4">
    </video>


<h2 id="two-observations-on-fuzzy-finding">
    <a href="#two-observations-on-fuzzy-finding">#</a> Two observations on fuzzy finding
</h2>
<p>In the summer of 2021 I noticed many of my fuzzy file searches didn’t sort the file I wanted as the first result. Motivated by frustration<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> I thought, “surely I can make something better,” and I began thinking of alternate algorithms for fuzzy finding.</p>
<p>I previously <a href="https://nathancraddock.com/blog/2021/in-search-of-a-better-finder/">wrote about my research</a> in detail:</p>
<blockquote>
<p>I theorized that prioritizing matches on file names would yield the best results. I figured that in the majority of cases, the queried name would be unique among all other file names. If this is most often the case, then it makes sense to optimize the algorithm to match based on the file name.</p>
</blockquote>
<p>To test my theory I analyzed many repositories from GitHub and found that <strong>in a typical codebase the majority of filenames are unique</strong>.</p>
<p>After some experimentation,<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> I also realized that <strong>most of my fuzzy finding involved files</strong>, so it would make sense to design a fuzzy finder around the use case of filepath matching.</p>
<h2 id="designing-a-filename-fuzzy-finder">
    <a href="#designing-a-filename-fuzzy-finder">#</a> Designing a filename fuzzy finder
</h2>
<p>My two observations guided the initial development of zf:</p>
<ol>
<li>Fuzzy finding is most commonly used to filter files</li>
<li>Most filenames are unique in a given codebase</li>
</ol>
<p>Like any typical terminal fuzzy finder, zf accepts a list of newline-separated <strong>candidates</strong> on <code>stdin</code>. The selected candidate is written to <code>stdout</code>. The <strong>query</strong> is made of space-separated <strong>tokens</strong>. Each query token is ranked separately, and any candidate that does not match all query tokens is discarded.</p>
<p>The algorithm to prioritize filenames is simple. It first attempts a match on the filename. If there is no match, it retries on the full candidate string. If the match was on the filename, it is given a better ranking. This simple behavior alone makes zf much more accurate for filtering by filename. And when there isn’t a filename match it fails gracefully and operates just like a typical fuzzy finder.</p>
<h3 id="filename-matching">
    <a href="#filename-matching">#</a> Filename matching
</h3>
<p>Here is an example of zf giving better rankings than other fuzzy finders. Note that although I find zf to give better results than the other fuzzy finders, that doesn’t make the alternatives <em>bad</em>. These other tools are wonderful projects!<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<p>The first frustrating fuzzy find I remember is searching for the <code>GNUMakefile</code> in Blender’s source code. The prefix <code>GNU</code> is a bit uncommon, and it throws off both fzf and fzy.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p>
<div><pre tabindex="0"><code data-lang="text"><span><span>$ fd -t f | fzf --height 16 --reverse --info hidden
</span></span><span><span>&gt; makefile
</span></span><span><span>&gt; source/blender/makesdna/DNA_fileglobal_types.h
</span></span><span><span>  source/blender/makesdna/DNA_packedFile_types.h
</span></span><span><span>  source/blender/makesdna/DNA_genfile.h
</span></span><span><span>  source/blender/makesdna/DNA_cachefile_types.h
</span></span><span><span>  source/blender/makesdna/DNA_cachefile_defaults.h
</span></span><span><span>  source/blender/makesdna/DNA_curveprofile_types.h
</span></span><span><span>  source/tools/utils_maintenance/cmake_sort_filelists.py
</span></span><span><span>  source/blender/makesdna/intern/dna_genfile.c
</span></span><span><span>  source/blender/makesrna/intern/rna_cachefile.c
</span></span><span><span>  source/blender/makesrna/intern/rna_packedfile.c
</span></span><span><span>  source/blender/makesrna/intern/rna_curveprofile.c
</span></span><span><span>  build_files/cmake/Modules/FindLevelZero.cmake
</span></span><span><span>  GNUmakefile
</span></span><span><span>  build_files/cmake/Modules/FindLibEpoxy.cmake
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>$ fd -t f | fzy
</span></span><span><span>&gt; makefile
</span></span><span><span>source/blender/makesdna/DNA_fileglobal_types.h
</span></span><span><span>source/blender/makesdna/DNA_packedFile_types.h
</span></span><span><span>GNUmakefile
</span></span><span><span>source/blender/makesdna/DNA_genfile.h
</span></span></code></pre></div><p>Notice that both fzf and fzy ranked <code>source/blender/makesdna/DNA_fileglobal_types.h</code> higher than <code>GNUMakefile</code>. I believe this is because <code>/make</code> and <code>_file</code> in that path are on word boundaries and are ranked higher than <code>UMakefile</code> that is not on a word boundary.</p>
<p>On the other hand, zf ranks <code>GNUMakefile</code> first.</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>$ fd -t f | zf
</span></span><span><span>&gt; makefile
</span></span><span><span>GNUmakefile
</span></span><span><span>source/tools/utils_maintenance/cmake_sort_filelists.py
</span></span></code></pre></div><p>Also notice that the second result is <code>cmake_sort_filelists.py</code> as well, another <em>filename</em> that matches <code>makefile</code>. The other fuzzy finders give higher precedence to the <code>makesdna/*</code> and <code>makesrna/*</code> paths.</p>
<h3 id="space-separated-tokens">
    <a href="#space-separated-tokens">#</a> Space-separated tokens
</h3>
<p>Although filename priority matching usually works well, there are still plenty of cases where there are similar filenames throughout a project. For example, <code>__init__.py</code> files in a Python project. This is why zf treats the query as whitespace separated tokens. It makes narrowing down search results trivial.</p>
<p>Imagine searching for an <code>__init__.py</code> file in a Python project.</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>$ fd -t f | zf
</span></span><span><span>&gt; init
</span></span><span><span>__init__.py
</span></span><span><span>ui/__init__.py
</span></span><span><span>data/__init__.py
</span></span><span><span>config/__init__.py
</span></span></code></pre></div><p>At this point you can either move the selected row down to find <code>config/__init__.py</code>, or you can add a new token to the query string.</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>$ fd -t f | zf
</span></span><span><span>&gt; init c
</span></span><span><span>config/__init__.py
</span></span></code></pre></div><p>Note that feature isn’t unique to zf. Most fuzzy finders that I have tried (except fzy) treat the query as whitespace separated tokens. I do think it is important behavior though.</p>
<p>For over a year these two features worked well for me in my fuzzy finding needs. I felt like zf was mostly feature complete. I did add small UI features and other improvements to zf, but the ranking algorithm didn’t change much from the first version back in 2021.</p>
<p>But a few months ago I started working on another feature.</p>
<h2 id="making-filepath-matches-more-accurate">
    <a href="#making-filepath-matches-more-accurate">#</a> Making filepath matches more accurate
</h2>
<p>I recently had a discussion with <a href="https://lobste.rs/s/x9mztx/find_anything_you_need_with_fzf_linux#c_hyhqmi">Pistos on lobste.rs</a> on an article about fzf. Their idea was to increase file <em>path</em> matching accuracy. I’ll explain the specifics in a moment.</p>
<p>Because zf already focused on file <em>name</em> matching this seemed like a natural extension of the project. So I now had two new observations:</p>
<ol>
<li>Fuzzy finders also deal with file <em>paths</em></li>
<li>Collaboration is great because other people have amazing ideas that you had never considered</li>
</ol>
<p>Pistos’ idea boils down to this: When the user of a fuzzy finder includes path separators in the query, their <em>intent</em> is to filter on file <em>paths</em>. I refer to this feature as “strict path matching”.</p>
<p>Strict path matching means that the path segments of the query token cannot overlap between path segments in the candidate. As a trivial example, <code>asdf/</code> would match <code>asdf/main.zig</code> but not <code>as/df/main.zig</code>. This is because <code>asdf</code> is a single path segment and should not cross between segments of the candidate.</p>
<p>It’s hard to illustrate how useful this is in small project trees, so I’ll use Blender’s source code again. In this scenario I’m trying to find the files in the <code>space_outliner/</code> directory using the query <code>sout/</code>.</p>
<div><pre tabindex="0"><code data-lang="text"><span><span># Without strict path matching
</span></span><span><span>$ fd -t f | zf
</span></span><span><span>&gt; sout/
</span></span><span><span>release/scripts/addons_contrib/lighting_hdri_shortcut/__init__.py
</span></span><span><span>source/tools/readme.rst
</span></span><span><span>source/tools/pyproject.toml
</span></span><span><span>source/tools/utils/git_log.py
</span></span><span><span>source/tools/utils/blend2json.py
</span></span><span><span>source/tools/modules/blendfile.py
</span></span><span><span>source/tools/utils/cycles_timeit.py
</span></span><span><span>source/tools/utils/weekly_report.py
</span></span><span><span>source/tools/git/git_sort_commits.py
</span></span><span><span>source/tools/utils/autopep8_clean.py
</span></span><span><span>
</span></span><span><span># With strict path matching
</span></span><span><span>❯ fd -t f | zf
</span></span><span><span>&gt; sout/
</span></span><span><span>source/blender/editors/space_outliner/CMakeLists.txt
</span></span><span><span>source/blender/editors/space_outliner/tree/common.cc
</span></span><span><span>source/blender/editors/space_outliner/tree/common.hh
</span></span><span><span>source/blender/editors/space_outliner/outliner_ops.cc
</span></span><span><span>source/blender/editors/space_outliner/outliner_draw.cc
</span></span><span><span>source/blender/editors/space_outliner/outliner_edit.cc
</span></span><span><span>source/blender/editors/space_outliner/outliner_sync.cc
</span></span><span><span>source/blender/editors/space_outliner/outliner_tree.cc
</span></span><span><span>source/blender/editors/space_outliner/outliner_query.cc
</span></span><span><span>source/blender/editors/space_outliner/outliner_tools.cc
</span></span></code></pre></div><p>Without strict path matching the results are the shortest matches for the query (<code>sout/</code> matching <code>source/tools/</code> for example). This makes sense, but doesn’t capture my intent. With strict path matching the directory I was looking for is the top result! And there are no results where the characters <code>sout</code> are spread across multiple path segments.</p>
<p>I’m grateful I ran into Pistos’ suggestion on lobste.rs. It gave me an opportunity to refine my project and taught me about user intent.</p>
<p>At the core of zf’s design is <em>intention</em>. If you type something that looks like a filename, you probably want to prioritize filename matches. When your search query looks like a filepath, you probably want to use an algorithm designed for filepath matching. This makes zf a “do what I mean” program.</p>
<p>Developing zf has been a fun and rewarding process. I don’t expect zf to ever become widely used (fzf has way more features than I’m ever willing to implement), but it has been very helpful to me. I hope it can be helpful for others too!</p>
<p>If you are interested in trying it out, <a href="https://github.com/natecraddock/zf">take a look at zf on GitHub</a> for more info! There are packages for Arch Linux and Homebrew, and integrations with both Vim and Neovim. I appreciate suggestions and feedback!</p>


</div></div>
  </body>
</html>
