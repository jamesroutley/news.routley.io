<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ralfj.de/blog/2025/07/24/memory-safety.html">Original</a>
    <h1>There is no memory safety without thread safety</h1>
    
    <div id="readability-page-1" class="page"><article id="-content">
      <header>
    
    
</header>

<p>Memory safety is all the rage these days.
But what does the term even mean?
That turns out to be harder to nail down than you may think.
Typically, people use this term to refer to languages that make sure that there are no use-after-free or out-of-bounds memory accesses in the program.
This is then often seen as distinct from other notions of safety such as thread safety, which refers to programs that do not have certain kinds of concurrency bugs.
However, in this post I will argue that this distinction isn’t all that useful, and that the actual property we want our programs to have is <em>absence of Undefined Behavior</em>.</p>

<!-- MORE -->

<h2 id="breaking-memory-safety-with-a-data-race">Breaking memory safety with a data race</h2>

<p>My main issue with the division of safety into fine-grained classes such as memory safety and thread safety is that there’s no meaningful sense in which a thread-unsafe language provides memory safety.
To see what I mean by this, consider this program written in Go, which <a href="https://en.wikipedia.org/wiki/Go_(programming_language)">according to Wikipedia</a> is memory-safe:</p>
<div><div><pre><code><span>package</span> <span>main</span>

<span>// Just some arbitrary interface so we can later use an interface type.</span>
<span>type</span> <span>Thing</span> <span>interface</span> <span>{</span>
    <span>get</span><span>()</span> <span>int</span>
<span>}</span>

<span>// Two types implementing the interface, with fields of very different types.</span>
<span>type</span> <span>Int</span> <span>struct</span> <span>{</span>
    <span>val</span> <span>int</span>
<span>}</span>
<span>func</span> <span>(</span><span>s</span> <span>*</span><span>Int</span><span>)</span> <span>get</span><span>()</span> <span>int</span> <span>{</span>
    <span>return</span> <span>s</span><span>.</span><span>val</span>
<span>}</span>

<span>type</span> <span>Ptr</span> <span>struct</span> <span>{</span>
    <span>val</span> <span>*</span><span>int</span>
<span>}</span>
<span>func</span> <span>(</span><span>s</span> <span>*</span><span>Ptr</span><span>)</span> <span>get</span><span>()</span> <span>int</span> <span>{</span>
    <span>return</span> <span>*</span><span>s</span><span>.</span><span>val</span>
<span>}</span>

<span>// A global variable of interface type, that we will swap back and</span>
<span>// forth between pointing to an `Int` and to a `Ptr`.</span>
<span>var</span> <span>globalVar</span> <span>Thing</span> <span>=</span> <span>&amp;</span><span>Int</span> <span>{</span> <span>val</span><span>:</span> <span>42</span> <span>}</span>

<span>// Repeatedly invoke the interface method on the global variable.</span>
<span>func</span> <span>repeat_get</span><span>()</span> <span>{</span>
    <span>for</span> <span>{</span>
        <span>x</span> <span>:=</span> <span>globalVar</span>
        <span>x</span><span>.</span><span>get</span><span>()</span>
    <span>}</span>
<span>}</span>

<span>// Repeatedly change the dynamic type of the global variable.</span>
<span>func</span> <span>repeat_swap</span><span>()</span> <span>{</span>
    <span>var</span> <span>myval</span> <span>=</span> <span>0</span>
    <span>for</span> <span>{</span>
        <span>globalVar</span> <span>=</span> <span>&amp;</span><span>Ptr</span> <span>{</span> <span>val</span><span>:</span> <span>&amp;</span><span>myval</span> <span>}</span>
        <span>globalVar</span> <span>=</span> <span>&amp;</span><span>Int</span> <span>{</span> <span>val</span><span>:</span> <span>42</span> <span>}</span>
    <span>}</span>
<span>}</span>

<span>func</span> <span>main</span><span>()</span> <span>{</span>
    <span>go</span> <span>repeat_get</span><span>()</span>
    <span>repeat_swap</span><span>()</span>
<span>}</span>
</code></pre></div></div>
<p>If you run this program (e.g. on the <a href="https://go.dev/play/p/SC-o_Q8e-aK">Go playground</a>), it will crash very quickly:</p>
<div><div><pre><code>panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x2a pc=0x468863]
</code></pre></div></div>
<p>Note that the address that caused the segfault is <code>0x2a</code>, the hex representation of 42.
What is happening here?</p>

<p>This example exploits that Go stores values of interface types like <code>Thing</code> as pairs of a pointer to the data and a pointer to the vtable.
Every time <code>repeat_swap</code> stores a new value in <code>globalVar</code>, it just does two separate stores to update those two pointers.
In <code>repeat_get</code>, there’s thus a small chance that when we read <code>globalVar</code> <em>in between</em> those two stores, we get a mix of a pointer to an <code>Int</code> with the vtable for a <code>Ptr</code>.
When that happens, we will run the <code>Ptr</code> version of <code>get</code>, which will dereference the <code>Int</code>’s <code>val</code> field as a pointer – and hence the program accesses address 42, and crashes.</p>

<p>One could construct a similar example using Go’s slices, where the data pointer, length, and capacity of the slice are stored in separate words, and reading a half-updated value can lead to an out-of-bounds access.</p>

<h2 id="what-about-other-languages">What about other languages?</h2>

<p>At this point you might be wondering, isn’t this a problem in many languages?
Doesn’t Java also allow data races?
And yes, Java does allow data races, but the Java developers spent a lot of effort to ensure that even programs with data races remain entirely well-defined.
They even developed the <a href="https://en.wikipedia.org/wiki/Java_memory_model">first industrially deployed concurrency memory model</a> for this purpose, many years before the C++11 memory model.
The result of all of this work is that in a concurrent Java program, you might see unexpected outdated values for certain variables, such as a null pointer where you expected the reference to be properly initialized, but you will <em>never</em> be able to actually break the language and dereference an invalid dangling pointer and segfault at address <code>0x2a</code>.
In that sense, all Java programs are thread-safe.<sup id="fnref:java-safe"><a href="#fn:java-safe" rel="footnote" role="doc-noteref">1</a></sup></p>

<p>Generally, there are two options a language can pursue to ensure that concurrency does not break basic invariants:</p>
<ul>
  <li>Ensure that arbitrary concurrent programs actually behave “reasonably” in some sense. This comes at a significant cost, restricting the language to never assume consistency of multi-word values and limiting which optimizations the compiler can perform. This is the route most languages take, from Java to C#, OCaml, JavaScript, and WebAssembly.</li>
  <li>Have a strong enough type system to fully rule out data races on most accesses, and pay the cost of having to safely deal with races for only a small subset of memory accesses. This is the approach that Rust first brought into practice, and that Swift is now also adopting with their <a href="https://developer.apple.com/documentation/swift/adoptingswift6">“strict concurrency”</a>.</li>
</ul>

<p>Go, unfortunately, chose to do neither of these.
This means it is, strictly speaking, not a memory safe language: the best the language can promise is that <em>if</em> a program has no data races (or more specifically, no data races on problematic values such as interfaces, slices, and maps), then its memory accesses will never go wrong.
Now, to be fair, Go comes with out-of-the-box tooling to detect data races, which quickly finds the issue in my example.
However, in a real program, that means you have to hope that your test suite covers all the situations your program might encounter in practice, which is <em>exactly</em> the sort of issue that a strong type system and static safety guarantees are intended to avoid.
It is therefore not surprising that <a href="https://arxiv.org/pdf/2204.00764">data races are a huge problem in Go</a>,
and there is at least <a href="https://www.reddit.com/r/rust/comments/wbejky/comment/iid990t">anecdotal evidence of actual memory safety violations</a>.</p>

<p>I could accept Go’s choice as an engineering trade-off, aimed at keeping the language simpler.
However, putting Go into the same bucket as languages that actually <em>did</em> go through the effort of solving the problem with data races misrepresents the safety promises of the language.
Even experienced Go programmers do not always realize that you can break memory safety without using any unsafe operations or exploiting any compiler or language bugs.
Go is a language <em>designed</em> for concurrent programming, so people do not expect footguns of this sort.
I think that is a problematic blind spot.</p>

<p>The <a href="https://go.dev/ref/mem">Go memory model documentation</a> is not exactly upfront about this point either: the “Informal Overview” emphasizes that “most races have a limited number of outcomes” and remarks that Go is unlike “C and C++, where the meaning of any program with a race is entirely undefined”.
You could say that the use of “most” here is foreshadowing, but this section does not list any cases where the number of outcomes is unlimited, so this is easy to miss.
They even go so far as to claim that Go is “more like Java or JavaScript”, which I think is rather unfair, given the lengths to which those languages went to achieve the thread safety they have.
Only <a href="https://go.dev/ref/mem#restrictions">a later subsection</a> explicitly admits to the fact that <em>some</em> races in Go <em>do</em> have entirely undefined behavior (which is very unlike Java or JavaScript).</p>

<h2 id="conclusion">Conclusion</h2>

<p>I would argue that the actual property people care about when talking about memory safety is that <em>the program cannot break the language</em>.
All these <a href="https://alexgaynor.net/2020/may/27/science-on-memory-unsafety-and-security/">security vulnerabilities caused by memory safety violations</a> are cases where the code did something which isn’t even possible in the language specification, such as jumping to some user-provided array and <em>executing it as assembly code</em>.
The typical term we use for a program that breaks the language like that is <em>Undefined Behavior</em>.
The moment your program has UB, all bets are off; whether or not an attacker can then control how exactly this UB manifests and exploit it to their advantage is mostly an implementation detail.<sup id="fnref:mitigations"><a href="#fn:mitigations" rel="footnote" role="doc-noteref">2</a></sup></p>

<p>In my view, there’s a bright line dividing “safe” languages where programs cannot have Undefined Behavior, and “unsafe” languages where they can.
There’s no meaningful sense in which this can be further subdivided into memory safety, thread safety, type safety, and whatnot – it doesn’t matter <em>why</em> your program has UB, what matters is that a program with UB defies the basic abstractions of the language itself, and this is a perfect breeding ground for vulnerabilities.</p>

<p>In practice, of course, safety is not binary, it is a spectrum, and on that spectrum Go is much closer to a typical safe language than to C.
It is plausible that UB caused by data races is less useful for attackers than UB caused by direct out-of-bounds or use-after-free accesses.
But at the same time I think it is important to understand which safety guarantees a language reliably provides, and where the fuzzy area of trade-offs begins.
I am in the business of <a href="https://research.ralfj.de/thesis.html"><em>proving</em></a> safety claims of languages, and for Go, there’s not much one could actually prove.
I hope this post helps you to better understand some the non-trivial consequences of the choices different languages have made.<sup id="fnref:go"><a href="#fn:go" rel="footnote" role="doc-noteref">3</a></sup> :)</p>






    </article></div>
  </body>
</html>
