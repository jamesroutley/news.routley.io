<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/whatever_jamie/archive/stop-building-closed-ecosystems/">Original</a>
    <h1>Stop Building Closed Ecosystems</h1>
    
    <div id="readability-page-1" class="page"><div>

                

                
                    
                        <p><img alt="whatever_plug(2).jpg" src="https://buttondown.imgix.net/images/942115dd-5bda-4c76-8c8e-c686b2f8a991.jpg?w=960&amp;fit=max"/> </p>
<p>I’m sick of it. In the world of mobile development (though likely also elsewhere), we sink so much engineering talent into making tools that are great within-ecosystem, but as we don’t bother making them available to other ecosystems, everyone ends up reinventing the wheel.</p>
<p>The end result is that we stretch ourselves thin and waste time that could have been spent innovating new things.</p>
<h2>Titans don’t want to share</h2>
<p>Here I admit to donning my tinfoil hat, but so often, the problem starts with Big Tech creating walled gardens. For all the decades that Apple and Google have had to collaborate, how much code is actually shared between iOS and Android, besides their common Unix ancestry? Although both are platforms for handheld devices, with all the same needs, at the level facing the app developer, they have:</p>
<ul>
<li>different UI toolkits</li>
<li>different layout engines</li>
<li>different runtime languages</li>
<li>different SDKs</li>
<li>different app stores</li>
</ul>
<p>… so to deploy a native app to both platforms, we need to learn and write everything twice. It’s an insane amount of work, hence the rise of cross-platform solutions such as React Native and Flutter.</p>
<h2>Cross-platform ≠ salvation</h2>
<p>They’re both compelling frameworks. Flutter casts aside the disparate platforms and invents a new, consistent one; while React Native provides a single abstraction to tame all their differences. I’ve used both, and would happily recommend them for their better-than-native developer experience, even should one only need to target a single platform.</p>
<p>But while they do solve the “learn twice, write twice” problem, they’re still closed ecosystems. Flutter locks you into Dart, and React Native locks you into React. Neither can use each other’s native modules, and even the communities on Twitter mostly chat within their own circles.</p>
<p>I’ve focused on these two big names, but all frameworks are guilty. Electron, Capacitor, Tauri, Xamarin, Qt, NativeScript, the lot. Can’t we find some common ground and start building together instead of purely focusing within-ecosystem and making the hundredth cross-platform accelerometer plugin?</p>
<h2>Glimmers of hope</h2>
<p>I’ve been heartened by this kind of work (excuse my bias in examples—I can’t follow all ecosystems!):</p>
<ul>
<li><a href="https://skia.org" target="_blank">Skia</a> is a valuable building block, being the 2D graphics library used in Chrome, Firefox, and Flutter. It’s been brought to <a href="https://github.com/Shopify/react-native-skia" target="_blank">React Native</a> and used to implement the Web’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" target="_blank">Canvas API</a> in <a href="https://github.com/NativeScript/canvas" target="_blank">NativeScript</a>.</li>
<li><a href="https://github.com/software-mansion/react-native-gesture-handler" target="_blank">React Native Gesture Handler</a> is a declarative abstraction for gesture-handling in iOS and Android, and has also been <a href="https://github.com/nativescript-community/gesturehandler" target="_blank">ported to NativeScript</a>.</li>
</ul>
<p>… But this is merely <em>porting</em> code. It’s clear that, in each of these cases, a lot of effort was needed to adapt the code (as it was written for a different ecosystem) and ongoing maintenance will remain a burden.</p>
<p>What I’d really rather see more of is <strong>standalone platform-agnostic modules</strong>:</p>
<ul>
<li><a href="https://github.com/facebook/yoga" target="_blank">Yoga</a>, the standalone flexbox layout engine used in React Native, has bindings for various languages, allowing it to be used just about anywhere (indeed, in <a href="https://github.com/nodegui/nodegui" target="_blank">NodeGUI</a> and <a href="https://github.com/triniwiz/nativescript-plugins/tree/main/packages/nativescript-yogalayout" target="_blank">NativeScript</a>). Though I’m even more excited for <a href="https://github.com/DioxusLabs/taffy" target="_blank">taffy</a>, which aims to implement even more web layouts (and is already being ported to <a href="https://github.com/triniwiz/nativescript-mason" target="_blank">NativeScript</a>!).</li>
<li><a href="https://github.com/facebook/react-native/tree/main/packages/react-native/ReactCommon/jsi" target="_blank">JSI</a> is another masterpiece of engineering out of React Native—a single common interface for interop between JS and native code. It’s been presented as a solution for accessing native code synchronously in React Native, but it could equally be used in (or as the core of) any JS&lt;-&gt;native framework, as it’s an <a href="https://en.wikipedia.org/wiki/Foreign_function_interface" target="_blank">FFI</a>. As a case in point, it is soon to be integrated into the NativeScript <a href="https://github.com/NativeScript/ios/pull/186" target="_blank">iOS</a> runtime to help with layout code.</li>
</ul>
<p>There was actually some movement in this direction in the past. <a href="https://blog.expo.dev/whats-new-in-expo-modules-infrastructure-7a7cdda81ebc" target="_blank">Expo Unimodules</a> was a standard to allow writing a cross-platform, ecosystem-agnostic native module. Alongside the original adapter for <a href="https://github.com/expo/expo/tree/master/packages/%40unimodules/react-native-adapter" target="_blank">React Native</a>, proof-of-concepts were made for <a href="https://github.com/expo/expo/tree/a2aad4ea6e9f327d03a9852102e18387420f3254/packages/expo-contacts-flutter-plugin" target="_blank">Flutter</a> and <a href="https://github.com/nativescript-community/expo-nativescript" target="_blank">NativeScript</a> (by yours truly!), but it ultimately never took off and the effort was <a href="https://blog.expo.dev/whats-new-in-expo-modules-infrastructure-7a7cdda81ebc" target="_blank">sunset</a> in 2021 as a result.</p>
<p>The lack of interest in Unimodules taught me that it’s not enough to come up with an opt-in common standard. Native modules are hard enough to write for one’s own platform, let alone for others.</p>
<p>Given it’s far too late to convince each framework to redesign their native module interfaces from the ground up for compatibility, it may be worth exploring a top-down approach instead. That is, producing tools to translate modules from one ecosystem to another “whether they like it or not”. We proved this with <a href="https://github.com/OpenNative/open-native" target="_blank">Open Native</a>, which reverse-engineered the whole React Native native module format to allow other ecosystems to use them. It has proved its worth already by allowing several developers to reuse packages such as <a href="https://github.com/auth0/react-native-auth0" target="_blank">react-native-auth0</a>.</p>
<h2>What about the Web?</h2>
<p>The Web sets a great example in openness and reuse of work:</p>
<ul>
<li>Web apps can consume modules from Node.js and native ecosystems (via WASM) relatively painlessly.</li>
<li>The Web follows an open standards process.</li>
<li>Users can extend browser functionality (e.g. through Web Extensions and user style sheets).</li>
<li>Dev tools (like Prettier, eslint, and Webpack) aren’t tied to any particular ecosystem.</li>
<li>There are many options for programming languages (compile-to-JS, or WASM).</li>
<li>Framework authors take note of rival design patterns (e.g. JSX and Signals appear across multiple frameworks).</li>
<li>No gatekeeping by app stores.</li>
</ul>
<p>… I could go on. So why can’t native platforms take a bit more inspiration from the Web? Sure, we see pieces like HMR, JS, CSS, and flexbox here and there (e.g. React Native, NodeGUI, NativeScript), and even WebView-based frameworks that can reuse all the same technologies (it’s a start!), but why not the <em>spirit</em> of the Web as well?</p>
<h2>How we could do better</h2>
<p>Cross-community collaboration could be improved by adhering to a few principles:</p>
<ol>
<li><strong>Minimise vendor lock-in.</strong> You’ll only get cross-pollination if you make it easy to come and go.</li>
<li><strong>Check for prior art first.</strong> The problem may have been solved before, and it’s worth joining forces on existing efforts in any case.</li>
<li><strong>Be open-minded to other approaches.</strong> There are great ideas in all communities.</li>
<li><strong>Listen to the little guys.</strong> They’re the ones you’re building for!</li>
<li><strong>Decouple and share core modules.</strong> Anything from your UI logic to your bridging code could be handy to somebody else!</li>
</ol>
<p>Just imagine what we could achieve if we all worked together! For my part, I’ll keep pushing for that cause with my little experiments to bring together ecosystems, like <a href="https://github.com/shirakaba/react-native-native-runtime" target="_blank">bringing the Objective C runtime to React Native</a> and <a href="https://github.com/shirakaba/nativescript-html" target="_blank">bringing the web platform to NativeScript</a>.</p>
<p>And with any luck, see you in the next issue where again, I’ll talk about Whatever.</p>
                    
                

                
            </div></div>
  </body>
</html>
