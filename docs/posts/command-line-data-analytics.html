<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielcmoura.com/blog/2022/spyql-cell-towers/">Original</a>
    <h1>Command-line data analytics</h1>
    
    <div id="readability-page-1" class="page"><div>
      <!-- _layouts/post.html -->

<div>

  

  <article>
    <p>The command-line is incredibly powerful when it comes to data processing. Still, many of us working with data do not take advantage of it. I can think of some reasons:</p>

<ul>
  <li>
<strong>Poor readability</strong>: the focus is on minimising how much you need to type and not so much on how readable a sequence of commands is;</li>
  <li>
<strong>Steep learning curve</strong>: many commands, with many options;</li>
  <li>
<strong>Looks outdated:</strong> some of these tools are around since the 70s and target delimited text files (and not modern formats like JSON and YAML).</li>
</ul>

<p>These motivated me to write a command-line tool that focus on readability, easiness to learn and modern data formats, while leveraging the command-line ecosystem. On top of that, it also leverages the Python ecosystem! Meet <a href="https://github.com/dcmoura/spyql" target="_blank" rel="noopener noreferrer">SPyQL - SQL with Python in the middle</a>:</p>

<figure><pre><code data-lang="sql"><span>SELECT</span> 
  <span>date</span><span>.</span><span>fromtimestamp</span><span>(</span><span>purchase_ts</span><span>)</span> <span>AS</span> <span>purchase_date</span><span>,</span>
  <span>sum_agg</span><span>(</span><span>price</span> <span>*</span> <span>quantity</span><span>)</span> <span>AS</span> <span>total</span>
<span>FROM</span> <span>csv</span><span>(</span><span>&#39;my_purchases.csv&#39;</span><span>)</span>
<span>WHERE</span> <span>department</span><span>.</span><span>upper</span><span>()</span> <span>==</span> <span>&#39;IT&#39;</span> <span>and</span> <span>purchase_ts</span> <span>is</span> <span>not</span> <span>Null</span>
<span>GROUP</span> <span>BY</span> <span>1</span>
<span>ORDER</span> <span>BY</span> <span>1</span>
<span>TO</span> <span>json</span></code></pre></figure>



<p>I think the best way for getting to know SPyQL and getting comfortable with the command-line is to open a terminal and solve a problem. In this case, we will try to understand the geographical distribution of cell towers. Let’s start!</p>

<h2 id="setup">Setup</h2>

<p>Let’s start by installing SPyQL:</p>



<p>and check its version:</p>

<div><div><pre><code><span>$ </span>spyql <span>--version</span>
spyql, version 0.8.1
</code></pre></div></div>

<p>Let’s also install <a href="https://github.com/dcmoura/matplotcli" target="_blank" rel="noopener noreferrer">MatplotCLI</a>, a utility for creating plots from the command-line that leverages <a href="https://matplotlib.org" target="_blank" rel="noopener noreferrer">Matplotlib</a>:</p>

<div><div><pre><code><span>$ </span>pip3 <span>install</span> <span>-U</span> matplotcli
</code></pre></div></div>

<p>Finally, we will download some sample data (you can alternatively copy-paste the URL to your browser and download the file from there):</p>

<div><div><pre><code><span>$ </span>wget https://raw.githubusercontent.com/dcmoura/blogposts/spyql_cell_towers/spyql_cell_towers/sample.csv
</code></pre></div></div>

<p>This CSV file contains data about cell towers that were added to the <a href="https://www.opencellid.org/" target="_blank" rel="noopener noreferrer">OpenCellid</a> database on 2022 September 10 (<code>OCID-diff-cell-export-2022-09-10-T000000.csv</code> file from the <a href="https://www.opencellid.org/" target="_blank" rel="noopener noreferrer">OpenCellid</a> project redistributed without modifications under the <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener noreferrer">Creative Commons Attribution-ShareAlike 4.0 International License</a>).</p>

<h2 id="inspecting-thedata">Inspecting the data</h2>

<p>Let’s look to the data by getting the first 3 lines of the file:</p>

<div><div><pre><code><span>$ </span><span>head</span> <span>-3</span> sample.csv
radio,mcc,net,area,cell,unit,lon,lat,range,samples,changeable,created,updated,averageSignal
GSM,262,2,852,2521,0,10.948628,50.170324,15762,200,1,1294561074,1662692508,0
GSM,262,2,852,2501,0,10.940241,50.174076,10591,200,1,1294561074,1662692508,0
</code></pre></div></div>

<p>You could do this same operation with SPyQL:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT * FROM csv LIMIT 2&#34;</span> &lt; sample.csv
</code></pre></div></div>

<p>or</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT * FROM csv(&#39;sample.csv&#39;) LIMIT 2&#34;</span>
</code></pre></div></div>

<p>Notice that we are telling to get 2 rows of data and not 3 rows of the file (where the first is the header).</p>

<p>One advantage of SPyQL is that we can change the output format easily. Let’s change the output to JSON and look to the first record:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT * FROM csv(&#39;sample.csv&#39;) LIMIT 1 TO json(indent=2)&#34;</span>
<span>{</span>
  <span>&#34;radio&#34;</span>: <span>&#34;GSM&#34;</span>,
  <span>&#34;mcc&#34;</span>: 262,
  <span>&#34;net&#34;</span>: 2,
  <span>&#34;area&#34;</span>: 852,
  <span>&#34;cell&#34;</span>: 2521,
  <span>&#34;unit&#34;</span>: 0,
  <span>&#34;lon&#34;</span>: 10.948628,
  <span>&#34;lat&#34;</span>: 50.170324,
  <span>&#34;range&#34;</span>: 15762,
  <span>&#34;samples&#34;</span>: 200,
  <span>&#34;changeable&#34;</span>: 1,
  <span>&#34;created&#34;</span>: 1294561074,
  <span>&#34;updated&#34;</span>: 1662692508,
  <span>&#34;averageSignal&#34;</span>: 0
<span>}</span>
</code></pre></div></div>

<h2 id="querying-thedata">Querying the data</h2>

<p>Let’s first count how many records we have:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT count_agg(*) AS n FROM csv(&#39;sample.csv&#39;)&#34;</span>
n
45745
</code></pre></div></div>

<p>Notice that aggregation functions have the suffix <code>_agg</code> to avoid conflicts with Python’s functions like <code>min</code>, <code>max</code> and <code>sum</code>.
Now, let’s count how many cell towers we have by radio type:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT radio, count_agg(*) AS n FROM csv(&#39;sample.csv&#39;) GROUP BY 1 
ORDER BY 2 DESC TO pretty&#34;</span>
radio        n
<span>-------</span>  <span>-----</span>
GSM      31549
LTE      12996
UMTS      1182
CDMA        16
NR           2
</code></pre></div></div>

<p>Notice the pretty printing output. We can plot the above results by setting the output format to JSON and piping results into <a href="https://github.com/dcmoura/matplotcli" target="_blank" rel="noopener noreferrer">MatplotCLI</a>:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT radio, count_agg(*) AS n FROM csv(&#39;sample.csv&#39;) GROUP BY 1 
ORDER BY 2 DESC TO json&#34;</span> | plt <span>&#34;bar(radio, n)&#34;</span>
</code></pre></div></div>

<div>
	
	<div>
		<figure>

  <picture>
    <!-- <source media="(max-width: 480px)" srcset="/assets/img/matplotcli_count_by_type-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/matplotcli_count_by_type-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/matplotcli_count_by_type-1400.webp" />
    -->

    <!-- Fallback to the original file -->
    <img src="https://danielcmoura.com/assets/img/matplotcli_count_by_type.png" title="Plot with MatplotCLI"/>

  </picture>

</figure>
 
	</div>
	
</div>
<p>
Matplolib plot created by MatplotCLI using the output of a SPyQL query
</p>

<p>How easy was that? <strong>:-)</strong></p>

<h2 id="querying-the-data-a-more-complexexample">Querying the data: a more complex example</h2>

<p>Now, let’s get the top 5 countries with more cell towers added on that day:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT mcc, count_agg(*) AS n FROM csv(&#39;sample.csv&#39;) GROUP BY 1 ORDER BY 2 DESC LIMIT 5 TO pretty&#34;</span>
  mcc      n
<span>-----</span>  <span>-----</span>
  262  24979
  440   5085
  208   4573
  310   2084
  311    799
</code></pre></div></div>

<p>MCC stands for Mobile Country Code (262 is the code for Germany). The first digit of the MCC identifies the region. Here’s an exert from <a href="https://en.wikipedia.org/wiki/Mobile_country_code" target="_blank" rel="noopener noreferrer">Wikipedia</a>:</p>

<div><div><pre><code>0: Test networks
2: Europe
3: North America and the Caribbean
4: Asia and the Middle East
5: Australia and Oceania
6: Africa
7: South and Central America
9: Worldwide
</code></pre></div></div>

<p>Let’s copy paste the above list of regions and create a new file named <code>mcc_geo.txt</code>. On the mac this is as easy as <code>$ pbpaste &gt; mcc_geo.txt</code>, but you can also paste this into a text editor and save it.</p>

<p>Now, let’s ask SPyQL to open this file as a CSV and print its contents:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT * FROM csv(&#39;mcc_geo.txt&#39;) TO pretty&#34;</span>
  col1  col2
<span>------</span>  <span>-------------------------------</span>
     0  Test networks
     2  Europe
     3  North America and the Caribbean
     4  Asia and the Middle East
     5  Australia and Oceania
     6  Africa
     7  South and Central America
     9  Worldwide
</code></pre></div></div>

<p>SPyQL detected that the separator is a colon and that the file has no header. We will use the <em>colN</em> syntax to address the <em>Nth</em> column.</p>

<p>Now, let’s create a single JSON object with as many key-value pairs as input rows. Let the 1st column of the input be the <em>key</em> and the 2nd column be the <em>value</em>, and save the result to a new file:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;SELECT dict_agg(col1,col2) AS json FROM csv(&#39;mcc_geo.txt&#39;) TO json(&#39;mcc_geo.json&#39;, indent=2)&#34;</span>
</code></pre></div></div>

<p>We can use <code>cat</code> to inspect the output file:</p>

<div><div><pre><code><span>$ </span><span>cat </span>mcc_geo.json                                               
<span>{</span>
  <span>&#34;0&#34;</span>: <span>&#34;Test networks&#34;</span>,
  <span>&#34;2&#34;</span>: <span>&#34;Europe&#34;</span>,
  <span>&#34;3&#34;</span>: <span>&#34;North America and the Caribbean&#34;</span>,
  <span>&#34;4&#34;</span>: <span>&#34;Asia and the Middle East&#34;</span>,
  <span>&#34;5&#34;</span>: <span>&#34;Australia and Oceania&#34;</span>,
  <span>&#34;6&#34;</span>: <span>&#34;Africa&#34;</span>,
  <span>&#34;7&#34;</span>: <span>&#34;South and Central America&#34;</span>,
  <span>&#34;9&#34;</span>: <span>&#34;Worldwide &#34;</span>
<span>}</span>
</code></pre></div></div>

<p>Basically, we have aggregated all input lines into a Python dictionary, and then saved it as a JSON file. Try removing the <code>AS json</code> alias from the <code>SELECT</code> to understand why we need it :-) </p>

<p>Now, let’s get the statistics by region instead of by MCC. For this, we will load the JSON file that we just created (with the <code>-J</code> option) and do a dictionary lookup:</p>

<div><div><pre><code><span>$ </span>spyql <span>-Jgeo</span><span>=</span>mcc_geo.json <span>&#34;SELECT geo[mcc//100] AS region, count_agg(*) AS n 
FROM csv(&#39;sample.csv&#39;) GROUP BY 1 ORDER BY 2 DESC TO pretty&#34;</span>
region                               n
<span>-------------------------------</span>  <span>-----</span>
Europe                           35601
Asia and the Middle East          5621
North America and the Caribbean   3247
Australia and Oceania              894
Africa                             381
South and Central America            1
</code></pre></div></div>

<p>We do an integer division by 100 to get the 1st digit of the MCC and then we lookup this digit on the JSON we just created (which is loaded as a Python dictionary). This how we do a JOIN in SPyQL, via a dictionary lookup :-)</p>

<h2 id="leveraging-python-libs-on-yourqueries">Leveraging Python libs on your queries</h2>

<p>Another advantage of SPyQL is that we can leverage the Python ecosystem. Let’s try to do some more geographical statistics. Let’s count towers by H3 cell (resolution 5) for Europe. First, we need to install the <a href="https://github.com/uber/h3-py" target="_blank" rel="noopener noreferrer">H3 lib</a>:</p>



<p>Then, we can convert latitude-longitude pairs into H3 cells, count how many towers we have by H3 cell, and save results into a CSV:</p>

<div><div><pre><code><span>$ </span>spyql <span>&#34;IMPORT h3 SELECT h3.geo_to_h3(lat, lon, 5) AS cell, count_agg(*) AS n 
FROM csv(&#39;sample.csv&#39;) WHERE mcc//100==2 GROUP BY 1 TO csv(&#39;towers_by_h3_res5.csv&#39;)&#34;</span>
</code></pre></div></div>

<p>Visualising these results is fairly simple with Kepler. Just go to <a href="https://kepler.gl/demo" target="_blank" rel="noopener noreferrer">kepler.gl/demo</a> and open the above file. You should see something like this:</p>

<div>
	<div>
		<figure>

  <picture>
    <!-- <source media="(max-width: 480px)" srcset="/assets/img/kepler_h3_cell_towers-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/kepler_h3_cell_towers-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/kepler_h3_cell_towers-1400.webp" />
    -->

    <!-- Fallback to the original file -->
    <img src="https://danielcmoura.com/assets/img/kepler_h3_cell_towers.png" title="Kepler visualization of aggregations by H3 cell (resolution 5) from SPyQL"/>

  </picture>

</figure>

	</div>
</div>
<p>
Kepler visualization of aggregations by H3 cell (resolution 5) from SPyQL
</p>



<p>I hope you enjoyed SPyQL and that I could show you how simple it makes to query data from the command-line. In this first post about SPyQL, we are just scratching the surface. There is a lot more we can do. We have barely leveraged the Shell and Python ecosystems in this article. And we worked with a small file (SPyQL can handle GB-size files without compromising system resources). So, stay tuned!</p>

<p>Try out SPyQL and reach back to me with your thoughts. Thank you!</p>



<ul>
  <li>
    <p>SPyQL repo: <a href="https://github.com/dcmoura/spyql" target="_blank" rel="noopener noreferrer">github.com/dcmoura/spyql</a></p>
  </li>
  <li>
    <p>SPyQL documentation: <a href="https://spyql.readthedocs.io" target="_blank" rel="noopener noreferrer">spyql.readthedocs.io</a></p>
  </li>
  <li>
    <p>MatplotCLI repo: <a href="https://github.com/dcmoura/matplotcli" target="_blank" rel="noopener noreferrer">github.com/dcmoura/matplotcli</a></p>
  </li>
</ul>

<hr/>

<p>SPyQL is open-source (<a href="https://github.com/dcmoura/spyql/blob/master/LICENSE" target="_blank" rel="noopener noreferrer">MIT license</a>).
If you like the project, please consider giving it a <a href="https://github.com/dcmoura/spyql" target="_blank" rel="noopener noreferrer">star</a>. I celebrate every star and every fork the project gets :-). All kind of contributions are welcomed, just reach out to me before you start coding. Thank you!</p>

  </article>

</div>

    </div></div>
  </body>
</html>
