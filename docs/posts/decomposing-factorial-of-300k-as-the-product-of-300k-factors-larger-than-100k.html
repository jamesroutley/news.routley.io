<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://gus-massa.blogspot.com/2025/04/decomposing-factorial-of-300k-as.html">Original</a>
    <h1>Decomposing factorial of 300K as the product of 300K factors larger than 100K</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-4133629183163280366" itemprop="description articleBody">
<p><span>A few days ago, <a href="https://terrytao.wordpress.com/2025/03/26/decomposing-a-factorial-into-large-factors/">Terence Tao proposed a challenge to decompose the 300K! as the product of 300K factors larger than 100K</a>. A smaller example is decomposing 10! as the product of 10 factor greater or equal than 3.</span></p><p><span>  10! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10</span></p><p><span>He was able to show a decomposition of 300K! </span><span>as the product of 300K factors larger than only 90K, and proposed a method to try to use larger numbers. This is part of an attempt to prove a conjecture, so the complete problem is more general, but let´s try to solve this case.</span></p><p><span>We will fix N=300K that is the case analyzed by Tao in the post. The idea by Tao is to start with a odd number B that is a product of 300K odds numbers larger than 100K, and attempt to fix the difference. One important point is that 300! is even, so the idea is to get try to use the 2 to help in this task.</span></p><p><span>He defines the B-heavy primes that are the primes that appear more time in B than in N!=300!, and </span><span>the N!-heavy primes that are the primes that appear more time in N!=300! than in B. The idea is to replace each </span><span>B-heavy prime with bigger a </span><span>N!-heavy prime n multiplied by a power of 2, or by a pure </span><span>power of 2. This will increase the factor of B and we will get the requested decomposition.It&#39;s important to use as few 2 as possible, so we don&#39;t run out of them. All of this is <a href="https://terrytao.wordpress.com/2025/03/26/decomposing-a-factorial-into-large-factors/">better explained in Tao&#39;s post</a>, so it&#39;s worth reading it.</span></p><p><span>He was able to apply this method to get a decomposition with number that are larger than  90K bu the mapping and use of 2 was not optimal, so it was not good enough for 100K. We are going to find the optimal way to do this mapping and get </span><span>a decomposition with number that are larger than 100K.</span></p><h4><span>A preamble</span></h4><p><span>We will use <a href="https://racket-lang.org/">Racket</a>. First we will try to reproduce the result with 90K.</span></p><p><span>We will fix N=300K and write a memoized version of factorize, because factorization is hard and slow, and we will reuse the same number a lot.</span></p><p><span>#lang racket</span><span></span></p><h4><span>Factorization of N!=300K!</span></h4><p><span>It&#39;s much better to factorize each number an collect the factorizations, than using the builtin factorial and try to factorize the result that may take a very long time (or fail, because factorizing  big numbers is hard)..</span></p><p><span>(define (hash-add-factorization! h f)</span><span><br/></span></p><p><span>The output is</span></p><p><span>N! factorization calculation (N=300000): cpu time: 4828 real time: 4825 gc time: 406</span><span>  <br/></span></p><p><span> It takes like 4 second to calculate the factorization, and we get the same number of 2 than Tao. (A lot of 2.)</span></p><h4><span>Factorization of B (L=90K, A=50)</span></h4><p><span>To reproduce the result, we will se the same L and A than Tao, so the number B is 50 copies of the odds numbers between 90K and 102K. The calculation consider the case where the number A does not divide N, and I decked to add more odd numbers starting from L.</span></p><p><span>(define (factorize-B-number N L size)</span></p><p><span>The output is</span></p><p><span>B factorization calculation (L=90000, A=50): cpu time: 531 real time: 534 gc time: 46</span></p><p><span>It&#39;s faster and it takes only half a second because the factorizations are memoized, I got 50 more primes counted with multiplicity. I was using a complicated method to calculate the odds number that are repeated, but I changed it to the simple and slow method, but the 50 extra primes don&#39;t disappear. Any insight or bug report is welcome.</span></p><h4><span>N!-heavy and B-heavy</span></h4><p><span>Now we compare the factorization of N! and B, remove the repeated primes (counted with multiplicity).</span></p><p><span>(define (factorization-split N B)</span></p><p><span>The output is</span></p><p><span>N! heavy part excluding 2: </span></p><p><span>Unsurprisingly, I got again 50 more primes 
counted with multiplicity than the expected number</span></p><h4><span>Balance primes in order</span></h4><p><span>Now we try to </span><span>replace each </span><span>B-heavy prime with bigger a </span><span>N!-heavy prime n multiplied by a power of 2, or a pure </span><span>power of 2. I couldn&#39;t write the method explained by Tao, so I made my own. Just match the primes (counted with multiplicity) in order. </span></p><p><span>There are more primes </span><span> (counted with multiplicity) </span><span> in B than in N!, so we pad the list with 1s. In spite 1 is not a prime, we will add it to the factorization lis to annoy mathematicians and make the program slightly simpler..We can put the 1s at the beginning or at the end, so there are two results.</span></p><p><span>The result of each function is the amount of unused 2, so 0 or positive is good, we can distribute them arbitrarily or save them for a future problem :). Also we get the replacement table of he heavy primes in B with the heavy primes in N! (counted with multiplicity, may include 1)  and powers of 2. This makes the verification easier.  <br/></span></p><p><span>(display &#34;--------------------------&#34;)</span></p><p><span>The output is</span></p><p><span>Balance primes / match first primes: </span></p><p><span>We got 6108 and 6497 unused 2, so the second method is better. I&#39;m not sure why, but it&#39;s interesting that the first method replaces 3 with 11, and the second replaces  with 4 that is ess wasteful. <br/></span></p><p><span>We can compare the results with the 6853 obtained by Tao with his method. But we have 50 more primes (cwm) so we may compare them with 6853+50*17=6003. They are similar, an I will unilaterally proclaim a successful reproduction. <br/></span></p><h4><span>Verification of the conversion tables</span></h4><p><span>I can´t imagine a mistake in the previous code, but just in case let&#39;s verify the conversion tables have the same primes than B-heavy and N!-heavy and the correct power of 2.</span></p><p><span>It will be useful to verify the next method that is not straightforward. <br/></span></p></div></div>
  </body>
</html>
