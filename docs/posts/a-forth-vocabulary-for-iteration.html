<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.information-superhighway.net/a-forth-vocabulary-for-iteration">Original</a>
    <h1>A Forth Vocabulary for Iteration</h1>
    
    <div id="readability-page-1" class="page"><div><p>I recently wrote a small 16-bit Forth for 8086 PCs running DOS. I built the basic one-liner loop words that can trivially be built with just “branch if zero” and “goto”: <code>begin</code>, <code>while</code>, <code>repeat</code>, <code>until</code>, <code>again</code>. But I held off on implementing <code>do</code> / <code>loop</code> at first.</p>

<p>It didn&#39;t seem like too much of a hardship. In a previous Forth I&#39;d built, I&#39;d implemented <code>do</code> / <code>loop</code> using the return stack, but it was... ugly. The code to implement it was ugly, the code it generated was ugly (and large!), and I didn&#39;t find a lot of places where it was actually much nicer to use than explicit <code>begin</code>-based loops. I was able to implement an 8086 assembler and a Minesweeper game without bothering to build <code>do</code> / <code>loop</code>. I didn&#39;t really miss it, but I had a design percolating in the back of my mind that I wanted to try.</p>

<p>At some point I came across some writing that suggested that Forth had a “loop control stack”. Wouldn&#39;t it be nice if I could implement some kind of loop control stack that worked for <em>all</em> kinds of iteration?</p>

<p>The thing I built has blown me away with how flexible, composable, and useful it&#39;s turned out to be. It&#39;s <em>way</em> more powerful than I was expecting. And the code that leverages it is inevitably much simpler and easier to read.</p>

<h2 id="the-stacks" id="the-stacks">The Stacks</h2>

<p>I added <em>two</em> loop control stacks – what I call the <code>i-stack</code>, and the <code>next-stack</code>. The <code>i-stack</code> contains the current value(s) being iterated over, and is read from with the <code>i</code> and <code>j</code> words like normal. The <code>next-stack</code> is where the magic happens.</p>

<p>When iterating, the top value of the <code>next-stack</code> is a pointer to a small structure called an iterator. It&#39;s a very simple structure, only two cells. The first cell contains the execution token of a word that will either update the current values on the <code>i-stack</code> and return true, or remove its state from both stacks and return false. The second cell points to a cancellation function, that cleans up whatever state the iterator has kept on the two stacks without iterating further, and returns nothing.</p>

<h2 id="iterators" id="iterators">Iterators</h2>

<p>I built some simple helpers for creating iterators. It took a few tries to nail down this design, but I&#39;m happy with it now. <code>defiter</code> creates a “blank” iterator, which, when called, pushes itself to the <code>next-stack</code>. <code>:iter</code> does the same thing but allows you to write some code that accepts parameters and prepares the loop stacks first. <code>:next</code> defines a new anonymous “next-word” and assigns it to the most-recently defined iterator. <code>:cancel</code> does the same thing, but for cancellation.</p>

<p>On its own, this is already quite nice. I&#39;ve got a page or so of basically-trivial iterators. Here&#39;s one:</p>

<pre><code>:iter times ( n -- ) &gt;i ;
:next &lt;i dup 1- &gt;i finish? ;
:cancel idrop nextdrop ;
</code></pre>

<p><code>times</code> keeps its state in the <code>i-stack</code> – it initializes itself by pushing the number of times to repeat onto it. When fetching the next value, it pops the current value off the <code>i-stack</code>, decrements it, and pushes it back, leaving the old value on the data stack. <code>finish?</code> is a simple helper word that peeks at the top of the stack and runs the current cancellation function if it&#39;s false, or in this case, if we&#39;ve already hit 0. Since cleaning up after an iterator is often the same job whether you&#39;re exiting early or not, this word is very handy. Explicitly defining cancellation for this iterator isn&#39;t actually necessary in my current implementation, because <code>idrop nextdrop</code> is common enough that I use it as the default.</p>

<h2 id="each-next" id="each-next">each / next</h2>

<p>I can use these iteration words (within a compiled definition) like this:</p>

<pre><code>5 times each i . next
( outputs: 4 3 2 1 0 )
</code></pre>

<p>All the common loop types are easy to build in this system, as well as some uncommon ones:</p>

<pre><code>5 10 for each i . next ( outputs: 5 6 7 8 9 )
0 10 2 for+ each i . next ( outputs: 0 2 4 6 8 )
( pchars yields pointers to each byte in a zero-terminated string )
s&#34; hello&#34; pchars each i b@ emit next ( outputs: hello )
</code></pre>

<p>Generic cancellation, of course, allows us to trivially implement <code>break</code>; just cancel the iteration at the top of the stack, and then jump to the <code>each</code> loop exit point, after <code>next</code>. <code>continue</code> is even simpler, just jump back to the top of the loop.</p>

<pre><code>5 times each i 3 &lt; if break then i . next ( outputs: 4 3 )
5 times each i 2 % if continue then i . next ( outputs 4 2 0 )
</code></pre>

<p>Under the hood, <code>each</code> just calls the “next-word” of the iterator and jumps to the end of the loop if it returns 0 – conceptually identical to <code>begin iterate while</code>, with <code>next</code> meaning the same thing as <code>repeat</code>. This allows for iterators that return no values.</p>

<pre><code>0 times each i . next ( outputs: )
</code></pre>

<h2 id="generators" id="generators">Generators</h2>

<p>That&#39;s <em>nice</em>, but it&#39;s not exactly setting the world on fire; it&#39;s a fair amount of work just to end up with a few different ways of writing “for” loops in practice, that Forth systems have had forever anyway. Is it really worth the cost of this abstraction?</p>

<p>Turns out, absolutely, yes, it is, because you can also build generators on it, and that blows things <em>wide</em> open.</p>

<p>First, a simple example:</p>

<pre><code>: 5-2-8 (( 5 yield 2 yield 8 yield )) ;
5-2-8 each i . next ( outputs: 5 2 8 )
</code></pre>

<p><code>((</code> defines the start of the generator, and <code>))</code> defines the end (and pushes it onto the <code>next-stack</code>). <em>Any valid Forth code goes in between</em>. <code>yield</code> takes the top of the stack, pushes it onto the <code>i-stack</code>, and then <em>suspends the generator</em> until the next iteration. How does this work? Essentially, <code>yield</code> takes the top of the return stack and pushes it onto the <code>next-stack</code>, then pushes an iterator that pops it off the <code>next-stack</code> and pushes it back onto the return stack. The details get a little messier in order to support some more advanced use cases, but that&#39;s the simple idea at the core of it.</p>

<p>OK, neat trick, we&#39;ve built ourselves a nice little coroutine-like system. But wait! It gets better! When <code>yield</code> resumes, it immediately removes all of its state from the iteration stacks. This means that <em>generators can safely interact with any iterator that might be “underneath” it</em>. They can iterate over things and yield in the middle! They can yield <em>different things</em> based on those values! We&#39;ve accidentally built an extremely powerful, totally generic map/filter capability!</p>

<pre><code>: doubled (( each i i + map next )) ;
5 times doubled each i . next ( outputs: 8 6 4 2 0 )
: odd (( each i 2 % filter next )) ;
5 times odd each i . next ( outputs: 3 1 )
</code></pre>

<p><code>map</code> and <code>filter</code> are more <code>yield</code>-like words – it turns out that there&#39;s a number of these that you might want to implement, with different logic for suspending, resuming, and cancelling. <code>map</code> saves the top of the <code>i-stack</code> onto the <code>next-stack</code> and replaces it with the input, restoring the original value after resuming (necessary since the iterator underneath might be using that value as its state). <code>filter</code> conditionally suspends based on the top of the data stack but otherwise doesn&#39;t touch the <code>i-stack</code>, leaving whatever iterator is running underneath to provide the value. Both of these words push iterators with special <code>cancel</code> logic that knows that there is another iterator underneath, and can <code>cancel</code> again recursively once they&#39;ve cleaned themselves up.</p>

<h2 id="generator-state" id="generator-state">Generator state</h2>

<p>This design can <em>almost</em> be made to work for generators that have extra state, but it&#39;s awkward and incomplete. You must ensure the data stack is clean whenever you yield, so you&#39;re forced to manually shuffle data to and from the next stack. Consider a filter that only returns values that are divisible by a certain number:</p>

<pre><code>: divisible-by ( n -- ) &gt;next 
  (( &lt;next each i over % 0 = swap &gt;next filter &lt;next next drop )) ;
5 divisible-by 21 times each i . next ( ouputs: 20 15 10 5 0 )
</code></pre>

<p>This works, but there&#39;s so much stack noise! And it breaks down if you need to cancel, because <code>filter</code> has no idea that there&#39;s extra stuff on the <code>next-stack</code> that it needs to clear. Ideally there would be some automatic way of keeping the state of the generator on the data stack while it&#39;s running, and push it safely away when we suspend. Could there be some way to write <code>divisible-by</code> like this?</p>

<pre><code>: divisible-by ( n -- ) &gt;arg (( each i over % 0 = filter next drop )) ;
</code></pre>

<p>In fact, this code works in my implementation. The scheme to make this happen is a little bit subtle, but it can be done efficiently with a minimum of bookkeeping noise in most cases. I define a variable, <code>gen-arg-count</code>, that starts at zero. <code>&gt;arg</code> is an immediate word that compiles a call to <code>&gt;next</code> and increments that variable. Then, any time I compile a yielding word, I append the value of <code>gen-arg-count</code> to the instruction stream – much like <code>lit</code>. When suspending, the yielding word reads that value out of the instruction stream and transfers that many values from the data stack to the <code>next-stack</code>. Then it moves the pointer to the instruction stream from the return stack to the <code>next-stack</code>, and finally pushes the yielding iterator. That iterator then pulls the instruction pointer back off the <code>next-stack</code> to determine how many values to move from the <code>next-stack</code> back onto the data stack, as well as where to resume the instruction stream. Cancellation similarly can read the <code>arg-count</code> byte to know how many extra values to drop from the <code>next-stack</code>.</p>

<p>Generators need to ensure the data stack is empty before exiting at <code>))</code>. At one point I considered having <code>))</code> compile the appropriate number of <code>drop</code> calls automatically, but in the end I decided that it&#39;s reasonable and idiomatic to expect a generator to exit with a clean stack, like any other Forth word would.</p>

<p>With this extension, it&#39;s trivial to write all kinds of new iterators – we could even do away with the base iterator system entirely and just express everything as generators. There are lots nice one-line definitions of <code>times</code>:</p>

<pre><code>( 1 ) : times ( n -- ) &gt;arg (( begin dup while 1- dup yield repeat drop )) ;
( 2 ) : times ( n -- ) &gt;next (( &lt;next begin dup while 1- yield&gt; repeat drop )) ;
( 3 ) : times ( n -- ) &gt;arg (( -arg begin dup while 1- yield&gt; repeat drop )) ;
( 4 ) ( suspend ) &#39; noop ( resume ) &#39; noop ( cancel ) &#39; idrop :yield iyield
: times ( n -- ) &gt;i (( begin i while &lt;i 1- &gt;i iyield repeat idrop )) ;
</code></pre>

<p>Definition 1 doesn&#39;t use anything I haven&#39;t already explained. The state of the iterator is managed on the data stack, and automatically shuffled back and forth from the <code>next-stack</code> by <code>yield</code>.</p>

<p>Definition 2 adds a new word. <code>yield&gt;</code> is a yielder that moves the yielded value from the <code>i-stack</code> back onto the data stack when it resumes, instead of dropping it. The state of the iterator starts on the <code>next-stack</code> but is moved to the <code>i-stack</code> once the iteration loop actually starts.</p>

<p>Definition 3 is virtually the same as 2, but demonstrates the ability to handle changes in the amount of state. <code>-arg</code> is an immediate word that generates no code, but decrements <code>gen-arg-count</code> so that you can express that you&#39;ve consumed the argument and the next yield should preserve one less value on the data stack. (<code>+arg</code> is also defined, performing an increment, in case you generate more values on the stack than you started with.)</p>

<p>Definition 4 is built to keep all state on the <code>i-stack</code> from the beginning. Here we use <code>:yield</code> to define a new yielding word. I realized I hadn&#39;t built a yielder that left the <code>i-stack</code> alone when resuming, but would drop the value when cancelling, so I added one.</p>

<p>All of these options will correctly be cancelled if the code iterating over it calls <code>break</code>, with no special effort!</p>

<h2 id="final-thoughts" id="final-thoughts">Final thoughts</h2>

<p>With this scheme, generators always take up at least two spaces on the <code>next-stack</code> – one for the yielder&#39;s iterator, and one for the resume point. But if <em>all</em> iterators were defined as generators, and all yielding words had to be defined with <code>:yield</code> to ensure a uniform structure, we could just push the resume point. <code>iterate</code> and <code>cancel</code> could easily find the appropriate function pointer by looking next to the resume point for the address of the yielder and digging inside. I think this could be built in such a way that it would be basically as efficient as the existing scheme, at the cost of making the whole thing more complex to explain. It might be worth pursuing, because generators are so pleasant to read and write, and raw iterators are... less so. I basically never want to write a raw iterator besides the very basic ones that are built-in.</p>

<p>All <a href="https://bitbucket.org/SpindleyQ/dialer/src/main/" rel="nofollow">the source for my Forth system</a> is available online; the iteration system is defined in <a href="https://bitbucket.org/SpindleyQ/dialer/src/main/iter.jrt" rel="nofollow"><code>iter.jrt</code></a>. There are some interesting examples of generators in <a href="https://bitbucket.org/SpindleyQ/dialer/src/main/embed.jrt" rel="nofollow"><code>embed.jrt</code></a>, <a href="https://bitbucket.org/SpindleyQ/dialer/src/main/dialer.jrt" rel="nofollow"><code>dialer.jrt</code></a> and <a href="https://bitbucket.org/SpindleyQ/dialer/src/main/rick.jrt" rel="nofollow"><code>rick.jrt</code></a> – some highlights:</p>
<ul><li><a href="https://bitbucket.org/SpindleyQ/dialer/src/314ee8b4765a864412d5a74874455a6a1cd9e48f/embed.jrt?at=main#lines-47" rel="nofollow"><code>rle-decode</code></a> – takes a pointer to some run-length encoded packed data, yields a stream of values. Uses the <code>times</code> iterator internally to count off the repeated values.</li>
<li><a href="https://bitbucket.org/SpindleyQ/dialer/src/314ee8b4765a864412d5a74874455a6a1cd9e48f/dialer.jrt?at=main#lines-222" rel="nofollow"><code>menu-options</code></a> – Provides a dynamic list of items to display in a menu. Yields 2 values at a time – the text to display, and the function to execute when the user selects it.</li>
<li><a href="https://bitbucket.org/SpindleyQ/dialer/src/314ee8b4765a864412d5a74874455a6a1cd9e48f/dialer.jrt?at=main#lines-111" rel="nofollow"><code>xmit-iter</code></a> – Writes text to the screen with a small delay between each character, to simulate a slow serial connection. An extremely simple loop that can be driven by complex generation logic – including <a href="https://bitbucket.org/SpindleyQ/dialer/src/314ee8b4765a864412d5a74874455a6a1cd9e48f/dialer.jrt?at=main#lines-211" rel="nofollow">streaming RLE-encoded data with embedded colour information</a>.</li></ul>
</div></div>
  </body>
</html>
