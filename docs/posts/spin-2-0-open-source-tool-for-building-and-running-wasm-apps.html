<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fermyon.com/blog/introducing-spin-v2">Original</a>
    <h1>Spin 2.0 – open-source tool for building and running WASM apps</h1>
    
    <div id="readability-page-1" class="page"><div>
            <article>
                
                
                <p><img src="https://www.scattered-thoughts.net/log/static/image/spin-v2-header.png" alt="../static/image/spin-v2-header.png"/></p>
<p>The Fermyon team is proud to introduce <a href="https://github.com/fermyon/spin/releases/tag/v2.0.0">Spin 2.0</a> — a new major release of <a href="https://github.com/fermyon/spin">Spin</a>, the open source developer tool for building, distributing, and running WebAssembly (Wasm) applications in the cloud.</p>
<p><a href="https://webassembly.org/">Wasm</a> is a technology that is <a href="https://www.fermyon.com/blog/four-domains-wasm">making its way into more and more parts of modern computing</a> — from browser applications, to plugin systems, IoT scenarios and <a href="https://www.fermyon.com/blog/how-to-think-about-wasm">more</a>, and Spin makes it possible to build your serverless-style APIs, websites, full-stack or AI-capable applications as WebAssembly components, generating applications that are:</p>
<ul>
<li><em>orders</em> of magnitude smaller than container images</li>
<li>entirely portable across operating systems and CPU architectures</li>
<li>with <a href="https://fermyon.github.io/spin-benchmarks/criterion/reports/spin-executor__noop/concurrency-1/index.html">incredibly low startup latency</a> and capable of running tens of thousands of requests per second</li>
<li>capable of running <em>anywhere</em>, from tiny devices such as Raspberry Pis, in <a href="https://www.docker.com/blog/announcing-dockerwasm-technical-preview-2/">Docker Desktop</a>, <a href="https://developer.fermyon.com/spin/v2/kubernetes">Kubernetes</a>, <a href="https://www.fermyon.com/blog/spin-nomad">Nomad</a>, or <a href="https://fermyon.com/cloud">Fermyon Cloud</a>, and in even more places soon!</li>
</ul>
<p>Since we <a href="https://www.fermyon.com/blog/introducing-spin">first introduced Spin</a>, our goal has been to create a foundation for a new kind of computing platform that could take advantage of WebAssembly’s runtime characteristics, and for Spin 2.0, we worked with the community on a few key scenarios:</p>
<ul>
<li>enabling WebAssembly component composition</li>
<li>improving performance</li>
<li>laying the foundation for Wasm portability across runtimes and implementations</li>
<li>improving the developer experience, capability support, and SDK ergonomics</li>
</ul>
<p>Let’s dive into what Spin 2.0 looks like!</p>
<!-- break -->
<h2>Hello, Spin!</h2>
<p><img src="https://www.scattered-thoughts.net/log/static/image/spin-v2-intro.png" alt="../static/image/spin-v2-intro.png"/></p>
<p>Spin is a developer tool and framework that guides users through creating, compiling, distributing, and running server-side applications with WebAssembly.
You can take advantage of the <code>spin new</code>, <code>spin build</code>, and <code>spin up</code> set of commands to start your journey:</p>
<pre><code># Create a new application with one JavaScript component and enter it&#39;s directory
$ spin new hello-spin2 --template http-js
$ cd hello-spin2
# Add a new component written in Rust to our application
$ spin add hellorust --template http-rust

</code></pre>
<p>This creates all the configuration and source code required to run our application.
Spin 2.0 comes with an <a href="https://github.com/fermyon/spin/blob/main/docs/content/sips/005-manifest-redesign.md">updated</a> <code>spin.toml</code> manifest that focuses on simplicity and on the capabilities a component is allowed to access. Let’s have a look at the manifest for a simple component that is allowed to access a Redis database:</p>
<pre><code># The HTTP route /hello-spin2 should be handled by the `hello-spin2` component
[[trigger.http]]
route = &#34;/hello-spin2&#34;
component = &#34;hello-spin2&#34;

[component.hello-spin2]
# The Wasm component to be instantiated and executed when receiving a request
source = &#34;target/hello-spin2.wasm&#34;

# Any capability this component can access (files, variables,
# outbound connections, KV stores, databases) must be declared
# in the component manifest.
# For example, this component can only make outbound connections
# to the following hosts:
allowed_outbound_hosts = [&#34;rediss://my-redis-server&#34;]

[component.hello-spin2.build]
# The command to execute when building this component
command = &#34;npm run build&#34;

</code></pre>
<p>At this point, you can write a handler function using any of the <a href="https://developer.fermyon.com/spin/v2/language-support-overview">supported languages</a>, such as Rust, JavaScript, TypeScript, or Go (or any language that <a href="https://www.fermyon.com/wasm-languages/index">compiles to WASI</a>).</p>
<p>Now let’s look at a simple component written in JavaScript — a single <code>handler</code> function that takes a request, then returns a response:</p>
<pre><code>// Hello world in JavaScript.
export async function handler(req, res) {
    res.status(200).body(&#34;Hello, Spin 2.0 from JavaScript!&#34;)
}
</code></pre>
<p>When writing your applications, you can interact with built-in persistence, configuration, or data services from your Wasm components, or communicate with external systems. Here is a sample of what you can do today from a component running in Spin:</p>
<ul>
<li>persistence using <a href="https://developer.fermyon.com/spin/v2/kv-store-api-guide">the build-in key value store</a>, <a href="https://developer.fermyon.com/spin/v2/sqlite-api-guide">built-in SQLite database</a>, <a href="https://developer.fermyon.com/spin/v2/rdbms-storage">external database support for MySQL and PostgreSQL</a>, <a href="https://developer.fermyon.com/spin/v2/redis-outbound">Redis</a></li>
<li><a href="https://developer.fermyon.com/spin/v2/variables">built-in dynamic application variables</a>, <a href="https://developer.fermyon.com/spin/v2/dynamic-configuration#vault-application-variable-provider">powered by Vault</a></li>
<li>outbound connectivity to any HTTP API, now built on top of the <a href="https://github.com/webassembly/wasi-http"><code>wasi-http</code> standard proposal</a></li>
<li>running AI workloads such as <a href="https://developer.fermyon.com/spin/v2/serverless-ai-api-guide#serverless-ai-interface">running inferencing on LLMs, or generating and storing sentence embeddings</a></li>
</ul>
<p>Next, <code>spin build</code> will execute the build commands for all components in the application, and <code>spin up</code> will start the application locally. If you’re iterating locally on your application, <a href="https://www.fermyon.com/blog/spin-watch-live-reloading">you might use <code>spin watch</code></a> to automatically rebuild and restart your app whenever you change your source code.</p>
<p>Finally, you can use <code>spin cloud deploy</code> to instantly <a href="https://developer.fermyon.com/cloud/deploy">deploy your application to Fermyon Cloud</a>, <a href="https://developer.fermyon.com/spin/v2/registry-tutorial">push the application to a registry service such as Docker Hub or GitHub Container Registry using <code>spin registry push</code></a>, or <a href="https://developer.fermyon.com/spin/v2/kubernetes">deploy the application to Kubernetes using <code>spin k8s deploy</code></a>.</p>
<p>Let’s see how we can deploy our newly created Spin 2.0 application to Fermyon Cloud:</p>
<pre><code># Deploying our Spin 2.0 application to Fermyon Cloud
$ spin cloud deploy
Uploading hello-spin2 version 0.1.0 to Fermyon Cloud...
Deploying...
Waiting for application to become ready........ ready
Available Routes:
  hello-spin2: https://hello-spin2-0a8dkb8e.fermyon.app/hello-spin2
  hellorust: https://hello-spin2-0a8dkb8e.fermyon.app/hellorust
</code></pre>
<h2>Bringing the Component Model and WASI Preview 2 to production</h2>
<p><img src="https://www.scattered-thoughts.net/log/static/image/spin-twcm-wasi.png" alt="../static/image/spin-twcm-wasi.png"/></p>
<p>All the above was possible in Spin 1.x already. In fact, while our SDKs so far produced regular <code>.wasm</code> files, since Spin 1.5 they were turned into WebAssembly Component binaries before execution. So Spin and Fermyon Cloud have executed nothing but components for months now — but this was an implementation detail under the hood. With today’s release of Spin 2.0, we’re taking things a huge step further: we’re finally bringing some of the benefits of the <a href="https://component-model.bytecodealliance.org/">WebAssembly Component Model</a> and the upcoming WASI Preview 2 milestone to a production environment.</p>
<p>The Component Model introduces two key additions to WebAssembly: a simple way to bring efficient high-level interfaces to content running in WebAssembly, regardless of which language was used to create that content; and the ability to compose components using these interfaces, building powerful applications out of smaller pieces that are isolated from each other, but can efficiently communicate across language boundaries.</p>
<p>Through the rest of this post, we’ll talk about how we’re making use of these properties in Spin 2.0, and how we’re going about making a precursor of the upcoming WASI Preview 2 available for production use right now, while supporting the standardization process towards an ideal final version of the specification.</p>
<h2>Enabling Polyglot Component Composition</h2>
<p>More concretely, with the Component Model a component written in JavaScript can import a high-performance component written in Rust, or another written in Python, and they can communicate and exchange data in a portable way, without needing to be aware of the language, or any other implementation details, of each other.</p>
<p>Spin 2.0 can produce and run WebAssembly components natively, and today you can use <a href="https://component-model.bytecodealliance.org/language-support.html">tooling in Rust, JavaScript, TypeScript, and Python</a> to build components that can run inside Spin applications.</p>
<p>Let’s explore a real example — one of the most used components in Spin applications is a <a href="https://github.com/fermyon/spin-fileserver">static file server</a>. It is a component that serves files from disk and sends them as HTTP responses, and it is used for every website powered by Spin (including the website you are reading this article on). We initially wrote it in Rust, which means until now, if we wanted to use its functionality from any other language, we had to either reimplement its functionality in a new language, or call it over the network.</p>
<p>With Spin 2.0, we can import the file server functionality and make use of it in a component written in another language. To achieve this for our example, we will use the following component tooling: <a href="https://github.com/bytecodealliance/cargo-component"><code>cargo component</code></a>, <a href="https://github.com/bytecodealliance/componentize-py"><code>componentize-py</code></a>, and <a href="https://github.com/bytecodealliance/wasm-tools"><code>wasm-tools compose</code></a>, which generates a new component by linking the two according to their interface contract. In <a href="https://component-model.bytecodealliance.org/design/wit.html">WIT</a>, the Component Model’s language for describing interfaces for components to implement or consume, such a contract is called a <a href="https://component-model.bytecodealliance.org/design/worlds.html">“world”</a>.</p>
<p><img src="https://www.scattered-thoughts.net/log/static/image/spin-v2-rust-python-components.png" alt="../static/image/spin-twcm-wasi.png"/></p>
<p>In other words — we implement our business logic in a high-performance, memory-safe language like Rust, targeting a known interface (in this case, the <a href="https://github.com/WebAssembly/wasi-http/blob/main/proxy.md">WASI HTTP <code>proxy</code> world</a>), and we compile it using <code>cargo component</code>, which generates a standard WebAssembly component (<code>spin_static_fs.wasm</code>):</p>
<pre><code>// A simplified Rust component that implements our business logic
// https://github.com/fermyon/spin-fileserver/blob/main/src/lib.rs
#[http_component]
async fn handle(req: IncomingRequest, res_out: ResponseOutparam) {
	println!(&#34;Hello from Rust!&#34;);
	// See the source file linked above for the actual implementation.
}
</code></pre>
<p>We can now use this interface in a new component, that we’ll write in Python and build with <code>componentize-py</code>. This component imports the same interfaces our Rust component implements, but instead of doing so itself, it handles our incoming HTTP request by calling into the Rust component we just built:</p>
<pre><code># A simplified Python component that imports the business logic
# https://github.com/fermyon/spin-fileserver/blob/main/examples/python/app.py
from proxy.imports import incoming_handler as file_server
from proxy.imports.types import IncomingRequest, ResponseOutparam
...
async def handler(req: IncomingRequest, res: ResponseOutparam):
  print(&#34;Hello from Python!&#34;)
	# Omitted: logic to further process the request, check authentication, etc.
	file_server.handle(req, res)
</code></pre>
<p>We now use <code>componentize-py</code> to create a new component, then use <code>wasm-tools compose</code> to link the two components, resulting in a new component that can be run in Spin 2.0 and other runtimes supporting the Component Model and the same precursor to WASI Preview 2:</p>
<pre><code># Build a component that imports the proxy world (http.wasm)
# This component will have to be linked with another component that
# implements the proxy world before it can be used.
$ componentize-py -d ../wit -w proxy componentize app -o http.wasm

# `spin_static_fs.wasm`, and generate a new component, `composed.wasm`
$ wasm-tools compose -d spin_static_fs.wasm http.wasm -o composed.wasm
</code></pre>
<p><img src="https://www.scattered-thoughts.net/log/static/image/spin-v2-composed-full.png" alt="../static/image/spin-twcm-wasi.png"/></p>
<p>And here’s this newly generated component running in Spin 2.0:</p>
<pre><code>$ cat spin.toml
...
[component.fileserver]
source = &#34;composed.wasm&#34;
files = [{ source =&#34;my-files/*&#34;, destination = &#34;/&#34; }]
$ spin up
Available Routes:
  fileserver: http://127.0.0.1:3000/static (wildcard)

Hello from Python!
Hello from Rust!
... stream the requested file over HTTP
</code></pre>
<p>This example walked through how to manually create components in different languages, link them, then execute the generated component with Spin.</p>
<p>As tooling for component composition matures, we are working within the language ecosystems to add more integrated support for components and to streamline the creation and composition of components.</p>
<p>You can find the <a href="https://github.com/fermyon/spin-fileserver">example importing the file server component in JavaScript or Python</a>, <a href="https://github.com/fermyon/http-auth-middleware">and an HTTP OAuth middleware component</a> on GitHub. You can import them in your own Spin applications, or use them as a starting point for building new WebAssembly components.</p>
<h2>Performance, Streaming, and WASI HTTP</h2>
<p>The composition of components allows very fine-grained isolation of different parts of an application from each other, enabling developers to reason about which parts of their application have access to the most sensitive data, or are most critical to the application’s overall security, correctness, and stability.</p>
<p>But Spin adds another dimension to this fine-grained isolation: for every new request, it will create a fresh new instance of the Wasm component(s) handling the request, process it, then terminate the instance. That means that even in case an attacker can exploit a flaw in the application to corrupt its state, that corruption will only last for the current request, instead of affecting all future requests processed on the same machine.</p>
<p>Spin can do this because of the incredibly fast startup time for WebAssembly components, and the incredible work happening in the <a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a> project.</p>
<p>For scenarios with many concurrent, short-lived instances (which is perfect for serverless-style workloads), Spin 2.0 has significantly improved performance compared to Spin 1.0, in large part due to <a href="https://github.com/fermyon/spin/pull/1721">using Wasmtime’s pooling memory allocator</a>, which when combined with other performance work, can improve the throughput of Spin <a href="https://www.fermyon.com/blog/introducing-spin-v1#2">by up to an order of magnitude</a> in real-world scenarios.</p>
<p>To showcase how fast Spin can create new isolated Wasm instances for every request, we can create a new “hello world” application using Spin 2.0 and run a simple load test locally:</p>
<pre><code># Creating a new Spin application
$ spin new perftest
$ spin build &amp;&amp; spin up &amp;
# Creating a load test for 10 seconds with 5 concurrent connections
$ bombardier localhost:3000 -c 5

Statistics        Avg      Stdev        Max
  Reqs/sec     28301.16    2875.66   32328.99
  Latency      175.56us    20.01us     4.57ms
  HTTP codes:
    1xx - 0, 2xx - 282999, 3xx - 0, 4xx - 0, 5xx - 0
</code></pre>
<p>On a macOS machine, in 10 seconds, Spin created and executed almost <em>three hundred thousand</em> WebAssembly instances, with about 28,000 requests per second and average latency that is below 200 <em>microseconds.</em></p>
<p>Real-world workloads will most often be bottlenecked by external calls such as database access and outbound networking, but the time between sending the request until your application starts executing is <a href="https://www.fermyon.com/blog/next-generation-of-serverless-is-happening">crucial in a lot of scenarios</a>, and Spin 2.0 ensures improved startup performance for such applications. And that goes for every request, not just those being processed after an initial startup and warmup phase.</p>
<p>Startup performance is just one aspect of performance — another crucial aspect is sending a response back as soon as it starts becoming available, even if the server hasn’t finished processing yet. This is known as “streaming” responses, and Spin 2.0 now has experimental support for streaming HTTP responses, built on top of <a href="https://github.com/webassembly/wasi">WASI preview 2</a> and <a href="https://github.com/webassembly/wasi-http">WASI HTTP</a>.</p>
<p>We’re already making use of this in the file server example described above, but let’s see a focused example in action — we want to read parts of a file, then send the chunks back as soon as they are done processing (as opposed to waiting and sending the entire file back):</p>
<pre><code>// https://github.com/fermyon/spin/blob/main/examples/wasi-http-streaming-file/src/lib.rs
async fn stream_file(_req: IncomingRequest, res: ResponseOutparam) -&gt; Result&lt;()&gt; {
    // Create a response body
    let mut body = response.take_body();
    // Open a file for processing and start reading 1 MB chunks.
    let mut file = File::open(&#34;my-large-file.bin&#34;)?;
    const CHUNK_SIZE: usize = 1024 * 1024; // 1 MB

    // For every chunk read from the file, process it, then
    // immediately stream the processed part to the client.
    let mut buffer = vec![0; CHUNK_SIZE];
    loop {
        let bytes_read = file.read(&amp;mut buffer[..])?;
        if bytes_read == 0 {
            break;
        }
        // Potentially further process the bytes read
        // and send the chunks back as they are available.
        let data = &amp;buffer[..bytes_read]);
        body.send(data.to_vec()).await?;
        println!(&#34;sent {} bytes&#34;, data.len());
    }
    Ok(())
}
</code></pre>
<p>This is essentially the core of how <a href="https://github.com/fermyon/spin-fileserver">the file server component</a> is able to stream large files, and it is a pattern that can be used whenever performance and interactivity are crucial.</p>
<h2>Bringing Production Use to the Standardization Process</h2>
<p>To reiterate, all the above is made possible by the WebAssembly Component Model and the upcoming next version of WASI, Preview 2. Much of this work is driven upstream in the <a href="https://bytecodealliance.org/">Bytecode Alliance</a>, where we’ve long provided major contributions and helped realize the vision of the WebAssembly Component Model and WASI.</p>
<p>Neither the Component Model nor WASI Preview 2 are “done”, and while the former is by now very stable, the latter is still under heavy development. We’re actively involved in this development, but with today’s release, we’re doing something different: we’re bringing real-world production use to the standardization and implementation process.</p>
<p>A good standard that serves real-world use cases well can’t be created in isolation and without input from developers using it in the real world. Besides bringing exciting new features to Spin and Fermyon Cloud, that is a key motivation for what we’re releasing today: we want developers to have a place where they can take the Component Model and the current iteration of WASI Preview 2 for a spin, with real production use, not just experiments and testcases.</p>
<h2>Adapting to a Changing World</h2>
<p>This poses the question of how we’re doing this. If the specification is in flux and APIs are changing, how can we give developers a stable basis to build on top of?</p>
<p>Luckily, this is made fairly easy by the fact that Component Model interfaces are versioned. Spin 2.0 exposes a the <a href="https://github.com/bytecodealliance/wasmtime/blob/release-14.0.0/crates/wasi/wit/main.wit"><code>2023-10-18</code> snapshot</a> of WASI Preview 2, which is shipping with <a href="https://github.com/bytecodealliance/wasmtime/releases/tag/v14.0.4">Wasmtime 14</a>. Over the next few months, we’ll continue releasing new snapshots of WASI Preview 2, while keeping support for the previous ones. This enables existing content to continue working, while allowing new content to make use of the latest WASI Preview 2 improvements.</p>
<p>But that raises another question: how do we indefinitely support all these different snapshots?</p>
<p>The answer lies in the composability of WebAssembly Components described above. Whenever we introduce support for a new snapshot, we can decide which of the existing snapshots we want to continue supporting natively. When we decide to stop native support for a snapshot, we can move its implementation into a component itself, which functions as an <em>adapter</em> between different snapshots. Such a component will then <em>import</em> one snapshot of WASI Preview 2 and <em>export</em> another one, implemented in terms of the imported one.</p>
<p>Eventually the final version of WASI Preview 2 will be released. After that point, we’ll likely move support for all snapshot versions into adapters, and only have that single, stable version implemented natively. This way, we get the best of both worlds: we can give developers using Spin, and customers deploying their applications to Fermyon Cloud the stability they need for production use, while ensuring that we’re able to keep the Spin codebase maintainable and lean.</p>
<h2>Towards an Interoperable Ecosystem</h2>
<p>The Component Model and WASI are of course not just aiming to make it easy to support different languages, and to allow components built using different languages to interoperate. Another key goal is interoperability between hosts. Once the final version of WASI Preview 2 is released, we’ll see that happening for a wide range of platforms, the way it’s currently the case for WASI Preview 1.</p>
<p>For now, interoperability is more limited, because not everyone will have the ability to rapidly deploy support for WASI Preview 2 snapshot versions. But it’s not entirely absent either: Spin 2.0 uses the implementation of WASI APIs provided by Wasmtime 14, so content that only uses WASI APIs (as opposed to <a href="https://developer.fermyon.com/spin/v2/api-guides-overview">Spin’s non-WASI APIs</a>) will work in Wasmtime 14 as well.</p>
<p>Additionally, we’ve worked with our friends at NGINX to implement <a href="https://github.com/nginx/unit/issues/991">experimental support for the Component Model and WASI HTTP</a> in NGINX Unit. You can play around with this, and see the same content running in Spin, NGINX Unit, and Wasmtime by downloading the <a href="https://hub.docker.com/layers/nginx/unit-preview/wasm-wasi-http/images/sha256-abeba2eb2f1ed10eb07336e57558664a868c4689bb02e279d16fe8a203f82379?context=explore">Docker image</a> of their current demo of a pre-release version of the next version of NGINX Unit.</p>
<h2>A Call to Action</h2>
<p>I want to end this post with a call to action: please take <a href="https://developer.fermyon.com/spin/v2/quickstart">Spin</a> and <a href="https://component-model.bytecodealliance.org/tutorial.html">the Component Model and WASI Preview 2</a> for a spin! And please <a href="https://www.fermyon.com/discord">let us know</a> how it goes, and what does and doesn’t work for your projects!</p>
<iframe width="768" height="395" src="https://www.youtube.com/embed/tlxkK_2NHII" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
<p>And if you’re at KubeCon in Chicago next week, <a href="https://www.fermyon.com/kubeconchicago2023">please come by our booth to chat about all this in person</a>.</p>


                <!-- embed Spin Up Hub examples in a blog post
     or page with this template -->
            </article>
        </div></div>
  </body>
</html>
