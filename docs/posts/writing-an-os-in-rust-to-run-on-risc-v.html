<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/cb372/5f6bf16ca0682541260ae52fc11ea3bb">Original</a>
    <h1>Writing an OS in Rust to run on RISC-V</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-riscv-md">
      
      <div id="file-riscv-md-readme">
    <article itemprop="text"><p dir="auto">(This is a translation of the original <a href="https://moraprogramming.hateblo.jp/entry/2019/03/17/165802" rel="nofollow">article in
Japanese</a> by
<a href="https://twitter.com/moratorium08" rel="nofollow">moratorium08</a>.)</p>
<p dir="auto">(UPDATE (22/3/2019): Added some corrections provided by the original author.)</p>
<p dir="auto">Writing your own OS to run on a handmade CPU is a pretty ambitious project, but
I&#39;ve managed to get it working pretty well so I&#39;m going to write some notes
about how I did it.</p>
<p dir="auto">For those of you who want to skip straight to the code, it&#39;s on GitHub:</p>
<p dir="auto"><a href="https://github.com/moratorium08/osmium/">https://github.com/moratorium08/osmium/</a></p>
<p dir="auto">I only wrote the actual OS. <a href="https://twitter.com/ATPYM4" rel="nofollow">ATP</a> wrote the core and
<a href="https://twitter.com/__dAi00" rel="nofollow">dai</a> implemented the multiply instruction.</p>
<p dir="auto"><a href="https://github.com/hitohira/yokyo">https://github.com/hitohira/yokyo</a></p>

<p dir="auto">I implemented an OS from scratch in Rust that runs on RISC-V(rv32im). When
writing an OS, you need to take care of things like paging, kernel/usermode
privilege separation, interrupts, etc., and I implemented these based on the
RISC-V Privilege spec document. There might be a few things in the RISC-V spec
that I didn&#39;t implement, but there&#39;s nothing in the implementation that is not
in the spec (in other words there&#39;s no code based on spec I came up with
myself). For paging, I implemented the Sv32 scheme.</p>
<p dir="auto">The major parts of the OS that I implemented are:</p>
<ul dir="auto">
<li>bootloader</li>
<li>memory mapped UART I/O</li>
<li>RISC-V Privileged Architecture, Sv32 paging</li>
<li>Supervisor Mode/User Mode privilege separation</li>
<li>ELF file parsing and process management</li>
<li>preemptive multitasking via clock interrupt trap handling</li>
<li>Copy on Write fork system calls: fork, execve, exit, mmap, etc.</li>
<li>inter-process communication</li>
<li>a simple filesystem</li>
</ul>
<p dir="auto">I also made a shell as an example of a usermode application that makes use of
these kernel features. It&#39;s quite a simple program, but it manages its child
processes in almost the same way as Linux shells can do (fork, execve, wait,
exit). In other words, it&#39;s proof that the OS has sufficient features to
support something as powerful as a shell.</p>

<ul dir="auto">
<li>Summary</li>
<li>What&#39;s RISC-V?</li>
<li>Why Rust?</li>
<li>About the implementation
<ul dir="auto">
<li>Building Rust programs to target the ISA</li>
<li>About the Privilege Architecture</li>
<li>UART I/O</li>
<li>Paging</li>
<li>Parsing ELF files</li>
<li>Copy on Write fork</li>
<li>Trap handling and preemptive multitasking</li>
<li>Inter-process communication</li>
<li>Filesystem (simple)</li>
<li>System calls</li>
<li>Shell</li>
</ul>
</li>
<li>Try it in an emulator</li>
<li>Final thoughts</li>
<li>References</li>
<li>Appendix: about the CPU assignment</li>
</ul>

<p dir="auto">You should probably just google it. It&#39;s an ISA (instruction set architecture)
that&#39;s gaining a lot of interest recently. Fundamentally it&#39;s similar to MIPS
but it&#39;s a clean, modern RISC architecture without all the legacy crud of MIPS.</p>
<p dir="auto">Writing a CISC core such as x86 is really tough, so if you&#39;re going to write an
OS for fun and run it on an FPGA, I think RISC-V is a natural choice. Compiler
tooling with support for this architecture, e.g. gcc and llvm, already exists,
and there is also an emulator called Spike (although I didn&#39;t use it myself).</p>

<p dir="auto">A lot of real-world kernel security vulnerabilities are caused by things like
buffer overflows and type errors. Using Rust means more powerful static
analysis, allowing you to build a more secure OS. Of course, in the process of
writing an OS you need to use a few unsafe features, so you might not achieve the
same level of safety as you would when writing a normal Rust program. But it&#39;s
easy to distinguish between the safe and unsafe parts of the code, and by
minimising the use of <code>unsafe</code> you can focus your efforts on the unstable parts
of the system.</p>
<p dir="auto">Furthermore, even if you can&#39;t use the features of std, you can still make use
of Iterator, Result, Option, pattern matching, traits, etc. to make your code
beautiful.</p>
<p dir="auto">Anyway, although I enumerated some reasons above, the reason why I adopted Rust
in this project was that I just felt like writing it in Rust.</p>

<p dir="auto">Some notes on things I struggled to implement, important implementation points,
etc.</p>
<h2 dir="auto"><a id="user-content-building-rust-programs-to-target-the-isa" aria-hidden="true" href="#building-rust-programs-to-target-the-isa"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Building Rust programs to target the ISA</h2>
<p dir="auto">Rust officially supports RISC-V as a target since last year. However, RISC-V has
a few different bases (rv32i, rv64i, etc.) and defines a number of extensions.
So when somebody says &#34;RISC-V&#34; they are actually talking about one of many
variants.</p>
<p dir="auto">The core I used to run the OS has a 32bit architecture. Currently there are 2
officially supported 32bit ISAs: rv32imac and rv32imc. The letters after the
number stand for spec extensions:  m stands for Integer Multiplication and
Division, a for Atomic Instructions and c for Compressed Instructions.</p>
<p dir="auto">For this project, we decided making a multicore CPU (in RISC-V terminology, a
CPU with multiple harts) was a bit too ambitious, so our core has only one hart
and we went for the architecture without atomic instructions. We also decided
not to bother with compressed instructions. &#34;Compressed instructions&#34; is a 16-bit
subset of the instruction set that only supports frequently used
instructions, frequently used constants (e.g. 0) and frequently used registers
(e.g. the zero register). According to the RISC-V spec, this subset of
instructions makes up 50-60% of most programs and use of compressed instructions
can reduce code size by 25-30%.</p>
<p dir="auto">In hindsight, all you need to do to support compressed instructions is fiddle
with the decoder and the instruction fetching code a bit, so maybe it wouldn&#39;t
be that hard. But, as we&#39;ll see later, since it was required to implement the
MMU and CSR  (Control and Status Register) in the CPU, we wanted to keep things
as simple as possible and focus on implementing them.</p>
<p dir="auto">As I mentioned above, rv32im does not exist as an official target, so I had to
set up my own build environment for cross-compilation. I did this with help from
<a href="https://os.phil-opp.com/" rel="nofollow">Writing an OS in Rust</a>, the Rust official docs, <a href="https://rust-embedded.github.io/book/" rel="nofollow">The
Embedded Rust Book</a> and <a href="https://qiita.com/tomoyuki-nakabayashi/items/76f912adb6b7da6030c7" rel="nofollow">RustでRISC-V
OS自作！はじめの一歩</a>.
For more details, take a look at <a href="https://moraprogramming.hateblo.jp/entry/2019/01/25/131314" rel="nofollow">my previous
post</a> or the GitHub
repo.</p>
<p dir="auto">The result is that I&#39;m able to make a build that doesn&#39;t use the standard
library.</p>
<h2 dir="auto"><a id="user-content-about-the-privilege-architecture" aria-hidden="true" href="#about-the-privilege-architecture"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>About the Privilege Architecture</h2>
<p dir="auto">The implementation follows the RISC-V Privilege Architecture spec. RISC-V
currently defines three privilege levels: Machine, Supervisor and User.
According to the spec, no matter what your hardware you have to implement
support for a Machine mode.</p>
<p dir="auto">For this project I wanted to implement paging, so Supervisor mode was also a
must, meaning I have to implement the whole Machine-Supervisor-User set.
However, to keep things simple, I decided to make it so the machine switches to
Supervisor mode immediately after startup. If we assume that interrupts alway
shave the delegate bit set, the Supervisor has the necessary permissions to
perform all the processing.</p>
<p dir="auto">I used nearly all of the supervisor&#39;s CSR. ATP (the person who wrote the CPU)
took care of implementing the corresponding instructions (csrrw, csrrc, csrrs,
etc.) and system-level instructions (sret, ecall) in the CPU.</p>
<h2 dir="auto"><a id="user-content-uart-io" aria-hidden="true" href="#uart-io"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>UART I/O</h2>
<p dir="auto">I decided to use UART for I/O, so first of all I had to write I/O processing
that uses UART. I made the UART memory-mapped, so you just need to read or write
the correct memory location one byte at a time, but I wanted to provide slightly
richer I/O support. So I implemented <code>print!</code> and <code>println!</code> macros so you can
do formatted output just like in regular Rust.</p>
<p dir="auto">This is pretty easy to do in Rust if you implement the <code>core::fmt::Write</code>
trait. (<code>0x80000000</code> is the UART input address I chose.)</p>
<div dir="auto"><pre><span>use</span> core<span>::</span>fmt<span>::</span><span>Write</span><span>;</span>

<span>const</span> <span>UART_RX</span><span>:</span> <span>*</span><span>const</span> <span>u8</span> = <span>0x80000000</span> <span>as</span> <span>*</span><span>const</span> <span>u8</span><span>;</span>
<span>const</span> <span>UART_TX</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span> = <span>0x80000004</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>;</span>

<span>struct</span> <span>UART</span><span>;</span>

<span>fn</span> <span>write_byte</span><span>(</span><span>byte</span><span>:</span> <span>u8</span><span>)</span> <span>{</span>
    <span>unsafe</span> <span>{</span>
        <span>*</span><span>UART_TX</span> = byte<span>;</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>Write</span> <span>for</span> <span>UART</span> <span>{</span>
    <span>fn</span> <span>write_str</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>s</span><span>:</span> <span>&amp;</span><span>str</span><span>)</span> -&gt; core<span>::</span>fmt<span>::</span><span>Result</span> <span>{</span>
        <span>for</span> c <span>in</span> s<span>.</span><span>bytes</span><span>(</span><span>)</span> <span>{</span>
            <span>write_byte</span><span>(</span>c<span>)</span><span>;</span>
        <span>}</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>print</span><span>(</span><span>arg</span><span>:</span> <span>::</span>core<span>::</span>fmt<span>::</span><span>Arguments</span><span>)</span> <span>{</span>
    <span>UART</span><span>.</span><span>write_fmt</span><span>(</span>arg<span>)</span><span>.</span><span>expect</span><span>(</span><span>&#34;failed to send by UART&#34;</span><span>)</span><span>;</span>
<span>}</span>

<span>#<span>[</span>macro_export<span>]</span></span>
<span>macro_rules!</span> print <span>{</span>
    <span>(</span>$<span>(</span>$arg<span>:</span>tt<span>)</span><span>*</span><span>)</span> =&gt; <span>(</span>$crate::uart::print<span>(</span>format_args!<span>(</span>$<span>(</span>$arg<span>)</span><span>*</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>#<span>[</span>macro_export<span>]</span></span>
<span>macro_rules!</span> println <span>{</span>
    <span>(</span><span>)</span> =&gt; <span>(</span>print!<span>(</span><span>&#34;<span>\n</span>&#34;</span><span>)</span><span>)</span><span>;</span>
    <span>(</span>$arg<span>:</span>expr<span>)</span> =&gt; <span>(</span>print!<span>(</span>concat!<span>(</span>$arg, <span>&#34;<span>\n</span>&#34;</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>(</span>$fmt<span>:</span>expr, $<span>(</span>$arg<span>:</span>tt<span>)</span><span>*</span><span>)</span> =&gt; <span>(</span>print!<span>(</span>concat!<span>(</span>$fmt, <span>&#34;<span>\n</span>&#34;</span><span>)</span>, $<span>(</span>$arg<span>)</span><span>*</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<h2 dir="auto"><a id="user-content-paging" aria-hidden="true" href="#paging"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Paging</h2>
<p dir="auto">RISC-V provides a spec for paging. For this project the architecture is 32bit,
so the only choice of paging scheme is Sv32. Putting it very roughly and
ignoring superpages, it&#39;s a 2-step jump: you use the first 10 bits of the
virtual address and the next 10 bits to do a double table lookup, then add the
resulting table entry to the bottom 12 bits of the virtual address to get the
physical address. For more details, refer to the spec.</p>
<p dir="auto">When it came to implement this, I struggled a bit with accessing the
intermediate page table.</p>
<p dir="auto">As mentioned above, conversion from a virtual address to a physical address
involves a 2-step table lookup (again, we&#39;re ignoring superpages). Now, let T0
and T1 be the first part of the tables and the second part of the tables
respectively. When you try to implement the table lookup you
hit a problem, which is that after you&#39;ve turned on the MMU it&#39;s difficult to
access T1. For the T0 table, I was able to pre-assign one entry per process at
startup time so I knew the table&#39;s virtual address. But the T1 tables are
assigned dynamically (at startup time not all the memory is mapped into the
kernel&#39;s page space. This means that even if you know a table&#39;s physical
address, the virtual address you need to access it hasn&#39;t been defined.</p>
<p dir="auto">One solution to this, for example with x86, is to assign one entry in the T0
table to point to itself, meaning you can avoid the need for 2 jumps (I think
this is known as recursive paging).  So x86 paging makes it possible to access
intermediate tables without having to sacrifice precious memory space.</p>
<p dir="auto">In Sv32 however, the spec dictates that every page&#39;s table entry must be either
a leaf, i.e. the physical address of the head of a page, or a pointer to the
next page table. And if you try to do more than 2 jumps, you get a page fault.
(I&#39;m a bit unsure about this stuff, so please correct me if I&#39;ve misunderstood.)</p>
<p dir="auto">Because of this, it&#39;s not possible to do recursive paging as described above.
This is because the page table entry pointing to the page table you want to
access is not a leaf. To work around this problem I made another table T0&#39;, which
is a duplicate of T0. One entry in T0 maps to T0&#39;, but all the other entries in
the two tables are identical.</p>
<p dir="auto">(see original post for diagram)</p>
<p dir="auto">Since this design needs one more page for paging, it wastes PAGESIZE memory
space per process compared with recursive paging, but it achieves the same result.
It can&#39;t really be described as beautiful though. If there&#39;s anyone out there who
understands this stuff properly, I&#39;d appreciate some advice.</p>
<h2 dir="auto"><a id="user-content-parsing-elf-files" aria-hidden="true" href="#parsing-elf-files"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parsing ELF files</h2>
<p dir="auto">Rust has a zero-copy ELF parsing library called goblin, but for reasons to do
with its use of synchronous instructions I wasn&#39;t able to use it. So I wrote my
own simple parser.</p>
<p dir="auto">Assuming you can fit the whole ELF in memory, it has a structure that&#39;s easy to
parse. If you define a struct like in the code below, you can simply decode the
bytes into the struct (although this code might be missing some validation).</p>
<div dir="auto"><pre><span>#<span>[</span>derive<span>(</span><span>Debug</span><span>)</span><span>]</span></span>
<span>#<span>[</span>repr<span>(</span><span>C</span><span>)</span><span>]</span></span>
<span>pub</span> <span>struct</span> <span>ElfHeader</span> <span>{</span>
    <span>pub</span> <span>magic</span><span>:</span> <span>u32</span><span>,</span>
    <span>pub</span> <span>elf</span><span>:</span> <span>[</span><span>u8</span><span>;</span> <span>12</span><span>]</span><span>,</span>
    <span>pub</span> <span>etype</span><span>:</span> <span>u16</span><span>,</span>
    <span>pub</span> <span>machine</span><span>:</span> <span>u16</span><span>,</span>
    <span>pub</span> <span>version</span><span>:</span> <span>u32</span><span>,</span>
    <span>pub</span> <span>entry</span><span>:</span> <span>u32</span><span>,</span>
    <span>pub</span> <span>phoff</span><span>:</span> <span>u32</span><span>,</span>
    <span>pub</span> <span>shoff</span><span>:</span> <span>u32</span><span>,</span>
    <span>pub</span> <span>flags</span><span>:</span> <span>u32</span><span>,</span>
    <span>pub</span> <span>size</span><span>:</span> <span>u16</span><span>,</span>
    <span>pub</span> <span>phentsize</span><span>:</span> <span>u16</span><span>,</span>
    <span>pub</span> <span>phnum</span><span>:</span> <span>u16</span><span>,</span>
    <span>pub</span> <span>shentsize</span><span>:</span> <span>u16</span><span>,</span>
    <span>pub</span> <span>shnum</span><span>:</span> <span>u16</span><span>,</span>
    <span>pub</span> <span>shstrndx</span><span>:</span> <span>u16</span><span>,</span>
<span>}</span>

<span>/*...*/</span>

    <span>pub</span> <span>fn</span> new<span>(</span><span>bytes</span><span>:</span> <span>*</span><span>const</span> <span>[</span><span>u8</span><span>]</span><span>)</span> -&gt; <span>Result</span><span>&lt;</span><span>Elf</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>,</span> <span>ElfError</span><span>&gt;</span> <span>{</span>
        <span>let</span> bytes = <span>unsafe</span> <span>{</span> <span>&amp;</span><span>*</span>bytes <span>}</span><span>;</span>
        <span>let</span> elf = <span>unsafe</span> <span>{</span>
            <span>let</span> data<span>:</span> <span>*</span><span>const</span> <span>ElfHeader</span> = bytes<span>.</span><span>as_ptr</span><span>(</span><span>)</span> <span>as</span> <span>*</span><span>const</span> <span>ElfHeader</span><span>;</span>
            <span>&amp;</span><span>*</span><span>(</span>data<span>)</span>
        <span>}</span><span>;</span>
        <span>if</span> elf<span>.</span><span>magic</span> != <span>ELF_MAGIC</span> <span>{</span>
            <span>return</span> <span>Err</span><span>(</span><span>ElfError</span><span>::</span><span>InvalidMagic</span><span>)</span><span>;</span>
        <span>}</span>
        <span>Ok</span><span>(</span><span>Elf</span> <span>{</span> bytes<span>,</span> elf <span>}</span><span>)</span></pre></div>
<p dir="auto">For more details take a look at the code. Maybe this stuff is common knowledge
to experts in the field.</p>
<h2 dir="auto"><a id="user-content-copy-on-write-fork" aria-hidden="true" href="#copy-on-write-fork"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Copy on Write fork</h2>
<p dir="auto">I implemented <code>fork</code> using Copy On Write.</p>
<p dir="auto">In order to start a new process, you need a command that takes an exact clone of
the current process&#39;s memory and uses it to create a new process, i.e. <code>fork</code>.</p>
<p dir="auto">You need a way to copy all of a given process&#39;s memory. Of course it&#39;s possible
to make a copy of all of the process&#39;s mapped memory, but this would involve a
huge amount of memory access and thus would be extremely expensive.</p>
<p dir="auto">We can improve the situation by taking a copy of the page table, setting a Copy
on Write flag on the writable pages, then only copying the pages when one of the
processes (either the original process or the forked one) actually makes a write
to that page. This is known as Copy on Write and can be thought of as lazily
evaluating the copying of pages. Often after a <code>fork</code> has taken place, a call to
<code>execve</code> will replace the address space, so not bothering to copy a load of
pages unnecessarily is a good optimisation.</p>
<p dir="auto">(see original post for diagram)</p>
<p dir="auto">In order to implement Copy on Write I used 1 bit of the RSW section in page
table entries.</p>
<p dir="auto">(see original post for diagram)</p>
<h2 dir="auto"><a id="user-content-trap-handling-and-preemptive-multitasking" aria-hidden="true" href="#trap-handling-and-preemptive-multitasking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Trap handling and preemptive multitasking</h2>
<p dir="auto">As mentioned above, the system is set up so that the supervisor is delegated to handle all
interrupts, so the CSR (Control and Status Registers) are all managed by the
supervisor.</p>
<p dir="auto">In order to handle a trap, you have to first set the address of the instruction
you want to jump to when a trap happens. You do that by writing the address to
the CSR called <code>STVEC</code>. (By the way, I&#39;m using Direct mode, not Vectored mode.)</p>
<p dir="auto">Having set that, when a trap occurs the program counter will be set to that
address and the processing of the trapframe will begin. When that happens, the
stack is replaced with a dedicated trap-handling stack and the usermode
registers are saved. The CSR called <code>sscratch</code> is used to point to the location
where the usermode registers are temporarily stored. Also the <code>sepc</code> holds the
program counter at the time the trap occurred, so that is also saved.</p>
<p dir="auto"><a href="https://github.com/moratorium08/osmium/blob/master/kernel/src/trap.rs#L394-L437">https://github.com/moratorium08/osmium/blob/master/kernel/src/trap.rs#L394-L437</a></p>
<p dir="auto">After that, the supervisor looks at the <code>scause</code> and <code>stval</code> registers and
handles the trap appropriately.</p>
<p dir="auto">To return to usermode after trap handling is complete, you basically do all of
the above in reverse, set all the registers appropriately, put the saved program
counter in <code>spec</code> and call <code>sret</code>.</p>
<p dir="auto"><a href="https://github.com/moratorium08/osmium/blob/master/kernel/src/trap.rs#L461-L544">https://github.com/moratorium08/osmium/blob/master/kernel/src/trap.rs#L461-L544</a></p>
<p dir="auto">This trap-handling mechanism can also be used for clock interrupts. RISC-V uses
2 memory-mapped registers <code>mtime</code> and <code>mtimecmp</code> to control timer interrupts.
The process for handling clock interrupts is pretty simple: put the currently
running process into Runnable state, and start running one of the currently
Runnable processes. I didn&#39;t have time to implement any funky scheduling
algorithms, so I used a pretty simple rule. I sort the processes in order of how
recently the scheduler has checked if they are Runnable, then start checking
them from the oldest one until I find one that is in Runnable state.</p>
<p dir="auto"><a href="https://github.com/moratorium08/osmium/blob/master/kernel/src/trap.rs#L340-L345">https://github.com/moratorium08/osmium/blob/master/kernel/src/trap.rs#L340-L345</a></p>
<p dir="auto"><a href="https://github.com/moratorium08/osmium/blob/master/kernel/src/proc.rs#L260-L279">https://github.com/moratorium08/osmium/blob/master/kernel/src/proc.rs#L260-L279</a></p>
<h2 dir="auto"><a id="user-content-inter-process-communication" aria-hidden="true" href="#inter-process-communication"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Inter-process communication</h2>
<p dir="auto">There are 2 standard ways to achieve IPC: message-passing using a queue, and
memory sharing, i.e. allowing multiple processes to share the same area of
physical memory. For this project I implemented both.</p>
<p dir="auto">When using message passing, you have to make a system call every time you
want to send a message. This means that, compared with memory sharing, it&#39;s not
very performant when passing large amounts of data (but, according to <a href="https://www.amazon.co.jp/Operating-System-Concepts-Abraham-Silberschatz/dp/1118063333" rel="nofollow">Operating System
Concepts</a> this is not always true when you have a large number of cores because of the effect of cache line bouncing). My implementation is heavily
influenced by <code>xv6</code>: there is one mailbox per process, and each mailbox can be
read only by that process but written by many processes. Writing to and reading
from mailboxes is asynchronous, so if you want to know whether the message has
actually been received or not, you need the recipient to send you another
message.</p>
<p dir="auto">If we assume people will use this message-passing mechanism for sending
lightweight synchronisation messages between processes, the use case for memory
sharing is inter-process sharing of large amounts of data. In order to use
memory sharing you only need to make a single system call to create the shared
memory zone, and after that you just do plain memory reads and writes, so there
are no system calls involved and it performs well.</p>
<p dir="auto">To showcase IPC I made a toy example,
<a href="https://github.com/moratorium08/osmium/blob/master/misc/src/bin/catch_ball.rs">catch_ball.rs</a>.
This programs first does some message passing, then sets up a shared memory zone
and manipulates data inside it.</p>
<h2 dir="auto"><a id="user-content-filesystem" aria-hidden="true" href="#filesystem"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Filesystem</h2>
<p dir="auto">Unfortunately I wasn&#39;t able to implement a proper filesystem in time for our
final presentation of the assignment (19th Feb), so I just hacked something together to provide
files to use as input for calls to <code>execve</code> etc. I hardcoded some static files
and just looked up the file content by name. This sucked, so after the final
presentation I started work on a real filesystem.</p>
<p dir="auto">Microkernels are kernels that implement things like memory management, process
management and IPC in kernel mode but provide things like filesystems and the
networking stack in userland. This OS follows that design.</p>
<p dir="auto">To briefly explain my homegrown filesystem spec, just like most mainstream
filesystems it manages &#34;blocks&#34;. The very first block is a &#34;superblock&#34;
containing information about the filesystem, and the next is a management
block containing information about which blocks are in use. After that come the
blocks containing actual file data.</p>
<p dir="auto">The filesystem supports regular files and directories, and directories can
recursively contain both regular files and other directories.</p>
<p dir="auto">Both regular files and directories have their own metadata sections, and a
double-jump pointer to the actual data. For example you can access the data in a regular file by traversing the 2 tables as shown in the diagram below.</p>
<p dir="auto">(see original post for diagram)</p>
<p dir="auto">Directories are structured in the same way and hold pointers to their child
files.</p>
<p dir="auto">I wrote <a href="https://github.com/moratorium08/osmium/blob/master/fs/scripts/disk_formatter.py">the disk
formatter</a>
in Python. To be honest I was getting tired so I didn&#39;t bother adding into the
OS properly. Writing all this stuff on your own is pretty tough, so if anyone
wants to help out that would be great. I guess I&#39;ll get around to implementing
it properly soon.</p>
<h2 dir="auto"><a id="user-content-system-calls" aria-hidden="true" href="#system-calls"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>System calls</h2>
<p dir="auto">In RISC-V system calls are known as environment calls and you can use the
<code>ecall</code> instruction to raise an environment call exception. The arguments to the
call are passed via <code>a0</code>, <code>a1</code>, ... and the result is returned in <code>a0</code>.</p>
<h2 dir="auto"><a id="user-content-shell" aria-hidden="true" href="#shell"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Shell</h2>
<p dir="auto">As an example of a user program that makes use of the features described above,
I built a shell. I didn&#39;t have much time so it only includes basic features, but
it&#39;s able to perform the basic <code>fork -&gt; execve -&gt; exit</code> flow.</p>
<div dir="auto"><pre><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>_start</span><span>(</span><span>)</span> -&gt; ! <span>{</span>
    <span>let</span> <span>mut</span> buf = <span>[</span><span>0u8</span><span>;</span> <span>256</span><span>]</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;** Osh **&#34;</span><span>)</span><span>;</span>
    <span>loop</span> <span>{</span>
        <span>print</span><span>!</span><span>(</span><span>&#34;$ &#34;</span><span>)</span><span>;</span>
        <span>let</span> <span>(</span>len<span>,</span> b<span>)</span> = uart<span>::</span><span>buffered_readline</span><span>(</span><span>&amp;</span><span>mut</span> buf<span>)</span><span>;</span>
        <span>if</span> len == <span>0</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>if</span> !b <span>{</span>
            <span>println</span><span>!</span><span>(</span><span>&#34;Sorry. too long. Please enter shorter command&#34;</span><span>)</span><span>;</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>let</span> cmd = <span>match</span> str<span>::</span><span>from_utf8</span><span>(</span><span>&amp;</span>buf<span>)</span> <span>{</span>
            <span>Ok</span><span>(</span>s<span>)</span> =&gt; s<span>,</span>
            <span>Err</span><span>(</span>_<span>)</span> =&gt; <span>{</span>
                <span>println</span><span>!</span><span>(</span><span>&#34;Failed to parse your input. Try again.&#34;</span><span>)</span><span>;</span>
                <span>continue</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
        <span>if</span> buf<span>[</span><span>0</span><span>]</span> == <span>b&#39;e&#39;</span> &amp;&amp; buf<span>[</span><span>1</span><span>]</span> == <span>b&#39;x&#39;</span> &amp;&amp; buf<span>[</span><span>2</span><span>]</span> == <span>b&#39;i&#39;</span> &amp;&amp; buf<span>[</span><span>3</span><span>]</span> == <span>b&#39;t&#39;</span>  &amp;&amp; len == <span>4</span><span>{</span>
            syscall<span>::</span><span>sys_exit</span><span>(</span><span>0</span><span>)</span><span>;</span>
        <span>}</span>
        <span>match</span> syscall<span>::</span><span>sys_fork</span><span>(</span><span>)</span> <span>{</span>
            syscall<span>::</span><span>ForkResult</span><span>::</span><span>Parent</span><span>(</span>id<span>)</span> =&gt; <span>{</span>
                <span>loop</span> <span>{</span>
                    <span>match</span> syscall<span>::</span><span>sys_check_process_status</span><span>(</span>id<span>)</span> <span>{</span>
                        syscall<span>::</span><span>ProcessStatus</span><span>::</span><span>Running</span> | syscall<span>::</span><span>ProcessStatus</span><span>::</span><span>Runnable</span> =&gt; <span>{</span>
                            syscall<span>::</span><span>sys_yield</span><span>(</span><span>)</span><span>;</span>
                        <span>}</span><span>,</span>
                        _ =&gt; <span>{</span>
                            <span>break</span><span>;</span>
                        <span>}</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span><span>,</span>
            syscall<span>::</span><span>ForkResult</span><span>::</span><span>Fail</span> =&gt; <span>{</span>
                <span>println</span><span>!</span><span>(</span><span>&#34;fork failed&#34;</span><span>)</span><span>;</span>
            <span>}</span><span>,</span>
            syscall<span>::</span><span>ForkResult</span><span>::</span><span>Child</span> =&gt; <span>{</span>
                syscall<span>::</span><span>sys_execve</span><span>(</span>cmd<span>,</span> len <span>as</span> <span>u32</span><span>,</span> <span>&amp;</span><span>[</span><span>]</span><span>,</span> <span>&amp;</span><span>[</span><span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>

<p dir="auto">I went into a lot of detail about the implementation, but if you want to
see it running in an emulator you can use the docker image.</p>
<pre><code>docker run -it moratorium08/osmium
</code></pre>
<p dir="auto">It&#39;s an image I made from the build environment so it&#39;s pretty massive. It might
take a while to download.</p>
<p dir="auto">The graphics are not pretty, but at least you can see that it&#39;s actually working.</p>

<p dir="auto">That&#39;s pretty much all I have to say. I didn&#39;t implement any networking stuff
but I probably should, as it would unlock a lot more interesting userland
applications. It would also be fun to implement some graphics support using VGA,
maybe even a windowing system. Also the whole implementation is pretty rough
around the edges (memory is not cleaned up properly, you can&#39;t clean up
processes, the privileges stuff is sometimes wrong, etc.) so there&#39;s plenty of tidying up
and polishing I could do.</p>
<p dir="auto">My background regarding operating systems is pretty much:</p>
<ul dir="auto">
<li><a href="https://moraprogramming.hateblo.jp/entry/2017/12/02/032133" rel="nofollow">I read the source code of Unix
V6</a></li>
<li>I did all the exercises for the <a href="https://pdos.csail.mit.edu/6.828/2018/" rel="nofollow">MIT xv6
course</a></li>
<li>I read <a href="https://os.phil-opp.com/" rel="nofollow">Writing an OS in Rust</a> (and did exactly what
it told me to)</li>
<li>I did <a href="https://twitter.com/liva_jy" rel="nofollow">liva</a>&#39;s systems programming assignment
(and took the operating systems course)</li>
</ul>
<p dir="auto">Before this I&#39;d never implemented my own OS, so it was a good experience. The OS
I made is pretty basic and doesn&#39;t break any new ground, so I&#39;d like to add some
more interesting features to it in the future.</p>
<p dir="auto">Also ATP writing an amazing core was a lifesaver, and hacking on this in a small
group with a short deadline was a lot of fun.</p>

<ul dir="auto">
<li><a href="https://pdos.csail.mit.edu/6.828/2018/" rel="nofollow">xv6(6.828 Operating System Engineering)</a></li>
<li><a href="https://os.phil-opp.com/" rel="nofollow">Writing an OS in Rust</a></li>
<li><a href="https://www.redox-os.org/" rel="nofollow">Redox</a></li>
</ul>

<p dir="auto">I haven&#39;t explained it properly so far, but this was an optional extra part of a
CPU assignment for my computer science course at <a href="https://www.is.s.u-tokyo.ac.jp/english/" rel="nofollow">university</a>, so it was just for
fun. Previous students to try this extra assignment have done a lot of different
things, including porting xv6 and building an OS from scratch. It&#39;s quite
exciting when you see your handmade CPU work for the first time, and I think
quite a lot of people feel the urge to build more on top of that foundation.</p>
<p dir="auto">In the main part of the CPU assignment, some people focussed heavily on
performance, and others were experts at building cores (ATP, who <a href="https://github.com/cpu2018-1">got raytracing
working on 3 different architectures</a> and wrote
<a href="https://github.com/hitohira/yokyo">the core</a> for my OS to use, is an expert on
cores, while uenoku, who <a href="https://github.com/uenoku/mincaml-rs">wrote min-caml from scratch in 2
languages</a> and <a href="http://uenoku.hatenablog.com/entry/2018/12/25/044244" rel="nofollow">wrote an LLVM
backend</a> for his original ISA is an expert on
compilers), but even though I can&#39;t claim that level of expertise I thought it
was worth jotting down my thoughts.</p>
<p dir="auto">For the CPU assignment we had to build a core and an FPU in Verilog, write a
compiler in OCaml, and use them to run a raytracing program on an FPGA,
competing on execution speed.</p>
<p dir="auto">Once you&#39;ve got it working, the idea is to optimise it by designing cores with
higher clock speeds, reducing the number of dynamically executed instructions,
increasing the instruction level parallelism in the core, etc.</p>
<p dir="auto">I was in charge of the core for this main part of the assignment, and I also
helped to optimise the compiler. The architecture was a simple pipeline running
at 210MHz (without instruction parallelism, but with register forwarding and
out-of-order completion of load instructions).</p>
<p dir="auto">After doing some optimisation work to reduce the instruction count, we ended up
with around 1.88 billion instructions, which took 20.7 seconds to execute. The
first time they did this exercise back in 2006 the record was set at 18.8
seconds, and the record as of 2016 was 4 seconds, so ours was not a spectacular
result. This was probably because we didn&#39;t have instruction-level parallelism,
and we could have optimised our multi-cycle floating point operations more.</p>
<p dir="auto">The point is, as we can plainly see from looking at modern commercial CPUs, that
parallelism is the key to getting good performance.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
