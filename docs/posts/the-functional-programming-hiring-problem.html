<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.janissary.xyz/posts/hiring-functional-programming">Original</a>
    <h1>The Functional Programming Hiring Problem</h1>
    
    <div id="readability-page-1" class="page"><article><div><p> <!-- -->June 9, 2024<!-- --> | <!-- -->20<!-- --> min. read </p><hr/><section><p>If you&#39;ve ever seen a discussion of functional programming languages on the
Internet, you&#39;ll have probably noticed one talking point in particular that
comes up frequently. For the sake of generalization, let&#39;s make up a
hypothetical functional programming language called Gooby. In these discussions,
often someone will say something like &#34;Oh man, I love writing Gooby. I wish I
could use it at my company or on my team, but it&#39;s just so hard to hire Gooby
engineers.&#34;</p><p>Inevitably, someone will reply with something like, &#34;You fool! Hiring Gooby
engineers is actually a hidden advantage! Sure, there&#39;s less Gooby engineers
than Java or Python or Node.js engineers, but everyone who bothers to learn a
niche language like Gooby is a passionate rockstar 10x engineer! Despite a lower
quantity of people to choose from, the average applicant is of much higher
quality so the <a href="https://en.wikipedia.org/wiki/Expected_value">expected value</a>
from hiring is much higher.  You should use Gooby at your company!&#34;</p><p>I&#39;ve worked at a company that used a functional programming language pretty
ubiquitously throughout its codebase<span><label for="sn-undefined"></label><span>I&#39;m not going to name the language
itself, because this post would just turn into a flame war over that language
specifically, and I definitely don&#39;t want to cast shade on any
language/community in particular. I&#39;m also kind of hoping that the most annoying
people read this and think, &#34;Ah, of course he&#39;s talking about <em>that</em> language
over there! This criticism obviously doesn&#39;t apply to <em>my</em> perfect and favorite
language!&#34;  Regardless, I feel that the thesis and content of this post applies
pretty evenly to most functional programming languages.</span></span>. I think I
agree with the above thesis - most of my coworkers were extraordinarily smart,
hard-working, and curious people - but I think it leaves out some important
information.</p><p>The fact of the matter is that, when hiring for functional programming languages
(such as Gooby), you&#39;re primarily picking from one of three applicant pools:</p><ol>
<li>Résumé-spammers that are applying to any and every job posting they see,
regardless of whether or not they are qualified for the job or have even
heard of Gooby.  There&#39;s tough times in the industry so I don&#39;t necessarily
fault these people for trying to find work, but it&#39;s seriously polluting the
hiring process for everyone else (and has turned the job hunt into an arms
race for producing the highest number of LLM-slop LinkedIn messages and cover
letters). In reality, you&#39;re probably not going to hire one of these people.</li>
<li>Bright undergraduates that have just taken their first Programming Languages
course, and have seen the light after their first brush with functional
programming. They believe that Gooby is the One True Way to write software,
and are a textbook example of &#34;zeal of the convert&#34;. These people typically
have little production engineering experience and are basing their opinion of
Gooby on a few personal projects, some open-source work, and many blog posts.</li>
<li>Senior engineers who are there for one purpose, and one purpose only - to
write code in Gooby. It doesn&#39;t matter what the company does, or if it&#39;s
successful, or if Gooby is the right tool for the job. As long as they&#39;re
writing Gooby, they&#39;re happy.</li>
</ol><p>As mentioned, you&#39;re probably not going to hire from Group 1 for reasons that
should be obvious. Group 2, however, can be a source of great potential. If you
can find a motivated and enthusiastic engineer early in their career and train
them in your stack and processes, you&#39;ve made a great hire. Once the rubber
meets the road and they have to use Gooby in anger<span><label for="sn-undefined"></label><span>I&#39;m not sure who
coined this turn of phrase (maybe <a href="https://erlang-in-anger.com/?ref=blog.janissary.xyz">Fred
Herbert</a>?), but I love
&#34;using X in anger&#34; as a way to describe real-world production use of something.
It&#39;s easy for everything to be butterflies and rainbows when you&#39;re using a tool
for fun. You can only truly know how you feel about a tool once you&#39;ve had it
page you at 3AM on a Saturday.</span></span>, they&#39;ll probably adopt a more nuanced
opinion of the language and be willing to try something different. If using
Gooby turns out to be a big win for the company, it&#39;ll be a pleasant surprise
for everyone. It won&#39;t be a huge deal to pivot to something different if not, or
if a new project uses a different stack, or any other scenario where Gooby might
have an uncertain future at your company.</p><p>Group 3, however, is where hiring mistakes are made. On paper, these look like
the best candidates anyone could ask for. They have real-world experience
working with Gooby, they might be the author of popular open source libraries
for Gooby, or even spoke at last year&#39;s GoobyCon! They love Gooby, they have
skin in the game, and it shows.</p><p>That&#39;s the thing, though. Gooby is just a means to an end; the ultimate end goal
of your company is to write software that is useful to people and makes money.
For the zealots, however, Gooby is the end in and of itself.  No man can serve
two masters, and this is no different.</p></section>
<section><h2>The Problem</h2><p>The <a href="https://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit</a> is a
really interesting problem in mathematical optimization. A one-armed bandit is a
sly name for a slot machine - if you pull the arm, you&#39;re likely to lose some
money - but a multi-armed bandit is a hypothetical bank of multiple slot
machines, each with a different payout amount and probability of payout.  The
problem is pretty simple: you&#39;re a gambler, and you&#39;re trying to maximize your
total winnings. The challenge is in balancing the amount of money spent to
determine average payouts of different machines, and the amount of money gained
from exploiting the highest expected value.</p><p>This problem is so interesting, in fact, that during World War II the Allies
proposed air dropping copies of the original paper over Germany. The end result,
or so it was theorized, was that German scientists would be so fascinated and
distracted by the problem that they would abandon the war effort and cripple any
German military research projects in the process.</p><p>I feel like functional programming languages can have the same effect on certain
software engineers. At first, it&#39;s just a convenient way to model data flows
immutably or confidently get stuff done with robust type systems.  Then, one
thing leads to another, and you&#39;re knee deep in learning about homotopy type
theory or continuations or whatever. Meanwhile, you&#39;re a week behind on that
Jira ticket for issuing JSON Web Tokens because there&#39;s no actively maintained
JWT libraries for Gooby.</p><p>I don&#39;t know if I would go so far as to describe it as an
<a href="https://en.wikipedia.org/wiki/Information_hazard">infohazard</a>, but it&#39;s pretty
darn close. I&#39;ve seen engineers, to the detriment of their
careers/company/reputation, <em>insist</em> on using a functional language at
every moment possible. I&#39;ve seen an engineer threaten to quit if their next
project wasn&#39;t written in their language of choice. I&#39;ve seen buggy pre-1.0
libraries used for critical production software<span><label for="sn-undefined"></label><span>Not &#34;critical&#34; as in
&#34;if it goes down it&#39;s really annoying&#34;, but &#34;critical&#34; as in &#34;checks and stores
passwords&#34; or &#34;moves money from one bank account to another&#34;.</span></span> simply
because it was a wrapper library written in a functional language, as opposed to
a more stable library written in an imperative language.  I&#39;ve seen, more times
than I can count, hand-wavey &#34;wisdom&#34; from the language BDFL used as a kind of
trump-card argument in technical discussions.</p><p>Granted, all of these things independently are personnel issues that should be
solved with managerial means. But in aggregate, they paint a pretty striking
picture of your &#34;ideal&#34; candidate when hiring for a functional programming
language. Yes, you&#39;re hiring the most maximally curious engineers.  The
engineers are so curious, in fact, that they&#39;ll become enamored with the most
esoteric and arcane tools available to the point of total tunnel vision.  Yes
indeed, you&#39;re hiring the most motivated engineers that really Know Their Shit.
These engineers are so motivated, they don&#39;t mind wasting a few weeks
reimplementing a protocol that&#39;s baked into the standard library of most other
mainstream languages.</p><p>Some engineers - the very engineers that the hiring process is inadvertently
filtering for! - just cannot be trusted to do what&#39;s actually productive if it&#39;s
at the cost of playing with their favorite intellectual chew toy.</p></section>
<section><h2>The Origin of The Problem</h2><p>A lot of ink has been spilled in the past year or so on the idea of the &#34;<a href="https://newsletter.pragmaticengineer.com/p/zirp">zero
interest rate phenomenon</a>&#34;. If
you&#39;re not in the industry or somehow haven&#39;t heard of it, the idea is pretty
simple. After the financial crisis of 2008, interest rates in the US were pretty
much rock bottom in order to stimulate economic activity. Due to this, money was
cheap and venture capital could afford to throw money at bad bets fairly often
(as long as their winners were big winners!). As a result, the tech industry was
flush with cash and could tolerate a pretty extreme amount of waste. Watch any
&#34;day in the life of a software engineer&#34; TikTok circa the Peak Good Times of
2021, and you&#39;ll get a good sample.</p><p>I think this is a pretty decent hypothesis for the origins of the functional
programming hiring problem. With easy funding and relatively relaxed
expectations on immediate profitability, companies could make poor technical
decisions and slide by being less productive and efficient. As long as they
could come up with semi-defensible tales of future growth, it wasn&#39;t a big deal
if they chose the wrong tools to make their products. Meanwhile, the labor
market for engineers became red-hot (for the engineers, that is!). With their
pick of the litter, engineers could be pretty choosy about who they worked for
and what they worked with (and make the big bucks all the same).</p><p>In the fallout of the industry bubble bursting, we&#39;re now left with a pretty
bleak scene. Companies that made the fun choice instead of the pragmatic choice
are facing the consequences and being shut down or acquihired for pennies. A lot
of good developers are being laid off, with years of nothing but niche languages
on their résumé<span><label for="sn-undefined"></label><span>A lot of people love to say that they&#39;re hiring &#34;good
engineers&#34;, rather than &#34;good Java engineers&#34; or &#34;good Rails engineers&#34; or
whatever. That might have held true in better times, but as someone who was
recently on the job hunt, employers are a whole lot pickier nowadays.</span></span>
.  Worst of all, genuinely interesting and innovative programming languages are
being falsely maligned for performing poorly on problems and domains they were
never designed for.</p></section>
<section><h2>Solutions to The Problem</h2><p>This isn&#39;t a screed against functional programming languages, or functional
programming in general. I love functional programming! Learning Haskell in my
college days genuinely revolutionized the way I think about programming, and I
got my career started on Clojure. Even in imperative languages, I often reach
for functional patterns to get the job done.</p><p>However, I think that we all need to be a little more honest with ourselves as
software engineers. Is using Gooby <em>really</em> an advantage for you? Does it
<em>actually</em> offer some <a href="https://en.wikipedia.org/wiki/Alpha_(finance)">alpha</a>, or
would you have been just as successful creating the same product in some other
language? Are you <em>sure</em> you don&#39;t use Gooby just because it&#39;s fun to
write<span><label for="sn-undefined"></label><span>If you answered &#34;no&#34; here, there&#39;s no shame! All other things
being equal, I&#39;d rather have fun while writing software.</span></span>?  If you
answered &#34;no&#34; to any of the above questions, your path forward is difficult but
<a href="https://boringtechnology.club/?ref=blog.janissary.xyz">crystal
clear</a>.
If you answered &#34;yes&#34; to every question, reflect a little harder and ask
yourself the same questions again.</p><p>If you <em>still</em> answered &#34;yes&#34; to every question, I have good news and bad news.
The good news is that you have won the lottery. You&#39;re one of the few
organizations with a <em>genuine</em> need to use Gooby in production for the unique
advantages that it offers. The bad news is that you are now cursed. You need to
continue using and maintaining Gooby in production, while simultaneously
maintaining a pragmatic engineering culture and preventing a cult of personality
around Gooby from developing. Good luck!</p><p>To the hiring managers of the world, my advice is a bit more draconian.  <strong>Do
not</strong> post your job listings on language-specific job boards, unless you want
the vast majority of your applicants to be language zealots. Filter <strong>very
strongly</strong> for flexibility of thought amongst potential hires - &#34;describe a time
you had to learn something new&#34; or &#34;talk about a time where you realized you
were wrong&#34; are some great questions to ask. Above all, <strong>do not</strong> let the
extremists or zealots into your company.  They are under the memetic influence
of dark programming language design warlocks, and their judgement is clouded.
They will saddle you with technical debt, poison the engineering culture of your
company, and, worst of all, leave you with a nostalgic longing for Java.</p><p>My advice to the language zealots of the world, if they have made it to the end
of this post, is pretty simple. Take a step back, and analyze your <a href="https://en.wikipedia.org/wiki/Utility#Utility_function">utility
function</a>. Are you in
this to make useful things for people, or are you in this to explore what&#39;s
possible at the bleeding edge of programming languages? If it&#39;s the latter,
perhaps research would be more fulfilling than industry. Academia and private
R&amp;D each have their own (pretty significant) problems, but you&#39;d be free to
explore new ideas and their applications without worrying too much about the
practicality of things. If it&#39;s the former, maybe soften your opinions a bit.
Divest the tools you use from your personal and intellectual identity. Question
honestly, and constantly, if the benefits of your tools outweigh their costs.
Meditate on <a href="https://en.wikipedia.org/wiki/Cromwell&#39;s_rule">Cromwell&#39;s rule</a>:</p><div><blockquote><p>I beseech you, in the bowels of Christ, think it possible that you may be mistaken.</p></blockquote></div><p>Or, more casually, this wisdom from Tumblr:</p><figure><img src="https://blog.janissary.xyz/hiring-functional-programming/wisdom.png"/></figure></section></div></article></div>
  </body>
</html>
