<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=39215779">Original</a>
    <h1>Launch HN: Escape (YC W23) – Discover and secure all your APIs</h1>
    
    <div id="readability-page-1" class="page"><div><td colspan="2"></td><td><div><p>Hey HN! We’re Tristan and Antoine, co-founders of Escape (<a href="https://escape.tech">https://escape.tech</a>). We use AI inspired by chess to help security engineers and developers discover and secure APIs created by their organizations.</p><p>Here is our demo: <a href="https://youtu.be/qcCaegVElTY" rel="nofollow">https://youtu.be/qcCaegVElTY</a></p><p>Typical modern large orgs have hundreds if not thousands of APIs, and many of those handle sensitive data or are critical to business operations. The development of those APIs is distributed across different development teams that don’t always have knowledge of API security best practices. API source codes are updated frequently, making it easy for new, easily exploitable security vulnerabilities to be introduced in production environments (think the 2018 FB 50M accounts data leak).</p><p>APIs make up 80% of global web traffic, and this share is growing. The responsibility for securing APIs is usually given to the organization&#39;s security engineers, not the API developers, which makes sense because they’re the ones who know how to secure things. But in practice, it is almost an impossible job because the security engineers have no way to track everything the developers are exposing online, and usually, there’s nobody to tell them! And when they do find out, they lack the right tooling for achieving it. This is a huge risk for organizations, a pain and personal risk for security engineers, and a great technical challenge.</p><p>Working as a software engineer a few years back, I faced a data scare: a pharmaceutical client&#39;s data was compromised due to a NoSQL injection. In this case the damage ended up controlled, but it led to the nightmarish thought of waking up one day with all the data from the applications gone, simply because cybercriminals exploited a security issue. When looking for solutions that allowed developers to ensure what they released in production was secure, we couldn’t find anything particularly good. Security scanning tools like OWASP ZAP had been designed for people with penetration testing backgrounds. Code scanning tools were only finding the low-hanging fruit at the cost of many false positives, and ended up resembling security-oriented linters, turning the entire IDE red for minimal value. It felt like none of the existing security tools were built with real engineers in mind.
When I met Antoine, who had previously been a security engineer at NATO and Apple, we decided to tackle this issue together and create a modern security tool that would appeal to both developers and security people. It needed to be fast, easy to set up yet configurable, have outstanding support for securing APIs, and find what was relevant with a low false positive rate.</p><p>The first step was to show security engineers and developers what APIs they had to secure. We needed to find an easy way to discover any organization’s exposed and internal APIs.</p><p>To discover all APIs, we crafted a system that extracts all the API routes the organization exposes by scanning its domains, frontend websites, and SPAs. It then enriches this data by connecting to code repositories, API gateways, and API development tools to create a full list of all the exposed endpoints and the sensitivity of the data they handle. Other testing tools do not provide an inventory of all the API routes exposed by an organization, but as we mentioned above, the biggest problem security engineers face is often just finding out what it is they need to test!</p><p>Then, we needed to provide security engineers and developers with a list of security issues in their APIs.</p><p>Since APIs act as a business model layer, most of the critical security issues lie in the business processes underlying APIs. In security, issues obtained from breaking business processes are called Broken Object Level Authorization (BOLA), Broken Function Level Authorization (BFLA), and Broken Object Property Level Authorization (BOPLA).</p><p>To find them, we knew we couldn’t rely on traditional techniques like fuzzing. We needed to find a way to model the Business Process underlying the API and attempt to break it.</p><p>Doing research on this topic, we discovered that modeling API business processes in a similar way to board games, like Chess or Go, worked surprisingly well. The underlying reason is simple: a board game is a state machine on which you can execute actions that must respect rules to change the game’s state. Think about moving the pieces in a chess game, each piece has its specific moves, and their position on the board represents the state.</p><p>APIs are similar: they have a database, which represents the internal state, and API routes, which represent the actions you can run on the state. Of course, most APIs are more complex than a chess game because they have much more routes than there are chess pieces. In mathematics, we would say that the action space is much larger.</p><p>But the models are similar enough for us to try applying alpha-beta, Monte-Carlo Search Three, and more advanced Machine Learning techniques that have proven to work well in the context of large action space games like Go.</p><p>Those were the foundational ideas behind our in-house algorithm, Feedback-Driven API Exploration (FDAE), which automatically identifies the underlying business processes and generates sequences of API requests especially aimed at breaking them, uncovering potential security flaws and data leaks.</p><p>FDAE starts by ingesting the list of routes and parameters in an API. It first identifies the routes leading to sensitive data, like PII or financial information, and the parameters that have the most chances of being vulnerable to various kinds of injections and attacks.</p><p>Often, those routes require parameters like UUIDs or domain-specific values. That’s where traditional security scanners fall short: they often fuzz randomly the parameters hoping to find some low-hanging fruit injection, but end up blocked at the data validation layer.</p><p>FDAE is smarter. If it detects that the route /user/:uuid might be sensible, it will first look at all the other routes in the API and try to find one that returns a valid user UUID. Once it gets the valid user UUID, it will use it to trigger the /user/:uuid route and try to exploit it in many different ways.</p><p>If there are no existing users in the database, but there is a route to create one, Escape’s FDAE will even be able to create a user, get its UUID, and then attempt exploiting the routes that require a user UUID.</p><p>This process, very similar to what human penetration testers and bug hunters do, allows Escape to do extensive and deep testing of any API and business processes. It’s specifically good at finding many access control bugs like tenant isolation problems, complex multi-step injections, and request forgeries.</p><p>To give a specific example, imagine you’re building an e-commerce application, Escape can detect cases where users can bypass payment steps or modify input parameters in the request to access other user’s orders or private information.</p><p>You can find a more detailed explanation of how Feedback Driven API Exploration works with graphics here: <a href="https://escape.tech/blog/feedback-driven-api-exploration/">https://escape.tech/blog/feedback-driven-api-exploration/</a></p><p>Escape’s entire scanning process takes minutes. It was very important to us, as former developers, to seamlessly integrate API testing in CI/CD pipelines and quickly implement relevant fixes. To verify that it was scalable, we scanned all public APIs on the internet and produced research reports on their quality: the State of GraphQL Security (<a href="https://26857953.fs1.hubspotusercontent-eu1.net/hubfs/26857953/State-of-GraphQL-security.pdf" rel="nofollow">https://26857953.fs1.hubspotusercontent-eu1.net/hubfs/268579...</a>), and the State of Public APIs (<a href="https://apirank.dev/state-of-public-api-2023/" rel="nofollow">https://apirank.dev/state-of-public-api-2023/</a>).</p><p>Apart from discovering and testing APIs in minutes, we wanted to make Escape actionable. Pinpointing a problem is one thing, but then how to fix it? Most dynamic scanners give vague remediation instructions. Escape actually generates code snippets to help developers.</p><p>We offer a few monthly and yearly subscription plans based on the number of APIs and developers in the org, with a free 7 days trial. The pricing is accessible in the app during a trial period. Since our product is highly technical, we wanted to make sure that users can explore our features, evaluate what Escape does, and understand its value before making a decision. Users can see pricing details at a point in their trial journey where it makes the most sense, aligning with their understanding of the product. You can try us without a credit card at <a href="https://escape.tech">https://escape.tech</a>.</p><p>Our main SaaS product is closed source, but we publish many open source packages for security and developers on <a href="https://github.com/Escape-Technologies/">https://github.com/Escape-Technologies/</a> , some of them being widely used like GraphQL Armor (<a href="https://github.com/Escape-Technologies/graphql-armor/">https://github.com/Escape-Technologies/graphql-armor/</a>)</p><p>The number and complexity of APIs are constantly growing, and we’re continuing to learn every day, so we would greatly appreciate and are eager for your feedback (no matter how big or small)! Thanks!</p></div></td></div></div>
  </body>
</html>
