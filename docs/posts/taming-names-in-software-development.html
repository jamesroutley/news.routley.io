<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.simplethread.com/taming-names-in-software-development/">Original</a>
    <h1>Taming names in software development</h1>
    
    <div id="readability-page-1" class="page"><div><article id="post-4615"><div><p><img width="1254" height="837" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%201254%20837%22%3E%3C/svg%3E" data-src="https://www.simplethread.com/wp-content/uploads/2022/12/dictionary.jpg" alt="Taming Names in Software Development" decoding="async" data-srcset="https://www.simplethread.com/wp-content/uploads/2022/12/dictionary.jpg 1254w, https://www.simplethread.com/wp-content/uploads/2022/12/dictionary-300x200.jpg 300w, https://www.simplethread.com/wp-content/uploads/2022/12/dictionary-1024x683.jpg 1024w, https://www.simplethread.com/wp-content/uploads/2022/12/dictionary-768x513.jpg 768w" data-sizes="(max-width: 1254px) 100vw, 1254px"/></p><div><p> Worried you’ll miss us?</p><p> Subscribe to get our articles and updates in your inbox.</p></div><h2><strong>Good names</strong></h2><p>What is a name? A name is a label, a handle, a pointer in your brain’s memory. A complex idea neatly encapsulated. A name lets you refer to “<a href="https://www.merriam-webster.com/dictionary/economy">the economy</a>” , or “<a href="https://en.wiktionary.org/wiki/dogfood#English">dogfooding</a>” mid-sentence without needing a three-paragraph essay to explain the term.</p><p>If you think of software development as just carving up data into boxes and labeling them, it becomes clear why Naming Things is one of the <a href="https://martinfowler.com/bliki/TwoHardThings.html">two hard problems in computer science</a>. Your brain has only so much space in working memory, and a good name makes the most of it. A good name is succinct, evocative, fitting. It reduces cognitive load and stand outs in your mind. Bad names are obscure, misleading, fuzzy or outright lies.</p><p>In software, <em>really</em> good names are meaningful, descriptive, short, consistent, and distinct. You will notice that ‘descriptive’ and ‘short’ are diametrically opposed. As are ‘consistent’ and ‘distinct’. There is no solution, only tradeoffs.</p><p>Descriptive names are safe, legible, clear. They tell you what exactly you’re dealing with, bring you up to speed, don’t require you to be an expert in the codebase or a mind reader. I understand exactly what <code>BasicReviewableFlaggedPostSerializer</code> is on my first time seeing it. But they can also be bulky and unwieldy.</p><p>Short names are easy to use, easy to scan, pithy and convenient. They use abbreviations and shorthands to get out of your way so you can focus on the logic. <code>pc_auth_token</code> is so much easier to say than <code>premium_customer_http_authentication_token</code>. But short names can also be confusing and opaque.</p><p>Consistent names communicate patterns, placing your variable in a familiar larger context. Distinctive names stand apart, safeguarding you from conflating different concepts based on surface-level similarities while avoiding uninformative and generic <code>Foo.bar</code> or “DataHandler” style names.</p><p>Balancing these opposing principles is what makes good naming so hard. The amount of knowledge conveyed in a single word is what makes good naming so powerful. The exact balance will depend on the size of the codebase and developer team, the domain complexity, frequency of use and many other factors.</p><p>Personally, I favor descriptive and conventional by default, and reserve shorter names for oft-repeated variables and classes.</p><h3><strong>Conventions to the rescue!</strong></h3><p>Luckily, people much smarter than us have thought long and hard about this problem, and developed some really <a href="https://namingconvention.org/ruby/">excellent guidelines</a>.</p><p>Conventions communicate intent, both by form and content. For example, Ruby naming conventions recommend <a href="https://namingconvention.org/ruby/class-naming.html">classes be written PascalCase</a> (form) , and preferably as nouns, concrete and thing-y (content). So you can see <code>User</code> or <code>CustomerAccount</code> and recognize them as classes. Ruby methods on the other hand should be snake_case, and preferably unabbreviated verbs (e.g. <code>publish</code>, <code>invite_user</code>, <code>find_all</code>). A method ending in an exclamation mark, like <code>archive!</code>, warns that it modifies data when called. A question mark a la <code>archived?</code>, on the other hand, implies the method will return a boolean true or false. Modules, constants, foreign keys, singular, plurals, cases, all come together to create a unique style, a shorthand that make them recognizable. By providing consistently varying forms, conventions can make names <em>distinct and expressive</em> without adding length.</p><blockquote><p>A foolish consistency is the hobgoblin of little minds</p><h4><cite> Ralph Waldo Emerson – Not a programmer </cite></h4></blockquote><p>Occasionally conventions directly clash with our good naming principles. Rubyists often use <code>k</code> and <code>v</code> for <code>key</code> and <code>value</code>. Certainly short, but only meaningful if you know or intuit the convention. In JavaScript, you’ll often see <code>i</code>, <code>j</code> and subsequent letters as iteration variables. <code>i</code> is not descriptive, and <code>j</code> is somehow even less so. But they at least communicate “here’s an iteration variable, and here’s the second one”; sometimes that’s all you need. If you’re going to use meaningless variable names, at least use the ones everyone else is using.</p><p>Know the naming conventions for your language or framework and follow them. <strong>Better yet, install a good linter to make adherence easy and automatic.</strong></p><h3><strong>Make your own conventions</strong></h3><p>Your code has its own needs. Patterns of logic specific to it. Think about ways to make those immediately evident. Consider namespaces to indicate hierarchies. Use prefixes like <code>user_</code> and <code>admin_</code> to group related classes together. Use suffixes like <code>_job</code> or <code>_spec</code> to identify jobs and tests. These organize your codebase, signpost intentions, and are often required to interface with popular libraries.</p><h3><strong>Be consistent</strong></h3><p>A good linter can check your syntax and name forms, but you’ll have to watch out for semantic consistency yourself. If you have a function like <code>searchKeyword(needle, haystack)</code>, don’t make <code>searchName(haystack, needle)</code> in a different class. (I’m looking at you, PHP.)</p><p>Consistency is your friend. <strong>For style, consistency beats out clever every time.</strong> I couldn’t care less whether you use dd/mm/yyyy or mm/dd/yyyy, just don’t mix them both together. Consistency is predictable, and predictable leads to less buggy code. If I look at your codebase and see <code>fetchValue()</code>, <code>getValue()</code>, and <code>retrieveValue()</code>, I’ll have no idea whether they differ. If they’re the same, name them the same. If they’re different, make sure they’re always different in the exact same way.</p><blockquote><p>Consistency is the last refuge of the unimaginative</p><h4><cite> Oscar Wilde – Definitely not a programmer</cite></h4></blockquote><h3><strong>Name molds – A Consistency Tool</strong></h3><p>One tool you can use in your quest for consistency is name molds. Felienne Hermans has a <a href="https://youtu.be/z7w2lKG8zWM?t=325">nice video explaining them</a>, or you can read D. Feitelson’s paper “<a href="https://arxiv.org/pdf/2103.07487.pdf">How Developers Choose Names</a>” if you want the full experience.</p><p>The crux of the idea is any given variable could be written any number of ways. Creating a “mold” that dictates a certain naming structure will make your codebase more consistent. Let’s go back to date formats for a second. They can be written all sorts of ways. February 24th, 1997, 02/24/97, 24/02/97 Feb 24, ’97. But say you want to change the day on a date like “01/01/01”. Out of context, it’s unclear if the first “01” is the month or the day. We need an established arbitrary pattern like <code>dd/mm/yyyy</code> to know which is which. A name mold establishes a set pattern for variable names in much the same way.</p><p>Let’s take the simple example of a variable representing the minimum permitted length for a message. How should it be written?</p><pre><code>min_message_length
minimum_message_len
message_lgth_min
minimum_msg_len
msg_lgth_min
</code></pre><p>We could come up with over a dozen reasonable valid variable names, even limiting ourselves to the <em>exact same three words</em>. The odds of two developers naming a variable exactly the same is low. The odds of 8 different devs on two different teams doing so is almost non-existent. And the more names, the more mental energy it takes to figure out if they’re actually the same thing or subtly different.</p><p>But if we create a simple name mold of <code>adjective/noun/unabreviated_measurement</code>, we can reliably get <code>minimum_message_length</code>, or at least a lot closer to it.</p><p>Maybe your project will establish preferred abbreviations (e.g. “len” not “lgth”) or say adjectives go before nouns (<code>active_user</code>, <code>blocked_user</code>). A little time thinking about it will save a lot of time renaming things later.</p><h3><strong>Acronyms, Initialisms and Abbreviations – Shortening Tools</strong></h3><p>Abbreviations sacrifice clarity for conciseness. See the “short names” section we covered above and decide whether it’s worth it in your case.</p><p>Acronyms are nifty. We’d never get anywhere if we wrote “Application Programing Interface Key” instead of API key. <a href="https://en.wikipedia.org/wiki/Laser">Laser</a> and <a href="https://en.wikipedia.org/wiki/Radar">radar</a> aren’t even acronyms anymore, they’re just straight-up words. But tech has more acronyms than you can shake a stick at. We are occasionally too eager to hack off 90% of the letters off a phrase and pretend that somehow makes it easy to understand.</p><p>Shorten wordy names that are frequently referenced, but don’t overdo it. Write a glossary with their definitions and/or put the full meaning in comments above the class.</p><h3><strong>Further Reading</strong></h3><p>I know that rules are made to be broken. But if ever you feel stifled by these arbitrary conventions, remember this. Which side of the road you drive on is an arbitrary rule too. <code>arbitrary != unimportant</code></p><p>If this hasn’t been enough for you, check out Chapter 2 of Clean Code “Meaningful Names”.</p><h2><strong>What is Name Complexity?</strong></h2><p>We’ve talked about good names, now let’s talk about… not <em>bad</em> names, per se. Just difficult cases. Systems where names get complicated. I’ll term this “Name Complexity”.</p><p>Name complexity is when your codebase has 28 distinct acronyms and, if asked, no one is sure what 13 of them actually stand for. It’s jargon, frequently changing terminology, naming collisions, and competing naming standards between frontend and backend. <a href="https://en.wikipedia.org/wiki/Semantic_change#Examples_in_English">Semantic Drift</a>. It’s when poorly understood classes gradually outgrow their original purpose.</p><p>It’s when a core entity is known by different names to different teams. “This is the <code>AssociatedGroup</code> model, but in the database it’s <code>usr_team_id_no</code>. And actually, the client company calls them ‘Franchise Partners’. Oh, except for their marketing team, who rebranded it in the last sales push from ‘Posses’ to ‘Business Cadres’ or something.”</p><p>It’s when two completely unrelated entities share an exact name or attribute name. “There’s a <code>project_status</code> database table and a <code>ProjectStatus</code> react component but they’re not the same project and definitely not the same status.”</p><p>You probably understand what I’m talking about.</p><h3><strong>Risk factors</strong></h3><p>Name complexity builds up over time, like any other sort of technical debt. Sometimes it’s a gradual drift over time as code accumulates features and unforeseen uses. Sometimes it’s a sharp break in a rebranding or company. And like any other form of debt it scales with codebase size, company size, and business domain complexity. A new 3-developer project is very different from a 10-year-old health system that needs to refresh their ontology with updated disease names.</p><h3><strong>What’s the big deal?</strong></h3><p>Well, (you might protest) things change, stuff gets renamed, but it’s still basically the same thing. “A rose by any other name” and all that. What’s the problem?</p><p>The problem is increased cognitive overhead, developer time wasted deciphering outdated terminology, burnout and buggy code. That last one, buggy code, is especially bad. A common source of bugs is when what you <em>think</em> should happen is badly mismatched with what <em>will</em> happen. Deceitful names are dangerous.</p><p>Once I wrote a memorable bug by calling <code>deleteResource()</code> and assuming it would delete the resource. Silly me! I spent the afternoon hunting all over the codebase for the logic flagging a resource as deleted. I naively assumed that logic would live in <code>deleteResource()</code>. No? Well maybe <code>sqlSetResourceDeleted()</code>? Huh. <code>sqlCoreDeleted()</code>? Nada… Ah… there it is, right in <code>prepResourceOperation()</code>. Of course, why didn’t I think of that!?</p><p>Remember when I said bad names could be outright lies? A badly-named <code>deleteResource()</code> function will lie right to your face and <code>prepResourceOperation()</code> will stand there not saying a single word.</p><p><strong>Coding with that sort of mental overhead and cognitive juggling is tantamount to playing Simon Says on Opposite Day while patting your head and rubbing your stomach.</strong> You might eventually succeed, but it’s needlessly difficult and way more error-prone. It makes it harder for new devs to contribute to the codebase, and reduces the likelihood anyone will be brave enough to refactor that old overgrown module gathering moss.</p><h2><strong>Putting it into practice. Let’s do a Name Audit.</strong></h2><p>Ok, so we’ve talked a lot, let’s try it out. I’m going to dive into the <a href="https://github.com/discourse/discourse">opensource rails forum app Discourse</a> for the first time, analyze its name complexity, look at its conventions, and get a sense of the naming patterns I should follow.</p><p>If you want to analyze a non-Rails app, you can follow along at the database level with something like this: <a href="https://dba.stackexchange.com/questions/57130/how-to-list-all-table-columns-in-sorted-order">List all tables in PSQL</a>.</p><pre><code>

-- PostgreSQL
SELECT distinct column_name
FROM information_schema.columns
WHERE table_schema = &#39;public&#39;
ORDER BY column_name ASC;

</code></pre><p>First, let’s <a href="https://stackoverflow.com/questions/516579/is-there-a-way-to-get-a-collection-of-all-the-models-in-your-rails-app">get a list of all our models</a>.</p><pre><code>
# In Rails console
Rails.application.eager_load!

# Can use ApplicationRecord.descendants on Rails 5 and up
&gt; ActiveRecord::Base.descendants.collect(&amp;:name)
=&gt;
[&#34;SiteSetting&#34;,
&#34;User&#34;,
&#34;DeletedChatUser&#34;,
&#34;PushSubscription&#34;,
&#34;UserChatChannelMembership&#34;,
&#34;ChatChannel&#34;,
&#34;DirectMessageChannel&#34;,
&#34;CategoryChannel&#34;,
&#34;ChatChannelArchive&#34;,
...
]

&gt; ActiveRecord::Base.descendants.collect(&amp;:name).count
=&gt; 202
</code></pre><p>202 models. A nice round number. Let’s sort so we can dig into “Chat” a bit more.</p><pre><code>&gt; ActiveRecord::Base.descendants.collect(&amp;:name).sort
[...
&#34;CategoryTagStat&#34;,
&#34;CategoryUser&#34;,
&#34;ChatChannel&#34;,
&#34;ChatChannelArchive&#34;,
&#34;ChatDraft&#34;,
&#34;ChatMention&#34;,
&#34;ChatMessage&#34;,
&#34;ChatMessageReaction&#34;,
&#34;ChatMessageRevision&#34;,
&#34;ChatUpload&#34;,
&#34;ChatWebhookEvent&#34;,
&#34;ChildTheme&#34;,
&#34;ColorScheme&#34;,
...
]

</code></pre><p>Looks like we have good naming patterns here. Lots of nouns, seems to be 9 Chat-related models at first alphabetical glance. Let’s take a second glance.</p><pre><code>&gt; ActiveRecord::Base.descendants.collect(&amp;:name).grep(/chat/i)
=&gt; [&#34;DeletedChatUser&#34;,
&#34;UserChatChannelMembership&#34;,
&#34;ChatChannel&#34;,
&#34;ChatChannelArchive&#34;,
&#34;ChatDraft&#34;,
&#34;ChatMessage&#34;,
&#34;ChatMessageReaction&#34;,
&#34;ChatMessageRevision&#34;,
&#34;ChatMention&#34;,
&#34;ChatUpload&#34;,
&#34;ChatWebhookEvent&#34;,
&#34;IncomingChatWebhook&#34;,
&#34;ReviewableChatMessage&#34;]
&gt; ActiveRecord::Base.descendants.collect(&amp;:name).grep(/chat/i).count
=&gt; 13
</code></pre><p>So there are actually 13 models with “chat” in them, something our simple alphabetical sort wouldn’t see. More digging shows 18 models with “Post” in the name, 21 with “Topic”, and a whopping 47 models with “User”.</p><p>They seem to follow the common <code>AdjectiveNoun</code> name mold, if the <code>ReviewableFlaggedPost</code> <code>ReviewableQueuedPost</code> and <code>ReviewableUser</code> are anything to go by.</p><p>Let’s see if there are any acronyms.</p><pre><code># Check for Acronyms in model names
ActiveRecord::Base.descendants.collect(&amp;:name).grep(/([A-Z]){2}/)
=&gt; [&#34;HABTM_WebHooks&#34;,
&#34;HABTM_WebHooks&#34;,
&#34;HABTM_WebHookEventTypes&#34;,
&#34;HABTM_Groups&#34;,
&#34;HABTM_Categories&#34;,
&#34;HABTM_Tags&#34;,
&#34;HABTM_WebHooks&#34;]</code></pre><p>Only one! That’s not too bad. If I don’t know what HABTM means, a quick google search reveals <code>has_and_belongs_to_many</code>, an associative relationship. Excellent.</p><p>Looking around I see a couple abbreviations that I don’t immediately understand, like <code>AllowedPmUser</code>, but nothing I couldn’t learn quickly with minimal effort.</p><p>Hang on… What’s “Stat” mean in <code>UserStat</code>? Status? No… There’s already a <code>UserStatus</code> Statistics, maybe?</p><pre><code>&gt; ActiveRecord::Base.descendants.collect(&amp;:name).grep(/stat/i)
  =&gt; [&#34;CategoryTagStat&#34;,
  &#34;PostStat&#34;,
  &#34;UserStat&#34;,
  &#34;UserStatus&#34;,
  &#34;MiniScheduler::Stat&#34;]</code></pre><p>Ah, yes. The code confirms “Stat” is short for “Statistics”.</p><p>Let’s look at attributes or database table names. At a total of 1919, there are too many to view here, but let’s sort and filter out duplicates.</p><pre><code># Count all attribute names
&gt; ActiveRecord::Base.descendants.collect(&amp;:attribute_names).flatten.count
=&gt; 1919

# Count distinct attribute names
&gt; ActiveRecord::Base.descendants.collect(&amp;:attribute_names).flatten.uniq.count
=&gt; 758

#  Get distinct attribute names
ActiveRecord::Base.descendants.collect(&amp;:attribute_names).flatten.uniq.sort
=&gt; [&#34;about_url&#34;,
&#34;access_control_post_id&#34;,
&#34;acting_user_id&#34;,
&#34;action&#34;,
&#34;action_code&#34;,
&#34;action_type&#34;,
&#34;active&#34;,
&#34;admin&#34;,
&#34;admin_only&#34;,
&#34;agreed_at&#34;,
&#34;agreed_by_id&#34;,
&#34;all_score&#34;,
&#34;all_topics_wiki&#34;,
&#34;allow_badges&#34;,
&#34;allow_channel_wide_mentions&#34;,
&#34;allow_global_tags&#34;,
...</code></pre><p>Now we have an easy reference we can use to check for terminology, in-use abbreviations, or name molds! Whenever we’re adding a table or new field name, we can do a quick scan and stay consistent.</p><pre><code># Get attributes with digits
ActiveRecord::Base.descendants.collect(&amp;:attribute_names).flatten.uniq.sort.grep(/d/)
=&gt; [&#34;content_sha1&#34;,
&#34;day_0_end_time&#34;,
&#34;day_0_start_time&#34;,
&#34;day_1_end_time&#34;,
&#34;day_1_start_time&#34;,
&#34;day_2_end_time&#34;,
&#34;day_2_start_time&#34;,
&#34;day_3_end_time&#34;,
&#34;day_3_start_time&#34;,
&#34;day_4_end_time&#34;,
&#34;day_4_start_time&#34;,
&#34;day_5_end_time&#34;,
&#34;day_5_start_time&#34;,
&#34;day_6_end_time&#34;,
&#34;day_6_start_time&#34;,
&#34;featured_user1_id&#34;,
&#34;featured_user2_id&#34;,
&#34;featured_user3_id&#34;,
&#34;featured_user4_id&#34;,
&#34;include_tl0_in_digests&#34;,
&#34;original_sha1&#34;,
&#34;sha1&#34;]</code></pre><p>There’s a little confusion on whether <code>day_1</code> or <code>user1</code> is better, but all in all, this project does a fantastic job with consistency. From what we’ve seen in our brief foray, it does an excellent job of managing name complexity.</p><h3><strong>Lessons learned</strong></h3><p>What does this teach us?</p><p>A project with good naming conventions can be surprisingly easy to navigate and explore. Methods say what they mean, classes are logically named and grouped.</p><p>Try looking at your project or codebase with the above tools and see how many unexplained acronyms, inconsistent numbering systems, or poorly named domains you can find. Imagine explaining everything to a newly onboarded developer and see which ones are hard to justify. Remember the better your names, the easier life gets for everyone.</p><p><strong>Even a brand new codebase can seem familiar and understandable if it follows naming standards, framework conventions, and signposts intent with excellent variable names. Naming might be hard, but it pays off.</strong></p><div><div><p> Loved the article? Hated it? Didn’t even read it?</p><p> We’d love to hear from you.</p></div> <p><a href="https://www.simplethread.com/contact">Reach Out</a></p></div></div></article></div></div>
  </body>
</html>
