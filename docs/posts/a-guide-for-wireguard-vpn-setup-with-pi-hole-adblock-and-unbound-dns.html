<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://psyonik.tech/posts/a-guide-for-wireguard-vpn-setup-with-pi-hole-adblock-and-unbound-dns/">Original</a>
    <h1>A Guide for WireGuard VPN Setup with Pi-Hole Adblock and Unbound DNS</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      <h2>A Guide For Wireguard VPN Setup With Pi-Hole Adblock and Unbound DNS</h2>
      <h3 id="why-setup-wireguard-network-with-pi-hole-adblock-and-unbound-dns">Why Setup Wireguard Network with Pi-Hole Adblock and Unbound DNS</h3>
<p>I’ve used <a href="https://mullvad.net">Mullvad</a> as my VPN provider for a few years. Their service is good, they provide keys for 5 devices, rely on the Wireguard protocol, and offer alternative configurations as well. Despite that, my needs have changed and I wanted to be able to have granular control over DNS queries and the ability to connect my various devices on my network through simple addresses, such as <a href="http://emby.home.server">http://emby.home.server</a>. Enter Wireguard, Pi-Hole and Unbound.</p>
<p>Of course, there are many tools that might achieve the same results with a lot less work, such as <a href="https://tailscale.com/">Tailscale</a>. I would reach devices on the network easily, one of the nodes could be set to act as an exit node and you could also apply network-wide ad-block with Next DNS (I believe that is, at the time of writing, the solution they offer). Outside of Tailscale there are other fully open source alternatives, such as Headscale, Nebula and others.
However, I chose to set up my own Wireguard network, as it gave me the opportunity to learn a lot and helped me better understand everything involved in the process.</p>
<h3 id="network-setup-and-clients">Network Setup and Clients</h3>
<p>For devices, I have the following configuration, and the below IPs will be used throughout the article. They represent a starting point, but should be sufficient for anyone to build their network according to their needs.</p>
<ul>
<li>VPN Server (<code>10.10.10.1</code>) - running on a VPS (Virtual Private Server) from a provider that meets my requirements (close physical proximity, high bandwidth and at least 1 Gbps transfer speeds)</li>
<li>Home Server (<code>10.10.10.10</code>) - running on my home network and providing various service (media server, personal cloud, torrent client, etc.)</li>
<li>Desktop (<code>10.10.10.11</code>) - running on my home network</li>
<li>Laptop (<code>10.10.10.12</code>) - running on my home network, but might connect through outside networks (i.e.: coffee shops, libraries, airports, etc.)</li>
<li>Mobile 1 (<code>10.10.10.100</code>) - running on my home network, mobile data, mobile data roaming or public networks (coffee shops, libraries, airports, etc.)</li>
<li>Mobile 2 (<code>10.10.10.101</code>) - same as above</li>
</ul>
<p>I will use a <a href="https://www.procustodibus.com/blog/2020/11/wireguard-hub-and-spoke-config/">hub and spoke network topology</a> where the VPS will act as the in-between for all inter-device communications on the network as well as the exit node for all Internet-facing communications. For example, if my Desktop connects to the Internet it will do so by navigating to the VPS, which will then resolve the query and block any domains that are on the block list. If it wants to connect to the Home Server it will do so without the VPS, since the Home Server and Desktop are on the same local network, connected via a router. If Smartphone 1 wants to connect to the Internet, the query is resolved by the VPS, which will block any domains on the block list. If it wants to connect to the Home Server, the VPS will receive the request and route it to the IP of the Home Server. It’s important to keep in mind that the contents of the request become visible as they <em>leave</em> the Wireguard tunnel between Smartphone 1 and the VPS. On the VPS contents will be encrypted again and <em>then</em> forwarded to the Home Server.</p>
<h3 id="vps-selection">VPS Selection</h3>
<p>I chose a VPS provider that is physically near my location, has minimum 1 Gbps speed (up/down), unlimited bandwidth and good performance while gaming (i.e.: specifically no packet loss). There are many options; you can check resources like <a href="https://lowendbox.com/">LowEndBox</a> and <a href="https://www.vpsbenchmarks.com/">VPSBenchmarks</a> to get an idea of price ranges, availability and regions. For your own needs, start by defining a set of requirements and see which of these match your needs.</p>
<p>My only recommendation is to initially opt for a cheaper provider, that offers hourly billing and understand the end-to-end-process before committing. Keep in mind that various providers have different configurations and settings, so setups can vary.</p>
<h3 id="initial-server-setup">Initial Server Setup</h3>
<p>If you are completely new to setting up servers using a command line interface (CLI) only, I recommend checking out the <a href="https://www.digitalocean.com/community/conceptual-articles/cloud-servers-an-introduction">Digital Ocean</a> cloud computing series. Most providers have their own guides, so for specific steps check their respective documentation. Same goes for any chosen OS. For this guide I will be using Ubuntu 24.04. For the remainder of the article I will assume you are running an OS with access to a terminal that can send commands to a CLI that can generate SSH keys, establish SSH connections and can run a text editor that you can use to create, edit, update and delete text files. I will be using BASH/Fish with <code>nano</code> as my text editor.</p>
<h4 id="ssh-key-authentication">SSH Key Authentication</h4>
<p>To start, create an SSH key on your local machine and upload it to your chosen cloud provider. This first step already greatly improves security of the VPS and simplifies connection to it as you don’t need to remember a password.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Run inside your terminal on your client machine </span>
</span></span><span><span><span># https://www.man7.org/linux/man-pages/man1/ssh-keygen.1.html</span>
</span></span><span><span>$ ssh-keygen -t ed25519
</span></span></code></pre></div><p>Follow the on-screen prompts to provide a name, set a passphrase (recommended) and have the private and public files created at the given path in the prompt.</p>
<p>Next, copy the contents of the <em>.pub</em> file, or the file itself to your chosen VPS provider’s server setup page. Complete the initial server setup as per your provider’s steps. Once ready, you will have a public IPv4 address to which you can connect (this is a requirement in this guide, and some providers might only offer IPv6 addresses on their cheapest VPS). A connection can now be established with:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># replace root with the username your provider created by default; could be ubuntu as well</span>
</span></span><span><span><span># replace 123.123.123.123 with the IP address of your VPS</span>
</span></span><span><span>$ ssh -i .ssh/article root@123.123.123.123
</span></span></code></pre></div><h4 id="automatic-updates">Automatic Updates</h4>
<p>You are now connected to the server, as the <code>root</code> user. If you connected via another user that has <code>sudo</code> access, then prepend all commands with <code>sudo</code>. If I write <code>ufw status numbered</code> use <code>sudo ufw status numbered</code>.</p>
<p>First, make sure you have <a href="https://wiki.debian.org/UnattendedUpgrades"><code>unattended-upgrades</code></a> installed on your VPS.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ apt install unattended-upgrades
</span></span><span><span>Reading package lists... Done
</span></span><span><span>Building dependency tree... Done
</span></span><span><span>Reading state information... Done
</span></span><span><span>unattended-upgrades is already the newest version <span>(</span>2.9.1+nmu4ubuntu1<span>)</span>.
</span></span><span><span><span>0</span> upgraded, <span>0</span> newly installed, <span>0</span> to remove and <span>29</span> not upgraded.
</span></span></code></pre></div><p>Next, prepare the settings you want to apply. Because the application reads through different configuration files in order, I made a copy of <em>/etc/apt/apt.conf.d/50unattended-upgrades</em> and called it <em>/etc/apt/apt.conf.d/51unattended-upgrades</em>. This means that even after an update, while the original file could be overwritten, my settings will persist. The main settings I changed in my copy are found below. Read through the different options and adjust to your preferences.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Make a copy and give a new name</span>
</span></span><span><span>$ cp /etc/apt/apt.conf.d/50unattended-upgrades /etc/apt/apt.conf.d/51unattended-upgrades
</span></span><span><span><span># Edit the file </span>
</span></span><span><span>$ nano /etc/apt/apt.conf.d/51unattended-upgrades
</span></span><span><span><span># File contents below are edited for brevity</span>
</span></span><span><span>Unattended-Upgrade::Allowed-Origins <span>{</span>
</span></span><span><span>        <span>&#34;</span><span>${</span>distro_id<span>}</span><span>:</span><span>${</span>distro_codename<span>}</span><span>&#34;</span>;
</span></span><span><span>        <span>&#34;</span><span>${</span>distro_id<span>}</span><span>:</span><span>${</span>distro_codename<span>}</span><span>-security&#34;</span>;
</span></span><span><span>        // Extended Security Maintenance; doesn<span>&#39;</span>t necessarily exist <span>for</span>
</span></span><span><span>        // every release and this system may not have it installed, but <span>if</span>
</span></span><span><span>        // available, the policy <span>for</span> updates is such that unattended-upgrades
</span></span><span><span>        // should also install from here by default.
</span></span><span><span>        <span>&#34;</span><span>${</span>distro_id<span>}</span><span>ESMApps:</span><span>${</span>distro_codename<span>}</span><span>-apps-security&#34;</span>;
</span></span><span><span>        <span>&#34;</span><span>${</span>distro_id<span>}</span><span>ESM:</span><span>${</span>distro_codename<span>}</span><span>-infra-security&#34;</span>;
</span></span><span><span>        <span>&#34;</span><span>${</span>distro_id<span>}</span><span>:</span><span>${</span>distro_codename<span>}</span><span>-updates&#34;</span>;
</span></span><span><span><span>}</span>;
</span></span><span><span>
</span></span><span><span>// Remove unused automatically installed kernel-related packages
</span></span><span><span>// <span>(</span>kernel images, kernel headers and kernel version locked tools<span>)</span>.
</span></span><span><span>Unattended-Upgrade::Remove-Unused-Kernel-Packages <span>&#34;true&#34;</span>;
</span></span><span><span>
</span></span><span><span>// Do automatic removal of newly unused dependencies after the upgrade
</span></span><span><span>Unattended-Upgrade::Remove-New-Unused-Dependencies <span>&#34;true&#34;</span>;
</span></span><span><span>
</span></span><span><span>// Do automatic removal of unused packages after the upgrade
</span></span><span><span>// <span>(</span>equivalent to apt-get autoremove<span>)</span>
</span></span><span><span>Unattended-Upgrade::Remove-Unused-Dependencies <span>&#34;true&#34;</span>;
</span></span><span><span>
</span></span><span><span>// Automatically reboot *WITHOUT CONFIRMATION* <span>if</span>
</span></span><span><span>// the file /var/run/reboot-required is found after the upgrade
</span></span><span><span>Unattended-Upgrade::Automatic-Reboot <span>&#34;true&#34;</span>;
</span></span><span><span>
</span></span><span><span>// If automatic reboot is enabled and needed, reboot at the specific
</span></span><span><span>// time instead of immediately
</span></span><span><span>// Default: <span>&#34;now&#34;</span> - change this to whatever works <span>for</span> you!
</span></span><span><span>Unattended-Upgrade::Automatic-Reboot-Time <span>&#34;00:00&#34;</span>;
</span></span></code></pre></div><p>Next, update the <em>periodic</em> file to provide <code>unattended-upgrades</code> with the intervals at which it checks for updates and runs the clean command. Create a new file at <em>/etc/apt/apt.conf.d/21periodic</em> (you can name it anything else, as these are parsed in order, so <em>22periodic</em>, <em>23…</em>). The below are the values for the purposes of this server:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>APT::Periodic::Update-Package-Lists <span>&#34;1&#34;</span>;
</span></span><span><span>APT::Periodic::Download-Upgradeable-Packages <span>&#34;1&#34;</span>;
</span></span><span><span>APT::Periodic::AutocleanInterval <span>&#34;7&#34;</span>;
</span></span><span><span>APT::Periodic::Unattended-Upgrade <span>&#34;1&#34;</span>;
</span></span></code></pre></div><p>Number 1 means the option is enabled and runs daily. Zero means the option is turned off. Any other number shows the frequency with which the step is completed (e.g.: 7 - the action is performed once a week).</p>
<p>Run <code>unattended-upgrade -d</code> to quickly debug your current app configuration and confirm the settings you have setup so far.</p>
<h4 id="configure-system-hostname">Configure System Hostname</h4>
<p>Next off, I configure the system hostname. The hostname can then be used as part of a fully qualified domain name for the system (e.g.: hostname = pihole, fqdn = pihole.psyonik.com)</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># you can check current hostname with</span>
</span></span><span><span>hostname
</span></span><span><span><span># set hostname to something else</span>
</span></span><span><span>hostnamectl set-hostname pihole
</span></span><span><span><span># edit hosts file to create static associations between IP addresses and hostnames/domains</span>
</span></span><span><span><span># which the system prioritizes before DNS for name resolution</span>
</span></span><span><span>nano /etc/hosts
</span></span><span><span><span># The contents of the file might be similar, adjust them to match what I have below </span>
</span></span><span><span><span># replacing &lt;pihole&gt; and &lt;psyonik&gt; with your settings</span>
</span></span><span><span>127.0.0.1 localhost
</span></span><span><span>127.0.0.1 pihole
</span></span><span><span>127.0.1.1 pihole.psyonik.com pihole
</span></span><span><span><span># replace the below address with your VPS actual IP address</span>
</span></span><span><span>123.123.123.113 pihole.psyonik.com pihole
</span></span></code></pre></div><p>I check if the hostname is setup correctly by calling <code>ping pihole.psyonik.com</code>.</p>
<h3 id="ssh-configuration---disable-password-auth-and-change-default-port">SSH Configuration - Disable Password Auth and Change Default Port</h3>
<p>As mentioned previously, I connect to the server by using <code>ssh -i .ssh/article root@123.123.123.123</code>. The command passes in the path to the SSH key I use, sets the username I want to connect as, and sets the IP address of the server. By default, the SSH service runs on port 22. This is not explicitly stated in the connection command, it is just assumed as being set as such. One of the first things I like to change on a new VPS is the default port to something else. On Ubuntu 24.04 you will have this option in the <em>sshd_config</em> file, but the actual port used will be picked up from the <a href="https://discourse.ubuntu.com/t/sshd-now-uses-socket-based-activation-ubuntu-22-10-and-later/30189"><code>ssh.socket</code> service</a>. This can be confusing, as the setting is still present in the <em>sshd_config</em> file.</p>
<p>The first step is to make a copy of the configuration file and then edit the following lines in the original file.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ cp /etc/ssh/sshd_config /etc/ssh/sshd_config.1
</span></span><span><span><span># Edit the SSH configuration - disable root login, password auth, enable pubkey login</span>
</span></span><span><span>$ nano /etc/ssh/sshd_config
</span></span><span><span>
</span></span><span><span><span># Find and edit the below values in the file</span>
</span></span><span><span>AddressFamily inet <span># SSH Service will only listen to IPv4 addresses</span>
</span></span><span><span>PermitRootLogin no <span># disable root login</span>
</span></span><span><span>PubkeyAuthentication yes <span># only allow SSH key-based authentication  </span>
</span></span><span><span>AuthorizedKeysFile .ssh/authorized_keys <span># file that contains allowed public keys  </span>
</span></span><span><span>PasswordAuthentication no <span># do not allow password auth  </span>
</span></span><span><span>PermitEmptyPasswords no <span># do not allow empty passwords </span>
</span></span><span><span>ChallengeResponseAuthentication no <span># Specifies if challenge-response auth is allowed</span>
</span></span><span><span>UsePAM no <span># disable authentication through PAM (Pluggable Authentication Module)</span>
</span></span></code></pre></div><p>Next, I create a folder and a configuration file to change the SSH port for the <code>ssh.socket</code>.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ mkdir /etc/systemd/system/ssh.socket.d
</span></span><span><span><span># Create and add the values into the listen.conf file</span>
</span></span><span><span>$ nano /etc/systemd/system/ssh.socket.d/listen.conf
</span></span><span><span><span>[</span>Socket<span>]</span>
</span></span><span><span>ListenStream<span>=</span>
</span></span><span><span>ListenStream<span>=</span><span>12345</span>
</span></span><span><span><span># Save and exit file</span>
</span></span><span><span>$ systemctl daemon-reload
</span></span><span><span><span># Restart the SSH Socket</span>
</span></span><span><span>$ systemctl restart ssh.socket
</span></span><span><span><span># Restart the SSH Service</span>
</span></span><span><span>$ systemctl restart ssh.service
</span></span><span><span><span># Check the status of the service after restart; you should see the new port number displayed</span>
</span></span><span><span>$ systemctl status ssh.service
</span></span><span><span><span># Output for my configuration</span>
</span></span><span><span>● ssh.service - OpenBSD Secure Shell server
</span></span><span><span>     Loaded: loaded <span>(</span>/usr/lib/systemd/system/ssh.service; disabled; preset: enabled<span>)</span>
</span></span><span><span>     Active: active <span>(</span>running<span>)</span> since Sun 1999-01-01 12:01:04 UTC; 5s ago
</span></span><span><span>TriggeredBy: ● ssh.socket
</span></span><span><span>       Docs: man:sshd<span>(</span>8<span>)</span>
</span></span><span><span>             man:sshd_config<span>(</span>5<span>)</span>
</span></span><span><span>    Process: <span>12928</span> ExecStartPre<span>=</span>/usr/sbin/sshd -t <span>(</span>code<span>=</span>exited, status<span>=</span>0/SUCCESS<span>)</span>
</span></span><span><span>   Main PID: <span>12929</span> <span>(</span>sshd<span>)</span>
</span></span><span><span>      Tasks: <span>1</span> <span>(</span>limit: 4543<span>)</span>
</span></span><span><span>     Memory: 1.2M <span>(</span>peak: 1.3M<span>)</span>
</span></span><span><span>        CPU: 36ms
</span></span><span><span>     CGroup: /system.slice/ssh.service
</span></span><span><span>             └─12929 <span>&#34;sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups&#34;</span>
</span></span><span><span>
</span></span><span><span>Jan <span>01</span> 12:01:04 pihole systemd<span>[</span>1<span>]</span>: Starting ssh.service - OpenBSD Secure Shell server...
</span></span><span><span>Jan <span>01</span> 12:01:04 pihole sshd<span>[</span>12929<span>]</span>: Server listening on :: port 12345.
</span></span><span><span>Jan <span>01</span> 12:01:04 pihole systemd<span>[</span>1<span>]</span>: Started ssh.service - OpenBSD Secure Shell server.
</span></span></code></pre></div><p>Now, in a new tab, if I try to connect with the previous command, this should not work. I would now also need to specify the port, but if I try to connect as <code>root</code> this should get denied.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ ssh -i .ssh/article -p <span>12345</span> root@123.123.123.123 <span># this should return an error</span>
</span></span></code></pre></div><p>While keeping my session open, I will create a new user, add the user to <code>sudo</code>, copy the <em>.ssh/authorized_keys</em> file over to the new users <em>home</em> directory and try to connect with that user. I then complete the remaining configuration using <code>root</code>.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Create a new user and follow on-screen prompts</span>
</span></span><span><span>$ adduser psyonik
</span></span><span><span><span># Add user to sudo</span>
</span></span><span><span>$ usermod -aG sudo psyonik
</span></span><span><span><span># Copy authorizedkeys file to the new user folder and change ownership </span>
</span></span><span><span>$ cp -r .ssh/ /home/psyonik/
</span></span><span><span>$ chown psyonik:psyonik -R /home/psyonik/.ssh
</span></span><span><span><span># Ensure ownership is set correctly</span>
</span></span><span><span>$ ls -alh /home/psyonik/.ssh/
</span></span><span><span>total 12K
</span></span><span><span>drwx------ <span>2</span> psyonik psyonik 4.0K Jan  <span>1</span> 12:09 .
</span></span><span><span>drwxr-x--- <span>3</span> psyonik psyonik 4.0K Jan  <span>1</span> 12:09 ..
</span></span><span><span>-rw------- <span>1</span> psyonik psyonik  <span>162</span> Jan  <span>1</span> 12:09 authorized_keys
</span></span></code></pre></div><p>When I connect from my local machine to the VPS using this new username, the connection should be established correctly.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ ssh -i .ssh/article -p <span>12345</span> psyonik@123.123.123.123
</span></span></code></pre></div><p>This completes the setup of SSH. Next up, we setup the firewall. If you encounter issues, you can use <code>ssh -vvv</code> to have verbose logging enabled during the SSH connection. This should highlight any issues such as access denied, incorrect keys or anything else of the sort.</p>
<h4 id="ufw-setup">UFW Setup</h4>
<p>Although the server can now do automatic updates, doesn’t rely on the default port to allow incoming connections and has <code>root</code> login disabled, we still need to configure the firewall. There are various ways to do this, but I like to use <code>ufw</code>.</p>
<p><a href="https://wiki.ubuntu.com/UncomplicatedFirewall">Uncomplicated firewall</a> is a great way to setup some basic rules and security on the server. I allow only 2 ports open on IPv4 on the server at this stage, enable logging, and deny all other incoming requests while allowing all outgoing requests.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># the SSH port should be replaced with whatever you wish to use instead</span>
</span></span><span><span>$ ufw allow from 0.0.0.0/0 to any port <span>12345</span> comment <span>&#34;SSH&#34;</span>
</span></span><span><span>$ ufw allow from 0.0.0.0/0 to any port <span>51820</span> comment <span>&#34;Wireguard&#34;</span>
</span></span><span><span><span># block all incoming connections except those going to the SSH/Wireguard ports</span>
</span></span><span><span>$ ufw default deny incoming
</span></span><span><span><span># allow </span>
</span></span><span><span>$ ufw default allow outgoing
</span></span><span><span><span># enable logging</span>
</span></span><span><span>$ ufw logging on
</span></span><span><span><span># enable ufw and display the rules in a numbered list</span>
</span></span><span><span>$ ufw enable
</span></span><span><span>$ ufw status numbered
</span></span><span><span>Status: active
</span></span><span><span>
</span></span><span><span>     To                         Action      From
</span></span><span><span>     --                         ------      ----
</span></span><span><span><span>[</span> 1<span>]</span> <span>12345</span>                      ALLOW IN    Anywhere                   <span># SSH</span>
</span></span><span><span><span>[</span> 2<span>]</span> <span>51820</span>                      ALLOW IN    Anywhere                   <span># Wireguard</span>
</span></span></code></pre></div><p>Each time you edit a rule you can call <code>ufw reload</code> to refresh the new rules. You can then check the status of the rules with <code>ufw status numbered</code>. This also gives you an easy way to delete any unused rules.</p>
<p>Lastly, there is one more change that can be done so that the server will not respond to ping requests.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sudo nano /etc/ufw/before.rules
</span></span><span><span><span># Look for the following row and change from ACCEPT to DROP</span>
</span></span><span><span>-A ufw-before-input -p icmp --icmp-type echo-request -j DROP
</span></span></code></pre></div><p>This completes a basic server configuration for this machine. Other settings can be changed and if I were to do this often, I would opt for a script file as a minimum, or ideally a <a href="https://cloud-init.io/">cloud-init</a> script. Feel free to explore that once you feel comfortable with this setup.</p>
<p>Next, I’ll setup Wireguard, Pi-Hole and Unbound.</p>
<h3 id="wireguard">Wireguard</h3>
<p>Unlike traditional VPN services, where a central server acts as a point of control and has clients, Wireguard uses the concept of peers. Peers can connect directly to each other, thus allowing for lower latency for connections and removing the single point of failure of a server. However, for my purposes, I configured one of the peers, in Wireguard parlance, to act as a server due to the hub-and-spoke network topology I employ in this setup. As such, the VPS will be referred to as the ‘server’ and all other devices as ‘clients’.</p>
<p>I will expand this article once I have a configuration in which clients that need to be able to connect to each other will do so directly, without a VPS in-between.</p>
<p>Next, to setup each client and the server, I need to create keys for all devices and create configuration files using these keys. The below steps will create public, private and pre-shared keys for all devices.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Install or make sure Wireguard is installed</span>
</span></span><span><span>$ apt install wireguard
</span></span><span><span>
</span></span><span><span><span># Create a folder to keep client keys and one for client configurations</span>
</span></span><span><span><span># This is not strictly needed, as once clients are added, the keys can be removed from the server</span>
</span></span><span><span><span># Except for the preshared keys </span>
</span></span><span><span>$ mkdir /etc/wireguard/clients
</span></span><span><span>$ mkdir /etc/wireguard/clientconfs
</span></span><span><span>
</span></span><span><span><span># Create VPS keys - key, pub, psk</span>
</span></span><span><span>$ wg genkey &gt; vps.key <span># I use .key to show we&#39;re dealing with a private key</span>
</span></span><span><span>$ wg pubkey &lt; vps.key &gt; vps.pub <span># I use .pub to show this is a public key</span>
</span></span><span><span>
</span></span><span><span>$ wg genkey &gt; /etc/wireguard/clients/homeserver.key
</span></span><span><span>$ wg pubkey &lt; /etc/wireguard/clients/homeserver.key &gt; /etc/wireguard/clients/homeserver.pub
</span></span><span><span>$ wg genpsk &gt; /etc/wireguard/clients/homeserver.psk <span># I use .psk to show this is a preshared key</span>
</span></span><span><span>
</span></span><span><span>$ wg genkey &gt; /etc/wireguard/clients/desktop.key
</span></span><span><span>$ wg pubkey &lt; /etc/wireguard/clients/desktop.key &gt; /etc/wireguard/clients/desktop.pub
</span></span><span><span>$ wg genpsk &gt; /etc/wireguard/clients/desktop.psk
</span></span><span><span>
</span></span><span><span>$ wg genkey &gt; /etc/wireguard/clients/laptop.key
</span></span><span><span>$ wg pubkey &lt; /etc/wireguard/clients/laptop.key &gt; /etc/wireguard/clients/laptop.pub
</span></span><span><span>$ wg genpsk &gt; /etc/wireguard/clients/laptop.psk
</span></span><span><span>
</span></span><span><span>$ wg genkey &gt; /etc/wireguard/clients/mobile1.key
</span></span><span><span>$ wg pubkey &lt; /etc/wireguard/clients/mobile1.key &gt; /etc/wireguard/clients/mobile1.pub
</span></span><span><span>$ wg genpsk &gt; /etc/wireguard/clients/mobile1.psk
</span></span><span><span>
</span></span><span><span>$ wg genkey &gt; /etc/wireguard/clients/mobile2.key
</span></span><span><span>$ wg pubkey &lt; /etc/wireguard/clients/mobile2.key &gt; /etc/wireguard/clients/mobile2.pub
</span></span><span><span>$ wg genpsk &gt; /etc/wireguard/clients/mobile2.psk
</span></span></code></pre></div><p>With the keys created, I prepare the VPS configuration file. Each peer that wants to join the VPN needs its own configuration file. In Wireguard, the configuration file is split into two main sections: <code>[Interface]</code> and <code>[Peer]</code>. Each configuration file can contain zero, one or multiple peers that I can connect to. If I have one peer in my config, I’m connecting to that one device, if I have more, it means I can directly connect to all those peers.</p>
<p>In this case, the server will have multiple peers while the peers will each have a single peer: the server. The term interface is used because Wireguard creates a new network interface which is named according to the name of the configuration file.</p>
<p>Following this, I create a new configuration file named <em>wg0</em>, which means that once I start Wireguard with this configuration, I will have a new network interface called <code>wg0</code>. This can be renamed to anything else.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ nano /etc/wireguard/wg0.conf
</span></span><span><span><span># Next I will populate the file with the below information</span>
</span></span><span><span><span>[</span>Interface<span>]</span>
</span></span><span><span><span># Replace the contents with the value you got in vps.key</span>
</span></span><span><span>PrivateKey <span>=</span> QELYVAdCPCaVQfoyE3KrADMZBBdoNotUseAsKeyThisIsMine+eWUA<span>=</span>
</span></span><span><span>Address <span>=</span> 10.10.10.1/24 <span># the IP address the server will have inside the wg0 network </span>
</span></span><span><span>ListenPort <span>=</span> <span>51820</span> <span># the port on which the server will listen for incoming connections</span>
</span></span><span><span>SaveConfig <span>=</span> true <span># https://manpages.debian.org/unstable/wireguard-tools/wg-quick.8.en.html</span>
</span></span><span><span>PreUp <span>=</span> sysctl -w net.ipv4.ip_forward<span>=</span><span>1</span> <span># enables ipv4 forwarding on the VPS</span>
</span></span><span><span><span># PreUp = sysctl -w net.ipv6.conf.all.forward=1 if you use ipv6 instead</span>
</span></span></code></pre></div><p>At this stage I have the base for my Wireguard network on the server. But because I want to hide traffic from peers behind the server’s IP address I need to apply <a href="https://tldp.org/HOWTO/IP-Masquerade-HOWTO/ipmasq-background2.1.html">masquerading</a> to the incoming requests from the clients, a function similar to NAT. To achieve this, we need to get the data coming in on the network interface Wireguard creates out to the network interface of the server and allow the server to alter the source IP.</p>
<p>The first step is finding the default network interface on the server, so I run the below command:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ ip route list default
</span></span><span><span><span># Output could be something like: </span>
</span></span><span><span><span># default via 123.123.123.123 dev eth0 proto dhcp src 123.123.123.123 metric 100</span>
</span></span></code></pre></div><p>The important bit here is to see the device (in my sample above it is <code>dev eth0</code>). This means I want to route requests that I receive out <code>eth0</code> and apply masquerading, which makes it look like a request received from a smartphone originated from the server.</p>
<p>I will go back to the configuration and continue applying a few more settings to enable masquerading out the <code>eth0</code> interface (again, this can be different on your machine) and allow traffic that comes in on the <code>wg0</code> interface (named after the configuration file) to go out on <code>eth0</code>.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ nano /etc/wireguard/wg0.conf
</span></span><span><span><span># Next I will populate the file with the below information</span>
</span></span><span><span><span>[</span>Interface<span>]</span>
</span></span><span><span>PrivateKey <span>=</span> QELYVAdCPCaVQfoyE3KrADMZBBdoNotUseAsKeyThisIsMine+eWUA<span>=</span>
</span></span><span><span>Address <span>=</span> 10.10.10.1/24 <span># the IP address the server will have inside the wg0 network </span>
</span></span><span><span>ListenPort <span>=</span> <span>51820</span> <span># the port on which the server will listen for incoming connections</span>
</span></span><span><span>SaveConfig <span>=</span> true <span># https://manpages.debian.org/unstable/wireguard-tools/wg-quick.8.en.html</span>
</span></span><span><span>PreUp <span>=</span> sysctl -w net.ipv4.ip_forward<span>=</span><span>1</span> <span># enables ipv4 forwarding on the VPS</span>
</span></span><span><span><span># PreUp = sysctl -w net.ipv6.conf.all.forward=1 if you use ipv6 instead</span>
</span></span><span><span>PostUp<span>=</span> ufw route allow in on wg0 out on eth0
</span></span><span><span>PostUp<span>=</span> iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE
</span></span><span><span>PreDown<span>=</span> ufw route delete allow in on wg0 out on eth0
</span></span><span><span>PreDown<span>=</span> iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
</span></span></code></pre></div><p>This completes the configuration of the Wireguard interface. After exiting and saving the file, I enable a <code>systemd</code> service that follows the name of the config file/interface and check to make sure it runs.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Enable Wireguard service at system startup </span>
</span></span><span><span>$ systemctl enable wg-quick@wg0.service
</span></span><span><span><span># Start Wireguard service</span>
</span></span><span><span>$ systemctl start wg-quick@wg0.service
</span></span><span><span><span># Check service status </span>
</span></span><span><span>$ systemctl status wg-quick@wg0.service
</span></span><span><span>● wg-quick@wg0.service - WireGuard via wg-quick<span>(</span>8<span>)</span> <span>for</span> wg0
</span></span><span><span>     Loaded: loaded <span>(</span>/usr/lib/systemd/system/wg-quick@.service; enabled; preset: enabled<span>)</span>
</span></span><span><span>     Active: active <span>(</span>exited<span>)</span> since Sun 2024-01-01 12:12:42 UTC; 1min 29s ago
</span></span><span><span>       Docs: man:wg-quick<span>(</span>8<span>)</span>
</span></span><span><span>             man:wg<span>(</span>8<span>)</span>
</span></span><span><span>             https://www.wireguard.com/
</span></span><span><span>             https://www.wireguard.com/quickstart/
</span></span><span><span>             https://git.zx2c4.com/wireguard-tools/about/src/man/wg-quick.8
</span></span><span><span>             https://git.zx2c4.com/wireguard-tools/about/src/man/wg.8
</span></span><span><span>    Process: <span>13987</span> ExecStart<span>=</span>/usr/bin/wg-quick up wg0 <span>(</span>code<span>=</span>exited, status<span>=</span>0/SUCCESS<span>)</span>
</span></span><span><span>   Main PID: <span>13987</span> <span>(</span>code<span>=</span>exited, status<span>=</span>0/SUCCESS<span>)</span>
</span></span><span><span>        CPU: 325ms
</span></span><span><span>
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>13997<span>]</span>: net.ipv4.ip_forward <span>=</span> <span>1</span>
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>13987<span>]</span>: <span>[</span><span>#] ip link add wg0 type wireguard</span>
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>13987<span>]</span>: <span>[</span><span>#] wg setconf wg0 /dev/fd/63</span>
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>13987<span>]</span>: <span>[</span><span>#] ip -4 address add 10.10.10.1/24 dev wg0</span>
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>13987<span>]</span>: <span>[</span><span>#] ip link set mtu 1420 up dev wg0</span>
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>13987<span>]</span>: <span>[</span><span>#] ufw route allow in on wg0 out on eth0</span>
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>14017<span>]</span>: Rule added
</span></span><span><span>Jan <span>01</span> 12:12:41 pihole wg-quick<span>[</span>14017<span>]</span>: Rule added <span>(</span>v6<span>)</span>
</span></span><span><span>Jan <span>01</span> 12:12:42 pihole wg-quick<span>[</span>13987<span>]</span>: <span>[</span><span>#] iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE</span>
</span></span><span><span>Jan <span>01</span> 12:12:42 pihole systemd<span>[</span>1<span>]</span>: Finished wg-quick@wg0.service - WireGuard via wg-quick<span>(</span>8<span>)</span> <span>for</span> wg0.
</span></span><span><span><span># Check wireguard status directly and verify the key</span>
</span></span><span><span>$ wg
</span></span><span><span>interface: wg0
</span></span><span><span>  public key: qUo/OLUZadoNotUseAsKeyThisIsMineokE6T3pYl0c<span>=</span>
</span></span><span><span>  private key: <span>(</span>hidden<span>)</span>
</span></span><span><span>  listening port: <span>51820</span>
</span></span><span><span><span># Show network interfaces</span>
</span></span><span><span>$ ip a
</span></span><span><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span>65536</span> qdisc noqueue state UNKNOWN group default qlen <span>1000</span>
</span></span><span><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span><span>    inet 127.0.0.1/8 scope host lo
</span></span><span><span>       valid_lft forever preferred_lft forever  
</span></span><span><span>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span>1500</span> qdisc fq_codel state UP group default qlen <span>1000</span>
</span></span><span><span>    link/ether 1f:1f:1f:1f:1f:1f brd ff:ff:ff:ff:ff:ff
</span></span><span><span>    inet 123.123.123.123/32 metric <span>100</span> scope global dynamic eth0
</span></span><span><span>       valid_lft 60719sec preferred_lft 60719sec
</span></span><span><span>4: wg0: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu <span>1420</span> qdisc noqueue state UNKNOWN group default qlen <span>1000</span>
</span></span><span><span>    link/none 
</span></span><span><span>    inet 10.10.10.1/24 scope global wg0
</span></span><span><span>       valid_lft forever preferred_lft forever
</span></span></code></pre></div><p>After this, I setup the first peer - remember, I need a configuration file for this. The private key field holds the private key of the peer, the pre-shared key is the value of the pre-shared key I created for the peer, and the public key section in the file holds the public key of the VPS.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Just naming it dwg0 as for me it will be easy to see that this is the desktop config</span>
</span></span><span><span><span># To bring this interface up on my desktop I would use `sudo wg-quick up dwg0`</span>
</span></span><span><span>$ nano dwg0.conf
</span></span><span><span><span>[</span>Interface<span>]</span>
</span></span><span><span><span># Replace with the private key file contents for THIS particular device, in my case desktop</span>
</span></span><span><span>PrivateKey <span>=</span> uIwALjBCXdoNotUseAsKeyThisIsMine1Vb/kI3XGXk<span>=</span>
</span></span><span><span><span># The address I had mentioned initially in the topology overview</span>
</span></span><span><span>Address <span>=</span> 10.10.10.11/32
</span></span><span><span><span># The VPS will act as a DNS server for this device</span>
</span></span><span><span>DNS <span>=</span> 10.10.10.1
</span></span><span><span>
</span></span><span><span><span>[</span>Peer<span>]</span>
</span></span><span><span><span># Replace with the public key file contents for your VPS, in my case vps.pub</span>
</span></span><span><span>PublicKey <span>=</span> qUo/OLUdoNotUseAsKeyThisIsMineWgokE6T3pYl0c<span>=</span>
</span></span><span><span><span># Replace with the value you got in your .psk file for THIS particular device, in my case desktop</span>
</span></span><span><span>PresharedKey <span>=</span> pMTDdoNotUseAsKeyThisIsMineeaGilNZRO9OGy3Q<span>=</span>
</span></span><span><span><span># https://www.procustodibus.com/blog/2021/03/wireguard-allowedips-calculator/#background</span>
</span></span><span><span>AllowedIPs <span>=</span> 0.0.0.0/0
</span></span><span><span><span># Replace 123.123.123.123:51820 with the IP of your VPS and the port you used if different</span>
</span></span><span><span>Endpoint <span>=</span> 123.123.123.123:51820
</span></span><span><span>PersistentKeepalive <span>=</span> <span>25</span> <span># https://wiki.archlinux.org/title/WireGuard#Unable_to_establish_a_persistent_connection_behind_NAT_/_firewall</span>
</span></span></code></pre></div><p>At this stage, if I enable the configuration on my desktop, it will not connect to the server. First, I need to add the desktop as a peer of the VPS. I can do that by either bringing down the <code>wg0</code> interface or by using the <code>wg set</code> command. I use the latter, which edits the <em>/etc/wireguard/wg0.conf</em> file and adds a new entry under the <code>[Peer]</code> section.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># The key that I provide to the command is the public key of the desktop </span>
</span></span><span><span>$ wg set wg0 peer KKdoNotUseAsKeyThisIsMineRFCyZVorUW8m7E/3S0<span>=</span> preshared-key /etc/wireguard/clients/desktop.psk allowed-ips 10.10.10.11
</span></span><span><span><span># Check the peer has been added to the interface</span>
</span></span><span><span>$ wg
</span></span><span><span>interface: wg0
</span></span><span><span>  public key: qUo/OLUdoNotUseAsKeyThisIsMineWgokE6T3pYl0c<span>=</span>
</span></span><span><span>  private key: <span>(</span>hidden<span>)</span>
</span></span><span><span>  listening port: <span>51820</span>
</span></span><span><span>
</span></span><span><span>peer: KKdoNotUseAsKeyThisIsMineRFCyZVorUW8m7E/3S0<span>=</span>
</span></span><span><span>  preshared key: <span>(</span>hidden<span>)</span>
</span></span><span><span>  allowed ips: 10.10.10.11/32
</span></span></code></pre></div><p>This completes this part of the setup. To use the server to resolve DNS queries and block ads, I setup Pi-Hole and Unbound next.</p>
<h3 id="pi-hole-setup">Pi-Hole Setup</h3>
<p>I installed Pi-Hole using the automated script from their <a href="https://docs.pi-hole.net/main/basic-install/">website</a>. I won’t go into the details of piping a script to bash directly, but for those of you who wish to dissect the script or use alternative methods, you can clone the repo and run the script that way, or you can download the installer file and run it. You can also use Docker to deploy it, but I won’t cover those in this guide.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ curl -sSL https://install.pi-hole.net | bash
</span></span></code></pre></div><p>You’ll be greeted by a step by step <em>graphical</em> install. Assuming you’re using a VPS with a dedicated IP, you can confirm that you do have a Static IP and select <strong>Continue</strong>. You’ll next be asked for the interface, at this stage select <code>wg0</code> as we want Pi-Hole to run for those connected on the Wireguard interface.</p>
<p>For upstream DNS provider I selected Quad9 for now. Next you’ll be asked to confirm using the suggested block list, select <strong>Yes</strong> and continue the install. Select <strong>Yes</strong> for the admin interface and select <strong>Yes</strong> to install <code>lighttpd</code> and the required PHP modules (adjust if you don’t wish to use these). It is up to yourself if you wish to enable query logging or not. You can turn this off later on, if you enable it now. Select the privacy level for the query log.</p>
<p>Once the install finishes you should see the IP on which Pi-Hole is running, the interface on which it is running and the password. Make sure to save the password.</p>
<p>With both the server and the client configured and Pi-Hole installed, we’re close to turning on the client. Before that, there is one thing to consider. The client configuration sets the server as the DNS resolver. However, the server currently only allows access to port 12345 (SSH) and port 51820 for Wireguard. Ubuntu has <code>systemd-resolved</code> using port 53 for DNS resolution, but access to this port is currently restricted, so I’ll add one more rule to UFW on the server, to allow requests to port 53 coming from the Wireguard IP range I defined earlier.</p>
<p>I also want to be able to configure Pi-Hole once I bring the Wireguard interface up, so for that I need to tell UFW to allow connections to port 80 (HTTP) on the Wireguard IP range.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Allow requests to port 53 from any ip in the 10.10.10.1 - 10.10.10.255 range</span>
</span></span><span><span>$ ufw allow from 10.10.10.0/24 to any port <span>53</span>
</span></span><span><span><span># Allow requests to port 80 from any ip in the 10.10.10.1 - 10.10.10.255 range</span>
</span></span><span><span>$ ufw allow from 10.10.10.0/24 to any port <span>80</span>
</span></span><span><span><span># Reload firewall to apply settings</span>
</span></span><span><span>$ ufw reload
</span></span><span><span><span># Check rules are showing up</span>
</span></span><span><span>$ ufw status numbered
</span></span></code></pre></div><p>At this point, I can copy the contents of the client config to my desktop, bring up the interface on the desktop (using <code>wg-quick</code>) and navigate to http://10.10.10.1/admin and change any settings on the Pi-Hole instance running on the VPS server. But before doing that, I want to have Unbound setup on the server too, and then bring up the interface on my desktop and change the DNS resolver on Pi-Hole from Quad9 to Unbound.</p>
<h3 id="unbound">Unbound</h3>
<p><a href="https://www.nlnetlabs.nl/projects/unbound/about/">Unbound</a> is a recursive, caching DNS resolver. During the Pi-Hole setup, I had picked an upstream DNS resolver, but the issue is, from a privacy standpoint, that the upstream server (in this case Quad9) knows my queries and the queries of everyone using VPS as their DNS, because it’s not VPS resolving the query, it just forwards it to the upstream provider. More information on this, along with the Unbound configuration and setup can be found on the <a href="https://docs.pi-hole.net/guides/dns/unbound/">Pi-Hole website</a>.</p>
<p>In this guide I’ll just walk you through the setup of Unbound and the configuration I use. To start off, I’ll install unbound and configure it.</p>
<p>Chances are that at this point when you check the status of the Unbound service, it shows as failed. The reason is that you have already a resolver running on port 53. To get around this, I setup a new configuration for Unbound in line with the one provided in the Pi-Hole documentation, with a few tweaks to match my VPS and IP ranges.</p>
<p>I create the new configuration file at <em>/etc/unbound/unbound.conf.d/pi-hole.conf</em>, and more details on options and how to change them can be found at the <a href="https://nlnetlabs.nl/documentation/unbound/unbound.conf/">Unbound configuration</a> documentation.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ nano /etc/unbound/unbound.conf.d/pi-hole.conf
</span></span><span><span><span># Add the below to the configuration file; adjust according to your needs and server capabilities  </span>
</span></span><span><span>server:
</span></span><span><span>  num-threads: <span>4</span>
</span></span><span><span>
</span></span><span><span>  <span># Enable operation information logging; up to 5</span>
</span></span><span><span>  verbosity: <span>1</span>
</span></span><span><span>
</span></span><span><span>  <span># Listen to queries on all interfaces</span>
</span></span><span><span>  interface: 127.0.0.1
</span></span><span><span>  port: <span>5353</span>
</span></span><span><span>
</span></span><span><span>  <span># Disable ipv6</span>
</span></span><span><span>  <span>do</span>-ip6: no
</span></span><span><span>
</span></span><span><span>  <span># IP range authorized to send queries to DNS</span>
</span></span><span><span>  access-control: 0.0.0.0/0 refuse
</span></span><span><span>  access-control: 127.0.0.1/32 allow
</span></span><span><span>  access-control: 10.10.10.0/24 allow
</span></span><span><span>
</span></span><span><span>  <span># Hide id.server and hostname.bind</span>
</span></span><span><span>  hide-identity: yes
</span></span><span><span>
</span></span><span><span>  <span># Hide version.server and version.bind</span>
</span></span><span><span>  hide-version: yes
</span></span><span><span>
</span></span><span><span>  <span># Hide addresses on the private network</span>
</span></span><span><span>  private-address: 10.0.0.0/8
</span></span><span><span>
</span></span><span><span>  <span># A total number of unwanted replies is kept track of; when reached cache is cleared to prevent DNS Poisoning</span>
</span></span><span><span>  unwanted-reply-threshold: <span>10000000</span>
</span></span><span><span>
</span></span><span><span>  <span># Because my server has low traffic/usage I enable prefetch; this adds load but cache elements are prefetched before expiry</span>
</span></span><span><span>  prefetch: yes
</span></span><span><span>  prefetch-key: yes
</span></span><span><span>
</span></span><span><span>  <span># Add minimum cache lifetime in seconds</span>
</span></span><span><span>  cache-min-ttl: <span>1800</span>
</span></span><span><span>  cache-max-ttl: <span>14400</span>
</span></span><span><span>
</span></span><span><span>  <span># Secure DNS and use DNSSEC</span>
</span></span><span><span>  harden-glue: yes
</span></span><span><span>  harden-dnssec-stripped: yes
</span></span></code></pre></div><p>Next, I restart the service and run a test query to make sure it’s resolving it.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ systemctl restart unbound.service
</span></span><span><span>$ systemctl status unbound.service
</span></span><span><span>$ dig news.ycombinator.com/ @127.0.0.1 -p <span>5353</span>
</span></span><span><span>; &lt;&lt;&gt;&gt; DiG 9.18.28-0ubuntu0.24.04.1-Ubuntu &lt;&lt;&gt;&gt; news.ycombinator.com/ @127.0.0.1 -p <span>5353</span>
</span></span><span><span>;; global options: +cmd
</span></span><span><span>;; Got answer:
</span></span><span><span>;; -&gt;&gt;HEADER<span>&lt;&lt;- opco</span>de: QUERY, status: NXDOMAIN, id: <span>31572</span>
</span></span><span><span>;; flags: qr rd ra ad; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: <span>1</span>
</span></span><span><span>
</span></span><span><span>;; OPT PSEUDOSECTION:
</span></span><span><span>; EDNS: version: 0, flags:; udp: <span>1232</span>
</span></span><span><span>;; QUESTION SECTION:
</span></span><span><span>;news.ycombinator.com/.		IN	A
</span></span><span><span>
</span></span><span><span>;; AUTHORITY SECTION:
</span></span><span><span>.			3563	IN	SOA	a.root-servers.net. nstld.verisign-grs.com. <span>2024120801</span> <span>1800</span> <span>900</span> <span>604800</span> <span>86400</span>
</span></span><span><span>
</span></span><span><span>;; Query time: <span>18</span> msec
</span></span><span><span>;; SERVER: 127.0.0.1#5353<span>(</span>127.0.0.1<span>)</span> <span>(</span>UDP<span>)</span>
</span></span><span><span>;; WHEN: Sun Jan <span>01</span> 12:14:17 UTC <span>2024</span>
</span></span><span><span>;; MSG SIZE  rcvd: <span>125</span>
</span></span></code></pre></div><p>The query should now be resolved by Unbound as the <code>SERVER</code> in the response gives <code>127.0.0.1#5353</code>.</p>
<p>With this, we’re almost done. I now turn on the Wireguard interface on the desktop as I have the configuration file prepared previously, and I added the client to the VPS’s list of peers.</p>
<p>This will disconnect the current SSH connection, but assuming all previous steps went OK, I am able to reconnect to the VPS server and also access http://10.10.10.1/admin to reach the admin interface for the current Pi-Hole installation.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># On my desktop I will enable the dwg0 service</span>
</span></span><span><span>$ sudo systemctl enable wg-quick@dwg0.service
</span></span><span><span><span># Start the dwg0 service which will create the dwg0 interface on my desktop </span>
</span></span><span><span><span># (I could also name this wg0, I just opted to rename it </span>
</span></span><span><span><span># to make it easier when working with multiple configs)</span>
</span></span><span><span>$ sudo systemctl start wg-quick@dwg0.service
</span></span><span><span><span># Check the status of the service and make sure it is active and running</span>
</span></span><span><span>$ sudo systemctl status wg-quick@dwg0.service
</span></span></code></pre></div><p>Now I can go to the admin interface of the Pi-Hole installation I had setup earlier and change the DNS provider from Quad9 to the instance of Unbound that runs on port 5353 on the VPS.</p>
<p>Once I log into the interface using the password displayed at the end of the Pi-Hole installation, I next go to <strong>Settings</strong>, select the <strong>DNS</strong> tab and here uncheck the Quad9 section in the <strong>Upstream DNS Servers</strong> part of the page. Then, I check the <strong>Custom 1 (IPv4)</strong> checkbox and enter <code>127.0.0.1#5353</code>, make sure that <em>Bind only to interface wg0</em> is selected and then <strong>Save</strong> the settings.</p>
<p>Now I can visit <a href="https://dnsleaktest.com">DNS Leak Test</a> and run an extended test. If everything runs as expected, the only result here should be the IP address of the VPS. If you are getting different servers showing up it means you are leaking DNS queries. There are a multitude of reasons for this, on Ubuntu derived distributions it might be down to Network Manager changing your DNS settings or you having different DNS servers configured which override the Wireguard DNS server.</p>
<p>This can be difficult to debug and it could take some time for you to chase it down, but some tips to get started would be to run <code>resolvectl dns</code> which will show you the global DNS (if this was configured in <em>/etc/systemd/resolved.conf</em>) or if a global DNS is picked up from somewhere else like <em>/run/systemd/resolve/resolved.conf</em> or Network Manager. For Network Manager, check <em>/etc/NetworkManager/system-connections</em> and look for the name of your connection. The file in there will have a setting in the <code>[ipv4]</code> section called <code>dns</code>. This supports multiple DNS settings separated by semicolons.</p>
<p>There are further steps you could take and I recommend the <a href="https://andrea.corbellini.name/2020/04/28/ubuntu-global-dns/">following article by Andrea Corbellini</a>. You can also check to see if it was indeed Pi-Hole that listened and resolved your query by running <code>lsof -i -P -n | grep LISTEN</code> on the VPS and check to see if pihole is actually listening on port 53 or if there is another resolver that is using the port and responding to your queries.</p>
<h3 id="adding-mobile-clients">Adding Mobile Clients</h3>
<p>While getting a configuration file from the VPS to a device with a keyboard is simple, Android and iOS devices aren’t that straightforward. To get a configuration over to a mobile device, I use <code>qrencode</code>. The application creates a QR Code from a given configuration file.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Install qrencode</span>
</span></span><span><span>$ apt install qrencode
</span></span><span><span><span># Create a QR Code from the previously created dwg0.conf file  </span>
</span></span><span><span>$ qrencode -t ansiutf8 &lt; dwg0.conf
</span></span><span><span><span># If the file was created by root and you are now signed in with a non-root account then use </span>
</span></span><span><span>$ sudo sh -c <span>&#39;qrencode -t ansiutf8 &lt; dwg0.conf&#39;</span>
</span></span></code></pre></div><p>The above command outputs a QR code to the terminal directly, which you can then scan with the Wireguard application on iOS or Android. Don’t forget that you need different configuration files for each new device you wish to add, so don’t try to reuse the same configuration file across multiple devices.</p>
<h3 id="accessing-home-server-resources">Accessing Home Server Resources</h3>
<p>One more goal that I wanted to achieve was that of being able to access my home server resources while I’m not on my home network. The final setup is a bit clunky, but it works for now. I’d be curious about any improvements any of you out there can think of. Feel free to e-mail me with any alternatives or ideas on the <em>vpn</em> email address for this domain.</p>
<p>First, go to the Pi-Hole administrator website, select <strong>Local DNS</strong> and then <strong>DNS Records</strong>. Then, add a number of domain/IP addresses to cover your use cases. While the VPN IP address range covers <code>10.10.10.0/24</code> the local home network IP address range covers <code>192.168.1.0/24</code>. Assuming these IP ranges, I ended up with the following list, assuming the home server runs on <code>10.10.10.10</code> within the Wireguard network and <code>192.168.1.10</code> on the local network:</p>
<ul>
<li>Local Domain Name / IP Address</li>
<li><em>emby.home.server</em> / <code>192.168.1.10</code></li>
<li><em>emby.travel.server</em> / <code>10.10.10.10</code></li>
<li><em>torrent.home.server</em> / <code>192.168.1.10</code></li>
<li><em>torrent.travel.server</em> / <code>10.10.10.10</code></li>
</ul>
<p>The home server is running a reverse proxy in front of these services, so each call gets resolved by the reverse proxy to their respective services. The VPS is already allowing traffic to port <code>80</code>, but if you are using HTTPS on any of these services, you would also need a rule to allow traffic to port <code>443</code>.</p>
<p>Lastly, any request coming in on the VPS <code>wg0</code> interface needs to be forwarded out on the same interface, so a couple more <code>ufw</code> rules need added to allow any device to easily reach these services whether they sit on the same LAN, or connect via Wireguard.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Set the following ufw rules on the VPS - this allows forwarding of requests received on wg0 on wg0</span>
</span></span><span><span>$ ufw route allow in on wg0 out on wg0
</span></span><span><span><span># Set the rule to allow HTTPS traffic if your services are running with HTTPS</span>
</span></span><span><span>$ ufw allow from 10.10.10.0/24 to any port <span>443</span>
</span></span><span><span>$ ufw reload
</span></span></code></pre></div><p>An easier way to persist the rules is to add them to the <code>PostUp</code> and <code>PreDown</code> sections of the Wireguard configuration file. The above settings also mean that if I’m on my home network, I can use <em>emby.home.server</em> and access my home server with its local IP address and when I’m outside my home network, then I can access it via <em>emby.travel.server</em>. It’s not ideal, but this seemed to work most consistently across various OSes, devices and apps.</p>
<p>With this change, the <em>travel</em> or external domain should work, but the local one might not, depending on the device you try to access it from. That is because the <code>AllowedIPs</code> setting tells Wireguard to route all traffic through the tunel, but the IP 192.168.1.10 is not reachable through the Wireguard network, as it is an internal network IP address. On most Linux distributions, there are default rules in place to route traffic to these internal or default IP ranges. On Linux you can check the default routes with <code>ip route show table main</code>. On other devices, you need to adjust the <code>AllowedIPs</code> setting, so that all traffic, except for that particular IP range, is routed through the Wireguard tunnel.</p>
<p>I used this <a href="https://www.procustodibus.com/blog/2021/03/wireguard-allowedips-calculator/">Wireguard AllowedIPs Calculator</a> to update the IP range for my mobile devices. By setting <em>Allowed IPs</em> on the page to <code>0.0.0.0/0</code> and the <em>Disallowed IPs</em> to <code>192.168.1.0/24</code>, I would get a list of <code>AllowedIPs</code> like such:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>AllowedIPs <span>=</span> 0.0.0.0/1, 128.0.0.0/2, 192.0.0.0/9, 192.128.0.0/11, 192.160.0.0/13, 192.168.0.0/24, 192.168.2.0/23, 192.168.4.0/22, 192.168.8.0/21, 192.168.16.0/20, 192.168.32.0/19, 192.168.64.0/18, 192.168.128.0/17, 192.169.0.0/16, 192.170.0.0/15, 192.172.0.0/14, 192.176.0.0/12, 192.192.0.0/10, 193.0.0.0/8, 194.0.0.0/7, 196.0.0.0/6, 200.0.0.0/5, 208.0.0.0/4, 224.0.0.0/3
</span></span></code></pre></div><p>On mobile clients you can also go directly into the Wireguard app, click on edit and select the checkbox <em>Exclude private IPs</em> then save the changes to the configuration file. With these changes you should now be able to reach applications on your local network or through the tunnel using the above domain names.</p>
<h3 id="testing-connection-speed-between-vps-and-client-linux">Testing Connection Speed Between VPS and Client (Linux)</h3>
<p>If after the setup, you notice that your connection isn’t that great or that you see a significant drop in connection performance, you can test the connection speed between the VPS and a client that is running Linux using <code>iperf3</code>. This is a good way to check if your speed is slow because of the VPS or some other factors. I would recommend using the <a href="https://speed.cloudflare.com/">Cloudflare Speedtest</a> on a client to get an idea of your current speed without the Wireguard tunnel enabled.</p>
<p>You can then use the <code>speedtest-cli</code> application on the VPS to test its upload and download connection and then use <code>iperf3</code> to test the speed of the connection between client and VPS to find any bottlenecks.</p>
<p>On the VPS I install <code>iperf3</code> and allow connections on port <code>5201</code> to run the speed test. I then start <code>iperf3</code> in server mode, which sets it up to listen for incoming requests.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Install iperf3 if not already installed</span>
</span></span><span><span>$ apt install iperf3
</span></span><span><span><span># Allow connections on port 5201 from the Wireguard IP range</span>
</span></span><span><span>$ ufw allow from 10.10.10.0/24 to any port <span>5201</span>
</span></span><span><span>$ ufw reload
</span></span><span><span><span># Start iperf3 in server mode</span>
</span></span><span><span>$ iperf3 --server
</span></span><span><span><span># Install iperf3 on client too and then start a test by defining the ip of the VPS on the Wireguard network</span>
</span></span><span><span><span># The below command will test the upload speed from client to VPS</span>
</span></span><span><span>$ iperf3 --client 10.10.10.1
</span></span><span><span>Connecting to host 10.10.10.1, port <span>5201</span>
</span></span><span><span><span>[</span>  5<span>]</span> local 10.10.10.11 port <span>56590</span> connected to 10.10.10.1 port <span>5201</span>
</span></span><span><span><span>[</span> ID<span>]</span> Interval           Transfer     Bitrate         Retr  Cwnd
</span></span><span><span><span>[</span>  5<span>]</span>   0.00-1.00   sec  1.21 MBytes  10.1 Mbits/sec    <span>0</span>   81.5 KBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   1.00-2.00   sec  2.39 MBytes  20.1 Mbits/sec    <span>0</span>    <span>195</span> KBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   2.00-3.00   sec  2.94 MBytes  24.7 Mbits/sec    <span>0</span>    <span>331</span> KBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   3.00-4.00   sec  3.37 MBytes  28.3 Mbits/sec    <span>0</span>    <span>484</span> KBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   4.00-5.00   sec  3.86 MBytes  32.4 Mbits/sec    <span>0</span>    <span>640</span> KBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   5.00-6.00   sec  2.45 MBytes  20.5 Mbits/sec    <span>0</span>    <span>786</span> KBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   6.00-7.00   sec  3.86 MBytes  32.4 Mbits/sec    <span>0</span>    <span>945</span> KBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   7.00-8.00   sec  3.50 MBytes  29.3 Mbits/sec    <span>0</span>   1.08 MBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   8.00-9.00   sec  3.75 MBytes  31.5 Mbits/sec    <span>0</span>   1.23 MBytes       
</span></span><span><span><span>[</span>  5<span>]</span>   9.00-10.00  sec  2.50 MBytes  21.0 Mbits/sec    <span>0</span>   1.35 MBytes       
</span></span><span><span>- - - - - - - - - - - - - - - - - - - - - - - - -
</span></span><span><span><span>[</span> ID<span>]</span> Interval           Transfer     Bitrate         Retr
</span></span><span><span><span>[</span>  5<span>]</span>   0.00-10.00  sec  29.8 MBytes  25.0 Mbits/sec    <span>0</span>             sender
</span></span><span><span><span>[</span>  5<span>]</span>   0.00-10.61  sec  27.6 MBytes  21.8 Mbits/sec                  receiver
</span></span><span><span>
</span></span><span><span>iperf Done.
</span></span><span><span><span># The below command will test the download speed from VPS to the client</span>
</span></span><span><span>$ iperf3 --client 10.10.10.1 --reverse
</span></span><span><span>Connecting to host 10.10.10.1, port <span>5201</span>
</span></span><span><span>Reverse mode, remote host 10.10.10.1 is sending
</span></span><span><span><span>[</span>  5<span>]</span> local 10.10.10.11 port <span>34346</span> connected to 10.10.10.1 port <span>5201</span>
</span></span><span><span><span>[</span> ID<span>]</span> Interval           Transfer     Bitrate
</span></span><span><span><span>[</span>  5<span>]</span>   0.00-1.00   sec  3.50 MBytes  29.4 Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   1.00-2.00   sec  7.35 MBytes  61.7 Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   2.00-3.00   sec  11.7 MBytes  98.0 Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   3.00-4.00   sec  23.6 MBytes   <span>198</span> Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   4.00-5.00   sec  39.6 MBytes   <span>332</span> Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   5.00-6.00   sec  44.4 MBytes   <span>372</span> Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   6.00-7.00   sec  40.6 MBytes   <span>340</span> Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   7.00-8.00   sec  40.5 MBytes   <span>340</span> Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   8.00-9.00   sec  38.4 MBytes   <span>322</span> Mbits/sec                  
</span></span><span><span><span>[</span>  5<span>]</span>   9.00-10.00  sec  40.8 MBytes   <span>342</span> Mbits/sec                  
</span></span><span><span>- - - - - - - - - - - - - - - - - - - - - - - - -
</span></span><span><span><span>[</span> ID<span>]</span> Interval           Transfer     Bitrate         Retr
</span></span><span><span><span>[</span>  5<span>]</span>   0.00-10.05  sec   <span>294</span> MBytes   <span>245</span> Mbits/sec    <span>0</span>             sender
</span></span><span><span><span>[</span>  5<span>]</span>   0.00-10.00  sec   <span>290</span> MBytes   <span>244</span> Mbits/sec                  receiver
</span></span><span><span>
</span></span><span><span>iperf Done.
</span></span></code></pre></div><p>In the above tests I can see that my upload speed to this test VPS is between 10 and 30 Mbps and my download speed is between 30 and 340 Mbps. After completing the test, I can stop the server on the VPS and even close down the port. For more information on tuning the performance of Wireguard, I recommend the <a href="https://www.procustodibus.com/blog/2022/12/wireguard-performance-tuning/">detailed article on the Pro Custodibus website</a>.</p>
<h3 id="links">Links</h3>
<p>At this stage, you should have your VPS setup, your first two devices connected and you should also be able to access any remote resources.</p>
<p>Most of this could not be done without the articles below. These were great resources and I would greatly recommend them for further reading of a particular topic:</p>
<ul>
<li>Initial idea:  <a href="https://www.ckn.io/blog/2017/11/14/wireguard-vpn-typical-setup/">https://www.ckn.io/blog/2017/11/14/wireguard-vpn-typical-setup/</a></li>
<li>Ubuntu 22.04 Digital Ocean Wireguard setup guide: <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-wireguard-on-ubuntu-22-04">https://www.digitalocean.com/community/tutorials/how-to-set-up-wireguard-on-ubuntu-22-04</a></li>
<li>What is Unbound: <a href="https://www.nlnetlabs.nl/projects/unbound/about/">https://www.nlnetlabs.nl/projects/unbound/about/</a></li>
<li>Pi-Hole Wireguard setup and information: <a href="https://docs.pi-hole.net/guides/vpn/wireguard/overview/">https://docs.pi-hole.net/guides/vpn/wireguard/overview/</a></li>
<li>UFW rules help: <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-20-04">https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-20-04</a></li>
<li>SSH behind Wireguard: <a href="https://rair.dev/wireguard-ssh/">https://rair.dev/wireguard-ssh/</a></li>
<li>Network Manager information on how DNS is processed and set: <a href="https://developer-old.gnome.org/NetworkManager/stable/NetworkManager.conf.html">https://developer-old.gnome.org/NetworkManager/stable/NetworkManager.conf.html</a></li>
<li>Android Mobile client Wireguard setup: <a href="https://tech.serhatteker.com/post/2021-01/how-to-set-up-wireguard-client-on-android/">https://tech.serhatteker.com/post/2021-01/how-to-set-up-wireguard-client-on-android/</a></li>
</ul>
<p>There are plenty more websites that I read through for quick fixes and I apologise for not recording those consistently, as the information there helped me fix some local issues on my Pop OS desktop.</p>
<p>In any case, I hope this article was useful and helped you setup your own Wireguard VPN server, access resources on your home network and provide network-wide ad-block for all your devices. By using a VPS you can generally cover a variety of devices for around $10 a month. This beats a lot of the providers out there and it does so while offering you full control over blocking lists and resources on the network.</p>
<p>If this guide was useful in any way, please make sure to support the <a href="https://www.wireguard.com/donations/">Wireguard</a> project, the <a href="https://pi-hole.net/donate/#donate">Pi-Hole</a> project, <a href="https://github.com/sponsors/NLnetLabs?o=esb">Unbound</a> and all the other open source projects that allow us to gain some modicum of control over out digital lives!</p>
<h3 id="catalin">Catalin</h3>

    </div>
  </div></div>
  </body>
</html>
