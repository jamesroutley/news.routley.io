<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://feyor.sh/blog/speedier-elisp-refs/">Original</a>
    <h1>Speedier elisp-refs-* with Dumb Grep</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content">




<content>
  <p><a href="https://github.com/Wilfred/helpful">Helpful</a> is a fantastic Emacs package that drastically improves the builtin <kbd>help-mode</kbd>.
One of the particularly nice features is finding references to a particular symbol.
Unfortunately it can be painfully slow in practice due to actually parsing every loaded Elisp file:</p>





<details open="">
  <summary>Emacs Lisp</summary>
  <div><pre tabindex="0"><code data-lang="elisp"><span><span>(<span>require</span> <span>&#39;benchmark</span>)
</span></span><span><span>(<span>benchmark-elapse</span> (<span>elisp-refs-function</span> <span>#&#39;car</span>))</span></span></code></pre></div>
</details>






<p>Instead of walking the ASTs of every file, why not do a regex search?</p>
<p>It sacrifices correctness (and completely ignores the type of the symbol), but it turns out to be orders of magnitude faster in practice.
Bonus points for using a fast tool like ripgrep and extra bonus points for completing the work asynchronously so as not to block Emacs’s main thread.</p>
<blockquote>
<p>I don’t mean to denigrate <a href="https://github.com/Wilfred/elisp-refs">elisp-refs</a>; the author clearly has put a lot of thought into performance and it’s only natural that using an approach that heavily cuts corners together with a tool implemented in optimized machine code instead of Elisp (which is especially hampered by GC performance) will lead to faster results.</p>
<p>I’m a ripgrep junkie and I prefer it for grokking most codebases, but the speed comes at the cost of having to sift through many false positives.</p>
</blockquote>
<p>I use the wonderful <a href="https://github.com/Wilfred/deadgrep">deadgrep</a> package to do just that:</p>





<details open="">
  <summary>Emacs Lisp</summary>
  <div><pre tabindex="0"><code data-lang="elisp"><span><span>(<span>when</span> (<span>locate-library</span> <span>&#34;deadgrep&#34;</span>)
</span></span><span><span>  (<span>require</span> <span>&#39;deadgrep</span>)
</span></span><span><span>  (<span>fset</span> <span>&#39;deadgrep--arguments-orig</span> (<span>symbol-function</span> <span>#&#39;</span><span>deadgrep--arguments</span>))
</span></span><span><span>  (<span>define-advice</span> <span>helpful--all-references</span> (<span>:override</span> (<span>button</span>) <span>fysh/use-deadgrep</span>)
</span></span><span><span>    (<span>cl-letf*</span> (((<span>symbol-function</span> <span>&#39;deadgrep--arguments</span>)
</span></span><span><span>                (<span>lambda</span> (<span>&amp;rest</span> <span>args</span>)
</span></span><span><span>                  <span>`</span>(<span>&#34;--follow&#34;</span> <span>&#34;--type=elisp&#34;</span> <span>&#34;--type=gzip&#34;</span> <span>&#34;--search-zip&#34;</span> <span>,@</span>(<span>butlast</span> (<span>apply</span> <span>#&#39;</span><span>deadgrep--arguments-orig</span> <span>args</span>)) <span>,</span><span>lisp-directory</span> <span>,</span>(<span>-first</span> (<span>lambda</span> (<span>p</span>) (<span>string-suffix-p</span> <span>&#34;/share/emacs/site-lisp&#34;</span> <span>p</span>)) <span>load-path</span>)))))
</span></span><span><span>      (<span>deadgrep</span> (<span>symbol-name</span> (<span>button-get</span> <span>button</span> <span>&#39;symbol</span>)) <span>default-directory</span>))))</span></span></code></pre></div>
</details>
<p>The code is quite hacky because deadgrep is not designed to allow passing multiple directories in a single search, but this gets the job done.</p>





<details open="">
  <summary>Emacs Lisp</summary>
  <div><pre tabindex="0"><code data-lang="elisp"><span><span>(<span>with-temp-buffer</span>
</span></span><span><span>  (<span>let</span> ((<span>button</span> (<span>make-button</span> (<span>point-min</span>) (<span>point-max</span>)))
</span></span><span><span>        (<span>time-to-draw</span>)
</span></span><span><span>        (<span>time-to-completion</span>))
</span></span><span><span>    (<span>button-put</span> <span>button</span> <span>&#39;symbol</span> <span>#&#39;car</span>)
</span></span><span><span>
</span></span><span><span>    (<span>setq</span> <span>time-to-completion</span> (<span>benchmark-elapse</span>
</span></span><span><span>                               (<span>setq</span> <span>time-to-draw</span> (<span>benchmark-elapse</span> (<span>helpful--all-references</span> <span>button</span>)))
</span></span><span><span>                               (<span>while</span> <span>deadgrep--running</span> (<span>sit-for</span> <span>0.1</span> <span>&#39;nodisp</span>))))
</span></span><span><span>    (<span>format</span> <span>&#34;Time to first draw: %s\nTime to completion: %s&#34;</span> <span>time-to-draw</span> <span>time-to-completion</span>)))</span></span></code></pre></div>
</details>





<div><pre tabindex="0"><code data-lang="text"><span><span>Time to first draw: 0.084542
</span></span><span><span>Time to completion: 38.184606</span></span></code></pre></div>
<p>In this pathological case the total time is slower than using <kbd>elisp-refs-function</kbd> because there are almost four times as many matches because of comments/docstrings and partial matches like <code>mapcar</code> or <code>car-safe</code> (including symbols that aren’t functions like <code>byte-car</code>).
The major difference is that while the performance of <kbd>elisp-refs-*</kbd> functions<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> are roughly constant regardless of the total number of references to a symbol, using ripgrep is significantly faster for terms with fewer than 10k matches (not to mention that you can browse the results immediately).</p>
<p>If you want to remove the partial matches, you could use the following advice instead:</p>





<details open="">
  <summary>Emacs Lisp</summary>
  <div><pre tabindex="0"><code data-lang="elisp"><span><span>(<span>define-advice</span> <span>helpful--all-references</span> (<span>:override</span> (<span>button</span>) <span>fysh/use-deadgrep</span>)
</span></span><span><span>  (<span>cl-letf*</span> (((<span>symbol-function</span> <span>&#39;deadgrep--arguments</span>)
</span></span><span><span>              (<span>lambda</span> (<span>&amp;rest</span> <span>args</span>)
</span></span><span><span>                <span>`</span>(<span>&#34;--follow&#34;</span> <span>&#34;--type=elisp&#34;</span> <span>&#34;--type=gzip&#34;</span> <span>&#34;--search-zip&#34;</span> <span>,@</span>(<span>butlast</span> (<span>apply</span> <span>#&#39;</span><span>deadgrep--arguments-orig</span> <span>args</span>) <span>3</span>) <span>&#34;--no-fixed-strings&#34;</span> <span>&#34;--&#34;</span> <span>,</span>(<span>car</span> <span>args</span>) <span>,</span><span>lisp-directory</span> <span>,</span>(<span>-first</span> (<span>lambda</span> (<span>p</span>) (<span>string-suffix-p</span> <span>&#34;/share/emacs/site-lisp&#34;</span> <span>p</span>)) <span>load-path</span>)))))
</span></span><span><span>    (<span>deadgrep</span> (<span>format</span> <span>&#34;(\\(|#?&#39;| )(%s) &#34;</span> (<span>symbol-name</span> (<span>button-get</span> <span>button</span> <span>&#39;symbol</span>))) <span>default-directory</span>)))</span></span></code></pre></div>
</details>
<p>This unfortunately will highlight the entire match instead of just the capturing group, so I prefer not to use it (althgough the speed is mostly the same, if not a bit faster).</p>


</content>
<p>
  
    <a href="https://feyor.sh/tags/emacs/">#emacs</a>  
  
</p>

  </div></div>
  </body>
</html>
