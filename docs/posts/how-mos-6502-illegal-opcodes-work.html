<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pagetable.com/?p=39">Original</a>
    <h1>How MOS 6502 Illegal Opcodes work</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
			<p>The original NMOS version of the MOS 6502, used in computers like the Commodore 64, the Apple II and the Nintendo Entertainment System (NES), is well-known for its illegal opcodes: Out of 256 possible opcodes, 151 are defined by the architecture, but many of the remaining 105 undefined opcodes do useful things.</p>
<p><a href="http://www.viceteam.org/plain/64doc.txt">Many</a> <a href="http://www.ffd2.com/fridge/docs/6502-NMOS.extra.opcodes">articles</a> <a href="http://members.chello.nl/taf.offenga/illopc31.txt">have</a> <a href="http://www.oxyron.de/html/opcodes02.html">been</a> <a href="http://bbc.nvg.org/doc/6502OpList.txt">written</a> to test and document these, but I am not aware of any article that tries to explain where exactly they come from. I’ll do this here.</p>
<h3>The Block Diagram</h3>
<p>Every 6502 data sheet comes with a block diagram, but these are of no use, because they are oversimplified, partially incorrect, and don’t explain how instruction decoding works. The following more detailed diagram is a lot more useful:</p>
<p><a href="http://www.weihenstephan.org/~michaste/pagetable/6502/6502.jpg"><img src="http://www.weihenstephan.org/~michaste/pagetable/6502/6502_small.png"/></a></p>
<h3>The Decode ROM (PLA)</h3>
<p>There is no need to understand the whole diagram. The important part is on the left: The instruction register, which holds the opcode, and the current clock cycle within the instruction (T0 to T6) get fed into a 130×21 bit decode ROM, i.e. a ROM with 130 lines of 21 bits each. On the die shot, this is the green area on the bottom.</p>
<p><a href="http://www.weihenstephan.org/~michaste/pagetable/6502/6502-die.jpg"><img src="http://www.weihenstephan.org/~michaste/pagetable/6502/6502-die.jpg" width="400"/></a></p>
<p>While other CPUs from the same era used microcode to interpret the instruction, the 6502 had this 130×21 bit PLA. All lines of the PLA compare the instruction and the current clock cycle, and if they match, the line fires. A little simplified, every line looks like this:</p>
<table>
<tbody><tr>
<td colspan="8"><b>ON bits</b></td>
<td colspan="8"><b>OFF bits</b></td>
<td colspan="6"><b>timing</b></td>
</tr>
<tr>
<td><i>7</i></td>
<td><i>6</i></td>
<td><i>5</i></td>
<td><i>4</i></td>
<td><i>3</i></td>
<td><i>2</i></td>
<td><i>1</i></td>
<td><i>0</i></td>
<td><i>7</i></td>
<td><i>6</i></td>
<td><i>5</i></td>
<td><i>4</i></td>
<td><i>3</i></td>
<td><i>2</i></td>
<td><i>1</i></td>
<td><i>0</i></td>
<td><i>T6</i></td>
<td><i>T5</i></td>
<td><i>T4</i></td>
<td><i>T3</i></td>
<td><i>T2</i></td>
<td><i>T1</i></td>
</tr>
</tbody></table>
<p>(See the diagrams at <a href="http://impulzus.sch.bme.hu/6502/letolt.php3">http://impulzus.sch.bme.hu/6502/</a> for details; partial English translation of the website <a href="http://www.downloads.reactivemicro.com/Public/Electronics/Reverse%20Engineering/">here</a>).</p>
<ul>
<li><b>“ON bits”</b> specifies, which bits need to be <b>set</b> for this line to fire.</li>
<li><b>“OFF bits”</b> specifies, which bits need to be <b>clear</b> for this line to fire.</li>
</ul>
<p>The opcode table of the 6502 is laid out in a way that you can find easy rules to generalize the effects of similar opcodes. For example, the branch opcodes are encoded like this:</p>
<pre>%aab10000</pre>
<p>where “aa” is the condition (00=N, 01=V, 10=C, 11=Z) and “b” decides whether the branch is taken on a set or a clear flag.</p>
<p>So the following line would fire on the first cycle of any branch:</p>
<table>
<tbody><tr>
<td colspan="8"><b>ON bits</b></td>
<td colspan="8"><b>OFF bits</b></td>
<td colspan="6"><b>timing</b></td>
</tr>
<tr>
<td><i>7</i></td>
<td><i>6</i></td>
<td><i>5</i></td>
<td><i>4</i></td>
<td><i>3</i></td>
<td><i>2</i></td>
<td><i>1</i></td>
<td><i>0</i></td>
<td><i>7</i></td>
<td><i>6</i></td>
<td><i>5</i></td>
<td><i>4</i></td>
<td><i>3</i></td>
<td><i>2</i></td>
<td><i>1</i></td>
<td><i>0</i></td>
<td><i>T6</i></td>
<td><i>T5</i></td>
<td><i>T4</i></td>
<td><i>T3</i></td>
<td><i>T2</i></td>
<td><i>T1</i></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>From now on, let’s write it differently, so that it’s more readable:</p>
<table>
<tbody><tr>
<td><b>mask</b></td>
<td><b>cycle</b></td>
<td><b>description</b></td>
</tr>
<tr>
<td>XXX10000</td>
<td>T1</td>
<td>T1 of Bcc: fetch branch offset</td>
</tr>
</tbody></table>
<p>If a line fires, it outputs a “1”. The “Random Control Logic” that can seen in the diagram then AND/OR-combines some lines and feeds the result into various components of the CPU: In the case of a branch, this would result in fetching the branch offset, for example.</p>
<p>One line can fire for several opcodes that are similar in their encoding and thus their behavior: For example, “LDA abs”, “ORA abs” and “AND abs” all do the same thing (fetch the low byte of the address) in T1, so there can be a line that matches all these opcodes and causes a memory fetch and a PC increment. Also, multiple lines can fire at the same time for any given cycle within an instruction, which will have the combined effect of the single lines.</p>
<h3>LDA and LDX becomes LAX</h3>
<p>Now there are many undefined opcodes. The designers of the 6502 have not created any specific PLA lines for them, but since their opcodes are similar to well-defined opcodes, there might be lines that fire nevertheless.</p>
<p>Let’s take opcode $AF for example, which is “LAX absolute”. It loads a value from an absolute address in memory and stores it in A and X at the same time. This is somewhat the combination of opcodes $AD (LDA abs) and $AE (LDX abs).</p>
<p>The instructions “LDA/LDX/LDY abs” ($AC/$AD/$AE) consist of four cycles:</p>
<ul>
<li>The first cycle fetches the low byte of the address.</li>
<li>The second cycle fetches the hgh byte of the address.</li>
<li>The third cycle fetches the address from memory and stores it in A/X/Y.</li>
<li>The fourth cycle fetches the next instruction.</li>
</ul>
<p>Cycles T1, T2 and T4 are identical for all three of them, and they are encoded smilarly, so the following three PLA lines can be used to detect these instructions and signal the rest of the CPU to carry out the specific tasks:</p>
<table>
<tbody><tr>
<td><b>mask</b></td>
<td><b>cycle</b></td>
<td><b>description</b></td>
</tr>
<tr>
<td>101011XX</td>
<td>T1</td>
<td>T1 of $AC/$AD/$AE: fetch addr/lo</td>
</tr>
<tr>
<td>101011XX</td>
<td>T2</td>
<td>T2 of $AC/$AD/$AE: fetch addr/lo</td>
</tr>
<tr>
<td>101011XX</td>
<td>T4</td>
<td>T4 of $AC/$AD/$AE: fetch next opcode</td>
</tr>
</tbody></table>
<p>The mask %101011XX doesn’t only fire for $AC/$AD/$AE, but also for the undefined opcode $AF: So $AF (LAX) behaves the same as LDA/LDX/LDY in T1/T2/T4, i.e. it fetches a 16 bit address and in the end fetches the next opcode.</p>
<p>T3 differs in all three cases, so it has to be handled by one separate line per case:</p>
<table>
<tbody><tr>
<td><b>mask</b></td>
<td><b>cycle</b></td>
<td><b>description</b></td>
</tr>
<tr>
<td>10101100</td>
<td>T3</td>
<td>T3 of $AC: read into Y</td>
</tr>
<tr>
<td>101011X1</td>
<td>T3</td>
<td>T3 of $AD: read into A</td>
</tr>
<tr>
<td>1010111X</td>
<td>T3</td>
<td>T3 of $AE: read into X</td>
</tr>
</tbody></table>
<p>(Actually, the lines in the actual PLA might be less specific, i.e. contain more X bits, since there are similar instructions like “ORA absolute” that might share this line.)</p>
<p>The line for $AC is only true for the exact value of $AC, but the $AD and $AE lines have one “don’t care” bit each. The bitfield of $AF, which is %10101111, is true for both masks, so in T3 of $AF, both the $AD and the $AE lines fire.</p>
<p>In T3, LDA/LDX/LDY have in common that they all read from memory and put the result onto the internal “SB” bus. “LDA” also sets the “SB-&gt;AC” control line to “1”, which will make the accumulator read its value from SB. Likewise, LDX causes “SB-&gt;X” to be “1” and makes X to read from the SB bus, and LDY reads SB into the Y register.</p>
<p>Since both the LDA and the LDX lines fire, both the accumulator and the X register will be sent the command to load their values from the SB bus, so $AF is effectively an LAX: Load Accumulator and X.</p>
<h3>The KIL Opcodes</h3>
<p>There are many “KIL” opcodes, i.e. opcodes that stop the CPU, so that it can only recover using a RESET, and not even an IRQ or an NMI.</p>
<p>In order to understand this, let’s look at the different states an instruction can be in. After the instruction fetch, the CPU is in cycle T1. It will feed the opcode and the cycle number into the PLA and cause the rest of the CPU to carry out whatever has to be done in this cycle, according to the PLA. Then it will shift the T bitfield left by one, so the T2 line will be “1”, then line T3 and so on. There are seven T lines total, T1 to T7. At the end of each instruction, the PLA causes the T bitfield to reset, so that the next instruction starts with T1=1 again.</p>
<p>But what happens if T does not get reset? This can happen if in all seven states of T, no line fires that actually belongs to an instruction that ends at this cycle. T gets shifted left until state T7, in which another shift left will just shift the 1 bit out of T – all bits of T will be zero then, so no PLA line can fire any more.</p>
<p>All interrupt and NMI requests are always delayed until the current instruction is finished, i.e. until T gets reset. But since T never gets reset, all interrupts and NMIs are effectively disabled.</p>
<h3>What’s next?</h3>
<p>There are many illegal opcodes, some with very weird behavior, and some that have been documented as unstable. Studying all these can reveal many interesting details about the internal design of the 6502.</p>
		</div></div>
  </body>
</html>
