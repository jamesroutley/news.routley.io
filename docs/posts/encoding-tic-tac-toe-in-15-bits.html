<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cbarrick.dev/posts/2024/02/19/tic-tac-toe">Original</a>
    <h1>Encoding tic-tac-toe in 15 bits</h1>
    
    <div id="readability-page-1" class="page"><div> <article> <time datetime="2024-02-19T00:00:00+00:00"> Feb 19th, 2024 </time>  <p>I recently stumbled upon a <a href="https://blog.goose.love/posts/tictactoe/">blog post</a> by Alejandra González (a.k.a <a href="https://tech.lgbt/@blyxyas">@blyxyas</a>) that seeks to compress a tic-tac-toe game state into as few bits as possible. She arrived at a solution in 18 bits. This got me thinking, can we do better?</p> <p>As Alejandra points out, there are 765 possible game states<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>. We could simply assign a number to all of the sates, which would take up 10 bits<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>. But in Alejandra’s words, that’s “boring.” More specifically, there’s not much we can do with a representation like that. Whether we want to read the value of a given cell or update from one state to another, in practice we’re going to need a lookup table to map each number to a larger, more structured representation, which defeats the whole idea behind a compressed representation.</p> <figure> <img src="https://cbarrick.dev/assets/tic-tac-toe-game.svg" alt="A game of tic-tac-toe" width="100%"/> <figcaption> A game of tic-tac-toe / © <a href="https://commons.wikimedia.org/wiki/User:Stannered">User:Stannered</a> / <a href="https://commons.wikimedia.org">Wikimedia Commons</a> / <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA-3.0</a> </figcaption> </figure> <h3 id="an-18-bit-solution">An 18 bit solution</h3> <p>Alejandra came up with a better solution, where each cell is represented by a pair of bits, and the grid is represented as a concatenation of nine of these bit pairs. Within a bit pair, one bit represents a circle and the other represents a cross; at most one bit of the pair can be set.</p> <div><div><pre><code><span>// The representation of a single cell.</span>
<span>typedef</span> <span>enum</span> <span>cell</span> <span>{</span>
    <span>EMPTY</span>  <span>=</span> <span>0</span><span>,</span> <span>// Binary 00</span>
    <span>CROSS</span>  <span>=</span> <span>1</span><span>,</span> <span>// Binary 01</span>
    <span>CIRCLE</span> <span>=</span> <span>2</span><span>,</span> <span>// Binary 10</span>
<span>}</span> <span>cell</span><span>;</span>

<span>// The concatenation of 9 cells. We only care about the lower 18 bits.</span>
<span>typedef</span> <span>uint32_t</span> <span>state</span><span>;</span>
</code></pre></div></div> <p>The core methods that we would like to have on our state type are getting and setting cell values at a given index. This is pretty easy to implement with some quick bit-twiddling.</p> <div><div><pre><code><span>cell</span> <span>get_cell</span><span>(</span><span>state</span> <span>s</span><span>,</span> <span>int</span> <span>i</span><span>)</span> <span>{</span>
    <span>int</span> <span>pos</span> <span>=</span> <span>2</span> <span>*</span> <span>i</span><span>;</span>        <span>// Bit offset of cell i.</span>
    <span>return</span> <span>(</span><span>s</span> <span>&gt;&gt;</span> <span>pos</span><span>)</span> <span>%</span> <span>4</span><span>;</span>  <span>// Read the cell.</span>
<span>}</span>

<span>void</span> <span>set_cell</span><span>(</span><span>state</span> <span>*</span><span>s</span><span>,</span> <span>int</span> <span>i</span><span>,</span> <span>cell</span> <span>val</span><span>)</span> <span>{</span>
    <span>int</span> <span>pos</span> <span>=</span> <span>2</span> <span>*</span> <span>i</span><span>;</span>    <span>// Bit offset of cell i.</span>
    <span>*</span><span>s</span> <span>&amp;=</span> <span>~</span><span>(</span><span>3</span> <span>&lt;&lt;</span> <span>pos</span><span>);</span>  <span>// Clear the old value.</span>
    <span>*</span><span>s</span> <span>|=</span> <span>val</span> <span>&lt;&lt;</span> <span>pos</span><span>;</span>   <span>// Set the new value.</span>
<span>}</span>
</code></pre></div></div> <p>This is a fantastic, efficient solution.</p> <h3 id="getting-smaller-with-base-3">Getting smaller with base-3</h3> <p>In practice, the number of bits in an integer needs to be a power of two. In the code above, we used a 32 bit integer to hold our state, when we really only needed 18 bits. If we could save just two more bits, we could cut our memory usage in half by using a 16 bit integer for the game state.</p> <p>In the code above, we’ve conceived the game state as the concatenation of nine cell states. This is a good idea because it makes it simple to implement our core methods. We can think of this as a base-4 number where each cell state is a base-4 digit having values 0 (empty), 1 (cross), 2 (circle), and 3 (invalid). This conception shows up in the code too, where we convert our base-4 index into a base-2 index by multiplying it by 2, so that we can use bitwise operations to access the data.</p> <p>The problem is that pesky invalid cell state. What if we instead conceive the game state as a base-3 number and a cell state as a base-3 digit? In this case we need nine base-3 digits, which maxes out at \(3^9-1\) or 19,682. Representing this in binary will cost us… 15 bits<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>!</p> <p>So we can use a base-3 representation to hit our 16 bit target. But how do we implement our methods?</p> <p>The trick is to generalize our bit-twiddling to arbitrary bases. In binary, the left-shift operation <code>x &lt;&lt; i</code> is equivalent to \(x \cdot 2^i\), and likewise the right-shift operation <code>x &gt;&gt; i</code> is equivalent to \(x \div 2^i \). To generalize these operations from base-2 to base-n, just replace 2 with n. For the other bitwise operations, we can use a combination of addition and subtraction.</p> <p>The new code looks like this:</p> <div><div><pre><code><span>// The representation of a single cell.</span>
<span>typedef</span> <span>enum</span> <span>cell</span> <span>{</span>
    <span>EMPTY</span>  <span>=</span> <span>0</span><span>,</span>
    <span>CROSS</span>  <span>=</span> <span>1</span><span>,</span>
    <span>CIRCLE</span> <span>=</span> <span>2</span><span>,</span>
<span>}</span> <span>cell</span><span>;</span>

<span>// Think of the game sate as a base-3 number with 9 digits.</span>
<span>typedef</span> <span>uint16_t</span> <span>state</span><span>;</span>

<span>// A helper to compute pow(3, i), when 0 &lt;= i &lt; 9.</span>
<span>static</span> <span>int</span> <span>pow3</span><span>(</span><span>int</span> <span>i</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>i</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>9</span> <span>&lt;=</span> <span>i</span><span>)</span> <span>return</span> <span>1</span><span>;</span>
    <span>static</span> <span>int</span> <span>p</span><span>[]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>9</span><span>,</span> <span>27</span><span>,</span> <span>81</span><span>,</span> <span>243</span><span>,</span> <span>729</span><span>,</span> <span>2187</span><span>,</span> <span>6561</span><span>};</span>
    <span>return</span> <span>p</span><span>[</span><span>i</span><span>];</span>
<span>}</span>

<span>cell</span> <span>get_cell</span><span>(</span><span>state</span> <span>s</span><span>,</span> <span>int</span> <span>i</span><span>)</span> <span>{</span>
    <span>int</span> <span>div</span> <span>=</span> <span>pow3</span><span>(</span><span>i</span><span>);</span>     <span>// Get the base-3 offset of the cell.</span>
    <span>return</span> <span>(</span><span>s</span> <span>/</span> <span>div</span><span>)</span> <span>%</span> <span>3</span><span>;</span>  <span>// &#34;Shift&#34; the base-3 number and read the cell.</span>
<span>}</span>

<span>void</span> <span>set_cell</span><span>(</span><span>state</span> <span>*</span><span>s</span><span>,</span> <span>int</span> <span>i</span><span>,</span> <span>cell</span> <span>val</span><span>)</span> <span>{</span>
    <span>int</span> <span>div</span> <span>=</span> <span>pow3</span><span>(</span><span>i</span><span>);</span>         <span>// Get the base-3 offset of the cell.</span>
    <span>int</span> <span>old</span> <span>=</span> <span>(</span><span>*</span><span>s</span> <span>/</span> <span>div</span><span>)</span> <span>%</span> <span>3</span><span>;</span>  <span>// Read the old value of the cell.</span>
    <span>*</span><span>s</span> <span>-=</span> <span>old</span> <span>*</span> <span>div</span><span>;</span>           <span>// Reset the cell to empty.</span>
    <span>*</span><span>s</span> <span>+=</span> <span>val</span> <span>*</span> <span>div</span><span>;</span>           <span>// Set the cell value.</span>
<span>}</span>
</code></pre></div></div> <h3 id="conclusion">Conclusion</h3> <p>Is this any better? It depends, but probably not.</p> <p>If you had a very large number of game states that you needed to store, you could pack them tightly using 18 bits for the base-4 representation or 15 bits for the base-3 representation. That’s a savings of 16%, which may or may not be worth it.</p> <p>And if you’re chosing a representation for CPU performance, then the base-4 representation wins hands down. The base-3 representation has a lof of multiplication and division that can’t be easily optimized away.</p> <p>But if you had some wild application where you needed to keep trillions of game states unpacked in memory, then sure, use base-3.</p> <p>This is a wild case of premature optimization that nobody asked for. 😅</p> <p>You can find <a href="https://gist.github.com/cbarrick/8c5726dcca7f5f1e436585e672bc7f1f">test cases on GitHub</a>.</p>  </article> </div></div>
  </body>
</html>
