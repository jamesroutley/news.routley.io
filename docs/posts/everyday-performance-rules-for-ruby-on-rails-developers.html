<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.rorvswild.com/blog/2023/everyday-performance-rules-for-ruby-on-rails-developers">Original</a>
    <h1>Everyday performance rules for Ruby on Rails developers</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p><em>This post takes inspiration from <a href="https://anthonyhobday.com/sideprojects/saferules">Visual design rules you can safely follow every time</a> by Anthony Hobday.</em></p>

<p>Here, we’re talking about performance rules you can safely follow every time. As with any rules, you are free to break them. You may need a good reason to do so.</p>

<p>We are covering some best practices for HTTP, Ruby, and the database layers so that most applications with decent traffic can improve their response time.
Some of these practices can be obvious to experienced developers. Your applications are on good Rails if you already know and use them all.</p>

<h2>HTTP</h2>

<h3>Use a CDN</h3>

<p>Serve all resources from a CDN. It will reduce latency for your visitors and the number of requests to your server. What’s more, CDNs provide more bandwidth than your servers.</p>

<p>CDNs aren’t expensive, and their rates are very progressive. They are also simple to set:</p>

<pre><code>config.action_controller.asset_host = &#34;cdn.application.example&#34;
</code></pre>

<p>We can’t think of any good reason to do without them except for an application running solely on a private network.</p>

<h3>Enable HTTP compression</h3>

<p>Compression saves bandwidth at a modest CPU cost.
Most web servers, like  <a href="https://httpd.apache.org/docs/current/mod/mod_deflate.html">Apache</a> and <a href="https://nginx.org/en/docs/http/ngx_http_gzip_module.html">Nginx</a>, enable compression by default.
To be sure, verify the presence of <code>Content-Encoding: gzip</code> in the response headers.</p>

<h3>Enable HTTP cache</h3>

<p>A cached resource means one less request for the client and server and, therefore, a faster loading time.</p>

<p>The Cache-Control header gives instructions to browsers and CDNs.
Check that you have a header in the response that looks like this <code>Cache-Control &#34;max-age=86400, public&#34;</code>.
Max age is the duration in seconds, so 24 hours in this case.
It’s up to you to decide whether you need a more aggressive cache.</p>

<p>For private resources, turn off the cache with the <code>Cache-Control: private</code> header.</p>

<h3>Enable keep-alive connections</h3>

<p>Keep-alive connections are reusable.
They prevent having to re-establish a connection, as well as SSL negotiation.
They reduce latency time for all pages made up of several resources.</p>

<p>Web servers often activate them by default.
You can verify the presence of the following header <code>Keep-Alive timeout=5, max=100</code>.
In this example, the connection is closed after 5 seconds of inactivity and can be reused 100 times.</p>

<h2>Ruby</h2>

<h3>Run in the background as much as possible</h3>

<p>Any heavy or latency-intensive task should be run in the background as far as possible.
Sending e-mails is a case in point.</p>

<p>As well as reducing response time, it frees up a web process or thread to handle the subsequent request.
So the application can handle a larger volume.
It will also be less vulnerable to a denial-of-service attack.</p>

<h3>Know count, size, and length to save on SQL queries</h3>

<p>It’s important to know the differences between these three methods to ensure you’re triggering the fewest or most optimized SQL queries possible.</p>

<p>The <code>count</code> method always triggers a <code>SELECT count(*) FROM table</code> query.
The <code>length</code> method ensures that the relationship has been loaded to count in memory.
The <code>size</code> method adapts to the loading of the relationship.
Either it triggers a query if it hasn’t been loaded, or it counts in memory if it has already been loaded.
Here’s a summary table:</p>

<table><thead>
<tr>
<th></th>
<th>Records loaded</th>
<th>Record not loaded</th>
</tr>
</thead><tbody>
<tr>
<td>count</td>
<td>SELECT count(*) FROM table</td>
<td>SELECT count(*) FROM table</td>
</tr>
<tr>
<td>size</td>
<td>Count in memory</td>
<td>SELECT count(*) FROM table</td>
</tr>
<tr>
<td>length</td>
<td>Count in memory</td>
<td>SELECT * FROM table</td>
</tr>
</tbody></table>

<p>When counting and enumerating, it’s important to call <code>size</code> after the relationship has been loaded.
In all cases, the aim is to trigger a single request.</p>

<pre><code># Bad 2 queries instead of 1
users = User.all
users.size # SELECT COUNT(*) FROM &#34;users&#34;
users.each { } # SELECT &#34;users&#34;.* FROM &#34;users&#34;

# Good
users = User.all
users.length # SELECT &#34;users&#34;.* FROM &#34;users&#34;
users.each { } # No queries

# Good
users = User.all
users.each { } # SELECT &#34;users&#34;.* FROM &#34;users&#34;
users.size # No queries

# Good
users = User.all.load # SELECT &#34;users&#34;.* FROM &#34;users&#34;
users.size # No queries
users.each { } # No queries

# Bad 2 queries instead of 1
users = User.all
users.each { } # SELECT &#34;users&#34;.* FROM &#34;users&#34;
users.count # SELECT COUNT(*) FROM &#34;users&#34;
</code></pre>

<h3>Know exists, any/empty, and present/blank to save on SQL queries</h3>

<p>As with <code>count</code>, <code>size</code>, and <code>length</code>, it’s important to know the subtleties of these methods to trigger the fewest and most efficient queries possible.</p>

<p>The <code>exists?</code> method always triggers a query. It is optimized because it stops as soon as it finds a line.
The <code>present?</code> and <code>blank?</code> methods make sure that the query has been executed before checking for their presence or absence in memory.
Finally, the <code>any?</code> and <code>empty?</code> methods adapt if the relationship has already been loaded.
Here’s a summary table:</p>

<table><thead>
<tr>
<th></th>
<th>Loaded</th>
<th>Not loaded</th>
</tr>
</thead><tbody>
<tr>
<td>exists?</td>
<td>SELECT 1 FROM table LIMIT 1</td>
<td>SELECT 1 FROM table LIMIT 1</td>
</tr>
<tr>
<td>any?/empty?</td>
<td>In memory</td>
<td>SELECT 1 FROM table LIMIT 1</td>
</tr>
<tr>
<td>present?/blank?</td>
<td>In memory</td>
<td>SELECT * FROM table</td>
</tr>
</tbody></table>

<p>In this way, we can deduce good and bad uses when we condition a display according to the presence of recordings.</p>

<pre><code># Bad 2 queries instead of 1
users = Users.all
if users.exists? # SELECT 1 FROM users LIMIT 1
  users.each { } # SELECT * FROM users
end

# Good
users = Users.all
if users.present? # SELECT * FROM users
  users.each { } # No queries
end

# Bad 2 queries instead of 1
users = Users.all
if users.any? # SELECT 1 FROM users LIMIT 1
  users.each { } # SELECT * FROM users
end

# Good
users = Users.all.load # SELECT * FROM users
if users.any? # No queries
  users.each { } # No queries
end
</code></pre>

<h3>Use pluck instead of loading ActiveRecord instances when possible</h3>

<p>Pluck allows you to retrieve the raw result of an SQL query and thus avoid creating ActiveRecord instances.
Since there are fewer things to do, it’s inevitably faster and less memory-hungry.
On the other hand, you no longer benefit from the full functionality of an ActiveRecord model.
So it’s a good idea to use it when you don’t need your model’s methods.
We’re thinking in particular of a CSV or text export of several thousand lines.</p>

<pre><code># Slow
CSV.generate do |csv|
  User.all.each { |user| csv &lt;&lt; [user.id, user.name, user.email] }
end

# Fast
CSV.generate do |csv|
  User.pluck(:id, :name, :email).each { |row| csv &lt;&lt; row }
end
</code></pre>

<p>When you need to retrieve a large number of records, try to find a solution with <code>pluck</code>.</p>

<h3>Use symbols or frozen string literals</h3>

<p>By default, Ruby creates a new instance for any string literal, but not for symbols.</p>

<pre><code>&#34;Ruby&#34;.object_id #=&gt; 60
&#34;Ruby&#34;.object_id #=&gt; 80
&#34;Ruby&#34;.object_id #=&gt; 100

:ruby.object_id # =&gt; 710748
:ruby.object_id # =&gt; 710748
:ruby.object_id # =&gt; 710748
</code></pre>

<p>The same chain has been created three times, which is wasteful when the symbol has been reused.
So symbols are more efficient.
A comment at the beginning of each file tells Ruby to freeze and reuse literal strings.</p>

<pre><code># frozen_string_literal: true
&#34;Ruby&#34;.object_id #=&gt; 60
&#34;Ruby&#34;.object_id #=&gt; 60
&#34;Ruby&#34;.object_id #=&gt; 60

:ruby.object_id # =&gt; 710748
:ruby.object_id # =&gt; 710748
:ruby.object_id # =&gt; 710748
</code></pre>

<p>However, the string can no longer be modified, as it has been frozen.
Passing a frozen string to a method you don’t control may result in a FrozenError exception.
You’ll need to duplicate it explicitly.</p>

<pre><code># frozen_string_literal: true
&#34;Ruby&#34;.concat(&#34; on Rails&#34;) # FrozenError: can&#39;t modify frozen String
&#34;Ruby&#34;.dup.concat(&#34; on Rails&#34;) # =&gt; &#34;Ruby on Rails&#34;
</code></pre>

<h3>Store function results in local variables if needed more than once</h3>

<p>Even if this sounds obvious, it’s not uncommon to read about this kind of code.</p>

<pre><code># Bad
if object.expensive_compute
  puts object.expensive_compute
end

# Good
if result = object.expensive_compute
  puts result
end
</code></pre>

<p>Even with relatively quick methods, it’s a shame to repeat them.</p>

<pre><code># Bad
puts array.first.method1
puts array.first.method2
puts array.first.method3

# Good
object = array.first
puts object.method1
puts object.method2
puts object.method3
</code></pre>

<p>This doesn’t make the code more complicated, and sometimes simplifies it a little.</p>

<h3>Reuse HTTP connections</h3>

<p>For the reasons explained in the <em>Enable keep-alive connections</em> section,
it’s more efficient to reuse the same HTTP connection to execute multiple requests.
Each time, you save the time needed to establish the connection, as well as the SSL negotiation.
This is a significant saving.</p>

<pre><code># Slow, create 5 connections
Net::HTTP.get(url)
Net::HTTP.get(url)
Net::HTTP.get(url)
Net::HTTP.get(url)
Net::HTTP.get(url)

# Fast, by re-using the same connection 5 times
Net::HTTP.start(url.host) do |http|
  http.get(url.path)
  http.get(url.path)
  http.get(url.path)
  http.get(url.path)
  http.get(url.path)
end

# Fast, but without a block
http = Net::HTTP.new(url.host, url.port)
http.start
http.get(url.path)
http.get(url.path)
http.get(url.path)
http.get(url.path)
http.get(url.path)
http.finish
</code></pre>

<p>The easiest way is to make all requests in a block passed to <code>Net::HTTP.start</code>, as you won’t forget to close the connection.
If you can’t group all your requests in one block, you can always start and end them manually.</p>

<h2>Database</h2>

<h3>Tune your Database settings</h3>

<p>By default, most databases are not optimally configured for your use and your server’s capabilities.
If you manage your own database, it’s crucial to do so.</p>

<p>Fortunately, there are tools available to help you do just that.
For PostgreSQL, we recommend <a href="https://pgtune.leopard.in.ua">PGTune</a>.
For MySQL, there is MySQLTunner, but we have yet to gain experience with it.</p>

<p>By giving the amount of RAM and number of CPUs, PGTune gives you the best settings for your server. It’s effortless to do.</p>

<p>We like to store those settings into a dedicated file such as <code>/etc/postgresql/16/main/conf.d/pgtune.conf</code>.
If we have to change it in the future, we just need to replace the whole file.
It’s easier for the maintenance.</p>

<p>For SQLite, there are good default since Rails 7.1.
Otherwise you can set those parameters yourself:</p>

<pre><code>PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;
PRAGMA journal_size_limit = 67108864; -- 64 megabytes
PRAGMA mmap_size = 134217728; -- 128 megabytes
PRAGMA cache_size = 2000;
PRAGMA busy_timeout = 5000;
-- Source: Stephen Margheim
-- https://fractaledmind.github.io/2023/09/21/enhancing-rails-sqlite-performance-metrics
</code></pre>

<h3>SQL will always be faster than your code</h3>

<p>If a task can be performed by the database or your code, let the database take care of it.
It’s faster because all the work is done where the data is.
This means less bandwidth consumption and less latency.
Moreover, your code is unlikely to be better than the database.</p>

<pre><code>  Invoice.pluck(:amount).sum # Slower
  Invoice.sum(:amount) # Faster
</code></pre>

<h3>Index all foreign keys</h3>

<p>The odds for a foreign key to appear in a where clause are very high.
If it’s not the case, probably that the foreign key is useless.
So it’s a no brainer decision to create an index when adding a foreign key.</p>

<p>The disadvantage of indexes is that they slow down table writes.
But very often, the number of reads far exceeds the number of writes.
On the other hand, if your index is never used, it should be deleted.
This information is available in PostgreSQL’s internal tables.
It’s a bit confusing to get into.
Fortunately, tools such as <a href="https://github.com/ankane/pghero">PgHero</a> make it very easy.</p>

<p>So, by default, add an index to each foreign key, then delete the few that are never used.</p>

<h3>Exclude nulls from indexes</h3>

<p>A database index is a B-tree structure.
It is very efficient when data has a high cardinality.
However, when a column allows nulls, it often becomes the most redundant value.
The index is less efficient and takes up more space.
Unless null is an infrequently repeated value, there are only disadvantages to indexing them.</p>

<pre><code>add_index :table, :column, where: &#34;(column IS NOT NULL)&#34;
</code></pre>

<p>Or in pure SQL :</p>

<pre><code>CREATE INDEX name ON table (column) WHERE column IS NOT NULL;
</code></pre>

<h3>Do not index column with a low cardinality such as boolean</h3>

<p>The reason is the same as in the previous paragraph.
B-tree indexes work best when cardinality is high.
So a Boolean is the worst column you can index.
So don’t index booleans.</p>

<p>As with other types, if you have very repetitive values that are not significant from a business point of view, it’s probably a good idea to exclude them from the index.
We’re thinking in particular of default values:</p>

<pre><code>add_column :accounts, :balance, default: 0, null: false
add_index :accouns, :balance, where: &#34;(balance != 0)&#34;
</code></pre>

<p>Or in pure SQL:</p>

<pre><code>ALTER TABLE accounts ADD COLUMN balance decimal DEFAULT 0 NOT NULL;
CREATE INDEX index_accounts_balance ON accounts (balance) WHERE balance != 0;
</code></pre>

<h2>Conclusion</h2>

<p>These rules are by no means exhaustive.
Feel free to share your own.</p>

    </div></div>
  </body>
</html>
