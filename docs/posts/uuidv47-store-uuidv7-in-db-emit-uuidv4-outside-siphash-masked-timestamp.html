<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/stateless-me/uuidv47">Original</a>
    <h1>UUIDv47: Store UUIDv7 in DB, emit UUIDv4 outside (SipHash-masked timestamp)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">uuidv47 lets you store sortable UUIDv7 in your database while emitting a
UUIDv4-looking façade at your API boundary. It does this by XOR-masking
only the UUIDv7 timestamp field with a keyed SipHash-2-4 stream tied to
the UUID’s own random bits.</p>
<ul dir="auto">
<li>Header-only C (C89) · zero deps</li>
<li>Deterministic, invertible mapping (exact round-trip)</li>
<li>RFC-compatible version/variant bits (v7 in DB, v4 on the wire)</li>
<li>Key-recovery resistant (SipHash-2-4, 128-bit key)</li>
<li>Full tests provided</li>
</ul>
<hr/>

<ul dir="auto">
<li>Why</li>
<li>Quick start</li>
<li>Public API</li>
<li>Specification
<ul dir="auto">
<li>UUIDv7 bit layout</li>
<li>Façade mapping (v7 ↔ v4)</li>
<li>SipHash message derived from random</li>
<li>Invertibility</li>
<li>Collision analysis</li>
</ul>
</li>
<li>Security model</li>
<li>Build, test, coverage</li>
<li>Integration tips</li>
<li>Performance notes</li>
<li>FAQ</li>
<li>License</li>
</ul>
<hr/>

<ul dir="auto">
<li>DB-friendly: UUIDv7 is time-ordered → better index locality &amp; pagination.</li>
<li>Externally neutral: The façade hides timing patterns and looks like v4 to clients/systems.</li>
<li>Secret safety: Uses a PRF (SipHash-2-4). Non-crypto hashes are not suitable when the key must not leak.</li>
</ul>
<hr/>

<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &#34;uuidv47.h&#34;

int main(void){
  const char* s = &#34;00000000-0000-7000-8000-000000000000&#34;;
  uuid128_t v7;
  if (!uuid_parse(s, &amp;v7)) return 1;
  uuidv47_key_t key = { .k0 = 0x0123456789abcdefULL, .k1 = 0xfedcba9876543210ULL };
  uuid128_t facade = uuidv47_encode_v4facade(v7, key);
  uuid128_t back = uuidv47_decode_v4facade(facade, key);

  char a[37], b[37], c[37];
  uuid_format(&amp;v7, a);
  uuid_format(&amp;facade, b);
  uuid_format(&amp;back, c);
  printf(&#34;v7 (DB) : %s\n&#34;, a);
  printf(&#34;v4 (API): %s\n&#34;, b);
  printf(&#34;back    : %s\n&#34;, c);
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&#34;uuidv47.h&#34;</span>

<span>int</span> <span>main</span>(<span>void</span>){
  <span>const</span> <span>char</span><span>*</span> <span>s</span> <span>=</span> <span>&#34;00000000-0000-7000-8000-000000000000&#34;</span>;
  <span>uuid128_t</span> <span>v7</span>;
  <span>if</span> (!<span>uuid_parse</span>(<span>s</span>, <span>&amp;</span><span>v7</span>)) <span>return</span> <span>1</span>;
  <span>uuidv47_key_t</span> <span>key</span> <span>=</span> { .<span>k0</span> <span>=</span> <span>0x0123456789abcdefULL</span>, .<span>k1</span> <span>=</span> <span>0xfedcba9876543210ULL</span> };
  <span>uuid128_t</span> <span>facade</span> <span>=</span> <span>uuidv47_encode_v4facade</span>(<span>v7</span>, <span>key</span>);
  <span>uuid128_t</span> <span>back</span> <span>=</span> <span>uuidv47_decode_v4facade</span>(<span>facade</span>, <span>key</span>);

  <span>char</span> <span>a</span>[<span>37</span>], <span>b</span>[<span>37</span>], <span>c</span>[<span>37</span>];
  <span>uuid_format</span>(<span>&amp;</span><span>v7</span>, <span>a</span>);
  <span>uuid_format</span>(<span>&amp;</span><span>facade</span>, <span>b</span>);
  <span>uuid_format</span>(<span>&amp;</span><span>back</span>, <span>c</span>);
  <span>printf</span>(<span>&#34;v7 (DB) : %s\n&#34;</span>, <span>a</span>);
  <span>printf</span>(<span>&#34;v4 (API): %s\n&#34;</span>, <span>b</span>);
  <span>printf</span>(<span>&#34;back    : %s\n&#34;</span>, <span>c</span>);
}</pre></div>
<p dir="auto">Build &amp; run with the provided Makefile:
make test
make coverage
sudo make install</p>
<hr/>

<div dir="auto" data-snippet-clipboard-copy-content="typedef struct { uint8_t  b[16]; } uuid128_t;
typedef struct { uint64_t k0, k1; } uuidv47_key_t;

uuid128_t uuidv47_encode_v4facade(uuid128_t v7, uuidv47_key_t key);
uuid128_t uuidv47_decode_v4facade(uuid128_t v4_facade, uuidv47_key_t key);
int  uuid_version(const uuid128_t* u);
void set_version(uuid128_t* u, int ver);
void set_variant_rfc4122(uuid128_t* u);
bool uuid_parse (const char* str, uuid128_t* out);
void uuid_format(const uuid128_t* u, char out[37]);"><pre><span>typedef</span> <span>struct</span> { <span>uint8_t</span>  <span>b</span>[<span>16</span>]; } <span>uuid128_t</span>;
<span>typedef</span> <span>struct</span> { <span>uint64_t</span> <span>k0</span>, <span>k1</span>; } <span>uuidv47_key_t</span>;

<span>uuid128_t</span> <span>uuidv47_encode_v4facade</span>(<span>uuid128_t</span> <span>v7</span>, <span>uuidv47_key_t</span> <span>key</span>);
<span>uuid128_t</span> <span>uuidv47_decode_v4facade</span>(<span>uuid128_t</span> <span>v4_facade</span>, <span>uuidv47_key_t</span> <span>key</span>);
<span>int</span>  <span>uuid_version</span>(<span>const</span> <span>uuid128_t</span><span>*</span> <span>u</span>);
<span>void</span> <span>set_version</span>(<span>uuid128_t</span><span>*</span> <span>u</span>, <span>int</span> <span>ver</span>);
<span>void</span> <span>set_variant_rfc4122</span>(<span>uuid128_t</span><span>*</span> <span>u</span>);
<span>bool</span> <span>uuid_parse</span> (<span>const</span> <span>char</span><span>*</span> <span>str</span>, <span>uuid128_t</span><span>*</span> <span>out</span>);
<span>void</span> <span>uuid_format</span>(<span>const</span> <span>uuid128_t</span><span>*</span> <span>u</span>, <span>char</span> <span>out</span>[<span>37</span>]);</pre></div>
<hr/>

<p dir="auto">UUIDv7 bit layout:</p>
<ul dir="auto">
<li>ts_ms_be: 48-bit big-endian timestamp</li>
<li>ver:      high nibble of byte 6 = 0x7 (v7) or 0x4 (façade)</li>
<li>rand_a:   12 random bits</li>
<li>var:      RFC variant (0b10)</li>
<li>rand_b:   62 random bits</li>
</ul>
<p dir="auto">Façade mapping:</p>
<ul dir="auto">
<li>Encode: ts48 ^ mask48(R), set version=4</li>
<li>Decode: encTS ^ mask48(R), set version=7</li>
<li>Random bits unchanged</li>
</ul>
<p dir="auto">SipHash input: 10 bytes from random field:
msg[0] = (byte6 &amp; 0x0F)
msg[1] = byte7
msg[2] = (byte8 &amp; 0x3F)
msg[3..9] = bytes9..15</p>
<p dir="auto">Invertibility: XOR mask is reversible with known key.</p>
<p dir="auto">Collision analysis: Injective mapping. Only risk is duplicate randoms per ms.</p>
<hr/>

<ul dir="auto">
<li>Goal: Secret key unrecoverable even with chosen inputs.</li>
<li>Achieved: SipHash-2-4 is a keyed PRF.</li>
<li>Keys: 128-bit. Derive via HKDF.</li>
<li>Rotation: store small key ID outside UUID.</li>
</ul>
<hr/>

<div data-snippet-clipboard-copy-content="make test
make coverage
make debug
sudo make install"><pre><code>make test
make coverage
make debug
sudo make install
</code></pre></div>
<hr/>

<ul dir="auto">
<li>Do encode/decode at API boundary.</li>
<li>For Postgres, write tiny C extension.</li>
<li>For sharding, hash v4 façade with xxh3 or SipHash.</li>
</ul>
<hr/>

<p dir="auto">SipHash-2-4 on 10-byte message is extremely fast. No allocations.</p>
<hr/>

<p dir="auto">Q: Why not xxHash with a secret?
A: Not a PRF; secret can leak. Use SipHash.</p>
<p dir="auto">Q: Is façade indistinguishable from v4?
A: Yes, variable bits uniform, version/variant set to v4.</p>
<hr/>

<p dir="auto">MIT, Copyright (c) 2025 Stateless Limited</p>
</article></div></div>
  </body>
</html>
