<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.influxdata.com/blog/mqtt-vs-kafka-iot-advocates-perspective-part-1/">Original</a>
    <h1>MQTT vs. Kafka: An IoT Advocate&#39;s Perspective</h1>
    
    <div id="readability-page-1" class="page"><div>
<section>


<p>With the Kafka Summit fast approaching, I thought it was time to get my hands dirty and see what it’s all about. As an advocate for IoT, I heard about Kafka but was too embedded in protocols like <a href="https://www.influxdata.com/mqtt/">MQTT</a> to investigate further. For the uninitiated (like me) both protocols seem extremely similar if not almost competing. However, I have learned this is far from the case and actually, in many cases, they complement one another.</p>
<p>In this blog series, I hope to summarize what Kafka and MQTT are and how they can both fit into an IoT architecture. To help explain some of the concepts, I thought it would be practical to use a past scenario:</p>
<p><img src="https://w2.influxdata.com/wp-content/uploads/monitoring-emergency-fuel-generators.jpg" alt="monitoring-emergency fuel generators" width="1000" height="523"/></p>
<p>In the <a href="https://www.influxdata.com/blog/influxdb-geodata-emergency-generators/">previous blog</a>, we discussed a scenario where we wanted to monitor emergency fuel generators. We created a simulator with the InfluxDB Python Client library to send generator data to InfluxDB Cloud. For this blog, I decided to reuse that simulator but replace the client library with an MQTT publisher and Kafka producer to understand the core mechanics behind each.</p>
<p>You can find the code for this demo <a href="https://github.com/InfluxCommunity/kafka_mqtt_tutorial">here</a>.</p>
<h2>Understanding the basics</h2>
<p>So what is Kafka? Kafka is described as an event streaming platform. It conforms to a publisher-subscriber architecture with the added benefit of data persistence (to understand more of the fundamentals, check out this <a href="https://www.influxdata.com/blog/influxdb-and-kafka-how-companies-are-integrating-the-two/">blog</a>). Kafka also promotes some pretty great benefits within the IoT sector:</p>
<ul>
<li>High throughput</li>
<li>High availability</li>
<li>Connectors to well-known third-party platforms</li>
</ul>
<p>So why would I not just build my entire IoT platform using Kafka? Well, it boils down to a few key issues:</p>
<ol>
<li>Kafka is built for stable networks which deploy a good infrastructure</li>
<li>It does not deploy key data delivery features such as Keep-Alive and Last Will</li>
</ol>
<p>Having said this, let’s go ahead and compare implementations of writing a basic Kafka producer and compare it to an MQTT publisher within the context of the Emergency generator demo:</p>
<p><img src="https://w2.influxdata.com/wp-content/uploads/demo.png" alt="demo" width="1000" height="830"/></p>
<p><em><strong>Assumptions:</strong> For the purposes of this demo, I will be making use of the Mosquitto MQTT Broker and the Confluent platform (Kafka). We will not cover the initial creation/setup here, but you can consult these instructions accordingly:</em></p>
<ol>
<li><a href="https://mosquitto.org/download/"><em>Mosquito Broker</em></a><em> </em></li>
<li><em><a href="https://docs.confluent.io/platform/current/quickstart/ce-docker-quickstart.html">Confluent</a> (I highly recommend using the free trial of Confluent Cloud to sense check if Kafka is right for you before bogging yourself down in an on-prem setup)</em></li>
</ol>
<h3>Initialization</h3>
<p>Let’s start with the initialization of our MQTT publisher and Kafka producer:</p>
<h4>MQTT</h4>
<p>The minimum requirements for an MQTT Publisher (omitting security) are as follows:</p>
<ol>
<li>Host: The address / IP of the platform hosting the Mosquitto server</li>
<li>Port: Which port will the MQTT producer talk to. Usually 1883 for basic connectivity, 8883 TLS.</li>
<li>Keep Alive Interval: The amount of time in seconds allowed between communications.</li>
</ol>
<p><code>self.client.connect(host=self.mqttBroker,port=self.port, keepalive=MQTT_KEEPALIVE_INTERVAL)</code></p>
<h4>Kafka</h4>
<p>There was a little more background work when it came to Kafka. We had to establish connectivity to two different Kafka entities:</p>
<ol>
<li>Kafka cluster: This is a given we will be sending our payload here.</li>
<li>Schema registry: The registry lies outside the scope of the Kafka Cluster. It handles the storing and delivery of topic schemers. In other words, this forces producers to deliver data in a format that is expected by the Kafka consumer. More on this later.</li>
</ol>
<p>So let’s set up connectivity to both entities:</p>
<p><strong>Schema registry</strong></p>
<pre><code>schema_registry_conf = {&#39;url&#39;: &#39;https://psrc-8vyvr.eu-central-1.aws.confluent.cloud&#39;, 
                                &#39;basic.auth.user.info&#39;: &lt;USERNAME&gt;:&lt;PASSWORD&gt;&#39;}
     schema_registry_client = SchemaRegistryClient(schema_registry_conf)</code></pre>
<p>The breakdown:</p>
<ul>
<li>url: The address of your schema registry. Confluent supports the creation of registries for hosting.</li>
<li>authentication: Like any repository, it contains basic security to keep your schema designs secure.</li>
</ul>
<p><strong>Kafka cluster</strong></p>
<pre><code>self.json_serializer = JSONSerializer(self.schema_str, schema_registry_client, engine_to_dict)
    self.p = SerializingProducer({
        &#39;bootstrap.servers&#39;: &#39;pkc-41wq6.eu-west-2.aws.confluent.cloud:9092&#39;,
        &#39;sasl.mechanism&#39;: &#39;PLAIN&#39;,
        &#39;security.protocol&#39;: &#39;SASL_SSL&#39;,
        &#39;sasl.username&#39;: &#39;######&#39;,
        &#39;sasl.password&#39;: &#39;######&#39;,
        &#39;error_cb&#39;: error_cb,
        &#39;key.serializer&#39;: StringSerializer(&#39;utf_8&#39;),
        &#39;value.serializer&#39;: self.json_serializer
        })</code></pre>
<p>The breakdown:</p>
<ol>
<li>bootstrap.servers: In short, the address points to Confluent Cloud hosting our Kafka Cluster; more specifically, a Kafka broker. (Kafka also has the notation of brokers but on a per-topic basis). Bootstrap is a reference to the producer establishing its presence globally in the cluster.</li>
<li>sasl.*: Simple security authentication protocol; these are a minimum requirement for connecting to Confluent Kafka. I won&#39;t cover this here, as it is of no interest to our overall comparison.</li>
<li>error_cb: Handles Kafka error handling.</li>
<li>key_serializer: This describes how the message key will be stored within Kafka. Keys are an extremely important part of how Kafka handles payloads. More on this within the next blog.</li>
<li>Value.serializer: We will cover this next, in short, we must describe what type of data our producer will be sending. This is why defining our schema registry is very important.</li>
</ol>
<h3>Topics and delivery</h3>
<p>Now that we have initiated our MQTT publisher and Kafka producer, it’s time to send our Emergency generator data. To do this, both protocols require the establishment of a topic and data preparation before delivery:</p>
<h4>MQTT</h4>
<p>Within MQTT’s world, a topic is a UTF-8 string that establishes logical filtering between payloads.</p>
<table>
<tbody>
<tr>
<td><b>Topic Name</b></td>
<td><b>Payload</b></td>
</tr>
<tr>
<td>temperature</td>
<td>36</td>
</tr>
<tr>
<td>fuel</td>
<td>400</td>
</tr>
</tbody>
</table>
<p>In <a href="https://www.influxdata.com/blog/mqtt-vs-kafka-an-iot-advocates-perspective-part-2/">Part 2</a> of this series, we break down the capabilities and differences of MQTT and Kafka topics in further detail. For now, we are going to establish one topic to send all of our Emergency Generator data (this is not best practice but is logical in the complexity build-up of this project).</p>
<pre><code>message = json.dumps(data)
self.client.publish(topic=&#34;emergency_generator&#34;, message)</code></pre>
<p>MQTT has the benefit of being able to generate topics on demand during the delivery of a payload. If the topic already exists, the payload is simply sent to the established topic. If not, the topic is created. This makes our code relatively simple. We define our topic name and the JSON string we plan to send. MQTT payloads by default are extremely flexible, which has pros and cons. On the positive side, you do not need to define strict schema typing for your data. On the other hand, you rely on your subscribers being robust enough to handle the incoming messages which fall out of the norm.</p>
<h4>Kafka</h4>
<p>So I must admit, I came in with foolish optimism that sending a JSON payload via Kafka would be as simple as publish(). How wrong I was! Let’s walk through it:</p>
<pre><code>self.schema_str = &#34;&#34;&#34;{
            &#34;$schema&#34;: &#34;http://json-schema.org/draft-07/schema#&#34;,
            &#34;title&#34;: &#34;Generator&#34;,
            &#34;description&#34;: &#34;A fuel engines health data&#34;,
            &#34;type&#34;: &#34;object&#34;,
            &#34;properties&#34;: {
                &#34;generatorID&#34;: {
                &#34;description&#34;: &#34;UniqueID of generator&#34;,
                &#34;type&#34;: &#34;string&#34;
                },
                &#34;lat&#34;: {
                &#34;description&#34;: &#34;latitude&#34;,
                &#34;type&#34;: &#34;number&#34;
                },
                &#34;lon&#34;: {
                &#34;description&#34;: &#34;longitude&#34;,
                &#34;type&#34;: &#34;number&#34;
                },
                &#34;temperature&#34;: {
                &#34;description&#34;: &#34;temperature&#34;,
                &#34;type&#34;: &#34;number&#34;
                },
                &#34;pressure&#34;: {
                &#34;description&#34;: &#34;pressure&#34;,
                &#34;type&#34;: &#34;number&#34;
                },
                &#34;fuel&#34;: {
                &#34;description&#34;: &#34;fuel&#34;,
                &#34;type&#34;: &#34;number&#34;
                }
            },
            &#34;required&#34;: [ &#34;generatorID&#34;, &#34;lat&#34;, &#34;lon&#34;, &#34;temperature&#34;, &#34;pressure&#34;, &#34;fuel&#34; ]
            }&#34;&#34;&#34;

        schema_registry_conf = {&#39;url&#39;: &#39;https://psrc-8vyvr.eu-central-1.aws.confluent.cloud&#39;, 
                                &#39;basic.auth.user.info&#39;: environ.get(&#39;SCHEMEA_REGISTRY_LOGIN&#39;)}
        schema_registry_client = SchemaRegistryClient(schema_registry_conf)

        self.json_serializer = JSONSerializer(self.schema_str, schema_registry_client, engine_to_dict)

        self.p = SerializingProducer({
        &#39;bootstrap.servers&#39;: &#39;pkc-41wq6.eu-west-2.aws.confluent.cloud:9092&#39;,
        &#39;sasl.mechanism&#39;: &#39;PLAIN&#39;,
        &#39;security.protocol&#39;: &#39;SASL_SSL&#39;,
        &#39;sasl.username&#39;: environ.get(&#39;SASL_USERNAME&#39;),
        &#39;sasl.password&#39;: environ.get(&#39;SASL_PASSWORD&#39;),
        &#39;error_cb&#39;: error_cb,
        &#39;key.serializer&#39;: StringSerializer(&#39;utf_8&#39;),
        &#39;value.serializer&#39;: self.json_serializer
        })</code></pre>
<p>The first task on our list is to establish a JSON schema. The JSON schema describes the expected structure of our data. In our example, we define our generator meter readings (temperature, pressure, fuel) and also our metadata (generdatorID, lat, lon).  Note, within the definition, we define their data types and which data points are required to be sent with each payload.</p>
<p>We have already discussed connecting to our schema registry earlier. Next, we want to register our JSON schema with the registry and create a JSON serializer. To do this we need three parameters:</p>
<ol>
<li>schema_str: the schema design we discussed</li>
<li>schema _registry_client: Our object connecting to the registry</li>
<li>engine_to_dict: The JSON serializer which allows you to write a custom function for building out a Python dictionary struct which will be converted to JSON format.</li>
</ol>
<p>The json_serializer object is then included within the initialization of the Serializing Producer.</p>
<p>Finally to send data we call our producer object:</p>
<p><code>self.p.produce(topic=topic, key=str(uuid4()), value=data, on_delivery=delivery_report)</code></p>
<p>To send data to our Kafka cluster we:</p>
<ol>
<li>Define our topic name (Kafka by default requires the manual generation of topics. You can, via settings within the broker/cluster, allow auto-generation).</li>
<li>Create a unique key for our data, the data we wish to publish (this will be processed through our custom function and delivery report (a function defined to provide feedback on successful or unsuccessful delivery of the payload).</li>
</ol>
<p>My first impression of strongly typed / schemer-based design was: “Wow, this must leave system designers with a lot of code to maintain and a steep learning curve”. As I implemented the example, I realized you would probably avert a lot of future technical debt this way. Schemers force new producers/consumers to conform to the current intended data structure or generate a new schema version. This allows the current system to continue unimpeded by a rogue producer connecting to your Kafka cluster. I am going to cover this in more detail within <a href="https://www.influxdata.com/blog/mqtt-vs-kafka-an-iot-advocates-perspective-part-2/">Part 2</a> of this blog series.</p>
<h2>Prospective and conclusion</h2>
<p>So, what have we done? Well, in its most brutally simplistic form we have created a Kafka producer and MQTT publisher to transmit our generator data. At face value, it may seem Kafka seems vastly more complex in its setup than MQTT for the same result.</p>
<p>At this level, you would be correct. However, we have barely scraped the surface of what Kafka can do and how it should be deployed in a true IoT architecture. I plan to release two more blogs in this series:</p>
<ul>
<li><a href="https://www.influxdata.com/blog/mqtt-vs-kafka-an-iot-advocates-perspective-part-2/">Part 2</a>: I cover more of the features unique to Kafka, such as a deeper look into topics, scalability and third-party integrations (including InfluxDB).</li>
<li><a href="https://www.influxdata.com/blog/mqtt-vs-kafka-iot-advocates-perspective-part-3/">Part 3</a>: We take what we have learned and apply best practices to a real IoT project. We will use Kafka&#39;s MQTT proxy and delve deeper into third-party integrations to get the most out of your Kafka infrastructure.</li>
</ul>
<p>Until then check out the code, run it, play with it, and improve it. <a href="https://www.influxdata.com/blog/mqtt-vs-kafka-an-iot-advocates-perspective-part-2/">Next blog (Part 2 of this series)</a> we cover topics in more detail.</p>
</section>
</div></div>
  </body>
</html>
