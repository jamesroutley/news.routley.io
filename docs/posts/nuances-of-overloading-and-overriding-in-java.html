<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://software.rajivprab.com/2019/08/14/nuances-of-overloading-and-overriding-in-java/">Original</a>
    <h1>Nuances of overloading and overriding in Java</h1>
    
    <div id="readability-page-1" class="page"><div>
		<div>
<figure><a href="https://blog.hyperiondev.com/index.php/2019/01/25/heres-need-know-object-oriented-programming/" target="_blank" rel="noreferrer noopener"><img loading="lazy" data-attachment-id="231" data-permalink="https://software.rajivprab.com/oop/" data-orig-file="https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg" data-orig-size="1280,854" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;@jjfarquitectos&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="oop" data-image-description="" data-image-caption="" data-medium-file="https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg?w=300" data-large-file="https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg?w=1024" src="https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg" alt="" width="640" height="427" srcset="https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg?w=640&amp;h=427 640w, https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg?w=150&amp;h=100 150w, https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg?w=300&amp;h=200 300w, https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg?w=768&amp;h=512 768w, https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg?w=1024&amp;h=683 1024w, https://softwarerajivprab.files.wordpress.com/2019/08/oop.jpg 1280w" sizes="(max-width: 640px) 100vw, 640px"/></a></figure></div>


<p>I’ve been programming in Java for over half a decade, and thought I had mastered all aspects of overloading and overriding. It was only once I started thinking of and writing up the following edge cases, that I realized I didn’t know it nearly as well as I thought. </p>



<p>In an effort to gamify these nuances, I’ve listed them below as a series of puzzles. Kudos if you get them all without peeking at the answers.</p>



<h2>Single Dispatch</h2>



<p>Given the following classes:</p>


<div><pre title="">class Parent {
  void print(String a) { log.info(&#34;Parent - String&#34;); }
  void print(Object a) { log.info(&#34;Parent - Object&#34;); }
}

class Child extends Parent {
  void print(String a) { log.info(&#34;Child - String&#34;); }
  void print(Object a) { log.info(&#34;Child - Object&#34;); }
}
</pre></div>


<p>What will get printed below?</p>


<div><pre title="">String string = &#34;&#34;;
Object stringObject = string;

// What gets printed?
Child child = new Child();
child.print(string);
child.print(stringObject);

Parent parent = new Child();
parent.print(string);
parent.print(stringObject);
</pre></div>


<hr/>



<h3>Answer:</h3>


<div><pre title="">child.print(string);	    // Prints: &#34;Child - String&#34;
child.print(stringObject);  // Prints: &#34;Child - Object&#34;

parent.print(string);	    // Prints: &#34;Child - String&#34;
parent.print(stringObject); // Prints: &#34;Child - Object&#34;
</pre></div>


<p><code>child.print(string)</code> and <code>parent.print(string)</code> are textbook examples of Object-Oriented programming in Java. The method that gets invoked depends on the “actual” instance type, not the “declared” instance type. Ie, regardless of whether you define the variable as being a <code>Child</code> or <code>Parent</code>, because the actual instance type is <code>Child</code>, <code>Child::print</code> will be invoked.</p>



<p>The second set of prints are more tricky. <code>stringObject</code> and <code>string</code> are both the exact same string. The only difference is that <code>string</code> is declared to be a <code>String</code>, whereas <code>stringObject</code> is declared to be an <code>Object</code>. Java does not support <a rel="noreferrer noopener" aria-label="double-dispatch (opens in a new tab)" href="https://www.baeldung.com/ddd-double-dispatch" target="_blank">double-dispatch</a>, and hence, when dealing with method parameters, what matters is the “declared” type of the parameter, not its “actual” type. <code>print(Object)</code> will be invoked, even though the “actual” parameter type is <code>String</code></p>



<h2>Hidden Override</h2>



<p>Given the following:</p>


<div><pre title="">class Parent {
  void print(Object a) { log.info(&#34;Parent - Object&#34;); }
}

class Child extends Parent {
  void print(String a) { log.info(&#34;Child - String&#34;); }
}
</pre></div>


<p>What gets printed?</p>


<div><pre title="">String string = &#34;&#34;;
Parent parent = new Child();
parent.print(string);
</pre></div>


<hr/>



<h3>Answer:</h3>


<div><pre title="">parent.print(string);  // Prints: &#34;Parent - Object&#34;
</pre></div>


<p>The actual instance type is <code>Child</code>, and the declared argument type is <code>String</code>, and we do indeed have a method defined for <code>Child::print(String)</code>. In fact, that’s exactly what got picked in the previous example when calling <code>parent.print(string)</code>. However, that’s not the method that gets invoked here. </p>



<p>It appears that Java first picks which method to invoke, before checking for sub-class overrides. In this case, the declared instance type is Parent and the only matching method in <code>Parent</code> is <code>Parent::print(Object)</code>. When Java then checks for any potential overrides of <code>Parent::print(Object)</code>, it does not find any, so that’s the method which gets executed.</p>



<h2>Exposed Override</h2>



<p>Given the following:</p>


<div><pre title="">class Parent {
  void print(Object a) { log.info(&#34;Parent - Object!&#34;); }
  void print(String a) { throw new RuntimeException(); }
}

class Child extends Parent {
  void print(String a) { log.info(&#34;Child - String!&#34;); }
}
</pre></div>


<p>What gets printed?</p>


<div><pre title="">String string = &#34;&#34;;
Parent parent = new Child();
parent.print(string);
</pre></div>


<hr/>



<h3>Answer:</h3>


<div><pre title="">parent.print(string);  // Prints: &#34;Child - String!&#34;
</pre></div>


<p>The only difference between this and the earlier example, is that we have added a new <code>Parent::print(String)</code> method. This method never actually gets executed – it will throw an exception if it ever gets run! However, its mere presence causes Java to execute a different method.</p>



<p>Presumably what’s happening is that when evaluating <code>parent.print(String)</code>, the runtime now finds a matching <code>Parent::print(String)</code> method, and then sees that this method is overridden by <code>Child::print(String)</code>. </p>



<p>It’s tempting to think that simply adding a new method will never change system behavior if the new method never gets called. The above example shows otherwise.</p>



<h2>Ambiguous Parameter</h2>



<p>Given the following class:</p>


<div><pre title="">class Foo {
  void print(Cloneable a) { log.info(&#34;I am cloneable!&#34;); }
  void print(Map a) { log.info(&#34;I am Map!&#34;); }
}
</pre></div>


<p>What gets printed below?</p>


<div><pre title="">HashMap cloneableMap = new HashMap();
Cloneable cloneable = cloneableMap;
Map map = cloneableMap;

// What gets printed?
Foo foo = new Foo();
foo.print(map);
foo.print(cloneable);
foo.print(cloneableMap);
</pre></div>


<hr/>



<h3>Answer:</h3>


<div><pre title="">foo.print(map);           // Prints: &#34;I am Map!&#34;
foo.print(cloneable);	  // Prints: &#34;I am cloneable!&#34;
foo.print(cloneableMap);  // Does not compile
</pre></div>


<p>Similar to the single_dispatch example, what matters here is the declared type of the parameter, not the actual type. In addition, if there are multiple methods that are equally valid for a given parameter, Java throws a compile error and forces you to specify which one should be called.</p>



<h2>Multiple Inheritance – Interfaces</h2>



<p>Given the following:</p>


<div><pre title="">interface Father {
  default void print() { log.info(&#34;I am Father!&#34;); }
}

interface Mother {
  default void print() { log.info(&#34;I am Mother!&#34;); }
}

class Child implements Father, Mother {}
</pre></div>


<p>What gets printed below?</p>





<hr/>



<h3>Answer:</h3>



<p>Similar to the earlier example, this also does not compile. Specifically, the class definition itself for <code>Child</code> will fail to compile because there are conflicting default methods in <code>Father</code> and <code>Mother</code>. You need to update the <code>Child</code> class to specify the behavior for <code>Child::print</code>. <a rel="noreferrer noopener" aria-label="See here (opens in a new tab)" href="https://dzone.com/articles/dealing-with-diamond-problem-in-java" target="_blank">See here</a> for a more detailed explanation.</p>



<h2>Multiple Inheritance – Class and Interface</h2>



<p>Given the following:</p>


<div><pre title="">class ParentClass {
  void print() { log.info(&#34;I am a class!&#34;); }
}

interface ParentInterface {
  default void print() { log.info(&#34;I am an interface!&#34;); }
}

class Child extends ParentClass implements ParentInterface {}
</pre></div>


<p>What gets printed?</p>





<hr/>



<h3>Answer:</h3>


<div><pre title="">new Child().print();  // Prints: &#34;I am a class!&#34;
</pre></div>


<p>Explanation:  <a rel="noreferrer noopener" aria-label="the linked article (opens in a new tab)" href="https://dzone.com/articles/dealing-with-diamond-problem-in-java" target="_blank">The linked article</a> in the previous section actually covers this as well. If there’s an inheritance conflict between a class and an interface, the class wins.</p>



<h2>Transitive Override</h2>



<p>Given the following:</p>


<div><pre title="">class Parent {
  void print() { foo(); }
  void foo() { log.info(&#34;I am Parent!&#34;); }
}

class Child extends Parent {
  void foo() { log.info(&#34;I am Child!&#34;); }
}
</pre></div>


<p>What gets printed?</p>





<hr/>



<h3>Answer:</h3>


<div><pre title="">new Child().print();  // Prints: &#34;I am Child!&#34;
</pre></div>


<p>Overriding a method will take effect even for transitive calls. Someone reading the <code>Parent</code> class may think that <code>Parent::print</code> will always invoke <code>Parent::foo</code>. But if the method gets overridden, then <code>Parent::print</code> will invoke the overridden version of <code>foo()</code>.</p>



<h2>Private Override</h2>



<p>Given the following:</p>


<div><pre title="">class Parent {
  void print() { foo(); }
  private void foo() { log.info(&#34;I am Parent!&#34;); }
}

class Child extends Parent {
  void foo() { log.info(&#34;I am Child!&#34;); }
}
</pre></div>


<p>What gets printed?</p>





<hr/>



<h3>Answer:</h3>


<div><pre title="">new Child().print();  // Prints: &#34;I am Parent!&#34;
</pre></div>


<p>The setup is identical to the previous one, except for one difference. <code>Parent.foo()</code> is now declared to be private. Because of this, when <code>Parent.print()</code> invokes <code>foo()</code>, this is hard-coded to be <code>Parent.foo()</code>. Regardless of any other implementations of <code>foo()</code> that may exist in the child class, and regardless of the actual type of the instance that is invoking <code>print()</code>.</p>



<p>It is often assumed that changing a method from public to private, is a purely refactoring change, as long as compilation still succeeds. The above example shows that this is false – even if compilation succeeds, system behavior can change in dramatic ways. </p>



<p>Using the <code>@Override</code> annotation on all override methods will help greatly in preventing such regressions, by producing compile errors as soon as any base methods have their visibility changed.</p>



<h2>Static Overrides</h2>



<p>Given the following:</p>


<div><pre title="">class Parent {
  static void print() { log.info(&#34;I am Parent!&#34;); }
}

class Child extends Parent {
  static void print() { log.info(&#34;I am Child!&#34;); }
}
</pre></div>


<p>What gets printed?</p>


<div><pre title="">Child child = new Child();
Parent parent = child;

parent.print();
child.print();
</pre></div>


<hr/>



<h3>Answer:</h3>


<div><pre title="">parent.print();	// Prints: &#34;I am Parent!&#34;
child.print();	// Prints: &#34;I am Child!&#34;
</pre></div>


<p>Java does not allow for overriding static methods. If you have the same static method defined in both the parent and child classes, the actual type of the instance does not matter at all. Only the declared type is used to determine which of the two methods is invoked. </p>



<p>This is the exact opposite of what happens with non-static methods where the declared type is ignored in favor of the actual type. Hence why you need to be careful when changing a method from non-static to static or vice-versa. Even if there are no compile errors, system behavior could change dramatically.</p>



<p>This is another reason to mark all override methods with the <code>@Override</code> annotation. In the above case, you will get a compile error when adding the annotation to <code>Child::print</code>, telling you that the method cannot be overridden because it is static. </p>



<p>This is also why it is good practice to never invoke static methods using an instance of the class – it can lead to surprising behavior like the above, and fail to alert you when problematic refactoring changes are made. Many IDEs like Intellij will warn you when calling a static-method from a non-static context, and it is best to follow up on such warnings.</p>



<h2>Static Linking</h2>



<p>Given the following:</p>


<div><pre title="">class Parent {
  void print() { staticMethod(); instanceMethod(); }
  static void staticMethod() { log.info(&#34;Parent::staticMethod&#34;); }
  void instanceMethod() { log.info(&#34;Parent::instanceMethod&#34;); }
}

class Child extends Parent {
  static void staticMethod() { log.info(&#34;Child::staticMethod&#34;); }
  void instanceMethod() { log.info(&#34;Child::instanceMethod&#34;); }
}
</pre></div>


<p>What gets printed?</p>


<div><pre title="">Child child = new Child();
child.print();
</pre></div>


<hr/>



<h3>Answer:</h3>


<div><pre title="">Parent::staticMethod
Child::instanceMethod
</pre></div>


<p>This is a combination of some different concepts we covered earlier. For instance methods, the override takes effect, even when the caller is in the parent. However, for static methods, even when the variable’s declared type is <code>Child</code>, <code>Parent::staticMethod</code> is what gets invoked, because of the intermediary <code>print()</code> method.</p>



<h2>Wrapping up</h2>



<p>If there’s one take-away from all this, it is that inheritance is very very tricky, and easy to get wrong. If you try to be smart, it will bite you in the ass one day. Use very dumb guardrails and best practices to protect yourself:</p>



<ol>
<li>Always mark all override methods with the <a rel="noreferrer noopener" aria-label="@Override annotation (opens in a new tab)" href="https://stackoverflow.com/questions/94361/when-do-you-use-javas-override-annotation-and-why" target="_blank">@Override annotation</a></li>



<li><a rel="noreferrer noopener" aria-label="Always call static methods using a class reference (opens in a new tab)" href="https://www.oracle.com/technetwork/java/codeconventions-137265.html#587" target="_blank">Always call static methods using a class reference</a>, not an instance reference</li>



<li>Set up IDE alerts or lint errors to enforce the above and other code smells</li>



<li><a rel="noreferrer noopener" aria-label="Use composition over inheritance (opens in a new tab)" href="https://en.wikipedia.org/wiki/Composition_over_inheritance" target="_blank">Use composition over inheritance</a></li>
</ol>



<hr/>



<p><a rel="noreferrer noopener" aria-label="Discussion thread on /r/java (opens in a new tab)" href="https://www.reddit.com/r/java/comments/cq2i3b/nuances_of_overloading_and_overriding_in_java/" target="_blank"><em>Discussion thread on /r/java</em></a></p>



<p><a href="https://news.ycombinator.com/item?id=35989696" target="_blank" rel="noreferrer noopener"><em>Discussion thread on Hacker News</em></a></p>
	</div></div>
  </body>
</html>
