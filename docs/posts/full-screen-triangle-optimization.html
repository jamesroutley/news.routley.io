<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://30fps.net/pages/twotris/">Original</a>
    <h1>Full screen triangle optimization</h1>
    
    <div id="readability-page-1" class="page"><div id="text">

<p>So here’s a well-known optimization trick that also tells you a bit about how GPUs work.</p>
<p>Full screen post processing effects are usually drawn as a pair of two big triangles that cover the whole screen. A fragment shader then processes every pixel. But you can make it a tiny bit faster by drawing a single large triangle instead:</p>
<figure>
<img src="https://30fps.net/pages/twotris/clipspace.png" alt=""/><figcaption>That square represents the screen in clip space. The big triangle on the right covers to whole screen just like the two triangles on the left but has a less shading overhead. The z coordinate doesn’t matter but zero should work both in D3D and OpenGL.</figcaption>
</figure>
<p>Setting up the triangle is convenient to do directly in a vertex shader with no vertex buffer bound. Call <code>glDrawArrays(GL_TRIANGLES, 0, 3)</code> with this vertex shader:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span>void</span> <span>main</span>()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>{</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span>vec2</span> coords[] = {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span>vec2</span>(-<span>1.0</span>f, <span>-1.0</span>f),</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>        <span>vec2</span>(<span>3.0</span>f, <span>-1.0</span>f),</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span>vec2</span>(-<span>1.0</span>f, <span>3.0</span>f),</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    };</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span>gl_Position</span> = <span>vec4</span>(coords[<span>gl_VertexID</span>], <span>0.0</span>f, <span>1.</span>f);</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>There are three reasons why the single triangle approach is faster.</p>
<ul>
<li>The GPU executes fragment shaders in lockstep 2x2 pixels at a time in order to support automatic mip level selection. This ends up making your shader run twice on some pixels where the two triangles meet. This is mandated by the Direct3D and OpenGL specifications.</li>
<li>In actual hardware shading is done 32 or 64 pixels at a time, not four. The problem above just got worse.</li>
<li>Covering the full screen with a single triangle can make your shader’s memory access patterns linear. See the “case study” section in this <a href="https://gpuopen.com/unreal-engine-performance-guide/#casestudy">AMD performance tuning guide</a> for an example of this and the second point.</li>
</ul>
<p>In my microbenchmark<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> the single triangle approach was 0.2% faster than two. We are definitely deep into micro-optimization territory here :) I suppose if you read textures in your shader you’ll see larger gains like happened in the AMD case study linked above.</p>
<p>For more details on the mechanics of the automatic mip selection, see the section “Hardware Partial Derivatives” <a href="http://filmicworlds.com/blog/visibility-buffer-rendering-with-material-graphs/">in this 2021 article by John Hable</a>.</p>
<p>Of course you could use compute shaders here but you need to <a href="https://computergraphics.stackexchange.com/a/10036">make sure the memory access patterns</a> <a href="https://computergraphics.stackexchange.com/a/60">play well</a> with whatever format your textures (and the framebuffer?) are stored in. So it’s not an obvious win if you take code complexity into account.</p>
<p>Finally, if you still end up drawing two triangles, make sure you’re drawing a four vertex triangle strip and not a six vertex list. I’m not claiming there’s a speed difference – this is only for the nerd cred!</p>
<hr/>
<p>For more tricks like this in general, see <a href="https://archive.org/details/GDC2014Bilodeau">Bill Bilodeau’s 2014 GDC talk on the subject</a> (<a href="https://www.slideshare.net/DevCentralAMD/vertex-shader-tricks-bill-bilodeau">slides</a>).</p>
<p><em>Thanks to mankeli for feedback on a draft of post.</em></p>


</div></div>
  </body>
</html>
