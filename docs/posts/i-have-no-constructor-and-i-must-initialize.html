<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://consteval.ca/2024/07/03/initialization/">Original</a>
    <h1>I have no constructor, and I must initialize</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><em>It has been three days. The room is cold and dark, but your screens are blinding. You feel disoriented as you come in and out of dissociative episodes. Now and again, you laugh, to no accompaniment. Why are you here? Was this your fault?</em></p>

<p><em>Your first mistake was to engage—this much is clear.</em></p>

<hr/>

<p>Back when I took a first course in C++ a few years ago, I was taught that, under certain circumstances, the compiler would provide some kind of defaulted constructors in case we don’t provide our own. Curious to know more, my primary concern was with cases like this:</p>

<div><div><pre><code><span>struct</span> <span>T</span> <span>{</span> <span>/* ... */</span> <span>};</span>

<span>T</span> <span>t</span><span>;</span>
<span>T</span> <span>s</span><span>{};</span>
<span>T</span> <span>r</span><span>{</span><span>arg1</span><span>,</span> <span>arg2</span><span>,</span> <span>...};</span>
</code></pre></div></div>

<p>I became interested in the particulars of what this meant. Most of my focus fell on the first two—for the third, I felt satisfied with a hand-wavy explanation of “if <code>T</code> is simple enough, it’ll do component-wise initialization.” The first two are where the danger lies, after all: what if some objects are left uninitialized? The search looked something like what follows.</p>

<p>Primarily, there are two kinds of initialization of concern: <em>default-initialization</em> and <em>value-initialization</em>. The rules given in the standard look roughly like this:</p>
<ul>
  <li>For any type <code>T</code>, <code><span>T</span> <span>t</span><span>;</span></code> performs <em>default-initialization</em> on <code>t</code> as follows:
    <ul>
      <li>If <code>T</code> is a class type and there is a default constructor, run it.</li>
      <li>If <code>T</code> is an array type, default-initialize each element.</li>
      <li>Otherwise, do nothing.</li>
    </ul>
  </li>
  <li>For any type <code>T</code>, <code><span>T</span> <span>t</span><span>{};</span></code> performs <em>value-initialization</em> on <code>t</code> as follows:
    <ul>
      <li>If <code>T</code> is a class type…
        <ul>
          <li>If there is no default constructor (i.e., if the user has declared any non-default constructors) or if there is a user-provided or deleted default constructor, default-initialize.</li>
          <li>Otherwise, zero-initialize and then default-initialize.</li>
        </ul>
      </li>
      <li>Otherwise, if <code>T</code> is an array type, value-initialize each element.</li>
      <li>Otherwise, zero-initialize.</li>
    </ul>
  </li>
</ul>

<p>You can see each of these in action here:</p>
<div><div><pre><code><span>struct</span> <span>Pair</span> <span>{</span>
    <span>int</span> <span>x</span><span>,</span> <span>y</span><span>;</span>
    <span>Pair</span><span>()</span> <span>:</span> <span>x</span><span>{</span><span>0</span><span>},</span> <span>y</span><span>{</span><span>1</span><span>}</span> <span>{}</span>
<span>};</span>
<span>struct</span> <span>SimplePair</span> <span>{</span>
    <span>int</span> <span>x</span><span>,</span> <span>y</span><span>;</span>
<span>};</span>

<span>int</span> <span>x</span><span>{};</span> <span>// value-initialized =&gt; zero-initialized</span>
<span>int</span> <span>y</span><span>;</span> <span>// default-initialized (to garbage)</span>
<span>Pair</span> <span>p</span><span>;</span> <span>// default-initialized =&gt; default-constructed</span>
<span>Pair</span> <span>q</span><span>{};</span> <span>// value-initialized =&gt; default-initialized =&gt; default-constructed</span>
<span>SimplePair</span> <span>r</span><span>;</span> <span>// default-initialized =&gt; default-constructed to garbage (more on this later)</span>
</code></pre></div></div>

<p>This leaves for discussion the <em>default constructor</em>, i.e., the zero-argument constructor overload. What does the compiler provide us and when? It’s generally common knowledge that, so long as you don’t declare any of your own constructors, the compiler will declare and (possibly) provide its own. But, the devil’s in the details after all—and C++ has a <em>terrifying</em> quantity of details, which bears some implication on the exorcist’s nightmare contained therein.</p>

<a href="#the-default-constructor"></a>
<p>When you don’t declare any constructors, the compiler will declare a default constructor for you: this one is called <em>implicitly-declared</em>. There’s also the almost-identical “defaulted on first declaration” constructor—almost-identical in that they’re mostly interchangeable in the standard, it looks like this:</p>
<div><div><pre><code><span>struct</span> <span>T</span> <span>{</span>
    <span>T</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>These constructors don’t necessarily do anything by virtue of being implicitly-declared or defaulted on first declaration—after all, they’re only <em>declared</em> so far—but there are knock-on effects which <em>will</em> affect what they do. In particular, if a default constructor is implicitly declared or explicitly defaulted (and <em>not</em> defined as deleted), an <em>implicitly-defined default constructor</em> will be provided by the compiler. In terms of implementation, it’s guaranteed to be equivalent to a constructor with an empty body and empty member initializer list (i.e., <code><span>T</span><span>()</span> <span>{}</span></code>).</p>

<p>So, if we did something like this:</p>
<div><div><pre><code><span>struct</span> <span>T</span> <span>{</span>
    <span>int</span> <span>x</span><span>;</span>
    <span>T</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
<span>};</span>

<span>T</span> <span>t</span><span>{};</span>
<span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>t</span><span>.</span><span>x</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span>
</code></pre></div></div>

<p>The printed result would be <code>0</code>. This is because we <em>value-initialize</em> <code>t</code> and, since <code>T</code> has a non-user-provided default constructor, the object is zero-initialized (hence <code>t.x</code> is zero-initialized) then default-initialized (calling the implicitly-defined default constructor, which does nothing).</p>

<p>Naturally, we can also get an implicitly-defined default constructor outside the class as follows:</p>

<div><div><pre><code><span>struct</span> <span>T</span> <span>{</span>
    <span>T</span><span>();</span>
<span>};</span>
<span>T</span><span>::</span><span>T</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
</code></pre></div></div>

<p>Actually, let me augment this to look a little more like the last example:</p>
<div><div><pre><code><span>struct</span> <span>T</span> <span>{</span>
    <span>int</span> <span>x</span><span>;</span>
    <span>T</span><span>();</span>
<span>};</span>
<span>T</span><span>::</span><span>T</span><span>()</span> <span>=</span> <span>default</span><span>;</span>

<span>T</span> <span>t</span><span>{};</span>
<span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>t</span><span>.</span><span>x</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span>
</code></pre></div></div>

<p>You’d expect the printed result to be <code>0</code>, right? You poor thing. Alas—it will be garbage. Some things can never be perfect, it seems. Here’s a relevant excerpt from our description of value-initialization:</p>
<blockquote>
  <p>If there is no default constructor (i.e., if the user has declared any non-default constructors) or if there is a user-provided or deleted default constructor, default-initialize.</p>
</blockquote>

<p>A-ha. You see this line?</p>
<div><div><pre><code><span>T</span><span>::</span><span>T</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
</code></pre></div></div>

<p>That’s <em>user-provided</em>. By defining the constructor outside the class like this, we are not <em>first-declaring</em> it as defaulted; we are <strong><em>defining</em></strong> it as defaulted. <em>Providing</em> it, if you will. So, the compiler will rightfully opt to simply default-initialize <code>t</code>, hence running the explicitly-defaulted default constructor which does precisely <em>nothing</em>. Great.</p>

<p>Of course, in some situations, it’s impossible for the compiler to provide a sane default constructor—in such cases, it defines the implicitly-declared default constructor as <em>deleted</em>. Here are some of the situations that lead to this:</p>
<ul>
  <li><code>T</code> has a non-static reference member <em>(what would you reasonably default-initialize this to?)</em>;</li>
  <li><code>T</code> has non-static members or non-abstract base classes which aren’t reasonably default-constructable or destructable <em>(I’m omitting some details here, but you get the idea)</em>; or</li>
  <li><code>T</code> has any <code><span>const</span></code>, non-static, non-const-default-constructible members without default member initializers <em>(if the member is <code><span>const</span></code> and won’t get default-initialized to anything useful, our final object would necessarily permanently contain garbage)</em>.
    <ul>
      <li><em>Aside: for a class type, “const-default-constructible” means default-initialization will invoke a non-inherited user-provided constructor—the idea being that a <code><span>const</span></code> object of the type can be sanely initialized by default-initialization.</em></li>
    </ul>
  </li>
</ul>

<p>Remember that that’s all assuming you don’t provide any constructors yourself. If you do, the compiler won’t try to implicitly define a default constructor—not even as deleted. There would be <em>no default constructor at all</em> here.</p>

<p>I’m omitting some details here and eliding discussion of unions altogether, but these are the broad strokes. Basically, if your class has anything that can’t be default-initialized in an at-least-sort-of-potentially-useful way, the compiler will give up and define the implicitly-declared default constructor as deleted. This follows the (often unfortunate) guiding C++ philosophy of being <em>very permissive</em>.</p>

<p>Here’s an example that’s as simple as it gets: the presence of a <code><span>const</span> <span>int</span></code> member without a default member initializer (e.g., <code>= 0</code>) defines the implicitly-declared default constructor as deleted, so it won’t compile:</p>
<div><div><pre><code><span>struct</span> <span>A</span> <span>{</span>
    <span>const</span> <span>int</span> <span>x</span><span>;</span>
<span>};</span>

<span>A</span> <span>a</span><span>{};</span>
</code></pre></div></div>

<p>Well, that’s what you’d think if you hadn’t read carefully enough, anyway. As it turns out, this gnarly code is perfectly well-formed and <em>will</em> compile—indeed, <code>a.x</code> will be initialized <code>0</code>. Why? Because <code>A</code> is an aggregate. And, actually, <strong>that’s not value-initialization at all.</strong></p>

<a href="#initialization-done-right"></a>
<p>Alright, let’s get down to brass tacks. I lied to you. Well, only kind of—all the other examples I gave so far were carefully cooked so that the explanations I gave were still <em>technically</em> right—there was just <em>one</em> incorrect definition, and some <em>very</em> deliberate dancing around a <em>very</em> large elephant in the room.</p>

<p>In fact, when we write something like <code><span>T</span> <span>t</span><span>{};</span></code>, what’s <em>actually</em> being performed first-up is something called <strong><em>list-initialization</em></strong>. Indeed, anything that looks like <code><span>T</span> <span>t</span><span>{...}</span></code>, <code><span>T</span> <span>t</span> <span>=</span> <span>{...}</span></code>, or most any other curly-brace-decorated form of initialization, is probably list-initialization. The first two forms here are called <em>direct-list-initialization</em> and <em>copy-list-initialization</em> respectively. Copy-initialization, as a standalone thing, is about initializing an object from another object, usually involving an <code>=</code> in some way; direct-initialization, on the other hand, is about initializing an object from a set of constructor arguments. The practical difference is minimal beyond syntax, so we’ll mostly restrict our discussion to direct-list-initialization.</p>

<p>List-initialization is a bit of a complicated thing but, as it turns out, there’s actually <em>yet another</em> kind of initialization standing between it and the funny-looking <code><span>const</span></code> example that got us here. First, a definition:</p>

<dl>
  <dt>Definition</dt>
  <dd>An <strong>aggregate</strong> is either (1) an array or (2) a class which has
    <ul>
      <li>no user-declared or inherited constructors;</li>
      <li>no private or protected direct non-static data members;</li>
      <li>no private or protected direct base classes; and</li>
      <li>no virtual functions or virtual base classes.</li>
    </ul>
  </dd>
</dl>

<p>Basically, an aggregate is one kind of “simple” type that we can craft, sitting close behind trivial and standard-layout types. There’s a special kind of list-initialization which exists for aggregates called <em>aggregate initialization</em>. The particulars surrounding this get a little hairy <em>(read: uninteresting)</em> in the standard, but it suffices to say that it’s a souped-up way of copy-initializing each element of the class (or array) with each element of the initializer list, in order. If the number of elements given in the list is less than the number of elements in the aggregate, each remaining element of the aggregate will be initialized with its default member initializer (if it has one) or, assuming it’s not a reference, copy-initialized with an empty initializer list (as in, <code>= {}</code>; this will recursively lead to another round of list-initialization).</p>

<p>So, here’s the glue between list-initialization and aggregate initialization: if list-initialization is performed on an aggregate, <em>aggregate initialization</em> is performed <strong><em>unless</em></strong> the list has only one argument, of type <code>T</code> or of type derived from <code>T</code>, in which case it performs direct-initialization (or copy-initialization). Hence, with an example like this:</p>
<div><div><pre><code><span>struct</span> <span>S</span> <span>{</span>
    <span>int</span> <span>a</span><span>;</span>
    <span>float</span> <span>b</span><span>;</span>
    <span>char</span> <span>c</span><span>;</span>
<span>};</span>

<span>S</span> <span>s</span><span>{</span><span>3</span><span>,</span> <span>4.0</span><span>f</span><span>,</span> <span>&#39;S&#39;</span><span>};</span>
</code></pre></div></div>
<p>…there are no constructor calls to speak of.</p>

<p>Of course, that covers list-initialization for aggregates, but there are a few other cases left. Namely…</p>
<ul>
  <li>If <code>T</code> is a <em>non-aggregate</em> class type…
    <ul>
      <li>If the initializer is empty and <code>T</code> has a default constructor, then value-initialization is performed.</li>
      <li>Otherwise, consider other constructors according to the usual overload resolution procedure—note that <code>std::initializer_list</code> constructor overloads always get priority here.</li>
    </ul>
  </li>
  <li>When the initializer list contains exactly one element, non-class types and references are initialized more or less how you’d expect, so we won’t dwell on them.</li>
  <li>Finally, otherwise, if the initializer list is empty, value-initialization is performed.</li>
</ul>

<p>With that, I will correct the <em>subtly wrong</em> definition of value-initialization I gave earlier: for <strong>non-aggregate</strong> types <code>T</code>, <code><span>T</span> <span>t</span><span>{};</span></code> performs <em>value-initialization</em> (via list-initialization) on <code>t</code> as follows:</p>
<ul>
  <li>If <code>T</code> is a class type…
    <ul>
      <li>If there is no default constructor or if there is a user-provided or deleted default constructor, default-initialize.</li>
      <li>Otherwise, zero-initialize and then default-initialize.</li>
    </ul>
  </li>
  <li>Otherwise, if T is an array type, value-initialize each element.</li>
  <li>Otherwise, zero-initialize.</li>
</ul>

<p>The only addition is the word “non-aggregate.” There are a few wrinkles I’m leaving out (like unions), but they all behave <em>more or less</em> how you’d expect given all of this. Anyway, here’s that gnarly example from earlier again:</p>
<div><div><pre><code><span>struct</span> <span>A</span> <span>{</span>
    <span>const</span> <span>int</span> <span>x</span><span>;</span>
<span>};</span>

<span>A</span> <span>a</span><span>{};</span>
</code></pre></div></div>

<p><em>A sharp moment of clarity and understanding; the sensation that, if there is a god, it must have spoken to you. You are grateful either way.</em> Here, <code>A</code> is clearly an aggregate, and so list-initialization leads to aggregate initialization which leads to copy-list-initialization of <code>a.x</code> with an empty list, hence value initialization, hence zero initialization. No fuss, no muss. Constructors were never in question to begin with. While we’re feeling so high and mighty, we might even try this:</p>
<div><div><pre><code><span>A</span> <span>b</span><span>{</span><span>4</span><span>};</span>
</code></pre></div></div>

<p>This performs list-initialization, hence aggregate initialization, hence copy-initialization of <code>b.a</code> with <code>4</code>. <em>Yes!</em> We might even be so bold as to try this:</p>
<div><div><pre><code><span>A</span> <span>c</span><span>{</span><span>4.0</span><span>f</span><span>};</span>
<span>// error: narrowing conversion of &#39;4.0e+0f&#39; from &#39;float&#39; to &#39;int&#39; [-Wnarrowing]</span>
</code></pre></div></div>

<p>Fuck. OK, maybe we pushed our luck. I forgot to mention that list-initializing with one element doesn’t allow for narrowing conversions. It’s fine, though. It’s all fine. Here:</p>
<div><div><pre><code><span>A</span> <span>c</span><span>(</span><span>4.0</span><span>f</span><span>);</span> <span>// N.B. parentheses, not braces</span>
</code></pre></div></div>

<p>Under C++20, this compiles.</p>

<p>Cry.</p>

<a href="#lists-but-rounder"></a>
<p>You might recall from a first course in C++ that you can <em>kind of mostly</em> use parentheses in the place of braces for the purposes of initialization. Not <em>everywhere</em>, but, like, <em>mostwhere</em>. You were probably told to avoid it for reasons like the <em>most vexing parse</em>: while <code><span>T</span> <span>t</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>);</span></code> syntactically represents an invocation of some constructor <em>(not quite; we’ll discuss this later)</em>, <code><span>T</span> <span>t</span><span>();</span></code> syntactically represents a declaration of a function <code>t</code> which takes no parameters and has return type <code>T</code>. Here, you really need to either settle on <code><span>T</span> <span>t</span><span>{};</span></code> or <code><span>T</span> <span>t</span><span>;</span></code> instead. However, this <em>parenthesized expression-list</em> initializer is often <strong>functionally different</strong> from braced-init-list initializers. Parenthesized initializers invoke <em>direct-non-list-initialization</em>, which has rules that are <em>similar to</em> but <em>different from</em> direct-list-initialization.</p>

<p>Parenthesized initializers let us perform aggregate initialization on aggregates (both classes and arrays) in basically the same way as with list-initialization, but narrowing conversions are allowed, remaining elements are directly value-initialized (rather than empty-list-initialized), and temporaries bound to references do not have their lifetime extended. Did you catch that last one? Here’s the action replay:</p>
<div><div><pre><code><span>struct</span> <span>T</span> <span>{</span>
    <span>const</span> <span>int</span><span>&amp;</span> <span>r</span><span>;</span>
<span>};</span>

<span>T</span> <span>t</span><span>(</span><span>42</span><span>);</span>
</code></pre></div></div>

<p>That’s right: <code>t.r</code> is a dangling reference. Reading from it is undefined behaviour. What a world. I really can’t imagine why this would be desired behaviour for <em>any programmer ever</em>, but that’s just how things are sometimes.</p>

<p>In any case, parentheses are generally less “regulatory”; they’re often more permissive. Along with those allowances I just mentioned, it also lets us invoke the copy constructor for <code>T</code> in case there’s also a <code><span>std</span><span>::</span><span>initializer_list</span><span>&lt;</span><span>T</span><span>&gt;</span></code> constructor overload—recall that such overloads take priority in overload resolution, and a braced-init-list of <code>T</code>s can be interpreted as <code><span>std</span><span>::</span><span>initializer_list</span><span>&lt;</span><span>T</span><span>&gt;</span></code>.</p>
<div><div><pre><code><span>struct</span> <span>T</span> <span>{</span>
    <span>T</span><span>(</span><span>std</span><span>::</span><span>initializer_list</span><span>&lt;</span><span>T</span><span>&gt;</span><span>)</span> <span>{</span>
        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;list&#34;</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span>
    <span>}</span>
    <span>T</span><span>(</span><span>const</span> <span>T</span><span>&amp;</span><span>)</span> <span>{</span>
        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;copy&#34;</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span>
    <span>}</span>
<span>};</span>

<span>T</span> <span>t</span><span>{};</span> <span>// list</span>
<span>T</span> <span>s</span><span>{</span><span>t</span><span>}</span> <span>// list</span>
<span>T</span> <span>r</span><span>(</span><span>t</span><span>);</span> <span>// copy</span>
<span>T</span> <span>q</span><span>(</span><span>T</span><span>{});</span> <span>// list (no copy!)</span>
</code></pre></div></div>

<p>That last one might come as a surprise—according to what we’ve seen so far, we would expect the list constructor to be used for <code><span>T</span><span>{}</span></code>, followed by the copy constructor for <code><span>q</span><span>(</span><span>T</span><span>{})</span></code>. You may recall something called <em>copy elision</em>—this is essentially that. In particular, direct- and copy-initialization have provisions where, if the initializer is a prvalue of type <code>T</code>, the object gets initialized <em>directly</em> by the expression rather than the temporary materialized by it. This is never explicitly called “elision” by the standard—one might argue that it’s not even an appropriate name for it since C++17—but it’s probably what you know it as anyway.</p>

<p><em>An aside:</em> from what I can tell, for some reason, this <em>technically</em> only works if non-list-initialization is used, i.e, <code><span>T</span> <span>q</span><span>(</span><span>T</span><span>{});</span></code> but NOT <code><span>T</span> <span>q</span><span>{</span><span>T</span><span>{}};</span></code>. Like, there’s just nothing described in the standard about list-initialization that would allow for elision to take place. Both GCC and Clang ignore this and elide anyway in most cases, <em>except</em> if a <code>std::initializer_list&lt;T&gt;</code> constructor overload is defined (like above), in which case GCC uses it instead of eliding—I understand this to be a single corner case where GCC does the right thing. I expect this whole thing will be cleared up eventually—see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2311">CWG issue 2311</a>.</p>

<p>Anyway, for a parenthesized initializer, if this elision provision doesn’t apply, constructors are considered as you would expect; if there are none and <code>T</code> is an aggregate class, it’ll do per-element copy-initialization as discussed earlier.</p>

<p>One last nugget: elements of parenthesized initialization lists have no guaranteed evaluation order, whereas braced initialization lists evaluate elements strictly from left to right.</p>

<hr/>

<p>That should be most of it. I mean, there are special initialization rules for static variables (<em>constant initialization</em> included), but, like, <em>do you really care?</em> In my humble opinion, here’s the key takeaway: <em>just write your own fucking constructors!</em> You see all that nonsense? Almost completely avoidable if you had just written your own fucking constructors. Don’t let the compiler figure it out for you. <em>You’re</em> the one in control here. Or is it that you think you’re being <em>cute?</em> You just added six instances of undefined behaviour to your company’s codebase, and now twenty Russian hackers are fighting to pwn your app first. Are you stupid? <em>What’s the matter with you? What were you thinking?</em> God.</p>

<p>❦</p>

  </div></div>
  </body>
</html>
