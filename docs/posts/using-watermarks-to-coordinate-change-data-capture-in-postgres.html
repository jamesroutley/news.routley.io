<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sequinstream.com/using-watermarks-to-coordinate-change-data-capture-in-postgres/">Original</a>
    <h1>Using watermarks to coordinate change data capture in Postgres</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      <p>In change data capture, consistency is paramount. A single missing or duplicate message can cascade into time-consuming bugs and erode trust in your entire system. The moment you find a record missing in the destination, you have to wonder: is this the only one? How many others are there?</p><p>Sequin sends changes from Postgres to destinations like Kafka, SQS, and webhook endpoints in real-time. In addition to change data capture, we let you perform table state capture: you can have Sequin generate read messages for all the rows or a subset of rows from tables in your database. This lets you rematerialize all your Postgres data in your destination. Or recover from errors by replaying Postgres rows through your system.</p><p>Because Postgres does not keep its WAL around indefinitely, we can&#39;t use the WAL to do a full table state capture. The WAL is only a partial tail of recent changes in the database. It&#39;s intended to send the latest changes to replicas.</p><p>Instead, we can perform table state capture by reading from the table, such as running a <code>select</code>.</p><p>Performing table state capture at the same time as you&#39;re capturing changes, though, turns out to be quite nuanced. That&#39;s because the table you&#39;re capturing is constantly changing as you&#39;re capturing it.</p><p>To get an idea of the challenge, imagine an implementation where we run the change data capture process at the same time as the table state capture process. Let&#39;s call the change data capture process the SlotProcessor and the table state capture process the TableReader.</p><p>Let&#39;s say we have some row, A₀. (The &#34;0&#34; represents the version of row A.) Before TableReader starts, row A is updated a few times:</p><figure><img src="https://blog.sequinstream.com/content/images/2025/01/image-3-1.png" alt="" loading="lazy" width="500" height="199"/></figure><p>Then, you start TableReader. TableReader captures A2 (the current version of A) and inserts it into the outgoing message buffer. (The output buffer is the outbox between Sequin and sinks.) We say that TableReader has emitted a <code>read</code> message for A2:</p><figure><img src="https://blog.sequinstream.com/content/images/2025/01/image-7-1.png" alt="" loading="lazy" width="500" height="178"/></figure><p>While this happened, SlotProcessor had fallen behind. So, it first picks up the change message for <code>A0</code> to <code>A1</code>. Then the change message for <code>A1</code> to <code>A2</code>.</p><p>This leads to an unfortunate ordering of messages in our output buffer:</p><figure><img src="https://blog.sequinstream.com/content/images/2025/01/image-5-1.png" alt="" loading="lazy" width="500" height="178"/></figure><p>This is undesirable, and could lead to many downstream problems.</p><p>But an even worse race condition can occur: it&#39;s possible that when TableReader queries, it will see A1. Then A1 is modified, becoming A2. The SlotProcessor picks up the A1 to A2 transition <em>first</em>. Then TableReader&#39;s query makes it to the output buffer:</p><figure><img src="https://blog.sequinstream.com/content/images/2025/01/image-6-1.png" alt="" loading="lazy" width="500" height="178"/></figure><p>Now, unsuspecting downstream consumers will presume A1 is the final version of A – but it&#39;s not!</p><p>Row A is stale in your stream, and there&#39;s no hope of recovering it until it&#39;s updated again.</p><p>At a high level, what&#39;s happening is that we have two streams of data, the stream from the table and the stream from the replication slot. Both those streams correspond to the same, ever-changing source. And we have <strong>no coordination</strong> between those two streams.</p><p>In order to achieve consistency (i.e. a consistently-ordered output buffer), we need some coordination between these two streams.</p><p>Let&#39;s build up to a consistent strategy for running both capture processes in parallel. By examining each potential solution, we&#39;ll uncover the subtle pitfalls that led Sequin to adopt its coordination strategy.</p><h2 id="solution-a-serialize-capture-processes">Solution A: Serialize capture processes</h2><p>A simple solution is to not run change capture and table state capture at the same time:</p><ol><li>Create the replication slot. We do this before we capture the table. That way, SlotProcessor can accumulate changes that happen during the table capture.</li><li>Run TableReader&#39;s full capture process. TableReader can write directly to the output stream.</li><li>Once TableReader is done, we can apply the SlotProcessor&#39;s accumulated changes.</li></ol><p>This approach can work because we&#39;re only processing one stream of data at a time. That means we need to do little coordination between them.</p><p>There&#39;s a path to making this approach consistent. But the drawback of this approach is that it isn&#39;t very flexible. We have to stop change capture in order to capture the table, which might take some time.</p><p>In operational use cases (like streaming to Kafka or SQS), you might run table captures often. For example, you might realize you deployed a bug and a downstream system needs to have the last few hours of data replayed. You don&#39;t want to stall change processing during that replay, which this design requires.</p><h2 id="solution-b-pipe-table-capture-through-the-replication-slot">Solution B: Pipe table capture through the replication slot</h2><p>As a thought exercise, another solution is to run our table capture process <em>through</em> the WAL. By having everything funnel through the WAL, we&#39;ll get strict ordering guarantees. That&#39;s because by forcing table capture through the change capture stream, we only have one stream to process.</p><p>The most naive solution is to simply touch every row:</p><pre><code>update mytable set id = id;
</code></pre><p>Of course, this strategy has a lot of undesirable side effects, not the least of which is adding a ton of load to the database.</p><h2 id="solution-c-buffer-the-entire-table-capture-process">Solution C: Buffer the entire table capture process</h2><p>The purpose of the table capture process is to load all selected rows into the destination. It&#39;s worth noting that if a row happens to get modified during the table capture process, it&#39;s actually safe for TableReader to skip that row. We don&#39;t need to emit a <code>read</code> message for the row in the table capture process, as the change capture process will emit an <code>insert</code> or <code>update</code> message for it.</p><p>Given that, another consistent solution follows this process:</p><ol><li>Start the SlotProcessor.</li><li>Start the TableReader. Store all rows <em>in memory</em>.</li><li>While the TableReader is running, the SlotProcessor keeps track of all records that it has seen (by primary key).</li><li>When the TableReader finishes, it emits a WAL message:</li></ol><pre><code>SELECT pg_logical_emit_message(true, &#39;my-cdc&#39;, &#39;{&#34;backfill_id&#34;: 1, &#34;marker&#34;: &#34;end&#34;&#39;);
</code></pre><p><code>pg_logical_emit_message</code> is a neat function that lets you write a message directly to the WAL. This message is how we &#34;join&#34; the two streams. When the SlotProcessor sees this message, it can briefly halt WAL processing. Then, it can emit TableReader&#39;s buffer into the output stream. Importantly, it first filters out every row in the set whose primary key ever appeared in the WAL processor.</p><p>This approach is consistent: we no longer need to worry about how we order our read messages and change messages. However, it&#39;s suboptimal, as the TableReader&#39;s buffer would grow very large with a large table.</p><p>But this design reveals a path: we can use a strategy where TableReader builds up its rows in memory. And SlotProcessor can then filter that set and insert it into the output stream.</p><h2 id="solution-d-buffer-chunks-of-table-capture">Solution D: Buffer <em>chunks</em> of table capture</h2><p>Having TableReader build up all its rows in memory is suboptimal. But what if we chunked it? That tweak brings us close to Sequin&#39;s design.</p><p>A few years ago, Netflix <a href="https://arxiv.org/abs/2010.12597?ref=blog.sequinstream.com">released a whitepaper</a> on the design of their internal change data capture tool, DBLog. Sequin&#39;s table capture design is in part inspired by DBLog.</p><p>The TableReader process can build up smaller chunks of rows in memory. Then, SlotProcessor can filter them against recent changes that came through the WAL before inserting <code>read</code> messages into the output stream.</p><p>What that looks like at a high level:</p><ol><li>Run TableReader. It accumulates e.g. 100k rows in memory.</li><li>While TableReader is selecting its chunk, SlotProcessor is tracking which PKs have flowed through the logs.</li><li>When TableReader fills out its chunk, it emits a <code>chunk-end</code> message.</li><li>SlotProcessor sees the <code>chunk-end</code> message come through the slot. It can then fetch the chunk, filter it, and insert the chunk into the output stream.</li><li>After inserting the chunk, the SlotProcessor can flush all the primary keys it was holding in memory.</li></ol><p>This solution works great. But we&#39;re missing some coordination: when should the SlotProcessor start accumulating primary keys? We don&#39;t want it to indefinitely accumulate primary keys.</p><p>DBLog uses the watermark pattern here: TableReader can emit a <em>low</em> watermark before its first select query. That serves as a signal to SlotProcessor: &#34;I&#39;m about to run a select query to grab a chunk of rows. Start keeping track of which primary keys have come through the slot for later filtering.&#34;</p><p>The low watermark should include a table OID so that SlotProcessor only hangs on to primary keys for that table:</p><pre><code>SELECT pg_logical_emit_message(true, &#39;my-cdc:low-watermark&#39;, &#39;{&#34;backfill_id&#34;: 1, &#34;table_oid&#34;: 1234&#39;);
</code></pre><p>So, TableReader:</p><ol><li>Emits a chunk capture low watermark</li><li>Runs a select to buffer its chunk</li><li>Emits a chunk capture high watermark</li></ol><p>And SlotProcessor:</p><ol><li>Receives the low watermark. Now it knows to start accumulating primary keys for that table.</li><li>Processes the replication slot per usual.</li><li>Receives the high watermark. Now, it can retrieve TableReader&#39;s chunk, filter it by primary key, and emit messages to the output stream.</li></ol><p>After TableReader&#39;s chunk is written to the output stream, TableReader can flush its chunk and SlotProcessor can flush its primary keys.</p><h3 id="comparison-to-dblog">Comparison to DBLog</h3><p>The process we landed on is very similar to how DBLog works.</p><p>One difference is that DBLog uses a watermark <em>table</em> to produce its messages. DBLog inserts low and high watermarks into a table. That then produces a WAL message for SlotProcessor to later capture.</p><p>This strategy is nice because it&#39;s applicable to more databases (vs using <code>pg_logical_emit_message</code>). However, it requires a bit more setup on the source database – you need to create this table on every source database and give Sequin&#39;s Postgres user write access to this table. So, we opted for <code>pg_logical_emit_message</code> to keep the setup simpler.</p><h2 id="pulling-this-together-in-elixir">Pulling this together in Elixir</h2><p>Sequin is written in Elixir. To make this happen in Elixir, we have a GenServer for each stream processor:</p><h3 id="tablereader">TableReader</h3><p>TableReader is responsible for orchestrating the table capture process. TableReader emits low/high watermarks and selects chunks from Postgres.</p><p>It first emits the low watermark:</p><pre><code> payload =
      Jason.encode!(%{
        table_oid: table_oid,
        batch_id: current_batch_id,
        backfill_id: backfill_id
      })

 Postgres.query(conn, &#34;select pg_logical_emit_message(true, $1, $2)&#34;, [
          &#34;sequin.table-capture.low-watermark&#34;,
          payload
        ])
</code></pre><p>Then, it runs its select. Finally, it emits a high watermark with the same payload:</p><pre><code> Postgres.query(conn, &#34;select pg_logical_emit_message(true, $1, $2)&#34;, [
          &#34;sequin.table-capture.high-watermark&#34;,
          payload
        ])
</code></pre><p>The TableReader stores its chunk in memory.</p><p>TableReader manages a cursor. The cursor (a <a href="https://blog.sequinstream.com/keyset-cursors-not-offsets-for-postgres-pagination/">keyset cursor</a>) indicates where it is in the table that it is reading from. When we flush a batch from the TableReader to the output stream, we can also persist the cursor position associated with the end of the flushed batch.</p><p>If TableReader crashes or is stopped, it&#39;s safe; when it reboots, it will fetch the cursor associated with the last batch that was written to the output stream.</p><h3 id="slotprocessor">SlotProcessor</h3><p>The SlotProcessor connects to the replication slot and processes WAL messages. When it encounters a low watermark, it updates its state, indicating it should start saving PKs for the associated table OID.</p><p>When the SlotProcessor encounters a high watermark, it makes a call to TableReader. In the call is the list of primary keys to filter out.</p><p>If TableReader has the corresponding batch, TableReader will perform the filter and flush its read messages to the output stream. If TableReader doesn&#39;t have the corresponding batch, that means it has likely been restarted since the low and high watermarks were emitted. This is an expected situation, so safe to ignore.</p><p>The call to TableReader from SlotProcessor is synchronous. When it completes, SlotProcessor drops the batch&#39;s primary keys from memory and continues processing the WAL.</p><h3 id="low-without-high">Low without high?</h3><p>One edge case that can emerge: The TableReader might emit a low watermark message. But then crash before it&#39;s able to complete the rest of its operation, namely writing the high watermark message.</p><p>This is bad, because the SlotProcessor will accumulate PKs in memory indefinitely.</p><p>To mitigate, SlotProcessor will check in with TableReader as its accumulated PKs grow to verify the watermark/batch is valid. If TableReader does not recognize the <code>batch_id</code> or is not alive, the SlotProcessor can safely discard its accumulated PKs.</p><h3 id="optimization">Optimization</h3><p>To make the table capture process fast, we want TableReader to process the biggest batch sizes that it can as fast as it can. This means filling out a large chunk with multiple, parallel queries.</p><p>In an upcoming blog post, we&#39;ll describe how this process works.</p><h3 id="drawbacks">Drawbacks</h3><p>The primary drawback of this approach is that it only works on tables with primary keys. Without a primary key or any other unique constraints, there&#39;s no way to uniquely identify rows. Therefore, we can&#39;t consolidate TableReader&#39;s batch with the SlotProcessor&#39;s recently-seen rows.</p><p>At the moment, Sequin does not support table capture for tables without primary keys. In the future, we&#39;ll roll out support, but probably with limitations (e.g. you can&#39;t run table capture at the same time as change capture).</p><h2 id="conclusion">Conclusion</h2><p>Building a reliable CDC system with table state capture requires careful coordination between change and state capture processes. Our approach using chunked capture with watermark synchronization solves several key challenges:</p><ol><li>It maintains consistency without requiring table locks or pausing change capture</li><li>It handles race conditions gracefully through PK-based filtering</li><li>It remains memory-efficient by processing tables in chunks</li><li>It provides recovery guarantees through cursor persistence and watermark validation</li></ol><p>Leveraging features in both Postgres and Elixir/OTP, we&#39;ve built a system that achieves both consistency and high performance.</p><p>Check out Sequin for yourself via <a href="https://sequinstream.com/docs/quickstart/webhooks?ref=blog.sequinstream.com">one of our quickstarts</a> or by <a href="https://console.sequinstream.com/?ref=blog.sequinstream.com">creating a free trial account</a> on Sequin Cloud.</p>
    </div>

    <!-- The design of the summary of contents / table of contents is ready, and here. Yet, it still needs to import the headings
    <div class="absolute h-full top-2 -left-72">
      <div class="sticky top-28 p-4 rounded bg-gray-100 w-60 flex flex-col gap-2.5">
        <a class="p-4 bg-black dark:bg-gray-700 dark:hover:bg-gray-600 hover:bg-gray-800 hover:shadow-xl transition-all text-root text-white w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Introduction
        </a>
        <a class="p-4  bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 1
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 2
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 3
        </a>
      </div>
    </div>
    -->

  </div></div>
  </body>
</html>
