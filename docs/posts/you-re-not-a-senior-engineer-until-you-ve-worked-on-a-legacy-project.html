<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infobip.com/developers/blog/seniors-working-on-a-legacy-project">Original</a>
    <h1>You&#39;re not a senior engineer until you&#39;ve worked on a legacy project</h1>
    
    <div id="readability-page-1" class="page"><div>
        <main>
          
<figure><img decoding="async" src="https://www.infobip.com/developers/wp-content/uploads/2023/03/antique-manometers-measuring-instruments-with-cont-2021-08-26-18-12-26-utc.jpg" alt="A sepia image of old pressure valves" width="780" srcset="https://www.infobip.com/developers/wp-content/uploads/2023/03/antique-manometers-measuring-instruments-with-cont-2021-08-26-18-12-26-utc.jpg 1200w, https://www.infobip.com/developers/wp-content/uploads/2023/03/antique-manometers-measuring-instruments-with-cont-2021-08-26-18-12-26-utc-300x200.jpg 300w, https://www.infobip.com/developers/wp-content/uploads/2023/03/antique-manometers-measuring-instruments-with-cont-2021-08-26-18-12-26-utc-1024x683.jpg 1024w, https://www.infobip.com/developers/wp-content/uploads/2023/03/antique-manometers-measuring-instruments-with-cont-2021-08-26-18-12-26-utc-768x512.jpg 768w" sizes="(max-width: 1200px) 100vw, 1200px"/></figure>



<p>Everybody hates working on legacy projects, myself included. As fate would have it, one landed in my lap recently. While working on it didn’t make me hate legacy projects any less, it did help me get a deeper understanding of the processes and practices we use today. </p>



<p>I am proud that I am a part of a team that uses <strong>most of the best practices:</strong> </p>



<ul>
<li>Writing clean code and automated tests </li>



<li>Participating in pull requests and tasks reviews </li>



<li>App is in production within the same day of merging into the master branch </li>



<li>Agile is well adopted </li>
</ul>



<p> It’s not perfect. Pull requests sometimes contain trivial suggestions and discussions. The ops team usually messes something up (or at least that’s what we devs like to think). Our product owner occasionally wants us to fast-track some ‘easy’ features… again. But all in all, things are pretty good. </p>



<h2>A trip to the Ant museum </h2>



<p>Since our team was performing well, our velocity was borrowed to another product, managed by another part of our company. We weren’t thrilled about it since the project <strong>uses an older version of Java, </strong>and the code wasn’t written the way we would do it.  </p>



<p>The job was to add a few metrics – simple ones, like whether the app is running and for how long, is it processing data (fast enough). The project itself was in maintenance mode, and no new features had been added in a while. Since we are accustomed to adding metrics, this should have been a piece of cake. </p>



<p>Rolling up our sleeves, we first noticed that <strong>the project had been built using something very old - </strong><a href="https://en.wikipedia.org/wiki/Apache_Ant" target="_blank" rel="noreferrer noopener"><strong>Ant</strong></a><strong>  build files. </strong>They are big XML files that contain every piece of information on how to build the project in question. For example, you need to specify that the project needs to be compiled, tested, and packaged. All details like source, target, and resource location must be explicitly configured within those files. This used to be pretty common for many programming languages. You wrote a build file once, copied it on each new project, and then changed it until it worked for the new project.  </p>



<p>Here’s what an Ant build file for a Hello World project would look like: </p>



<div><pre data-lang="SQL"><code>&lt;project&gt;

    &lt;target name=&#34;clean&#34;&gt;
        &lt;delete dir=&#34;build&#34;/&gt;
    &lt;/target&gt;

    &lt;target name=&#34;compile&#34;&gt;
        &lt;mkdir dir=&#34;build/classes&#34;/&gt;
        &lt;javac srcdir=&#34;src&#34; destdir=&#34;build/classes&#34;/&gt;
    &lt;/target&gt;

    &lt;target name=&#34;jar&#34;&gt;
        &lt;mkdir dir=&#34;build/jar&#34;/&gt;
        &lt;jar destfile=&#34;build/jar/HelloWorld.jar&#34; basedir=&#34;build/classes&#34;&gt;
            &lt;manifest&gt;
                &lt;attribute name=&#34;Main-Class&#34; value=&#34;oata.HelloWorld&#34;/&gt;
            &lt;/manifest&gt;
        &lt;/jar&gt;
    &lt;/target&gt;

    &lt;target name=&#34;run&#34;&gt;
        &lt;java jar=&#34;build/jar/HelloWorld.jar&#34; fork=&#34;true&#34;/&gt;
    &lt;/target&gt;

&lt;/project&gt;</code></pre></div>



<p>There must be a more convenient way to manage that, right? Well, that’s why the idea of <a href="https://en.wikipedia.org/wiki/Convention_over_configuration" target="_blank" rel="noreferrer noopener">convention over configuration</a> came to life, suggesting that developers only need to specify unconventional aspects of the application. <strong>Modern build tools have adopted</strong> <strong>this paradigm by providing developers with defaults that can be overridden if needed.</strong> That’s why most java source files are in src/main/java source, while the compiled classes are in the target folder—no need to specify this over and over. </p>



<p>That got us thinking about whether this approach would be helpful in our current projects. We had a huge application properties file, with most values having the same value (e.g., application port). <strong>Could we apply the same principle to our application properties?</strong> Most properties could have defaults, and our properties file wouldn’t be as large. </p>



<h2>Things we take for granted</h2>



<p>Back to our legacy project – we managed to build and package our application! The tedious part was behind us, and we could start coding. But <strong>how do we embed our metrics component into the legacy code base</strong>? We took this for granted because our application framework usually handled it.  </p>



<p>Now, what would be the best way to inject our metric components into various parts of the legacy code? Singletons! Well, it seemed the easiest way, at least, but the community considers them anti-patterns. Why? Isn’t our beloved XY framework relying on singletons? If not, what does it use? What is dependency injection? How does it function under the hood? </p>



<p><strong>These questions got us thinking about basic concepts that we took for granted</strong>. Using singletons wasn’t exactly a bad idea in this case since most of the code wasn’t covered with unit tests. Nevertheless, we couldn’t have a good night’s sleep unless the code was immaculate. We tried a different approach and ended up with decent and simple code – no singletons, no new abstractions. </p>



<h2>The limited role of developers </h2>



<p>The only thing left was to deploy it so that we could test it. This was a problem, of course – in this case, we were not the ones deploying it or testing it. <strong>Deploying had to be done by the ops team, and testing by the test team.</strong> Why couldn’t we, as developers, manage the whole feature from start to production instead of opening tickets and waiting for other teams before we could close our task?</p>



<p>Firstly, we couldn’t avoid manual testing since much of the code wasn’t covered with tests. We also couldn’t deploy the application ourselves since the infrastructure didn’t allow us to.  </p>



<p>This had us thinking about the reasons behind <strong>the separation of duties</strong> and <strong>how our current approach is better</strong>. Seeing that our <a href="https://en.wikipedia.org/wiki/Lead_time" target="_blank" rel="noreferrer noopener">lead</a> and <a href="https://en.wikipedia.org/wiki/Cycle_time_(software)" target="_blank" rel="noreferrer noopener">cycle time</a> on this project was significantly higher than usual (it took us weeks to deliver something we usually deliver in several days), the evidence was strongly in favor of that.</p>



<h2>Learn outdated practices to understand current ones </h2>



<p>At the end of the <s>day</s> month, our metrics were up and running in production. My feeling about legacy projects hasn’t changed – I still hate them, and I am not expecting you to hate them any less.  </p>



<p>We couldn’t change the project we were assigned to, and these were the cards that we were dealt. What we could <strong>change is our attitude towards the legacy project</strong>. Instead of feeling resigned, we saw it as <strong>a place to ask questions and learn.</strong>  </p>



<p>It taught us how things were done before and why they are done differently now. Instead of just knowing the best practices, we gained first-hand experience with the history behind them.  </p>



<p>Once you start having this deep-rooted knowledge, other developers will recognize this and trust your knowledge and expertise.  If you want to be that person, you better be ready to dig into some legacy projects. </p>
        </main>
      </div></div>
  </body>
</html>
