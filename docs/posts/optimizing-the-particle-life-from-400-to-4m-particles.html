<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://programmingattack.com/articles/optimizing-the-article-life-from-a-thousand-to-a-milion-particles">Original</a>
    <h1>Optimizing the Particle Life: From 400 to 4M particles</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://bytes.zone/articles/1.webp" alt=""/></p><h2 id="why-particle-life"><a href="#why-particle-life"><!--[-->Why Particle Life?<!--]--></a></h2><p><!--[-->For one of my programming classes this semester, my task was writing a program in Python. It was only an introductory course, so it didn’t have to be anything fancy. Whenever I get assignments like this one, my choice is simple: I enjoy tinkering around with cellular automata and particle simulations.<!--]--></p><p><!--[-->I have had an eye on Particle Life for quite a while now. The idea belongs to Jeffrey Ventrella, who called it &#34;Clusters.&#34; As the name suggests, its simple rules result in the emergence of lifelike, cell-like structures interacting with one another. During my experiments, I was also amazed by the fact that applying the same rules on much larger scales gives us a resemblance to many different phenomena in nature, somewhat like electron clouds or cosmic structures. I, personally, found it mesmerizing, and I got completely absorbed by writing this program for the better part of a week, completely neglecting other things I needed to take care of.<!--]--></p><p><!--[-->But what do I even mean by emergence in the paragraph above?<!--]--></p><p><!--[-->Have you ever wondered how a flock of birds operates? How is it able to travel, forage, and respond to predators? An individual bird does not have a blueprint of the flock&#39;s final behavior and its part in it.<!--]--></p><p><!--[-->Instead, a singular bird operates based on simple rules guiding its behavior. For example, in boids, an algorithm simulating the flocking behavior of birds, an individual agent&#39;s interaction must adhere to (a simplified) set of rules:<!--]--></p><ol><!--[--><li><!--[-->Stay <strong><!--[-->separated<!--]--></strong> to avoid crowding local flockmates.<!--]--></li><li><!--[--><strong><!--[-->Align<!--]--></strong> with the average direction of your local flockmates.<!--]--></li><li><!--[-->Navigate towards the average position of your local flockmates to retain <strong><!--[-->cohesion<!--]--></strong>.<!--]--></li><!--]--></ol><p><!--[-->The complexity of the flock emerges from every agent in the system following these rules. Flock has distinct properties that arose from the behavior of its components, but there&#39;s no way for us to deduce these properties from the rules we applied to individual agents. This is why we can call a flock a complex system.<!--]--></p><p><!--[-->Human societies, the universe, climate, cities—all these are examples of complex systems. And the simulation we&#39;ll write is an example of it as well. You&#39;ll see for yourself how the structures we&#39;ll see on the screen are described nowhere in the code but emerge as a result of uncomplicated rules generated for every particle randomly each time we start the program.<!--]--></p><p><!--[-->There are multiple implementations of the algorithm available online. To contribute something new, I decided to focus on the optimization of the program. This is a deep-dive, several-piece series, but at the end, we&#39;ll render a million particles in real-time, which makes it completely worth the time spent on the project!<!--]--></p><h2 id="the-rules"><a href="#the-rules"><!--[-->The rules<!--]--></a></h2><p><!--[-->The first thing we need to specify is the number of classes of particles. We will denote these classes by their colors, and how particles interact with each other will depend on their respective colors. This force can be attractive or repulsive, depending on our color-attraction matrix. It doesn’t have to be symmetric: red particles can be attracted to green particles, but green particles can be repulsed by red ones.<!--]--></p><p><!--[-->To visualize this dependence, let’s see an example matrix with two classes of particles and forces ranging from -1.0 to 1.0:<!--]--></p>




















<table><!--[--><thead><!--[--><tr><!--[--><th><!--[--><!--]--></th><th><!--[-->Red<!--]--></th><th><!--[-->Blue<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[--><strong><!--[-->Red<!--]--></strong><!--]--></td><td><!--[-->.86<!--]--></td><td><!--[-->-.15<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><strong><!--[-->Blue<!--]--></strong><!--]--></td><td><!--[-->.33<!--]--></td><td><!--[-->.24<!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table><p><!--[-->In this case, red particles are strongly attracted to one another. They’re slightly repulsed by blue ones. Blue particles also attract each other, although in a weaker manner, and they’re also attracted to red particles.<!--]--></p><p><!--[-->This force works within a radius that we’ll specify. But within a fraction of this radius, we have another force, the universal repulsive force. Otherwise, particles that are attracted to each other would end up collapsing into one.<!--]--></p><p><!--[-->This is how we can visualize our force function, assuming the force value between two particles to be 1.0 and a repulsive radius of 1/4 of the max radius:<!--]--></p><p><img src="https://bytes.zone/articles/graph%20%281%29.png" alt=""/></p><p><!--[-->Of course, these rules are not set in stone. In the following parts, you will see how slight changes in force function affect our system:<!--]--></p><p><img src="https://bytes.zone/articles/graph.png" alt=""/><img src="https://bytes.zone/articles/graph%20%282%29.png" alt=""/><img src="https://bytes.zone/articles/graph%20%283%29.png" alt=""/></p><p><!--[-->So far, so good. You must admit that these rules are really beautifully simple. It&#39;s time to write a Python script to test if I can get it up and running.<!--]--></p><p><!--[-->After some time, and some frustrating errors originating from Qt, my particles came to life. Below, you can find the whole script. I tried to add explicit comments to every line so that there aren’t any confusing bits. A little note about system parameters: those are arbitrarily chosen values. You have to experiment for a bit to see what works and what doesn’t.<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>import numpy as np
</span></span><span line="2"><span>import colorsys as cs
</span></span><span line="3"><span>import random as rd
</span></span><span line="4"><span>import sys
</span></span><span line="5"><span>import math
</span></span><span line="6"><span>from PySide6.QtCore import *
</span></span><span line="7"><span>from PySide6.QtWidgets import *
</span></span><span line="8"><span>from PySide6.QtGui import *
</span></span><span line="9"><span emptylineplaceholder="true">
</span></span><span line="10"><span>width = 800
</span></span><span line="11"><span>height = 800
</span></span><span line="12"><span emptylineplaceholder="true">
</span></span><span line="13"><span>#function definitions
</span></span><span line="14"><span>def buildAttractionMatrix(m):
</span></span><span line="15"><span>    return (m*2)-1 # Multiple random between [0.0,1.0] by 2 and substract one to get random between [-1.0,1.0]
</span></span><span line="16"><span emptylineplaceholder="true">
</span></span><span line="17"><span>#With HSL, unlike RGB, to change color we have to update only one value [[H]SL -&gt; Hue]. Hence, it will work perfectly
</span></span><span line="18"><span>#for generating predefined no of colors, sufficiently distinct from one another. Since our GUI library accepts only RGB colors,
</span></span><span line="19"><span>#we have to convert it RGB.
</span></span><span line="20"><span>def createColors(m):
</span></span><span line="21"><span>    colors = list()
</span></span><span line="22"><span>    for i in range(m):
</span></span><span line="23"><span>        hueValue = (i *( 360/(m - 1)))
</span></span><span line="24"><span>        #hsvtorgb() returns values between [0.0,1.0] hence i*255
</span></span><span line="25"><span>        color = tuple(round(i * 255) for i in cs.hsv_to_rgb(hueValue/100,1,1))
</span></span><span line="26"><span>        colors.append(QColor(color[0],color[1],color[2]))
</span></span><span line="27"><span>    return colors
</span></span><span line="28"><span emptylineplaceholder="true">
</span></span><span line="29"><span>def force(d, f): #d - ratio of particles distance and max distance , f - force according to attraction matrix
</span></span><span line="30"><span>    repRadius = 0.25 #universal repulsive force that prevents our particles from collapsing into each other
</span></span><span line="31"><span>    #25% is an arbitrary value I tested to behave the best - feel free to experiment, like with other system parameters.
</span></span><span line="32"><span>    if (d&lt;repRadius):
</span></span><span line="33"><span>        #if d is within the range of universal repulsive we return negative value. As the distance approaches 0 returned value approaches -1 which is max value
</span></span><span line="34"><span>        #for our repulsive force
</span></span><span line="35"><span>        return (d/repRadius - 1)
</span></span><span line="36"><span>    elif (repRadius &lt; d and d&lt;1): #our distance is within max radius for standard force defined by attraction matrix
</span></span><span line="37"><span>        #the closer we get the particles together, the stronger their interaction is.
</span></span><span line="38"><span>        #As the particle move apart from each other, the force dissipates to reach 0 as we
</span></span><span line="39"><span>        #reach max radius
</span></span><span line="40"><span>        return f * (1-d)
</span></span><span line="41"><span>    else:
</span></span><span line="42"><span>        return 0 #particles are indiffirent to each other
</span></span><span line="43"><span emptylineplaceholder="true">
</span></span><span line="44"><span>def updatePositions():
</span></span><span line="45"><span>    #we initiate a loop to update all particles in our system
</span></span><span line="46"><span>    for i in range(n):
</span></span><span line="47"><span>        #every particle will accumulate total force value we&#39;ll get by evaluating it&#39;s attraction to every other particle in the system. Hence, our algorithm
</span></span><span line="48"><span>        #has a time complexity of O(n^2) if we don&#39;t add any optimizations.
</span></span><span line="49"><span>        totalForceX = 0
</span></span><span line="50"><span>        totalForceY = 0
</span></span><span line="51"><span>        for j in range(n):
</span></span><span line="52"><span>            if (i!=j):#we&#39;re not calculating the particle&#39;s influence on itself
</span></span><span line="53"><span>                #calculating distance between tested particle (i) to all other particles (j)
</span></span><span line="54"><span>                x = positionsX[j]-positionsX[i]
</span></span><span line="55"><span>                y = positionsY[j]-positionsY[i]
</span></span><span line="56"><span>                d = math.sqrt(x * x + y* y)
</span></span><span line="57"><span emptylineplaceholder="true">
</span></span><span line="58"><span>                if (d&lt;radius): #we&#39;re only proceeding with calculating distance if the distance between particle is less than max radius we specified for our system
</span></span><span line="59"><span>                    #1st param: We have to apply force proportionally to the distance between particles instead of simply using the value from out matrix
</span></span><span line="60"><span>                    #2nd param: To get the right value from the attraction matrix we need to get colors of particles we test
</span></span><span line="61"><span>                    f = force(d/radius, attractionMatrix[colors.index(particlesColors[i])][colors.index(particlesColors[j])])
</span></span><span line="62"><span>                    #lets add our force for this particle (j) to our total forces for particle (i)
</span></span><span line="63"><span>                    totalForceX+=(x / d)*f
</span></span><span line="64"><span>                    totalForceY+=(y / d)*f
</span></span><span line="65"><span>        #total force we just calculated will increase the particle&#39;s velocity
</span></span><span line="66"><span>        velocitiesX[i]+=totalForceX
</span></span><span line="67"><span>        velocitiesY[i]+=totalForceY
</span></span><span line="68"><span>        #we have to apply friction so that our particles don&#39;t accumulate velocity forever
</span></span><span line="69"><span>        velocitiesX[i]*=fr
</span></span><span line="70"><span>        velocitiesY[i]*=fr
</span></span><span line="71"><span>        #now that we have the particles velocity we can know how to change its position
</span></span><span line="72"><span>        positionsX[i]+=velocitiesX[i]
</span></span><span line="73"><span>        positionsY[i]+=velocitiesY[i]
</span></span><span line="74"><span emptylineplaceholder="true">
</span></span><span line="75"><span>#system properties
</span></span><span line="76"><span>n = 400 #number of particles
</span></span><span line="77"><span>m = 5 #number of colors
</span></span><span line="78"><span>radius = 0.20
</span></span><span line="79"><span>fr = math.pow(.5, 10) #friction
</span></span><span line="80"><span emptylineplaceholder="true">
</span></span><span line="81"><span>#init arrays to hold our values
</span></span><span line="82"><span>attractionMatrix = buildAttractionMatrix(np.random.random((m,m))) #create 2-d matrix based on number of colors
</span></span><span line="83"><span>colors = createColors(m)
</span></span><span line="84"><span>particlesColors = [rd.choice(colors) for _ in range(n)] #every particle is assigned random color from colors we created
</span></span><span line="85"><span>#every particle is assigned random position
</span></span><span line="86"><span>positionsX = [rd.random() for _ in range(n)]
</span></span><span line="87"><span>positionsY = [rd.random() for _ in range(n)]
</span></span><span line="88"><span>#every particle is assigned velocity = 0
</span></span><span line="89"><span>velocitiesX = np.empty(n, dtype=float)
</span></span><span line="90"><span>velocitiesY = np.empty(n, dtype=float)
</span></span><span line="91"><span emptylineplaceholder="true">
</span></span><span line="92"><span>class Window(QWidget):
</span></span><span line="93"><span>    def __init__(self):
</span></span><span line="94"><span>        super().__init__()
</span></span><span line="95"><span emptylineplaceholder="true">
</span></span><span line="96"><span>    def paintEvent(self, event):
</span></span><span line="97"><span>        painter = QPainter(self)
</span></span><span line="98"><span emptylineplaceholder="true">
</span></span><span line="99"><span>        updatePositions()
</span></span><span line="100"><span>        for i in range(n):
</span></span><span line="101"><span>            x = positionsX[i] * width
</span></span><span line="102"><span>            y = positionsY[i] * height
</span></span><span line="103"><span>            painter.setPen(particlesColors[i])
</span></span><span line="104"><span>            painter.drawEllipse(x, y, 1, 1)
</span></span><span line="105"><span>            self.update()
</span></span><span line="106"><span emptylineplaceholder="true">
</span></span><span line="107"><span emptylineplaceholder="true">
</span></span><span line="108"><span>app = QApplication(sys.argv)
</span></span><span line="109"><span>window = Window()
</span></span><span line="110"><span>window.height = height
</span></span><span line="111"><span>window.width = width
</span></span><span line="112"><span>window.show()
</span></span><span line="113"><span emptylineplaceholder="true">
</span></span><span line="114"><span>sys.exit(app.exec())
</span></span></code><!--]--></pre><!--]--><h2 id="choosing-the-right-language-for-the-job"><a href="#choosing-the-right-language-for-the-job"><!--[-->Choosing the right language for the job<!--]--></a></h2><p><!--[-->There’s just one problem. My code is embarrassingly inefficient. I haven’t implemented any optimizations yet, but I didn’t expect it to be so bad! I work on a decent machine with an M2 processor, but I was barely able to run 500 particles before the animation stopped being smooth. It was my first time writing any Python code, so I suspected stepping on mine of using an inappropriate data structure or an unfortunate library function call (for example, later on, when I was implementing the same thing in javascript, calculating distance using Math.hypot() instead of Math.sqrt(x<em><!--[-->x+y<!--]--></em>y) turned out to be nearly 10x slower).<!--]--></p><p><!--[-->Unfortunately, after using line profiler I realized that it is basic arithmetic operations that take up most of the time. I know Python is not exactly the most efficient language out there, but I expected better.<!--]--></p><p><!--[-->At this stage, I decided that my Python script would be only a point of origin, and I would write my proper implementation in something else. I’d love to simply embed my work to a webpage, where everyone can play with it, but first I wanted to see how JS will perform with a large amount of arithmetics compared to low-level languages. I know that nowadays v8 is pretty performant, so I had a good feeling about this. I know, I know - you can use C modules for Python, but since I don’t plan to dive deep into Python anytime soon, this option didn’t interest me. Another thing I was curious about was how WebAssebly would perform compared to JS.<!--]--></p><p><!--[-->Before we start any benchmarking, we have to consider what we need to measure. What are the most costly operations of our algorithm?<!--]--></p><p><!--[-->First of all, let&#39;s stress the fact that to calculate the positions of every particle we have to iterate over every other particle in the system, which gives us O(N^2) complexity. So, it is the code inside the inner loop in the updatePositions() function that takes most of the time. What is this code responsible for? Simply speaking, it performs basic arithmetic operations on array elements.<!--]--></p><p><!--[-->It is important to realize you should never treat these types of benchmarks as an oracle guiding your development decisions. Here, it was useful. But there are many factors that influence code execution time besides language itself, and the first call should be always to optimize what you can with the language of your choice, unless it really is unreasonable, like using Python in this case.<!--]--></p><p><!--[-->Having this little disclaimer out of the way, let&#39;s see what we can expect from Python, C, JS, and WebAssembly for the tasks described above.<!--]--></p><p><!--[-->C:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>int main(int argc, char * argv[]) {
</span></span><span line="2"><span>  srand((unsigned int) time(NULL));
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>  int diff;
</span></span><span line="5"><span>  int i;
</span></span><span line="6"><span>  int j;
</span></span><span line="7"><span>  int l = 10000;
</span></span><span line="8"><span>  float t[l];
</span></span><span line="9"><span emptylineplaceholder="true">
</span></span><span line="10"><span>  clock_t start = clock();
</span></span><span line="11"><span emptylineplaceholder="true">
</span></span><span line="12"><span>  for (int i = 0; i &lt; l; i++) {
</span></span><span line="13"><span>    t[i] = 0.0;
</span></span><span line="14"><span>    for (j = 0; j &lt; l; j++) {
</span></span><span line="15"><span>      t[i] += 0.02 * (float)j;
</span></span><span line="16"><span>      t[i] *= 0.03 * (float)j;
</span></span><span line="17"><span>      t[i] -= 0.04 * (float)j;
</span></span><span line="18"><span>      t[i] /= 0.05 * (float)j+1.00;
</span></span><span line="19"><span>    }
</span></span><span line="20"><span>  }
</span></span><span line="21"><span emptylineplaceholder="true">
</span></span><span line="22"><span>  clock_t end = clock();
</span></span><span line="23"><span>  int elapsed = (int)(end - start) / (CLOCKS_PER_SEC / 1000);
</span></span><span line="24"><span>  printf(&#34;%d %s&#34;, elapsed, &#34;ms elapsed&#34;);
</span></span><span line="25"><span emptylineplaceholder="true">
</span></span><span line="26"><span>  return 0;
</span></span><span line="27"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->JS:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>const</span><span> l</span><span> =</span><span> 10000</span><span>;
</span></span><span line="2"><span>const</span><span> t</span><span> =</span><span> [];
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>const</span><span> s</span><span> =</span><span> Date.</span><span>now</span><span>();
</span></span><span line="5"><span emptylineplaceholder="true">
</span></span><span line="6"><span>for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> l; i</span><span>++</span><span>) {
</span></span><span line="7"><span>  t[i] </span><span>=</span><span> 0</span><span>;
</span></span><span line="8"><span emptylineplaceholder="true">
</span></span><span line="9"><span>  for</span><span> (j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> l; j</span><span>++</span><span>) {
</span></span><span line="10"><span>    t[i] </span><span>+=</span><span> 0.02</span><span> *</span><span> j;
</span></span><span line="11"><span>    t[i] </span><span>*=</span><span> 0.03</span><span> *</span><span> j;
</span></span><span line="12"><span>    t[i] </span><span>-=</span><span> 0.04</span><span> *</span><span> j;
</span></span><span line="13"><span>    t[i] </span><span>/=</span><span> 0.05</span><span> *</span><span> (j </span><span>+</span><span> 1</span><span>);
</span></span><span line="14"><span>  }
</span></span><span line="15"><span>}
</span></span><span line="16"><span emptylineplaceholder="true">
</span></span><span line="17"><span>console.</span><span>log</span><span>(
</span></span><span line="18"><span>  Date.</span><span>now</span><span>() </span><span>-</span><span> s,
</span></span><span line="19"><span>  &#34;ms elapsed&#34;
</span></span><span line="20"><span>);
</span></span></code><!--]--></pre><!--]--><p><!--[-->Python:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>import time
</span></span><span line="2"><span>import random as rd
</span></span><span line="3"><span>import numpy as np
</span></span><span line="4"><span emptylineplaceholder="true">
</span></span><span line="5"><span>l = 10000
</span></span><span line="6"><span>t = np.empty(l, dtype=float)
</span></span><span line="7"><span emptylineplaceholder="true">
</span></span><span line="8"><span>s= time.time()
</span></span><span line="9"><span>for i in range(l):
</span></span><span line="10"><span>    t[i] = 0.0
</span></span><span line="11"><span>    for j in range(l):
</span></span><span line="12"><span>        t[i] += 0.02 * j
</span></span><span line="13"><span>        t[i] *= 0.03 * j
</span></span><span line="14"><span>        t[i] -= 0.04 * j
</span></span><span line="15"><span>        t[i] /= 0.05 * (j+1)
</span></span><span line="16"><span emptylineplaceholder="true">
</span></span><span line="17"><span>print( (time.time()-s) * 1000, &#39;ms elapsed&#39;)
</span></span></code><!--]--></pre><!--]--><p><!--[-->The results were interesting to say the least:<!--]--></p><p><img src="https://bytes.zone/articles/Zrzut%20ekranu%202024-02-26%20o%2018.50.11.png" alt=""/></p><p><!--[-->Few things require noting here:<!--]--></p><ol><!--[--><li><!--[-->I didn&#39;t use any optimization flags when compiling my C code.<!--]--></li><li><!--[-->Node is using a V8 engine. When I ran the same file using Apple&#39;s JavascriptCore, the result was nearly twice as long. I can turn a blind eye to that when developing a hobby project, but for the real product, it would be quite an issue.<!--]--></li><!--]--></ol><p><!--[-->We need to remember that these benchmarks measure nothing but the efficiency of my little script. It would be unwise to draw any premature conclusions from it. Still, we should appreciate how optimized modern JS is. In the next part, you&#39;ll see that many of the go-to points developers usually go through when optimizing their code, give no advantage, because the V8 compiler is just smart enough to know to take care of it for us... If there&#39;s one lesson to be learned from the examples above, it would be that for things requiring performance, developers should never trust, and always verify. I was very surprised!<!--]--></p><p><!--[-->If JS performed so well compared to low-level C, you can probably already guess what my next point will be: using WebAssembly gives us no advantage in this case.<!--]--></p><p><!--[-->For the curious of you, WASM module compiled from this AssemblyScript:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>export</span><span> function</span><span> updateParticles</span><span>()</span><span>:</span><span> void</span><span> {
</span></span><span line="2"><span>  const</span><span> l</span><span> =</span><span> 10000</span><span>;
</span></span><span line="3"><span>  const</span><span> t</span><span>:</span><span> f32</span><span>[] </span><span>=</span><span> [];
</span></span><span line="4"><span emptylineplaceholder="true">
</span></span><span line="5"><span>  const</span><span> s</span><span> =</span><span> Date.</span><span>now</span><span>();
</span></span><span line="6"><span emptylineplaceholder="true">
</span></span><span line="7"><span>  for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> l; i</span><span>++</span><span>) {
</span></span><span line="8"><span>    t[i] </span><span>=</span><span> 0</span><span>;
</span></span><span line="9"><span emptylineplaceholder="true">
</span></span><span line="10"><span>    for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> l; j</span><span>++</span><span>) {
</span></span><span line="11"><span>      t[i] </span><span>+=</span><span> 0.02</span><span> *</span><span> (j </span><span>as</span><span> f32</span><span>);
</span></span><span line="12"><span>      t[i] </span><span>*=</span><span> 0.03</span><span> *</span><span> (j </span><span>as</span><span> f32</span><span>);
</span></span><span line="13"><span>      t[i] </span><span>-=</span><span> 0.04</span><span> *</span><span> (j </span><span>as</span><span> f32</span><span>);
</span></span><span line="14"><span>      t[i] </span><span>/=</span><span> 0.05</span><span> *</span><span> ((j </span><span>+</span><span> 1</span><span>) </span><span>as</span><span> f32</span><span>);
</span></span><span line="15"><span>    }
</span></span><span line="16"><span>  }
</span></span><span line="17"><span emptylineplaceholder="true">
</span></span><span line="18"><span>  console.</span><span>log</span><span>((Date.</span><span>now</span><span>() </span><span>-</span><span> s).</span><span>toString</span><span>() </span><span>+</span><span> &#34; ms elapsed&#34;</span><span>);
</span></span><span line="19"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->Yielded the following result. My research here was nearly non-existing, so I don&#39;t feel confident enough to make any further comments:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>12878</span><span> ms elapsed
</span></span></code><!--]--></pre><!--]--><p><!--[-->This is the end of the first part. In the next part, we’ll implement the same code in JS and use spatial partitioning methods to get rid of the scary O(N^2) complexity. In part 3, we’ll implement 3D life on GPU with the new WebGPU API and optimize our WGSL code. Spoiler alert: the goal is to reach one million particles!<!--]--></p><p><!--[-->To keep you interested, a few screenshots:<!--]--></p><p><img src="https://bytes.zone/articles/Zrzut%20ekranu%202024-02-26%20o%2022.02.57.png" alt="1000 2D particles - JS"/><sup>1000 2D particles - JS</sup><img src="https://bytes.zone/articles/Zrzut%20ekranu%202024-02-26%20o%2022.06.52.png" alt="1 million 2D particles - GPU.js"/><sup>1 million 2D particles - GPU.js. First frames.</sup><img src="https://bytes.zone/articles/Zrzut%20ekranu%202024-02-26%20o%2022.09.40.png" alt="50000 2D particles - vanilla JS optimized with quadtree."/><sup>50000 2D particles - vanilla JS optimized with quadtree.</sup></p><p><sup>Playing around with webGPU implementation.</sup><img src="https://bytes.zone/articles/3dparticle.png" alt="256000 particles within interaction radius."/><sup>256000 particles within interaction radius</sup><img src="https://bytes.zone/articles/image.png" alt="4 million particles."/><sup>4 million particles. WebGPU.</sup></p><p><!--[--><a href="https://bytes.zone/articles/optimizing-the-particle-life-javascript-quadtree"><!--[-->See the next part<!--]--></a><!--]--></p></div></div>
  </body>
</html>
