<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackoverflow.blog/2022/11/03/multiple-assertions-per-test-are-fine/">Original</a>
    <h1>Multiple assertions are fine in a unit test</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p>Assertion Roulette doesn’t mean that multiple assertions are bad.</p>



<p>When I coach teams or individual developers in test-driven development (TDD) or unit testing, I frequently encounter a particular notion: <em>Multiple assertions are bad. A test must have only one assertion.</em></p>



<p>That idea is rarely helpful.</p>



<p>Let’s examine a realistic code example and subsequently try to understand the origins of the notion.</p>



<h2 id="h-outside-in-tdd">Outside-in TDD</h2>



<p>Consider a REST API that enables you to make and cancel restaurant reservations. First, an HTTP <code>POST</code> request makes a reservation:</p>



<pre><code>POST /restaurants/1/reservations?sig=epi301tdlc57d0HwLCz[...] HTTP/1.1
Content-Type: application/json
{
  &#34;at&#34;: &#34;2023-09-22 18:47&#34;,
  &#34;name&#34;: &#34;Teri Bell&#34;,
  &#34;email&#34;: &#34;terrible@example.org&#34;,
  &#34;quantity&#34;: 1
}

HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
Location: /restaurants/1/reservations/971167d4c79441b78fe70cc702[...]
{
  &#34;id&#34;: &#34;971167d4c79441b78fe70cc702d3e1f6&#34;,
  &#34;at&#34;: &#34;2023-09-22T18:47:00.0000000&#34;,
  &#34;email&#34;: &#34;terrible@example.org&#34;,
  &#34;name&#34;: &#34;Teri Bell&#34;,
  &#34;quantity&#34;: 1
}
</code></pre>



<p>Notice that in <a href="https://martinfowler.com/articles/richardsonMaturityModel.html">proper REST</a> fashion, the response returns the location of the created reservation in the <code>Location</code> header.</p>



<p>If you change your mind, you can cancel the reservation with a <code>DELETE</code> request:</p>



<pre><code>DELETE /restaurants/1/reservations/971167d4c79441b78fe70cc702[...] HTTP/1.1

HTTP/1.1 200 OK
</code></pre>



<p>Imagine that this is the desired interaction. Using <a href="https://blog.ploeh.dk/outside-in-tdd">outside-in TDD</a> you write the following test:</p>



<pre><code>[Theory]
[InlineData(884, 18, 47, &#34;c@example.net&#34;, &#34;Nick Klimenko&#34;, 2)]
[InlineData(902, 18, 50, &#34;emot@example.gov&#34;, &#34;Emma Otting&#34;, 5)]
public async Task DeleteReservation(
    int days, int hours, int minutes,
    string email, string name, int quantity)
{
    using var api = new LegacyApi();
    var at = DateTime.Today.AddDays(days).At(hours, minutes)
        .ToIso8601DateTimeString();
    var dto = Create.ReservationDto(at, email, name, quantity);
    var postResp = await api.PostReservation(dto);
    Uri address = FindReservationAddress(postResp);
 
    var deleteResp = await api.CreateClient().DeleteAsync(address);
 
    Assert.True(
        deleteResp.IsSuccessStatusCode,
        $&#34;Actual status code: {deleteResp.StatusCode}.&#34;);
}
</code></pre>



<p>This example is in C# using <a href="https://xunit.net/">xUnit.net</a> because we need <em>some</em> language and framework to show realistic code. The point of the article, however, applies across languages and frameworks. The code examples in this article are based on the sample code base that accompanies my book <a href="https://blog.ploeh.dk/2021/06/14/new-book-code-that-fits-in-your-head"><em>Code That Fits in Your Head</em></a>.</p>



<p>In order to pass this test, you can implement the server-side code like this:</p>



<pre><code>[HttpDelete(&#34;restaurants/{restaurantId}/reservations/{id}&#34;)]
public void Delete(int restaurantId, string id)
{
}
</code></pre>



<p>While clearly a <a href="https://en.wikipedia.org/wiki/NOP_(code)">no-op</a>, this implementation passes all tests. The newly-written test asserts that the HTTP response returns a status code in the <code>200</code> (success) range. This is part of the API’s REST protocol, so this response is important. You want to keep this assertion around as a regression test. If the API ever begins to return a status code in the <code>400</code> or <code>500</code> range, it would be a breaking change.</p>



<p>So far, so good. TDD is an incremental process. One test doesn’t drive a full feature.</p>



<p>Since all tests are passing, you can <a href="https://stackoverflow.blog/2022/04/06/use-git-tactically/">commit the changes to source control and proceed to the next iteration</a>.</p>



<h2 id="h-strengthening-the-postconditions">Strengthening the postconditions</h2>



<p>You should be able to check that the resource is truly gone by making a <code>GET</code> request:</p>



<pre><code>GET /restaurants/1/reservations/971167d4c79441b78fe70cc702[...] HTTP/1.1

HTTP/1.1 404 Not Found</code></pre>



<p>This, however, is not the behavior of the current implementation of <code>Delete</code>, which does nothing. It seems that you’re going to need another test.</p>



<p>Or do you?</p>



<p>One option is to <em>copy</em> the existing test and change <a href="https://blog.ploeh.dk/2013/06/24/a-heuristic-for-formatting-code-according-to-the-aaa-pattern">the assertion phase</a> to perform the above <code>GET</code> request to check that the response status is <code>404</code>:</p>



<pre><code>[Theory]
[InlineData(884, 18, 47, &#34;c@example.net&#34;, &#34;Nick Klimenko&#34;, 2)]
[InlineData(902, 18, 50, &#34;emot@example.gov&#34;, &#34;Emma Otting&#34;, 5)]
public async Task DeleteReservationActuallyDeletes(
    int days, int hours, int minutes,
    string email, string name, int quantity)
{
    using var api = new LegacyApi();
    var at = DateTime.Today.AddDays(days).At(hours, minutes)
        .ToIso8601DateTimeString();
    var dto = Create.ReservationDto(at, email, name, quantity);
    var postResp = await api.PostReservation(dto);
    Uri address = FindReservationAddress(postResp);
 
    var deleteResp = await api.CreateClient().DeleteAsync(address);
 
    var getResp = await api.CreateClient().GetAsync(address);
    Assert.Equal(HttpStatusCode.NotFound, getResp.StatusCode);
}
</code></pre>



<p>This does, indeed, prompt you to properly implement the server-side <code>Delete</code> method.</p>



<p>Is this, however, a good idea? Is the test code easy to maintain?</p>



<p>Test code is code too, and you have to maintain it. Copy and paste is problematic in test code for the same reasons that it can be a problem in production code. If you later have to change something, you have to identify all the places that you have to edit. It’s easy to miss one, which can lead to bugs. This is true for test code as well.</p>



<h2 id="h-one-action-more-assertions">One action, more assertions</h2>



<p>Instead of copy-and-pasting the first test, why not instead <a href="https://blog.ploeh.dk/2021/12/13/backwards-compatibility-as-a-profunctor">strengthen the postconditions of the first test case</a>?</p>



<p>Just add the new assertion after the first assertion:</p>



<pre><code>[Theory]
[InlineData(884, 18, 47, &#34;c@example.net&#34;, &#34;Nick Klimenko&#34;, 2)]
[InlineData(902, 18, 50, &#34;emot@example.gov&#34;, &#34;Emma Otting&#34;, 5)]
public async Task DeleteReservation(
    int days, int hours, int minutes,
    string email, string name, int quantity)
{
    using var api = new LegacyApi();
    var at = DateTime.Today.AddDays(days).At(hours, minutes)
        .ToIso8601DateTimeString();
    var dto = Create.ReservationDto(at, email, name, quantity);
    var postResp = await api.PostReservation(dto);
    Uri address = FindReservationAddress(postResp);
 
    var deleteResp = await api.CreateClient().DeleteAsync(address);
 
    Assert.True(
        deleteResp.IsSuccessStatusCode,
        $&#34;Actual status code: {deleteResp.StatusCode}.&#34;);
    var getResp = await api.CreateClient().GetAsync(address);
    Assert.Equal(HttpStatusCode.NotFound, getResp.StatusCode);
}
</code></pre>



<p>This means that you only have a single test method to maintain instead of two duplicated methods that are almost identical.</p>



<p><em>But,</em> some of the people I’ve coached might say, <em>this test has two assertions!</em></p>



<p>Indeed. So what? It’s one single <em>test case</em>: Cancelling a reservation.</p>



<p>While cancelling a reservation is a single action, we care about multiple outcomes:</p>



<ul>
<li>The status code after a successful <code>DELETE</code> request should be in the <code>200</code> range.</li>



<li>The reservation resource should be gone.</li>
</ul>



<p>Developing the system further, we might add more behaviors that we care about. Perhaps the system should also send an email about the cancellation. We should assert that as well. It’s still the same test case, though: Successfully cancelling a reservation.</p>



<p>There’s nothing wrong with multiple assertions in a single test. The above example illustrates the benefits. A single test case can have multiple outcomes that should all be verified.</p>



<h2 id="h-origins-of-the-single-assertion-notion">Origins of the single assertion notion</h2>



<p>Where does the <em>only one assertion per test</em> notion come from? I don’t know, but I can guess.</p>



<p>The excellent book <a href="https://blog.ploeh.dk/ref/xunit-patterns"><em>xUnit Test Patterns</em></a> describes a test smell named <a href="http://xunitpatterns.com/Assertion%20Roulette.html">Assertion Roulette</a>. It describes situations where it may be difficult to determine exactly which assertion caused a test failure.</p>



<p>It looks to me as though the <em>only one assertion per test</em> ‘rule’ stems from a misreading of the Assertion Roulette description. (I may even have contributed to that myself. I don’t remember that I have, but to be honest I’ve produced so much content about unit testing over the decades that I don’t want to assume myself free of guilt.)</p>



<p><em>xUnit Test Patterns</em> describes two causes of Assertion Roulette:</p>



<ul>
<li>Eager Test: A single test verifies too much functionality.</li>



<li>Missing Assertion Message</li>
</ul>



<p>You have an Eager Test when you’re trying to exercise more than one <em>test case</em>. You may be trying to simulate a ‘session’ where a client performs many steps in order to achieve a goal. As Gerard Meszaros writes regarding the test smell, this is appropriate for manual tests, but rarely for automated tests. It’s not the number of assertions that cause problems, but that the test does too much.</p>



<p>The other cause occurs when the assertions are sufficiently similar that you can’t tell which one failed, and they have no assertion messages.</p>



<p>That’s not the case with the above example. If the <code>Assert.True</code> assertion fails, the assertion message will tell you:</p>



<pre><code>Actual status code: NotFound.
Expected: True
Actual:   False
</code></pre>



<p>Likewise, if the <code>Assert.Equal</code> assertion fails, that too will be clear:</p>



<pre><code>Assert.Equal() Failure
Expected: NotFound
Actual:   OK
</code></pre>



<p>There’s no ambiguity.</p>



<h2 id="h-one-assertion-per-test">One assertion per test</h2>



<p>Now that you understand that multiple assertions per test are fine, you may be inclined to have a ball adding assertions like there’s no tomorrow.</p>



<p>Usually, however, there’s a germ of truth in a persistent notion like the <em>one test, one assertion</em> ‘rule’. Use good judgement.</p>



<p>If you consider what an automated test is, it’s basically a predicate. It’s a statement that we expect a particular outcome. We then compare the actual outcome to the expected outcome to see if they are equal. Thus, in essence, the ideal assertion is this:</p>



<pre><code>Assert.Equal(expected, actual);</code></pre>



<p>I can’t always attain that ideal, but whenever I can, I feel deep satisfaction. Sometimes, <code>expected</code> and <code>actual</code> are primitive values like integers or strings, but they might also be complex values that represent the subset of program state that the test cares about. <a href="https://blog.ploeh.dk/2021/05/03/structural-equality-for-better-tests">As long as the objects have structural equality, such an assertion is meaningful</a>.</p>



<p>At other times I can’t quite find a way to express the verification step as succinctly as that. If I have to add another assertion or two, I’ll do that.</p>



<h2 id="h-conclusion">Conclusion</h2>



<p>There’s this notion that you’re only allowed to write one assertion per unit test. It probably originates from real concerns about badly-factored test code, but over the years the nuanced test smell <em>Assertion Roulette</em> has become garbled into a simpler, but less helpful ‘rule’.</p>



<p>That ‘rule’ often gets in the way of maintainable test code. Programmers following the ‘rule’ resort to gratuitous copying and pasting instead of adding another assertion to an existing test.</p>



<p>If adding a relevant assertion to an existing test is the best way forward, don’t let a misunderstood ‘rule’ stop you.</p><p>
    Tags: <a href="https://stackoverflow.blog/tag/testing/" rel="tag">testing</a>, <a href="https://stackoverflow.blog/tag/unit-tests/" rel="tag">unit tests</a>  </p></div></div>
  </body>
</html>
