<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html">Original</a>
    <h1>Why Racket? Why Lisp?</h1>
    
    <div id="readability-page-1" class="page"><div id="doc"><h3 anchorize="false"><a href="https://beautifulracket.com/">Beau­tiful Racket</a> / <a href="https://beautifulracket.com/#appendix">appendix</a></h3><div><p></p><p id="a_y8YCw"><em>Beau­tiful Racket</em> and <em>Prac­tical Typog­raphy</em> were made possible by a publishing system called <a href="http://pollenpub.com">Pollen.</a> I created Pollen with the <a href="http://racket-lang.org">Racket</a> program­ming language. Racket is a descen­dant of <a href="http://schemers.org/">Scheme,</a> which in turn is a descen­dant of Lisp.</p></div><div><p></p><p id="a_5IsIB">So while Racket is not Lisp (in the specific Common Lisp sense), it is <em>a</em> Lisp (in the familial sense). Its core ideas—and core virtues—are shared with Lisp. So talking about Racket means talking about Lisp.</p></div><div><p></p><p id="a_RBull">In prac­tical program­ming projects, Lisps are rare. Racket espe­cially so. Thus, before I orig­i­nally embarked on my Lisp adven­ture, I wanted to under­stand the costs &amp; bene­fits of using a Lisp. Why do Lisps have such a great repu­ta­tion, yet few users? Was I seeing some­thing everyone else missed? Or did they know some­thing I didn’t? To find out, I read what­ever I could find about Lisps, including Paul Graham’s <em><a href="http://www.paulgraham.com/hackpaint.html">Hackers &amp; Painters</a></em> and Peter Seibel’s <em><a href="http://www.gigamonkeys.com/book/">Prac­tical Common Lisp</a></em>. (OK, parts. It’s a big book.)</p></div><div><p></p><p id="a_48t3M">What I found was plenty of Lisp flat­tery from expert Lisp program­mers. (Also plenty of Lisp kvetchery from its detrac­tors.) What I didn’t find were simple, persua­sive argu­ments in its favor. So here’s why Racket was the right tool for me, and what I see as the prac­tical virtues of Lisps in general.</p></div><div><p></p><p id="a_RiEle">I didn’t study computer science in college (though I was a math major for two years, before switching to design). I’ve never held an offi­cial job as a programmer. Rather, program­ming has been a secondary skill I’ve used in my work as a web designer, type designer, and writer.</p></div><div><p></p><p id="a_wScJi">But in the last few years, I’ve spent an increasing amount of my time program­ming. This program­ming gener­ates income. So by the simplest defi­n­i­tion—does the skill make you money?—I suppose I qualify as a profes­sional programmer. And since most of my program­ming efforts are in Racket, I qualify as a profes­sional Racket programmer.</p></div><div><p></p><p id="a_HYdgT">Mind you, I’m not claiming that I’m an <em>expert</em> programmer. Among the Racket commu­nity, which is laden with computer-science PhDs &amp; profes­sors, I (have no choice but to) embrace my rela­tive inex­pe­ri­ence. Hence the title of my talk at Rack­etCon 2014: <em><a href="https://www.youtube.com/watch?v=IMz09jYOgoc">Like a Blind Squirrel in a Ferrari</a></em>.</p></div><div><p></p><p id="a_EGosM">Yet despite my limi­ta­tions as a programmer, with Racket I’ve been able to render bigger ideas into programs more quickly, and with fewer bugs, than any language I’ve used before (and there have been many—BASIC, C, C++, Perl, Java, JavaScript, Python, and others). Since I haven’t gotten a brain trans­plant recently, there must be some­thing special about Racket as a language.</p></div><div><p></p><p id="a_tI2dY">Lisp is a language most program­mers have heard of, for two reasons. First, it’s one of the oldest computer languages, in use since 1958. Second, it’s accrued a repu­ta­tion as a language for brainiacs. Orig­i­nally this repu­ta­tion arose from its asso­ci­a­tion with the field of arti­fi­cial intel­li­gence. Since then, this repu­ta­tion has been main­tained by peri­odic endorse­ments from respected program­mers (latterly, <a href="http://www.catb.org/esr/faqs/hacker-howto.html">Eric Raymond</a> and <a href="http://www.paulgraham.com/avg.html">Paul Graham</a>) and the enduring fame of the text­book used in intro­duc­tory computer-science courses at MIT, <em><a href="http://mitpress.mit.edu/sicp/">Struc­ture and Inter­pre­ta­tion of Computer Programs</a></em> (which uses Scheme, and that one I did read start to finish).</p></div><div><p></p><p id="a_SZdAL">But as main­stream program­ming tools, Lisp and its descen­dants have been largely ignored. Popu­larity of program­ming languages is tricky to measure, but here’s a simple proxy—let’s count the number of projects currently hosted on <a href="http://github.com">GitHub.</a> One could quibble about the accu­racy of this method, except that the results aren’t even close:</p></div><div><p></p><div id="a_TPyvN"><div><p></p><div id="a_uejqL1"><table id="a_uejqL" form="false"><tbody><tr><th>Language</th><th>GitHub projects</th></tr><tr><td hyphens="none">JavaScript</td><td hyphens="none">7,488,087</td></tr><tr><td hyphens="none">Java</td><td hyphens="none">6,570,575</td></tr><tr><td hyphens="none">Python</td><td hyphens="none">4,017,958</td></tr><tr><td hyphens="none">PHP</td><td hyphens="none">2,123,489</td></tr><tr><td hyphens="none">Ruby</td><td hyphens="none">1,699,590</td></tr><tr><td hyphens="none">Clojure</td><td hyphens="none">64,239</td></tr><tr><td hyphens="none">Lisp</td><td hyphens="none">17,989</td></tr><tr><td hyphens="none">Scheme</td><td hyphens="none">12,412</td></tr><tr><td hyphens="none">Racket</td><td hyphens="none">11,725</td></tr></tbody></table></div></div></div></div><div><p></p><p id="a_hlVUA"> The last four languages are Lisps, and together account for only 106,365 projects. Racket itself only accounts for a small frac­tion of this small frac­tion.</p></div><div><p></p><p id="a_vPLhS">Popular program­ming languages aren’t neces­sarily good—look what’s at the top of that list. <span onclick="this.classList.toggle(&#39;tooltip_visible&#39;)"> + <span><em>[JavaScript] has a lot of stupid in it … The good parts of [JavaScript] go back to Scheme and Self.</em></span></span> But unpop­ular languages often have fatal flaws that prevent wider adop­tion. As I was consid­ering languages, Racket had a lot to recom­mend it. But was there a fatal flaw I was over­looking? And by commit­ting to a Lisp, would I be painting myself into a corner? I wanted to under­stand the risks and bene­fits.</p></div><div><p></p><p id="a_C5upJ">I said above that Lisp flat­tery is easy to find. The problem with Lisp flat­tery is that it makes sense only to expe­ri­enced Lisp program­mers. To others—espe­cially those who are trying to decide whether to learn and use a Lisp—it just comes across as unsub­stan­ti­ated hoodoo.</p></div><div><p></p><p id="a_N9DMj">For example, in his essay <em><a href="http://www.catb.org/esr/faqs/hacker-howto.html">How to Become a Hacker,</a></em> Eric Raymond says “Lisp is worth learning for … the profound enlight­en­ment expe­ri­ence you will have when you finally get it. That expe­ri­ence will make you a better programmer for the rest of your days, even if you never actu­ally use Lisp itself a lot.” Unfor­tu­nately Raymond doesn’t follow up this claim by describing the “enlight­en­ment expe­ri­ence”, nor why it’s “profound”, nor how it will improve your program­ming skills gener­ally.</p></div><div><p></p><p id="a_qYrrl">To be fair, Raymond’s essay is not focused on Lisp. But compare <em><a href="http://www.paulgraham.com/avg.html">Beating the Aver­ages,</a></em> by Paul Graham, which is. Graham starts off by citing Raymond’s compli­ment to Lisp and seems ready to make the claim concrete.</p></div><div><p></p><p id="a_bcnMk">Instead, he breaks it into smaller chunks of flat­tery. “We knew Lisp was a really good language for writing soft­ware quickly.” Because of what char­ac­ter­is­tics? He doesn’t say, but then describes Lisp as his “secret weapon”. OK, so what’s the secret? He says “program­ming languages vary in power”. Fine, but what exactly makes Lisp more powerful?</p></div><div><p></p><p id="a_e4H1Y">Graham offers one concrete example: Lisp’s <a href="https://beautifulracket.com/appendix/glossary.html#macro"><span>macro</span></a> facility, which he describes as its ability to make “programs that write programs”. After four years using a Lisp language, I’d agree with Graham that macros are great when you need them. But for someone new to Lisp languages, they’re not neces­sarily a bread-and-butter benefit.</p></div><div><p></p><p id="a_OpsvE">I was hopeful when I opened Peter Seibel’s <em><a href="http://www.gigamonkeys.com/book">Prac­tical Common Lisp</a></em> and saw that the <a href="http://www.gigamonkeys.com/book/introduction-why-lisp.html">intro­duc­tion</a> was subti­tled “Why Lisp?” Yes, tell me! Seibel echoes Graham’s claim: “You’ll get more done, faster, using [Lisp] than you would using pretty much any other language.” OK, but how? Seibel wonders whether “I like Lisp because of some quirk in the way my brain is wired. It could even be genetic, since my dad has it too.” That’s not encour­aging to those of us outside your family. Ulti­mately, he sums up the appeal of Lisp by describing it as “the program­mable program­ming language”. But I’ve never used a program­mable program­ming language. Why should I start?</p></div><div><p></p><p id="a_fhXXs">And by the way, when do I get the speed and power you keep promising?</p></div><div><p></p><p id="a_rjm58">In short—<strong>what’s in it for me, now?</strong></p></div><div><p></p><p id="a_ZMlCV">This is the funda­mental ques­tion that Lisp advo­cates have to answer for new users. But more often, it’s side­stepped. I’m not picking on Raymond or Graham or Seibel. They’re excel­lent writers. As program­mers, they’re way out of my league. As I learn more about Lisps, I return to these arti­cles and they make more sense.</p></div><div><p></p><p id="a_NZLeJ">But these arti­cles are also emblem­atic of a general weak­ness of messaging about Lisp. I say that not as a ranking member of the Lisp commu­nity, but rather as someone who spent a lot of time seeking an answer to that funda­mental ques­tion. I never got it.</p></div><div><p></p><p id="a_zoXtC">Seibel is passing the buck when he says that to under­stand the bene­fits of Lisp, “you’re going to have to learn some Lisp and see for your­self”. Sure, this method works—using Racket for a few months finally made the bene­fits of Lisp clear to me. But it also required an invest­ment of about 100–200 hours. <span onclick="this.classList.toggle(&#39;tooltip_visible&#39;)"> + <span><span>For more on the perils of taxing reader patience, see <a href="http://practicaltypography.com/why-does-typography-matter.html">why does typog­raphy matter</a> in Prac­tical Typog­raphy.</span></span></span></p></div><div><p></p><p id="a_TWAKB">That’s asking too much. If Lisp languages are so great, then it should be possible to summa­rize their bene­fits in concise, prac­tical terms. It should be possible to demon­strate the power of Lisp <a href="https://beautifulracket.com/stacker/">in one hour</a>, not 100. If Lisp advo­cates refuse to do this, then we shouldn’t be surprised when these languages remain stuck near the bottom of the charts.</p></div><div><p></p><p id="a_fOyth">In a word, <em>expres­sive­ness:</em> the measure of how easy it is to put your ideas into code. For instance, an expres­sive language like Racket lets you write the “Hello world” program like this:</p></div><div><p></p><div id="a_oSdFX"><p>&#34;Hello world&#34;</p><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_TiikM">Whereas a less expres­sive language—I won’t name names—requires this:</p></div><div><p></p><div id="a_Msw5g"><div id="code_44" form="false" decode="exclude"><p>public class HelloWorld {</p></div><div id="a_ucZTI" form="false"><table><tbody><tr><td></td><td><div><pre><span>public</span> <span>class</span> <span>HelloWorld</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[]</span> <span>args</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>&#34;Hello world&#34;</span><span>);</span>
    <span>}</span>
<span>}</span>
</pre></div>
</td></tr></tbody></table></div><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_g2r6x">Conci­sion is valu­able, but expres­sive­ness also embodies other qual­i­ties: preci­sion, read­ability, flex­i­bility, poten­tial for gener­al­iza­tion.</p></div><div><p></p><p id="a_Vldpk3"><img src="https://beautifulracket.com/appendix/racetrack.jpg"/></p></div><div><p></p><p id="a_yhBHn">Compared to other languages, Lisps are tremen­dously expres­sive. Like the over­pow­ered Japanese motor­cycle I once owned, they go where you want, very quickly, with a minimum of input. If you’ve ridden a motor­cycle, then you know what I mean. If you haven’t, good news—Lisps are cheaper and safer.</p></div><div><p></p><p id="a_o3ilO">Here’s my ranking of the language features that offered the most imme­diate value to me, when I was a programmer new to the Lisp world. For each, I’ve noted whether it’s a feature of Racket specif­i­cally, or Lisps gener­ally.</p></div><ol><li><div><p></p><p id="a_CU5IP"><strong>Every­thing is an expres­sion.</strong> [Lisps] Most program­ming languages are a combi­na­tion of two distinct ingre­di­ents: <em><a href="https://beautifulracket.com/appendix/glossary.html#expression"><span>expres­sions</span></a></em> (things that are eval­u­ated to produce a value) and <em><a href="https://beautifulracket.com/appendix/glossary.html#statement"><span>state­ments</span></a></em> (things that denote an action). For instance, in Python, <span decode="exclude">x = 42</span> is a state­ment, and <span decode="exclude">x + 42</span> is an expres­sion.</p></div><div><p></p><p id="a_CXX6H">State­ments and expres­sions are distinct because while expres­sions can be natu­rally nested with each other, state­ments and expres­sions cannot. For instance, in Python, this is a valid expres­sion:</p></div><div><p></p><div id="a_TGk6g"><p>42 + 101</p><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_wfzwn">And so is this, substi­tuting another expres­sion for the right-hand value:</p></div><div><p></p><div id="a_e1s0B"><p>42 + (100 + 100)</p><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_5ND4C">But this is not valid:</p></div><div><p></p><div id="a_5CJlS"><div id="a_G1Z94" form="false"><table><tbody><tr><td></td><td><div><pre><span>42</span> <span>+</span> <span>if</span> <span>1</span> <span>&lt;</span> <span>0</span><span>:</span>
         <span>100</span>
     <span>else</span><span>:</span>
         <span>200</span>
</pre></div>
</td></tr></tbody></table></div><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_CJSPp">Why? Because in Python, a stan­dard <span decode="exclude">if</span> condi­tional is a state­ment, and can only be used in certain posi­tions.</p></div><div><p></p><p id="a_7dNqY">By making every­thing an expres­sion, however, Lisps remove this limi­ta­tion. Since expres­sions are nestable, anything in the language can be combined with nearly anything else. For instance, because an <a hyphens="none" href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))">if</a> condi­tional is an expres­sion, you can use it in place of a value:</p></div><div><p></p><div id="a_hvIW1"><p>(+ 42 (if (&lt; 1 0) 100 200))</p><div id="a_gYDaO" form="false"><table><tbody><tr><td></td><td><div><pre><span>(</span><span><a hyphens="none" href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))">+</a></span> <span>42</span> <span>(</span><span><a hyphens="none" href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))">if</a></span> <span>(</span><span><a hyphens="none" href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))">&lt;</a></span> <span>1</span> <span>0</span><span>)</span> <span>100</span> <span>200</span><span>))</span>
</pre></div>
</td></tr></tbody></table></div><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_K7Jhj">“But wait! Python has a ternary condi­tional expres­sion!” It doesn’t change the essen­tial point, but OK—you can indeed write this:</p></div><div><p></p><div id="a_B7HgX"><p>42 + (100 if 1 &lt; 0 else 200)</p><div id="a_ia09R" form="false"><table><tbody><tr><td></td><td><div><pre><span>42</span> <span>+</span> <span>(</span><span>100</span> <span>if</span> <span>1</span> <span>&lt;</span> <span>0</span> <span>else</span> <span>200</span><span>)</span>
</pre></div>
</td></tr></tbody></table></div><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_hfZCA">But now suppose we want to use a condi­tional in place of the oper­ator, not the right-hand value. In a Lisp, because every­thing is an expres­sion—including the oper­ator itself—this is easy:</p></div><div><p></p><div id="a_vcxCY"><p>((if (&lt; 1 0) + *) 42 100)</p><div id="a_AQJKm" form="false"><table><tbody><tr><td></td><td><div><pre><span>((</span><span><a hyphens="none" href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))">if</a></span> <span>(</span><span><a hyphens="none" href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))">&lt;</a></span> <span>1</span> <span>0</span><span>)</span> <span><a hyphens="none" href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))">+</a></span> <span><a hyphens="none" href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))">*</a></span><span>)</span> <span>42</span> <span>100</span><span>)</span>
</pre></div>
</td></tr></tbody></table></div><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_iNzei">But if you try the same thing in Python, it will raise a syntax error:</p></div><div><p></p><div id="a_Qx0Te"><p>42 (+ if 1 &lt; 0 else *) 100</p><div id="a_GEquL" form="false"><table><tbody><tr><td></td><td><div><pre><span>42</span> <span>(</span><span>+</span> <span>if</span> <span>1</span> <span>&lt;</span> <span>0</span> <span>else</span> <span>*</span><span>)</span> <span>100</span>
</pre></div>
</td></tr></tbody></table></div><p><img src="https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg" alt="copy to clipboard"/></p></div></div><div><p></p><p id="a_8QeAf">Why? Because Python oper­a­tors are not expres­sions.</p></div><div><p></p><p id="a_4G8dY">This is a synthetic example. The point is not that you’d neces­sarily want to do this, but that Lisps permit it. You don’t run into the syntactic guardrails that are lurking in other languages. As a programmer, this simpli­fies your work, because every­thing snaps together easily. It also expands your possi­bil­i­ties, because you can combine parts of the language in unusual ways if you feel like it.</p></div><div><p></p><p id="a_pMmbU">It’s similar to the basic idea behind Legos. Other building sets offer special­ized pieces that can only fit together certain ways. But by sharing uniform measure­ments, Lego bricks offer maximum possi­bil­i­ties for combi­na­tions. This ends up being more flex­ible &amp; more fun.</p></div><div><p></p><p id="a_92337">So it is with an expres­sion-based language. If you find this idea exciting, congrat­u­la­tions—you might be a Lisp programmer. (If you find this idea weird and scary, this is a good moment to <a href="https://www.youtube.com/watch?v=8CmeDu7K7f4">bail out.</a>)</p></div></li><li><div><p></p><p id="a_mKkuD"><strong>Every expres­sion is either a single value or a list.</strong> [Lisps] Single values are things like numbers and <a href="https://beautifulracket.com/explainer/stringlike-types.html">strings</a> and <a href="https://beautifulracket.com/appendix/glossary.html#hash-table"><span>hash tables</span></a>. (In Lisps, they’re some­times called <em>atoms</em>.) That part is no big deal.</p></div><div><p></p><p id="a_uAxVf">The list part, however, is a big deal. In a language like Python, the list is one data type within the language. But in Lisps, the <a href="https://beautifulracket.com/appendix/glossary.html#list"><span>list</span></a> is more like an orga­nizing prin­ciple for every­thing that happens. <span onclick="this.classList.toggle(&#39;tooltip_visible&#39;)"> + <span>The name “Lisp” is an abbre­vi­a­tion for “list processing”.</span></span> So yes, you can use the list as a data type. But a func­tion call is also a list. In fact, the source code for the func­tion is a list. Actu­ally, the rest of the program is too. Lists are every­where. <span onclick="this.classList.toggle(&#39;tooltip_visible&#39;)"> + <span>The fancy CS term for this prop­erty is <em>homoiconicity</em>.</span></span></p></div><div><p></p><p id="a_IOotS">The bene­fits of lists are similar to that of expres­sions. By bringing more of the language into a consis­tent form, more possi­bil­i­ties arise for how pieces can be combined and manip­u­lated.</p></div><div><p></p><p id="a_KRHtv">Seibel describes Lisp as a tool for getting “more done, faster”. Here, you can start to see why this is so. Lisp languages are immensely flex­ible and permis­sive in how their pieces can be connected. This means that the way you <em>think</em> about a program­ming problem can be quite close to the way you actu­ally program it. (This is also why Lisps have tradi­tion­ally excelled for proto­types and exploratory work.)</p></div><div><p></p><p id="a_kZiuM">To be fair, getting the most out of a Lisp means learning to think more in the Lisp idiom of lists and expres­sions. For that reason, I agree with Seibel—trying it your­self is the best way to be convinced of the bene­fits. As you get a feel for lists and expres­sions, it does pay increasing divi­dends throughout the language. You see how tiny lines of code can produce epic amounts of work. You also start to appre­ciate that even in a well-designed language like Python, you’re spending a lot of time shaping your ideas to fit its limi­ta­tions, like shaving an invis­ible yak.</p></div></li><li><div><p></p><p id="a_1SiMu"><strong>Func­tional program­ming.</strong> [Lisps] Yes, I know that other languages offer func­tional-program­ming features, and that Lisps aren’t consid­ered pure func­tional languages. But many program­mers haven’t been exposed to this idiom, and thus tend to under­rate its bene­fits. I know I was in that cate­gory.</p></div><div><p></p><p id="a_fqr1j"><a href="https://beautifulracket.com/appendix/glossary.html#functional-programming"><span>Func­tional program­ming</span></a> doesn’t mean program­ming with <a href="https://beautifulracket.com/appendix/glossary.html#function"><span>func­tions</span></a>. Every­body does that. Func­tional program­ming refers to a stricter style where func­tions receive certain data as input, process only that data, and return a result. In func­tional program­ming, func­tions avoid two habits common in other languages: <em><a href="https://beautifulracket.com/appendix/glossary.html#mutation"><span>muta­tion</span></a></em> (= changing data in-place rather than returning a value) and relying on <em><a href="https://beautifulracket.com/appendix/glossary.html#state"><span>state</span></a></em> (= extra context that’s not provided as input, for instance global vari­ables).</p></div><div><p></p><p id="a_p0Dw6">“Wait—I love state and muta­tion. Why would you take them away?” Because they’re false friends. They contra­dict the essen­tial concept of a func­tion, which is to encap­su­late data and algo­rithms. When a func­tion relies on state or muta­tion, it’s oper­ating outside those bound­aries. There­fore, you either take on an increasing house­keeping burden to keep track of how func­tions affect each other, or watch your program sink into a swamp of myste­rious, compli­cated bugs.</p></div><div><p></p><p id="a_N19hr">Program­ming in a func­tional style takes more effort at the outset. But it encour­ages you to struc­ture the program in a clean, compart­men­tal­ized way. This pays off imme­di­ately in programs that are easier to test and debug. It’s also more likely to lead to reusable compo­nents, since func­tions are truly inde­pen­dent.</p></div><div><p></p><p id="a_kUh8r">This bite-the-bullet aspect of func­tional program­ming is another reason why you can get “more done, faster” with a Lisp. The differ­ence between proto­type and produc­tion code often ends up being small, because you don’t take as many short­cuts at the start. The program grows and evolves more smoothly because it’s easy to change one part without causing ripple effects else­where.</p></div></li><li><div><p></p><p id="a_vmsLq"><strong>Macros.</strong> [Racket] Some Rack­e­teers quibble with this term, prefer­ring <em>syntax trans­formers</em>, because a Racket <a href="http://docs.racket-lang.org/guide/macros.html">macro</a> can be more sophis­ti­cated than the usual Common Lisp macro.</p></div><div><p></p><p id="a_KGBbb">A macro in Common Lisp is a func­tion that runs at <a href="https://beautifulracket.com/appendix/glossary.html#compile-time"><span>compile time</span></a>, accepting symbols as input and injecting them into a template to produce new code.</p></div><div><p></p><p id="a_bAV9J">Macros in Racket, on the other hand, rely on the concept of <a href="https://beautifulracket.com/appendix/glossary.html#hygiene"><span>hygiene</span></a>. They can handle Common Lisp-style macros, but also more elab­o­rate syntax rearrange­ments.</p></div><div><p></p><p id="a_Ccxeh">But forget that—what’s in it for you? As a programmer, you end up getting two bites at the apple every time you run a file: Racket runs the macros (which alter the source code), and then the source code itself.</p></div><div><p></p><p id="a_v0SLB">Unlike some­thing like the C preprocessor, which is basi­cally a sepa­rate mini-language, Racket macros are them­selves Racket func­tions that give you access to every­thing in Racket. Like lists and expres­sions, macros add another layer of expres­sive possi­bil­i­ties.</p></div></li><li><div><p></p><p id="a_pwJR1"><strong>Create new program­ming languages.</strong> [Racket] When I first read that Racket could be used to <a href="http://docs.racket-lang.org/guide/languages.html">create new languages,</a> I had two thoughts—<em>are they serious?</em> and <em>would I really want to do that?</em> The answers were <em>yes</em> and <em>oh hell yes.</em></p></div><div><p></p><p id="a_OVWAw">Between expres­sions, lists, and macros, Racket gives you a huge amount of semantic flex­i­bility. But on top of that, it also adds syntactic flex­i­bility, in that you can define a <em><a href="https://beautifulracket.com/appendix/glossary.html#reader"><span>reader</span></a></em> that converts surface syntax into stan­dard Racket <a href="https://beautifulracket.com/appendix/glossary.html#s-expression"><span>S-expres­sions</span></a>, and an <em><a href="https://beautifulracket.com/appendix/glossary.html#expander"><span>expander</span></a></em> that deter­mines the meaning of these S-expres­sions. <span onclick="this.classList.toggle(&#39;tooltip_visible&#39;)"> + <span>Paul Graham’s program­ming language <a href="http://arclanguage.org/">Arc,</a> a dialect of Lisp, was built on top of Racket.</span></span></p></div><div><p></p><p id="a_vQdh7">You can use this facility to make <a href="http://docs.racket-lang.org/ts-guide/index.html">special­ized dialects</a> of Racket. Or imple­ment <a href="http://docs.racket-lang.org/r6rs/index.html">earlier languages.</a> Or create entirely <a href="http://docs.racket-lang.org/datalog/datalog.html">new languages</a> with their own rules. You can use any of these languages within DrRacket to code new projects. (These special languages are some­times called <em><a href="https://beautifulracket.com/appendix/glossary.html#domain-specific-language"><span>domain-specific languages</span></a></em>, or <em>DSLs</em>.) Scribble is a DSL based on Racket; Pollen is a set of DSLs based on Scribble.</p></div><div><p></p><p id="a_iPw66">If you’re like most program­mers, you’ve never had a tool for making a new language, so you’ve not consid­ered it a real­istic approach to a problem. And you won’t need it all the time. But when you do, it is awesome, in both the new and old senses of that word.</p></div></li><li><div><p></p><p id="a_izkHi"><strong>Libraries &amp; docu­men­ta­tion.</strong> [Racket] This might not look like a compet­i­tive differ­en­tiator—doesn’t every program­ming language have libraries &amp; docu­men­ta­tion?</p></div><div><p></p><p id="a_91wq2">Yes, but prob­ably not like this. As a conse­quence of being used in research settings for many years—Racket’s core devel­op­ment team is made of computer-science profes­sors—Racket’s libraries &amp; docs are more like a trans­mis­sion from a highly evolved alien intel­li­gence.</p></div><div><p></p><p id="a_fNsEV">You get the essen­tials, of course: <a href="http://docs.racket-lang.org/web-server-internal/index.html">web server,</a> <a href="http://docs.racket-lang.org/json/index.html">JSON,</a> <a href="http://docs.racket-lang.org/xml/index.html">XML,</a> <a href="http://docs.racket-lang.org/draw/index.html">drawing,</a> <a href="http://docs.racket-lang.org/foreign/index.html">foreign-func­tion inter­face,</a> and so on. Then you notice pack­ages you maybe didn’t expect: <a href="http://docs.racket-lang.org/framework/index.html">GUI appli­ca­tion frame­work,</a> <a href="http://docs.racket-lang.org/plot/index.html">math plot­ting,</a> <a href="http://docs.racket-lang.org/pkg/index.html">package-distri­bu­tion system,</a> <a href="http://docs.racket-lang.org/rackunit/index.html">unit tester.</a> Beyond that, your face starts to melt a little bit: <a href="http://docs.racket-lang.org/redex/index.html">seman­tics engi­neering?</a> <a href="http://docs.racket-lang.org/future-visualizer/index.html">Futures visu­al­izer?</a></p></div><div><p></p><p id="a_XEPwB">I won’t pretend to know what all this shit does. A lot of it is over my head. But I like that. Each week I use Racket, I end up exploring a new part of the library, and learning some­thing new. As opposed to other languages that seem to kill brain cells on contact (= pretty much anything named *Script, I find). </p></div><div><p></p><p id="a_iemSL">This learning is only possible because of Racket’s truly outstanding docu­men­ta­tion. It’s vast, thor­ough, precise, and approach­able. <a href="http://docs.racket-lang.org/">See for your­self.</a> <span onclick="this.classList.toggle(&#39;tooltip_visible&#39;)"> + <span>If you don’t like the typog­raphy and layout of the docs, blame me.</span></span></p></div></li><li><div><p></p><p id="a_WVxXM"><strong>DrRacket.</strong> [Racket] Yes, I know how to use a command line. But Racket includes a cross-plat­form graph­ical IDE called <a href="http://docs.racket-lang.org/drracket/index.html">DrRacket</a> that’s pretty great. DrRacket lets you edit, run, and debug Racket source files (or any other language based on Racket—see item #9 on this list.)</p></div><div><p></p><p id="a_pR9BU">No, it doesn’t have the Ginsu-level search-and-replace facil­i­ties of some­thing like Sublime Text. But it does have helpful editing features opti­mized for Racket code (for instance, you can right-click on a symbol name and rename it throughout the file, or jump from a func­tion to its docu­men­ta­tion).</p></div><div><p></p><p id="a_k37rJ">More­over, the command line within DrRacket doesn’t just show plain text—it can show stacked frac­tions, <a href="http://docs.racket-lang.org/teachpack/2htdpimage.html">draw­ings,</a> <a href="http://docs.racket-lang.org/plot/renderer3d.html?q=plot">math plots,</a> and other unex­pected guests. If your command line does all that, by all means keep using it.</p></div></li><li><div><p></p><p id="a_dV4tA"><strong>X-expres­sions.</strong> [Racket] This choice is some­what biased by my work with Racket, which mostly involves docu­ment processing and type­set­ting. But related topics arise in most web program­ming. An X-expres­sion is a special native data struc­ture that Lisps use to repre­sent HTML and other XML-ish data.</p></div><div><p></p><p id="a_RMYQa">Well, not “special” in a Lispy sense—keeping with the usual policy, an X-expres­sion is just another list—but special in the sense that other program­ming languages don’t have it. Usually your choice is to repre­sent HTML either as a string or as a full XML tree. A string is wrong because it doesn’t capture the struc­ture of the HTML, as defined by its tags and attrib­utes. An XML tree shows this struc­ture, but conceals the sequen­tial nature of the data elements, and is unwieldy to work with.</p></div><div><p></p><p id="a_jFZub">An X-expres­sion ends up being an ideal hybrid between a string and a tree. More­over, because it’s just another list-based expres­sion in the language, you have a lot of options for processing it. Trans­lating an X-expres­sion to or from a text repre­sen­ta­tion using angle brackets is trivial and fast. (<a href="http://pkg-build.racket-lang.org/doc/pollen/second-tutorial.html#%28part._.X-expressions%29">Details.</a>)</p></div><div><p></p><p id="a_3hkxm">Given the close kinship between XML-ish data struc­tures and Lisp languages, I have no expla­na­tion why, during the Internet era, they’ve not been paired more often. They’re like peanut butter and jelly.</p></div></li><li><div><p></p><p id="a_LTLNF"><strong>Scribble.</strong> [Racket] Pollen wouldn’t have been possible without <a href="http://docs.racket-lang.org/scribble/index.html">Scribble,</a> so for me, this has been the stone-cold killer feature of Racket. But that won’t be true for everyone, so I’m moving it down the list. <span onclick="this.classList.toggle(&#39;tooltip_visible&#39;)"> + <span>Scribble was orig­i­nally created to serve as Racket’s <a href="https://www.cs.utah.edu/plt/publications/icfp09-fbf.pdf">docu­men­ta­tion language</a> (a job it does well).</span></span></p></div><div><p></p><p id="a_L1DOZ">Scribble is a dialect of Racket that inverts the ordi­nary rela­tion­ship of plain text and code: rather than embed­ding text strings within source, a Scribble docu­ment consists of code expres­sions embedded within plain text.</p></div><div><p></p><p id="a_QANop">“So it’s like an HTML template language.” Yes, in the sense that a template language allows code to be embedded in text. But also no, because a template language is usually a pidgin version of a real program­ming language. Scribble, by contrast, lets you invoke any Racket code simply by adding a command char­acter to the front. In keeping with the theme already estab­lished, this approach is both simpler (because there’s almost nothing new to learn) and more powerful (because you can invoke anything in Racket).</p></div><div><p></p><p id="a_8doUi">In its combi­na­tion of text and code, Scribble has more kinship with LaTeX. While it doesn’t have the type­set­ting facil­i­ties of LaTeX, the program­ming facil­i­ties are much better.</p></div></li><li><div><p></p><p id="a_fFuGh"><strong>Oppor­tu­ni­ties to partic­i­pate.</strong> [Racket] In theory, open-source soft­ware projects create the oppor­tu­nity for groups of devel­opers to join together and make better things in collab­o­ra­tion than they could sepa­rately.</p></div><div><p></p><p id="a_k8KIu">In prac­tice, I’ve found that they sort into a bimodal distri­bu­tion: over here, the under­doc­u­mented solo projects that sputter along fitfully (if at all); over there, the mature, popular projects that can be intim­i­dating for new contrib­u­tors.</p></div><div><p></p><p id="a_GFycS">As an open-source project, <a href="https://github.com/racket/racket">Racket</a> is posi­tioned at a happy medium. The core devel­op­ment team has been working together for years, and the commits remain <a href="https://github.com/racket/racket/commits/master">fast &amp; furious.</a> But they’re friendly scien­tists, not Shire-dwelling egotists, and remain recep­tive to improve­ments across the whole system. If you have a better idea, they’ll listen; if you code it up to their stan­dards and make a pull request, they’ll take it.</p></div><div><p></p><p id="a_eVtoV"><em>[2021 update: I <a href="https://beautifulracket.com/appendix/why-i-no-longer-contribute-to-racket.html">no longer contribute</a> to Racket due to abuse &amp; bullying by the project lead­er­ship. Everyone in the broader Racket commu­nity, however, has always been helpful and kind.]</em></p></div></li></ol><div><p></p><p id="a_3a0rj">The point of this list has been to tell you about the posi­tives. That doesn’t mean there aren’t nega­tives. The small pool of Racket program­mers means that when you hit a pothole, it’s possible no one’s ever seen your problem (= the inverse of <a href="http://en.wikipedia.org/wiki/Linus&#39;s_Law">Linus’s Law</a>). If I wanted to hire a Racket programmer, the options would be few.</p></div><div><p></p><p id="a_R1464">Still, why shouldn’t I be enthu­si­astic? What I’ve been able to accom­plish so far with Racket has been tremen­dously useful, educa­tional, and fun—the most fun I’ve had in 25+ years of program­ming.</p></div><div><p></p><p id="a_huQWU">If you think I sound like a fanboy or cult member, I can live with that. But those are people whose enthu­siasm is dispro­por­tionate to reality. Here, I’ve tried to stay out of the clouds (and the weeds) and explain the concrete, prac­tical features that have made Racket such a plea­sure in my own work.</p></div><div><p></p><p id="a_2QJAd">As always, your mileage may vary. But if I persuade a few people to <a href="http://racket-lang.org/download/">down­load Racket</a> and try it, I’ll be happy. In fact, if you try it and <em>don’t</em> like it, I invite you to <a href="https://beautifulracket.com/about-the-author.html">contact</a> me, because I’m always curious to hear dissenting opin­ions.</p></div><div><p></p><p id="a_Nn64r">I will end by taking on the big kahuna—</p></div><div><p></p><p id="a_qU7B0">I won’t claim I’ve reached the top of the moun­tain. But I can tell you what the view looks like so far.</p></div><div><p></p><p id="a_OQBfU">There’s a sense in which Lisp and its descen­dants are more than program­ming languages. They’re tools in the broader intel­lec­tual inquiry into the theory of compu­ta­tion. Lisp’s inventor, John McCarthy, orig­i­nally <a href="http://www-formal.stanford.edu/jmc/history/lisp.ps">consid­ered Lisp</a> a “way of describing computable func­tions much neater than the Turing machines”, adapting the nota­tion of <a href="https://beautifulracket.com/appendix/glossary.html#lambda-calculus"><span>lambda calculus</span></a> to do so. Racket, like­wise, has grown out of scien­tific research and explo­ration.</p></div><div><p></p><p id="a_SDy2m">The theory of compu­ta­tion is just one of many great scien­tific discov­eries in the last 100 years. But I don’t get to use quantum mechanics or rela­tivity or DNA sequencing in my daily work. When I’m program­ming, however, I’m using compu­ta­tion.</p></div><div><p></p><p id="a_jIoHk">Racket, as a Lisp dialect, has many prac­tical bene­fits. But it also opens a window onto a vast theo­ret­ical world that under­lies every­thing we can do with programs. I’m not a brainiac computer scien­tist. But some days, through that window, I can start to see a bit of what they see—some math, some science, a lot of truth, and more than a little beauty and mystery.</p></div><div><p></p><p id="a_u7mH4">Paul Graham <a href="http://www.paulgraham.com/avg.html">calls Lisp</a> a “secret weapon”. I would clarify: Lisp itself isn’t the secret weapon. Rather, <strong>you</strong> are—because a Lisp language offers you the chance to discover your poten­tial as a programmer and a thinker, and thereby raise your expec­ta­tions for what you can accom­plish.</p></div><div><p></p><p id="a_JM9I9">If that’s not a step toward enlight­en­ment, I don’t know what is.</p></div><ul><li></li></ul></div></div>
  </body>
</html>
