<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/">Original</a>
    <h1>Digital Audio Workstation Front End Development Struggles</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<article>
    
    <em>Published on: <time>21 Feb 2023</time></em>
    
    
    <h2>Table of Contents</h2>
    <ul>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#preface">Preface</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#daw-guis-are-complicated">DAW GUIs are complicated</a>
            
            <ul>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#performance-problems">Performance problems</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#gui-library-problems">GUI library problems</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#complicated-logic">Complicated logic</a>
                </li>
                
            </ul>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#my-views-on-the-rust-gui-landscape">My views on the Rust GUI landscape</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#what-actually-makes-a-gui-high-performance">What actually makes a GUI &#34;high performance&#34;?</a>
            
            <ul>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#rendering-performance">Rendering performance</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#input-handling-performance">Input handling performance</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#update-handling-performance">Update handling performance</a>
                </li>
                
            </ul>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#my-views-on-the-rust-gui-landscape-part-2">My views on the Rust GUI landscape - Part 2</a>
            
            <ul>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#the-web-based-toolkits">The web-based toolkits</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#the-immediate-mode-toolkits">The immediate-mode toolkits</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#the-elm-based-toolkits">The Elm-based toolkits</a>
                </li>
                
            </ul>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#potential-plans-moving-forward">Potential plans moving forward</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#should-i-stick-with-rust">Should I stick with Rust?</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#options-using-native-rust-libraries">Options using native Rust libraries</a>
            
            <ul>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#vizia">Vizia</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#iced">Iced</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#custom-in-house-solution">Custom in-house solution</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#non-options">Non-Options</a>
                </li>
                
            </ul>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#options-using-rust-bindings">Options using Rust bindings</a>
            
            <ul>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#gtk">GTK</a>
                </li>
                
            </ul>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#options-using-c">Options using C++</a>
            
            <ul>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#fltk">FLTK</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#juce">JUCE</a>
                </li>
                
                <li>
                    <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#qt">QT</a>
                </li>
                
            </ul>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#development-plan">Development plan?</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/daw-frontend-development-struggles/#final-thoughts">Final thoughts</a>
            
        </li>
        
    </ul>
    
    
    <hr/>

<p>I would like to write about where my head&#39;s been the past several months. If you&#39;ve noticed that Meadowlark&#39;s development has slowed down, this article explains why.</p>
<p>Essentially I&#39;ve really underestimated how difficult it would be to develop the frontend/GUI of Meadowlark. Not just with how complicated a DAW&#39;s GUI is, but also in finding a GUI library that is actually suitable for the task.</p>
<p>I want to use this blog post to do three things. First I want to highlight why this is such a hard problem. Second I want to share my thoughts on the current state of Rust&#39;s GUI library ecosystem. And third I want to share some potential paths I can take for the future of Meadowlark.</p>
<p>I would like to hear any thoughts people may have (especially on the part on potential paths for this project). I am most active in my <a href="https://discord.gg/2W3Xvc8wy4">Discord server</a> if you are interested in discussion.</p>
<hr/>

<p>Saying that Meadowlark&#39;s frontend/GUI has unusual needs (both performance needs and just features in general) is an understatement. DAWs might just have one of the most complicated GUIs out of any piece of software out there.</p>
<p>Here are some complications I&#39;ve come across, divided into three parts.</p>
<h2 id="performance-problems">Performance problems</h2>
<ul>
<li>DAWs have a <em>lot</em> of toolbars and panels (browser panel, timeline panel, piano roll panel, fx rack panel, mixer panel, audio editor panel, automation editor panel, settings panel, etc.).</li>
<li>Some widgets like decibel meters and other visualizers are constantly being animated, meaning the GUI library needs to efficiently redraw the screen every frame.
<ul>
<li>In addition, visualizers can be expensive to render on the CPU (especially spectrograms/spectrometers). Ideally you should use custom shaders to render them on the GPU.</li>
</ul>
</li>
<li>Clips on the timeline are notoriously expensive to render. There needs to be some way to cache the contents of clips into a texture (Either directly or by making use of the GUI library&#39;s &#34;damage tracking&#34; which I&#39;ll get into later.)
<ul>
<li>Audio clips are the biggest culprit, because rendering waveforms requires the CPU to first do a linear search through the source material for peak values, and then render the waveform pixel-by-pixel (or even better use custom shaders to send commands to the GPU).</li>
<li>Automation clips can contain a bunch of bezier curves, which are slow to render.</li>
<li>Piano roll clips can contain lots of little rectangles in order to display a &#34;minimap&#34; of the MIDI notes inside of it.</li>
<li>On top of all this, clips can contain text labels which can also be expensive to render.</li>
<li>The fact that a timeline is zoom-able also makes it harder to cache the rendering of clips. If the timeline changed its zoom level, all visible clips pretty much have to redraw all of their contents.</li>
</ul>
</li>
<li>Piano rolls can also be expensive to render if there is a bunch of MIDI notes, especially if there are text labels on the notes.</li>
<li>If the user clicks on a folder in a sample browser containing hundreds or even thousands of files, allocating a label widget for each file in the browser list will be very expensive. Something like the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/book/list_widgets.html">list factory in GTK</a> is needed here.</li>
<li>We want to reserve as much CPU as possible for the actual audio processing. Ideally the GUI shouldn&#39;t take up more than one or two CPU threads.</li>
<li>On some platforms, we also need to make sure there&#39;s actually enough CPU left for 3rd-party plugins to render their GUIs.</li>
</ul>
<h2 id="gui-library-problems">GUI library problems</h2>
<ul>
<li>DAWs have unconventional widgets and  layouts. For example, not only does a mixer track contain custom widgets like knobs, sliders, and decibel meters, but all of those widgets are not positioned according to a traditional layout scheme like a list, grid, or a tree.
<ul>
<li>This is especially true if the DAW has a horizontal FX rack like I plan with Meadowlark.</li>
</ul>
</li>
<li>DAWs don&#39;t follow traditional/recommended design standards or &#34;human interface guidelines&#34;. They have a bunch of custom styling to cram all of that information onto the screen (and to actually look like an audio application).
<ul>
<li>This custom styling and layout also makes it harder to support localization.</li>
</ul>
</li>
<li>Ideally I want to support loading user-generated themes.</li>
<li>Preferably the DAW should let the user pop out panels into another window (or at least support a preset number of multi-window workspaces). Multi-window setups are harder to deal with in code.</li>
<li>The timeline and piano roll are not simple &#34;scroll areas&#34;. They can be zoomed in and out, meaning there needs to be some kind of custom positioning and sizing logic for clips and MIDI notes.</li>
<li>When the timeline is zoomed in very far and/or a clip is very long, the resulting width of the clip in pixels can be very, very long. This could cause issues if the UI library tries to render the whole thing (especially if the clip has expensive contents). So you need to make sure only the visible part of the clip is actually processed and rendered.</li>
<li>In order to deal with really long audio clips, you need to stream the file from disk. This makes rendering their contents on the timeline much more complicated because now you are dealing with an async operation.</li>
<li>Some widgets like knobs and sliders need to be able to listen to raw mouse input data as opposed to absolute mouse coordinates (or even better is the ability to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">pointer locking</a>). Otherwise if the user&#39;s mouse hits the edge of a screen or moves outside the window while dragging one of these widgets, they will stop working.
<ul>
<li>This is especially true with a horizontal FX rack where there are bunch of knobs and sliders near the bottom of the screen.</li>
</ul>
</li>
<li>There needs to be some way to easily input the value of a knob/slider parameter using a keyboard. Ideally in some sort-of pop-up text input box.</li>
<li>There needs to be extensive support for custom keyboard shortcuts. This includes shortcuts that could potentially conflict with accessibility features such as using the spacebar to start/stop the transport.
<ul>
<li>In addition, the UI library needs to support keyboard shortcuts even when a widget/window isn&#39;t focused. For example pressing spacebar to start/stop the transport while inside a 3rd-party plugin window.</li>
</ul>
</li>
<li>There needs to be some way to access the raw window handles in order to host 3rd-party plugin GUIs.</li>
</ul>
<h2 id="complicated-logic">Complicated logic</h2>
<ul>
<li>There are three separate states that must be kept in sync: The state of the save file (which I call the &#34;source state&#34;), the state of the GUI, and the state of the backend. These have to be separate states because:
<ul>
<li>The source state, the backend, and the GUI sometimes want different units. For example, the start of an audio clip on the timeline may be in units of beats in the source state, units of samples in the backend, and units of pixels in the GUI. So units must somehow be efficiently converted from the source state the the backend/GUI state.</li>
<li>The backend process runs on a realtime thread, so you cannot just use simple mutexes to read the source state. Some other method must be used like lock-free message channels or <a href="https://docs.rs/basedrop/0.1.2/basedrop/struct.SharedCell.html">garbage-collected clone-on-write smart pointers</a>.</li>
<li>There are situations where the state of the GUI/backend can be different from the source state. For example when the user is in the process of dragging the position of a clip on the timeline, the clip needs to move in the GUI, but the change shouldn&#39;t actually be committed into the source state or backend state until the user lets go of the mouse button. Otherwise it would cause expensive updates to happen every single frame the user is dragging the clip.
<ul>
<li>Another example is when the backend can&#39;t find a plugin listed in the source state. In this case, both the backend and the GUI will have a &#34;missing plugin&#34; placeholder. But this shouldn&#39;t cause the original state of the plugin to be overwritten.</li>
</ul>
</li>
</ul>
</li>
<li>There can be a lot of drag-and-drop targets which can be complicated to implement. For example:
<ul>
<li>dragging samples/midi/automation from the browser onto the timeline</li>
<li>dragging samples/midi/automation from the browser onto a track header to add it to the timeline</li>
<li>dragging samples/midi/automation from the browser into an empty portion of the timeline to add a new track</li>
<li>dragging samples/presets from the browser onto a plugin in the horizontal FX rack</li>
<li>dragging a modulation source onto a parameter in the horizontal FX rack</li>
<li>dragging a plugin in the horizontal FX rack into a slot in a container device</li>
<li>dragging a plugin in the horizontal FX rack between two other plugins to reorder them</li>
<li>dragging a plugin from the horizontal FX rack onto a track header to move that plugin to that track</li>
<li>dragging a track header/mixer track into an area between two other tracks to reorder them</li>
<li>dragging a clip/multiple clips onto a different lane to move them to another track</li>
</ul>
</li>
<li>The code to interact with the timeline can be very complicated because of all the different operations you can perform. For example:
<ul>
<li>panning/scrolling the timeline (horizontally and vertically)</li>
<li>zooming the timeline</li>
<li>clicking to set the position of the playhead</li>
<li>clicking/dragging to set the position of the loop points</li>
<li>adding/removing/dragging time markers</li>
<li>adding/removing/resizing/reordering tracks/lanes</li>
<li>using the pencil tool to draw new clips onto the timeline</li>
<li>selecting multiple clips with Ctrl+Click or the lasso tool</li>
<li>dragging one/multiple clips horizontally to change their position (and snapping their positions to the grid unless Shift is held down)</li>
<li>using the arrow keys to nudge the position of one/multiple clips</li>
<li>dragging the edge of one/multiple clips to change their lengths</li>
<li>dragging a handle on an audio clip to adjust the crossfade</li>
<li>adding/removing nodes on an automation clip</li>
<li>using the lasso tool to select multiple nodes on an automation clip</li>
<li>dragging one/multiple nodes on an automation clips (and snapping their positions to the grid unless Shift is held down)</li>
<li>adjusting the curvature between nodes on an automation clip</li>
<li>slicing a clip</li>
<li>copy/pasting single/multiple clips (and possibly on a different track)</li>
<li>duplicating clips (and making sure they are grid-aligned)</li>
<li>dragging one/multiple clips up/down to change the track they are on</li>
<li>reversing/stretching/pitch-shifting and audio clip</li>
<li>audio clips can have even more complicated maneuvers such as time stretching just a selected portion of a clip in order to correct the timing of a recorded performance</li>
<li>dragging an audio file/automation clip/MIDI clip from the browser onto the timeline</li>
</ul>
</li>
<li>Undo/Redo logic can get complicated:
<ul>
<li>Like I mentioned above, there are a lot of operations that can be done with tracks, clips, MIDI notes, plugins, etc.</li>
<li>The undo/redo operations need to perform as expected when manipulating multiple items at the same time. For example, if you select and bunch of clips and drag their positions, hitting the undo button should move back all of those clips at once and not one at a time.</li>
<li>Not all operations are undo-able, especially operations dealing with 3rd-party plugins since plugins are in charge of their own state, not the host.</li>
</ul>
</li>
<li>There are some more complexities when it comes to hosting 3rd-party plugin windows which I won&#39;t get into here.</li>
</ul>
<hr/>

<p><a href="https://www.youtube.com/watch?v=tKbV6BpH-C8">This video</a> I watched recently brings up a good point about software development (Albeit the video is bit heavy-handed with its message and I might be taking the original message a bit out of context, but I think the point still stands). In the video, there is this chart:</p>
<p><img src="http://jimkang.com/images/daw-frontend-development-struggles/performance-velocity-adaptability.png" alt="performance-velocity-adaptability chart"/></p>
<p>Here are what each each of the ends of the triangle mean:</p>
<ul>
<li>&#34;Performance&#34; literally means how well the application performs.</li>
<li>&#34;Velocity&#34; means how fast an application gets developed. For example, did the app take a few weeks to develop, or several months?</li>
<li>&#34;Adaptability&#34; means how easily features can be changed/added/removed from the application in the future (another good word for this is &#34;maintainability&#34;).</li>
</ul>
<p>The idea of this chart is that you can&#39;t have all three:</p>
<ul>
<li>If you focus too much on performance, it will take much longer to actually create the app and it will be harder to change/add/remove features in the future.</li>
<li>If you focus too much on adaptability, you are potentially over-engineering and over-abstracting your code architecture to the point where it both hurts performance and it eats into the time actually developing the app.</li>
<li>If you focus too much on velocity (as in taking a quick n&#39; dirty path to get something out as fast as possible), not only will the application be unoptimized, but it will be harder to actually fix any problems you have in the future, possibly requiring you to rewrite the code later.</li>
</ul>
<p>Now this brings me to my current views on Rust GUI libraries (and other modern GUI libraries in general, not just Rust). It is my observation that modern GUI toolkits tend to focus too hard on the velocity/adaptability end of the triangle and not the performance end.</p>
<p>Now I totally get why this is. Every developer wants to have a GUI library that is easy to use and gives results quickly. Every developer wants a GUI that is not a nightmare to maintain. And the clever architecture of Rust GUI libraries definitely delivers on those fronts (and at a level that has probably not been done before).</p>
<p>However, I think Rust GUI libraries seriously mistake and/or neglect what it actually takes to have a GUI that has good performance when scaled up to a large project. Of course large and complicated GUIs may not be a target use-case for some or all of these libraries. My point is more to highlight why they won&#39;t quite work for Meadowlark.</p>
<p>Now first I should mention that I am definitely aware of premature optimizations, and I am aware that I&#39;m stressing a lot about performance before actually creating the GUI. However, that&#39;s not what I&#39;m worried about. What I&#39;m worried about is the GUI library I end up using not even allowing me to do optimizations in the first place if I needed to (and I will very likely need to).</p>
<p>So to start, I should explain what it actually takes for a GUI to be &#34;high performance&#34;.</p>
<hr/>

<h2 id="rendering-performance">Rendering performance</h2>
<p>The first aspect that makes a &#34;high performance&#34; GUI is quickly rendering the contents onto the screen. While this has definitely gotten easier in the modern age of GPU-acceleration, I don&#39;t believe GPU-acceleration alone is a silver bullet:</p>
<ul>
<li>The CPU still has to package all of the commands into a buffer to send to the GPU. If there are thousands of UI elements on the screen, that is a lot of commands for the CPU to package (especially when using OpenGL).</li>
<li>Text looks awful when rendered on the GPU. This is just due to the nature of how complex text rendering is. Best case is to have the CPU render each glyph into a texture atlas, and then have the GPU sample each glyph one at a time from this atlas. Even then, this approach has its footguns.</li>
<li>GPU power is not free. Having the GPU render all of those elements on all of those pixels every frame can chug a lot of battery. GPUs are more optimized for dealing with triangles and textures, and not so much for dealing with vector graphics. While consuming a lot of GPU power is fine for a video game, it&#39;s not as fine when it&#39;s an app meant to open for hours at a time.</li>
</ul>
<p>So I believe it&#39;s still important to do what&#39;s called &#34;damage tracking&#34;, where <em>only</em> the widgets that have changed get redrawn. This is usually done by clearing a rectangular region around a widget, filling the background back into that cleared region, and then redrawing the widget. Though this does definitely get complicated when the &#34;background&#34; is not a flat color, but is instead a hierarchy of other (possibly partially-transparent) widgets.</p>
<blockquote>
<p>I also learned recently that damage tracking is not just an optimization on the application-level, but on the operating system level as well. Every OS has some sort of &#34;damage region&#34; concept built into the OS&#39;s compositor system, which allows the OS to more efficiently blit small rectangles onto the final screen output instead of needing to blit the entire application&#39;s window onto the final output. </p>
</blockquote>
<h2 id="input-handling-performance">Input handling performance</h2>
<p>The second aspect is efficiently handling input events. If a GUI library sends every mouse/keyboard/animation event to every widget, then that can get really expensive when there are a bunch of nodes in the widget tree.</p>
<p>Iterating a tree structure is not the most efficient to begin with. But there is a bigger problem called &#34;pointer chasing&#34;, which happens when you try to excessively dereference a bunch of pointers at once (in this case we dereference each node/widget pointer in order to call its <code>on_event()</code> method).</p>
<p>A good first step is to only send events to the widgets that actually ask for it (although a lot of widgets want both mouse and keyboard input). Mouse input can be optimized by skipping all child nodes if the cursor isn&#39;t contained within the bounds of the parent node (however, you then need a system to handle drag operations since those can happen outside the bounds of the widget being dragged).</p>
<h2 id="update-handling-performance">Update handling performance</h2>
<p>The third aspect is efficiently updating the widget tree. When an input event causes a widget to change, the GUI system needs to not only tell the rendering system that the widget has changed and it should be re-rendered, but it also needs to check if any other widgets have changed as a side effect. For example, if the width of a widget changed, that could cause the position of other widgets next to it to change.</p>
<hr/>

<p>In my experience, every Rust GUI library fails in one or more of those categories listed in the section above.</p>
<p>But I don&#39;t believe this to be due to the developer&#39;s lack of caring or lack of skill. I think this is an issue rooted in the very architecture that Rust GUI libraries tend to use.</p>
<p>I have found that Rust GUI library architectures (and a lot of modern GUI architectures in general, not just Rust) tend to fall into three categories.</p>

<p>The first category is web-based GUI solutions such as <a href="https://github.com/electron/electron">electron</a> and <a href="https://github.com/tauri-apps/tauri">tauri</a>. I understand why these solutions are so popular, it&#39;s because they fall square into the &#34;velocity&#34; corner of the triangle. Do you know HTML/CSS or have employees that do? Congratulations, you can create desktop apps!</p>
<p>However, it&#39;s no secret that I&#39;m quite against this industry trend of &#34;let&#39;s use web tech for everything!&#34;:</p>
<ul>
<li>Both Javascript and the DOM are <em>slow</em>, there&#39;s no changing that. Webassembly is definitely a good step forward, however that still doesn&#39;t fix the DOM problem.</li>
<li>Web engines are also expensive in terms of memory. Not just RAM, but also in terms of file size (especially apps built with electron). I&#39;m sure a lot of users are tired of every app having a minimum size of around 50-100MB.</li>
<li>Both Javascript and the DOM model make it harder to create maintainable codebases using things like abstractions (thus it&#39;s not very &#34;adaptable&#34;). Again webassembly helps here, but the root problem is still there.</li>
<li>It takes resources away from the much-needed innovation in native GUI toolkits.</li>
<li>On a slightly political note, web tech is all but dominated by Chromium (and therefore Google). Using web tech for everything gives Google a lot more power over the software industry as a whole, and it should be obvious why this is potentially a bad thing.</li>
</ul>

<p>The second category is immediate-mode GUI solutions such as <a href="https://github.com/emilk/egui">egui</a>, <a href="https://github.com/ocornut/imgui">imgui</a>, and <a href="https://github.com/makepad/makepad">makepad</a>. This architecture is both very quick and easy to use, while also having a high degree of adaptability due to the fact that &#34;the GUI is a function of the data&#34;.</p>
<p>However, this is definitely at the cost of performance. Whenever any part of the data changes, it reconstructs/restyles/relayouts the entire widget tree and redraws the entire screen widget-by-widget. While there can be some clever caching optimizations under the hood, the architecture is still flawed in this regard. This performance is not a problem if the app is small or the app already redraws every frame like a video game. But it is a problem when the GUI is as complicated as a DAW GUI.</p>

<p>An architecture that is very popular in the Rust ecosystem is the <a href="https://dennisreimann.de/articles/elm-architecture-overview.html">Elm architecture</a> (or some variation of the architecture). This is because it gets around the problem of shared mutability in Rust, while also having a very high degree of adaptability/maintainability due to its data/event-driven nature. GUI toolkits that use a variant of this architecture include <a href="https://github.com/iced-rs/iced">Iced</a>, <a href="https://github.com/vizia/vizia">Vizia</a>, <a href="https://github.com/linebender/druid">Druid</a> <a href="https://github.com/antoyo/relm">Relm</a>, and even Apple&#39;s <a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a> to some extent.</p>
<p>However, the Elm architecture still has drawbacks in terms of performance. While performance is definitely better than immediate-mode (because they are what is called &#34;retained-mode&#34;), these kind of architectures still do a lot of work in order to detect changes to the state of the application. This is mainly to do with their data-driven nature. Because any part of the widget tree can depend on any part of the input data (this input data also includes things like layout and styling), the GUI library has to somehow check the entire input data and the entire widget tree for changes. Each library has a different method for doing this, with varying levels of performance.</p>
<p>Still, I should mention that the alternative to a data-driven approach is to have the user manually update the widget tree themselves. This is definitely more time consuming and more error-prone, so I understand why the industry is gravitating away from it. And I don&#39;t dislike the concept. In theory it has the potential to have &#34;good enough&#34; performance at a large scale (of course the actual real-world performance is a different question).</p>
<p>However, there&#39;s a much bigger problem with these Rust GUI libraries in particular, which is that none of them actually do any kind of damage tracking for rendering. They redraw the whole screen widget-by-widget every frame, relying heavily on GPU-acceleration in order to make performance not turn into a slideshow. (Although this situation might change for one library which I&#39;ll get into later.)</p>
<hr/>

<p>So all this brings me to my current situation of figuring out the best path forward for Meadowlark. This is the part where I would like to hear your thoughts if you have any.</p>
<p>I think there are three main questions to answer here: Should I stick with Rust for Meadowlark&#39;s frontend, what GUI library should I use, and what method is best to actually go about developing the frontend?</p>
<hr/>

<p>This first question is definitely a tough one. Meadowlark has been rooted in Rust since the beginning (even starting out as the &#34;Rusty DAW project&#34;).</p>
<p>However, from my experience I&#39;m just not sure anymore that the Rust GUI ecosystem is quite there yet (or even that it will be &#34;there&#34; in a year or two). GUI is just so complicated that I&#39;m not sure that passion-driven projects alone are enough to push it to the level of mature C++ libraries. And frankly, I find it harder to get motivated to work on Meadowlark when the underlying technology is unproven and experimental.</p>
<p>But on the flip side, maybe my concerns are unwarranted and Rust is still the best way to go? I don&#39;t know. Either way, I&#39;ll list the potential options there are for both Rust and C++ to get a better idea on answering this question:</p>
<blockquote>
<p>To be clear, with whatever path I choose, I still want to use Rust for the backend as much as possible (namely in my <a href="https://github.com/MeadowlarkDAW/dropseed">dropseed</a> engine). </p>
</blockquote>
<hr/>

<p>Here are the native-Rust options I think have any potential to fit my use case.</p>
<h2 id="vizia">Vizia</h2>
<p>I&#39;ve used <a href="https://github.com/vizia/vizia">Vizia</a> for the latest attempt at Meadowlark&#39;s GUI. It still has potential and I may still decide to stick with it, but I do have quite a few concerns with it.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Creating the non-timeline portions of the GUI was a breeze with this library.</li>
<li>I am close with the developer on Discord, and he has expressed interest in adapting Vizia to cover the needs of Meadowlark.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Vizia&#39;s performance is currently quite poor. It currently excessively iterates the widget tree to search for changes, and it redraws the whole screen on every change. While various optimizations are on the roadmap (including a form of damage-tracking), a part of me is still concerned with how well it will turn out in practice.</li>
<li>The data-binding system has proven to be a bit awkward when the application state is very complicated. In order to make it work, I need to create a &#34;GUI state&#34; that is separate from my source state, which means that I still need to manually keep this GUI state in sync with my source state. So for my use case, I&#39;ve found there is not much benefit to the data-binding system over just being able to manually update the widget tree.</li>
<li>It&#39;s declarative architecture makes it difficult to put wildly different widgets into a list. Namely a horizontal list of inline plugin GUIs on the horizontal FX rack.</li>
<li>There is currently a noticeable amount of input latency when using vsync. This could just be the nature of <a href="https://github.com/femtovg/femtovg">femtovg</a> or even just OpenGL in general, but it would be a bummer if it could never be fixed.</li>
<li>Vizia is still missing a lot of features I need such as multi-window support, custom shaders, global keyboard shortcuts, localization features, list factories for long lists of items, and pointer locking. Again, these are on the roadmap, but that leads me to my last concern:</li>
<li>Vizia is mainly worked on by just one person, and there is no funding behind it. It&#39;s not that I doubt the developer&#39;s abilities, but just that it&#39;s a risk to consider for the longevity of the project.</li>
</ul>
<h2 id="iced">Iced</h2>
<p><a href="https://github.com/iced-rs/iced">Iced</a> was actually my original gateway for getting into Rust in the first place. However, I have some serious doubts about its performance. It&#39;s possible that performance can be improved in future updates to Iced, but it&#39;s currently a gamble.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Iced is by far the most mature native Rust GUI library.</li>
<li>It gets financial backing from a few companies (albeit fairly small companies).</li>
<li>It recently got adoption by System76 who are also interested in accelerating its development.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>On every update cycle, Iced reconstructs an entire abstract representation of the widget tree, diffs it with the previous widget tree, and then applies the necessary updates. While Iced touts that constructing this abstract tree and diffing it &#34;should be cheap&#34;, I&#39;m skeptical of how well it scales to a very large GUI.</li>
<li>Iced doesn&#39;t use damage tracking for rendering. It&#39;s possible this could change in the future, but again it&#39;s a gamble.</li>
<li>It&#39;s still missing a few key features such as proper multi-window support.</li>
</ul>
<h2 id="custom-in-house-solution">Custom in-house solution</h2>
<p>For a while I was working on a concept called <a href="https://github.com/MeadowlarkDAW/firewheel">Firewheel</a>. The main idea was that it&#39;s a low-level GUI library where the user manually updates the widget tree, manually lays out the widgets (with a simple but powerful &#34;anchor&#34; system), and manually assigns widgets to layers to most optimally take advantage of render regions.</p>
<p>However, developing an in-house toolkit most definitely falls into the &#34;performance&#34; corner of the triangle chart.</p>
<p>But as a counter-argument, because it&#39;s so low-level, maybe it won&#39;t actually take <em>that</em> much time to complete? A custom solution would also have the advantage of being in full control of the feature set.</p>
<p>Then again, it could just be too much work. I&#39;d like to hear other people&#39;s opinions on this.</p>
<h2 id="non-options">Non-Options</h2>
<p>Here I&#39;ll list other existing native Rust GUI libraries and why I&#39;m not considering them.</p>
<ul>
<li><a href="https://github.com/linebender/druid">Druid</a>
<ul>
<li>It&#39;s no longer being updated and is in maintenance mode.</li>
<li>Its performance isn&#39;t much better (or possibly even worse) than Iced.</li>
<li>It doesn&#39;t use damage tracking for rendering.</li>
</ul>
</li>
<li><a href="https://github.com/slint-ui/slint">slint</a>
<ul>
<li>It prioritizes using declarative markup files to construct the GUI. While I <em>think</em> you can use it in a non-declarative way, I&#39;m not sure how well this works in practice.</li>
<li>Its support for custom widgets is quite limited.</li>
<li>Desktop platform support is currently unfinished, and I&#39;m not sure it will even end up supporting all the features I need.</li>
<li>Its GPU-based renderer currently doesn&#39;t use damage tracking, only its CPU-based renderer does.</li>
</ul>
</li>
<li><a href="https://github.com/ocornut/imgui">imgui</a>
<ul>
<li>immediate-mode</li>
</ul>
</li>
<li><a href="https://github.com/makepad/makepad">makepad</a>
<ul>
<li>immediate-mode</li>
</ul>
</li>
<li><a href="https://github.com/tauri-apps/tauri">tauri</a>
<ul>
<li>web-based</li>
</ul>
</li>
<li><a href="https://github.com/redox-os/orbtk">OrbTK</a>
<ul>
<li>No longer maintained</li>
</ul>
</li>
</ul>
<hr/>

<p>There is only one I think has any potential to fit my use case.</p>
<h2 id="gtk">GTK</h2>
<p>I&#39;ve used <a href="https://github.com/gtk-rs/gtk4-rs">gtk-rs</a> in a previous attempt at Meadowlark&#39;s GUI. They are bindings to the <a href="https://www.gtk.org/">GTK</a> GUI library which is written in C (and is used by a lot of Linux applications). But again I have some concerns with it:</p>
<p><strong>Pros</strong></p>
<ul>
<li>There is already a DAW that uses GTK4 called <a href="https://www.zrythm.org/en/index.html">Zrythm</a> (albeit the developer uses C not Rust).
<ul>
<li>Ardour also uses GTK (although it&#39;s a very old and heavily modified version of GTK2).</li>
</ul>
</li>
<li>It uses damage tracking for its rendering and is quite efficient even on complex GUIs.</li>
<li>GTK is battle-tested and has a lot of developers behind it.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>THE BIGGEST deal breaker for me was that it doesn&#39;t have a way for widgets to listen to relative mouse movements as opposed to absolute mouse coordinates. Currently if you are dragging a knob/slider and the mouse hits the edge of the screen (or even outside a floating window), it will stop working. This might not be a problem for Zrythm since its only parameters are mixer tracks with large sliders, but for Meadowlark I want a horizontal FX rack like in Bitwig/Ableton. Horizontal FX racks have a lot of knobs/sliders near the bottom of the screen.
<ul>
<li>It seems like adding this feature to GTK would be difficult. I might be able to do it myself given enough time, but even then will those changes be accepted upstream? And even then I&#39;ll have to wait for the Rust bindings to catch up.</li>
</ul>
</li>
<li>CSS styling is finicky.</li>
<li>Support for Windows/Mac definitely takes a backseat to Linux support.
<ul>
<li>I&#39;ve run into an issue where text on Windows is straight up messed up even in the default demo. It seems to be getting a fix, but still that&#39;s several months after I posted the issue.</li>
</ul>
</li>
<li>I&#39;m also just unsure about the direction that the Gnome team is taking with GTK as a whole (especially the whole controversy with libadwaita). This is a minor nitpick, but still.</li>
</ul>
<blockquote>
<p>Another potential solution I&#39;ll throw out there is maybe we just don&#39;t have knobs in Meadowlark, only sliders? It&#39;s not ideal, but considering that relative mouse movement support is the only real deal breaker I have with GTK, maybe it&#39;s an acceptable tradeoff?</p>
</blockquote>
<hr/>

<p>Unfortunately using Rust bindings to these are either nonexistent or are practically unusable due to the incompatible philosophies between Rust and C++. So this means I would need to write Meadowlark&#39;s frontend in C++ if I go with one of these options.</p>
<h2 id="fltk">FLTK</h2>
<p><strong>Pros</strong></p>
<ul>
<li>Very efficient.</li>
<li>Excellent support for custom OpenGL shaders.</li>
<li>The (possibly abandoned?) <a href="http://non.tuxfamily.org/">Non DAW</a> project uses it (or at least a modified version of it).</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>I haven&#39;t yet looked into if it actually has all the features I need. Still, it seems quite promising.</li>
</ul>
<h2 id="juce">JUCE</h2>
<p><strong>Pros</strong></p>
<ul>
<li>It&#39;s already touted as a GUI library for audio applications.</li>
<li>It also has a lot of other audio-related features such as connecting to system devices, meaning we wouldn&#39;t need to develop our own solutions such as <a href="https://github.com/MeadowlarkDAW/rainout">rainout</a>.</li>
<li>It also has features like loading audio files and streaming them from disk, meaning we wouldn&#39;t need our own solutions such as <a href="https://github.com/MeadowlarkDAW/creek">creek</a> and <a href="https://github.com/MeadowlarkDAW/pcm-loader">pcm-loader</a> (although those two are already pretty much complete).</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Its performance can be quite poor even for a CPU-rendered library. Still, it uses damage tracking, and there are workarounds to greatly improve performance in areas.</li>
<li>It&#39;s owned by PACE Anti-Piracy Inc. 🤢</li>
</ul>
<h2 id="qt">QT</h2>
<p><strong>Pros</strong></p>
<ul>
<li>No shortage of features.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Its signal architecture can lead to buggy and hard-to-maintain spaghetti code (there are some ways to make it more manageable though).</li>
<li>Its styling system is finicky. It could be tricky to support user-generated themes.</li>
</ul>
<hr/>

<p>The final question I want an answer to is what is the best way to go about actually developing Meadowlark&#39;s frontend? By this I mean who actually does the work of developing it?</p>
<p>No matter what GUI library I choose, developing the frontend is going to take a lot of work due to how complex the logic is.</p>
<p>A part of me is starting to feel like maybe I&#39;ve bitten off more than I can chew. If I were a company I would just hire a frontend developer, but Meadowlark is currently unfunded so I don&#39;t have that luxury (well there&#39;s a tiny bit of donations coming in, but definitely not enough to hire anyone).</p>
<p>Now this being an open source project, maybe I could leverage volunteers? However, I&#39;m not sure how well volunteer-driven work will pan out considering just how complex the frontend is. I&#39;m not sure any amount of drafting design documents (which also take quite a bit of work to create) would fix that issue. Ideally I would love if there was one or two people who could dedicated a large amount of time to the frontend. However, I haven&#39;t found anyone who is able or willing to do this amount of work for free, and I of course don&#39;t blame them for that.</p>
<blockquote>
<p>And if you are wondering how I am currently financially supporting myself, I am fortunate enough to have supportive parents to fall back on. I&#39;m currently living at their house on a farm. </p>
</blockquote>
<p>Another reason I brought up potentially using C++ is that developers (especially those with experience in the audio industry or the desktop GUI industry) are much harder to come by. If I go with a Rust library, not only will volunteers/employees need to learn Rust, but also the experimental GUI library itself (and Rust GUI libraries tend to have some pretty foreign concepts).</p>
<p>But on the flip-side, maybe the frontend is something I can handle by myself? Maybe I&#39;m just doubting my own abilities too much? I&#39;m not sure. In the end I just want to make sure that I&#39;m allocating my time and resources wisely.</p>
<p>Still, if I do this solo, I think creating some design documents is probably a good idea just to help wrap my head around the complexity.</p>
<hr/>

<p>After writing this, I&#39;m now kind-of leaning towards the idea of using the Rust bindings to GTK and only having sliders in Meadowlark. It&#39;s probably possible to do what Tracktion Waveform does for some of its sliders, which is to show a large pop-up slider when dragging a small slider in order to save space while still allowing for a large degree of control.</p>
<p>But of course I would like to hear any thoughts and ideas you may have. I am most active in my <a href="https://discord.gg/2W3Xvc8wy4">Discord server</a> if you are interested in discussion.</p>

</article>

    </div></div>
  </body>
</html>
