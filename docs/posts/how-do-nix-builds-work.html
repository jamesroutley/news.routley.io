<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/03/03/how-do-nix-builds-work-/">Original</a>
    <h1>How do Nix builds work?</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>Hello! For some reason after the last <a href="https://jvns.ca/blog/2023/02/28/some-notes-on-using-nix/">nix post</a> I got nerdsniped by trying to understand how Nix builds
work under the hood, so here’s a quick exploration I did today. There are probably some mistakes in here.</p>

<p>I started by <a href="https://social.jvns.ca/@b0rk/109954253779465018">complaining on Mastodon</a>:</p>

<blockquote>
<p>are there any guides to nix that start from the bottom up (for example
starting with <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/setup.sh">this bash script</a>
and then working up the layers of abstraction) instead of from the top down?</p>

<p>all of the guides I’ve seen start by describing the nix programming language
or other abstractions, and I’d love to see a guide that starts with concepts I
already understand like compiler flags, linker flags, Makefiles, environment
variables, and bash scripts</p>
</blockquote>

<p>Ross Light wrote a great blog post in response called <a href="https://www.zombiezen.com/blog/2023/03/connecting-bash-to-nix/">Connecting Bash to Nix</a>, that shows how to compile a basic C program without using most of Nix’s standard machinery.</p>

<p>I wanted to take this a tiny bit further and compile a slightly more
complicated C program.</p>

<h3 id="the-goal-compile-a-c-program-without-using-nix-s-standard-machinery">the goal: compile a C program, without using Nix’s standard machinery</h3>

<p>Our goal is to compile a C program called <code>paperjam</code>. This is a real C program
that wasn’t in the Nix repository already. I already figured out how to
compile it in <a href="https://jvns.ca/blog/2023/02/28/some-notes-on-using-nix/">this post</a> by copying and pasting a bunch of stuff I didn’t understand, but this time I wanted to do
it in a more principled way where I actually understand more of the steps.</p>

<p>We’re going to avoid using most of Nix’s helpers for compiling C programs.</p>

<p>The plan is to start with an almost empty build script, and then resolve errors
until we have a working build.</p>

<h3 id="first-what-s-a-derivation">first: what’s a derivation?</h3>

<p>I said that we weren’t going to talk about too many Nix abstractions (and we won’t!), but understanding what a derivation is really helped me.</p>

<p>Everything I read about Nix talks about derivations all the time, but I was
really struggling to figure out what a derivation <em>is</em>. It turns out that <code>derivation</code>
is a function in the Nix language. But not just any function! The whole point of the Nix language seems to be to
to call this function. The <a href="https://nixos.org/manual/nix/stable/language/derivations.html">official documentation for the <code>derivation</code> function</a> is actually extremely clear. Here’s what I took away:</p>

<p><code>derivation</code> takes a bunch of keys and values as input. There are 3 required keys:</p>

<ol>
<li><code>system</code>: the system, for example <code>x86_64-darwin</code></li>
<li><code>name</code>: the name of the package you’re building</li>
<li><code>builder</code>: a program (usually a bash script) that runs the build</li>
</ol>

<p>Every other key is an arbitrary string that gets passed as an environment
variable to the <code>builder</code> shell script.</p>

<h3 id="derivations-automatically-build-all-their-inputs">derivations automatically build all their inputs</h3>

<p>A derivation doesn’t just call a shell script though! Let’s say I reference another derivation called <code>pkgs.qpdf</code> in my script.</p>

<p>Nix will:</p>

<ul>
<li>automatically build the <code>qpdf</code> package</li>
<li>put the resulting output directory somewhere like <code>/nix/store/4garxzr1rpdfahf374i9p9fbxnx56519-qpdf-11.1.0</code></li>
<li>expand <code>pkgs.qpdf</code> into that output directory (as a string), so that I can reference it in my build script</li>
</ul>

<p>The derivation function does some other things (described in the
<a href="https://nixos.org/manual/nix/stable/language/derivations.html">documentation</a>), but “it builds all of its inputs” is all we really need to know
for now.</p>

<h3 id="step-1-write-a-derivation-file">step 1: write a derivation file</h3>

<p>Let’s write a very simple build script and call the <code>derivation</code> function. These don’t work yet,
but I found it pretty fun to go through all the errors, fix them one at a time,
and learn a little more about how Nix works by fixing them.</p>

<p>Here’s the build script (<code>build_paperjam.sh</code>). This just unpacks the tarball and runs <code>make install</code>.</p>

<pre><code>#!/bin/bash

tar -xf &#34;$SOURCE&#34;
cd paperjam-1.2 
make install
</code></pre>

<p>And here’s the Nix code calling the <code>derivation</code> function (in <code>paperjam.nix</code>). This calls the core <code>derivation</code> function, without too much magic.</p>

<pre><code>let pkgs = import (fetchTarball &#34;https://github.com/NixOS/nixpkgs/archive/4d2b37a84fad1091b9de401eb450aae66f1a741e.tar.gz&#34;) {};

builtins.derivation {
  name = &#34;paperjam-fake&#34;;
  builder = ./build-paperjam.sh;
  system = builtins.currentSystem;

  SOURCE = pkgs.fetchurl {
    url = &#34;https://mj.ucw.cz/download/linux/paperjam-1.2.tar.gz&#34;;
    hash = &#34;sha256-0AziT7ROICTEPKaA4Ub1B8NtIfLmxRXriW7coRxDpQ0&#34;;
  };

}
</code></pre>

<p>The main things here are:</p>

<ul>
<li><code>fetchurl</code> (which downloads an url and puts the path in to the <code>SOURCE</code> environment variable)</li>
<li><code>pkgs</code> (which lets us depend on other Nix packages from the central repository). I don’t totally understand this but I’m already in a pretty deep rabbit hole so we’re going to leave that for now.</li>
</ul>

<p><code>SOURCE</code> evaluates to a string – it’s the path to the downloaded source tarball.</p>

<h3 id="problem-1-tar-command-not-found">problem 1: <code>tar: command not found</code></h3>

<p>Nix needs you to declare all the dependencies for your builds. It forces this
by removing your <code>PATH</code> environment variable so that you have no binaries in
your PATH at all.</p>

<p>This is pretty easy to fix: we just need to edit our <code>PATH</code>.</p>

<p>I added this to <code>paperjam.nix</code> to get <code>tar</code>, <code>gzip</code>, and <code>make</code>:</p>

<pre><code>  PATH = &#34;${pkgs.gzip}/bin:${pkgs.gnutar}/bin:${pkgs.gnumake}/bin&#34;;
</code></pre>

<h3 id="problem-2-we-need-a-compiler">problem 2: we need a compiler</h3>

<p>Next, we had this error:</p>

<pre><code>g++ -O2 -Wall -Wextra -Wno-parentheses -std=gnu++11 -g -DVERSION=&#39;&#34;1.2&#34;&#39; -DYEAR=&#39;&#34;2022&#34;&#39; -DBUILD_DATE=&#39;&#34;&#34;&#39; -DBUILD_COMMIT=&#39;&#34;&#34;&#39;   -c -o paperjam.o paperjam.cc
make: g++: No such file or directory
</code></pre>

<p>So we need to put a compiler in our PATH. For some reason I felt like using <code>clang++</code> to compile, not <code>g++</code>. To do that I need to make 2 changes to <code>paperjam.nix</code>:</p>

<ol>
<li>Add the line <code>CXX=&#34;clang++&#34;;</code></li>
<li>Add <code>${pkgs.clang}/bin</code> to my <code>PATH</code></li>
</ol>



<p>The next error was:</p>

<pre><code> &gt; ./pdf-tools.h:13:10: fatal error: &#39;qpdf/QPDF.hh&#39; file not found
 &gt; #include &lt;qpdf/QPDF.hh&gt;
</code></pre>

<p>Makes sense: everything is isolated, so it can’t access my system header files.
Figuring out how to handle this was a little more confusing though.</p>

<p>It turns out that the way Nix handles header files is that it has a shell
script wrapper around <code>clang</code>. So when you run <code>clang++</code>, you’re actually
running a shell script.</p>

<p>On my system, the <code>clang++</code> wrapper script was at <code>/nix/store/d929v59l9a3iakvjccqpfqckqa0vflyc-clang-wrapper-11.1.0/bin/clang++</code>. I searched that file for <code>LDFLAGS</code> and found that it uses 2 environment variables:</p>

<ol>
<li><code>NIX_LDFLAGS_aarch64_apple_darwin</code></li>
<li><code>NIX_CFLAGS_COMPILE_aarch64_apple_darwin</code></li>
</ol>

<p>So I figured I needed to put all the arguments to clang in the <code>NIX_CFLAGS</code> variable and all the linker arguments in <code>NIX_LDFLAGS</code>. Great! Let’s do that.</p>

<p>I added these 2 lines to my <code>paperjam.nix</code>, to link the <code>libpaper</code> and <code>qpdf</code> libraries:</p>

<pre><code>NIX_LDFLAGS_aarch64_apple_darwin = &#34;-L ${pkgs.qpdf}/lib   -L ${pkgs.libpaper}/lib&#34;;
NIX_CFLAGS_COMPILE_aarch64_apple_darwin = &#34;-isystem ${pkgs.qpdf}/include   -isystem ${pkgs.libpaper}/include&#34;;
</code></pre>

<p>And that worked!</p>

<h3 id="problem-4-missing-c-abi">problem 4: missing <code>c++abi</code></h3>

<p>The next error was:</p>

<pre><code>&gt; ld: library not found for -lc++abi
</code></pre>

<p>Not sure what this means, but I searched for “abi” in the Nix packages and fixed it by adding <code>-L ${pkgs.libcxxabi}/lib</code> to my <code>NIX_LDFLAGS</code> environment variable.</p>

<h3 id="problem-5-missing-iconv">problem 5: missing iconv</h3>

<p>Here’s the next error:</p>

<pre><code>&gt; Undefined symbols for architecture arm64:
&gt;   &#34;_iconv&#34;, referenced from: ...
</code></pre>

<p>I started by adding <code>-L ${pkgs.libiconv}/lib</code> to my <code>NIX_LDFLAGS</code> environment variable, but that didn’t fix it. Then I spent a while going around in circles and being confused.</p>

<p>I eventually figured out how to fix this by taking a working version of the <code>paperjam</code> build that I’d made before
and editing my <code>clang++</code> wrapper file to print out all of its environment
variables. The <code>LDFLAGS</code> environment variable in the working version was different from mine: it had <code>-liconv</code> in it.</p>

<p>So I added <code>-liconv</code> to <code>NIX_LDFLAGS</code> as well and that fixed it.</p>

<h3 id="why-doesn-t-the-original-makefile-have-liconv">why doesn’t the original Makefile have <code>-liconv</code>?</h3>

<p>I was a bit puzzled by this <code>-liconv</code> thing though: the original Makefile links
in <code>libqpdf</code> and <code>libpaper</code> by passing <code>-lqpdf -lpaper</code>. So why doesn’t it link in iconv, if it requires the
iconv library?</p>

<p>I think the reason for this is that the original Makefile assumed that you were
running on Linux and using glibc, and glibc includes these iconv functions by
default. But I guess Mac OS libc doesn’t include iconv, so we need to
explicitly set the linker flag <code>-liconv</code> to add the iconv library.</p>

<h3 id="problem-6-missing-codesign-allocate">problem 6: missing <code>codesign_allocate</code></h3>

<p>Time for the next error:</p>

<pre><code>libc++abi: terminating with uncaught exception of type std::runtime_error: Failed to spawn codesign_allocate: No such file or directory
</code></pre>

<p>I guess this is some kind of Mac code signing thing. I used <code>find /nix/store -name codesign_allocate</code> to find <code>codesign_allocate</code> on my system. It’s at
<code>/nix/store/a17dwfwqj5ry734zfv3k1f5n37s4wxns-cctools-binutils-darwin-973.0.1/bin/codesign_allocate</code>.</p>

<p>But this doesn’t tell us what the package is called – we need to be able to refer to it as <code>${pkgs.XXXXXXX}</code> and <code>${pkgs.cctools-binutils-darwin}</code> doesn’t work.</p>

<p>I couldn’t figure out a way go from a Nix folder to the name of the package, but I ended up poking around and finding out that it was called <code>pkgs.darwin.cctools</code>.</p>

<p>So I added <code>${pkgs.darwin.cctools}/bin</code> to the <code>PATH</code>.</p>

<h3 id="problem-7-missing-a2x">problem 7: missing <code>a2x</code></h3>

<p>Easy, just add <code>${pkgs.asciidoc}/bin</code> to the <code>PATH</code>.</p>

<h4 id="problem-8-missing-install">problem 8: missing <code>install</code></h4>

<pre><code>make: install: No such file or directory
</code></pre>

<p>Apparently <code>install</code> is a program? This turns out to be in <code>coreutils</code>, so we add <code>${pkgs.coreutils}/bin</code> to the <code>PATH</code>. Adding <code>coreutils</code> also fixes some other warnings I was seeing about missing commands like <code>date</code>.</p>

<h3 id="problem-9-can-t-create-usr-local-bin-paperjam">problem 9: can’t create /usr/local/bin/paperjam</h3>

<p>This took me a little while to figure out because I’m not very familiar with make. The Makefile has a <code>PREFIX</code> of <code>/usr/local</code>, but we want it to be the program’s output directory in <code>/nix/store/</code></p>

<p>I edited the <code>build-paperjam.sh</code> shell script to say:</p>

<pre><code>make install PREFIX=&#34;$out&#34;
</code></pre>

<p>and everything worked! Hooray!</p>

<h3 id="our-final-configuration">our final configuration</h3>

<p>Here’s the final <code>paperjam.nix</code>. It’s not so different from what we started with – we just added 4 environment variables.</p>

<pre><code>let pkgs = import (fetchTarball &#34;https://github.com/NixOS/nixpkgs/archive/ae8bdd2de4c23b239b5a771501641d2ef5e027d0.tar.gz&#34;) {};
in

builtins.derivation {
  name = &#34;paperjam-fake&#34;;
  builder = ./build-paperjam.sh;
  system = builtins.currentSystem;

  SOURCE = pkgs.fetchurl {
    url = &#34;https://mj.ucw.cz/download/linux/paperjam-1.2.tar.gz&#34;;
    hash = &#34;sha256-0AziT7ROICTEPKaA4Ub1B8NtIfLmxRXriW7coRxDpQ0&#34;;
  };

  CXX=&#34;clang++&#34;;
  PATH = &#34;${pkgs.gzip}/bin:${pkgs.gnutar}/bin:${pkgs.gnumake}/bin:${pkgs.clang}/bin:${pkgs.darwin.cctools}/bin:${pkgs.asciidoc}/bin:${pkgs.coreutils}/bin:${pkgs.bash}/bin&#34;;
  NIX_LDFLAGS_aarch64_apple_darwin = &#34;-L ${pkgs.qpdf}/lib   -L ${pkgs.libpaper}/lib -L ${pkgs.libcxxabi}/lib -liconv -L ${pkgs.libiconv}/lib &#34;;
  NIX_CFLAGS_COMPILE_aarch64_apple_darwin = &#34;-isystem ${pkgs.qpdf}/include   -isystem ${pkgs.libpaper}/include&#34;;
}
</code></pre>

<p>And here’s the final <code>build-paperjam.sh</code> build script. Here we just needed to edit the <code>make install</code> line to set the <code>PREFIX</code>.</p>

<pre><code>#!/bin/bash

tar -xf &#34;$SOURCE&#34;
cd paperjam-1.2
make install PREFIX=&#34;$out&#34;
</code></pre>

<h3 id="let-s-look-at-our-compiled-derivation">let’s look at our compiled derivation!</h3>

<p>Now that we understand this configuration a little better, let’s talk about
what <code>nix-build</code> is doing a little more.</p>

<p>Behind the scenes, <code>nix-build paperjam.nix</code> actually runs <code>nix-instantiate</code> and <code>nix-store --realize</code>:</p>

<pre><code>$ nix-instantiate paperjam.nix
/nix/store/xp8kibpll55s0bm40wlpip51y7wnpfs0-paperjam-fake.drv
$ nix-store --realize /nix/store/xp8kibpll55s0bm40wlpip51y7wnpfs0-paperjam-fake.drv
</code></pre>

<p>I think what this means is that <code>paperjam.nix</code> get compiled to some
intermediate representation (also called a derivation?), and then the Nix
runtime takes over and is in charge of actually running the build scripts.</p>

<p>We can look at this <code>.drv</code> intermediate representation with <code>nix show-derivation</code></p>

<pre><code>{
  &#34;/nix/store/xp8kibpll55s0bm40wlpip51y7wnpfs0-paperjam-fake.drv&#34;: {
    &#34;outputs&#34;: { &#34;out&#34;: { &#34;path&#34;: &#34;/nix/store/bcnyqizvcysqc1vy382wfx015mmwn3bd-paperjam-fake&#34; }
    },
    &#34;inputSrcs&#34;: [ &#34;/nix/store/pbjj91f0qr8g14k58m744wdl9yvr2f5k-build-paperjam.sh&#34; ],
    &#34;inputDrvs&#34;: {
      &#34;/nix/store/38sikqcggyishxbgi2xnyrdsnq928gqx-asciidoc-10.2.0.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/3llc749f9pn0amlb9vgwsi22hin7kmz4-libcxxabi-11.1.0.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/a8ny8lrbpyn15wdxk3v89f4bdr08a38a-libpaper-1.1.28.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/d888pj9lll12s5qx11v850g1vd4h3vxq-cctools-port-973.0.1.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/gkpdv7xl39x9yxch0wjarq19mmv7j1pm-bash-5.2-p15.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/hwx16m7hmkp2rcik8h67nnyjp52zj849-gnutar-1.34.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/kqqwffajj24fmagxqps3bjcbrglbdryg-gzip-1.12.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/lnrxa45bza18dk8qgqjayqb65ilfvq2n-qpdf-11.2.0.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/rx7a5401h44dqsasl5g80fl25jqqih8r-gnumake-4.4.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/sx8blaza5822y51abdp3353xkdcbkpkb-coreutils-9.1.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/v3b7r7a8ipbyg9wifcqisf5vpy0c66cs-clang-wrapper-11.1.0.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/wglagz34w1jnhr4xrfdk0g2jghbk104z-paperjam-1.2.tar.gz.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/y9mb7lgqiy38fbi53m5564bx8pl1arkj-libiconv-50.drv&#34;: [ &#34;out&#34; ]
    },
    &#34;system&#34;: &#34;aarch64-darwin&#34;,
    &#34;builder&#34;: &#34;/nix/store/pbjj91f0qr8g14k58m744wdl9yvr2f5k-build-paperjam.sh&#34;,
    &#34;args&#34;: [],
    &#34;env&#34;: {
      &#34;CXX&#34;: &#34;clang++&#34;,
      &#34;NIX_CFLAGS_COMPILE_aarch64_apple_darwin&#34;: &#34;-isystem /nix/store/h25d99pd3zln95viaybdfynfq82r2dqy-qpdf-11.2.0/include   -isystem /nix/store/agxp1hx267qk1x79dl4jk1l5cg79izv1-libpaper-1.1.28/include&#34;,
      &#34;NIX_LDFLAGS_aarch64_apple_darwin&#34;: &#34;-L /nix/store/h25d99pd3zln95viaybdfynfq82r2dqy-qpdf-11.2.0/lib   -L /nix/store/agxp1hx267qk1x79dl4jk1l5cg79izv1-libpaper-1.1.28/lib -L /nix/store/awkb9g93ci2qy8yg5jl0zxw46f3xnvgv-libcxxabi-11.1.0/lib -liconv -L /nix/store/nmphpbjn8hhq7brwi9bw41m7l05i636h-libiconv-50/lib &#34;,
      &#34;PATH&#34;: &#34;/nix/store/90cqrp3nxbcihkx4vswj5wh85x5klaga-gzip-1.12/bin:/nix/store/siv9312sgiqwsjrdvj8lx0mr3dsj3nf5-gnutar-1.34/bin:/nix/store/yy3fdgrshcblwx0cfp76nmmi24szw89q-gnumake-4.4/bin:/nix/store/cqag9fv2gia03nzcsaygan8fw1ggdf4g-clang-wrapper-11.1.0/bin:/nix/store/f16id36r9xxi50mgra55p7cf7ra0x96k-cctools-port-973.0.1/bin:/nix/store/x873pgpwqxkmyn35jvvfj48ccqav7fip-asciidoc-10.2.0/bin:/nix/store/vhivi799z583h2kf1b8lrr72h4h3vfcx-coreutils-9.1/bin:/nix/store/0q1jfjlwr4vig9cz7lnb5il9rg0y1n84-bash-5.2-p15/bin&#34;,
      &#34;SOURCE&#34;: &#34;/nix/store/6d2fcw88d9by4fz5xa9gdpbln73dlhdk-paperjam-1.2.tar.gz&#34;,
      &#34;builder&#34;: &#34;/nix/store/pbjj91f0qr8g14k58m744wdl9yvr2f5k-build-paperjam.sh&#34;,
      &#34;name&#34;: &#34;paperjam-fake&#34;,
      &#34;out&#34;: &#34;/nix/store/bcnyqizvcysqc1vy382wfx015mmwn3bd-paperjam-fake&#34;,
      &#34;system&#34;: &#34;aarch64-darwin&#34;
    }
  }
}
</code></pre>

<p>This feels surprisingly easy to understand – you can see that there are a
bunch of environment variables, our bash script, and the paths to our inputs.</p>

<h3 id="the-compilation-helpers-we-re-not-using-stdenv">the compilation helpers we’re not using: <code>stdenv</code></h3>

<p>Normally when you build a package with Nix, you don’t do all of this stuff
yourself. Instead, you use a helper called <code>stdenv</code>, which seems to have two parts:</p>

<ol>
<li>a function called <code>stdenv.mkDerivation</code> which takes some arguments and generates a bunch of environment variables (it seems to be <a href="https://nixos.org/manual/nixpkgs/stable/#chap-stdenv">documented here</a>)</li>
<li>a 1600-line bash build script (<a href="https://github.com/NixOS/nixpkgs/blob/fc2bfe1cdc910104e6df52c5dc449e8f855c66b7/pkgs/stdenv/generic/setup.sh">setup.sh</a>) that consumes those environment variables. This is like our <code>build-paperjam.sh</code>, but much more generalized.</li>
</ol>

<p>Together, these two tools:</p>

<ul>
<li>add <code>LDFLAGS</code> automatically for each C library you depend on</li>
<li>add <code>CFLAGS</code> automatically so that you can get your header files</li>
<li>run <code>make</code></li>
<li>depend on clang and coreutils and bash and other core utilities so that you don’t need to add them yourself</li>
<li>set <code>system</code> to your current system</li>
<li>let you easily add custom bash code to run at various phases of your build</li>
<li>maybe also manage versions somehow? Not sure about this one.</li>
</ul>

<p>and probably lots more useful things I don’t know about yet</p>

<h3 id="let-s-look-at-the-derivation-for-jq">let’s look at the derivation for <code>jq</code></h3>

<p>Let’s look at one more compiled derivation, for <code>jq</code>. This is quite long but there
are some interesting things in here. I wanted to look at this because I wanted to see what a more typical derivation generated by <code>stdenv.mkDerivation</code> looked like.</p>

<pre><code>$ nix show-derivation /nix/store/q9cw5rp0ibpl6h4i2qaq0vdjn4pyms3p-jq-1.6.drv
{
  &#34;/nix/store/q9cw5rp0ibpl6h4i2qaq0vdjn4pyms3p-jq-1.6.drv&#34;: {
    &#34;outputs&#34;: {
      &#34;bin&#34;: { &#34;path&#34;: &#34;/nix/store/vabn35a2m2qmfi9cbym4z50bwq94fdzm-jq-1.6-bin&#34; },
      &#34;dev&#34;: { &#34;path&#34;: &#34;/nix/store/akda158i8gr0v0w397lwanxns8yrqldy-jq-1.6-dev&#34; },
      &#34;doc&#34;: { &#34;path&#34;: &#34;/nix/store/6qimafz8q88l90jwrzciwc27zhjwawcl-jq-1.6-doc&#34; },
      &#34;lib&#34;: { &#34;path&#34;: &#34;/nix/store/3wzlsin34l1cs70ljdy69q9296jnvnas-jq-1.6-lib&#34; },
      &#34;man&#34;: { &#34;path&#34;: &#34;/nix/store/dl1xf9w928jai5hvm5s9ds35l0m26m0k-jq-1.6-man&#34; },
      &#34;out&#34;: { &#34;path&#34;: &#34;/nix/store/ivzm5rrr7riwvgy2xcjhss6lz55qylnb-jq-1.6&#34; }
    },
    &#34;inputSrcs&#34;: [
      &#34;/nix/store/6xg259477c90a229xwmb53pdfkn6ig3g-default-builder.sh&#34;,
      &#34;/nix/store/jd98q1h1rxz5iqd5xs8k8gw9zw941lj6-fix-tests-when-building-without-regex-supports.patch&#34;
    ],
    &#34;inputDrvs&#34;: {
      &#34;/nix/store/0lbzkxz56yhn4gv5z0sskzzdlwzkcff8-autoreconf-hook.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/6wh5w7hkarfcx6fxsdclmlx097xsimmg-jq-1.6.tar.gz.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/87a32xgqw85rxr1fx3c5j86y177hr9sr-oniguruma-6.9.8.drv&#34;: [ &#34;dev&#34; ],
      &#34;/nix/store/gkpdv7xl39x9yxch0wjarq19mmv7j1pm-bash-5.2-p15.drv&#34;: [ &#34;out&#34; ],
      &#34;/nix/store/xn1mjk78ly9wia23yvnsyw35q1mz4jqh-stdenv-darwin.drv&#34;: [ &#34;out&#34; ]
    },
    &#34;system&#34;: &#34;aarch64-darwin&#34;,
    &#34;builder&#34;: &#34;/nix/store/0q1jfjlwr4vig9cz7lnb5il9rg0y1n84-bash-5.2-p15/bin/bash&#34;,
    &#34;args&#34;: [
      &#34;-e&#34;,
      &#34;/nix/store/6xg259477c90a229xwmb53pdfkn6ig3g-default-builder.sh&#34;
    ],
    &#34;env&#34;: {
      &#34;__darwinAllowLocalNetworking&#34;: &#34;&#34;,
      &#34;__impureHostDeps&#34;: &#34;/bin/sh /usr/lib/libSystem.B.dylib /usr/lib/system/libunc.dylib /dev/zero /dev/random /dev/urandom /bin/sh&#34;,
      &#34;__propagatedImpureHostDeps&#34;: &#34;&#34;,
      &#34;__propagatedSandboxProfile&#34;: &#34;&#34;,
      &#34;__sandboxProfile&#34;: &#34;&#34;,
      &#34;__structuredAttrs&#34;: &#34;&#34;,
      &#34;bin&#34;: &#34;/nix/store/vabn35a2m2qmfi9cbym4z50bwq94fdzm-jq-1.6-bin&#34;,
      &#34;buildInputs&#34;: &#34;/nix/store/xfnl6xqbvnpacx8hw9d99ca4mly9kp0h-oniguruma-6.9.8-dev&#34;,
      &#34;builder&#34;: &#34;/nix/store/0q1jfjlwr4vig9cz7lnb5il9rg0y1n84-bash-5.2-p15/bin/bash&#34;,
      &#34;cmakeFlags&#34;: &#34;&#34;,
      &#34;configureFlags&#34;: &#34;--bindir=${bin}/bin --sbindir=${bin}/bin --datadir=${doc}/share --mandir=${man}/share/man&#34;,
      &#34;depsBuildBuild&#34;: &#34;&#34;,
      &#34;depsBuildBuildPropagated&#34;: &#34;&#34;,
      &#34;depsBuildTarget&#34;: &#34;&#34;,
      &#34;depsBuildTargetPropagated&#34;: &#34;&#34;,
      &#34;depsHostHost&#34;: &#34;&#34;,
      &#34;depsHostHostPropagated&#34;: &#34;&#34;,
      &#34;depsTargetTarget&#34;: &#34;&#34;,
      &#34;depsTargetTargetPropagated&#34;: &#34;&#34;,
      &#34;dev&#34;: &#34;/nix/store/akda158i8gr0v0w397lwanxns8yrqldy-jq-1.6-dev&#34;,
      &#34;doCheck&#34;: &#34;&#34;,
      &#34;doInstallCheck&#34;: &#34;1&#34;,
      &#34;doc&#34;: &#34;/nix/store/6qimafz8q88l90jwrzciwc27zhjwawcl-jq-1.6-doc&#34;,
      &#34;installCheckTarget&#34;: &#34;check&#34;,
      &#34;lib&#34;: &#34;/nix/store/3wzlsin34l1cs70ljdy69q9296jnvnas-jq-1.6-lib&#34;,
      &#34;man&#34;: &#34;/nix/store/dl1xf9w928jai5hvm5s9ds35l0m26m0k-jq-1.6-man&#34;,
      &#34;mesonFlags&#34;: &#34;&#34;,
      &#34;name&#34;: &#34;jq-1.6&#34;,
      &#34;nativeBuildInputs&#34;: &#34;/nix/store/ni9k35b9llfc3hys8nv5qsipw8pfy1ln-autoreconf-hook&#34;,
      &#34;out&#34;: &#34;/nix/store/ivzm5rrr7riwvgy2xcjhss6lz55qylnb-jq-1.6&#34;,
      &#34;outputs&#34;: &#34;bin doc man dev lib out&#34;,
      &#34;patches&#34;: &#34;/nix/store/jd98q1h1rxz5iqd5xs8k8gw9zw941lj6-fix-tests-when-building-without-regex-supports.patch&#34;,
      &#34;pname&#34;: &#34;jq&#34;,
      &#34;postInstallCheck&#34;: &#34;$bin/bin/jq --help &gt;/dev/null\n$bin/bin/jq -r &#39;.values[1]&#39; &lt;&lt;&lt; &#39;{\&#34;values\&#34;:[\&#34;hello\&#34;,\&#34;world\&#34;]}&#39; | grep &#39;^world$&#39; &gt; /dev/null\n&#34;,
      &#34;preBuild&#34;: &#34;rm -r ./modules/oniguruma\n&#34;,
      &#34;preConfigure&#34;: &#34;echo \&#34;#!/bin/sh\&#34; &gt; scripts/version\necho \&#34;echo 1.6\&#34; &gt;&gt; scripts/version\npatchShebangs scripts/version\n&#34;,
      &#34;propagatedBuildInputs&#34;: &#34;&#34;,
      &#34;propagatedNativeBuildInputs&#34;: &#34;&#34;,
      &#34;src&#34;: &#34;/nix/store/ggjlgjx2fw29lngbnvwaqr6hiz1qhy8g-jq-1.6.tar.gz&#34;,
      &#34;stdenv&#34;: &#34;/nix/store/qrz2mnb2gsnzmw2pqax693daxh5hsgap-stdenv-darwin&#34;,
      &#34;strictDeps&#34;: &#34;&#34;,
      &#34;system&#34;: &#34;aarch64-darwin&#34;,
      &#34;version&#34;: &#34;1.6&#34;
    }
  }
}
</code></pre>

<p>I thought it was interesting that some of the environment variables in here are actually bash scripts themselves – for example the <code>postInstallCheck</code> environment variable is a bash script.
Those bash script environment variables are <code>eval</code>ed in the main bash script (you can <a href="https://github.com/NixOS/nixpkgs/blob/fc2bfe1cdc910104e6df52c5dc449e8f855c66b7/pkgs/stdenv/generic/setup.sh#L61-L74">see that happening in setup.sh here</a>)</p>

<p>The <code>postInstallCheck</code> environment variable in this particular derivation starts like this:</p>

<pre><code>$bin/bin/jq --help &gt;/dev/null
$bin/bin/jq -r &#39;.values[1]&#39; &lt;&lt;&lt; &#39;{&#34;values&#34;:[&#34;hello&#34;,&#34;world&#34;]}&#39; | grep &#39;^world$&#39; &gt; /dev/null
</code></pre>

<p>I guess this is a test to make sure that <code>jq</code> installed correctly.</p>

<h3 id="finally-clean-up">finally: clean up</h3>

<p>All of my compiler experiments used about 3GB of disk space, but <code>nix-collect-garbage</code> cleaned up all of it.</p>

<h3 id="let-s-recap-the-process">let’s recap the process!</h3>

<p>I feel like I understand Nix a bit better after going through this. I still
don’t feel very motivated to learn the Nix language, but now I have some
idea of what Nix programs are actually doing under the hood!</p>

<p>My understanding is:</p>

<ol>
<li>First, <code>.nix</code> files get compiled into a <code>.drv</code> file, which is mostly a bunch of inputs and outputs and environment variables. This is where the Nix language stops being relevant.</li>
<li>Then all the environment variables get passed to a build script, which is in charge of doing the actual build</li>
<li>In the Nix standard environment (<code>stdenv</code>), some of those environment variables are themselves bash code, which gets <code>eval</code>ed by the big build script <code>setup.sh</code></li>
</ol>

<p>That’s all! I probably made some mistakes in here, but this was kind of a fun rabbit hole.</p>

</div></div>
  </body>
</html>
