<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sive.rs/com">Original</a>
    <h1>Find a good available .com domain</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<article>
<header>


<small>2022-06-08</small>
</header>

<p>
	If you need a new domain name, you want a <strong>.com</strong>, and you don’t want to type random ideas into a registrar search, here’s a way to do it.
</p>
<h2>
	Download the list of all registered .com domains
</h2>
<p>
	First, apply for access to the zone file, using ICANN’s Centralized Zone Data Service (CZDS) at <a href="https://czds.icann.org/">https://czds.icann.org/</a>.
	It’s free, but takes a few days to get approved.
	<a href="https://www.verisign.com/en_US/channel-resources/domain-registry-products/zone-file/index.xhtml">Read more about it here</a>.
</p><p>
	Once approved, they email you a password to log in and download the file called <strong>com.txt.gz</strong>.
</p>
<code><pre>$ du -hs com.txt.gz # 4.6GB compressed
4.6G    com.txt.gz
$ gunzip com.txt.gz # uncompress and wait
$ du -hs com.txt
23.0G   com.txt     # 23 gigs uncompressed
$ wc -l com.txt
404261754 com.txt   # 404 million lines
</pre></code>

<h2>
	Extract the unique names
</h2>
<p>
	<strong>com.txt</strong> has 404 million lines like this:
</p>
<code><pre>zombahomes.com. 172800  in      ns      ns2.tierra.net.
zombai.com.     172800  in      ns      ns1.parkingcrew.net.
zombai.com.     172800  in      ns      ns2.parkingcrew.net.
zombaid.com.    172800  in      ns      nsg1.namebrightdns.com.
zombaid.com.    172800  in      ns      nsg2.namebrightdns.com.
zombaimmo.com.  172800  in      ns      ns10.lwsdns.com.
zombaimmo.com.  172800  in      ns      ns11.lwsdns.com.
zombaimmo.com.  172800  in      ns      ns12.lwsdns.com.
zombaimmo.com.  172800  in      ns      ns17.lwsdns.com.
zombaio.com.    172800  in      ns      ns-1073.awsdns-06.org.
</pre></code>
<p>
	Domains usually have more than one entry.
	You need to extract the unique entries.
	And you only need the part before the “.com”.
</p><p>
	Here’s a Ruby script that loops through com.txt, gets the part before .com, skips it if duplicate, and outputs it if unique.
</p>
<div>
<pre><code>domain = &#39;&#39;
File.open(&#39;com.txt&#39;, &#39;r&#39;) do |infile|
  File.open(&#39;domains.txt&#39;, &#39;w&#39;) do |outfile|
    while line = infile.gets
      temp = line[0...(line.index(&#39;.com&#39;))]
      next if temp == domain
      domain = temp
      outfile.puts domain
    end
  end
end
</code></pre><p><small><a href="https://sive.rs/code/domain-parse.rb">download code</a></small>
</p></div>
<p>
	“domains.txt” should now be about 162 million lines - (about 2.2GB) - that look like this:
</p>
<code><pre>zombahomes
zombai
zombaid
zombaimmo
zombaio
</pre></code>

<h2>
	Load it into SQLite, and index it.
</h2>
<code><pre>$ sqlite3 domains.db 
sqlite&gt; create table domains(domain text);
sqlite&gt; .import &#34;domains.txt&#34; domains
sqlite&gt; create index dd on domains(domain);
</pre></code>

<h2>
	Find available dictionary words
</h2>
<p>
	If you’re on Mac, Linux, or <a href="https://sive.rs/openbsd">BSD</a>, you should have a dictionary of words at <strong>/usr/share/dict/words</strong>.
	See which of those words are available:
</p>
<div>
<pre><code>require &#39;sqlite3&#39;
db = SQLite3::Database.new(&#39;domains.db&#39;)
query = db.prepare(&#39;select domain from domains where domain = ?&#39;)
File.readlines(&#39;/usr/share/dict/words&#39;).each do |word|
  rows = query.execute(word.downcase)
  puts word unless rows.next
end
</code></pre><p><small><a href="https://sive.rs/code/domain-word.rb">download code</a></small>
</p></div>
<p>
	Run that, and you’ll have a list of 93,000 dictionary words that are available with the .com extension.
	Congratulations!
	Go to <a href="https://porkbun.com/">porkbun.com</a> (a great little registrar) to register yours.
</p><p>
	You’ll find that some are not actually available because that “com.txt” file doesn’t list domains on hold, pending deletion, or without name servers.
</p>

<h2>
	Combine short dictionary words
</h2>
<p>
	If you are not excited that “electrotelethermometer.com” or “counterexcommunication.com” is available, maybe you would like a combination of two short words?
	Select only dictionary words up to four letters, then search for the combination.
</p>
<div>
<pre><code>require &#39;sqlite3&#39;
words = File.readlines(&#39;/usr/share/dict/words&#39;).map(&amp;:strip)
words.select! {|w| w.size &lt;= 4}
db = SQLite3::Database.new(&#39;domains.db&#39;)
query = db.prepare(&#34;select domain from domains where domain = ?&#34;)
words.each do |word1|
  words.each do |word2|
    combo = (word1 + word2).downcase
    rows = query.execute(combo)
    puts combo unless rows.next
  end
end
</code></pre><p><small><a href="https://sive.rs/code/domain-words.rb">download code</a></small>
</p></div>

<h2>
	Narrow it down to good words
</h2>
<p>
	If you ran that last script, you’ll get tens of millions of available domains like “knabtuik.com” because there are many unknown, ugly, and useless short words.
</p><p>
	So make a new file called “<strong>goodwords.txt</strong>” of only three and four letter words, using grep:
</p>
<code><pre>$ grep &#34;^...$&#34; /usr/share/dict/words &gt;&gt; goodwords.txt
$ grep &#34;^....$&#34; /usr/share/dict/words &gt;&gt; goodwords.txt
</pre></code>
<p>
	Edit that file by hand, deleting every word you would never want.
	(The less you keep, the better.)
	Then run that Ruby script again, combining just the good words:
</p>
<div>
<pre><code>require &#39;sqlite3&#39;
words = File.readlines(&#39;goodwords.txt&#39;).map(&amp;:strip)
db = SQLite3::Database.new(&#39;domains.db&#39;)
query = db.prepare(&#34;select domain from domains where domain = ?&#34;)
words.each do |word1|
  words.each do |word2|
    combo = (word1 + word2).downcase
    rows = query.execute(combo)
    puts combo unless rows.next
  end
end
</code></pre><p><small><a href="https://sive.rs/code/domain-goodwords.rb">download code</a></small>
</p></div>
<p>
	Much better, right?
	A little time consuming, but worth it.
	This is how I found the name of my new translation service, <a href="https://inchword.com/">Inchword</a>.
</p>

<h2>
	Need it super-short and nerdy?
</h2>
<p>
	One final hack is that there are tons of very-short .com domain names available in the format “letter-number-letter-number”.
	For example: <strong>q7r7.com</strong> or <strong>e3p3.com</strong>.
</p>
<div>
<pre><code>require &#39;sqlite3&#39;
db = SQLite3::Database.new(&#39;domains.db&#39;)
query = db.prepare(&#34;select domain from domains where domain = ?&#34;)
(&#39;a&#39;..&#39;z&#39;).each do |a|
  (&#39;0&#39;..&#39;9&#39;).each do |b|
    (&#39;a&#39;..&#39;z&#39;).each do |c|
      (&#39;0&#39;..&#39;9&#39;).each do |d|
        combo = a + b + c + d
        rows = query.execute(combo)
        puts combo unless rows.next
      end
    end
  end
end
</code></pre><p><small><a href="https://sive.rs/code/domain-letters.rb">download code</a></small>
</p></div>



</article>


</div></div>
  </body>
</html>
