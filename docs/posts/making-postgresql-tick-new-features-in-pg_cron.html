<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.citusdata.com/blog/2023/10/26/making-postgres-tick-new-features-in-pg-cron/">Original</a>
    <h1>Making PostgreSQL tick: New features in pg_cron</h1>
    
    <div id="readability-page-1" class="page"><div data-sticky-container="">  <div>  <section> <div> <p><a href="https://github.com/citusdata/pg_cron">pg_cron</a> is an open source PostgreSQL extension that provides a cron-based scheduler to periodically run SQL commands. Almost every managed PostgreSQL service supports pg_cron and it has become a standard tool for many PostgreSQL users. Since <a href="https://github.com/citusdata/citus">Citus</a> has been my full-time job, pg_cron has always been a side project for me, and so I tried to architect it for simplicity, reliability, and low maintenance. Of course, with many users there is a long list of feature requests, and with the help of the Postgres community pg_cron keeps becoming more and more capable over time.</p> <p>We recently added PostgreSQL 16 support (in version 1.6), but perhaps the most exciting feature added to pg_cron in the past year (in version 1.5) is the ability to schedule a job every few seconds. I shunned this feature idea for a while, because (a) it is not something regular cron can do; and (b) any issue in pg_cron would get much more severe if it were to happen every few seconds. However, by now pg_cron is reasonably battle-tested and second-granularity jobs had become the most popular pg_cron feature request by far. </p> <h2>Schedule a job every few seconds</h2> <p>Being able to run second-granularity jobs enables you to react quickly to incoming events in your database. Some example use cases include:</p> <ul> <li>update aggregations for real-time insights</li> <li>detect anomalies (e.g. many requests from the same IP)</li> <li>poll external sources (e.g. frequently sync from a remote server)</li> <li>implement more sophisticated job scheduling workflows</li> </ul> <p>Since pg_cron 1.5, you can easily schedule jobs that run every 1-59 seconds:</p> <div> <pre><code><span>-- Call my procedure every 10 seconds</span>
<span>SELECT</span> <span>cron</span><span>.</span><span>schedule</span><span>(</span><span>&#39;call-my-agent&#39;</span><span>,</span> <span>&#39;10 seconds&#39;</span><span>,</span> <span>&#39;call my_agent()&#39;</span><span>)</span>
</code></pre></div> <p>The reason for not allowing intervals higher than 59 seconds is that existing cron schedules already allow for running a job every minute, and that logic more reliably deals with clock jumps. The reason for not allowing lower intervals (e.g. milliseconds) is that this is a different type of workload which might cause issues. Hence, 1-59 seemed like a safe range for a low maintenance, mission-critical project.</p> <p><strong>Tip</strong>: Be careful that every job run is still logged in <code>cron.job_run_details</code> by default, which can grow very large after months of running jobs every few seconds. You could decide to disable the <code>cron.log_run</code> setting if you expect a very high volume. It is recommended that you at least set up a pg_cron job to clean up after pg_cron:</p> <div> <pre><code><span>-- Delete old cron.job_run_details records of the current user every day at noon</span>
<span>SELECT</span>  <span>cron</span><span>.</span><span>schedule</span><span>(</span><span>&#39;delete-job-run-details&#39;</span><span>,</span> <span>&#39;0 12 * * *&#39;</span><span>,</span> <span>$$</span><span>DELETE</span> <span>FROM</span> <span>cron</span><span>.</span><span>job_run_details</span> <span>WHERE</span> <span>end_time</span> <span>&lt;</span> <span>now</span><span>()</span> <span>-</span> <span>interval</span> <span>&#39;3 days&#39;</span><span>$$</span><span>);</span>
</code></pre></div> <h2>Scalable parallel job queue executor in PostgreSQL</h2> <p>Second-granularity scheduling enables you to use <a href="https://github.com/citusdata/pg_cron">pg_cron</a> as a foundational scheduling primitive on top of which you can build more sophisticated schedulers, without having to modify pg_cron itself.</p> <p>A common request from pg_cron users is the ability to schedule one-off commands, which would be helpful for moving a large task into the background or scheduling many separate operations at once. For example, you may want to load batches of data from another system, apply transformations, perform an operation on many different tables, and more. However, that also brings in many questions around failure handling that pg_cron is not meant to answer. Instead, you could build such infrastructure on top of pg_cron.</p> <p>Below, we give a basic (public domain) implementation of a job queue executor for one-off jobs in PL/pgSQL on top of pg_cron:</p> <div> <pre><code><span>-- table to track jobs to be executed immediately</span>
<span>CREATE</span> <span>TABLE</span> <span>job_queue</span> <span>(</span>
  <span>jobid</span> <span>bigserial</span> <span>primary</span> <span>key</span><span>,</span>
  <span>command</span> <span>text</span> <span>not</span> <span>null</span><span>,</span>
  <span>search_path</span> <span>text</span> <span>not</span> <span>null</span> <span>default</span> <span>&#39;pg_catalog&#39;</span><span>,</span>
  <span>attempts</span> <span>int</span> <span>not</span> <span>null</span> <span>default</span> <span>0</span><span>,</span>
  <span>max_attempts</span> <span>int</span> <span>not</span> <span>null</span> <span>default</span> <span>5</span><span>,</span>
  <span>last_attempt</span> <span>timestamptz</span><span>,</span>
  <span>last_error</span> <span>text</span>
<span>);</span>

<span>-- table to track job failures</span>
<span>CREATE</span> <span>TABLE</span> <span>job_errors</span> <span>(</span>
  <span>jobid</span> <span>bigint</span> <span>not</span> <span>null</span><span>,</span>
  <span>command</span> <span>text</span> <span>not</span> <span>null</span><span>,</span>
  <span>message</span> <span>text</span> <span>not</span> <span>null</span><span>,</span>
  <span>start_time</span> <span>timestamptz</span> <span>not</span> <span>null</span><span>,</span>
  <span>end_time</span> <span>timestamptz</span> <span>not</span> <span>null</span>
<span>);</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>FUNCTION</span> <span>schedule_once</span><span>(</span><span>p_command</span> <span>text</span><span>)</span>
<span>RETURNS</span> <span>void</span> <span>LANGUAGE</span> <span>plpgsql</span> <span>AS</span> <span>$</span><span>fn</span><span>$</span>
<span>BEGIN</span>
  <span>INSERT</span> <span>INTO</span> <span>job_queue</span> <span>(</span><span>command</span><span>,</span> <span>search_path</span><span>)</span>
  <span>VALUES</span> <span>(</span><span>p_command</span><span>,</span> <span>current_setting</span><span>(</span><span>&#39;search_path&#39;</span><span>));</span>
<span>END</span><span>;</span> <span>$</span><span>fn</span><span>$</span><span>;</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>PROCEDURE</span> <span>run_jobs</span><span>()</span>
<span>LANGUAGE</span> <span>plpgsql</span> <span>AS</span> <span>$</span><span>fn</span><span>$</span>
<span>DECLARE</span>
  <span>v_ctid</span> <span>tid</span><span>;</span>
  <span>v_jobid</span> <span>bigint</span><span>;</span>
  <span>v_command</span> <span>text</span><span>;</span>
  <span>v_search_path</span> <span>text</span><span>;</span>
  <span>v_message</span> <span>text</span><span>;</span>
  <span>v_success</span> <span>bool</span><span>;</span>
  <span>v_attempts</span> <span>int</span><span>;</span>
  <span>v_max_attempts</span> <span>int</span><span>;</span>
  <span>v_start_time</span> <span>timestamptz</span><span>;</span>
  <span>v_end_time</span> <span>timestamptz</span><span>;</span>
<span>BEGIN</span>
  <span>LOOP</span>
    <span>-- get a job from the queue</span>
    <span>SELECT</span> <span>ctid</span><span>,</span> <span>jobid</span><span>,</span> <span>command</span><span>,</span> <span>search_path</span><span>,</span> <span>attempts</span> <span>+</span> <span>1</span><span>,</span> <span>max_attempts</span>
    <span>INTO</span> <span>v_ctid</span><span>,</span> <span>v_jobid</span><span>,</span> <span>v_command</span><span>,</span> <span>v_search_path</span><span>,</span> <span>v_attempts</span><span>,</span> <span>v_max_attempts</span>
    <span>FROM</span> <span>job_queue</span>
    <span>WHERE</span> <span>last_attempt</span> <span>is</span> <span>null</span> <span>OR</span> <span>last_attempt</span> <span>&lt;</span> <span>now</span><span>()</span> <span>-</span> <span>interval</span> <span>&#39;10 seconds&#39;</span>
    <span>LIMIT</span> <span>1</span> <span>FOR</span> <span>UPDATE</span> <span>SKIP</span> <span>LOCKED</span><span>;</span>

    <span>IF</span> <span>NOT</span> <span>FOUND</span> <span>THEN</span>
      <span>-- no jobs found, exit, but will resume soon</span>
      <span>EXIT</span><span>;</span>
    <span>END</span> <span>IF</span><span>;</span>

    <span>v_start_time</span> <span>:</span><span>=</span> <span>now</span><span>();</span>

    <span>BEGIN</span>
      <span>-- Execute the command</span>
      <span>SET</span> <span>LOCAL</span> <span>search_path</span> <span>TO</span> <span>v_search_path</span><span>;</span>
      <span>EXECUTE</span> <span>v_command</span><span>;</span>
      <span>RESET</span> <span>search_path</span><span>;</span>
      <span>v_message</span> <span>:</span><span>=</span> <span>&#39;Success&#39;</span><span>;</span>
      <span>v_success</span> <span>:</span><span>=</span> <span>true</span><span>;</span>
    <span>EXCEPTION</span> <span>WHEN</span> <span>others</span> <span>THEN</span>
      <span>-- Command failed, log and store the error message</span>
      <span>RAISE</span> <span>WARNING</span> <span>&#39;scheduled job failed: %&#39;</span><span>,</span> <span>SQLERRM</span><span>;</span>
      <span>v_message</span> <span>:</span><span>=</span> <span>SQLERRM</span><span>;</span>
      <span>v_success</span> <span>:</span><span>=</span> <span>false</span><span>;</span>
    <span>END</span><span>;</span>

    <span>v_end_time</span> <span>:</span><span>=</span> <span>now</span><span>();</span>

    <span>IF</span> <span>v_success</span> <span>OR</span> <span>v_attempts</span> <span>&gt;=</span> <span>v_max_attempts</span> <span>THEN</span>
      <span>-- delete the job if it was successful or we did more than max attempts</span>
      <span>DELETE</span> <span>FROM</span> <span>job_queue</span> <span>WHERE</span> <span>ctid</span> <span>=</span> <span>v_ctid</span><span>;</span>

      <span>IF</span> <span>NOT</span> <span>v_success</span> <span>THEN</span>
        <span>-- we currently only log in case of error to minimize redundant inserts</span>
        <span>INSERT</span> <span>INTO</span> <span>job_errors</span> <span>(</span><span>jobid</span><span>,</span> <span>command</span><span>,</span> <span>message</span><span>,</span> <span>start_time</span><span>,</span> <span>end_time</span><span>)</span>
        <span>VALUES</span> <span>(</span><span>v_jobid</span><span>,</span> <span>v_command</span><span>,</span> <span>v_message</span><span>,</span> <span>v_start_time</span><span>,</span> <span>now</span><span>());</span>
      <span>END</span> <span>IF</span><span>;</span>
    <span>ELSE</span>
      <span>-- update the attempt number and try again later</span>
      <span>UPDATE</span> <span>job_queue</span>
      <span>SET</span> <span>attempts</span> <span>=</span> <span>v_attempts</span><span>,</span> <span>last_attempt</span> <span>=</span> <span>now</span><span>(),</span> <span>last_error</span> <span>=</span> <span>v_message</span>
      <span>WHERE</span> <span>ctid</span> <span>=</span> <span>v_ctid</span><span>;</span>
    <span>END</span> <span>IF</span><span>;</span>

    <span>COMMIT</span><span>;</span>
  <span>END</span> <span>LOOP</span><span>;</span>
<span>END</span><span>;</span> <span>$</span><span>fn</span><span>$</span><span>;</span>

<span>-- Run up to 4 jobs concurrently via pg_cron</span>
<span>SELECT</span> <span>cron</span><span>.</span><span>schedule</span><span>(</span><span>&#39;job-runner-1&#39;</span><span>,</span> <span>&#39;5 seconds&#39;</span><span>,</span> <span>&#39;call run_jobs()&#39;</span><span>);</span>
<span>SELECT</span> <span>cron</span><span>.</span><span>schedule</span><span>(</span><span>&#39;job-runner-2&#39;</span><span>,</span> <span>&#39;5 seconds&#39;</span><span>,</span> <span>&#39;call run_jobs()&#39;</span><span>);</span>
<span>SELECT</span> <span>cron</span><span>.</span><span>schedule</span><span>(</span><span>&#39;job-runner-3&#39;</span><span>,</span> <span>&#39;5 seconds&#39;</span><span>,</span> <span>&#39;call run_jobs()&#39;</span><span>);</span>
<span>SELECT</span> <span>cron</span><span>.</span><span>schedule</span><span>(</span><span>&#39;job-runner-4&#39;</span><span>,</span> <span>&#39;5 seconds&#39;</span><span>,</span> <span>&#39;call run_jobs()&#39;</span><span>);</span>
</code></pre></div> <p>With the job queue set up, you can now schedule one-off jobs which will typically start within 5 seconds and will finish even if you disconnect:</p> <div> <pre><code><span>-- start a long-running job in the background:</span>
<span>select</span> <span>schedule_once</span><span>(</span><span>&#39;create table random as select random() from generate_series(1,10000000) s&#39;</span><span>);</span>
</code></pre></div> <p>The system can run multiple jobs in parallel, and once active it will keep running jobs in quick succession without the overhead of spawning a new process, which enables it to scale to a large number of jobs. The <code>run_jobs</code> procedure will also retry each job up to 5 times, with at least 10 seconds between runs. Permanent errors are logged into the <code>job_errors</code> table.</p> <p><strong>Tip:</strong> Keep in mind that your <code>cron.job_run_details</code> table will fill up rapidly when using this pattern. Consider disabling the <code>cron.log_run</code> setting (to skip <code>cron.job_run_details</code>) and/or the <code>cron.log_statement</code> setting (to skip PostgreSQL log) in your settings when using this pattern.</p> <h2>Example of using pg_cron in a job queue pattern</h2> <p>There are countless ways in which this job queue pattern can be used. An interesting example for <a href="https://github.com/citusdata/citus">Citus</a> database users could be to manage a large number of schemas when using <a href="https://blog.plover.com/blog/2023/07/18/citus-12-schema-based-sharding-for-postgres/">schema-based sharding</a>. For instance, if you want to add a new column in many schemas:</p> <div> <pre><code><span>-- add a column to a table in all distributed schemas:</span>
<span>select</span> <span>schedule_once</span><span>(</span><span>format</span><span>(</span><span>&#39;alter table %I.data add column extra jsonb&#39;</span><span>,</span> <span>schema_name</span><span>))</span> <span>from</span> <span>citus_schemas</span><span>;</span>
</code></pre></div> <p>By performing an ALTER TABLE operation this way instead of iterating over the Postgres schemas, you can avoid running a long-running transaction that holds aggressive locks and can effectively parallelize the work.</p> <h2>Happy job scheduling with pg_cron!</h2> <p>Hopefully this post gives you other ideas for how you can use pg_cron to automate your PostgreSQL workflows. If you want to get started, the main documentation for pg_cron is in the <a href="https://github.com/citusdata/pg_cron">pg_cron GitHub repo</a>.</p> <ul> <li> <a href="https://blog.plover.com/blog/tags/microsoft/">Microsoft</a> </li> <li> <a href="https://blog.plover.com/blog/tags/open-source/">open source</a> </li> <li> <a href="https://blog.plover.com/blog/tags/pg-cron/">pg_cron</a> </li> <li> <a href="https://blog.plover.com/blog/tags/popular/">popular</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres/">Postgres</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres-extensions/">Postgres extensions</a> </li> </ul> <div> <h3> Enjoy what you’re reading? </h3> <p>If you want to read more posts from our Citus database and Postgres teams, sign up for our monthly newsletter and get the latest content delivered straight to your inbox.</p>  <form data-formid="1355" data-forminstance="blog-inline"></form>  </div>   <div> <div> <picture> <source srcset="../../../../../assets/images/team/blog_authors/marco-5df77eb7.webp" type="image/webp"/> <source srcset="../../../../../assets/images/team/blog_authors/marco-bcd5026d.jpg" type="image/jpeg"/> <img alt="Marco Slot" loading="lazy" src="https://blog.plover.com/assets/images/team/blog_authors/marco-bcd5026d.jpg"/> </picture> </div> <p><small> <p> <strong> Written by <a href="https://blog.plover.com/blog/authors/marco-slot/">Marco Slot</a> </strong> </p> <p>Former lead engineer for the Citus database engine at Microsoft. Speaker at Postgres Conf EU, PostgresOpen, pgDay Paris, Hello World, SIGMOD, &amp; lots of meetups. Talk selection team member for Citus Con: An Event for Postgres. PhD in distributed systems. Loves mountain hiking.</p>  </small> </p> </div> <ul> <li> <a href="https://blog.plover.com/blog/tags/microsoft/">Microsoft</a> </li> <li> <a href="https://blog.plover.com/blog/tags/open-source/">open source</a> </li> <li> <a href="https://blog.plover.com/blog/tags/pg-cron/">pg_cron</a> </li> <li> <a href="https://blog.plover.com/blog/tags/popular/">popular</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres/">Postgres</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres-extensions/">Postgres extensions</a> </li> </ul> </div> </section>  </div> </div></div>
  </body>
</html>
