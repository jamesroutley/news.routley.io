<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chadaustin.me/2024/02/windows-terminal-latency/">Original</a>
    <h1>Terminal Latency on Windows (2024)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><strong>UPDATE 2024-04-15</strong>: Windows Terminal 1.19 contains a fix that
reduces latency by half! It’s now competitive with WSLtty on my
machine. Details in the <a href="https://github.com/microsoft/terminal/issues/5590">GitHub
Issue</a>.</p>

<p>In 2009, I wrote about <a href="https://chadaustin.me/2009/10/reasons-why-mintty-is-the-best-terminal-on-windows/">why MinTTY is the best terminal on
Windows</a>.
Even today, that post is one of my most popular.</p>

<figure>
<a href="https://chadaustin.me/wp-uploads/mintty_right_click.png"><img src="https://chadaustin.me/wp-uploads/mintty_right_click.png" alt="MinTTY in 2009"/></a>
<figcaption>MinTTY in 2009</figcaption>
</figure>

<p>Since then, the terminal situation on Windows has improved:</p>
<ul>
  <li>Cygwin defaults to MinTTY; you no longer need to manually install
it.</li>
  <li>Windows added <a href="https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/">PTY
support</a>,
obviating the need for offscreen console window hacks that add
latency.</li>
  <li>Windows added basically full support for <a href="https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences">ANSI terminal
sequences</a>
in both the legacy conhost.exe consoles and its new <a href="https://github.com/microsoft/terminal">Windows
Terminal</a>.</li>
  <li>We now have a variety of terminals to choose from, even on Windows:
<a href="https://cmder.app/">Cmder</a>, <a href="https://conemu.github.io/">ConEmu</a>,
<a href="https://alacritty.org/">Alacritty</a>,
<a href="https://wezfurlong.org/wezterm/index.html">WezTerm</a>,
<a href="http://xtermjs.org/">xterm.js</a> (component of Visual Studio Code)</li>
</ul>

<p>The beginning of a year is a great time to look at your tools and
improve your environment.</p>

<p>I’d already <a href="https://chadaustin.me/2024/01/truecolor-terminal-emacs/">enabled 24-bit color in all of my
environments</a>
and <a href="https://chadaustin.me/2024/02/tmux-config/">streamlined my tmux
config</a>. It’s about time
that I take a look at the newer terminals.</p>

<p>Roughly in order, I care about:</p>
<ul>
  <li>Minimum feature set: 24-bit color, reasonable default fonts with
emoji support, italics are nice.</li>
  <li>Input latency.</li>
  <li>Throughput at line rate, for example, when I <code>cat</code> a large file.</li>
  <li>Support for multiple tabs in one window would be nice, but tmux
suffices for me.</li>
</ul>

<h2 id="which-terminals-should-i-test">Which terminals should I test?</h2>

<p>I considered the following.</p>

<ul>
  <li>Legacy conhost.exe (also known as Windows Console), Windows 10 19045</li>
  <li>MinTTY (3.7.0)</li>
  <li>Alacritty (0.13.1)</li>
  <li>WezTerm (20240203-110809-5046fc22)</li>
  <li>Windows Terminal (1.18.10301.0)</li>
</ul>

<h2 id="testing-features">Testing Features</h2>

<p>Testing color and italics support is easy with my
<a href="https://gist.github.com/chadaustin/2d2c2cb4b71fd1d4163aa8115077624a">colortest.rs</a>
script. To test basic emoji, you can cat the <a href="https://unicode.org/Public/emoji/1.0/emoji-data.txt">Unicode emoji 1.0
emoji-data.txt</a>.
To test more advanced support, try the zero-width joiner list in the
<a href="https://unicode.org/Public/emoji/latest/">latest/</a> directory.</p>

<table>
  <thead>
    <tr>
      <th>Terminal</th>
      <th>Emoji</th>
      <th>Font Attributes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>conhost.exe</td>
      <td>No</td>
      <td>No italics</td>
    </tr>
    <tr>
      <td>MinTTY</td>
      <td>Black and white</td>
      <td>All major attributes</td>
    </tr>
    <tr>
      <td>Alacritty</td>
      <td>Black and white</td>
      <td>Everything but double underline</td>
    </tr>
    <tr>
      <td>WezTerm</td>
      <td><a href="https://wezfurlong.org/wezterm/config/fonts.html">Color</a></td>
      <td>All major attributes</td>
    </tr>
    <tr>
      <td>Windows Terminal</td>
      <td>Color</td>
      <td>All major attributes</td>
    </tr>
  </tbody>
</table>

<p>Everything but conhost.exe meets my bar.</p>

<p>It’s also worth noting that conhost.exe has a terrible default
palette. The default yellow is a pukey green and dark blue is barely
visible. You can change palettes, but defaults matter.</p>

<figure>
<a href="https://chadaustin.me/images/windows-terminal-latency/default-palette-conhost.png"><img src="https://chadaustin.me/images/windows-terminal-latency/default-palette-conhost.png" alt="Conhost.exe Default Palette"/></a>
<figcaption>Conhost.exe Default Palette</figcaption>
</figure>

<figure>
<a href="https://chadaustin.me/images/windows-terminal-latency/default-palette-mintty.png"><img src="https://chadaustin.me/images/windows-terminal-latency/default-palette-mintty.png" alt="MinTTY Default Palette"/></a>
<figcaption>MinTTY Default Palette</figcaption>
</figure>

<h2 id="latency">Latency</h2>

<p>I set up two latency tests. One with an 80x50 blank window in the
upper left corner of the screen. The other fullscreen, editing an
Emacs command at the bottom of the screen.</p>

<p>Since latencies are additive, system configuration doesn’t matter as
much as the absolute milliseconds of latency each terminal adds, but
I’ll describe my entire setup and include total keypress-to-pixels
latency.</p>

<ul>
  <li>Windows 10</li>
  <li>Intel i7-4771 @ 3.5 GHz</li>
  <li>NVIDIA GTX 1060</li>
  <li>Keyboard: <a href="https://1upkeyboards.com/shop/keyboard-kits/macro-pads/sweet16-macro-pad-white/">Sweet 16 Macro
Pad</a></li>
  <li>Display: <a href="https://www.lg.com/us/monitors/lg-27gp950-b-gaming-monitor">LG
27GP950-B</a>
at 4K, 120 Hz, adaptive sync</li>
</ul>

<h3 id="measurement-methodology">Measurement Methodology</h3>

<p>With <a href="https://isitsnappy.com/">Is It Snappy?</a>, I measured the number
of frames between pressing a key and pixels changing on the screen.</p>

<p>To minimize ambiguity about when the key was pressed, I slammed a
pencil’s eraser into the key, and always measured the key press as the
<em>second</em> frame after contact. (The first frame was usually when the
eraser barely touched the key. It would usually clear the activation
depth by the second frame.)</p>

<p>I considered the latency to end when pixels just started to change on
the screen. In practice, pixels take several 240 Hz frames to
transition from black to white, but I consistently marked the
beginning of that transition.</p>

<p>I took five measurements for each configuration and picked the median.
Each measurement was relatively consistent, so average would have been
a fine metric too. It doesn’t change the results below.</p>

<h3 id="80x50">80x50</h3>

<p>80x50 window, upper left of screen, cleared terminal, single keypress.</p>

<p>Confirmed window size with:</p>

<div><div><pre><code>$ echo $(tput cols)x$(tput lines)
80x50
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>Terminal</th>
      <th>Median Latency (ms)</th>
      <th>240 Hz Camera Frames</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>conhost.exe WSL1</td>
      <td>33.3</td>
      <td>8</td>
    </tr>
    <tr>
      <td>MinTTY WSL1</td>
      <td>33.3</td>
      <td>8</td>
    </tr>
    <tr>
      <td>conhost.exe Cygwin</td>
      <td>41.3</td>
      <td>10</td>
    </tr>
    <tr>
      <td>MinTTY Cygwin</td>
      <td>57.9</td>
      <td>14</td>
    </tr>
    <tr>
      <td>WezTerm cmd.exe</td>
      <td>62.5</td>
      <td>15</td>
    </tr>
    <tr>
      <td>Alacritty WSL1</td>
      <td>62.5</td>
      <td>15</td>
    </tr>
    <tr>
      <td>WezTerm WSL1</td>
      <td>66.7</td>
      <td>16</td>
    </tr>
    <tr>
      <td>Windows Terminal WSL1</td>
      <td>66.7</td>
      <td>16</td>
    </tr>
  </tbody>
</table>

<h3 id="fullscreen">Fullscreen</h3>

<p>Maximized emacs, editing a command in the bottom row of the terminal.
I only tested WSL1 this time.</p>

<table>
  <thead>
    <tr>
      <th>Terminal</th>
      <th>Median Latency (ms)</th>
      <th>240 Hz Camera Frames</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>conhost.exe</td>
      <td>45.8</td>
      <td>11</td>
    </tr>
    <tr>
      <td>MinTTY</td>
      <td>52.42</td>
      <td>12</td>
    </tr>
    <tr>
      <td>WezTerm</td>
      <td>75</td>
      <td>18</td>
    </tr>
    <tr>
      <td>Windows Terminal</td>
      <td>75</td>
      <td>18</td>
    </tr>
    <tr>
      <td>Alacritty</td>
      <td>87.5</td>
      <td>21</td>
    </tr>
  </tbody>
</table>

<h3 id="throughput">Throughput</h3>

<p>I generated a 100,000-line file with:</p>

<div><div><pre><code>$ yes &#34;This sentence has forty-five (45) characters.&#34; | head -n 100000 &gt; /tmp/lines.txt
</code></pre></div></div>

<p>Then I measured the wall-clock duration of:</p>

<div><div><pre><code>$ time cat /tmp/lines.txt
</code></pre></div></div>

<p>This benchmark captures the case that I accidentally dump a ton of
output and I’m sitting there just waiting for the terminal to become
responsive again. I have a gigabit internet connection, and it’s
embarrassing to be CPU-bound instead of IO-bound.</p>

<p>I did include Cygwin in this test, just to have two different MinTTY
datapoints.</p>

<table>
  <thead>
    <tr>
      <th>Terminal</th>
      <th>Elapsed Time (s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MinTTY WSL1</td>
      <td>0.57</td>
    </tr>
    <tr>
      <td>MinTTY Cygwin</td>
      <td>2.2</td>
    </tr>
    <tr>
      <td>Windows Terminal</td>
      <td>5.25</td>
    </tr>
    <tr>
      <td>Alacritty</td>
      <td>5.75</td>
    </tr>
    <tr>
      <td>WezTerm</td>
      <td>6.2</td>
    </tr>
    <tr>
      <td>conhost.exe</td>
      <td>21.8</td>
    </tr>
  </tbody>
</table>

<p>I assume this means MinTTY throttles display updates in some way. Of
course this is totally fine, because you couldn’t read the output
either way.</p>

<p>To test the hypothesis that MinTTY was caching cell rendering by
their contents, I also tried generating a file that rotated through
different lines, with no effect.</p>

<div><div><pre><code><span>with</span> <span>open</span><span>(</span><span>&#34;/tmp/lines2.txt&#34;</span><span>,</span> <span>&#34;w&#34;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
  <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>100000</span><span>):</span>
    <span>sentence</span><span>=</span><span>&#34;This sentence has forty-five (45) characters.&#34;</span>
    <span>print</span><span>(</span><span>sentence</span><span>[</span><span>i</span><span>%</span><span>len</span><span>(</span><span>sentence</span><span>):]</span><span>+</span><span>sentence</span><span>[:</span><span>i</span><span>%</span><span>len</span><span>(</span><span>sentence</span><span>)],</span> <span>file</span><span>=</span><span>f</span><span>)</span>
</code></pre></div></div>

<h3 id="cpu-usage-during-repeated-keypresses">CPU Usage During Repeated Keypresses</h3>

<p>While making these measurements, I noticed some strange behaviors. My
monitor runs at 120 Hz and animation and window dragging are generally
smooth. But right after you start Alacritty, dragging the window
animates at something like 30-60 frames per second. It’s noticeably
chunkier. WezTerm does the same, but slightly worse. Maybe 20 frames
per second.</p>

<p>I don’t know if I can blame the terminals themselves, because I
sometimes experience this even with Notepad.exe too. But the
choppiness stands out much more. Maybe something is CPU-bound in
responding to window events?</p>

<p>This made me think of a new test: if I open a terminal and hold down
the “a” button on autorepeat, how much CPU does the terminal consume?</p>

<p>To measure this, I set the terminal process’s affinity to my third
physical core, and watched the CPU usage graph in Task Manager. Not a
great methodology, but it gave a rough sense. Again, 80x50.</p>

<table>
  <thead>
    <tr>
      <th>Terminal</th>
      <th>Percent of Core</th>
      <th>Private Bytes After Startup (KiB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>conhost</td>
      <td>0%</td>
      <td>6,500</td>
    </tr>
    <tr>
      <td>Alacritty</td>
      <td>5%</td>
      <td>74,000</td>
    </tr>
    <tr>
      <td>MinTTY WSL1</td>
      <td>10%</td>
      <td>10,200</td>
    </tr>
    <tr>
      <td>MinTTY Cygwin</td>
      <td>10%</td>
      <td>10,500</td>
    </tr>
    <tr>
      <td>Windows Terminal</td>
      <td>20%</td>
      <td>73,700</td>
    </tr>
    <tr>
      <td>WezTerm</td>
      <td>85%</td>
      <td>134,000</td>
    </tr>
  </tbody>
</table>

<p>The WezTerm CPU usage has to be a bug. I’ll report it.</p>

<h3 id="cpu-usage-idle">CPU Usage (Idle)</h3>

<p>I often have a pile of idle terminals sitting around. I don’t want
them to chew battery life. So let’s take a look at CPU Cycles Delta
(courtesy of Process Explorer) with a fresh, idle WSL
session.</p>

<table>
  <thead>
    <tr>
      <th>Terminal</th>
      <th>Idle Cycles/s (Focused)</th>
      <th>Idle Cycles/s (Background)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>conhost</td>
      <td>~900,000</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Alacritty</td>
      <td>~2,400,000</td>
      <td>no difference</td>
    </tr>
    <tr>
      <td>WezTerm</td>
      <td>~2,600,000</td>
      <td>~1,600,000</td>
    </tr>
    <tr>
      <td>Windows Terminal</td>
      <td>~55,000,000</td>
      <td>~6,100,000</td>
    </tr>
    <tr>
      <td>MinTTY WSL1</td>
      <td>~120,000,000</td>
      <td>no difference</td>
    </tr>
    <tr>
      <td>MinTTY Cygwin</td>
      <td>~120,000,000</td>
      <td>no difference</td>
    </tr>
  </tbody>
</table>

<p>These numbers aren’t great at all! For perspective, I have a pile of
Firefox tabs open, some of them actively running JavaScript, and
they’re “only” using a few hundred million cycles per second.</p>

<p>Raymond Chen once wrote a <a href="https://devblogs.microsoft.com/oldnewthing/20060124-17/?p=32553">blog post about the importance of properly
idling</a>
in the Windows Terminal Server days. You might have a dozen users
logged into a host, and if a program is actively polling, it’s eating
performance that others could use.</p>

<p>Today, we often run on batteries, so idling correctly still matters,
but it seems to be something of a lost art. The only terminal that
idles completely is the old conhost.exe.</p>

<p>The other lesson we can draw is that Microsoft’s own replacement for
conhost.exe, Windows Terminal, uses over 10x the RAM, 60x the CPU when
focused, and infinitely more CPU when idle.</p>

<h2 id="conclusions">Conclusions</h2>

<p>conhost.exe consistently has the best latency, with MinTTY not much
behind. MinTTY handily dominates the throughput test, supports all
major ANSI character attributes, and has a better default palette.</p>

<p>As in 2009, I’d say MinTTY is still pretty great. (I should try to
track down that idle CPU consumption. It feels more like a bug than a
requirement.)</p>

<p>If you want to use MinTTY as the default terminal for WSL, install
<a href="https://github.com/mintty/wsltty">WSLtty</a>.</p>

<p>The others all have slightly worse latencies, but they’re in a similar
class. I’m particularly sensitive to latency, so I’d had a suspicion
even before measuring. Maybe it’s some consequence of being
GPU-accelerated? Out of curiousity, I put Windows Terminal in
software-rendered mode, and it shaved perhaps 4 ms off (median of 62.5
ms, 15 frames). Perhaps just measurement noise.</p>

<p>While I’m going to stick with MinTTY, one thing is clear: there is
room to improve all of the above.</p>

  </div></div>
  </body>
</html>
