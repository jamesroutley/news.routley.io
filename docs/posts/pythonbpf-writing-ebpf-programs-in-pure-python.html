<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xeon.me/gnome/pythonbpf/">Original</a>
    <h1>PythonBPF – Writing eBPF Programs in Pure Python</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction">Introduction</h2><p>Python-BPF offers a new way to write eBPF programs entirely in Python, compiling them into real object files. This project is open-source and available on <a href="https://github.com/varun-r-mallya/python-bpf">GitHub</a> and <a href="https://pypi.org/project/pythonbpf/">PyPI</a>. I wrote it alongside <a href="https://github.com/r41k0u">R41k0u</a>.</p><h2 id="published-library-with-future-plans">Published Library with Future Plans</h2><p>Python-BPF is a published Python library with plans for further development towards production-ready use.</p><h2 id="the-old-way-before-python-bpf">The Old Way: Before Python-BPF</h2><p>Before Python-BPF, writing eBPF programs in Python typically involved embedding C code within multiline strings, often using libraries like <code>bcc</code>. eBPF allows for small programs to run based on kernel events, similar to kernel modules.</p><p>Here’s an example of how it used to be:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>bcc</span> <span>import</span> <span>BPF</span>
</span></span><span><span><span>from</span> <span>bcc.utils</span> <span>import</span> <span>printb</span>
</span></span><span><span>
</span></span><span><span><span># define BPF program</span>
</span></span><span><span><span>prog</span> <span>=</span> <span>&#34;&#34;&#34;
</span></span></span><span><span><span>int hello(void *ctx) {
</span></span></span><span><span><span>    bpf_trace_printk(&#34;Hello, World!</span><span>\\</span><span>n&#34;);
</span></span></span><span><span><span>    return 0;
</span></span></span><span><span><span>}
</span></span></span><span><span><span>&#34;&#34;&#34;</span>
</span></span><span><span>
</span></span><span><span><span># load BPF program</span>
</span></span><span><span><span>b</span> <span>=</span> <span>BPF</span><span>(</span><span>text</span><span>=</span><span>prog</span><span>)</span>
</span></span><span><span><span>b</span><span>.</span><span>attach_kprobe</span><span>(</span><span>event</span><span>=</span><span>b</span><span>.</span><span>get_syscall_fnname</span><span>(</span><span>&#34;clone&#34;</span><span>),</span> <span>fn_name</span><span>=</span><span>&#34;hello&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># header</span>
</span></span><span><span><span>print</span><span>(</span><span>&#34;</span><span>%-18s</span><span> </span><span>%-16s</span><span> </span><span>%-6s</span><span> </span><span>%s</span><span>&#34;</span> <span>%</span> <span>(</span><span>&#34;TIME(s)&#34;</span><span>,</span> <span>&#34;COMM&#34;</span><span>,</span> <span>&#34;PID&#34;</span><span>,</span> <span>&#34;MESSAGE&#34;</span><span>))</span>
</span></span><span><span>
</span></span><span><span><span># format output</span>
</span></span><span><span><span>while</span> <span>1</span><span>:</span>
</span></span><span><span>    <span>try</span><span>:</span>
</span></span><span><span>        <span>(</span><span>task</span><span>,</span> <span>pid</span><span>,</span> <span>cpu</span><span>,</span> <span>flags</span><span>,</span> <span>ts</span><span>,</span> <span>msg</span><span>)</span> <span>=</span> <span>b</span><span>.</span><span>trace_fields</span><span>()</span>
</span></span><span><span>    <span>except</span> <span>ValueError</span><span>:</span>
</span></span><span><span>        <span>continue</span>
</span></span><span><span>    <span>except</span> <span>KeyboardInterrupt</span><span>:</span>
</span></span><span><span>        <span>exit</span><span>()</span>
</span></span><span><span>    <span>printb</span><span>(</span><span>b</span><span>&#34;</span><span>%-18.9f</span><span> </span><span>%-16s</span><span> </span><span>%-6d</span><span> </span><span>%s</span><span>&#34;</span> <span>%</span> <span>(</span><span>ts</span><span>,</span> <span>task</span><span>,</span> <span>pid</span><span>,</span> <span>msg</span><span>))</span>
</span></span></code></pre></div><p>This approach, while functional, meant writing C code within Python, lacking support from modern Python development tools like linters.</p><h2 id="features-of-the-multiline-c-program-approach">Features of the Multiline C Program Approach</h2><div><pre tabindex="0"><code data-lang="python"><span><span><span># load BPF program</span>
</span></span><span><span><span>b</span> <span>=</span> <span>BPF</span><span>(</span><span>text</span><span>=</span><span>&#34;&#34;&#34;
</span></span></span><span><span><span>#include &lt;uapi/linux/ptrace.h&gt;
</span></span></span><span><span><span>
</span></span></span><span><span><span>BPF_HASH(last);
</span></span></span><span><span><span>
</span></span></span><span><span><span>int do_trace(struct pt_regs *ctx) {
</span></span></span><span><span><span>    u64 ts, *tsp, delta, key = 0;
</span></span></span><span><span><span>
</span></span></span><span><span><span>    // attempt to read stored timestamp
</span></span></span><span><span><span>    tsp = last.lookup(&amp;key);
</span></span></span><span><span><span>    if (tsp != NULL) {
</span></span></span><span><span><span>        delta = bpf_ktime_get_ns() - *tsp;
</span></span></span><span><span><span>        if (delta &lt; 1000000000) {
</span></span></span><span><span><span>            // output if time is less than 1 second
</span></span></span><span><span><span>            bpf_trace_printk(&#34;</span><span>%d</span><span>\\</span><span>n&#34;, delta / 1000000);
</span></span></span><span><span><span>        }
</span></span></span><span><span><span>        last.delete(&amp;key);
</span></span></span><span><span><span>    }
</span></span></span><span><span><span>
</span></span></span><span><span><span>    // update stored timestamp
</span></span></span><span><span><span>    ts = bpf_ktime_get_ns();
</span></span></span><span><span><span>    last.update(&amp;key, &amp;ts);
</span></span></span><span><span><span>    return 0;
</span></span></span><span><span><span>}
</span></span></span><span><span><span>&#34;&#34;&#34;</span><span>)</span>
</span></span></code></pre></div><p>The multiline C program approach allowed for features like BPF MAPS (hashmap type), map lookup, update, and delete, BPF helper functions (e.g., <code>bpf_ktime_get_ns</code>, <code>bpf_printk</code>), control flow, assignment, binary operations, sections, and tracepoints.</p><h2 id="similar-program-in-reduced-c">Similar Program in Reduced C</h2><p>For production environments, eBPF programs are typically written in pure C, compiled by <code>clang</code> into a bpf target object file, and loaded into the kernel with tools like <code>libbpf</code>. This approach features map sections, license global variables, and section macros specifying tracepoints.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;linux/bpf.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/bpf_helpers.h&gt;</span><span>
</span></span></span><span><span><span>#define u64 unsigned long long
</span></span></span><span><span><span>#define u32 unsigned int
</span></span></span><span><span><span></span>
</span></span><span><span><span>struct</span> <span>{</span>
</span></span><span><span>    <span>__uint</span><span>(</span><span>type</span><span>,</span> <span>BPF_MAP_TYPE_HASH</span><span>);</span>
</span></span><span><span>    <span>__uint</span><span>(</span><span>max_entries</span><span>,</span> <span>1</span><span>);</span>
</span></span><span><span>    <span>__type</span><span>(</span><span>key</span><span>,</span> <span>u32</span><span>);</span>
</span></span><span><span>    <span>__type</span><span>(</span><span>value</span><span>,</span> <span>u64</span><span>);</span>
</span></span><span><span><span>}</span> <span>last</span> <span>SEC</span><span>(</span><span>&#34;.maps&#34;</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>SEC</span><span>(</span><span>&#34;tracepoint/syscalls/sys_enter_execve&#34;</span><span>)</span>
</span></span><span><span><span>int</span> <span>hello</span><span>(</span><span>struct</span> <span>pt_regs</span> <span>*</span><span>ctx</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>bpf_printk</span><span>(</span><span>&#34;Hello, World!</span><span>\\</span><span>n&#34;</span><span>);</span>
</span></span><span><span>    <span>return</span> <span>0</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>char</span> <span>LICENSE</span><span>[]</span> <span>SEC</span><span>(</span><span>&#34;license&#34;</span><span>)</span> <span>=</span> <span>&#34;GPL&#34;</span><span>;</span>
</span></span></code></pre></div><h2 id="finally-python-bpf">Finally! Python-BPF</h2><p>Python-BPF brings the true eBPF experience to Python by allowing the exact same functionality to be replaced by valid Python code. This is a significant improvement over multiline C strings, offering support from existing Python tools.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>pythonbpf</span> <span>import</span> <span>bpf</span><span>,</span> <span>map</span><span>,</span> <span>section</span><span>,</span> <span>bpfglobal</span><span>,</span> <span>compile</span>
</span></span><span><span><span>from</span> <span>ctypes</span> <span>import</span> <span>c_void_p</span><span>,</span> <span>c_int64</span><span>,</span> <span>c_int32</span><span>,</span> <span>c_uint64</span>
</span></span><span><span><span>from</span> <span>pythonbpf.helpers</span> <span>import</span> <span>ktime</span>
</span></span><span><span><span>from</span> <span>pythonbpf.maps</span> <span>import</span> <span>HashMap</span>
</span></span><span><span>
</span></span><span><span><span>@bpf</span>
</span></span><span><span><span>@map</span>
</span></span><span><span><span>def</span> <span>last</span><span>()</span> <span>-&gt;</span> <span>HashMap</span><span>:</span>
</span></span><span><span>    <span>return</span> <span>HashMap</span><span>(</span><span>key_type</span><span>=</span><span>c_uint64</span><span>,</span> <span>value_type</span><span>=</span><span>c_uint64</span><span>,</span> <span>max_entries</span><span>=</span><span>1</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>@bpf</span>
</span></span><span><span><span>@section</span><span>(</span><span>&#34;tracepoint/syscalls/sys_enter_execve&#34;</span><span>)</span>
</span></span><span><span><span>def</span> <span>hello</span><span>(</span><span>ctx</span><span>:</span> <span>c_void_p</span><span>)</span> <span>-&gt;</span> <span>c_int32</span><span>:</span>
</span></span><span><span>    <span>print</span><span>(</span><span>&#34;entered&#34;</span><span>)</span>
</span></span><span><span>    <span>return</span> <span>c_int32</span><span>(</span><span>0</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>@bpf</span>
</span></span><span><span><span>@section</span><span>(</span><span>&#34;tracepoint/syscalls/sys_exit_execve&#34;</span><span>)</span>
</span></span><span><span><span>def</span> <span>hello_again</span><span>(</span><span>ctx</span><span>:</span> <span>c_void_p</span><span>)</span> <span>-&gt;</span> <span>c_int64</span><span>:</span>
</span></span><span><span>    <span>print</span><span>(</span><span>&#34;exited&#34;</span><span>)</span>
</span></span><span><span>    <span>key</span> <span>=</span> <span>0</span>
</span></span><span><span>    <span>last</span><span>()</span><span>.</span><span>update</span><span>(</span><span>key</span><span>)</span>
</span></span><span><span>    <span>ts</span> <span>=</span> <span>ktime</span><span>()</span>
</span></span><span><span>    <span>return</span> <span>c_int64</span><span>(</span><span>0</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>@bpf</span>
</span></span><span><span><span>@bpfglobal</span>
</span></span><span><span><span>def</span> <span>LICENSE</span><span>()</span> <span>-&gt;</span> <span>str</span><span>:</span>
</span></span><span><span>    <span>return</span> <span>&#34;GPL&#34;</span>
</span></span><span><span>
</span></span><span><span><span>compile</span><span>()</span>
</span></span></code></pre></div><p>Python-BPF uses <code>ctypes</code> to preserve compatibility, employs decorators to separate the BPF program from other Python code, allows intuitive creation of global variables, and defines sections and tracepoints similar to its C counterpart. It also provides an interface to compile and run in the same file.</p><h2 id="how-it-works-under-the-hood">How it Works Under the Hood</h2><ol><li><p><strong>Step 1: Generate AST</strong>
The Python <code>ast</code> module is used to generate the Abstract Syntax Tree (AST).</p></li><li><p><strong>Step 2: Emit LLVM IR</strong>
<code>llvmlite</code> from Numba emits LLVM Intermediate Representation (IR) and debug information for specific parts like BPF MAPs. The <code>.py</code> file is converted into LLVM Intermediate Representation.</p></li><li><p><strong>Step 3: Compile LLVM IR</strong>
The <code>.ll</code> file, containing all code written under the <code>@bpf</code> decorator, is compiled using <code>llc -march=bpf -O2</code>.</p></li><li><p><strong>Step 4: Generate eBPF Object File</strong>
The LLVM backend takes the IR and converts it into a bpf object file with eBPF bytecode, handling all optimizations.</p><p><img src="https://xeon.me/gnome/pythonbpf/image.png" alt="alt text"/></p></li></ol><h2 id="salient-features">Salient Features</h2><p>Previous Python options for eBPF relied on <code>bcc</code> for compilation, which is not ideal for production use. The only two real options for production-quality eBPF programs were <code>aya</code> in Rust and Clang with kernel headers in C. Python-BPF introduces a third, new option, expanding the horizons for eBPF development.</p><p>It currently supports:</p><ul><li>Control flow</li><li>Hash maps (with plans to add support for other map types)</li><li>Binary operations</li><li>Helper functions for map manipulation</li><li>Kernel trace printing functions</li><li>Timestamp helpers</li><li>Global variables (implemented as maps internally with syntactical differences)</li></ul><h2 id="tldr">TL;DR</h2><ul><li>Python-BPF allows writing eBPF programs directly in Python.</li><li>This library compiles Python eBPF code into actual object files.</li><li>Previously, eBPF programs in Python were written as C code strings.</li><li>Python-BPF simplifies eBPF development with Python decorators.</li><li>It offers a new option for production quality BPF programs in Python.</li><li>The tool supports BPF maps, helper functions, and control flow, with plans to extend to completeness later.</li></ul><p>Thanks for reading my poorly written blog :)</p></div></div>
  </body>
</html>
