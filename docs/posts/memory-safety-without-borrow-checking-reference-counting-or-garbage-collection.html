<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">Original</a>
    <h1>Memory Safety Without Borrow Checking, Reference Counting, or Garbage Collection</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
    <div>
  

        <div>
          <div>
  

            <div>
    

              
    

              <p>this one simple trick language designers don&#39;t want you to know</p>
        

              <div>
      

                <p><span>June 15, 2023</span>
        

                <span> — </span>
          

                
        

                  <span> — </span>
          

                  <span><a href="https://github.com/sponsors/ValeLang">Sponsor us on GitHub!</a></span>
        

              </p></div>
      

            </div>
    
<section>
<p>
Single ownership is once of those concepts that&#39;s both easier and more powerful than we realize.
</p>

</section>
<section>
<p>
People often think it&#39;s complex, because it most often appears in languages that are already complex for separate reasons.
</p>

</section>
<section>
<p>
Let&#39;s <b>dispel that myth</b>, and figure out what it really is!
</p>

</section>
<section>
<p>
Even if you already know what single ownership is, you&#39;ll probably find some interesting surprises:
</p>
<ul>
<li>
You <b>don&#39;t need borrow checking</b> for memory-safe single ownership.
</li>
<li>
You can use it to enforce all sorts of <b>compile-time guarantees</b>.
</li>
<li>
You can <b>blend it</b> with other memory management techniques!
</li>
</ul>

</section>
<section>
<p>
Below, I&#39;ll explain single ownership from a C foundation, and then we&#39;ll see the <i>weird</i> things it can do.
</p>

</section>
<section>
<h2 id="we-often-track-single-ownership-manually-in-c">
 We often track single ownership manually in C</h2>
<p>
With manual memory management, we usually make it clear who&#39;s responsible for eventually freeing certain memory, via documentation or naming.
</p>

</section>
<section>
<p>
For example, <span>strdup</span> will return a heap-allocated buffer, which the caller then owns. From GLib&#39;s <span>strdup</span> <a href="https://docs.gtk.org/glib/func.strdup.html">documentation</a>:
</p>
<p>
The caller of the function takes ownership of the data, and is responsible for freeing it.
</p>

</section>
<section>
<p>
So we make sure to eventually deliver this data to another function that destroys it.
</p>

</section>
<section>
<p>
If we don&#39;t do that, we get a memory leak; the memory is unusable for the rest of the program&#39;s run.
</p>

    <div>
      
      <pre><code>void main() {
  char* myBuffer = GetRealPath(&#34;./myfile.txt&#34;);

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf(&#34;Real path: %s\n&#34;, myBuffer);

  // uh oh, we forgot to free(myBuffer)!
  // Memory leak.
}</code></pre>
    </div>
  
<p>
If we accidentally do it multiple times, the program might crash or exhibit undefined behavior.
</p>

    <div>
      
      <pre><code>void main() {
  char* myBuffer = GetRealPath(&#34;./myfile.txt&#34;);

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf(&#34;Real path: %s\n&#34;, myBuffer);

  free(myBuffer);
  // Shenanigans ensue!
  free(myBuffer);
}</code></pre>
    </div>
  

</section>
<section>
<p>
As any C programmer knows, we <b>carefully track who owns the data</b>, all the way from when it&#39;s created, to when it&#39;s finally destroyed.
</p>

</section>
<section>
<p>
At any given time in between, we can generally identify who &#34;owns&#34; certain data, whether it be a certain local variable or a field in some struct somewhere.
</p>

</section>
<section>
<p>
Of course, other pointers to the data can exist, they just don&#39;t <i>own</i> the data. We have a <b>mental distinction</b> between owning pointers and non-owning pointers.
</p>

</section>
<section>
<p>
If you&#39;ve ever implemented a balancing binary search tree like a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree</a> or an <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree</a>, recall that a parent conceptually has &#34;owning&#34; pointers to its children, and its children have non-owning pointers back to their parents.
</p>

</section>
<section>
<p>
Single ownership isn&#39;t just for pointers and <span>malloc</span> and <span>free</span>, it&#39;s to anything that we have a <b>future responsibility</b> for.
</p>

</section>
<section>
<p>
For example, <span>pthread_create</span> creates a handle that we&#39;re responsible for eventually <span>pthread_destroy</span>ing. We generalize this a bit more later, but for now let&#39;s just think about heap allocations.
</p>

</section>

      </div>
  
<div>

      <nav>
      <p>Single Ownership and Memory Safety without Borrow Checking, Reference Counting, or Garbage Collection</p>
    


      </nav>
      
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="how-might-we-track-it">
 How might we track it?</h2>
<p>
When I was a wee lad, I would suffix my &#34;owning&#34; pointers with <span>_owning</span> to keep things straight.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Here&#39;s a balancing binary search tree node in regular C...
</p>

    <div>
      
      <pre><code>struct Node {
  struct Node* parent;
  struct Node* leftChild;
  struct Node* rightChild;
};</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
...and here it is with some helpful <span>_owning</span>s added to the names.
</p>

    <div>
      
      <pre><code>struct Node {
  struct Node* parent;
  struct Node* leftChild_owning;
  struct Node* rightChild_owning;
};</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
I had some sensible guidelines:
</p>
<p>
<b>Rule 1:</b> Anything that comes from <span>malloc</span> must be put in a variable ending in <span>_owning</span>.
</p>
<p>
<b>Rule 2:</b> We can&#39;t let an <span>_owning</span> variable (or field) go out of scope, the only way to destroy it is to explicitly give it to <span>free</span> (or &#34;move&#34; it, which we&#39;ll talk about later).
</p>
<p>
<b>Rule 3:</b> We can&#39;t use that variable after freeing it (or moving it).
</p>

</section>
<section>
<p>
We could even make a linter or compiler to enforce this, and detect both memory leaks and double-frees:
</p>

</section>
<section>

    <div>
      
      <pre><code>void main() {
  char* myBuffer_owning = GetRealPath(&#34;./myfile.txt&#34;);

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf(&#34;Real path: %s\n&#34;, myBuffer_owning);

  // Take out this line for an error!
  free(myBuffer_owning)

  // Or add this bad line for a different error!
  // printf(&#34;Freed: %s\n&#34;, myBuffer_owning);
}</code></pre>
    </div>
  

</section>
<section>
<p>
In a way, these rules help us <b>track responsibility for freeing the buffer</b>.
</p>

</section>
<section>
<p>
Keep the phrase &#34;tracking responsibility&#34; in mind, we&#39;ll build on that later to make the system help us with much more than managing memory.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="how-a-compiler-can-track-it">
 How a compiler can track it</h2>
<p>
If we were to craft a C-like language, then instead of using a suffix like <span>char* myBuffer_owning</span>, we might use a symbol on the type, like: <span>char^ myBuffer</span>.
</p>

</section>
<section>
<p>
When you look at it that way, it&#39;s kind of like <span>char</span>, <span>char^</span>, and <span>char*</span> are all different types:
</p>
<ul>
<li>
<span>char</span> is an (owned) <b>value</b>, owned by the containing stack frame, struct, or array.
</li>
<li>
<span>char^</span> is an <b>owning pointer</b> to something in the heap.
</li>
<li>
<span>char*</span> is a <b>non-owning pointer</b>.
</li>
</ul>

</section>
<section>
<p>
The above <span>char* myBuffer_owning = ...</span> would become <span>char^ myBuffer = ...</span>.
</p>

</section>
<section>
<p>
However, for the compiler to be able to keep things straight, we also need to add the ability to <span>move</span> ownership from one variable into another variable or field:
</p>

</section>
<section>

    <div>
      
      <pre><code>void main() {
  char^ myBuffer = GetRealPath(&#34;./myfile.txt&#34;);

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf(&#34;Real path: %s\n&#34;, myBuffer);

  char^ otherVar = move myBuffer;
  // Now, we can&#39;t access myBuffer.

  free(move otherVar)
}</code></pre>
    </div>
  

</section>
<section>
<p>
Notice how we <span>move</span>d from <span>myBuffer</span> to <span>otherVar</span>. We also moved into the <span>free</span> call as well.
</p>

</section>
<section>
<p>
This <span>move</span> keyword comes with a new rule.
</p>
<p>
<b>Rule 4:</b> When we <span>move</span> out of a variable, we can&#39;t use it anymore.
</p>

</section>
<section>
<p>
We would also use this new <span>move</span> keyword to transfer ownership of some data to our caller, like so:
</p>

    <div>
      
      <pre><code>Spaceship^ makeSpaceship() {
  Spaceship^ ship = (Spaceship^)malloc(sizeof(Spaceship));
  ship-&gt;fuel = 42;
  return move ship;
}</code></pre>
    </div>
  
<center><span>(now watch as this new syntax completely confuses the site&#39;s code highlighter)</span></center>


</section>
<section>
<p>
These rules are sometimes known as <b>move semantics</b>.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="lets-keep-it-weird">
 Let&#39;s keep it weird</h2>

</section>
<section>
<p>
C++ and Rust also have move semantics, but ours is a little different so far:
</p>
<ul>
<li>
C++ doesn&#39;t have rule 4, in C++ the compiler lets us accidentally use the variable after we <span>move</span> out of it.
</li>
<li>
Rust adds a borrow checker on top. We&#39;re going to do something else!
</li>
<li>
Both C++ and Rust will automatically <span>free</span> an owning pointer when it goes out of scope.
</li>
</ul>

</section>
<section>
<p>
Of course, we&#39;re not doing any of that.
</p>

</section>
<section>
<p>
Let&#39;s see what interesting things happen!
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="higher-raii-and-compile-time-guarantees">
 Higher RAII, and compile-time guarantees</h2>
<p>
Recall Rule 2: The user can&#39;t let an owning variable (or field) go out of scope, the only way to destroy it is to <i>explicitly</i> <span>move</span> it or give it to <span>free</span>.
</p>

</section>
<section>
<p>
Because of this, if you accidentally let an owning pointer go out of scope, you&#39;ll get a compiler error.
</p>

</section>
<section>
<p>
You can use this to your advantage, using a technique called &#34;Higher RAII&#34;, which is similar to linear types. <a href="#note0" data-noteid="0">0</a>
</p>
<p>
Basically, if you want your caller to remember to do something later, give them ownership of a &#34;reminder&#34; object that they can&#39;t accidentally drop. <a href="#note1" data-noteid="1">1</a>
</p>

</section>
<section>
<p>
This technique is incredibly powerful. With it, the compiler can enforce that you:
</p>
<ul>
<li>
Remember to <span>fulfill</span> a <span>Promise</span> <a href="#note2" data-noteid="2">2</a> exactly once.
</li>
<li>
Remember to remove something from a cache that you previously added to.
</li>
<li>
Remember to explicitly rollback or commit a transaction.
</li>
<li>
Remember to join a thread and do something with the thread function&#39;s result.
</li>
<li>
Remember to explicitly force-close a TCP connection or wait for a graceful close.
</li>
</ul>

</section>
<section>
<p>
More generally, it means the compiler can <b>ensure you remember to do something in the future</b> and don&#39;t accidentally forget it.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note0" data-noteid="0">
<p><span>0</span></p><section>
<p>
Higher RAII is similar to linear typing. An owning reference is a linear type, but when we can also make non-owning references to the same object, we get Higher RAII.
</p>

</section>
</div>
<div id="note1" data-noteid="1">
<p><span>1</span></p><section>
<p>
&#34;Drop&#34; here means to let the compiler clean it up with some default action.
</p>

</section>
</div>
<div id="note2" data-noteid="2">
<p><span>2</span></p><section>
<p>
A <span>Promise</span> is an object that will deliver a result to a corresponding <span>Future</span>, sometimes on a different thread.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="an-example">
 An Example</h3>

</section>
<section>
<p>
Lets say we have a spaceship game.
</p>

</section>
<section>
<p>
Some facts about our game&#39;s code:
</p>
<ul>
<li>
All of our spaceships live in a central list.
</li>
<li>
We <i>also</i> need to have a separate cache for displaying them.
</li>
<li>
Every ship needs to be in both the central list <i>and</i> the display cache.
</li>
<li>
When the ship dies, we need to remove it from both the central list <i>and</i> the display cache.
</li>
</ul>

</section>
<section>
<p>
If we forget to remove it from the display cache, we&#39;d get an odd bug when displaying.
</p>

</section>
<section>
<p>
Let&#39;s use single ownership to prevent this bug at compile-time. No mainstream language prevents this kind of bug, but we&#39;re about to do it easily!
</p>

</section>
<section>
<p>
We already have a function that will add the ship to the display cache, which looks like this:
</p>

</section>
<section>

    <div>
      
      <pre><code>void AddShipToDisplayCache(DisplayCache* cache, Ship* ship) {
  ... // Add to cache
}</code></pre>
    </div>
  

</section>
<section>
<p>
Let&#39;s instead return a &#34;reminder&#34; object: <a href="#note3" data-noteid="3">3</a>
</p>

</section>
<section>

    <div>
      
      <pre><code>struct ShipInCacheReminder { };

ShipInCacheReminder^ AddShipToDisplayCache(DisplayCache* cache, Ship* ship) {
  ... // Add to cache
  // Return a zero-sized reminder object
  return (ShipInCacheReminder^)malloc(sizeof(ShipInCacheReminder));
}</code></pre>
    </div>
  

</section>
<section>
<p>
The compiler prevents us from accidentally dropping this <span>ShipInCacheReminder^</span>; we must explicitly <span>move</span> or <span>free</span> it. That makes it a very effective reminder.
</p>

</section>
<section>
<p>
The only place we&#39;ll ever <span>free</span> it is in the <span>RemoveShipFromDisplayCache</span> function: <a href="#note4" data-noteid="4">4</a>
</p>

</section>
<section>

    <div>
      
      <pre><code>void RemoveShipFromDisplayCache(
    DisplayCache* cache,
    Ship* ship,
    ShipInCacheReminder^ reminder) {
  free(move reminder);
  ... // Remove it from the cache
}</code></pre>
    </div>
  

</section>
<section>
<p>
Voilà! The compiler now guarantees that we&#39;ll not forget to <span>RemoveShipFromDisplayCache</span>.
</p>

</section>
<section>
<p>
Let&#39;s see it more in context, and get a clearer picture of how this is used.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Personally, I prefer storing the reminder next to the <span>Ship^</span> itself. For example, instead of a central list of <span>Ship^</span>, we might have a central list of <span>ShipAndMetadata^</span> which contains a <span>Ship^</span> and all the reminder objects for it.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>struct ShipAndMetadata {
  Ship^ ship;
  ShipInCacheReminder^ shipInCache;
};</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
That way, when we take apart the <span>ShipAndMetadata</span> struct to get to the <span>Ship</span> we want to destroy, we&#39;re naturally left holding a <span>ShipInCacheReminder</span>.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Here, we try to delete the <span>shipAndMetadata</span> directly, and justifiably get an error.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>void DestroyShip(
    ShipAndMetadata^ shipAndMetadata) {
  // Error: freed a struct without
  //   moving data from it
  free(move shipAndMetadata);
}</code></pre>
    </div>
  


</section>
</div>
</div>
<div>
<div>
<section>
<p>
The compiler knows we need to <span>move</span> fields out before <span>free</span>ing the container, so let&#39;s move things out first. <a href="#note5" data-noteid="5">5</a>
</p>

</section>
<section>
<p>
We also free <span>ship</span> here. However, the <span>shipInCache</span> was not dealt with, so the compiler notices that and throws an error.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>void DestroyShip(
    ShipAndMetadata^ shipAndMetadata) {
  Ship^ ship = move shipAndMetadata.ship;
  ShipInCacheReminder^ shipInCache =
      move shipAndMetadata.shipInCache;
  free(move shipAndMetadata);

  free(move ship);
  // Error: Un-destroyed data:
  //   ShipInCacheReminder^ shipInCache
}</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
That&#39;s good! We don&#39;t want the compiler to leak or even <span>free</span> that reminder automatically, that would defeat the purpose.
</p>

</section>
<section>
<p>
To fix it, we&#39;ll call <span>RemoveShipFromDisplayCache</span>:
</p>

    <div>
      
      <pre><code>void DestroyShip(
    DisplayCache* cache,
    ShipAndMetadata^ shipAndMetadata) {
  Ship^ ship = move shipAndMetadata.ship;
  ShipInCacheReminder^ shipInCache = move shipAndMetadata.shipInCache;
  free(move shipAndMetadata);

  // Gets rid of the shipInCache
  RemoveShipFromDisplayCache(cache, &amp;ship, move shipInCache);

  // Gets rid of the ship
  free(move ship);

  // No errors!
}</code></pre>
    </div>
  

</section>
<section>
<p>
As a bonus, this technique prevents us from accidentally doing <span>RemoveShipFromDisplayCache</span> twice, because there&#39;s only one reminder object instance. <a href="#note6" data-noteid="6">6</a>
</p>

</section>
<section>
<p>
They say the biggest two problems in computer science are off-by-one errors and cache invalidation. We just solved the latter!
</p>

</section>
<section>
<p>
If you want to learn more about this, check out <a href="https://verdagon.dev/blog/higher-raii-7drl">Vale&#39;s Higher RAII, the pattern that saved me a vital 5 hours in the 7DRL Challenge</a>, where I used this exact technique to remember to remove things from a cache.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note3" data-noteid="3">
<p><span>3</span></p><section>
<p>
This <span>ShipInCacheReminder^</span> could even just be a <span>ShipInCacheReminder</span> if the compiler knows to not drop <span>ShipInCacheReminder</span>s, such as how in Vale it&#39;s decided on a per-type basis.
</p>

</section>
</div>
<div id="note4" data-noteid="4">
<p><span>4</span></p><section>
<p>
We could get around this system by maually <span>free</span>ing it elsewhere. We&#39;d have to go out of our way to cause that bug, so it&#39;s not as worrisome.
</p>

</section>
</div>
<div id="note5" data-noteid="5">
<p><span>5</span></p><section>
<p>
This is so common thing that languages like Vale can just &#34;move-destructure&#34; to do this, e.g. <span>[ship, shipInCache] = shipAndMetadata;</span>.
</p>

</section>
</div>
<div id="note6" data-noteid="6">
<p><span>6</span></p><section>
<p>
So far, this technique doesn&#39;t prevent us from removing the wrong <span>Ship</span>. If we want, we could prevent that by putting the <span>Ship</span>&#39;s ID into the <span>ShipInCacheReminder</span>.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="memory-safety">
 Memory Safety</h2>

</section>
<section>
<p>
Let&#39;s make something else amazing happen.
</p>

</section>
<section>
<p>
We can make our little C-like language <b>completely memory safe</b> with a few extra rules:
</p>
<p>
<b>Rule 5:</b> Always bounds-check array accesses.
</p>
<p>
<b>Rule 6:</b> No using pointer arithmetic.
</p>
<p>
<b>Rule 7:</b> Never use non-owning pointers. Each object only ever has one pointer to it, the owning pointer.
</p>

</section>
<section>
<p>
You&#39;re probably thinking, &#34;That&#39;s insane! How can you make a program without non-owning pointers? And how does that make our programs memory safe?&#34;
</p>

</section>
<section>
<p>
It does sound insane! But we can refactor any program to not use non-owning pointers, if we have these guidelines:
</p>
<ol>
<li>
Any function that receives a non-owning pointer would instead take (and return) ownership of data.
</li>
<li>
Any struct that stores a non-owning pointer would instead store an index (or ID) into some central data structure.
</li>
</ol>

</section>
<section>
<p>
If you want to read more about this &#34;linear style&#34;, check out <a href="https://verdagon.dev/blog/linear-types-borrowing">last week&#39;s article</a> on how Vale taught me about all of this. Vale&#39;s <a href="https://vale.dev/linear-aliasing-model">Linear-Aliasing Model</a> is about using linear style, and falling back to <a href="https://verdagon.dev/blog/generational-references">generational references</a> when the user chooses not to use it.
</p>

</section>
<section>
<p>
If you&#39;ve ever used a language with a <a href="https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems">linear type system</a> like <a href="https://austral-lang.org/">Austral</a>, this will sound familiar.
</p>

</section>
<section>
<p>
After a few hours of using this style, it actually feels pretty similar to Rust. The first guideline is semantically equivalent to passing an <span>&amp;mut</span>, and we use the second gudeline all the time in Rust already.
</p>

</section>
<section>
<h2 id="adding-non-owning-pointers-back-in-safely">
 Adding non-owning pointers back in safely</h2>
<p>
If we want to add non-owning pointers back in while keeping our newfound memory safety, there are a few ways we can go about it.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="memory-tagging-and-cheri">
 Memory Tagging and CHERI</h3>
<p>
<a href="https://source.android.com/docs/security/test/memory-safety/arm-mte">Memory tagging</a> is when every 16-byte chunk of memory has a corresponding 4-bit &#34;key&#34; that goes with it. Every time we allocate or deallocate that chunk, we change the chunk&#39;s key.
</p>
<p>
Whenever we make a pointer to some data, we copy that key into the unused top bits of the pointer.
</p>
<p>
When we attempt to dereference the pointer, the hardware will assert that the key in the chunk matches the key in the pointer.
</p>

</section>
<section>
<p>
Even though these asserts have a 1/16 chance of a false negative, this is great for detecting bugs in development and testing.
</p>

</section>
<section>
<p>
<a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a> is still in the R&amp;D phase, but it seems like it will solve a lot of memory tagging&#39;s downsides.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="borrow-checking">
 Borrow Checking</h3>
<p>
Of course, there&#39;s always Rust&#39;s borrow checking approach! It enforces that if someone has a mutable reference to an object, no other references can exist. This simple rule gives us temporary non-owning pointers with full memory safety.
</p>

</section>
<section>
<p>
It has some really nice benefits:
</p>
<ul>
<li>
With a little bit of function coloring and data coloring, we can temporarily share data with multiple threads, without risking data races!
</li>
<li>
It doesn&#39;t have the run-time cost of memory tagging or CHERI (about <a href="https://lobste.rs/s/nw7hsd/how_memory_safe_is_zig_updated#c_tyzbaf">6.8%</a>).
</li>
</ul>

</section>
<section>
<p>
But also some drawbacks:
</p>
<ul>
<li>
It doesn&#39;t let us use common patterns like observers, graphs, back-references, dependency references, intrusive data structures, delegates, and struggles with certain kinds of RAII and interconnected data.
</li>
<li>
It can be difficult for time management and <a href="https://verdagon.dev/blog/when-to-use-memory-safe-part-2">development velocity</a>.
</li>
</ul>

</section>
<section>
<p>
I would love to see a language that has both linear types and borrow checking. <a href="https://austral-lang.org/">Austral</a> is looking pretty promising here. Rust gets close, but its affine types can&#39;t get the specific compile-time guarantees of linear types and higher RAII. <a href="#note7" data-noteid="7">7</a> <a href="#note8" data-noteid="8">8</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note7" data-noteid="7">
<p><span>7</span></p><section>
<p>
All types in Rust must be affine, in other words all types must have a zero-arg no-return <span>drop</span> method defined, so that Rust can automatically drop any type when it goes out of scope. This conflicts with higher RAII, which is all about requiring <i>explicit</i> destruction of certain types.
</p>

</section>
</div>
<div id="note8" data-noteid="8">
<p><span>8</span></p><section>
<p>
Some folks have been <a href="http://smallcultfollowing.com/babysteps/blog/2023/03/16/must-move-types/">thinking</a> <a href="https://blog.yoshuawuyts.com/linearity-and-control/">about</a> what it would take for Rust to do full linear types. It sounds pretty promising, and I hope it happens!
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="generational-references">
 Generational References</h3>
<p>
<a href="https://vale.dev/">Vale</a>&#39;s <a href="https://verdagon.dev/blog/generational-references">generational references</a> is like a 64-bit memory tagging system, but it uses the language&#39;s semantics to skip as many assertions as the user wants. <a href="#note9" data-noteid="9">9</a>
</p>

</section>
<section>
<p>
It has a some benefits:
</p>
<ul>
<li>
It skips the assertions when we access an owning pointer, or when reading from an immutable <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">region</a>. Between these, one can eliminate every single assertion in a program if they want.
</li>
<li>
Its owning references are regular thin 64-bit pointers, as opposed to CHERI&#39;s 128-bit ones.
</li>
<li>
It&#39;s easy, and lets us use whatever patterns we want.
</li>
<li>
It can be used with <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">regions</a> to eliminate data races.
</li>
</ul>

</section>
<section>
<p>
It has its drawbacks too, of course:
</p>
<ul>
<li>
It has a &#34;key&#34; at the top of every allocation, though structs and enums share the key of the containing struct, array, or stack frame to save space.
</li>
<li>
Its non-owning references are 128 bits (like CHERI&#39;s), though they can be avoided with the above linear style.
</li>
<li>
When we choose to dereference a generational reference, it does a check at run-time similar to a bounds check.
</li>
</ul>

</section>
<section>
<p>
This combination of generational references and regions is my favorite approach, especially since it still lets us use Higher RAII.
</p>

</section>
<section>
<h2 id="other-approaches">
 Other Approaches</h2>
<p>
There are a few other approaches we can use to add non-owning pointers back in while preserving memory safety:
</p>

<p>
...but this post is getting quite large already! <a href="#note10" data-noteid="10">10</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note9" data-noteid="9">
<p><span>9</span></p><section>
<p>
Specifically, <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">regions</a> eliminate the vast majority, and we can use <a href="https://verdagon.dev/blog/linear-types-borrowing">linear style</a> to eliminate the rest.
</p>

</section>
</div>
<div id="note10" data-noteid="10">
<p><span>10</span></p><section>
<p>
One day I&#39;d really like to write a series on the surprising number of mechanisms for memory safety. We often think it&#39;s just reference counting, tracing garbage collection, and borrow checking, but it turns out there are a lot more.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="what-does-it-all-mean">
 What does it all mean?</h2>
<p>
Single ownership is a <i>lot</i> simpler and more powerful than people realize. Even without reference counting, garbage collection, or borrow checking, we can use it for memory safety <i>and</i> extra guarantees at compile-time.
</p>

</section>
<section>
<p>
I hope languages will start moving in this direction. C++ pioneered single ownership with <span>unique_ptr</span> and Rust added memory safety, but both are affine <a href="#note11" data-noteid="11">11</a> <a href="#note12" data-noteid="12">12</a> so don&#39;t get higher RAII&#39;s compile-time guarantees. 
</p>

</section>
<section>
<p>
Austral uses linear types for its memory safety, and built their entire language around them to great effect. They wrote up a really great <a href="https://austral-lang.org/linear-types">Introduction to Linear Types</a> too, definitely worth checking out. <a href="#note13" data-noteid="13">13</a>
</p>

</section>
<section>
<p>
<a href="https://vale.dev/">Vale</a> has both linear and affine types, plus generational references on top. The user might decide that <span>Ship</span>s are affine and <span>ShipInCacheReminder</span>s are linear, and can have references to either of them. We also just successfully used <a href="https://verdagon.dev/blog/first-regions-prototype">regions</a> to eliminate most of generational references&#39; downsides, though it&#39;s still quite experimental.
</p>

</section>
<section>
<p>
Next week I&#39;ll be writing about how we can use these techniques (and a few others) to design some memory safety for C++, so keep an eye on the <a href="https://verdagon.dev/rss.xml">RSS feed</a>, <a href="https://twitter.com/vale_pl">twitter</a>, <a href="https://discord.gg/SNB8yGH">discord server</a>, or <a href="https://reddit.com/r/vale">subreddit</a>!
</p>

</section>
<section>
<p>
<b>That&#39;s all for now!</b> If you enjoyed this article, please consider <a href="https://github.com/sponsors/ValeLang">sponsoring</a>!
</p>

</section>
<section>
<p>
See you next time!
</p>

</section>
<section>
<p>
- Evan Ovadia
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note11" data-noteid="11">
<p><span>11</span></p><section>
<p>
Affine means the compiler must always be able to drop data automatically when it goes out of scope.
</p>

</section>
</div>
<div id="note12" data-noteid="12">
<p><span>12</span></p><section>
<p>
I was hoping that by using <span>= delete;</span> on a constructor in C++ we could get a linear type. Alas, no such luck.
</p>

</section>
</div>
<div id="note13" data-noteid="13">
<p><span>13</span></p><section>
<p>
Austral&#39;s creator was the first person I talked to when I realized all of this!
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>


</section>
<section>
<p>
With your help, we can bring a new language into the world that focuses on <b>speed</b>, <b>safety</b>, <b>flexibility</b>, and <b>ease of use.</b>
</p>

</section>
<section>
<p>
We’re a very small team of passionate individuals, working on this on our own and not backed by any corporation.
</p>

</section>
<section>
<p>
If you want to support our work, please consider <a href="https://github.com/sponsors/ValeLang">sponsoring us on GitHub</a>!
</p>

</section>
<section>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor us on GitHub
  </a>
</center>


</section>
<section>
<p>
Those who sponsor us also get extra benefits, including:
</p>
<ul>
<li>
Early access to all of our articles!
</li>
<li>
A sneak peek at some of our more ambitious designs, such as memory-safe allocators based on algebraic effects, an async/await/goroutine hybrid that works without data coloring or function coloring, and more.
</li>
<li>
Your name on the <a href="https://vale.dev/">vale.dev</a> home page!
</li>
</ul>

</section>
<section>
<p>
With enough sponsorship, we can:
</p>
<ul>
<li>
Start a a 501(c)(3) non-profit organization to hold ownership of Vale. <a href="#note14" data-noteid="14">14</a>
</li>
<li>
Buy the necessary computers to support more architectures.
</li>
<li>
Work on this full-time.
</li>
<li>
Make Vale into a production-ready language, and push it into the mainstream!
</li>
</ul>

</section>
<section>
<p>
We have a strong <a href="https://vale.dev/roadmap">track record</a>, and during this quest we&#39;ve discovered and implemented a lot of completely new techniques:
</p>
<ul>
<li>
The <a href="https://verdagon.dev/blog/linear-types-borrowing">Linear-Aliasing Model</a> that lets us use linear types where we need speed, and <a href="https://verdagon.dev/blog/generational-references">generational references</a> where we need the flexibility of shared mutability.
</li>
<li>
<a href="https://verdagon.dev/blog/first-regions-prototype">Region Borrowing</a>, which makes it easier to write efficient code by composing shared mutability with the ability to temporarily freeze data.
</li>
<li>
<a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">Higher RAII</a>, where the language adds logic safety by enforcing that we eventually perform a specific future operation.
</li>
<li>
<a href="https://verdagon.dev/blog/perfect-replayability-prototyped">Perfect Replayability</a> makes debugging race conditions obsolete  by recording all inputs and replaying execution exactly.
</li>
</ul>

</section>
<section>
<p>
These have been successfully prototyped. With your sponsorship we can polish them, integrate them, and bring these techniques into the mainstream. <a href="#note15" data-noteid="15">15</a>
</p>

</section>
<section>
<p>
Our next steps are focused on making Vale more user-friendly by:
</p>
<ol>
<li>
Finalizing the compiler&#39;s error messages and improving compile speeds.
</li>
<li>
Polishing interop with other languages.
</li>
<li>
Growing the standard library and ecosystem!
</li>
</ol>

</section>
<section>
<p>
We aim to combine and add to the benefits of our favorite languages:
</p>
<ul>
<li>
The scalability of <a href="https://go.dev/">Go</a> and ergonomics of <a href="https://scala-lang.org/">Scala</a>, but using Vale&#39;s <a href="https://verdagon.dev/blog/linear-types-borrowing">linear-aliasing model</a> instead of garbage collection.
</li>
<li>
C++&#39;s single-ownership shared-mutability abilities with more <a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">memory safety</a>, without sacrificing its flexibility.
</li>
<li>
The speed and safety of <a href="https://www.rust-lang.org/">Rust</a>, but with <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">easier borrowing rules</a>, more <a href="https://verdagon.dev/blog/higher-raii-7drl">compile time guarantees</a>, and better compatibility with <a href="https://verdagon.dev/blog/linear-types-borrowing">shared mutability</a>.
</li>
</ul>

</section>
<section>
<p>
<b>We need your help to make this happen!</b>
</p>

</section>
<section>
<p>
If you&#39;re impressed by our <a href="https://vale.dev/roadmap">track record</a> and believe in the direction we&#39;re heading, please consider sponsoring us:
</p>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor us on GitHub
  </a>
</center>


</section>
<section>
<p>
If you have any questions, always feel free to reach out via <a href="mailto:verdagon_epsa@verdagon.dev">email</a>, <a href="https://twitter.com/vale_pl">twitter</a>, <a href="https://discord.gg/SNB8yGH">discord</a>, or the <a href="https://reddit.com/r/vale">subreddit</a>. Cheers!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note14" data-noteid="14">
<p><span>14</span></p><section>
<p>
Tentatively name the Vale Software Foundation.
</p>

</section>
</div>
<div id="note15" data-noteid="15">
<p><span>15</span></p><section>
<p>
 <a href="https://verdagon.dev/blog/generational-references">Generational references</a>, the <a href="https://verdagon.dev/blog/linear-types-borrowing">linear-aliasing model</a>, and <a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">higher RAII</a> are all complete, and <a href="https://verdagon.dev/blog/first-regions-prototype">Region borrowing</a>, <a href="https://verdagon.dev/blog/fearless-ffi">fearless FFI</a>, and <a href="https://verdagon.dev/blog/perfect-replayability-prototyped">perfect replayability</a> have been successfully prototyped. Be sure to check out the experimental version of the compiler!

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    
    
  

    </div>
  </div></div>
  </body>
</html>
