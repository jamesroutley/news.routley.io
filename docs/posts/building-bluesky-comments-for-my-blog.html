<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://natalie.sh/posts/bluesky-comments/">Original</a>
    <h1>Building Bluesky comments for my blog</h1>
    
    <div id="readability-page-1" class="page"><p data-astro-cid-2q5oecfc=""> I hate disqus too much. </p><article data-astro-cid-2q5oecfc=""> 
<p>I’ve been running my blog without decent comments for years. Not by choice, really - I just couldn’t find a solution that didn’t suck.</p>
<ul>
<li>
<p>Disqus? Slow, heavy, tracks users, and I don’t own anything. Plus it makes every page 100x slower to load.</p>
</li>
<li>
<p>Self-hosted solutions? Great in theory. (not really.) You’re signing up to manage users, moderate spam, maintain databases, and deal with all the headaches that come with running basically a miniature social platform. And if your users aren’t where you are, it’s probably slow as hell.</p>
</li>
<li>
<p>GitHub Issues as comments? Probably works for some developer blogs, but feels hacky and limits your audience to people with GitHub accounts.</p>
</li>
<li>
<p>No comments at all? Clean and simple, but you lose the conversations. Some of my favorite discoveries came from comment threads that went in unexpected directions.</p>
</li>
</ul>
<p>I’ve been a Bluesky user for a while. Recently, the community has been feeling healthier than Twitter ever did, the API is designed, and this decentralized approach means I don’t necessarily have to be beholden to a single company. People have been doing some interesting things with Bluesky, like on-protocol blog content and using Bluesky comments as a comment system. Why not do some of that for myself?</p>
<h2 id="why-bluesky-actually-makes-sense">Why Bluesky Actually Makes Sense</h2>
<p>The more I thought about it, the more directly using Bluesky for comments made sense:</p>
<ul>
<li>
<p>No infrastructure to maintain. (for me, at least) I don’t need to run databases, manage user accounts, or build moderation tools. Bluesky handles all of that.</p>
</li>
<li>
<p>Rich(er) content support. People can post images, links, and in threads. All the stuff that makes conversations interesting.</p>
</li>
<li>
<p>Real identities. Since people are using their actual Bluesky profiles, and your one profile can <em>actually</em> be used on any supported platform, there’s more accountability and less incentive to drive-by troll.</p>
</li>
<li>
<p>Cross-platform conversations. Comments live on Bluesky too, so people can discover my blog posts through social media and vice versa.</p>
</li>
<li>
<p>I own my content, they own theirs. No platform lock-in for anyone!</p>
</li>
</ul>
<p>The workflow is simple: I publish a blog post, share it on Bluesky, edit the post to add the AT URI, and the replies to that Bluesky post become the comments on my blog.</p>
<h2 id="building-the-component">Building the Component</h2>
<h3 id="understanding-the-at-protocol">Understanding the AT Protocol</h3>
<p>Bluesky runs on the AT Protocol, which has surprisingly okay documentation. The key concepts I needed:</p>
<ul>
<li><strong>DIDs</strong> (Decentralized Identifiers): Unique user IDs like <code>did:plc:abc123...</code> or <code>did:web:joe.coffee</code></li>
<li><strong>CIDs</strong> (Content Identifiers): Unique post IDs</li>
<li><strong>AT URIs</strong>: Addresses for content like <code>at://did:plc:user.../app.bsky.feed.post/postid</code></li>
</ul>
<p>To fetch comments, I just need to call the <code>getPostThread</code> endpoint with the right URI. No authentication required. Easy peasy.</p>
<h3 id="component-architecture">Component Architecture</h3>
<p>I ended up with three main pieces:</p>
<ol>
<li>The main comments component that fetches and displays the thread.</li>
<li>A reply component that handles rendering individual posts and their replies. Also includes metadata and a link to the original Bluesky post.</li>
<li>An embed component for rich content like images and open graph previews.</li>
</ol>
<p>This separation made each piece reasonably manageable, reasonable, and small.</p>
<h3 id="the-threading-challenge">The Threading Challenge</h3>
<p>The interesting part was handling nested replies. Bluesky threads can go arbitrarily deep, but I needed to display them in a way that’s readable and doesn’t break layouts.</p>
<p>I settled on a naive recursive approach where each reply can render child replies, with visual indentation to show the hierarchy. I cap it at 5 levels deep because beyond that, conversations usually devolve into two people arguing anyway.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> MAX_DEPTH </span><span>=</span><span> 5</span><span>;</span></span>
<span><span>const</span><span> BlueskyReply</span><span> =</span><span> ({</span><span> thread</span><span>,</span><span> depth</span><span> =</span><span> 0</span><span> })</span><span> =&gt;</span><span> {</span></span>
<span><span>  return</span><span> (</span></span>
<span><span>    &lt;</span><span>div style</span><span>=</span><span>{{</span><span> marginLeft</span><span>:</span><span> depth </span><span>*</span><span> 12</span><span> }}</span><span>&gt;</span></span>
<span><span>      {</span><span>/* Render the post content */</span><span>}</span></span>
<span></span>
<span><span>      {</span><span>depth</span><span> &lt; </span><span>MAX_DEPTH</span><span> &amp;&amp; </span><span>thread</span><span>.</span><span>replies</span><span>?.</span><span>map</span><span>(</span><span>reply</span><span> =&gt;</span></span>
<span><span>        &lt;</span><span>BlueskyReply</span><span> thread</span><span>=</span><span>{</span><span>reply</span><span>}</span><span> depth</span><span>=</span><span>{</span><span>depth + </span><span>1</span><span>}</span><span> /&gt;</span></span>
<span><span>      )</span><span>}</span></span>
<span><span>    &lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>  )</span><span>;</span></span>
<span><span>};</span></span></code></pre>
<h3 id="handling-rich-content">Handling Rich Content</h3>
<p>One of the nice things about Bluesky is that posts can contain more than just text. People embed images, external links, and even quote other posts. Each embed type needs special handling.</p>
<p><strong>Images</strong> were the most complex. Bluesky serves them through their CDN, and people often post multiple images in a single reply. I built a responsive grid layout that adapts based on image count, plus a modal for viewing images full-screen.</p>
<p><strong>External links</strong> get rendered as cards with thumbnails and descriptions, just like they appear in Bluesky apps.</p>
<p><strong>Other embed types</strong> get a graceful fallback message since the AT Protocol is extensible and new embed types might appear.</p>
<h3 id="integrating-with-astro">Integrating with Astro</h3>
<p>Getting this working with my Astro blog was straightforward. I had the React integration (which I already had for my background and music components) and used the <code>client:load</code> directive to ensure the comment component hydrates immediately:</p>
<pre tabindex="0" data-language="astro"><code><span><span>---</span></span>
<span><span>import</span><span> BlueskyComments </span><span>from</span><span> &#39;../components/bsky-comments.tsx&#39;</span><span>;</span></span>
<span><span>---</span></span>
<span></span>
<span><span>{</span><span>post</span><span>.</span><span>data</span><span>.</span><span>bsky </span><span>&amp;&amp;</span><span> (</span></span>
<span><span>  &lt;</span><span>BlueskyComments</span></span>
<span><span>    did</span><span>=</span><span>{</span><span>post</span><span>.</span><span>data</span><span>.</span><span>bsky</span><span>.</span><span>did</span><span>}</span></span>
<span><span>    postCid</span><span>=</span><span>{</span><span>post</span><span>.</span><span>data</span><span>.</span><span>bsky</span><span>.</span><span>postCid</span><span>}</span></span>
<span><span>    client</span><span>:</span><span>load</span></span>
<span><span>  /&gt;</span></span>
<span><span>)</span><span>}</span></span></code></pre>
<p>Now I just add this to any post’s frontmatter to enable comments:</p>
<pre tabindex="0" data-language="yaml"><code><span><span>bsky</span><span>:</span></span>
<span><span>  did</span><span>:</span><span> &#34;my-bluesky-did&#34;</span></span>
<span><span>  postCid</span><span>:</span><span> &#34;the-post-id&#34;</span></span></code></pre>
<h2 id="what-i-learned">What I Learned</h2>
<h3 id="typescript-is-your-friend">TypeScript is Your Friend</h3>
<p>There are proper TypeScript types for all their API responses through the <code>@atcute/client</code> package. This made development much smoother as I could rely on autocomplete and catch type errors before they became runtime bugs.</p>
<h3 id="progressive-enhancement-works">Progressive Enhancement Works</h3>
<p>I built the comments as an enhancement to the blog, not a core dependency. If JavaScript is disabled or the API is down, the blog post (rendered a long time ago) still works perfectly. The comments just don’t appear.</p>
<h3 id="performance-by-default--ish">Performance by Default (-ish)</h3>
<p>Since I’m not managing any backend infrastructure, server-side performance optimizations are just there. Bluesky’s CDN handles image delivery, their public API is fast and cached, and I don’t have to care about database queries or server scaling.</p>
<h2 id="the-results">The Results</h2>
<p>I’m pretty happy with how it turned out. The conversations feel more natural than traditional blog comments - people use their actual profiles, share images and links, and more. It’s a lot more like social media.</p>
<h2 id="whats-next">What’s Next</h2>
<p>I’m considering a few improvements, but honestly, the core system works so well that I’m not in a rush to change it. Sometimes the best solution is the one just works, almost invisibly.</p>
<h2 id="why-this-approach-works">Why This Approach Works</h2>
<p>Traditional comment systems try to recreate social media features on every individual website. I think that’s backwards. People already have social media accounts they like using. Instead of forcing them to create new accounts and learn new interfaces, why not try meeting them where they already are?</p>
<p>This approach scales with the platform because it <em>uses</em> the platform. As Bluesky grows, more people can participate in blog discussions without any additional work from me. And because everything is built on open protocols, I’m not locked into any single platform’s decisions. If Bluesky ever changes for the worse, I can always switch to another AppView, such as zeppelin or Blacksky’s AppView.</p>
<p>I could theoretically even write my own comments AppView. ATProto is designed to be flexible, especially with data, so doing such would be quite simple. I’d just need to listen to the right events on the firehose and store the data in a way that makes sense and rebuild the comment thread every so often.</p>
<p>In my opinion, the web is better when independent sites can connect to broader conversations without sacrificing their independence. I feel like this <del>is</del> was the goal of other decentralised platforms like Mastodon, but Bluesky’s focus on user-owned identities and app intercompat via the PDS ultimately makes it a better fit.</p>
<hr/>
<p><em>Want to see it in action? The comments are right below this post, powered by the system I mentioned above. Meta.</em></p> </article></div>
  </body>
</html>
