<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://m4xc.dev/articles/fundamental-rc/">Original</a>
    <h1>Fundamentals of Radiance Cascades</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><span> 2024-10-22 • 3683 words • 19 min • Max &lt;mxcop&gt; </span></p><h2 id="introduction">Introduction</h2><p>In this article I&#39;m going to share my understanding of the fudamentals of Radiance Cascades. <em>(abbreviated as RC)</em></p><blockquote><p>For the sake of simplicity I will explain everything in 2D, however RC can be expanded into 3D aswell.</p></blockquote><p>So, what can RC in 2D <em>(also referred to as Flatland)</em> achieve?</p><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/showcase.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Diffuse global illumination in flatland.</i></p></div><p>An awesome property of this method is that this is done <span>fully-deterministically</span> and without temporal re-use!</p><p><em>So without further ado, let&#39;s dive in!</em></p><hr/><h2 id="observations">Observations</h2><p>Radiance Cascades is built on <strong>two</strong> key observations.</p><h3 id="angular-observation">Angular Observation</h3><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/angular-anim.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Figure A: Circular object with a radiance probe.</i></p></div><p><em>Figure A</em>, depicts a <span>circular object</span> on the left, with a radiance probe to the right of it.</p><p>What we can observe here is that the angle between rays we can get away with for a probe, depends on <strong>two</strong> factors:</p><ol><li>$ D $ The <span>distance</span> to the furthest object.</li><li>$ w $ The <span>size</span> of the smallest object.</li></ol><p>In the <a href="https://github.com/Raikiri/RadianceCascadesPaper">paper</a> this restriction is formalized with this equation: $ \Delta_\omega &lt; w/D $</p><h3 id="spatial-observation">Spatial Observation</h3><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/spatial-anim.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Figure B: Penumbra created by line light and line occluder.</i></p></div><p><em>Figure B</em>, shows that we can resolve a penumbra by <span>interpolating</span> between only 2 probes. <em>(Shown as blue dots)</em></p><p>We can observe that the probe spacing is dependent on <strong>two</strong> factors:</p><ol><li>$ D $ The <span>distance</span> to the closest object.</li><li>$ w $ The <span>size</span> of the smallest object.</li></ol><blockquote><p>Does that not sound familiar?</p></blockquote><p>The <span>distance</span> is the <strong>inverse</strong> of the angular observation!</p><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/penumbra-anim.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Figure C: Moving the line occluder around.</i></p></div><p><em>Figure C</em>, shows that regardless of the distance between the light and the occluder, the penumbra still <span>grows with distance</span>.</p><p><em>Figure C</em>, also serves to <span>highlight</span> that we&#39;re interested in the nearest or furthest object, <strong>not light source</strong>.</p><h3 id="penumbra-condition-theorem">Penumbra Condition / Theorem</h3><p>While the required angle between rays ($ \Delta_\omega $) decreases, the required distance between probes ($ \Delta_p $) increases and vice versa.</p><p>In the <a href="https://github.com/Raikiri/RadianceCascadesPaper">paper</a> this relationship is formalized as the <span>penumbra condition</span> with this equation:</p><p>$ \begin{cases} \Delta_p &lt;\sim D, \\ \Delta_\omega &lt;\sim 1/D \end{cases} $</p><blockquote><p>$ A &lt;\sim B $ means that; $ A $ is less than the output of some function, which scales linearly with $ B $.</p></blockquote><p>$ w $ <em>(the size of the smallest object)</em> is not included in the <span>penumbra condition</span> because it is the same at all points in the scene.</p><h3 id="recap">Recap</h3><p>Ok, these <span>observations</span> took me some time to <em>wrap my head around</em> but they&#39;re key to understanding RC.</p><p>What we&#39;ve <span>observed</span> is that the <strong>further</strong> we are from the closest object in the scene:</p><ol><li>The <strong>less</strong> spatial resolution we need. <em>(e.g. the <span>larger spacing</span> can be between probes)</em></li><li>The <strong>more</strong> angular resolution we need. <em>(e.g. the <span>more rays</span> we need per probe)</em></li></ol><hr/><h2 id="exploiting-observations">Exploiting Observations</h2><p>Now that we&#39;ve made the observations and defined the penumbra theorem, let&#39;s look at how we can <span>exploit</span> these observations.</p><h3 id="angular">Angular</h3><p>We&#39;ve got a <strong>problem</strong>: classic probes we&#39;re all used to, can hit objects at <span>virtually any distance</span>.</p><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/splitting-anim.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Figure D: Probe being split into “rings”.</i></p></div><p><em>Figure D</em>, shows one way of narrowing this window, we can discretize our circular probes into rings.</p><blockquote><p>These new rays with a limited range, are referred to as <strong>intervals</strong>.</p></blockquote><p>This is exactly what we&#39;re looking for to <span>exploit</span> the <span>angular part</span> of the penumbra theorem.</p><p><img alt="Figure E: Increasing angular resolution for more distant “rings”." title="Figure E: Increasing angular resolution for more distant “rings”." src="https://m4xc.dev/img/articles/fundamental-rc/inc-angular-split.png" width="360px"/><i>Figure E: Increasing angular resolution for more distant “rings”.</i></p><p>In order to still <span>capture</span> our entire scene, we will have many of these <em>rings</em>.</p><p>In the example in <em>Figure E</em>, we increase the interval count by <strong>2x</strong> with every consecutive ring.</p><h3 id="spatial">Spatial</h3><p>So far, with the angular observation we haven&#39;t really achieved any <span>reduction</span> in ray count.</p><p>This is when we <span>drop the idea</span> that these rings together make up a <strong>single</strong> probe.</p><blockquote><p>From now on when we refer to <strong>probes</strong>, we are referring to <strong>rings</strong>.</p></blockquote><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/spatial-exploit-anim.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Figure F: Increasing probe/ring spacing.</i></p></div><blockquote><p>The length of the intervals in <em>Figure F</em> is <strong>incorrect</strong>, this is to make them easier on the eyes.</p></blockquote><p><em>Figure F</em>, shows one way we can use this new <span>perspective</span> on the probes.</p><p>So, when our <span>distance window</span> gets further and further away, we may increase the <span>spacing</span> between those probes.</p><p>There is a visible <span>disconnect</span> between probes between cascades, this <em>does</em> result in artifacts, mainly <em>ringing</em>.</p><blockquote><p>There are fixes out there <em>(e.g. bilinear &amp; parallax fix)</em>, however they&#39;re out of the scope of this article.</p></blockquote><hr/><h2 id="cascades">Cascades</h2><p>Now that we understand how we can exploit the <strong>two</strong> key observations.</p><div><p><img alt="Figure G1: Cascade 0, with 4x4 probes." title="Figure G1: Cascade 0, with 4x4 probes." src="https://m4xc.dev/img/articles/fundamental-rc/cascade0.png" width="360px"/><i>Figure G1: Cascade 0, with 4x4 probes.</i></p><p><img alt="Figure G2: Cascade 1, with 2x2 probes." title="Figure G2: Cascade 1, with 2x2 probes." src="https://m4xc.dev/img/articles/fundamental-rc/cascade1.png" width="360px"/><i>Figure G2: Cascade 1, with 2x2 probes.</i></p></div><p>A cascade is basically a <span>grid of probes</span>, in which all probes have <strong>equal</strong> properties.</p><p>The reason we call them cascades is because they <span>cascade outwards</span> with increasing interval count and length.</p><h3 id="cascade-hierarchy">Cascade Hierarchy</h3><p>A cascade <span>on its own</span> isn&#39;t super useful, only capturing a small part of the scene.</p><p>Most of the time, for <span>simplicity</span> sake we will decrease probe count between cascades by <strong>2x</strong> along each axis.</p><p>If we&#39;re following the <span>penumbra condition</span>, the spatial and angular resolution should be <strong>inversely proportional</strong>.</p><blockquote><p>However, there&#39;s also many implementation which decrease the angle between intervals by <strong>4x</strong> instead.</p></blockquote><h3 id="cascade-memory">Cascade Memory</h3><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/probe-memory-anim.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Figure H: 4x4 probe in texture memory.</i></p></div><p>The most common way we <span>store probes</span> in memory is using a <strong>2D texture</strong>.</p><pre data-lang="glsl"><code data-lang="glsl"><span>const </span><span>int</span><span> dir_count </span><span>= </span><span>16</span><span>; </span><span>/* 4x4 */
</span><span>const </span><span>int</span><span> dir_index </span><span>=</span><span> ...;
</span><span>
</span><span>/* Compute interval direction from direction index */
</span><span>float</span><span> angle </span><span>= </span><span>2.0 </span><span>*</span><span> PI </span><span>* </span><span>((</span><span>float</span><span>(dir_index) </span><span>+ </span><span>0.5</span><span>) </span><span>/ </span><span>float</span><span>(dir_count));
</span><span>vec2</span><span> dir    </span><span>= </span><span>vec2</span><span>(</span><span>cos</span><span>(angle), </span><span>sin</span><span>(angle));
</span></code></pre><blockquote><p>The <em>code snippet</em> above shows how we can derive an interval direction from its index within its probe.</p></blockquote><p><img alt="Figure I: Cascade in texture memory." title="Figure I: Cascade in texture memory." src="https://m4xc.dev/img/articles/fundamental-rc/cascade-memory.png" width="360px"/><i>Figure I: Cascade in texture memory.</i></p><p>Now, of course we&#39;re not going to store <span>each probe</span> in its own texture.</p><blockquote><p>There&#39;s also an alternative superior data layout, called <strong>direction first</strong>.</p></blockquote><p>This is where we see why decreasing the probe count by <strong>2x</strong> on <span>each axis</span> is nice.</p><p>If we decrease the angle between intervals by <strong>2x</strong> each cascade, each subsequent cascade will have <span>half the intervals</span> of the previous.</p><blockquote><p>Meaning our total interval count will aproach <strong>2x</strong> the interval count of the first cascade as we add more cascades.</p></blockquote><p>If instead, we decrease the angle between intervals by <strong>4x</strong> each cascade, each cascade will have <span>equal the intervals</span>.</p><blockquote><p>Meaning our total interval count will grow linearly with cascade count.</p></blockquote><p>I <span>recommend</span> using the <strong>4x</strong> branching method where interval count remains equal, it is <span>simpler</span> to work with in practice.</p><h3 id="cascade-gathering">Cascade Gathering</h3><p>To gather the <span>radiance</span> for each cascade we simply loop over each texel in its memory texture.</p><p>First, let&#39;s find out what our coordinate is within the probe we&#39;re apart of:</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Get the local texel coordinate in the local probe */
</span><span>const </span><span>ivec2</span><span> dir_coord </span><span>=</span><span> texel_coord </span><span>%</span><span> probe_size;
</span></code></pre><p>Second, we can convert this coordinate to a <span>direction index</span>:</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Convert our local texel coordinate to a direction index */
</span><span>const </span><span>int</span><span> dir_index </span><span>=</span><span> dir_coord.</span><span>x </span><span>+</span><span> dir_coord.</span><span>y </span><span>*</span><span> probe_size.</span><span>x</span><span>;
</span></code></pre><p>Third, using that direction index we can obtain the direction vector: <em>(like I showed earlier)</em></p><pre data-lang="glsl"><code data-lang="glsl"><span>const </span><span>int</span><span> dir_count </span><span>=</span><span> probe_size.</span><span>x </span><span>*</span><span> probe_size.</span><span>y</span><span>;
</span><span>
</span><span>/* Compute interval direction from direction index */
</span><span>float</span><span> angle </span><span>= </span><span>2.0 </span><span>*</span><span> PI </span><span>* </span><span>((</span><span>float</span><span>(dir_index) </span><span>+ </span><span>0.5</span><span>) </span><span>/ </span><span>float</span><span>(dir_count));
</span><span>vec2</span><span> dir    </span><span>= </span><span>vec2</span><span>(</span><span>cos</span><span>(angle), </span><span>sin</span><span>(angle));
</span></code></pre><p>Now we have to <span>cast the interval</span>, let&#39;s not forget intervals have a start and end time:</p><pre data-lang="glsl"><code data-lang="glsl"><span>vec2</span><span> interval_start </span><span>=</span><span> probe_pos </span><span>+</span><span> dir </span><span>*</span><span> start_time;
</span><span>vec2</span><span> interval_end   </span><span>=</span><span> probe_pos </span><span>+</span><span> dir </span><span>*</span><span> end_time;
</span><span>vec3</span><span> radiance       </span><span>= </span><span>cast_interval</span><span>(interval_start, interval_end);
</span></code></pre><p>It&#39;s important to note, the <code>cast_interval</code> function can use whatever <span>ray casting method</span> you want.</p><p>The <span>start &amp; end time</span> of our intervals depends on which cascade we&#39;re evaluating, and what branching is used.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Get the scale factor for an interval in a given cascade */
</span><span>float </span><span>interval_scale</span><span>(</span><span>int </span><span>cascade_index</span><span>) {
</span><span>    </span><span>if </span><span>(cascade_index </span><span>&lt;= </span><span>0</span><span>) </span><span>return </span><span>0.0</span><span>;
</span><span>
</span><span>    </span><span>/* Scale interval by 4x each cascade */
</span><span>    </span><span>return </span><span>float</span><span>(</span><span>1 </span><span>&lt;&lt; </span><span>(</span><span>2 </span><span>*</span><span> cascade_index));
</span><span>}
</span><span>
</span><span>/* Get the start &amp; end time of an interval for a given cascade */
</span><span>vec2 </span><span>interval_range</span><span>(</span><span>int </span><span>cascade_index</span><span>, </span><span>float </span><span>base_length</span><span>) {
</span><span>    </span><span>return</span><span> base_length </span><span>* </span><span>vec2</span><span>(</span><span>interval_scale</span><span>(cascade_index), </span><span>interval_scale</span><span>(cascade_index </span><span>+ </span><span>1</span><span>));
</span><span>}
</span></code></pre><blockquote><p>The <code>base_length</code> above is the length you want intervals in cascade0 to have.</p></blockquote><hr/><h2 id="merging">Merging</h2><p>Now we have our <span>radiance field</span> stored as cascades in textures. <em>Awesome!</em></p><p>We&#39;re going to extract specifically the <span>diffuse irradiance</span> of the scene. <em>(also called fluence in 2D)</em></p><h3 id="merging-intervals">Merging Intervals</h3><p>We&#39;ve talked about basically splitting our rays into seperate intervals, probes =&gt; rings.</p><div><video autoplay="" loop="" muted="" playsinline=""><source src="https://m4xc.dev/anim/articles/fundamental-rc/interval-merge-anim.mp4" type="video/mp4"/> Video tag is not supported.</video><p><i>Figure J: Green interval should occlude red interval.</i></p></div><p>In <em>Figure J</em>, we can see that intervals earlier in the chain can <span>occlude</span> intervals further down the chain.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Merge 2 connected intervals with respect to their visibility term */
</span><span>vec4 </span><span>merge_intervals</span><span>(</span><span>vec4 </span><span>near</span><span>, </span><span>vec4 </span><span>far</span><span>) {
</span><span>    </span><span>/* Far radiance can get occluded by near visibility term */
</span><span>    </span><span>const </span><span>vec3</span><span> radiance </span><span>=</span><span> near.</span><span>rgb </span><span>+ </span><span>(far.</span><span>rgb </span><span>*</span><span> near.</span><span>a</span><span>);
</span><span>
</span><span>    </span><span>return </span><span>vec4</span><span>(radiance, near.</span><span>a </span><span>*</span><span> far.</span><span>a</span><span>);
</span><span>}
</span></code></pre><p>The <em>code snippet</em> above shows how we can implement interval merging in code.</p><blockquote><p>We also merge the visibility terms, by multiplying them a hit will also be carried downwards. <em>(1.0 * 0.0 = 0.0)</em></p></blockquote><h3 id="merging-cones">Merging Cones</h3><p>It would be <span>really expensive</span> if we had to merge through each cascade for each possible direction.</p><p><img alt="Figure K: Cone made out of intervals." title="Figure K: Cone made out of intervals." src="https://m4xc.dev/img/articles/fundamental-rc/interval-cone.png" width="360px"/><i>Figure K: Cone made out of intervals.</i></p><p>Because we&#39;re trying to extract <span>diffuse lighting</span>, directional resolution isn&#39;t very important.</p><p>Because we have a <span>branch factor</span>, e.g. <strong>4x</strong>, each cascade we will merge <strong>4</strong> intervals down into <strong>1</strong> interval.</p><p>This is perfect for capturing our <span>low angular resolution</span> diffuse lighting!</p><h3 id="merging-spatially">Merging Spatially</h3><p>Not only our angular resolution changes between cascades, we also know our spatial resolution changes.</p><blockquote><p>The &#34;next cascade&#34; is the cascade above the current one, it has lower spatial &amp; higher angular resolution.</p></blockquote><p><img alt="Figure L: Merging with nearest probe only." title="Figure L: Merging with nearest probe only." src="https://m4xc.dev/img/articles/fundamental-rc/nearest-interp.png" width="360px"/><i>Figure L: Merging with nearest probe only.</i></p><p>In <em>Figure L</em>, we can clearly see this obvious grid pattern, which actually <span>visualizes</span> the probes themselves.</p><p><img alt="Figure M: Merging with 4 bilinear probes." title="Figure M: Merging with 4 bilinear probes." src="https://m4xc.dev/img/articles/fundamental-rc/bilinear-probes.png" width="360px"/><i>Figure M: Merging with 4 bilinear probes.</i></p><blockquote><p>Weights shown in <em>Figure M</em> are incorrect! They should always add up to <code>1.0</code>.</p></blockquote><p>Let&#39;s instead use <span>bilinear interpolation</span> to merge with the nearest <strong>4</strong> probes from the next cascade.</p><p>I like to think of it as <span>blurring</span> those blocky probes in <em>Figure L</em> with their neighbours.</p><blockquote><p>I tend to refer to the <strong>green</strong> probes as &#34;bilinear probes&#34; &amp; the <strong>blue</strong> probe as &#34;destination probe&#34;.</p></blockquote><p><img alt="Figure N: Smooth penumbrae using bilinear interpolation." title="Figure N: Smooth penumbrae using bilinear interpolation." src="https://m4xc.dev/img/articles/fundamental-rc/bilinear-interp.png" width="360px"/><i>Figure N: Smooth penumbrae using bilinear interpolation.</i></p><p>In <em>Figure N</em>, we can see the effect of <span>spatially interpolating</span> the probes using bilinear interpolation.</p><h3 id="merging-algorithm">Merging Algorithm</h3><p>Let&#39;s put our <span>angular &amp; spatial</span> merging together to finally obtain our diffuse lighting.</p><blockquote><p>Remember, we merge top down, starting with the lowest spatial resolution going down to the highest spatial resolution.</p></blockquote><p>Starting from the top, the <span>first cascade</span> doesn&#39;t have a cascade to merge with.</p><p>For every other cascade we will <span>merge</span> with the one above it, we can write this as: $ N_{i+1} \to N_{i} $</p><p>The first step is finding our <strong>4</strong> <span>bilinear probes</span> from <strong>N+1</strong>, and their respective weights.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Sub-texel offset to bilinear interpolation weights */
</span><span>vec4 </span><span>bilinear_weights</span><span>(</span><span>vec2 </span><span>ratio</span><span>) {
</span><span>    </span><span>return </span><span>vec4</span><span>(
</span><span>        (</span><span>1.0 </span><span>-</span><span> ratio.</span><span>x</span><span>) </span><span>* </span><span>(</span><span>1.0 </span><span>-</span><span> ratio.</span><span>y</span><span>),
</span><span>        ratio.</span><span>x </span><span>* </span><span>(</span><span>1.0 </span><span>-</span><span> ratio.</span><span>y</span><span>),
</span><span>        (</span><span>1.0 </span><span>-</span><span> ratio.</span><span>x</span><span>) </span><span>*</span><span> ratio.</span><span>y</span><span>,
</span><span>        ratio.</span><span>x </span><span>*</span><span> ratio.</span><span>y
</span><span>    );
</span><span>}
</span><span>
</span><span>void </span><span>bilinear_samples</span><span>(</span><span>vec2 </span><span>dest_center</span><span>, </span><span>vec2 </span><span>bilinear_size</span><span>, </span><span>out </span><span>vec4 </span><span>weights</span><span>, </span><span>out </span><span>ivec2 </span><span>base_index</span><span>) {
</span><span>    </span><span>/* Coordinate of the top-left bilinear probe when floored */
</span><span>    </span><span>const </span><span>vec2</span><span> base_coord </span><span>= </span><span>(dest_center </span><span>/</span><span> bilinear_size) </span><span>- </span><span>vec2</span><span>(</span><span>0.5</span><span>, </span><span>0.5</span><span>);
</span><span>
</span><span>    </span><span>const </span><span>vec2</span><span> ratio </span><span>= </span><span>fract</span><span>(base_coord);  </span><span>/* Sub-bilinear probe position */
</span><span>    weights </span><span>= </span><span>bilinear_weights</span><span>(ratio);
</span><span>    base_index </span><span>= </span><span>ivec2</span><span>(</span><span>floor</span><span>(base_coord)); </span><span>/* Top-left bilinear probe coordinate */
</span><span>}
</span></code></pre><p>As inputs our <code>bilinear_samples</code> takes the following parameters:</p><pre data-lang="glsl"><code data-lang="glsl"><span>vec2</span><span> dest_center </span><span>=</span><span> ...; </span><span>/* Center position of destination probe in pixels */
</span><span>vec2</span><span> bilinear_size </span><span>=</span><span> ...; </span><span>/* Size of bilinear probe in pixels */
</span></code></pre><p>Now we will have 2 <span>nested loops</span>:</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* For each extra N+1 interval */
</span><span>for </span><span>(</span><span>int</span><span> d </span><span>= </span><span>0</span><span>; d </span><span>&lt; </span><span>4</span><span>; d</span><span>++</span><span>) {
</span><span>    </span><span>/* For each N+1 bilinear probe */
</span><span>    </span><span>for </span><span>(</span><span>int</span><span> b </span><span>= </span><span>0</span><span>; b </span><span>&lt; </span><span>4</span><span>; b</span><span>++</span><span>) {
</span><span>        </span><span>const </span><span>ivec2</span><span> base_offset </span><span>= </span><span>bilinear_offset</span><span>(b);
</span><span>
</span><span>        </span><span>/* ... */
</span><span>    }
</span><span>}
</span></code></pre><p><img alt="Figure O: Merging for 1 interval (in blue)." title="Figure O: Merging for 1 interval (in blue)." src="https://m4xc.dev/img/articles/fundamental-rc/full-merge.png" width="360px"/><i>Figure O: Merging for 1 interval (in blue).</i></p><p>Looking at <em>Figure O</em>, we get a visual of what those <span>nested loops</span> are for.</p><blockquote><p>The <strong>green</strong> intervals in <em>Figure O</em> are colored based on their bilinear <strong>weights</strong>, brighter means a higher weight.</p></blockquote><p>You may have noticed the <code>bilinear_offset</code> function in the <span>inner loop</span>.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Convert index 0..4 to a 2d index in a 2x2 square */
</span><span>ivec2 </span><span>bilinear_offset</span><span>(</span><span>int </span><span>offset_index</span><span>) {
</span><span>    </span><span>const </span><span>ivec2</span><span> offsets[</span><span>4</span><span>] </span><span>= </span><span>{ </span><span>ivec2</span><span>(</span><span>0</span><span>, </span><span>0</span><span>), </span><span>ivec2</span><span>(</span><span>1</span><span>, </span><span>0</span><span>), </span><span>ivec2</span><span>(</span><span>0</span><span>, </span><span>1</span><span>), </span><span>ivec2</span><span>(</span><span>1</span><span>, </span><span>1</span><span>) };
</span><span>    </span><span>return</span><span> offsets[offset_index];
</span><span>}
</span></code></pre><p>We can add our <code>base_offset</code> to the <code>base_index</code> we got <span>earlier</span> to get the <strong>2D</strong> index of the bilinear probe.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Get the index of the bilinear probe to merge with */
</span><span>const </span><span>ivec2</span><span> bilinear_index </span><span>=</span><span> base_index </span><span>+</span><span> base_offset;
</span></code></pre><p>Now it is relatively trivial to use our <code>dir_index</code> we learned how to get earlier.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Get the directional base index */
</span><span>const </span><span>int</span><span> base_dir_index </span><span>=</span><span> dir_index </span><span>* </span><span>4</span><span>;
</span><span>
</span><span>/* Get the directional index we want to merge with */
</span><span>const </span><span>int</span><span> bilinear_dir_index </span><span>=</span><span> base_dir_index </span><span>+</span><span> d;
</span></code></pre><p>Then finally we can combine the <code>bilinear_dir_index</code> &amp; <code>bilinear_index</code> to get the <span>texel</span> coordinate in cascade <strong>N+1</strong> to merge with.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* Convert the directional index to a local texel coordinate */
</span><span>const </span><span>ivec2</span><span> bilinear_dir_coord </span><span>= </span><span>ivec2</span><span>(
</span><span>    bilinear_dir_index </span><span>%</span><span> bilinear_size.</span><span>x</span><span>,
</span><span>    bilinear_dir_index </span><span>/</span><span> bilinear_size.</span><span>y
</span><span>);
</span><span>
</span><span>/* Get the texel coordinate to merge with in cascade N+1 */
</span><span>const </span><span>ivec2</span><span> bilinear_texel </span><span>=</span><span> bilinear_index </span><span>*</span><span> bilinear_size </span><span>+</span><span> bilinear_dir_coord;
</span></code></pre><p>Merging we do using the <code>merge_intervals</code> function from <span>earlier</span> in the article.</p><pre data-lang="glsl"><code data-lang="glsl"><span>/* For each extra N+1 interval */
</span><span>vec4</span><span> merged </span><span>= </span><span>vec4</span><span>(</span><span>0.0</span><span>);
</span><span>for </span><span>(</span><span>int</span><span> d </span><span>= </span><span>0</span><span>; d </span><span>&lt; </span><span>4</span><span>; d</span><span>++</span><span>) {
</span><span>    </span><span>/* For each N+1 bilinear probe */
</span><span>    </span><span>vec4</span><span> radiance </span><span>= </span><span>vec4</span><span>(</span><span>0.0</span><span>);
</span><span>    </span><span>for </span><span>(</span><span>int</span><span> b </span><span>= </span><span>0</span><span>; b </span><span>&lt; </span><span>4</span><span>; b</span><span>++</span><span>) {
</span><span>        </span><span>/* ... */
</span><span>
</span><span>        </span><span>/* Fetch the bilinear interval from the cascade N+1 texture */
</span><span>        </span><span>const </span><span>vec4</span><span> bilinear_interval </span><span>= </span><span>textureFetch</span><span>(bilinear_texel);
</span><span>
</span><span>        </span><span>/* Merge our destination interval with the bilinear interval */
</span><span>        radiance </span><span>+= </span><span>merge_intervals</span><span>(destination_interval, bilinear_interval) </span><span>*</span><span> weights[b];
</span><span>    }
</span><span>
</span><span>    merged </span><span>+=</span><span> radiance </span><span>/ </span><span>4.0</span><span>;
</span><span>}
</span></code></pre><p><span>That&#39;s all</span>! We&#39;ve now merged all the cascades down into <strong>cascade0</strong>.</p><h3 id="final-pass">Final Pass</h3><p>I did say <em>&#34;that&#39;s all&#34;</em>, I know, I know, but there&#39;s <span>one more step</span>,</p><p>Luckily this is <em>relatively trivial</em>, we already have most of the code we need.</p><p><img alt="Figure P: Final result! (Credit: Fad&#39;s Shadertoy)" title="Figure P: Final result! (Credit: Fad&#39;s Shadertoy)" src="https://m4xc.dev/img/articles/fundamental-rc/final-result.png" width="540px"/><i>Figure P: Final result! (Credit: Fad&#39;s Shadertoy)</i></p><blockquote><p>Image credit: <a href="https://www.shadertoy.com/view/mtlBzX">Fad&#39;s Shadertoy</a>.</p></blockquote><p>If we did everything correctly, we should end up with a <span>beautiful</span> result like in <em>Figure P</em>.</p><p>For those who made it all the way till the end, <span>thank you</span> for reading my article!</p><hr/><h2 id="amazing-resources">Amazing Resources</h2><p>There&#39;s quite a few resources already out there related to RC. <em>(which also helped me)</em></p><ul><li>Alexander Sannikov&#39;s <a href="https://github.com/Raikiri/RadianceCascadesPaper">paper</a> on Radiance Cascades.</li><li>XorDev &amp; Yaazarai&#39;s articles, <a href="https://mini.gmshaders.com/p/radiance-cascades">part 1</a> &amp; <a href="https://mini.gmshaders.com/p/radiance-cascades2">part 2</a>.</li><li>SimonDev&#39;s video <a href="https://youtu.be/3so7xdZHKxw">https://youtu.be/3so7xdZHKxw</a>.</li><li>Christopher M. J. Osborne&#39;s <a href="https://arxiv.org/abs/2408.14425">paper</a> diving deeper into the bilinear fix.</li><li>Jason&#39;s blog post <a href="https://jason.today/rc">https://jason.today/rc</a>.</li><li>Fad&#39;s <a href="https://www.shadertoy.com/view/mtlBzX">Shadertoy</a> implementation.</li></ul><blockquote><p>Also check out our <a href="https://discord.gg/WQ4hCHhUuU">Discord community</a> there&#39;s a lot of awesome people there that might be able to help you out!</p></blockquote></div></div></div>
  </body>
</html>
