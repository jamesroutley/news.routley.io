<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://steven-giesel.com/blogPost/59752c38-9c99-4641-9853-9cfa97bb2d29">Original</a>
    <h1>Async2 – The .NET Runtime Async experiment concludes</h1>
    
    <div id="readability-page-1" class="page"><div b-gj8cwnhyng=""><p>The .NET team has been working on a new experiment called async2, which is a new implementation of the async/await pattern that is designed to be more efficient and more flexible than the current implementation. It started with green threads and ended with an experiment that moves <code>async</code> and <code>await</code> to the runtime. This post will cover the journey of <code>async2</code> and the conclusion of the experiment.</p>
<h2 id="where-all-began-green-threads">Where all began - Green threads</h2>
<p>Let&#39;s start here: <a href="https://github.com/dotnet/runtimelab/issues/2398"><em>&#34;Green Thread Experiment Results&#34;</em></a>. The team invested in an experiment to evaluate the feasibility of using green threads in the .NET runtime. But wait a second, what are green threads?</p>
<h3 id="green-threads">Green threads</h3>
<p>Green threads are user-space threads that are managed by a runtime library or a virtual machine (VM) instead of the operating system.<sup>Source: <a href="https://en.wikipedia.org/wiki/Green_thread">Wikipedia</a></sup> They are lightweight and can be created and managed more quickly than kernel threads. Green threads are also known as &#34;coroutines&#34; or &#34;fibers&#34; in other programming languages. The idea is that you, as a developer, don&#39;t have to worry about threads.</p>
<p>Currently, with threads and to some extend with <code>async</code>/<code>await</code>, a new stack is created. You can easily see that in your favourite IDE, if you debug:</p>
<p><img src="https://linkdotnetblog.azureedge.net/blog/20240812_Async2/stacks.webp" alt="stack"/></p>
<p>Green threads are different. <a href="https://stackoverflow.com/a/19098856/1892523">The memory of a green thread is allocated on the heap</a>. But all of this comes with a cost: As they aren&#39;t managed by the OS, they can&#39;t take advantage of multiple cores inherently. But for I/O-bound operations, they are a good fit.</p>
<h3 id="abandoning-green-threads">Abandoning green threads</h3>
<p>The key-challenges were (which lead to the abandonment of the green threads experiment):</p>
<ul>
<li>Complex interaction between green threads and existing async model</li>
<li>Interop with native code was complex and slower than using regular threads</li>
<li>Compatibility issues with security mitigations like shadow stacks</li>
<li>Uncertainty about whether it would be possible to make green threads faster than async in important scenarios, given the effort required for improvement.</li>
</ul>
<p>This lead to the conclusion that green threads are not the right way to go for the .NET runtime and gave birth to the <code>async2</code> experiment. From here on out, I will keep the term <code>async2</code> for the experiment, as it is the codename for the experiment.</p>
<h2 id="async2-the.net-runtime-async-experiment"><code>async2</code> - The .NET Runtime Async experiment</h2>
<p>Now, <code>async2</code> is obviously only a codename. The goal of the experiment was to move <code>async</code> and <code>await</code> to the runtime. The main motivation behind this was to make <code>async</code> more efficient and more flexible. As <code>async</code> is already used as an identifier in C#, the team decided to use <code>async2</code> as a codename for the experiment. <strong>If</strong> that thing ever makes it into the runtime, it will be called <code>async</code> - so it will be a replacement for the current <code>async</code> implementation. But let&#39;s start at the beginning.</p>
<h3 id="async-is-a-compiler-feature"><code>async</code> is a compiler feature</h3>
<p>I talked about this from time to time in my blog posts. For example:</p>
<ul>
<li><a href="https://steven-giesel.com/blogPost/720a48fd-0abe-4c32-83ac-26926d501895/the-state-machine-in-c-with-asyncawait"><em>&#34;The state machine in C# with async/await&#34;</em></a></li>
<li><a href="https://steven-giesel.com/blogPost/69dc05d1-9c8a-4002-9d0a-faf4d2375bce/c-lowering"><em>&#34;C# Lowering&#34;</em></a></li>
</ul>
<p>The current implementation of <code>async</code> and <code>await</code> is a compiler feature. The compiler generates a state machine for the <code>async</code> method. The runtime doesn&#39;t know anything about <code>async</code> and <code>await</code>. There is no trace of an <code>async</code>-like keyword in IL or in the JIT-compiled code. And that is where the experiment started.</p>
<p>Starting point is this nice GitHub issue: <a href="https://github.com/dotnet/runtime/issues/94620">&#34;<em>.NET 9 Runtime Async Experiment</em>&#34;</a>, which basically describes the whole experiment in more detail with an ongoing discussion from the community.</p>
<h3 id="async-is-a-runtime-feature"><code>async</code> is a runtime feature</h3>
<p>The goal of the experiment was to move <code>async</code> and <code>await</code> to the runtime. This would allow the runtime to have more control over the pattern itself. With that there would be also some different semantics:</p>
<h3 id="async2-and-executioncontext-and-synchronizationcontext"><code>async2</code> and <code>ExecutionContext</code> and <code>SynchronizationContext</code></h3>
<p><code>async2</code> would not have save or restore of <code>SynchronizationContext</code> and <code>ExecutionContext</code> at function boundaries, instead allowing callers to observe changes. With the <code>ExecutionContext</code>, this would shift a big change in how <code>AsyncLocal</code> behaves.</p>
<p>Today, <code>AsyncLocal</code> is used to store data that flows with the logical call context. It gets copied to the new context. That said, if a function deep down the call stack changes the value of an <code>AsyncLocal</code>, the caller will <strong>not</strong> see the updated value, only functions further down the logical async flow. Here an example:</p>
<pre><code>await new AsyncLocalTest().DoOuter();

public class AsyncLocalTest
{
    private readonly AsyncLocal&lt;string&gt; _asyncLocal = new();

    public async Task DoOuter()
    {
        _asyncLocal.Value = &#34;Outer&#34;;
        Console.WriteLine($&#34;DoOuter: {_asyncLocal.Value}&#34;);
        await DoInner();
        Console.WriteLine($&#34;DoOuter: {_asyncLocal.Value}&#34;);
    }

    private async Task DoInner()
    {
        _asyncLocal.Value = &#34;Inner&#34;;
        Console.WriteLine($&#34;DoInner: {_asyncLocal.Value}&#34;);
        await Task.Yield();
        Console.WriteLine($&#34;DoInner: {_asyncLocal.Value}&#34;);
    }
}
</code></pre>
<p>The output of this code is:</p>
<pre><code>DoOuter: Outer
DoInner: Inner
DoInner: Inner
DoOuter: Outer
</code></pre>
<p>With <code>async2</code> those changes are not &#34;reverted&#34; which would lead to a different output:</p>
<pre><code>DoOuter: Outer
DoInner: Inner
DoInner: Inner
DoOuter: Inner
</code></pre>
<h3 id="comparison-with-the-current-implementation-and-some-results">Comparison with the current implementation and some results</h3>
<p>The whole document, that describes all the details, can be found here: <a href="https://github.com/dotnet/runtimelab/blob/feature/async2-experiment/docs/design/features/runtime-handled-tasks.md">https://github.com/dotnet/runtimelab/blob/feature/async2-experiment/docs/design/features/runtime-handled-tasks.md</a></p>
<p>The team found out that the approach of putting <code>async</code> into the JIT might yield the best results overall. Here a basic overview:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>async</code></th>
<th><code>async2</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Performance</td>
<td>Generally slower than <code>async2</code>, especially for deep call stacks</td>
<td>Generally faster than <code>async</code>, with performance comparable to synchronous code in non-suspended scenarios</td>
</tr>
<tr>
<td>Exception Handling</td>
<td>Slow and inefficient, causing GC pauses and impacting responsive performance of applications</td>
<td>Improved EH handling, reducing the impact on application responsiveness</td>
</tr>
<tr>
<td>Stack Depth Limitation</td>
<td>Limited by stack depth, which can cause issues for deep call stacks</td>
<td>No explicit limitations on stack depth, allowing <code>async2</code> to handle deeper call stacks more efficiently</td>
</tr>
<tr>
<td>Memory Consumption</td>
<td>Generally lower than <code>async2</code>, especially in scenarios with many suspended tasks</td>
<td>Higher memory consumption due to capturing entire stack frames and registers, but still acceptable compared to other factors like pause times</td>
</tr>
</tbody>
</table>
<h2 id="where-do-we-go-from-here">Where do we go from here?</h2>
<p>As the name suggests, this is just an experiment, that may lead to a replacement of <code>async</code> <strong>in some years</strong>. Yes, <strong>years</strong>. It might take a while until this is production-ready. And for the transition phase, there has to be interop for <code>async</code> ↔ <code>async2</code>. Anyway - a very good starting point and I am looking forward to the future of <code>async2</code>.</p>
</div></div>
  </body>
</html>
