<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jason-williams.co.uk/speeding-up-vscode-extensions-in-2022">Original</a>
    <h1>Speeding up VSCode extensions in 2022</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  
  <div>
      <div>            
        <article>
	

	<p><time datetime="2022-01-27T17:17:17" pubdate="">January 27, 2022</time>
		</p>

 
<p>I was curious to know if the functionality of VSCode can catch up with the native speed of some editors, such as Sublime. That led me to seek out where some bottlenecks may be and where time is being spent. In this post I look at both the internals and extensions.</p>



<span id="more-565"></span>



<p>VSCode has a broad range of extensions, from <a href="https://www.dendron.so/">knowledge management</a> to <a href="https://twitter.com/Tyriar/status/1478372478544089091">image editors</a>, but what does the growing ecosystem mean for raw performance?</p>



<p>It can often be quick and easy to point at the underlying stack (in this case, Electron) and say that’s where problems lay, but I’ve found it isn’t always the case. This post explores a deep dive into the internals, shows areas that can be improved, plus talks through some changes we may see this year. It should be of interest to anybody who is planning to work on an extension or has a general interest in the performance of VSCode.</p>



<h2 id="a-note-on-architecture">A note on architecture</h2>



<p>The crux of the design is for extensions to run in a separate process to the UI. This way, they’re more free to do their own thing without competing with the core runtime.</p>



<p>They are written in JS and share the same event loop which is advantageous because:</p>



<ol>
<li>Extensions don’t need to run all the time, so having a dedicated thread per-extension would be overkill and memory intensive.</li>
<li>They can yield back control when performing I/O (like reading a file or fetching from the network).</li>
<li>Sharing memory/configurations between them works a lot easier.</li>
</ol>



<p>However, It’s still possible for 1 extension to block another.</p>



<figure><img width="661" height="392" src="https://jason-williams.co.uk/wp-content/uploads/2022/01/VSCode-Threads.svg" alt="Diagram of VSCode architecure with extensions"/></figure>



<p>So, the main lifecycle of each extension is to parse the code (starting from the package.json file), instantiate, and call activate. The running time for this can sometimes be around 300ms.</p>



<p><a href="https://web.dev/rail/">R.A.I.L</a>, the user-centric performance model for web apps, describes 100ms+ “<em>representing a task</em>” (I.E you know something is happening), and 1000ms+ as <em>“users lose focus on the task they are performing”.</em> Now R.A.I.L is a guide for web, but the same applies in apps such as VSCode too. Having 10 extensions all taking around 300ms is not only 3s of startup time but falls into the realm of noticeable delay. Most extensions don’t need to spend that long starting up and these issues can be avoided.</p>



<p>Let’s look at a practical example.</p>



<h2 id="case-study-postfix-ts">Case Study: Postfix TS</h2>



<p>PR: <a href="https://github.com/ipatalas/vscode-postfix-ts/pull/52">https://github.com/ipatalas/vscode-postfix-ts/pull/52</a></p>



<p>Postfix TS is an extension that allows you to add completions to the end of already-existing expressions. So data.log becomes console.log(data). It’s fairly straight forward as far as extensions go, so I was intrigued as to why it had some beefy startup times.</p>



<p>First, I started with the <em>“Developer: Startup Performance”</em> command.</p>



<p>This shows you where time is being spent across the application. There is a section near the top just for extensions.</p>



<p><img loading="lazy" width="100%" height="116" src="https://lh3.googleusercontent.com/UzJAhqV-2pvrlLHD5zxDBA3XhskRHQx0OBEFZDKMLWTP2vNTzQjthBLNE32hwhhO32GZmKo_r9y9M_aiWQNx1_rasPtpLSB5sZBFmh16ujdmdOvF4R6w46BeDMEx_UOnyWkTmQTN"/></p>



<p>Let’s focus on 3 columns:</p>



<ul><li><strong>Load Code (Column 3): </strong> How long is spent parsing and executing the source code supplied by the extension (in ms). CPU-intensive script parsing and execution can delay not only other extensions, but also user interaction (not to mention cause battery drain if using a laptop or mobile device). In the above image, load code is the third column in, showing the value 153ms.</li><li><strong>Call Activate (Column 4): </strong>How long the extension takes to “activate”. This is the fourth column set to 15ms.</li><li><strong>Event (Column 6):</strong> What triggered the extension to activate? This is the sixth column with *.</li></ul>



<h3 id="event">Event</h3>



<p>Let’s start with Event. * is not ideal. * means the extension starts immediately, competing with other extensions and VSCode itself during startup. This often isn’t needed, as most extensions don’t do anything until called-upon or just run in the background. An exception to the rule is anything that changes the UI. Having a flash of unstyled-to-styled content can be jarring on the web, this UI is no different, things like sudden syntax colour change can be frustrating.</p>



<p>Extensions that offer codelens (like Gitlens) are fine to be delayed, as they are more of an enhancement to the current view. Plus, they’re not really useful until there’s some interaction with the editor (such as selecting a line).</p>



<p>If we imagine the loading of extensions like a queue from the top image, then it makes sense to have visual changes towards the front and then features that require interaction to be near the back. Developing for the web works the same way; fonts and CSS are loaded as early as possible, whereas some JS uses the <em>defer </em>attribute.</p>



<p>VSCode offers a comprehensive <a href="https://code.visualstudio.com/api/references/activation-events">range </a>of different activation events for extensions to use, but if you really need a startup hook, then consider using <a href="https://code.visualstudio.com/updates/v1_46#_onstartupfinished-activation-event">onStartupFinished</a>. This will kick off your extension after VSCode has loaded and will also give other extensions time to start up.</p>



<pre><code>
[
    &#34;onLanguage:javascript&#34;,
    &#34;onLanguage:typescript&#34;,
    &#34;onLanguage:javascriptreact&#34;,
    &#34;onLanguage:typescriptreact&#34;
]
</code>
</pre>



<p>This allows VSCode to ignore the extension if I’m not using those languages and will save me a whole chunk of startup time.</p>



<h3 id="load-code">Load Code</h3>



<p>In the image above, we see 153ms spent on load code. Now, this is relative, but anything much higher than the others tends to mean no bundling is happening. This is a problem because there’s a cost to opening and closing files. If it’s &gt; 100ms, that starts to become noticeable.  Loading 600 small files is much slower than loading one large file. When I unpacked the extension I saw entire projects in there, such as TypeScript (that thing is 50MB!). The node_modules folder was over 60MB and had 1,373 files.</p>



<p>If you’re putting together an extension, there’s nothing wrong with using the tsc CLI. It comes with TypeScript and is fully available without needing other packages. But, once you’re ready to distribute your extension (even for testing), you should switch to a bundler. I’ve found ESbuild is the easiest one to get up and running.</p>



<p>I set up an <a href="https://code.visualstudio.com/api/working-with-extensions/bundling-extension#using-esbuild">ESBuild</a> workflow; you can see it <a href="https://github.com/ipatalas/vscode-postfix-ts/pull/52/files#diff-7d111b05fe05c50beb729d1e99a36010fbda8c89b57a1a26ac3e7b0778a0ed53">here</a>. Now only a single file (extension.js) is generated and published.</p>



<h3 id="reduce-code-gen">Reduce code-gen</h3>



<p>I see far too many extensions setting ES6 or ES2015 as a compile target; there is no need for this. ES6 is almost seven years old. Almost no one is using a version of code that old.</p>



<p>Updating the compile target means having less code generated. Since newer syntax doesn’t need to be downlevelled, it also means faster build times, as there’s less work for the code transformer to do.</p>



<p>If you’re unsure which to choose, ES2020 is a good target, as that will cover the last few versions back to April 2021. Be sure to set a minimum version higher than v1.56. Anyone using a version lower will continue to use the previous version of your extension.</p>



<h3 id="results">Results</h3>



<figure><img loading="lazy" src="https://jason-williams.co.uk/wp-content/uploads/2022/01/postfix-chart-update1.svg" alt="" width="604" height="371"/></figure>



<p><strong>Before:</strong></p>



<p>58.4 MB (61,314,657 bytes), 201ms startup time</p>



<p><strong>After:</strong></p>



<p>3.43 MB (3,607,464 bytes), 32ms startup time</p>



<p>We’ve shaved off quite a bit of space and time, but remember, this is just one extension, there were many in this shape. I <a href="https://github.com/d4rkr00t/vscode-open-in-github/pull/42">did the same thing</a> with the Open In Github extension.</p>



<figure><img loading="lazy" width="600" height="371" src="https://jason-williams.co.uk/wp-content/uploads/2022/01/chart-2.svg" alt=""/></figure>



<p>Between the 2 extensions that’s just under half a second saved. There’s more improvement opportunities to dig into, some of which aren’t available today but are worth highlighting.</p>



<h2 id="esmodules">ESModules</h2>



<p>We saw above that using a bundler really helps bring down both size and load times. Part of this is due to tree-shaking out unused code. However, sometimes the tree-shaking process wrongly includes code because it can’t confidently know whether to leave something out or not.</p>



<p>Today all extensions are exported as CommonJS, which, due to its dynamic nature, is difficult to optimize for bundling. ESModules are more statically analyzable in comparison due to their import/export syntax being standardized and paths needing to be strings. This, coupled with better loading performance (due to its asynchronous nature), should improve overall load/run times. If you’re using a bundler, it should be a simple case of changing your output from CJS to ESM (don’t do this today though, as it won’t work yet).</p>



<p>When will we see a transition? It seems VSCode may be waiting on TypeScript for full ESModules support. You can follow the issue here: <a href="https://github.com/microsoft/vscode/issues/130367">https://github.com/microsoft/vscode/issues/130367</a> (feel free to vote on it). The TypeScript team looks to be aiming for a release once they resolve their <a href="https://github.com/microsoft/TypeScript/issues/46452">remaining concerns</a>. I hope to see both of these happening in 2022.</p>



<h2 id="tree-sitter">Tree-sitter</h2>



<p>Slow loading of large files can be due to syntactical analysis.</p>



<p>Today tokenization (for syntax highlighting) runs on the main thread, if too much time is spent there things will quickly freeze up, so in order to avoid that the syntax highlighting process will periodically yield back until it’s finished. But why is it slow in the first place?</p>



<p>Syntax highlighting uses inefficient textmate grammars which are regex based, these regular expressions can get pretty immense, the example below is from the TypeScript <a href="https://github.com/microsoft/vscode/blob/9efc116de0ea4998616ebe3b17ee5b92f7dc1161/extensions/typescript-basics/syntaxes/TypeScript.tmLanguage.json#L881">ruleset</a>.</p>



<figure><img src="https://user-images.githubusercontent.com/5047891/62771189-eddf2700-ba9c-11e9-9263-604ad468deb2.png" alt=""/></figure>



<p>Despite the effort the team have put in to speeding things up, the aging system using these regex grammars is hitting a limit. </p>



<blockquote><p><em>The fact that we now have these complex grammars that end up producing beautiful tokens is more of a testament to the amazing computing power available to us than to the design of the [TextMate] grammar semantics.</em></p><cite>Alex Dima – Microsoft</cite></blockquote>



<p><a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> is a new concurrent, incremental parsing system created to solve this problem. The “incremental” bit is note-worthy because it’s designed to handle updates as syntax changes; in fact, it’s fast enough to run on each keystroke. Max Brunfield goes into more detail in his talk about Tree-Sitter <a href="https://www.youtube.com/watch?v=a1rC79DHpmY">here</a>. GitHub migrated to Tree-Sitter for the parsing of syntax and code navigation, NeoVim added experimental support in 2021, and former Atom team members will be moving forward with <a href="https://zed.dev/">Zed</a>, a Rust-based text editor that will use Tree-Sitter from the outset.</p>



<p>There’s a spark of interest from VSCode devs but nothing which signals it being integrated fully. Currently there’s little appetite to unearth all of the syntax-parsing architecture, especially as so many features depend on it.  It’s worth seeing how this all plays out, but if anything is certain we will be seeing more of Tree Sitter in 2022.</p>



<h2 id="web-assembly-wasm">Web Assembly (WASM)</h2>



<p>If you really need to do some CPU intensive work, it’s now possible to offload some of the workload to a language server. This allows you to implement the bulk of your extension in another language (for instance, writing Rust code and compiling it down to WASM).</p>



<p>Thanks to <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a> it’s easy to write a Rust extension, or module, and export it. In the following example I am making a change to the Rust code for the server part of  the extension which triggers an update, then I can see it being ran on the right hand Code window.</p>



<figure>
  <video autoplay="" loop="" muted="" playsinline="">
    <source src="/wp-content/uploads/2022/01/wasm-rust-demo-2.mp4" type="video/mp4"/>
    <source src="/wp-content/uploads/2022/01/wasm-rust-demo-2.webm" type="video/webm"/>
    <img src="https://jason-williams.co.uk/wp-content/uploads/2022/01/wasm-rust-demo-2-1-scaled.gif"/>
</video>
</figure>



<p>I’ve created a useful template to get started with here: <a href="https://github.com/jasonwilliams/hello-wasm">https://github.com/jasonwilliams/hello-wasm</a></p>



<p>This is made possible not only by wasm-pack, but also by the great <a href="https://www.npmjs.com/package/esbuild-plugin-wasm-pack">esbuild-wasm-pack-plugin</a> that will watch both Rust and TypeScript/JavaScript code, then rebuild on a change.</p>



<p>As Gabe Jackson from OSO <a href="https://www.osohq.com/post/building-vs-code-extension-with-rust-wasm-typescript">explained, </a>bundling to WASM has its advantages. One is that you don’t need to provide a binary for every architecture.</p>



<figure><img loading="lazy" width="421" height="252" src="https://jason-williams.co.uk/wp-content/uploads/2022/01/lang-server-diagram-2.svg" alt=""/></figure>



<h2 id="wrapping-up">Wrapping Up</h2>



<p>So there are changes that can be made today and there are features to look forward to in the future. It will be an interesting year if some of these projects reach prime time. I also believe we’ll see more competition in this space, especially from Zed.</p>



<p>That being said, there are plenty of improvements that can be made in the extensions space today without needing to perform wholesale changes to the architecture.</p>

</article><!-- /.blog-post -->


      </div>
      
  </div>
</div></div>
  </body>
</html>
