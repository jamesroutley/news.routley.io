<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/">Original</a>
    <h1>Unix as IDE (2012)</h1>
    
    <div id="readability-page-1" class="page"><div id="main">

		<section id="primary">
			<div id="content" role="main">

			
				

				
				
					
	<article id="post-299">
		<!-- .entry-header -->

				<div>
			<p>This entry is part 1 of 7 in the series <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/" title="Unix as IDE">Unix as IDE</a>.</p><p><em>This series has been independently translated into <a href="https://conanblog.me/Unix-as-IDE--Chinese-/">Chinese</a>, <a href="https://habr.com/post/150930/">Russian</a>,
<a href="https://ahmetkun.com/post/bir-ide-olarak-unix/">Turkish</a>, and <a href="http://dgkim5360.tistory.com/entry/unix-as-ide-korean-translation">Korean</a>, and formatted as an
<a href="https://github.com/mrzool/unix-as-ide">ebook</a>.</em></p>

<p>Newbies and experienced professional programmers alike appreciate the concept
of the IDE, or <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">integrated development environment</a>. Having the primary
tools necessary for organising, writing, maintaining, testing, and debugging
code in an integrated application with common interfaces for all the different
tools is certainly a very valuable asset. Additionally, an environment
expressly designed for programming in various languages affords advantages such
as autocompletion, and syntax checking and highlighting.</p>

<p>With such tools available to developers on all major desktop operating systems
including GNU/Linux and BSD, and with many of the best free of charge, there’s not
really a good reason to write your code in Windows Notepad, or with <code>nano</code> or
<code>cat</code>.</p>

<p>However, there’s a minor meme among devotees of Unix and its modern-day
derivatives that “Unix is an IDE”, meaning that the tools available to
developers on the terminal cover the major features in cutting-edge desktop
IDEs with some ease. Opinion is quite divided on this, but whether or not you
feel it’s fair to call Unix an IDE in the same sense as Eclipse or Microsoft
Visual Studio, it may surprise you just how comprehensive a development
environment the humble Bash shell can be.</p>

<h2>How is UNIX an IDE?</h2>

<p>The primary rationale for using an IDE is that it gathers all your tools in the
same place, and you can use them in concert with roughly the same user
interface paradigm, and without having to exert too much effort to make
separate applications cooperate. The reason this becomes especially desirable
with GUI applications is because it’s very difficult to make windowed
applications speak a common language or work well with each other; aside from
cutting and pasting text, they don’t share a <em>common interface</em>.</p>

<p>The interesting thing about this problem for shell users is that well-designed
and enduring Unix tools already share a common user interface in <em>streams of
text</em> and <em>files as persistent objects</em>, otherwise expressed in the axiom
“everything’s a file”. Pretty much everything in Unix is built around these two
concepts, and it’s this common user interface, coupled with a forty-year
history of high-powered tools whose users and developers have especially prized
interoperability, that goes a long way to making Unix as powerful as a
full-blown IDE.</p>

<h2>The right idea</h2>

<p>This attitude isn’t the preserve of battle-hardened Unix greybeards; you can
see it in another form in the way the modern incarnations of the two grand old
text editors Emacs and Vi (GNU Emacs and Vim) have such active communities
developing plugins to make them support pretty much any kind of editing task.
There are plugins to do pretty much anything you could really want to do in
programming in both editors, and any Vim junkie could spout off at least
three or four that they feel are “essential”.</p>

<p>However, it often becomes apparent to me when reading about these efforts that
the developers concerned are trying to make these text editors into IDEs in
their own right. There are posts about <a href="https://kev.town/2010/12/15/this-is-your-brain-on-vim/">never needing to leave Vim</a>, or
<a href="https://news.ycombinator.com/item?id=819447">never needing to leave Emacs</a>. But I think that trying to shoehorn Vim or
Emacs into becoming something that it’s not isn’t quite thinking about the
problem in the right way. Bram Moolenaar, the author of Vim, appears to agree
to some extent, as you can see by reading <a href="https://vimhelp.appspot.com/develop.txt.html#design-not"><code>:help design-not</code></a>. The shell is
only ever a Ctrl+Z away, and its mature, highly composable toolset will afford
you more power than either editor ever could.</p>

<p><em>EDIT October 2017: New versions of Vim 8.x now include an embedded terminal accessible with the <code>:terminal</code> command. It works a lot better than previous plugin-based attempts to do this. Even with this new feature, I still strongly recommend the approach discussed in these posts instead.</em></p>

<h2>About this series</h2>

<p>In this series of posts, I will be going through six major features of an IDE,
and giving examples showing how common tools available in GNU/Linux allow you to
use them together with ease. This will by no means be a comprehensive survey,
nor are the tools I will demonstrate the only options.</p>

<ul>
<li><strong><a href="https://blog.sanctum.geek.nz/unix-as-ide-files/">File and project management</a></strong> — <code>ls</code>, <code>find</code>, <code>grep</code>/<code>ack</code>, <code>bash</code></li>
<li><strong><a href="https://blog.sanctum.geek.nz/unix-as-ide-editing/">Text editor and editing tools</a></strong> — <code>vim</code>, <code>awk</code>, <code>sort</code>, <code>column</code></li>
<li><strong><a href="https://blog.sanctum.geek.nz/unix-as-ide-compiling/">Compiler and/or interpreter</a></strong> — <code>gcc</code>, <code>perl</code></li>
<li><strong><a href="https://blog.sanctum.geek.nz/unix-as-ide-building/">Build tools</a></strong> — <code>make</code></li>
<li><strong><a href="https://blog.sanctum.geek.nz/unix-as-ide-debugging/">Debugger</a></strong> — <code>gdb</code>, <code>valgrind</code>, <code>ltrace</code>, <code>lsof</code>, <code>pmap</code></li>
<li><strong><a href="https://blog.sanctum.geek.nz/unix-as-ide-revisions/">Version control</a></strong> — <code>diff</code>, <code>patch</code>, <code>svn</code>, <code>git</code></li>
</ul>

<h2>What I’m not trying to say</h2>

<p>I don’t think IDEs are bad; I think they’re brilliant, which is why I’m trying
to convince you that Unix can be used as one, or at least thought of as one.
I’m also not going to say that Unix is always the best tool for any programming
task; it is arguably much better suited for C, C++, Python, Perl, or Shell
development than it is for more “industry” languages like Java or C#,
especially if writing GUI-heavy applications. In particular, I’m not going to
try to convince you to scrap your hard-won Eclipse or Microsoft Visual Studio
knowledge for the sometimes esoteric world of the command line. All I want to
do is show you what we’re doing on the other side of the fence.</p>
					</div><!-- .entry-content -->
		
		<!-- .entry-meta -->
	</article><!-- #post-299 -->

				
					
	<article id="post-313">
		<!-- .entry-header -->

				<div>
			<p>This entry is part 2 of 7 in the series <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/" title="Unix as IDE">Unix as IDE</a>.</p><p>One prominent feature of an IDE is a built-in system for managing files, both
the elementary functions like moving, renaming, and deleting, and ones more
specific to development, like compiling and checking syntax. It may also be
useful to have operations on sets of files, such as finding files of a certain
extension or size, or searching files for specific patterns. In this first
article, I’ll explore some useful ways to use tools that will be familiar to
most GNU/Linux users for the purposes of working with sets of files in a project.</p>

<h2>Listing files</h2>

<p>Using <code>ls</code> is probably one of the first commands an administrator will learn
for getting a simple list of the contents of the directory. Most administrators
will also know about the <code>-a</code> and <code>-l</code> switches, to show all files including
dot files and to show more detailed data about files in columns, respectively.</p>

<p>There are other switches to GNU <code>ls</code> which are less frequently used, some of
which turn out to be very useful for programming:</p>

<ul>
<li><code>-t</code> — List files in order of last modification date, newest first. This is
useful for very large directories when you want to get a quick list of the
most recent files changed, maybe piped through <code>head</code> or <code>sed 10q</code>. Probably
most useful combined with <code>-l</code>. If you want the <em>oldest</em> files, you can add
<code>-r</code> to reverse the list.</li>
<li><code>-X</code> — Group files by extension; handy for polyglot code, to group header
files and source files separately, or to separate source files from
directories or build files.</li>
<li><code>-v</code> — Naturally sort version numbers in filenames.</li>
<li><code>-S</code> — Sort by filesize.</li>
<li><code>-R</code> — List files recursively. This one is good combined with <code>-l</code> and
piped through a pager like <code>less</code>.</li>
</ul>

<p>Since the listing is text like anything else, you could, for example, pipe the
output of this command into a <code>vim</code> process, so you could add explanations of
what each file is for and save it as an <code>inventory</code> file or add it to a README:</p>

<pre><code>$ ls -XR | vim -
</code></pre>

<p>This kind of stuff can even be automated by <code>make</code> with a little work, which
I’ll cover in another article later in the series.</p>

<h2>Finding files</h2>

<p>Funnily enough, you can get a complete list of files including relative paths
with no decoration by simply typing <code>find</code> with a <code>.</code> argument for the current
directory, though you may want to pipe it through <code>sort</code>:</p>

<pre><code>$ find . | sort
.
./Makefile
./README
./build
./client.c
./client.h
./common.h
./project.c
./server.c
./server.h
./tests
./tests/suite1.pl
./tests/suite2.pl
./tests/suite3.pl
./tests/suite4.pl
</code></pre>

<p>If you want an <code>ls -l</code> style listing, you can add <code>-ls</code> as the action to <code>find</code>
results in GNU <code>find(1)</code>:</p>

<pre><code>$ find . -ls | sort -k11,11
1155096    4 drwxr-xr-x   4 tom      tom          4096 Feb 10 09:37 .
1155152    4 drwxr-xr-x   2 tom      tom          4096 Feb 10 09:17 ./build
1155155    4 -rw-r--r--   1 tom      tom          2290 Jan 11 07:21 ./client.c
1155157    4 -rw-r--r--   1 tom      tom          1871 Jan 11 16:41 ./client.h
1155159   32 -rw-r--r--   1 tom      tom         30390 Jan 10 15:29 ./common.h
1155153   24 -rw-r--r--   1 tom      tom         21170 Jan 11 05:43 ./Makefile
1155154   16 -rw-r--r--   1 tom      tom         13966 Jan 14 07:39 ./project.c
1155080   28 -rw-r--r--   1 tom      tom         25840 Jan 15 22:28 ./README
1155156   32 -rw-r--r--   1 tom      tom         31124 Jan 11 02:34 ./server.c
1155158    4 -rw-r--r--   1 tom      tom          3599 Jan 16 05:27 ./server.h
1155160    4 drwxr-xr-x   2 tom      tom          4096 Feb 10 09:29 ./tests
1155161    4 -rw-r--r--   1 tom      tom           288 Jan 13 03:04 ./tests/suite1.pl
1155162    4 -rw-r--r--   1 tom      tom          1792 Jan 13 10:06 ./tests/suite2.pl
1155163    4 -rw-r--r--   1 tom      tom           112 Jan  9 23:42 ./tests/suite3.pl
1155164    4 -rw-r--r--   1 tom      tom           144 Jan 15 02:10 ./tests/suite4.pl
</code></pre>

<p>Note that in this case I have to specify to <code>sort</code> that it should sort by the
11th column of output, the filenames; this is done with the <code>-k</code> option.</p>

<p><code>find</code> has a complex filtering syntax all of its own; the following examples
show some of the most useful filters you can apply to retrieve lists of certain
files:</p>

<ul>
<li><code>find . -name &#39;*.c&#39;</code> — Find files with names matching a shell-style pattern.
Use <code>-iname</code> for a case-insensitive search.</li>
<li><code>find . -path &#39;*test*&#39;</code> — Find files with paths matching a shell-style
pattern. Use <code>-ipath</code> for a case-insensitive search.</li>
<li><code>find . -mtime -5</code> — Find files edited within the last five days. You can use
<code>+5</code> instead to find files edited <em>before</em> five days ago.</li>
<li><code>find . -newer server.c</code> — Find files more recently modified than <code>server.c</code>.</li>
<li><code>find . -type d</code> — Find directories. For files, use <code>-type f</code>; for symbolic
links, use <code>-type l</code>.</li>
</ul>

<p>Note, in particular, that all of these can be combined, for example to find C
source files edited in the last two days:</p>

<pre><code>$ find . -name &#39;*.c&#39; -mtime -2
</code></pre>

<p>By default, the action <code>find</code> takes for search results is simply to list them
on standard output, but there are several other useful actions:</p>

<ul>
<li><code>-ls</code> — Provide an <code>ls -l</code> style listing, as above (GNU <code>find(1)</code>)</li>
<li><code>-delete</code> — Delete matching files</li>
<li><p><code>-exec</code> — Run an arbitrary command line on each file, replacing <code>{}</code> with
the appropriate filename, and terminated by <code>\;</code>; for example:</p>

<pre><code>$ find . -name &#39;*.pl&#39; -exec perl -c {} \;
</code></pre>

<p>You can use <code>+</code> as the terminating character instead if you want to put all
of the results on one invocation of the command. One trick I find myself
using often is using <code>find</code> to generate lists of files that I then edit in
vertically split Vim windows:</p>

<pre><code>$ find . -name &#39;*.c&#39; -exec vim {} +
</code></pre></li>
</ul>

<p><em>Earlier versions of Unix as IDE suggested the use of <code>xargs</code> with <code>find</code>
results. In most cases this should not really be necessary, and it’s more
robust to handle filenames with whitespace using <code>-exec</code> or a <code>while read -r</code>
loop.</em></p>

<h2>Searching files</h2>

<p>More often than <em>attributes</em> of a set of files, however, you want to find files
based on their <em>contents</em>, and it’s no surprise that <code>grep</code>, in particular
<code>grep -R</code>, is useful here. This searches the current directory tree recursively
for anything matching ‘someVar’:</p>

<pre><code>$ grep -FR someVar .
</code></pre>

<p>Don’t forget the case insensitivity flag either, since by default <code>grep</code> works
with fixed case:</p>

<pre><code>$ grep -iR somevar .
</code></pre>

<p>Also, you can print a list of files that match without printing the matches
themselves with <code>grep -l</code>:</p>

<pre><code>$ grep -lR someVar .
</code></pre>

<p>If you write scripts or batch jobs using the output of the above, use a <code>while</code>
loop with <code>read</code> to handle spaces and other special characters in filenames:</p>

<pre><code>grep -lR someVar | while IFS= read -r file; do
    head &#34;$file&#34;
done
</code></pre>

<p>If you’re using version control for your project, this often includes metadata
in the <code>.svn</code>, <code>.git</code>, or <code>.hg</code> directories. This is dealt with easily enough
by <em>excluding</em> (<code>grep -v</code>) anything matching an appropriate fixed (<code>grep -F</code>)
string:</p>

<pre><code>$ grep -R someVar . | grep -vF .svn
</code></pre>

<p>Some versions of <code>grep</code> include <code>--exclude</code> and <code>--exclude-dir</code> options, which
may be tidier.</p>

<p>With all this said, there’s a very popular <a href="http://betterthangrep.com/">alternative to grep</a> called
<code>ack</code>, which excludes this sort of stuff for you by default. It also allows you
to use Perl-compatible regular expressions (PCRE), which are a favourite for
many programmers. It has a lot of utilities that are generally useful for working
with source code, so while there’s nothing wrong with good old <code>grep</code> since you
know it will always be there, if you can install <code>ack</code> I highly recommend it.
There’s a Debian package called <code>ack-grep</code>, and being a Perl script it’s
otherwise very simple to install.</p>

<p>Unix purists might be displeased with my even mentioning a relatively new Perl
script alternative to classic <code>grep</code>, but I don’t believe that the Unix
philosophy or using Unix as an IDE is dependent on sticking to the same classic
tools when alternatives with the same spirit that solve new problems are
available.</p>

<h2>File metadata</h2>

<p>The <code>file</code> tool gives you a one-line summary of what kind of file you’re
looking at, based on its extension, headers and other cues. This is very handy
used with <code>find</code> when examining a set of unfamiliar files:</p>

<pre><code>$ find . -exec file {} +
.:            directory
./hanoi:      Perl script, ASCII text executable
./.hanoi.swp: Vim swap file, version 7.3
./factorial:  Perl script, ASCII text executable
./bits.c:     C source, ASCII text
./bits:       ELF 32-bit LSB executable, Intel 80386, version ...
</code></pre>

<h2>Matching files</h2>

<p>As a final tip for this section, I’d suggest learning a bit about pattern
matching and brace expansion in Bash, which you can do in my earlier post
entitled <a href="https://blog.sanctum.geek.nz/bash-shell-expansion/">Bash shell expansion</a>.</p>

<p>All of the above make the classic UNIX shell into a pretty powerful means of
managing files in programming projects.</p>

<p><em>Edited April 2017 to use POSIX-compatible examples for most of the <code>find(1)</code> invocations.</em></p>
					</div><!-- .entry-content -->
		
		<!-- .entry-meta -->
	</article><!-- #post-313 -->

				
					
	<article id="post-324">
		<!-- .entry-header -->

				<div>
			<p>This entry is part 3 of 7 in the series <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/" title="Unix as IDE">Unix as IDE</a>.</p><p>The text editor is the core tool for any programmer, which is why choice of
editor evokes such tongue-in-cheek zealotry in debate among programmers. Unix
is the operating system most strongly linked with two enduring favourites,
Emacs and Vi, and their modern versions in GNU Emacs and Vim, two editors with
very different editing philosophies but comparable power.</p>

<p>Being a Vim heretic myself, here I’ll discuss the indispensable features of Vim
for programming, and in particular the use of shell tools called from
<em>within</em> Vim to complement the editor’s built-in functionality. Some of the
principles discussed here will be applicable to those using Emacs as well, but
probably not for underpowered editors like Nano.</p>

<p>This will be a very general survey, as Vim’s toolset for programmers is
<em>enormous</em>, and it’ll still end up being quite long. I’ll focus on the
essentials and the things I feel are most helpful, and try to provide links to
articles with a more comprehensive treatment of the topic. Don’t forget that
Vim’s <code>:help</code> has surprised many people new to the editor with its high quality
and usefulness.</p>

<h2>Filetype detection</h2>

<p>Vim has built-in settings to adjust its behaviour, in particular its syntax
highlighting, based on the filetype being loaded, which it happily detects and
generally does a good job at doing so. In particular, this allows you to set an
indenting style conformant with the way a particular language is usually
written. This should be one of the first things in your <code>.vimrc</code> file.</p>

<pre><code>if has(&#34;autocmd&#34;)
  filetype indent plugin on
endif
</code></pre>

<h2>Syntax highlighting</h2>

<p>Even if you’re just working with a 16-color terminal, just include the
following in your <code>.vimrc</code> if you’re not already:</p>

<pre><code>syntax on
</code></pre>

<p>The colorschemes with a default 16-color terminal are not pretty largely by
necessity, but they do the job, and for most languages syntax definition files
are available that work very well. There’s a <a href="http://code.google.com/p/vimcolorschemetest/">tremendous array of
colorschemes</a> available, and it’s not hard to tweak them to suit or even to
write your own. Using a <a href="http://vim.wikia.com/wiki/256_colors_in_vim">256-color terminal</a> or gVim will give you more
options. Good syntax highlighting files will show you definite syntax errors
with a glaring red background.</p>

<h2>Line numbering</h2>

<p>To turn line numbers on if you use them a lot in your traditional IDE:</p>

<pre><code>set number
</code></pre>

<p>You might like to try this as well, if you have at least Vim 7.3 and are keen
to try numbering lines relative to the current line rather than absolutely:</p>

<pre><code>set relativenumber
</code></pre>

<h2>Tags files</h2>

<p>Vim <a href="http://amix.dk/blog/post/19329">works very well</a> with the output from the <code>ctags</code> utility. This allows
you to search quickly for all uses of a particular identifier throughout the
project, or to navigate straight to the declaration of a variable from one of
its uses, regardless of whether it’s in the same file. For large C projects in
multiple files this can save huge amounts of otherwise wasted time, and is
probably Vim’s best answer to similar features in mainstream IDEs.</p>

<p>You can run <code>:!ctags -R</code> on the root directory of projects in many popular
languages to generate a <code>tags</code> file filled with definitions and locations for
identifiers throughout your project. Once a <code>tags</code> file for your project is
available, you can search for uses of an appropriate tag throughout the project
like so:</p>

<pre><code>:tag someClass
</code></pre>

<p>The commands <code>:tn</code> and <code>:tp</code> will allow you to iterate through successive uses
of the tag elsewhere in the project. The built-in tags functionality for this
already covers most of the bases you’ll probably need, but for features such as
a tag list window, you could try installing the very popular <a href="http://vim-taglist.sourceforge.net/">Taglist
plugin</a>. Tim Pope’s <a href="https://github.com/tpope/vim-unimpaired">Unimpaired plugin</a> also contains a couple of useful
relevant mappings.</p>

<h2>Calling external programs</h2>

<p>Until 2017, there were three major methods of calling external programs during a Vim session:</p>

<ul>
<li><strong><code>:!&lt;command&gt;</code></strong> — Useful for issuing commands from within a Vim context
particularly in cases where you intend to record output in a buffer.</li>
<li><strong><code>:shell</code></strong> — Drop to a shell as a subprocess of Vim. Good for
interactive commands.</li>
<li><strong>Ctrl-Z</strong> — Suspend Vim and issue commands from the shell that called it.</li>
</ul>

<p>Since 2017, Vim 8.x now includes a <code>:terminal</code> command to bring up a terminal emulator buffer in a window. This seems to work better than previous plugin-based attempts at doing this, such as <a href="http://code.google.com/p/conque/">Conque</a>. For the moment I still strongly recommend using one of the older methods, all of which also work in other <code>vi</code>-type editors.</p>

<h2>Lint programs and syntax checkers</h2>

<p>Checking syntax or compiling with an external program call (e.g. <code>perl -c</code>,
<code>gcc</code>) is one of the calls that’s good to make from within the editor using
<code>:!</code> commands. If you were editing a Perl file, you could run this like so:</p>

<pre><code>:!perl -c %

/home/tom/project/test.pl syntax OK

Press Enter or type command to continue
</code></pre>

<p>The <code>%</code> symbol is shorthand for the file loaded in the current buffer. Running
this prints the output of the command, if any, below the command line. If you
wanted to call this check often, you could perhaps map it as a command, or even
a key combination in your <code>.vimrc</code> file. In this case, we define a command
<code>:PerlLint</code> which can be called from normal mode with <code>\l</code>:</p>

<pre><code>command PerlLint !perl -c %
nnoremap &lt;leader&gt;l :PerlLint&lt;CR&gt;
</code></pre>

<p>For a lot of languages there’s an even better way to do this, though, which
allows us to capitalise on Vim’s built-in quickfix window. We can do this by
setting an appropriate <code>makeprg</code> for the filetype, in this case including a
module that provides us with output that Vim can use for its quicklist, and a
definition for its two formats:</p>

<pre><code>:set makeprg=perl\ -c\ -MVi::QuickFix\ %
:set errorformat+=%m\ at\ %f\ line\ %l\.
:set errorformat+=%m\ at\ %f\ line\ %l
</code></pre>

<p>You may need to install this module first via CPAN, or the Debian package
<code>libvi-quickfix-perl</code>. This done, you can type <code>:make</code> after saving the file to
check its syntax, and if errors are found, you can open the quicklist window
with <code>:copen</code> to inspect the errors, and <code>:cn</code> and <code>:cp</code> to jump to them within
the buffer.</p>

<div id="attachment_325"><p><a href="https://blog.sanctum.geek.nz/wp-content/uploads/2012/02/vim-quickfix.png"><img title="vim-quickfix" src="https://blog.sanctum.geek.nz/wp-content/uploads/2012/02/vim-quickfix.png" alt="Vim quickfix working on a Perl file" width="804" height="567"/></a></p><p id="caption-attachment-325">Vim
quickfix working on a Perl file</p></div>

<p>This also works for output from <a href="http://tldp.org/HOWTO/C-editing-with-VIM-HOWTO/quickfix.html"><code>gcc</code></a>, and pretty much any other compiler
syntax checker that you might want to use that includes filenames, line
numbers, and error strings in its error output. It’s even possible to do this
with <a href="http://stackoverflow.com/questions/7193547/debugging-php-with-vim-using-quickfix">web-focused languages like PHP</a>, and for tools like <a href="https://github.com/hallettj/jslint.vim">JSLint for
JavaScript</a>. There’s also an excellent plugin named <a href="http://www.vim.org/scripts/script.php?script_id=2736">Syntastic</a> that
does something similar.</p>

<h2>Reading output from other commands</h2>

<p>You can use <code>:r!</code> to call commands and paste their output directly into the
buffer with which you’re working. For example, to pull a quick directory
listing for the current folder into the buffer, you could type:</p>

<pre><code>:r!ls
</code></pre>

<p>This doesn’t just work for commands, of course; you can simply read in other
files this way with just <code>:r</code>, like public keys or your own custom boilerplate:</p>

<pre><code>:r ~/.ssh/id_rsa.pub
:r ~/dev/perl/boilerplate/copyright.pl
</code></pre>

<h2>Filtering output through other commands</h2>

<p>You can extend this to actually filter text in the buffer through external
commands, perhaps selected by a range or visual mode, and replace it with the
command’s output. While Vim’s visual block mode is great for working with
columnar data, it’s very often helpful to bust out tools like <code>column</code>, <code>cut</code>,
<code>sort</code>, or <code>awk</code>.</p>

<p>For example, you could sort the entire file in reverse by the second column by
typing:</p>

<pre><code>:%!sort -k2,2r
</code></pre>

<p>You could print only the third column of some selected text where the line
matches the pattern <code>/vim/</code> with:</p>

<pre><code>:&#39;&lt;,&#39;&gt;!awk &#39;/vim/ {print $3}&#39;
</code></pre>

<p>You could arrange keywords from lines 1 to 10 in nicely formatted columns like:</p>

<pre><code>:1,10!column -t
</code></pre>

<p>Really <em>any kind</em> of text filter or command can be manipulated like this in
Vim, a simple interoperability feature that expands what the editor can do by
an order of magnitude. It effectively makes the Vim buffer into a text stream,
which is a language that all of these classic tools speak.</p>

<p>There is a lot more detail on this in my <a href="https://blog.sanctum.geek.nz/shell-from-vi/">“Shell from Vi”</a> post.</p>

<h2>Built-in alternatives</h2>

<p>It’s worth noting that for really common operations like sorting and searching,
Vim has built-in methods in <code>:sort</code> and <code>:grep</code>, which can be helpful if you’re
stuck using Vim on Windows, but don’t have nearly the adaptability of shell
calls.</p>

<h2>Diffing</h2>

<p>Vim has a <em>diffing</em> mode, <code>vimdiff</code>, which allows you to not only view the
differences between different versions of a file, but also to resolve conflicts
via a three-way merge and to replace differences to and fro with commands like
<code>:diffput</code> and <code>:diffget</code> for ranges of text. You can call <code>vimdiff</code> from the
command line directly with at least two files to compare like so:</p>

<pre><code>$ vimdiff file-v1.c file-v2.c
</code></pre>

<div id="attachment_326"><p><a href="https://blog.sanctum.geek.nz/wp-content/uploads/2012/02/vim-diff.png"><img title="vim-diff" src="https://blog.sanctum.geek.nz/wp-content/uploads/2012/02/vim-diff.png" alt="Vim diffing a .vimrc file" width="1224" height="672"/></a></p><p id="caption-attachment-326">Vim
diffing a .vimrc file</p></div>

<h2>Version control</h2>

<p>You can call version control methods directly from within Vim, which is
probably all you need most of the time. It’s useful to remember here that <code>%</code>
is always a shortcut for the buffer’s current file:</p>

<pre><code>:!svn status
:!svn add %
:!git commit -a
</code></pre>

<p>Recently a clear winner for Git functionality with Vim has come up with Tim
Pope’s <a href="https://github.com/tpope/vim-fugitive">Fugitive</a>, which I highly recommend to anyone doing Git development
with Vim. There’ll be a more comprehensive treatment of version control’s basis
and history in Unix in Part 7 of this series.</p>

<h2>The difference</h2>

<p>Part of the reason Vim is thought of as a toy or relic by a lot of programmers
used to GUI-based IDEs is its being seen as just a tool for editing files on
servers, rather than a very capable editing component for the shell in its own
right. Its own built-in features being so composable with external tools on
Unix-friendly systems makes it into a text editing powerhouse that sometimes
surprises even experienced users.</p>
					</div><!-- .entry-content -->
		
		<!-- .entry-meta -->
	</article><!-- #post-324 -->

				
					
	<article id="post-337">
		<!-- .entry-header -->

				<div>
			<p>This entry is part 4 of 7 in the series <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/" title="Unix as IDE">Unix as IDE</a>.</p><p>There are a lot of tools available for compiling and interpreting code on the
Unix platform, and they tend to be used in different ways. However,
conceptually many of the steps are the same. Here I’ll discuss compiling C code
with <code>gcc</code> from the GNU Compiler Collection, and briefly the use of <code>perl</code> as
an example of an interpreter.</p>

<h2>GCC</h2>

<p><a href="http://gcc.gnu.org/">GCC</a> is a very mature GPL-licensed collection of compilers, perhaps
best-known for working with C and C++ programs. Its free software license and
near ubiquity on free Unix-like systems like GNU/Linux and BSD has made it
enduringly popular for these purposes, though more modern alternatives are
available in compilers using the <a href="http://llvm.org/">LLVM</a> infrastructure, such as <a href="http://clang.llvm.org/">Clang</a>.</p>

<p>The frontend binaries for GNU Compiler Collection are best thought of less as a
set of complete compilers in their own right, and more as <em>drivers</em> for a set
of discrete programming tools, performing parsing, compiling, and linking,
among other steps. This means that while you can use GCC with a relatively
simple command line to compile straight from C sources to a working binary, you
can also inspect in more detail the steps it takes along the way and tweak it
accordingly.</p>

<p>I won’t be discussing the use of <code>make</code> files here, though you’ll almost
certainly be wanting them for any C project of more than one file; that will be
discussed in the next article on build automation tools.</p>

<h2>Compiling and assembling object code</h2>

<p>You can compile object code from a C source file like so:</p>

<pre><code>$ gcc -c example.c -o example.o
</code></pre>

<p>Assuming it’s a valid C program, this will generate an unlinked binary object
file called <code>example.o</code> in the current directory, or tell you the reasons it
can’t. You can inspect its assembler contents with the <code>objdump</code> tool:</p>

<pre><code>$ objdump -D example.o
</code></pre>

<p>Alternatively, you can get <code>gcc</code> to output the appropriate assembly code for
the object directly with the <code>-S</code> parameter:</p>

<pre><code>$ gcc -c -S example.c -o example.s
</code></pre>

<p>This kind of assembly output can be particularly instructive, or at least
interesting, when printed inline with the source code itself, which you can do
with:</p>

<pre><code>$ gcc -c -g -Wa,-a,-ad example.c &gt; example.lst
</code></pre>

<h2>Preprocessor</h2>

<p>The C preprocessor <code>cpp</code> is generally used to include header files and define
macros, among other things. It’s a normal part of <code>gcc</code> compilation, but you
can view the C code it generates by invoking <code>cpp</code> directly:</p>

<pre><code>$ cpp example.c
</code></pre>

<p>This will print out the complete code as it would be compiled, with includes
and relevant macros applied.</p>

<h2>Linking objects</h2>

<p>One or more objects can be linked into appropriate binaries like so:</p>

<pre><code>$ gcc example.o -o example
</code></pre>

<p>In this example, GCC is not doing much more than abstracting a call to <code>ld</code>,
the GNU linker. The command produces an executable binary called <code>example</code>.</p>

<h2>Compiling, assembling, and linking</h2>

<p>All of the above can be done in one step with:</p>

<pre><code>$ gcc example.c -o example
</code></pre>

<p>This is a little simpler, but compiling objects independently turns out to have
some practical performance benefits in not recompiling code unnecessarily,
which I’ll discuss in the next article.</p>

<h2>Including and linking</h2>

<p>C files and headers can be explicitly included in a compilation call with the
<code>-I</code> parameter:</p>

<pre><code>$ gcc -I/usr/include/somelib.h example.c -o example
</code></pre>

<p>Similarly, if the code needs to be dynamically linked against a compiled system
library available in common locations like <code>/lib</code> or <code>/usr/lib</code>, such as
<code>ncurses</code>, that can be included with the <code>-l</code> parameter:</p>

<pre><code>$ gcc -lncurses example.c -o example
</code></pre>

<p>If you have a lot of necessary inclusions and links in your compilation
process, it makes sense to put this into environment variables:</p>

<pre><code>$ export CFLAGS=-I/usr/include/somelib.h
$ export CLIBS=-lncurses
$ gcc $CFLAGS $CLIBS example.c -o example
</code></pre>

<p>This very common step is another thing that a <code>Makefile</code> is designed to
abstract away for you.</p>

<h2>Compilation plan</h2>

<p>To inspect in more detail what <code>gcc</code> is doing with any call, you can add the
<code>-v</code> switch to prompt it to print its compilation plan on the standard error
stream:</p>

<pre><code>$ gcc -v -c example.c -o example.o
</code></pre>

<p>If you don’t want it to actually generate object files or linked binaries, it’s
sometimes tidier to use <code>-###</code> instead:</p>

<pre><code>$ gcc -### -c example.c -o example.o
</code></pre>

<p>This is mostly instructive to see what steps the <code>gcc</code> binary is abstracting
away for you, but in specific cases it can be useful to identify steps the
compiler is taking that you may not necessarily want it to.</p>

<h2>More verbose error checking</h2>

<p>You can add the <code>-Wall</code> and/or <code>-pedantic</code> options to the <code>gcc</code> call to prompt
it to warn you about things that may not necessarily be errors, but could be:</p>

<pre><code>$ gcc -Wall -pedantic -c example.c -o example.o
</code></pre>

<p>This is good for including in your <code>Makefile</code> or in your <a href="http://vim.wikia.com/wiki/Errorformat_and_makeprg"><code>makeprg</code></a>
definition in Vim, as it works well with the quickfix window discussed in the
previous article and will enable you to write more readable, compatible, and
less error-prone code as it warns you more extensively about errors.</p>

<h2>Profiling compilation time</h2>

<p>You can pass the flag <code>-time</code> to <code>gcc</code> to generate output showing how long each
step is taking:</p>

<pre><code>$ gcc -time -c example.c -o example.o
</code></pre>

<h2>Optimisation</h2>

<p>You can pass generic optimisation options to <code>gcc</code> to make it attempt to build
more efficient object files and linked binaries, at the expense of compilation
time. I find <code>-O2</code> is usually a happy medium for code going into production:</p>

<ul>
<li><code>gcc -O1</code></li>
<li><code>gcc -O2</code></li>
<li><code>gcc -O3</code></li>
</ul>

<p>Like any other Bash command, all of this can be <a href="https://blog.sanctum.geek.nz/unix-as-ide-editing/">called from within
Vim</a> by:</p>

<pre><code>:!gcc % -o example
</code></pre>

<h2>Interpreters</h2>

<p>The approach to interpreted code on Unix-like systems is very different. In
these examples I’ll use Perl, but most of these principles will be applicable
to interpreted Python or Ruby code, for example.</p>

<h2>Inline</h2>

<p>You can run a string of Perl code directly into the interpreter in any one of
the following ways, in this case printing the single line “Hello, world.” to
the screen, with a linebreak following. The first one is perhaps the tidiest
and most standard way to work with Perl; the second uses a
<a href="http://tldp.org/LDP/abs/html/here-docs.html">heredoc</a> string, and the third a
classic Unix shell pipe.</p>

<pre><code>$ perl -e &#39;print &#34;Hello world.\n&#34;;&#39;
$ perl &lt;&lt;&lt;&#39;print &#34;Hello world.\n&#34;;&#39;
$ echo &#39;print &#34;Hello world.\n&#34;;&#39; | perl
</code></pre>

<p>Of course, it’s more typical to keep the code in a file, which can be run
directly:</p>

<pre><code>$ perl hello.pl
</code></pre>

<p>In either case, you can check the syntax of the code without actually running
it with the <code>-c</code> switch:</p>

<pre><code>$ perl -c hello.pl
</code></pre>

<p>But to use the script as a <em>logical binary</em>, so you can invoke it directly
without knowing or caring what the script is, you can add a special first line
to the file called the “shebang” that does some magic to specify the
interpreter through which the file should be run.</p>

<pre><code>#!/usr/bin/env perl
print &#34;Hello, world.\n&#34;;
</code></pre>

<p>The script then needs to be made executable with a <code>chmod</code> call. It’s also good
practice to rename it to remove the extension, since it is now taking the shape
of a logic binary:</p>

<pre><code>$ mv hello{.pl,}
$ chmod +x hello
</code></pre>

<p>And can thereafter be invoked directly, as if it were a compiled binary:</p>

<pre><code>$ ./hello
</code></pre>

<p>This works so transparently that many of the common utilities on modern GNU/Linux systems,
such as the <code>adduser</code> frontend to <code>useradd</code>, are actually Perl or even Python
scripts.</p>

<p>In the next post, I’ll describe the use of <code>make</code> for defining and automating
building projects in a manner comparable to IDEs, with a nod to newer takes on
the same idea with Ruby’s <code>rake</code>.</p>
					</div><!-- .entry-content -->
		
		<!-- .entry-meta -->
	</article><!-- #post-337 -->

				
					
	<article id="post-346">
		<!-- .entry-header -->

				<div>
			<p>This entry is part 5 of 7 in the series <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/" title="Unix as IDE">Unix as IDE</a>.</p><p>Because compiling projects can be such a complicated and repetitive process, a
good IDE provides a means to abstract, simplify, and even automate software
builds. Unix and its descendents accomplish this process with a <code>Makefile</code>, a
prescribed recipe in a standard format for generating executable files from
source and object files, taking account of changes to only rebuild what’s
necessary to prevent costly recompilation.</p>

<p>One interesting thing to note about <code>make</code> is that while it’s generally used
for compiled software build automation and has many shortcuts to that effect,
it can actually effectively be used for any situation in which it’s required to
generate one set of files from another. One possible use is to generate
web-friendly optimised graphics from source files for deployment for a website;
another use is for generating static HTML pages from code, rather than
generating pages on the fly. It’s on the basis of this more flexible
understanding of software “building” that modern takes on the tool like <a href="http://rake.rubyforge.org/">Ruby’s
<code>rake</code></a> have become popular, automating the general tasks for producing and
installing code and files of all kinds.</p>

<h2>Anatomy of a <code>Makefile</code></h2>

<p>The general pattern of a <code>Makefile</code> is a list of variables and a list of
<em>targets</em>, and the sources and/or objects used to provide them. Targets may not
necessarily be linked binaries; they could also constitute actions to perform
using the generated files, such as <code>install</code> to instate built files into the
system, and <code>clean</code> to remove built files from the source tree.</p>

<p>It’s this flexibility of targets that enables <code>make</code> to automate any sort of
task relevant to assembling a production build of software; not just the
typical parsing, preprocessing, compiling proper and linking steps performed by
the compiler, but also running tests (<code>make test</code>), compiling documentation
source files into one or more appropriate formats, or automating deployment of
code into production systems, for example, uploading to a website via a <code>git
push</code> or similar content-tracking method.</p>

<p>An example <code>Makefile</code> for a simple software project might look something like
the below:</p>

<pre><code>all: example

example: main.o example.o library.o
    gcc main.o example.o library.o -o example

main.o: main.c
    gcc -c main.c -o main.o

example.o: example.c
    gcc -c example.c -o example.o

library.o: library.c
    gcc -c library.c -o library.o

clean:
    rm *.o example

install: example
    cp example /usr/bin
</code></pre>

<p>The above isn’t the most optimal <code>Makefile</code> possible for this project, but it
provides a means to build and install a linked binary simply by typing <code>make</code>.
Each <em>target</em> definition contains a list of the <em>dependencies</em> required for the
command that follows; this means that the definitions can appear in any order,
and the call to <code>make</code> will call the relevant commands in the appropriate
order.</p>

<p>Much of the above is needlessly verbose or repetitive; for example, if an
object file is built directly from a single C file of the same name, then we
don’t need to include the target at all, and <code>make</code> will sort things out for
us. Similarly, it would make sense to put some of the more repeated calls into
variables so that we would not have to change them individually if our choice
of compiler or flags changed. A more concise version might look like the
following:</p>

<pre><code>CC = gcc
OBJECTS = main.o example.o library.o
BINARY = example

all: example

example: $(OBJECTS)
    $(CC) $(OBJECTS) -o $(BINARY)

clean:
    rm -f $(BINARY) $(OBJECTS)

install: example
    cp $(BINARY) /usr/bin
</code></pre>

<h2>More general uses of <code>make</code></h2>

<p>In the interests of automation, however, it’s instructive to think of this a
bit more generally than just code compilation and linking. An example could be
for a simple web project involving deploying PHP to a live webserver. This is
not normally a task people associate with the use of <code>make</code>, but the principles
are the same; with the source in place and ready to go, we have certain targets
to meet for the build.</p>

<p>PHP files don’t require compilation, of course, but web assets often do. An
example that will be familiar to web developers is the generation of scaled and
optimised raster images from vector source files, for deployment to the web.
You keep and version your original source file, and when it comes time to
deploy, you generate a web-friendly version of it.</p>

<p>Let’s assume for this particular project that there’s a set of four icons used
throughout the site, sized to 64 by 64 pixels. We have the source files to hand
in SVG vector format, safely tucked away in version control, and now need to
<em>generate</em> the smaller bitmaps for the site, ready for deployment. We could
therefore define a target <code>icons</code>, set the dependencies, and type out the
commands to perform. This is where command line tools in Unix really begin to
shine in use with <code>Makefile</code> syntax:</p>

<pre><code>icons: create.png read.png update.png delete.png

create.png: create.svg
    convert create.svg create.raw.png &amp;&amp; \
    pngcrush create.raw.png create.png

read.png: read.svg
    convert read.svg read.raw.png &amp;&amp; \
    pngcrush read.raw.png read.png

update.png: update.svg
    convert update.svg update.raw.png &amp;&amp; \
    pngcrush update.raw.png update.png

delete.png: delete.svg
    convert delete.svg delete.raw.png &amp;&amp; \
    pngcrush delete.raw.png delete.png
</code></pre>

<p>With the above done, typing <code>make icons</code> will go through each of the source
icons files in a Bash loop, convert them from SVG to PNG using ImageMagick’s
<code>convert</code>, and optimise them with <code>pngcrush</code>, to produce images ready for
upload.</p>

<p>A similar approach can be used for generating help files in various forms, for
example, generating HTML files from Markdown source:</p>

<pre><code>docs: README.html credits.html

README.html: README.md
    markdown README.md &gt; README.html

credits.html: credits.md
    markdown credits.md &gt; credits.html
</code></pre>

<p>And perhaps finally deploying a website with <code>git push web</code>, but only <em>after</em>
the icons are rasterized and the documents converted:</p>

<pre><code>deploy: icons docs
    git push web
</code></pre>

<p>For a more compact and abstract formula for turning a file of one suffix into
another, you can use the <code>.SUFFIXES</code> pragma to define these using special
symbols. The code for converting icons could look like this; in this case, <code>$&lt;</code>
refers to the source file, <code>$*</code> to the filename with no extension, and <code>$@</code> to
the target.</p>

<pre><code>icons: create.png read.png update.png delete.png

.SUFFIXES: .svg .png

.svg.png:
    convert $&lt; $*.raw.png &amp;&amp; \
    pngcrush $*.raw.png $@
</code></pre>

<h2>Tools for building a <code>Makefile</code></h2>

<p>A variety of tools exist in the GNU Autotools toolchain for the construction of
<code>configure</code> scripts and <code>make</code> files for larger software projects at a higher
level, in particular <a href="http://en.wikipedia.org/wiki/Autoconf"><code>autoconf</code></a> and <a href="http://en.wikipedia.org/wiki/Automake"><code>automake</code></a>. The use of these
tools allows generating <code>configure</code> scripts and <code>make</code> files covering very
large source bases, reducing the necessity of building otherwise extensive
makefiles manually, and automating steps taken to ensure the source remains
compatible and compilable on a variety of operating systems.</p>

<p>Covering this complex process would be a series of posts in its own right, and
is out of scope of this survey.</p>

<p><em>Thanks to user samwyse for the <code>.SUFFIXES</code> suggestion in the comments.</em></p>
					</div><!-- .entry-content -->
		
		<!-- .entry-meta -->
	</article><!-- #post-346 -->

				
					
	<article id="post-362">
		<!-- .entry-header -->

				<div>
			<p>This entry is part 6 of 7 in the series <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/" title="Unix as IDE">Unix as IDE</a>.</p><p>When unexpected behaviour is noticed in a program, GNU/Linux provides a wide
variety of command-line tools for diagnosing problems. The use of <code>gdb</code>, the
GNU debugger, and related tools like the lesser-known Perl debugger, will be
familiar to those using IDEs to set breakpoints in their code and to examine
program state as it runs. Other tools of interest are available however to
observe in more detail how a program is interacting with a system and using its
resources.</p>

<h2>Debugging with <code>gdb</code></h2>

<p>You can use <code>gdb</code> in a very similar fashion to the built-in debuggers in modern
IDEs like Eclipse and Visual Studio. If you are debugging a program that you’ve
just compiled, it makes sense to compile it with its <em>debugging symbols</em> added
to the binary, which you can do with a <code>gcc</code> call containing the <code>-g</code> option.
If you’re having problems with some code, it helps to also use <code>-Wall</code> to show
any errors you may have otherwise missed:</p>

<pre><code>$ gcc -g -Wall example.c -o example
</code></pre>

<p>The classic way to use <code>gdb</code> is as the shell for a running program compiled in
C or C++, to allow you to inspect the program’s state as it proceeds towards
its crash.</p>

<pre><code>$ gdb example
...
Reading symbols from /home/tom/example...done.
(gdb)
</code></pre>

<p>At the <code>(gdb)</code> prompt, you can type <code>run</code> to start the program, and it may
provide you with more detailed information about the causes of errors such as
segmentation faults, including the source file and line number at which the
problem occurred. If you’re able to compile the code with debugging symbols as
above and inspect its running state like this, it makes figuring out the cause
of a particular bug a lot easier.</p>

<pre><code>(gdb) run
Starting program: /home/tom/gdb/example 

Program received signal SIGSEGV, Segmentation fault.
0x000000000040072e in main () at example.c:43
43     printf(&#34;%d\n&#34;, *segfault);
</code></pre>

<p>After an error terminates the program within the <code>(gdb)</code> shell, you can type
<code>backtrace</code> to see what the calling function was, which can include the
specific parameters passed that may have something to do with what caused the
crash.</p>

<pre><code>(gdb) backtrace
#0  0x000000000040072e in main () at example.c:43
</code></pre>

<p>You can set breakpoints for <code>gdb</code> using the <code>break</code> to halt the program’s run
if it reaches a matching line number or function call:</p>

<pre><code>(gdb) break 42
Breakpoint 1 at 0x400722: file example.c, line 42.
(gdb) break malloc
Breakpoint 1 at 0x4004c0
(gdb) run
Starting program: /home/tom/gdb/example 

Breakpoint 1, 0x00007ffff7df2310 in malloc () from /lib64/ld-linux-x86-64.so.2
</code></pre>

<p>Thereafter it’s helpful to <em>step</em> through successive lines of code using
<code>step</code>. You can repeat this, like any <code>gdb</code> command, by pressing Enter
repeatedly to step through lines one at a time:</p>

<pre><code>(gdb) step
Single stepping until exit from function _start,
which has no line number information.
0x00007ffff7a74db0 in __libc_start_main () from /lib/x86_64-linux-gnu/libc.so.6
</code></pre>

<p>You can even attach <code>gdb</code> to a process that is already running, by finding the
process ID and passing it to <code>gdb</code>:</p>

<pre><code>$ pgrep example
1524
$ gdb -p 1524
</code></pre>

<p>This can be useful for <a href="http://stackoverflow.com/questions/593724/redirect-stderr-stdout-of-a-process-after-its-been-started-using-command-lin">redirecting streams of output</a> for a task that is
taking an unexpectedly long time to run.</p>

<h2>Debugging with <code>valgrind</code></h2>

<p>The much newer <a href="http://valgrind.org/">valgrind</a> can be used as a debugging tool in a similar way.
There are many different checks and debugging methods this program can run, but
one of the most useful is its Memcheck tool, which can be used to detect common
memory errors like buffer overflow:</p>

<pre><code>$ valgrind --leak-check=yes ./example
==29557== Memcheck, a memory error detector
==29557== Copyright (C) 2002-2011, and GNU GPL&#39;d, by Julian Seward et al.
==29557== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==29557== Command: ./example
==29557== 
==29557== Invalid read of size 1
==29557==    at 0x40072E: main (example.c:43)
==29557==  Address 0x0 is not stack&#39;d, malloc&#39;d or (recently) free&#39;d
==29557== 
...
</code></pre>

<p>The <code>gdb</code> and <code>valgrind</code> tools <a href="http://valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.gdbserver">can be used together</a> for a very thorough
survey of a program’s run. Zed Shaw’s <a href="http://c.learncodethehardway.org/book/">Learn C the Hard Way</a> includes a
really good introduction for elementary use of <code>valgrind</code> with a deliberately
broken program.</p>

<h2>Tracing system and library calls with <code>ltrace</code></h2>

<p>The <code>strace</code> and <code>ltrace</code> tools are designed to allow watching system calls and
library calls respectively for running programs, and logging them to the screen
or, more usefully, to files.</p>

<p>You can run <code>ltrace</code> and have it run the program you want to monitor in this
way for you by simply providing it as the sole parameter. It will then give you
a listing of all the system and library calls it makes until it exits.</p>

<pre><code>$ ltrace ./example
__libc_start_main(0x4006ad, 1, 0x7fff9d7e5838, 0x400770, 0x400760 
srand(4, 0x7fff9d7e5838, 0x7fff9d7e5848, 0, 0x7ff3aebde320) = 0
malloc(24)                                                  = 0x01070010
rand(0, 0x1070020, 0, 0x1070000, 0x7ff3aebdee60)            = 0x754e7ddd
malloc(24)                                                  = 0x01070030
rand(0x7ff3aebdee60, 24, 0, 0x1070020, 0x7ff3aebdeec8)      = 0x11265233
malloc(24)                                                  = 0x01070050
rand(0x7ff3aebdee60, 24, 0, 0x1070040, 0x7ff3aebdeec8)      = 0x18799942
malloc(24)                                                  = 0x01070070
rand(0x7ff3aebdee60, 24, 0, 0x1070060, 0x7ff3aebdeec8)      = 0x214a541e
malloc(24)                                                  = 0x01070090
rand(0x7ff3aebdee60, 24, 0, 0x1070080, 0x7ff3aebdeec8)      = 0x1b6d90f3
malloc(24)                                                  = 0x010700b0
rand(0x7ff3aebdee60, 24, 0, 0x10700a0, 0x7ff3aebdeec8)      = 0x2e19c419
malloc(24)                                                  = 0x010700d0
rand(0x7ff3aebdee60, 24, 0, 0x10700c0, 0x7ff3aebdeec8)      = 0x35bc1a99
malloc(24)                                                  = 0x010700f0
rand(0x7ff3aebdee60, 24, 0, 0x10700e0, 0x7ff3aebdeec8)      = 0x53b8d61b
malloc(24)                                                  = 0x01070110
rand(0x7ff3aebdee60, 24, 0, 0x1070100, 0x7ff3aebdeec8)      = 0x18e0f924
malloc(24)                                                  = 0x01070130
rand(0x7ff3aebdee60, 24, 0, 0x1070120, 0x7ff3aebdeec8)      = 0x27a51979
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
</code></pre>

<p>You can also attach it to a process that’s already running:</p>

<pre><code>$ pgrep example
5138
$ ltrace -p 5138
</code></pre>

<p>Generally, there’s quite a bit more than a couple of screenfuls of text
generated by this, so it’s helpful to use the <code>-o</code> option to specify an output
file to which to log the calls:</p>

<pre><code>$ ltrace -o example.ltrace ./example
</code></pre>

<p>You can then view this trace in a text editor like Vim, which includes syntax
highlighting for <code>ltrace</code> output:</p>

<div id="attachment_363"><p><a href="https://blog.sanctum.geek.nz/wp-content/uploads/2012/02/ltrace-vim.png"><img title="ltrace-vim" src="https://blog.sanctum.geek.nz/wp-content/uploads/2012/02/ltrace-vim.png" alt="Vim session with ltrace output" width="844" height="526"/></a></p><p id="caption-attachment-363">Vim
session with ltrace output</p></div>

<p>I’ve found <code>ltrace</code> very useful for debugging problems where I suspect improper
linking may be at fault, or the absence of some needed resource in a <code>chroot</code>
environment, since among its output it shows you its search for libraries at
dynamic linking time and opening configuration files in <code>/etc</code>, and the use of
devices like <code>/dev/random</code> or <code>/dev/zero</code>.</p>

<h2>Tracking open files with <code>lsof</code></h2>

<p>If you want to view what devices, files, or streams a running process has open,
you can do that with <code>lsof</code>:</p>

<pre><code>$ pgrep example
5051
$ lsof -p 5051
</code></pre>

<p>For example, the first few lines of the <code>apache2</code> process running on my home
server are:</p>

<pre><code># lsof -p 30779
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
apache2 30779 root  cwd    DIR    8,1     4096       2 /
apache2 30779 root  rtd    DIR    8,1     4096       2 /
apache2 30779 root  txt    REG    8,1   485384  990111 /usr/lib/apache2/mpm-prefork/apache2
apache2 30779 root  DEL    REG    8,1          1087891 /lib/x86_64-linux-gnu/libgcc_s.so.1
apache2 30779 root  mem    REG    8,1    35216 1079715 /usr/lib/php5/20090626/pdo_mysql.so
...
</code></pre>

<p>Interestingly, another way to list the open files for a process is to check the
corresponding entry for the process in the dynamic <code>/proc</code> directory:</p>

<pre><code># ls -l /proc/30779/fd
</code></pre>

<p>This can be very useful in confusing situations with file locks, or identifying
whether a process is holding open files that it needn’t.</p>

<h2>Viewing memory allocation with <code>pmap</code></h2>

<p>As a final debugging tip, you can view the memory allocations for a particular
process with <code>pmap</code>:</p>

<pre><code># pmap 30779 
30779:   /usr/sbin/apache2 -k start
00007fdb3883e000     84K r-x--  /lib/x86_64-linux-gnu/libgcc_s.so.1 (deleted)
00007fdb38853000   2048K -----  /lib/x86_64-linux-gnu/libgcc_s.so.1 (deleted)
00007fdb38a53000      4K rw---  /lib/x86_64-linux-gnu/libgcc_s.so.1 (deleted)
00007fdb38a54000      4K -----    [ anon ]
00007fdb38a55000   8192K rw---    [ anon ]
00007fdb392e5000     28K r-x--  /usr/lib/php5/20090626/pdo_mysql.so
00007fdb392ec000   2048K -----  /usr/lib/php5/20090626/pdo_mysql.so
00007fdb394ec000      4K r----  /usr/lib/php5/20090626/pdo_mysql.so
00007fdb394ed000      4K rw---  /usr/lib/php5/20090626/pdo_mysql.so
...
total           152520K
</code></pre>

<p>This will show you what libraries a running process is using, including those
in shared memory. The total given at the bottom is a little misleading as for
loaded shared libraries, the running process is not necessarily the only one
using the memory; <a href="http://stackoverflow.com/questions/118307/a-way-to-determine-a-processs-real-memory-usage-i-e-private-dirty-rss">determining “actual” memory usage for a given process</a> is
a little more in-depth than it might seem with shared libraries added to the
picture.</p>
					</div><!-- .entry-content -->
		
		<!-- .entry-meta -->
	</article><!-- #post-362 -->

				
					
	<article id="post-375">
		<!-- .entry-header -->

				<div>
			<p>This entry is part 7 of 7 in the series <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/" title="Unix as IDE">Unix as IDE</a>.</p><p>Version control is now seen as an indispensable part of professional software
development, and GUI IDEs like Eclipse and Visual Studio have embraced it and
included support for industry standard version control systems in their
products. Modern version control systems trace their lineage back to Unix
concepts from programs such as <code>diff</code> and <code>patch</code> however, and there are plenty
of people who will insist that the best way to use a version control system is
still at a shell prompt.</p>

<p>In this last article in the <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/">Unix as an IDE series</a>, I’ll follow the
evolution of common open-source version control systems from the basic concepts
of <code>diff</code> and <code>patch</code>, among the very first version control tools.</p>

<h2><code>diff</code>, <code>patch</code>, and RCS</h2>

<p>A central concept for version control systems has been that of the <em>unified
diff</em>, a file expressing in human and computer readable terms a set of changes
made to a file or files. The <code>diff</code> command was first released by Douglas
McIlroy in 1974 for the 5th Edition of Unix, so it’s one of the oldest commands
still in regular use on modern systems.</p>

<p>A <em>unified diff</em>, the most common and interoperable format, can be generated by
comparing two versions of a file with the following syntax:</p>

<pre><code>$ diff -u example.{1,2}.c
--- example.1.c    2012-02-15 20:15:37.000000000 +1300
+++ example.2.c    2012-02-15 20:15:57.000000000 +1300
@@ -1,8 +1,9 @@
 #include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt; 

 int main (int argc, char* argv[]) { printf(&#34;Hello, world!\n&#34;);
-    return 0;
+    return EXIT_SUCCESS; }
</code></pre>

<p>In this example, the second file has a header file added, and the call to
<code>return</code> changed to use the standard <code>EXIT_SUCCESS</code> rather than a literal <code>0</code>
as the return value for <code>main()</code>. Note that the output for <code>diff</code> also includes
metadata such as the filename that was changed and the last modification time
of each of the files.</p>

<p>A primitive form of version control for larger code bases was thus for
developers to trade <code>diff</code> output, called <em>patches</em> in this context, so that
they could be applied to one another’s code bases with the <code>patch</code> tool. We
could save the output from <code>diff</code> above as a patch like so:</p>

<pre><code>$ diff -u example.{1,2}.c &gt; example.patch
</code></pre>

<p>We could then send this patch to a developer who still had the old version of
the file, and they could automatically apply it with:</p>

<pre><code>$ patch example.1.c &lt; example.patch
</code></pre>

<p>A patch can include <code>diff</code> output from more than one file, including within
subdirectories, so this provides a very workable way to apply changes to a
source tree.</p>

<p>The operations involved in using <code>diff</code> output to track changes were
sufficiently regular that for keeping in-place history of a file, the <a href="http://en.wikipedia.org/wiki/Source_Code_Control_System">Source
Code Control System</a> and the <a href="http://en.wikipedia.org/wiki/Revision_Control_System">Revision Control System</a> that has pretty
much replaced it were developed. RCS enabled “locking” files so that they could
not be edited by anyone else while “checked out” of the system, paving the way
for other concepts in more developed version control systems.</p>

<p>RCS retains the advantage of being very simple to use. To place an existing
file under version control, one need only type <code>ci &lt;filename&gt;</code> and provide an
appropriate description for the file:</p>

<pre><code>$ ci example.c
example.c,v  &lt;--  example.c
enter description, terminated with single &#39;.&#39; or end of file:
NOTE: This is NOT the log message!
&gt;&gt; example file
&gt;&gt; .
initial revision: 1.1
done
</code></pre>

<p>This creates a file in the same directory, <code>example.c,v</code>, that will track the
changes. To make changes to the file, you <em>check it out</em>, make the changes,
then <em>check it back in</em>:</p>

<pre><code>$ co -l example.c
example.c,v  --&gt;  example.c
revision 1.1 (locked)
done
$ vim example.c
$ ci -u example.c
example.c,v  &lt;--  example.c
new revision: 1.2; previous revision: 1.1
enter log message, terminated with single &#39;.&#39; or end of file:
&gt;&gt; added a line
&gt;&gt; .
done
</code></pre>

<p>You can then view the history of a project with <code>rlog</code>:</p>

<pre><code>$ rlog example.c

RCS file: example.c,v
Working file: example.c
head: 1.2
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 2; selected revisions: 2
description:
example file
----------------------------
revision 1.2
date: 2012/02/15 07:39:16;  author: tom;  state: Exp;  lines: +1 -0
added a line
----------------------------
revision 1.1
date: 2012/02/15 07:36:23;  author: tom;  state: Exp;
Initial revision
=============================================================================
</code></pre>

<p>And get a patch in unified <code>diff</code> format between two revisions with <code>rcsdiff
-u</code>:</p>

<pre><code>$ rcsdiff -u -r1.1 -r1.2 ./example.c 
===================================================================
RCS file: ./example.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- ./example.c 2012/02/15 07:36:23 1.1
+++ ./example.c 2012/02/15 07:39:16 1.2
@@ -4,6 +4,7 @@
 int main (int argc, char* argv[])
 {
     printf(&#34;Hello, world!\n&#34;);
+    printf(&#34;Extra line!\n&#34;);
     return EXIT_SUCCESS;
 }
</code></pre>

<p>It would be misleading to imply that simple patches were now in disuse as a
method of version control; they are still very commonly used in the forms
above, and also figure prominently in both centralised and decentralised
version control systems.</p>

<h2>CVS and Subversion</h2>

<p>To handle the problem of resolving changes made to a code base by multiple
developers, <em>centralized version systems</em> were developed, with the <a href="http://en.wikipedia.org/wiki/Concurrent_Versions_System">Concurrent
Versions System (CVS)</a> developed first and the slightly more advanced
<a href="http://en.wikipedia.org/wiki/Apache_Subversion">Subversion</a> later on. The central feature of these systems are using a
<em>central server</em> that contains the repository, from which authoritative
versions of the codebase at any particular time or revision can be retrieved.
These are termed <em>working copies</em> of the code.</p>

<p>For these systems, the basic unit of the systems remained the <em>changeset</em>, and
the most common way to represent these to the user was in the archetypal <code>diff</code>
format used in earlier systems. Both systems work by keeping records of these
changesets, rather than the actual files themselves from state to state.</p>

<p>Other concepts introduced by this generation of systems were of <em>branching</em>
projects so that separate instances of the same project could be worked on
concurrently, and then merged into the mainline, or <em>trunk</em> with appropriate
testing and review. Similarly, the concept of <em>tagging</em> was introduced to flag
certain revisions as representing the state of a codebase at the time of a
release of the software. The concept of the <code>merge</code> was also introduced;
reconciling conflicting changes made to a file manually.</p>

<h2>Git and Mercurial</h2>

<p>The next generation of version control systems are <em>distributed</em> or
<em>decentralized</em> systems, in which working copies of the code themselves contain
a complete history of the project, and are hence not reliant on a central
server to contribute to the project. In the open source, Unix-friendly
environment, the standout systems are Git and Mercurial, with their client
programs <code>git</code> and <code>hg</code>.</p>

<p>For both of these systems, the concept of communicating changesets is done with
the operations <code>push</code>, <code>pull</code> and <code>merge</code>; changes from one repository are
accepted by another. This decentralized system allows for a very complex but
tightly controlled ecosystem of development; Git was originally developed by
Linus Torvalds to provide an open-source DVCS capable of managing development
for the Linux kernel.</p>

<p>Both Git and Mercurial differ from CVS and Subversion in that the basic unit
for their operations is not changesets, but complete files (blobs) saved using
compression. This makes finding the log history of a single file or the
differences between two revisions of a file slightly more expensive, but the
output of <code>git log --patch</code> still retains the familiar unified <code>diff</code> output
for each revision, some forty years after <code>diff</code> was first being used:</p>

<pre><code>commit c1e5559ddb09f8d02b989596b0f4100ad1aab422
Author: Tom Ryder &lt;tom@sanctum.geek.nz&gt;
Date:   Thu Feb 2 01:14:21 2012

Changed my mind about this one.

diff --git a/vim/vimrc b/vim/vimrc index cfbe8e0..65a3143 100644
--- a/vim/vimrc
+++ b/vim/vimrc
@@ -47,10 +47,6 @@
 set shiftwidth=4
 set softtabstop=4
 set tabstop=4

-&#34; Heresy
-inoremap &lt;C-a&gt; &lt;Home&gt;
-inoremap &lt;C-e&gt; &lt;End&gt;
-
 &#34; History
 set history=1000
</code></pre>

<p>The two systems have considerable overlap in functionality and even in command
set, and the question of which to use provokes <a href="http://stackoverflow.com/questions/35837/what-is-the-difference-between-mercurial-and-git">considerable debate</a>. The
best introductions I’ve seen to each are <a href="http://progit.org/">Pro Git</a> by Scott Chacon, and <a href="http://hginit.com/">Hg
Init</a> by Joel Spolsky.</p>

<h2>Conclusion</h2>

<p>This is the last post in the <a href="https://blog.sanctum.geek.nz/series/unix-as-ide/">Unix as IDE series</a>; I’ve tried to offer a
rapid survey of the basic tools available just within a shell on GNU/Linux for all
of the basic functionality afforded by professional IDEs. At points I’ve had to
be not quite as thorough as I’d like in explaining certain features, but to
those unfamiliar to development on GNU/Linux machines this will all have hopefully
given some idea of how comprehensive a development environment the humble shell
can be, and all with free, highly mature, and standard software tools.</p>
					</div><!-- .entry-content -->
		
		<!-- .entry-meta -->
	</article><!-- #post-375 -->

				
				
			
			</div><!-- #content -->
		</section><!-- #primary -->

		<div id="secondary" role="complementary">
			
		
		</div><!-- #secondary .widget-area -->

	</div></div>
  </body>
</html>
