<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bitecode.dev/p/whats-up-python-the-gil-removed-a">Original</a>
    <h1>What&#39;s up, Python? The GIL removed, a new compiler, optparse deprecated</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><ul><li><p><em>Python without the GIL, for good</em></p></li><li><p><em>LPython: a new Python Compiler</em></p></li><li><p><em>Pydantic 2 is getting usable</em></p></li><li><p><em>PEP 387 defines &#34;Soft Deprecation&#34;, getopt and optparse soft deprecated</em></p></li><li><p><em>Cython 3.0 released with better pure Python support</em></p></li><li><p><em>PEP 722 – Dependency specification for single-file scripts</em></p></li><li><p><em>Python VSCode support gets faster</em></p></li><li><p><em>Paint in the terminal</em></p></li></ul><p><a href="https://www.bitecode.dev/p/whats-up-in-the-python-community-98e" rel="">We saw last month</a><span> the G</span><a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="">lobal Interpreter Lock</a><span> was the center of attention once again. This month it carried on to the point than even Meta, Facebook’s parent company, </span><a href="https://discuss.python.org/t/a-fast-free-threading-python/27903/99?u=ambv" rel="">pitched in</a><span>:</span></p><blockquote><p>If PEP 703 is accepted, Meta can commit to support in the form of three [engineer years on landing] nogil CPython</p></blockquote><p><span>It is nice to have Python seeing more and more contributions from the big companies that used it for their success. It&#39;s a huge contrast </span><a href="https://pyfound.blogspot.com/2012/01/psf-grants-over-37000-to-python.html" rel="">compared to the 2010 decade</a><span>.</span></p><p><span>The discussion culminated with an internal debate with the core devs, which ended up with an official announcement that </span><a href="https://peps.python.org/pep-0703/" rel="">PEP 703</a><span>, the proposal that relit the fire, </span><a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474" rel="">was going to be accepted </a><span>after some details being figured out.</span></p><p>This means in the coming years, Python will have its GIL removed.</p><p>Here is the plan:</p><ul><li><p>Short term, an unsupported experimental version of Python without the GIL is published in parallel to the regular one. Target is 3.13/3.14.</p></li><li><p>Mid-term, the no-GIL version is marked as officially supported, but is still just an alternative to Python with GIL. A target date is announced to make it the default once. This will happen only after the community has shown enough support for it, and will take several years.</p></li><li><p>Long-term, no-GIL becomes the default. Before this, the core devs can reverse the decision and abort the no-GIL project if it proves to have a bad ROI.</p></li></ul><p>Note that if the program imports one single C-extension that uses the GIL on the no-GIL build, it&#39;s designed to switch back to the GIL automatically. So this is not a 2=&gt;3 situation where non-compatible code breaks. </p><p>The main reason for the two different builds is to manage the unknown unknowns. Indeed, nobody expects the no-GIL to break things, but with such a big project, you can never be sure. ABI compat is tricky, and new extensions need to be compiled explicitly against it for it to work, so there is a need for the community embracing it.</p><p>Also, no-GIL compatible extensions will work on the old interpreter, so you don&#39;t get in the situation like Python 3 code not working on Python 2.</p><p>In fact, Python code itself should not be affected and will work seamlessly on one or the other, albeit with threads limited to a single core with the GIL.</p><p><span>That&#39;s the news I didn&#39;t see coming. In &#34;</span><a href="https://www.bitecode.dev/p/whats-the-deal-with-cpython-pypy" rel="">What&#39;s the deal with CPython, Pypy, MicroPython, Jython...?</a><span>&#34; we talked about Python compilers, and I thought I did a pretty good job about listing everything that mattered. Well, the team behind </span><a href="https://github.com/lcompilers/lpython" rel="">LPython</a><span> decided to take this list and </span><code>.append()</code><span> on it.</span></p><p><span>LPython is a new BSD 3 compiler that takes Python code and translate it for the following for LLVM, C, C++ or WASM. It doesn&#39;t aim to compile the entire program, although it can, but rather, like numba and cython, to let you speed up numerical bottle neck. </span><a href="https://lpython.org/blog/2023/07/lpython-novel-fast-retargetable-python-compiler/" rel="">The benchmarks</a><span> are very promising and the ability to switch between Ahead-of-Time and Just-in-Time very convenient, although you will still need </span><a href="https://github.com/lcompilers/lpython#installation" rel="">the entire compilation chain installed on the machine</a><span>. LPython likes raw Python code, so if you call a Python function inside your snippet, you must explicitly mark it as such with a decorator. So most will likely use it for very specific snippets.</span></p><p>I&#39;ve been pitching the coming of the version 2 of Pydantic for some time, because I, and many people, use it a lot for data validation / schema definition, and the new version is much faster.</p><p><span>Yes, it came out as stable last month, but if you read &#34;</span><a href="https://www.bitecode.dev/p/relieving-your-python-packaging-pain" rel="">Relieving your Python packaging pain</a><span>&#34; you know I don&#39;t encourage people to use the last version of anything except for testing or having fun.</span></p><p>Indeed, even a stable major version is still something that is guaranteed to need refinement, and still has little community support.</p><p>But now two things have happened:</p><ul><li><p><a href="https://github.com/pydantic/pydantic/releases" rel="">Pydantic 2.1 has been released</a><span>, the first wave of nasty bugs have been eradicated.</span></p></li><li><p><a href="https://fastapi.tiangolo.com/release-notes/#01000" rel="">Fast API announced support of Pydantic 2</a><span>. Since it&#39;s the biggest driver of Pydantic usage, it&#39;s a milestone.</span></p></li></ul><p>I will now proceed with giving it a try in one personal project, and if it works, move it into professional projects in a few months.</p><p><span>If you haven&#39;t read Victor Stinner&#39;s blog yet, I encourage you to do so. It&#39;s technical and raw, with zero BS, and gives you a good view of what happens inside the contribution life of a core dev. </span><a href="https://vstinner.github.io/contrib-python-july-2023.html" rel="">Last article</a><span> mentions something I missed last month: soft deprecation has been added to </span><a href="https://peps.python.org/pep-0387/" rel="">PEP 387 – Backwards Compatibility Policy</a><span>.</span></p><p>This document, created in 2009, states how the Python projects deals with deprecation, and it will now contain the following:</p><blockquote><p>A soft deprecation can be used when using an API which should no longer be used to write new code, but it remains safe to continue using it in existing code. The API remains documented and tested, but will not be developed further (no enhancement). The main difference between a “soft” and a (regular) “hard” deprecation is that the soft deprecation does not imply scheduling the removal of the deprecated API.</p></blockquote><p>Basically, a soft deprecated API is in a zombie state, maintained alive forever, but will never see any work on it and be explicitly advised against being used.</p><p><a href="https://docs.python.org/3/library/optparse.html" rel="">optparse</a><span> and </span><a href="https://docs.python.org/3/library/getopt.html" rel="">getopt</a><span>, two modules that used to be a de-facto solution for parsing script arguments in their time, are now marked as &#34;soft-deprecated&#34;. You can use them forever, but you probably should not.</span></p><p><span>First, </span><a href="https://docs.python.org/3/library/argparse.html#module-argparse" rel="">argparse</a><span> is the more modern stdlib solution, and we have </span><a href="https://www.bitecode.dev/p/parameters-options-and-flags-for" rel="">a good article on it.</a></p><p><span>Second, 3rd party projects like </span><a href="https://typer.tiangolo.com/" rel="">typer</a><span> and </span><a href="https://click.palletsprojects.com/en/8.1.x/" rel="">click</a><span> exist.</span></p><p><a href="https://cython.org/" rel="">Cython</a><span>, the most famous Python compiler, </span><a href="https://cython.readthedocs.io/en/latest/src/changes.html" rel="">released version 3</a><span>. While the release comes with all sorts of improvement, one particularly stands out. Cython always had limitations: it used a superset of Python to express some of its features.</span></p><p>This is no more the case, as the release notes: &#34;it should now be possible to express all Cython code and use all features in regular Python syntax&#34;.</p><p>Which means you now should be able to use any Python code base, just Cython it all and see what happens.</p><p><span>While the no-GIL topic was certainly still alive and well, the proposal of </span><a href="https://pep-previews--3210.org.readthedocs.build/pep-0722" rel="">PEP 722</a><span> really </span><a href="https://discuss.python.org/t/pep-722-dependency-specification-for-single-file-scripts/29905" rel="">heated things up</a><span>.</span></p><p><span>The idea is to formalize a syntax in comments that, similar to </span><a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" rel="">Groovy’s</a><span>, would allow expressing the dependency of a single script. Taking the example from the PEP itself:</span></p><pre><code><code># In order to run, this script needs the following 3rd party libraries
#
# Requirements:
#    requests
#    rich

import requests
from rich.pretty import pprint

resp = requests.get(&#34;https://peps.python.org/api/peps.json&#34;)
data = resp.json()
pprint([(k, v[&#34;title&#34;]) for k, v in data.items()][:10])</code></code></pre><p>The important lines are:</p><pre><code><code># Requirements:
#    requests
#    rich</code></code></pre><p><span>Which now would be officially formalized to be parsed by third-party tools. The concept is not new and tools like </span><a href="https://pypi.org/project/pip-run/" rel="">pip-run</a><span> already support running a script for which you have the deps described with such comments:</span></p><pre><code><code>$ pip uninstall rich requests
WARNING: Skipping rich as it is not installed.
WARNING: Skipping requests as it is not installed.
$ pip-run dah_script.py
[
│   (&#39;1&#39;, &#39;PEP Purpose and Guidelines&#39;),
│   (&#39;2&#39;, &#39;Procedure for Adding New Modules&#39;),
│   (&#39;3&#39;, &#39;Guidelines for Handling Bug Reports&#39;),
│   (&#39;4&#39;, &#39;Deprecation of Standard Modules&#39;),
│   (&#39;5&#39;, &#39;Guidelines for Language Evolution&#39;),
│   (&#39;6&#39;, &#39;Bug Fix Releases&#39;),
│   (&#39;7&#39;, &#39;Style Guide for C Code&#39;),
│   (&#39;8&#39;, &#39;Style Guide for Python Code&#39;),
│   (&#39;9&#39;, &#39;Sample Plaintext PEP Template&#39;),
│   (&#39;10&#39;, &#39;Voting Guidelines&#39;)
]</code></code></pre><p><span>Packages are installed in a temporary </span><a href="https://www.bitecode.dev/p/back-to-basics-with-pip-and-venv" rel="">virtual env</a><span> and deleted after the run, like </span><a href="https://www.npmjs.com/package/npx" rel="">npx</a><span> used to do for the JS world.</span></p><p><span>The PEP doesn&#39;t imply Python or pip are going to integrate such feature, it&#39;s only about formalizing the syntax for now. But I have good hope for this one, as I have several lone Python scripts lying around that would really benefit from this, especially if you can keep the env around in the future. Such a proposal could show demand for it, and years later, lead to pip adoption. E.G: npx influenced the addition of </span><code>npm create</code><span>, which allows to fetch a project template from specific packages. Indeed, that was the most common use case for npx.</span></p><p><span>If you use VSCode, you may have noticed using a lot of linters made the IDE slower. Mypy is particularly at fault as the </span><code>mypy</code><span> command is slow to start, and the daemon mode is not used by VSCode.</span></p><p><span>For his </span><a href="https://devblogs.microsoft.com/python/python-in-visual-studio-code-july-2023-release/" rel="">new release</a><span>, a new official mypy extension is now available, which uses the dmypy daemon. The speed up is such that the editor can now offer the check on the entire code base, not just the current file.</span></p><p>On top of that, pylance, the Microsft official extension for Python support, will now persist all the indexing work it performs on 3rd party libs. This will result in a lighter startup, and for big project, a speedier experience as indexing can take some time with slow machines.</p><p>I personally have to work on corporate clients’ laptops I can&#39;t modify, and they come with a ton of security software that makes them slow down to crawl, with process inspection and network calls to check file signatures after you click on anything. So this is a lifesaver.</p><p>This is just so cool:</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png" width="1008" height="834" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:834,&#34;width&#34;:1008,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:28943,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7266f3-6542-4d5f-a261-3e0ba3c0edca_1008x834.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p><a href="https://github.com/1j01/textual-paint" rel="">It&#39;s a version of paint</a><span> that runs in the terminal, thanks to the Python lib </span><a href="https://textual.textualize.io/" rel="">textual</a></p><p>It&#39;s not going to change your life or anything, but WOW.</p><p>I installed it, and it&#39;s damn reactive. It even handles Ctrl-Z, and features a file selector when you try to save your work.</p></div></div></div></article></div></div></div>
  </body>
</html>
