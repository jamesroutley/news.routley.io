<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samwho.dev/turing-machines/">Original</a>
    <h1>Turing Machines</h1>
    
    <div id="readability-page-1" class="page"><article>
    <main id="content">
        
<figure>
  <figcaption>
    <img src="https://samwho.dev/images/turing-signature.svg" alt="Alan Turing&#39;s written signature"/>
    <p><b>ALAN M. TURING</b></p>
    <p aria-label="Born 23rd June 1912, died 7th June 1954">23 June 1912 – 7 June 1954</p>
  </figcaption>
  <a href="https://samwho.dev/">
    <img src="https://samwho.dev/images/turing-sketch.png" alt="A pencil drawing of Alan Turing, drawn by the post author Sam Rose."/>
  </a>
  <turing-machine padding="0" show-head="false" play="true">
    <program entrypoint="F" show="false">
      F |   |   P(T) R P(u) R P(r) R P(i) R P(n) R P(g) R P( ) R P(M) R P(a) R P(c) R P(h) R P(i) R P(n) R P(e) R P(s) R -&gt; B
      B |   | L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( ) L P( )   -&gt; F
    </program>
  </turing-machine>
</figure>

<p>In 1928, David Hilbert, one of the most influential mathematicians of his time,
asked whether it is possible to create an algorithm that could determine the
correctness of a mathematical statement. This was called the &#34;decision problem,&#34;
or &#34;Entscheidungsproblem&#34; in Hilbert&#39;s native German. In 1936 both Alan Turing
and Alonzo Church independently reached the conclusion, using different methods,
that the answer is &#34;no.&#34;</p>
<p>The way Turing did it was to imagine a &#34;universal machine&#34;, a machine that could
compute anything that could be computed. This idea, the &#34;Turing machine&#34; as
Alonzo Church christened it in 1937, laid the foundations for the device you are
using to read this post. If we look hard enough we can see Turing&#39;s legacy in
today&#39;s CPUs.</p>
<p>By the end of this post, you will know:</p>
<ul>
<li>What a Turing machine is.</li>
<li>What can and cannot be computed.</li>
<li>What it means to be Turing complete.</li>
<li>How modern computers relate to Turing machines.</li>
<li>How to write and run your own programs for a Turing machine.</li>
</ul>
<h2 id="what-is-a-turing-machine"><a href="#what-is-a-turing-machine">#</a>
What <em>is</em> a Turing machine?</h2>
<p>You might expect a universal machine, capable of computing anything that can be
computed, to be a complex device. Nothing could be further from the truth. The
machine has just 4 parts, and the language used to program it has just 5
instructions.</p>
<dog- name="sage" position="right">
  It&#39;s important to keep in mind that what Turing described is a
  <b>theoretical</b> machine. It was created as a thought experiment to explore
  the limits of what can be computed. Some have of course <a href="https://www.youtube.com/watch?v=vo8izCKHiF0">been built</a>, but in 1936
  they existed only in the heads of Turing and those who read his paper.
</dog->
<p>The parts are: a !tape, a !head, a !program, and a !state. When you&#39;re ready,
go ahead and press !play.</p>
<turing-machine>
  <controls></controls>
  <program entrypoint="start">
    start |   | P(0) R -&gt; start
  </program>
</turing-machine>
<p>What you&#39;re seeing here is a program that executes <span>P(0)</span> to print 0 to the tape, moves the head
right with the <span>R</span> instruction, then
!jumps back to the start. It will go on printing 0s forever.</p>
<p>At any point, feel free to !pause, step the machine !forwards or !backwards one
instruction at a time, or !restart the program from the beginning. There is also
a speed selector on the far right of the controls if you want to speed up the
machine.</p>
<p>Notice that !state and !value never change. Every time the machine performs a
!jump, the current state and value are used to pick the correct next row of
instructions to execute. This program only has a single state, <span>start</span>, and every time it jumps, the symbol under the
!head is !blank.</p>
<p>Let&#39;s take a look at a program with multiple states.</p>
<turing-machine>
  <controls></controls>
  <program entrypoint="zero">
    zero |   | P(0) R -&gt; one
    one  |   | P(1) R -&gt; zero
  </program>
</turing-machine>
<p>This program prints alternating 0s and 1s to the tape. It has 2 states, <span>zero</span> and <span>one</span>, to
illustrate what happens when you !jump to a different state.</p>
<dog- name="doe">
  <b>Things moving too fast?</b> The slider below can be used to adjust the speed
  of all the Turing machines on this page.
  <p><label for="speed" id="speed-label">100%</label>
    
  </p>
</dog->
<p>You can also achieve this same result by using a single !state and alternating
the !value. Here&#39;s an example of that:</p>
<turing-machine>
  <controls></controls>
  <program entrypoint="start">
    start |   | R P(1) -&gt; start
    start | 1 | R P(0) -&gt; start
    start | 0 | R P(1) -&gt; start
  </program>
</turing-machine>
<p>The !value column always stays up to date with what the current symbol is under
the !head, then when we !jump that value is used to know which row of
instructions to execute. Combining state and value gives us a surprising amount
of control over what our !program does.</p>
<p>We&#39;ve so far seen 3 instructions:</p>
<ul>
<li><span>P</span> prints a given symbol to the tape.</li>
<li><span>R</span> moves the tape head right.</li>
<li><span>↪︎</span> jumps to a given state.</li>
</ul>
<p>There are 2 more:</p>
<ul>
<li><span>L</span> moves the tape head left.</li>
<li><span>H</span> halts the machine.</li>
</ul>
<turing-machine>
  <controls></controls>
  <program entrypoint="0">
    0 |   | P(n) L -&gt; 1
    1 |   | P(a) L -&gt; 2
    2 |   | P(l) L -&gt; 3
    3 |   | P(A) H
  </program>
</turing-machine>
<p>This program prints the word &#34;Alan&#34; from right to left then halts. If you can&#39;t
see the full word, you can drag the !tape left and right. If the machine has
halted, you can use !restart to start it again from the beginning.</p>
<dog- name="haskie" mode="concerned" position="right">
  You&#39;re telling me that everything can be computed with just these 5
  instructions? Word processors, YouTube, video games, all of it?
</dog->
<p>All of it! You&#39;re probably not going to get Crysis running at 60fps on a
simulated Turing machine, but all of the calculations required to render each
frame can be done with just these 5 instructions. Everything you have ever seen
a computer do can be done with a Turing machine. We&#39;ll see a glimpse of how
that can work in practice a little later.</p>
<p>The last example I want to show you before we move on is the very first program
Alan Turing showed the world. It&#39;s the first program featured in his 1936 paper:
<em>&#34;On Computable Numbers, with an application to the Entsheidungsproblem.&#34;</em></p>
<turing-machine>
  <controls></controls>
  <program entrypoint="b">
    b |   | P(0) R -&gt; c
    c |   | R -&gt; e
    e |   | P(1) R -&gt; k
    k |   | R -&gt; b
  </program>
</turing-machine>
<p>Turing liked to leave spaces between symbols, going as far as to even define
them as &#34;F-squares&#34; and &#34;E-squares&#34;. F for figure, and E for erasable. His
algorithms would often make use of E-squares to help the machine remember the
location of specific !tape squares.</p>
<h2 id="what-does-it-mean-to-compute"><a href="#what-does-it-mean-to-compute">#</a>
What does it mean to <em>compute</em>?</h2>
<p>Something is said to be &#34;computable&#34; if there exists an algorithm that can get
from the given input to the expected output. For example, adding together 2
integers is computable. Here I&#39;m giving the machine a !tape that starts out with
the values 2 and 6 in binary separated by a !blank.</p>
<turing-machine input="010 110">
  <controls></controls>
  <program entrypoint="b1">
    b1 | 0 | R -&gt; b1
    b1 | 1 | R -&gt; b1
    b1 |   | R -&gt; b2
<pre><code><span>b2 | 0 | R -&gt; b2
</span><span>b2 | 1 | R -&gt; b2
</span><span>b2 |   | L -&gt; dec
</span><span>
</span><span>dec | 0 | P(1) L -&gt; dec
</span><span>dec | 1 | P(0) L -&gt; b3
</span><span>dec |   | H
</span><span>
</span><span>b3 | 0 | L -&gt; b3
</span><span>b3 | 1 | L -&gt; b3
</span><span>b3 |   | L -&gt; inc
</span><span>
</span><span>inc | 0 | P(1) R -&gt; b1
</span><span>inc | 1 | P(0) L -&gt; inc
</span><span>inc |   | P(1) R -&gt; b1
</span></code></pre>
  </program>
</turing-machine>
<p>This program adds the two numbers together, arriving at the answer 8. It does
this by decrementing from the right number and incrementing the left number
until the right number is 0. Here&#39;s the purpose of each state:</p>
<ul>
<li><span>b1</span> Move right until the first !blank square
is found. This is to navigate past the first number.</li>
<li><span>b2</span> Move right until the second !blank
square is found. This is to navigate past the second number.</li>
<li><span>dec</span> Decrement the current number by 1. In
practice this will always be the right number. It decrements by flipping bits
until it either reaches a 1, where it will navigate back to the left number, or
a !blank, which it will interpret as the number having hit 0.</li>
<li><span>b3</span> Move left until the first !blank
square again. This is only ever used after we&#39;ve decremented the rightmost
number. We can&#39;t reuse the <span>b1</span> state here
because when we reach the !blank, we want to jump to <span>inc</span>.</li>
<li><span>inc</span> Increment the current number by 1.
Similar to decrementing, this will only ever happen on the leftmost number in
practice. This is done by flipping bits until we reach a 0, at which point we
navigate back to the right number.</li>
</ul>
<p>That we can write this program at all is proof that addition is computable, but
it also implies that all integers are computable. If we can add any 2 integers,
we can compute any other integer. 1 is 0+1, 2 is 1+1, 3 is 2+1, and so on.</p>
<dog- name="haskie" mode="confused">
  Why is the right number 111 and not 000 at the end of
  this program?
</dog->
<p>It&#39;s tricky to write the equivalent of <code>if (rightNum === 0) break;</code> in a Turing
machine, so this program does it as part of the decrementing process. If, while
decrementing, it gets all the way to a !blank square, it interprets that to mean
the number has hit 0 and halts.</p>
<h3 id="binary-vs-decimal"><a href="#binary-vs-decimal">#</a>
Binary vs Decimal</h3>
<p>You may have wondered why I&#39;m choosing to work with binary numbers rather than
decimal. It&#39;s not just because that&#39;s how modern computers work. I&#39;m going to
show you 2 examples, and from those examples you&#39;ll be able to see <em>why</em> modern
computers choose to work in binary.</p>
<p>The first example is a program that increments a binary number in an endless
loop.</p>
<turing-machine>
  <controls></controls>
  <program entrypoint="move">
    move | 1 | R -&gt; move
    move | 0 | R -&gt; move
    move |   | L -&gt; flip
    flip | 0 | P(1) R -&gt; move
    flip | 1 | P(0) L -&gt; flip
    flip |   | P(1) R -&gt; move
  </program>
</turing-machine>
<p>The second example is a program that increments a decimal number in an endless
loop.</p>
<turing-machine input="0">
  <controls></controls>
  <program entrypoint="inc">
    inc    | 0 | P(1)   -&gt; back
    inc    | 1 | P(2)   -&gt; back
    inc    | 2 | P(3)   -&gt; back
    inc    | 3 | P(4)   -&gt; back
    inc    | 4 | P(5)   -&gt; back
    inc    | 5 | P(6)   -&gt; back
    inc    | 6 | P(7)   -&gt; back
    inc    | 7 | P(8)   -&gt; back
    inc    | 8 | P(9)   -&gt; back
    inc    | 9 | P(0) L -&gt; inc
    inc    |   | P(1)   -&gt; back
    back   |   | L -&gt; inc
    back   | * | R -&gt; back
  </program>
</turing-machine>
<p>These two programs are doing the same thing, but the program for manipulating
decimal numbers is much longer. We&#39;ve even introduced some new syntax, the <span>*</span> symbol, to handle a !value under the !head that
does not match any of the other values for that !state. It&#39;s for this reason
when programming Turing machines we prefer binary numbers: the programs end up
being shorter and easier to reason about.</p>
<p>This benefit also translates to the physical world. Components that switch
between 2 states are cheaper, smaller, and more reliable than components that
switch between 10. It was more practical to build computers that worked in
binary than ones that work in decimal, though attempts to build decimal
computers <a href="https://en.wikipedia.org/wiki/Decimal_computer">were made</a>.</p>
<h2 id="what-can-t-be-computed"><a href="#what-can-t-be-computed">#</a>
What <em>can&#39;t</em> be computed?</h2>
<p>To approach this question we need to explain the &#34;Halting problem.&#34; It goes like
this:</p>
<blockquote>
Given a program and some input, is it possible to write a second program
that will tell you with certainty whether the first program will halt or run
forever?
</blockquote>
<p>The answer is no, and this is what Turing essentially proved. The proof is
complicated and I&#39;m not ashamed to admit I don&#39;t understand it, but there is an
example I can give you that can be intuitively understood to be &#34;undecidable.&#34;</p>
<p>Imagine you write a program that takes as its input the program being used to
decide whether it will halt or not. What it then does is run the decider program
on itself, and then do the opposite of what the decider program says.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>function </span><span>undecidable</span><span>(</span><span>willHalt</span><span>) {
</span><span>  </span><span>if </span><span>(</span><span>willHalt</span><span>(undecidable)) {
</span><span>    </span><span>while </span><span>(</span><span>true</span><span>);
</span><span>  } </span><span>else </span><span>{
</span><span>    </span><span>return </span><span>true</span><span>;
</span><span>  }
</span><span>}
</span></code></pre>
<p>This program intentionally enters an infinite loop if it is told it will halt,
and halts if it is told it will run forever. It seems like a silly example, the
kind of answer a cheeky high school student might try to get away with, but it
is a legitimate counterexample to the idea that the halting problem can be
solved.</p>
<p>If you were to imagine encoding the program and input into something that could
be represented on the !tape, there would be no !program that could determine
whether the program would halt or not. Imagining this encoding becomes quite
natural when you realise that modern programs are encoded as binary data to
be saved to disk.</p>
<h2 id="what-does-it-mean-to-be-turing-complete"><a href="#what-does-it-mean-to-be-turing-complete">#</a>
What does it mean to be <em>Turing complete</em>?</h2>
<p>If you&#39;ve been involved in the world of programming for more than a few years,
there&#39;s a good chance you&#39;ve come across the term &#34;Turing complete.&#34; Most likely
in the context of things that really ought not to be Turing complete, like
<a href="https://rtraba.com/wp-content/uploads/2015/05/cppturing.pdf">C++ templates</a>, <a href="https://itnext.io/typescript-and-turing-completeness-ba8ded8f3de3">TypeScript&#39;s type system</a> or <a href="https://www.infoq.com/articles/excel-lambda-turing-complete/">Microsoft Excel</a>.</p>
<p>But what does it <em>mean</em>?</p>
<p>Like the Halting problem, the proof is complicated but there&#39;s a straightforward
test you can apply to something to judge it Turing complete:</p>
<blockquote>
  A system is Turing complete if it can be used to simulate a Turing machine.
</blockquote>
<p>I&#39;ve written this post, with the Turing machine simulations, in JavaScript.
Therefore JavaScript is Turing complete. The C++ template example given above
simulates a Turing machine in C++&#39;s template system. The TypeScript example
takes the route of writing an interpreter for a different Turing complete
language.</p>
<dog- name="haskie" mode="confused">
  Wait a second, wouldn&#39;t you need an infinite amount of memory to simulate a
  Turing machine? Doesn&#39;t the !tape extend forever in both directions?
</dog->
<p>You&#39;re right, and everyone tends to cheat a bit with the definition. When
someone says something is Turing complete, what they mean is it <em>would</em> be Turing
complete if it had an infinite amount of memory. The infinite tape limitation
means no Turing machine could ever exist in our physical reality, so that
requirement tends to get waived.</p>
<h2 id="how-does-this-all-relate-to-modern-computers"><a href="#how-does-this-all-relate-to-modern-computers">#</a>
How does this all relate to <em>modern computers</em>?</h2>
<p>If you read around the topic of Turing machines outside of this post, you might
see it said that modern computers are effectively Turing machines. You would be
forgiven for finding it difficult to imagine how you go from adding 2 integers
in binary on a !tape to running a web browser, but the line is there.</p>
<p>A key difference between our Turing machine and the device you&#39;re reading this
on is that your device&#39;s CPU has &#34;registers.&#34; These are small pieces of memory
that live directly on the CPU and are used to store values temporarily while
they&#39;re being operated on. Values are being constantly loaded from memory into
registers and saved back again. You can think of registers as variables for your
CPU, but they can only store fixed-size numbers.</p>
<p>We <em>can</em> create registers in our Turing machine. We can do this by creating a
&#34;format&#34; for our tape.</p>
<turing-machine input="HA000B000C000">
</turing-machine>
<p>Here we define 3 registers: A, B, and C. Each register contains a 3 bits and can
store numbers between 0 and 7. Then at the far left we have an H, which stands
for &#34;home&#34;, which will help us navigate.</p>
<p>To increment register C, we can write a program like this:</p>
<turing-machine input="HA000B000C000">
  <controls></controls>
  <program entrypoint="goto_c">
    goto_c | * | R -&gt; goto_c
    goto_c | C | R R R -&gt; inc
    inc    | 0 | P(1) -&gt; goto_h
    goto_h | * | L -&gt; goto_h
    goto_h | H | H
  </program>
</turing-machine>
<p>We&#39;re making a lot more liberal use of the <span>*</span>
symbol here to help us navigate to specific parts of the !tape without having to
enumerate all possible values that could be under the !head on the way there.</p>
<p>This program is effectively equivalent to the following x86 assembly code, if
x86 had a register named <code>c</code>:</p>
<pre data-lang="asm"><code data-lang="asm"><span>mov </span><span>c</span><span>, </span><span>0</span><span> ; Load 0 into c
</span><span>inc </span><span>c</span><span>    ; Increment c by 1
</span></code></pre>
<p>If we wanted to add values in A and B, storing the result in C, we need to do
more work. Here&#39;s the assembly code we&#39;re trying to replicate:</p>
<pre data-lang="asm"><code data-lang="asm"><span>mov </span><span>a</span><span>, </span><span>2</span><span>  ; Load 2 into a
</span><span>mov </span><span>b</span><span>, </span><span>3</span><span>  ; Load 3 into b
</span><span>add </span><span>c</span><span>, </span><span>a</span><span>  ; Add a to c
</span><span>add </span><span>c</span><span>, </span><span>b</span><span>  ; Add b to c
</span></code></pre>
<p>Before you scroll down I will warn you that the program is long and complex. It
is the last program we will see in this post, and I don&#39;t expect you to
understand it in full to continue to the end. Its main purpose is to show you
that we <em>can</em> implement operations seen in modern assembly code on a Turing
machine.</p>
<turing-machine input="HA000B000C000">
  <controls></controls>
  <program entrypoint="inita">
    inita | * | R R P(0) R P(1) R P(0) R -&gt; initb
    initb | * | R P(0) R P(1) R P(1) R -&gt; start
<pre><code><span>start | * | L -&gt; start
</span><span>start | H | R -&gt; go_a
</span><span>
</span><span>go_a | * | R -&gt; go_a
</span><span>go_a | A | R R R -&gt; dec_a
</span><span>
</span><span>dec_a  | 0 | P(1) L -&gt; cry_a
</span><span>dec_a  | 1 | P(0) -&gt; go_c1
</span><span>
</span><span>cry_a | 0 | P(1) L -&gt; cry_a
</span><span>cry_a | 1 | P(0) -&gt; go_c1
</span><span>cry_a | * | R P(0) R P(0) R P(0) -&gt; goto_b
</span><span>
</span><span>go_c1 | * | R -&gt; go_c1
</span><span>go_c1 | C | R R R -&gt; inc_c1
</span><span>
</span><span>inc_c1 | 0 | P(1) -&gt; h2a
</span><span>inc_c1 | 1 | P(0) L -&gt; cry_ca
</span><span>
</span><span>cry_ca | 0 | P(1) -&gt; h2a
</span><span>cry_ca | 1 | P(0) L -&gt; cry_ca
</span><span>cry_ca | * | R -&gt; h2a
</span><span>
</span><span>h2a | * | L -&gt; h2a
</span><span>h2a | H | R -&gt; go_a
</span><span>
</span><span>goto_b | * | R -&gt; goto_b
</span><span>goto_b | B | R R R -&gt; dec_b
</span><span>
</span><span>dec_b | 0 | P(1) L -&gt; dec_bc
</span><span>dec_b | 1 | P(0) -&gt; go_c2
</span><span>
</span><span>dec_bc | 0 | P(1) L -&gt; dec_bc
</span><span>dec_bc | 1 | P(0) -&gt; go_c2
</span><span>dec_bc | * | R P(0) R P(0) R P(0) -&gt; end
</span><span>
</span><span>go_c2 | * | R -&gt; go_c2
</span><span>go_c2 | C | R R R -&gt; inc_c2
</span><span>
</span><span>inc_c2 | 0 | P(1) -&gt; go_hb
</span><span>inc_c2 | 1 | P(0) L -&gt; cry_cb
</span><span>
</span><span>cry_cb | 0 | P(1) -&gt; go_hb
</span><span>cry_cb | 1 | P(0) L -&gt; cry_cb
</span><span>cry_cb | * | R -&gt; go_hb
</span><span>
</span><span>go_hb | * | L -&gt; go_hb
</span><span>go_hb | H | R -&gt; goto_b
</span><span>
</span><span>end | * | L -&gt; end
</span><span>end | H | H
</span></code></pre>
  </program>
</turing-machine>
<p>This is painfully laborious, and it doesn&#39;t even precisely match the assembly
code. It destroys the values in A and B as it adds them together, and it doesn&#39;t
handle overflow. But it&#39;s a start, and I hope it gives you a glimpse of how this
theoretical machine can be built up to operate like a modern CPU.</p>
<p>If you watch the program run to completion, something that might strike you is
just how much work is required to do something as simple as adding 2 numbers.
Turing machines were not designed to be practical, Turing never intended anyone
to go out and build one of these machines in the hope it will be useful.</p>
<p>Modern machines have circuits within them that can add 2 numbers together by
passing 2 electrical signals in and getting the sum as a single signal out. This
happens in less than a nanosecond. Modern machines have memory where any byte
can be accessed at any time, no tape manipulation required. This memory access
takes a few dozen nanoseconds.</p>
<h2 id="writing-and-running-your-own-programs"><a href="#writing-and-running-your-own-programs">#</a>
Writing and running your own programs</h2>
<p>I&#39;ve built a web-based development environment for writing programs that will
run on the Turing machine visualisations you&#39;ve seen throughout the post.</p>
<p>You can access the editor <b><a href="https://samwho.dev/christopher">here</a></b>.</p>
<p>I encourage you to play around with it. Set a simple goal, like adding
together 2 numbers without going back to look at the way I did it in the post.
It&#39;s a great way to get a feel for how the machine works.</p>
<h2 id="conclusion"><a href="#conclusion">#</a>
Conclusion</h2>
<p>To recap, we&#39;ve covered:</p>
<ul>
<li>What a Turing machine is.</li>
<li>What can and cannot be computed.</li>
<li>What it means to be Turing complete.</li>
<li>How modern computers relate to Turing machines.</li>
</ul>
<p>And you now have access to an environment for writing and running your own
Turing machine programs. If you use it to make something neat, please do reach
out to me and show me! My email address is <a href="mailto:hello@samwho.dev">hello@samwho.dev</a>.</p>
<figure>
  <img src="https://samwho.dev/images/turing-apple.png"/>
  <figcaption>
    On June 8th, 1954, Alan Turing was found dead in bed, at his home in
    Wilmslow. He had died the day before, aged 41, from cyanide poisoning. A
    half-slice of apple was on his bedside table, laced with cyanide. An inquest
    ruled the death a suicide.
  </figcaption>
</figure>
<h2 id="further-reading"><a href="#further-reading">#</a>
Further reading</h2>
<ul>
<li><a href="https://archive.org/details/Turing1936OnCumputableNumbers/page/n3/mode/2up">Turing&#39;s original paper</a> on computable numbers.</li>
<li><a href="https://www.charlespetzold.com/AnnotatedTuring/">The Annotated Turing</a> I
referenced this throughout the making of this post. It is a fabulous read,
strongly recommend.</li>
<li><a href="https://en.wikipedia.org/wiki/Alan_Turing:_The_Enigma">Alan Turing: The Enigma</a>
by Andrew Hodges. An excellent biography of Turing, I read this during the
writing of this post.</li>
<li><a href="https://redfrontdoor.org/turing-mandelbrot/">Calculating a Mandelbrot Set using a Turing
Machine</a>. This was exceptionally
useful for me to understand how to get from Turing machines to modern computers.</li>
</ul>
<figure>
  <img src="https://samwho.dev/images/christopher-morcom.png"/>
  <figcaption>
    Christopher Morcom, 13 July 1911 - 13 February 1930. Turing&#39;s childhood
    friend and first love.
  </figcaption>
</figure>
<h2 id="acknowledgements"><a href="#acknowledgements">#</a>
Acknowledgements</h2>
<p>These posts are never a solo effort, and this one is no exception. Sincere thanks
go to the following people:</p>
<ul>
<li>To my wife, Sophie, who drew the biographical sketches you&#39;re seeing at the
end here, and for putting up with my incessant talking about this post the
last 2 weeks.</li>
<li>Everyone who let me watch them read this post in real-time over a video call
and gave me feedback: <a href="https://jagasantagostino.com">Jaga Santagostino</a>, <a href="https://robert.bio">Robert Aboukhalil</a>, <a href="https://bsky.app/profile/me.tverghis.space">Tarun Verghis</a>, <a href="https://tylerity.com">Tyler Sparks</a>.</li>
<li>Everyone who came to hang out and help out in the <a href="https://www.twitch.tv/samwhoo">Twitch streams</a> when I
was building out the early versions of the Turing machine visualisations.</li>
<li>Everyone who supports my work on <a href="https://patreon.com/samwho">Patreon</a>.</li>
<li>Everyone who works on the tools used to build this post: TypeScript, Bun,
Two.js, Tween.js, Monaco, Peggy, Zed, and many other indirect dependencies.
We really do stand upon the shoulders of giants.</li>
</ul>
<figure>
  <img src="https://samwho.dev/images/hut-8.png"/>
  <figcaption>
    Hut 8, Bletchley Park, where Turing worked during World War II. It was in
    this hut that Alan worked with his team to break the German Naval Enigma
    code.
  </figcaption>
</figure>

    </main>
</article></div>
  </body>
</html>
