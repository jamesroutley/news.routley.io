<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aerique.blogspot.com/2011/01/baby-steps-into-genetic-programming.html">Original</a>
    <h1>Baby Steps into Genetic Programming</h1>
    
    <div id="readability-page-1" class="page"><div>
	<div>
      

<div id="outline-container-1">
<h2 id="sec-1"><span>1</span> Introduction </h2>
<div id="text-1">


<p>
While my final ranking in the Google AI Contest was disappointing
(<a href="http://ai-contest.com/language_profile.php?lang=Lisp">280th</a>), it was a very educational experience and was totally offset
by <a href="http://quotenil.com/Planet-Wars-Post-Mortem.html">Gábor Melis&#39; dominating win</a> using Common Lisp as well.
</p>
<p>
One of things that piqued my interest during the contest was <a href="http://ai-contest.com/forum/viewtopic.php?f=17&amp;t=1136">a post on the AI Challenge forums</a> about a bot written using <a href="http://en.wikipedia.org/wiki/Genetic_programming">genetic programming</a>.
Genetic programming (GP) and <a href="http://en.wikipedia.org/wiki/Genetic_algorithms">genetic algorithms</a> have always held my
interest but <a href="http://ai-contest.com/visualizer.php?game_id=9519434">seeing the bot in action</a> really motivated me to dive into
the matter.
</p>
<p>
Genetic programming is inspired by biological evolution and is a way
of solving problems by setting up an environment (tuned to the problem
at hand!) and allowing computer programs to evolve towards a possible
solution in that environment.
</p>
<p>
This article shows my initial exploration into GP using Common Lisp
and should be an example of a typical <a href="http://en.wikipedia.org/wiki/REPL">REPL</a> session (my session was a
couple of hours divided over two evenings).  The code has been
reviewed, made a more readable and lispier but still looks very much
like what I wrote initially.  From the REPL session useful output has
been cut and pasted into this article.
</p>
<p>
This is a <i>really</i> basic introduction into GP and is meant for people
interested in GP and/or interested in (Common) Lisp.  It is heavy on
code and examples and light on theory.  My intention is for the reader
to play around with the functions on the REPL as they come by in the
article.
</p>
<p>
The code in this article should be portable Common Lisp.  If you need
to know what a function or macro does please consult the <a href="http://clhs.lisp.se/Front/X_Symbol.htm">Common Lisp HyperSpec</a>.
</p>

</div>



<div id="outline-container-1_2">
<h3 id="sec-1_2"><span>1.2</span> Environment </h3>
<div id="text-1_2">


<p>
Many Common Lispers use Emacs, <a href="http://common-lisp.net/project/slime/">Slime</a> and usually Unix or OS X as
development environment.  However, do not get the impression this is
the only way to write Lisp.  The <a href="http://www.cliki.net/development">development page on CLiki</a> lists many
other alternatives in various states of usability.
</p>
<p>
My recommendation is to use your favorite text editor and <a href="http://www.clisp.org/">CLISP</a> since
it comes with command line history and tab completion built in.  Write
or paste the code in your editor and save the file after every
addition as for example &#34;<code>gp.lisp</code>&#34;.  Then you only need to type:
</p>
<dl><dd>
<pre>(load &#34;/path/to/gp.lisp&#34;)
</pre>

</dd></dl>

<p>
once and can use the command line history to reload it.
</p>
</div>
</div>

</div>

<div id="outline-container-2">
<h2 id="sec-2"><span>2</span> Generating Random Code </h2>
<p>
As you might have read, the <a href="http://ai-contest.com/profile.php?user_id=4038">space.invaders</a> bot was written in PHP.
Our weapon of choice is Common Lisp and the first matter of business
is generating random code.
</p>

<div id="outline-container-2_1">
<h3 id="sec-2_1"><span>2.1</span> Operators </h3>
<div id="text-2_1">





<pre>(<span>defparameter</span> <span>*operators*</span> &#39;(+ - * /))
</pre>



<p>
To keep things simple and already knowing our target function (πr²) we
opt for using four operators: addition, subtraction, multiplication
and division.  In the name of simplicity (again) they will have an
arity of 2, so they will all take two arguments.
</p>
<p>
*OPERATORS* is the name of the  variable.  The *earmuffs* convention
is used to signify global variables.
</p>
</div>

</div>

<div id="outline-container-2_2">
<h3 id="sec-2_2"><span>2.2</span> RANDOM-ELT </h3>
<div id="text-2_2">





<pre>(<span>defun</span> <span>random-elt</span> (sequence)
  (<span>let</span> ((seq-length (length sequence)))
    (<span>when</span> (&gt; seq-length 0)
      (elt sequence (random seq-length)))))
</pre>



<p>
The function RANDOM-FORM in the next section uses RANDOM-ELT to select
a random element from the list of operators.
</p>
</div>

</div>

<div id="outline-container-2_3">
<h3 id="sec-2_3"><span>2.3</span> Generating Random <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_form">Function Forms</a> </h3>
<div id="text-2_3">





<pre>(<span>defun</span> <span>random-form</span> (operators)
  (append (list (random-elt operators))
          (<span>loop</span> repeat 2  <span>; </span><span>arity
</span>                collect (<span>let</span> ((random-nr (random 100)))
                          (<span>cond</span> ((&lt; random-nr 50) (random-form operators))
                                ((&lt; random-nr 75) (random 10.0))
                                (t                &#39;=input=))))))
</pre>



<p>
The function works as follows: it creates a list of three items.  The
first item is a random operator and the second and third items are the
arguments to that operator:
</p>
<dl><dd>
<pre>(operator argument-1 argument-2)
</pre>

</dd></dl>

<p>
The arguments are either a random number between 0.0 and 10.0
(arbitrary limit), a variable called <code>=INPUT=</code> (more about this later)
or, <b>and this is important</b>, another list of three items.  For
example:
</p>
<dl><dd>
<pre>(* =INPUT= 2.345)
</pre>

</dd></dl>

<p>
or
</p>
<dl><dd>
<pre>(+ 6.789 (- =INPUT= 0.123))
</pre>

</dd></dl>

<p>
So the RANDOM-FORM function will call itself recursively if needed.
The (arbitrary) probabilities for the ARGUMENT-1 and ARGUMENT-2 are:
50% of the time another random form, 25% of the time a random number
and 25% of the time the <code>=INPUT=</code> variable.
</p>
<p>
The process of generating random forms described above is similar to
the &#34;grow&#34; method described in <a href="http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/22InitialisingthePopulation.html">Chapter 2.2 of the Field Guide</a>.
</p>

</div>

<div id="outline-container-2_3_1">
<h4 id="sec-2_3_1"><span>2.3.1</span> Limiting RANDOM-FORM </h4>
<div id="text-2_3_1">





<pre>(<span>defun</span> <span>random-form</span> (operators <span>&amp;optional</span> (max-depth 4))
  (append (list (random-elt operators))
          (<span>loop</span> repeat 2  <span>; </span><span>arity
</span>                collect (<span>let</span> ((random-nr (random 100)))
                          (<span>if</span> (&gt; max-depth 0)
                              (<span>cond</span> ((&lt; random-nr 50)
                                     (random-form operators (- max-depth 1)))
                                    ((&lt; random-nr 75) (random 10.0))
                                    (t                &#39;=input=))
                              (<span>cond</span> ((&lt; random-nr 50) (random 10.0))
                                    (t                &#39;=input=)))))))
</pre>



<p>
Since RANDOM-FORM can call itself recursively it can potentially
create huge amounts of random code and even exhaust the stack of the
Lisp implementation.  Hence we need to place some limits on
RANDOM-FORM.  The addition of the MAX-DEPTH parameter and the
deduction of MAX-DEPTH when RANDOM-FORM is called again prevents nasty
things from happening.
</p>
</div>
</div>

</div>

<div id="outline-container-2_4">
<h3 id="sec-2_4"><span>2.4</span> <code>=INPUT=</code> </h3>
<p>
Since we want our generated code to calculate the area of a circle
from an input value, the radius, we&#39;ve added the possibility to
generate the <code>=INPUT=</code> variable to RANDOM-FORM.  This variable is the
same as the input argument of the RUN-FORM function that is discussed
later.
</p>

</div>

<div id="outline-container-2_5">
<h3 id="sec-2_5"><span>2.5</span> Testing RANDOM-ELT and RANDOM-FORM </h3>
<div id="text-2_5">


<p>
Pasting RANDOM-ELT and RANDOM-FORM into the REPL and running the
latter a couple of times will yield some randomly generated code:
</p>
<dl><dd>
<pre>CL-USER&gt; (random-form *operators*)
(/ 2.8173013 5.378826)

CL-USER&gt; (random-form *operators*)
(* =INPUT= =INPUT=)

CL-USER&gt; (random-form *operators*)
(+ 7.9595613
 (- (- =INPUT= (* =INPUT= 0.57189345))
  (* (- (/ 6.9174767 9.723027) =INPUT=) (* =INPUT= =INPUT=))))

CL-USER&gt; (random-form *operators*)
(- (- =INPUT= (- (/ 2.002045 (* =INPUT= 9.829036)) 4.531122)) =INPUT=)
</pre>

</dd></dl>

</div>
</div>

</div>

<div id="outline-container-3">
<h2 id="sec-3"><span>3</span> Running Generated Code </h2>
<div id="text-3">





<pre>(<span>defun</span> <span>run-form</span> (form input)
  (funcall (eval `(<span>lambda</span> (=input=) ,form))  <span>; </span><span>note: backquote!
</span>           input))
</pre>



<p>
To run the generated forms we wrap them in a LAMBDA with an <code>=INPUT=</code>
argument and funcall the evaluated lambda with an input value.  The
following REPL interaction shows line by line what happens in
RANDOM-FORM:
</p>
<dl><dd>
<pre>CL-USER&gt; (defparameter random-form (random-form *operators*))
RANDOM-FORM

CL-USER&gt; random-form
(* 6.341989 =INPUT=)

CL-USER&gt; `(lambda (=input=) ,random-form)
(LAMBDA (=INPUT=) (* 6.341989 =INPUT=))

CL-USER&gt; (eval `(lambda (=input=) ,random-form))
#&lt;FUNCTION (LAMBDA (=INPUT=)) {AF2F08D}&gt;

CL-USER&gt; (funcall (eval `(lambda (=input=) ,random-form)) 2)
12.683978

CL-USER&gt; (* 6.341989 2)
12.683978
</pre>

</dd></dl>

<p>
However, the generated code can be illegal and cause errors.  Since
we&#39;ll be running a great many pieces of generated code multiple times
we don&#39;t want to see error messages and drop into the debugger.  To
keep things simple we let illegal forms return NIL so we can kill them
off later.  Adding an error handler to RUN-FORM will do this:
</p>



<pre>(<span>defun</span> <span>run-form</span> (form input)
  (<span>let</span> ((*error-output* (make-broadcast-stream)))
    (<span>handler-case</span> (funcall (eval `(<span>lambda</span> (=input=) ,form))
                           input)
      (<span>error</span> () nil))))
</pre>



<p>
<code>*ERROR-OUTPUT*</code> is redirected so we won&#39;t be bothered by all kinds of
compilation notices.  They only serve to distract in this situation.
</p>

</div>

<div id="outline-container-3_1">
<h3 id="sec-3_1"><span>3.1</span> SBCL note </h3>
<div id="text-3_1">


<p>
SBCL is a very good, open-source CL implementation but it doesn&#39;t
compile code very fast.  The way we currently handle RUN-FORM by
recompiling the form every time causes the advancing of generations
later in the article to be very slow .  Compared to SBCL, which
compiles to native code, CLISP, which compiles to byte-code, does the
advancing of generations much faster.
</p>
<p>
Since we&#39;re in exploration mode we will leave RUN-FORM as it is.
</p>
</div>
</div>

</div>

<div id="outline-container-4">
<h2 id="sec-4"><span>4</span> Population </h2>
<div id="text-4">





<pre>(<span>defun</span> <span>create-initial-population</span> (operators <span>&amp;optional</span> (size 100))
  (<span>loop</span> repeat size
        collect (random-form operators)))
</pre>



<p>
If you&#39;re not familiar with CL: the COLLECT statement in LOOP
accumulates a random form on each iteration and returns them as a list
once iteration has finished.  For example:
</p>
<dl><dd>
<pre>CL-USER&gt; (create-initial-population *operators* 10)
((* =INPUT= 6.8947406)
 (* (+ =INPUT= 2.1140647) 6.7930226)
 (+
  (/ (+ (* =INPUT= (/ 8.296512 =INPUT=)) 1.1989254)
   (- =INPUT= (/ =INPUT= (- 5.1625586 1.4763731))))
  =INPUT=)
 (- 1.5379852 2.1223724)
 (* =INPUT= (- 3.0632048 (* (+ (- 5.8116364 =INPUT=) 0.1915878) =INPUT=)))
 (/ 8.237898 =INPUT=)
 (* (/ (/ (- =INPUT= =INPUT=) 0.56726336) =INPUT=) =INPUT=)
 (+ (+ 7.147339 =INPUT=) =INPUT=)
 (- (- =INPUT= =INPUT=) =INPUT=)
 (+ (/ =INPUT= (- (* =INPUT= =INPUT=) (* (- =INPUT= =INPUT=) =INPUT=)))
  6.520609))
</pre>

</dd></dl>

<p>
The way we&#39;re creating the initial population is not ideal.  This is
because RANDOM-FORM only creates one type of syntax tree (using the
&#34;grow&#34; method mentioned earlier).  For a more diverse initial
population we&#39;d need more code generation functions that would output
different kinds of syntax trees.
</p>
<p>
The &#34;full&#34; method is easy to add and is left as an exercise to the
reader.  See the <a href="http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/22InitialisingthePopulation.html">Field Guide</a> for a description.
</p>
</div>

</div>

<div id="outline-container-5">
<h2 id="sec-5"><span>5</span> Fitness </h2>
<div id="text-5">





<pre>(<span>defun</span> <span>fitness</span> (form fitness-fn test-input)
  (<span>loop</span> for input in test-input
        for output = (run-form form input)
        for target = (funcall fitness-fn input)
        for difference = (<span>when</span> output (abs (- target output)))
        for fitness = (<span>when</span> output (/ 1.0 (+ 1 difference)))
        when (null output) do (<span>return-from</span> fitness nil)
        collect fitness into fitness-values
        finally (<span>return</span> (reduce #&#39;* fitness-values))))
</pre>



<p>
We need a way to test the output of a generated function against our
desired outcome and represent this as a number: the fitness.  This is
commonly a number between 0.0 and 1.0.  The closer to 1.0 the better
the fitness.
</p>
<p>
We also need to check whether the return value of RUN-FORM is NIL in
which case it executed illegal code.  FITNESS will return NIL in that
case as well.  (Poor man&#39;s exception handling but suffices for now.)
</p>
<p>
So the function needs: 1) the form to check, 2) the fitness function
to check against and 3) test input.  We also want to check against
multiple input values.
</p>
<p>
The TEST-INPUT argument is a list of input values so the most direct
approach will be to iterate over these values and running both the
form and the fitness functions against them.
</p>
<p>
To get a fitness value between 0.0 and 1.0 we take the absolute
difference between the output of the generated form (OUTPUT) and the
output of the fitness function (TARGET).  We then add 1 to this
difference and use that to divide 1.0.  To illustrate:
</p>
<dl><dd>
<pre>CL-USER&gt; (defun fit (x) (/ 1.0 (+ 1 x)))
FIT
CL-USER&gt; (fit 0)  ; no difference so the desired output
1.0
CL-USER&gt; (fit 0.1)
0.9090909
CL-USER&gt; (fit 5)
0.16666667
CL-USER&gt; (fit 500)
0.001996008
</pre>

</dd></dl>

<p>
We&#39;re not testing negative values since DIFFERENCE in FITNESS will never be
negative.
</p>
<p>
REPL test of FITNESS:
</p>
<dl><dd>
<pre>CL-USER&gt; (defparameter random-form (random-form *operators*))
RANDOM-FORM

CL-USER&gt; random-form
(/ 8.552494 =INPUT=)
CL-USER&gt; (fitness random-form (lambda (r) (* pi r r)) &#39;(0 1 -2))
NIL  ; this is correct since we divided by zero

CL-USER&gt; (setf random-form (random-form *operators*))
(- =INPUT= 5.246996)
CL-USER&gt; (fitness random-form (lambda (r) (* pi r r)) &#39;(0 1 -2))
9.168484389517398d-4

CL-USER&gt; (setf random-form (random-form *operators*))
(* =INPUT= (+ (* =INPUT= 1.8322039) (- =INPUT= 6.812643)))
CL-USER&gt; (fitness random-form (lambda (r) (* pi r r)) &#39;(0 1 -2))
0.009196622001630076d0

CL-USER&gt; (fitness &#39;(* pi =input= =input=) (lambda (r) (* pi r r)) &#39;(0 1 -2))
1.0d0
CL-USER&gt; (fitness &#39;(* (- pi 0.1) =input= =input=) (lambda (r) (* pi r r)) &#39;(0 1 -2))
0.649350645706412d0
</pre>

</dd></dl>

</div>

</div>

<div id="outline-container-6">
<h2 id="sec-6"><span>6</span> Generation Functions </h2>
<p>
Now everything is in place to start thinking about creating new
generations from the initial population.  Currently we will only
support <a href="http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/53GPCrossover.html#11_3">cross-overs</a> and <a href="http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/52GPMutation.html#11_2">mutations</a>.
</p>

<div id="outline-container-6_1">
<h3 id="sec-6_1"><span>6.1</span> Traversing Nodes </h3>
<div id="text-6_1">


<p>
Before we get to cross-overs and mutations we need to look at three
important functions: N-NODES, RANDOM-NODE and REPLACE-NODE.  They all
share a common, but for each slightly different, function:
TRAVERSE-NODES.
</p>
<p>
It is a basic recursive function.  It iterates through each element of
the FORM list and if that element is a list as well it calls
TRAVERSE-NODES again with that list element as argument.
</p>



<pre>(<span>defun</span> <span>traverse-nodes-example</span> (form)
  (<span>labels</span> ((traverse-nodes (subform <span>&amp;optional</span> (indent <span>&#34;&#34;</span>))
             (<span>loop</span> for node in subform
                   do (format t <span>&#34;~D:~A ~S~%&#34;</span> (/ (length indent) 2) indent node)
                      (<span>when</span> (listp node)
                        (traverse-nodes node
                                        (concatenate &#39;string indent <span>&#34;  &#34;</span>))))))
    (traverse-nodes form)))
</pre>



<p>
TRAVERSE-NODES-EXAMPLE goes through FORM exactly how TRAVERSE-NODES
does and for each node it prints its nesting level and the node
itself:
</p>
<dl><dd>
<pre>CL-USER&gt; (traverse-nodes-example &#39;(a (b c) (d (e f) g) h))
0: A
0: (B C)
1:   B
1:   C
0: (D (E F) G)
1:   D
1:   (E F)
2:     E
2:     F
1:   G
0: H
</pre>

</dd></dl>


</div>

<div id="outline-container-6_1_1">
<h4 id="sec-6_1_1"><span>6.1.1</span> N-NODES </h4>
<div id="text-6_1_1">





<pre>(<span>defun</span> <span>n-nodes</span> (form)
  (<span>let</span> ((nodes 1))
    (<span>labels</span> ((traverse-nodes (subform)
               (<span>loop</span> for node in subform
                     do (incf nodes)
                        (<span>when</span> (listp node)
                          (traverse-nodes node)))))
      (traverse-nodes form))
    nodes))
</pre>



<p>
Helper function for <a href="#RANDOM-NODE">RANDOM-NODE</a>.  Returns the number of nodes in FORM
including the root node.  Note that &#34;<code>(B C)</code>&#34; as well as B and C are
counted as nodes:
</p>
<dl><dd>
<pre>CL-USER&gt; (n-nodes &#39;(b c))
3
CL-USER&gt; (n-nodes &#39;(a (b c) (d (e f) g) h))
12
CL-USER&gt; (n-nodes &#39;())
1
</pre>

</dd></dl>

</div>

</div>

<div id="outline-container-6_1_2">
<h4 id="sec-6_1_2"><span>6.1.2</span> Picking Random Nodes </h4>
<div id="text-6_1_2">


<p>
We want to be able to pick a random node from a form to perform
operations on.  <a name="RANDOM-NODE">RANDOM-NODE</a> does this:
</p>



<pre>(<span>defun</span> <span>random-node</span> (form)
  (<span>let*</span> ((index 1)
         (nodes-1 (- (n-nodes form) 1))
         (random-node-index (+ (random nodes-1) 1)))
    (<span>labels</span> ((traverse-nodes (subform)
               (<span>loop</span> for node in subform
                     do (<span>when</span> (= index random-node-index)
                          (<span>return-from</span> random-node
                                       (list <span>:index</span> index <span>:node</span> node)))
                        (incf index)
                        (<span>when</span> (listp node)
                          (traverse-nodes node)))))
      (traverse-nodes form))))
</pre>



<p>
It picks a RANDOM-NODE-INDEX and starts traversing the nodes of FORM.
When it arrives at the index it returns both the node and the index as
a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#property_list">property list</a>:
</p>
<dl><dd>
<pre>(:index random-node-index :node random-node)
</pre>

</dd></dl>

<p>
Will not return the root node at index 0.
</p>
</div>

</div>

<div id="outline-container-6_1_3">
<h4 id="sec-6_1_3"><span>6.1.3</span> Replacing Nodes </h4>
<div id="text-6_1_3">


<p>
We need to be able to replace a node in a form with another node.  The
avoid bugs and confusion we&#39;ll let REPLACE-NODE return this result as
a <b>new form</b>.
</p>



<pre>(<span>defun</span> <span>replace-node</span> (form node-index new-node)
  (<span>let</span> ((index 0))
    (<span>labels</span> ((traverse-nodes (subform)
               (<span>loop</span> for node in subform
                     do (incf index)
                     when (= index node-index)
                       collect new-node
                     when (and (/= index node-index)
                               (not (listp node)))
                       collect node
                     when (and (/= index node-index)
                               (listp node))
                       collect (traverse-nodes node))))
      (traverse-nodes form))))
</pre>



<p>
Traverses the nodes of FORM and collects them to return as a new form.
When its INDEX counter is equal to NODE-INDEX it collects NEW-NODE
instead.
</p>
<p>
The function does not replace the root node (index 0).
</p>
</div>
</div>

</div>

<div id="outline-container-6_2">
<h3 id="sec-6_2"><span>6.2</span> Cross-overs </h3>
<div id="text-6_2">


<p>
There are <a href="http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/53GPCrossover.html#11_3">different kinds of cross-overs</a> but we will be doing the most
straight-forward one: replace a random node in form A with a random
node from form B.
</p>
<p>
Cross-overs are the most used genetic operation in GP and some people
have even suggested to never use mutations.  They can be compared to
the procreation of humans in which attributes of the male and female
are represented in their offspring.
</p>



<pre>(<span>defun</span> <span>cross-over</span> (form1 form2 <span>&amp;key</span> (debug nil))
  (<span>let</span> ((rnode1 (random-node form1))
        (rnode2 (random-node form2)))
    (<span>when</span> debug
      (format t <span>&#34;form1: ~S~%form2: ~S~%rnode1: ~S~%rnode2: ~S~%&#34;</span>
              form1 form2 rnode1 rnode2))
    (replace-node form1 (getf rnode1 <span>:index</span>) (getf rnode2 <span>:node</span>))))
</pre>



<p>
CROSS-OVER takes two forms as arguments and returns a new form.  The
new form is largely similar to FORM1 but one random node is replaced
by a random node from FORM2.  The function RANDOM-NODE is used to pick
these random nodes.
</p>
<dl><dd>
<pre>CL-USER&gt; (cross-over &#39;(1 (2 3) (4 (5 6) 7) 8) &#39;(a (b c) (d (e f) g) h) :debug t)
form1: (1 (2 3) (4 (5 6) 7) 8)
form2: (A (B C) (D (E F) G) H)
rnode1: (:INDEX 1 :NODE 1)
rnode2: (:INDEX 3 :NODE B)
(B (2 3) (4 (5 6) 7) 8)

CL-USER&gt; (cross-over &#39;(1 (2 3) (4 (5 6) 7) 8) &#39;(a (b c) (d (e f) g) h) :debug t)
form1: (1 (2 3) (4 (5 6) 7) 8)
form2: (A (B C) (D (E F) G) H)
rnode1: (:INDEX 3 :NODE 2)
rnode2: (:INDEX 7 :NODE (E F))
(1 ((E F) 3) (4 (5 6) 7) 8)

CL-USER&gt; (cross-over &#39;(1 (2 3) (4 (5 6) 7) 8) &#39;(a (b c) (d (e f) g) h) :debug t)
form1: (1 (2 3) (4 (5 6) 7) 8)
form2: (A (B C) (D (E F) G) H)
rnode1: (:INDEX 2 :NODE (2 3))
rnode2: (:INDEX 6 :NODE D)
(1 D (4 (5 6) 7) 8)

CL-USER&gt; (cross-over &#39;(1 (2 3) (4 (5 6) 7) 8) &#39;(a (b c) (d (e f) g) h) :debug t)
form1: (1 (2 3) (4 (5 6) 7) 8)
form2: (A (B C) (D (E F) G) H)
rnode1: (:INDEX 5 :NODE (4 (5 6) 7))
rnode2: (:INDEX 5 :NODE (D (E F) G))
(1 (2 3) (D (E F) G) 8)
</pre>

</dd></dl>

</div>

</div>

<div id="outline-container-6_3">
<h3 id="sec-6_3"><span>6.3</span> Mutation </h3>
<div id="text-6_3">


<p>
Mutations change a part of a form without needing another form for the
operation.  It is perhaps analogue to a cosmic ray changing a bit of
genetic information in a biological entity.
</p>
<p>
We will be using <a href="http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/52GPMutation.html">subtree mutation</a> since it is straight-forward to
write and has a potentially large effect.
</p>



<pre>(<span>defun</span> <span>mutate</span> (form operators <span>&amp;key</span> (debug nil))
  (<span>let</span> ((rform (random-form operators))
        (rnode (random-node form)))
    (<span>when</span> debug
      (format t <span>&#34;form: ~S~%rform: ~S~%rnode: ~S~%&#34;</span> form rform rnode))
    (replace-node form (getf rnode <span>:index</span>) rform)))
</pre>



<p>
Mutation replaces a random node of FORM with a form created by
RANDOM-FORM.
</p>
<dl><dd>
<pre>CL-USER&gt; (mutate &#39;(a (b c) (d (e f) g) h) *operators* :debug t)
form: (A (B C) (D (E F) G) H)
rform: (+ =INPUT= (- 4.4699216 (+ 9.623513 =INPUT=)))
rnode: (:INDEX 3 :NODE B)
(A ((+ =INPUT= (- 4.4699216 (+ 9.623513 =INPUT=))) C) (D (E F) G) H)

CL-USER&gt; (mutate &#39;(a (b c) (d (e f) g) h) *operators* :debug t)
form: (A (B C) (D (E F) G) H)
rform: (+ 4.5209084 (- 8.943897 (+ 6.657296 =INPUT=)))
rnode: (:INDEX 2 :NODE (B C))
(A (+ 4.5209084 (- 8.943897 (+ 6.657296 =INPUT=))) (D (E F) G) H)
</pre>

</dd></dl>

</div>
</div>

</div>

<div id="outline-container-7">
<h2 id="sec-7"><span>7</span> Advancing a Generation </h2>


<div id="outline-container-7_1">
<h3 id="sec-7_1"><span>7.1</span> Evaluating a Population </h3>
<div id="text-7_1">





<pre>(<span>defun</span> <span>evaluate-population</span> (population fitness-fn test-input)
  (<span>loop</span> for form in population
        for fitness = (fitness form fitness-fn test-input)
        when fitness collect (list <span>:fitness</span> fitness <span>:form</span> form) into result
        finally (<span>return</span> (sort result
                              (<span>lambda</span> (a b)
                                (&gt; (getf a <span>:fitness</span>) (getf b <span>:fitness</span>)))))))
</pre>



<p>
To advance a generation we need to do cross-overs and mutations to the
forms in the population.  The literature suggests we give forms with a
higher fitness more chance to be a candidate for a cross-over or
mutation.
</p>
<p>
EVALUATE-POPULATION evaluates a population and returns a list of the
forms in that population and their fitness (minus any forms that gave
errors).  For ease of testing on the REPL and for use in our next
function the output is <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sort_.htm#sort">sorted</a> from best fitness to worst:
</p>
<dl><dd>
<pre>CL-USER&gt; (defparameter population (create-initial-population *operators* 10))
POPULATION

CL-USER&gt; (evaluate-population population (lambda (r) (* pi r r)) &#39;(0 1 -2))
((:FITNESS 0.016815323605722716111d0 :FORM (- (- =INPUT= =INPUT=) =INPUT=))
 (:FITNESS 0.009437720627636827027d0 :FORM (- 1.5379852 2.1223724))
 (:FITNESS 0.007690745276452599039d0 :FORM (* =INPUT= 6.8947406))
 (:FITNESS 0.0031801166742824690382d0 :FORM
  (* =INPUT= (- 3.0632048 (* (+ (- 5.8116364 =INPUT=) 0.1915878) =INPUT=))))
 (:FITNESS 0.0016815216288940106286d0 :FORM (+ (+ 7.147339 =INPUT=) =INPUT=))
 (:FITNESS 2.6768631466526024146d-4 :FORM (* (+ =INPUT= 2.1140647) 6.7930226)))
</pre>

</dd></dl>

<p>
This is the same population as created in the <a href="#sec-4">Population</a> chapter.
Note that four of the ten forms have been eliminated since they
executed illegal code.
</p>
</div>

</div>

<div id="outline-container-7_2">
<h3 id="sec-7_2"><span>7.2</span> HEAD </h3>
<div id="text-7_2">





<pre>(<span>defun</span> <span>head</span> (sequence <span>&amp;optional</span> (amount 1))
  (<span>if</span> (&lt;= amount 0)
      nil
      (<span>if</span> (&lt; (length sequence) amount)
          sequence
          (subseq sequence 0 amount))))
</pre>



<p>
Utility function used by ADVANCE-GENERATION.  Returns AMOUNT
elements from the start of SEQUENCE.  If SEQUENCE is shorter than
AMOUNT it will return the whole SEQUENCE.
</p>
</div>

</div>

<div id="outline-container-7_3">
<h3 id="sec-7_3"><span>7.3</span> Running the Advancement </h3>
<div id="text-7_3">





<pre>(<span>defun</span> <span>advance-generation</span> (population fitness-fn operators test-input
                           <span>&amp;optional</span> (max-population 100))
  (<span>let</span> ((epop (evaluate-population population fitness-fn test-input)))
    (format t <span>&#34;Best fitness of current population: ~S~%&#34;</span>
            (getf (first epop) <span>:fitness</span>))
    (<span>loop</span> for plist in (head epop max-population)
          for i from 0
          for fitness = (getf plist <span>:fitness</span>)
          for form = (getf plist <span>:form</span>)
          collect form
          when (&lt;= (random 1.0d0) fitness)
            collect (<span>if</span> (&lt;= (random 100) 90)
                        (cross-over form (getf (random-elt epop) <span>:form</span>))
                        (mutate form operators))
          <span>;; </span><span>Add a new random form to the population now and then.
</span>          when (&lt;= (random 100) 2) collect (random-form operators))))
</pre>



<p>
Using the list of forms and their fitness from EVALUATE-POPULATION as
input we only loop over the first MAX-POPULATION items to keep the
population size in check.  We then check the form&#39;s fitness against a
random number between 0.0 and 1.0 and if the number is lower than the
fitness the form will be selected for either a cross-over (90% chance)
or a mutation (10% chance).
</p>
<p>
So the form&#39;s fitness is its chance to be selected.  Since the fitness
of the forms in the initial population is usually very low it will
take quite a few generations before something starts happening.
</p>
<p>
We collect the form and if it&#39;s been selected we also collect the
result from either CROSS-OVER or MUTATE.  These will all be
accumulated and eventually returned as the new generation.
</p>
<p>
There&#39;s also a small chance a new random form will be added to the
population since the way we&#39;re currently handling things it is very
possible for a successful form to take over the entire population and
make it too homogeneous for good results.  This is a quick and easy
hack to introduce some chaos into populations.
</p>
</div>

</div>

<div id="outline-container-7_4">
<h3 id="sec-7_4"><span>7.4</span> Finding a Solution </h3>
<div id="text-7_4">


<p>
Lets run ADVANCE-GENERATION a hundred times over a new population (we
also update the population on each iteration with SETF):
</p>
<dl><dd>
<pre>CL-USER&gt; (defparameter population (create-initial-population *operators* 100))
POPULATION
CL-USER&gt; (loop repeat 100
               for i from 0
               do (format t &#34;[~S] &#34; i)
                  (setf population
                        (advance-generation population
                                            (lambda (r) (* pi r r))
                                            *operators*
                                            &#39;(0 1 -2))))
[0] Best fitness of current population: 0.08546627574466652d0
[...]
[43] Best fitness of current population: 0.08626213422506805d0
[...]
[66] Best fitness of current population: 0.10050107335294403d0
[...]
</pre>

</dd></dl>

<p>
And again:
</p>
<dl><dd>
<pre>CL-USER&gt; (loop repeat 100 for i from 0 do (format t &#34;[~S] &#34; i) (setf population (advance-generation population (lambda (r) (* pi r r)) *operators* &#39;(0 1 -2))))
[...]
[26] Best fitness of current population: 0.3865141184760903d0
[...]
[93] Best fitness of current population: 0.49884414719455095d0
[...]
</pre>

</dd></dl>

<p>
Lets do another 300 runs so we&#39;ve done 500 in total and see what the
best form looks like in the end:
</p>
<dl><dd>
<pre>CL-USER&gt; (loop repeat 300 for i from 0 do (format t &#34;[~S] &#34; i) (setf population (advance-generation population (lambda (r) (* pi r r)) *operators* &#39;(0 1 -2))))
[...]
[35] Best fitness of current population: 0.5397727425319018d0
[...]
[62] Best fitness of current population: 0.559234953025742d0
[...]
[117] Best fitness of current population: 0.6436990901489741d0
[...]
[179] Best fitness of current population: 0.9657338407311192d0
[...]
[201] Best fitness of current population: 0.9705968409735506d0
[202] Best fitness of current population: 0.9755729636966523d0
[203] Best fitness of current population: 0.9994359703065686d0
[...]

CL-USER&gt; (defparameter best-form (first (evaluate-population population (lambda (r) (* pi r r)) &#39;(0 1 -2))))
BEST-FORM
CL-USER&gt; best-form
(:FITNESS 0.9994359703065686d0 :FORM
 (* (+ (+ =INPUT= =INPUT=) (+ =INPUT= (/ =INPUT= (+ 3.5050452 3.5518444))))
    =INPUT=))

CL-USER&gt; (run-form (getf best-form :form) 0)
0.0
CL-USER&gt; (run-form (getf best-form :form) 1)
3.1417055
CL-USER&gt; (run-form (getf best-form :form) 2)
12.566822
CL-USER&gt; (run-form (getf best-form :form) 3)
28.275349
</pre>

</dd></dl>

<p>
Here&#39;s the output from the real function to calculate the area of a
circle for comparison:
</p>
<dl><dd>
<pre>CL-USER&gt; (run-form &#39;(* pi =input= =input=) 0)
0.0d0
CL-USER&gt; (run-form &#39;(* pi =input= =input=) 1)
3.141592653589793d0
CL-USER&gt; (run-form &#39;(* pi =input= =input=) 2)
12.566370614359172d0
CL-USER&gt; (run-form &#39;(* pi =input= =input=) 3)
28.274333882308138d0
</pre>

</dd></dl>

<p>
Not quite the impressive result of Bill Clementson&#39;s attempt but not
half bad either!
</p>
</div>
</div>

</div>

<div id="outline-container-8">
<h2 id="sec-8"><span>8</span> Conclusion </h2>
<div id="text-8">


<p>
I hope to have shown how one can start with a few simple functions
(RANDOM-FORM and its RANDOM-ELT helper) and explore a topic which
might interest you.
</p>
<p>
If you read the literature you&#39;ll notice that there are a lot of
things still wrong with the current setup.  As you will find out if
you start experimenting with the code in this article <a href="http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/113Bloat.html#17_3">bloat</a> is a big
problem, as well as a successful form taking over the entire
population.
</p>
<p>
If the topic of GP interests you I would suggest you read up and look
into:
</p>
<ul>
<li>
eliminating bloat
</li>
<li>
improving the creation of the initial population
</li>
<li>
improvements to the cross-over and mutation functions

</li>
</ul>

<p>for the code in this article.
</p>
</div>

</div>

<div id="outline-container-9">
<h2 id="sec-9"><span>9</span> Thanks </h2>
<div id="text-9">


<p>
Thanks to the denizens of #lisp at freenode for Common Lisp help in
general.
</p>
<p>
Thanks to the following people for proofreading and comments: Marijn
Haverbeke, Gábor Melis, David O&#39;Toole and Matthias of the space.invaders team.
</p>
<p>
Keep in mind that any mistakes are mine.
</p></div>
</div><p>Labels: <a rel="tag" href="http://aerique.blogspot.com/search/label/ai">ai</a>, <a rel="tag" href="http://aerique.blogspot.com/search/label/artificial-intelligence">artificial-intelligence</a>, <a rel="tag" href="http://aerique.blogspot.com/search/label/common-lisp">common-lisp</a>, <a rel="tag" href="http://aerique.blogspot.com/search/label/genetic-programming">genetic-programming</a>, <a rel="tag" href="http://aerique.blogspot.com/search/label/lisp">lisp</a>, <a rel="tag" href="http://aerique.blogspot.com/search/label/machine-learning">machine-learning</a></p>
    </div>
    </div></div>
  </body>
</html>
