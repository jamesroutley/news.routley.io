<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.meadsteve.dev/programming/2022/09/27/making-python-fast-for-free/">Original</a>
    <h1>Making Python fast – Adventures with mypyc</h1>
    
    <div id="readability-page-1" class="page"><article>
  <header>
    
    <time datetime="2022-09-27 10:00:00">2022-09-27</time>
    
    
  </header>
  <p>I recently learnt that mypy has a compiler called <a href="https://github.com/mypyc/mypyc">mypyc</a>. The compiler uses standard
python type hints to generate c extensions automatically from python code. I found the idea very interesting as
I have a library (<a href="https://lagom-di.readthedocs.io/en/stable/">Lagom</a> - a dependency injection container) which is fairly extensively annotated with types. I liked the idea of getting a performance boost without having to 
rewrite any code or having to deal with multiple languages. This blogpost is intended to be a short overview of what
I did, the problems I ran into and the workflow I ended up with.</p>

<p>(Note: <a href="https://cython.readthedocs.io/">Cython</a> has a similar target usage but often requires a few more code changes)</p>

<h2 id="attempting-to-compile-the-whole-thing">Attempting to compile the whole thing</h2>

<p>For my first attempt at using mypyc I attempted to compile my entire library. This failed. The main issue was 
<a href="https://github.com/mypyc/mypyc/issues/864">mypyc issue 864 - no nested class definitions</a>. This was almost where
I stopped. The idea was I shouldn’t need to make changes and fixing this would have been a big change.</p>

<h2 id="picking-core-modules">Picking core modules</h2>
<p>I took a step back and realised that I would get most of the benefit from compilation if the most executed code in my 
library was compiled even if this was not 100% of the code. I thought about my code and realised I had 3 or 4 modules
that do most of the heavy lifting of the library. Luckily mypyc has catered for this and has a function you can
call from <code>setup.py</code> to specify which files need compilation. So I ended up with something like this:</p>

<div><div><pre><code>    <span>from</span> <span>mypyc.build</span> <span>import</span> <span>mypycify</span>
    <span>setup</span><span>(</span>
        <span>version</span><span>=</span><span>load_version</span><span>(</span><span>&#34;lagom/version.py&#34;</span><span>),</span>
        <span>ext_modules</span><span>=</span><span>mypycify</span><span>([</span>
            <span>&#39;lagom/container.py&#39;</span><span>,</span>
            <span>&#39;lagom/context_based.py&#39;</span><span>,</span>
            <span>&#39;lagom/definitions.py&#39;</span><span>,</span>
            <span>&#39;lagom/updaters.py&#39;</span><span>,</span>
        <span>])</span>
    <span>)</span>
</code></pre></div></div>

<h2 id="losing-flit-and-adding-a-build-step">Losing flit and adding a build step</h2>

<p>The next big shock was that I now had a build step. Up until now I’d been using <a href="https://flit.pypa.io/">flit</a> to push 
my package to pypi. Flit has been great for just getting out of the way. It was easy to set up and required very
little code or configuration. It does come with one downside though (taken from the docs):</p>

<blockquote>
  <p>If your package needs a build step, you won’t be able to use Flit.</p>
</blockquote>

<p>So I had to spend a few hours reworking my package for publication using setuptools. Although this is the de-facto 
standard it’s something I’ve always struggled with. But I got it working, and now I had a build step.</p>

<h2 id="building-the-wheels-on-ci">Building the wheels on CI</h2>
<p>Rather than requiring everyone to compile the code as part of installing the library I wanted to push some pre-built
wheels to pypi. The <a href="https://github.com/pypa/cibuildwheel">cibuildwheel</a> is perfect for this. I was already using
github actions so with a little work I had this job building wheels across versions for windows, mac and linux:</p>

<div><div><pre><code>
<span>jobs</span><span>:</span>
  <span>mac-and-windows-and-linux-publish</span><span>:</span>
    <span>runs-on</span><span>:</span> <span>${{ matrix.builds.os }}</span>
    <span>strategy</span><span>:</span>
      <span>fail-fast</span><span>:</span> <span>false</span>
      <span>matrix</span><span>:</span>
        <span>builds</span><span>:</span> <span>[</span>
          <span>{</span><span>os</span><span>:</span> <span>&#34;</span><span>macOS-latest&#34;</span><span>,</span> <span>python_requires</span><span>:</span> <span>&#34;</span><span>&gt;=3.7.0&#34;</span><span>},</span>
          <span>{</span><span>os</span><span>:</span> <span>&#34;</span><span>windows-latest&#34;</span><span>,</span> <span>python_requires</span><span>:</span> <span>&#34;</span><span>&gt;=3.7.0&#34;</span><span>},</span>
          <span>{</span><span>os</span><span>:</span> <span>&#34;</span><span>ubuntu-latest&#34;</span><span>,</span> <span>python_requires</span><span>:</span> <span>&#34;</span><span>&gt;=3.7.0,&lt;3.11.0&#34;</span><span>}</span>
        <span>]</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> <span>actions/checkout@v2</span>
      <span>-</span> <span>name</span><span>:</span> <span>Set up Python ${{ matrix.python-version }}</span>
        <span>uses</span><span>:</span> <span>actions/setup-python@v2</span>
        <span>with</span><span>:</span>
          <span>python-version</span><span>:</span> <span>3.8</span>
      <span>-</span> <span>name</span><span>:</span> <span>Install deps</span>
        <span>run</span><span>:</span> <span>python -m pip install cibuildwheel==2.9.0 twine==4.0.1</span>
      <span>-</span> <span>name</span><span>:</span> <span>Build wheels</span>
        <span>env</span><span>:</span>
          <span>CIBW_PROJECT_REQUIRES_PYTHON</span><span>:</span> <span>${{ matrix.builds.python_requires }}</span>
          <span>CIBW_BUILD</span><span>:</span> <span>&#34;</span><span>cp3*&#34;</span>
        <span>run</span><span>:</span> <span>python -m cibuildwheel --output-dir wheelhouse</span>
      <span>-</span> <span>name</span><span>:</span> <span>Publish</span>
        <span>env</span><span>:</span>
          <span>TWINE_USERNAME</span><span>:</span> <span>__token__</span>
          <span>TWINE_PASSWORD</span><span>:</span> <span>${{ secrets.PYPI_TOKEN }}</span>
        <span>run</span><span>:</span> <span>|</span>
          <span>twine upload --skip-existing wheelhouse/*</span>

</code></pre></div></div>

<p>I limited cibuildwheel to cpython only with a <code>CIBW_BUILD</code> set to <code>cp3*</code> and each OS has the python 
version range specified (at the time of writing I had some problems building for linux with 3.11). I also added
a final step to use twine to publish these versions. Since this job is scheduled to run when a commit is tagged
I now had an automated publishing workflow triggered entirely by git.</p>

<h2 id="building-a-generic-wheel-for-unsupported-platforms">Building a generic wheel for unsupported platforms</h2>
<p>I wanted to keep support in my library for platforms where the code could not be compiled, so I decided to have a 
final build step that publishes a pure python wheel without any compiled code. I modified my <code>setup.py</code> file to toggle
the compilation step based on an environment variable.</p>

<div><div><pre><code><span>if</span> <span>not</span> <span>bool</span><span>(</span><span>int</span><span>(</span><span>os</span><span>.</span><span>getenv</span><span>(</span><span>&#39;LAGOM_SKIP_COMPILE&#39;</span><span>,</span> <span>&#39;0&#39;</span><span>))):</span>
    <span>from</span> <span>mypyc.build</span> <span>import</span> <span>mypycify</span>
    <span># ... compiled build
</span><span>else</span><span>:</span>
    <span># This branch doesn&#39;t use mypyc compilation
</span>    <span>setup</span><span>(</span>
        <span>version</span><span>=</span><span>load_version</span><span>(</span><span>&#34;lagom/version.py&#34;</span><span>)</span>
    <span>)</span>
</code></pre></div></div>

<p>and then an extra job in the github action:</p>

<div><div><pre><code>
 <span>pure-python-wheel-publish</span><span>:</span>
   <span>runs-on</span><span>:</span> <span>ubuntu-latest</span>
   <span>steps</span><span>:</span>
     <span>-</span> <span>uses</span><span>:</span> <span>actions/checkout@v2</span>
     <span>-</span> <span>name</span><span>:</span> <span>Set up Python ${{ matrix.python-version }}</span>
       <span>uses</span><span>:</span> <span>actions/setup-python@v2</span>
       <span>with</span><span>:</span>
         <span>python-version</span><span>:</span> <span>3.8</span>
     <span>-</span> <span>name</span><span>:</span> <span>Install deps</span>
       <span>run</span><span>:</span> <span>python -m pip install wheel==0.37.1  twine==4.0.1</span>
     <span>-</span> <span>name</span><span>:</span> <span>Build pure python wheel</span>
       <span>env</span><span>:</span>
         <span>LAGOM_SKIP_COMPILE</span><span>:</span> <span>&#34;</span><span>1&#34;</span>
       <span>run</span><span>:</span> <span>pip wheel -w wheelhouse .</span>
     <span>-</span> <span>name</span><span>:</span> <span>Publish</span>
       <span>env</span><span>:</span>
         <span>TWINE_USERNAME</span><span>:</span> <span>__token__</span>
         <span>TWINE_PASSWORD</span><span>:</span> <span>${{ secrets.PYPI_TOKEN }}</span>
       <span>run</span><span>:</span> <span>|</span>
         <span>twine upload --skip-existing wheelhouse/*</span>

</code></pre></div></div>

<p>This should mean all previous consumers of my library can still use it. Platforms that don’t support the
compilation should see no change and supported platforms will see a speed boost.</p>

<h2 id="testing-the-compiled-code">Testing the compiled code</h2>

<p>As part of my workflow I continuously run the unit tests and mypy. These give me relatively 
good confidence that the code will compile and work as I expect. Meaning I don’t need to execute the compile step
whist I develop which helps keep the feedback cycle short.</p>

<p>However, despite these checks, I still want to make sure that the compiled library does behave in the same
way before merging any code. I use another github action to check this which runs on PRs. 
It builds the compiled wheel, installs it, then runs the test suite against it.</p>

<div><div><pre><code>
    <span>-</span> <span>name</span><span>:</span> <span>Install dependencies</span>
      <span>run</span><span>:</span> <span>|</span>
        <span>make setup</span>
        <span>pip install build</span>
    <span>-</span> <span>name</span><span>:</span> <span>build wheel and then remove code</span>
      <span>run</span><span>:</span> <span>|</span>
        <span>python -m build</span>
        <span>rm -rf ./lagom</span>
    <span>-</span> <span>name</span><span>:</span> <span>install built wheel</span>
      <span>run</span><span>:</span> <span>|</span>
        <span>find ./dist -name &#39;*.whl&#39;| head -n 1 | xargs pipenv install --skip-lock</span>
    <span>-</span> <span>name</span><span>:</span> <span>Run Tests</span>
      <span>run</span><span>:</span> <span>|</span>
        <span>pipenv run pytest tests -m &#34;not benchmarking&#34; -vv</span>

</code></pre></div></div>

<p>I was glad I added these tests because they found a fairly major backwards compatability break.</p>

<h2 id="native-classes-cant-be-used-as-a-base-class-for-inheritance">Native classes can’t be used as a base class for inheritance</h2>
<p>The documentation mentions that once a class is compiled it can’t be extended by a python class. This was a problem
as a number of my tests rely on this. It would also be a fairly major BC break, so I’m glad the tests caught this.</p>

<p>Luckily mypyc has a solution and provides the <code>@mypyc_attr</code> decorator which can be used to allow extension:</p>

<div><div><pre><code><span>@</span><span>mypyc_attr</span><span>(</span><span>allow_interpreted_subclasses</span><span>=</span><span>True</span><span>)</span>
<span>class</span> <span>Container</span><span>(</span>
    <span>WriteableContainer</span><span>,</span> <span>ExtendableContainer</span><span>,</span> <span>DefinitionsSource</span><span>,</span> <span>ContainerDebugInfo</span>
<span>):</span>
    <span>...</span>
</code></pre></div></div>

<p>This comes at a slight performance cost but for maintaining the interface I felt it was worth it</p>

<h2 id="was-it-worth-it-the-results">Was it worth it? The results</h2>

<p>Now the important question is how much of a difference does this make? Was it worth the build complexity?</p>

<p>Luckily I have a benchmark set of tests I run using <a href="https://pypi.org/project/pytest-benchmark/">pytest-benchmark</a>.
Running these against the new compiled version I get the following:</p>

<div><div><pre><code>---------------------------------------------------------------------------------------------- benchmark: 6 tests ----------------------------------------------------------------------------------------------
Name (time in us)                      Min                    Max                Mean              StdDev              Median                IQR            Outliers  OPS (Kops/s)            Rounds  Iterations
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_optimised (compiled)         71.7450 (1.0)         971.7620 (1.65)      87.0807 (1.0)       20.9528 (1.0)       81.8410 (1.0)        5.2518 (1.0)     6107;9432       11.4836 (1.0)       87699           1
test_plain (compiled)             128.2760 (1.79)        588.2040 (1.0)      154.0175 (1.77)      32.0413 (1.53)     144.8510 (1.77)      9.5982 (1.83)    1084;1869        6.4928 (0.57)      14475           1
test_magic (compiled)             147.2380 (2.05)        598.4200 (1.02)     169.9302 (1.95)      36.6631 (1.75)     159.4025 (1.95)      8.2840 (1.58)      227;405        5.8848 (0.51)       2962           1
test_optimised (old)              159.1330 (2.22)     19,492.6290 (33.14)    218.7509 (2.51)     238.4710 (11.38)    185.7110 (2.27)     40.6575 (7.74)     542;4813        4.5714 (0.40)      43520           1
test_plain (old)                  250.3910 (3.49)        780.7970 (1.33)     289.7597 (3.33)      52.2043 (2.49)     272.0675 (3.32)     18.1820 (3.46)     839;1469        3.4511 (0.30)       9416           1
test_magic (old)                  271.6470 (3.79)      1,122.6480 (1.91)     314.4931 (3.61)      65.8549 (3.14)     291.0765 (3.56)     24.0800 (4.59)      230;353        3.1797 (0.28)       2718           1
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre></div></div>

<p>So the TLDR from the above is that the compiled code performs more than twice as many operations per second as the
previous version of the code. I’m pretty happy with this from a mostly one time investment in my build tooling.</p>

<p>I also believe there’s some additional improvement that could be made with a little bit of profiling and work to 
make more modules compilable.</p>

<p>So if you maintain a fairly well typed library or codebase that could do with a speed boost I suggest you take a look 
at mypyc.</p>

<p>For now I’ve completely ignored the fact that mypyc is described as alpha quality. I have my escape hatch of maintaining
a pure python build alongside the compiled one.</p>

</article></div>
  </body>
</html>
