<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://beza1e1.tuxen.de/config_levels.html">Original</a>
    <h1>Levels of configuration languages</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>Code is data and data is code.
Years ago, I had a brief affair with Lisp
and there I picked up this meme.
Today, I believe there are also benefits in separating code and data.</p>
<p>Glimpses of this debate come up
whenever people discuss the syntax for yet another configuration schema.
There are 5 levels of power for configuration languages.
If you design a new schema,
be aware of all of them.</p>
<h2>Level 1: String in a File</h2>
<p>The file system is a key-value store.
The Linux kernel does it with <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>
and <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a>.
Example from my shell:</p>
<pre><code>$ cat /proc/sys/kernel/arch
x86_64
$ cat /proc/sys/kernel/sched_energy_aware
1
</code></pre>
<p>I could write <code>0</code> to the second one to change the kernel behavior.</p>
<p>This certainly is the simplest format, yet it works.</p>
<h2>Level 2: A List</h2>
<p>For a little bit more expressive power,
you can treat the file contents as a list.
Maybe one per line.
Maybe a key-plus-value per line.
Maybe with sections like an <a href="https://en.wikipedia.org/wiki/INI_file">INI file</a>.
Example file contents:</p>
<pre><code>[database]
server = 192.0.2.62     
port = 143
file = &#34;payroll.dat&#34;
</code></pre>
<p>This is already complex enough that not everything is intuitive.
What happens if you duplicate a key?
Can you do multiline strings?</p>
<p>The defining constraint is that you cannot have a list of lists.
That would be the next level.
However, think twice before going there
because with a little pre- and postfixing names,
you can do a lot here.</p>
<h2>Level 3: Nested Data Structures</h2>
<p>This is probably the most popular level,
where we find JSON, YAML, XML, TOML, etc.
Example file contents:</p>
<pre><code>{
  &#34;database&#34;: {
    &#34;host&#34;: &#34;localhost&#34;,
    &#34;port&#34;: 1234,
    &#34;auth&#34;: {
      &#34;user&#34;: &#34;elon&#34;,
      &#34;password&#34;: &#34;mars2023&#34;
    }
  }
}
</code></pre>
<p>It is fascinating how much people can discuss about the pros and cons
of the alternatives on this level even though they are more or less the same.</p>
<p>I actually like XML.
It isn&#39;t &#34;cool&#34; like YAML anymore,
but it has better tooling support (e.g. schema checking)
and doesn&#39;t try to be <a href="https://www.brautaset.org/posts/yaml-exponent-problem.html">too clever</a>.
Just try to stay away from namespaces and don&#39;t be afraid of using attributes.</p>
<p>In practice,
many later encounter the limitation that you cannot compute anything.
Maybe they need <em>variables</em> or want to <em>generate</em> a list of things.
Then they retrofit it with abominations like &#34;Python-expressions as values&#34;
or &#34;Jinja-templates for generation&#34;.
At this point, you better get up another level
and this is where we transition from data to code, don&#39;t you think?</p>
<h2>Level 4: Total Programming Languages</h2>
<p>This is the least known level and should probably be more popular.
The term <a href="https://en.wikipedia.org/wiki/Total_functional_programming">total functional programming</a>
means you can compute stuff,
but it will terminate.
This is explicitly <em>not</em> Turing-complete.</p>
<p>This level includes <a href="https://de.wikipedia.org/wiki/XSL_Transformation">XSLT</a>,
<a href="https://jsonnet.org/">Jsonnet</a> (a JSON extension),
and even typed ones like <a href="https://dhall-lang.org/">Dhall</a>.
Here is a <a href="https://bazel.build/rules/language">Starlark</a> example from Bazel:</p>
<pre><code>java_binary(
    name = &#34;ProjectRunner&#34;,
    srcs = glob([&#34;src/main/java/com/example/*.java&#34;]),
)
</code></pre>
<p>A challenge here is that you are programming,
but since the languages are not that popular,
you don&#39;t have the usual language tooling available.
So, the final level...</p>
<h2>Level 5: Full Programming Language</h2>
<p>Of course, you can use any scripting language to configure things.
Python, Javascript, Lua, TCL, whatever.
They are Turing-complete.
For example, <a href="https://conan.io/">Conan</a> is a package manager where you specify packages in Python:</p>
<pre><code>from conan import ConanFile

class CompressorRecipe(ConanFile):
    settings = &#34;os&#34;, &#34;compiler&#34;, &#34;build_type&#34;, &#34;arch&#34;
    generators = &#34;CMakeToolchain&#34;, &#34;CMakeDeps&#34;

    def requirements(self):
        self.requires(&#34;zlib/1.2.11&#34;)

    def build_requirements(self):
        self.tool_requires(&#34;cmake/3.22.6&#34;)
</code></pre>
<p>Any Python programmer can easily add complex logic where they see fit.</p>
<p>Often people discover the problem,
that the configuration determines <em>what</em> to import,
but the imports also determine the configuration itself.
This circular dependency leads to madness.</p>
<p>For example,
in Conan you declare dependencies like in the example above.
You might want to depend on some Python module
which you use in this script.
At that point you are already executing the script though.
Thus, Conan invented <code>python_requires_extend</code>,
its own weird way to inject a super-class into an existing object.</p>
<p>How to avoid this madness?
Introduce another low-level configuration file.
Back to level one...</p>
<h2>Which Level to Use?</h2>
<p>The guiding principles is to <strong>use the lowest possible level</strong> to keep it simple.
Unfortunately, it usually is not an easy decision
because you don&#39;t know the future.</p>
<p>The corollary of my level structure:
Don&#39;t waste time on discussions <em>within</em> a level.
For example, JSON and YAML both have their problems and pitfalls
but both are probably good enough.</p>
<hr/>
<p><a href="https://lobste.rs/s/erkm24/5_levels_configuration_languages">Discussion on lobste.rs</a>
with great comments.</p>

</article><p>There are levels of power and you should stay low.</p></div>
  </body>
</html>
