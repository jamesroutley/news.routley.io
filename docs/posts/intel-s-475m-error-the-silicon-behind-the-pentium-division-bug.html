<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2024/12/this-die-photo-of-pentium-shows.html">Original</a>
    <h1>Intel&#39;s $475M error: the silicon behind the Pentium division bug</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-639773237179033868" itemprop="description articleBody">
<p>In 1993, Intel released the high-performance Pentium processor, the start of the long-running Pentium line.
The Pentium had many improvements over the previous processor, the Intel 486, including a faster floating-point division algorithm.
A year later, Professor Nicely, a number theory professor,
was researching reciprocals of twin prime numbers when he noticed a problem:
his Pentium sometimes generated the wrong result when performing floating-point division.
Intel considered this &#34;an extremely minor technical problem&#34;, but much to Intel&#39;s surprise,
the bug became a large media story.
After weeks of criticism, mockery, and bad publicity, Intel agreed to replace everyone&#39;s faulty Pentium chips, costing the company $475 million.</p>
<p>In this article, I discuss the Pentium&#39;s division algorithm, show exactly where the bug is on the Pentium chip, take a close look at the circuitry, and explain what went wrong.
In brief, the division algorithm uses a lookup table. In 1994, Intel stated that the cause of the bug was
that five entries were omitted from the
table due to an error in a script. However, my analysis shows that 16 entries were omitted due to a
mathematical mistake in the definition of the lookup table. Five of the missing entries trigger the bug—
also called the FDIV bug after the floating-point division instruction &#34;FDIV&#34;—while 11 of the missing entries have no effect.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/fdiv-bug-here.jpg"><img alt="This die photo of the Pentium shows the location of the FDIV bug. Click this image (or any other) for a larger version." height="453" src="https://static.righto.com/images/pentium-fdiv/fdiv-bug-here-w500.jpg" title="This die photo of the Pentium shows the location of the FDIV bug. Click this image (or any other) for a larger version." width="500"/></a></p><p>This die photo of the Pentium shows the location of the FDIV bug. Click this image (or any other) for a larger version.</p>
<p>Although Professor Nicely brought attention to the FDIV bug, he wasn&#39;t the first to find it.
In May 1994, Intel&#39;s internal testing of the Pentium revealed that
very rarely, floating-point division was slightly inaccurate.<span id="fnref:dham"><a href="#fn:dham">1</a></span>
Since only one in 9 billion values caused the problem, Intel&#39;s view was that the problem was trivial:  &#34;This doesn&#39;t even qualify as an errata.&#34; Nonetheless, Intel quietly revised the Pentium circuitry to fix the problem.</p>
<p>A few months later, in October, Nicely noticed erroneous results in his prime number computations.<span id="fnref:prime"><a href="#fn:prime">2</a></span>
He soon determined that 1/824633702441 was wrong on three different Pentium computers, but his older computers gave the right answer.
He called Intel tech support but was brushed off, so
Nicely emailed a dozen computer magazines and individuals about the bug.
One of the recipients was Andrew Schulman, author of &#34;Undocumented DOS&#34;. He forwarded the email to Richard Smith, cofounder of a DOS software tools company.
Smith posted the email on a Compuserve forum, a 1990s version of social media.</p>
<p>A reporter for the journal <em>Electronic Engineering Times</em> spotted the Compuserve post and wrote about the Pentium bug in the November 7 issue: <a href="https://davefaq.com/Opinions/Stupid/Pentium.html">Intel fixes a Pentium FPU glitch</a>.
In the article, Intel explained that the bug was in a component of the chip called a PLA (Programmable Logic Array)
that acted as a lookup table for the division operation.
Intel had fixed the bug in the latest Pentiums and
would replace faulty processors for concerned customers.<span id="fnref:timeline"><a href="#fn:timeline">3</a></span></p>
<p>The problem might have quietly ended here, except that Intel decided to restrict which customers could get a replacement.
If a customer couldn&#39;t convince an Intel engineer that they needed the accuracy, they couldn&#39;t get a fixed Pentium.
Users were irate to be stuck with faulty chips so they took their complaints to online groups such as <a href="https://groups.google.com/g/comp.sys.intel/c/L1KDE1d_ZLA/m/7rydJksrVTcJ">comp.sys.intel</a>.
The controversy spilled over into the offline world on November 22 when CNN reported on the bug.
Public awareness of the Pentium bug took off as newspapers wrote about the bug and
Intel became a punchline on talk shows.<span id="fnref:letterman"><a href="#fn:letterman">4</a></span></p>
<p>The situation became intolerable for Intel on December 12 when IBM announced that it was stopping shipments of Pentium computers.<span id="fnref:errata"><a href="#fn:errata">5</a></span>
On December 19, less than two months after Nicely first reported the bug, Intel gave in and announced that it would replace the flawed chips for all customers.<span id="fnref:apology"><a href="#fn:apology">6</a></span>
This recall cost Intel $475 million (over a billion dollars in current dollars).</p>
<p>Meanwhile, engineers and mathematicians were analyzing the bug, including
Tim Coe, an engineer who had designed floating-point units.<span id="fnref:coe"><a href="#fn:coe">7</a></span>
Remarkably, by studying the Pentium&#39;s bad divisions, Coe reverse-engineered the Pentium&#39;s division algorithm and determined why it went wrong.
Coe and others wrote papers describing the mathematics behind the Pentium bug.<span id="fnref:papers"><a href="#fn:papers">8</a></span>
But until now, nobody has shown how the bug is implemented in the physical chip itself.</p>
<h2>A quick explanation of floating point numbers</h2>
<p>At this point, I&#39;ll review a few important things about floating point numbers.
A binary number can have a fractional part, similar to a decimal number.
For instance, the binary number 11.1001 has four digits after the binary point.
(The binary point &#34;.&#34; is similar to the decimal point, but for a binary number.) The first digit after the binary point represents 1/2, the second represents 1/4, and so forth.
Thus, 11.1001 corresponds to 3 + 1/2 + 1/16 = 3.5625.
A &#34;fixed point&#34; number such as this can express a fractional value, but its range is limited.</p>
<p>Floating point numbers, on the other hand, include very large numbers such as 6.02×10<sup>23</sup> and very small numbers such as 1.055×10<sup>−34</sup>.
In decimal, 6.02×10<sup>23</sup> has a significand (or mantissa) of 6.02, multiplied by a power of 10 with an exponent of 23.
In binary, a floating point number is represented similarly, with a significand and exponent, except the significand is multiplied by a power of 2 rather than 10.</p>
<p>Computers have used floating point since the early days of computing, especially for scientific computing.
For many years, different computers used incompatible formats for floating point numbers.
Eventually, a standard arose when
Intel developed the 8087 floating point coprocessor chip for use with the 8086/8088 processor.
The characteristics of this chip became a standard (IEEE 754) in 1985.<span id="fnref:ieee754"><a href="#fn:ieee754">9</a></span>
Subsequently, most computers, including the Pentium, implemented floating point numbers according to this standard.
The result of a basic arithmetic operation is supposed to be accurate up to the last bit of the significand.
Unfortunately, division on the Pentium was occasionally much, much worse.</p>
<h2>How SRT division works</h2>
<p>How does a computer perform division? The straightforward way is similar to grade-school long division, except in binary.
That approach was used in the Intel 486 and earlier processors, but the process is slow, taking one clock cycle for each bit of the quotient.
The Pentium uses a different approach called SRT,<span id="fnref:srt-history"><a href="#fn:srt-history">10</a></span> performing division in base four.
Thus, SRT generates two bits of the quotient per step, rather than one, so division is twice as fast.
I&#39;ll explain SRT in a hand-waving manner with a base-10 example; rigorous explanations are available elsewhere.</p>
<p>The diagram below shows base-10 long division, with the important parts named.
The dividend is divided by the divisor, yielding the quotient.
In each step of the long division algorithm, you generate one more digit of the quotient.
Then you multiply the divisor (1535) by the quotient digit (2) and subtract this from the dividend,
leaving a partial remainder.
You multiply the partial remainder by 10 and then repeat the process, generating a quotient digit and partial remainder at each step.
The diagram below stops after two quotient digits, but you can keep going to get as much accuracy as desired.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/srt-diagram1.jpg"><img alt="Base-10 division, naming the important parts." height="168" src="https://static.righto.com/images/pentium-fdiv/srt-diagram1-w300.jpg" title="Base-10 division, naming the important parts." width="300"/></a></p><p>Base-10 division, naming the important parts.</p>
<p>Note that division is more difficult than multiplication since there is no easy way to determine each quotient digit.
You have to estimate a quotient digit, multiply it by the divisor, and then check if the quotient digit is correct.
For example, you have to check carefully to see if 1535 goes into 4578 two times or three times.</p>
<p>The SRT algorithm makes it easier to select the quotient digit through an unusual approach: it allows negative digits in the quotient.
With this change, the quotient digit does not need to be exact.
If you pick a quotient digit that is a bit too large, you can use a negative number for the next digit:
this will counteract the too-large digit since the next divisor will be added rather than subtracted.</p>
<p>The example below shows how this works.
Suppose you picked 3 instead of 2 as the first quotient digit.
Since 3 is too big, the partial remainder is negative (-261).
In normal division, you&#39;d need to try again with a different quotient digit.
But with SRT, you keep going, using a negative digit (-1) for the quotient digit in the next step.
At the end, the quotient with positive and negative digits can be converted to the standard form: 3×10-1 = 29, the same quotient as before.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/srt-diagram2.jpg"><img alt="Base-10 division, using a negative quotient digit. The result is the same as the previous example." height="159" src="https://static.righto.com/images/pentium-fdiv/srt-diagram2-w300.jpg" title="Base-10 division, using a negative quotient digit. The result is the same as the previous example." width="300"/></a></p><p>Base-10 division, using a negative quotient digit. The result is the same as the previous example.</p>
<p>One nice thing about the SRT algorithm is that since the quotient digit only needs to be close, a lookup table can be used to select the quotient digit.
Specifically, the partial remainder and divisor can be truncated to a few digits, making the lookup table a practical size.
In this example, you could truncate 1535 and 4578 to 15 and 45, the table says that 15 goes into 45 three times, and you can use 3 as your quotient digit.</p>
<p>Instead of base 10, the Pentium uses the SRT algorithm in base 4: groups of two bits.
As a result, division on the Pentium is twice as fast as standard binary division.
With base-4 SRT, each quotient digit can be -2, -1, 0, 1, or 2.
Multiplying by any of these values is very easy in hardware since multiplying by 2 can be done by a bit shift.
Base-4 SRT does not require quotient digits of -3 or 3;
this is convenient since multiplying by 3 is somewhat difficult.
To summarize, base-4 SRT is twice as fast as regular binary division, but it requires more hardware:
a lookup table, circuitry to add or subtract multiples of 1 or 2, and circuitry to convert the
quotient to the standard form.</p>
<h2>Structure of the Pentium&#39;s lookup table</h2>
<p>The purpose of the SRT lookup table is to provide the quotient digit.
That is, the table takes the partial remainder <em>p</em> and the divisor <em>d</em> as inputs and
provides an appropriate quotient digit.
The Pentium&#39;s lookup table is the cause of the division bug, as was explained in 1994.
The table was missing five entries; if the SRT algorithm accesses one of these missing entries, it generates an incorrect result.
In this section, I&#39;ll discuss the structure of the lookup table and explain what went wrong.</p>
<p>The Pentium&#39;s lookup table contains 2048 entries, as shown below.
The table has five regions corresponding to the quotient digits +2, +1, 0, -1, and -2.
Moreover, the upper and lower regions of the table are unused (due to the mathematics of SRT).
The unused entries were filled with 0, which turns out to be very important.
In particular, the five red entries need to contain +2 but were erroneously filled with 0.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/table-labeled.jpg"><img alt="The 2048-entry lookup table used in the Pentium for division. The divisor is along the X-axis, from 1 to 2. The partial remainder is along the Y-axis, from -8 to 8. Click for a larger version." height="716" src="https://static.righto.com/images/pentium-fdiv/table-labeled-w250.jpg" title="The 2048-entry lookup table used in the Pentium for division. The divisor is along the X-axis, from 1 to 2. The partial remainder is along the Y-axis, from -8 to 8. Click for a larger version." width="250"/></a></p><p>The 2048-entry lookup table used in the Pentium for division. The divisor is along the X-axis, from 1 to 2. The partial remainder is along the Y-axis, from -8 to 8. Click for a larger version.</p>
<p>When the SRT algorithm uses the table, the partial remainder <em>p</em> and the divisor <em>d</em> are inputs.
The divisor (scaled to fall between 1 and 2) provides the X coordinate into the table, while the partial remainder
(between -8 and 8) provides the Y coordinate.
The details of the table coordinates will be important, so I&#39;ll go into some detail.
To select a cell, the divisor (X-axis) is truncated to a 5-bit binary value 1.dddd.
(Since the first digit of the divisor is always 1, it is ignored for the table lookup.)
The partial remainder (Y-axis) is truncated to a 7-bit signed binary value pppp.ppp.
The 11 bits indexing into the table result in a table with 2<sup>11</sup> (2048) entries.
The partial remainder is expressed in 2&#39;s complement, so values 0000.000 to 0111.111 are non-negative values from 0 to (almost) 8, while values 1000.000 to 1111.111 are negative values from -8 to (almost) 0.
(To see the binary coordinates for the table, click on the image and zoom in.)</p>
<h2>The lookup table is implemented in a Programmable Logic Array (PLA)</h2>
<p>In this section, I&#39;ll explain how the lookup table is implemented in hardware in the Pentium.
The lookup table has 2048 entries so it could be stored in a ROM with 2048 two-bit outputs.<span id="fnref:dimensions"><a href="#fn:dimensions">11</a></span>
(The sign is not explicitly stored in the table because
the quotient digit sign is the same as the partial remainder sign.)
However, because the table is highly structured (and largely empty), the table can be stored more compactly in a structure called a Programmable Logic Array (PLA).<span id="fnref:intel-pla"><a href="#fn:intel-pla">12</a></span>
By using a PLA, the Pentium stored the table in just 112 rows rather than 2048 rows, saving an enormous amount of space.
Even so, the PLA is large enough on the chip that it is visible to the naked eye, if you squint a bit.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-zoom.jpg"><img alt="Zooming in on the PLA and associated circuitry on the Pentium die." height="514" src="https://static.righto.com/images/pentium-fdiv/pla-zoom-w600.jpg" title="Zooming in on the PLA and associated circuitry on the Pentium die." width="600"/></a></p><p>Zooming in on the PLA and associated circuitry on the Pentium die.</p>
<p>The idea of a PLA is to provide a dense and flexible way of implementing arbitrary logic functions.
Any Boolean logic function can be expressed as a &#34;sum-of-products&#34;, a collection of AND terms (products) that are OR&#39;d together (summed).
A PLA has a block of circuitry called the AND plane that generates the desired sum terms.
The outputs of the AND plane are fed into a second block, the OR plane, which ORs the terms together.
The AND plane and the OR plane are organized as grids. Each gridpoint can either have a transistor
or not, defining the logic functions.
The point is that by putting the appropriate pattern of transistors in the grids, you can create any function.
For the division PLA, there are has 22 inputs (the 11 bits from the divisor and partial remainder indices, along with their complements) and two outputs, as shown below.<span id="fnref:pla"><a href="#fn:pla">13</a></span></p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-structure.jpg"><img alt="A simplified diagram of the division PLA." height="317" src="https://static.righto.com/images/pentium-fdiv/pla-structure-w400.jpg" title="A simplified diagram of the division PLA." width="400"/></a></p><p>A simplified diagram of the division PLA.</p>
<p>A PLA is more compact than a ROM if the structure of the function allows it to be expressed with a small number of terms.<span id="fnref:rom"><a href="#fn:rom">14</a></span>
One difficulty with a PLA is figuring out how to express the function with the minimum number of terms to
make the PLA as small as possible.
It turns out that this problem is NP-complete in general.
Intel used a program called Espresso to generate compact PLAs using heuristics.<span id="fnref:espresso"><a href="#fn:espresso">15</a></span></p>
<p>The diagram below shows the division PLA in the Pentium. The PLA has 120 rows, split into two 60-row parts with support circuitry in the middle.<span id="fnref:split"><a href="#fn:split">16</a></span>
The 11 table input bits go into the AND plane drivers in the middle, which produce the 22 inputs to the PLA (each table input and its complement).
The outputs from the AND plane transistors go through output buffers and are fed into the OR plane. 
The outputs from the OR plane go through additional buffers and logic in the center, producing two
output bits, indicating a ±1 or ±2 quotient.
The image below shows the updated PLA that fixes the bug; the faulty PLA looks similar except the transistor
pattern is different. In particular, the updated PLA has 46 unused rows at the bottom while the original, faulty
PLA has 8 unused rows.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-labeled.jpg"><img alt="The division PLA with the metal layers removed to show the silicon. This image shows the PLA in the updated Pentium, since that photo came out better." height="802" src="https://static.righto.com/images/pentium-fdiv/pla-labeled-w450.jpg" title="The division PLA with the metal layers removed to show the silicon. This image shows the PLA in the updated Pentium, since that photo came out better." width="450"/></a></p><p>The division PLA with the metal layers removed to show the silicon. This image shows the PLA in the updated Pentium, since that photo came out better.</p>
<p>The image below shows part of the AND plane of the PLA.
At each point in the grid, a transistor can be present or absent.
The pattern of transistors in a row determines the logic term for that row.
The vertical doped silicon lines (green) are connected to ground. The vertical polysilicon lines (red) are
driven with the input bit pattern. If a polysilicon line crosses doped silicon, it forms a
transistor (orange) that will pull that row to ground when activated.<span id="fnref:demorgan"><a href="#fn:demorgan">17</a></span>
A metal line connects all the transistor rows in a row to produce the output;
most of the metal has been removed, but some metal lines are visible at the right.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-silicon-right.jpg"><img alt="Part of the AND plane in the fixed Pentium. I colored the first silicon and polysilicon lines green and red respectively." height="430" src="https://static.righto.com/images/pentium-fdiv/pla-silicon-right-w600.jpg" title="Part of the AND plane in the fixed Pentium. I colored the first silicon and polysilicon lines green and red respectively." width="600"/></a></p><p>Part of the AND plane in the fixed Pentium. I colored the first silicon and polysilicon lines green and red respectively.</p>
<p>By carefully examining the PLA under a microscope, I extracted the pattern of transistors in
the PLA grid. (This was somewhat tedious.) From the transistor pattern, I could
determine the equations for each PLA row, and then generate the contents of the lookup table.
Note that the transistors in the PLA don&#39;t directly map to the table contents (unlike a ROM).
Thus, there is no specific place for transistors corresponding to the 5 missing table entries.</p>
<p>The left-hand side of the PLA implements the OR planes (below).
The OR plane determines if the row output produces a quotient of 1 or 2.
The OR plane is oriented 90° relative to the AND plane: the inputs are horizontal polysilicon
lines (red) while the output lines are vertical.
As before, a transistor (orange) is formed where polysilicon crosses doped silicon.
Curiously, each OR plane has four outputs, even though the PLA itself has two outputs.<span id="fnref:outputs"><a href="#fn:outputs">18</a></span></p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-lhs.jpg"><img alt="Part of the OR plane of the division PLA. I removed the metal layers to show the underlying silicon and polysilicon. I drew lines for ground and outputs, showing where the metal lines were." height="488" src="https://static.righto.com/images/pentium-fdiv/pla-lhs-w450.jpg" title="Part of the OR plane of the division PLA. I removed the metal layers to show the underlying silicon and polysilicon. I drew lines for ground and outputs, showing where the metal lines were." width="450"/></a></p><p>Part of the OR plane of the division PLA. I removed the metal layers to show the underlying silicon and polysilicon. I drew lines for ground and outputs, showing where the metal lines were.</p>
<p>Next, I&#39;ll show exactly how the AND plane produces a term.
For the division table, the inputs are the 7 partial remainder bits and 4 divisor bits, as explained
earlier.
I&#39;ll call the partial remainder bits p<sub>6</sub>p<sub>5</sub>p<sub>4</sub>p<sub>3</sub>.p<sub>2</sub>p<sub>1</sub>p<sub>0</sub> and the divisor bits 1.d<sub>3</sub>d<sub>2</sub>d<sub>1</sub>d<sub>0</sub>.
These 11 bits and their complements are fed vertically into the PLA as shown at the top of the diagram below.
These lines are polysilicon, so they will form transistor gates, turning on the corresponding transistor when activated.
The arrows at the bottom point to nine transistors in the first row.
(It&#39;s tricky to tell if the polysilicon line passes next to doped silicon or over the silicon, so
the transistors aren&#39;t always obvious.)
Looking at the transistors and their inputs shows that the first term in the PLA is generated by
p<sub>0</sub>p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub>&#39;p<sub>5</sub>p<sub>6</sub>d<sub>1</sub>d<sub>2</sub>.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-top-labeled.jpg"><img alt="The first row of the division PLA in a faulty Pentium." height="175" src="https://static.righto.com/images/pentium-fdiv/pla-top-labeled-w500.jpg" title="The first row of the division PLA in a faulty Pentium." width="500"/></a></p><p>The first row of the division PLA in a faulty Pentium.</p>
<p>The diagram below is a closeup of the lookup table, showing how this PLA row assigns the value 1 to four table cells (dark blue).
You can think of each term of the PLA as pattern-matching to a binary pattern that can include &#34;don&#39;t care&#34; values.
The first PLA term (above) matches the pattern P=110.1111, D=x11x, where the &#34;don&#39;t care&#34; x values can be either 0 or 1.
Since one PLA row can implement multiple table cells, the PLA is more efficient than a ROM;
the PLA uses 112 rows, while a ROM would require 2048 rows.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-entry-diagram.jpg"><img alt="The first entry in the PLA assigns the value 1 to the four dark blue cells." height="242" src="https://static.righto.com/images/pentium-fdiv/pla-entry-diagram-w400.jpg" title="The first entry in the PLA assigns the value 1 to the four dark blue cells." width="400"/></a></p><p>The first entry in the PLA assigns the value 1 to the four dark blue cells.</p>
<p>Geometrically, you can think of each PLA term (row) as covering a rectangle or rectangles in the table.
However, the rectangle can&#39;t be arbitrary, but must be aligned on a bit boundary.
Note that each &#34;bump&#34; in the table boundary (magenta) requires a separate rectangle and thus a separate PLA row.
(This will be important later.)</p>
<p>One PLA row can generate a large rectangle, filling in many table cells at once,
if the region happens to be aligned nicely.
For instance, the third term in the PLA matches d=xxxx, p=11101xx.
This single PLA row efficiently fills in
64 table cells as shown below, replacing the 64 rows that would be required in a ROM.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-entry-diagram2.jpg"><img alt="The third entry in the PLA assigns the value 1 to the 64 dark blue cells." height="238" src="https://static.righto.com/images/pentium-fdiv/pla-entry-diagram2-w400.jpg" title="The third entry in the PLA assigns the value 1 to the 64 dark blue cells." width="400"/></a></p><p>The third entry in the PLA assigns the value 1 to the 64 dark blue cells.</p>
<p>To summarize, the pattern of transistors in the PLA implements a set of equations, which define
the contents of the table, setting the quotient to 1 or 2 as appropriate.
Although the table has 2048 entries, the PLA represents the contents in just 112 rows.
By carefully examining the transistor pattern, I determined the table contents in a faulty Pentium and
a fixed Pentium.</p>
<h2>The mathematical bounds of the lookup table</h2>
<p>As shown earlier, the lookup table has regions corresponding to quotient digits of +2, +1, 0, -1, and -2.
These regions have irregular, slanted shapes, defined by mathematical bounds.
In this section, I&#39;ll explain these mathematical bounds since
they are critical to understanding how the Pentium bug occurred.</p>
<p>The essential step of the division algorithm is to divide
the partial remainder <em>p</em> by the divisor <em>d</em> to get the quotient digit.
The following diagram shows how <em>p/d</em> determines the quotient digit. The ratio <em>p/d</em> will define a point on
the line at the top. (The point will be in the range [-8/3, 8/3] for mathematical reasons.)
The point will fall into one of the five lines below, defining the quotient digit <em>q</em>. However, the five quotient
regions overlap; if <em>p/d</em> is in one of the green segments, there are two possible quotient digits.
The next part of the diagram illustrates how subtracting
<em>q*d</em> from the partial remainder <em>p</em> shifts <em>p/d</em> into the middle, between -2/3 and 2/3.
Finally, the result is multiplied by 4 (shifted left by two bits), expanding<span id="fnref:chaos"><a href="#fn:chaos">19</a></span> the interval back to [-8/3, 8/3], which is the same size as the original interval.
The 8/3 bound may seem arbitrary, but the motivation is that
it ensures that the new interval is the same size as the original interval, so the process can be repeated.
(The bounds are all thirds for algebraic reasons; the value 3 comes from base 4 minus 1.<span id="fnref:bound"><a href="#fn:bound">20</a></span>)</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/intervals.jpg"><img alt="The input to a division step is processed, yielding the input to the next step." height="335" src="https://static.righto.com/images/pentium-fdiv/intervals-w550.jpg" title="The input to a division step is processed, yielding the input to the next step." width="550"/></a></p><p>The input to a division step is processed, yielding the input to the next step.</p>
<p>Note that the SRT algorithm has some redundancy, but cannot handle <em>q</em> values that are &#34;too wrong&#34;.
Specifically, if <em>p/d</em> is in a green region,
then either of two <em>q</em> values can be selected.
However, the algorithm cannot recover from a bad <em>q</em> value in general.
The relevant case is that if <em>q</em> is supposed to be 2 but 0 is selected,
the next partial remainder will be outside the interval and the algorithm can&#39;t recover.
This is what causes the FDIV bug.</p>
<p>The diagram below shows the structure of the SRT lookup table (also called the P-D table since the axes are <em>p</em> and <em>d</em>).
Each bound in the diagram above turns into a line in the table.
For instance, the green segment above with <em>p/d</em> between 4/3 and 5/3 turns into a green region in the
table below with <em>4/3 d ≤ p ≤ 5/3 d</em>.
These slanted lines show the regions in which a particular quotient digit <em>q</em> can be used.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pd-table.jpg"><img alt="The P-D table specifies the quotient digit for a partial remainder (Y-axis) and divisor (X-axis)." height="686" src="https://static.righto.com/images/pentium-fdiv/pd-table-w350.jpg" title="The P-D table specifies the quotient digit for a partial remainder (Y-axis) and divisor (X-axis)." width="350"/></a></p><p>The P-D table specifies the quotient digit for a partial remainder (Y-axis) and divisor (X-axis).</p>
<p>The lookup table in the Pentium is based on the above table, quantized with a <em>q</em> value in each cell.
However, there is one more constraint to discuss.</p>
<h2>Carry-save and carry-lookahead adders</h2>
<p>The Pentium&#39;s division circuitry uses a special circuit to perform addition and subtraction efficiently:
the carry-save adder.
One consequence of this adder is that each access to the lookup table may go to the cell just below
the &#34;right&#34; cell. This is expected and should be fine, but in very rare and complicated circumstances,
this behavior causes an access to one of the Pentium&#39;s five missing cells, triggering the division bug.
In this section, I&#39;ll discuss why the division circuitry uses a carry-save adder, how the carry-save adder works,
and how the carry-save adder triggers the FDIV bug.</p>
<p>The problem with addition is that carries make addition slow.
Consider calculating 99999+1 by hand.
You&#39;ll start with 9+1=10, then carry the one, generating another carry, which generates another carry, and so forth, until you go through all the digits.
Computer addition has the same problem.
If you&#39;re adding, say, two 64-bit numbers, the low-order bits can generate a carry that then propagates through all 64 bits.
The time for the carry signal to go through 64 layers of circuitry is significant and can limit CPU performance.
As a result, CPUs use special circuits to make addition faster.</p>
<p>The Pentium&#39;s division circuitry uses an unusual adder circuit called a carry-save adder to add (or subtract) the divisor and the partial remainder.
A carry-save adder speeds up addition if you are performing a bunch of additions, as happens during division.
The idea is that instead of adding a carry to each digit as it happens, you hold onto the carries in a separate word.
As a decimal example, 499+222 would be 611 with carries 011; you don&#39;t carry the one to the second digit, but hold onto it.
The next time you do an addition, you add in the carries you saved previously, and again save any new carries.
The advantage of the carry-save adder is that the sum and carry at each digit position can be computed in parallel, which is fast.
The disadvantage is that you need to do a slow addition at the end of the sequence of additions to add in the remaining carries to get the final answer.
But if you&#39;re performing multiple additions (as for division), the carry-save adder is faster overall.</p>
<p>The carry-save adder creates a problem for the lookup table.
We need to use the partial remainder as an index into the lookup table.
But the carry-save adder splits the partial remainder into two parts: the sum bits and the carry bits.
To get the table index, we need to add the sum bits and carry bits together.
Since this addition needs to happen for every step of the division, it seems like we&#39;re back to using a slow adder and the carry-save adder has just made things worse.</p>
<p>The trick is that we only need 7 bits of the partial remainder for the table index, so we can use
a different type of adder—a carry-lookahead adder—that calculates each carry in parallel using brute force logic.
The logic in a carry-lookahead adder gets more and more complex for each bit so a carry-lookahead adder is impractical for large words, but it is practical for a 7-bit value.</p>
<p>The photo below shows the carry-lookahead adder used by the divider.
Curiously, the adder is an 8-bit adder but only 7 bits are used;
perhaps the 8-bit adder was a standard logic block at Intel.<span id="fnref:8bit"><a href="#fn:8bit">21</a></span>
I&#39;ll just give a quick summary of the adder here, and leave the details for another post.
At the top, logic gates compute signals in parallel for each of the 8 pairs of inputs: sum, carry generate, and carry propagate.
Next, the complex carry-lookahead logic determines in parallel if there will be a carry at each position.
Finally, XOR gates apply the carry to each bit.
The circuitry in the middle is used for testing; see the footnote.<span id="fnref:testing"><a href="#fn:testing">22</a></span>
At the bottom, the drivers amplify control signals for various parts of the adder and send the PLA output to other parts of the chip.<span id="fnref:bicmos"><a href="#fn:bicmos">23</a></span>
By counting the blocks of repeated circuitry, you can see which blocks are 8 bits wide, 11, bits wide, and so forth.
The carry-lookahead logic is different for each bit, so there is no repeated structure.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/adder-silicon.jpg"><img alt="The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray)." height="859" src="https://static.righto.com/images/pentium-fdiv/adder-silicon-w600.jpg" title="The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray)." width="600"/></a></p><p>The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).</p>
<p>The carry-save and carry-lookahead adders may seem like implementation trivia, but they are
a critical part of the FDIV bug because they change the constraints on the table.
The cause is that the partial remainder is 64 bits,<span id="fnref:64-bits"><a href="#fn:64-bits">24</a></span> but the adder that computes the table
index is 7 bits.
Since the rest of the bits are truncated before the sum, the partial remainder sum for the table index
can be slightly lower than the real partial remainder.
Specifically, the table index can be one cell lower than the correct cell, an offset of 1/8.
Recall the earlier diagram with diagonal lines separating the regions.
Some (but not all) of these lines must be shifted down by 1/8 to account for the carry-save effect,
but Intel made the wrong adjustment, which is the root cause of the FDIV error.
(This effect was well-known at the time and mentioned in papers on SRT division, so Intel shouldn&#39;t have gotten it wrong.)</p>
<p>An interesting thing about the FDIV bug is how extremely rare it is.
With 5 bad table entries out of 2048, you&#39;d expect erroneous divides to be very common.
However, for complicated mathematical reasons involving the carry-save adder
the missing table entries are almost never encountered:
only about 1 in 9 billion random divisions will encounter a problem.
To hit a missing table entry, you need an &#34;unlucky&#34; result from the carry-save adder multiple
times in a row, making the odds similar to winning the lottery, if the lottery prize were a division error.<span id="fnref:heatmaps"><a href="#fn:heatmaps">25</a></span></p>
<h2>What went wrong in the lookup table</h2>
<p>I consider the diagram below to be the &#34;smoking gun&#34; that explains how the FDIV bug happens:
the top magenta line should be above the sloping black line, but it crosses the black line repeatedly.
The magenta line carefully stays above the gray line, but that&#39;s the wrong line.
In other words, Intel picked the wrong bounds line when defining the +2 region of the table.
In this section, I&#39;ll explain why that causes the bug.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/bounds2.jpg"><img alt="The top half of the lookup table, explaining the root of the FDIV bug." height="469" src="https://static.righto.com/images/pentium-fdiv/bounds2-w500.jpg" title="The top half of the lookup table, explaining the root of the FDIV bug." width="500"/></a></p><p>The top half of the lookup table, explaining the root of the FDIV bug.</p>
<p>The diagram is colored according to the quotient values stored in the Pentium&#39;s lookup table: yellow is +2,
blue is +1, and white is 0, with magenta lines showing the boundaries between different values.
The diagonal black lines are the mathematical constraints on the table, defining the region that
must be +2, the region that can be +1 or +2, the region that must be +1, and so forth.
For the table to be correct, each cell value in the table must satisfy these constraints.
The middle magenta line is valid:
it remains between the two black lines (the redundant +1 or +2 region), so all the cells that need
to be +1 are +1 and all the cells that need to be +2 are +2, as required.
Likewise, the bottom magenta line remains between the black lines.
However, the top magenta line is faulty: it must remain above the top black line, but it crosses
the black line. The consequence is that some cells that need to be +2 end up holding 0: these are the missing
cells that caused the FDIV bug.</p>
<p>Note that the top magenta line stays above the diagonal gray line while following it as closely
as possible. If the gray line were the correct line, the table would be perfect.
Unfortunately, Intel picked the wrong constraint line for the table&#39;s upper bound when the table was
generated.<span id="fnref:bounds"><a href="#fn:bounds">26</a></span></p>
<p>But why are some diagonal lines lowered by 1/8 and other lines are not lowered?
As explained in the previous section, as a consequence of the carry-save adder truncation,
the table lookup may end up one cell lower than the actual <em>p</em> value would indicate, i.e. the
<em>p</em> value for the table index is 1/8 lower than that actual value. 
Thus, both the correct cell and the cell below must satisfy the SRT constraints.
Thus, the line moves down if that makes the constraints stricter but does not move down
if that would expand the redundant area.
In particular, the top line must not be move down, but clearly Intel moved the line down and generated the
faulty lookup table.</p>
<!--
Next, let's look at the design and manufacturing steps between the table and the chip.
The lookup table is defined mathematically by the sloping lines that separate its regions.
The 2048 cells of the table were assigned according to these lines.
Next, the table was processed to form the optimized set of PLA entries using the Espresso tool.
These entries were loaded into the Pentium's RTL model as well as the layout representation.
The layout representation defined the physical layout of the transistors and wiring on the chip.
The layout was used to create masks, which were then used to fabricate the integrated circuits.

I don't know all the details of Intel's design automation software, so my list of steps is slightly speculative.
    -->

<p>Intel, however, has a different explanation for the bug.
The Intel white paper states that the problem was in a script that downloaded the table into a PLA: an error caused the script to omit a few entries from the PLA.<span id="fnref:script"><a href="#fn:script">27</a></span>
I don&#39;t believe this explanation: the missing terms match a mathematical error, not a copying error.
I suspect that Intel&#39;s statement is technically true but misleading: they ran a C program
(which they called a script) to generate the table but the program had a mathematical error
in the bounds.</p>
<p>In his book &#34;The Pentium Chronicles&#34;, Robert Colwell, architect of the Pentium Pro, provides
a different explanation of the FDIV bug.
Colwell claims that the Pentium design originally used the same lookup table as the 486,
but shortly before release, the engineers were pressured by management to shrink the circuitry to save die space.
The engineers optimized the table to make it smaller and
had a proof that the optimization would work.
Unfortunately, the proof was faulty, but the testers trusted the engineers and didn&#39;t test the modification thoroughly, causing the Pentium to be released with the bug.
The problem with this explanation is that the Pentium was designed from the start with a completely different division algorithm from the 486: the Pentium uses radix-4 SRT, while the 486 uses standard binary division.
Since the 486 doesn&#39;t have a lookup table, the story falls apart.
Moreover, the PLA could trivially have been made smaller by removing the 8 unused rows, so the engineers clearly weren&#39;t trying to shrink it.
My suspicion is that since Colwell developed the Pentium Pro in Oregon but the original Pentium was developed in California, Colwell didn&#39;t get firsthand information on the Pentium problems.</p>
<h2>How Intel fixed the bug</h2>
<p>Intel&#39;s fix for the bug was straightforward but also surprising.
You&#39;d expect that Intel added the five missing table values to the PLA, and this is what was
reported at the time.
The <a href="https://www.nytimes.com/1994/11/24/business/company-news-flaw-undermines-accuracy-of-pentium-chips.html">New York Times</a> wrote that Intel fixed the flaw by adding several dozen transistors to the chip.
<a href="https://davefaq.com/Opinions/Stupid/Pentium.html">EE Times</a> wrote that &#34;The fix entailed adding terms, or additional gate-sequences, to the PLA.&#34;</p>
<p>However, the updated PLA (below) shows something entirely different.
The updated PLA is exactly the same size as the original PLA. However,
about 1/3 of the terms were <em>removed</em> from the PLA, eliminating hundreds of transistors.
Only 74 of the PLA&#39;s 120 rows are used, and the rest are left empty. (The original PLA had 8 empty rows.)
How could removing terms from the PLA fix the problem?</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/new-pla.jpg"><img alt="The updated PLA has 46 unused rows." height="735" src="https://static.righto.com/images/pentium-fdiv/new-pla-w300.jpg" title="The updated PLA has 46 unused rows." width="300"/></a></p><p>The updated PLA has 46 unused rows.</p>
<p>The explanation is that
Intel didn&#39;t just fill in the five missing table entries with the correct value of 2.
Instead, Intel filled <em>all</em> the unused table entries with 2, as shown below.
This has two effects.
First, it eliminates any possibility of hitting a mistakenly-empty entry.
Second, it makes the PLA equations much simpler.
You might think that more entries in the table would make the PLA larger, but the number of
PLA terms depends on the structure of the data.
By filling the unused cells with 2, the jagged borders between the unused regions (white) and the &#34;2&#34; regions (yellow) disappear.
As explained earlier, a large rectangle can be covered by a single PLA term, but a jagged border requires
a lot of terms.
Thus, the updated PLA is about 1/3 smaller than the original, flawed PLA.
One consequence is that the terms in the new PLA are completely different from the terms in the
old PLA so one can&#39;t point to the specific transistors that fixed the bug.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/old-vs-new.jpg"><img alt="Comparison of the faulty lookup table (left) and the corrected lookup table (right)." height="546" src="https://static.righto.com/images/pentium-fdiv/old-vs-new-w400.jpg" title="Comparison of the faulty lookup table (left) and the corrected lookup table (right)." width="400"/></a></p><p>Comparison of the faulty lookup table (left) and the corrected lookup table (right).</p>
<p>The image below shows the first 14 rows of the faulty PLA and the first 14 rows of the fixed PLA. As you can
see, the transistor pattern (and thus the PLA terms) are entirely different.
The doped silicon is darkened in the second image due to differences in how I processed the dies to remove
the metal layers.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/comparison.jpg"><img alt="Top of the faulty PLA (left) and the fixed PLA (right). The metal layers were removed to show the silicon of the transistors. (Click for a larger image.)" height="301" src="https://static.righto.com/images/pentium-fdiv/comparison-w700.jpg" title="Top of the faulty PLA (left) and the fixed PLA (right). The metal layers were removed to show the silicon of the transistors. (Click for a larger image.)" width="700"/></a></p><p>Top of the faulty PLA (left) and the fixed PLA (right). The metal layers were removed to show the silicon of the transistors. (Click for a larger image.)</p>
<h2>Impact of the FDIV bug</h2>
<p>How important is the Pentium bug? This became a highly controversial topic.
A failure of a random division operation is very rare: about one in 9 billion values will trigger the bug.
Moreover, an erroneous division is still mostly accurate: the error is usually in the 9th or 10th decimal
digit, with rare worst-case error in the 4th significant digit.
Intel&#39;s <a href="https://www.ardent-tool.com/CPU/Intel/fdiv/white11.pdf">whitepaper</a> claimed that a typical user would encounter a problem once every 27,000 years, insignificant compared to other sources of error such as DRAM bit flips.
Intel said: &#34;Our overall conclusion is that the flaw in the floating point unit of the Pentium processor is of no concern to the vast majority of users.
A few users of applications in the scientific/engineering and financial engineering fields may need to employ either an updated processor without the flaw or a software workaround.&#34;</p>
<p>However, IBM performed their own analysis,<span id="fnref:ibm"><a href="#fn:ibm">29</a></span> suggesting that the problem could hit customers every few days, and IBM suspended Pentium sales. (Coincidentally, IBM had a competing processor, the PowerPC.)
The battle made it to major newspapers; the Los Angeles Times split the difference with <a href="https://www.latimes.com/archives/la-xpm-1994-12-17-fi-9948-story.html">Study Finds Both IBM, Intel Off on Error Rate</a>.
Intel soon gave in and agreed to replace all the Pentiums, making the issue moot.</p>
<p>I mostly agree with Intel&#39;s analysis. It appears that only one person (Professor Nicely) noticed the bug
in actual use.<span id="fnref:legends"><a href="#fn:legends">28</a></span>
The IBM analysis seems contrived to hit numbers that trigger the error.
Most people would never hit the bug and even if they hit it, a small degradation in floating-point accuracy is unlikely to matter to most people.
Looking at society as a whole, replacing the Pentiums was a huge expense for minimal gain.
On the other hand, it&#39;s reasonable for customers to expect an accurate processor.</p>
<p>Note that the Pentium bug is deterministic: if you use a specific divisor and dividend that trigger the problem,
you will get the wrong answer 100% of the time.
Pentium engineer Ken Shoemaker suggested that the outcry over the bug was because it was so easy for
customers to reproduce.
It was hard for Intel to argue that customers would never encounter the bug when customers could trivially
see the bug on their own computer, even if the situation was artificial.</p>
<h2>Conclusions</h2>
<p>The FDIV bug is one of the most famous processor bugs.
By examining the die, it is possible to see exactly where it is on the chip.
But Intel has had other important bugs.
Some early 386 processors had a 32-bit multiply problem.
Unlike the deterministic FDIV bug, the 386 would unpredictably produce the wrong results under particular temperature/voltage/frequency conditions.
The underlying issue was a layout problem that didn&#39;t provide enough electrical margin to handle the worst-case situation.
Intel sold the faulty chips but restricted them to the 16-bit market; bad chips were labeled &#34;16 BIT S/W ONLY&#34;, while the good processors were marked with a double sigma.
 Although Intel had to suffer through embarrassing headlines such as <a href="https://archive.org/details/bub_gb_mDsEAAAAMBAJ/page/n5/mode/1up?view=theater">Some 386 Systems Won&#39;t Run 32-Bit Software, Intel Says</a>, the bug was soon forgotten.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/steppings.jpg"><img alt="Bad and good versions of the 386. Note the labels on the bottom line. Photos (L), (R) by Thomas Nguyen, (CC BY-SA 4.0)" height="205" src="https://static.righto.com/images/pentium-fdiv/steppings-w400.jpg" title="Bad and good versions of the 386. Note the labels on the bottom line. Photos (L), (R) by Thomas Nguyen, (CC BY-SA 4.0)" width="400"/></a></p><p>Bad and good versions of the 386. Note the labels on the bottom line. Photos (<a href="https://commons.wikimedia.org/wiki/File:Intel_A80386-16_16_bit_SW_Only.jpg">L</a>), (<a href="https://commons.wikimedia.org/wiki/File:Intel_A80386-16_%CE%A3%CE%A3.jpg">R</a>) by Thomas Nguyen, (<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA 4.0</a>)</p>
<p>Another memorable Pentium issue was the &#34;F00F bug&#34;, a problem where a particular instruction sequence starting with F0 0F would cause the processor to lock up until rebooted.<span id="fnref:f00f"><a href="#fn:f00f">30</a></span>
The bug was found in 1997 and solved with an operating system update.
The bug is presumably in the Pentium&#39;s voluminous microcode. The microcode is too complex for me to analyze,
so don&#39;t expect a detailed blog post on this subject. :-)</p>
<p>You might wonder why Intel needed to release a new revision of the Pentium to fix the FDIV bug, rather than just updating the microcode.
The problem was that microcode for the Pentium (and earlier processors) was hard-coded into a ROM and couldn&#39;t be modified.
Intel added patchable microcode to the Pentium Pro (1995), allowing limited modifications to the microcode.
Intel originally implemented this feature for chip debugging and testing.
But after the FDIV bug, Intel realized that patchable microcode was valuable for bug fixes too.<span id="fnref:patchable"><a href="#fn:patchable">31</a></span>
The Pentium Pro stores microcode in ROM, but it also has a static RAM that holds up to 60 microinstructions.
During boot, the BIOS can load a microcode patch into this RAM.
In modern Intel processors, microcode patches have been used for problems ranging from the <a href="https://support.microsoft.com/en-us/topic/kb4090007-intel-microcode-updates-3bdf784b-d4ad-d881-cfc1-658095b59638">Spectre</a> vulnerability to <a href="https://community.intel.com/t5/Processors/Microcode-0x129-Update-for-Intel-Core-13th-and-14th-Gen-Desktop/m-p/1622129">voltage problems</a>.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/pla-m2.jpg"><img alt="The Pentium PLA with the top metal layer removed, revealing the M2 and M1 layers. The OR and AND planes are at the top and bottom, with drivers and control logic in the middle." height="872" src="https://static.righto.com/images/pentium-fdiv/pla-m2-w250.jpg" title="The Pentium PLA with the top metal layer removed, revealing the M2 and M1 layers. The OR and AND planes are at the top and bottom, with drivers and control logic in the middle." width="250"/></a></p><p>The Pentium PLA with the top metal layer removed, revealing the M2 and M1 layers. The OR and AND planes are at the top and bottom, with drivers and control logic in the middle.</p>
<p>As the number of transistors in a processor increased exponentially, as described by Moore&#39;s Law,
processors used more complex circuits and algorithms. Division is one example.
Early microprocessors such as the Intel 8080 (1974, 6000 transistors) had no hardware support for
division or floating point arithmetic. The Intel 8086 (1978, 29,000 transistors) implemented integer division
in microcode but required the 8087 coprocessor chip for floating point. The Intel 486 (1989, 1.2 million transistors) added floating-point support on the chip.
The Pentium (1993, 3.1 million transistors) moved to the
faster but more complicated SRT division algorithm.
The Pentium&#39;s division PLA alone has roughly 4900 transistor sites, more than a MOS Technology 6502 processor—one component of the Pentium&#39;s division circuitry uses more transistors than an entire 1975 processor.</p>
<p>The long-term effect of the FDIV bug on Intel is a subject of debate.
On the one hand, competitors such as AMD benefitted from Intel&#39;s error.
AMD&#39;s <a href="https://bsky.app/profile/trevorkevorson.bsky.social/post/3lcnv6h65hc26">ads</a> poked fun at the Pentium&#39;s problems by listing features of AMD&#39;s chips such as &#34;You don&#39;t have to double check your math&#34; and &#34;Can actually handle the rigors of complex calculations like <em>division</em>.&#34;
On the other hand, Robert Colwell, architect of the Pentium Pro, said that the FDIV bug may have been a net benefit to Intel as it created enormous name recognition for the Pentium, along with a demonstration that Intel was willing to back up its brand name.
Industry writers agreed; see <a href="https://websrv.cecs.uci.edu/~papers/mpr/MPR/EDITOR/0903ed.pdf">The Upside of the Pentium Bug</a>.
In any case, Intel survived the FDIV bug; time will tell how Intel survives its current problems.</p>
<p>I plan to write more about the implementation of the Pentium&#39;s PLA, the adder, and the test circuitry. Until then, 
you may enjoy reading about the <a href="https://www.righto.com/2024/08/pentium-navajo-fairchild-shiprock.html">Pentium Navajo rug</a>.
(The rug represents the P54C variant of the Pentium, so it is safe from the FDIV bug.)
Thanks to Bob Colwell and Ken Shoemaker for helpful discussions.</p>

<div>
<ol>
<li id="fn:dham">
<p>The book <a href="https://amzn.to/4gcXzVS">Inside Intel</a> says that Vin Dham, the &#34;Pentium czar&#34;, found the FDIV problem in May 1994.
The book &#34;The Pentium Chronicles&#34; says that Patrice Roussel, the floating-point architect for Intel&#39;s upcoming Pentium Pro processor, found the FDIV problem in Summer 1994.
I suspect that the bug was kept quiet inside Intel and was discovered more than once. <a href="#fnref:dham" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:prime">
<p>The divisor being a prime number has nothing to do with the bug. It&#39;s just a coincidence that the problem was found during research with prime numbers. <a href="#fnref:prime" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:timeline">
<p>See Nicely&#39;s <a href="https://faculty.lynchburg.edu/~nicely/#PENT">FDIV page</a> for more information on the bug and its history.
Other sources are the books <a href="https://amzn.to/4gAD1pM">Creating the Digital Future</a>, <a href="https://amzn.to/4gl8mx9">The Pentium Chronicles</a>, and <a href="https://amzn.to/4gcXzVS">Inside Intel</a>.
The New York Times wrote about the bug: <a href="https://www.nytimes.com/1994/11/24/business/company-news-flaw-undermines-accuracy-of-pentium-chips.html">Flaw Undermines Accuracy of Pentium Chips</a>.
Computerworld wrote <a href="https://books.google.com/books?id=LbKf4ilmW8EC&amp;pg=PA1">Intel Policy Incites User Threats</a> on threats of a class-action lawsuit.
IBM&#39;s response is described in <a href="https://www.nytimes.com/1994/12/13/us/ibm-deals-blow-to-a-rival-as-it-suspends-pentium-sales.html">IBM Deals Blow to a Rival as it Suspends Pentium Sales</a> <a href="#fnref:timeline" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:letterman">
<p>Talk show host David Letterman <a href="http://lists.sigcis.org/pipermail/members-sigcis.org/2020-August/007088.html">joked</a> about the Pentium on <a href="https://groups.google.com/g/comp.sys.intel/c/xivOgqcUrS8/m/sODzYaJZzWMJ">December 15</a>: &#34;You know what goes great with those defective Pentium chips? Defective Pentium salsa!&#34; Although a list of Letterman-style <a href="https://groups.google.com/g/aus.jokes/c/72sZitg-bTY/m/LCMN-LRD6egJ">top ten Pentium slogans</a> circulated, the list was a Usenet creation.
There&#39;s a <a href="https://historyofcomputers.eu/hardware/the-pentium-fdiv-bug-when-math-became-a-stand-up-comedy-act/">claim</a> that Jay Leno also joked about the Pentium, but I haven&#39;t found verification. <a href="#fnref:letterman" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:errata">
<p>Processors have many more bugs than you might expect.
Intel&#39;s 1995 errata list for the Pentium had &#34;21 errata (including the FDIV problem), 4 changes, 16 clarifications, and 2 documentation changes.&#34; See <a href="https://ardent-tool.com/CPU/docs/Intel/Pentium/spec_update/242480-022.pdf">Pentium Processor Specification Update</a> and <a href="https://websrv.cecs.uci.edu/~papers/mpr/MPR/ARTICLES/090303.pdf">Intel Releases Pentium Errata List</a>. <a href="#fnref:errata" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
<li id="fn:apology">
<p>Intel published full-page newspaper ads apologizing for its handling of the problem, stating: &#34;What Intel continues to believe is an extremely minor technical problem has taken on a life of its own.&#34;</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/apology.jpg"><img alt="Intel&#39;s apology letter, published in Financial Times. Note the UK country code in the phone number." height="771" src="https://static.righto.com/images/pentium-fdiv/apology-w500.jpg" title="Intel&#39;s apology letter, published in Financial Times. Note the UK country code in the phone number." width="500"/></a></p><p>Intel&#39;s apology letter, published in <a href="https://archive.org/details/FinancialTimes1994UKEnglish/Dec%2022%201994%2C%20Financial%20Times%2C%20%2322%2C%20UK%20%28en%29/page/n4/mode/1up">Financial Times</a>. Note the UK country code in the phone number.</p>
<p><!-- --> <a href="#fnref:apology" title="Jump back to footnote 6 in the text">↩</a></p>
</li>
<li id="fn:coe">
<p>Tim Coe&#39;s reverse engineering of the Pentium divider was described on the Usenet group <a href="https://groups.google.com/g/comp.sys.intel/c/L1KDE1d_ZLA/m/7rydJksrVTcJ">comp.sys.intel</a>, archived <a href="https://daviddeley.com/pentbug/tim_coe.txt">here</a>.
To summarize, Andreas Kaiser found 23 failing reciprocals.
Tim Coe determined that most of these failing reciprocals were of the form 3*(2^(K+30)) - 1149*(2^(K-(2*J))) - delta*(2^(K-(2*J))).
He recognized that the factor of 2 indicated a radix-4 divider.
The extremely low probability of error indicated the presence of a carry save adder; the odds of both the sum and carry bits getting long patterns of ones were very low.
Coe constructed a simulation of the divider that matched the Pentium&#39;s behavior and noted which table entries must be faulty. <a href="#fnref:coe" title="Jump back to footnote 7 in the text">↩</a></p>
</li>
<li id="fn:papers">
<p>The main papers on the FDIV bug are <a href="https://people.cs.vt.edu/~naren/Courses/CS3414/assignments/pentium.pdf">Computational Aspects of the Pentium Affair</a>, <a href="https://doi.org/10.1109/ARITH.1995.465365">It Takes Six Ones to Reach a Flaw</a>,
<a href="https://www.jstor.org/stable/2133004">The Mathematics of the Pentium Division Bug</a>, <a href="https://web.archive.org/web/20060209005434/http://www.byte.com/art/9503/sec13/art1.htm">The Truth Behind the Pentium Bug</a>,  <a href="http://link.springer.com/10.1007/3-540-59293-8_189">Anatomy of the Pentium Bug</a>, and <a href="http://boole.stanford.edu/pentium.html">Risk Analysis of the Pentium Bug</a>.
Intel&#39;s whitepaper is <a href="https://www.ardent-tool.com/CPU/Intel/fdiv/white11.pdf">Statistical Analysis of Floating Point Flaw in the Pentium Processor</a>; I archived IBM&#39;s study <a href="https://righto.com/files/IBM_study.txt">here</a>. <a href="#fnref:papers" title="Jump back to footnote 8 in the text">↩</a></p>
</li>
<li id="fn:ieee754">
<p>The Pentium uses floating point numbers that follow the IEEE 754 standard.
Internally, floating point numbers are represented with 80 bits: 1 bit for the sign, 15 bits for the exponent, and 64 bits for the significand.
Externally, floating point numbers are 32-bit single-precision numbers or 64-bit double-precision numbers.
Note that the number of significand bits limits the accuracy of a floating-point number. <a href="#fnref:ieee754" title="Jump back to footnote 9 in the text">↩</a></p>
</li>
<li id="fn:srt-history">
<p>The SRT division algorithm is named after the three people who independently created it in 1957-1958: Sweeney at IBM, Robertson at the University of Illinois, and Tocher at Imperial College London.
The SRT algorithm was developed further by Atkins in his <a href="https://www.osti.gov/biblio/4157138">PhD research</a> (1970).</p>
<p>The SRT algorithm became more practical in the 1980s as chips became denser.
Taylor <a href="https://www.doi.org/10.1109/ARITH.1981.6159293">implemented</a> the SRT algorithm on a board with 150 chips in 1981. The IEEE floating point standard (1985) led to a market for faster floating point circuitry.
For instance, the Weitek 4167 floating-point coprocessor chip (1989) was designed for use with the Intel 486 CPU (<a href="http://www.bitsavers.org/components/weitek/dataSheets/4167_Floating-Point_Coprocessor_Jul89.pdf">datasheet</a>)
and described in <a href="https://www.ece.ucdavis.edu/~vojin/CLASSES/EPFL/Papers/4-Fandrianto_division_ARITH8.pdf">an influential paper</a>.
Another important SRT implementation is the MIPS R3010 (1988), the coprocessor for the R3000 RISC processor.
The MIPS R3010 uses radix-4 SRT for division with 9 bits from the partial remainder and 9 bits from the divisor, making for a larger lookup table and adder than the Pentium
(<a href="https://doi.org/10.1109/40.540">link</a>).</p>
<p>To summarize, when Intel wanted to
make division faster on the Pentium (1993), the SRT algorithm was a reasonable choice.
Competitors had already implemented SRT and multiple papers explained how SRT worked.
The implementation should have been straightforward and bug-free. <a href="#fnref:srt-history" title="Jump back to footnote 10 in the text">↩</a></p>
</li>
<li id="fn:dimensions">
<p>The dimensions of the lookup table can&#39;t be selected arbitrarily.
In particular, if the table is too small, a cell may need to hold two different q values, which isn&#39;t possible.
Note that constructing the table is only possible due to the redundancy of SRT.
For instance, if some values in the call require q=1 and other values require q=1 or 2, then the value q=1 can be assigned to the cell. <a href="#fnref:dimensions" title="Jump back to footnote 11 in the text">↩</a></p>
</li>
<li id="fn:intel-pla">
<p>In the white paper, Intel calls the PLA a Programmable Lookup Array, but that&#39;s an error; it&#39;s a Programmable <em>Logic</em> Array. <a href="#fnref:intel-pla" title="Jump back to footnote 12 in the text">↩</a></p>
</li>
<li id="fn:pla">
<p>I&#39;ll explain a PLA in a bit more detail in this footnote.
An example of a sum-of-products formula with inputs a and b is ab&#39; + a&#39;b + ab.
This formula has three sum terms, so it requires three rows in the PLA.
However, this formula can be reduced to a + b, which uses a smaller two-row PLA.
Note that any formula can be trivially expressed with a
separate product term for each 1 output in the truth table.
The hard part is optimizing the PLA to use fewer terms. The original PLA patent is probably <a href="https://patents.google.com/patent/US3702985A">MOS Transistor Integrated Matrix</a> from 1969. <a href="#fnref:pla" title="Jump back to footnote 13 in the text">↩</a></p>
</li>
<li id="fn:rom">
<p>A ROM and a PLA have many similarities.
You can implement a ROM with a PLA by using the AND terms to decode addresses and the OR terms to hold the data.
Alternatively, you can replace a PLA with a ROM by putting the function&#39;s truth table into the ROM.
ROMs are better if you want to hold arbitrary data that doesn&#39;t have much structure (such as the microcode ROMs).
PLAs are better if the functions have a lot of underlying structure.
The key theoretical difference between a ROM and a PLA is that a ROM activates exactly one row at a time, corresponding to the address, while a PLA may activate one row, no rows, or multiple rows at a time.
Another alternative for representing functions is to use logic gates directly (known as random logic); moving from the 286 to the 386, Intel replaced many small PLAs with logic gates, enabled by improvements in the standard-cell software.
Intel&#39;s design process is described in <a href="https://www.researchgate.net/publication/268005718_Coping_with_the_Complexity_of_Microprocessor_Design_at_Intel_-_A_CAD_History">Coping with the Complexity of Microprocessor Design</a>. <a href="#fnref:rom" title="Jump back to footnote 14 in the text">↩</a></p>
</li>
<li id="fn:espresso">
<p>In 1982, Intel developed a program called LOGMIN to automate PLA design.  The original LOGMIN used an
exhaustive exponential search, limiting its usability.
See <a href="https://doi.org/10.1109/DAC.1982.1585495">A Logic Minimizer for VLSI PLA Design</a>.
For the <a href="https://www.youtube.com/watch?v=LQcLhBZY12g&amp;t=1700s">386</a>, Intel used <a href="https://en.wikipedia.org/wiki/Espresso_heuristic_logic_minimizer">Espresso</a>, a heuristic PLA minimizer that originated at IBM and was
developed at UC Berkeley.
Intel probably used Espresso for the Pentium, but I can&#39;t confirm that. <a href="#fnref:espresso" title="Jump back to footnote 15 in the text">↩</a></p>
</li>
<li id="fn:split">
<p>The Pentium&#39;s PLA is split into a top half and a bottom half, so you might expect the top half would generate a quotient of 1 and the bottom half would generate a quotient of 2.
However, the rows for the two quotients are shuffled together with no apparent pattern.
I suspect that the PLA minimization software generated the order arbitrarily. <a href="#fnref:split" title="Jump back to footnote 16 in the text">↩</a></p>
</li>
<li id="fn:demorgan">
<p>Conceptually, the PLA consists of AND gates feeding into OR gates.
To simplify the implementation, both layers of gates are actually NOR gates.
Specifically, if any transistor in a row turns on, the row will be pulled to ground, producing
a zero.
De Morgan&#39;s laws show that the two approaches are the same, if you invert the inputs and outputs.
I&#39;m ignoring this inversion in the diagrams.</p>
<p>Note that each square can form a transistor on the left, the right, or both.
The image must be examined closely to distinguish these cases. 
Specifically, if the polysilicon line produces a transistor, horizontal lines are visible in
the polysilicon. If there are no horizontal lines, the polysilicon passes by without creating
a transistor. <a href="#fnref:demorgan" title="Jump back to footnote 17 in the text">↩</a></p>
</li>
<li id="fn:outputs">
<p>Each OR plane has four outputs, so there are eight outputs in total. These outputs are
combined
with logic gates to generate the desired two outputs (quotient of 1 or 2).
I&#39;m not sure why the PLA is implemented in this fashion.
Each row alternates between an output on the left and an output on the right, but I don&#39;t
think this makes the layout any denser.
As far as I can tell, the extra outputs just waste space.
One could imagine combining the outputs in a clever way to reduce the number of terms, but
instead the outputs are simply OR&#39;d together. <a href="#fnref:outputs" title="Jump back to footnote 18 in the text">↩</a></p>
</li>
<li id="fn:chaos">
<p>The dynamics of the division algorithm are interesting.
The computation of a particular division will result in the partial remainder bouncing from
table cell to table cell, while remaining in one column of the table.
I expect this could be analyzed in terms of chaotic dynamics.
Specifically, the partial remainder interval is squished down by the subtraction and then
expanded when multiplied by 4.
This causes low-order bits to percolate upward so the result is exponentially sensitive to initial conditions.
I think that the division behavior satisfies the definition of chaos in <a href="https://mathscinet.ams.org/mathscinet/relay-station?mr=1010233">Dynamics of Simple Maps</a>, but I haven&#39;t investigated this in detail.</p>
<p>You can see this chaotic behavior with a base-10 division, e.g.
compare 1/3.0001 to 1/3.0002:
</p>
<p>I tried to make a fractal out of the SRT algorithm and came up with the image below. There
are 5 bands for convergence, each made up of 5 sub-bands, each made up of 5 sub-sub bands, and so on, corresponding to the 5 q values.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/fractal.jpg"><img alt="A fractal showing convergence or divergence of SRT division as the scale factor (X-axis) ranges from the normal value of 4 to infinity. The Y-axis is the starting partial remainder. The divisor is (arbitrarily) 1.5. Red indicates convergence; gray is darker as the value diverges faster." height="500" src="https://static.righto.com/images/pentium-fdiv/fractal-w500.jpg" title="A fractal showing convergence or divergence of SRT division as the scale factor (X-axis) ranges from the normal value of 4 to infinity. The Y-axis is the starting partial remainder. The divisor is (arbitrarily) 1.5. Red indicates convergence; gray is darker as the value diverges faster." width="500"/></a></p><p>A fractal showing convergence or divergence of SRT division as the scale factor (X-axis) ranges from the normal value of 4 to infinity. The Y-axis is the starting partial remainder. The divisor is (arbitrarily) 1.5. Red indicates convergence; gray is darker as the value diverges faster.</p>
<p><!-- --> <a href="#fnref:chaos" title="Jump back to footnote 19 in the text">↩</a></p>
</li>
<li id="fn:bound">
<p>The algebra behind the bound of 8/3 is that <em>p</em> (the partial remainder) needs to be in an interval that stays the same size each step.
Each step of division computes <em>p<sub>new</sub> =  (p<sub>old</sub> - q*d)*4</em>.
Thus, at the boundary, with <em>q=2</em>, you have <em>p = (p-2*d)*4</em>, so <em>3p=8d</em> and thus <em>p/d</em> = 8/3.
Similarly, the other boundary, with <em>q=-2</em>, gives you <em>p/d</em> = -8/3. <a href="#fnref:bound" title="Jump back to footnote 20 in the text">↩</a></p>
</li>
<li id="fn:8bit">
<p>I&#39;m not completely happy with the 8-bit carry-lookahead adder.
Coe&#39;s mathematical analysis in 1994 showed that the carry-lookahead adder operates on 7 bits.
The adder in the Pentium has two 8-bit inputs connected to another part of the division circuit.
However, the adder&#39;s bottom output bit is not connected to anything.
That would suggest that the adder is adding 8 bits and then truncating to 7 bits, which would
reduce the truncation error compared to a 7-bit adder.
However, when I simulate the division algorithm this way, the FDIV bug doesn&#39;t occur.
Wiring the bottom input bits to 0 would explain the behavior, but that seems pointless.
I haven&#39;t examined the circuitry that feeds the adder, so I don&#39;t have a conclusive answer. <a href="#fnref:8bit" title="Jump back to footnote 21 in the text">↩</a></p>
</li>
<li id="fn:testing">
<p>Half of the circuitry in the adder block is used to test the lookup table.
The reason is that
a chip such as the Pentium is very difficult to test: if one out of 3.1 million transistors goes bad, how do you detect it?  For a simple processor like the 8080, you can run through the instruction set and be fairly confident that any problem would turn up.
But with a complex chip, it
is almost impossible to come up with an instruction sequence that would test every bit of the microcode ROM, every bit of the cache, and so forth.
Starting with the 386, Intel added circuitry to the processor solely to make testing easier; about 2.7% of the transistors in the 386 were for testing.</p>
<p>To test a ROM inside the processor, Intel added circuitry to scan the entire ROM and checksum its contents.
Specifically, a pseudo-random number generator runs through each address, while another circuit computes a checksum of the ROM output, forming a &#34;signature&#34; word.
At the end, if the signature word has the right value, the ROM is almost certainly correct.
But if there is even a single bit error, the checksum will be wrong and the chip will be rejected.
The pseudo-random numbers and the checksum are both implemented with linear feedback shift registers (LFSR), a shift register along with a few XOR gates to feed the output back to the input.
For more information on testing circuitry in the 386, see <a href="https://doi.org/10.1109/MDT.1987.295165">Design and Test of the 80386</a>,
written by Pat Gelsinger, who became Intel&#39;s CEO years later.
Even with the test circuitry, 48% of the transistor sites in the 386 were untested.
The instruction-level test suite to test the remaining circuitry took almost 800,000 clock cycles to run.
The overhead of the test circuitry was about 10% more transistors in the blocks that were tested.</p>
<p>In the Pentium, the circuitry to test the lookup table PLA is just below the 7-bit adder.
An 11-bit LFSR creates the 11-bit input value to the lookup table.
A 13-bit LFSR hashes the two-bit quotient result from the PLA, forming a 13-bit checksum.
The checksum is fed serially to test circuitry elsewhere in the chip, where it is merged with
other test data and written to a register. If the register is 0 at the end, all the tests pass.
In particular, if the checksum is correct, you can be 99.99% sure that the lookup table
is operating as expected.
The ironic thing is that this test circuit was useless for the FDIV bug: it ensured that the lookup table held the intended values, but the intended values were wrong.</p>
<p>Why did Intel generate test addresses with a pseudo-random sequence instead of a sequential
counter?
It turns out that a linear feedback shift register (LFSR) is slightly more compact than a
counter.
This LFSR trick was also used in a <a href="https://www.righto.com/2017/08/inside-fake-ram-chip-i-found-something.html">touch-tone chip</a> and the program counter of the Texas Instruments TMS 1000 microcontroller (1974).
In the TMS 1000, the program counter steps through the
program pseudo-randomly rather than sequentially.
The program is shuffled appropriately in the ROM to counteract the
sequence, so the program executes as expected and a few transistors are saved. <a href="#fnref:testing" title="Jump back to footnote 22 in the text">↩</a></p>
</li>
<li id="fn:bicmos">
<p>One unusual feature of the Pentium is that it uses BiCMOS technology: both bipolar and CMOS transistors.
Note the distinctive square boxes in the driver circuitry; these are bipolar transistors, part of the high-speed drivers.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/bipolar.jpg"><img alt="Three bipolar transistors. These transistors transmit the quotient to the rest of
the division circuitry." height="269" src="https://static.righto.com/images/pentium-fdiv/bipolar-w350.jpg" title="Three bipolar transistors. These transistors transmit the quotient to the rest of
the division circuitry." width="350"/></a></p><p>Three bipolar transistors. These transistors transmit the quotient to the rest of
the division circuitry.</p>
<p><!-- --> <a href="#fnref:bicmos" title="Jump back to footnote 23 in the text">↩</a></p>
</li>
<li id="fn:64-bits">
<p>I think the partial remainder is actually 67 bits because there are three extra bits
to handle rounding. Different parts of the floating-point datapath have different widths, depending on
what width is needed at that point. <a href="#fnref:64-bits" title="Jump back to footnote 24 in the text">↩</a></p>
</li>
<li id="fn:heatmaps">
<p>In this long footnote, I&#39;ll attempt to explain why the FDIV bug is so rare, using heatmaps.
My analysis of Intel&#39;s lookup table shows several curious factors that almost cancel out, making failures rare but not impossible.
(For a rigorous explanation, see <a href="https://doi.org/10.1109/ARITH.1995.465365">It Takes Six Ones to Reach a Flaw</a> and 
<a href="https://www.jstor.org/stable/2133004">The Mathematics of the Pentium Division Bug</a>.
These papers explain that, among other factors, a bad divisor must have six consecutive ones in positions 5 through 10 and
the division process must go through nine specific steps, making a bad result extremely uncommon.)</p>
<p>The diagram below shows a heatmap of how often each table cell is accessed when simulating
a generic SRT algorithm with a carry-save adder.
The black lines show the boundaries of the quotient regions in the Pentium&#39;s lookup table.
The key point is that the top colored cell in each column is above the black line, so some table cells
are accessed but are not defined in the Pentium.
This shows that the Pentium is missing 16 entries, not just the 5 entries that are usually discussed.
(For this simulation, I generated the
quotient digit directly from the SRT bounds, rather than the lookup table, selecting the digit randomly in the redundant regions.)</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/statsn-c-b-18.jpg"><img alt="A heatmap showing the table cells accessed by an SRT simulation." height="421" src="https://static.righto.com/images/pentium-fdiv/statsn-c-b-18-w350.jpg" title="A heatmap showing the table cells accessed by an SRT simulation." width="350"/></a></p><p>A heatmap showing the table cells accessed by an SRT simulation.</p>
<p>The diagram is colored with a logarithmic color scale. The blue cells are accessed
approximately uniformly. The green cells at the boundaries are accessed about 2 orders of
magnitude less often. The yellow-green cells are accessed about 3 orders of magnitude less
often. The point is that it is hard to get to the edge cells since you need to start in
the right spot and get the right quotient digit, but it&#39;s not extraordinarily hard.</p>
<p>(The diagram also shows an interesting but ultimately unimportant feature of the Pentium table:
at the bottom of the diagram, five white cells are above the back line.
This shows that the Pentium assigns values to five table cells that can&#39;t be accessed.
(This was also mentioned in &#34;The Mathematics of the Pentium Bug&#34;.)
These cells are in the same columns as the 5 missing cells, so it would be interesting if
they were related to the missing cells. But as far as I can tell, the extra cells are due
to using a bound of &#34;greater or equals&#34; rather than &#34;greater&#34;, unrelated to the
missing cells. In any case, the extra cells are harmless.)</p>
<p>The puzzling factor is that if the Pentium table has 16 missing table cells,
and the SRT uses these cells fairly often, you&#39;d expect maybe 1 division out of 1000 or so to
be wrong. So why are division errors extremely rare?</p>
<p>It turns out that the structure of the Pentium lookup table makes some table cells inaccessible.
Specifically, the table is arbitrarily biased to pick the higher quotient digit rather than the lower
quotient digit in the redundant regions.
This has the effect of subtracting more from the partial remainder, pulling the partial remainder
away from the table edges.
The diagram below shows a simulation using the Pentium&#39;s lookup table and
no carry-save adder.
Notice that many cells inside the black lines are white,
indicating that they are never accessed.
This is by coincidence, due to arbitrary decisions when constructing in the lookup table.
Importantly, the missing cells just above the black line are never accessed, so the missing cells
shouldn&#39;t cause a bug.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/statsn-p-18.jpg"><img alt="A heatmap showing the table cells accessed by an SRT simulation using the Pentium&#39;s lookup table but no carry-save adder." height="422" src="https://static.righto.com/images/pentium-fdiv/statsn-p-18-w350.jpg" title="A heatmap showing the table cells accessed by an SRT simulation using the Pentium&#39;s lookup table but no carry-save adder." width="350"/></a></p><p>A heatmap showing the table cells accessed by an SRT simulation using the Pentium&#39;s lookup table but no carry-save adder.</p>
<p>Thus, Intel almost got away with the missing table entries. Unfortunately, the carry-save
adder makes it possible to reach some of the otherwise inaccessible cells. Because the output from
the carry-save adder is truncated, the algorithm can access the table cell below the
&#34;right&#34; cell. In the redundant regions, this can yield a different (but still valid) quotient
digit, causing the next partial remainder to end up in a different cell than usual.
The heatmap below shows the results.</p>
<p><a href="https://static.righto.com/images/pentium-fdiv/statsn-c-p-merge.jpg"><img alt="A heatmap showing the probability of ending up in each table cell when using the Pentium&#39;s division algorithm." height="419" src="https://static.righto.com/images/pentium-fdiv/statsn-c-p-merge-w350.jpg" title="A heatmap showing the probability of ending up in each table cell when using the Pentium&#39;s division algorithm." width="350"/></a></p><p>A heatmap showing the probability of ending up in each table cell when using the Pentium&#39;s division algorithm.</p>
<p>In particular, five cells above the black line can be reached: these are instances of the
FDIV bug. These cells are orange, indicating that they are about 9 orders of magnitude less
likely than the rest of the cells.
It&#39;s almost impossible to reach these cells, requiring multiple &#34;unlucky&#34; values in a row from
the carry-save adder.
To summarize, the Pentium lookup table has 16 missing cells. Purely by coincidence, the choices
in the lookup table make many cells inaccessible, which almost counteracts the problem. However,
the carry-save adder provides a one-in-a-billion path to five of the missing cells, triggering
the FDIV bug.</p>
<p>One irony is that if division errors were more frequent, Intel would have caught the FDIV bug before shipping.
But if division errors were substantially less frequent, no customers would have noticed the bug.
Inconveniently, the frequency of errors fell into the intermediate zone: errors were too rare for Intel to spot them, but frequent enough for a single user to spot them.
(This makes me wonder what other astronomically infrequent errors may be lurking in processors.) <a href="#fnref:heatmaps" title="Jump back to footnote 25 in the text">↩</a></p>
</li>
<li id="fn:bounds">
<p><a href="https://link.springer.com/chapter/10.1007/3-540-59293-8_189">Anatomy of the Pentium Bug</a> reached a similar conclusion, stating &#34;The [Intel]  White Paper attributes the error to a script that incorrectly copied values; one is nevertheless tempted to wonder whether the rule for lowering thresholds was applied to the 8D/3 boundary, which would be an incorrect application because that boundary is serving to bound a threshold from below.&#34;
(That paper also hypothesizes that the table was compressed to 6 columns, a hypothesis that my examination of the die disproves.) <a href="#fnref:bounds" title="Jump back to footnote 26 in the text">↩</a></p>
</li>
<li id="fn:script">
<p>The Intel white paper describes the underlying cause of the bug: &#34;After the quantized P-D plot (lookup table) was numerically generated as in Figure 4-1, a script was written to download the entries into a hardware PLA (Programmable Lookup Array).
An error was made in this script that resulted in a few lookup entries (belonging to the positive plane of the P-D plot) being omitted from the PLA.&#34; The script explanation is repeated in <a href="https://web.archive.org/web/20060209005434/http://www.byte.com/art/9503/sec13/art1.htm">The Truth Behind the Pentium Bug</a>: &#34;An engineer prepared the lookup table on a computer and wrote a script in C to download it into a PLA (programmable logic array) for inclusion in the Pentium&#39;s FPU.
Unfortunately, due to an error in the script, five of the 1066 table entries were not downloaded.
To compound this mistake, nobody checked the PLA to verify the table was copied correctly.&#34;
My analysis suggests that the table was copied correctly; the problem was that the table was
mathematically wrong. <a href="#fnref:script" title="Jump back to footnote 27 in the text">↩</a></p>
</li>
<li id="fn:legends">
<p>It&#39;s not hard to find claims of people encountering the Pentium division bug, but these seem
to be in the &#34;urban legend&#34; category. Either the problem is described second-hand, or the problem
is unrelated to division, or the problem happened much too frequently to be the FDIV bug.
It has been <a href="https://youtu.be/E2MIpi8pIvY?t=1511">said</a> that the game Quake would occasionally show the
wrong part of a level due to the FDIV bug, but I find that implausible. 
<a href="https://archive.org/details/1995-01-01_W5YI_Report/page/n8/mode/1up">The &#34;Intel Inside—Don&#39;t Divide&#34; Chipwreck</a> describes how the division bug was blamed for everything from database and application server crashes
to gibberish text. <a href="#fnref:legends" title="Jump back to footnote 28 in the text">↩</a></p>
</li>
<li id="fn:ibm">
<p>IBM&#39;s analysis of the error rate seems contrived, coming up with reasons to use numbers that are
likely to cause errors.
In particular, IBM focuses on slightly truncated numbers, either numbers with two decimal digits or
hardcoded constants.
Note that a slightly truncated number is much more likely to hit a problem because
its binary representation will have multiple 1&#39;s in a row, a necessity to trigger the bug.
Another paper <a href="http://boole.stanford.edu/pentium.html">Risk Analysis of the Pentium Bug</a> claims a risk of one in every 200 divisions.
It depends on &#34;bruised integers&#34;, such as 4.999999, which are similarly contrived.
I&#39;ll also point out that if you start with numbers that are &#34;bruised&#34; or otherwise corrupted, you obviously don&#39;t care about floating-point accuracy and shouldn&#39;t complain if the Pentium adds slightly more inaccuracy.</p>
<p>The book &#34;Inside Intel&#34; says that &#34;the IBM analysis was quite wrong&#34; and &#34;IBM&#39;s intervention in the Pentium affair was not an example of the company on its finest behavior&#34; (page 364). <a href="#fnref:ibm" title="Jump back to footnote 29 in the text">↩</a></p>
</li>
<li id="fn:f00f">
<p>The F00F bug happens when an invalid compare-and-exchange instruction leaves the bus locked.
The instruction is supposed to exchange with a memory location, but the invalid instruction specifies a register instead causing unexpected behavior.
This is very similar to some undocumented instructions in the 8086 processor where a register is specified when memory is required;
see my article <a href="https://www.righto.com/2023/07/undocumented-8086-instructions.html">Undocumented 8086 instructions, explained by the microcode</a>. <a href="#fnref:f00f" title="Jump back to footnote 30 in the text">↩</a></p>
</li>
<li id="fn:patchable">
<p>For details on the Pentium Pro&#39;s patchable microcode, see <a href="https://www.ele.uva.es/~jesman/BigSeti/ftp/Cajon_Desastre/MPR/111204.pdf">P6 Microcode Can Be Patched</a>.
But patchable microcode dates back much earlier.
The IBM System/360 mainframes (1964) had microcode that could be updated in the field,
either to fix bugs or to implement new features.
These systems stored microcode on metalized Mylar sheets that could be replaced as necessary.
In that era, semiconductor ROMs didn&#39;t exist, so Mylar sheets were also a cost-effective way to
implement read-only storage.
See <a href="https://www.righto.com/2019/11/tros-how-ibm-mainframes-stored.html">TROS: How IBM mainframes stored microcode in transformers</a>. <a href="#fnref:patchable" title="Jump back to footnote 31 in the text">↩</a></p>
</li>
</ol>
</div>

</div></div>
  </body>
</html>
