<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://avi.im/blag/2025/sqlite-fsync/">Original</a>
    <h1>SQLite commits are not durable under default settings</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>Previously, I claimed that transactions in SQLite with WAL are not durable under default settings. Turns out, I was only half wrong but technically correct; the issue is actually with SQLite in rollback journal mode (the default). This post is now amended with the changes.</p><p>Here‚Äôs what I mean by durability: when the database acknowledges that a transaction is committed, it‚Äôs ‚Äòdurably‚Äô saved to disk. That is, neither an application crash nor an OS crash should make that transaction disappear. Imagine you make a new commit, the db acknowledges success, and suddenly your OS reboots. Do you expect your transaction changes to be persisted? For example, in Postgres you can expect your changes to be there. This is how most OLTP databases behave.</p><h2 id="sqlite-journal-mode">SQLite Journal Mode</h2><p>Under the default settings, SQLite operates in rollback journal mode. SQLite also has a PRAGMA called <code>synchronous</code> which configures how <code>fsync</code> is called. The synchronous setting has many modes: <code>OFF</code>, <code>NORMAL</code>, <code>FULL</code>, <code>EXTRA</code>. The default is set to <code>FULL</code>:</p><pre tabindex="0"><code>$ sqlite3 test.db

SQLite version 3.50.4 2025-07-30 19:33:53
Enter &#34;.help&#34; for usage hints.
sqlite&gt; PRAGMA journal_mode;
delete
sqlite&gt; PRAGMA synchronous;
2
</code></pre><p>Unfortunately, in journal mode, <code>FULL</code> isn‚Äôt enough to make transactions durable. Here‚Äôs what the documentation states:</p><blockquote><p><strong>EXTRA (3)</strong>
EXTRA synchronous is like FULL with the addition that the directory containing a rollback journal is synced after that journal is unlinked to commit a transaction in DELETE mode. <strong>EXTRA provides additional durability if the commit is followed closely by a power loss.</strong></p></blockquote><blockquote><p><strong>FULL (2)</strong>
When synchronous is FULL (2), the SQLite database engine will use the xSync method of the VFS to ensure that all content is safely written to the disk surface prior to continuing. This ensures that an operating system crash or power failure will not corrupt the database.</p></blockquote><p>Notice that it says <code>FULL</code> ensures that the database isn‚Äôt corrupted, but NOT that the last transaction is durable. The highlighted part in <code>EXTRA</code> provides that durability.</p><h2 id="sqlite-with-wal">SQLite with WAL</h2><p>SQLite also has a WAL mode, and you‚Äôre likely using it if you want higher write throughput. The <code>synchronous</code> PRAGMA also applies to WAL. The default is <code>FULL</code>:</p><blockquote><p>With <code>synchronous=FULL</code> in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction helps ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by <code>synchronous=FULL</code>.</p></blockquote><p>However, <code>NORMAL</code> seems misnamed, as it doesn‚Äôt seem normal to me:</p><blockquote><p>[..] but WAL mode does lose durability. A transaction committed in WAL mode with <code>synchronous=NORMAL</code> might roll back following a power loss or system crash.</p></blockquote><blockquote><p>In WAL mode when synchronous is <code>NORMAL (1)</code>, the WAL file is synchronized before each checkpoint and the database file is synchronized after each completed checkpoint and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions.</p></blockquote><blockquote><p>If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</p></blockquote><p>So, if you‚Äôre using WAL, stick with <code>FULL</code>. If durability isn‚Äôt a concern, then <code>NORMAL</code> may be preferred for higher performance. While this is what the documentation says, <a href="https://news.ycombinator.com/item?id=45014296">DRH, the creator of SQLite, said the following</a> which contradicts the documentation:</p><blockquote><p>If you switch to WAL mode, the default behavior is that transactions are durable across application crashes (or SIGKILL or similar) but are not necessarily durable across OS crashes or power failures. Transactions are atomic across OS crashes and power failures. But if you commit a transaction in WAL mode and take a power loss shortly thereafter, the transaction might be rolled back after power is restored.</p></blockquote><p>I‚Äôll leave it up to you to decide which is correct ü§∑‚Äç‚ôÇÔ∏è</p><h2 id="sqlite-on-macos">SQLite on macOS</h2><p>The situation on macOS is quite fucked up. The SQLite shipped with macOS has the following:</p><pre tabindex="0"><code>$ sqlite3 test.db

SQLite version 3.43.2 2023-10-10 13:08:14
Enter &#34;.help&#34; for usage hints.
sqlite&gt; PRAGMA journal_mode=wal;
wal
sqlite&gt; PRAGMA synchronous;
1
sqlite&gt; PRAGMA fullfsync;
0
sqlite&gt;
</code></pre><p>That is, the default is <code>NORMAL</code>. So, commits are not durable. But even if you use <code>FULL</code>, it‚Äôs not enough. You‚Äôll want to <a href="https://www.sqlite.org/pragma.html#pragma_fullfsync">set <code>fullfsync</code></a> to true. This is false by default. Apparently, <a href="https://bonsaidb.io/blog/acid-on-apple/">Apple has purposely fucked up fsync</a> and you always want to use <code>fullfsync</code>. This setting has no effect on non-macOS machines.</p><h2 id="compile-time-options">Compile Time Options</h2><p>SQLite decides all this config through compile-time defaults:</p><blockquote><p><code>SQLITE_DEFAULT_SYNCHRONOUS=&lt;0-3&gt;</code> This macro determines the default value of the PRAGMA synchronous setting. If not overridden at compile-time, the default setting is 2 (FULL).</p></blockquote><blockquote><p><code>SQLITE_DEFAULT_WAL_SYNCHRONOUS=&lt;0-3&gt;</code> This macro determines the default value of the PRAGMA synchronous setting for database files that open in WAL mode. If not overridden at compile-time, this value is the same as <code>SQLITE_DEFAULT_SYNCHRONOUS</code>.</p></blockquote><p>There‚Äôs no compile-time option for fullfsync, so by default it‚Äôs false.</p><p>So it‚Äôs totally possible that your distribution might be shipping SQLite with default <code>synchronous</code> as <code>NORMAL</code>.</p><p>The lesson here should be that you should always check the setting and make sure it‚Äôs what you want. Here‚Äôs a small chart to help you set:</p><table><thead><tr><th>Journal Mode</th><th>Synchronous</th><th>fullfsync</th></tr></thead><tbody><tr><td><code>DELETE</code> (rollback)</td><td><code>EXTRA</code></td><td>1</td></tr><tr><td><code>WAL</code></td><td><code>FULL</code></td><td>1</td></tr></tbody></table><hr/><p><small>Thanks to all the people who commented and discussed the original version of this article on <a href="https://news.ycombinator.com/item?id=45005071">Hacker News</a>. Their comments helped me make this post better.</small></p><p><small>Someone passed me this post <a href="https://blog.cf8.gg/surrealdbs-ch/">SurrealDB is sacrificing data durability to make benchmarks look better</a> and asked me how SQLite works.</small></p></article></div></div>
  </body>
</html>
