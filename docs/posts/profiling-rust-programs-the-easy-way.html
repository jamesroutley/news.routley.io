<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/profiling-rust-programs-the-easy-way/">Original</a>
    <h1>Profiling Rust programs the easy way</h1>
    
    <div id="readability-page-1" class="page"><div><p>Performance is one of the big reasons to use Rust.
It&#39;s not a magic wand for performance, it just gives you the control to eke out whatever performance you need.
So if your program is still slow, how do you fix that?</p>
<p>Profiling your program is one of the best options for figuring out why it&#39;s slow and where you need to focus your improvement.
Without profiling, you&#39;re guessing blindly at where the problem may lie.
With a profile, you can see where most of the time is spent and focus your efforts.</p>
<p>There are a few ways to profile Rust programs, but my favorite is <a href="https://github.com/flamegraph-rs/flamegraph"><code>flamegraph</code></a> (also called <code>cargo-flamegraph</code>).
It&#39;s a wonderful tool that wraps around the standard profilers <a href="https://en.wikipedia.org/wiki/Perf_(Linux)">perf</a> (on Linux) and <a href="https://en.wikipedia.org/wiki/DTrace">dtrace</a> (on MacOS).</p>

<p>The basic usage of <code>flamegraph</code> is quite straightforward and their docs cover it well, but the amount of options can be daunting.
At its most basic, after you install it and dependencies, you can run it as a cargo command.
Here are a few of the invocations I use.</p>
<pre><code># Run your default target with no arguments
cargo flamegraph

# Run your default target with the arguments after --
cargo flamegraph -- arg1 arg2 arg3

# Run the specified bin target with arguments
cargo flamegraph -b mybin -- arg1 arg2 arg3

# Run your default target with arguments and save
# the results to a different filename
cargo flamegraph -o myoutput.svg -- arg1 arg2 arg3
</code></pre>
<p>You can mix and match these options to combine them.
Running one of these commands will produce a file, named <code>flamegraph.svg</code> unless you overrode the output filename.</p>
<p>After you generate that, you&#39;ll want to make sure the results are reasonable to get the results you need.
The output will tell you how much data it recorded and how many samples it took, something like this:</p>
<pre><code>[ perf record: Woken up 59 times to write data ]
[ perf record: Captured and wrote 14.706 MB perf.data (925 samples) ]
</code></pre>
<p>In this example, we have 925 samples which is probably reasonable to make progress on the big things.
How many samples you need will vary depending on your program, but I&#39;ve not found good results too far below 1,000, and far above that seems to make things really slow.
If you have big, sweeping inefficiencies, fewer samples will still catch them.
If they&#39;re relatively subtle and small gains, you may need many more samples.
It&#39;s an art to figure out how to tune the sample size.</p>
<p>To control how many samples you get, you have two options: you can change your program, or change the instrumentation.
Sampling is done at a particular frequency, so you can control the program duration and you can control the sampling frequency.
If you&#39;re getting very few samples, but you can make your program run for longer (larger input, multiple repetitions, etc.) then that can increase the samples you get.
The same applies in reverse for too many samples.
The other option is to change the instrumentation itself: you can use the <code>-F</code> argument to alter the frequency of sampling.</p>
<pre><code># Sample at a rate of 1997 samples per second
cargo flamegraph -F 1997 -- arg1 arg2 arg3
</code></pre>
<p>From here with a good sample, the work is now back to you, the programmer-analyst.
I like to open the SVG file in Firefox, which has a convenient viewer that allows you to zoom in and examine individual stacks of events.
But you can use any suitable SVG viewer.
You should be able to navigate around the <code>flamegraph</code> to see visually where CPU time is being spent and use that to concentrate your efforts.
For a stronger introduction to how to read and use a flamegraph, see the <a href="https://github.com/flamegraph-rs/flamegraph#systems-performance-work-guided-by-flamegraphs">flamegraph docs</a> which has a section dedicated to this.</p>

<p>While doing various profiling of my Rust programs, I&#39;ve hit a few gotchas that tripped me up.
Here are the ones I remember.
There are certainly more, so <a href="mailto:me@ntietz.com">let me know</a> if there&#39;s something I should add to this list!</p>
<ul>
<li><strong>Missing system calls.</strong> When the system under test spends a lot of time in system calls, those can lead to a misleading flamegraph if they aren&#39;t captured. Since system calls transfer control to the kernel, a standard user typically cannot measure themâ€”and perf is by default running as you! To get around that, you can have it sample as root. In <code>flamegraph</code> you would add the <code>--root</code> flag, which will use sudo to get privileges to sample everything including during system calls. This is especially important when you&#39;re doing anything with a lot of disk or network activity, otherwise the code calling those system calls may be missing and you will be on a wild goose chase!</li>
<li><strong>Optimizations hiding information.</strong> As stated in the <a href="https://github.com/flamegraph-rs/flamegraph#improving-output-when-running-with---release"><code>flamegraph</code> docs</a>, &#34;Due to optimizations etc... sometimes the quality of the information presented in the flamegraph will suffer when profiling release builds.&#34; To address this, you either set <code>debug = true</code> for your release target, or you can use the environment variable <code>CARGO_PROFILE_RELEASE_DEBUG=true</code>.</li>
<li><strong>Lockstep sampling.</strong> As Brendan Gregg <a href="https://www.brendangregg.com/blog/2014-06-22/perf-cpu-sample.html">points out</a>, sampling frequencies are set off from typical frequencies used by programs. If you use a frequency like 100Hz, you may end up on the same frequency of a repeating event in your program, resulting in sampling from the same point repeatedly instead of sampling from across the <em>entire</em> program. You can experiment with different frequencies and see if any of them result in notably better or worse results; if they&#39;re all about the same, then you&#39;re probably not in lockstep with your program.</li>
</ul>
<p>Now go forth and profile your programs!</p>
<hr/>


</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://techcrunch.com/newsletter">newsletter</a> or use the <a href="https://techcrunch.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
