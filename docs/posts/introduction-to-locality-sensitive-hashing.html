<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tylerneylon.com/a/lsh1/">Original</a>
    <h1>Introduction to Locality-Sensitive Hashing</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Introduction to Locality-Sensitive Hashing</p>
      
      <p>521.2018</p>
      <p>[Formats: <a href="http://tylerneylon.com/a/lsh1/lsh_post1.html">html</a> | <a href="http://tylerneylon.com/a/lsh1/lsh_post1.pdf">pdf</a> | <a href="http://tylerneylon.com/a/lsh1/lsh_post1_for_kindle.pdf">kindle pdf</a>]</p>
      <p><em>Locality-sensitive hashing</em> (LSH) is a set of techniques that dramatically speed up search-for-neighbors or near-duplication detection on data. These techniques can be used, for example, to filter out duplicates of scraped web pages at an impressive speed, or to perform near-constant-time lookups of nearby points from a geospatial data set.</p>
      <div>
      <p>Figure 1: A preview of LSH in action. Only hash collisions were used to find the weights in this image — no pairwise distances were explicitly computed.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/image8b@2x.gif" alt="Figure 1: A preview of LSH in action. Only hash collisions were used to find the weights in this image — no pairwise distances were explicitly computed." id="fig:fig0"/>
      </p></div>
      <p>Let’s take a quick look at other types of hash functions to get a bird’s-eye view of what counts as a <em>hash function</em>, and how LSH fits into that world. A traditional use for hash functions is in <em>hash tables</em>. As a reminder, the hash functions used in a hash table are designed to map a piece of data to an integer that can be used to look in a particular <em>bucket</em> within the hash table to retrieve or delete that element. Many containers with string keys, such as JavaScript objects or Python dictionaries, are based on hash tables. Although hash tables might not <em>guarantee</em> constant-time lookups, in practice they effectively provide them.</p>
      <p>There are other classes of hash functions as well. For example, the <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> cryptographic hash function is designed to be <em>difficult to reverse</em>, which is useful if you want to store someone’s password as a hashed value. Hash functions like these are called <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"><em>cryptographic hash functions</em></a>.</p>
      <p>Hash functions typically have these key properties:</p>
      <ul>
      <li>They map some type of input, such as strings or floats, to discrete values, such as integers.</li>
      <li>They’re designed so that two inputs will result in hash outputs that are either different or the same based on key properties of the inputs.</li>
      </ul>
      <p>Here’s how LSH fits in: Locality-sensitive hash functions are specifically designed so that hash value collisions are <em>more likely</em> for two input values that are <em>close together</em> than for inputs that are far apart. Just as there are different implementations of secure hash functions for different use cases, there are different implementations of LSH functions for different data types and for different definitions of being <em>close together</em>. I’ll use the terms <em>neighbors</em> or <em>being nearby</em> to refer to points that we deem “close enough” together that we’d want to notice their similarity. In this post, I’ll give a brief overview of the key ideas behind LSH and take a look at a simple example based on an idea called <em>random projections</em>, which I’ll define in section 2 below.</p>
      
      <p>It will probably be much easier to grasp the main idea behind LSH with an example you can relate to. This way we can build some intuition before diving into those random projections that we’ll use in the next section.</p>
      <p>Suppose you have a million people from across the United States all standing in a huge room. It’s your job to get people who live close together to stand in their own groups. Imagine how much time it would take to walk up to each person, ask for their street address, map that to a lat/long pair, then write code to find geographic clusters, and walk up to every person again and tell them how to find the rest of their cluster. I cringe just thinking about the time complexity.</p>
      <p>Here’s a much better way to solve this problem: Write every U.S. zip code on poster boards and hang those from the ceiling. Then tell everyone to go stand under the zip code where they live.</p>
      <p>Voila! That’s much easier, right? That’s also the main idea behind LSH. We’re taking an arbitrary data type (a person, who we can think of as a ton of data including their street address), and mapping that data into a set of discrete values (zip codes) such that people who live close together probably hash to the same value. In other words, the clusters (people with the same zip code) are very likely to be groups of neighbors.</p>
      <p>A nice benefit of the zip code approach is that it’s <em>parallel-friendly</em>. Instead of requiring a center of communication, every person can walk directly to their destination without further coordination. This is a bit surprising in light of the fact that the result (clusters of neighbors) is based entirely on the <em>relationships</em> between the inputs.</p>
      <p>Another property of this example is that it is <em>approximate</em>: some people may live across the street from each other, but happen to have different zip codes, in which case they would not be clustered together here. As we’ll see below, it’s also possible for data points to be clustered together even when they’re very far apart, although a well-designed LSH can at least give some mathematical evidence that this will be a rare event, and some implementations manage to guarantee this can never happen.</p>
      
      <p>In this section, I’ll explain exactly how a relatively straightforward LSH approach works, explore some key parameters for this LSH system, and review why this technique is an order of magnitude faster than some other approaches.</p>
      <p>Let’s start with an incredibly simple mathematical function that we can treat as an LSH. Define <span>\(h_1:{\mathbb{R}}^2 \to {\mathbb{Z}}\)</span> for a point <span>\(x=(x_1, x_2)\in{\mathbb{R}}^2\)</span> by</p>
      <p><span>\[ h_1(x) := \lfloor x_1 \rfloor; \]</span></p>
      <p>that is, <span>\(h_1(x)\)</span> is the largest integer <span>\(a\)</span> for which <span>\(a\le x_1.\)</span> For example, <span>\(h_1((3.2, -1.2)) = 3.\)</span></p>
      <p>Let’s suppose we choose points at random by uniformly sampling from the origin-centered circle <span>\(\mathcal C\)</span> with radius 4:</p>
      <p><span>\[ \mathcal C := \{ (x, y) : x^2 + y^2 \le 4^2 \}. \]</span></p>
      <p>Suppose we want to find which of our points in <span>\(\mathcal C\)</span> are close together. We can estimate this relationship by considering points <span>\(a, b \in \mathcal C\)</span> to be clustered together when <span>\(h_1(a) = h_1(b).\)</span> It will be handy to introduce the notation <span>\(a \sim b\)</span> to indicate that <span>\(a\)</span> and <span>\(b\)</span> are in the same cluster. With that notation, we can write our current hash setup as</p>
      <p><span>\[ a \sim b \iff h_1(a) = h_1(b). \]</span></p>
      <p>Figure 2 shows an example of such a clustering.</p>
      <div>
      <p>Figure 2: Twenty points chosen randomly in a circle with radius 4. Each point <span>\(x\)</span> is colored based on its hash value <span>\(h_1(x).\)</span></p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/lsh_image1_v2.png" alt="Figure 2: Twenty points chosen randomly in a circle with radius 4. Each point x is colored based on its hash value h_1(x)." id="fig:fig1"/>
      </p></div>
      <p>You can immediately see that some points are far apart yet clustered, while others are relatively close yet unclustered. There’s also a sense that this particular hash function <span>\(h_1\)</span> was arbitrarily chosen to focus on the x-axis. What would have happened with the same data if we had used instead <span>\(h_2(x) := \lfloor x_2 \rfloor?\)</span> The result is figure 3.</p>
      <div>
      <p>Figure 3: The same twenty points as figure 1, except that we’re using the <span>\(y\)</span> values (instead of <span>\(x\)</span> values) to determine the hash-based cluster colors this time around.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/lsh_image2.png" alt="Figure 3: The same twenty points as figure 1, except that we’re using the y values (instead of x values) to determine the hash-based cluster colors this time around." id="fig:fig2"/>
      </p></div>
      <p>While neither clustering alone is amazing, things start to work better if we use both of them simultaneously. That is, we can redefine our clustering via</p>
      <p><span id="eq:eq1"><span>\[ a \sim b \iff
      \begin{cases}
      h_1(a) = h_1(b), \text{and} \\
      h_2(a) = h_2(b). \\
      \end{cases} {\class{smallscrneg}{ }}\qquad(1)\]</span></span></p>
      <p>Our same example points are shown under this new clustering in figure 4.</p>
      <div>
      <p>Figure 4: The same twenty points clustered via two different hashes — one using <span>\(\lfloor x\rfloor\)</span>, the other using <span>\(\lfloor y\rfloor.\)</span> As before, points are colored based on which cluster they’re in; a cluster is the set of all points who share both their <span>\(\lfloor x\rfloor\)</span> and their <span>\(\lfloor y\rfloor\)</span> values.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/lsh_image3.png" alt="Figure 4: The same twenty points clustered via two different hashes — one using \lfloor x\rfloor, the other using \lfloor y\rfloor. As before, points are colored based on which cluster they’re in; a cluster is the set of all points who share both their \lfloor x\rfloor and their \lfloor y\rfloor values." id="fig:fig3"/>
      </p></div>
      <p>This does a much better job of avoiding clusters with points far apart, although, as we’ll see below, we can still make some improvements.</p>
      <h2 id="randomizing-our-hashes"> Randomizing our hashes</h2>
      <p>So far we’ve defined deterministic hash functions. Let’s change that by choosing a random rotation matrix <span>\(U\)</span> (a rotation around the origin) along with a random offset <span>\(b \in [0, 1).\)</span> Given such a random <span>\(U\)</span> and <span>\(b,\)</span> we could define a new hash function via</p>
      <p><span>\[ h(x) := \lfloor (Ux)_1 + b \rfloor, \]</span></p>
      <p>where I’m using the notation <span>\(( \textit{vec} )_1\)</span> to indicate the first coordinate of the vector value <em>vec</em>. (That is, the notation <span>\((Ux)_1\)</span> means the first coordinate of the vector <span>\(Ux\)</span>.) This function is the <em>random projection</em> I referred to earlier.</p>
      <p>It may seem a tad arbitrary to use only the first coordinate here rather than any other, but the fact that we’re taking a random rotation first means that we have the same set of possibilities, with the same probability distribution, as we would when pulling out any other single coordinate value.</p>
      <p>A key advantage of using randomized hash functions is that any probabilistic statements we want to make about performance (e.g., “99% of the time this algorithms will give us the correct answer”) applies equally to all data, as opposed to applying to some data sets but not to others. As a counterpoint, consider the way quicksort is typically fast, but ironically uses <span>\(O(n^2)\)</span> time to sort a pre-sorted list; this is a case where performance depends on the data, and we’d like to avoid that. If we were using deterministic hash functions, then someone could choose the worst-case data for our hash function, and we’d be stuck with that poor performance (for example, choosing maximally-far apart points that are still clustered together by our <span>\(h_1\)</span> function above). By using randomly chosen hash functions, we can ensure that any average-case behavior of our hash functions applies equally well to all data. This same perspective is useful for hash tables in the form of <a href="https://en.wikipedia.org/wiki/Universal_hashing"><em>universal hashing</em></a>.</p>
      <p>Let’s revisit the example points we used above, but now apply some randomized hash functions. In figure 4, points are clustered if and only if both of their hash values (from <span>\(h_1(x)\)</span> and <span>\(h_2(x)\)</span>) collide. We’ll use that same idea, but this time choose four rotations <span>\(U_1, \ldots, U_4\)</span> as well as four offsets <span>\(b_1, \ldots, b_4\)</span> to define <span>\(h_1(), \ldots, h_4()\)</span> via</p>
      <p><span id="eq:eq3"><span>\[ h_i(x) := \lfloor (U_i x)_1 + b_i \rfloor. \qquad(2)\]</span></span></p>
      <p>Figure 5 shows the resulting clustering. This time, there are 100 points since using more hash functions has effectively made the cluster areas smaller. We need higher point density to see points that are clustered together now.</p>
      <div>
      <p>Figure 5: One hundred random points clustered using four random hash functions as defined by (2). Points have the same color when all four of their hash values are the same. Each set of parallel light gray lines delineates the regions with the same hash value for each of the <span>\(h_i()\)</span> functions.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/lsh_image4.png" alt="Figure 5: One hundred random points clustered using four random hash functions as defined by (2). Points have the same color when all four of their hash values are the same. Each set of parallel light gray lines delineates the regions with the same hash value for each of the h_i() functions." id="fig:fig4"/>
      </p></div>
      <p>It’s not obvious that we actually want to use all four of our hash functions. The issue is that our clusters have become quite small. There are a couple ways to address this. One is to simply increase the scale of the hash functions; for example, set:</p>
      <p><span>\[ \tilde h_i(x) := h_i(x/s), \]</span></p>
      <p>where <span>\(s\)</span> is a scale factor. In this setup, larger <span>\(s\)</span> values will result in larger clusters.</p>
      <p>However, there is something a bit more nuanced we can look at, which is to allow some adaptability in terms of <em>how many hash collisions we require</em>. In other words, suppose we have <span>\(k\)</span> total hash functions (just above, we had <span>\(k=4\)</span>). Instead of insisting that all <span>\(k\)</span> hash values must match before we say two points are in the same cluster, we could look at cases where some number <span>\(j \le k\)</span> of them matches. To state this mathematically, we would rewrite equation (1) as</p>
      <p><span id="eq:eq2"><span>\[ a \sim b \iff \#\{i: h_i(a) = h_i(b)\} \ge j. {\class{smallscrneg}{ }}\qquad(3)\]</span></span></p>
      <p>Something interesting happens here, which is that the <span>\(a \sim b\)</span> relationship is no longer a clustering, but becomes more like adjacency (that is, sharing an edge) in a graph. The difference is that, in a clustering, if <span>\(a\sim b\)</span> and <span>\(b\sim c,\)</span> then we must have <span>\(a\sim c\)</span> as well; this is called being <em>transitively closed</em>. Graphs don’t need to have this property. Similarly, it’s no longer true that our similarity relationship <span>\(a\sim b\)</span> is transitively closed.</p>
      <p>It may help your intuition to see this new definition of <span>\(a\sim b\)</span> in action on the same 100 points from figure 5. This time, in figure 6, there are twenty random hashes, and we’re seeing the graphs generated by equation (3) using cutoff values (values of <span>\(j\)</span>) of 6, 7, 8, and 9. The top-left graph in figure 6 has an edge drawn between two points <span>\(a\)</span> and <span>\(b\)</span> whenever there are at least 6 hash functions <span>\(h_i()\)</span> with <span>\(h_i(a) = h_i(b),\)</span> out of a possible 20 used hash functions.</p>
      <div>
      <p>Figure 6: A set of 100 random points with graph edges drawn according to (3). There are 20 random hash functions used. The top-left graph uses the cutoff value <span>\(j=6.\)</span> The remaining three graphs, from top-left to bottom-right, have cutoff values <span>\(j=7,\)</span> 8, and 9 respectively; this means each graph is a subgraph (having a subset of the edges) of the previous one.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/lsh_image5.png" alt="Figure 6: A set of 100 random points with graph edges drawn according to (3). There are 20 random hash functions used. The top-left graph uses the cutoff value j=6. The remaining three graphs, from top-left to bottom-right, have cutoff values j=7, 8, and 9 respectively; this means each graph is a subgraph (having a subset of the edges) of the previous one." id="fig:fig5"/>
      </p></div>
      <p>In fact, we can visualize all possible cutoff values of 6 or higher — these are values of <span>\(j\)</span> in equation (3) — using a single image with weighted edges, as seen in figure 7. Keep in mind that we haven’t explicitly computed <em>any</em> pairwise distances to arrive at this data.</p>
      <div>
      <p>Figure 7: The same 100 random points from figure 6, this time rendered with edge weights that depend on how many hash collisions are present between any two points. A black edge represents the maximum of 20 hash collisions; the lightest edge represents only 6 hash collisions.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/lsh_image6.png" alt="Figure 7: The same 100 random points from figure 6, this time rendered with edge weights that depend on how many hash collisions are present between any two points. A black edge represents the maximum of 20 hash collisions; the lightest edge represents only 6 hash collisions." id="fig:fig6"/>
      </p></div>
      <p>There’s another fun way to build intuition for what information our hashes provide. Let’s visualize regions of the circle where all points have the same number of hash collisions with a given query point. We can do this by showing an example query point <span>\(q\)</span>, and shading each region based on the number of hash collisions the region’s points have with <span>\(q\)</span>; this is shown in figure 8. Every point in each shaded region has the same hash values for all the hash functions used. The first part of figure 8 shows a scaled version of the two-hash system (using <span>\(h_1()\)</span> and <span>\(h_2()\)</span>, similar to figure 4) that we saw before; the second part uses 5 random hashes. The darkest region contains points <span>\(p\)</span> where all hash values collide, so <span>\(h_i(p) = h_i(q)\)</span> for all <span>\(i\)</span>. In a lightly shaded region that equation will only hold true for a smaller subset of the hash functions <span>\(h_i().\)</span></p>
      <p>The second part of figure 8 (with 5 hashes) shows nicer behavior, and I’ll try to explain why. Imagine that we were drawing these same images for some theoretically perfect LSH setup that somehow managed to match point <span>\(q\)</span> to every point <span>\(p\)</span> with <span>\(||p-q||\le r\)</span> for some radius <span>\(r\)</span>; all other points were not matched. For that perfect LSH setup, images like figure 8 would show a fixed-size circle with center at <span>\(q\)</span> that moved along with <span>\(q\)</span>. With that in mind as the perfect LSH result, notice that the second part in figure 8 is much closer to this ideal than the first part. Keep in mind that lookups within the shaded regions are no longer linear searches through data, but rather the intersection of <span>\(k\)</span> hash table lookups — that is, lookups of nearby points are significantly faster.</p>
      <div>
      <p>Figure 8: The first part shows the regions where points would be matched by either two (dark regions) or just one (lighter shade) hash collision with the moving query point <span>\(q\)</span>. The second part shows the analogous idea for 5 random hash functions; in the latter case, the lightest shaded region indicates 3 hash collisions.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/image8a@2x.gif" alt="Figure 8: The first part shows the regions where points would be matched by either two (dark regions) or just one (lighter shade) hash collision with the moving query point q. The second part shows the analogous idea for 5 random hash functions; in the latter case, the lightest shaded region indicates 3 hash collisions." id="fig:fig8a"/>
      </p></div>
      <p>It may further help your intuition to see how weighted edges connecting a point to its neighbors, like those in figure 7, change as a single query point moives. This is the idea behind figure 9, where weighted edges are drawn between a moving query point and 100 random points. Notice that the edge weightings make intuitive sense: they tend to connect strongly to very close neighbors, weakly to farther neighbors, and not at all to points beyond a certain distance.</p>
      <div>
      <p>Figure 9: Edges weighted by how many hash collisions are present between the moving query point and 100 random points. Darker edges indicate more hash collisions. This image uses 12 random hashes, and requires at least 6 hash collisions for an edge to appear.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/image8b@2x.gif" alt="Figure 9: Edges weighted by how many hash collisions are present between the moving query point and 100 random points. Darker edges indicate more hash collisions. This image uses 12 random hashes, and requires at least 6 hash collisions for an edge to appear." id="fig:fig8b"/>
      </p></div>
      <h2 id="choosing-values-of-j"> Choosing values of <span>\(j\)</span></h2>
      <p>So far, we’ve seen that we can use hash lookups to find nearby neighbors of a query point, and that using <span>\(k\)</span> different randomized hash functions gives us much more accurate lookups than if we used a single hash function. An interesting property of figure 7 and figure 9 is that we used different numbers of hash collisions — via the variable <span>\(j\)</span> — to discover different degrees of similarity between points. In many applications, such as finding near duplicates or close geospatial points, we only want a binary output, so we have to choose a particular value for <span>\(j\)</span>. Let’s discuss how to choose good values for <span>\(j.\)</span></p>
      <p>Suppose <span>\(k\)</span> is fixed. How can we decide which value of <span>\(j\)</span> is best?</p>
      <p>To answer this question, let’s temporarily consider what a perfect function would do for us. We’ll call this function <code>search(q)</code>. In an ideal world this function returns all points within a fixed distance of the query point. We could visualize this as an <span>\(n-\)</span>dimensional sphere around the query point <span>\(q\)</span>. A call to <code>search(q)</code> ought to return all the indexed points <span>\(p\)</span> that live within this sphere.</p>
      <p>Let’s move from that idealized algorithm into our fast-but-approximate world of locality-sensitive hashes. With this approach, there is no exact cutoff distance, although we keep the property that nearby neighbors are very likely to be in the returned list and distant points are very likely to be excluded. Since our hash functions are randomized, we can think of the neighbor relationship <span>\(p\sim q\)</span> as being a <em>random variable</em> that has a certain probability of being true or false once all our parameters are fixed (as a reminder, our main parameters are <span>\(j\)</span> and <span>\(k\)</span>).</p>
      <p>Now consider what great performance looks like in the context of this random variable. Ideally, there is some distance <span>\(D\)</span> such that</p>
      <p><span>\[||p-q|| &lt; D-\varepsilon {\quad{\class{smallscr}{\hskip -0.8em}}}\Rightarrow{\quad{\class{smallscr}{\hskip -0.8em}}}P(p\sim q) &gt; 1 - \delta;\]</span> <span>\[||p-q|| &gt; D+\varepsilon {\quad{\class{smallscr}{\hskip -0.8em}}}\Rightarrow{\quad{\class{smallscr}{\hskip -0.8em}}}P(p\sim q) &lt; \delta.\]</span></p>
      <p>In other words, this distance <span>\(D\)</span> acts like a cutoff for our approximate search function. Points closer than distance <span>\(D\)</span> to query point <span>\(q\)</span> are returned, while points farther are not.</p>
      <p>I wrote a Python script to calculate some of these probabilities for the particular parameters <span>\(k=10\)</span> and <span>\(d=2\)</span> (<span>\(d\)</span> is the dimensionality of the points), and for various values of <span>\(j\)</span>. In particular, I restricted my input points to certain distances and measured the probability that they had at least <span>\(j\)</span> hash collisions for different <span>\(j\)</span> values. If you’re familiar with conditional probabilities, then this value can be written as:</p>
      <p><span>\[ P\big(p \sim_j q \, \big| \, ||p-q|| = D\big), \]</span></p>
      <p>where I’ve written <span>\(p\sim_j q\)</span> to denote that points <span>\(p\)</span> and <span>\(q\)</span> have at least <span>\(j\)</span> hash collisions.</p>
      <p>Using this Python script, I’ve visualized the collision behavior of <span>\(p\sim_j q\)</span> for various <span>\(j\)</span> in figure 10. I’ll go into more detail about what each tick on the box plot indicates, but the intuition is that shorter box plots are better because in this visualization a shorter box plot indicates a smaller range of uncertainty.</p>
      <div>
      <p>Figure 10: Intuitively, each box plot represents the distances at which points <span>\(p, q\)</span> will achieve mixed results (sometimes classified as nearby, other times as not) from our LSH setup. A very short box plot is ideal because it indicates a smaller range of uncertainty. In other words, a short box plot corresponds to a setting in which most pairs of points are correctly classified by an LSH system as nearby or far apart based on their actual distance.</p>
      <p><img src="https://tylerneylon.com/a/lsh1/images/image9@2x.png" alt="Figure 10: Intuitively, each box plot represents the distances at which points p, q will achieve mixed results (sometimes classified as nearby, other times as not) from our LSH setup. A very short box plot is ideal because it indicates a smaller range of uncertainty. In other words, a short box plot corresponds to a setting in which most pairs of points are correctly classified by an LSH system as nearby or far apart based on their actual distance." id="fig:fig9"/>
      </p></div>
      <p>The most interesting element of this graph is that the best value of <span>\(j\)</span> appears to be <span>\(j=6.\)</span> You might have guessed that your best LSH approach is to insist that <em>all</em> of your random hashes must collide before you consider two points to be neighbors, but this measurement shows that intuition to be false.</p>
      <p>So what exactly did we measure in figure 10? A traditional box plot visualizes the 25th and 75th percentiles of a set of scalar data points as the boundaries of the box. Often the median (50th percentile) is also shown within the box, but we don’t include an analogous mark in figure 10. The “whiskers” at either end may indicate the minimum and maximum values, or something similar such as the extreme values after removing outliers.</p>
      <p>In our case, we have one box plot for each value of <span>\(j\)</span>, and each plot has been normalized so that the bottom whiskers all align at value 1. (I’ll explain why this is useful in a moment.) The bottom whisker indicates the distance between <span>\(p\)</span> and <span>\(q\)</span> so that <span>\(p\sim_j q\)</span> is true 99% of the time. The bottom of the box is the relative distance at which <span>\(p\sim_j q\)</span> is true 75% of the time. Continuing in this pattern, the box top corresponds to the distance at which we get collisions 25% of the time, and the top whisker is the distance at which we get collisions 1% of the time. Since the box plots are all normalized (meaning that the distances per <span>\(j\)</span> value have all been divided through by the smallest distance), it’s easy to visually see the ratio of each box plot position versus its smallest distance. In other words, it’s easy to see which distance range is smallest.</p>
      <p>Because I love math and precision, I’m going to provide one last definition to formalize the idea of figure 10. Given a value <span>\(s \in (0, 1)\)</span>, define the distance <span>\(D_s\)</span> as the value satisfying the given equation:</p>
      <p><span>\[ P\big(p \sim_j q \, \big| \, ||p-q|| = D_s\big) = s, \]</span></p>
      <p>where <span>\(p\sim_j q\)</span> means that <span>\(\#\{i : h_i(p) = h_i(q)\} \ge j.\)</span> Intuitively, if <span>\(\varepsilon\)</span> is close to zero, then the distance <span>\(D_\varepsilon\)</span> is large because the probability of <span>\(p\sim_j q\)</span> is small. The value of <span>\(D_{1/2}\)</span> is the perfect distance so that <span>\(p \sim_j q\)</span> happens half of the time, and <span>\(D_{1-\varepsilon}\)</span> is a small distance where <span>\(p \sim_j q\)</span> happens almost all the time. Using this definition, the four values shown in each box plot of figure 10, from bottom to top, are:</p>
      <p><span>\[D_{.99} / D_{.99} ,{\;\;{\class{smallscr}{\hskip -0.3em}}}D_{.75} / D_{.99}   ,{\;\;{\class{smallscr}{\hskip -0.3em}}}D_{.25} / D_{.99}   ,{\;\;{\class{smallscr}{\hskip -0.3em}}}D_{.01} / D_{.99}.\]</span></p>
      <h2 id="why-an-lsh-is-faster"> Why an LSH is faster</h2>
      <p>So far we’ve been sticking to 2-dimensional data because that’s easier to visualize in an article. However, if you think about computing 10 hashes for every 2-dimensional point in order to find neighbors, it may feel like you’re doing more work than the simple solution of a linear search through your points. Let’s review cases where using an LSH is more efficient than other methods of finding nearby points.</p>
      <p>There are two ways an LSH can speed things up: by helping you deal with a huge number of points, or by helping you deal with points in a high-dimensional space such as image or video data.</p>
      <h3 id="an-lsh-is-fast-over-many-points"> An LSH is fast over many points</h3>
      <p>If you want to find all points close to a query point <span>\(q,\)</span> you could execute a full linear search. A single-hash LSH can give you results in constant time. That’s faster.</p>
      <p>Things are slightly more complex for higher values of <span>\(j\)</span> and <span>\(k.\)</span> If you keep <span>\(j=k,\)</span> then your LSH result is a simple intersection of <span>\(k\)</span> different lists, each list being the set of hash collision points returned by a given randomized hash function <span>\(h_i().\)</span> Finding this intersection can be sped up by starting with the smallest of these lists and shrinking it by throwing out points not present in the other lists. This throwing-out process can be done quickly by using hash-table lookups to test for inclusion in the point lists, which are basically constant time. The running time of this approach is essentially <span>\(O(mk),\)</span> where <span>\(m\)</span> is the length of the shortest list returned by any of your hash functions <span>\(h_i().\)</span> This running time is very likely to be an order of magnitude faster than linear search.</p>
      <h3 id="an-lsh-is-faster-for-high-dimensional-points"> An LSH is faster for high-dimensional points</h3>
      <p>There is a beautiful mathematical result called the <a href="https://en.wikipedia.org/wiki/Johnson%E2%80%93Lindenstrauss_lemma">Johnson-Lindenstrauss lemma</a> which shows that random projections (which is what we’re using in our <span>\(h_i()\)</span> functions) are amazingly good at preserving point-wise distances <span>(Dasgupta and Gupta 2003)</span>. As a result of this, you can often use a much <em>smaller</em> number of hash functions than your dimensionality <span>\(d\)</span> to set up an effective LSH system.</p>
      <p>In particular, if you have <span>\(n\)</span> points, then you can use on the order of <span>\(\log(n)\)</span> hash functions and still achieve good results. With the <span>\(j=k\)</span> approach from the last section, a lookup would require <span>\(O(m\log(n))\)</span> time, where <span>\(m\)</span> is the length of the smallest list returned by your hash functions. Even if you wanted to take the more complex approach of setting <span>\(j &lt; k,\)</span> you would still gain a speedup even on pairwise comparisons. Normally it requires <span>\(O(d)\)</span> time to compute the distance between two points. Using <span>\(k \approx \log(n)\)</span> hashes, it would instead take <span>\(O(\log(n))\)</span> time to compute the number of hash collisions between two points.</p>
      <p>To show how significant this last speedup can be, imagine looking for copyright violations among movie files that are 1GB each. There have been about 500,000 movies made in the United States so far. With these numbers, we would require looking at 2 billion numeric values of data to directly compare two video files, versus looking at about 210 numeric values of data to compare their LSH values. (The value 210 is twice the expression <span>\(8\log(500,000),\)</span> which is a simplified suggested value for <span>\(k\)</span> from the Johnson-Lindenstrauss lemma.) The LSH approach here is about 10 million times faster.</p>
      
      <p>This article has focused on numeric, 2-dimensional data because it’s easier to visualize. Locality-sensitive hashes can certainly be used for many data types including strings, sets, or high-dimensional vectors.</p>
      <p>Yet another ingredient to throw into the mix here is a set of techniques to boost performance tht treat an LSH as a black box. My favorite approach here is to simply perform multiple lookups on a hash system, each time using <span>\(q + \varepsilon\)</span> as an input, where <span>\(q\)</span> is your query value, and <span>\(\varepsilon\)</span> is a random variable centered at zero <span>(Panigrahy 2006)</span>.</p>
      <p>There’s a lot more that can be said about LSH techniques. If there is reader interest, I may write a follow-up article explaining the details of min-wise hashing, which is a fun case that’s simultaneously good at quickly finding nearby sets as well as nearby strings <span>(Broder et al. 2000)</span>.</p>
      <hr/>
      <p><em><strong>Hi!</strong> I hope you enjoyed my article. As you can see, I love building systems that get the most out of data. If you’d like to work together on a machine learning project, I’d love to hear from you. My company, Unbox Research, has a small team of talented ML engineers. We specialize in helping content platforms make more intelligent use of their data, which translates to algorithmic text and image comprehension as well as driving user engagement through discovery or personalization. Email me at <a href="mailto:tyler@unboxresearch.com">tyler@unboxresearch.com</a>.</em></p>
      <hr/>
      
      <div id="refs">
      <p>Broder, Andrei Z, Moses Charikar, Alan M Frieze, and Michael Mitzenmacher. 2000. “Min-Wise Independent Permutations.” <em>Journal of Computer and System Sciences</em> 60 (3). Elsevier: 630–59.</p>
      <p>Dasgupta, Sanjoy, and Anupam Gupta. 2003. “An Elementary Proof of a Theorem of Johnson and Lindenstrauss.” <em>Random Structures &amp; Algorithms</em> 22 (1). Wiley Online Library: 60–65.</p>
      <p>Panigrahy, Rina. 2006. “Entropy Based Nearest Neighbor Search in High Dimensions.” In <em>Proceedings of the Seventeenth Annual Acm-Siam Symposium on Discrete Algorithm</em>, 1186–95. Society for Industrial; Applied Mathematics.</p>
      </div>
    </div></div>
  </body>
</html>
