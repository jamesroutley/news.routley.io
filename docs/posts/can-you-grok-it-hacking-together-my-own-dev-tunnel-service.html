<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0xda.de/blog/2024/04/can-you-grok-it/">Original</a>
    <h1>Can You Grok It – Hacking together my own dev tunnel service</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>My friend sent me a tunnel link where he had to manually set it up with socat and his nginx ingress controller in his k8s cluster. He made an offhand comment about needing a better way to setup tunnels and it got me thinking. This post is the result of a long night of hacking away at my own tunnel solution.</p>
<p>If you want to jump into the nitty gritty of how it works, you can skip to <a href="#roll-your-own-tunnel">Roll Your Own Tunnel</a>. If you want to skip the nitty gritty and figure it out yourself, <a href="#putting-it-all-together">Putting It All Together</a> is where you want to be.</p>
<p>















  
  
    
    
    
    
    
    
    
    
  <picture>
    <source srcset="https://0xda.de/blog/2024/04/can-you-grok-it/img/gronk_hu6a56ea17b41afa887ba4069bb5bed54b_135943_867x1184_resize_q75_h2_box.webp" type="image/webp"/>
  <img src="https://0xda.de/blog/2024/04/can-you-grok-it/img/gronk.6e943441cc81a6a519cba39bb9fbac13.jpeg" alt="pull the lever, ngrok" loading="lazy" height="1184" width="867"/>
</picture>
</p>
<h2 id="criteria">Criteria</h2>
<p>I had a handful of criteria that I wanted to consider for a functional solution.</p>
<ol>
<li>I wanted it to run on my own infrastructure - I was likely going to be doing TLS termination at the public web server, since my development servers aren’t going to be using publicly trusted TLS certificates.</li>
<li>I wanted the tunnels to be created under my own domain. I chose <code>dev.0xda.de</code> to be the parent of the tunnels – any new tunnel should be available underneath <code>.dev.0xda.de</code>.</li>
<li>I didn’t want to leak the links to new tunnels automatically and invite automated scanning – dev services are often running in debug or development mode, which may leak sensitive information even in simple cases like a 404 response. This is an important distinction for one particular solution I looked at, which we’ll cover in the next section.</li>
</ol>
<p>With these criteria in mind, I looked at existing solutions. Unfortunately while looking for solutions I could potentially self host, I mostly was reading awesome-selfhosted which didn’t seem to have a good section on tunnels. It turns out there’s a whole separate list called <a href="https://github.com/anderspitman/awesome-tunneling">awesome-tunneling</a>, which has a handful of criteria that are somewhat similar to mine. But I didn’t know about this list until after I spent my whole night working on this, so I won’t really be touching on any items from that list.</p>
<h2 id="solutions-i-considered">Solutions I Considered</h2>
<h3 id="ngrok">Ngrok</h3>
<p>I have been using <a href="https://ngrok.com/">ngrok</a> off and on for years. It is okay – it’s convenient to spin up tunnels quickly, and even the free tier allows you to reserve one static domain that you can reuse. This makes testing development of flows like OAuth2 login easier, especially on providers that restrict the redirect URI to publicly routable domains.</p>
<p>















  
  
    
    
    
    
    
    
    
    
  <picture>
    <source srcset="https://0xda.de/blog/2024/04/can-you-grok-it/img/ngrok-pricing_hu611ea6457a8718ece8f2e8aecf03e783_62526_1145x495_resize_q75_h2_box_3.webp" type="image/webp"/>
  <img src="https://0xda.de/blog/2024/04/can-you-grok-it/img/ngrok-pricing.a0c71c19601c3e38e05cabe57e57188b.png" alt="ngrok pricing page" loading="lazy" height="495" width="1145"/>
</picture>
</p>
<p>To get a custom domain, you have to use the $10/mo or $96/yr “Personal” plan. This is fairly reasonable, if I’m being honest. But it doesn’t meet my first requirement – Ngrok controls the TLS termination before forwarding the request to my service. Ngrok can potentially see whatever I’m developing, can potentially see secrets that leak in debug pages, etc. I have no reason to really worry about this, but in the pursuit of my ideals, I moved on to another option.</p>
<h3 id="tailscale-funnel">Tailscale Funnel</h3>
<p>I love <a href="https://tailscale.com/">Tailscale</a>. I’ve been a free tier user for over a year now, setting it up is incredibly easy, and I can use the Wireguard mesh network to easily connect my phone to my home services while I’m on the go. On top of this, I can even use Tailscale to restrict my administrative ports on web servers, such that you have to either connect through my tailnet or connect through my bastion host.</p>
<p>Tailscale offers a feature called <a href="https://tailscale.com/kb/1223/funnel">Funnel</a>, which works similarly to ngrok as a way to route internet traffic into your local service. It doesn’t meet the self-hosted criteria or hosting on my own domain, but I was already using Tailscale so it was easy to test out.</p>
<p>One of the cool things about Tailscale Funnel is that it handles the <strong>TLS termination on your device</strong> – this is an improvement over ngrok’s basic proxy service, since I know that the only people who can see the traffic are my local service and the client requesting it. But this comes with an important caveat that I was surprised to learn about.</p>
<p>Within minutes of running my tailscale funnel, my Django service I was running for testing was being bombarded by internet scanning noise. This was surprising to me, but in hindsight it makes perfect sense.</p>
<p>















  
  
    
    
    
    
    
    
    
    
  <picture>
    <source srcset="https://0xda.de/blog/2024/04/can-you-grok-it/img/scanning-traffic_hue5201c6b2692755e39f89ba582d02bd4_44606_1208x264_resize_q75_h2_box_3.webp" type="image/webp"/>
  <img src="https://0xda.de/blog/2024/04/can-you-grok-it/img/scanning-traffic.311aba8b85990431e17242ca9ea3dd10.png" alt="automated scanning traffic" loading="lazy" height="264" width="1208"/>
</picture>
</p>
<p>Without too much detail about the Tailscale product, you have a “tailnet” address of <code>&lt;unique-tailnet&gt;.ts.net</code>. For simplicity sake, let’s say my tailnet is named <code>ellingson-mineral.ts.net</code>. This address can be used as the parent domain of all devices on your tailnet, so you can access the Gibson by visiting <code>gibson.ellingson-mineral.ts.net</code> from any device connected to your tailnet.</p>
<p>Remember how I said that Tailscale funnel handles TLS termination on your device? Well in order to do that, your device has to control the keys for the certificate. And since you want it to be publicly available, you need a certificate that is trusted. So Tailscale fetches a certificate from LetsEncrypt for your host.</p>
<p>So the first time you set up a Tailscale funnel, your tailnet address shows up in Certificate Transparency Logs (CTL). <a href="https://crt.sh/?q=%25.ts.net"><em>A LOT</em></a> of tailnet addresses are in CTL.</p>
<p>















  
  
    
    
    
    
    
    
    
    
  <picture>
    <source srcset="https://0xda.de/blog/2024/04/can-you-grok-it/img/crt-sh-truncated-results_hu6547f74f22b82ea931888559ca1126c4_26064_824x169_resize_q75_h2_box_3.webp" type="image/webp"/>
  <img src="https://0xda.de/blog/2024/04/can-you-grok-it/img/crt-sh-truncated-results.deff177fa5404d802d7096030ff3b6a4.png" alt="crt.sh truncated results for .ts.net" loading="lazy" height="169" width="824"/>
</picture>
</p>
<p>This could explain how my service started getting scanned minutes after being made available online.</p>
<p>While this service is really easy to use and really powerful for exposing services indirectly, I think I’m not a huge fan of it being immediately available and scannable online, especially if it’s a development service. It also doesn’t allow me to create tunnels with specific names – the tunnel will always just be <code>gibson.ellingson-mineral.ts.net</code>.</p>
<h3 id="vs-code-developer-tunnels">VS Code Developer Tunnels</h3>
<p>I already use VS Code for most of my development, and they released a public preview of <a href="https://learn.microsoft.com/en-us/azure/developer/dev-tunnels/overview">Dev Tunnels</a> back in November 2023. This allows easily hooking up a development tunnel to a port on your local computer, allows persistent URLs for as long as you need, and it’s secure by default – the tunnels default to only being accessible to your own Microsoft or Github account. This is especially cool if you want to test things across your own devices, and it does appear to offer more <a href="https://learn.microsoft.com/en-us/azure/developer/dev-tunnels/cli-commands#advanced-manage-dev-tunnel-access">granular access controls</a> if you so desire them.</p>
<p>Either way, this service is cool but it relies on the generosity of Microsoft, tunnels my traffic through their relays, and I can’t really control the domain I want to use.</p>
<p>I didn’t spend a lot of time testing this, I’ve used it before and it’s okay. But I really just like the idea of being able to send someone a link on my own domain.</p>
<h2 id="roll-your-own-tunnel">Roll Your Own Tunnel</h2>
<p>So I was settling into rolling my own ngrok-like service. I spent maybe half an hour thinking about doing it with a simple HTTP application built with FastAPI that would broker a tunnel between clients and the server. I could front the API with nginx and write a simple client. But as I started considering proxying all traffic through websockets, I realized I didn’t need to write any of my own code to make this work.</p>
<p>While looking around, I found a post by Vallard called “<a href="https://benincosa.com/?p=3755">my own ngrok</a>”. This uses a simple nginx configuration and an ssh reverse proxy. These are both things I’ve used a great deal in the past. In Vallard’s post, he uses a single reusable hostname, and a single port. This works great for simplicity, and for most people this is probably more than enough. But I thought I could make it just a little bit better.</p>
<h3 id="wildcard-domains">Wildcard Domains</h3>
<p>First I wanted to tackle the ability to have arbitrary subdomains for tunnels. Some years ago, I figured out that you can do <a href="https://gist.github.com/0xdade/d6dd7dadba2c48295dde0b3260d072d2">wildcard server_name blocks in nginx</a> while I was trying to bypass the Twitter ban on sharing links to ddosecrets.com.</p>
<p>To make this work, we have to do a couple things.</p>
<ol>
<li>Create a wildcard A record in your DNS zone. E.g. <code>*.dev 10800 IN A 51.81.64.16</code> routes all subdomains of <code>*.dev.0xda.de</code> to the host that is serving this website.</li>
<li>Create a wildcard TLS certificate with <a href="https://community.letsencrypt.org/t/acme-v2-production-environment-wildcards/55578">Lets Encrypt</a> – you’ll want to make sure this can auto-renew, which will require some extra work on your part. We’re not going to cover the auto-renewal in this post.</li>
<li>Create the following nginx config. This is loosely modified from Vallard’s post referenced above, to account for my domain name and my wildcard server_name.</li>
</ol>
<pre tabindex="0"><code>server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name ~^(.*)\.dev\.0xda\.de$;
    ssl_certificate /etc/letsencrypt/live/dev.0xda.de/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/dev.0xda.de/privkey.pem;
    location / {
        include proxy_params;
        proxy_pass http://localhost:7070;
        error_page 502 /no-tunnel.html;
    }
    location /no-tunnel.html {
        return 404 &#34;&lt;center&gt;No such tunnel...&lt;/center&gt;&#34;;
    }
}
</code></pre><p>Now, we can have arbitrary tunnel names without leaking them to cert transparency logs.</p>
<h3 id="enabling-multiple-simultaneous-tunnels">Enabling Multiple Simultaneous Tunnels</h3>
<p>One major drawback with the configuration so far is that we can only setup one tunnel – our SSH reverse tunnel binds on port 7070, and our nginx config is routing all traffic to that port.</p>
<p>To fix this, we’re going to use a feature of ssh reverse tunnels that is probably a little bit lesser known. See, of course you can proxy to TCP ports like 7070. But you can also establish reverse proxies to a unix domain socket, which is just a file on disk.</p>
<p>This gives us a pretty cool capability to define a name for our tunnel on the client and have that name be available on the server as a unix domain socket.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>ssh user@example.com -R /tmp/test.dev.0xda.de.socket:127.0.0.1:8000
</span></span></code></pre></div><p>The important bit here is the <code>/tmp/test.dev.0xda.de.socket</code>. We define this on the client, and it creates a file at <code>/tmp/test.dev.0xda.de.socket</code> on the server.</p>
<p>We can then combine this with a slight modification to our nginx server block to have nginx send traffic to the <code>/tmp/test.dev.0xda.de.socket</code> socket.</p>
<pre tabindex="0"><code>[...]
    location / {
        include proxy_params;
        proxy_pass /tmp/$host.socket; # this is the important change
        error_page 502 /no-tunnel.html;
    }
[...]
</code></pre><p>We’re making use of the <code>$host</code> variable in nginx to pass to a named socket on disk. So if our request is to <code>https://test.dev.0xda.de</code>, then nginx will match this server block and then pass the request to <code>/tmp/test.dev.0xda.de.socket</code>.</p>
<p>There’s one glaring problem with this, though.</p>
<h3 id="linux-permissions">Linux Permissions</h3>
<p>We’re sshing to our server as our own user, but our nginx server workers are running as <code>www-data</code>. When our socket gets created, only our own user can interact with it.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ ls -la /tmp/test.dev.0xda.de.socket
</span></span><span><span>srw------- <span>1</span> dade dade <span>0</span> Apr <span>14</span> 02:04 /tmp/test.dev.0xda.de.socket
</span></span></code></pre></div><p>We need to let <code>www-data</code> read and write to this socket. There are a handful of things I tried, and the one that is probably the sketchiest is also the one I ended up selecting. But let’s take a look at the options first.</p>

<p>… and then having my local tunnel command ssh in as the <code>www-data</code> user. This worked, sorta, but usually if I see <code>www-data</code> running ssh, or anything, really, I get pretty sketched out. And plus, the user’s shell defaults to <code>/usr/sbin/nologin</code> – so the shell immediately terminates after ssh authenticates.</p>
<h4 id="make-a-group-that-my-user-and-www-data-belong-to">Make a group that my user and www-data belong to</h4>
<p>This probably could work, but I was having trouble with it because whenever I tried to <code>chown dade:grok /tmp/test.dev.0xda.de.socket</code>, I was met with a <code>Operation not permitted</code> error. I <em>suspect</em> this is probably something we could overcome, and is better than the alternative options if it does work, because we can enable only our user and <code>www-data</code> to talk to the socket.</p>
<h4 id="chmod-ogw">chmod o+gw</h4>
<p>What I ultimately ended up doing is the dumbest possible solution. We can just run <code>chmod o+rw /tmp/test.dev.0xda.de.socket</code> and allow any user, any process on the server to communicate with this socket. Since ultimately I’m granting <em>the internet</em> read/write access to this socket anyways, I decided I was okay with this for now. If I was in a shared hosting environment with other users, I might reconsider – but in that scenario, I’d also probably not be able to make the nginx config changes necessary, so maybe that scenario is irrelevant.</p>
<p>But I don’t want to have to run this every time I start the tunnel, that’s annoying.</p>
<h3 id="the-worlds-sketchiest-automation">The world’s sketchiest automation</h3>
<p>To automatically run a command when we ssh in to establish the tunnel, we have a bunch of options. We could set it up to run a non-interactive ssh session and run a pre-defined bash script, for instance. But for reasons I don’t remember, this didn’t really work well for me. We could also use our various shell rc files to attempt it whenever our shell starts up. But this also isn’t my favorite option, since I could start shells inside of <code>screen</code> or <code>tmux</code>, for instance.</p>
<p>Instead, I specifically only want to run this bit of code when I establish a new ssh session. Enter my old persistence friend <code>~/.ssh/rc</code>. This is an ssh-specific configuration file that runs when you establish a new ssh connection – both for interactive logins as well as remote commands.</p>
<p>Our naïve solution for this can begin with the following:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>chmod o+rw /tmp/*.dev.0xda.de.socket 2&gt;/dev/null
</span></span></code></pre></div><p>But this runs every time, even when I don’t specify a tunnel. It also blanket runs across all dev sockets in the tmp directory, rather than only running against the specific tunnel we’re establishing with our ssh session.</p>
<p>What we need is to pass the tunnel domain to the server, that way the process on the server knows the exact domain name to use. This will also be helpful when we talk about cleaning up the tunnel afterwards.</p>
<p>In ssh, you can use an option called <code>SendEnv</code> to send an environment variable from the local environment to your remote environment. The sshd server must be configured to support this, and I’m probably about to make some unix grey-beards very angry with my next suggestion.</p>
<p>On my Ubuntu 20.04 server, <code>sshd_config</code> allows certain variables to be sent by default.</p>
<pre tabindex="0"><code># Allow client to pass locale environment variables
AcceptEnv LANG LC_*
</code></pre><p>That wildcard <code>LC_*</code> is our saving grace here. <em>ANY</em> environment variable that begins with<code>LC_</code> can be sent from a client to the server, should the client so choose. So let’s abuse that with a new variable called <code>LC_GROKDOMAIN</code>.</p>
<p>So now our ssh command to start the tunnel looks like this:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>export LC_GROKDOMAIN<span>=</span>test.dev.0xda.de
</span></span><span><span>ssh user@example.com -o SendEnv<span>=</span>LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:8000
</span></span></code></pre></div><p>And we can update our <code>~/.ssh/rc</code> file to only run with this new information.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>if</span> <span>[</span> -n <span>&#34;</span>$LC_GROKDOMAIN<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>    chmod o+rw /tmp/$LC_GROKDOMAIN.socket 2&gt;/dev/null
</span></span><span><span>    echo <span>&#34;You can now visit https://</span>$LC_GROKDOMAIN<span> in your browser&#34;</span>
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><h4 id="cleaning-up-the-socket">Cleaning up the socket</h4>
<p>Now that we have the automation setup to automatically give nginx the ability to read/write to our socket when we establish our ssh connection, we have one more annoying thing that happens on the server to contend with. Cleaning up.</p>
<p>When we’re done with our socket, we want to remove the file from <code>/tmp/</code> – otherwise if we try to reuse the socket next time, the forward will fail since the file already exists.</p>
<p>My really hacky way to do this was to add a conditional block to my <code>~/.bash_logout</code>. This works well enough when I close the session when I’m done with it.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>if</span> <span>[</span> -n <span>&#34;</span>$LC_GROKDOMAIN<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>    rm /tmp/$LC_GROKDOMAIN.socket 2&gt;/dev/null
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><p><strong>Note:</strong> This unfortunately leaves the socket file hanging around in the event that your ssh connection dies through anything other than a clean exit. There is almost certainly room for improvement here, but I was at the end of my knowledge for code that automatically gets executed in my ssh sessions. Failure to clean up the socket will result in the next attempt to establish the tunnel failing until you remove the socket file and re-connect.</p>
<h3 id="streamlining-the-client-experience">Streamlining the Client Experience</h3>
<p>Okay so far so good. We can run a single ssh command and have a new tunnel set up on our infrastructure, on our domain, and we haven’t even introduced any new code. We already had nginx, and we already had ssh. We can have as many tunnels as we can have unix domain sockets and nginx will handle routing requests to the appropriate tunnel.</p>
<p>But the command is kind of clunky and not easy to use. We have to export the domain variable, we have to write out a long ssh command, it’s just not fun. Let’s write a wrapper that simplifies things.</p>
<p>Consider our current process for setting up a new tunnel:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>export LC_GROKDOMAIN<span>=</span>test.dev.0xda.de
</span></span><span><span>ssh user@example.com -o SendEnv<span>=</span>LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:8000
</span></span></code></pre></div><p>Doing this manually also leaves <code>LC_GROKDOMAIN</code> hanging around in our shell, which might cause some confusion the next time we want to open a tunnel. It’s also just a lot to type out.</p>
<p>We want our interface to be simple. <code>grok &lt;port&gt; [&lt;name&gt;]</code> – port is required, and name is optional. We <em>have</em> to know what port to forward the traffic to, but we don’t necessarily <em>have</em> to designate a name.</p>
<p>A simple bash script later, and we’ve got exactly what we need.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>
</span></span><span><span>grok<span>()</span> <span>{</span>
</span></span><span><span>    TOP_LEVEL_DOMAIN<span>=</span><span>&#34;dev.0xda.de&#34;</span>
</span></span><span><span>    <span>if</span> <span>[</span> -z <span>&#34;</span>$1<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>        echo <span>&#34;Usage: grok &lt;port&gt; [&lt;name&gt;]&#34;</span>
</span></span><span><span>        <span>return</span> <span>1</span>
</span></span><span><span>    <span>fi</span>
</span></span><span><span>
</span></span><span><span>    local port<span>=</span><span>&#34;</span>$1<span>&#34;</span>
</span></span><span><span>    local name<span>=</span><span>&#34;</span>$2<span>&#34;</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>[</span> -z <span>&#34;</span>$name<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>        <span># Generate a random 12-digit hexadecimal string</span>
</span></span><span><span>        name<span>=</span><span>$(</span>openssl rand -hex 6<span>)</span>
</span></span><span><span>    <span>fi</span>
</span></span><span><span>    echo <span>&#34;Setting up </span><span>${</span>name<span>}</span><span>.</span><span>${</span>TOP_LEVEL_DOMAIN<span>}</span><span>&#34;</span>
</span></span><span><span>    export LC_GROKDOMAIN<span>=</span><span>&#34;</span><span>${</span>name<span>}</span><span>.</span><span>${</span>TOP_LEVEL_DOMAIN<span>}</span><span>&#34;</span>
</span></span><span><span>    ssh user@example.com -o ControlPath<span>=</span>none -o SendEnv<span>=</span>LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:$port
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>grok $@
</span></span></code></pre></div><p>I put this in <code>.local/bin/grok</code>, which is in my path, and now I can just run <code>grok 8000 test</code>. I also added in a feature that will generate a random 12 digit hexadecimal tunnel name if we don’t specify one. I also explicitly disable <code>ControlPath</code> in my command – I noticed that our tunnels don’t reliably close if you make use of <code>ControlMaster</code> at all.</p>
<h2 id="limitations">Limitations</h2>
<p>There are some limitations to this method that I feel are important to address.</p>
<ul>
<li>If the socket stays behind on the remote host, our tunnel will fail next time and we have to manually connect in and delete it, then disconnect and reconnect our ssh session. (Technically we can do this with control sequences, but that’s also a topic for a different time)</li>
<li>Our current implementation keeps the interactive session open the whole time – it would be cool if we could skip the interactive session but keep the session open until we close it. Due to the first limitation, the interactive session is just more useful right now.</li>
<li>This version of this project can’t handle arbitrary TCP tunneling – the nginx block is in an <code>http</code> block. We can technically setup an arbitrary named TCP tunneling service, but that’s definitely a topic for another day</li>
<li>The HTTP logs for basic web servers can’t distinguish between clients – E.g. <code>python3 -m http.server 8080</code> results in all requests having a client IP of <code>127.0.0.1</code>. I think this can be handled in the nginx config, but I haven’t looked further into it yet.</li>
</ul>
<h2 id="putting-it-all-together">Putting It All Together</h2>
<p>This should be everything you need to replicate this configuration. Adjust domain names and paths appropriately.</p>
<p>(Remote) <code>/etc/nginx/sites-available/dev.0xda.de.conf</code></p>
<pre tabindex="0"><code>server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name ~^(.*)\.dev\.0xda\.de$;
    ssl_certificate /etc/letsencrypt/live/dev.0xda.de/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/dev.0xda.de/privkey.pem;
    location / {
        include proxy_params;
        proxy_pass /tmp/$host.socket;
        error_page 502 /no-tunnel.html;
    }
    location /no-tunnel.html {
        return 404 &#34;&lt;center&gt;No such tunnel...&lt;/center&gt;&#34;;
    }
}
</code></pre><p>(Remote) <code>~/.ssh/rc</code></p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>if</span> <span>[</span> -n <span>&#34;</span>$LC_GROKDOMAIN<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>    chmod o+rw /tmp/$LC_GROKDOMAIN.socket 2&gt;/dev/null
</span></span><span><span>    echo <span>&#34;You can now visit https://</span>$LC_GROKDOMAIN<span> in your browser&#34;</span>
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><p>(Remote) <code>~/.bash_logout</code></p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># rest of your config here ...</span>
</span></span><span><span><span>if</span> <span>[</span> -n <span>&#34;</span>$LC_GROKDOMAIN<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>    rm /tmp/$LC_GROKDOMAIN.socket 2&gt;/dev/null
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><p>(Local) <code>~/.local/bin/grok</code> – Make sure <code>~/.local/bin</code> is in your <code>$PATH</code></p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>
</span></span><span><span>grok<span>()</span> <span>{</span>
</span></span><span><span>    TOP_LEVEL_DOMAIN<span>=</span><span>&#34;dev.0xda.de&#34;</span>
</span></span><span><span>    <span>if</span> <span>[</span> -z <span>&#34;</span>$1<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>        echo <span>&#34;Usage: grok &lt;port&gt; [&lt;name&gt;]&#34;</span>
</span></span><span><span>        <span>return</span> <span>1</span>
</span></span><span><span>    <span>fi</span>
</span></span><span><span>
</span></span><span><span>    local port<span>=</span><span>&#34;</span>$1<span>&#34;</span>
</span></span><span><span>    local name<span>=</span><span>&#34;</span>$2<span>&#34;</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>[</span> -z <span>&#34;</span>$name<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>        <span># Generate a random 12-digit hexadecimal string</span>
</span></span><span><span>        name<span>=</span><span>$(</span>openssl rand -hex 6<span>)</span>
</span></span><span><span>    <span>fi</span>
</span></span><span><span>    echo <span>&#34;Setting up </span><span>${</span>name<span>}</span><span>.</span><span>${</span>TOP_LEVEL_DOMAIN<span>}</span><span>&#34;</span>
</span></span><span><span>    export LC_GROKDOMAIN<span>=</span><span>&#34;</span><span>${</span>name<span>}</span><span>.</span><span>${</span>TOP_LEVEL_DOMAIN<span>}</span><span>&#34;</span>
</span></span><span><span>    ssh user@example.com -o ControlPath<span>=</span>none -o SendEnv<span>=</span>LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:$port
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>grok $@
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>I have been using this quite a bit since building it and the quirks definitely make the experience a little less than ideal. But I also don’t have to run any new applications on my server, don’t have new credentials to worry about, and it works well enough that it’s easy for me to quickly send someone a customized link to a development tunnel.</p>
<p>Should you use this? I’m not sure, really. It feels kinda sketchy to pass the Host header directly to the filesystem, and I’m not particularly happy with giving the whole server read/write to the socket file either.</p>
<p>But it was fun to piece these two pieces of technology together in this surprisingly useful way, using knowledge that isn’t particularly arcane but also isn’t particularly common.</p>
<p>Please <a href="https://twitter.com/intent/tweet?text=%400xdade%20re%3A%20grok%20-%20">tweet me</a> with ways you’d improve this. You can also message me on Bluesky (<a href="https://bsky.app/profile/0xda.de">@0xda.de</a>) or Mastodon (<a href="https://crime.st/@dade">@dade@crime.st</a>).</p>
<h2 id="errata">Errata</h2>
<h3 id="improving-socket-cleanup">Improving socket cleanup</h3>
<p>HN User <a href="https://news.ycombinator.com/item?id=40035922">mcint</a> recommended using bash’s trap command to cleanup the socket on disconnect. By itself this didn’t work because it automatically removed the socket when <code>.ssh/rc</code> finished running. But in awful, inelegant fashion, I combined it with an infinite sleep loop and was able to get a much more reliable cleanup mechanism.</p>
<p>This seems to clean up no matter what – I can ctrl-c and it’ll clean up. I can kill the ssh connection and it’ll clean up. I can kill the ssh connection through my bastion host, get a broken pipe, and it’ll clean up. It’s a considerably more robust cleanup, and equally as hacky to boot.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>if</span> <span>[</span> -n <span>&#34;</span>$LC_GROKDOMAIN<span>&#34;</span> <span>]</span>; <span>then</span>
</span></span><span><span>    chmod o+rw /tmp/$LC_GROKDOMAIN.socket 2&gt;/dev/null
</span></span><span><span>    clean_socket<span>()</span> <span>{</span> rm /tmp/$LC_GROKDOMAIN.socket 2&gt;/dev/null; <span>}</span>
</span></span><span><span>    echo <span>&#34;You can now visit https://</span>$LC_GROKDOMAIN<span> in your browser&#34;</span>
</span></span><span><span>    trap clean_socket EXIT INT HUP;
</span></span><span><span>    <span>while</span> true; <span>do</span> sleep 60; <span>done</span>
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><p>You can also change your <code>grok</code> script’s ssh command to cleanup the output with this in mind, as long as you <em>don’t</em> want an interactive ssh session combined with your dev tunnel.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>ssh user@example.com -o ControlPath<span>=</span>none -o SendEnv<span>=</span>LC_GROKDOMAIN -T -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:$port echo <span>&#34;hello&#34;</span>
</span></span></code></pre></div><p>This adds <code>-T</code>, which disables the pseudo-tty allocation. It’s designed to run simple commands on a remote host without a full shell environment. Hence, <code>echo &#34;hello&#34;</code> at the end of the command now. But what that command is is irrelevant, because our <code>.ssh/rc</code> is now infinitely looping and will never let that code execute. It has the added benefit of not printing out the MOTD, so your shell output is quieter:</p>
<pre tabindex="0"><code>➜ grok 8080 test
Setting up test.dev.0xda.de
Enter passphrase for key &#39;/home/dade/.ssh/id_ed25519&#39;:
You can now visit https://test.dev.0xda.de in your browser
</code></pre><h3 id="security-of-passing-user-input-to-the-filesystem-path">Security of passing user input to the filesystem path</h3>
<p>I also had a couple people ask me about whether or not it was safe to use the <code>$host</code> variable in a path to my filesystem. My understanding of this, based on <a href="https://nginx.org/en/docs/http/request_processing.html">how nginx processes a request</a>, is yes. The TL;DR of it is that <code>$host</code> should be guaranteed to match my <code>server_name</code> regex by the time it reaches the <code>proxy_pass</code> directive, so long as my dev tunnel server block isn’t also the default server block.</p>
<p>Hypothetically, it might be possible to try to access something like <code>Host: ../etc/passwd.dev.0xda.de.socket</code> – however as long as I’m pretty reasonable about not renaming arbitrary important system files with this naming pattern, it’s probably pretty safe. Also I’m <em>fairly</em> sure, but haven’t looked at the source to confirm, that <code>/</code> isn’t valid in a <code>Host</code> header. Attempting to send one to my nginx server results in a 400 bad request instead of a 502 bad gateway, suggesting that it isn’t matching the server block.</p>

            </div></div>
  </body>
</html>
