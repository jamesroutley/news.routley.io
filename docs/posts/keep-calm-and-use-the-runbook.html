<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cortex.io/post/keep-calm-and-use-the-runbook">Original</a>
    <h1>Keep calm and use the runbook</h1>
    
    <div id="readability-page-1" class="page"><div id="w-node-_32987516-cd92-7936-c83c-b0d3724b1a2f-23f8a7b5"><h3>What is a runbook and why is it important?</h3><p><strong>A runbook is a well-defined set of instructions to address a particular situation. </strong>For example, a runbook could be a list of commands to debug a service, or a series of escalation steps when a server goes down.</p><p>Runbooks are important because <strong>they make knowledge easily actionable for someone without domain expertise. </strong>This ensures, for example, that the engineer who created the service<strong> </strong>doesn’t need to be the first line of defense in the event of an outage. Instead, if they create a runbook, anyone else can pick it up and take the right steps to fix the problem. This is <strong>especially necessary in a crisis situation where time is of the essence</strong> <strong>and</strong> <strong>relying on the availability of a particular person simply doesn’t scale</strong>.</p><p>Given their usefulness, runbooks are ubiquitous and are the foundation for any team concerned with reliability. Looking beyond the lens of software, we see that our world is filled with “mini-runbooks” for what to do when the unexpected happens:  “Stop, drop, and roll,” “Break glass in case of emergency,” “Put your mask on before helping others on the airplane.” These statements distill the key actions needed to resolve the situation. They encode the knowledge of experts and ensure that even without one at hand, you can avert a crisis.</p><h3>What are the qualities of a good runbook?</h3><p>Runbooks are most effective when they are readily <strong>available</strong>, easily <strong>actionable, </strong>and up-to-date and <strong>accurate.</strong></p><h4>Available </h4><p>In a crisis, the best runbook you can have is one that exists. Teams should ensure that they <em>proactively </em>create runbooks for important services before the unexpected hits. Best practices may vary: whether it’s having a process to create a new runbook for every service, or whether it’s architecting your systems to ensure that they have common fundamental components that can be addressed by the same runbook. What matters most is that teams should not wait for something to go wrong before they create a runbook. </p><p>Building on the above, the second best runbook you can have is one that you can find. Runbooks should be accessible in a way that anyone can find the right runbook for the problem. Across different companies this can mean different things: powerful internal search tools, well-structured wikis, or even just an organized folder. The specific implementation can vary, but what is most important is that it&#39;s easy for anyone to find and look up the right runbook quickly when needed.</p><h4>Actionable</h4><p>Runbooks should be specific. Assuming that the user does not have the same knowledge as the creator, steps in a runbook should not rely on inferred or ambiguous processes. First, a good runbook should have an obvious trigger criteria so that the user knows when it is applicable. This can be a well-defined start state, or even a series of diagnostic commands to ensure that the runbook will actually be useful. </p><p>Second, if the runbook is determined to be applicable, it should have a clear set of steps. Similar to a decision tree, this helps the user map through all common outcomes: If command X succeeds do Y, otherwise do Z, and so on. Without this level of specificity, users are likely to get stuck following the instructions and will not be able to use the runbook effectively.</p><h4>Accurate</h4><p>While runbooks are meant to be used by those without domain expertise, they should be regularly checked and updated by those with the necessary knowledge. This means not only updating when the underlying functionality of the service changes, but also incorporating learnings from outages. Stale runbooks not only prevent you from solving the problem quickly, but also erode trust in processes overall and make your team less likely to use runbooks in the first place.</p><h4>Automated (optional)</h4><p>While not in our official list of “guidelines that start with A,” runbook automation is an important tool to be aware of. Essentially, many of the steps performed in a runbook, such as running diagnostic commands or triggering alerts, can also be automated as a service. This can help teams easily do initial triaging before having an engineer take a look. In some cases it may even result in an automated fix. </p><p>That said, runbook automation can be complex and is not necessary for all teams. If your team will only experience a few non-critical outages, a manual runbook could more than suffice. Hence the value of automation largely depends on the system’s complexity and the team’s bandwidth.</p><p>The principle of making knowledge accessible for teams is key to building scalable and reliable software. In addition to runbooks, there are many more things you can do: everything from knowing who the owners of a service are to ensuring there are objective well-known standards for quality. These are all ways in which effective distribution of knowledge can help teams succeed. This principle is at the heart of Cortex’s mission to help teams gain visibility into their services and deliver high-quality software. To learn more, check out our demo <a href="https://www.cortex.io/demo" target="_blank">here</a>.</p></div></div>
  </body>
</html>
