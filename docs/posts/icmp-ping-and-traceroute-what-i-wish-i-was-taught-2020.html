<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xkln.net/blog/icmp-ping-and-traceroute--what-i-wish-i-was-taught/">Original</a>
    <h1>ICMP, Ping, and Traceroute – What I wish I was taught (2020)</h1>
    
    <div id="readability-page-1" class="page"><section><p>I wanted to write a post and do a bit of a deepdive into ICMP, ping and traceroute. I’ve found that having a good networking foundation has been a tremendous help in my day to day work. So if you’ve ever used ping or traceroute, and wanted to know a little more, read on.</p>
<p>I’m not going to cover every detail, but a few key topics that have helped me troubleshoot and better understand issues over the years.</p>
<h2>ICMP and Ping</h2>
<h3>ICMP (Internet Control Message Protocol)</h3>
<p>Most traffic on the internet is encapsulated in either TCP, or UDP. Ping however uses a protocol called ICMP. ICMP is a diagnostic protocol and has a number of different message types, each one responsible for communicating a specific event - be it a ping request (called an Echo Request), a ping reply (called an Echo Reply), or a number of other diagnostic results.</p>
<p>Each message type consists of two fields, a <code>Type</code> field, which is a general grouping of similar sub-types, called <code>Codes</code>. For example, the <code>Destination Unreachable</code> type contains multiple <code>Codes</code>, one of which is <code>1</code>, which maps to the message <code>Destination host unreachable</code>. A complete list of ICMP Types can be found on <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Control_messages">Wikipedia</a>.</p>
<p>You’ve no doubt seen these messages when doing pings. If I ping an IP on a network I know my router doesn’t have a route for, we get a <code>Destination host unreachable</code> message from the router (<code>Reply from 10.250.1.1</code>).</p>
<div data-language="text"><pre><code>C:\&gt;ping 10.44.44.4

Pinging 10.44.44.4 with 32 bytes of data:
Reply from 10.250.1.1: Destination host unreachable.
Reply from 10.250.1.1: Destination host unreachable.
Reply from 10.250.1.1: Destination host unreachable.
Reply from 10.250.1.1: Destination host unreachable.

Ping statistics for 10.44.44.4:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)</code></pre></div>
<p>If we check the ICMP Control Messages table, we can see <code>Destination host unreachable</code> maps to <code>Type: 3, Code: 1</code>. We can confirm this with a Wireshark capture, looking at the response packet.</p>
<p><span>
<a href="https://xkln.net/static/95d40215db197e200f0f12295f38dc01/3cf3e/icmp-destination-unreachable.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark Destination host unreachable" title="Wireshark Destination host unreachable" src="https://xkln.net/static/95d40215db197e200f0f12295f38dc01/3cf3e/icmp-destination-unreachable.png" srcset="/static/95d40215db197e200f0f12295f38dc01/4edbd/icmp-destination-unreachable.png 175w,
/static/95d40215db197e200f0f12295f38dc01/3cf3e/icmp-destination-unreachable.png 293w" sizes="(max-width: 293px) 100vw, 293px" loading="lazy"/>
</a>
</span></p>
<p>What’s happening here is our PC is sending a <code>Type 8, Code 0</code> message which is an <code>Echo Request</code> to <code>10.44.44.4</code>. This message reaches our default gateway which checks its routing table for that network, doesn’t find one, and responds to our request accordingly with a <code>Destination host unreachable</code> message.</p>
<p>There is one caveat worth mentioning if you’re trying this at home - this primarily applies to enterprise or business networks. Most residential routers will simply send all traffic they don’t have a specific route for out to the Internet, even if the destination IP is within the RFC1918 private address space. In this case the ISP will simply drop these packets and you will see a <code>Request timed out</code> message instead.</p>
<p><code>Request timed out</code> does not map to an ICMP message type as it’s not a message, rather, it is the absence of any return data.</p>
<p>So why is all this important?</p>
<h3>Know what ICMP messages mean</h3>
<p>The returned ICMP message can give us clues as to what is actually happening. <code>Destination host unreachable</code> is very different from <code>Request timed out</code>. The first indicates we don’t know how to get to a network, the second that we do, but there was no response.</p>
<p>Further, the system that replies with a <code>Destination host unreachable</code> is the system which doesn’t have a path to the requested network - so you immediately know where to start looking.</p>
<p>Let’s dig a little deeper into this because it gets interesting.</p>
<h3>Pinging on your local network</h3>
<p>What happens if you ping a non-existent host on your network? Do you get <code>Request timed out</code>, <code>Destination host unreachable</code>, or something else? What happens if the device is live, but the firewall is blocking ICMP? Can you tell the difference between a non-existent host, and one that simply discards ICMP Echo Requests?</p>
<p>With these questions in mind, let’s ping a device that is set to discard ICMP Echo Requests and see what happens.</p>
<div data-language="text"><pre><code>C:\&gt;ping 10.250.1.5

Pinging 10.250.1.5 with 32 bytes of data:
Request timed out.
Request timed out.
Request timed out.
Request timed out.

Ping statistics for 10.250.1.5:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss)</code></pre></div>
<p>Let’s examine how that looks in Wireshark.</p>
<p><span>
<a href="https://xkln.net/static/41bc833442f570c5e5b68acdb735c8a5/966a0/icmp-firewall-blocked.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark ICMP firewall blocked" title="Wireshark ICMP firewall blocked" src="https://xkln.net/static/41bc833442f570c5e5b68acdb735c8a5/8c557/icmp-firewall-blocked.png" srcset="/static/41bc833442f570c5e5b68acdb735c8a5/4edbd/icmp-firewall-blocked.png 175w,
/static/41bc833442f570c5e5b68acdb735c8a5/13ae7/icmp-firewall-blocked.png 350w,
/static/41bc833442f570c5e5b68acdb735c8a5/8c557/icmp-firewall-blocked.png 700w,
/static/41bc833442f570c5e5b68acdb735c8a5/966a0/icmp-firewall-blocked.png 944w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>We sent 4 ICMP Echo Requests and got no replies, resulting a <code>Request timed out</code>, which is what we would expect when a device’s firewall is set to drop ICMP.</p>
<p>However, what if the device was not on the network at all? Would we get the same result? For this example I’ve removed the device from the network.</p>
<div data-language="text"><pre><code>C:\&gt;ping 10.250.1.5

Pinging 10.250.1.5 with 32 bytes of data:
Reply from 10.250.1.100: Destination host unreachable.
Reply from 10.250.1.100: Destination host unreachable.
Reply from 10.250.1.100: Destination host unreachable.
Reply from 10.250.1.100: Destination host unreachable.

Ping statistics for 10.250.1.5:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)</code></pre></div>
<p>And let’s look at Wireshark.</p>
<p><span>
<a href="https://xkln.net/static/b9dea31e8f2019ed03de36c1d40c3205/73fd0/icmp-no-device.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark ICMP non-existent device" title="Wireshark ICMP non-existent device" src="https://xkln.net/static/b9dea31e8f2019ed03de36c1d40c3205/8c557/icmp-no-device.png" srcset="/static/b9dea31e8f2019ed03de36c1d40c3205/4edbd/icmp-no-device.png 175w,
/static/b9dea31e8f2019ed03de36c1d40c3205/13ae7/icmp-no-device.png 350w,
/static/b9dea31e8f2019ed03de36c1d40c3205/8c557/icmp-no-device.png 700w,
/static/b9dea31e8f2019ed03de36c1d40c3205/73fd0/icmp-no-device.png 793w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>Your eyes aren’t deceiving you, there is nothing there - we’re not even <strong>sending</strong> a single Echo Request.</p>
<p>What is happening here has to do with how packets are switched inside a network segment. When you ping a remote resource (something on the Internet, or on another VLAN), the Layer 2 destination address on the packet is set to your default gateway’s MAC address. However, when you send traffic to a device on your local network, the router does not need to get involved, so the Layer 2 destination address is set to the MAC address of the destination device.</p>
<p>And how does our computer know what the MAC address is? It broadcasts out an ARP Request and listens for the reply containing the address. As there is no device on the network to respond to the ARP Request, the ICMP Echo frame cannot be created, and therefore <em>it never gets sent</em>.</p>
<p>If I change the Wireshark filter to show ARP traffic, here’s what we see.</p>
<p><span>
<a href="https://xkln.net/static/b01a2fae64612c900e93c17f9c7e0c7d/c5bb3/wireshark-arp-requests.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark ARP Requests" title="Wireshark ARP Requests" src="https://xkln.net/static/b01a2fae64612c900e93c17f9c7e0c7d/c5bb3/wireshark-arp-requests.png" srcset="/static/b01a2fae64612c900e93c17f9c7e0c7d/4edbd/wireshark-arp-requests.png 175w,
/static/b01a2fae64612c900e93c17f9c7e0c7d/13ae7/wireshark-arp-requests.png 350w,
/static/b01a2fae64612c900e93c17f9c7e0c7d/c5bb3/wireshark-arp-requests.png 680w" sizes="(max-width: 680px) 100vw, 680px" loading="lazy"/>
</a>
</span></p>
<p>We’re broadcasting out ARP Requests, but as there is no device to respond nothing is returned. Let’s take a look at the full capture (Both ARP and ICMP) of the previous example where the host was live, but dropping ICMP.</p>
<p><span>
<a href="https://xkln.net/static/41e20fa55ec7925f926252c7a22047ee/44fd6/wireshark-icmp-blocked-arp.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark ICMP blocked ARP packets" title="Wireshark ICMP blocked ARP packets" src="https://xkln.net/static/41e20fa55ec7925f926252c7a22047ee/8c557/wireshark-icmp-blocked-arp.png" srcset="/static/41e20fa55ec7925f926252c7a22047ee/4edbd/wireshark-icmp-blocked-arp.png 175w,
/static/41e20fa55ec7925f926252c7a22047ee/13ae7/wireshark-icmp-blocked-arp.png 350w,
/static/41e20fa55ec7925f926252c7a22047ee/8c557/wireshark-icmp-blocked-arp.png 700w,
/static/41e20fa55ec7925f926252c7a22047ee/44fd6/wireshark-icmp-blocked-arp.png 789w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>There it is, we make the same initial ARP Request, but this time we receive a reply with the MAC address, which lets our computer create an appropriately addressed Layer 2 frame, and enables the Echo Requests to be sent.</p>
<p>This essentially means we don’t really need ICMP to detect hosts on our local subnet, if we have an entry in our ARP cache for the IP we’re looking for, it most likely means there is something there.</p>
<div data-language="text"><pre><code>C:\&gt;arp -a 10.250.1.5

Interface: 10.250.1.100 --- 0xa
  Internet Address      Physical Address      Type
  10.250.1.5            6c-41-6a-54-3d-0e     dynamic</code></pre></div>
<p>Despite not receiving a reply to our ping, we can tell there <em>is</em> something there purely by the presence of an entry in our ARP table, or to put it another way, by the fact that we’re even sending ICMP Echo Requests.</p>
<p>To summarize, <code>Destination host unreachable</code> on the same subnet means that there is nothing there, <code>Request timed out</code> means there could be something there, but it’s blocking ICMP.</p>
<p>These are safe rules of thumb, but there are always exceptions.</p>
<p>Your PC may have a cached ARP entry that’s being used to generate the packets. You can clear your ARP cache on Windows with <code>arp -d</code> in an administrative command prompt.</p>
<p>Windows has some <a href="https://support.microsoft.com/en-us/help/949589/description-of-address-resolution-protocol-arp-caching-behavior-in-win">interesting rules</a> around how it maintains and flushes the local ARP cache.</p>
<p>Here we can see the effect of those rules, I’ve re-enabled the device with the address of <code>10.250.1.5</code>, and have removed the firewall rule that blocks ICMP. After a few successful pings I’ve once again removed the device from the network.</p>
<div data-language="text"><pre><code>C:\&gt;ping -t 10.250.1.5

Pinging 10.250.1.5 with 32 bytes of data:
Reply from 10.250.1.5: bytes=32 time&lt;1ms TTL=255
Reply from 10.250.1.5: bytes=32 time&lt;1ms TTL=255
Reply from 10.250.1.5: bytes=32 time&lt;1ms TTL=255
Reply from 10.250.1.5: bytes=32 time&lt;1ms TTL=255
Request timed out.
Request timed out.
Request timed out.
Request timed out.
Request timed out.
Request timed out.
Request timed out.
Reply from 10.250.1.100: Destination host unreachable.
Reply from 10.250.1.100: Destination host unreachable.
Reply from 10.250.1.100: Destination host unreachable.
Reply from 10.250.1.100: Destination host unreachable.
Reply from 10.250.1.100: Destination host unreachable.</code></pre></div>
<p>We can see the first few replies, followed by the device being unplugged, the MAC address remaining in our cache resulting in <code>Request timed out</code> due to lack of replies to our pings, eventually Windows purges the cached entry, and our ARP requests once again go unanswered, finally resulting in <code>Destination host unreachable</code> as we can no longer send the ping requests.</p>
<p>Lastly, another ‘feature’ that can mess with ARP is <a href="https://www.cisco.com/c/en/us/support/docs/ip/dynamic-address-allocation-resolution/13718-5.html">Proxy ARP</a>, though this is rarely enabled (and if it is, it’s more than likely due to misconfiguration or the use of Private VLANs)</p>
<p>Let’s move onto another useful ICMP message code.</p>
<h3>Detecting closed ports</h3>
<p>Sometimes (definitely not always), when a firewall is configured to deny a connection an ICMP message is returned to indicate that the connection is <code>Administratively Prohibited</code>. This has saved me a lot of going back and forth between teams blaming firewalls, servers, etc. A very simple way to test a TCP service is by doing a telnet to the port you want to reach.</p>
<p>In this example I’ll try a telnet to port 80 on my router, which I know is explicitly blocked.</p>
<div data-language="text"><pre><code>C:\&gt;telnet 10.250.1.1 80
Connecting To 10.250.1.1...Could not open connection to the host, on port 80: Connect failed</code></pre></div>
<p>Ok, so telnet itself doesn’t give us the actual ICMP code, but what about Wireshark?</p>
<p><span>
<a href="https://xkln.net/static/4f4b4f1571964d21e773673942938ace/e24fe/icmp-administratively-prohibited1.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark Administratively Prohibited Local" title="Wireshark Administratively Prohibited Local" src="https://xkln.net/static/4f4b4f1571964d21e773673942938ace/8c557/icmp-administratively-prohibited1.png" srcset="/static/4f4b4f1571964d21e773673942938ace/4edbd/icmp-administratively-prohibited1.png 175w,
/static/4f4b4f1571964d21e773673942938ace/13ae7/icmp-administratively-prohibited1.png 350w,
/static/4f4b4f1571964d21e773673942938ace/8c557/icmp-administratively-prohibited1.png 700w,
/static/4f4b4f1571964d21e773673942938ace/e996b/icmp-administratively-prohibited1.png 1050w,
/static/4f4b4f1571964d21e773673942938ace/e24fe/icmp-administratively-prohibited1.png 1073w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>Bingo, we can see a reply from the router with <code>Communication administratively filtered</code>. This tells us our packet is making to all the way to the device (so it’s not being blocked by another firewall or some other network control software like AV heuristics or an IPS), and that the device itself is telling us that the port is not open for business.</p>
<p>We can again confirm the ICMP message type and code in the Wireshark capture.</p>
<p><span>
<a href="https://xkln.net/static/8a3abb48c4e4c3dff56e3f087c392cfb/2cb6c/icmp-administratively-prohibited-ws.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark Administratively Prohibited Packet" title="Wireshark Administratively Prohibited Packet" src="https://xkln.net/static/8a3abb48c4e4c3dff56e3f087c392cfb/2cb6c/icmp-administratively-prohibited-ws.png" srcset="/static/8a3abb48c4e4c3dff56e3f087c392cfb/4edbd/icmp-administratively-prohibited-ws.png 175w,
/static/8a3abb48c4e4c3dff56e3f087c392cfb/13ae7/icmp-administratively-prohibited-ws.png 350w,
/static/8a3abb48c4e4c3dff56e3f087c392cfb/2cb6c/icmp-administratively-prohibited-ws.png 395w" sizes="(max-width: 395px) 100vw, 395px" loading="lazy"/>
</a>
</span></p>
<p>The great thing about this method, is we can tell exactly which device is blocking the connection. I’ve adjusted the firewall rule on my router to block <em>all</em> traffic to port 80 to any host. Let’s see what happens when I try to telnet to google.com on port 80.</p>
<p><span>
<a href="https://xkln.net/static/aaa73452b88c9514aee459ad9683c812/620ae/icmp-administratively-prohibited2.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark Administratively Prohibited WAN" title="Wireshark Administratively Prohibited WAN" src="https://xkln.net/static/aaa73452b88c9514aee459ad9683c812/8c557/icmp-administratively-prohibited2.png" srcset="/static/aaa73452b88c9514aee459ad9683c812/4edbd/icmp-administratively-prohibited2.png 175w,
/static/aaa73452b88c9514aee459ad9683c812/13ae7/icmp-administratively-prohibited2.png 350w,
/static/aaa73452b88c9514aee459ad9683c812/8c557/icmp-administratively-prohibited2.png 700w,
/static/aaa73452b88c9514aee459ad9683c812/620ae/icmp-administratively-prohibited2.png 1043w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>We can see my PC (<code>10.250.1.100</code>) sending the initial <code>TCP SYN</code> packet to the IP which google.com resolved to (<code>216.58.203.110</code>), however, the ICMP reply has originated from the local firewall - <code>10.250.1.1</code>, telling us that connection to that resource has been denied. This process is repeated several times as my PC stubbornly retries several more times with the same result.</p>
<p>While this is a very simple example, in larger corporate networks it can be useful to quickly identify which system is blocking a connection as those networks tend to have much more complexity and it’s not always obvious.</p>
<p>A quick side note here, while somewhat off topic it’s worth mentioning. Many firewalls will instead send back a spoofed <code>TCP RST</code> packet instead of an ICMP <code>Communication administratively filtered</code> message. This especially applies to web filtering or IPS systems which are not inline, but are connected to a SPAN/mirror port.</p>
<h3>Security and Path MTU Discovery</h3>
<p>We can see in the previously linked Wikipedia page that there are many ICMP Types and Codes. Some have been deprecated, and many are generally not used.</p>
<p>Your firewall rules should be configured to permit specific ICMP Types and Codes - do not blindly permit <em>all</em> ICMP because you want pings to work, and don’t blindly drop all ICMP because there are some message types that could be abused. There is a <a href="https://security.stackexchange.com/a/22713/223285">good post on Security StackExchange</a> which discusses some ICMP types that are commonly permitted, and some you should always block.</p>
<p>That’s it for ICMP Types, lets move on.</p>
<h3>High latency isn’t always a problem</h3>
<p>Many times when we use ping we’re not only looking at reachability, but also latency. While high latencies can often be problematic, it’s not always the case. Lets examine a scenario where a high ping to a device may not be a problem.</p>
<p>Most modern enterprise routers and switches perform packet forwarding (routing and switching) in ASICs (Application Specific Integrated Circuits). These are hardware chips inside the device that are dedicated to these functions, and they are <em>fast</em>. The vast majority of packets passing through a router or switch are handled by ASICs.</p>
<p>However, a packet that is destined <em>for</em> the device, is not. They are punted off to the general purpose CPU which handles many other tasks, such as routing updates, packet fragmentation, etc. This creates the possibility of a scenario where a router may be CPU starved, but still be able to process normal packet forwarding at the usual hardware accelerated speeds.</p>
<p><span>
<a href="https://xkln.net/static/6b47b9062129484dfc8ebb51654bc907/3cb0f/high-latency.png" target="_blank" rel="noopener">
<span></span>
<img alt="High latency" title="High latency" src="https://xkln.net/static/6b47b9062129484dfc8ebb51654bc907/8c557/high-latency.png" srcset="/static/6b47b9062129484dfc8ebb51654bc907/4edbd/high-latency.png 175w,
/static/6b47b9062129484dfc8ebb51654bc907/13ae7/high-latency.png 350w,
/static/6b47b9062129484dfc8ebb51654bc907/8c557/high-latency.png 700w,
/static/6b47b9062129484dfc8ebb51654bc907/3cb0f/high-latency.png 708w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>This manifests itself as high latency to a specific hop (device) along the path to the desired resource, but acceptable latency to the end resource.</p>
<p>Even if the device is not CPU starved, there are control plane policies that network administrators can define which effectively apply QoS rules that can have a detrimental effect on ping response times. These policies are designed to ensure that critical services such as routing updates and management access are not interrupted by excessive non-critical traffic such as ICMP packet processing. In some cases ICMP packets are completely dropped if the configured policy threshold is hit - this can look like packet loss, but many times isn’t relevant to normal packets simply passing through the device as they do not have these policies applied to them.</p>
<p>Don’t make the assumption that if a device along the path is slow to respond to a ping (or only responds intermittently) that the issue lies on that device.</p>
<h3>Round trip times and Asymmetric Routing</h3>
<p>Finally, what are we actually measuring when we look at ping latency? It’s measurement of <em>round trip time</em>, that is, the ping request being sent from your PC, reaching the destination device, being processed, a reply being generated, sent back to your PC, and processed.</p>
<p>The Internet is complex, with peering agreements between ISPs and entities largely determining which path a packet takes through the web. A key concept is that the path <em>to</em> a device may not be the same as the return path <em>from</em> that device.</p>
<p>Consider the following simplified diagram, the sever is located in a datacenter with two internet connections via different ISPs.</p>
<p><span>
<a href="https://xkln.net/static/0e8668d853d713b5cf1ace7499d619e5/0f67e/asymmetric-routing-round-trip-time.png" target="_blank" rel="noopener">
<span></span>
<img alt="Asymmetric Routing" title="Asymmetric Routing" src="https://xkln.net/static/0e8668d853d713b5cf1ace7499d619e5/8c557/asymmetric-routing-round-trip-time.png" srcset="/static/0e8668d853d713b5cf1ace7499d619e5/4edbd/asymmetric-routing-round-trip-time.png 175w,
/static/0e8668d853d713b5cf1ace7499d619e5/13ae7/asymmetric-routing-round-trip-time.png 350w,
/static/0e8668d853d713b5cf1ace7499d619e5/8c557/asymmetric-routing-round-trip-time.png 700w,
/static/0e8668d853d713b5cf1ace7499d619e5/0f67e/asymmetric-routing-round-trip-time.png 921w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>Due to peering arrangements, the datacenter provider prefers the path in green when sending data to your ISP, but they don’t have a lot of control over how data is sent <em>to</em> them <em>from</em> your ISP. The result is that the ICMP Echo Request takes the path in blue, while the ICMP Echo Reply takes the path in green.</p>
<p>What if there is congestion or a fault on the link drawn in red? You’re going to see high latency when you ping the server, but it won’t have anything to do with the server or datacenter.</p>
<p>That’s it for pings, but lets continue the asymmetric routing story with traceroute.</p>
<h2>Traceroute</h2>
<h3>Refresher - How does traceroute work?</h3>
<p>It’s important we’re all on the same page regarding the operation of traceroute, so let’s quickly cover it.</p>
<p>Traceroute works by sending packets to the <strong>final destination</strong>, starting with an IP TTL (Time To Live) of 1, and incrementing it after every hop until a reply is received from destination resource. TTL is a field in the IP header that is decremented by 1 at each layer 3 device it passes through. When it reaches 0 the packet stops being forwarded, an error is generated and returned within an ICMP packet.</p>
<p>This means, since traceroute starts with a TTL of 1, every hop along the way to our destination receives a packet where the TTL is decremented to 0, and therefore responds with an ICMP <code>Time to live exceeded in transit</code> message, which is ICMP <code>Type 11, Code 0</code>.</p>
<p><span>
<a href="https://xkln.net/static/781eb7341b13a8d7421faaa740b6b00e/2b41d/icmp-ttl-exceeded.png" target="_blank" rel="noopener">
<span></span>
<img alt="ICMP TTL Exceeded" title="ICMP TTL Exceeded" src="https://xkln.net/static/781eb7341b13a8d7421faaa740b6b00e/2b41d/icmp-ttl-exceeded.png" srcset="/static/781eb7341b13a8d7421faaa740b6b00e/4edbd/icmp-ttl-exceeded.png 175w,
/static/781eb7341b13a8d7421faaa740b6b00e/2b41d/icmp-ttl-exceeded.png 338w" sizes="(max-width: 338px) 100vw, 338px" loading="lazy"/>
</a>
</span></p>
<p>This ordered flow of ICMP TTL Exceeded packets is what allows us to map the path to the resource. Here is an example traceroute from my PC to 1.1.1.1</p>
<div data-language="text"><pre><code>C:\&gt;tracert 1.1.1.1

Tracing route to one.one.one.one [1.1.1.1]
over a maximum of 30 hops:

  1    &lt;1 ms    &lt;1 ms    &lt;1 ms  10.250.1.1
  2    *        *        *      Request timed out.
  3    16 ms    16 ms    16 ms  58.160.251.129
  4    20 ms    12 ms    17 ms  bundle-ether4.way-edge901.adelaide.telstra.net [203.50.116.104]
  5    19 ms    35 ms    14 ms  bundle-ether9.way-core10.adelaide.telstra.net [203.50.11.156]
  6    16 ms    26 ms    14 ms  bundle-ether1.way-edge903.adelaide.telstra.net [203.50.6.13]
  7    24 ms    13 ms    24 ms  twi3395298.lnk.telstra.net [203.54.226.194]
  8    11 ms    12 ms    13 ms  one.one.one.one [1.1.1.1]

Trace complete.</code></pre></div>
<p>Let’s see how lines 1 and 2 look in Wireshark.</p>
<p><span>
<a href="https://xkln.net/static/1e6a141ec573bf0eda67c82d49edf8c2/0f67e/traceroute1.png" target="_blank" rel="noopener">
<span></span>
<img alt="Wireshark Traceroute" title="Wireshark Traceroute" src="https://xkln.net/static/1e6a141ec573bf0eda67c82d49edf8c2/8c557/traceroute1.png" srcset="/static/1e6a141ec573bf0eda67c82d49edf8c2/4edbd/traceroute1.png 175w,
/static/1e6a141ec573bf0eda67c82d49edf8c2/13ae7/traceroute1.png 350w,
/static/1e6a141ec573bf0eda67c82d49edf8c2/8c557/traceroute1.png 700w,
/static/1e6a141ec573bf0eda67c82d49edf8c2/0f67e/traceroute1.png 921w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>There are a few things to note.</p>
<ul>
<li>Firstly, the destination for packets sent by my PC (<code>10.250.1.1</code>) is always <code>1.1.1.1</code>.</li>
<li>We send 3 ICMP Echo Requests to each hop before the TTL is incremented, these map to the latency figures seen in the output</li>
<li>The packets begin with a TTL of 1 for the first hop, and are incremented to 2 for the second hop</li>
<li>The second hop does not respond, therefore we show a <code>Request timed out</code> and move on</li>
<li>By default, Windows uses ICMP packets for traceroute, while Linux uses UDP (not relevant here but it’s useful interview trivia)</li>
</ul>
<p>Let’s pick up where we left off - asymmetric routing.</p>
<h3>Asymmetric Routing - Traceroute edition</h3>
<p>One of the most important concepts to understand when looking at traceroute data to is that you’re only seeing <em>one</em> path - the path from the source device (where the traceroute command is ran) to the destination device. As our diagram above shows, return packets may take a completely different path, but we have absolutely no visibility into this.</p>
<p>Let’s demonstrate this with a quick lab. I have the following configured in GNS3.</p>
<p><span>
<a href="https://xkln.net/static/f0605892c05953eedb168ab72d1f3b48/2e195/traceroute-lab.png" target="_blank" rel="noopener">
<span></span>
<img alt="GNS3 Traceroute Lab" title="GNS3 Traceroute Lab" src="https://xkln.net/static/f0605892c05953eedb168ab72d1f3b48/8c557/traceroute-lab.png" srcset="/static/f0605892c05953eedb168ab72d1f3b48/4edbd/traceroute-lab.png 175w,
/static/f0605892c05953eedb168ab72d1f3b48/13ae7/traceroute-lab.png 350w,
/static/f0605892c05953eedb168ab72d1f3b48/8c557/traceroute-lab.png 700w,
/static/f0605892c05953eedb168ab72d1f3b48/2e195/traceroute-lab.png 782w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>The configuration is fairly simple, we’re using two routers to emulate a PC and a Server (labelled as such). Packets from the PC to the Server take the lower path via <code>PC -&gt; R1 -&gt; R2 -&gt; R3 -&gt; Server</code>, but packets from the Server to the PC take the upper path via <code>Server -&gt; R3 -&gt; R4 -&gt; R5 -&gt; R6 -&gt; R1 -&gt; PC</code>.</p>
<p>Let’s see what this looks like in a traceroute, first from the PC to the Server. The output will be a little different to before as we’re doing this in Cisco IOS CLI but it should still make sense. We can also ignore the reported latencies as they are of no relevance here and are caused by emulated hardware.</p>
<div data-language="text"><pre><code>PC#traceroute 192.168.1.100

Type escape sequence to abort.
Tracing the route to 192.168.1.100

  1 10.250.1.1 28 msec 16 msec 24 msec
  2 10.1.2.2 40 msec 36 msec 36 msec
  3 10.2.3.2 80 msec 76 msec 88 msec
  4 192.168.1.100 84 msec 124 msec 108 msec</code></pre></div>
<p>We can see the exact path we described above. How about from the Server to the PC?</p>
<div data-language="text"><pre><code>Server#traceroute 10.250.1.100

Type escape sequence to abort.
Tracing the route to 10.250.1.100

  1 192.168.1.1 16 msec 20 msec 16 msec
  2 10.3.4.2 40 msec 44 msec 36 msec
  3 10.4.5.2 76 msec 44 msec 76 msec
  4 10.5.6.2 60 msec 104 msec 92 msec
  5 10.1.6.1 80 msec 76 msec 60 msec
  6 10.250.1.100 112 msec 120 msec 84 msec</code></pre></div>
<p>There we have it - a completely different path to before. If we only had a traceroute from one side of the connection we would have zero insight into what the return path looked like. What if the issue we were diagnosing was along the return path? A single traceroute would be of little use, and could cause us to misdiagnose the issue. Let’s simulate that - I’m going to bring down the link between <code>R5</code> and <code>R6</code>. What will the traceroute from the PC to the Server look like? Place your bets!</p>
<p><span>
<a href="https://xkln.net/static/c2fb29057c0bbed58815e92b1e939e6d/2e195/traceroute-lab-broken.png" target="_blank" rel="noopener">
<span></span>
<img alt="GNS3 Traceroute Lab" title="GNS3 Traceroute Lab" src="https://xkln.net/static/c2fb29057c0bbed58815e92b1e939e6d/8c557/traceroute-lab-broken.png" srcset="/static/c2fb29057c0bbed58815e92b1e939e6d/4edbd/traceroute-lab-broken.png 175w,
/static/c2fb29057c0bbed58815e92b1e939e6d/13ae7/traceroute-lab-broken.png 350w,
/static/c2fb29057c0bbed58815e92b1e939e6d/8c557/traceroute-lab-broken.png 700w,
/static/c2fb29057c0bbed58815e92b1e939e6d/2e195/traceroute-lab-broken.png 782w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<div data-language="text"><pre><code>PC#traceroute 192.168.1.100

Type escape sequence to abort.
Tracing the route to 192.168.1.100

  1 10.250.1.1 24 msec 24 msec 16 msec
  2 10.1.2.2 36 msec 36 msec 48 msec
  3  *  *  *
  4  *  *  *
  5  *  *  *
  6  *  *  *
  7  *  *  *
  # Output truncated...
</code></pre></div>
<p>Despite the fault being on <code>R5</code>, our output shows no indication of that, in fact, many would look at this and conclude that the issue is on <code>R2</code> since our packets get no further. What is actually happening is that every device after <code>R2</code> (so from <code>R3</code> onwards) the return packets take the upper path which is not able to route the traffic due to the broken link.</p>
<p>However, if we now attempt the traceroute from the server, we get a more accurate picture.</p>
<div data-language="text"><pre><code>Server#traceroute 10.250.1.100

Type escape sequence to abort.
Tracing the route to 10.250.1.100

  1 192.168.1.1 16 msec 16 msec 20 msec
  2 10.3.4.2 32 msec 40 msec 44 msec
  3 10.4.5.2 64 msec 44 msec 76 msec
  4 10.4.5.2 !H  !H  !H</code></pre></div>
<p>The <code>!H</code> in the output from <code>10.4.5.2</code> maps to <code>Host Unreachable</code> in Cisco IOS syntax - that is, <code>R5</code> no longer has a path (route) to our final destination of <code>10.250.1.100</code>.</p>
<p>For this reason when using traceroute to troubleshoot connectivity issues it’s really important to try to get the results from both sides of the connection.</p>
<p>Let’s move on to an interesting side effect MPLS networks have on reported traceroute latencies.</p>
<h3>Traceroute and MPLS</h3>
<p>With normal IP routing each device along a path decides how to route the packet. The destination IP address is pulled out of the IP header, a routing table lookup is done, and the packet is sent on its way, out whatever interface that particular router decided was the best for that destination network.</p>
<p><span>
<a href="https://xkln.net/static/2892922efbd459be9c37a78ded92d03c/9d5da/routing.png" target="_blank" rel="noopener">
<span></span>
<img alt="Routing" title="Routing" src="https://xkln.net/static/2892922efbd459be9c37a78ded92d03c/8c557/routing.png" srcset="/static/2892922efbd459be9c37a78ded92d03c/4edbd/routing.png 175w,
/static/2892922efbd459be9c37a78ded92d03c/13ae7/routing.png 350w,
/static/2892922efbd459be9c37a78ded92d03c/8c557/routing.png 700w,
/static/2892922efbd459be9c37a78ded92d03c/9d5da/routing.png 871w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>With MPLS (Multiprotocol Label Switching) the first router in the path determines the <em>entire</em> path to the destination, and all subsequent routers mindlessly adhere to that path.</p>
<p><span>
<a href="https://xkln.net/static/385e10433b946e53fec58f5099926873/71c8e/mpls-routing.png" target="_blank" rel="noopener">
<span></span>
<img alt="MPLS Routing" title="MPLS Routing" src="https://xkln.net/static/385e10433b946e53fec58f5099926873/8c557/mpls-routing.png" srcset="/static/385e10433b946e53fec58f5099926873/4edbd/mpls-routing.png 175w,
/static/385e10433b946e53fec58f5099926873/13ae7/mpls-routing.png 350w,
/static/385e10433b946e53fec58f5099926873/8c557/mpls-routing.png 700w,
/static/385e10433b946e53fec58f5099926873/71c8e/mpls-routing.png 875w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>The caveat here is that even diagnostic error packets, such as those generated when a TTL Expired condition occurs are still sent on along the <em>entire</em> path before being returned to the source.</p>
<p><span>
<a href="https://xkln.net/static/ced7b7485808285787ee7be516ab68fb/62de4/mpls-traceroute.png" target="_blank" rel="noopener">
<span></span>
<img alt="MPLS Traceroute" title="MPLS Traceroute" src="https://xkln.net/static/ced7b7485808285787ee7be516ab68fb/8c557/mpls-traceroute.png" srcset="/static/ced7b7485808285787ee7be516ab68fb/4edbd/mpls-traceroute.png 175w,
/static/ced7b7485808285787ee7be516ab68fb/13ae7/mpls-traceroute.png 350w,
/static/ced7b7485808285787ee7be516ab68fb/8c557/mpls-traceroute.png 700w,
/static/ced7b7485808285787ee7be516ab68fb/62de4/mpls-traceroute.png 746w" sizes="(max-width: 700px) 100vw, 700px" loading="lazy"/>
</a>
</span></p>
<p>Imagine any router in the path being being in a different country or state, this has the inadvertent effect of showing a consistently high latency across the entire traceroute (or at least across the MPLS sections of the path) as each TTL Expired message must traverse the full path before being sent back.</p>
<p>That’s it for now, hope this has been useful, ping me if you have any comments!</p></section></div>
  </body>
</html>
