<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matheustavares.gitlab.io/posts/committing-without-git">Original</a>
    <h1>Committing Without Git</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p>Our goal is to create a branch with two commits: the first adding a single
README file, and the second changing this file slightly. <strong>All of this
without running git.</strong></p>

<h2 id="first-of-all-why">First of all, why?</h2>

<p>Chances are if you clicked on this post I don’t have to convince you why anyone
would want to do this… ‘cause it’s fun! :) But also, it should help understand
some of the main data structures in git, the “git objects”. I personally think
understanding how they work and how they relate to one another is deeply
valuable and allows for a better experience when using git.</p>

<h2 id="what-will-you-need">What will you need?</h2>

<p>This is a hands-on tutorial, in the sense that you should be able to copy
the code snippets and make commits without git on your own machine. We will be
doing everything with python (I wanted to do it in Bash, but Bash
strings cannot include the null byte and that complicates things quite a bit).</p>

<p><strong>NOTE:</strong> although following these steps should produce a valid git commit,
it’s advisable not to use this “in production” as git commands will perform
a lot of safe checks and special handling that we will skip for the sake
of simplicity. If you need to create commits programmatically, check
<a href="https://libgit2.org/">libgit2</a>.</p>

<h2 id="what-is-a-git-object-btw">What is a git object, BTW?</h2>

<p>Object are immutable units of storage in Git. They are compressed using the
DEFLATE algorithm, and referenced by the SHA-1 hash of their contents (though
there is a work in progress to support SHA-256). You can see the objects at the
<code>.git/objects</code> directory of any git repo; some will be inside two-hex-digits
subdirectories (these are called loose object), and some will be collective
stored in files under <code>.git/objects/pack</code> (these are called
packed objects). The latter is more optimized as it allows to use “deltas” to
minimize redundancies when storing similar objects.</p>

<p>Objects are one of the most important structures in Git; they are responsible
for storing the different versions of the project files, as well as other
metadata like the structure of the directories, authors and dates of each
commit, etc. Here is an example containing the four most important git
objects and how they interact with one another:</p>

<p><img src="https://matheustavares.gitlab.io/assets/committing-without-git/git-objects.png" alt="git objects diagram"/></p>

<p>Yes, <strong>commits are not diffs</strong>, but snapshots of the whole project at a given
time (stored in an efficient manner, of course). The diffs are generated on-the-fly
when needed, such as when running <code>git show &lt;commit&gt;</code>.</p>

<h2 id="making-a-blob">Making a blob</h2>

<p>Without further ado, let’s start writing some code. To start, we need a way
to make blobs (Binary Large Objects), which are used to store file contents. A
blob has the following structure:</p>

<div><div><pre><code>blob {content size}{null byte}{content}
</code></pre></div></div>

<p>In fact, the header part is similar across different objects, so let’s create a
<code>write_obj()</code> auxiliary function, which will be responsible for creating and
storing a loose object in our git repo:</p>

<div><div><pre><code><span>import</span> <span>hashlib</span><span>,</span> <span>zlib</span><span>,</span> <span>os</span>

<span>def</span> <span>write_obj</span><span>(</span><span>objtype</span><span>,</span> <span>content</span><span>):</span>
    <span>&#39;&#39;&#39;
    Writes the loose object to the git object data base and returns
    its sha1 object. The content must be a byte stream.
    &#39;&#39;&#39;</span>
    <span>data</span> <span>=</span> <span>f</span><span>&#34;</span><span>{</span><span>objtype</span><span>}</span><span> </span><span>{</span><span>len</span><span>(</span><span>content</span><span>)</span><span>}</span><span>\0</span><span>&#34;</span><span>.</span><span>encode</span><span>()</span> <span>+</span> <span>content</span>
    <span>sha1</span> <span>=</span> <span>hashlib</span><span>.</span><span>sha1</span><span>(</span><span>data</span><span>)</span>
    <span>hex_sha1</span> <span>=</span> <span>sha1</span><span>.</span><span>hexdigest</span><span>()</span>
    <span>path</span> <span>=</span> <span>f</span><span>&#34;.git/objects/</span><span>{</span><span>hex_sha1</span><span>[</span><span>:</span><span>2</span><span>]</span><span>}</span><span>/</span><span>{</span><span>hex_sha1</span><span>[</span><span>2</span><span>:</span><span>]</span><span>}</span><span>&#34;</span>
    <span>os</span><span>.</span><span>makedirs</span><span>(</span><span>os</span><span>.</span><span>path</span><span>.</span><span>dirname</span><span>(</span><span>path</span><span>),</span> <span>exist_ok</span><span>=</span><span>True</span><span>)</span>
    <span>with</span> <span>open</span><span>(</span><span>path</span><span>,</span> <span>&#34;wb&#34;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
        <span>f</span><span>.</span><span>write</span><span>(</span><span>zlib</span><span>.</span><span>compress</span><span>(</span><span>data</span><span>))</span>
    <span>return</span> <span>sha1</span>
</code></pre></div></div>

<p>Writing a blob now it’s a piece of cake:</p>

<div><div><pre><code><span>def</span> <span>write_blob</span><span>(</span><span>content</span><span>):</span>
    <span>return</span> <span>write_obj</span><span>(</span><span>&#34;blob&#34;</span><span>,</span> <span>content</span><span>.</span><span>encode</span><span>())</span>
</code></pre></div></div>

<h2 id="making-a-tree">Making a tree</h2>

<p>Next, we need a way to describe the directory structure which will contain
our README file. That’s the job for a tree object, which is structured as:</p>

<div><div><pre><code>tree {content size}{null byte}[list of entries]
</code></pre></div></div>

<p>Where each entry has the format:</p>

<div><div><pre><code>{mode} {filename}{null byte}{sha1 of tree or blob in binary}
</code></pre></div></div>

<p>We won’t go into to much detail about the file mode, so its sufficient to say
that <code>100644</code> represents a regular file with no execution permission.</p>

<p>Note that, in git, all the file attributes (i.e. its name and mode) are stored
in the directory structure, not the blob. The blob only holds the file
contents. “What about subdirectories?” - you may ask. These are represented by
trees as well, whose hashes are referenced by the parent tree. Anyway, here is
our <code>write_tree()</code> function:</p>

<div><div><pre><code><span>def</span> <span>write_tree</span><span>(</span><span>filenames</span><span>,</span> <span>hashes</span><span>):</span>
    <span>mode</span> <span>=</span> <span>100644</span>
    <span>entries</span> <span>=</span> <span>b</span><span>&#34;&#34;</span>
    <span>for</span> <span>name</span><span>,</span> <span>hash</span> <span>in</span> <span>zip</span><span>(</span><span>filenames</span><span>,</span> <span>hashes</span><span>):</span>
        <span>entries</span> <span>+=</span> <span>f</span><span>&#34;</span><span>{</span><span>mode</span><span>}</span><span> </span><span>{</span><span>name</span><span>}</span><span>\0</span><span>&#34;</span><span>.</span><span>encode</span><span>()</span> <span>+</span> <span>hash</span>
    <span>return</span> <span>write_obj</span><span>(</span><span>&#34;tree&#34;</span><span>,</span> <span>entries</span><span>)</span>
</code></pre></div></div>

<h2 id="commit-it">Commit it</h2>

<p>The last step is to create a commit to encompass our tree object. A commit
in git has the following structure, where the “parents” section is optional
and may contain as many parents as needed:</p>

<div><div><pre><code>tree {hash}
parent hash1
parent hash2
...
author {name} &lt;{email}&gt; {author_date} {author_timezone}
committer {committer} &lt;{email}&gt; {committer_date} {committer_timezone}

{commit message}
</code></pre></div></div>

<p>Some important things to highlight here: the author and committer date are
stored as seconds since the Epoch; the timezone is encoded as an offset from
UTC; and yes, the author may be different from the committer. This happens,
for example, when you cherry-pick a commit authored by another person. The
new commit will have the same author, but you will be set as the committer.</p>

<p>OK, let’s write our function to create a commit:</p>

<div><div><pre><code><span>import</span> <span>time</span>

<span>def</span> <span>write_commit</span><span>(</span><span>tree_sha1</span><span>,</span> <span>parents</span><span>,</span> <span>author</span><span>,</span> <span>committer</span><span>,</span> <span>msg</span><span>):</span>
    <span>content</span> <span>=</span> <span>f</span><span>&#34;tree </span><span>{</span><span>tree_sha1</span><span>}</span><span>\n</span><span>&#34;</span>
    <span>for</span> <span>parent</span> <span>in</span> <span>parents</span><span>:</span>
        <span>content</span> <span>+=</span> <span>f</span><span>&#34;parent </span><span>{</span><span>parent</span><span>}</span><span>\n</span><span>&#34;</span>
    <span>content</span> <span>+=</span> <span>f</span><span>&#34;author </span><span>{</span><span>author</span><span>}</span><span> </span><span>{</span><span>int</span><span>(</span><span>time</span><span>.</span><span>time</span><span>())</span><span>}</span><span> </span><span>{</span><span>time</span><span>.</span><span>strftime</span><span>(</span><span>&#39;%z&#39;</span><span>)</span><span>}</span><span>\n</span><span>&#34;</span>
    <span>content</span> <span>+=</span> <span>f</span><span>&#34;committer </span><span>{</span><span>committer</span><span>}</span><span> </span><span>{</span><span>int</span><span>(</span><span>time</span><span>.</span><span>time</span><span>())</span><span>}</span><span> </span><span>{</span><span>time</span><span>.</span><span>strftime</span><span>(</span><span>&#39;%z&#39;</span><span>)</span><span>}</span><span>\n</span><span>&#34;</span>
    <span>content</span> <span>+=</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
    <span>content</span> <span>+=</span> <span>msg</span>
    <span>return</span> <span>write_obj</span><span>(</span><span>&#34;commit&#34;</span><span>,</span> <span>content</span><span>.</span><span>encode</span><span>())</span>
</code></pre></div></div>

<h2 id="branches">Branches</h2>

<p>With all of the above set, we can write a simple function that takes one of
our created commits’ hash and creates a branch on it:</p>

<div><div><pre><code><span>def</span> <span>write_branch</span><span>(</span><span>name</span><span>,</span> <span>hash</span><span>):</span>
    <span>with</span> <span>open</span><span>(</span><span>f</span><span>&#34;.git/refs/heads/</span><span>{</span><span>name</span><span>}</span><span>&#34;</span><span>,</span> <span>&#34;w&#34;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
        <span>f</span><span>.</span><span>write</span><span>(</span><span>hash</span><span>)</span>
</code></pre></div></div>

<p>If this seems confusing to you it may be because we usually think of branches
as commit chains, but in reality, they are nothing more than labels. The way
git retrieves the commit chain (or better yet, the graph) is by traversing
the commits through their “parent” pointers, starting from the branch’s tip
commit. Furthermore, if we didn’t create a branch after making our commits here,
they would be considered dangling objects because they can’t be reached from
any reference (branch, tag, HEAD, etc.). So git’s garbage collector would
eventually prune them from the repo.</p>

<h2 id="lets-test">Let’s test!</h2>

<p>Finally, let’s wrap it all together:</p>

<div><div><pre><code><span># First commit
</span><span>author</span> <span>=</span> <span>&#34;John Doe &lt;john@doe&gt;&#34;</span>
<span>blob1_sha1</span> <span>=</span> <span>write_blob</span><span>(</span><span>&#34;This is a simple README file</span><span>\n</span><span>&#34;</span><span>)</span>
<span>tree1_sha1</span> <span>=</span> <span>write_tree</span><span>([</span><span>&#34;README&#34;</span><span>],</span> <span>[</span><span>blob1_sha1</span><span>.</span><span>digest</span><span>()])</span>
<span>commit1_sha1</span>  <span>=</span> <span>write_commit</span><span>(</span><span>tree1_sha1</span><span>.</span><span>hexdigest</span><span>(),</span> <span>[],</span> <span>author</span><span>,</span> <span>author</span><span>,</span>
                            <span>&#34;Add the README file&#34;</span><span>)</span>

<span># Second commit
</span><span>blob2_sha1</span> <span>=</span> <span>write_blob</span><span>(</span><span>&#34;This is a simple README file</span><span>\n</span><span>With one extra line</span><span>\n</span><span>&#34;</span><span>)</span>
<span>tree2_sha1</span> <span>=</span> <span>write_tree</span><span>([</span><span>&#34;README&#34;</span><span>],</span> <span>[</span><span>blob2_sha1</span><span>.</span><span>digest</span><span>()])</span>
<span>commit2_sha1</span>  <span>=</span> <span>write_commit</span><span>(</span><span>tree2_sha1</span><span>.</span><span>hexdigest</span><span>(),</span> <span>[</span><span>commit1_sha1</span><span>.</span><span>hexdigest</span><span>()],</span>
                             <span>author</span><span>,</span> <span>author</span><span>,</span> <span>&#34;Add another line to README&#34;</span><span>)</span>

<span># Create branch
</span><span>write_branch</span><span>(</span><span>&#34;my_branch&#34;</span><span>,</span> <span>commit2_sha1</span><span>.</span><span>hexdigest</span><span>())</span>
</code></pre></div></div>

<p>And now, let’s validate it with git:</p>

<div><div><pre><code><span>$</span> git log -p my_branch

commit 28188fd39b658ff830cd063de722e3803561eef2 (my_branch)
<span>Author: John Doe &lt;john@doe&gt;
Date:   Thu Dec 28 08:07:23 2023 -0300
</span>
    Add another line to README

diff --git a/README b/README
<span>index a0a40df..fe62de5 100644
</span><span>--- a/README
</span><span>+++ b/README
</span><span>@@ -1 +1,2 @@</span>
 This is a simple README file
<span>+With one extra line
</span>
commit a33ef02efcf8616ff65faf746780971e740c31c6
<span>Author: John Doe &lt;john@doe&gt;
Date:   Thu Dec 28 08:07:23 2023 -0300
</span>
    Add the README file

diff --git a/README b/README
<span>new file mode 100644
</span><span>index 0000000..a0a40df
</span><span>--- /dev/null
</span><span>+++ b/README
</span><span>@@ -0,0 +1 @@</span>
<span>+This is a simple README file
</span></code></pre></div></div>

<p>Success! :) You can find a condensed script version of this code here: <a href="https://matheustavares.gitlab.io/assets/committing-without-git/commit.py">commit.py</a>.</p>

<h3 id="further-reading">Further reading</h3>

<ol>
  <li>Git Book, <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">Chapter 10.2 - Git Objects</a></li>
  <li>My <a href="https://matheustavares.gitlab.io/slides/git_under_the_hood_en.pdf">“Git Under the Hood”</a> slides</li>
  <li><a href="https://www.youtube.com/watch?v=xbLVvrb2-fY">Introduction to Git</a> talk by Scott Chacon</li>
  <li><a href="https://public-inbox.org/git/5dab3dc6-3942-422e-d29d-3e8682ebc4df@gmail.com/T/#mf6c760fd87f7416d39e5ac54e9e33df9d835be87">post: a tour of git’s object types</a> by Emily Shaffer, Junio C Hamano, and others.</li>
  <li><a href="https://git-scm.com/docs/pack-format">pack-format docs</a> (to understand more about packfiles and deltification).</li>
</ol>

        </div></div>
  </body>
</html>
