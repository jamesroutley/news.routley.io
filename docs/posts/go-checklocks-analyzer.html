<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/google/gvisor/tree/master/tools/checklocks">Original</a>
    <h1>Go CheckLocks Analyzer</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">

<p dir="auto">Checklocks is an analyzer for lock and atomic constraints. The analyzer relies
on explicit annotations to identify fields that should be checked for access.</p>
<h2 dir="auto"><a id="user-content-atomic-annotations" aria-hidden="true" href="#atomic-annotations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Atomic annotations</h2>
<p dir="auto">Individual struct members may be noted as requiring atomic access. These
annotations are of the form:</p>
<div data-snippet-clipboard-copy-content="type foo struct {
  // +checkatomic
  bar int32
}"><pre><span>type</span> <span>foo</span> <span>struct</span> {
  <span>// +checkatomic</span>
  <span>bar</span> <span>int32</span>
}</pre></div>
<p dir="auto">This will ensure that all accesses to bar are atomic, with the exception of
operations on newly allocated objects.</p>
<h2 dir="auto"><a id="user-content-lock-annotations" aria-hidden="true" href="#lock-annotations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lock annotations</h2>
<p dir="auto">Individual struct members may be protected by annotations that indicate locking
requirements for accessing members. These annotations are of the form:</p>
<div data-snippet-clipboard-copy-content="type foo struct {
    mu sync.Mutex
    // +checklocks:mu
    bar int

    foo int  // No annotation on foo means it&#39;s not guarded by mu.

    secondMu sync.Mutex

    // Multiple annotations indicate that both must be held but the
    // checker does not assert any lock ordering.
    // +checklocks:secondMu
    // +checklocks:mu
    foobar int
}"><pre><span>type</span> <span>foo</span> <span>struct</span> {
    <span>mu</span> sync.<span>Mutex</span>
    <span>// +checklocks:mu</span>
    <span>bar</span> <span>int</span>

    <span>foo</span> <span>int</span>  <span>// No annotation on foo means it&#39;s not guarded by mu.</span>

    <span>secondMu</span> sync.<span>Mutex</span>

    <span>// Multiple annotations indicate that both must be held but the</span>
    <span>// checker does not assert any lock ordering.</span>
    <span>// +checklocks:secondMu</span>
    <span>// +checklocks:mu</span>
    <span>foobar</span> <span>int</span>
}</pre></div>
<p dir="auto">The checklocks annotation may also apply to functions. For example:</p>
<div data-snippet-clipboard-copy-content="// +checklocks:f.mu
func (f *foo) doThingLocked() { }"><pre><span>// +checklocks:f.mu</span>
<span>func</span> (<span>f</span> <span>*</span><span>foo</span>) <span>doThingLocked</span>() { }</pre></div>
<p dir="auto">This will check that the &#34;f.mu&#34; is locked for any calls, where possible.</p>
<p dir="auto">In case of functions which initialize structs that may have annotations one can
use the following annotation on the function to disable reporting by the lock
checker. The lock checker will still track any mutexes acquired or released but
won&#39;t report any failures for this function for unguarded field access.</p>
<div data-snippet-clipboard-copy-content="// +checklocks:ignore
func newXXX() *X {
...
}"><pre><span>// +checklocks:ignore</span>
<span>func</span> <span>newXXX</span>() <span>*</span><span>X</span> {
<span>...</span>
}</pre></div>
<p dir="auto"><em><strong>The checker treats both &#39;sync.Mutex&#39; and &#39;sync.RWMutex&#39; identically, i.e, as
a sync.Mutex. The checker does not distinguish between read locks vs. exclusive
locks and treats all locks as exclusive locks</strong></em>.</p>
<p dir="auto">For cases the checker is able to correctly handle today please see test/test.go.</p>
<p dir="auto">The checklocks check also flags any invalid annotations where the mutex
annotation refers either to something that is not a &#39;sync.Mutex&#39; or
&#39;sync.RWMutex&#39; or where the field does not exist at all. This will prevent the
annotations from becoming stale over time as fields are renamed, etc.</p>
<h2 dir="auto"><a id="user-content-lock-suggestions" aria-hidden="true" href="#lock-suggestions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lock suggestions</h2>
<p dir="auto">Based on locks held during field access, the analyzer will suggest annotations.
These can be ignored with the standard <code>+checklocksignore</code> annotation.</p>
<p dir="auto">The annotation will be generated when the lock is held the vast majority of the
time the field is accessed. Note that it is possible for this frequency to be
greater than 100%, if the lock is held multiple times. For example:</p>
<div data-snippet-clipboard-copy-content="func foo(ts1 *testStruct, ts2 *testStruct) {
  ts1.Lock()
  ts2.Lock()
  ts1.gaurdedField = 1 // 200% locks held.
  ts1.Unlock()
  ts2.Unlock()
}"><pre><span>func</span> <span>foo</span>(<span>ts1</span> <span>*</span><span>testStruct</span>, <span>ts2</span> <span>*</span><span>testStruct</span>) {
  <span>ts1</span>.<span>Lock</span>()
  <span>ts2</span>.<span>Lock</span>()
  <span>ts1</span>.<span>gaurdedField</span> <span>=</span> <span>1</span> <span>// 200% locks held.</span>
  <span>ts1</span>.<span>Unlock</span>()
  <span>ts2</span>.<span>Unlock</span>()
}</pre></div>
<h2 dir="auto"><a id="user-content-currently-not-supported" aria-hidden="true" href="#currently-not-supported"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Currently not supported</h2>
<ol dir="auto">
<li>Anonymous functions are not correctly evaluated. The analyzer does not
currently support specifying annotations on anonymous functions as a result
evaluation of a function that accesses protected fields will fail.</li>
</ol>
<div data-snippet-clipboard-copy-content="type A struct {
  mu sync.Mutex

  // +checklocks:mu
  x int
}

func abc() {
  var a A
  f := func()  { a.x = 1 }  &lt;=== This line will be flagged by analyzer
  a.mu.Lock()
  f()
  a.mu.Unlock()
}"><pre><span>type</span> <span>A</span> <span>struct</span> {
  <span>mu</span> sync.<span>Mutex</span>

  <span>// +checklocks:mu</span>
  <span>x</span> <span>int</span>
}

<span>func</span> <span>abc</span>() {
  <span>var</span> <span>a</span> <span>A</span>
  <span>f</span> <span>:=</span> <span>func</span>()  { <span>a</span>.<span>x</span> <span>=</span> <span>1</span> }  <span>&lt;=</span><span>==</span> <span>This</span> <span>line</span> <span>will</span> <span>be</span> <span>flagged</span> <span>by</span> <span>analyzer</span>
  <span>a</span>.<span>mu</span>.<span>Lock</span>()
  <span>f</span>()
  <span>a</span>.<span>mu</span>.<span>Unlock</span>()
}</pre></div>
<h3 dir="auto"><a id="user-content-explicitly-not-supported" aria-hidden="true" href="#explicitly-not-supported"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Explicitly Not Supported</h3>
<ol dir="auto">
<li>
<p dir="auto">The checker will not support guards on anything other than the cases
described above. For example, global mutexes cannot be referred to by
checklocks. Only struct members can be used.</p>
</li>
<li>
<p dir="auto">The checker will not support checking for lock ordering violations.</p>
</li>
</ol>
<h2 dir="auto"><a id="user-content-mixed-mode" aria-hidden="true" href="#mixed-mode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Mixed mode</h2>
<p dir="auto">Some members may allow read-only atomic access, but be protected against writes
by a mutex. Generally, this imposes the following requirements:</p>
<p dir="auto">For a read, one of the following must be true:</p>
<ol dir="auto">
<li>A lock held be held.</li>
<li>The access is atomic.</li>
</ol>
<p dir="auto">For a write, both of the following must be true:</p>
<ol dir="auto">
<li>The lock must be held.</li>
<li>The write must be atomic.</li>
</ol>
<p dir="auto">In order to annotate a relevant field, simply apply <em>both</em> annotations from
above. For example:</p>
<div data-snippet-clipboard-copy-content="type foo struct {
  mu sync.Mutex
  // +checklocks:mu
  // +checkatomic
  bar int32
}"><pre><span>type</span> <span>foo</span> <span>struct</span> {
  <span>mu</span> sync.<span>Mutex</span>
  <span>// +checklocks:mu</span>
  <span>// +checkatomic</span>
  <span>bar</span> <span>int32</span>
}</pre></div>
</article>
        </div></div>
  </body>
</html>
