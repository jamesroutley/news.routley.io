<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2024-08-23-the-4-chan-go-programmer/">Original</a>
    <h1>The 4-chan Go programmer</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text">
<p>We&#39;re using Go to write <a href="https://doltdb.com">Dolt</a>, the world&#39;s first version-controlled SQL
database. Like most Go codebases, we use <a href="https://gobyexample.com/channels">channels</a> and
<a href="https://gobyexample.com/goroutines">goroutines</a> to implement concurrent execution. Usually we use
these constructs in the most boring and straightforward way possible, because concurrent programming
is hard enough without trying to be clever. But at one point we inherited some code from another
open source project that used channels in a very clever way: it used them to send additional
channels.</p>

<p>This is a channel that sends another channel, which then sends a struct. It&#39;s basically a way to
pass channels between different goroutines, to implement some fan-out pattern among worker
goroutines. Think of the &#34;middle&#34; channel as the middleman in the workflow: its job is to pass new
channels as they are produced down to workers who actually do useful work. It did work, but it&#39;s the
kind of overly clever idea that was hard to reason about and work with, especially once you consider
goroutine leaks. We rewrote it, and that <code>chan chan struct{}</code> is long gone.</p>
<p>But it did get me thinking. How far can you take this dumb idea? Behold the 4-chan:</p>
<div data-language="go"><pre><code>_4chan <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>chan</span> <span>chan</span> <span>chan</span> <span>int</span><span>)</span></code></pre></div>

<p>There&#39;s an old programming joke from back in the days when C and its derivatives dominated the
landscape. A lot of people had a very hard time understanding pointers, probably because they didn&#39;t
have this meme back then.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/375f585a6a89a468f359df8c43ef8a3c/6af66/pointers-meme.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="pointers" title="" src="https://www.dolthub.com/blog/static/375f585a6a89a468f359df8c43ef8a3c/6af66/pointers-meme.png" srcset="/blog/static/375f585a6a89a468f359df8c43ef8a3c/a48b3/pointers-meme.png 214w,
/blog/static/375f585a6a89a468f359df8c43ef8a3c/47730/pointers-meme.png 428w,
/blog/static/375f585a6a89a468f359df8c43ef8a3c/6af66/pointers-meme.png 640w" sizes="(max-width: 640px) 100vw, 640px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Because pointers were necessary to do many useful things in C, and relatively hard to understand
for a lot of people, newbies would sometimes do very silly things with them, like declaring
variables like this:</p>

<p>And these novices didn&#39;t realize what a silly thing this is to do, thinking instead that getting a
working program that used this many layers of pointer indirection was actually a sign of
expertise. Such unfortunate newbies were called &#34;4-star programmers&#34;.</p>
<p>Because Go is also largely derived from C, you can do the same thing in Go:</p>
<div data-language="go"><pre><code><span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	i <span>:=</span> <span>1</span>
	<span>setInt</span><span>(</span><span>&amp;</span>i<span>)</span>

	fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;i is now %d&#34;</span><span>,</span> i<span>)</span>
<span>}</span>

<span>func</span> <span>setInt</span><span>(</span>i <span>*</span><span>int</span><span>)</span> <span>{</span>
	<span>setInt2</span><span>(</span><span>&amp;</span>i<span>)</span>
<span>}</span>

<span>func</span> <span>setInt2</span><span>(</span>i <span>*</span><span>*</span><span>int</span><span>)</span> <span>{</span>
	<span>setInt3</span><span>(</span><span>&amp;</span>i<span>)</span>
<span>}</span>

<span>func</span> <span>setInt3</span><span>(</span>i <span>*</span><span>*</span><span>*</span><span>int</span><span>)</span> <span>{</span>
	<span>setInt4</span><span>(</span><span>&amp;</span>i<span>)</span>
<span>}</span>

<span>func</span> <span>setInt4</span><span>(</span>i <span>*</span><span>*</span><span>*</span><span>*</span><span>int</span><span>)</span> <span>{</span>
	<span>*</span><span>*</span><span>*</span><span>*</span>i <span>=</span> <span>100</span>
<span>}</span></code></pre></div>
<p>This compiles and prints <code>i is now 100</code>. You too can be a 4-star Go programmer, it&#39;s just that easy.</p>
<p>But we can take this one step farther, and use a construct that Go has but C does not:
channels. Declared in code as <code>chan</code>.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/445c20c53d8333439a2a6385fcfe6409/4b9ef/4chan.jpg" target="_blank" rel="noopener">
    <span></span>
  <img alt="4 chan" title="" src="https://www.dolthub.com/blog/static/445c20c53d8333439a2a6385fcfe6409/4b9ef/4chan.jpg" srcset="/blog/static/445c20c53d8333439a2a6385fcfe6409/606a2/4chan.jpg 214w,
/blog/static/445c20c53d8333439a2a6385fcfe6409/65a3f/4chan.jpg 428w,
/blog/static/445c20c53d8333439a2a6385fcfe6409/4b9ef/4chan.jpg 641w" sizes="(max-width: 641px) 100vw, 641px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>You see where I&#39;m going with this.</p>

<p>The basic idea is that we&#39;ll write a program that uses 4 layers of channel indirection to complete
some task. Our top-level channel has to be a 4-chan, so we declare it like this:</p>
<div data-language="go"><pre><code>_4chan <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>chan</span> <span>chan</span> <span>chan</span> <span>int</span><span>)</span></code></pre></div>
<p>(It&#39;s somewhat irritating for the purpose of this gag that Go doesn&#39;t let you begin an identifier
with a numeral, but that&#39;s life).</p>
<p>The values we send on that channel are 3-chans, like this:</p>
<div data-language="go"><pre><code>_3chan <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>chan</span> <span>chan</span> <span>int</span><span>)</span></code></pre></div>
<p>And so on, down to the lowly int channel itself.</p>
<p>At each layer of indirection, we&#39;ll spawn producers according to some constant branching factor:</p>
<div data-language="go"><pre><code><span>func</span> <span>sendChanChanChan</span><span>(</span>c <span>chan</span> <span>chan</span> <span>chan</span> <span>chan</span> <span>int</span><span>)</span> <span>{</span>
	<span>for</span> <span>range</span> factor <span>{</span>
		<span>go</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
			logrus<span>.</span><span>Debug</span><span>(</span><span>&#34;starting 3chan producer&#34;</span><span>)</span>
			_3chan <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>chan</span> <span>chan</span> <span>int</span><span>)</span>
			<span>sendChanChan</span><span>(</span>c<span>,</span> _3chan<span>)</span>
		<span>}</span><span>(</span><span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>And the same thing for consumers:</p>
<div data-language="go"><pre><code><span>func</span> <span>receiveChanChanChan</span><span>(</span>c <span>chan</span> <span>chan</span> <span>chan</span> <span>chan</span> <span>int</span><span>)</span> <span>{</span>
	<span>for</span> _3chan <span>:=</span> <span>range</span> c <span>{</span>
		logrus<span>.</span><span>Debug</span><span>(</span><span>&#34;got message from 4chan&#34;</span><span>)</span>
		<span>for</span> <span>range</span> factor <span>{</span>
			logrus<span>.</span><span>Debug</span><span>(</span><span>&#34;starting 3chan consumer&#34;</span><span>)</span>
			<span>go</span> <span>receiveChanChan</span><span>(</span>_3chan<span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Finally we hit the bottom of the stack, where we send an actual value instead of a channel for
values.</p>
<div data-language="go"><pre><code><span>func</span> <span>send</span><span>(</span>_2chan <span>chan</span> <span>chan</span> <span>int</span><span>,</span> _1chan <span>chan</span> <span>int</span><span>)</span> <span>{</span>
	_2chan <span>&lt;-</span> _1chan
	<span>for</span> <span>range</span> factor <span>{</span>
		<span>go</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
			logrus<span>.</span><span>Debug</span><span>(</span><span>&#34;starting int producer&#34;</span><span>)</span>
			<span>for</span> <span>range</span> factor <span>{</span>
				<span>go</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
					logrus<span>.</span><span>Debug</span><span>(</span><span>&#34;sending int&#34;</span><span>)</span>
					_1chan <span>&lt;-</span> <span>1</span>
				<span>}</span><span>(</span><span>)</span>
			<span>}</span>
		<span>}</span><span>(</span><span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>For the consumers, we have to do something with the values we receive. Let&#39;s add them together.</p>
<div data-language="go"><pre><code><span>var</span> sum <span>=</span> <span>&amp;</span>atomic<span>.</span>Int32<span>{</span><span>}</span>

<span>func</span> <span>receive</span><span>(</span>c <span>chan</span> <span>int</span><span>)</span> <span>{</span>
	<span>for</span> s <span>:=</span> <span>range</span> c <span>{</span>
		logrus<span>.</span><span>Debug</span><span>(</span><span>&#34;received int&#34;</span><span>)</span>
		sum<span>.</span><span>Add</span><span>(</span><span>int32</span><span>(</span>s<span>)</span><span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Now let&#39;s put it all together:</p>
<div data-language="go"><pre><code><span>const</span> factor <span>=</span> <span>3</span>

<span>var</span> sum <span>=</span> <span>&amp;</span>atomic<span>.</span>Int32<span>{</span><span>}</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	

	_4chan <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>chan</span> <span>chan</span> <span>chan</span> <span>int</span><span>)</span>

	<span>go</span> <span>sendChanChanChan</span><span>(</span>_4chan<span>)</span>
	<span>go</span> <span>receiveChanChanChan</span><span>(</span>_4chan<span>)</span>

	time<span>.</span><span>Sleep</span><span>(</span><span>500</span> <span>*</span> time<span>.</span>Millisecond<span>)</span>

	fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;%d ^ 5: %d&#34;</span><span>,</span> factor<span>,</span> sum<span>.</span><span>Load</span><span>(</span><span>)</span><span>)</span>
<span>}</span></code></pre></div>
<p>This prints <code>3 ^ 5: 243</code>. Which is correct! This program is a fully generalized way to compute a
number&#39;s fifth power in a maximally distributed way. You can play with it
<a href="https://go.dev/play/p/Pzf3aRnXpcE">here</a> (or view with syntax highlighting on GitHub
<a href="https://gist.github.com/zachmu/0209f3437bdda512b8c6170acb07d239">here</a>). For larger factors you may
need to increase the <code>Sleep</code> duration for it to run.</p>
<p>If you enable logging by uncommenting the first line, you&#39;ll get output like this that lets you see
the branching factor at each layer of channel production / consumption:</p>
<div data-language="bash"><pre><code><span>sort</span> 4chan.txt <span>|</span> <span>sed</span> <span>-e</span> <span>&#39;s/.*msg=//&#39;</span> <span>|</span> <span>uniq</span> <span>-c</span> <span>|</span> <span>sort</span> <span>-n</span>
      <span>1</span> <span>3</span> ^ <span>5</span>: <span>243</span>
      <span>3</span> <span>&#34;starting 3chan producer&#34;</span>
      <span>9</span> <span>&#34;starting 2chan producer&#34;</span>
      <span>9</span> <span>&#34;starting 3chan consumer&#34;</span>
     <span>27</span> <span>&#34;starting 2chan consumer&#34;</span>
     <span>27</span> <span>&#34;starting chan producer&#34;</span>
     <span>81</span> <span>&#34;starting 1chan consumer&#34;</span>
     <span>81</span> <span>&#34;starting int producer&#34;</span>
    <span>243</span> <span>&#34;received int&#34;</span>
    <span>243</span> <span>&#34;sending int&#34;</span></code></pre></div>

<p>There are a lot of reasons not to do this in real code: the difficulty of implementation and
debugging, having a little self-respect, not wanting to be clubbed to death by your peers&#39; bulky
mechanical keyboards, etc.</p>
<p>On the other hand, it&#39;s extremely fun to do and pretty entertaining that it works at all.</p>
<p>So, trade-offs.</p>
<p>One of the best practical reasons not to send channels over channels is that it makes it really
difficult to ever close any of them, which obviously you would want to do in a real use case. At one
point I actually implemented close logic, which required adding a <code>sync.WaitGroup</code> everywhere so
that I could keep track of when all the channel sends were finished before closing anything, but it
made the gag much harder to read so I ditched it and stuck with <code>time.Sleep()</code> and massive goroutine
leaks.</p>

<p>Have questions or comments about silly concurrency patterns in Go? Or maybe you are curious about
the world&#39;s first version-controlled SQL database? <a href="https://discord.gg/gqr7K4VNKe">Join us on
Discord</a> to talk to our engineering team and other Dolt users.</p></div></div>
  </body>
</html>
