<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cerbos.dev/blog/crdts-and-collaborative-playground">Original</a>
    <h1>CRDTs and Collaborative Playground</h1>
    
    <div id="readability-page-1" class="page"><div><p>At <a href="https://www.cerbos.dev/">Cerbos</a>, we specialize in simplifying complex authorization logic to empower developers with the tools to implement secure, scalable, and maintainable access control systems. Our mission is to streamline the development of robust access policies, making it easier for teams to define who can do what in their applications.</p>
<p>One of the tools we offer is a collaborative IDE and testing environment we nicknamed the &#34;Playground&#34; (because access control should be a joy, not a chore). The Playground is a fully integrated collaborative IDE with built-in testing that provides feedback in real-time, and easily integrates into your GitOps workflow! We&#39;re very proud of it, but rather than spending too much time bragging, I&#39;m going to deep-dive into a very particular word from the spiel before: &#34;collaborative&#34;.</p>
<p>We saw real value in building the environment with collaboration in mind‚Äîboth for efficiency in authoring policies and also as a tool for sharing knowledge or educating others (pair-programming FTW, right?).</p>
<p>But how does one make an app collaborative? Well, there are several approaches, but we chose one that stands out for its elegance and efficiency. To enable this seamless collaboration, we&#39;ve leveraged the power of Conflict-Free Replicated Data Types (CRDTs).</p>

<p>CRDTs are a class of data structures that automatically resolve conflicts in distributed systems, allowing for seamless data synchronization across multiple points without centralized coordination. They&#39;re designed for environments where network partitions or latency make constant communication impractical but have since found more generalised use due to their simplicity and elegance.</p>
<p>They&#39;re incredibly useful when it comes to developing robust, distributed applications that require real-time collaboration. They enable multiple users to work concurrently on the same dataset, with guarantees of eventual consistency, eliminating the need for complex conflict resolution logic. Does your application need offline support? Good news: you get that for free, too!</p>
<p>The concept was formalised in 2011 when a group of very smart researchers came together and presented <a href="https://inria.hal.science/inria-00609399v1/document">a paper</a> on the topic; initially motivated by collaborative editing and mobile computing, but its adoption has spread to numerous other applications in the years that followed.</p>

<p>The answer, surprisingly, is &#34;very easily&#34;. Given its meteoric adoption rate in recent years, some excellent, battle-tested projects have appeared and taken strong hold in the community. Let&#39;s take a look at a couple:</p>
<h2>Yjs</h2>
<p>Yjs is a bit of a household name, it&#39;s probably fair to say that this project underpins a large proportion of CRDT-driven applications in general use today. Born originally in the JS space by the prolific Kevin Jahns, it started as a collection of importable familiar &#34;types&#34; with a sync-able central <code>document</code>:</p>
<pre><code>import * as Y from &#39;yjs&#39;;


const doc = new Y.Doc();
const yarray = doc.getArray(&#39;my-array&#39;)

yarray.observe(event =&gt; {
  console.log(&#39;yarray was modified&#39;)
})

// every time a local or remote client modifies yarray, the observer is called
yarray.insert(0, [&#39;val&#39;]) // =&gt; &#34;yarray was modified&#34;
</code></pre>
<p>Over the years that followed, Yjs grew into an extensive library of adapters for different communication protocols, editor integrations and storage drivers, each with an almost &#34;drag and drop&#34; integration pattern. More recently, the maintainers built a cross-language/cross-platform <a href="https://github.com/y-crdt/y-crdt">Rust port</a> which itself then came with language bindings to several other languages.</p>
<p>On top of its massive ecosystem and reputation for ease of use, it&#39;s also an extremely performant implementation. Kevin was the first to introduce a rather clever optimization in the underlying data model which has since become a de facto industry standard: representing a more complex tree-type structure in a single flat list. If you want to read more about this, I recommend you dive into <a href="https://josephg.com/blog/crdts-go-brrr/">CRDTs go brrr</a>; this pivotal piece goes  into some intricate detail of the inner workings of CRDTs, and explains in reasonably accessible terms just how this optimization was achieved.</p>
<p>In short, if you want to dabble in the world of CRDTs, Yjs is a good place to start.</p>
<h2>Automerge</h2>
<p>Automerge is the brainchild of Martin Kleppman and his team as part of their research at the University of Cambridge. (You may remember Martin as the author of <a href="https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/">Designing Data-Intensive Applications</a> and other notable works.)</p>
<p>After its foundational release back in 2021, the more recent <a href="https://automerge.org/blog/automerge-2/">Automerge 2.0</a> introduced a plethora of optimizations, features and support. Similarly to Yjs, it also offers a library of data structures as well as a central <code>document</code>.</p>
<p>Automerge is production-ready, available in Javascript and Rust, and includes TypeScript types and C bindings for use in other ecosystems, and is definitely worth a good look if you&#39;re considering diving in. Be sure to check out the nifty &#34;5-minute quickstart&#34; to see how it all works!</p>
<h2>Do-it-yourself</h2>
<p>This isn&#39;t a project name‚Äîit&#39;s a <em>suggestion</em>. If you fancy a challenge, it might not be as tricky as you&#39;d think to build a basic, functioning CRDT‚Äîeven one that you could tailor to your own specific needs!</p>
<h3>How?</h3>
<p>Ultimately, what it boils down to is the requirement of a resolvable &#34;unit&#34; within your data structure. What this means is that you can compare that unit to another of the same type, and one will deterministically always be &#34;less than&#34; or &#34;greater than&#34; the other.</p>
<p>Let&#39;s take a simple example: a CRDT &#34;string&#34; (e.g. a line in a text document). Our &#34;string&#34; CRDT will be represented by a tree-like structure of the following <code>Unit</code> type instances:</p>
<pre><code>type Unit struct {
    ClientID uint64  // the unique ID of the client/process within the distributed system
    Data     string  // this could simply be a character or perhaps a contiguous set of characters (note: I like this concept and I shall call it a &#34;word&#34;)
    Clock    uint64  // I&#39;ll come to this below...
    Children []*Unit // ... and this ...
}

type Sentence []*Unit
</code></pre>
<h4>The <code>Clock</code></h4>
<p>Time is‚Ä¶ a bit complicated, but very important. In a distributed system, we need to be able to compare the <em>exact</em> <code>datetime</code> of two moments in time. You might be asking, &#34;can&#39;t we just rely on physical clocks read directly from the origin computers?&#34; No, because there&#39;s no guarantee that both computers have exactly the same time‚Äîand the clock skew of even a millisecond could result in havoc in a distributed system.</p>
<p>What we need is the concept of a logical clock. A simple but effective implementation is called a &#34;Lamport timestamp&#34;. These clever things provide a method to order events in a distributed system without relying on synchronized physical clocks. Here&#39;s a summary explanation as brief as I can muster:</p>
<blockquote>
<p>Each process in the system maintains a counter. When an event occurs, the counter is increased. If a process sends a message, it includes its counter with the message. Upon receiving a message, a process sets its counter to be greater than both its current counter and the received counter value. This way, Lamport timestamps ensure a partial ordering of events based on the &#34;happens-before&#34; relation, allowing the system to determine the sequence of events across different processes.</p>
</blockquote>
<p>Here&#39;s a nice diagram I drew to further demonstrate:</p>
<p><img src="https://stylish-appliance-1c1cc1c30d.media.strapiapp.com/lamport_timestamp_diagram_5d1f08ef44.png" alt="Lamport Timestamp Diagram"/></p>
<p>Each line represents a separate process in the distributed system. The black nodes are local origin events, the arrows denote the event being passed to another process, and the pink nodes represent that event being received and thus the local clock incremented.</p>
<p>Beyond this, if you want to determine <em>causality</em>, e.g. whether events are &#34;causally related&#34; (happened before or after each other) or are &#34;concurrent&#34; (entirely independent of), you can look at <a href="https://en.wikipedia.org/wiki/Vector_clock">Vector Clocks</a>‚ÄîI won&#39;t go down that rabbit-hole here, though.</p>
<h4>Insertion</h4>
<p>Let&#39;s say we have a line (a tree of <code>Unit</code>s). Let&#39;s say its current state is:</p>
<pre><code>s := &amp;Unit{ClientID: 1, Data: &#34;S&#34;, Clock: 1, Children: []*Unit{
    &amp;Unit{ClientID: 1, Data: &#34;h&#34;, Clock: 2, Children: []*Unit{
        &amp;Unit{ClientID: 1, Data: &#34;i&#34;, Clock: 3},
    }},
}}
</code></pre>
<p>This assumes that each <code>Unit</code> stores a single character in <code>Data</code> and that the characters were typed in order, start to finish (e.g. no cursoring back to a middle position). We could write a method to build the representative string from this structure:</p>
<pre><code>func (s *Sentence) build() string {
    if len(*s) == 0 {
        return &#34;&#34;
    }

    b := new(strings.Builder)
    for _, u := range *s {
        traverse(u, b)
    }

    return b.String()
}

func traverse(u *Unit, b *strings.Builder) {
    b.WriteString(u.Data)

    for _, child := range u.Children {
        traverse(child, b)
    }
}
</code></pre>
<p>Which, when called, would return:</p>
<blockquote>
<p>&#34;Shi&#34;</p>
</blockquote>
<p>Nice. But now I want to be able to insert characters into my string. Let&#39;s write another slightly more involved function:</p>
<pre><code>func (s *Sentence) insert(unit, parent *Unit) {
    // Resolve within children of parent
    if parent != nil {
        if len(parent.Children) == 0 {
            parent.Children = []*Unit{unit}
        } else {
            for i, c := range parent.Children {
                if unit.Clock &gt; c.Clock || (unit.Clock == c.Clock &amp;&amp; unit.ClientID &gt; c.ClientID) {
                    // Insert newer item before older
                    parent.Children = append(parent.Children, &amp;Unit{})
                    copy(parent.Children[i+1:], parent.Children[i:])
                    parent.Children[i] = unit
                    return
                }
            }
            parent.Children = append(parent.Children, unit)
        }
    } else {
        // Otherwise, prepend?
        *s = append([]*Unit{unit}, *s...)
    }
}
</code></pre>
<p>When I insert, I increment my local counter, specify a parent <code>Unit</code>, and hand it off to this resolution logic to figure out where it should go. We can run it like this:</p>
<pre><code>func main() {
    u0 := &amp;Unit{ClientID: 1, Data: &#34;S&#34;, Clock: 1}
    u1 := &amp;Unit{ClientID: 1, Data: &#34;h&#34;, Clock: 2}
    u2 := &amp;Unit{ClientID: 1, Data: &#34;i&#34;, Clock: 3}

    u0.Children = []*Unit{u1}
    u1.Children = []*Unit{u2}

    sentence := Sentence{u0}

    sentence.insert(&amp;Unit{ClientID: 1, Data: &#34;p&#34;, Clock: 4}, u2)

    print(sentence.build())
}
</code></pre>
<p>And we receive:</p>
<blockquote>
<p>&#34;Ship&#34;</p>
</blockquote>
<p>Even nicer. But what happens if two users attempt to update the same word at the same time? Let&#39;s see:</p>
<pre><code>    sentence.insert(&amp;Unit{ClientID: 1, Data: &#34;t&#34;, Clock: 4}, u2)
    sentence.insert(&amp;Unit{ClientID: 2, Data: &#34;p&#34;, Clock: 4}, u2)
</code></pre>
<p>Note the differing <code>ClientID</code>s. If we build this string, it gives us:</p>
<blockquote>
<p>&#34;Shipt&#34;</p>
</blockquote>
<p>This scenario made it into the inner loop of the resolution. Because these updates were concurrent (e.g. two separate offline operations), the resolution logic falls back to the tie-breaker, which in this case is a comparison of the <code>ClientID</code>. Thus, we still have our deterministic output!</p>
<h3>The case against DIY</h3>
<p>It&#39;s worth acknowledging the overhead involved with building your own CRDT‚Äîparticularly if you intend on building a product <em>on top</em> of that CRDT. I learnt this first-hand with one of my own projects: <a href="https://github.com/Sambigeara/fuzzynote">fuzzynote</a>.</p>
<p>Fuzzynote is a list-based note-taking tool, backed by a tree-based CRDT which supports sensical partial ordering and the ability to move items (plus their dependents) to other locations in the list. The reason for the novel design was very specific to the use case: it allowed users to share and collaborate on individual items (or selections thereof) with other users whilst still maintaining a sane ordering of the overall list.</p>
<p>The original app was terminal-based, but I found myself wanting to access my notes on the go. So I abstracted away the core functionality, compiled it to Wasm, and built a web app around it, too. I then built a lambda-based infrastructure to serve the web app. I then figured I might be able to sell this to other people, so I doubled down and set about productizing it‚Ä¶</p>
<p>As the months rolled on, between the web app, the infrastructure, and the underlying engine and CRDT‚Äîeven though the first two were hefty undertakings in themselves‚ÄîI still found that the <em>vast</em> majority of my time was spent digging around the dark corners of the engine, adding new minor features, or fixing obscure (terrifying) bugs. Unsurprisingly, I ran out of steam and shelved it. üè≥Ô∏è</p>
<p>Lesson learnt: if I ever fancied having another crack at building a marketable product, I would more than likely just use Yjs. That said, while it might not have been the best product-building approach, I still had a lot of fun.</p>

<h2>A brief word on our architecture</h2>
<p>We adopt a <a href="https://remix.run/docs/en/main/guides/bff">backend-for-frontend (BFF) architecture</a>. The Node.js backend is responsible for communicating with the various Go services that power Cerbos Hub and does all of the heavy lifting required to retrieve, aggregate and transform data used in the front end. This keeps our front end nice and light‚Äîand maintainable.</p>
<p>Now, for the playground clients to talk to each other, we need a central point of communication. Conveniently, our Node.js backend offers us this very functionality. Our Go backend has no interest in the CRDT data that&#39;s fired around‚Äîin fact, it&#39;s better to consider the users&#39; browsers themselves as the primary sources of truth‚Äîso we don&#39;t have to bother with the extra network jump! This also gives us the power to deploy the UI backend close to our users and keep that collaborative latency down to a minimum. Very cool!</p>
<p>Given its basic proxying needs, CRDT data transfer is also protocol agnostic. Providing the state ends up where it needs to be, you can use any method to get it there. We opted for Websockets, given its simplicity, prevalence, and performance.</p>
<p><img src="https://stylish-appliance-1c1cc1c30d.media.strapiapp.com/crdts_hub_arch_diagram_75fed9167e.png" alt="Websocket diagram for Cerbos Hub"/></p>
<p>Notice how at this point, there is no persistence in the backend, but there <em>is</em> <code>IndexedDB</code> persistence in each user&#39;s browser. Providing no user deletes their IdDB storage and all users maintain an internet connection, we now have fully functioning collaboration in our Playground with only a single proxy layer in our UI backend! When a user logs in, they load up the state from their browser IdDB instance and send off a synchronisation event to any other listening clients. This clever &#34;handshake&#34; mechanism results in missing events being shared between all who need them! And all the resolution occurs locally within the user&#39;s browsers.</p>
<p>You might have a couple of questions, though:</p>
<ol>
<li>What about if everyone loses the local state?</li>
<li>What about if someone made loads of edits and then closed their laptop and went on holiday?</li>
</ol>
<p>These are fair questions. The scenario above describes what will likely occur in the vast majority of cases, however, we need to cover these, too.</p>
<h3>Persisting state in the backend with Yjs</h3>
<p>We use Yjs as our weapon of choice, given its hefty ecosystem and brilliant performance. Because our UI backend runs in Node.js, we&#39;re able to represent the same Playground state there as well; in essence, the backend is just another read-only user.</p>
<p><img src="https://stylish-appliance-1c1cc1c30d.media.strapiapp.com/crdts_backend_hub_diagram_735db5592a.png" alt="Backend CRDT diagram for Cerbos Hub"/></p>
<p>This almost solves our persistence problem itself, but we can&#39;t rely on a single process being around forever holding the CRDT state in memory. So, what we do is serialize it into binary format and periodically ship it off to a Go service which stores it, as is, in our Postgres DB. When someone loads up the given playground, they make a request to the UI backend, which calls this Go service to retrieve the binary blob, deserializes it into Yjs&#39;s CRDT state, and then syncs that back down with the user. Success!</p>
<h3>My colleague lives at the South Pole.</h3>
<p>The eagle-eyed reader may have spotted a potential flaw with a comment I made previously on &#34;deploying the UI backend near to users&#34;. This is all well and good if collaborators all share the same backend server, but what if they don&#39;t? If two users are attempting to collaborate on a single playground via two different backends, how do the events reach each other? This issue also rings true in more localised setups; what if I have two or more instances of the UI backend running in the same region, due to demand?</p>
<p>OK. So we need another approach for this:</p>
<p><img src="https://stylish-appliance-1c1cc1c30d.media.strapiapp.com/crdts_redis_crdt_diagram_ed25bf000c.png" alt="Redis on the CRDT backend diagram"/></p>
<p>In the massive library of useful Yjs tooling, there is a <a href="https://github.com/yjs/y-redis">Redis adapter</a> available which allows us to represent our CRDT state in Redis&#39; KV format (scoped to each Yjs document or Playground). If we extend it further with a fairly simple distributed mutex mechanism, we can now persist and share state across any service which can access the Redis instance!</p>
<p>And with that, we have a fully functioning, globally distributed, persisting collaboration infrastructure. üéâ</p>

<p>Cerbos leverages the power of CRDTs to facilitate real-time collaboration in our Playground, ensuring a seamless and efficient development experience. By adopting a combination of advanced data structures and innovative architecture, we offer developers a robust platform for building and testing access control systems collaboratively. This approach not only simplifies the complexity of authorization logic but also enhances productivity and knowledge sharing among teams.</p>
<p>Whether you&#39;re a seasoned developer or just starting out, Cerbos provides the tools and support needed to implement secure, scalable, and maintainable access policies with ease.</p>
<p>As always, if you have any questions or comments on the above, please head over to our <a href="https://community.cerbos.dev/">Slack community</a>‚Äîwe look forward to seeing you there.</p>
<p>Thanks for reading!</p>
</div></div>
  </body>
</html>
