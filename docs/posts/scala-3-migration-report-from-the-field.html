<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pierre-ricadat.com/scala-3-migration-report-from-the-field">Original</a>
    <h1>Scala 3 Migration: Report from the field</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>April 30, 2024. I decided to dedicate a week to migrate our main project at work (a multiplayer mobile game server in production for over 4 years) from Scala 2.13 to Scala 3.</p>
<p>May 7, 2024. I gave up. The removal of several features from Scala 3 (macro annotations, type projections, etc.), combined with the large number of changes necessary for the migration, was overwhelming. I was barely able to migrate a single module, had to modify thousands of lines of code (while my colleagues were adding new features to the main branch, a large number of merge conflicts were already appearing), and the IDE was completely unresponsive due to hundreds of compile errors. At that point, I thought the project might be stuck on Scala 2 forever.</p>
<p>Flash forward to January 2025. I had a little free time, so I decided to give it another try. And (spoiler!) this time I made it to the end. Let’s see what the various problems I encountered were, the changes I had to make, and the workarounds I implemented.</p>
<h2 id="heading-preamble">Preamble</h2>
<p>The main place to look when starting a migration is the official <a target="_blank" href="https://docs.scala-lang.org/scala3/guides/migration/compatibility-intro.html">Scala 3 Migration Guide</a>. It contains a lot of information about the changes in the language and details on how to proceed.</p>
<p>As I mentioned, the large number of changes required was an issue because it caused a lot of merge conflicts with the main branch. It was not possible to stop all other developments during the migration, so I decided to apply as many changes as possible in the Scala 2 main branch to avoid these conflicts.</p>
<p>The main thing you can do while still on Scala 2.13 is to compile with the <code>-Xsource:3</code> compiler flag, which enables the Scala 3 syntax for imports (<code>*</code> instead of <code>_</code>, <code>as</code> instead of <code>=&gt;</code>), intersection types (<code>&amp;</code> instead of <code>with</code>), and more, and also turns on a number of warnings for things no longer supported in Scala 3 (e.g., <code>.map(CaseClass)</code> should become <code>.map(CaseClass.apply)</code>).</p>
<p>Most of those changes were easy to apply, but there were a lot of them, which was challenging. Scala 3 offers a “migration mode” and is able to rewrite the code with the new syntax, but this is not applicable if you want to apply these changes in a Scala 2 codebase. My salvation actually came from IntelliJ, which has an inspection for code compiled with <code>-Xsource:3</code> and a quick fix action to replace all the code at once. Incredibly useful!</p>
<p><img data-zoomable="true" loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1737941342711/38246c7a-77a4-455b-aaf8-fbd28d76eb11.png?auto=compress,format&amp;format=webp" alt="IntelliJ inspection for -Xsource:3"/></p>
<p>IntelliJ even lets you select which of these changes you want to apply, so I excluded the “<code>case</code> in pattern bindings of for-comprehensions” because it transformed the code in a weird, unnecessary way.</p>
<p>After this was done, I was able to apply a large number of changes directly to our main branch, avoiding many more conflicts!</p>
<p><img data-zoomable="true" loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1737941447355/dd5a5858-c5de-42ff-a28e-0975572b8294.png?auto=compress,format&amp;format=webp" alt=""/></p>
<h2 id="heading-dropped-features">Dropped Features</h2>
<p>While it brought a number of new and interesting features such as enums or opaque types, Scala 3 dropped a few features altogether, and this proved to be particularly challenging for us. The dropped features are listed <a target="_blank" href="https://docs.scala-lang.org/scala3/reference/dropped-features/">on this page</a>, and there were two of them that we relied on heavily: macro annotations and type projections.</p>
<h3 id="heading-macro-annotations">Macro annotations</h3>
<p>Macro annotations let you annotate Scala 2 types to generate code at compile-time, most typically by adding code to the companion object of annotated classes.</p>
<p>For example, using the <a target="_blank" href="https://github.com/circe/circe">Circe JSON library</a>, you could write this:</p>
<pre><code><span>@JsonCodec</span>
<span>case</span> <span><span>class</span> <span>Bar</span>(<span>i: <span>Int</span>, s: <span>String</span></span>)</span>
</code></pre>
<p>This will automatically generate an implicit <code>Codec[Bar]</code> in the companion object of <code>Bar</code>. Very concise, very convenient. In the case of Circe, there was an &#34;easy&#34; workaround, which is to use the <code>derives</code> keyword available in Scala 3. I put quotes around &#34;easy&#34; because, for some reason, it is not mentioned at all in the <a target="_blank" href="https://circe.github.io/circe/codecs/semiauto-derivation.html#jsoncodec">Circe documentation</a>.</p>
<p>The code above can be changed to the following for the same result:</p>
<pre><code><span>case</span> <span><span>class</span> <span>Bar</span>(<span>i: <span>Int</span>, s: <span>String</span></span>) <span>derives</span> <span>Codec</span>.<span>AsObject</span></span>
</code></pre>
<p>Case closed? Not exactly, because our main use of macro annotations was not with Circe, but with <a target="_blank" href="https://github.com/optics-dev/Monocle">Monocle</a> and its <code>@Lenses</code> annotation.</p>
<pre><code><span>@Lenses</span>
<span>case</span> <span><span>class</span> <span>Bar</span>(<span>i: <span>Int</span>, s: <span>String</span></span>)</span>
</code></pre>
<p>This will generate the following in the companion object of <code>Bar</code>:</p>
<pre><code><span><span>object</span> <span>Bar</span> </span>{
  <span>val</span> i: <span>Lens</span>[<span>Bar</span>, <span>Int</span>] = ??? 
  <span>val</span> s: <span>Lens</span>[<span>Bar</span>, <span>String</span>] = ??? 
}
</code></pre>
<p>Our project, being a complex game, has a huge user state object, lots of business logic, and domain entities. Lenses allow us to modify parts of the user state in a concise and elegant manner without having to use a chain of nested <code>copy</code>.</p>
<p>The removal of that macro annotation left us with no clear path or alternative for the migration. Unlike the Circe case, this is not a typeclass instance, so we can’t use the <code>derives</code> keyword: we need a <code>val</code> generated for each field of the case class. There is an <a target="_blank" href="https://github.com/optics-dev/Monocle/issues/1337">open issue</a> in the Monocle repository that discusses various options, but nothing tangible (Kit Langton has an <a target="_blank" href="https://contributors.scala-lang.org/t/scala-3-macro-annotations-and-code-generation/6035/69">interesting approach</a> using <code>Selectable</code>, but this is not supported by IntelliJ).</p>
<p>One obvious alternative was to write those lenses ourselves. That was definitely doable; however, it would have required considerable effort to write thousands of these, and it would have added an enormous amount of boilerplate to the project, making Scala 3 quite unpopular within our team. This alone stopped the migration effort I started in 2024.</p>
<p>We are always trying to reduce boilerplate in our project, so we’ve used a few techniques over the years to address it. Sometimes it’s doable with macros or mirrors, but one way is to use sbt’s source generators, which allow you to run some custom code before compilation to generate additional source code files. Combined with <a target="_blank" href="https://scalameta.org/">Scalameta</a>, you can parse and analyze your own code to generate more code. It is ultimately this technique that we used to generate the lenses.</p>
<p>The code generation works like this:</p>
<ul>
<li><p>Look for all case classes in a specific module that contain the <code>@lenses</code> annotation</p>
</li>
<li><p>For each of those case classes, create an object</p>
<ul>
<li>For each field of the case class, create a lens with the appropriate types</li>
</ul>
</li>
</ul>
<p>Using Scalameta is a little bit involved, so I’ve shared a snippet of our code <a target="_blank" href="https://gist.github.com/ghostdogpr/3b5bd33dd3356e16434db42595924bf4">in this gist</a> so that it may be used by others. One downside of this approach is that the generated lenses are no longer in the companion objects of the case classes (we can generate new source files but not modify the existing ones), which required us to change all the lenses usage to use different object names. But it was worth it since it unlocked the migration path.</p>
<p>Note that a “macro annotation” feature was added to Scala 3, but it is much more limited than what was possible in Scala 2 and does not allow implementing the Monocle <code>@Lenses</code> annotation (the generated code is not visible to the user).</p>
<h3 id="heading-type-projections">Type projections</h3>
<p>Imagine you have a type <code>Request</code> that has an abstract <code>type Result</code> defined inside it.</p>
<pre><code><span><span>trait</span> <span>Request</span> </span>{
  <span><span>type</span> <span>Result</span></span>
}

<span>case</span> <span><span>class</span> <span>IntRequest</span>(<span></span>) <span>extends</span> <span>Request</span> </span>{
  <span><span>type</span> <span>Result</span> </span>= <span>Int</span>
}
</code></pre>
<p>In Scala 2, you can write a function that, for a given <code>Request</code>, returns <code>Request#Result</code>, meaning it returns the <code>Result</code> that matches the subtype of <code>Request</code> that was used. So if <code>Request</code> is <code>IntRequest</code>, we will get an <code>Int</code> back.</p>
<pre><code><span><span>def</span> <span>foo</span></span>[<span>R</span> &lt;: <span>Request</span>](req: <span>Request</span>): <span>R</span>#<span>Result</span> = ???
</code></pre>
<p>This is no longer possible in Scala 3 if <code>R</code> is abstract! You get a compile error saying <code>R is not a legal path since it is not a concrete type</code>. There is an easy workaround if you have a value of type <code>Request</code>, which is to use a function dependent type and return <code>req.Result</code>.</p>
<pre><code><span><span>def</span> <span>foo</span></span>[<span>R</span> &lt;: <span>Request</span>](req: <span>Request</span>): req.<span>Result</span> = ???
</code></pre>
<p>However, our code had various uses of this pattern, and not all of them could be changed to a function dependent type. We ended up using a combination of different techniques depending on each case: function dependent types in some places, typeclasses in others, and we had to give up on making the code generic in a few places. Overall, this felt like a regression from the old code, but at least we were able to make it compile without changing too much code.</p>
<p>EDIT: After publishing this article, Voytek Pituła <a target="_blank" href="https://www.reddit.com/r/scala/comments/1ihf75z/comment/mawmkn0/">suggested a different workaround on Reddit</a> using match types, and I was able to apply it successfully in the places where I had no alternatives. It made the code much nicer! I had heard of match types as an alternative before, but I thought I would have to construct a giant pattern matching with the list of all requests and their matching results. I had no idea it could be used in a generic way. Here’s his approach applied to our example:</p>
<pre><code><span><span>trait</span> <span>Request</span> </span>{
  <span><span>type</span> <span>Result</span> </span>
}

<span><span>object</span> <span>Request</span> </span>{
  <span><span>type</span> <span>Aux</span>[<span>T</span>] </span>= <span>Request</span> { <span><span>type</span> <span>Result</span> </span>= <span>T</span> }
  <span><span>type</span> <span>Result</span>[<span>T</span> &lt;: <span>Request</span>] </span>= <span>T</span> <span>match</span> {
    <span>case</span> <span>Aux</span>[s] =&gt; s
  }
}

<span><span>def</span> <span>foo</span></span>[<span>T</span> &lt;: <span>Request</span>]: <span>Request</span>.<span>Result</span>[<span>T</span>]
</code></pre>
<h2 id="heading-unsupportedbroken-libraries">Unsupported/broken libraries</h2>
<p>Most libraries we were using were available on Scala 3, and for a few missing ones (mostly related to Spark or Kryo), we used <code>cross(CrossVersion.for3Use2_13)</code>, which allows depending on a library built for Scala 2.13.</p>
<p>However, a few of them were not available or didn’t work as expected, so they required a complete change.</p>
<h3 id="heading-newtypes-and-refined-types">Newtypes and refined types</h3>
<p>In Scala 2, we were using a combination of <a target="_blank" href="https://github.com/estatico/scala-newtype">scala-newtype</a> and <a target="_blank" href="https://github.com/fthomas/refined">refined</a> to define custom types used all over our business logic (IDs, bounded values, etc.). There is no Scala 3 version of scala-newtype, which makes sense because it can be entirely replaced by opaque types. Refined is sneakier: it has a Scala 3 version, but if you try to use it, you will notice that it is only partially implemented; the macros are missing, so the library is not usable (the first example in their README doesn’t compile).</p>
<p>In another project using Scala 3, we were already using the <a target="_blank" href="https://github.com/kitlangton/neotype">neotype</a> library, which lets you define both newtypes and refined types and is built on top of opaque types, therefore having no runtime cost. We switched to using this library instead. It might sound simple on paper, but we rely on these types so much that it was quite an invasive change impacting a lot of files. At least the migrated code felt better than the old one since writing refined type validation is nicer and slightly less boilerplate-y, and the runtime impact was reduced.</p>
<h3 id="heading-magnolia-typeclass-derivation">Magnolia typeclass derivation</h3>
<p>Another issue we had was with typeclass derivation using <a target="_blank" href="https://github.com/softwaremill/magnolia">Magnolia</a>. While the library supports Scala 3, our existing derivation code caused a compile error for reaching <code>-Xmax-inlines</code> (too much inlined code). I tried to increase it up to 10,000 (!) and it finally failed with a stack overflow in the compiler.</p>
<p>The failing derivation occurred while deriving a sealed trait with a LOT of subtypes (~1,000), but there was already a typeclass instance for each of the subtypes. After looking at the internals of Magnolia, I noticed that a recursive method was used to fold over the list of subtypes, and that method was not tail-recursive, explaining why the number of inlines (and the stack depth) was increasing proportionally to the number of subtypes. To make matters worse, that recursive method also called <code>distinctBy</code> and <code>sortBy</code> on the list of subtypes at <em>every</em> iteration, which is pretty bad when you have lots of them. I opened <a target="_blank" href="https://github.com/softwaremill/magnolia/issues/565">an issue</a> to report this behavior and changed the code locally, but then I ran into a <code>Method too large</code> error because the generated code was longer than what the JVM allows.</p>
<p>After doing a little research, I came across a great feature of Scala 3 that is poorly documented: <code>Tuple.Map</code>. Mirrors give you access to two tuples: for a sum type, <code>MirroredElemLabels</code> is a tuple with the names of the subtypes, while <code>MirroredElemTypes</code> is a tuple with the actual subtypes. You can use <code>summonAll</code> and <code>Tuple.Map</code> to materialize the list of names of those types or even to summon a typeclass instance for each of them.</p>
<pre><code><span><span>trait</span> <span>TC</span>[<span>A</span>]</span>

inline <span><span>def</span> <span>gen</span></span>[<span>A</span>](using m: <span>Mirror</span>.<span>SumOf</span>[<span>A</span>]): <span>TC</span>[<span>A</span>] = {
  
  <span>val</span> subTypes = compiletime.summonAll[<span>Tuple</span>.<span>Map</span>[m.<span>MirroredElemTypes</span>, <span>TC</span>]]
  <span>new</span> <span>TC</span>[<span>A</span>] {
    ??? 
  }
}
</code></pre>
<p>I posted a <a target="_blank" href="https://gist.github.com/ghostdogpr/6f2ca0939c67765a0657a255ed653765">full example on Gist</a> that shows how to derive a typeclass for a sealed trait without even needing Magnolia. This solution is very concise and does not run into inline or <code>Method too large</code> issues. I just wish there were more learning materials about these <code>Tuple</code> utilities because I think they are very powerful.</p>
<h2 id="heading-macros">Macros</h2>
<p>We had a few macros developed in-house, mostly to reduce boilerplate code. They proved relatively easy to port, except for one of them. The reason it was difficult is that Scala 3 macros are much more strict than Scala 2 macros, which let you generate any kind of code. On the other hand, Scala 3 macros require that the code you generate is valid in the context where the macro is defined (which might be different from where the macro is used, making things trickier). I am not a macro expert, so apologies if this is a little imprecise; my colleague <a target="_blank" href="https://x.com/nox737">@nox737</a> is the one who made the magic happen.</p>
<p>It took us quite a long time to make the macro compile with these restrictions (note: AI agents were not helpful at all for this kind of task!), and in the end, the code still failed to compile because of a <code>Method too large</code> error. Compile time felt a bit slower too. We ended up removing the macro entirely and replacing it with another source generator written with Scalameta. It made the code easier to inspect and to split into smaller chunks.</p>
<h2 id="heading-dependency-issues">Dependency issues</h2>
<p>As mentioned earlier, we used <code>CrossVersion.for3Use2_13</code> for a few libraries not available in Scala 3, but one tough problem arose. One of those libraries was <a target="_blank" href="https://github.com/scalapb/sparksql-scalapb">sparksql-scalapb</a>, which lets us use protobuf with Spark. This library depends on Spark, so it is only available for 2.13. It also depends on <code>scalapb-runtime</code>, so depending on it brings <code>scalapb_runtime_2.13</code> into dependencies. The problem is that the rest of our code already depended on <code>scalapb_runtime_3</code>. In that case, sbt failed to resolve the build with this error:</p>
<pre><code>Modules were resolved with conflicting cross-version suffixes in ProjectRef(uri(&#34;...&#34;), &#34;spark&#34;):
org.scala-lang.modules:scala-collection-compat _3, _2.13
com.thesamet.scalapb:lenses _3, _2.13
com.thesamet.scalapb:scalapb-runtime _3, _2.13
</code></pre>
<p>In other words, you can’t depend on the same library in both 2.13 and 3 versions.</p>
<p>I initially tried to solve that issue by shading dependencies, but it didn’t work because one function we use from <code>sparksql-scalapb</code> expects a specific input extending a type from ScalaPB, which means the rest of our code needs to extend that type. If that type is shaded only in the spark module, it doesn’t match the type from our other modules.</p>
<p>The solution was actually relatively simple: I forked <code>sparksql-scalapb</code> and made it compile with Scala 3, depending on <code>scalapb_runtime_3</code> and using <code>CrossVersion.for3Use2_13</code> for its other dependencies. The code was very straightforward to port, with just some minor things to fix. Then I embedded the produced JAR in our project instead of depending on the 2.13 library. I had to add the transitive dependencies of that library explicitly in our project, and that was it.</p>
<h2 id="heading-slow-compile-time">Slow compile time</h2>
<p>Once all the code was migrated and I was able to compile successfully for the first time, I noticed that it was taking longer than usual. I also noticed that IntelliJ was constantly compiling to show syntax highlighting. There was definitely something wrong. I had already debugged slow compile times with Scala 2 and was accustomed to using the <code>-Vstatistics</code> compiler flag to see which phases were taking time, and even using <a target="_blank" href="https://github.com/scalacenter/scalac-profiling">scalac-profiling</a> to profile the compilation. Unfortunately, a little research made me realize that such tools did not exist for Scala 3. After asking around on <a target="_blank" href="https://x.com/ghostdogpr/status/1881657774817591559">Twitter</a>, I heard that the new version of Scala (3.6.3) released a day earlier was <a target="_blank" href="https://www.scala-lang.org/news/3.6.3/">bringing a compiler flag to generate compiler traces</a>. What a nice timing, I really got lucky with this one.</p>
<p>I immediately upgraded from 3.6.2 to 3.6.3 and enabled the traces. Within minutes, I was able to generate the following flamegraph:</p>
<p><img data-zoomable="true" loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1737952440000/f9cded6c-8ccc-4c73-b884-886469c80831.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>This was extremely useful: as you can see, it breaks down the compilation time by phases, but also by files and even methods! This helped me pinpoint which code was slow to compile. Even though I did not really understand why it was slow (I tried to reproduce it in an isolated example but failed), I was able to refactor the code in a way that made it fast. The issue was about using an extremely large intersection type (with over 100+ types) as a ZIO environment. Reorganizing the environment into fewer types completely solved this issue, made the compile time on par with 2.13, and made IntelliJ very reactive.</p>
<p>This tool is so useful that I plan to spend more time on it in the future because I am pretty sure that it will allow me to find other slow points, considering how detailed the output is. But my goal for the migration was only to be as fast as with 2.13.</p>
<h2 id="heading-intellij-support">IntelliJ support</h2>
<p>Speaking of IntelliJ, I did run into a couple of issues, which I reported to JetBrains:</p>
<ul>
<li><p><a target="_blank" href="https://youtrack.jetbrains.com/issue/SCL-23387/Monocles-focus-macro-is-not-supported-in-Scala-3-works-with-Scala-2-scala-3-context-functions">Context functions are not well supported when combined with an actual function</a> (e.g., <code>Context ?=&gt; From =&gt; To</code>), which comes up when using the Monocle <code>focus</code> macro.</p>
</li>
<li><p><a target="_blank" href="https://youtrack.jetbrains.com/issue/SCL-21142/scala3-cant-resolve-definitions-from-intersection-types-from-self-type">Using a self type in combination with intersection types is broken</a> (e.g., <code>trait A { self: B &amp; C =&gt;</code>), fortunately, it works when using <code>with</code> instead of <code>&amp;</code>, so the workaround was easy.</p>
</li>
</ul>
<p>I hope these bugs get fixed in the near future since they have very simple and easy reproducers (the first one was fixed as I was writing this post, though not released yet). I briefly looked into it, but the Scala plugin for IntelliJ is not really approachable, and I didn’t even know where to start looking.</p>
<p>Other than that, IntelliJ support was pretty good. One thing I recommend is to select <code>Use separate compiler output paths</code> in the sbt configuration menu because the sbt shell and IntelliJ’s own compiler tend to conflict with each other otherwise.</p>
<h2 id="heading-compiler-flags">Compiler flags</h2>
<p>Here are a few notable compiler flags I ended up using:</p>
<ul>
<li><p><code>-language:experimental.betterFors</code> (available under <code>-experimental</code>): this allows using <code>=</code> on the first line of for-comprehensions, and it also optimizes the generated bytecode by avoiding the extra <code>map</code> call at the end of the <code>flatMap</code> calls.</p>
</li>
<li><p><code>-no-indent</code>: I am strongly against significant indentation in Scala, wish it never happened, but at least I am glad it is easy to disable. This is coupled with <code>runner.dialectOverride.allowSignificantIndentation = false</code> in Scalafmt.</p>
</li>
<li><p><code>-Wunused:all</code>: I had a bunch of <code>@nowarn</code> I had to add with Scala 2 because of false positives, and I was able to remove them. It also found some extra unused code that Scala 2 didn’t detect, so it seemed to work better.</p>
</li>
</ul>
<h2 id="heading-conclusion">Conclusion</h2>
<p><img data-zoomable="true" loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1738645933609/3ecd0d93-c28e-45ac-b3a0-bc2b723ea770.png?auto=compress,format&amp;format=webp" alt=""/></p>
<p>Finally, on February 4, the CI turned green on this PR. It has been a long journey with a lot of hurdles, but the situation felt much better in 2025 than a year before. Overall, our code did not change heavily, and most of the changes are for the best. The two things that I really regret are the lack of macro annotations (fortunately, sbt source generators and Scalameta are powerful enough to emulate it) and the removal of general type projections that made our code uglier in some places.</p>
<p>To wrap things up, I am glad our main project did not become a painful legacy stuck in the past, and I am now excited to be able to play with some of the powerful tools that Scala 3 has to offer, particularly around metaprogramming. I hope this read will be helpful to others, whether you have a similar migration to perform or are involved directly with the development of the language and its tooling.</p>
</div></div></div>
  </body>
</html>
