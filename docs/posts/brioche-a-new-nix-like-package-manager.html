<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brioche.dev/blog/announcing-brioche/">Original</a>
    <h1>Show HN: Brioche – A new Nix-like package manager</h1>
    
    <div id="readability-page-1" class="page"><div> <p>I’m super excited to announce the first public release of Brioche! Brioche is a brand new package manager and build tool that builds on top of the best ideas of other package managers, like Nix, Homebrew, and Cargo. It’s designed to be flexible and easy to use, and it leverages TypeScript for fancy typechecking and autocompletions in your build scripts.</p>
<p>I’d consider this release a <strong>Technical Preview</strong>. Currently, it’s limited to x86-64 Linux only, there’s only a small number of packages, and there are still some outstanding issues, including pretty bad performance issues and bugs in the Language Server Protocol implementation. Brioche isn’t really at the point I’d recommend folks use it for Serious Business™ yet… but, everything is <em>working</em>, and I’m finally at the point where I’m ready to get some more eyes on the project.</p>
<blockquote>
<p>If you’ve heard of <a href="https://www.tangram.dev/">Tangram</a> before, Brioche might looks pretty familiar because Brioche heavily borrows ideas from it too. There’s a bit of a history there, which I <a href="#on-tangram">touch on below</a>.</p>
</blockquote>
<p>…Anyway, without further ado, here’s a fairly simple Brioche project file:</p>
<div><figure><pre data-language="ts"><code><div><p><span>// project.bri</span></p></div><div></div><div><p><span>// Import dependencies</span></p></div><div><p><span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> std </span><span>from</span><span> </span><span>&#34;</span><span>std</span><span>&#34;</span><span>;</span></p></div><div><p><span>import</span><span> { cargoBuild } </span><span>from</span><span> </span><span>&#34;</span><span>rust</span><span>&#34;</span><span>;</span></p></div><div></div><div><p><span>// This will get built by default</span></p></div><div><p><span>export</span><span> </span><span>default</span><span> </span><span>function</span><span> </span><span>app</span><span>()</span><span> {</span></p></div><div><p><span>  </span><span>// Build a Rust project with Cargo</span></p></div><div><p><span>  </span><span>return</span><span> </span><span>cargoBuild</span><span>({</span></p></div><div><p><span>    </span><span>// Import Cargo files to build</span></p></div><div><p><span><span>    </span></span><span>crate: Brioche</span><span>.</span><span>glob</span><span>(</span><span>&#34;</span><span>src</span><span>&#34;</span><span>,</span><span> </span><span>&#34;</span><span>Cargo.*</span><span>&#34;</span><span>)</span><span>,</span></p></div><div></div><div><p><span>    </span><span>// Define the path of the default binary to run</span></p></div><div><p><span><span>    </span></span><span>runnable: </span><span>&#34;</span><span>bin/hello</span><span>&#34;</span><span>,</span></p></div><div><p><span><span>  </span></span><span>});</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>// Define an extra export that builds a container</span></p></div><div><p><span>export</span><span> </span><span>function</span><span> </span><span>container</span><span>()</span><span> {</span></p></div><div><p><span>  </span><span>// Wrap the Rust build into an OCI container image</span></p></div><div><p><span>  </span><span>return</span><span> std</span><span>.</span><span>ociContainerImage</span><span>({</span></p></div><div><p><span><span>    </span></span><span>recipe: </span><span>app</span><span>()</span><span>,</span></p></div><div><p><span><span>  </span></span><span>});</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>The <code dir="auto">Brioche.glob</code> line imports files from disk next to the <code dir="auto">project.bri</code> file, so this particular script is meant to live alongside an existing Rust project. Besides that, hopefully it’s pretty self-explanatory what’s going on. A few things you can do with this:</p>
<ul>
<li>You can run <code dir="auto">brioche run</code>, which will call the default export function. This returns a <a href="https://brioche.dev/docs/core-concepts/recipes"><strong>recipe</strong></a> that will use the Rust compiler to build the project. Then, Brioche will call the <code dir="auto">bin/hello</code> binary</li>
<li>You can run <code dir="auto">brioche build -e container -o container.tar</code> to call the <code dir="auto">container</code> function. This will build an OCI container image, ready to be imported into either Docker or Podman</li>
<li>You can run <code dir="auto">brioche build -o output/</code> to save a directory containing <code dir="auto">bin/hello</code>. Not just that: this directory will contain all of the runtime dependencies for the project (including glibc)! That means you can send it to another computer, and it’ll run using the exact same dependencies you just ran it with</li>
</ul>
<p>If you want to check out some more examples or if you want to give Brioche a spin yourself, take a look at the <a href="https://brioche.dev/docs">documentation</a>. If you want to see the currently available packages (or just want to explore some real-world Brioche code), check out the <a href="https://github.com/brioche-dev/brioche-packages">brioche-packages repo</a>.</p>
<h2 id="why-write-another-package-manager">Why write another package manager?</h2>
<p>There are <em>lots</em> of tools that cover some or all of the use-cases I had in mind for Brioche: Nix, Bazel, Earthly, Homebrew, asdf, direnv, devenv, tea, and too many more to list. So why spend the time building something new?</p>
<p>Well, first off, it’s fun! Brioche has been one of my favorite projects to work on. Rust and TypeScript are my two favorite languages to write, and I love the fairly low-level nature of working with compiler toolchains (even if dealing with autotools is endlessly frustrating…)</p>
<p>Second, Nix. A long long time ago (circa 2016), I daily drove NixOS and even briefly maintained a package in the Nixpkgs repo. I was really sold on Nix’s ideas, but I eventually abandoned it because I ended up feeling pretty frustrated when using it. I learned Nix-the-language pretty in-depth, but it never really felt intuitive to me. Derivations always felt weirdly rigid. I didn’t like that the Nixpkgs repo as a whole is versioned as one unit instead of individual packages. I didn’t like how much work I had to put in to get stuff that just works out-of-the-box everywhere else to work on NixOS: I felt like my tools work working <em>against</em> me instead of <em>for</em> me.</p>
<p>2016 was 8 years ago now, and I know the Nix ecosystem has evolved a lot since then. I know Flakes are supposed to be a game changer, there are lots more packages and resources for using Nix, and the core tooling has certainly been improved a lot since then. But it was this experience that planted the idea for Brioche in my head, and I couldn’t shake the feeling that, starting from scratch, I could design something less quirky than Nix while keeping its best features.</p>
<h2 id="whats-in-store-for-brioche">What’s in store for Brioche</h2>
<p>In the short term, there’s lots of things I want to get done: improve performance (I have a lot of ideas here), add more packages, make it easier to do more exotic builds, get Brioche working on more platforms, etc.</p>
<p>In the long term, I want Brioche to be the best way to manage your software projects. I end up finding myself mixing and matching lots of tools in weird ways: I’ve had projects that mix Rust and TypeScript, Rust and ffmpeg, Rust and Swift, Rust and the Windows API, Rust and Godot, Rust and SDL2, etc. (did I mention I like Rust?)</p>
<p>My dream is that I could use Brioche for all of these projects. I want to make a project and have all of its external dependencies tracked in a lockfile. I want to run one command that takes care of building, seeding my test databases, checking formatting, then starting a server in watch mode with my database running alongside. I want to use the same build configuration locally, for a container image, and for CI builds. And I want it to work without virtualization whether I’m using Windows on my desktop, macOS on my laptop, or Linux on the server (and Linux on the desktop when I can finally run all the games I want through Proton)</p>

<p>The Nix community has recently <a href="https://lwn.net/Articles/970824/">been going through Something</a>. My decision to build Brioche was in no way a reaction to the recent fallout around Nix. I still have a ton of respect for Nix as a community, and I’m genuinely rooting for them to establish a solid governance model that puts the community first so Nix-the-project can thrive.</p>
<h2 id="on-tangram">On Tangram</h2>
<p><a href="https://www.tangram.dev/">Tangram</a> is another package manager that has a lot of overlap with Brioche: it’s heavily Nix-inspired, it uses TypeScript for build scripts, it’s written in Rust, and generally Brioche build scripts look pretty similar to Tangram build scripts. At the time of writing, Tangram hasn’t yet been released, but it’s due to release very soon.</p>
<p>The similarities between Tangram and Brioche aren’t a coincidence: I worked for Tangram, Inc. starting in October 2022 to April 2023, when I was fired (I felt I was fired unfairly, but this isn’t the time or place for that story). I had been working on Brioche before my time there, and I decided to resume it some time after I was fired.</p>
<p>There were design decisions made at Tangram that I thought worked really well, and some I thought didn’t work so well, so I simply incorporated what I learned at Tangram into the current iteration of Brioche. I think it’s fair to say that Brioche is, ethically, a fork of Tangram, even though haven’t used any code from Tangram directly (although I am still using some prebuilt static Busybox/Dash/env binaries that Tangram built/published). This is also why the <a href="https://github.com/brioche-dev/brioche/blob/2dd8b881b68adb090c5115e245c3dbc1ee605e6c/LICENSE.md">Brioche license</a> includes a copyright notice from Tangram.</p>
<p>So, why build Brioche rather than just using Tangram when it comes out? Basically, my time at Tangram, Inc. led me to believe pretty strongly that Tangram hits <em>most</em> of what I want from a package manager, but I don’t believe it hits <em>everything</em> I have in mind for Brioche (and vice versa, there certainly will be things Tangram can do that Brioche won’t be able to do and aren’t part of my long-term goals for the project). Said another way, I think both Tangram and Brioche have their own goals and will have their own niches to fill.</p>
<p>I also chose to start from a fresh codebase rather than forking. I felt that starting from scratch would let me re-evaluate some fundamental design decisions. Even though the up-front cost was higher, it also let me iterate faster in the long-run.</p> </div></div>
  </body>
</html>
