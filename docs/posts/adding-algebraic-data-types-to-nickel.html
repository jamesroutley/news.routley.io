<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tweag.io/blog/2024-09-05-algebraic-data-types-nickel/">Original</a>
    <h1>Adding algebraic data types to Nickel</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Our <a href="https://github.com/tweag/nickel/">Nickel</a> language is a configuration language. It’s also a
functional programming language. Functional programming isn’t a well-defined
term: it can encompass anything from being vaguely able to pass functions as
arguments and to call them (in that respect, C and JavaScript are functional) to
being a statically typed, pure and immutable language based on the
lambda-calculus, like Haskell.</p>
<p>However, if you ask a random developer, I can guarantee that one aspect will be
mentioned every time: algebraic data types (ADTs) and pattern matching. They are
the bread and butter of typed functional languages. ADTs are relatively easy to
implement (for language maintainers) and easy to use. They’re part of the 20% of
the complexity that makes for 80% of the joy of functional programming.</p>
<p>But Nickel didn’t have ADTs until recently. In this post, I’ll tell the story of
Nickel and ADTs, starting from why they were initially lacking, the exploration
of different possible solutions and the final design leading to the eventual
retro-fitting of proper ADTs in Nickel. This post is intended for Nickel users,
for people interested in configuration management, but also for anyone interested
in programming language design and functional programming. It doesn’t require
prior Nickel knowledge.</p>
<h2 id="a-quick-primer-on-nickel"><a href="#a-quick-primer-on-nickel" aria-label="a quick primer on nickel permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A quick primer on Nickel</h2>
<p>Nickel is a gradually typed, functional, configuration language. From this
point, we’ll talk about Nickel <em>before</em> the introduction of ADTs in the 1.5
release, unless stated otherwise. The core language features:</p>
<ul>
<li>let-bindings: <code>let extension = &#34;.ncl&#34; in &#34;file.%{extension}&#34;</code></li>
<li>first-class functions: <code>let add = fun x y =&gt; x + y in add 1 2</code></li>
<li>records (JSON objects): <code>{name = &#34;Alice&#34;, age = 42}</code></li>
<li>static typing: <code>let mult : Number -&gt; Number -&gt; Number = fun x y =&gt; x * y</code>. By
default, expressions are dynamically typed. A static type annotation makes a
definition or an inline expression typechecked statically.</li>
<li>contracts look and act almost like types but are evaluated at runtime:
<code>{ port | Port = 80 }</code>. They are used to validate configurations against
potentially complex schemas.</li>
</ul>
<p>The lifecycle of a Nickel configuration is to be 1) written, 2) evaluated and 3) serialized, typically to JSON, YAML or TOML. An important guideline that we set
first was that <em>every native data structure (record, array, enum, etc.) should
be trivially and straightforwardly serializable to JSON</em>. In consequence, Nickel
started with the JSON data model: records (objects), arrays, booleans, numbers
and strings.</p>
<p>There’s one last primitive value: enums. As in C or in JavaScript, an enum in
Nickel is just a tag. An enum value is an identifier with a leading <code>&#39;</code>, such as
in <code>{protocol = &#39;http, server = &#34;tweag.io&#34;}</code>. An enum is serialized as a string:
the previous expression is exported to JSON as <code>{&#34;protocol&#34;: &#34;http&#34;, &#34;server&#34;: &#34;tweag.io&#34;}</code>.</p>
<p>So why not just using strings? Because enums can better represent a finite set
of alternatives. For example, the enum type <code>[| &#39;http, &#39;ftp, &#39;sftp |]</code> is the
type of values that are either <code>&#39;http</code>, <code>&#39;ftp</code> or <code>&#39;sftp</code>. Writing <code>protocol : [| &#39;http, &#39;ftp, &#39;sftp |]</code> will <em>statically</em> (at typechecking time) ensure that
<code>protocol</code> doesn’t take forbidden values such as <code>&#39;https</code>. Even without static
typing, using an enum conveys to the reader that a field isn’t a free-form
string.</p>
<p>Nickel has a <code>match</code> which corresponds to C or JavaScript’s <code>switch</code>:</p>
<div data-language="nickel"><pre><code><span>i</span><span>s</span><span>_</span><span>h</span><span>t</span><span>t</span><span>p</span><span> </span><span>:</span><span> </span><span>[</span><span>|</span><span> </span><span>&#39;</span><span>h</span><span>t</span><span>t</span><span>p</span><span>,</span><span> </span><span>&#39;</span><span>f</span><span>t</span><span>p</span><span>,</span><span> </span><span>&#39;</span><span>s</span><span>f</span><span>t</span><span>p</span><span> </span><span>|</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>Bool</span><span> </span><span>=</span>
<span> </span><span> </span><span>match</span><span> </span><span>{</span>
<span> </span><span> </span><span> </span><span> </span><span>&#39;</span><span>h</span><span>t</span><span>t</span><span>p</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>true</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>_</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>false</span><span>,</span>
<span> </span><span> </span><span>}</span></code></pre></div>
<p>As you might notice, there are no ADTs in sight yet.</p>
<h2 id="adts-in-a-configuration-language"><a href="#adts-in-a-configuration-language" aria-label="adts in a configuration language permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ADTs in a configuration language</h2>
<p>While Nickel is a functional language, it’s first and foremost a configuration
language, which comes with specific design constraints.</p>
<p>Because we’re telling the story of ADTs before they landed in Nickel, we can’t really
use a proper Nickel syntax yet to provide examples. In what follows, we’ll use a
Rust-like syntax to illustrate the examples: <code>enum Foo&lt;T&gt; { Bar(i32), Baz(bool, T) }</code> is an ADT parametrized by a generic type <code>T</code> with two constructors <code>Bar</code>
and <code>Baz</code>, where the first one takes an integer as an argument and the other
takes a pair of a boolean and a <code>T</code>. Concrete values are written as <code>Bar(42)</code> or
<code>Baz(true, &#34;hello&#34;)</code>.</p>
<h3 id="an-unexpected-obstacle-serialization"><a href="#an-unexpected-obstacle-serialization" aria-label="an unexpected obstacle serialization permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>An unexpected obstacle: serialization</h3>
<p>As said earlier, we want values to be straightforwardly serializable to the JSON
data model.</p>
<p>Now, take a simple ADT such as <code>enum Foo&lt;T,U&gt; = { SomePair(T,U), Nothing }</code>. You
can find reasonable serializations for <code>SomePair(1,2)</code>, such as <code>{&#34;tag&#34;: &#34;SomePair&#34;, &#34;a&#34;: 1, &#34;b&#34;: 2}</code>. But why not <code>{&#34;flag&#34;: &#34;SomePair&#34;, &#34;0&#34;: 1, &#34;1&#34;: 2}</code> or <code>{&#34;mark&#34;: &#34;SomePair&#34;, &#34;data&#34;: [1, 2]}</code>? While those representations are isomorphic, it’s hard to know
the right choice for the right use-case beforehand, as it depends on the
consumer of the resulting JSON. We really don’t want to make an arbitrary choice
on behalf of the user.</p>
<p>Additionally, while ADTs are natural for a classical typed functional language,
they might not entirely fit the configuration space. A datatype like <code>enum Literal { String(String), Number(Number) }</code> that can store either a string or a
number is usually represented directly as an <em>untagged</em> union in a
configuration, that <code>{&#34;literal&#34;: 5}</code> or <code>{&#34;literal&#34;: &#34;hello&#34;}</code>, instead of the
less natural <em>tagged</em> union (another name for ADTs) <code>{&#34;literal&#34;: {&#34;tag&#34; = &#34;Number&#34;, &#34;value&#34;: 5}}</code>.</p>
<p>This led us to look at (untagged) union types instead. Untagged unions have the
advantage of not making any choice about the serialization: they aren’t a new
data structure, as are ADTs, but rather new types (and contracts) to classify
values that are already representable.</p>
<h2 id="the-road-of-union-types"><a href="#the-road-of-union-types" aria-label="the road of union types permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The road of union types</h2>
<p>A union type is a type that accepts different alternatives. We’ll use the
fictitious <code>\/</code> type combinator to write a union in Nickel (<code>|</code> is commonly used
elswhere but it’s already taken in Nickel). Our previous example of a <code>literal</code>
that can be either a string or a number would be <code>{literal: Number \/ String}</code>.
Those types are broadly useful independently of ADTs. For example, JSON Schema
features unions through the core combinator <code>any_of</code>.</p>
<p>Our hope was to kill two birds with one stone by adding unions both as a way to
better represent existing configuration schemas, but also as a way to emulate
ADTs. Using unions lets users represent ADTs directly as plain records using
their preferred serialization scheme. Together with <a href="https://en.wikipedia.org/wiki/Flow-sensitive_typing">flow-sensitive
typing</a>, we can get as expressive as ADTs while letting
the user decide on the encoding. Here is an example in a hypothetical Nickel
enhanced with unions and flow-sensitive typing:</p>
<div data-language="nickel"><pre><code><span>let</span><span> </span><span>s</span><span>u</span><span>m</span>
<span> </span><span> </span><span>:</span><span> </span><span>{</span><span>tag</span><span> </span><span>=</span><span> </span><span>&#39;</span><span>S</span><span>o</span><span>m</span><span>e</span><span>P</span><span>a</span><span>i</span><span>r</span><span>,</span><span> </span><span>a</span><span> </span><span>:</span><span> </span><span>Number</span><span>,</span><span> </span><span>b</span><span> </span><span>:</span><span> </span><span>Number</span><span>}</span><span> </span><span>\</span><span>/</span><span> </span><span>{</span><span>tag</span><span> </span><span>=</span><span> </span><span>&#39;</span><span>N</span><span>o</span><span>t</span><span>h</span><span>i</span><span>n</span><span>g</span><span>}</span>
<span> </span><span> </span><span> </span><span> </span><span>-&gt;</span><span> </span><span>Number</span>
<span> </span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>{</span>
<span> </span><span> </span><span> </span><span> </span><span>{</span><span>tag</span><span> </span><span>=</span><span> </span><span>&#39;</span><span>S</span><span>o</span><span>m</span><span>e</span><span>P</span><span>a</span><span>i</span><span>r</span><span>,</span><span> </span><span>a</span><span>,</span><span> </span><span>b</span><span>}</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>a</span><span> </span><span>+</span><span> </span><span>b</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>{</span><span>tag</span><span> </span><span>=</span><span> </span><span>&#39;</span><span>N</span><span>o</span><span>t</span><span>h</span><span>i</span><span>n</span><span>g</span><span>}</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>0</span><span>,</span>
<span> </span><span> </span><span>}</span></code></pre></div>
<p>Using unions and flow-sensitive typing as ADTs is the approach taken by
TypeScript, where the previous example would be:</p>
<div data-language="typescript"><pre><code><span>type</span> <span>Foo</span> <span>=</span> <span>{</span> tag<span>:</span> <span>&#34;SomePair&#34;</span><span>;</span> a<span>:</span> <span>number</span><span>;</span> b<span>:</span> <span>number</span> <span>}</span> <span>|</span> <span>{</span> tag<span>:</span> <span>&#34;Nothing&#34;</span> <span>}</span>

<span>function</span> <span>sum</span><span>(</span>value<span>:</span> Foo<span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>switch</span> <span>(</span>value<span>.</span>tag<span>)</span> <span>{</span>
    <span>case</span> <span>&#34;SomePair&#34;</span><span>:</span>
      <span>return</span> value<span>.</span>a <span>+</span> value<span>.</span>b
    <span>case</span> <span>&#34;Nothing&#34;</span><span>:</span>
      <span>return</span> <span>0</span>
  <span>}</span>
<span>}</span></code></pre></div>
<p>In Nickel, any type must have a contract counter-part. Alas <a href="https://www.tweag.io/blog/2022-04-28-union-intersection-contracts/">union and
intersection contracts are hard</a> (in fact, union
types alone are also not a trivial feat to implement!). In the linked blog post,
we hint at possible pragmatic solutions for union contracts that <a href="https://github.com/tweag/nickel/pull/1995">we finally got
to implement for Nickel 1.8</a>. While sufficient for
practical union contracts, this is far from the general union types that could
subsume ADTs. This puts a serious stop to the idea of using union types to
represent ADTs.</p>
<h2 id="what-are-adts-really-good-for"><a href="#what-are-adts-really-good-for" aria-label="what are adts really good for permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are ADTs really good for?</h2>
<p>As we have been writing more and more Nickel, we realized that we have been missing ADTs a
lot for library functions - typically the types <code>enum Option&lt;T&gt; { Some(T), None }</code> and <code>Result&lt;T,E&gt; = { Ok(T), Error(E) }</code> - where we don’t care about
serialization. Those ADTs are “internal” markers that wouldn’t leak out to the
final exported configuration.</p>
<p>Here are a few motivating use-cases.</p>
<h3 id="stdstringfind"><a href="#stdstringfind" aria-label="stdstringfind permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>std.string.find</code></h3>
<p><code>std.string.find</code> is a function that searches for a substring in a string. Its
current type is:</p>
<div data-language="nickel"><pre><code><span>String</span>
<span>-&gt;</span><span> </span><span>String</span>
<span>-&gt;</span><span> </span><span>{</span><span> </span><span>m</span><span>a</span><span>t</span><span>c</span><span>h</span><span>e</span><span>d</span><span> </span><span>:</span><span> </span><span>String</span><span>,</span><span> </span><span>i</span><span>n</span><span>d</span><span>e</span><span>x</span><span> </span><span>:</span><span> </span><span>Number</span><span>,</span><span> </span><span>g</span><span>r</span><span>o</span><span>u</span><span>p</span><span>s</span><span> </span><span>:</span><span> </span><span>Array</span><span> </span><span>String</span><span> </span><span>}</span></code></pre></div>
<p>If the substring isn’t found, <code>{matched = &#34;&#34;, index = -1, groups []}</code> is
returned, which is error-prone if the consumer doesn’t defend against such
values. We would like to return a proper ADT instead, such as <code>Found {matched : String, index : Number, groups : Array String}</code> or <code>NotFound</code>, which
would make for a better and a safer interface<sup id="fnref-1"><a href="#fn-1">1</a></sup>.</p>
<h3 id="contract-definition"><a href="#contract-definition" aria-label="contract definition permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Contract definition</h3>
<p>Contracts are a powerful validation system in Nickel. The ability to plug in
your own custom contracts is crucial.</p>
<p>However, the general interface to define custom contracts can seem bizarre.
Custom contracts need to set error reporting data on a special <code>label</code> value and
use the exception-throwing-like <code>std.contract.blame</code> function. Here is a
simplified definition of <code>std.number.Nat</code> which checks that a value is natural
number:</p>
<div data-language="nickel"><pre><code><span>fun</span><span> </span><span>l</span><span>a</span><span>b</span><span>e</span><span>l</span><span> </span><span>v</span><span>a</span><span>l</span><span>u</span><span>e</span><span> </span><span>=</span><span>&gt;</span>
<span> </span><span> </span><span>if</span><span> </span><span>s</span><span>t</span><span>d</span><span>.</span><span>t</span><span>y</span><span>p</span><span>e</span><span>o</span><span>f</span><span> </span><span>value</span><span> </span><span>=</span><span>=</span><span> </span><span>&#39;</span><span>Number</span><span> </span><span>then</span>
<span> </span><span> </span><span> </span><span> </span><span>if</span><span> </span><span>v</span><span>a</span><span>l</span><span>u</span><span>e</span><span> </span><span>%</span><span> </span><span>1</span><span> </span><span>=</span><span>=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>v</span><span>a</span><span>l</span><span>u</span><span>e</span><span> </span><span>&gt;</span><span>=</span><span> </span><span>0</span><span> </span><span>then</span>
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>v</span><span>a</span><span>l</span><span>u</span><span>e</span>
<span> </span><span> </span><span> </span><span> </span><span>else</span>
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>let</span><span> </span><span>label</span><span> </span><span>=</span><span> </span><span>s</span><span>t</span><span>d</span><span>.</span><span>c</span><span>o</span><span>n</span><span>t</span><span>r</span><span>a</span><span>c</span><span>t</span><span>.</span><span>l</span><span>a</span><span>b</span><span>e</span><span>l</span><span>.</span><span>w</span><span>i</span><span>t</span><span>h</span><span>_</span><span>m</span><span>e</span><span>s</span><span>s</span><span>a</span><span>g</span><span>e</span><span> </span><span>&#34;not a natural&#34;</span><span> </span><span>in</span>
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>s</span><span>t</span><span>d</span><span>.</span><span>c</span><span>o</span><span>n</span><span>t</span><span>r</span><span>a</span><span>c</span><span>t</span><span>.</span><span>b</span><span>l</span><span>a</span><span>m</span><span>e</span><span> </span><span>l</span><span>a</span><span>b</span><span>e</span><span>l</span>
<span> </span><span> </span><span>else</span>
<span> </span><span> </span><span> </span><span> </span><span>let</span><span> </span><span>label</span><span> </span><span>=</span><span> </span><span>s</span><span>t</span><span>d</span><span>.</span><span>c</span><span>o</span><span>n</span><span>t</span><span>r</span><span>a</span><span>c</span><span>t</span><span>.</span><span>l</span><span>a</span><span>b</span><span>e</span><span>l</span><span>.</span><span>w</span><span>i</span><span>t</span><span>h</span><span>_</span><span>m</span><span>e</span><span>s</span><span>s</span><span>a</span><span>g</span><span>e</span><span> </span><span>&#34;not a number&#34;</span><span> </span><span>in</span>
<span> </span><span> </span><span> </span><span> </span><span>s</span><span>t</span><span>d</span><span>.</span><span>c</span><span>o</span><span>n</span><span>t</span><span>r</span><span>a</span><span>c</span><span>t</span><span>.</span><span>b</span><span>l</span><span>a</span><span>m</span><span>e</span><span> </span><span>l</span><span>a</span><span>b</span><span>e</span><span>l</span></code></pre></div>
<p>There are good (and bad) reasons for this situation, but if we had ADTs, we
could cover most cases with an alternative interface where custom contracts
return a <a href="https://doc.rust-lang.org/std/result/"><code>Result&lt;T,E&gt;</code></a>, which is simpler and more natural:</p>
<div data-language="nickel"><pre><code><span>fun</span><span> </span><span>v</span><span>a</span><span>l</span><span>u</span><span>e</span><span> </span><span>=</span><span>&gt;</span>
<span> </span><span> </span><span>if</span><span> </span><span>s</span><span>t</span><span>d</span><span>.</span><span>t</span><span>y</span><span>p</span><span>e</span><span>o</span><span>f</span><span> </span><span>value</span><span> </span><span>=</span><span>=</span><span> </span><span>&#39;</span><span>Number</span><span> </span><span>then</span>
<span> </span><span> </span><span> </span><span> </span><span>if</span><span> </span><span>v</span><span>a</span><span>l</span><span>u</span><span>e</span><span> </span><span>%</span><span> </span><span>1</span><span> </span><span>=</span><span>=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>v</span><span>a</span><span>l</span><span>u</span><span>e</span><span> </span><span>&gt;</span><span>=</span><span> </span><span>0</span><span> </span><span>then</span>
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>O</span><span>k</span>
<span> </span><span> </span><span> </span><span> </span><span>else</span>
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>E</span><span>r</span><span>r</span><span>o</span><span>r</span><span>(</span><span>&#34;not a natural&#34;</span><span>)</span>
<span> </span><span> </span><span>else</span>
<span> </span><span> </span><span> </span><span> </span><span>E</span><span>r</span><span>r</span><span>o</span><span>r</span><span>(</span><span>&#34;not a number&#34;</span><span>)</span></code></pre></div>
<p>Of course, we could just encode this using a record, but it’s just not as nice.</p>
<h3 id="let-it-go-let-it-go"><a href="#let-it-go-let-it-go" aria-label="let it go let it go permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let it go, let it go!</h3>
<p>The list of other examples of using ADTs to make libraries nicer is endless.</p>
<p><strong>Thus, for the first time, we decided to introduce a native data
structure that isn’t serializable</strong>.</p>
<p>Note that this doesn’t break any existing code and is forward-compatible with
making ADTs serializable in the future, should we change our mind and settle on
one particular encoding. Besides, <a href="https://github.com/tweag/nickel/issues/1170#issuecomment-1461637685">another feature</a> is
independently explored to make serialization more customizable through metadata,
which would let users use custom (de)serializer for ADTs easily.</p>
<p>Ok, let’s add the good old-fashioned ADTs to Nickel!</p>
<h2 id="the-design"><a href="#the-design" aria-label="the design permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The design</h2>
<h3 id="structural-vs-nominal"><a href="#structural-vs-nominal" aria-label="structural vs nominal permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Structural vs nominal</h3>
<p>In fact, we won’t exactly add the old-fashioned version. ADTs are traditionally
implemented in their <em>nominal</em> form.</p>
<p>A nominal type system (such as C, Rust, Haskell, Java, etc.) decides if two
types are equal based on their name and definition. For example, values of <code>enum Alias1 { Value(String) }</code> and <code>enum Alias2 { Value(String) }</code> are entirely
interchangeable in practice, but Rust still doesn’t accept <code>Alias1::Value(s)</code>
where a <code>Alias2</code> is expected, because those types have distinct definitions.
Similarly, you can’t swap a class for another in Java just because they have
exactly the same fields and methods.</p>
<p>A structural type system, on the other hand, only cares about the shape of data.
TypeScript has a structural type system. For example, the types <code>interface Ball { diameter: number; }</code> and <code>interface Sphere { diameter: number; }</code> are entirely
interchangeable, and <code>{diameter: 42}</code> is both a <code>Ball</code> and a <code>Sphere</code>. Some
languages, like OCaml<sup id="fnref-2"><a href="#fn-2">2</a></sup> or Go<sup id="fnref-3"><a href="#fn-3">3</a></sup>,
mix both.</p>
<p>Nickel’s current type system is structural because it’s better equipped to
handle arbitrary JSON-like data. Because ADTs aren’t serializable, this
consideration doesn’t weight as much for our motivating use-cases, meaning ADTs
could be still be either nominal or structural.</p>
<p>However, nominal types aren’t really usable without some way of exporting and
importing type definitions, which Nickel currently lacks. It sounds more natural
to go for structural ADTs, which seamlessly extend the existing enums and would
overall fit better with the rest of the type system.</p>
<p>Structural ADTs look like the better choice for Nickel. We can build,
typecheck, and match on ADTs locally without having to know or to care about any
type declaration. Structural ADTs are a natural extension of Nickel (structural)
enums, syntactically, semantically, and on the type level, as we will see.</p>
<p>While less common, structural ADTs do exist in the wild and they are pretty
cool. OCaml has both nominal ADTs and structural ADTs, the latter being known as
<em><a href="https://ocaml.org/manual/5.2/polyvariant.html">polymorphic variants</a></em>. They are an especially powerful way to represent a non
trivial hierarchy of data types with overlapping, such as <a href="https://github.com/ocsigen/tyxml">abstract syntax
trees</a> or sets of error values.</p>
<h3 id="syntax"><a href="#syntax" aria-label="syntax permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax</h3>
<p>C-style enums are just a special case of ADTs, namely ADTs where constructors
don’t have any argument. The dual conclusion is that ADTs are enums with
arguments. We thus write the ADT <code>Some(&#34;hello&#34;)</code> as an enum with an argument in
Nickel: <code>&#39;Some &#34;hello&#34;</code>.</p>
<p>We apply the same treatment to types. <code>[| &#39;Some, &#39;None |]</code> was a valid enum
type, and now <code>[| &#39;Some String, &#39;None |]</code> is also a valid type (which would
correspond to Rust’s <code>Option&lt;String&gt;</code>).</p>
<p>There is a subtlety here: what should be the type inferred for <code>&#39;Some</code> now? In
a structural type system, <code>&#39;Some</code> is just a free-standing symbol. The typechecker
can’t know if it’s a constant that will stay as it is - and thus has the type
<code>[| &#39;Some |]</code> - or a constructor that will be eventually applied, of type <code>a -&gt; [| &#39;Some a |]</code>. This difficulty just doesn’t exist in a nominal type system like
Rust: there, <code>Option::Some</code> refers to a unique, known and fixed ADT constructor
that is known to require precisely one argument.</p>
<p>To make it work, <code>&#39;Ok 42</code> isn’t actually a normal function application in
Nickel: it’s an ADT constructor application, and it’s parsed differently. We
just repurpose the function application syntax<sup id="fnref-4"><a href="#fn-4">4</a></sup>
in this special case. <code>&#39;Ok</code> isn’t a function, and <code>let x = &#39;Ok in x 42</code> is an
error (applying something that isn’t a function).</p>
<p>You can still recover Rust-style constructors that can be applied by defining a
function (<em>eta-expanding</em>, in the functional jargon): <code>let ok = fun x =&gt; &#39;Ok x</code>.</p>
<p>We restrict ADTs to a single argument. You can use a record to emulate multiple
arguments: <code>&#39;Point {x = 1, y = 2}</code>.</p>
<p>ADTs also come with pattern matching. The basic switch that was <code>match</code> is now a
powerful pattern matching construct, with support for ADTs but also arrays,
records, constant, wildcards, or-patterns and guards (<code>if</code> side-conditions).</p>
<h3 id="typechecking"><a href="#typechecking" aria-label="typechecking permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Typechecking</h3>
<p>Typechecking structural ADTs is a bit different from nominal ADTs. Take the
simple example (the enclosing <code>: _</code> annotation is required to make the example
statically typed in Nickel)</p>
<div data-language="nickel"><pre><code><span>(</span>
<span> </span><span> </span><span>let</span><span> </span><span>data</span><span> </span><span>=</span><span> </span><span>&#39;</span><span>O</span><span>k</span><span> </span><span>42</span><span> </span><span>in</span>
<span> </span><span> </span><span>let</span><span> </span><span>process</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>{</span>
<span> </span><span> </span><span> </span><span> </span><span>&#39;</span><span>O</span><span>k</span><span> </span><span>x</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>&#39;</span><span>E</span><span>r</span><span>r</span><span>o</span><span>r</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>0</span><span>,</span>
<span> </span><span> </span><span>}</span><span> </span><span>in</span>

<span> </span><span> </span><span>p</span><span>r</span><span>o</span><span>c</span><span>e</span><span>s</span><span>s</span><span> </span><span>d</span><span>a</span><span>t</span><span>a</span>
<span>)</span><span> </span><span>:</span><span> </span><span> </span><span>_</span></code></pre></div>
<p><code>process</code> is inferred to have type <code>[| &#39;Ok Number, &#39;Error |] -&gt; Number</code>. What
type should we infer for <code>data = &#39;Ok 42</code>? The most obvious one is <code>[| &#39;Ok Number |]</code>. But then <code>[| &#39;Ok Number |]</code> and <code>[| &#39;Ok Number, &#39;Error |]</code> don’t match and
<code>process data</code> doesn’t typecheck! This is silly, because this example should
be perfectly valid.</p>
<p>One possible solution is to introduce subtyping, which is able to express this
kind of inclusion relation: here that <code>[| &#39;Ok Number |]</code> is included in <code>[| &#39;Ok Number, &#39;Error |]</code>. However, subtyping has some defects and is whole can of
worms when mixed with polymorphism (which Nickel has).</p>
<p>Nickel rather relies on another approach called <em>row polymorphism</em>, which is the
ability to abstract over not just a type, as in classical polymorphism, but a
whole piece of an enum type. Row polymorphism is well studied in the literature,
and is for example implemented in PureScript. Nickel already features row
polymorphism for basic enum types and for records types.</p>
<p>Here is how it works:</p>
<div data-language="nickel"><pre><code><span>let</span><span> </span><span>p</span><span>r</span><span>o</span><span>c</span><span>e</span><span>s</span><span>s</span><span> </span><span>:</span><span> </span><span>forall</span><span> </span><span>a</span><span>.</span><span> </span><span>[</span><span>|</span><span> </span><span>&#39;</span><span>O</span><span>k</span><span> </span><span>Number</span><span>,</span><span> </span><span>&#39;</span><span>E</span><span>r</span><span>r</span><span>o</span><span>r</span><span>;</span><span> </span><span>a</span><span> </span><span>|</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>Number</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>{</span>
<span> </span><span> </span><span>&#39;</span><span>O</span><span>k</span><span> </span><span>x</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span>
<span> </span><span> </span><span>&#39;</span><span>E</span><span>r</span><span>r</span><span>o</span><span>r</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>0</span><span>,</span>
<span> </span><span> </span><span>_</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>-</span><span>1</span><span>,</span>
<span>}</span><span> </span><span>in</span>

<span>p</span><span>r</span><span>o</span><span>c</span><span>e</span><span>s</span><span>s</span><span> </span><span>&#39;</span><span>O</span><span>t</span><span>h</span><span>e</span><span>r</span></code></pre></div>
<p>Because there’s a catch-all case <code>_ =&gt; -1</code>, the type of <code>process</code> is
polymorphic, expressing that it can handle any other variant beside <code>&#39;Ok Number</code>
and <code>&#39;Error</code> (this isn’t entirely true: <code>Ok String</code> is forbidden for example, because it can’t be distinguished from <code>Ok Number</code>). Here, <code>a</code> can be substituted for a subsequence of an enum type,
such as <code>&#39;Foo Bool, &#39;Bar {x : Number}</code>.</p>
<p>Equipped with row polymorphism, we can infer the type <code>forall a. [| &#39;Ok Number; a |]</code><sup id="fnref-5"><a href="#fn-5">5</a></sup> for <code>&#39;Ok 42</code>. When typechecking <code>process data</code> in the
original example, <code>a</code> will be instantiated to the single row <code>&#39;Error</code> and the
example typechecks. You can learn more about structural ADTs and row
polymorphism in the <a href="https://nickel-lang.org/user-manual/typing#enum-row-polymorphism">corresponding section of the Nickel user
manual</a>.</p>
<h2 id="conclusion"><a href="#conclusion" aria-label="conclusion permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>While ADTs are part of the basic package of functional languages, Nickel didn’t
have them until relatively recently because of peculiarities of the design of a
configuration language. After exploring the route of union types, which came to
a dead-end, we settled on a structural version of ADTs that turns out to be a
natural extension of the language and didn’t require too much new syntax or
concepts.</p>
<p>ADTs already prove useful to write cleaner and more concise code, and to improve
the interface of libraries, even in a gradually typed configuration language.
Some concrete usages can be found in <a href="https://github.com/tweag/nickel/pull/2000">try_fold_left</a> and <a href="https://github.com/tweag/nickel/pull/1970">validators</a> already.</p>
</div></div></div></div>
  </body>
</html>
