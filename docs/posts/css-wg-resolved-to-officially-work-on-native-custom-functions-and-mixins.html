<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://css.oddbird.net/sasslike/mixins-functions/">Original</a>
    <h1>CSS WG resolved to officially work on native custom functions and mixins</h1>
    
    <div id="readability-page-1" class="page"><div>
    









<p>Miriam Suzanne</p>
<p>(Based heavily on a custom-function proposal by Tab<span> </span>Atkins)</p>
<h2 id="intro">Intro <a href="#intro">¶</a></h2>
<p>In order to reduce code repetition,
ensure consistency across a project,
and encourage best practice,
authors have often turned to third-party
<span>CSS</span> pre-processors
(Sass, Less, PostCSS, Stylus, etc)
to define custom reusable ‘macros’.
These generally fall into two<span> </span>categories:</p>
<ul>
<li><strong>Functions</strong> return <span>CSS</span> <em>values</em> –
like a string, color, or length.
They can only be used <em>inside</em>
the value space of a <span>CSS</span><span> </span>property.</li>
<li><strong>Mixins</strong> return <span>CSS</span> <em>declarations</em>
or entire <em>rule blocks</em>.
They can only be used <em>outside</em>
the value space of a <span>CSS</span><span> </span>property.</li>
</ul>
<p><span>CSS</span> already provides a wide range
of built-in functions,
such as <code>calc()</code>, <code>minmax()</code>, and many more.
Ideally, custom functions would work in a similar way,
but prefixed with a dashed-ident
to avoid future compatibility issues.
For a simple<span> </span>example:</p>
<pre><code><span><span>@function</span> --negative <span>(</span>--value<span>)</span></span> <span>{</span></code></pre>
<p><span>CSS</span> does not yet have built-in mixins,
though several have been proposed
in discussions of this feature.
A simple mixin might look something like<span> </span>this:</p>
<pre><code><span><span>@mixin</span> --button <span>(</span>--face<span>,</span> --text<span>,</span> --radius<span>)</span></span> <span>{</span></code></pre>
<h2 id="discussion">Discussion <a href="#discussion">¶</a></h2>
<ul>
<li>Discussion on <span>CSSWG</span> Drafts
<a href="https://github.com/w3c/csswg-drafts/issues/9350">Proposal: Custom <span>CSS</span> Functions <span>&amp;</span> Mixins<span> </span>(#9350)</a></li>
<li>Existing proposal for
<a href="https://github.com/w3c/csswg-drafts/issues/7490">Declarative custom functions<span> </span>(#7490)</a></li>
<li>Issue tracker
for this explainer:
<a href="https://github.com/oddbird/css-sandbox/issues">OddBird <span>CSS</span> Sandbox<span> </span>Issues</a></li>
</ul>
<p>There are several other relevant discussions
in the <span>CSS</span> Working Group,
that predate this<span> </span>proposal:</p>
<ul>
<li><a href="https://github.com/w3c/csswg-drafts/issues/7879">[css-variables-2] Custom shorthands with @property<span> </span>#7879</a></li>
<li><a href="https://github.com/w3c/csswg-drafts/issues/7490">Declarative custom functions<span> </span>#7490</a></li>
<li><a href="https://github.com/w3c/csswg-drafts/issues/5624">[css-variables?] Higher level custom properties that control multiple declarations<span> </span>#5624</a></li>
</ul>
<p>(If there are more I haven’t found,
please <a href="https://github.com/oddbird/css-sandbox/issues">let me know</a>.)</p>
<!--
..######..##.....##.##.....##.##.....##....###....########..##....##
.##....##.##.....##.###...###.###...###...##.##...##.....##..##..##.
.##.......##.....##.####.####.####.####..##...##..##.....##...####..
..######..##.....##.##.###.##.##.###.##.##.....##.########.....##...
.......##.##.....##.##.....##.##.....##.#########.##...##......##...
.##....##.##.....##.##.....##.##.....##.##.....##.##....##.....##...
..######...#######..##.....##.##.....##.##.....##.##.....##....##...
-->
<h2 id="summary--goals">Summary <span>&amp;</span> Goals <a href="#summary--goals">¶</a></h2>
<p>Features often change
as they move from (generally imperative)
pre-processors into <span>CSS</span> –
taking on different affordances and constraints
appropriate for a declarative,
client-side<span> </span>language:</p>
<ul>
<li>How would <span>CSS</span>-native mixins and functions
differ from<span> </span>pre-processors?</li>
<li>What extra functionality or limitations
come from providing these features
in the<span> </span>browser?</li>
</ul>
<p>From a language/implementation perspective
mixins and functions
are entirely distinct features –
they live at different levels of the syntax,
and come with different complications.
If we pursue both,
we likely want to define them at
different levels of a specification,
or even in different<span> </span>specifications.</p>
<p>Removing the reliance on pre-processors
would further simplify maintenance for <span>CSS</span> authors,
while providing new client-side<span> </span>functionality:</p>
<ul>
<li>Passing cascaded custom-properties as<span> </span>arguments.</li>
<li>Adding media/support and other client-side<span> </span>conditions.</li>
</ul>
<p>My goal here is to explore
what would be possible with each feature,
where we could re-use syntax between them,
and how we might move forward
with implementing<span> </span>them.</p>
<p>I am not expecting this to be the final shape
for either feature,
but I want to capture the state of the conversation,
and help move it forward.
If these features are officially
adopted by the working group,
further development can be broken
into individual specs and<span> </span>issues.</p>
<!--
.####.##....##.########.########.########..########..######..########
..##..###...##....##....##.......##.....##.##.......##....##....##...
..##..####..##....##....##.......##.....##.##.......##..........##...
..##..##.##.##....##....######...########..######....######.....##...
..##..##..####....##....##.......##...##...##.............##....##...
..##..##...###....##....##.......##....##..##.......##....##....##...
.####.##....##....##....########.##.....##.########..######.....##...
-->
<h2 id="author-interest">Author Interest <a href="#author-interest">¶</a></h2>
<p>There is some (incomplete) data
from the <span>HTTP</span> Archive project
that can help us understand
how authors are using Sass<span> </span>currently:</p>
<ul>
<li><a href="https://github.com/w3c/csswg-drafts/issues/5798">Stats on Scss usage of control flow, conditional logic, nesting, custom functions<span> </span>#5798</a></li>
</ul>
<p>I also ran a small <a href="https://front-end.social/@mia/110833306689188274">survey on Mastodon</a>:</p>
<blockquote>
<p>“What are the most common custom functions or mixins
that you define/use in a css<span> </span>pre-processor?”</p>
</blockquote>
<p>The answers included:</p>
<ul>
<li>(Functions) Conversion from pixel to <code>rem</code> units</li>
<li>(Functions) random number<span> </span>generators</li>
<li>(Functions) Color contrast</li>
<li>(Mixins) Named shorthands for common media<span> </span>queries</li>
<li>(Mixins) Generating output from object for-each loops (like Sass<span> </span>Maps)</li>
<li>(Mixins) Reusable component<span> </span>styles</li>
<li>(Mixins) Complex solutions, like scroll-shadows or gradient<span> </span>text</li>
<li>(Both) Fluid typography<span> </span>settings</li>
<li>(Both) Complex <code>calc()</code> shorthands for various<span> </span>situations</li>
</ul>
<p>Some of these would be possible to achieve
in <span>CSS</span> with a declarative syntax,
without additional new functionality.
Others (like loops) would require imperative control<span> </span>structures.</p>
<p>While some of these (like <code>random()</code>)
are already being discussed for built-in functions,
others (like <code>color-contrast()</code>)
may be simpler to solve in user-space.
It has been very difficult for the <span>CSSWG</span>
to settle on a long-term solution
for the entire platform,
while an individual team would be
more able to change their approach gradually over time.
By capturing that logic in a single place
(like a custom function),
many changes could be made without
any invasive re-write of the code<span> </span>base.</p>
<p>The ability to declare this logic in <span>CSS</span>
rather than a pre-processor
would provide several<span> </span>benefits:</p>
<ul>
<li><em>Reduce the external dependencies</em> and build steps
required in order to generate the<span> </span>code</li>
<li><em>Reduce the file size delivered</em> from the server
(though this may be negligible after compression <span>&amp;</span>
increased client-side<span> </span>processing)</li>
<li><em>use custom properties as arguments</em>
so that the mixins or functions
could respond to changes in the<span> </span>cascade</li>
<li><em>use media/container/support conditions</em>
as part of the internal<span> </span>logic</li>
</ul>
<!--
.########.....###....########.....###....##.....##..######.
.##.....##...##.##...##.....##...##.##...###...###.##....##
.##.....##..##...##..##.....##..##...##..####.####.##......
.########..##.....##.########..##.....##.##.###.##..######.
.##........#########.##...##...#########.##.....##.......##
.##........##.....##.##....##..##.....##.##.....##.##....##
.##........##.....##.##.....##.##.....##.##.....##..######.
-->
<h2 id="defining-parameters">Defining parameters <a href="#defining-parameters">¶</a></h2>
<p>Both functions and mixins
rely on a <code>&lt;parameter-list&gt;</code> syntax.
Each <code>&lt;parameter&gt;</code>
in the <code>&lt;parameter-list&gt;</code>
consists of three<span> </span>parts:</p>
<ul>
<li><code>&lt;name&gt;</code> (required)
which is a <code>dashed-ident</code></li>
<li><code>&lt;syntax&gt;</code> (default: <code>*</code>)
similar to the <code>syntax</code> descriptor in <code>@property</code></li>
<li><code>&lt;default-value&gt;</code> (default: <code>guaranteed invalid</code>)
which is any value that matches the<span> </span>syntax</li>
</ul>
<p>Defining all three aspects in the function prelude
(name, type, and default)
can make the syntax over-complicated.
My initial proposal
included special <code>@property</code>-like
descriptor blocks to make that<span> </span>possible.</p>
<p>Since then,
the discussion has moved towards
a more concise approach
using a comma-separated<span> </span>list.</p>
<p>Authors can provide names<span> </span>only:</p>
<pre><code><span><span>@function</span> <span>--my-function</span><span>(</span>--param-a<span>,</span> --another-param<span>)</span></span> <span>{</span> … <span>}</span></code></pre>
<p>Optionally,
they can also provide a default<span> </span>value:</p>
<pre><code><span><span>@function</span> <span>--my-function</span><span>(</span></span> <span>{</span> … <span>}</span></code></pre>
<details data-alert="note" open="">
            <summary>Note:</summary>
            
          </details>
<p>Finally,
authors could define
a syntax for any parameter,
using the <code>type()</code> function
along side the name.
This would work with or without default<span> </span>values:</p>
<pre><code><span><span>@function</span> <span>--my-function</span><span>(</span></span> <span>{</span> … <span>}</span></code></pre>
<!--
.########.##.....##.##....##..######..########.####..#######..##....##..######.
.##.......##.....##.###...##.##....##....##.....##..##.....##.###...##.##....##
.##.......##.....##.####..##.##..........##.....##..##.....##.####..##.##......
.######...##.....##.##.##.##.##..........##.....##..##.....##.##.##.##..######.
.##.......##.....##.##..####.##..........##.....##..##.....##.##..####.......##
.##.......##.....##.##...###.##....##....##.....##..##.....##.##...###.##....##
.##........#######..##....##..######.....##....####..#######..##....##..######.
-->
<h2 id="defining-a-function-the-function-rule">Defining a function: the <code>@function</code> rule <a href="#defining-a-function-the-function-rule">¶</a></h2>
<p>In order to define a custom function,
we need several bits of<span> </span>information:</p>
<ul>
<li><code>function-name</code> (required)</li>
<li><code>parameter-list</code> (optional - see<span> </span>above)</li>
<li>Some amount of internal logic using <code>function-rules</code></li>
<li>A returned <code>result</code> value</li>
</ul>
<p>The proposed syntax
(with a few adjustments)
could look something<span> </span>like:</p>
<pre><code>@function &lt;function-name&gt; [( &lt;parameter-list&gt; )]? {
  &lt;function-rules&gt;

  result: &lt;result&gt;;
}
</code></pre>
<p>The <code>function-name</code> is a dashed-ident.
If multiple functions have the same name,
then functions in a higher cascade layer take priority,
and functions defined later have priority
within a given cascade layer.
This matches the behavior of other name-defining<span> </span>at-rules.</p>
<p>It may also be useful to define an intended ‘return type’
(e.g. <code>color</code> or <code>length</code>) for the function,
so that it can be validated at parse time.
Like custom properties,
there is still a chance that a function’s output
will be <em>invalid at computed value time</em>,
but we can at least ensure that
the function is intended to return an appropriate syntax
for the context where it is being<span> </span>called.</p>
<p>Extending the above syntax,
I would imagine re-using the <code>type()</code> function
in the<span> </span>prelude:</p>
<pre><code>@function &lt;function-name&gt; [( &lt;parameter-list&gt; )]? [returns type(&lt;syntax&gt;)]? {
  &lt;function-rules&gt;

  result: &lt;result&gt;;
}
</code></pre>
<p>I would expect <code>&lt;syntax&gt;</code> to allows the same
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@property/syntax#values">subset of <span>CSS</span> Types</a>
provided by the <code>syntax</code> descriptor of the <code>@property</code> rule.
Maybe it would be possible to remove
the requirement for quotes around a syntax in this<span> </span>context?</p>
<h3 id="returning-values">Returning values <a href="#returning-values">¶</a></h3>
<p>There have been several syntax options discusses
for returning a <code>&lt;result&gt;</code> value,
but it seems to me like the simplest
and most familiar would be a descriptor
called something like <code>result</code> or <code>output</code>.
This would help re-enforce
the declarative nature of functions,
since it can be treated similar to other declarations:
the last <code>result</code> is used if multiple are<span> </span>present.</p>
<p>Like custom properties:</p>
<ul>
<li>The <code>&lt;result&gt;</code> can contain any valid <span>CSS</span> value-space<span> </span>syntax</li>
<li>This value has <code>invalid at computed value time</code> behavior</li>
</ul>
<p>Since functions exist in the value space,
<code>&lt;function-rules&gt;</code> will not contain any other
(non-custom) <span>CSS</span> properties,
so the single <code>result</code> descriptor should stand out.
If multiple results are encountered,
the last result takes precedence
(consistent with other descriptors and properties).
This is discussed in more detail<span> </span>below.</p>
<details data-alert="note" open="">
            <summary>Note:</summary>
            
          </details>
<h3 id="function-rules">Function rules <a href="#function-rules">¶</a></h3>
<p>The <code>&lt;function-rules&gt;</code> can include custom property declarations
(which are scoped to the function),
as well as conditional at-rules
(which may contain further nested
custom properties and <code>result</code>s).
Element-specific conditions (such as container queries)
would be resolved for each element that calls the<span> </span>function.</p>
<p>My assumption
would be that custom properties
defined inside the function
are not available
on elements where the function is called.
However, it’s clear that authors will expect
to reference external custom properties
from inside functions –
using some variation of dynamic scope,
and ‘shadowing’<span> </span>behavior.</p>
<p>As far as I can tell,
only custom properties, args/variables,
and conditional rules
are useful inside a function definition.
Functions have no output
besides their returned value,
so nested selectors, built-in properties,
and name-defining rules
are not necessary or meaningful.
I don’t think there’s any need for these things
to invalidate the entire function,
but they should be ignored and<span> </span>discarded.</p>
<p>An example function
using conditional rules
to return one of multiple<span> </span>values:</p>
<pre><code><span><span>@function</span> <span>--sizes</span><span>(</span></span> <span>{</span></code></pre>
<p>Some functions will also want access to
contextual variables
on the calling elements.
To avoid fully dynamic scoping
of custom properties,
Tab has proposed a second list
of properties that should be available
in the<span> </span>function:</p>
<pre><code><span><span>@function</span> --my-function <span>(</span>--arg1<span>,</span> --arg2<span>)</span> using <span>(</span>--var1<span>,</span> --var2<span>)</span></span> <span>{</span></code></pre>
<details data-alert="note" open="">
            <summary>Note:</summary>
            
          </details>
<h3 id="calling-functions">Calling functions <a href="#calling-functions">¶</a></h3>
<p>Custom functions can be called
from the value space of any property,
with the name of the functions,
followed by parenthesis and
a comma-separated list of<span> </span>arguments:</p>
<pre><code><span>button</span> <span>{</span></code></pre>
<p>If we do (eventually) want to support named arguments,
it would ideally use a familiar
declaration<span> </span>syntax:</p>
<pre><code><span>button</span> <span>{</span></code></pre>
<p>If positional and named arguments
are allowed in the same function call,
the common convention is to require
all positional values come before any named values
to avoid<span> </span>confusion:</p>
<pre><code><span>button</span> <span>{</span></code></pre>
<p>We need to allow a broad
syntax for argument values –
including values that contain commas.
There’s an active discussion
about the best way to handle this
more generally in
<a href="https://github.com/w3c/csswg-drafts/issues/9539">issue #9539</a>.
Custom functions should use whatever solution
is agreed on<span> </span>there.</p>
<h3 id="putting-it-all-together">Putting it all together <a href="#putting-it-all-together">¶</a></h3>
<p>Adapting the fluid ratio function above
to the proposed<span> </span>syntax:</p>
<pre><code><span><span>@function</span> <span>--fluid-ratio</span><span>(</span></span> <span>{</span></code></pre>
<p>We could also consider moving the <code>mix()</code> logic
into the<span> </span>function:</p>
<pre><code><span><span>@function</span> <span>--fluid-mix</span><span>(</span></span> <span>{</span></code></pre>
<!--
.##.....##.####.##.....##.####.##....##..######.
.###...###..##...##...##...##..###...##.##....##
.####.####..##....##.##....##..####..##.##......
.##.###.##..##.....###.....##..##.##.##..######.
.##.....##..##....##.##....##..##..####.......##
.##.....##..##...##...##...##..##...###.##....##
.##.....##.####.##.....##.####.##....##..######.
-->
<h2 id="defining-a-mixin-the-mixin-rule">Defining a mixin: the <code>@mixin</code> rule <a href="#defining-a-mixin-the-mixin-rule">¶</a></h2>
<p>Rather than returning a single value,
mixins return entire declarations
and potentially entire nested rule blocks.
While much of the function syntax
could be re-purposed,
we would need an additional way
to manage property scoping –
clearly marking what rule blocks are internal,
and which should be part of the<span> </span>output.</p>
<pre><code>@mixin &lt;mixin-name&gt; [( &lt;parameter-list&gt; )]? {
  &lt;mixin-rules&gt;
}
</code></pre>
<p>Again, when there are multiple mixins
that use the same name,
the last mixin with that name
takes<span> </span>precedence.</p>
<h3 id="mixin-rules-and-output">Mixin rules and output <a href="#mixin-rules-and-output">¶</a></h3>
<p>The simplest approach
to nested rules and output
would be to treat the inside of a mixin definition
the same as any rule-block nested context.
Anything we can put inside a rule block
can be put inside a mixin,
and will be output where the mixin is called
(with any parameters being replaced first).
This will work for many simpler<span> </span>cases:</p>
<pre><code><span><span>@mixin</span> --center-content</span> <span>{</span></code></pre>
<pre><code><span>@mixin</span> <span>--clearfix </span><span>{</span></code></pre>
<p>This approach doesn’t allow
the mixin to contain any internal logic
scoped to the mixin itself.
Mixins should be able to
use internally scoped custom-properties,
and also optionally <em>output</em> custom properties
as part of the returned rule block.
As things stand,
this doesn’t seem relevant
to anything other than custom properties.
Built-in properties, selectors, and at-rules
are only useful for their<span> </span>output.</p>
<p>Given that this issue is specific to custom properties,
we could consider a flag such as <code>!private</code>.
That flag could be interesting
for custom properties in other contexts,
but I won’t follow that path unless there’s interest.
Alternatively,
we could explicitly mark
blocks of content
with either <code>@output</code> or <code>@private</code> at-rules.</p>
<h3 id="applying-mixins-the-new-apply-rule">Applying mixins: the (new) <code>@apply</code> rule <a href="#applying-mixins-the-new-apply-rule">¶</a></h3>
<p>In order to apply a mixin,
we use an <code>@apply</code> rule:</p>
<pre><code>@apply &lt;mixin-name&gt; [<span>(</span>&lt;argument-list&gt;<span>)</span>]?</code></pre>
<p>The <code>&lt;argument-list&gt;</code> syntax
should ideally match the function argument<span> </span>notation.</p>
<p>When the mixin is resolved,
the output of the mixin
is inserted where the apply rule was<span> </span>called:</p>
<pre><code></code></pre>
<p>There is an additional question
about how to handle mixin output
at the top level of the document
(not nested inside a<span> </span>selector):</p>
<pre><code><span><span>@apply</span> --center-content<span>;</span></span></code></pre>
<p>As long as there is a selector wrapping the output,
this should not be an issue.
Even if that selector is simply
the parent reference <code>&amp;</code>,
that has a well-defined behavior
at the top level of documents –
referring to the current <code>:scope</code>.
However, if the result is bare declarations
without any selector,
they should be discarded and<span> </span>ignored.</p>
<p>Another example,
from a Sass mixin I’ve used on<span> </span>occasion:</p>
<pre><code><span><span>@mixin</span> <span>--gradient-text</span><span>(</span></span> <span>{</span></code></pre>
<!--
.##..........###....##....##.########.########...######.
.##.........##.##....##..##..##.......##.....##.##....##
.##........##...##....####...##.......##.....##.##......
.##.......##.....##....##....######...########...######.
.##.......#########....##....##.......##...##.........##
.##.......##.....##....##....##.......##....##..##....##
.########.##.....##....##....########.##.....##..######.
-->
<h2 id="layers-of-complexity">Layers of complexity <a href="#layers-of-complexity">¶</a></h2>
<p>The popular Sass functions and mixins
demonstrate a range of different input needs,
from relatively static shorthands,
to fully imperative control<span> </span>structures.</p>
<h3 id="simple-shorthands">Simple shorthands <a href="#simple-shorthands">¶</a></h3>
<p>A <code>clearfix</code> mixin
often has no exposed ‘parameters’,
and no internal logic.
When the mixin is invoked,
it will output
the same code every time.
This is useful for maintaining
<span>DRY</span> code (Don’t Repeat<span> </span>Yourself),</p>
<p>Static mixins like this
end up very similar to
‘utility classes’ such as <code>.clearfix</code>.
However, mixins still have the advantage
that they can be applied in <span>CSS</span>,
rather than <span>HTML</span>.
The need for <span>CSS</span> control
comes into focus when combined
with <code>@media</code>/<code>@container</code> and other conditional logic.
There is currently no way in <span>CSS</span>
to write this code without
defining all the custom properties<span> </span>twice:</p>
<pre><code><span>.dark-mode</span> <span>{</span></code></pre>
<p>Most of the existing proposals around this use-case
would combine conditional logic
with selector logic,
so that both can be defined at once.
In Sass, we might fix this instead
by providing a <code>dark-mode</code> mixin
that can be used multiple times
to output the same declarations
with only minimal<span> </span>repetition:</p>
<pre><code><span>@mixin</span> <span>dark-mode </span><span>{</span></code></pre>
<p>Using Container Style Queries
might also be an option here.
They can be somewhat <em>mixin-like</em>,
but come with all the limitations
of container queries.
If we set a custom property <code>--mode</code>
on the root <code>html</code> element,
we have to assign properties on a different element
than we<span> </span>query:</p>
<pre><code><span>.dark-mode</span> <span>{</span></code></pre>
<p>That can cause several<span> </span>problems:</p>
<ul>
<li>There are optimizations and features specific to the root,
that can’t be replicated on other<span> </span>elements.</li>
<li>In other component contexts,
it’s likely to require extra<span> </span>markup.</li>
</ul>
<p>While no-parameter mixins like these
are somewhat common,
it’s much less common to have a
function without parameters,
since a simple value
can be captured in a variable
or custom property<span> </span>instead.</p>
<h3 id="built-in-conditions">Built-in conditions <a href="#built-in-conditions">¶</a></h3>
<p>It can also be useful to provide mixins
that have no author-facing parameters,
but still contain internal logic and conditional statements –
using <code>@supports</code>, <code>@media</code>, or <code>@container</code>:</p>
<pre><code><span>@mixin</span> <span>gradient-text </span><span>{</span></code></pre>
<p>A mixin like this might even
reference external values
by relying on custom properties
without accepting explicit override<span> </span>parameters:</p>
<pre><code><span>@mixin</span> <span>gradient-text </span><span>{</span></code></pre>
<h3 id="accepting-parameters">Accepting parameters <a href="#accepting-parameters">¶</a></h3>
<p>The most common reason
to use a function or mixin
is the ability to define parameters
that alter the output
based on different input.
For example, a
<code>darken()</code> function
would accept two parameters:
a color,
and an amount to darken that<span> </span>color.</p>
<p>In many cases (like <code>darken()</code>)
the internal function logic
can be represented by an inline calculation
using existing <span>CSS</span> features.
In those situations,
a custom function could still provide
more concise and easy-to-use shorthand
around a more complex <code>calc()</code>
or relative color<span> </span>adjustment.</p>
<h3 id="parameter-conditions">Parameter conditions <a href="#parameter-conditions">¶</a></h3>
<p>Once we allow both parameters
and conditional logic,
the next step would be to allow
parameters to be used in the conditions themselves.
For<span> </span>example:</p>
<pre><code><span><span>@mixin</span> <span>button</span><span>(</span><span>--style</span><span>:</span> outline<span>,</span> <span>--shape</span><span>:</span> pill<span>)</span></span> <span>{</span></code></pre>
<h3 id="imperative-control-flow">Imperative control flow <a href="#imperative-control-flow">¶</a></h3>
<p>Some use-cases require
more complex ‘flow control’
such as loops.
For example,
a combination of mixins might generate
a full color-palette
based on a single origin color.
In Sass,
it might looks something like<span> </span>this:</p>
<pre><code><span>@use</span> <span>&#39;sass:color&#39;</span><span>;</span></code></pre>
<p>The resulting output <span>CSS</span> would<span> </span>be:</p>
<pre><code><span>html</span> <span>{</span></code></pre>
<p>I think it would be reasonable
to draw a boundary here,
since <span>CSS</span> is a declarative language.
Adding imperative flows
would likely cause confusion around the execution<span> </span>model.</p>
<!--
.########..########.########....###....####.##........######.
.##.....##.##..........##......##.##....##..##.......##....##
.##.....##.##..........##.....##...##...##..##.......##......
.##.....##.######......##....##.....##..##..##........######.
.##.....##.##..........##....#########..##..##.............##
.##.....##.##..........##....##.....##..##..##.......##....##
.########..########....##....##.....##.####.########..######.
-->
<h2 id="detailed-discussion-and-open-questions">Detailed discussion and open questions <a href="#detailed-discussion-and-open-questions">¶</a></h2>
<h3 id="other-result-syntaxes-for-functions">Other result syntaxes for functions <a href="#other-result-syntaxes-for-functions">¶</a></h3>
<p>Both Lea and I have noted that
it would be useful
if authors could rely on cascade
‘order of appearance’
to provide ‘fallback’ return values.
Sadly, however,
that sort of parse-time fallback
is not possible with dynamic
computed-value-time features
like custom properties or<span> </span>functions.</p>
<p>I initially proposed an at-rule syntax (<code>@return</code>),
arguing that:</p>
<ul>
<li>It helps distinguish
the final returned value from any internal logic
like custom properties and nested<span> </span>rules</li>
<li>Result is not a property,
but looks a lot like<span> </span>one</li>
</ul>
<p>However, <code>result</code>
does act like a property in many ways,
and would help to re-enforce
our familiarity with declarative execution.
While many imperative languages
allow an ‘eager’ <em>first-takes-precedence</em> function return,
<span>CSS</span> and other declarative languages
generally uses a <em>last-takes-precedence</em> approach.
For the same reason,
we should avoid active words like <code>return</code>
that suggest the evaluation is linear
and can be cut<span> </span>short.</p>
<p>François Remy
has proposed setting a custom property
with the same name as the function,
and that property is treated as the resulting value.
Lea Verou suggested making the property name
customizable in the<span> </span>prelude.</p>
<p>I prefer a syntax that is more consistent and reliable.
I don’t see any utility that comes from
allowing this functionality to be renamed in each function,
or requiring that name to be determined by authors,
or putting it in the author’s custom-ident name space.
Those all seem to me like ways of inviting typos and confusion,
without any clear<span> </span>gain.</p>
<p>Matching the function name
seems to me extra fragile –
as you could never rename one
without also updating the other.
Still,
either approach could work,
and provide the same basic behavior.
We can continue to bike-shed the<span> </span>details.</p>
<h3 id="passing-nested-content-to-mixins">Passing nested content to mixins <a href="#passing-nested-content-to-mixins">¶</a></h3>
<p>Another common feature of Sass mixins
is the ability to pass nested content blocks
into a mixin,
and have the mixin place that content
in a specific context.
This seems like a feature
that could be supported in <span>CSS</span> as well,
but would require another mixin-specific at-rule
(or similar placeholder).
I’ll call it <code>@nested</code> for now:</p>
<pre><code><span><span>@mixin</span> --media-medium</span> <span>{</span></code></pre>
<p>The expected behavior would be
the same as<span> </span>writing:</p>
<pre><code><span>.grid</span> <span>{</span></code></pre>
<p>This seems like something that could be added later,
if<span> </span>necessary.</p>
<h3 id="invalid-function-fallbacks">Invalid function fallbacks <a href="#invalid-function-fallbacks">¶</a></h3>
<p>Sadly,
last-takes-precedence <code>@return</code> behavior
doesn’t provide the same benefit here
that it has in the cascade –
where invalid declarations
can be discarded at parse time,
falling back on previously declared values.
In order to achieve that,
we would need to limit functions
so that they are the only value in a property.
I don’t think that tradeoff makes sense
for the use-cases I’ve<span> </span>seen.</p>
<p>I’m also not sure it makes sense
to provide function-defined fallback values
to return when arguments provided have invalid syntax.
Ideally, function fallbacks
would be modeled after variable fallbacks –
established where the function is called,
rather than where it is defined.
It’s hard to see where this would fit
in the proposed<span> </span>syntax.</p>
<p>One option would be a <code>var()</code>-like
wrapper function:</p>
<pre><code><span>button</span> <span>{</span></code></pre>
<p>We could even use the existing <code>var()</code>,
but that would result in functions and custom properties
sharing a single namespace,
which might not be ideal.
Maybe the proposed function for
<code>first-supported()</code> would also be an option
that has broader use?
This likely needs more<span> </span>bike-shedding.</p>
<h3 id="using-parameters-in-conditional-rules">Using parameters in conditional rules <a href="#using-parameters-in-conditional-rules">¶</a></h3>
<p>Above,
I used an example with conditional output
using media queries inside the function.
Authors may reasonably wish to take this farther
and use parameters to define the media queries<span> </span>themselves:</p>
<pre><code><span><span>@function</span> <span>--media</span><span>(</span></span> <span>{</span></code></pre>
<p>This is a very common use of pre-processor mixins,
and a common use-case for the proposed inline <code>if()</code>
and <code>media()</code> functions as<span> </span>well.</p>
<p>As I understand it,
that will not be possible as written above,
for the same reasons <code>var()</code> is not currently allowed
in media-query conditions.
However,
the issues are specific to cascaded values
that need to be resolved at computed value time.
Passing static arguments from a parameter
should not pose the same<span> </span>problem.</p>
<p>If we had a new way of accessing
values passed in –
I’ll use <code>arg()</code> for the sake of argument –
simple value substitution should be<span> </span>possible:</p>
<pre><code><span><span>@function</span> <span>--media</span><span>(</span></span> <span>{</span></code></pre>
<p>In the above example,
the <code>padding</code> declaration
would be valid
since a static value
can be passed along to the media query <code>arg()</code> –
but the <code>margin</code> declaration would fail
since it supplies a custom property
to a media query<span> </span>condition.</p>
<p>It’s not clear to me
if parameters used this way
would need to be explicitly marked in advance
for any reason?
As proposed here,
it would be up to function authors
to document and communicate
which parameters can accept cascading variables,
and which can<span> </span>not.</p>
<h3 id="argument-conditions-and-loops">Argument conditions and loops <a href="#argument-conditions-and-loops">¶</a></h3>
<p>With both mixins and functions
it can be useful to have conditions
based on the arguments passed in.
For example, we might want to pass in
one of several established keywords,
and return a different value
depending which keyword is<span> </span>used:</p>
<pre><code><span><span>@function</span> <span>--link</span><span>(</span></span></code></pre>
<p>It’s not clear to me
if the proposed <code>@when</code>/<code>@else</code> features
can be adapted to this use-case,
or if it would need to be
a distinct set of similar flow<span> </span>controls.</p>
<p>Similarly,
as we saw in the tint-shade example earlier,
it can be useful to loop over
a set number of repetitions (for loop)
or a set list of items (each<span> </span>loop).</p>
<p>While these would be helpful features for authors,
they are not required for
(or dependent on)
an initial implementation of mixins or functions.
They feel like distinct features
that would go well<span> </span>together.</p>
<h3 id="can-we-allow-the-calc-sum-syntax">Can we allow the <code>&lt;calc-sum&gt;</code> syntax? <a href="#can-we-allow-the-calc-sum-syntax">¶</a></h3>
<p>This question was raised
by <a href="https://github.com/w3c/csswg-drafts/issues/7490#issuecomment-1256880496">Brandon McConnell</a>
in the ‘Declarative Custom Functions’ issue
(see point 5, even though it’s not specific to recursion).
The goal is to provide custom functions
that take raw calc expressions,
without being explicitly wrapped in a nested
<code>calc()</code> function,
similar to the way other math functions<span> </span>work:</p>
<pre><code><span>.item</span> <span>{</span></code></pre>
<p>On the one hand,
custom property substitution
makes it trivial to capture expressions,
and later call them inside a <code>calc()</code> function.
This already<span> </span>works:</p>
<pre><code><span>html</span> <span>{</span></code></pre>
<p>To take it farther,
we would need to expose the <code>&lt;calc-sum&gt;</code>
grammar as a valid syntax
for authors to<span> </span>use.</p>
<p>It might also be worth considering
what other syntax/types would be useful to expose –
either for parameters specifically,
or for property registration more generally.
It seems ideal to me
if those lists can be kept in<span> </span>alignment.</p>
<h3 id="what-about-extend">What about <code>@extend</code>? <a href="#what-about-extend">¶</a></h3>
<p>In Sass,
mixins without parameters also
overlap with the <code>@extend</code> feature,
which is used to combine related classes –
one as an ‘extension’ of the other.
In most cases,
that has the same intended result
as a<span> </span>no-parameter-mixin:</p>
<pre><code></code></pre>
<p>The difference is that a class definition
can be compiled from multiple rule blocks
in different style sheets,
while a mixin generally has one centralized definition.
This is part of the reason
extensions have become less common in Sass –
it can be difficult to reason about their impact.
For now,
I think mixins would provide the similar functionality
without the same<span> </span>complexity.</p>
<p>If we are interested in exploring <code>@extend</code> at some point,
Tab has already written an
<a href="http://tabatkins.github.io/specs/css-extend-rule/">unofficial draft specification</a>
that we can build<span> </span>from.</p>
<h3 id="can-functions-be-chained-or-call-themselves">Can functions be chained, or call themselves? <a href="#can-functions-be-chained-or-call-themselves">¶</a></h3>
<p>I would expect that it should be possible
to chain function/mixin calls together.
A theme-generating mixin
should be able to reference
a single-color generating mixin or function<span> </span>internally.</p>
<p>It’s less clear to me if recursive function calls
are possible or necessary.
There are likely use-cases for recursion
as a form of looping,
but I’m not sure how central they are.
This doesn’t seem like a feature requirement in level<span> </span>1.</p>
<h3 id="keyframe-based-mixins-for-interpolated-values">Keyframe-based mixins for interpolated values? <a href="#keyframe-based-mixins-for-interpolated-values">¶</a></h3>
<p>There has been a lot of recent discussion around
<a href="https://github.com/w3c/csswg-drafts/issues/6245#issuecomment-1715416464">interpolating values between breakpoints</a>
for e.g. responsive typography.
Conceptually, animation keyframes work well
for defining the steps involved –
but in this case the result is not technically animated,
and interpolated values
should ideally not be removed
to the animation<span> </span>origin.</p>
<p>To get around that,
the most recent proposals
involves a new property
(tentatively <code>interpolate</code>)
that would accept a keyframes name
and timeline,
then ‘expand in place’
to represent the declarations
in the referenced <code>@keyframes</code> rule.</p>
<pre><code><span><span>@keyframes</span> typography</span> <span>{</span></code></pre>
<p>Alan Stearns has pointed out
in conversations
that this is a very mixin-like behavior,
and suggested treating keyframes
as an existing form of mixin,
rather than a new property.
Given the same keyframes above,
we could consider a syntax<span> </span>like:</p>
<pre><code><span>h2</span> <span>{</span></code></pre>
<p>If that clutters the mixin namespace,
another approach might be
requiring dashed-ident mixin names,
and providing some built-in mixins such<span> </span>as:</p>
<pre><code><span>h2</span> <span>{</span></code></pre>
<!--
.########..########..####..#######..########........###....########..########
.##.....##.##.....##..##..##.....##.##.....##......##.##...##.....##....##...
.##.....##.##.....##..##..##.....##.##.....##.....##...##..##.....##....##...
.########..########...##..##.....##.########.....##.....##.########.....##...
.##........##...##....##..##.....##.##...##......#########.##...##......##...
.##........##....##...##..##.....##.##....##.....##.....##.##....##.....##...
.##........##.....##.####..#######..##.....##....##.....##.##.....##....##...
-->
<h2 id="prior-art">Prior art <a href="#prior-art">¶</a></h2>
<h3 id="the-apply-rule-abandoned">The <code>@apply</code> Rule (abandoned) <a href="#the-apply-rule-abandoned">¶</a></h3>
<details data-alert="note" open="">
            <summary>Links:</summary>
            
          </details>
<p>At one point,
there was a plan
for custom properties to act as a form of mixin,
using the <code>@apply</code> rule.
That proposal was abandoned
as the wrong approach
for several related<span> </span>reasons:</p>
<ul>
<li>Custom properties are value-level syntax,
while mixins are<span> </span>declaration-level</li>
<li>It doesn’t make sense for mixin definitions
to be passed around in the<span> </span>cascade</li>
</ul>
<p>These are not difficult issues to avoid.
I’m working from the premise<span> </span>that:</p>
<ul>
<li>Both function and mixins
should be <em>defined</em> globally,
and not rely on any element-aware
aspects of the<span> </span>cascade.</li>
<li>Similar to e.g. <code>@keyframes</code>,
function and mixin definitions
would still resolve name conflicts
using global cascade features
like <em>layers</em> and <em>order of<span> </span>appearance</em>.</li>
<li>Functions are applied in the <em>value</em> space,
while mixins are applied in the <em>declaration</em><span> </span>space.</li>
</ul>
<h3 id="container-style-queries-partially-implemented">Container Style Queries (partially implemented) <a href="#container-style-queries-partially-implemented">¶</a></h3>
<details data-alert="note" open="">
            <summary>Links:</summary>
            
          </details>
<p>The <code>style()</code> feature of <code>@container</code>
can sometimes be used to approximate mixin behavior.
There are several recent
<a href="https://front-end.social/@chriscoyier/110821892737745155">posts</a>
and <a href="https://chriskirknielsen.com/blog/future-themes-with-container-style-queries/">articles</a>
written about that approach.
However, style queries
share the limitation of other container queries:
<em>we can’t style the container being<span> </span>queried</em>.</p>
<p>Container queries are designed
as a <em>conditional selector</em> mechanism,
for responding to changes in context.
The ancestor/descendant limitation
is required for browsers to separate
selector-matching from value-resolution
on a given<span> </span>element.</p>
<p>However, <em>mixins do not alter selection</em>,
they only ‘bundle’ existing <span>CSS</span> rules and declarations for re-use.
Ideally, these two features should work well together,
so that contextual conditions
can change the arguments passed to a given<span> </span>mixin.</p>
<h3 id="custom-properties-implemented">Custom Properties (implemented) <a href="#custom-properties-implemented">¶</a></h3>
<details data-alert="note" open="">
            <summary>Links:</summary>
            
          </details>
<p>We can also use custom properties to
approximate some basic mixins and functions.
While these tricks can be useful,
they involve significant complexity,
caveats, and<span> </span>limitations:</p>
<ul>
<li>Each ‘function/mixin’ and ‘argument’ is a custom property,
which can only have a single resolved value per<span> </span>element</li>
<li>Arguments are substituted in the function/mixin
<em>before the computed value inherits</em>,
so the logic has to be defined
on every element that should re-calculate a<span> </span>result</li>
</ul>
<h3 id="mixins-and-functions-in-pre-processors">Mixins and functions in pre-processors <a href="#mixins-and-functions-in-pre-processors">¶</a></h3>
<details data-alert="note" open="">
            <summary>Links:</summary>
            
          </details>
<p>In addition to parameters,
Sass mixins can accept <em>content blocks</em>.
An example <a href="https://sass-lang.com/documentation/at-rules/mixin/#content-blocks">from the documentation</a>:</p>
<pre><code><span>@mixin</span> <span>hover </span><span>{</span></code></pre>
<p>That might be a useful feature
for <span>CSS</span> mixins as well.
It would be required for the use-case
of creating named conditions.
That use-case may also be solved by the proposed
<code>@when</code> rule and ‘custom media queries’<span> </span>feature.</p>
<p>Sass provides some built-in core functions,
but (so far) does not provide core mixins.
Likely for that reason,
the <span>HTTP</span> Archive report lists
several commonly-used built-in functions
(<code>if()</code>, and <code>darken()</code>),
but only the most commonly used
custom mixin name (<code>clearfix</code>).</p>
<h3 id="existing-proposal-for-custom-functions">Existing Proposal for Custom Functions <a href="#existing-proposal-for-custom-functions">¶</a></h3>
<p>In July of 2022,
Johannes Odland proposed
‘<a href="https://github.com/w3c/csswg-drafts/issues/7490">Declarative custom functions</a>’
in the <span>CSS</span> Working Group issue tracker.
Since then,
the proposal has gone through
several revisions and<span> </span>updates.</p>
<p>The current (2023-08-08)
proposal in that thread
suggests<span> </span>that:</p>
<ul>
<li>Functions would be resolved
at the same time as variable<span> </span>substitution</li>
<li>Function parameters defined with a <span>CSSOM</span> ‘syntax’
can be validated at parse time
(like <code>@property</code>-registered variables)</li>
<li>This would be a declarative version
of the more full-featured Houdini <span>API</span><span> </span>feature</li>
</ul>
<p>There are also several example use-cases,
such as this function
for fluid<span> </span>typography:</p>
<pre><code><span><span>@custom-function</span> <span>--fluid-ratio</span><span>(</span></span> <span>{</span></code></pre>
<details data-alert="warn">
            <summary>Unit division in math functions:</summary>
            <p>In addition to the new syntax proposed here,
browsers would also need to implement
<a href="https://drafts.csswg.org/css-values/#calc-type-checking">unit-division in math functions</a>
for this use-case to work as<span> </span>shown.</p>
          </details>
<p>Or a function for
generating checkerboard<span> </span>background-images:</p>
<pre><code><span><span>@custom-function</span> <span>--checkerboard</span><span>(</span>--size<span>)</span></span> <span>{</span></code></pre>
<p>For these use-case,
custom functions could be a simple wrapper
for inserting parameters into
existing functions like <code>calc()</code>.
Tab Atkins has suggested a math-only version of this
would be simplest to implement.
While that might be a useful first-step,
it quickly falls short of the use-cases I’ve seen.
I would prefer to start with a more fully-featured approach,
and work backwards to an attainable level 1 implementation
if<span> </span>needed.</p>
<p>In addition to some bike-shedding of the syntax,
there are several more open questions in the<span> </span>thread:</p>
<ul>
<li>Can authors provide a fallback output
for invalid<span> </span>arguments?</li>
<li>Would it be helpful to include default parameter values
in the function<span> </span>definition?</li>
<li>Can function authors define internally-scoped custom<span> </span>properties?</li>
<li>Can authors use conditional at-rules
inside the function<span> </span>logic?</li>
<li>Can functions expose a parameter
that accepts bare calculations (without <code>calc()</code> syntax)
similar to <code>clamp()</code> etc?</li>
<li>Can functions perform recursive function<span> </span>calls?</li>
<li>Can functions be called with named
(rather than positional)<span> </span>arguments?</li>
</ul>
<p>I hope to expand on this proposal,
and explore some of those questions along the<span> </span>way.</p>
<!--
.##.....##.########.########....###...
.###...###.##..........##......##.##..
.####.####.##..........##.....##...##.
.##.###.##.######......##....##.....##
.##.....##.##..........##....#########
.##.....##.##..........##....##.....##
.##.....##.########....##....##.....##
-->
<h2 id="acknowledgments">Acknowledgments <a href="#acknowledgments">¶</a></h2>
<p>This proposal is based on
an <a href="https://github.com/w3c/csswg-drafts/issues/7490">existing discussion</a>
with input<span> </span>from:</p>
<ul>
<li>Johannes Odland</li>
<li>David Baron</li>
<li>Brian Kardell</li>
<li>Tab Atkins-Bittner</li>
<li>@jimmyfrasche</li>
<li>Brandon McConnell</li>
<li>Lea Verou</li>
</ul>
<p>I’ve also incorporated feedback
along the way<span> </span>from:</p>
<ul>
<li>Nicole Sullivan</li>
<li>Anders Hartvoll Ruud</li>
<li>Rune Lillesveen</li>
<li>Alan Stearns</li>
<li>Yehonatan Daniv</li>
<li>Emilio Cobos Álvarez</li>
<li>François Remy</li>
<li>Steinar H Gunderson</li>
<li>Matt Giuca</li>
</ul>
<h2 id="todo">Todo <a href="#todo">¶</a></h2>
<ul>
<li><a href="https://github.com/w3c/csswg-drafts/issues/9350#issuecomment-1717661703">Defer mixin-nested selectors</a>
as <a href="https://github.com/w3c/csswg-drafts/issues/9350#issuecomment-1723337386">potentially<span> </span>expensive</a></li>
<li><a href="https://github.com/w3c/csswg-drafts/issues/9350#issuecomment-1719603753">Clarify recursion limitations</a></li>
<li><a href="https://github.com/w3c/csswg-drafts/issues/9350#issuecomment-1720836487">Clarify static vs dynamic<span> </span>args</a></li>
</ul>








  </div></div>
  </body>
</html>
