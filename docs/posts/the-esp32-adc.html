<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cceckman.com/writing/esp-adc/">Original</a>
    <h1>The ESP32 ADC</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>A while back, I spotted the XIAO line of ESP32 microcontrollers.
For $5, you get a microcontroller, WiFi and/or Bluetooth, a decent number of GPIOs, <em>and</em> LiPo battery management with USB-C charging.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>
And the microcontroller is an ESP32, which has first-party <a href="https://docs.espressif.com/projects/rust/" rel="external" target="_blank">support for Rust</a> from Espressif.
That sounded pretty good to me– I picked up a few of the ESP32-C3 <a href="https://www.seeedstudio.com/Seeed-XIAO-ESP32C3-p-5431.html" rel="external" target="_blank">variant</a>, a small LiPo battery, and some connecting wires.</p>
<h2 id="watching-the-battery">Watching the battery</h2>
<p>While a given battery has a “nominal” voltage, e.g. 3.7V for a LiPo, it doesn’t deliver exactly that voltage.
The effective voltage varies (lowers) as the battery discharges.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
For the device(s) I have in mind to build, I want to keep an eye on the battery state from software, so I know when they approach empty and need a recharge.</p>
<p>One thing missing from the XIAO ESP32-C3 board is <strong>battery monitoring</strong>. There’s not anything built-in to read out the charge level, or voltage.</p>
<p>But! The Seeed Studio wiki has <a href="https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/#check-the-battery-voltage" rel="external" target="_blank">a section on battery usage and monitoring</a>,
based on a user’s <a href="https://forum.seeedstudio.com/t/battery-voltage-monitor-and-ad-conversion-for-xiao-esp32c/267535" rel="external" target="_blank">forum post</a>.
With a couple external resistors, we can allocate an analog-to-digital converter (ADC) pin to read out the battery voltage.</p>
<p>Or can we? The guide uses the Arduino environment, but there’s some gaps we need to fill when coming from Rust. Let’s go!</p>
<h2 id="esp32-in-rust">ESP32 in Rust</h2>
<p>First, we need to get set up to run code on the ESP32– Rust code specifically, as is my habit these days.
<a href="https://docs.espressif.com/projects/rust/book/preface.html" rel="external" target="_blank">This tutorial</a> covers getting set up with the <code>std</code> environment, which runs FreeRTOS under the hood.
Once oriented with that, I went through <a href="https://docs.espressif.com/projects/rust/no_std-training/01_intro.html" rel="external" target="_blank">this tutorial</a> to understand the <code>no_std</code> environment better.</p>
<p>I wound up using the <code>no_std</code> environment and the <code>embassy</code> runtime, with tools (<code>espflash</code>) installed as described in those tutorials.</p>
<details><summary><code>Cargo.toml</code></summary>
<div><pre tabindex="0"><code data-lang="toml"><span><span><span>[</span><span>package</span><span>]</span>
</span></span><span><span><span>name</span> <span>=</span> <span>&#34;esp-adc-examples&#34;</span>
</span></span><span><span><span>version</span> <span>=</span> <span>&#34;0.1.0&#34;</span>
</span></span><span><span><span>edition</span> <span>=</span> <span>&#34;2024&#34;</span>
</span></span><span><span>
</span></span><span><span><span>[</span><span>dependencies</span><span>]</span>
</span></span><span><span><span>esp-backtrace</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;0.18.1&#34;</span><span>,</span> <span>features</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>&#34;esp32c3&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;panic-handler&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;println&#34;</span><span>,</span>
</span></span><span><span><span>]}</span>
</span></span><span><span><span>esp-bootloader-esp-idf</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;0.4.0&#34;</span><span>,</span> <span>features</span> <span>=</span> <span>[</span><span>&#34;esp32c3&#34;</span><span>]}</span>
</span></span><span><span><span>esp-hal</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;1&#34;</span><span>,</span> <span>features</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>&#34;esp32c3&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;unstable&#34;</span><span>,</span>
</span></span><span><span><span>]</span> <span>}</span>
</span></span><span><span><span>esp-println</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;0.16.1&#34;</span><span>,</span> <span>features</span> <span>=</span> <span>[</span><span>&#34;esp32c3&#34;</span><span>,</span> <span>&#34;log-04&#34;</span><span>]</span> <span>}</span>
</span></span><span><span><span>esp-rtos</span> <span>=</span> <span>{</span><span>version</span> <span>=</span> <span>&#34;0.2.0&#34;</span><span>,</span> <span>features</span><span>=[</span><span>&#34;esp32c3&#34;</span><span>,</span> <span>&#34;embassy&#34;</span><span>]</span> <span>}</span>
</span></span><span><span><span>embassy-executor</span> <span>=</span> <span>{</span><span>version</span><span>=</span><span>&#34;0.9.1&#34;</span><span>}</span>
</span></span><span><span><span>embassy-time</span> <span>=</span> <span>{</span><span>version</span><span>=</span><span>&#34;0.5.0&#34;</span><span>}</span>
</span></span></code></pre></div></details>
<details><summary><code>main.rs</code></summary>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>#![no_std]</span><span>
</span></span></span><span><span><span></span><span>#![no_main]</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>embassy_time</span>::<span>Duration</span><span>;</span><span>
</span></span></span><span><span><span></span><span>// Use the panic-handler from esp_backtrace:
</span></span></span><span><span><span></span><span>use</span><span> </span><span>esp_backtrace</span><span> </span><span>as</span><span> </span><span>_</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>embassy_executor</span>::<span>Spawner</span><span>;</span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>esp_println</span>::<span>println</span><span>;</span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>esp_hal</span>::<span>analog</span>::<span>adc</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>esp_bootloader_esp_idf</span>::<span>esp_app_desc!</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[esp_rtos::main]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>main</span><span>(</span><span>_spawner</span>: <span>Spawner</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>esp_println</span>::<span>logger</span>::<span>init_logger_from_env</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>peripherals</span><span> </span><span>=</span><span> </span><span>esp_hal</span>::<span>init</span><span>(</span><span>esp_hal</span>::<span>Config</span>::<span>default</span><span>());</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>use</span><span> </span><span>esp_hal</span>::<span>timer</span>::<span>timg</span>::<span>TimerGroup</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>timg0</span><span> </span><span>=</span><span> </span><span>TimerGroup</span>::<span>new</span><span>(</span><span>peripherals</span><span>.</span><span>TIMG0</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>use</span><span> </span><span>esp_hal</span>::<span>interrupt</span>::<span>software</span>::<span>SoftwareInterruptControl</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>software_interrupt</span><span> </span><span>=</span><span> </span><span>SoftwareInterruptControl</span>::<span>new</span><span>(</span><span>peripherals</span><span>.</span><span>SW_INTERRUPT</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>esp_rtos</span>::<span>start</span><span>(</span><span>timg0</span><span>.</span><span>timer0</span><span>,</span><span> </span><span>software_interrupt</span><span>.</span><span>software_interrupt0</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// ADC setup code goes here...
</span></span></span><span><span><span></span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// ADC reading code goes here...
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>println!</span><span>(</span><span>&#34;ADC reading: </span><span>{value}</span><span>&#34;</span><span>,);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>embassy_time</span>::<span>Timer</span>::<span>after</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>2</span><span>)).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div></details>
<details><summary><code>.cargo/config.toml</code></summary>
<div><pre tabindex="0"><code data-lang="toml"><span><span>
</span></span><span><span><span>[</span><span>target</span><span>.</span><span>riscv32imc-unknown-none-elf</span><span>]</span>
</span></span><span><span><span>runner</span> <span>=</span> <span>&#34;espflash flash --monitor&#34;</span>
</span></span><span><span>
</span></span><span><span><span>[</span><span>build</span><span>]</span>
</span></span><span><span><span>rustflags</span> <span>=</span> <span>[</span>
</span></span><span><span>  <span>&#34;-C&#34;</span><span>,</span> <span>&#34;link-arg=-Tlinkall.x&#34;</span><span>,</span>
</span></span><span><span>  <span># Required to obtain backtraces (e.g. when using the &#34;esp-backtrace&#34; crate.)</span>
</span></span><span><span>  <span># NOTE: May negatively impact performance of produced code</span>
</span></span><span><span>  <span>&#34;-C&#34;</span><span>,</span> <span>&#34;force-frame-pointers&#34;</span><span>,</span>
</span></span><span><span><span>]</span>
</span></span><span><span>
</span></span><span><span><span>target</span> <span>=</span> <span>&#34;riscv32imc-unknown-none-elf&#34;</span>
</span></span><span><span>
</span></span><span><span><span>[</span><span>unstable</span><span>]</span>
</span></span><span><span><span>build-std</span> <span>=</span> <span>[</span><span>&#34;core&#34;</span><span>]</span>
</span></span><span><span>
</span></span><span><span><span># Enable usable backtraces even in release builds.</span>
</span></span><span><span><span>[</span><span>profile</span><span>.</span><span>release</span><span>]</span>
</span></span><span><span><span>debug</span> <span>=</span> <span>true</span>
</span></span></code></pre></div></details>
<h2 id="hardware-setup">Hardware setup</h2>
<p>The wiki page recommends
putting two resistors in series between the battery’s positive and negative terminals,
and connecting the node between the resistors to pin GPIO2 / A0.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>
The wiki page suggests 220kΩ resistors; I didn’t have those on hand, so I used 470kΩ instead
(more on this below).</p>

<p>Why do we have these resistors? A second-hand statement on the wiki page:</p>
<blockquote>
<p>The datasheet says nominally 2500mV full scale AD conversion…</p>
</blockquote>
<p>but I’ve measured this battery at over 4V when fully charged.
So: we need to cut the voltage down into a range the ADC can measure.</p>
<p>These resistors create a <em>voltage divider</em>.
Because the resistors form a path between the positive and negative terminals of the battery,
some current flows through them. By Ohm’s Law:</p>
$$\begin{aligned}
I &amp;= {V_{bat} \over {R_1 + R_2}} \\
  &amp;= {3.7\text{V} \over {470\text{kΩ} + 470\text{kΩ}}} \\
  &amp;= 3.94 \text{μA} \\
\end{aligned}$$<p>Across <em>each</em> resistor, there’s a voltage drop proportionate to resistance:</p>
$$\begin{aligned}
V_{R_2}  &amp;= I \times R_2 \\
        &amp;= 3.94 \text{μA} \times 470\text{kΩ} \\
        &amp;= 1.85 \text{V} \\
\end{aligned}$$<p>At a cost of 3.9μA of current, we’ve halved the voltage.
Note that while the current (\(I\)) depends on the particular values,
the <em>divisor</em> only depends on the fact that \(R_1 = R_2\).
That’s why it was fine for me to substitute bigger resistors: the voltage divider only cares that
the resistors are equal.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p>
<p>For a ~4V max battery, dividing by 2 that should put us well within the ADC’s range.
So, we should be fine to measure, right? Let’s try it out!</p>
<figure><a href="https://cursor.com/blog/test-setup.web"><img src="https://cursor.com/writing/esp-adc/test-setup.webp" alt="Photo: the schematic described above, laid out on a breadboard. Some of the wires are bent in awkward positions."/></a><figcaption>
      <p>Maybe I should stick with the diagrams.</p>
    </figcaption>
</figure>
<h2 id="attenuation">Attenuation</h2>
<p>I started with an examples based on <a href="https://jamesmcm.github.io/blog/beginner-rust-esp32-lcdsnake/" rel="external" target="_blank">this “snake” program</a>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>// ADC setup code:
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>config</span><span> </span><span>=</span><span> </span><span>adc</span>::<span>AdcConfig</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>pin</span><span> </span><span>=</span><span> </span><span>config</span><span>.</span><span>enable_pin</span><span>(</span><span>peripherals</span><span>.</span><span>GPIO2</span><span>,</span><span> </span><span>adc</span>::<span>Attenuation</span>::<span>_0dB</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>adc</span><span> </span><span>=</span><span> </span><span>adc</span>::<span>Adc</span>::<span>new</span><span>(</span><span>peripherals</span><span>.</span><span>ADC1</span><span>,</span><span> </span><span>config</span><span>).</span><span>into_async</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// ADC reading code:
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span><span>SAMPLES</span>: <span>usize</span> <span>=</span><span> </span><span>100</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>// ADC produces 12-bit values, we can store in a u16
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>samples</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>u16</span><span>;</span><span> </span><span>SAMPLES</span><span>];</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>v</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>samples</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>*</span><span>v</span><span> </span><span>=</span><span> </span><span>adc</span><span>.</span><span>read_oneshot</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>pin</span><span>).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>total</span>: <span>usize</span> <span>=</span><span> </span><span>samples</span><span>.</span><span>iter</span><span>().</span><span>map</span><span>(</span><span>|</span><span>v</span><span>|</span><span> </span><span>*</span><span>v</span><span> </span><span>as</span><span> </span><span>usize</span><span>).</span><span>sum</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>total</span><span> </span><span>/</span><span> </span><span>SAMPLES</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;ADC reading: </span><span>{value}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>embassy_time</span>::<span>Timer</span>::<span>after</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>2</span><span>)).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This <em>kinda</em> worked, but I was only getting a binary value: either 4095, or something much lower,
depending on whether I had connected the battery or grounded the pin.</p>
<p>I recognized the 4095 value as “off the charts high”. The ADC has 12 bits of resolution, and \(2^{12} - 1 = 4095\);
we’re saturating the ADC.</p>
<p>All this was running through the external voltage divider; it should be within the 2500mV range. Why was the ADC saturated?</p>
<p>After some flailing, I went back to <a href="https://documentation.espressif.com/esp32-c3_datasheet_en.pdf" rel="external" target="_blank">the datasheet</a>, where the 2500mV range was supposedly sourced from.
Section 5.5 “ADC characteristics” does indeed state a range of 0~2500… for ATTEN3. What’s that?</p>
<p>The ESP32 ADC has an internal <em>attenuator</em>, i.e. a configurable voltage divider–
like the one we made, but inside the chip, and configurable to different ratios.
The options are framed as decibel levels in the <a href="https://docs.espressif.com/projects/rust/esp-hal/1.0.0/esp32c3/esp_hal/analog/adc/enum.Attenuation.html" rel="external" target="_blank">esp_hal::analog::adc::Attenuation</a> type:<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></p>
<table>
  <thead>
      <tr>
          <th>Attentuation level</th>
          <th>Gain</th>
          <th>Multiplier</th>
          <th>Approximate max</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ATTEN0</td>
          <td>0dB</td>
          <td>1</td>
          <td>750mV</td>
      </tr>
      <tr>
          <td>ATTEN1</td>
          <td>-2.5dB</td>
          <td>0.562</td>
          <td>1050 mV</td>
      </tr>
      <tr>
          <td>ATTEN2</td>
          <td>-6dB</td>
          <td>0.251</td>
          <td>1300 mV</td>
      </tr>
      <tr>
          <td>ATTEN3</td>
          <td>-11 dB</td>
          <td>0.079</td>
          <td>2500 mV</td>
      </tr>
  </tbody>
</table>
<p>The wiki’s example (apparently) assumes the use of 11dB attenuation, giving the widest range.
That makes sense as a default for, say, the Arduino environment:
there are a lot of 5V signals, so a simple external divide-by-2 can make that range useful.</p>
<p>I’m not sure what typical levels the other attenuation levels are “good” for.
For instance, 3.3V divided-by-2 is still more than the ATTEN2 range.
If you know why these target ranges show up, drop me a line!</p>
<p>If we want to stick with the “even” voltage divider, we’ll want to use the maximum attenuation going forward:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>// ADC setup code:
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>config</span><span> </span><span>=</span><span> </span><span>adc</span>::<span>AdcConfig</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>pin</span><span> </span><span>=</span><span> </span><span>config</span><span>.</span><span>enable_pin</span><span>(</span><span>peripherals</span><span>.</span><span>GPIO2</span><span>,</span><span> </span><span>adc</span>::<span>Attenuation</span>::<span>_11dB</span><span>);</span><span> </span><span>// changed!
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>adc</span><span> </span><span>=</span><span> </span><span>adc</span>::<span>Adc</span>::<span>new</span><span>(</span><span>peripherals</span><span>.</span><span>ADC1</span><span>,</span><span> </span><span>config</span><span>).</span><span>into_async</span><span>();</span><span>
</span></span></span></code></pre></div><p>But that didn’t cut it: I still got a saturated value of 4095.
To understand why, we need to look beyond the electrical <em>model</em>
to see what the ADC is actually measuring, and how to calibrate our measurements to reality.</p>
<h2 id="external-calibration">External calibration</h2>
<p>Let’s start by reviewing the external voltage divider. Is it actually “divide by 2”?</p>
$$V_{adc} = V_{bat} \times {R_2 \over {R_1 + R_2}}$$<p>
In the case of \(R_1 = R_2\), that’s the same as dividing by 2.</p>
<p>We could create a different ratio by having different resistances on either side of the ADC.
For instance, if we wanted to divide by 4, we could chain three resistors for \(R_1\) and use just one for \(R_2\).
That would give us a ~10V ADC range; we could measure the charge of a 9V battery!</p>
<p>Even if we’re using “the same resistor value” for \(R_1\) and \(R_2\),
the actual resistors on the breadboard are slightly different.
The resistors are only <em>nominally</em> 470kΩ; the ones I’m using have tolerances ±5%, so 447kΩ-494kΩ.<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>
As a result, the external voltage divider divides by <em>about</em> 2, but it will vary depending on the <em>specific parts</em> we have on hand.</p>
<p>With multimeter in hand, I took some measurements:</p>
$$\begin{aligned}
R_1 &amp;= 477.2 \text{kΩ} \\
R_2 &amp;= 475.5 \text{kΩ}
\end{aligned}$$<p>Both are within 2% of their nominal resistances.
They’re both skewed in the same direction, which is good for calibration:
as we approach \(R_1 = R_2\), we get close to a divisor of 2, regardless of the absolute values.<sup id="fnref1:4"><a href="#fn:4" role="doc-noteref">4</a></sup>
So with these components, the actual ratio we’re getting is:</p>
$$ {R_2 \over {R_1 + R_2}} = {475.5 \text{kΩ} \over {475.5 \text{kΩ}+ 477.2 \text{kΩ}}} = 0.499$$<p>&lt;1% off the expected value? That’s fine…for the <em>external</em> voltage divider.</p>
<p>What about the <em>internal</em> voltage divider– the attenuator?</p>
<h2 id="internal-calibration">Internal calibration</h2>
<p>There’s <em>process variation</em> in manufacturing discrete resistors,
and likewise in creating integrated circuits (“chips”) like the ESP32.
Each individual chip will have slightly different electrical properties: changes in internal resistance,
changes in the ADC’s reference voltage…
which can result in quite different readings!</p>
<p>Unlike with my breadboard, we can’t poke a multimeter inside a chip to measure these different values.
Instead, the manufacturers send each chip through a calibration process before selling it,
and provide the calibration information for that chip.</p>
<p>As far as I can tell, the ESP32C3 is calibrated by:</p>
<ul>
<li>For each attenuation level,
<ol>
<li>Applying a 0V signal to the ADC; recording the ADC’s reading as <em>init</em></li>
<li>Applying an <em>x</em>V signal to the ADC; recording the ADC’s reading as <em>cal</em></li>
<li>Writing to a one-time-writeable memory (<a href="https://en.wikipedia.org/wiki/EFuse" rel="external" target="_blank">efuse</a>) the values of <em>init</em>, <em>x</em>, and <em>cal</em> for this attenuation level</li>
</ol>
</li>
</ul>
<p>We can read these calibration values out with a little bit of code.
We don’t <em>need</em> to read them out manually, but it’s interesting to see what they are!</p>
<details><summary><code>main.rs</code>, to read attenuation values</summary>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>#![no_std]</span><span>
</span></span></span><span><span><span></span><span>#![no_main]</span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>esp_backtrace</span><span> </span><span>as</span><span> </span><span>_</span><span>;</span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>esp_hal</span>::<span>analog</span>::<span>adc</span>::<span>Attenuation</span><span>;</span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>esp_println</span>::<span>println</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>esp_bootloader_esp_idf</span>::<span>esp_app_desc!</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[esp_rtos::main]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>main</span><span>(</span><span>_spawner</span>: <span>embassy_executor</span>::<span>Spawner</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>esp_println</span>::<span>logger</span>::<span>init_logger_from_env</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>peripherals</span><span> </span><span>=</span><span> </span><span>esp_hal</span>::<span>init</span><span>(</span><span>esp_hal</span>::<span>Config</span>::<span>default</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>use</span><span> </span><span>esp_hal</span>::<span>timer</span>::<span>timg</span>::<span>TimerGroup</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>timg0</span><span> </span><span>=</span><span> </span><span>TimerGroup</span>::<span>new</span><span>(</span><span>peripherals</span><span>.</span><span>TIMG0</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>use</span><span> </span><span>esp_hal</span>::<span>interrupt</span>::<span>software</span>::<span>SoftwareInterruptControl</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>software_interrupt</span><span> </span><span>=</span><span> </span><span>SoftwareInterruptControl</span>::<span>new</span><span>(</span><span>peripherals</span><span>.</span><span>SW_INTERRUPT</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>esp_rtos</span>::<span>start</span><span>(</span><span>timg0</span><span>.</span><span>timer0</span><span>,</span><span> </span><span>software_interrupt</span><span>.</span><span>software_interrupt0</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>use</span><span> </span><span>esp_hal</span>::<span>efuse</span>::<span>{</span><span>AdcCalibUnit</span><span>,</span><span> </span><span>Efuse</span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>atten</span><span> </span><span>in</span><span> </span><span>[</span><span>
</span></span></span><span><span><span>        </span><span>Attenuation</span>::<span>_0dB</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Attenuation</span>::<span>_2p5dB</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Attenuation</span>::<span>_6dB</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Attenuation</span>::<span>_11dB</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>]</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// The &#34;zero&#34; value: what the ADC reads when the input is at 0mV.
</span></span></span><span><span><span></span><span>        </span><span>// Internal voltages, impedences, etc. in the chip mean this is probably a non-zero value!
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>init</span><span> </span><span>=</span><span> </span><span>Efuse</span>::<span>rtc_calib_init_code</span><span>(</span><span>AdcCalibUnit</span>::<span>ADC1</span><span>,</span><span> </span><span>atten</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>// A nonzero voltage applied to the input during calibration, in millivolts.
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>mv</span><span> </span><span>=</span><span> </span><span>Efuse</span>::<span>rtc_calib_cal_mv</span><span>(</span><span>AdcCalibUnit</span>::<span>ADC1</span><span>,</span><span> </span><span>atten</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>// What the ADC read when the &#39;mv&#39; voltage was applied.
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>cal</span><span> </span><span>=</span><span> </span><span>Efuse</span>::<span>rtc_calib_cal_code</span><span>(</span><span>AdcCalibUnit</span>::<span>ADC1</span><span>,</span><span> </span><span>atten</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>println!</span><span>(</span><span>&#34;attenuation: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>atten</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>println!</span><span>(</span><span>&#34;rtc_calib_init_code: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>init</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>println!</span><span>(</span><span>&#34;rtc_calib_cal_mv: </span><span>{}</span><span>&#34;</span><span>,</span><span> </span><span>mv</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>println!</span><span>(</span><span>&#34;rtc_calib_cal_code: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>cal</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div></details>
<p>For the chip on my breadboard, I get:</p>
<table>
  <thead>
      <tr>
          <th>Attentuation</th>
          <th><em>init</em></th>
          <th><em>x</em></th>
          <th><em>cal</em></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0dB</td>
          <td>1364</td>
          <td>400 mV</td>
          <td>1958</td>
      </tr>
      <tr>
          <td>2.5dB</td>
          <td>1512</td>
          <td>550 mV</td>
          <td>2013</td>
      </tr>
      <tr>
          <td>6dB</td>
          <td>1539</td>
          <td>750 mV</td>
          <td>1969</td>
      </tr>
      <tr>
          <td>11dB</td>
          <td>1666</td>
          <td>1370 mV</td>
          <td>1931</td>
      </tr>
  </tbody>
</table>
<p>Look at those high <em>init</em> values! At a glance, it looks like a quarter of the ADC range is unusable!
Let’s not panic, though; let’s see how to use these values.</p>
<p>The <code>esp_hal</code> crate offers various calibration methods
that handle reading the efuse <em>and</em> passing the values through the appropriate formulas<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> before returning values.
The three mechanisms stack: <a href="https://docs.espressif.com/projects/rust/esp-hal/1.0.0/esp32c3/esp_hal/analog/adc/struct.AdcCalCurve.html" rel="external" target="_blank">AdcCalCurve</a> incorporates <a href="https://docs.espressif.com/projects/rust/esp-hal/1.0.0/esp32c3/esp_hal/analog/adc/struct.AdcCalLine.html" rel="external" target="_blank">AdcCalLine</a>, which incorporates <a href="https://docs.espressif.com/projects/rust/esp-hal/1.0.0/esp32c3/esp_hal/analog/adc/struct.AdcCalBasic.html" rel="external" target="_blank">AdcCalBasic</a>,
so we can just use AdcCalCurve and get “the best of all worlds”.</p>
<p>The <a href="https://docs.espressif.com/projects/rust/esp-hal/1.0.0/esp32c3/esp_hal/analog/adc/struct.AdcCalBasic.html" rel="external" target="_blank">AdcCalBasic</a> mechanism has this comment:</p>
<blockquote>
<p>Basic calibration sets the initial ADC bias value so that a zero voltage gives a reading of zero. The correct bias value is usually stored in efuse..</p>
<p>Failing to apply basic calibration can substantially reduce the ADC’s output range because bias correction is done before the ADC’s output is truncated to 12 bits.</p>
</blockquote>
<p>Aha! This explains why our uncalibrated values were (still) saturated:
they weren’t getting the bias subtracted out, so they saturated the 12 bits available.
Let’s see what we get if we ask for calibrated values:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>esp_hal</span>::<span>peripherals</span>::<span>ADC1</span><span>;</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>atten</span><span> </span><span>=</span><span> </span><span>adc</span>::<span>Attenuation</span>::<span>_11dB</span><span>;</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>config</span><span> </span><span>=</span><span> </span><span>adc</span>::<span>AdcConfig</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// NEW: enable_pin_with_cal, instead of just enable_pin
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>pin</span><span> </span><span>=</span><span> </span><span>config</span><span>.</span><span>enable_pin_with_cal</span>::<span>&lt;</span><span>_</span><span>,</span><span> </span><span>adc</span>::<span>AdcCalCurve</span><span>&lt;</span><span>ADC1</span><span>&gt;&gt;</span><span>(</span><span>peripherals</span><span>.</span><span>GPIO2</span><span>,</span><span> </span><span>atten</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>adc</span><span> </span><span>=</span><span> </span><span>adc</span>::<span>Adc</span>::<span>new</span><span>(</span><span>peripherals</span><span>.</span><span>ADC1</span><span>,</span><span> </span><span>config</span><span>).</span><span>into_async</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// ADC reading code:
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>v_adc</span><span> </span><span>=</span><span> </span><span>adc</span><span>.</span><span>read_oneshot</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>pin</span><span>).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;Internally-calibrated ADC reading: </span><span>{v_adc}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>embassy_time</span>::<span>Timer</span>::<span>after</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>2</span><span>)).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>In this setup, I got these readings:</p>
<ul>
<li>ADC reading: 1990mV</li>
<li>Voltmeter, \(V_{adc}\): 1972mV</li>
</ul>
<p>The ADC is &lt;1% off of the voltmeter; not bad!
The datasheet says the ATTEN3 range is ±35mV; 18mV is well within that.</p>
<p>This gives us a calibrated value of “what’s on the ADC pin”.
To map that back to the battery, we’ll also need to use the values from our external voltage divider.
Note how I’m now using the <em>measured</em> values instead of the <em>nominal</em> ones–sticking with “calibrated”!</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>const</span><span> </span><span>R1</span>: <span>usize</span> <span>=</span><span> </span><span>477_200</span><span>;</span><span> </span><span>// ohms
</span></span></span><span><span><span></span><span>const</span><span> </span><span>R2</span>: <span>usize</span> <span>=</span><span> </span><span>475_500</span><span>;</span><span> </span><span>// ohms
</span></span></span><span><span><span></span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// ADC reading code:
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>v_adc</span><span> </span><span>=</span><span> </span><span>adc</span><span>.</span><span>read_oneshot</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>pin</span><span>).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;Internally-calibrated ADC reading: </span><span>{v_adc}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>v_bat</span><span> </span><span>=</span><span> </span><span>(</span><span>v_adc</span><span> </span><span>as</span><span> </span><span>usize</span><span>)</span><span> </span><span>*</span><span> </span><span>(</span><span>R1</span><span> </span><span>+</span><span> </span><span>R2</span><span>)</span><span> </span><span>/</span><span> </span><span>R2</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;Externally-calibrated battery reading: </span><span>{v_bat}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>embassy_time</span>::<span>Timer</span>::<span>after</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>2</span><span>)).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>As measured:</p>
<ul>
<li>Chip reading: 4.025V</li>
<li>Voltmeter: \(V_{bat}\): 4.115V</li>
</ul>
<p>A little further off (~3%). Probably my measurements of the resistors have some noise, and I’m not accounting for all the resistances on the breadboard.
Still, this should be good enough for me to track “how close is the battery to empty”. Success!</p>
<p>As always, drop me a line if this helped you, or if you have corrections or comments!</p>




</div></div>
  </body>
</html>
