<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hasenjudy.wordpress.com/2022/08/25/odin-praise/">Original</a>
    <h1>I like the Odin programming language</h1>
    
    <div id="readability-page-1" class="page"><article id="post-158">
		<!-- .entry-header -->

	<div>
					<p>As someone who is interested in systems programming, and has experience working with Go, but not with C or C++, The Odin language is a great fit.</p>
<h2 id="proper-systems-language">Proper systems language</h2>
<p>Odin is a systems langauge that can viably be used to create programs that you would otherwise create in C or C++.</p>
<p>There’s no garbage collection. There’s no “runtime” doing things behind your back in the background.</p>
<p>This is in contrast to say, Go, which at first tried to claim to be a systems language, even though it has a garbage collector and a background runtime for pre-emptively managing goroutines.</p>
<p>In Odin, like in C, what you code is what you get.</p>
<p>You get to control memory layout.</p>
<p>Local variables are allocated on the stack.</p>
<p>Custom allocators are not only supported but expected, and the core library provides several useful allocators out of the box.</p>
<p>There is even some SIMD support at the language level!</p>
<p>There are no “exceptions”.</p>
<p>There’s no pretense of “memory safety”. The language assumes that you are in charge of memory. The compiler does not force you to check for nulls, prevent you from casting pointers, or otherwise impose restrictions on how you handle data in memory.</p>
<h2 id="language-defined-compilation-units">Language-defined compilation units</h2>
<p>In C and C++, the language does not define how source files relate to each other. If you just write code in two separate source files, the compiler has no idea how to combine the code into a program. This is the reason why header files are needed. It’s the reason why a build system is required.</p>
<p>This is the thing that makes writing substantial amount of C code not enjoyable for me. It makes integrating libraries really difficult and complicated.</p>
<p>In Odin, the basic compilation unit is a package. A package is just a directory with source files. All source files within a package (i.e. in the same directory) automatically know about each other.</p>
<p>To compile a program, you just point the odin compiler to a directory corresponding to a package that has a <code>main</code> procedure.</p>
<p>If this package imports other packages, they will be automatically included in the build.</p>
<p>No build system needed. No header files needed. The compiler knows how to put together all the source files into a final program.</p>
<h2 id="data-and-procedures">Data and procedures</h2>
<p>The programming model that Odin assumes is data and procedures.</p>
<p>Define your data types. Define your procedures. That’s it. That’s your program.</p>
<p>No macros. No “interfaces”. No “objects”.</p>
<p>If you need dynamic dispatch, define your data model such that it has function pointers.</p>
<p>If you need generic containers, you have parametric polymorphism.</p>
<p>If you want more complex meta-programming, you have to resort to code generation; just like with Go.</p>
<p>This is not to say there are no visibility controls in the language: there are. You can make some things private: to the file, or the package.</p>
<h2 id="batteries-included">Batteries included</h2>
<p>The standard library is quite extensive. It not only covers the basics like pretty printing to stdout and operating with files, but even has things like an LRU cache and a PNG image loader!</p>
<p>The language has builtin support for dynamic arrays and hashmaps – thanks to the language being aware of “allocators”.</p>
<p>A few high quality external libraries are hand picked and distributed with the compiler as vendored packages.</p>
<h2 id="sensible-design-choices">Sensible design choices</h2>
<ul>
<li>Nice and consistent syntax</li>
<li>Conditional compilation (without C style macros)</li>
<li>Everything is utf8</li>
<li>Everything is zero initialized (but no default values for struct fields)</li>
<li>Parametric polymorphism (generics)</li>
<li>Tagged unions</li>
<li>Defer and auto defer</li>
<li>Runtime Type Information (plain data; nothing hidden)</li>
<li>Type inference (more extensive than you might think)</li>
<li>Multiple return values (but no tuples)</li>
<li>Procedure parameters:
<ul>
<li>Are immutable (aka const ref)</li>
<li>Support default values</li>
<li>Can be passed by name (at call site)</li>
</ul>
</li>
<li>Procedure definitions can be nested (but no closures)</li>
<li>Interop with C and Objective-C
<ul>
<li>Native macOS applications be written in pure Odin.</li>
</ul>
</li>
</ul>
<p>Let’s expand on a few of them a little bit</p>
<h2 id="nice-sane-and-consistent-syntax">Nice, sane, and consistent syntax</h2>
<p>This might not seem like a big deal, but having a nice syntax is a big factor in whether the language is enjoyable or not. This is especially true when it comes to complex types, like function pointers.</p>
<p>In c, function pointers look sort of like this:</p>
<pre><code><span>void</span> <span>(</span><span>*</span>fn<span>)</span><span>(</span><span>int</span><span>)</span>
</code></pre>
<p>The equivalent in Odin looks like this:</p>
<pre><code>fn: proc(p: int)
</code></pre>
<p>Which is just like how you normally define procedures:</p>
<pre><code>my_proc :: proc(p: int) {
    // body
}
</code></pre>
<h2 id="defer-and-auto-defer">Defer, and auto defer</h2>
<p>Like Go, Odin has a <code>defer</code> statement. Unlike Go, the defer in Odin works at the scope level, and the entire expression is deferred (including the evaluation of parameters passed to procedures)</p>
<p>So you can always open a small scope within a procedure and put a defer at the top.</p>
<pre><code>myproc :: proc(....) {
    // ... lots of code ...
    {
        start := time.tick_now()
        defer fmt.println(&#34;Time passed:&#34;, time.tick_since(start))
        // .. something you want to measure ..
    }
    // .. more code ..
}
</code></pre>
<p>What’s more, you can define a procedure that is automatically called when calling another procedure. Using one of the <code>deferred_xxxx</code> attributes, you can specify a procedure to be automatically deferred, and specify how parameters are passed to it.</p>
<pre><code>@(deferred_in_out=print_duration)
scoped_measure_duration :: proc(label: string) -&gt; time.Tick {
    return time.tick_now()
}

print_duration :: proc(label: string, start: time.Tick) {
    duration := time.tick_since(start)
    fmt.println(label, duration)
}
</code></pre>
<p>Now you can just do this in any scope:</p>
<pre><code>{
    scoped_measure_duration(&#34;reading file: &#34;)

    os.read_entire_file(&#34;something.txt&#34;)
}
</code></pre>
<h2 id="tagged-unions">Tagged unions</h2>
<p>This is a big one – for me anyway. It’s something I really wish Go had support for.</p>
<p>Example: suppose you want to represent color using 4 different ways: ‘rgb’, ‘rgba’,  ‘hsl’, and ‘hsla’. They are wildly different but you know how to handle all of them correctly.</p>
<pre><code>RGB :: struct {
    r, g, b: u8
}

RGBA :: struct {
    r, g, b, a: u8,
}

HSL :: struct {
    h, s, l: f32
}

HSLA :: struct {
    h, s, l, a: f32
}

Color :: union {
    RGB,
    RGBA,
    HSL,
    HSLA,
}
</code></pre>
<p>You can define a color variable and set it to one of these:</p>
<pre><code>c1, c2, c3, c4: Color

c1 = RGB{50, 50, 50}
c2 = RGBA{30, 30, 30, 200}
c3 = HSL{0.5, 0.3, 0.9}
c4 = HSLA{0.5, 0.3, 0.9, 0.2}
</code></pre>
<p>You can then “query” the underlying type to do something with it.</p>
<p>Let’s say we want to just figure out the “alpha” value for a color as a float from 0 to 1.</p>
<pre><code>get_opacity :: proc(color: Color) -&gt; f32 {
    switch v in color {
        case RGB, HSL:
            return 1
        case HSLA:
            return v.a
        case RGBA:
            return cast(f32)v.a / 255
        case: // nil
            return 0
    }
}
</code></pre>
<p>Now we can call this procedure:</p>
<pre><code> fmt.println(&#34;c1 opacity:&#34;, get_opacity(c1))
    fmt.println(&#34;c2 opacity:&#34;, get_opacity(c2))
    fmt.println(&#34;c3 opacity:&#34;, get_opacity(c3))
    fmt.println(&#34;c4 opacity:&#34;, get_opacity(c4))
</code></pre>
<p>And the output:</p>
<pre><code>c1 opacity: 1.000
c2 opacity: 0.784
c3 opacity: 1.000
c4 opacity: 0.200
</code></pre>
<p>One thing to note about the <code>switch v in color</code> construct is that within the case body, <code>v</code> is immutable (I believe the C++ terminology in const reference), so you can’t <strong>change</strong>  anything about. But, if you <code>switch v in &amp;color</code> then ` you can. In general, you can also do a switch statement on a pointer and it will work the same way.</p>
<p>Let’s see a procedure to set the opacity:</p>
<pre><code>set_opacity :: proc(color: ^Color, alpha: f32) {
    #partial switch v in color {
        case RGBA:
            v.a = cast(u8) (alpha * 255)
        case HSLA:
            v.a = alpha
    }
}
</code></pre>
<p>Note how the case labels are the type names, just like in the union definition. They do not change to <code>case ^RGBA</code> just because we’re switching type on a pointer variable.</p>
<h2 id="introspection--type-information">Introspection / Type Information</h2>
<p>This is also a big one. You get runtime type information in the form of data.</p>
<p>The runtime type information is just a bunch of structs that describe the types.</p>
<p>Unlike other languages, there’s nothing “hidden” from you behind opaque objects and abstractions. It’s all there laid out in the open.</p>
<p>Introspection is how the standard library <code>print</code> procedures are able to “pretty print” any value you pass to it. It’s also how the json module knows how to “jsonify” anything you pass to it (as long as it is jsonifyable in principle).</p>
<p>Basically any serialization/deserialization scheme can be implemented using this system.</p>
<h2 id="type-inference">Type inference</h2>
<p>Many modern languages provide type inference in the sense of allowing to declare variables and assign them at the same time without having to be explicit about the type of the variable.</p>
<p>Type inference in Odin goes beyond that.</p>
<p>Enum members don’t require the full enum type before the enum value.</p>
<p>Struct literals don’t require the struct name if the context makes it unambiguous.</p>
<p>Let’s say you have the following enum:</p>
<pre><code>Direction :: enum {
    Unknown,

    North,
    East,
    South,
    West,
}
</code></pre>
<p>We don’t have to say <code>Direction.North</code> all the time. Most of the time, just <code>.North</code> will be enough, because the context is clear.</p>
<p>As a simple example:</p>
<pre><code> d: Direction

    d = .North
</code></pre>
<p>But this even works with procedure parameters.</p>
<pre><code>opposite_direction :: proc(d: Direction) -&gt; Direction {
 ....
}
</code></pre>
<p>You can call it like this:</p>
<pre><code> fmt.println(&#34;North &lt;=&gt;&#34;, opposite_direction(.North))
</code></pre>
<p>And the body of the procedure itself benefits from this feature too:</p>
<pre><code>opposite_direction :: proc(d: Direction) -&gt; Direction {
    switch d {
        case .North:
            return .South
        case .South:
            return .North
        case .East:
            return .West
        case .West:
            return .East
        case .Unknown:
            return .Unknown
    }
    return .Unknown
}
</code></pre>
<p>This same rule applies to structs as well.</p>
<p>The normal way to assign a struct using a literal is like this:</p>
<pre><code>rgb_color = RGB{ 100, 150, 200 }
</code></pre>
<p>But if the variable already has the type assigned, it can be dropped from the struct literal:</p>
<pre><code> rgb_color: RGB;
    rgb_color = { 100, 150, 200 }
</code></pre>
<p>Again this applies to procedure parameters:</p>
<p>Given this procedure:</p>
<pre><code>set_color :: proc(r: RGB) {
    fmt.println(&#34;color set to:&#34;, r)
}
</code></pre>
<p>It can be called like this:</p>
<pre><code> set_color({100, 200, 150})
</code></pre>
<h2 id="a-word-about-memory-management-phobia">A word about memory management phobia</h2>
<p>If you are interested in delving into systems programming but dread having to work with C or C++, then Odin might be just the right language for you, and I recomend you check it out.</p>
<p>For me, the reasons I “dread” working with C are centered around the complicated compilation model, the awkward syntax, the lack of support for slices, the lack of zero initialization, and the like.</p>
<p>If your “dread” of C comes from fear of memory management, then Odin is probably not for you, and dare I say, maybe systems programming is not for you.</p>
<p>That said, the vast majority of memory corruption in C systems very likely stem from the lack of a proper slice type. It’s common for C programs to pass around pointers and lengths as two separate parameters. Combined with the assumptions that strings are null terminated, creates the conditions where it’s easy to make the mistake of reading beyond the end of buffers.</p>
<p>This problem is pretty much solved in Odin. Most of the time when you deal with buffers, you are not dealing with raw pointers: you are either dealing with a slice, or a dynamic array, where not only the length and capacity are explicitly specified, but even the allocator is specified.</p>


						</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
