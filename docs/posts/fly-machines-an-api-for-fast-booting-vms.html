<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/fly-machines/">Original</a>
    <h1>Fly Machines: An API for Fast-Booting VMs</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/public/images/kurt.jpg" alt="Kurt Mackey" srcset=""/> <dl> <dt>Name</dt> <dd> Kurt Mackey </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/mrkurt" target="_blank"> @mrkurt </a> </dd> </dl> </dd> </dl> <section> <img src="https://fly.io/blog/2022-05-24/machine-whack-a-mole.jpg" alt="Whack-a-mole-type game with Fly.io bird characters where the moles would be."/> <p> <a href="http://Fly.io">Fly.io</a> turns Docker images into running VMs on physical servers all over the world. We built <a href="https://fly.io/docs/reference/machines/">an API for booting VMs very quickly</a>. Here&#39;s what you need to know.</p><p>Fly Machines are VMs with a fast REST API that can boot instances in about 300ms.</p> <p>Our proxy can boot Fly Machines for you, and you can shut them down when they&#39;re idle. Which means you can cost-effectively create VMs and keep them standing by to handle new requests.</p> <p>We built Machines for us. Our customers want their apps to scale to zero, mostly to save money. Also because it feels right. An app that isn&#39;t doing anything shouldn&#39;t be running. Fly Machines will help us ship apps that scale to zero sometime this year.</p> <p>Fly Machines may be useful to you, too. A lot of y&#39;all want to build your own functions-as-a-service. <a href="https://fly.io/docs/app-guides/functions-with-machines/">You can build a FaaS with Fly Machines</a>.</p> <h2 id="how-to-boot-vms-in-a-hurry"><a href="#how-to-boot-vms-in-a-hurry" aria-label="Anchor"></a>How to Boot VMs in a Hurry</h2><p>We said we want our VMs to boot fast. They already do; <a href="https://jvns.ca/blog/2021/01/23/firecracker--start-a-vm-in-less-than-a-second/">Firecracker is pretty darn fast</a> to boot a given executable on a given host. Our job is to get our own plumbing out of your way, and get you close to local-Firecracker speeds.</p> <p>Spinning up a VM as fast as possible <em>on a server somewhere</em> is an exercise in reducing infrastructure latency. We need to play latency whack-a-mole.</p> <p>When you ask for a VM, you wait for network packets to travel to an API somewhere. Then you wait for them to come back. The API is also, at minimum, talking to the host your job will run on. If all your users are in Virginia and your API is in Virginia and the hardware running Firecrackers is in Virginia, this might take 20-50ms.</p> <p>If your users are in Sydney and the hardware for the Firecrackers are in Sydney and the API is in Virginia, &#34;boot me a VM&#34; takes more like 300ms. Three tenths of a second just waiting for light to move around is not fast.</p> <p>We&#39;re not done. You need something to run, right? Firecracker needs a root filesystem. For this, we download Docker images from a repository backed by S3. This can be done in a few seconds if you&#39;re near S3 and the image is smol. It might take several minutes (minutes!) if you&#39;re far away and the image is chonk.</p> <p>We solve this by making you create machines ahead of time. Accountants (not the TikTok kind; actual accountants) call this &#34;amortization&#34; – pay the cost up front, yield the benefit over time.</p> <h2 id="the-slow-part"><a href="#the-slow-part" aria-label="Anchor"></a>The Slow Part</h2><p>Here&#39;s what happens when you call the <a href="https://fly.io/docs/reference/machines/#create-and-start-a-machine">create machine endpoint</a>:</p> <p><img src="https://fly.io/blog/2022-05-24/machine-reservation-process.png" alt="The 92 step process our infrastructure uses to create a machine"/></p> <p>If you&#39;re an app developer in Los Angeles and you want a machine in São Paulo, your request gets routed to your friendly local API server. We run API servers in every region, so this part of the process is fast.</p> <p>The API server makes a preflight request to our centralized database in Virginia, which gives back a yay (or nay!) and an immutable Docker image URL.</p> <p>Our database in Virginia has to be looped in on machine creation. We want a strongly-consistent record that machines exist. We also want to make sure you can&#39;t create a machine if you&#39;re 8 months behind on bills or got banned for mining cryptocurrency with a stolen credit card.</p> <p>The Los Angeles API instance then broadcasts a NATS message to the available hosts in São Paulo saying &#34;hey, reserve me a machine with these specs&#34;. Hosts with resources to spare reserve a slice of their capacity and reply with information about what they have to offer.</p> <p>The API server evaluates each host&#39;s offer, picks one, and says &#34;OK, host, create a machine for reservation X&#34;. The API server then records a machine record in our centralized database. The other hosts garbage-collect the unused reservations a few seconds later.</p> <p>You might be thinking &#34;if I&#39;m in Los Angeles and I request a machine in São Paulo, won&#39;t it take like a second for that whole dance to happen?&#34; It would, yes.</p> <p>You might also be thinking &#34;pulling that image from a remote repository was probably soul-crushingly slow, right?&#34; Also true! You don&#39;t want to do that any more times than you need to.</p> <p>We made machines really cheap to create and keep stopped. In fact, right now, you pay for image storage; that&#39;s it. What we want you do is: create machines ahead of time and start them when you need them.</p> <h2 id="the-fast-part"><a href="#the-fast-part" aria-label="Anchor"></a>The Fast Part</h2><p>You should create machines just before you need them. Slightly earlier than just-in-time. All the stuff I just told you about is necessary to get to this point, but the protein is here: we designed Fly Machines for fast <em>starts</em>.</p> <p>When you&#39;re ready, you start a machine in São Paulo with a request to the nearest API server. This time, though, there&#39;s no need to wait on our database in Virginia. The central accounting is done and the API server knows exactly which host it needs to talk to. And the OCI image for the VM&#39;s filesystem is ready to go.</p> <p>Here&#39;s what the <a href="https://fly.io/docs/reference/machines/#start-a-machine">start machine endpoint</a> does:</p> <p><img src="https://fly.io/blog/2022-05-24/machine-start-api.png?3/4&amp;centered" alt="The one step process our infrastructure uses to start a machine"/></p> <p><em>Now</em> the start is fast. How fast?</p> <p>When you run <code>fly machine start e21781960b2896</code>, the API server knows that <code>e21781960b2896</code> is owned by a host in São Paulo. It then sends a message directly to that host saying &#34;<a href="https://www.youtube.com/watch?v=7XL84zQZ1nw">start it up</a>&#34;. This message travels as fast as physics allows.</p> <p>The host receives the start message…and starts the machine. It already has the image stored locally, so it doesn&#39;t need to wait on an image pull.</p> <p>If you&#39;re in Los Angeles and start your machine in São Paulo, the &#34;start&#34; message gets where it needs to go in ~150ms. But if you&#39;re in Los Angeles and start a machine in Los Angeles, the &#34;start&#34; message might arrive in ~10ms.</p> <p>The lesson here is &#34;start machines close to your users&#34;; the operation is very fast. Here&#39;s something cool about this, though: <em>You</em> don&#39;t necessarily start the machine from where you are; an <em>app</em> can do it for you. In fact, this is kind of the point. Your application logic should be close to your users&#39; machines.</p> <p>Or, you can forego the app and let <code>fly-proxy</code> boot machines when HTTP requests arrive. It can do all this for you.</p> <p>I should clarify: our infrastructure is fast to run start operations. Your application boot time is something you should optimize. We can&#39;t help with that (yet!)</p> <h3 id="stopping-and-scaling-to-zero"><a href="#stopping-and-scaling-to-zero" aria-label="Anchor"></a>Stopping and Scaling to Zero</h3><p>Stop commands are fast too. You may not want to issue stop commands, though. If your machine should stop when it&#39;s idle, there&#39;s a better way.</p> <p>Fly.io users have been requesting &#34;scale to zero&#34; since January 1st, 1970 at 00:00:00 UTC. Scaling up is pretty easy; it&#39;s usually safe to boot a new VM and add it to a load balancer. Scaling down is harder—stop a VM at the wrong time and shit breaks.</p> <p>So here&#39;s how we modeled this: when you use Fly.io machines to run apps that need to scale down, make your process exit when it&#39;s idle. That&#39;s it. You&#39;ve exited the container, effectively stopping the machine, but it&#39;s intact to pick up a future start request from a clean slate.</p> <p>This works because your in-machine process has a strongly-consistent view of local activity and can confidently detect &#34;idle&#34;.</p> <figure> <figcaption> <p> If you&#39;ve got a Fly.io account, you can play with the Fly Machines API right now—even if you&#39;re not ready to <a href="https://fly.io/docs/app-guides/functions-with-machines">build your own FaaS</a>.</p><p><a href="https://fly.io/docs/reference/machines/"> Try Machines  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/public/images/cta-rabbit.jpg" srcset="/public/images/cta-rabbit@2x.jpg 2x" alt=""/></p></figure><h2 id="how-fly-machines-will-frustrate-you-the-emotional-cost-of-simplicity"><a href="#how-fly-machines-will-frustrate-you-the-emotional-cost-of-simplicity" aria-label="Anchor"></a>How Fly Machines Will Frustrate You (the Emotional Cost of Simplicity)</h2><p>One thing you may have noticed about our design: machines are pinned to specific hardware in our datacenters. This is a tradeoff that buys simplicity at the risk of your patience.</p> <p>Pinning machines to specific hardware means that if the PSU on that host goes pop, your machine won&#39;t work (kind of; we run redundant PSUs). Capacity issues will create more surprising failures. If you create a biggish 64GB RAM machine and leave it stopped, we might be out of capacity on that specific host when you attempt to start it back up.</p> <p>We will mostly shield you from capacity issues, but you should <em>definitely</em> be prepared for the eventuality that your first-choice hardware is indisposed. Which really just means: plan to have two machines for redundancy.</p> <p>The good news is that our API is pretty fast. Creating a machine is relatively slow, but you can do it in a pinch. If a machine fails to start, you can usually get another one running in a few seconds.</p> <p>The best way to use machines is to think of a list of operations in priority order. If you&#39;re trying to run some user code, come up with a list like this:</p> <ol> <li>Start machine X in Chicago. If that fails, </li><li>Start machine Z in New Jersey. If that fails, </li><li>Launch new machine in Chicago. If that fails, </li><li>Launch new machine in New Jersey. If that fails, </li><li>Launch new machine somewhere in the US. If that fails, </li><li>Check your internet connection (or our status page). That should not fail. </li></ol> <p>This cycle will account for all the predictable failures and should get you a machine any time you want one.</p> <h2 id="pricing-the-monetary-cost-of-simplicity"><a href="#pricing-the-monetary-cost-of-simplicity" aria-label="Anchor"></a>Pricing (the Monetary Cost of Simplicity)</h2><p>Running machines costs the same as <a href="https://fly.io/docs/about/pricing/#compute">running normal VM instances</a>. The same goes for bandwidth, RAM, and persistent disks.</p> <p>Stopped machines, though, are something we could use your feedback on. There&#39;s a cost to keeping these things around. Right now, we just charge you for storage when a machine isn&#39;t running. Like $0.15/mo for a 1GB Docker image.</p> <hr/> <p>Questions? Comments? Pricing ideas? Vitriol? Comment <a href="https://community.fly.io/t/were-launching-machines-today/5305">in our forum thread</a>.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/blog/fly-io-is-hiring-rails-specialists/"> Fly.io is Hiring Rails Specialists </a> </dd> </dl> </article></div>
  </body>
</html>
