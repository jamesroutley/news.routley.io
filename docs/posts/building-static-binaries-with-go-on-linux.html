<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2024/building-static-binaries-with-go-on-linux/">Original</a>
    <h1>Building static binaries with Go on Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>One of Go&#39;s advantages is being able to produce statically-linked
binaries <a href="#footnote-1" id="footnote-reference-1">[1]</a>. This doesn&#39;t mean that Go always produces such binaries by default,
however; in some scenarios it requires extra work to make this happen.
Specifics here are OS-dependent; here we focus on Unix systems.</p>
<div id="basics-hello-world">
<h2>Basics - hello world</h2>
<p>This post goes over a series of experiments: we take simple programs and use
<tt>go build</tt> to produce binaries on a Linux machine. We then examine whether
the produced binary is statically or dynamically linked. The first example is
a simple &#34;hello, world&#34;:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>import</span><span> </span><span>&#34;fmt&#34;</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;hello world&#34;</span><span>)</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>After building it with <tt>go build</tt>, we get a binary. There are a few ways on
Linux to determine whether a binary is statically or dynamically linked. One
is the <tt>file</tt> tool:</p>
<div><pre><span></span>$ file ./helloworld
helloworld: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=Flm7stIXKLPfvBhTgXmR/PPwdjFUEkc9NCSPRC7io/PofU_qoulSqJ0Ktvgx5g/eQXbAL15zCEIXOBSPZgY, with debug_info, not stripped
</pre></div>
<p>You can see it says &#34;statically linked&#34;. Another way is to use <tt>ldd</tt>, which
prints the shared object dependencies of a given binary:</p>
<div><pre><span></span>$ ldd ./helloworld
  not a dynamic executable
</pre></div>
<p>Alternatively, we can also use the ubiquitous <tt>nm</tt> tool, asking it to list the
undefined symbols in a binary (these are symbols the binary expects the dynamic
linker to provide at run-time from shared objects):</p>
<div><pre><span></span>$ nm -u ./helloworld
&lt;empty output&gt;
</pre></div>
<p>All of these tell us that a simple <tt>helloworld</tt> is a statically-linked binary.
Throughout the post I&#39;ll mostly be using <tt>ldd</tt> (out of habit), but you can
use any approach you like.</p>
</div>
<div id="dns-and-user-groups">
<h2>DNS and user groups</h2>
<p>There are two pieces of functionality the Go standard library defers to the
system&#39;s <tt>libc</tt> on Unix machines, when some conditions are met. When cgo
is enabled (as it often - but not always - is on Unix machines), Go will call
the C library for DNS lookups in the <tt>net</tt> package and for user and group
ID lookups in the <tt>os/user</tt> package.</p>
<p>Let&#39;s observe this with an experiment:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>import</span><span> </span><span>(</span><span></span>
<span>  </span><span>&#34;fmt&#34;</span><span></span>
<span>  </span><span>&#34;net&#34;</span><span></span>
<span>)</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>net</span><span>.</span><span>LookupHost</span><span>(</span><span>&#34;go.dev&#34;</span><span>))</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>If we build this program, we notice it&#39;s <em>dynamically</em> linked, expecting to
load a <tt>libc</tt> shared object at run-time:</p>
<div><pre><span></span>$ go build lookuphost.go
$ ldd ./lookuphost
  linux-vdso.so.1 (0x00007b50cb22a000)
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007b50cae00000)
  /lib64/ld-linux-x86-64.so.2 (0x00007b50cb22c000)
</pre></div>
<p>This is explained in the <a href="https://pkg.go.dev/net#hdr-Name_Resolution">net package documentation</a> in some detail. The Go
standard library does have a pure Go implementation of this functionality
(although it may lack some advanced features). We can ask the toolchain to use
it in a couple of ways. First, we can set the <tt>netgo</tt> build tag:</p>
<div><pre><span></span>$ go build -tags netgo lookuphost.go
$ ldd ./lookuphost
  not a dynamic executable
</pre></div>
<p>Second, we can disable cgo entirely with the <tt>CGO_ENABLED</tt> env var. This env
var is usually on by default on Unix systems:</p>

<p>If we disable it explicitly for our build, we&#39;ll get a static binary again:</p>
<div><pre><span></span>$ CGO_ENABLED=0 go build lookuphost.go
$ ldd ./lookuphost
  not a dynamic executable
</pre></div>
<p>Similarly, some of the functionality of the <tt>os/user</tt> package uses <tt>libc</tt>
by default. Here&#39;s an example:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>import</span><span> </span><span>(</span><span></span>
<span>  </span><span>&#34;encoding/json&#34;</span><span></span>
<span>  </span><span>&#34;log&#34;</span><span></span>
<span>  </span><span>&#34;os&#34;</span><span></span>
<span>  </span><span>&#34;os/user&#34;</span><span></span>
<span>)</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>user</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>user</span><span>.</span><span>Lookup</span><span>(</span><span>&#34;bob&#34;</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>log</span><span>.</span><span>Fatal</span><span>(</span><span>err</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>je</span><span> </span><span>:=</span><span> </span><span>json</span><span>.</span><span>NewEncoder</span><span>(</span><span>os</span><span>.</span><span>Stdout</span><span>)</span><span></span>
<span>  </span><span>je</span><span>.</span><span>Encode</span><span>(</span><span>user</span><span>)</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>This produces a dynamically-linked binary:</p>
<div><pre><span></span>$ go build userlookup.go
$ ldd ./userlookup
  linux-vdso.so.1 (0x0000708301084000)
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x0000708300e00000)
  /lib64/ld-linux-x86-64.so.2 (0x0000708301086000)
</pre></div>
<p>As with <tt>net</tt>, we can ask the Go toolchain to use the pure Go implementation
of this user lookup functionality. The build tag for this is <tt>osusergo</tt>:</p>
<div><pre><span></span>$ go build -tags osusergo userlookup.go
$ ldd ./userlookup
  not a dynamic executable
</pre></div>
<p>Or, we can disable cgo:</p>
<div><pre><span></span>$ CGO_ENABLED=0 go build userlookup.go
$ ldd ./userlookup
  not a dynamic executable
</pre></div>
</div>
<div id="linking-c-into-our-go-binary">
<h2>Linking C into our go binary</h2>
<p>We&#39;ve seen that the standard library has some functionality that may require
dynamic linking by default, but this is relatively easy to override. What
happens when we actually have C code as part of our Go program, though?</p>
<p>Go supports C extensions and FFI using <a href="https://pkg.go.dev/cmd/cgo">cgo</a>.
For example:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>// #include &lt;stdio.h&gt;</span><span></span>
<span>// void helloworld() {</span><span></span>
<span>//   printf(&#34;hello, world from C\n&#34;);</span><span></span>
<span>// }</span><span></span>
<span>import</span><span> </span><span>&#34;C&#34;</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>C</span><span>.</span><span>helloworld</span><span>()</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>A program built from this source will be dynamically linked, due to cgo:</p>
<div><pre><span></span>$ go build cstdio.go
$ ldd ./cstdio
  linux-vdso.so.1 (0x00007bc6d68e3000)
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007bc6d6600000)
  /lib64/ld-linux-x86-64.so.2 (0x00007bc6d68e5000)
</pre></div>
<p>In our C code, <tt>printf</tt> is a call to <tt>libc</tt>; even if we don&#39;t explicitly
call into the C runtime in our C code, cgo may do it in the scaffolding code
it generates.</p>
<p>Note that cgo may be involved even if your project has no C code of its own;
several dependencies may bring in cgo. Some popular packages - like the
<a href="https://pkg.go.dev/github.com/mattn/go-sqlite3">go-sqlite3</a> driver - depend
on cgo, and importing them will impose a cgo requirement on a program.</p>
<p>Obviously, building with <tt>CGO_ENABLED=0</tt> is no longer an option.
So what&#39;s the recourse?</p>
</div>
<div id="linking-a-libc-statically">
<h2>Linking a <tt>libc</tt> statically</h2>
<p>To recap, once we have C code as part of our Go binary, it&#39;s going to be
dynamically linked on Unix, because:</p>
<ol>
<li>The C code calls into <tt>libc</tt> (the C runtime)</li>
<li>The <tt>libc</tt> typically used on Unix systems is <a href="https://en.wikipedia.org/wiki/Glibc">glibc</a></li>
<li>The recommended way to link to <tt>glibc</tt> is dynamically (for various
technical and license-related reasons that are outside the scope of this
post)</li>
<li>Therefore, <tt>go build</tt> produces dynamically-linked Go binaries</li>
</ol>
<p>To change this flow of events, we can interpose at step (2) - use a <em>different</em>
<tt>libc</tt> implementation, one that&#39;s statically linked. Luckily, such an
implementation exists and is well used and tested - <a href="https://wiki.musl-libc.org/">musl</a>.</p>
<p>To follow along, start by installing musl. The standard instructions using
<tt>./configure <span>--prefix=&lt;MUSLDIR&gt;</span></tt> and <tt>make</tt> / <tt>make install</tt> work well.
We&#39;ll use <tt>$MUSLDIR</tt> to refer to the directory where musl is installed.
musl comes with a <tt>gcc</tt> wrapper that makes it easy to pass all the right
flags. To re-build our <tt>cstdio</tt> example using musl, run:</p>
<div><pre><span></span>$ CC=$MUSLDIR/bin/musl-gcc go build --ldflags &#39;-linkmode external -extldflags &#34;-static&#34;&#39; cstdio.go
$ ldd ./cstdio
  not a dynamic executable
</pre></div>
<p>The <tt>CC</tt> env var tells <tt>go build</tt> which C compiler to use for cgo; the
linker flags instruct it to use an external linker for the final build
(<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.22.0:src/cmd/cgo/doc.go;l=830">read this for the gory details</a>)
and then to perform a static link.</p>
<p>This approach works for more complex use cases as well! I won&#39;t paste the code
here, but the <a href="https://github.com/eliben/code-for-blog/tree/main/2024/go-static-linking">sample repository accompanying this post</a> has a file
called <tt><span>use-sqlite.go</span></tt>; it uses the <tt><span>go-sqlite3</span></tt> package. Try
<tt>go build</tt>-ing it normally and observe the dynamically linked binary produced;
next, try to build it with the flags shown above to use musl, and observe
that the produced binary will be statically linked.</p>
<p>Another curious tidbit is that we now have another way to build a statically-linked
<tt>lookuphost</tt> program - by linking it with musl:</p>
<div><pre><span></span>$ CC=$MUSLDIR/bin/musl-gcc go build --ldflags &#39;-linkmode external -extldflags &#34;-static&#34;&#39; lookuphost.go
$ ldd ./lookuphost
  not a dynamic executable
</pre></div>
<p>Since we didn&#39;t provide <tt><span>-tags</span> netgo</tt> and didn&#39;t disable cgo, the Go toolchain
uses calls into <tt>libc</tt> to implement DNS lookup; however, since these calls
end up in the statically-linked musl, the final binary is statically linked!</p>
</div>
<div id="using-zig-as-our-c-compiler">
<h2>Using Zig as our C compiler</h2>
<p>Another alternative emerged recently to achieve what we want: using the Zig
toolchain. <a href="https://ziglang.org/">Zig</a> is a new systems programming language,
which uses a bundled toolchain approach similar to Go. Its toolchain bundles
together a Zig compiler, C/C++ compiler, linker and <tt>libc</tt> for static linking.
Therefore, Zig can actually be used to link Go binaries statically with C code!</p>
<p><em>Instead</em> of installing musl, we could instead install Zig and use its
<tt><span>x86_64-linux-musl</span></tt> target (adjust the architecture if needed). This is
done by pointing to the <tt>zig</tt> binary as our <tt>CC=</tt> env var; assuming Zig
is installed in <tt>$ZIGDIR</tt>:</p>
<div><pre><span></span>$ CC=&#34;$ZIGDIR/zig cc -target x86_64-linux-musl&#34; go build cstdio.go
$ CC=&#34;$ZIGDIR/zig cc -target x86_64-linux-musl&#34; go build use-sqlite.go
</pre></div>
<p>These will produce statically-linked Go binaries; the <tt>zig</tt> driver takes
care of setting the right linker flags automatically, so the command-line ends
up being slightly simpler than invoking <tt><span>musl-gcc</span></tt>. Another advantage of Zig
here is that enables cross-compilation of Go programs that include C code <a href="#footnote-2" id="footnote-reference-2">[2]</a>.</p>
<p>I did find some issues with this approach, however; for example, attempting to
link the <tt>lookuphost.go</tt> sample fails with a slew of linker errors.</p>
</div>
<div id="summary">
<h2>Summary</h2>
<p>Making sure Go produces a statically-linked binary on Linux takes a little
bit of effort, but works well overall.</p>
<p>There&#39;s a <a href="https://github.com/golang/go/issues/26492">long standing accepted proposal</a>
about adding a <tt><span>-static</span></tt> flag to <tt>go build</tt> that would take care of setting
up all the flags required for a static build. AFAICT, the proposal is just
waiting for someone with enough grit and dedication to implement and test it
in all the interesting scenarios.</p>
</div>


            </div></div>
  </body>
</html>
