<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/mfa-auth-via-rls">Original</a>
    <h1>Supabase introduces MFA support</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>Today, we’re releasing Multi Factor Authentication for everyone.</p>
<p>Additionally, in preparation for releasing SAML, we&#39;re &#34;dogfooding&#34; the feature with the introduction of Single Sign On (SSO) on our dashboard. Contact us at <a href="mailto:growth@supabase.com">growth@supabase.com</a> if you want to <a href="https://docs.supabase.com/guides/platform/sso/enable-sso">enable this in your Enterprise or Pro plan</a>.</p>
<h2 id="what-is-mfa">What is MFA?</h2>
<p>Multi-factor authentication (MFA), sometimes called two-factor authentication (2FA), adds an additional layer of security to your application by letting you verify users’ identity through extra steps. This typically consists of something you know, like a password, and something you have, like an authenticator application. We built MFA in response to customer requests - developers wanted enhanced security - be it for compliance, client requirements, or simply for peace of mind. As such, we started by building MFA support for Time-Based One Time Passwords (TOTP).</p>
<h2 id="an-overview-of-totp">An Overview of TOTP</h2>
<p><a href="https://www.rfc-editor.org/rfc/rfc6238">TOTP</a> works by generating a unique, one-time password that is valid for a limited amount of time, usually 30 seconds or less. This password is generated using a shared secret key that is known only to the device and Supabase Auth, along with the current time. To exchange the shared secret key, a user scans a QR code generated by the server in order to establish a connection. The QR code can be represented by a URI which conforms to the <a href="https://github.com/google/google-authenticator/wiki/Key-Uri-Format">Google Authenticator Key URI format</a>:</p>

<p>The first portion of  <code>otpauth://totp/supabase.io</code> describes the protocol and issuer while <code>j@supacats.io</code> refers to the user. The remaining parameters refer to specifics around OTP generation. In this case, the OTP code is generated using a SHA1 hash of the secret combined with the timestamp and the OTP code is valid for <code>30s</code></p>
<p>In the event that the user faces difficulties entering a QR code the user can also opt to manually type the secret into the authenticator device.</p>
<h2 id="mfa-flows-enrollment-and-verification">MFA Flows: Enrollment and Verification</h2>
<p>An MFA flow can be broken into two key steps: Enrollment and Verification. During the <em>Enrollment</em> process Supabase Auth exchanges a randomly generated secret with the user’s authenticator application. During the <em>Verification</em> process, the device makes use of the timestamp together with the secret to produce a six digit code that the server can verify.</p>
<p><span><span><img alt="Flowchart of an MFA flow" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span>
<strong>Enrollment</strong></p>
<p>To generate a QR code, call the <code>/enroll</code> endpoint which returns an SVG encoded QR and the secret. Thereafter, create a challenge by calling the <code>/challenge</code> endpoint. Once the user has entered the six digit TOTP code generated by their authenticator app, call the<code>/verify</code>  endpoint with the corresponding factor and challenge details.</p>
<p>You might wonder: why the need for the &#34;challenge&#34; step? This step creates an interval between MFA initiation and the action of making a verification. This is useful in cases like Yubikey authentication where a user might need to request a challenge before placing their finger on the device.</p>
<p><span><span><img alt="MFA Enrollment Flow" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span>
<em>Overview of Enrollment Flow</em></p>
<p><strong>Verification</strong></p>
<p>On subsequent logins attempts, redirect a user to an MFA verification after they have completed the conventional sign in process. On the verification page, wait for the user to enter the six digit OTP code from the authenticator application and then call  the<code>/challenge</code> endpoint followed by the <code>/verify</code> endpoint. If a correct code is submitted, a JWT will be created with a few additional fields.</p>
<p><span><span><img alt="MFA Verification Flow" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span>
<em>Overview of Verification Flow</em></p>
<h2 id="enforcement-via-row-level-security">Enforcement via Row Level Security</h2>
<p>Using MFA without enforcing it is like buying an expensive door and never locking it. We love Postgres RLS at Supabase. To support RLS integration, JWTs issued by Supabase Auth now contain two additional pieces of information:</p>
<ol>
<li>An Authenticator Assurance Level (AAL) claim. Use this to quickly identify the level of identity checks the user has performed. <code>aal1</code> is reserved for conventional sign in, while <code>aal2</code> is issued only after the user has verified with an additional factor.</li>
<li>An Authenticator Method Reference (AMR) claim. Use this to identify all of the authentication methods used by the user. This is also useful if you wish to implement step-up login scenarios.</li>
</ol>

<p>The information encoded in these claims can be used for both full enforcement and partial enforcement across database queries.</p>

<p><em>Enforce MFA for all end users</em></p>

<p><em>Enforce MFA for selected users</em></p>
<p>Note that both RLS policies are restrictive. By default, overlapping policies in PostgreSQL are permissive rather than restrictive. This means that RLS policies are combined with an <code>OR</code> clause and only one policy needs to pass in order for a row to be operated on. Therefore, we set RLS policies as restrictive to enforce the checks from multiple policies.</p>
<p>Be mindful of your user’s preference, though. If a user has enabled MFA, they are expecting a higher level of security for their account. Consequently, we recommend that developers enforce MFA across all operations if a user has MFA enabled. You can check out <a href="https://supabase.com/docs/guides/auth/auth-mfa">our MFA guide</a> for more details about MFA enforcement.</p>
<h2 id="whats-next">What&#39;s Next</h2>
<p>For starters, we are looking to support WebAuthn and FIDO2 compliant devices such as Yubikeys. We also hope to allow users to receive email notifications when selected MFA actions are triggered. If you have MFA requirements which are not covered here feel free to write to us at support[at]supabase.io .</p>
<p>We are grateful to our early MFA users for the support and feedback provided throughout this period. In particular, we would like to thank <a href="https://madebyfabian.com">Fabian Beer</a>, <a href="https://www.cogram.com">Cogram</a>, and <a href="https://happl.com">Happl</a> whose detailed feedback helped to shape our implementation. We would also like to specially thank the community behind the <a href="https://github.com/pquerna/otp">pquerna/otp</a> and <a href="https://github.com/ajstarks/svgo">ajstarks/svgo</a> libraries - their work is indispensable to this implementation.</p></div></article></div>
  </body>
</html>
