<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/supabase-vault">Original</a>
    <h1>Supabase Vault</h1>
    
    <div id="readability-page-1" class="page"><article><div><p>Today we&#39;re announcing <a href="https://github.com/supabase/vault">Supabase Vault</a>, a Postgres extension for managing secrets and encryption inside your database.
Vault is a thin usability-layer on top of <a href="https://github.com/michelp/pgsodium">pgsodium</a>.</p><p>Vault is not available on the Supabase platform yet. We&#39;re finalizing usability and security testing.
This release is intended to gather user-feedback from our community and customers.</p><p>Soon, we&#39;ll release a blog post that describes more about the technology behind Vault - <a href="https://doc.libsodium.org/">libsodium</a> and
<a href="https://doc.libsodium.org/">pgsodium</a>. For now, we will go through a quick example of storing a secret, like a service access token, into the Vault.</p><h2 id="background">Background</h2><p>Until now, the industry-standard for PostgreSQL encryption is a built-in extension called <a href="https://www.postgresql.org/docs/current/pgcrypto.html"><code>pgcrypto</code></a>.
Like most cloud providers, Supabase offers <code>pgcrypto</code> for developers to use in their applications. <code>pgcrypto</code> has been around for a long time,
and while it supports some basic encryption and decryption abilities, it lacks features like public key signing, key derivation APIs, streaming encryption,
and other modern features required by security-first applications.</p><h3 id="problems-with-raw-keys">Problems with raw keys</h3><p>Databases often store sensitive information, and they need tools that guarantee this data is stored and backed-up in an encrypted form.
A fundamental issue with <code>pgcrypto</code> is that it lacks the ability to derive keys from outside of SQL. Instead you must have the raw encryption key for the algorithm you wish to use:</p><pre></pre><p>pgcrypto works with <em>raw</em> keys. In order to encrypt the data with pgcrypto you must pass the key directly to the encryption function.
Leaking those raw keys is all too easy - logs, files, clients, tables, replication streams - you name it.
Wouldn&#39;t it be great if you could encrypt data, but instead of specifying the raw key you reference it indirectly, like with a key ID?</p><h2 id="supabase-vault">Supabase Vault</h2><p>Supabase Vault allows you to store secrets without leaking any sensitive information.</p><p>The Vault is a good place to put things like API keys, access tokens, and other secrets from external services that you need to access within your database.
The core of the Supabase Vault is a table with some metadata and an encrypted text column where you can put your secrets and any metadata related to them.</p><p>We take the pain out of key management by pre-generating a unique, per-database key that is used by default - a “root” key - which is stored outside of the SQL language,
accessibly only internally in the Postgres server by the libsodium library. This root key is managed by the <a href="https://github.com/michelp/pgsodium">pgsodium</a> Postgres extension
when the server boots using <a href="https://github.com/michelp/pgsodium#server-key-management">Server Key Management.</a></p><p>pgsodium provides an Encryption and Key Derivation API based on the <a href="https://libsodium.gitbook.io/doc/">libsodium library</a> and can get it&#39;s root key from a
variety of sources depending on how you configure it. Supabase generates and preserves your project&#39;s root key behind the scenes, so you don&#39;t have to worry about it.
If you install pgsodium locally the default is to generate a random root key from the <code>/dev/urandom</code> device which is then saved in a file in your Postgres data directory.</p><p>Installing the <code>vault</code> extension is the same as any other Postgres extension:</p><pre></pre><p>Once enabled, you can insert secrets into the <code>vault.secrets</code> table:</p><pre></pre><p>Now when you look in the <code>vault.secrets</code> table, the secret is encrypted:</p><pre></pre><pre></pre><p>Notice how the row has a <code>key_id</code> column. This is the <em>ID</em> of the internally derived key that is used to encrypt the secret, not the key itself.
The actual raw key is not available to you in SQL, it is managed entirely outside of the SQL language in the Postgres server.</p><p>At Supabase, we manage this key for your project automatically and generate a unique default Key ID for you in the <code>secrets</code> table.
For self-hosting, pgsodium <a href="https://github.com/michelp/pgsodium#server-key-management">supports a variety of ways</a> to place the root key into Postgres.</p><p>To see the decrypted data, there is a special view created called <code>vault.decrypted_secrets</code>:</p><pre></pre><pre></pre><p>Now you can see a new <code>decrypted_secret</code> column that contains the decrypted secret we originally inserted into the table.
This <code>vault.decrypted_secrets</code> view automatically decrypts rows in the <code>vault.secrets</code> table “on-the-fly” as you query them, but the secret is stored on disk in <em>encrypted</em> form.
If you take a backup, or pause your project, that data remains encrypted. We will keep your hidden root key safe in our backend systems for when you need to restore or un-pause your projects.</p><p>If you wish to use your own Key ID for different secrets, insted of the default Key ID we&#39;ve generated, you can create one using the <code>pgsodium.create_key()</code> function:</p><pre></pre><pre></pre><p>Now you can encrypt table secrets with this new key by inserting its ID explicitly:</p><pre></pre><pre></pre><p>The type of encryption used by the Vault is called <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">Authenticated Encryption with Associated Data</a>.
The data you insert into the <code>associated</code> column, which is up to you, is combined with the encrypted text when libsodium creates the authentication signature for the secret.
This means that when you read the secret, you know that the associated data is also authentic. The associated data could be an account ID or some
information that ties your system to the secret. And as always, you can refer to rows in the secrets table by their primary key UUID.</p><p>If you only want to store secrets that you know are encrypted on disk and in backups, then all you need to know is shown above. Just insert secrets into the table,
optionally creating new keys, and select them from the view when you want to use them.</p><h2 id="going-beyond-the-vault">Going Beyond the Vault</h2><p>The Vault is good for a reasonable amount of secure data, like API keys, access tokens, or environment variables.
But if you have a lot more sensitive information, like personally Identifiable Information (PII),
you may want to break them out into side-tables using pgsodium&#39;s
<a href="https://github.com/michelp/pgsodium#transparent-column-encryption">Transparent Column Encryption</a> which we will describe soon in a follow-up blog post. Stay tuned!</p></div></article></div>
  </body>
</html>
