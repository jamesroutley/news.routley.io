<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.shalerb.org/">Original</a>
    <h1>Show HN: Shale â€“ a Ruby object mapper and serializer for JSON, YAML and XML</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <p>
        <strong>Shale</strong> is a Ruby object mapper and serializer for JSON, YAML and XML.
      </p>

      <p>
        It allows you to parse JSON, YAML and XML data and convert it into Ruby data structures,
        as well as serialize data structures into JSON, YAML or XML.
      </p>

      

      <p>
        Working with data serialization formats directly can be painfull.
        This is especially true for XML. Let&#39;s consider this simple example of adding an
        address to a person using <code>Nokogiri</code>:
      </p>

      <div>
        <div>
          <p>require &#39;nokogiri&#39;

doc = Nokogiri::XML(&lt;&lt;~XML)
  &lt;person&gt;&lt;/person&gt;
XML

address = Nokogiri::XML::Node.new(&#39;address&#39;, doc)

street = Nokogiri::XML::Node.new(&#39;street&#39;, doc)
street.content = &#39;Oxford Street&#39;
address.add_child(street)

city = Nokogiri::XML::Node.new(&#39;city&#39;, doc)
city.content = &#39;London&#39;
address.add_child(city)

doc.root.add_child(address)
puts doc.to_xml
          </p>
        </div>
        </div>

      <p>
        That&#39;s a lot of code for very simple use case.
        Anything more complex and code complexity increases exponentially
        leading to a maintanace problems and errors.
      </p>

      <p>
        With Shale you can use Ruby objects to work with data
        converting it to/from JSON, YAML or XML.
      </p>

      <p>
        Let&#39;s convert the same example to Shale:
      </p>

      <div>
        <div>
          <p>require &#39;shale&#39;

class Address &lt; Shale::Mapper
  attribute :street, Shale::Type::String
  attribute :city, Shale::Type::String
end

class Person &lt; Shale::Mapper
  attribute :address, Address
end

person = Person.from_xml(&#39;&lt;person&gt;&lt;/person&gt;&#39;)
person.address = Address.new(street: &#39;Oxford Street&#39;, city: &#39;London&#39;)

puts person.to_xml
          </p>
        </div>
        </div>

      <p>
        That&#39;s much simpler and it stays simple when the code complexity increases.
      </p>

      <h2 id="prerequisites">
        <a href="#prerequisites">#</a> Prerequisites
      </h2>

      <ul>
        <li>
          <a href="https://www.ruby-lang.org" target="_blank" rel="noopener noreferrer">
            Ruby 2.7+
          </a>
        </li>
        <li>
          <a href="https://nokogiri.org" target="_blank" rel="noopener noreferrer">
            Nokogiri
          </a>
          (Optional)
        </li>
        <li>
          <a href="https://github.com/ohler55/ox" target="_blank" rel="noopener noreferrer">
            Ox
          </a>
          (Optional)
        </li>
      </ul>

      <p>
        Shale doesn&#39;t have external dependencies. It uses standard library&#39;s
        <code>JSON</code>, <code>YAML</code> and <code>REXML</code> parsers by default.
      </p>

      <p>
        If you need more performant solutions you can use custom libraries.
        Out of the box, Shale provides adapters for <code>Nokogiri</code> and <code>Ox</code>
        - <a href="#adapters">see how to use them</a>.
      </p>

      <h2 id="features">
        <a href="#features">#</a> Features
      </h2>

      <ul>
        <li>Convert JSON, YAML and XML to Ruby data model</li>
        <li>Convert Ruby data model to JSON, YAML and XML</li>
        <li>Generate JSON and XML Schema from Ruby models</li>
        <li>Compile JSON Schema into Ruby models</li>
        <li>Out of the box support for JSON, YAML, Nokogiri, REXML and Ox parsers</li>
        <li>Support for custom adapters</li>
      </ul>

      <h2 id="installation">
        <a href="#installation">#</a> Installation
      </h2>

      <p>Add this line to your application&#39;s Gemfile:</p>

      

      <p>And then execute:</p>

      

      <p>Or install it yourself as:</p>

      

      <h2 id="convert-data-to-ruby">
        <a href="#convert-data-to-ruby">#</a> Convert data to Ruby
      </h2>

      <p>
        Converting data to Ruby is as simple as defining model classes and calling
        <code>from_&lt;format&gt;</code> method on this class.
        e.g. <code>Person.from_json(json_doc)</code>
      </p>

      

      <h2 id="convert-ruby-to-data">
        <a href="#convert-ruby-to-data">#</a> Convert Ruby to data
      </h2>

      <p>
        To convert Ruby to data just define model class, initialize object and call
        <code>to_&lt;format&gt;</code> method on it.
        e.g. <code>Person.new(name: &#39;John Doe&#39;).to_json</code>
      </p>

      

      <h2 id="custom-mappings">
        <a href="#custom-mappings">#</a> Custom mappings
      </h2>

      <p>
        When you define a class and add attributes, underneath Shale creates an implicit mapping
        of keys (for JSON/YAML) and elements (for XML) to attributes.
        That is nice for setting up your data model quickly, but usually your data format doesn&#39;t
        match your data model so cleanly.
      </p>

      <p>
        That&#39;s why you can explicitly map keys, element, attributes from your
        data format to attributes on you Ruby model.
      </p>

      

      <p>
        XML is more complicated format.
      </p>

      <ul>
        <li>To map XML element use <code>map_element</code></li>
        <li>To map XML attribute use <code>map_attribute</code></li>
        <li>
          To map XML text node use <code>map_content</code>
          (it will map first text node of an element)
        </li>
        <li>To change the name of the root element use <code>root</code></li>
      </ul>

      

      <h2 id="using-xml-namespaces">
        <a href="#using-xml-namespaces">#</a> Using XML namespaces
      </h2>

      <p>
        To map namespaced elements and attributes use
        <code>namespace</code> and <code>prefix</code> properties on
        <code>map_element</code> and <code>map_attribute</code>
      </p>

      <p>
        To define default namespace for all elements use <code>namespace</code> declaration
        (this will define namespace only on elements, if you want to define
        namespace on an attribute, explicitly declare it on <code>map_attribute</code>).
      </p>

      

      <h2 id="using-methods">
        <a href="#using-methods">#</a>
        Using methods to extract and generate data
      </h2>

      <p>
        If you need full controll over extracting and generating data you can use methods to do so.
      </p>

      

      <h2 id="pretty-printing">
        <a href="#pretty-printing">#</a>
        Pretty printing and XML declaration
      </h2>

      <p>
        By default generated JSON and XML are compacted. If you need human readable format use
        <code>:pretty</code> parameter on <code>#to_json</code> and <code>#to_xml</code>
      </p>

      <div>
        <div>
          <p>person.to_json(:pretty)
# =&gt;
#
# {
#   &#34;name&#34;: &#34;John Doe&#34;,
#   &#34;address&#34;: {
#     &#34;city&#34;: &#34;London&#34;
#   }
# }
          </p>
        </div>
        </div>

      <p>
        You can also add an XML declaration by passing
        <code>:declaration</code> to <code>#to_xml</code>
      </p>

      <div>
        <div>
          <p>person.to_xml(:pretty, :declaration)
# =&gt;
#
# &lt;?xml version=&#34;1.0&#34;?&gt;
# &lt;Person&gt;
#   &lt;Address city=&#34;London&#34;/&gt;
# &lt;/Person&gt;
          </p>
        </div>
        </div>

      <h2 id="generating-json-and-xml-schema">
        <a href="#generating-json-and-xml-schema">#</a>
        Generating JSON and XML Schema
      </h2>

      <div>
        <p>WARNING</p>
        <p>Shale only supports <strong>Draft 2020-12</strong> JSON Schema</p>
      </div>

      <p>
        To generate JSON or XML Schema from you Shale data model use:
      </p>

      

      <p>You can also use a command line tool to do it:</p>

      <div>
        <div>
          <p>
  $ shaleb -i data_model.rb -r Person -p -f json
          </p>
        </div>
        </div>

      <p>or XML Schema:</p>

      <div>
        <div>
          <p>
  $ shaleb -i data_model.rb -r Person -p -f xml
          </p>
        </div>
        </div>

      <p>If you want to convert your own types to Schema types use:</p>

      

      <h2 id="compiling-json-and-xml-schema">
        <a href="#compiling-json-and-xml-schema">#</a>
        Compiling JSON Schema
      </h2>

      <p>
        To compile JSON Schema and generate Ruby data model use:
      </p>

      

      <p>You can also use a command line tool to do it:</p>

      <div>
        <div>
          <p>
  $ shaleb -c -i schema.json -r Person
          </p>
        </div>
        </div>

      <h2 id="supported-types">
        <a href="#supported-types">#</a> Supported types
      </h2>

      <p>
        Shale supports these types out of the box:
      </p>

      <ul>
        <li><code>Shale::Type::String</code></li>
        <li><code>Shale::Type::Integer</code></li>
        <li><code>Shale::Type::Float</code></li>
        <li><code>Shale::Type::Boolean</code></li>
        <li><code>Shale::Type::Date</code></li>
        <li><code>Shale::Type::Time</code></li>
      </ul>

      <p>
        To add your own type extend defina a class and extend it from
        <code>Shale::Type::Value</code> and implement <code>.cast</code> class method.
      </p>

      <div>
        <div>
          <p>require &#39;shale/type/value&#39;

class MyIntegerType &lt; Shale::Type::Value
  def self.cast(value)
    value.to_i
  end
end
          </p>
        </div>
        </div>

      <h2 id="adapters">
        <a href="#adapters">#</a> Adapters
      </h2>

      <p>
        Shale uses adapters for parsing and generating documents.
        By default Ruby&#39;s standard JSON parser is used for handling JSON documents,
        YAML for YAML and REXML for XML.
      </p>
      <p>
        You can change it by providing your own adapter. For JSON and YAML, adapter must implement
        <code>.load</code> and <code>.dump</code> class methods.
      </p>

      <div>
        <div>
          <p>require &#39;shale&#39;
require &#39;multi_json&#39;

Shale.json_adapter = MultiJson
Shale.yaml_adapter = MyYamlAdapter
          </p>
        </div>
        </div>

      <p>
        For XML, Shale provides adapters for most popular Ruby XML parsers:
      </p>

      <div>
        <p>WARNING</p>
        <p>Ox parser doesn&#39;t support XML namespaces</p>
      </div>

      <div>
        <div>
          <p>require &#39;shale&#39;

# REXML is used by default:
require &#39;shale/adapter/rexml&#39;
Shale.xml_adapter = Shale::Adapter::REXML

# if you want to use Nokogiri:
require &#39;shale/adapter/nokogiri&#39;
Shale.xml_adapter = Shale::Adapter::Nokogiri

# or if you want to use Ox:
require &#39;shale/adapter/ox&#39;
Shale.xml_adapter = Shale::Adapter::Ox
          </p>
        </div>
        </div>

    </div></div>
  </body>
</html>
