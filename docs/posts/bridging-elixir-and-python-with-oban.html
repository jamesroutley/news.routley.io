<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://oban.pro/articles/bridging-with-oban">Original</a>
    <h1>Bridging Elixir and Python with Oban</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>What choices lay before you when your Elixir app needs functionality that only exists, or is more
mature, in Python? There are machine learning models, PDF rendering libraries, and audio/video
editing tools without an Elixir equivalent (yet). You could piece together some HTTP calls, or
bring in a message queue...but there&#39;s a simpler path through Oban.</p>
<p>Whether you&#39;re enabling disparate teams to collaborate, gradually migrating from one language to
another, or leveraging packages that are lacking in one ecosystem, having a mechanism to
transparently exchange <em>durable jobs</em> between Elixir <em>and</em> Python opens up new possibilities.</p>
<p>On that tip, let&#39;s build a small example to demonstrate how trivial bridging can be. We&#39;ll call it
&#34;Badge Forge&#34;.</p>
<h2>Forging Badges</h2>
<p>&#34;Badge Forge,&#34; like &#34;<a href="https://oban.pro/articles/weaving-stories-with-cascading-workflows">Fire Saga</a>&#34; before it, is a pair of nouns that <em>barely</em> describes what
our demo app does. But, it&#39;s balanced and why hold back on the whimsy?</p>
<p>More concretely, we&#39;re building a micro app that prints conference badges. The actual PDF
generation happens through <a href="https://weasyprint.org/">WeasyPrint</a>, a Python library that turns HTML and CSS into
print-ready documents. It&#39;s mature and easy to use. For the purpose of this demo, we&#39;ll pretend
that running <a href="https://hexdocs.pm/chromic_pdf/ChromicPDF.html">ChromaticPDF</a> is unpalatable and <a href="https://typst.app/">Typst</a> isn&#39;t available.</p>
<p>There&#39;s no web framework involved, just command-line output and job processing. Don&#39;t fret, we&#39;ll
bring in some visualization later.</p>
<h2>Sharing a Common Database</h2>
<p>Some say you&#39;re cra-zay for sharing a database between applications. We say you&#39;re already
willing to share a message queue, and now the database is your task broker, so why not? It&#39;s
happening.</p>
<p>Oban for Python was designed for interop with Elixir from the beginning. Both libraries read
and write to the same <code>oban_jobs</code> table, with job args stored as JSON, so they&#39;re fully
language-agnostic. When an Elixir app enqueues a job destined for a Python worker (or vice versa),
it simply writes a row. The receiving side picks it up based on the queue name, processes it, and
updates the status. That&#39;s the whole mechanism:</p>
<p><img src="https://oban.pro/images/bridging-with-oban/elixir-python-interop.png" alt="Interop"/></p>
<p>Each side maintains its own cluster leadership, so an Elixir node and a Python process won&#39;t
compete for leader responsibilities. They coordinate through the jobs table, but <a href="https://www.elvispresleytcb.com/">take care of
business</a> independently.</p>
<p>Both sides can also exchange PubSub notifications through Postgres for real-time coordination.
The importance of that tidbit will become clear soon enough.</p>
<h2>Printing in Action</h2>
<p>This is more of a demonstration than a tutorial. We don&#39;t expect you to build along, but we hope
you&#39;ll see how little code it takes to form a bridge.</p>
<p>With a wee config in place and both apps pointing at the same database, we can start generating
badges.</p>
<h3>Enqueueing Jobs</h3>
<p>Generation starts on the Elixir side. This function enqueues a batch of (fake) jobs destined for
the Python worker:</p>
<pre><code translate="no" tabindex="0"><span data-line="1"><span>def</span> <span>enqueue_batch</span><span>(</span><span>count</span> <span>\\</span> <span>100</span><span>)</span> <span>do</span>
</span><span data-line="2">  <span>generate</span> <span>=</span> <span>fn</span> <span>_</span> <span>-&gt;</span>
</span><span data-line="3">    <span>args</span> <span>=</span> <span>%</span><span>{</span>
</span><span data-line="4">      <span>id: </span><span>Ecto.UUID</span><span>.</span><span>generate</span><span>(</span><span>)</span><span>,</span>
</span><span data-line="5">      <span>name: </span><span>fake_name</span><span>(</span><span>)</span><span>,</span>
</span><span data-line="6">      <span>company: </span><span>fake_company</span><span>(</span><span>)</span><span>,</span>
</span><span data-line="7">      <span>type: </span><span>Enum</span><span>.</span><span>random</span><span>(</span><span>~</span>w<span>(</span>attendee speaker sponsor organizer<span>)</span><span>)</span>
</span><span data-line="8">    <span>}</span>
</span><span data-line="9">
</span><span data-line="10">    <span>Oban.Job</span><span>.</span><span>new</span><span>(</span><span>args</span><span>,</span> <span>worker: </span><span>&#34;badge_forge.generator.GenerateBadge&#34;</span><span>,</span> <span>queue: </span><span>:badges</span><span>)</span>
</span><span data-line="11">  <span>end</span>
</span><span data-line="12">
</span><span data-line="13">  <span>1</span><span>..</span><span>count</span>
</span><span data-line="14">  <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>generate</span><span>)</span>
</span><span data-line="15">  <span>|&gt;</span> <span>Oban</span><span>.</span><span>insert_all</span><span>(</span><span>)</span>
</span><span data-line="16"><span>end</span>
</span></code></pre>
<p>Notice the worker name is a string, &#34;badge_forge.generator.GenerateBadge&#34;, matching the Python
worker&#39;s fully qualified name. The job lands in the <code>badges</code> queue, where a Python worker is
listening.</p>
<h3>The Python Side</h3>
<p>The Python worker receives badge requests and generates PDFs using WeasyPrint:</p>
<pre><code translate="no" tabindex="0"><span data-line="1"><span>from</span> <span>oban</span> <span>import</span> <span>Job</span><span>,</span> <span>Oban</span><span>,</span> <span>worker</span>
</span><span data-line="2"><span>from</span> <span>weasyprint</span> <span>import</span> <span>HTML</span>
</span><span data-line="3">
</span><span data-line="4"><span>@</span><span>worker</span><span>(</span><span>max_attempts</span><span>=</span><span>5</span><span>,</span> <span>queue</span><span>=</span><span>&#34;badges&#34;</span><span>)</span>
</span><span data-line="5"><span>class</span> <span>GenerateBadge</span><span>:</span>
</span><span data-line="6">    <span>async</span> <span>def</span> <span>process</span><span>(</span><span>self</span><span>,</span> <span>job</span><span>:</span> <span>Job</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
</span><span data-line="7">        <span>id</span> <span>=</span> <span>job</span><span>.</span><span>args</span><span>[</span><span>&#34;badge_id&#34;</span><span>]</span>
</span><span data-line="8">        <span>name</span> <span>=</span> <span>job</span><span>.</span><span>args</span><span>[</span><span>&#34;name&#34;</span><span>]</span>
</span><span data-line="9">        <span>html</span> <span>=</span> <span>render_badge_html</span><span>(</span><span>name</span><span>,</span> <span>job</span><span>.</span><span>args</span><span>[</span><span>&#34;company&#34;</span><span>]</span><span>,</span> <span>job</span><span>.</span><span>args</span><span>[</span><span>&#34;type&#34;</span><span>]</span><span>)</span>
</span><span data-line="10">        <span>path</span> <span>=</span> <span>BADGES_DIR</span> <span>/</span> <span>f&#34;<span>{</span><span>name</span><span>}</span>.pdf&#34;</span>
</span><span data-line="11">
</span><span data-line="12">        <span># Generate the pdf content</span>
</span><span data-line="13">        <span>HTML</span><span>(</span><span>string</span><span>=</span><span>html</span><span>)</span><span>.</span><span>write_pdf</span><span>(</span><span>path</span><span>)</span>
</span><span data-line="14">
</span><span data-line="15">        <span># Construct a job manually</span>
</span><span data-line="16">        <span>job</span> <span>=</span> <span>Job</span><span>(</span>
</span><span data-line="17">            <span>args</span><span>=</span><span>{</span><span>&#34;id&#34;</span><span>:</span> <span>id</span><span>,</span> <span>&#34;name&#34;</span><span>:</span> <span>name</span><span>,</span> <span>&#34;path&#34;</span><span>:</span> <span>str</span><span>(</span><span>path</span><span>)</span><span>}</span><span>,</span>
</span><span data-line="18">            <span>queue</span><span>=</span><span>&#34;printing&#34;</span><span>,</span>
</span><span data-line="19">            <span>worker</span><span>=</span><span>&#34;BadgeForge.PrintCenter&#34;</span><span>,</span>
</span><span data-line="20">        <span>)</span>
</span><span data-line="21">
</span><span data-line="22">        <span># Use the active Oban instance and enqueue the job</span>
</span><span data-line="23">        <span>await</span> <span>Oban</span><span>.</span><span>get_instance</span><span>(</span><span>)</span><span>.</span><span>enqueue</span><span>(</span><span>job</span><span>)</span>
</span></code></pre>
<p>When a job arrives, it pulls the attendee info from the args, renders an HTML template, and writes
the PDF to disk. After completion, it enqueues a confirmation job back to Elixir.</p>
<h3>The Elixir Side</h3>
<p>The Elixir side listens for confirmations and prints the result:</p>
<pre><code translate="no" tabindex="0"><span data-line="1"><span>defmodule</span> <span>BadgeForge.PrintCenter</span> <span>do</span>
</span><span data-line="2">  <span>use</span> <span>Oban.Worker</span><span>,</span> <span>queue: </span><span>:printing</span>
</span><span data-line="3">
</span><span data-line="4">  <span>require</span> <span>Logger</span>
</span><span data-line="5">
</span><span data-line="6">  <span><span>@<span><span>impl <span>Oban.Worker</span></span></span></span></span>
</span><span data-line="7">  <span>def</span> <span>perform</span><span>(</span><span>%</span><span>Job</span><span>{</span><span>args: </span><span>%</span><span>{</span><span>&#34;id&#34;</span> <span>=&gt;</span> <span>id</span><span>,</span> <span>&#34;name&#34;</span> <span>=&gt;</span> <span>name</span><span>,</span> <span>&#34;path&#34;</span> <span>=&gt;</span> <span>path</span><span>}</span><span>}</span><span>)</span> <span>do</span>
</span><span data-line="8">    <span>Logger</span><span>.</span><span>info</span><span>(</span><span>&#34;Printing badge <span>#{</span><span>id</span><span>}</span> for <span>#{</span><span>name</span><span>}</span>: <span>#{</span><span>path</span><span>}</span>...&#34;</span><span>)</span>
</span><span data-line="9">
</span><span data-line="10">    <span>do_actual_printing_here</span><span>(</span><span>...</span><span>)</span>
</span><span data-line="11">
</span><span data-line="12">    <span>:ok</span>
</span><span data-line="13">  <span>end</span>
</span><span data-line="14"><span>end</span>
</span></code></pre>
<p>With that, there&#39;s two-way communication through the jobs table.</p>
<h2>Sample Output</h2>
<p>To print conference badges you need a conference. You <em>should</em> have a conference. We&#39;re printing
badges for the <em>fictional</em> &#34;Oban Conf&#34; being held this year in Edinburgh. It will be both
<a href="https://www.dailyrecord.co.uk/lifestyle/scottish-tap-water-considered-best-35229754">hydrating</a> and engaging. Kicking off a batch of ten jobs from Elixir:</p>
<pre><code translate="no" tabindex="0"><span data-line="1"><span>iex</span><span>&gt;</span> <span>BadgeForge</span><span>.</span><span>enqueue_batch</span><span>(</span><span>10</span><span>)</span>
</span><span data-line="2"><span>:ok</span>
</span></code></pre>
<p>On the Python side, we see automatic logging for each job with output like this (output has been
prettified):</p>
<pre><code translate="no" tabindex="0"><span data-line="1">[INFO] oban: {
</span><span data-line="2">  &#34;id&#34;:14,
</span><span data-line="3">  &#34;worker&#34;:&#34;badge_forge.generator.GenerateBadge&#34;,
</span><span data-line="4">  &#34;queue&#34;:&#34;badges&#34;,
</span><span data-line="5">  &#34;attempt&#34;:1,
</span><span data-line="6">  &#34;max_attempts&#34;:20,
</span><span data-line="7">  &#34;args&#34;:{
</span><span data-line="8">    &#34;id&#34;:&#34;7bfb7c39-c354-4cce-ad5b-f1be2814b17e&#34;,
</span><span data-line="9">    &#34;name&#34;:&#34;Alasdair Fraser&#34;,
</span><span data-line="10">    &#34;type&#34;:&#34;speaker&#34;,
</span><span data-line="11">    &#34;company&#34;:&#34;Wavelength Tech&#34;
</span><span data-line="12">  },
</span><span data-line="13">  &#34;meta&#34;:{},
</span><span data-line="14">  &#34;tags&#34;:[],
</span><span data-line="15">  &#34;event&#34;:&#34;oban.job.stop&#34;,
</span><span data-line="16">  &#34;state&#34;:&#34;completed&#34;,
</span><span data-line="17">  &#34;duration&#34;:2.51,
</span><span data-line="18">  &#34;queue_time&#34;:5.45
</span><span data-line="19">}
</span></code></pre>
<p>The job completed successfully, and back in the Elixir app, we see that the print completed:</p>
<pre><code translate="no" tabindex="0"><span data-line="1">[info] Printing badge 7bfb7c39 for Alasdair Fraser: /some/path...
</span></code></pre>
<p>The output looks <em>something</em> like this:</p>
<p><img src="https://oban.pro/images/bridging-with-oban/oban-conf-badge.jpg" alt="Badge Sample"/></p>
<p>Apologies to any &#34;Alasdair Frasers&#34; out there, your name was pulled from the nether and there
isn&#39;t a real conference. As consolation, if you contact us, you have stickers coming.</p>
<h2>Visualizing the Activity</h2>
<p>Seeing jobs in terminal logs is fine, but watching them flow through a dashboard is far more
satisfying. We recently shipped a <a href="https://hexdocs.pm/oban_web/standalone.html">standalone Oban Web</a> Docker image for situations like
this; where you want monitoring without mounting it in your app. It&#39;s also useful when your
primary app is actually Python...</p>
<p>With docker running, point the <code>DATABASE_URL</code> at your Oban-ified database and pull the image:</p>
<pre><code translate="no" tabindex="0"><span data-line="1"><span>docker</span> <span>run</span> <span>-d</span> \
</span><span data-line="2">  <span>-e</span> <span>DATABASE_URL=</span><span>&#34;postgres://user:pass@host.docker.internal:5432/badge_forge_dev&#34;</span> \
</span><span data-line="3">  <span>-p</span> <span>4000:4000</span> \
</span><span data-line="4">  <span>ghcr.io/oban-bg/oban-dash</span>
</span></code></pre>
<p>That starts Oban Web running in the background to monitor jobs from all connected Oban instances.
Queue activity and metrics are exchanged via PubSub, so the Web instance can store them for
visualization. Trigger a few (hundred) jobs, navigate to the dashboard on <code>localhost:4000</code>, and
<a href="https://y.yarn.co/154d07d9-30c8-47d2-af63-f4cc69b0bca8_text.gif">look at &#39;em roll</a>:</p>
<video autoplay="" loop="" muted="" playsinline="" loading="lazy" preload="none">
  <source src="/images/bridging-with-oban/oban-web-bridged.mp4" type="video/mp4"/>
</video>
<h2>Bridging Both Ways</h2>
<p>Badge Forge is whimsical, some say &#34;useless&#34;, but the pattern is practical! When you need tools
that are stronger in one ecosystem, you can bridge it. <em>This goes both ways</em>. A Python app can
reach for Elixir&#39;s strengths just as easily.</p>
<p>Check out the <a href="https://github.com/oban-bg/badge_forge">full demo</a> code for the boilerplate and config we rested over here.</p>

    <hr/>

    <p>
      As usual, if you have any questions or comments, ask in the <a href="https://elixirforum.com">Elixir Forum</a>. For future announcements and insight into
      what we&#39;re working on next, <a href="#subscribe-to-newsletter">subscribe to our
        newsletter</a>.
    </p>
  </article></div>
  </body>
</html>
