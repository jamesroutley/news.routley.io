<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.timescale.com/blog/vector-databases-are-the-wrong-abstraction/">Original</a>
    <h1>Vector databases are the wrong abstraction</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><em>&#34;Your embeddings are out of sync again.&#34;</em></p><p>It&#39;s a message that haunts engineering teams trying to build AI applications. What starts as a simple vector search implementation inevitably evolves into a complex orchestra of monitoring, synchronization, and firefighting.</p><p>We&#39;ve spent the past year talking to dozens of engineering teams building AI systems with vector databases, whether semantic search, retrieval-augmented generation (RAG) systems, or AI agents. We learned that while everything works smoothly for simple applications and PoCs, taking these AI systems into production reveals flawed abstractions with vector databases and the way we use them today. </p><p>Here’s one common thread we heard:</p><p><em>&#34;You&#39;re building a RAG system, and your team uses Pinecone as a vector database to store and search embeddings. But you can&#39;t just use Pinecone—your text data doesn&#39;t fit well into Pinecone&#39;s metadata, so you&#39;re also using DynamoDB to handle those blobs and application data. And for lexical search, you needed OpenSearch. Now you&#39;re juggling three systems, and syncing them is a nightmare.&#34;</em></p><p>It’s easy to see why. Say you delete a source document in your database because it&#39;s outdated. Now you have to:</p><ol><li>Fire up boto3 to remove the record from DynamoDB.</li><li>Remember to update Pinecone to ensure the embedding is deleted.</li><li>Need a POST request to update the lexical search index.</li></ol><p>And you need to do this for every update, addition, or delete to your source documents!</p><p>Managing these configurations isn’t just messy—it’s risky. One missed step, and you&#39;re stuck paying for an index you haven’t used in months. One team recently shared how they ended up paying $2,000 a month for an index that should&#39;ve been deleted four months ago! And that’s not even mentioning the risk of returning incorrect or stale data to your users.</p><p>Sounds familiar? After hearing this pattern repeatedly, we realized something crucial:</p><p><strong>Vector databases are built on the wrong abstraction.</strong></p><p>Vector databases treat embeddings as independent data, divorced from the source data from which embeddings are created, rather than what they truly are: derived data. By treating embeddings as independent data, we’ve created unnecessary complexity for ourselves.</p><p>In this post, we&#39;ll propose a better way: treating embeddings more like database indexes through what we call the <strong>&#34;vectorizer&#34;</strong> abstraction. This approach automatically keeps embeddings in sync with their source data, eliminating the maintenance costs that plague current implementations. </p><p>A vectorizer’s equivalent of the <code>CREATE INDEX</code> command is:</p><pre><code>-- Create a vectorizer to embed data in the blogs table
-- Use Open AI text-embedding-3-small model
SELECT ai.create_vectorizer(
    &#39;public.blogs&#39;::regclass,
    embedding =&gt; ai.embedding_openai(&#39;text-embedding-3-small&#39;, 1536),
    chunking =&gt; ai.chunking_recursive_character_text_splitter(&#39;content&#39;)
);</code></pre><p>This one command will create embeddings for every entry in the blog table and keep updating those embeddings as you change the data in the blog table. In the immortal words of Ina Garten: how easy is that! </p><p>We’ll detail how we implemented this vectorizer abstraction in PostgreSQL in a new open-source tool called <a href="https://github.com/timescale/pgai/blob/main/docs/vectorizer.md?ref=timescale.com"><u>pgai Vectorizer</u></a>, making it work with the open-source <a href="https://github.com/pgvector/pgvector/blob/master/README.md?ref=timescale.com"><u>pgvector</u></a> and <a href="https://github.com/timescale/pgvectorscale/?ref=timescale.com"><u>pgvectorscale</u></a> extensions for vector search. </p><p>We built a vectorizer for PostgreSQL because many developers regard PostgreSQL as the “Swiss army knife” of databases, as it can handle everything from vectors and text data to JSON documents. We think an “everything database” like PostgreSQL is the solution to eliminate the nightmare of managing multiple databases, making it the ideal home for vectorizers and the foundation for AI applications.</p><p>If you&#39;ve ever cursed at stale embeddings or questioned why managing vector search feels needlessly complex, this post is for you.</p><h2 id="the-problem-with-vector-databases-and-vector-data-types">The Problem With Vector Databases (and Vector Data Types)</h2><p>Vector databases were developed as specialized systems to handle large volumes of vector embeddings for text, image, and multi-modal data. And, as the utility of vector embeddings became clearer, many general-purpose databases, like PostgreSQL (with pgvector), MySQL, MongoDB, and even Oracle, added vector search support to their general-purpose offerings either officially or via extensions.</p><p>However, the abstraction of vector search capabilities, either in a standalone system or added to an existing database, suffers from a fatal flaw: once embeddings are inserted into the database, <strong>we lose the connection between the unstructured data that is being embedded and the vector embeddings themselves</strong>.</p><p>Without this connection, embeddings are mistakenly treated as standalone data atoms that developers must manage rather than what they truly are: <strong>derived data</strong>. After all, <a href="https://www.timescale.com/blog/a-beginners-guide-to-vector-embeddings/"><u>vector embeddings are high-dimensional representations of their source data</u></a>, whether the source data be text, images, or something else. There is a fundamental connection between the vector embedding and the source data it is generated from.</p><p>When we reconceptualize embeddings as derived data, the absurdity of the current vector database abstraction becomes evident, with embeddings disconnected from their source data. To handle the demands of a production AI system, even the best teams find themselves juggling multiple databases and managing the following:</p><ul><li>Complex ETL (extract-load-transform) pipelines to chunk, format, and create embeddings from source data</li><li>A vector database for embeddings, another database for metadata and app data, and perhaps even a separate lexical search index</li><li>A data sync service to synchronize across various databases to avoid conflicting sources of truth</li><li>Queuing systems for updates and synchronization</li><li>Monitoring tools to catch data drift and deal with rate limits and other errors from the embedding service</li><li>Alert systems for when searches return stale results</li><li>Validation checks across all these systems</li></ul><p>And what if you want to upgrade to a newer embedding model or try a different chunking method? Now you&#39;re writing custom code and coordinating changes across multiple data services and databases. For example, we’ve heard teams who’ve put off migrating from OpenAI’s <code>text-embedding-ada-002</code> to the newer text-embedding-3 model family for this very reason.</p><p>These tasks place the burden on the development team to ensure that the embeddings are timeously created as source data changes. Otherwise, they risk embeddings frequently becoming stale, leading to a worse application experience for users.</p><p>Thus, even in the best case, teams spend countless hours writing and debugging synchronization logic, setting up infrastructure to handle embedding updates at scale, and firefighting when these systems inevitably break down. </p><h2 id="a-better-way-let-the-database-handle-the-complexity">A Better Way: Let the Database Handle the Complexity </h2><p>When we reconceptualize embeddings as derived data, the <strong>responsibility for generating and updating them as the underlying data changes can be handed over to the database management system</strong>. This change frees developers from the burden of manually keeping embeddings in sync with the source data. (*Cue in collective developer rejoice*)</p><p>This distinction may not seem critical for simple applications that perform a one-time data import for RAG. But for most real-world applications, data is constantly changing. Consider an e-commerce platform that uses embedding-based semantic search across its product catalog, always evolving with new products and updated descriptions. Or a product assistant RAG app that must be kept up to date with the latest product information to give accurate answers to prospective and current customers.</p><p>Manually tracking these changes and regenerating embeddings is not only labor-intensive and error-prone but also distracts developers from focusing on core business objectives. Why waste valuable development time managing this manually when the database system could handle it for you automatically?</p><h2 id="vectorizers-vector-embeddings-as-indexes">Vectorizers: Vector Embeddings as Indexes</h2><p>A more effective abstraction is conceptualizing vector embeddings not as independent tables or data types but as a <strong>specialized index</strong> on the embedded data. This is not to say that vector embeddings are <em>literally</em> indexes in the traditional sense, like those in PostgreSQL or MySQL, which retrieve entire data rows from indexed tables. Instead, vector embeddings function as an indexing mechanism that retrieves the most relevant parts of the data based on its embeddings.</p><p>Rather than indexes, we can call this new index-like abstraction a “<strong>vectorizer</strong>,” as it creates vectors from the underlying source data it is connected to (in other words, vectorizes them). The vectorizer abstraction offers several key advantages:</p><h3 id="automatic-synchronization">Automatic synchronization</h3><p>One of the primary benefits of indexing in databases is that it automatically keeps the index in sync with the underlying data. When the data in a column changes, the index is updated accordingly. By treating vector embeddings as a form of indexing, we can leverage this same automatic synchronization. The system would ensure that vector embeddings are always up-to-date with the latest data, eliminating the need for manual updates and reducing the risk of errors.</p><h3 id="reinforced-data-embedding-relationship">Reinforced data-embedding relationship</h3><p>When vectors are stored independently, it is easy to lose track of their relationship with the original data. Was this vector generated from a recent update to the data? Or is it an outdated vector from a previous embedding model? These questions are critical, and confusion here can lead to significant errors. The relationship is clear and maintained automatically by tying vector embeddings directly to the data as an index.</p><h3 id="simplified-data-management">Simplified data management</h3><p>Developers often face challenges when managing data synchronization manually. For instance, forgetting to delete data from an old embedding model when the underlying data is deleted can cause inconsistencies. The vectorizer abstraction simplifies this process by making it the system’s responsibility to manage these relationships, thus reducing the cognitive load on developers and minimizing the potential for mistakes.</p><h2 id="vectorizers-are-a-natural-evolution-of-the-core-dbms-promise">Vectorizers Are a Natural Evolution of the Core DBMS Promise </h2><p>The vectorizer concept is a natural evolution of modern database management systems (DBMS) capabilities. Today’s DBMSs are already adept at managing data transformations and synchronizations through declarative constructs like indexes, triggers, and materialized views. The vectorizer abstraction fits neatly into this paradigm, providing a new tool for handling the increasingly important task of managing vector embeddings.</p><p>By embedding this functionality directly into the DBMS, we move closer to fulfilling the ultimate promise of database systems: to manage data in a way that abstracts away the complexities, allowing users to focus on what they do best—building applications, analyzing data, and driving innovation.</p><h2 id="implementing-a-vectorizer-for-postgresql-pgai-vectorizer">Implementing a Vectorizer for PostgreSQL: Pgai Vectorizer</h2><p>The good news is that we don’t have to wait long for the vectorizer dream described above to become a reality. Motivated by the promise of making developers’ burdens lighter, our AI Engineering team at Timescale implemented a vectorizer for PostgreSQL. It’s called <a href="https://github.com/timescale/pgai/blob/main/docs/vectorizer.md?ref=timescale.com"><u>pgai Vectorizer</u></a> (currently in Early Access) and is part of the <a href="https://github.com/timescale/pgai?ref=timescale.com"><u>PGAI project</u></a> to make PostgreSQL better for AI systems and make AI development accessible to developers familiar with PostgreSQL.</p><p>If you’d like to see pgai Vectorizer in action, <a href="https://youtu.be/ZoC2XYol6Zk?ref=timescale.com" rel="noreferrer">check out this demo video </a>on how it automatically creates and updates vector embeddings for data in PostgreSQL.</p><figure><iframe width="200" height="113" src="https://www.youtube.com/embed/ZoC2XYol6Zk?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="" title="Auto Create and Sync Vector Embeddings in 1 Line of SQL (pgai Vectorizer)"></iframe></figure><p>For more advanced use cases, here&#39;s how you can use pgai Vectorizer to easily <a href="https://www.timescale.com/blog/which-openai-embedding-model-is-best/"><u>test different embedding models</u></a>, or test which <a href="https://www.timescale.com/blog/which-rag-chunking-and-formatting-strategy-is-best"><u>chunking and formatting strategy fits your data best</u></a>.</p><h3 id="how-pgai-vectorizer-works">How pgai Vectorizer works</h3><p>Let’s move on to some background on how pgai Vectorizer works and how it brings the discussed advantages to life.</p><p>Developers define and create a vectorizer in SQL. The following query creates a vectorizer and specifies the table it acts on, the column to vectorize, the embedding model to use, and additional formatting for other information to include in the source data to be embedded.</p><pre><code>-- Create a vectorizer to automatically embed data in the blogs table
SELECT ai.create_vectorizer(
   &#39;public.blogs&#39;::regclass
   -- Use Open AI text-embedding-3-small model
 , embedding=&gt;ai.embedding_openai(&#39;text-embedding-3-small&#39;, 1536, api_key_name=&gt;&#39;OPENAI_API_KEY&#39;)
   -- Automatically create a StreamingDiskANN index when table has 100k rows
 , indexing =&gt; ai.indexing_diskann(min_rows =&gt; 100000, storage_layout =&gt; &#39;memory_optimized&#39;),
   -- Apply recursive chunking on the content column
 , chunking=&gt;ai.chunking_recursive_character_text_splitter(&#39;content&#39;)
   -- Add metadata from other columns to the embedding for better retrieval
 , formatting=&gt;ai.formatting_python_template(&#39;Blog title: $title url: $url blog chunk: $chunk&#39;)
);
-- The vectorizer will update the embeddings as the source table changes
-- No other user actions are required</code></pre><p>We also define some default chunking functions since long pieces of text need to be split up into multiple smaller chunks to fit inside embedding model token limits.</p><h4 id="tracking-changes-to-source-data">Tracking changes to source data</h4><p>Under the hood, pgai Vectorizer checks for modifications to the source table (inserts, updates, and deletes) and asynchronously creates and updates vector embeddings. Our team built pgai Vectorizer for two deployment types: <a href="https://github.com/timescale/pgai/blob/main/docs/vectorizer-quick-start.md?ref=timescale.com"><u>self-hosted</u></a> and fully managed in <a href="https://console.cloud.timescale.com/signup/?utm_source=blog&amp;utm_medium=website&amp;utm_campaign=vectorlaunch&amp;utm_content=vectorizer-thought-leadership-cta" rel="noreferrer"><u>Timescale Cloud</u></a>.</p><p>In the cloud-hosted implementation of pgai Vectorizer, we use cloud functions in the Timescale Cloud platform to create embeddings. In the open-source version of pgai Vectorizer, embeddings are created by running an external worker.</p><p>Pgai Vectorizer stores the configuration and catalog information along with key internal bookkeeping data inside the database.</p><p>Here’s an overview of the architecture of the pgai Vectorizer system:</p><figure><img src="https://www.timescale.com/blog/content/images/2024/10/Vector-Databases-are-the-wrong-abstraction_pgai_vectorizer_architecture.png" alt="A diagram representing pgai Vectorizer&#39;s system overview." loading="lazy" width="2000" height="1136" srcset="https://www.timescale.com/blog/content/images/size/w600/2024/10/Vector-Databases-are-the-wrong-abstraction_pgai_vectorizer_architecture.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2024/10/Vector-Databases-are-the-wrong-abstraction_pgai_vectorizer_architecture.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2024/10/Vector-Databases-are-the-wrong-abstraction_pgai_vectorizer_architecture.png 1600w, https://www.timescale.com/blog/content/images/size/w2400/2024/10/Vector-Databases-are-the-wrong-abstraction_pgai_vectorizer_architecture.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption><i><em>Pgai Vectorizer automatically creates and updates embeddings from a source data table using work queues and configuration tables housed in PostgreSQL. Embeddings are created in an external worker that interacts with embedding services like the OpenAI API.</em></i></figcaption></figure><h4 id="where-are-embeddings-actually-created">Where are embeddings actually created?</h4><p>An important note is that the actual embedding process occurs outside the database in an external process. This helps reduce the load on the database server and means that vectorizers don’t affect the database’s ability to service application queries. It also makes it easier to scale the embedding task independently of other database operations.</p><p>This process first reads the database to see if there is work to be done. If there is, it reads the data from the database, performs chunking and formatting, makes a call to an embedding model provider, such as OpenAI, to generate the embedding, and writes the result back to the database. </p><h4 id="customizing-the-process">Customizing the process</h4><p>Pgai Vectorizer is flexible: You can specify the chunking and formatting rules used to create embeddings. In particular, you can configure which columns of the source table are to be vectorized and the chunking and formatting rules to ensure the source data fits within embedding token limits and that relevant data is contained within each embedding.</p><p>In the Early Access release of pgai Vectorizer, you can customize the choice of OpenAI embedding model (e.g., <code>text-embedding-3-small, text-embedding-3-large, text-embedding-ada-002</code>), chunking strategies to split text into smaller chunks, formatting options to inject additional context into each chunk, and custom indexing configurations for automated index creation and performance tuning. We plan to make this even more flexible soon by allowing users to submit their own Python code to fully customize chunking, embedding, and formatting.</p><p>For example, here’s a vectorizer configured to split HTML source files recursively and create OpenAI embeddings from the source data. You can configure the chunking and formatting to suit your specific application data, whether it be code, documents, markdown, or anything else.</p><pre><code>-- Advanced vectorizer configuration
SELECT ai.create_vectorizer(
   &#39;public.blogs&#39;::regclass,
   destination =&gt; &#39;blogs_embedding_recursive&#39;,
   embedding =&gt; ai.embedding_openai(&#39;text-embedding-3-small&#39;, 1536),
   -- apply recursive chunking with specified settings for HTML content
   chunking =&gt; ai.chunking_recursive_character_text_splitter(
       &#39;content&#39;,
       chunk_size =&gt; 800,
       chunk_overlap =&gt; 400,
       -- HTML-aware separators, ordered from highest to lowest precedence
       separator =&gt; array[
           E&#39;&lt;/article&gt;&#39;, -- Split on major document sections
           E&#39;&lt;/div&gt;&#39;,    -- Split on div boundaries
           E&#39;&lt;/section&gt;&#39;,
           E&#39;&lt;/p&gt;&#39;,      -- Split on paragraphs
           E&#39;&lt;br&gt;&#39;,      -- Split on line breaks
           E&#39;&lt;/li&gt;&#39;,     -- Split on list items
           E&#39;. &#39;,        -- Fall back to sentence boundaries
           &#39; &#39;          -- Last resort: split on spaces
       ]
   ),
   formatting =&gt; ai.formatting_python_template(&#39;title: $title url: $url $chunk&#39;)
);</code></pre><p>We plan to detail the design decisions which informed our building of pgai Vectorizer in a future blog post.</p><h2 id="try-pgai-vectorizer-today">Try Pgai Vectorizer Today</h2><p>Try pgai Vectorizer now in Early Access. Open source, built for application devs, and ready to simplify your AI workflows. See how much easier embedding management can be—jump in and let us know what you think. Pick your favorite deployment option: <a href="https://console.cloud.timescale.com/signup/?utm_source=blog&amp;utm_medium=website&amp;utm_campaign=vectorlaunch&amp;utm_content=vectorizer-thought-leadership-cta" rel="noreferrer"><u>fully managed on Timescale Cloud</u></a> or <a href="https://github.com/timescale/pgai/blob/main/docs/vectorizer-quick-start.md?ref=timescale.com"><u>self-hosted in your PostgreSQL environment of choice</u></a> (leave us a GitHub ⭐ along the way).</p><p>Why waste your precious development time manually managing embeddings when you could simply hand this over to your database?</p><p>With pgai Vectorizer, you can. It enables you to keep your vector embeddings always up to date, reinforcing the embedding-data relationship and simplifying your data management. PostgreSQL becomes your AI development platform of choice, allowing you to store all your data in one place and automating embedding management. In addition, pgai Vectorizer builds upon other tools in the PGAI suite, like <a href="https://github.com/timescale/pgvectorscale?ref=timescale.com"><u>pgvectorscale</u></a>, which complements pgvector for high-performance vector search, and the <a href="https://github.com/timescale/pgai?ref=timescale.com"><u>pgai</u></a> extension, which brings AI models closer to your data in PostgreSQL. </p><p>Questions or feedback? Join our <a href="https://discord.gg/KRdHVXAmkp?ref=timescale.com"><u>Discord community</u></a>, where our team is ready to help you make the most of pgai Vectorizer and the rest of the tools in the <a href="https://www.timescale.com/ai?ref=timescale.com"><u>PGAI suite</u></a>.</p><h3 id="learn-more">Learn more</h3><p>Learn more about pgai Vectorizer and how it can help you build better AI systems with PostgreSQL in these companion blogs and videos:</p><ul><li><a href="https://www.timescale.com/blog/how-to-automatically-create-update-embeddings-in-postgresql/"><u>How to Automatically Create &amp; Update Embeddings in PostgreSQL — With One SQL Query</u></a></li><li><a href="https://www.timescale.com/blog/which-openai-embedding-model-is-best/"><u>Which OpenAI Embedding Model Is Best for Your RAG App With Pgvector?</u></a></li><li><a href="https://www.timescale.com/blog/which-rag-chunking-and-formatting-strategy-is-best" rel="noreferrer">Which RAG Chunking and Formatting Strategy Is Best for Your AI App With Pgvector?</a></li><li>Watch 🎥: <a href="https://www.youtube.com/watch?v=j2B5fx1p1Ps&amp;ref=timescale.com" rel="noreferrer">What If Vector Embeddings Were Database Indexes?</a></li></ul>
        
      </div></div>
  </body>
</html>
