<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/buck2-basics/">Original</a>
    <h1>buck2 basics</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, August 7, 2023</em></p><p>I just finished an experiment with <a href="https://buck2.build">Buck 2</a> at work. We didn&#39;t end up using it, but it was more for organizational reasons than technical ones. I&#39;ll be watching the project to see if it would make sense to use in the future!</p><p>One thing that held me back during the early part of the experiment was not having enough learning material around the basics. That makes sense: it&#39;s a pretty new project (at least in this iteration) and there are a <em>lot</em> of concepts to learn.</p><p>So instead of teaching things from first principles, I want to run head-first into getting something simple set up. We won&#39;t have any more functionality than we could get with some simple <code>make</code> rules, but since <a href="https://bytes.zone/posts/learning-requires-effort/">the person who does the work does the learning</a> I hope this will be helpful! That said, keep in mind that I&#39;m no expert—just some person who learned enough to get stuff done!</p><h2 id="the-simplest-possible-rule">The Simplest Possible Rule</h2><p>We&#39;ll start off with the simplest possible thing: a file that says &#34;Hello, World!&#34; We&#39;ll use a <code>genrule</code> for this, which lets you say what shell commands to run to produce some file. In the root <code>BUCK</code> file, write this:</p><pre data-lang="python"><code data-lang="python"><span>genrule</span><span>(
</span><span>  </span><span>name </span><span>= </span><span>&#34;some-target&#34;</span><span>,
</span><span>  </span><span>out </span><span>= </span><span>&#34;target-file&#34;</span><span>,
</span><span>  </span><span>cmd </span><span>= </span><span>&#34;echo &#39;Hello, World!&#39; &gt; $OUT&#34;</span><span>,
</span><span>)
</span></code></pre><p>That configures a target named <code>some-target</code> that you can build with <code>buck2 build //:some-target</code>. If you add <code>--show-output</code> to that, it&#39;ll tell you where the file is, and if you <code>cat buck-out/v2/gen/root/213ed1b7ab869379/__some-target__/out/target-file</code> (or whatever path Buck gives you) it out it&#39;ll say &#34;Hello, World!&#34; First build done. Yay!</p><p>So what do all the parts in that rule mean?</p><ul><li><code>genrule(…)</code> is the rule you&#39;re calling. I think &#34;gen&#34; here is short for &#34;generic&#34; (or maybe &#34;generate&#34;?) Anyway, it&#39;s the simplest thing that the build system can possibly do.</li><li><code>name</code> defines how you&#39;ll refer to this target from other rules or from the CLI. See <a href="https://buck2.build/docs/concepts/target_pattern/">the target pattern docs</a>, which also explain why you refer to this as <code>//:some-target</code>.</li><li><code>out</code> is the file that will be produced by the rule</li><li><code>cmd</code> is the command that will be run to produce the file. <code>$OUT</code> looks like an environment variable reference, but as far as I can tell Buck is actually interpolating it into the string before calling the command. <a href="https://buck2.build/docs/api/rules/#genrule">The docs for <code>genrule</code> have some examples of other variables you can use</a>.</li></ul><h2 id="more">More!</h2><p>Next, let&#39;s chain two rules together. Here&#39;s another rule in the same file:</p><pre data-lang="python"><code data-lang="python"><span>genrule</span><span>(
</span><span>  </span><span>name </span><span>= </span><span>&#34;yelling-target&#34;</span><span>,
</span><span>  </span><span>out </span><span>= </span><span>&#34;target-file&#34;</span><span>,
</span><span>  </span><span>cmd </span><span>= </span><span>&#34;tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; &lt; $(location :some-target) &gt; $OUT&#34;</span><span>,
</span><span>)
</span></code></pre><p>The new thing here is <code>$(location ...)</code>, which interpolates the location of some the output of the named target into the command line.</p><blockquote><p>[!aside] I had a hard time finding out if there was anything else like <code>location</code> that I could use. It turns out that the call there is actually a lookup for the &#34;location&#34; attribute on the target inside Buck&#39;s build graph. That means different rules will produce different things! But generally speaking, <code>location</code> will work for files in general and <code>executable</code> will work for files that you need to run.</p></blockquote><p>Now if you build everything and go look at the output (using <code>--show-output</code>), you will get a new file that says &#34;HELLO, WORLD!&#34;. If you change the original rule, the new one will get built too.</p><p>So with these two rules (plus the thing in <code>toolchain</code>), you can:</p><ul><li>Run <code>buck2 build //...</code> to build both targets</li><li>Run <code>buck2 build //:some-target</code> to build only the &#34;Hello, World!&#34; file.</li><li>Run <code>buck2 build //:yelling-target</code> to build the &#34;HELLO, WORLD!&#34; file, which will build <code>:some-target</code> as well, if necessary.</li></ul><p>Try changing things around (for example by changing the message) and seeing what happens. You can also run <code>buck clean</code> to remove the targets to get a fresh build.</p><p>Next time, we&#39;ll talk about moving these from <code>genrule</code>s into a library that we can import and call.</p></article></div>
  </body>
</html>
