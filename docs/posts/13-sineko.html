<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0013-sineko/">Original</a>
    <h1>13. sineko</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2023-12-08</p>

<p>In my post from <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/">yesterday</a> I forgot to mention one small project I also recently did at <a href="https://www.recurse.com">Recurse</a>. We had an activity called &#34;Impossible Stuff Day&#34; where we were invited to come up with an &#34;impossible&#34; project and then work on it for one day. The idea of this is to challenge your own notions of what is and isn&#39;t possible.</p>

<p>My main project at the time was <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/#daisyx7">DaisyX7</a> and I thought to myself: can I run this synthesis engine inside the Linux kernel? It doesn&#39;t make sense (to me anyway) but I thought it was a fun idea.</p>

<p>The DX7 synthesis engine is based on sine waves so I figured the first step was to generate a sine wave. I looked a bit into how audio work in Linux (the foundation layer seems to be <a href="https://www.alsa-project.org/wiki/Main_Page">Alsa</a>) but interacting with that from within the kernel looked complicated. In order to run code in the kernel, my first thought was <a href="https://ebpf.io/">eBPF</a> because it is an in-vogue technology but thinking about it longer it made more sense to try and make a <a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">Linux kernel module</a>. This would allow me to compile and run just my code and not the entire kernel every time. Unlike eBPF, however, my code could do whatever it wants.</p>

<p>Looking into kernel modules I stumbled into this amazing online book: <a href="https://sysprog21.github.io/lkmpg/">The Linux Kernel Module Programming Guide (&#34;LKMPG&#34;)</a>. It is an introduction to writing kernel modules with examples you can compile and run yourself. In one of the early chapters, the book shows you how to create a Linux character device (<code>/dev/foobar</code>).</p>

<p>This helped me narrow down what I was going to do next. I would make a kernel module <code>sine.ko</code> which would generate raw PCM audio data that you could read from <code>/dev/sine</code>. If you want to see the code now you can skip ahead to <a href="https://github.com/jacobvosmaer/sineko/">GitHub</a> to look at the &#34;sineko&#34; project.</p>

<p>So why did I want to create raw PCM audio data? At first I thought of generating a WAV file but it seems those contain length information and I did not want to have t o worry about how to communicate to the kernel how much data it should generate. An endless sine wave seemed simpler. I could then read that data in userspace and send it back to the kernel using the <a href="https://linux.die.net/man/1/play"><code>play</code> command from SoX</a>.</p>

<p>Thanks to the LKMPG book I could create my <code>/dev/sine</code> device quite easily, but I then had to generate the sine wave data instead of &#34;Hello world&#34;. This led to another obstacle. My limited experience with DSP so far has been on the <a href="https://www.electro-smith.com/daisy">Daisy</a> platform. The <a href="https://github.com/electro-smith/libDaisy">Daisy hardware abstraction library</a> provides audio callbacks that use floating point values (C <code>float</code>s). This works out because the microcontroller (MCU) of the Daisy can do floating point operations. (It&#39;s an <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32h750-value-line.html">STM32H7</a>.)</p>

<p>While the hardware I was targeting with my Linux kernel (amd64) also supports floating point instructions, the Linux kernel is not keen on letting you use them. If I understand correctly the reason for this is that the floating point unit (FPU) has its own register state, and by banning FPU instructions in the kernel, Linux avoids having to save and restore FPU register state on each context switch. There are ways around this but they looked very fidgety to me.</p>

<p>This opened an interesting new can of worms. I know from reading (for example <a href="https://www.righto.com/2021/12/yamaha-dx7-reverse-engineering-part-iii.html">here</a>) that you can implement a sine function using a lookup-table. But how do I do that? How many entries should the table have? Luckily I found <a href="https://github.com/torvalds/linux/blob/master/include/linux/fixp-arith.h"><code>linux/fixp-arith.h</code></a> inside the kernel source code, which includes sine functions. The implementation contains a look-up table so this solved my problem of having to make my own.</p>

<p>With this I was able to have <code>/dev/sine</code> generate raw PCM data for a sine wave at 220Hz. Not long after this I ran out of time for what I could do in one day.</p>

<p>While I don&#39;t see myself &#34;finishing&#34; this project, it was a lot of fun because I got to learn about Alsa, kernel modules, FPU&#39;s and fixed point arithmetic.</p>

<p><a href="https://github.com/jacobvosmaer/sineko/">Source code on GitHub</a>.</p>
<p>Tags:
<a href="https://blog.jacobvosmaer.nl/recurse.html">recurse</a>
</p><details><summary>Edit history</summary><table>
<tbody><tr><td>2023-12-08</td><td></td><td>Remove embedded dates in favor of meta.json</td></tr>
<tr><td>2023-12-08</td><td></td><td>Add dates to header</td></tr>
<tr><td>2023-12-08</td><td></td><td>Add 0013-sineko</td></tr>
</tbody></table></details><p><a href="https://blog.jacobvosmaer.nl/">Back</a></p>
</div></div>
  </body>
</html>
