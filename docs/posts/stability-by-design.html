<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://potetm.com/devtalk/stability-by-design.html">Original</a>
    <h1>Stability by Design</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>I recently came across the following tweet from OneHappyFellow<a href="#footnote-1" id="return-1"><sup>1</sup></a>:</p> <blockquote> <p lang="en" dir="ltr"> I think I figured out what’s stressing me out about programming in dynamically typed languages:</p> — One Happy Fellow (@onehappyfellow) <a href="https://twitter.com/onehappyfellow/status/1919362152487415839?ref_src=twsrc%5Etfw"> May 5, 2025 </a> </blockquote> <p>I found this tweet interesting because the language I use the most—Clojure—is both dynamic and yet the ecosystem has a <em>very</em> strong reputation for stability. Before diving into why exactly this is the case, allow me to present some evidence to justify this belief.</p> <h2>Are Clojure Libraries Stable?</h2> <p>I searched the <a href="https://clojurians.slack.com/">Clojurians Slack</a> for the word &#34;stability,&#34; and out of 20 total posts on the first page, 8 are applauding the stability that Clojure brings. This slack is the main forum for Clojurians, and it includes discussions about various libraries, bugs, fixes, etc, therefore one would reasonably expect stability <em>complaints</em> to dominate the discussion. My search is obviously not a random sampling, but it should give you an idea of how much the community appreciates and celebrates stability.</p> <p>As further evidence, consider the following two charts from <a href="https://docdrop.org/download_annotation_doc/3386321-trk2f.pdf"><em>A History of Clojure</em></a> which detail the introduction and retention of new code by release for both Clojure and for Scala.</p> <img id="clojure-code-retention" src="https://potetm.com/img/stability-by-design/clojure-code-retention.webp" alt="Clojure codebase—Introduction and retention of code"/> <sup>Clojure codebase—Introduction and retention of code</sup> <img id="scala-code-retention" src="https://potetm.com/img/stability-by-design/scala-code-retention.webp" alt="Scala codebase—Introduction and retention of code"/> <sup>Scala codebase—Introduction and retention of code</sup> <p>While this doesn&#39;t necessarily translate to <em>library</em> stability, it&#39;s reasonable to assume that the attitude of the Clojure maintainers will seep into the community. And that assumption is true.</p> <p>Let&#39;s look at the retention of code for various popular libraries. I selected the following libraries off the top of my head with three criteria: all have more than 500 stars and are in active use. I could have easily selected more.</p> <div> <p><img id="scala-code-retention" src="https://potetm.com/img/stability-by-design/xforms.png" alt="xforms codebase—Introduction and retention of code"/> <sup>xforms codebase—Introduction and retention of code</sup> </p> <p><img id="scala-code-retention" src="https://potetm.com/img/stability-by-design/component.png" alt="Component codebase—Introduction and retention of code"/> <sup>Component codebase—Introduction and retention of code</sup> </p> </div> <div> <p><img id="scala-code-retention" src="https://potetm.com/img/stability-by-design/instaparse.png" alt="Instaparse codebase—Introduction and retention of code"/> <sup>Instaparse codebase—Introduction and retention of code</sup> </p> <p><img id="scala-code-retention" src="https://potetm.com/img/stability-by-design/core-match.png" alt="core.match codebase—Introduction and retention of code"/> <sup>core.match codebase—Introduction and retention of code</sup> </p> </div> <p>Clearly library authors follow in the footsteps of the Clojure maintainers in this regard.</p> <p>The last evidence I will give is anecdotal, but informative. I recently <a href="https://github.com/potetm/fusebox/blob/master/CHANGELOG.md#1010">pushed an update</a> to my fault tolerance library, <a href="https://github.com/potetm/fusebox">Fusebox</a>. This update came about because of a quirk in the retry utility. Whenever an exception is thrown, the exception is wrapped with metadata from the retry utility (e.g. how many retries happened) and then re-thrown.</p> <p>A fusebox user, Martin Kavalar, recently requested that the exception be wrapped only if a retry actually happened. Not only was this a reasonable request, but this probably should have been the behavior from the beginning. I would even go so far as to call this a bug.</p> <p>However, this is a bug that people have dealt with. They&#39;ve written their code in such a way as to handle this bug. In other words, if I were to do the &#34;right&#34; thing and &#34;fix&#34; the bug, I would be breaking <em>somebody else&#39;s</em> code.</p> <p>I told Martin as much, and he agreed without hesitation that we needed to find a solution that didn&#39;t break current users&#39; code. This is <em>not</em> a normal interaction amongst software engineers—a breed infamous for their long, drawn out debates on the most minute of details. However, this is absolutely expected in the Clojure community.</p> <p>Having given the evidence that, in practice, Clojure libraries tend to be very stable, the question becomes, &#34;How is this possible?&#34; On the surface, OneHappyFellow&#39;s reasoning makes sense: static types tell you when a breaking change has occurred, therefore they make the upgrade process much easier. The answer to this riddle has two parts.</p> <h2>What Makes Clojure Different?</h2> <p>In short, Clojure is—by convention—the most static dynamic language in existence.</p> <p>In his twitter thread, OneHappyFellow argues a couple of smaller points: dynamic language serialization <a href="https://x.com/onehappyfellow/status/1919362154722889782">is busted</a>, and monkey patching makes it a nightmare to <a href="https://x.com/onehappyfellow/status/1919362156815892909">pass objects across processes</a>.</p> <p>Consider a typical Javascript program. What is it comprised of? Objects, objects, and more objects. Members of those objects must be either introspected or divined. Worse, it&#39;s normal to monkeypatch those objects, so the object members may (or may not) change over time.</p> <p>Now, consider a typical Clojure program. What is it comprised of? Namespaces. Those namespaces contain functions and data. Functions may be dynamically generated (via macros), but it is <em>extremely</em> rare to &#34;monkeypatch&#34; a namespace.<a href="#footnote-2" id="return-2"><sup>2</sup></a> If you want to know what functions are available in a namespace, you can simply read the source file.</p> <p>What&#39;s more, you <em>never</em> serialize a namespace. That doesn&#39;t even make sense. Rather, you serialize data, and <em>all</em> Clojure data is serializable out of the box. In fact, it&#39;s serialized in the exact same way you write it in your source code, in a format called <a href="https://github.com/edn-format/edn">Extensible Data Notation (EDN)</a>. EDN even lets you to create custom tags that allow you to use custom constructors for data (e.g. for a datetime or a red-black tree).</p> <p>Clojure data has another curious property that makes it more resilient to change: it&#39;s immutable. Once you&#39;re handed a hashmap, you can rest assured that <em>nobody</em> is going to tweak it without your knowing about it. It&#39;s impossible. Calls to <code>assoc</code> and <code>update</code> return a <em>new</em> hashmap rather than updating the existing hashmap.<a href="#footnote-3" id="return-3"><sup>3</sup></a> This means that when you pass data to another process or over the wire, you <em>know</em> the receiver is going to see exactly what you&#39;re seeing.</p> <p>Lastly, I would like to draw your attention to how object members are named in dynamic languages. Typically (meaning, afaik always), they are simple, unadorned symbols like <code>.name</code> for a field or <code>.doSomething()</code> for a function. This naturally leads to ambiguity when, for example, you want to attach two names to something. Take, for instance, a <code>user</code> object. You start with <code>user.name</code>, but then realize you need the organization name. There are multiple options at this point, but one option is to rename <code>user.name</code> to <code>user.username</code> to accommodate for the new field, <code>user.orgName</code>. The problem is, this just created a breaking change.</p> <p>In contrast, Clojure fields are typically given a namespace element. (This concept is related to but distinct from the namespaces we use to house functions.) So whereas <code>user.name</code> is common in Javascript, in Clojure it would look like <code>{:user/name &#34;OneHappyFellow&#34;}</code>. This allows for other kinds of &#34;names&#34; to be seamlessly integrated without breakage:</p> <pre><code>{:user/name &#34;OneHappyFellow&#34;
 :organization/name &#34;OCaml Bois&#34;}
</code></pre> <p>OneHappyFellow&#39;s <a href="https://x.com/onehappyfellow/status/1919362158971727953">final point</a> cuts much deeper, and it requires asking another question.</p> <blockquote> <p lang="en" dir="ltr"> The worst case to me is when I refactor some code only to discover the way I went about it is fundamentally incompatible with some library I’m using.</p> — One Happy Fellow (@onehappyfellow) <a href="https://twitter.com/onehappyfellow/status/1919362158971727953?ref_src=twsrc%5Etfw">May 5, 2025</a> </blockquote> <h2>Why do Library Changes Break Programs?</h2> <p>Well, it&#39;s complicated, but to start, let&#39;s list out the reasons libraries make changes at all:</p> <ul> <li>Security fixes</li> <li>Bug patches</li> <li>Enhancements</li> </ul> <p>Of those changes, I think we can agree, at least in principle, that security fixes and bug patches should be <em>non-breaking</em> changes. Security fixes should basically ~never trigger a breaking change, and while bug patches <em>might</em> break things, they&#39;re typically minor, or they&#39;re marked wontfix.</p> <p>Which leaves &#34;enhancements&#34; as the real booger.</p> <p>&#34;Enhancement&#34; in and of itself don&#39;t mean breakage. After all, adding a new method to an object doesn&#39;t break anything. So what sort of &#34;enhancements&#34; <em>do</em> break things? Well:</p> <ul> <li>renaming method (breaking)</li> <li>renaming a type (breaking)</li> <li>renaming a field (breaking)</li> <li>renaming a package (breaking)</li> <li>changing a method signature (depends)</li> </ul> <p>It&#39;s not difficult to see that the only item in that list that has any semblance of validity is the last one. And here we come to the first hard truth in this article.</p> <p><strong>All this random renaming is <em>killing</em> us.</strong></p> <p>And all of this clamoring for static types? All of the insistence that static types &#34;fix&#34; this problem? It makes it worse. Static types &#34;fix&#34; this problem in the same way brooms fix the problem of you throwing your wine glasses on the kitchen floor. Of course, types make it more bearable, but they are not addressing the issue. Why are you hurling your wine glasses around your house in the first place?</p> <p>Why are we renaming everything all the time?</p> <p>Once you notice this trend, it&#39;s impossible to un-see. We get records out of the database, and what&#39;s the first thing we do? Rename its fields. We then run it through several transformation steps which will invariable rename them again. We then put it on the wire as JSON, and, of course, that requires that we rename them again. We then load them in our SPA and, well the names we got off the wire certainly won&#39;t do. Best rename them one more time.</p> <p>It&#39;s insanity, and yet it is the world we created.</p> <p>And, believe it or not, this is one major reason Clojure programs are so stinkin&#39; stable. We don&#39;t do that. We don&#39;t rename things in our libraries, and when we pull data from somewhere, we do our very best to <em>not</em> rename things.</p> <p>But renaming wasn&#39;t the only thing in the list of &#34;stuff that causes breakages.&#34; What about changing method signatures? To address this, we need to further categorize things. What sorts of changes trigger changing a method signature?</p> <ul> <li>Allowing—but not requiring—more data in the parameters (non-breaking)</li> <li>Requiring more data in the parameters (breaking)</li> <li>Requiring less data in the parameters (non-breaking)</li> <li>Returning more data in the return (depends)</li> <li>Returning less data in the return (breaking)</li> </ul> <p>Of those items, two of them should cause no problems at all. Adding optional inputs to a function is obviously non-breaking.<a href="#footnote-4" id="return-4"><sup>4</sup></a> If you suddenly require fewer inputs—for example you figure out how to solve some partitioning dynamically—that need not be a breaking change. It&#39;s possible that this ends up as a breaking change (e.g. if your function once took three arguments, and now it only takes two), however, at least in principle, if you structure your code a certain way your users need not deal with this change.</p> <p>Returning more data than before is somewhat nuanced. In principle, it shouldn&#39;t be a breaking change. However, if a function returns a new field, and then that data gets written directly to a database that doesn&#39;t have a column for that field, you might get an error (depending on the database). In general, if you make it a practice to select out the data you want prior to transferring it over the wire, you&#39;ll avoid any issues along these lines.</p> <p>The two that you want to <em>always</em> avoid are requiring more inputs and returning less outputs. <em>That&#39;s</em> what breaks user code. If you avoid doing that, you will <em>never</em> break user code.</p> <p>The question arises: What if you figure out a much better way to do things that requires more inputs and returns fewer outputs? The answer is simple: Make a <em>new</em> function for it. New functions do <em>not</em> break user code. New functions are simply new capabilities. They&#39;re great! You don&#39;t even have to edit that old code. You can just rewrite it from scratch!</p> <p>Once again, types are a <em>wonderful</em> enabler in this situation. &#34;Oh I don&#39;t have to worry about requiring more data to this function. The type checker will alert the user.&#34; That&#39;s true, but it doesn&#39;t change the fact that you needn&#39;t make this demand of your users in the first place.</p> <h2>Why are Clojure Libraries Stable?</h2> <p>In short, the Clojure ecosystem is abnormally stable <em>because we avoid breaking things</em>.</p> <p>We don&#39;t rename namespaces. We don&#39;t rename functions. We don&#39;t rename keywords. We neither increase the data we demand, nor do we reduce the data we emit. If we think of a better way to do things, we create a new function, a new namespace, or even a whole new library.</p> <p>It&#39;s worth noting that these activities are not free. Your mindset shifts when you&#39;re aware that you&#39;re going to be carrying some chunk of code for a long time. You become more deliberate, more cognizant of tradeoffs. You learn to watch for patterns that limit growth and patterns that enable growth. For example, over its lifetime the Clojure community has shifted from accepting argument lists and named parameters in their functions to accepting a single hashmap. This is because the single hashmap is easier to grow over time.</p> <p>These principles are already well-known in the developer community. How often do you rename a URL path in your API? Never! How often do you rename a key in your API? Never! Do you ever decide to just return less data? No! Any time you&#39;re tempted to do any of these things, what do you do? You create a <em>new name</em> (usually <code>v2</code>).</p> <p>Why do we do this? Because we know the pain it causes our customers, and we want to help them avoid that pain. Yet, somehow the rules change drastically when dealing with other developers. Suddenly it becomes okay to induce pain.</p> <p>Note that this is not a static vs dynamic issue per se. <em>Any</em> library in <em>any</em> language can easily adopt these principles. However, I often see static type enthusiasts loudly proclaiming the benefits of type checkers by saying, &#34;When I upgrade a library, I know that it&#39;s going to work.&#34; Fair enough. At the very least you know that your code will compile, and you won&#39;t be left wondering what changed and where. What&#39;s left unsaid, however, is the work that goes in to <em>making</em> the upgrade work.</p> <p>Look again at the <a href="#scala-code-retention">Scala code retention chart</a>. How many of the cliffs in that chart represent a <em>lot</em> of work for their users? How much work could have been avoided if, instead, we opted to just not break things?</p> <hr/> <p> <sub> <a href="#return-1" id="footnote-1">1</a>: <a href="https://x.com/onehappyfellow">OneHappyFellow</a> is a great follow btw. </sub> </p> <p> <sub> <a href="#return-2" id="footnote-2">2</a>: The only time I&#39;ve seen it done was when I did it myself for... reasons. If you do something like that to yourself, you can hardly blame a library for subsequent errors. </sub> </p> <p> <sub> <a href="#return-3" id="footnote-3">3</a>: It does this in an <a href="https://en.wikipedia.org/wiki/Persistent_data_structure#Persistent_hash_array_mapped_trie"> efficient way</a> by sharing elements of old structure with the new structure. </sub> </p> <p> <sub> <a href="#return-4" id="footnote-4">4</a>: Coincidentally this is exactly how I ended up resolving Martin&#39;s issue in fusebox. I added an <a href="https://github.com/potetm/fusebox/blob/d9df37f7b327f59aebc12aea06fe4fa159e18951/src/com/potetm/fusebox/retry.clj#L82-L88">optional `::retry/exception` key to the function signature</a>. </sub> </p> <hr/> <p>Thank you to <a href="https://x.com/onehappyfellow">OneHappyFellow</a>, <a href="https://x.com/slimjimmy_dev">Slim Jimmy</a>, and <a href="https://x.com/bostonaholic">Matthew Boston</a> for their input on this article.</p> <p>A special thank you to <a href="https://truegrok.com/">Eugene Pakhomov</a> for giving input on the article and for supplying the stack charts for the Clojure libraries.</p> </article></div></div>
  </body>
</html>
