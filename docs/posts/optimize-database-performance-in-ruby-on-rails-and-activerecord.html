<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2024/10/30/optimize-database-performance-in-ruby-on-rails-and-activerecord.html">Original</a>
    <h1>Optimize Database Performance in Ruby on Rails and ActiveRecord</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>In Rails, we&#39;re more likely to use SQL databases than other frameworks. Unlike NoSQL databases, which can be scaled horizontally with relative ease, SQL databases like PostgreSQL or MySQL are much less amenable to easy scaling.</p>
<p>As a result, our database usually becomes the primary bottleneck as our business grows. Although SQL databases are very efficient, as our growing customer base puts an increasing load on our servers, we begin scaling our instance counts, workers, etc. But we can&#39;t just make copies of our database for each new server we spin up. This makes optimizing database performance critical for any serious Rails project.</p>
<p>In this post, we&#39;ll explore strategies for optimizing performance to minimize the load on our database. We&#39;ll start with some more basic topics like eager loading and the N+1 query problem, database indexing, <code>select</code>, <code>pluck</code>, and immediate loading. Then, we&#39;ll move on to more involved topics like performance profiling, scaling via techniques like database sharding, and background jobs using read replicas.</p>
<p>Let&#39;s get going!</p>
<h2 id="getting-activerecord-n1s-out-of-the-way">Getting ActiveRecord N+1s Out of the Way</h2>
<p>No discussion of database performance involving ActiveRecord (or any ORM) is complete without addressing the <a href="https://blog.appsignal.com/2018/04/24/active-record-performance-the-n-1-queries-antipattern.html">infamous N+1 problem</a>. While most readers are likely familiar with it, it&#39;s still worth revisiting, as N+1 queries can (and do) creep into our projects over time, especially as our codebase evolves and we add or update features.</p>
<p>The N+1 problem generally occurs when iterating through a (potentially large) group of retrieved records. Because we haven&#39;t loaded their association/s, each loop means an additional query for each associated model we access inside the loop. This can quickly spiral out of control, resulting in a staggering number of queries and causing serious consequences such as crashed pages, an exhausted database connection pool, and memory running out, ultimately grinding our site to a halt.</p>
<p>There are a few useful tools at your disposal to help identify and resolve N+1 problems. The first is simply looking at your server output; generally, this works pretty well, as N+1s are easy to spot. For a more assisted approach, the <a href="https://github.com/flyerhzm/bullet"><code>Bullet</code></a> gem is a popular tool that automatically detects N+1s in applications and suggests ways to fix them. Another, arguably better option is <a href="https://github.com/charkost/prosopite"><code>prosopite</code></a>, a less well-known option that generally provides better results with fewer false positives (and false negatives).</p>
<p>Eager loading should be used with care, however; while you&#39;re probably safe loading <code>has_one</code> associations, <code>has_many</code> can sometimes be dangerous: what happens when we&#39;ve got a query of multiple joined, <a href="https://en.wikipedia.org/wiki/Many-to-many_(data_model)">many-to-many</a> tables, and eager load one or more of the many-to-many associations?</p>
<p>We can end up loading <em>way</em> too many records into memory. This can crash our app just as surely as a bad N+1. If you&#39;re at this point, and both the N+1 and eager loading approaches are causing you problems, it may be time to reevaluate the query itself. Maybe you&#39;re trying to load associations you just want to <code>COUNT</code> (which is something you might be able to build into your query), tighten your pagination limits, or consider offloading the query to a background job if possible (which we&#39;ll cover).</p>
<h2 id="database-performance-in-rails-considerations-and-optimization">Database Performance in Rails: Considerations and Optimization</h2>
<p>Sometimes, breaking queries down into a couple of steps can both improve performance and simplify a query. Ever find yourself trying to get a subset of records to complete a mind-bending query? In certain cases, just finding the IDs of the subset you want and then feeding them into a second, less complex query can help reduce the need for complex joins, subqueries, etc.</p>
<p>Have you ever fallen victim to Rails&#39; (usually beneficial) default lazy-loading and evaluation, and wished you could load something <em>immediately</em> rather than the first time it&#39;s used? Sometimes we need not only the results of a query, but another aspect of it too, like the number of records we&#39;ve retrieved. Our seemingly harmless code looks like this:</p>

<p>Normally, this is fine, but what if we need to count users before we do anything with them (maybe we&#39;re displaying the number of users returned in our live search at the top of the page, followed by the users themselves)? We might add <code>COUNT</code> to our query, but then we need to retrieve the records again.</p>
<p>We can get around this by explicitly calling <code>load</code> on our query â€” for example:</p>

<p>This simple change can save us a query. With our users already loaded, our display of <code>@total_users</code> above the user list will no longer trigger an expensive <code>COUNT</code> followed by another query to get users.</p>
<p>In the other direction, we have <a href="https://www.rubydoc.info/github/rails/rails/ActiveRecord%2FRelation:load_async"><code>load_async</code></a> with Rails 7. This allows us to asynchronously query the database with multiple requests at once, rather than being locked to one synchronous query at a time. This can be a total game-changer if you&#39;re in a situation that can benefit from it. Be careful though, as this (probably unsurprisingly) uses Ruby threads under the hood, so comes with all the same issues you&#39;d expect from threads. That&#39;s not to mention the fact that it (potentially) opens our database up to a greatly increased number of connections, and can exhaust our connection pool if we aren&#39;t careful.</p>

<p>A large part of database performance in Rails comes down to how you utilize ActiveRecord. While AR is an invaluable tool, it can also lead to performance issues if not used with care. As you&#39;re probably aware, it loads every column of every table involved in a query (<code>SELECT *</code>) by default, regardless of how much of that data we actually use. It&#39;s pretty easy to forget this though, especially as our queries evolve, and we can end up loading a lot of unnecessary data. It&#39;s important to consider whether or not you&#39;re really using all of the columns you&#39;re loading, or if a <code>select</code> (or even a <code>pluck</code>) statement might be a better fit for your use case.</p>
<p>You&#39;re probably familiar with eager loading in Rails, but one thing that&#39;s often overlooked is that Rails makes it easy to introduce <em>optional</em> eager-loading (and <code>WHERE</code> clauses, and <code>SELECT</code>s). If you&#39;ve ever had slightly different requirements for two very similar queries, you might feel like you&#39;re left with two options: write two queries, or write covering both use cases, each retrieving more than you need. This might happen in a <code>before_action</code>, where you typically want the same thing for each action in a particular controller. But one controller might benefit from eager loading, more careful column selection, or a search results page which is just filtering the usual index based on some criteria.</p>
<p>There&#39;s another way, though:</p>

<p>Rails is smart enough to know not to execute anything here if there&#39;s nothing passed in; <code>where(nil)</code> will behave as though it doesn&#39;t exist, as will <code>includes([])</code>, etc. This can really clean up your code and help you tailor performance to your needs.</p>
<p>Finally, rethinking your <code>JOIN</code>s and <code>WHERE</code>s can sometimes be beneficial. Are you querying a very large dataset where using a <code>JOIN</code> could significantly reduce the initial result set? Try it out, and don&#39;t be afraid to run <a href="https://apidock.com/rails/ActiveRecord/Relation/explain"><code>#explain</code></a> on your query. It can help you determine if switching to a <code>JOIN</code> might work better and identify any missing indexes on critical queries.</p>
<h2 id="database-indexing">Database Indexing</h2>
<p>One of our most important (and nearly universally necessary) tools for database performance is indexing. As you&#39;re probably aware, indexes are special data structures (typically <a href="https://en.wikipedia.org/wiki/B-tree">B-trees</a>) that a database uses to quickly find records, improving retrieval times from <code>O(n)</code> to <code>O(log(n))</code>. However, it&#39;s important to add indexes carefully, as indexing columns unnecessarily can actually <a href="https://www.arkware.com/striking-a-balance-the-pitfalls-of-over-indexing-in-databases/">harm performance</a>.</p>
<p>The trick is to identify the columns and associations that your application needs to query frequently, and then create indexes on those. This allows the database to quickly locate the relevant data without having to scan the entire table.</p>
<p>You can also use partial indexing. Partial indexes allow you to index a subset of a table&#39;s rows based on a specified condition. This is particularly useful when your queries frequently target only a specific portion of the data.</p>
<p>For example, maybe your app has a core of frequent visitors, the majority of whom have their own accounts. They make up the lion&#39;s share of your traffic, but represent a small minority of your total users. You could define a partial index on the <code>users</code> table like this:</p>

<p>Here, we&#39;ve specifically targeted rows where <code>guest</code> is <code>false</code>. This optimizes the performance of any query searching for non-guest <code>users</code> by reducing the total rows covered by the index.</p>
<p>It&#39;s important to revisit your indexing profile and database schema periodically. The specific indexing needs of your application may change over time as the user base, codebase, and feature set evolve. Doing so often means you end up reviewing your indexes during comfortable periods where you have time to analyze and think about your database, rather than in a panic when an influx of traffic crashes your app.</p>
<p>All of this brings us to our next topic: performance profiling.</p>
<h2 id="performance-profiling-for-your-ruby-on-rails-app">Performance Profiling for Your Ruby on Rails App</h2>
<p>So, we&#39;ve identified some major categories of performance optimization; what now? Do we go through our entire app from top to bottom, optimizing line by line? Probably not.</p>
<p>It&#39;s pretty unlikely that you have evenly distributed traffic across your whole site. It&#39;s even less likely that you can afford to go through your entire codebase; premature optimization may not actually be the root of all evil, but you also don&#39;t have time for it. So how do we know what to focus on?</p>
<p>This is where profiling tools come in. While your local server output can provide valuable performance insights into response times, memory use, and query performance, you are only one user. Your local database likely doesn&#39;t reflect the scale or patterns of your production database. Valuable as it is for spotting potential performance issues, your local environment doesn&#39;t provide the context you need to make decisions about what genuinely needs your attention.</p>
<p><a href="https://www.appsignal.com/learning-center/what-is-an-apm">Application Performance Monitoring tools</a> (APMs) like <a href="https://www.appsignal.com/ruby">AppSignal for Ruby</a> are essential for monitoring and maintaining our site&#39;s performance. They provide comprehensive insights not just at the database layer, but across the rest of the stack, allowing us to pinpoint specific areas (pages, endpoints, and even specific queries) that are causing headaches. With a good APM tool, we can track the performance of any request over various timescales, monitor background jobs, spot memory leaks, set up custom error and performance alerts, and more.</p>
<p>APMs provide visualization tools that make it much easier to spot and understand complex performance trends, leading to quicker, more informed decisions. They help prioritize optimization efforts by highlighting not only the slowest queries and most resource-intensive parts of an application, but also the endpoints that consume the most total time (<code>total request count * average response time</code>). This means we can focus on what&#39;s actually important. Remember that page we were worried about that takes a couple of seconds to load? Turns out, its total impact on our site amounts to practically nothing. Our products page though, clocking in at a reasonable 150ms? That&#39;s taking up 15% of our total server time.</p>
<blockquote>
<p>To find out more about measuring database performance using AppSignal, check out our post <a href="https://blog.appsignal.com/2024/06/12/monitor-the-performance-of-your-ruby-on-rails-application-using-appsignal.html">Monitor the Performance of Your Ruby on Rails Application Using AppSignal</a>.</p>
</blockquote>
<h2 id="background-jobs">Background Jobs</h2>
<p>It isn&#39;t always an option, but running queries in background jobs is a powerful tool for improving performance.</p>
<p>You might be asking yourself how this could be, given that we only have one database; what difference does it make if we&#39;re merely calling on it from another thread or process? But there are a few main ways background jobs can come to our database&#39;s rescue.</p>
<p>First, just by nature of the fact that our background jobs run asynchronously, we&#39;re pretty free to run relatively resource-intensive tasks â€” like setting up <a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert_all">bulk inserts</a> (or <a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert_all">upserts</a>), for example (note: neither validations nor callbacks are triggered for bulk operations) â€” and potentially distributing large numbers of queries across periods of time (perhaps especially for write operations), possibly with the use of <code>find_each</code>.</p>
<p>You&#39;re likely used to using a job to process a CSV or spreadsheet; those tasks tend to lend themselves to asynchronous processing as well as bulk insertions. If you&#39;re doing this on your server&#39;s main thread, you&#39;re likely doing something wrong. But sometimes other, less obvious things we&#39;re currently doing on our main thread can be moved to a background job to improve performance on the main thread <em>and</em> reduce load on the database.</p>
<p>Consider a scenario where your site allows people to make potentially large purchases of relatively inexpensive items. A school, for example, might order tens of thousands of pencils at once, and maybe your system creates a <code>PurchaseItem</code> for every single item purchased. Instead of creating or updating thousands of rows one at a time, we can set up a bulk insert in a background job, create all the individual hashes inside a loop, and use <code>insert_all</code> to get the job done â€” taking advantage of our background worker to set up our bulk inserts, and then writing to the database once, instead of locking it with thousands of writes.</p>
<h2 id="read-replicas">Read Replicas</h2>
<p>Background jobs are great, but eventually, even if we&#39;re spacing out those large, numerous database queries, we hit a point where we&#39;re asking too much of our database. We&#39;re probably okay in terms of write performance (we tend to read from our database far more than we write to it, after all), but we&#39;re constantly bombarding it with queries. Our site&#39;s response times are steadily rising, and user experience is suffering.</p>
<p>At this point, the next logical step may be to introduce <a href="https://blogs.oracle.com/mysql/post/read-replicas-mysql-database-service">read replicas</a> to offload work from the primary database. Read replicas allow you to distribute the read query load across one or more replicas of your database. This can improve performance across the board, as it greatly reduces the number of reads (and thus the total I/O) of your primary database, leaving it less swamped by requests (most of which are likely reads in the first place).</p>
<p>Ideally, large database operations are performed in background jobs reading from replicas, setting up a bulk <code>insert</code> or <code>upsert</code>, and then making one atomic write to your main database. This means you can potentially raise not only the read performance of your site, but can also boost write performance to some degree, as your primary database is consistently freer to accept write requests.</p>
<p>While <a href="https://catalinionescu.dev/blog/how-to-connect-to-multiple-databases/">read replicas are not painless to set up</a>, they can provide the extra performance our site needs.</p>
<h2 id="database-sharding-at-a-high-level">Database Sharding At A High Level</h2>
<p>Remember how we said SQL databases don&#39;t scale horizontally? Technically, they can scale horizontally through <a href="https://blog.appsignal.com/2022/12/07/database-performance-optimization-and-scaling-in-rails.html">database sharding</a>. Sharding involves splitting up your database into multiple databases, which are then distributed across multiple servers (and often across geographical locations).</p>
<p>There are several approaches for doing this, including:</p>
<ul>
<li>Geographical sharding (based on user locations).</li>
<li>Vertical sharding (splitting into different tables or groups of tables based on access patterns, with each shard storing a different subset of the databaseâ€™s tables).</li>
<li>Functional sharding (splitting based on business function; like separating out billing from user content).</li>
</ul>
<p>And more. Each approach has its use cases, and some naturally lend themselves better to some businesses than others.</p>
<p>As you&#39;ve doubtlessly realized by now, sharding is generally difficult, and depending on your business, sometimes not even possible. It adds complexity, developmental and maintenance overhead to our apps, and potentially a lot of it. The good news is that if you don&#39;t have the resources to cover this, you probably don&#39;t need it in the first place. The bad news is that even if you do, it still complicates things and means increased costs (presumably balanced by the potential benefits).</p>
<p>But if you&#39;ve done all you can with query optimization, read replicas, and caching, sharding might just be the next necessary step â€” and one that can greatly increase your I/O capability.</p>
<h2 id="words-of-caution-and-final-words-database-optimization-in-ruby-on-rails">Words of Caution and Final Words: Database Optimization in Ruby on Rails</h2>
<p>We need to be conscientious in how we approach our optimizations. It&#39;s possible to over-index (or index the wrong things, which hurts write performance). In the same way that N+1s can get out of control if we&#39;re not careful, so can eager loading, and it&#39;s not always immediately obvious when we&#39;re developing locally (hence the importance of at least approximating your real-world site locally).</p>
<p>Keep an eye on things via an APM, as traffic and user patterns can change and new ones can emerge, not just over time but potentially week to week and season to season, depending on your business.</p>
<p>There&#39;s no one-size-fits-all approach, so we have to be mindful of how we tailor our optimizations to our own site. Remember not to waste too much time trying to optimize things until you have an idea of the impact they&#39;ll have on your site.</p>
<p>That doesn&#39;t mean you shouldn&#39;t try to write generally efficient code, just that there&#39;s generally no reason to agonize over tweaking things to be absolutely optimal or wasting time on micro-optimizations. Try to keep the time-to-benefit ratio in mind, and how what you&#39;re working on will likely fit into your existing site as it is now, and as it evolves.</p>
<p>If you&#39;re interested in diving deeper into aspects of database optimization like sharding, you can <a href="https://edgeguides.rubyonrails.org/active_record_multiple_databases.html">learn more from the Rails guides</a>. Also, check out <a href="https://pawelurbanek.com/rails-load-async">PaweÅ‚ Urbanek&#39;s great article on <code>load_async</code></a>.</p>
<p>Happy optimizing!</p>
<p><strong>P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press, <a href="https://blog.appsignal.com/ruby-magic">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p></div></div></div>
  </body>
</html>
