<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://craftinginterpreters.com/compiling-expressions.html">Original</a>
    <h1>Compiling Expressions</h1>
    
    <div id="readability-page-1" class="page"><article>

  <p>17</p>
  

<blockquote>
<p>In the middle of the journey of our life I found myself within a dark woods
where the straight way was lost.</p>
<p><cite>Dante Alighieri, <em>Inferno</em></cite></p>
</blockquote>
<p>This chapter is exciting for not one, not two, but <em>three</em> reasons. First, it
provides the final segment of our VM’s execution pipeline. Once in place, we can
plumb the user’s source code from scanning all the way through to executing it.</p><img src="https://craftinginterpreters.com/image/compiling-expressions/pipeline.png" alt="Lowering the &#39;compiler&#39; section of pipe between &#39;scanner&#39; and &#39;VM&#39;."/>
<p>Second, we get to write an actual, honest-to-God <em>compiler</em>. It parses source
code and outputs a low-level series of binary instructions. Sure, it’s <span name="wirth">bytecode</span> and not some chip’s native instruction set, but
it’s way closer to the metal than jlox was. We’re about to be real language
hackers.</p>

<p><span name="pratt">Third</span> and finally, I get to show you one of my
absolute favorite algorithms: Vaughan Pratt’s “top-down operator precedence
parsing”. It’s the most elegant way I know to parse expressions. It gracefully
handles prefix operators, postfix, infix, <em>mixfix</em>, any kind of <em>-fix</em> you got.
It deals with precedence and associativity without breaking a sweat. I love it.</p>

<p>As usual, before we get to the fun stuff, we’ve got some preliminaries to work
through. You have to eat your vegetables before you get dessert. First, let’s
ditch that temporary scaffolding we wrote for testing the scanner and replace it
with something more useful.</p>
<div><pre>InterpretResult interpret(const char* source) {
</pre>
<pre>  <span>Chunk</span> <span>chunk</span>;
  <span>initChunk</span>(&amp;<span>chunk</span>);

  <span>if</span> (!<span>compile</span>(<span>source</span>, &amp;<span>chunk</span>)) {
    <span>freeChunk</span>(&amp;<span>chunk</span>);
    <span>return</span> <span>INTERPRET_COMPILE_ERROR</span>;
  }

  <span>vm</span>.<span>chunk</span> = &amp;<span>chunk</span>;
  <span>vm</span>.<span>ip</span> = <span>vm</span>.<span>chunk</span>-&gt;<span>code</span>;

  <span>InterpretResult</span> <span>result</span> = <span>run</span>();

  <span>freeChunk</span>(&amp;<span>chunk</span>);
  <span>return</span> <span>result</span>;
</pre><pre>}
</pre></div>
<p><em>vm.c</em>, in <em>interpret</em>(), replace 2 lines</p>

<p>We create a new empty chunk and pass it over to the compiler. The compiler will
take the user’s program and fill up the chunk with bytecode. At least, that’s
what it will do if the program doesn’t have any compile errors. If it does
encounter an error, <code>compile()</code> returns <code>false</code> and we discard the unusable
chunk.</p>
<p>Otherwise, we send the completed chunk over to the VM to be executed. When the
VM finishes, we free the chunk and we’re done. As you can see, the signature to
<code>compile()</code> is different now.</p>
<div><pre>#define clox_compiler_h

</pre>
<pre><span>#include &#34;vm.h&#34;</span>

<span>bool</span> <span>compile</span>(<span>const</span> <span>char</span>* <span>source</span>, <span>Chunk</span>* <span>chunk</span>);
</pre><pre>

#endif
</pre></div>
<p><em>compiler.h</em>, replace 1 line</p>

<p>We pass in the chunk where the compiler will write the code, and then
<code>compile()</code> returns whether or not compilation succeeded. We make the same
change to the signature in the implementation.</p>
<div><pre>#include &#34;scanner.h&#34;

</pre>
<pre><span>bool</span> <span>compile</span>(<span>const</span> <span>char</span>* <span>source</span>, <span>Chunk</span>* <span>chunk</span>) {
</pre><pre>  initScanner(source);
</pre></div>
<p><em>compiler.c</em>, function <em>compile</em>(), replace 1 line</p>

<p>That call to <code>initScanner()</code> is the only line that survives this chapter. Rip
out the temporary code we wrote to test the scanner and replace it with these
three lines:</p>
<div><pre>  initScanner(source);
</pre>
<pre>  <span>advance</span>();
  <span>expression</span>();
  <span>consume</span>(<span>TOKEN_EOF</span>, <span>&#34;Expect end of expression.&#34;</span>);
</pre><pre>}
</pre></div>
<p><em>compiler.c</em>, in <em>compile</em>(), replace 13 lines</p>

<p>The call to <code>advance()</code> “primes the pump” on the scanner. We’ll see what it does
soon. Then we parse a single expression. We aren’t going to do statements yet,
so that’s the only subset of the grammar we support. We’ll revisit this when we
<a href="https://craftinginterpreters.com/global-variables.html">add statements in a few chapters</a>. After we compile the expression, we
should be at the end of the source code, so we check for the sentinel EOF token.</p>
<p>We’re going to spend the rest of the chapter making this function work,
especially that little <code>expression()</code> call. Normally, we’d dive right into that
function definition and work our way through the implementation from top to
bottom.</p>
<p>This chapter is <span name="blog">different</span>. Pratt’s parsing technique is
remarkably simple once you have it all loaded in your head, but it’s a little
tricky to break into bite-sized pieces. It’s recursive, of course, which is part
of the problem. But it also relies on a big table of data. As we build up the
algorithm, that table grows additional columns.</p>

<p>I don’t want to revisit 40-something lines of code each time we extend the
table. So we’re going to work our way into the core of the parser from the
outside and cover all of the surrounding bits before we get to the juicy center.
This will require a little more patience and mental scratch space than most
chapters, but it’s the best I could do.</p>
<h2><a href="#single-pass-compilation" id="single-pass-compilation"><small>17 . 1</small>Single-Pass Compilation</a></h2>
<p>A compiler has roughly two jobs. It parses the user’s source code to understand
what it means. Then it takes that knowledge and outputs low-level instructions
that produce the same semantics. Many languages split those two roles into two
separate <span name="passes">passes</span> in the implementation. A parser
produces an AST<span>—</span>just like jlox does<span>—</span>and then a code generator traverses
the AST and outputs target code.</p>

<p>In clox, we’re taking an old-school approach and merging these two passes into
one. Back in the day, language hackers did this because computers literally
didn’t have enough memory to store an entire source file’s AST. We’re doing it
because it keeps our compiler simpler, which is a real asset when programming in
C.</p>
<p>Single-pass compilers like we’re going to build don’t work well for all
languages. Since the compiler has only a peephole view into the user’s program
while generating code, the language must be designed such that you don’t need
much surrounding context to understand a piece of syntax. Fortunately, tiny,
dynamically typed Lox is <span name="lox">well-suited</span> to that.</p>

<p>What this means in practical terms is that our “compiler” C module has
functionality you’ll recognize from jlox for parsing<span>—</span>consuming tokens,
matching expected token types, etc. And it also has functions for code gen<span>—</span>emitting bytecode and adding constants to the destination chunk. (And it means
I’ll use “parsing” and “compiling” interchangeably throughout this and later
chapters.)</p>
<p>We’ll build the parsing and code generation halves first. Then we’ll stitch them
together with the code in the middle that uses Pratt’s technique to parse Lox’s
particular grammar and output the right bytecode.</p>
<h2><a href="#parsing-tokens" id="parsing-tokens"><small>17 . 2</small>Parsing Tokens</a></h2>
<p>First up, the front half of the compiler. This function’s name should sound
familiar.</p>
<div><pre>#include &#34;scanner.h&#34;
</pre><p><em>compiler.c</em></p>
<pre>

<span>static</span> <span>void</span> <span>advance</span>() {
  <span>parser</span>.<span>previous</span> = <span>parser</span>.<span>current</span>;

  <span>for</span> (;;) {
    <span>parser</span>.<span>current</span> = <span>scanToken</span>();
    <span>if</span> (<span>parser</span>.<span>current</span>.<span>type</span> != <span>TOKEN_ERROR</span>) <span>break</span>;

    <span>errorAtCurrent</span>(<span>parser</span>.<span>current</span>.<span>start</span>);
  }
}
</pre></div>
<p><em>compiler.c</em></p>

<p>Just like in jlox, it steps forward through the token stream. It asks the
scanner for the next token and stores it for later use. Before doing that, it
takes the old <code>current</code> token and stashes that in a <code>previous</code> field. That will
come in handy later so that we can get at the lexeme after we match a token.</p>
<p>The code to read the next token is wrapped in a loop. Remember, clox’s scanner
doesn’t report lexical errors. Instead, it creates special <em>error tokens</em> and
leaves it up to the parser to report them. We do that here.</p>
<p>We keep looping, reading tokens and reporting the errors, until we hit a
non-error one or reach the end. That way, the rest of the parser sees only valid
tokens. The current and previous token are stored in this struct:</p>
<div><pre>#include &#34;scanner.h&#34;
</pre><p><em>compiler.c</em></p>
<pre>

<span>typedef</span> <span>struct</span> {
  <span>Token</span> <span>current</span>;
  <span>Token</span> <span>previous</span>;
} <span>Parser</span>;

<span>Parser</span> <span>parser</span>;
</pre><pre>

static void advance() {
</pre></div>
<p><em>compiler.c</em></p>

<p>Like we did in other modules, we have a single global variable of this struct
type so we don’t need to pass the state around from function to function in the
compiler.</p>
<h3><a href="#handling-syntax-errors" id="handling-syntax-errors"><small>17 . 2 . 1</small>Handling syntax errors</a></h3>
<p>If the scanner hands us an error token, we need to actually tell the user. That
happens using this:</p>
<div>
<pre><span>static</span> <span>void</span> <span>errorAtCurrent</span>(<span>const</span> <span>char</span>* <span>message</span>) {
  <span>errorAt</span>(&amp;<span>parser</span>.<span>current</span>, <span>message</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after variable <em>parser</em></p>

<p>We pull the location out of the current token in order to tell the user where
the error occurred and forward it to <code>errorAt()</code>. More often, we’ll report an
error at the location of the token we just consumed, so we give the shorter name
to this other function:</p>
<div>
<pre><span>static</span> <span>void</span> <span>error</span>(<span>const</span> <span>char</span>* <span>message</span>) {
  <span>errorAt</span>(&amp;<span>parser</span>.<span>previous</span>, <span>message</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after variable <em>parser</em></p>

<p>The actual work happens here:</p>
<div>
<pre><span>static</span> <span>void</span> <span>errorAt</span>(<span>Token</span>* <span>token</span>, <span>const</span> <span>char</span>* <span>message</span>) {
  <span>fprintf</span>(<span>stderr</span>, <span>&#34;[line %d] Error&#34;</span>, <span>token</span>-&gt;<span>line</span>);

  <span>if</span> (<span>token</span>-&gt;<span>type</span> == <span>TOKEN_EOF</span>) {
    <span>fprintf</span>(<span>stderr</span>, <span>&#34; at end&#34;</span>);
  } <span>else</span> <span>if</span> (<span>token</span>-&gt;<span>type</span> == <span>TOKEN_ERROR</span>) {
    <span>// Nothing.</span>
  } <span>else</span> {
    <span>fprintf</span>(<span>stderr</span>, <span>&#34; at &#39;%.*s&#39;&#34;</span>, <span>token</span>-&gt;<span>length</span>, <span>token</span>-&gt;<span>start</span>);
  }

  <span>fprintf</span>(<span>stderr</span>, <span>&#34;: %s</span><span>\n</span><span>&#34;</span>, <span>message</span>);
  <span>parser</span>.<span>hadError</span> = <span>true</span>;
}
</pre></div>
<p><em>compiler.c</em>, add after variable <em>parser</em></p>

<p>First, we print where the error occurred. We try to show the lexeme if it’s
human-readable. Then we print the error message itself. After that, we set this
<code>hadError</code> flag. That records whether any errors occurred during compilation.
This field also lives in the parser struct.</p>
<div><pre>  Token previous;
</pre>
<pre>  <span>bool</span> <span>hadError</span>;
</pre><pre>} Parser;
</pre></div>
<p><em>compiler.c</em>, in struct <em>Parser</em></p>

<p>Earlier I said that <code>compile()</code> should return <code>false</code> if an error occurred. Now
we can make it do that.</p>
<div><pre>  consume(TOKEN_EOF, &#34;Expect end of expression.&#34;);
</pre>
<pre>  <span>return</span> !<span>parser</span>.<span>hadError</span>;
</pre><pre>}
</pre></div>
<p><em>compiler.c</em>, in <em>compile</em>()</p>

<p>I’ve got another flag to introduce for error handling. We want to avoid error
cascades. If the user has a mistake in their code and the parser gets confused
about where it is in the grammar, we don’t want it to spew out a whole pile of
meaningless knock-on errors after the first one.</p>
<p>We fixed that in jlox using panic mode error recovery. In the Java interpreter,
we threw an exception to unwind out of all of the parser code to a point where
we could skip tokens and resynchronize. We don’t have <span name="setjmp">exceptions</span> in C. Instead, we’ll do a little smoke and
mirrors. We add a flag to track whether we’re currently in panic mode.</p>

<div><pre>  bool hadError;
</pre>
<pre>  <span>bool</span> <span>panicMode</span>;
</pre><pre>} Parser;
</pre></div>
<p><em>compiler.c</em>, in struct <em>Parser</em></p>

<p>When an error occurs, we set it.</p>
<div><pre>static void errorAt(Token* token, const char* message) {
</pre>
<pre>  <span>parser</span>.<span>panicMode</span> = <span>true</span>;
</pre><pre>  fprintf(stderr, &#34;[line %d] Error&#34;, token-&gt;line);
</pre></div>
<p><em>compiler.c</em>, in <em>errorAt</em>()</p>

<p>After that, we go ahead and keep compiling as normal as if the error never
occurred. The bytecode will never get executed, so it’s harmless to keep on
trucking. The trick is that while the panic mode flag is set, we simply suppress
any other errors that get detected.</p>
<div><pre>static void errorAt(Token* token, const char* message) {
</pre>
<pre>  <span>if</span> (<span>parser</span>.<span>panicMode</span>) <span>return</span>;
</pre><pre>  parser.panicMode = true;
</pre></div>
<p><em>compiler.c</em>, in <em>errorAt</em>()</p>

<p>There’s a good chance the parser will go off in the weeds, but the user won’t
know because the errors all get swallowed. Panic mode ends when the parser
reaches a synchronization point. For Lox, we chose statement boundaries, so when
we later add those to our compiler, we’ll clear the flag there.</p>
<p>These new fields need to be initialized.</p>
<div><pre>  initScanner(source);
</pre>
<pre>

  <span>parser</span>.<span>hadError</span> = <span>false</span>;
  <span>parser</span>.<span>panicMode</span> = <span>false</span>;

</pre><pre>  advance();
</pre></div>
<p><em>compiler.c</em>, in <em>compile</em>()</p>

<p>And to display the errors, we need a standard header.</p>
<div><pre>#include &lt;stdio.h&gt;
</pre><p><em>compiler.c</em></p>
<pre><span>#include &lt;stdlib.h&gt;</span>
</pre><pre>

#include &#34;common.h&#34;
</pre></div>
<p><em>compiler.c</em></p>

<p>There’s one last parsing function, another old friend from jlox.</p>
<div>
<pre><span>static</span> <span>void</span> <span>consume</span>(<span>TokenType</span> <span>type</span>, <span>const</span> <span>char</span>* <span>message</span>) {
  <span>if</span> (<span>parser</span>.<span>current</span>.<span>type</span> == <span>type</span>) {
    <span>advance</span>();
    <span>return</span>;
  }

  <span>errorAtCurrent</span>(<span>message</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after <em>advance</em>()</p>

<p>It’s similar to <code>advance()</code> in that it reads the next token. But it also
validates that the token has an expected type. If not, it reports an error. This
function is the foundation of most syntax errors in the compiler.</p>
<p>OK, that’s enough on the front end for now.</p>
<h2><a href="#emitting-bytecode" id="emitting-bytecode"><small>17 . 3</small>Emitting Bytecode</a></h2>
<p>After we parse and understand a piece of the user’s program, the next step is to
translate that to a series of bytecode instructions. It starts with the easiest
possible step: appending a single byte to the chunk.</p>
<div>
<pre><span>static</span> <span>void</span> <span>emitByte</span>(<span>uint8_t</span> <span>byte</span>) {
  <span>writeChunk</span>(<span>currentChunk</span>(), <span>byte</span>, <span>parser</span>.<span>previous</span>.<span>line</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after <em>consume</em>()</p>

<p>It’s hard to believe great things will flow through such a simple function. It
writes the given byte, which may be an opcode or an operand to an instruction.
It sends in the previous token’s line information so that runtime errors are
associated with that line.</p>
<p>The chunk that we’re writing gets passed into <code>compile()</code>, but it needs to make
its way to <code>emitByte()</code>. To do that, we rely on this intermediary function:</p>
<div><pre>Parser parser;
</pre>
<pre><span>Chunk</span>* <span>compilingChunk</span>;

<span>static</span> <span>Chunk</span>* <span>currentChunk</span>() {
  <span>return</span> <span>compilingChunk</span>;
}

</pre><pre>static void errorAt(Token* token, const char* message) {
</pre></div>
<p><em>compiler.c</em>, add after variable <em>parser</em></p>

<p>Right now, the chunk pointer is stored in a module-level variable like we store
other global state. Later, when we start compiling user-defined functions, the
notion of “current chunk” gets more complicated. To avoid having to go back and
change a lot of code, I encapsulate that logic in the <code>currentChunk()</code> function.</p>
<p>We initialize this new module variable before we write any bytecode:</p>
<div><pre>bool compile(const char* source, Chunk* chunk) {
  initScanner(source);
</pre>
<pre>  <span>compilingChunk</span> = <span>chunk</span>;
</pre><pre>

  parser.hadError = false;
</pre></div>
<p><em>compiler.c</em>, in <em>compile</em>()</p>

<p>Then, at the very end, when we’re done compiling the chunk, we wrap things up.</p>
<div><pre>  consume(TOKEN_EOF, &#34;Expect end of expression.&#34;);
</pre>
<pre>  <span>endCompiler</span>();
</pre><pre>  return !parser.hadError;
</pre></div>
<p><em>compiler.c</em>, in <em>compile</em>()</p>

<p>That calls this:</p>
<div>
<pre><span>static</span> <span>void</span> <span>endCompiler</span>() {
  <span>emitReturn</span>();
}
</pre></div>
<p><em>compiler.c</em>, add after <em>emitByte</em>()</p>

<p>In this chapter, our VM deals only with expressions. When you run clox, it will
parse, compile, and execute a single expression, then print the result. To print
that value, we are temporarily using the <code>OP_RETURN</code> instruction. So we have the
compiler add one of those to the end of the chunk.</p>
<div>
<pre><span>static</span> <span>void</span> <span>emitReturn</span>() {
  <span>emitByte</span>(<span>OP_RETURN</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after <em>emitByte</em>()</p>

<p>While we’re here in the back end we may as well make our lives easier.</p>
<div>
<pre><span>static</span> <span>void</span> <span>emitBytes</span>(<span>uint8_t</span> <span>byte1</span>, <span>uint8_t</span> <span>byte2</span>) {
  <span>emitByte</span>(<span>byte1</span>);
  <span>emitByte</span>(<span>byte2</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after <em>emitByte</em>()</p>

<p>Over time, we’ll have enough cases where we need to write an opcode followed by
a one-byte operand that it’s worth defining this convenience function.</p>
<h2><a href="#parsing-prefix-expressions" id="parsing-prefix-expressions"><small>17 . 4</small>Parsing Prefix Expressions</a></h2>
<p>We’ve assembled our parsing and code generation utility functions. The missing
piece is the code in the middle that connects those together.</p><img src="https://craftinginterpreters.com/image/compiling-expressions/mystery.png" alt="Parsing functions on the left, bytecode emitting functions on the right. What goes in the middle?"/>
<p>The only step in <code>compile()</code> that we have left to implement is this function:</p>
<div>
<pre><span>static</span> <span>void</span> <span>expression</span>() {
  <span>// What goes here?</span>
}
</pre></div>
<p><em>compiler.c</em>, add after <em>endCompiler</em>()</p>

<p>We aren’t ready to implement every kind of expression in Lox yet. Heck, we don’t
even have Booleans. For this chapter, we’re only going to worry about four:</p>
<ul>
<li>Number literals: <code>123</code></li>
<li>Parentheses for grouping: <code>(123)</code></li>
<li>Unary negation: <code>-123</code></li>
<li>The Four Horsemen of the Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
</ul>
<p>As we work through the functions to compile each of those kinds of expressions,
we’ll also assemble the requirements for the table-driven parser that calls
them.</p>
<h3><a href="#parsers-for-tokens" id="parsers-for-tokens"><small>17 . 4 . 1</small>Parsers for tokens</a></h3>
<p>For now, let’s focus on the Lox expressions that are each only a single token.
In this chapter, that’s just number literals, but there will be more later. Here’s
how we can compile them:</p>
<p>We map each token type to a different kind of expression. We define a function
for each expression that outputs the appropriate bytecode. Then we build an
array of function pointers. The indexes in the array correspond to the
<code>TokenType</code> enum values, and the function at each index is the code to compile
an expression of that token type.</p>
<p>To compile number literals, we store a pointer to the following function at the
<code>TOKEN_NUMBER</code> index in the array.</p>
<div>
<pre><span>static</span> <span>void</span> <span>number</span>() {
  <span>double</span> <span>value</span> = <span>strtod</span>(<span>parser</span>.<span>previous</span>.<span>start</span>, <span>NULL</span>);
  <span>emitConstant</span>(<span>value</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after <em>endCompiler</em>()</p>

<p>We assume the token for the number literal has already been consumed and is
stored in <code>previous</code>. We take that lexeme and use the C standard library to
convert it to a double value. Then we generate the code to load that value using
this function:</p>
<div>
<pre><span>static</span> <span>void</span> <span>emitConstant</span>(<span>Value</span> <span>value</span>) {
  <span>emitBytes</span>(<span>OP_CONSTANT</span>, <span>makeConstant</span>(<span>value</span>));
}
</pre></div>
<p><em>compiler.c</em>, add after <em>emitReturn</em>()</p>

<p>First, we add the value to the constant table, then we emit an <code>OP_CONSTANT</code>
instruction that pushes it onto the stack at runtime. To insert an entry in the
constant table, we rely on:</p>
<div>
<pre><span>static</span> <span>uint8_t</span> <span>makeConstant</span>(<span>Value</span> <span>value</span>) {
  <span>int</span> <span>constant</span> = <span>addConstant</span>(<span>currentChunk</span>(), <span>value</span>);
  <span>if</span> (<span>constant</span> &gt; <span>UINT8_MAX</span>) {
    <span>error</span>(<span>&#34;Too many constants in one chunk.&#34;</span>);
    <span>return</span> <span>0</span>;
  }

  <span>return</span> (<span>uint8_t</span>)<span>constant</span>;
}
</pre></div>
<p><em>compiler.c</em>, add after <em>emitReturn</em>()</p>

<p>Most of the work happens in <code>addConstant()</code>, which we defined back in an
<a href="https://craftinginterpreters.com/chunks-of-bytecode.html">earlier chapter</a>. That adds the given value to the end of the chunk’s
constant table and returns its index. The new function’s job is mostly to make
sure we don’t have too many constants. Since the <code>OP_CONSTANT</code> instruction uses
a single byte for the index operand, we can store and load only up to <span name="256">256</span> constants in a chunk.</p>

<p>That’s basically all it takes. Provided there is some suitable code that
consumes a <code>TOKEN_NUMBER</code> token, looks up <code>number()</code> in the function pointer
array, and then calls it, we can now compile number literals to bytecode.</p>
<h3><a href="#parentheses-for-grouping" id="parentheses-for-grouping"><small>17 . 4 . 2</small>Parentheses for grouping</a></h3>
<p>Our as-yet-imaginary array of parsing function pointers would be great if every
expression was only a single token long. Alas, most are longer. However, many
expressions <em>start</em> with a particular token. We call these <em>prefix</em> expressions.
For example, when we’re parsing an expression and the current token is <code>(</code>, we
know we must be looking at a parenthesized grouping expression.</p>
<p>It turns out our function pointer array handles those too. The parsing function
for an expression type can consume any additional tokens that it wants to, just
like in a regular recursive descent parser. Here’s how parentheses work:</p>
<div>
<pre><span>static</span> <span>void</span> <span>grouping</span>() {
  <span>expression</span>();
  <span>consume</span>(<span>TOKEN_RIGHT_PAREN</span>, <span>&#34;Expect &#39;)&#39; after expression.&#34;</span>);
}
</pre></div>
<p><em>compiler.c</em>, add after <em>endCompiler</em>()</p>

<p>Again, we assume the initial <code>(</code> has already been consumed. We <span name="recursive">recursively</span> call back into <code>expression()</code> to compile the
expression between the parentheses, then parse the closing <code>)</code> at the end.</p>

<p>As far as the back end is concerned, there’s literally nothing to a grouping
expression. Its sole function is syntactic<span>—</span>it lets you insert a
lower-precedence expression where a higher precedence is expected. Thus, it has
no runtime semantics on its own and therefore doesn’t emit any bytecode. The
inner call to <code>expression()</code> takes care of generating bytecode for the
expression inside the parentheses.</p>
<h3><a href="#unary-negation" id="unary-negation"><small>17 . 4 . 3</small>Unary negation</a></h3>
<p>Unary minus is also a prefix expression, so it works with our model too.</p>
<div>
<pre><span>static</span> <span>void</span> <span>unary</span>() {
  <span>TokenType</span> <span>operatorType</span> = <span>parser</span>.<span>previous</span>.<span>type</span>;

  <span>// Compile the operand.</span>
  <span>expression</span>();

  <span>// Emit the operator instruction.</span>
  <span>switch</span> (<span>operatorType</span>) {
    <span>case</span> <span>TOKEN_MINUS</span>: <span>emitByte</span>(<span>OP_NEGATE</span>); <span>break</span>;
    <span>default</span>: <span>return</span>; <span>// Unreachable.</span>
  }
}
</pre></div>
<p><em>compiler.c</em>, add after <em>number</em>()</p>

<p>The leading <code>-</code> token has been consumed and is sitting in <code>parser.previous</code>. We
grab the token type from that to note which unary operator we’re dealing with.
It’s unnecessary right now, but this will make more sense when we use this same
function to compile the <code>!</code> operator in <a href="https://craftinginterpreters.com/types-of-values.html">the next chapter</a>.</p>
<p>As in <code>grouping()</code>, we recursively call <code>expression()</code> to compile the operand.
After that, we emit the bytecode to perform the negation. It might seem a little
weird to write the negate instruction <em>after</em> its operand’s bytecode since the
<code>-</code> appears on the left, but think about it in terms of order of execution:</p>
<ol>
<li>
<p>We evaluate the operand first which leaves its value on the stack.</p>
</li>
<li>
<p>Then we pop that value, negate it, and push the result.</p>
</li>
</ol>
<p>So the <code>OP_NEGATE</code> instruction should be emitted <span name="line">last</span>.
This is part of the compiler’s job<span>—</span>parsing the program in the order it
appears in the source code and rearranging it into the order that execution
happens.</p>

<p>There is one problem with this code, though. The <code>expression()</code> function it
calls will parse any expression for the operand, regardless of precedence. Once
we add binary operators and other syntax, that will do the wrong thing.
Consider:</p>

<p>Here, the operand to <code>-</code> should be just the <code>a.b</code> expression, not the entire
<code>a.b + c</code>. But if <code>unary()</code> calls <code>expression()</code>, the latter will happily chew
through all of the remaining code including the <code>+</code>. It will erroneously treat
the <code>-</code> as lower precedence than the <code>+</code>.</p>
<p>When parsing the operand to unary <code>-</code>, we need to compile only expressions at a
certain precedence level or higher. In jlox’s recursive descent parser we
accomplished that by calling into the parsing method for the lowest-precedence
expression we wanted to allow (in this case, <code>call()</code>). Each method for parsing
a specific expression also parsed any expressions of higher precedence too, so
that included the rest of the precedence table.</p>
<p>The parsing functions like <code>number()</code> and <code>unary()</code> here in clox are different.
Each only parses exactly one type of expression. They don’t cascade to include
higher-precedence expression types too. We need a different solution, and it
looks like this:</p>
<div>
<pre><span>static</span> <span>void</span> <span>parsePrecedence</span>(<span>Precedence</span> <span>precedence</span>) {
  <span>// What goes here?</span>
}
</pre></div>
<p><em>compiler.c</em>, add after <em>unary</em>()</p>

<p>This function<span>—</span>once we implement it<span>—</span>starts at the current token and parses
any expression at the given precedence level or higher. We have some other setup
to get through before we can write the body of this function, but you can
probably guess that it will use that table of parsing function pointers I’ve
been talking about. For now, don’t worry too much about how it works. In order
to take the “precedence” as a parameter, we define it numerically.</p>
<div><pre>} Parser;
</pre>
<pre>

<span>typedef</span> <span>enum</span> {
  <span>PREC_NONE</span>,
  <span>PREC_ASSIGNMENT</span>,  <span>// =</span>
  <span>PREC_OR</span>,          <span>// or</span>
  <span>PREC_AND</span>,         <span>// and</span>
  <span>PREC_EQUALITY</span>,    <span>// == !=</span>
  <span>PREC_COMPARISON</span>,  <span>// &lt; &gt; &lt;= &gt;=</span>
  <span>PREC_TERM</span>,        <span>// + -</span>
  <span>PREC_FACTOR</span>,      <span>// * /</span>
  <span>PREC_UNARY</span>,       <span>// ! -</span>
  <span>PREC_CALL</span>,        <span>// . ()</span>
  <span>PREC_PRIMARY</span>
} <span>Precedence</span>;
</pre><pre>

Parser parser;
</pre></div>
<p><em>compiler.c</em>, add after struct <em>Parser</em></p>

<p>These are all of Lox’s precedence levels in order from lowest to highest. Since
C implicitly gives successively larger numbers for enums, this means that
<code>PREC_CALL</code> is numerically larger than <code>PREC_UNARY</code>. For example, say the
compiler is sitting on a chunk of code like:</p>

<p>If we call <code>parsePrecedence(PREC_ASSIGNMENT)</code>, then it will parse the entire
expression because <code>+</code> has higher precedence than assignment. If instead we
call <code>parsePrecedence(PREC_UNARY)</code>, it will compile the <code>-a.b</code> and stop there.
It doesn’t keep going through the <code>+</code> because the addition has lower precedence
than unary operators.</p>
<p>With this function in hand, it’s a snap to fill in the missing body for
<code>expression()</code>.</p>
<div><pre>static void expression() {
</pre>
<pre>  <span>parsePrecedence</span>(<span>PREC_ASSIGNMENT</span>);
</pre><pre>}
</pre></div>
<p><em>compiler.c</em>, in <em>expression</em>(), replace 1 line</p>

<p>We simply parse the lowest precedence level, which subsumes all of the
higher-precedence expressions too. Now, to compile the operand for a unary
expression, we call this new function and limit it to the appropriate level:</p>
<div><pre>  // Compile the operand.
</pre>
<pre>  <span>parsePrecedence</span>(<span>PREC_UNARY</span>);
</pre><pre>

  // Emit the operator instruction.
</pre></div>
<p><em>compiler.c</em>, in <em>unary</em>(), replace 1 line</p>

<p>We use the unary operator’s own <code>PREC_UNARY</code> precedence to permit <span name="useful">nested</span> unary expressions like <code>!!doubleNegative</code>. Since
unary operators have pretty high precedence, that correctly excludes things like
binary operators. Speaking of which<span> . . . </span></p>

<h2><a href="#parsing-infix-expressions" id="parsing-infix-expressions"><small>17 . 5</small>Parsing Infix Expressions</a></h2>
<p>Binary operators are different from the previous expressions because they are
<em>infix</em>. With the other expressions, we know what we are parsing from the very
first token. With infix expressions, we don’t know we’re in the middle of a
binary operator until <em>after</em> we’ve parsed its left operand and then stumbled
onto the operator token in the middle.</p>
<p>Here’s an example:</p>

<p>Let’s walk through trying to compile it with what we know so far:</p>
<ol>
<li>
<p>We call <code>expression()</code>. That in turn calls
<code>parsePrecedence(PREC_ASSIGNMENT)</code>.</p>
</li>
<li>
<p>That function (once we implement it) sees the leading number token and
recognizes it is parsing a number literal. It hands off control to
<code>number()</code>.</p>
</li>
<li>
<p><code>number()</code> creates a constant, emits an <code>OP_CONSTANT</code>, and returns back to
<code>parsePrecedence()</code>.</p>
</li>
</ol>
<p>Now what? The call to <code>parsePrecedence()</code> should consume the entire addition
expression, so it needs to keep going somehow. Fortunately, the parser is right
where we need it to be. Now that we’ve compiled the leading number expression,
the next token is <code>+</code>. That’s the exact token that <code>parsePrecedence()</code> needs to
detect that we’re in the middle of an infix expression and to realize that the
expression we already compiled is actually an operand to that.</p>
<p>So this hypothetical array of function pointers doesn’t just list functions to
parse expressions that start with a given token. Instead, it’s a <em>table</em> of
function pointers. One column associates prefix parser functions with token
types. The second column associates infix parser functions with token types.</p>
<p>The function we will use as the infix parser for <code>TOKEN_PLUS</code>, <code>TOKEN_MINUS</code>,
<code>TOKEN_STAR</code>, and <code>TOKEN_SLASH</code> is this:</p>
<div>
<pre><span>static</span> <span>void</span> <span>binary</span>() {
  <span>TokenType</span> <span>operatorType</span> = <span>parser</span>.<span>previous</span>.<span>type</span>;
  <span>ParseRule</span>* <span>rule</span> = <span>getRule</span>(<span>operatorType</span>);
  <span>parsePrecedence</span>((<span>Precedence</span>)(<span>rule</span>-&gt;<span>precedence</span> + <span>1</span>));

  <span>switch</span> (<span>operatorType</span>) {
    <span>case</span> <span>TOKEN_PLUS</span>:          <span>emitByte</span>(<span>OP_ADD</span>); <span>break</span>;
    <span>case</span> <span>TOKEN_MINUS</span>:         <span>emitByte</span>(<span>OP_SUBTRACT</span>); <span>break</span>;
    <span>case</span> <span>TOKEN_STAR</span>:          <span>emitByte</span>(<span>OP_MULTIPLY</span>); <span>break</span>;
    <span>case</span> <span>TOKEN_SLASH</span>:         <span>emitByte</span>(<span>OP_DIVIDE</span>); <span>break</span>;
    <span>default</span>: <span>return</span>; <span>// Unreachable.</span>
  }
}
</pre></div>
<p><em>compiler.c</em>, add after <em>endCompiler</em>()</p>

<p>When a prefix parser function is called, the leading token has already been
consumed. An infix parser function is even more <em>in medias res</em><span>—</span>the entire
left-hand operand expression has already been compiled and the subsequent infix
operator consumed.</p>
<p>The fact that the left operand gets compiled first works out fine. It means at
runtime, that code gets executed first. When it runs, the value it produces will
end up on the stack. That’s right where the infix operator is going to need it.</p>
<p>Then we come here to <code>binary()</code> to handle the rest of the arithmetic operators.
This function compiles the right operand, much like how <code>unary()</code> compiles its
own trailing operand. Finally, it emits the bytecode instruction that performs
the binary operation.</p>
<p>When run, the VM will execute the left and right operand code, in that order,
leaving their values on the stack. Then it executes the instruction for the
operator. That pops the two values, computes the operation, and pushes the
result.</p>
<p>The code that probably caught your eye here is that <code>getRule()</code> line. When we
parse the right-hand operand, we again need to worry about precedence. Take an
expression like:</p>

<p>When we parse the right operand of the <code>*</code> expression, we need to just capture
<code>3</code>, and not <code>3 + 4</code>, because <code>+</code> is lower precedence than <code>*</code>. We could define
a separate function for each binary operator. Each would call
<code>parsePrecedence()</code> and pass in the correct precedence level for its operand.</p>
<p>But that’s kind of tedious. Each binary operator’s right-hand operand precedence
is one level <span name="higher">higher</span> than its own. We can look that up
dynamically with this <code>getRule()</code> thing we’ll get to soon. Using that, we call
<code>parsePrecedence()</code> with one level higher than this operator’s level.</p>

<p>This way, we can use a single <code>binary()</code> function for all binary operators even
though they have different precedences.</p>
<h2><a href="#a-pratt-parser" id="a-pratt-parser"><small>17 . 6</small>A Pratt Parser</a></h2>
<p>We now have all of the pieces and parts of the compiler laid out. We have a
function for each grammar production: <code>number()</code>, <code>grouping()</code>, <code>unary()</code>, and
<code>binary()</code>. We still need to implement <code>parsePrecedence()</code>, and <code>getRule()</code>. We
also know we need a table that, given a token type, lets us find</p>
<ul>
<li>
<p>the function to compile a prefix expression starting with a token of that
type,</p>
</li>
<li>
<p>the function to compile an infix expression whose left operand is followed
by a token of that type, and</p>
</li>
<li>
<p>the precedence of an <span name="prefix">infix</span> expression that uses
that token as an operator.</p>
</li>
</ul>

<p>We wrap these three properties in a little struct which represents a single row
in the parser table.</p>
<div><pre>} Precedence;
</pre>
<pre>

<span>typedef</span> <span>struct</span> {
  <span>ParseFn</span> <span>prefix</span>;
  <span>ParseFn</span> <span>infix</span>;
  <span>Precedence</span> <span>precedence</span>;
} <span>ParseRule</span>;
</pre><pre>

Parser parser;
</pre></div>
<p><em>compiler.c</em>, add after enum <em>Precedence</em></p>

<p>That ParseFn type is a simple <span name="typedef">typedef</span> for a function
type that takes no arguments and returns nothing.</p>

<div><pre>} Precedence;
</pre>
<pre>

<span>typedef</span> <span>void</span> (*<span>ParseFn</span>)();
</pre><pre>

typedef struct {
</pre></div>
<p><em>compiler.c</em>, add after enum <em>Precedence</em></p>

<p>The table that drives our whole parser is an array of ParseRules. We’ve been
talking about it forever, and finally you get to see it.</p>
<div>
<pre><span>ParseRule</span> <span>rules</span>[] = {
  [<span>TOKEN_LEFT_PAREN</span>]    = {<span>grouping</span>, <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_RIGHT_PAREN</span>]   = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_LEFT_BRACE</span>]    = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},<span name="big"> </span>
  [<span>TOKEN_RIGHT_BRACE</span>]   = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_COMMA</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_DOT</span>]           = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_MINUS</span>]         = {<span>unary</span>,    <span>binary</span>, <span>PREC_TERM</span>},
  [<span>TOKEN_PLUS</span>]          = {<span>NULL</span>,     <span>binary</span>, <span>PREC_TERM</span>},
  [<span>TOKEN_SEMICOLON</span>]     = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_SLASH</span>]         = {<span>NULL</span>,     <span>binary</span>, <span>PREC_FACTOR</span>},
  [<span>TOKEN_STAR</span>]          = {<span>NULL</span>,     <span>binary</span>, <span>PREC_FACTOR</span>},
  [<span>TOKEN_BANG</span>]          = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_BANG_EQUAL</span>]    = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_EQUAL</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_EQUAL_EQUAL</span>]   = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_GREATER</span>]       = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_GREATER_EQUAL</span>] = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_LESS</span>]          = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_LESS_EQUAL</span>]    = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_IDENTIFIER</span>]    = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_STRING</span>]        = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_NUMBER</span>]        = {<span>number</span>,   <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_AND</span>]           = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_CLASS</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_ELSE</span>]          = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_FALSE</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_FOR</span>]           = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_FUN</span>]           = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_IF</span>]            = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_NIL</span>]           = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_OR</span>]            = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_PRINT</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_RETURN</span>]        = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_SUPER</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_THIS</span>]          = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_TRUE</span>]          = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_VAR</span>]           = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_WHILE</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_ERROR</span>]         = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
  [<span>TOKEN_EOF</span>]           = {<span>NULL</span>,     <span>NULL</span>,   <span>PREC_NONE</span>},
};
</pre></div>
<p><em>compiler.c</em>, add after <em>unary</em>()</p>


<p>You can see how <code>grouping</code> and <code>unary</code> are slotted into the prefix parser column
for their respective token types. In the next column, <code>binary</code> is wired up to
the four arithmetic infix operators. Those infix operators also have their
precedences set in the last column.</p>
<p>Aside from those, the rest of the table is full of <code>NULL</code> and <code>PREC_NONE</code>. Most
of those empty cells are because there is no expression associated with those
tokens. You can’t start an expression with, say, <code>else</code>, and <code>}</code> would make for
a pretty confusing infix operator.</p>
<p>But, also, we haven’t filled in the entire grammar yet. In later chapters, as we
add new expression types, some of these slots will get functions in them. One of
the things I like about this approach to parsing is that it makes it very easy
to see which tokens are in use by the grammar and which are available.</p>
<p>Now that we have the table, we are finally ready to write the code that uses it.
This is where our Pratt parser comes to life. The easiest function to define is
<code>getRule()</code>.</p>
<div>
<pre><span>static</span> <span>ParseRule</span>* <span>getRule</span>(<span>TokenType</span> <span>type</span>) {
  <span>return</span> &amp;<span>rules</span>[<span>type</span>];
}
</pre></div>
<p><em>compiler.c</em>, add after <em>parsePrecedence</em>()</p>

<p>It simply returns the rule at the given index. It’s called by <code>binary()</code> to look
up the precedence of the current operator. This function exists solely to handle
a declaration cycle in the C code. <code>binary()</code> is defined <em>before</em> the rules
table so that the table can store a pointer to it. That means the body of
<code>binary()</code> cannot access the table directly.</p>
<p>Instead, we wrap the lookup in a function. That lets us forward declare
<code>getRule()</code> before the definition of <code>binary()</code>, and <span name="forward">then</span> <em>define</em> <code>getRule()</code> after the table. We’ll need a
couple of other forward declarations to handle the fact that our grammar is
recursive, so let’s get them all out of the way.</p>

<div><pre>  emitReturn();
}
</pre>
<pre>

<span>static</span> <span>void</span> <span>expression</span>();
<span>static</span> <span>ParseRule</span>* <span>getRule</span>(<span>TokenType</span> <span>type</span>);
<span>static</span> <span>void</span> <span>parsePrecedence</span>(<span>Precedence</span> <span>precedence</span>);

</pre><pre>static void binary() {
</pre></div>
<p><em>compiler.c</em>, add after <em>endCompiler</em>()</p>

<p>If you’re following along and implementing clox yourself, pay close attention to
the little annotations that tell you where to put these code snippets. Don’t
worry, though, if you get it wrong, the C compiler will be happy to tell you.</p>
<h3><a href="#parsing-with-precedence" id="parsing-with-precedence"><small>17 . 6 . 1</small>Parsing with precedence</a></h3>
<p>Now we’re getting to the fun stuff. The maestro that orchestrates all of the
parsing functions we’ve defined is <code>parsePrecedence()</code>. Let’s start with parsing
prefix expressions.</p>
<div><pre>static void parsePrecedence(Precedence precedence) {
</pre>
<pre>  <span>advance</span>();
  <span>ParseFn</span> <span>prefixRule</span> = <span>getRule</span>(<span>parser</span>.<span>previous</span>.<span>type</span>)-&gt;<span>prefix</span>;
  <span>if</span> (<span>prefixRule</span> == <span>NULL</span>) {
    <span>error</span>(<span>&#34;Expect expression.&#34;</span>);
    <span>return</span>;
  }

  <span>prefixRule</span>();
</pre><pre>}
</pre></div>
<p><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</p>

<p>We read the next token and look up the corresponding ParseRule. If there is no
prefix parser, then the token must be a syntax error. We report that and return
to the caller.</p>
<p>Otherwise, we call that prefix parse function and let it do its thing. That
prefix parser compiles the rest of the prefix expression, consuming any other
tokens it needs, and returns back here. Infix expressions are where it gets
interesting since precedence comes into play. The implementation is remarkably
simple.</p>
<div><pre>  prefixRule();
</pre>
<pre>

  <span>while</span> (<span>precedence</span> &lt;= <span>getRule</span>(<span>parser</span>.<span>current</span>.<span>type</span>)-&gt;<span>precedence</span>) {
    <span>advance</span>();
    <span>ParseFn</span> <span>infixRule</span> = <span>getRule</span>(<span>parser</span>.<span>previous</span>.<span>type</span>)-&gt;<span>infix</span>;
    <span>infixRule</span>();
  }
</pre><pre>}
</pre></div>
<p><em>compiler.c</em>, in <em>parsePrecedence</em>()</p>

<p>That’s the whole thing. Really. Here’s how the entire function works: At the
beginning of <code>parsePrecedence()</code>, we look up a prefix parser for the current
token. The first token is <em>always</em> going to belong to some kind of prefix
expression, by definition. It may turn out to be nested as an operand inside one
or more infix expressions, but as you read the code from left to right, the
first token you hit always belongs to a prefix expression.</p>
<p>After parsing that, which may consume more tokens, the prefix expression is
done. Now we look for an infix parser for the next token. If we find one, it
means the prefix expression we already compiled might be an operand for it. But
only if the call to <code>parsePrecedence()</code> has a <code>precedence</code> that is low enough to
permit that infix operator.</p>
<p>If the next token is too low precedence, or isn’t an infix operator at all,
we’re done. We’ve parsed as much expression as we can. Otherwise, we consume the
operator and hand off control to the infix parser we found. It consumes whatever
other tokens it needs (usually the right operand) and returns back to
<code>parsePrecedence()</code>. Then we loop back around and see if the <em>next</em> token is
also a valid infix operator that can take the entire preceding expression as its
operand. We keep looping like that, crunching through infix operators and their
operands until we hit a token that isn’t an infix operator or is too low
precedence and stop.</p>
<p>That’s a lot of prose, but if you really want to mind meld with Vaughan Pratt
and fully understand the algorithm, step through the parser in your debugger as
it works through some expressions. Maybe a picture will help. There’s only a
handful of functions, but they are marvelously intertwined:</p>

<p><img src="https://craftinginterpreters.com/image/compiling-expressions/connections.png" alt="The various parsing
functions and how they call each other."/></p>

<p>Later, we’ll need to tweak the code in this chapter to handle assignment. But,
otherwise, what we wrote covers all of our expression compiling needs for the
rest of the book. We’ll plug additional parsing functions into the table when we
add new kinds of expressions, but <code>parsePrecedence()</code> is complete.</p>
<h2><a href="#dumping-chunks" id="dumping-chunks"><small>17 . 7</small>Dumping Chunks</a></h2>
<p>While we’re here in the core of our compiler, we should put in some
instrumentation. To help debug the generated bytecode, we’ll add support for
dumping the chunk once the compiler finishes. We had some temporary logging
earlier when we hand-authored the chunk. Now we’ll put in some real code so that
we can enable it whenever we want.</p>
<p>Since this isn’t for end users, we hide it behind a flag.</p>
<div><pre>#include &lt;stdint.h&gt;

</pre><p><em>common.h</em></p>
<pre><span>#define DEBUG_PRINT_CODE</span>
</pre><pre>#define DEBUG_TRACE_EXECUTION
</pre></div>
<p><em>common.h</em></p>

<p>When that flag is defined, we use our existing “debug” module to print out the
chunk’s bytecode.</p>
<div><pre>  emitReturn();
</pre>
<pre><span>#ifdef DEBUG_PRINT_CODE</span>
  <span>if</span> (!<span>parser</span>.<span>hadError</span>) {
    <span>disassembleChunk</span>(<span>currentChunk</span>(), <span>&#34;code&#34;</span>);
  }
<span>#endif</span>
</pre><pre>}
</pre></div>
<p><em>compiler.c</em>, in <em>endCompiler</em>()</p>

<p>We do this only if the code was free of errors. After a syntax error, the
compiler keeps on going but it’s in kind of a weird state and might produce
broken code. That’s harmless because it won’t get executed, but we’ll just
confuse ourselves if we try to read it.</p>
<p>Finally, to access <code>disassembleChunk()</code>, we need to include its header.</p>
<div><pre>#include &#34;scanner.h&#34;
</pre><p><em>compiler.c</em></p>
<pre>

<span>#ifdef DEBUG_PRINT_CODE</span>
<span>#include &#34;debug.h&#34;</span>
<span>#endif</span>
</pre><pre>

typedef struct {
</pre></div>
<p><em>compiler.c</em></p>

<p>We made it! This was the last major section to install in our VM’s compilation
and execution pipeline. Our interpreter doesn’t <em>look</em> like much, but inside it
is scanning, parsing, compiling to bytecode, and executing.</p>
<p>Fire up the VM and type in an expression. If we did everything right, it should
calculate and print the result. We now have a very over-engineered arithmetic
calculator. We have a lot of language features to add in the coming chapters,
but the foundation is in place.</p>
<div>
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>To really understand the parser, you need to see how execution threads
through the interesting parsing functions<span>—</span><code>parsePrecedence()</code> and the
parser functions stored in the table. Take this (strange) expression:</p>

<p>Write a trace of how those functions are called. Show the order they are
called, which calls which, and the arguments passed to them.</p>
</li>
<li>
<p>The ParseRule row for <code>TOKEN_MINUS</code> has both prefix and infix function
pointers. That’s because <code>-</code> is both a prefix operator (unary negation) and
an infix one (subtraction).</p>
<p>In the full Lox language, what other tokens can be used in both prefix and
infix positions? What about in C or in another language of your choice?</p>
</li>
<li>
<p>You might be wondering about complex “mixfix” expressions that have more
than two operands separated by tokens. C’s conditional or “ternary”
operator, <code>?:</code>, is a widely known one.</p>
<p>Add support for that operator to the compiler. You don’t have to generate
any bytecode, just show how you would hook it up to the parser and handle
the operands.</p>
</li>
</ol>
</div>
<div>
<h2><a href="#design-note" id="design-note">Design Note: It’s Just Parsing</a></h2>
<p>I’m going to make a claim here that will be unpopular with some compiler and
language people. It’s OK if you don’t agree. Personally, I learn more from
strongly stated opinions that I disagree with than I do from several pages of
qualifiers and equivocation. My claim is that <em>parsing doesn’t matter</em>.</p>
<p>Over the years, many programming language people, especially in academia, have
gotten <em>really</em> into parsers and taken them very seriously. Initially, it was
the compiler folks who got into <span name="yacc">compiler-compilers</span>,
LALR, and other stuff like that. The first half of the dragon book is a long
love letter to the wonders of parser generators.</p>

<p>Later, the functional programming folks got into parser combinators, packrat
parsers, and other sorts of things. Because, obviously, if you give a functional
programmer a problem, the first thing they’ll do is whip out a pocketful of
higher-order functions.</p>
<p>Over in math and algorithm analysis land, there is a long legacy of research
into proving time and memory usage for various parsing techniques, transforming
parsing problems into other problems and back, and assigning complexity classes
to different grammars.</p>
<p>At one level, this stuff is important. If you’re implementing a language, you
want some assurance that your parser won’t go exponential and take 7,000 years
to parse a weird edge case in the grammar. Parser theory gives you that bound.
As an intellectual exercise, learning about parsing techniques is also fun and
rewarding.</p>
<p>But if your goal is just to implement a language and get it in front of users,
almost all of that stuff doesn’t matter. It’s really easy to get worked up by
the enthusiasm of the people who <em>are</em> into it and think that your front end
<em>needs</em> some whiz-bang generated combinator-parser-factory thing. I’ve seen
people burn tons of time writing and rewriting their parser using whatever
today’s hot library or technique is.</p>
<p>That’s time that doesn’t add any value to your user’s life. If you’re just
trying to get your parser done, pick one of the bog-standard techniques, use it,
and move on. Recursive descent, Pratt parsing, and the popular parser generators
like ANTLR or Bison are all fine.</p>
<p>Take the extra time you saved not rewriting your parsing code and spend it
improving the compile error messages your compiler shows users. Good error
handling and reporting is more valuable to users than almost anything else you
can put time into in the front end.</p>
</div>


</article></div>
  </body>
</html>
