<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2024-03-17-c&#43;&#43;-exit-time-destructors">Original</a>
    <h1>C&#43;&#43; Exit-Time Destructors</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
        <p>In ISO C++ standards, [basic.start.term] specifies that:</p>
<blockquote>
<p>Constructed objects ([dcl.init]) with static storage duration are
destroyed and functions registered with std::atexit are called as part
of a call to std::exit ([support.start.term]). The call to std::exit is
sequenced before the destructions and the registered functions. [Note
1: Returning from main invokes std::exit ([basic.start.main]). — end
note]</p>
</blockquote>
<p>For example, consider the following code:</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span><span>struct</span> <span>A</span> { ~<span>A</span>(); } a;</span><br/></pre></td></tr></tbody></table></figure>
<p>The destructor for object a will be registered for execution at
program termination.</p>
<h2 id="cxa_atexit"><code>__cxa_atexit</code></h2>
<p>The Itanium C++ ABI employs <code>__cxa_atexit</code> rather than
atexit for object destructor registration for two primary reasons:</p>
<ul>
<li>Limited <code>atexit</code> guarantee: ISO C (up to C23) guarantees
support for 32 registered functions, although most implementations
support many more.</li>
<li>Dynamic library unloading: <code>__cxa_atexit</code> provides a
mechanism for handling destructors when dynamic libraries are unloaded
via <code>dlclose</code> before program termination.</li>
</ul>
<p>Several standard libraries, including glibc, musl, and FreeBSD libc,
implement <code>atexit</code> using <code>__cxa_atexit</code>.</p>
<ul>
<li>In glibc, <code>atexit</code> returns
<code>__cxa_atexit ((void (*) (void *)) func, NULL, __dso_handle)</code>,
where <code>__dso_handle</code> is part of libc itself.</li>
<li>musl uses 0 instead of <code>__dso_handle</code>.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#dso-dtor-runtime-api">https://itanium-cxx-abi.github.io/cxx-abi/abi.html#dso-dtor-runtime-api</a>
provides detailed documentation on object destruction mechanisms. Let&#39;s
illustrate this with a GCC and glibc example:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>cat</span> &gt; a.cc &lt;&lt;<span>&#39;eof&#39;</span></span></pre></td></tr></tbody></table></figure>
<p>An invocation yields:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>foo</span></pre></td></tr></tbody></table></figure>
<p>Key points:</p>
<ul>
<li>The compiler registers destructors with <code>__cxa_atexit</code>
using the <code>__dso_handle</code> symbol as an argument.</li>
<li><code>crtbeginS.o</code> defines the <code>.fini_array</code>
section (triggering <code>__do_global_dtors_aux</code>) and the hidden
symbol <code>__dso_handle</code>.</li>
<li>Since 2017, lld <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D33856">defines
<code>__dso_handle</code> as a hidden symbol</a> if crtbegin does
not.</li>
<li><code>dlclose</code> invokes <code>.fini_array</code> functions.
<code>__cxa_finalize(d)</code> iterates through the termination function
list, calling matching destructors based on the DSO handle.</li>
<li><code>__cxa_atexit</code> implementations typically allocate memory
dynamically and may fail. The failures are simply ignored.</li>
</ul>
<p>Note: In glibc, the <code>DF_1_NODELETE</code> flag marks a shared
object as unloadable. Additionally, symbol lookups with
<code>STB_GNU_UNIQUE</code> automatically set this flag.</p>
<p>musl provides a <a target="_blank" rel="noopener" href="https://wiki.musl-libc.org/functional-differences-from-glibc.html#Unloading_libraries">no-op
implementation for <code>dlclose</code> and
<code>__cxa_finalize</code></a>.</p>
<h2 id="thread-storage-duration-variables">Thread storage duration
variables</h2>
<p>Objects with thread storage duration that have non-trivial
destructors will register those destructors using
<code>__cxa_thread_atexit</code> during construction.</p>
<h2 id="when-exit-time-destructors-are-undesired">When exit-time
destructors are undesired</h2>
<p>Exit-time destructors for static and thread storage duration
variables can be undesired due to</p>
<ul>
<li>Unnecessary overhead and complexity: This includes operating system
kernels and memory-constrained systems.</li>
<li>Potential race conditions: Destructors might execute during thread
termination, while other threads still attempt to access the object.
Examples: <a target="_blank" rel="noopener" href="https://bugs.webkit.org/show_bug.cgi?id=21810">webkit</a></li>
</ul>
<p>Clang provides <code>-Wexit-time-destructors</code> (disabled by
default) to warn about exit-time destructors.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>% clang++ -c -Wexit-time-destructors g.cc</span></pre></td></tr></tbody></table></figure>
<h2 id="disabling-exit-time-destructors">Disabling exit-time
destructors</h2>
<p>Then, I will describe some approaches to disable exit-time
destructors.</p>
<h3 id="pointerreference-to-a-dynamically-allocated-object">Pointer/reference
to a dynamically-allocated object</h3>
<p>We can use a reference or pointer that refers to a
dynamically-allocated object.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>struct</span> <span>A</span> { <span>int</span> v; ~<span>A</span>(); };</span></pre></td></tr></tbody></table></figure>
<p>This approach prevents the destructor from running at program exit,
as pointers and references have a trivial destructor. Note that this
does not create a memory leak, since the pointer/reference is part of
the root set.</p>
<p>The primary downside is unnecessary pointer indirection when
accessing the object. Additionally, this approach uses a mutable pointer
in the data segment and requires a memory allocation.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span># %bb.2:                                 // initializer</span></pre></td></tr></tbody></table></figure>
<h2 id="class-template-with-an-empty-destructor">Class template with an
empty destructor</h2>
<p>A common approach, as outlined in <a target="_blank" rel="noopener" href="https://wg21.link/p1247">P1247</a>, is to use a class template
with an empty destructor to prevent exit-time destruction:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>template</span> &lt;<span>class</span> <span>T</span>&gt; <span>class</span> <span>no_destroy</span> {</span></pre></td></tr></tbody></table></figure>
<p>libstdc++ employs a variant that uses a union member.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>struct</span> <span>A</span> { ~<span>A</span>(); };</span></pre></td></tr></tbody></table></figure>
<p>C++20 will support constexpr destructor:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>template</span> &lt;<span>class</span> <span>T</span>&gt; <span>union</span> <span>no_destroy</span> {</span></pre></td></tr></tbody></table></figure>
<p>Libraries like <a target="_blank" rel="noopener" href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/no_destructor.h"><code>absl::NoDestructor</code></a>
and <a target="_blank" rel="noopener" href="https://github.com/facebook/folly/blob/main/folly/Indestructible.h"><code>folly::Indestructible</code></a>
offer similar functionality. The absl version optimizes for trivially
destructible types.</p>
<h3 id="compiler-optimization-for-no-op-destructors">Compiler
optimization for no-op destructors</h3>
<p>Ideally, compilers should optimize out exit-time destructors for
empty user-provided destructors:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>struct</span> <span>C</span> { <span>C</span>(); ~<span>C</span>() {} };</span></pre></td></tr></tbody></table></figure>
<p>LLVM has addressed this <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/ee6bc70d2f1c2434ca9ca8092216bdeab322c7e5">since
2011</a>. Its GlobalOpt pass eliminates <code>__cxa_atexit</code> calls
related to empty destructors, along with other global variable
optimizations.</p>
<p>In contrast, GCC has an <a target="_blank" rel="noopener" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=19661">open feature
request</a> for this optimization since 2005.</p>
<h3 id="no_destroy-attribute"><code>no_destroy</code> attribute</h3>
<p>Clang supports <code>[[clang::no_destroy]]</code> (alternative form:
<code>__attribute__((no_destroy))</code>) to disable exit-time
destructors for variables of static or thread storage duration. Its
<code>-fno-c++-static-destructors</code> option allows disabling
exit-time destructors globally.</p>
<ul>
<li>July 2018 discussion: <a target="_blank" rel="noopener" href="https://discourse.llvm.org/t/rfc-suppress-c-static-destructor-registration/49128">https://discourse.llvm.org/t/rfc-suppress-c-static-destructor-registration/49128</a></li>
<li>Patch: <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D50994">https://reviews.llvm.org/D50994</a> with follow-up <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D54344">https://reviews.llvm.org/D54344</a></li>
<li>Documentation: <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/AttributeReference.html#no-destroy">https://clang.llvm.org/docs/AttributeReference.html#no-destroy</a></li>
</ul>
<p>Standardization efforts for this attribute are underway <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1247r0.html">P1247R0</a>.</p>
<p>I recently encountered a scenario where the <code>no_destroy</code>
attribute would have been beneficial. I&#39;ve filed a GCC feature request
(<a target="_blank" rel="noopener" href="https://gcc.gnu.org/PR114357">PR114357</a>) after I learned
that GCC doesn&#39;t have the attribute.</p>
<h2 id="case-study">Case study</h2>
<p>LLVM provides <code>ManagedStatic</code> to construct an object
on-demand (good for reducing startup time) and make destruction
explicitly through <code>llvm_shutdown</code>.
<code>ManagedStatic</code> is intended to be used at namespace scope. A
prime example is LLVM&#39;s statistics mechanisms (<code>-stats</code> and
<code>-time-passes</code>).</p>
<p>Programs using LLVM can strategically avoid calling
<code>llvm_shutdown</code> for fast teardown by skipping some
destructors. The lld linker employs this approach unless the
<code>LLD_IN_TEST</code> environment variable is set to a non-zero
integer.</p>
<p>DSO plugin users requiring library unloading may <a target="_blank" rel="noopener" href="https://discourse.llvm.org/t/making-llvm-play-nice-r-when-used-as-a-shared-library-in-a-plugin-setting/63306">find
<code>ManagedStatic</code> unsuitable</a>. This is because:</p>
<ul>
<li>A DSO may not be able to determine if other active LLVM users exist
within the process, making it unsafe to call
<code>llvm_shutdown</code>.</li>
<li>If <code>llvm_shutdown</code> is deferred until around program exit,
executing destructors becomes unsafe once the DSO&#39;s code has been
removed.</li>
</ul>
<p>The mold linker improves perceived linking speed by spawning a
separate process for the linking task. This allows the parent process
(the one launched from the shell or other programs) to exit early. This
approach eliminates overhead associated with static destructors and
other operations.</p>

      
    </div></div>
  </body>
</html>
