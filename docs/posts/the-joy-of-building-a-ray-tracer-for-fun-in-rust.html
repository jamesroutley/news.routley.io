<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.singleton.io/posts/2022-01-02-raytracing-with-rust/">Original</a>
    <h1>The joy of building a ray tracer, for fun, in Rust</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            

<p><em>TLDR? You can find the code and a bunch of examples on GitHub at <a href="https://github.com/dps/rust-raytracer">dps/rust-raytracer</a>.</em></p>

<p>Over the holiday break, I decided to learn Rust. Rust is a modern systems programming language which has a really interesting type system. The type system can catch broad classes of common programming mistakes - e.g. ensuring memory is accessed safely - at compile time while generating tight, performant machine code. I‚Äôve heard a lot about Rust from friends and colleagues over the past several years. Their most frequent descriptions in the early days were ‚Äúesoteric‚Äù and ‚Äúpuzzling‚Äù but during 2021 it‚Äôs been increasingly common to hear gushing praise for the language.</p>

<center>
<figure>
<blockquote><p lang="en" dir="ltr">rust is a perfect programming language</p>‚Äî jack‚ö°Ô∏è (@jack) <a href="https://twitter.com/jack/status/1474263588651126788?ref_src=twsrc%5Etfw">December 24, 2021</a></blockquote> 
<figcaption>Former Twitter CEO Jack Dorsey described Rust as a ‚Äúperfect‚Äù programming language last week.</figcaption></figure>
</center>

<p>I had run through ‚Äúhello world‚Äù and simple boilerplate web server examples in early versions of Rust but didn‚Äôt leave those experiences feeling like this language was about to take over the world. Now I really wanted to understand what all the fuss was about so decided to try building something real in Rust to see for myself - building a simple ray tracer was a great fit.</p>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/cover.png" alt="An example of what my raytracer can do"/></p>

<p>This post isn‚Äôt really about ray tracing, for that you should check out the wonderful <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend by Peter Shirley</a>. Nor is it really a post about Rust, for that you can try the <a href="https://doc.rust-lang.org/book/">Rust Book</a> or the <a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">O‚ÄôReilly book</a> which I enjoyed. What I‚Äôd like to share with you is simply how much <em>fun</em> it was to fiddle around with my own software which paints pretty pictures of a virtual world while exploring a whole new way of thinking about code.</p>

<h2 id="getting-started-rust">Getting started: Rust</h2>

<p>I‚Äôm a bit of a polyglot as programming languages go (or perhaps jack of all languages, master of none üôà). I keep mostly current in C++, Java, Go, python, ruby and Javascript and write a little Scala each year too. I knew that Rust‚Äôs memory management was going to be a bit different to each of those, though I well understood the motivation for it having written plenty of buggy code in all of the above. As Rust would feel different, I knew I would do best to start by reading.</p>

<p>Rust has batteries-included documentation baked right in to its toolchain - you can get straight to the docs in your browser after a fresh Rust install with <code>rustup docs</code>. This includes <a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a> and <a href="https://doc.rust-lang.org/book/">The official Rust book</a>. I had a couple of flights to take, so I started with a ‚Äúreal‚Äù book. The <a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">O‚ÄôReilly ‚Äúcrab‚Äù book</a> by Jim Blandy, Jason Orendorff and Leonora Tindall. This is one of the best O‚ÄôReilly books I have used - it opens with a brief treatise on why you should learn Rust and then dives in to three worked examples of real and <em>not-completely-trivial</em> programs which help you get a feel for the syntax, the standard library and the power of Rust‚Äôs build and packaging system <code>cargo</code>. I loved this - starting with real code is great. If you‚Äôre getting started with Rust I thoroughly recommend it.</p>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/rust_book.jpeg" alt="O&#39;Reilly Rust book cover"/></p>

<p>At first glance, Rust looks a bit like C but I found it best to try <em>not</em> to think of it that way. For the first hour or so I was reaching for constructs like the ternary operator (<code>x = condition ? a : b</code>) in C or Javascript, but soon realized that (i) there is no ternary operator because (ii) there are much better ways of expressing stuff like that because‚Ä¶ Rust is an expression language like LISP or Ruby. That means almost <em>everything</em> is an expression, even <code>if</code> statements so <code>let x = if condition { a } else { b }</code> just works. Here you can see a <em>closure</em> in Rust and the extremely versatile <code>match</code> block and <code>Option</code> enum which reminds me of Scala code.</p>

<pre><code>|texture: &amp;Option&lt;(Vec&lt;u8&gt;, usize, usize, String)&gt;| {
    match texture {
        Some(tuple) =&gt; tuple.3.clone(),
        None =&gt; &#34;&#34;.to_string(),
    }
}
</code></pre>

<p>In fact writing Rust code reminds me most of writing Scala with some of the nice parts of the toolchain of Go and the package ecosystem of Javascript/npm thrown in. Besides that, of course, there‚Äôs a mysterious little <code>.clone()</code> in that snippet - the way Rust handles memory management and object lifecycles is all its own. More on that in a bit‚Ä¶</p>

<h2 id="getting-started-ray-tracer">Getting started: ray tracer</h2>

<p>Ray tracing is a technique for creating images of a virtual scene by modeling what happens to the path of virtual rays of light as they bounce off all the objects in it. We place a bunch of objects including a camera and light source(s) in a scene. Then we shoot rays of light out at the scene for each pixel in the image we‚Äôre trying to draw.</p>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/diagram.png" alt="Diagram of camera and objects in a scene"/></p>

<p>Every time a light ray hits an object we model what would happen to it using a real-world physics/optics based model and lots of trigonometry. For example, if a light ray hits a shiny surface we model it being reflected off at the correct angle. We continue tracing the ray‚Äôs path as it bounces around until it reaches a light-source (or is completely absorbed) and then work the color of that light and the effect of each surface it hit all the way back to the eye to determine the color of that particular pixel in our final image. In fact we do that many times for each pixel and average the color together (reflections off rough surfaces are random, for instance, so you can get a different result each time a ray shoots out from the same pixel). The really cool thing is that if we implement just a few rules for a few different kinds of material in the scene, ray tracing can produce impressive, close to photorealistic, results.</p>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/weekend_cover.png" alt="Cover image from Ray Tracking in one weekend, but this one was rendered by my Rust code"/></p>

<p>To build my ray tracer, I started by following <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Peter Shirley‚Äôs guide: Ray Tracing in One Weekend</a>. Peter‚Äôs guide includes example code in C++ and is really clear and well paced. It goes into a lot of detail on the math and physics behind the raytracer. As I translated the code into Rust, I tried not to copy it directly but rather to figure out a more idiomatic Rust way of doing what I wanted. I think this was fairly successful - my code certainly reads more like Rust than C++ as the commits proceed.</p>

<p>If you open up Peter‚Äôs guide, you‚Äôll see that the cover image looks strikingly like the one above. That one, however, was generated entirely by my own code written in Rust. I made a few mistakes along the way - for instance, check out this wonky ‚Äúsphere‚Äù.
<img src="https://blog.singleton.io/static/imgs-raytracer/debugging_aspect_ratio.png" alt="wonky sphere"/></p>

<blockquote>
<p>This wonky sphere is a result of my code to compute the aspect ratio of the image not working correctly and took an embarrassingly long time to debug. I had written something like: <code>let aspect_ratio = (800 / 600) as f64</code> You‚Äôve probably spotted the bug already? Rust sees 800 and 600 are both integers and does integer division producing <code>1 as f64</code> ü§¶. This is not Rust‚Äôs fault (python does the same FWIW), but I had a few habits to unlearn from recent weeks of Javascript coding.</p>
</blockquote>

<p>It was extremely satisfying to end up with a fully working implementation in a new language.</p>

<p>I won‚Äôt rehash the guide step by step here - go take a look for yourself. I will say that simply getting a basic ray tracer working is an excellent project to explore the features of any new language. There‚Äôs enough code that you‚Äôll want to split it into modules. You need to create plenty of objects and use some mechanism where code can work on objects of different types (e.g. so that operations on rays bouncing off of objects made of different materials can reuse the same code). You‚Äôll also have to figure out how to debug the code you are writing. As a treat you get to look at lots of pretty (and sometimes not so pretty) pictures along the way.</p>

<h2 id="impressions-of-rust">Impressions of Rust</h2>

<h3 id="rust-memory-model">Rust memory model</h3>

<p>Rust‚Äôs memory model and type system‚Äôs understanding of how objects are owned, what interacts with them and when was the most novel part of the whole experience. I <em>ultimately</em> found this quite intuitive to understand and powerful to work with. I made a few mistakes that tested my understanding. The compiler feels persnickety for sure, but the error messages it produces are really clear and helped me learn how to think about the concepts involved.</p>

<pre><code>error[E0382]: use of moved value: `foo`
  --&gt; src/main.rs:20:15
   |
18 |     let foo: String = &#34;Hello, world!&#34;.to_string();
   |         --- move occurs because `foo` has type `std::string::String`, which does not implement the `Copy` trait
19 |     consume(foo);
   |             --- value moved here
20 |     let bar = foo;
   |               ^^^ value used here after move
</code></pre>

<p>Rust doesn‚Äôt have a garbage collected memory model like Go or Java. Like C++ this makes it <em>possible</em> to write more efficient and deterministically performant code. The challenge of doing this in C++ is that ensuring you access memory correctly and safely (e.g. never <a href="https://en.wikipedia.org/wiki/Dangling_pointer">using a pointer to an object after it has been freed</a>) is entirely your concern. Empirically most C++ codebases have many cases of unintended, unsafe, memory access which introduce correctness and security problems. Rust aims to fix this by restricting how programs can use pointers to objects and verifying at compile time that the rules haven‚Äôt been broken.</p>

<blockquote>
<p>‚ÄúRust‚Äôs rules are probably unlike what you‚Äôve seen in other programming languages. Learning how to work with them and turn them to your advantage is, in our opinion, the central challenge of learning Rust.‚Äù
‚Äì Programming Rust, O‚ÄôReilly Media.</p>
</blockquote>

<h4 id="ownership">Ownership</h4>

<p>Rust makes the concept of ownership explicit (vs implicit in C++). Except for very simple types (like integers, characters), every value has a single owner and they are freed when the owner goes out of scope. Values are explicitly <em>moved</em> from one owner to another and the compiler verifies that they are not accessed via the original owner after such a move. You can ‚Äúborrow‚Äù a reference to a valued owned by another object. There are two types of reference - shared <em>read only</em> references and mutable references. Mutable references allow reading <em>and writing</em> the value, but crucially the compiler ensures that one and only one mutable reference can exist at a time. These restrictions prevent use-after-free errors and also help ensure safe access to data in a multi-threaded context (either one thread can be reading and writing and object or many threads can be reading).</p>

<p>For my raytracer, all the objects that represent the scene need to be set up and then shared across the threads doing the rendering. The scene can contain objects like <code>Sphere</code>s which can be made of <code>Texture</code> type materials. Textures can hold huge bitmaps and we definitely don‚Äôt want to copy them around as execution proceeds. Our <code>Texture</code>s need to have a single owner and correctly use references across the program.</p>

<pre><code>
// The scene is parsed from a json file, loading every Texture that is referenced.
// scene now owns all the related objects - the Spheres, the Camera etc.
let scene = serde_json::from_slice::&lt;Config&gt;(&amp;json).expect(&#34;Unable to parse config json&#34;);

// ...
// Much later, when it&#39;s time to render a line in the image, we pass scene in as a reference.
// render_line runs across many threads so the scene reference here is a shared, read-only, one.
render_line(band, &amp;scene, &amp;lights, i);
</code></pre>

<p>By contrast, I made the simple type <code>Point3D</code> (which just stores three floats) one that could be copied when needed with <code>#[derive(... Copy ...)]</code>:</p>

<pre><code>#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct Point3D {
    x: f64,
    y: f64,
    z: f64,
}
</code></pre>

<p><code>Point3D</code>s are therefore <em>passed by value</em> in function calls. Making both pass by reference and pass by value possible and so clear as a direct language feature is something I really appreciated.</p>

<h3 id="arranging-code">Arranging code</h3>

<p>In this regard, Rust is quite particular and the docs quite confusing (or at least long winded and lacking a quick practical example). The source files <code>main.rs</code> and <code>lib.rs</code> within a package are magically known to the build system (as well as <code>mod.rs</code> in subdirectories). Modules can, of course, be broken up into additional files beyond these and when referenced with a <code>mod module_name</code> statement within one of the known files (or dependent code pulled in already) the build system automatically tries to find them at <code>module_name.rs</code> or <code>module_name/mod.rs</code>. It‚Äôs a bit weird but at least you don‚Äôt have to write any BUILD files by hand. The full docs on how to <a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">structure your code across modules and files</a> are here.</p>

<p>This is perhaps a good moment to mention that there‚Äôs much less StackOverflow content for Rust than I was used to for Javascript, python etc. Google also mostly serves the official docs (or mirrors of them) for most queries, so if the official docs are not great on a particular topic, there‚Äôs a good chance you‚Äôll have to figure it out for yourself. Did I mention the O‚ÄôReilly book was a godsend?</p>

<h3 id="polymorphic-types">Polymorphic types</h3>

<p>Polymorphism in Rust works more like it does in Go than in C++ or Java. Rust doesn‚Äôt do polymorphism by inheritance / subclassing. Indeed, there‚Äôs no concept of inheritance among objects at all in Rust.</p>

<p>Instead Rust uses generics to abstract over different possible types and <code>trait</code>s to impose constraints on what those types must provide.</p>

<blockquote>
<p>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it‚Äôs often at risk of sharing more code than necessary. Subclasses shouldn‚Äôt always share all characteristics of their parent class but will do so with inheritance. ‚Ä¶
For these reasons, Rust takes a different approach, using trait objects instead of inheritance.
‚Äì Rust docs</p>
</blockquote>

<p>For the ray tracer, I defined <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a> for two types - <code>Hittable</code> and <code>Scatterable</code>. Hittable is the base type for any object that a ray of light can hit. Scatterable is a behavior of materials that objects are made of and determines what happens to the light ray as it is scattered off them.</p>

<pre><code>pub trait Hittable {
    fn hit(&amp;self, ray: &amp;Ray, t_min: f64, t_max: f64) -&gt; Option&lt;HitRecord&gt;;
}

pub trait Scatterable {
    fn scatter(&amp;self, ray: &amp;Ray, hit_record: &amp;HitRecord) -&gt; Option&lt;(Option&lt;Ray&gt;, Srgb)&gt;;
}
</code></pre>

<h3 id="debugging">Debugging</h3>

<p>The most natural way to debug a ray tracer involves generating small test scenes, rendering them and seeing whether the results match your intuition. Each iteration can take tens of seconds and this becomes tedious quite quickly. I started to rely instead on unit tests for each part of the code. Rust makes this delightfully simple. You can write tests inline in the same file as the code being exercised, labeled with a special <code>#[test]</code> attribute. <code>cargo test</code> then compiles and runs all the tests in the package.</p>

<pre><code>#[test]
fn test_sphere_hit() {
    let center = Point3D::new(0.0, 0.0, 0.0);
    let sphere = Sphere::new(center, 1.0, ...);
    let ray = Ray::new(Point3D::new(0.0, 0.0, -5.0),
                       Point3D::new(0.0, 0.0, 1.0));
    let hit = sphere.hit(&amp;ray, 0.0, f64::INFINITY);
    assert_eq!(hit.unwrap().t, 4.0);
}
</code></pre>

<p>As my project became more elaborate, I added <code>cargo test</code> to a git precommit hook and wrote test cases which rendered (a very very low res version of) a couple of test scenes. This was super useful to keep every commit nice and clean.</p>

<h2 id="the-real-fun-begins">The real fun begins</h2>

<p>Now I had a complete simple ray tracer and a basic understanding of how Rust works, it was time to have some fun! Peter Shirley suggests a few <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#wherenext?">extensions</a> at the end of his guide.</p>

<h3 id="parallel-rendering">Parallel rendering</h3>

<p>I wanted to go beyond a single frame and make some cool animations of the camera flying around my scene. However, rendering a single 800x600 frame for a complex scene was pretty slow (approx 20 seconds) so my first task was to speed that up. Initially I was only rendering in a single thread on one CPU core, but my laptop has 8 CPU cores (16 CPU threads). Ray tracing is inherently very parallelizable - we can model each ray independently of all the others. Let‚Äôs see if we can use all that processing power to speed things up. The Rust ecosystem has a bunch of modules that make concurrent programming easy. I followed the same process demonstrated in the O‚ÄôReilly book to speed up the rendering of a Mandelbrot set and ultimately used the <code>rayon</code> crate to achieve an approx 10x speed up by distributing the load across CPUs. <a href="https://github.com/rayon-rs/rayon">Rayon</a> is a data-parallelism library for Rust which makes it easy to convert a sequential computation into a parallel one. It also guarantees freedom from data-races. Rayon was impressively easy to use.</p>

<pre><code> 1  let mut pixels = vec![0; image_width * image_height * 3];
 2  let bands: Vec&lt;(usize, &amp;mut [u8])&gt; = pixels.chunks_mut(image_width * 3).enumerate().collect();
 3
 4  bands.into_par_iter().for_each(|(i, band)| {
 5      render_line(band, &amp;scene, &amp;lights, i);
 6  });
</code></pre>

<p>Rust has standard library support to break a large structure like the vector holding our output image pixels here into many non-overlapping mutable chunks. This makes it possible to divide work across multiple threads where each thread owns a subset of the overall output data, maintaining the single writer constraint. That‚Äôs what <code>chunks_mut</code> does on line 2 above - we‚Äôre breaking our vector of pixels into chunks representing each line in the output.</p>

<p><code>into_par_iter</code> is a a Rayon primitive and it‚Äôs kinda magic! It decides how to divide the data into tasks and it will dynamically adapt for maximum performance as computation proceeds.</p>

<p>This really works! Not every line in a ray traced scene is equally complicated to compute (e.g. the top row will often be all sky and intersect no objects, whereas a line near the center of the scene might have much more complexity).</p>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/complication.jpeg" alt="Diagram showing the relative complication to draw scene"/></p>

<p>Before I tried Rayon, I used another crate (crossbeam) which divided the work naively across CPUs, here‚Äôs what the wall clock time looked like on each CPU to render a single frame:</p>

<pre><code>Rendering anim/frame_003.png
Chunk time: 573ms   // the &#34;easiest&#34; 1/8th
Chunk time: 776ms
Chunk time: 1728ms
Chunk time: 4180ms
Chunk time: 5215ms
Chunk time: 5428ms
Chunk time: 5632ms
Chunk time: 5705ms  // the &#34;hardest&#34; 1/8th
Frame time: 5735ms  // time for the whole frame. 
</code></pre>

<p>Here we‚Äôre using 8 threads to render 1/8th of the lines each. The time to complete the frame is determined by the most complicated eighth. But that one took 10 times longer to render than the simplest. What we want is for that first CPU, once it‚Äôs done to start ‚Äústealing‚Äù work from the ones which are lagging overall and that‚Äôs exactly what Rayon does to achieve a faster overall throughput.</p>

<p>Ultimately, dividing the work up with <code>into_par_iter</code> rendered the same frame in 2500 ms and made it possible to max out my laptop CPU. By parallelizing the work, Rayon achieved a 10x speed up with the same input data vs a single threaded render.</p>

<h3 id="texture-mapping">Texture mapping</h3>

<p>My ray tracer draws spheres. It‚Äôs really simple, so it can <em>only</em> draw spheres. What‚Äôs the coolest thing you can draw with spheres? Yep, I wanted to draw the earth and the moon (and maybe if I could get lighting working well simulate an eclipse by casting the shadow of the moon onto the earth). To make the earth look like the earth, I needed to implement texture mapping - to wrap a satellite image around the sphere and determine the right color for each ray intersection from it.
<img src="https://blog.singleton.io/static/imgs-raytracer/texture.jpeg" alt="texture mapping to sphere"/></p>

<p>Conceptually this is fairly simple - the vector from the sphere‚Äôs center to the point hit by the ray is easy to calculate by doing vector arithmetic and subtracting the sphere‚Äôs center point from point where the ray intersected the sphere. Once normalized, the y component of that vector determines <em>v</em> - the latitude on the sphere and vertical offset in the texture image. <em>u</em> - the longitude / horizontal offset can be computed with arctan(x/z) / 2ùúã (i.e. the angular distance around the sphere). While it might be conceptually simple, I managed to implement this wrong on the first couple of tries.</p>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/debugging_texture_no_work.png" alt="debug this"/>
</p><center><figcaption>First attempt at texture mapping‚Ä¶ This should look like the earth.</figcaption></center>

<p>I assumed the problem was with my trigonometry (and indeed, it was broken). The easiest way to debug this turned out to be to ignore the texture pixels and check that I could simply render the northern/southern/eastern and western hemispheres correctly:
<img src="https://blog.singleton.io/static/imgs-raytracer/debugging_texture.png" alt="debug this"/>
<img src="https://blog.singleton.io/static/imgs-raytracer/debugging_texture_2.png" alt="debug this"/>
Once I got that working it turned out the pixel indexing code was wrong too. This might look cool, but it‚Äôs not the earth! It took a couple more debugging steps to get this right.
<img src="https://blog.singleton.io/static/imgs-raytracer/debugging_texture_no_work_nice.png" alt="debug this"/>
</p><center><figcaption>Cool but not the earth - pixel indexing math was wrong.</figcaption></center>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/debugging_texture_no_work_upside.png" alt="debug this"/>
</p><center><figcaption>Upside down! But at least this should be easy to fix.</figcaption></center>

<p>Finally, I figured it all out and was able to make this pretty neat looking animation.
<span>
        <video muted="" playsinline="" preload="auto" autoplay="false">
                <source src="https://user-images.githubusercontent.com/237355/147687883-4e9ca4fc-7c3b-4adb-85d7-6b08d1bc69f7.mp4" type=""/>
        </video>
</span></p>

<h3 id="lighting">Lighting</h3>

<blockquote>
<p>Lights ‚Äî You can do this explicitly, by sending shadow rays to lights, or it can be done implicitly by making some objects emit light, biasing scattered rays toward them, and then downweighting those rays to cancel out the bias. Both work. I am in the minority in favoring the latter approach.</p>

<p>‚Äì Ray Tracing in One Weekend</p>
</blockquote>

<p>I decided to try Peter Shirley‚Äôs approach to lighting as mentioned above. For each scattering interaction with some probability I cast new rays towards the center of every light in the scene.</p>

<p><img src="https://blog.singleton.io/static/imgs-raytracer/first_light.png" alt="debug this"/>
This was the first attempt - it looks pretty good! But it didn‚Äôt work quite right when I cranked up the samples per pixel to show more detail. Check out the glass sphere on the left below  - it shouldn‚Äôt be starting to look opalescent.
<img src="https://blog.singleton.io/static/imgs-raytracer/first-lighting-recast.png" alt="debug this"/>
Debugging/iterating on this was <em>really</em> fun. I just kinda followed my nose and experimented with a bunch of stuff. This part of the project really helped me truly understand how every part of the ray tracer works. Here‚Äôs an example - I wanted to figure out how much difference the maximum depth of recursion in rendering made. In the animation below you can see the detail that appears with each subsequent depth limit.
<img src="https://blog.singleton.io/static/imgs-raytracer/max_depth_anim.gif" alt="debug this"/>
It‚Äôs pretty cool to see only direct illumination on the first pass, the first set of reflections on the second. The moon appears at max_depth 5 because it is <em>inside</em> a hollow glass sphere itself composed of two nested spheres - so you have to traverse that many object intersections before the light can get in to the moon and escape back out to the camera!
<img src="https://blog.singleton.io/static/imgs-raytracer/lighting-recast-2.png" alt="debug this"/></p>

<p>Here‚Äôs my final lighting set up, applied to a scene with a small offset light and a big light directly above the objects. You can see the light and shadows cast by each light.
<img src="https://blog.singleton.io/static/imgs-raytracer/lighting-recast-final.png" alt="debug this"/></p>

<h3 id="render-a-sky-texture">Render a sky texture</h3>

<p>Before the lighting code I added, all the light in the scene came from the sky, which is rendered as a continuous gradient from light blue to white. A logical extension of the texture mapping work is to apply a texture to the sky. I figured it would look pretty cool to see realistic clouds in the sky. The end result didn‚Äôt disappoint - I think this is cool!
<img src="https://blog.singleton.io/static/imgs-raytracer/sky_textures.gif" alt="Animation of sky texture renders"/>
While I had already written texture and lighting code to solve the crux of this problem, getting it done required a big refactor of the code to avoid lots of duplicated logic and motivated the final feature I added - the ability to read scene data from a file.
<img src="https://blog.singleton.io/static/imgs-raytracer/sky_texture_experiment_5.png" alt="One of my later stage renders"/>
</p><center><figcaption>One of my later stage renders.</figcaption></center>

<h3 id="read-scene-data-from-json-file">Read scene data from JSON file</h3>

<p>Reading the scene from a file gave me a chance to explore the <code>serde</code> crate. Serde is a framework for serializing and deserializing Rust data structures efficiently and generically. Serde is built on the trait system and can read and write a whole bunch of formats including JSON. It can autogenerate (‚Äúderive‚Äù) deserializers for arbitrary structs. It‚Äôs also possible to customize these. Here‚Äôs an example - for the texture property of my <code>Sky</code> struct, I didn‚Äôt want to serialize out all the raw pixel data. This property should be serialized as the path to the file that contains the data. Deserializing should read the file path and then try to load the raw data from the file. The <code>serde_conv</code> macro made this pretty easy (elegant, even?)</p>

<pre><code>#[serde_with::serde_as]
#[derive(Debug, Serialize, Deserialize)]
pub struct Sky {
    #[serde_as(as = &#34;TextureOptionPixelsAsPath&#34;)]
    pub texture: Option&lt;(Vec&lt;u8&gt;, usize, usize, String)&gt;,
}

serde_with::serde_conv!(
    TextureOptionPixelsAsPath,
    Option&lt;(Vec&lt;u8&gt;, usize, usize, String)&gt;,
    |texture: &amp;Option&lt;(Vec&lt;u8&gt;, usize, usize, String)&gt;| {
        match texture {
            Some(tuple) =&gt; tuple.3.clone(),
            None =&gt; &#34;&#34;.to_string(),
        }
    },
    |value: &amp;str| -&gt; Result&lt;_, std::convert::Infallible&gt; {
        match value {
            &#34;&#34; =&gt; Ok(None),
            _ =&gt; Ok(Some(load_texture_image(value))),
        }
    }
);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Building a ray tracer was a great way to learn Rust. Rust is a powerful and effective language - it has a learning curve but rewards study! You can find the code I wrote and a bunch of examples on GitHub at <a href="https://github.com/dps/rust-raytracer">dps/rust-raytracer</a>.</p>

<p>And finally, here is that little earth / moon eclipse scene I was excited about. The size of the shadow is not to scale, but it‚Äôs fun to see some <a href="https://en.wikipedia.org/wiki/Earthlight_(astronomy)">earthshine</a> illuminating the dark side of the moon!
<img src="https://blog.singleton.io/static/imgs-raytracer/eclipse.png" alt="Eclipse"/></p>

<p>‚Äì Thanks to Luke Miles for reviewing a draft of this post.</p>

        </div></div>
  </body>
</html>
