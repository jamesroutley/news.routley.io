<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eshelyaron.com/posts/2024-11-27-emacs-aritrary-code-execution-and-how-to-avoid-it.html">Original</a>
    <h1>Emacs arbitrary code execution and how to avoid it</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<header>

<p role="doc-subtitle">Details and advice about a long standing arbitrary code execution vulnerability in Emacs</p>
</header><p>Created on <span><span>[2024-11-27]</span></span>, last updated <span><span>[2024-11-27]</span></span></p>


<p>
This is a security advisory about CVE-2024-53920, an Emacs
vulnerability that I (re-)discovered a few months ago.
</p>
<div id="outline-container-org049caf1">
<h2 id="org049caf1">TL;DR</h2>
<div id="text-org049caf1">
<p>
Viewing or editing Emacs Lisp code in Emacs can run arbitrary code.
The vulnerability stems from unsafe Lisp <i>macro-expansion</i>, which runs
unrestricted Emacs Lisp code.  Most common configurations are
vulnerable (see details below).  The best security measures are:
</p>

<ul>
<li>Avoid visiting untrusted <code>.el</code> files in Emacs</li>
<li>Disable automatic error checking (with Flymake or Flycheck) in
untrusted <code>.el</code> files</li>
<li>Disable auto-completion features in untrusted <code>.el</code> files</li>
</ul>

<p>
This is a long-standing vulnerability which has been known for several
years, but has not been addressed thus far.  Emacs maintainers are
working on countermeasures that will hopefully make their way into
future Emacs versions.  This advisory is intended to help users of
existing Emacs versions protect themselves.
</p>
</div>
</div>
<div id="outline-container-org33b9590">
<h2 id="org33b9590">Background</h2>
<div id="text-org33b9590">
<p>
<i>Macros</i> are a staple feature across Lisp dialects.  They are often
cited as one of the superpowers of Lisp.  They are essentially a
meta-programming facility: a macro is just a Lisp function that
outputs Lisp code.  Since Lisp is homoiconic (code and data are
represented using the same data structures), manipulating Lisp code in
Lisp is as simple as processing any other program input.  This makes
such meta-programming fun and easy, especially in comparison to the
experience of writing elaborate C preprocessor macros, for example,
which often feels a bit hackish.
</p>

<p>
However, as is often the case with great powers, Lisp macros are
double-edged swords—wielding them safely requires special care.
</p>

<p>
Normally, macros are executed, or “expanded”, during so-called
macro-expansion time: after parsing (“reading”) text into a Lisp form,
macro calls that occur in the form are expanded by executing the
macro, which produces new (sub-)forms.  The macro-free form obtained
by expanding all macro calls can then be compiled and executed.  Thus
macro-expansion time comes after “read time” and before compile time
and runtime.
</p>

<p>
<i>Emacs Lisp</i> is the programming language used implement most of
Emacs’s core features and extensions, as well to configure it.  It is
not the most powerful Lisp dialect out there, but it does boast a
full-blown meta-programming facility in the form of macros.  The
problem is that macros in Emacs Lisp come with no safety
measures—they can execute arbitrary, unrestricted, Emacs Lisp code.
The basic macro-expansion primitive in Emacs is the Lisp function
<code>macroexpand</code>, defined in C code in <code>src/eval.c</code> in the Emacs sources.
It repeatedly replaces macro names with their definitions as
functions, and applies those functions to the provided code:
</p>

<div>
<pre><span>while</span> <span>(</span>1<span>)</span>
  <span>{</span>
    

...
    <span>{</span>
      <span>Lisp_Object</span> <span>newform</span> = apply1 <span>(</span>expander, XCDR <span>(</span>form<span>)</span><span>)</span>;
      <span>if</span> <span>(</span>EQ <span>(</span>form, newform<span>)</span><span>)</span>
        <span>break</span>;
      <span>else</span>
        form = newform;
    <span>}</span>
  <span>}</span>
<span>return</span> form;
</pre>
</div>

<p>
That <code>apply1</code> call up there can do, well, literally anything,
depending on the <code>expander</code> function (the definition of the macro) and
the given input <code>form</code>.
</p>

<p>
The Emacs Lisp library <code>macroexp.el</code> provides higher-level routines on
top of this <code>macroexpand</code> primitive, such as <code>macroexpand-all</code> which
the Lisp byte-compiler in <code>bytecomp.el</code> uses to preprocess Lisp forms.
</p>

<p>
In addition, Emacs ships with several built-in macros that actually do
execute arbitrary code by <i>evaluating</i> some of their arguments, no
questions asked.  These macros are <code>static-if</code>, <code>rx</code>, <code>cl-eval-when</code>,
<code>eval-when-compile</code>, <code>eval-and-compile</code>, and perhaps others.
</p>

<p>
Therefore, if we can nudge Emacs to expand one of these macros, we get
arbitrary code execution.  That’s the crux of this vulnerability.
<i>Expanding macros in Emacs Lisp is unsafe by design</i>.
</p>
</div>
</div>
<div id="outline-container-org435223b">
<h2 id="org435223b">Exploitation</h2>
<div id="text-org435223b">
<p>
But could an attacker really coerce Emacs to expand macros without an
explicit user request?  When you open (or “visit”, in Emacs parlance)
an Emacs Lisp file, Emacs enables “ELisp mode”, a dedicated editor
mode defined in <code>elisp-mode.el</code>, which provides various useful
features for exploring and editing Emacs Lisp code.
</p>

<p>
One of the features that ELisp mode provides is code completion.
Completion is implemented in the function <code>elisp-completion-at-point</code>,
which tries to examine the code around your cursor and come up with
relevant completions.  Among other things, it invokes a subroutine
<code>elisp--local-variables</code> that looks for local variable names in the
current scope.  Since macros can completely change the meaning of the
code they apply to, <code>elisp--local-variables</code> expands macros in the
surrounding code to uncover local variables that may be created or
obscured by such macros.  Hence <i>invoking code completion runs
arbitrary code</i>.  In vanilla Emacs, by default, code completion is
only triggered when you issue a completion command.  However, since
macros run arbitrary code in a Turing complete language (Emacs Lisp),
there’s no way to know for sure whether invoking completion will get
you pwned.  More importantly, almost no one uses the default Emacs
configuration.  Emacs users tweak various knobs, and in many common
configurations folks enable auto-completion features which then
trigger code completion without an explicit completion command.  Such
auto-completion is performed by the popular Emacs packages Corfu and
Company, as well as the newly built-in <a href="https://eshelyaron.com/posts/2023-11-17-completion-preview-in-emacs.html">Completion Preview mode</a>.
</p>

<p>
But the most common flow that involves automatic macro-expansion is
probably <i>on-the-fly code diagnosis</i>.  There are two widespread Emacs
packages that check your code and warn about potential errors
automatically.  One is Flymake, which is built into Emacs, and the
other is a popular extension package called <a href="https://www.flycheck.org/en/latest/">Flycheck</a>.  Both of them,
when enabled in an ELisp mode buffer, check for code issues by
<i>byte-compiling</i> the code.  As mentioned earlier, this involves
macro-expansion, and thus arbitrary code execution.  For Flymake, this
byte-compilation happens in the function <code>elisp-flymake-byte-compile</code>.
Like auto-completion, on-the-fly diagnosis is not enabled by default
in vanilla Emacs, but it is extremely common for users to enable it.
In some Emacs “distributions”, such as the popular <a href="https://github.com/doomemacs/doomemacs">Doom Emacs</a> and
<a href="https://prelude.emacsredux.com/en/latest/">Prelude</a>, either Flymake or Flycheck are enabled by default in ELisp
mode.
</p>

<p>
So the idea is simple: to exploit this vulnerability, an attacker
crafts an Emacs Lisp file that includes a malicious macro invocation,
and sends that file to an unsuspecting Emacs user.  When that user
opens the file in Emacs, code diagnosis is triggered automatically,
which expands macros and executes arbitrary code.
</p>

<p>
Here’s the content of the POC “malicious” file that I shared with the
Emacs maintainers when reporting this vulnerability:
</p>

<div>
<pre><span>(</span><span>rx</span> <span>(</span>eval <span>(</span><span>call-process</span> <span>&#34;touch&#34;</span> nil nil nil <span>&#34;/tmp/owned&#34;</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
If you have Flymake or Flycheck hooked to ELisp mode (again, such a
setting is often the default in Emacs starter kits, and generally very
common among Emacs users), then just putting the above line of code
anywhere in a <code>.el</code> file and opening that file in Emacs will create a
new file <code>/tmp/owned</code> on your system.  Such a setup usually looks
something like the following in the Emacs initialization file,
<code>~/.emacs.d/init.el</code>:
</p>

<div>
<pre>

<span>(</span><span>add-hook</span> &#39;emacs-lisp-mode-hook #&#39;<span>flymake-mode</span><span>)</span>
</pre>
</div>

<p>
This is reproducible at least since Emacs version from 26.1 and all
the way up to the development version of the upcoming Emacs 30.
</p>

<p>
So this is a long-standing vulnerability, and the gist of it is very
simple: macros are unsafe, and in common setups Emacs expands them
automatically.  I’ve come to discover this issue while working on an
enhancement for ELisp mode, which employed macro-expansion to provide
semantic code highlighting.  I quickly realized that doing so naively
is a security risk, and soon afterwards it hit me that Emacs suffered
from such a vulnerability already without my custom hacks.
</p>

<p>
The very same day, 17/08/2024, I reported my findings to the Emacs
maintainers via private email.  The maintainers informed me that
variants of this issue have been surfaced in the past, but the issue,
sadly, still stands.  AFAICT the earliest public discussion about the
security implications of Emacs Lisp macros started in August 2018,
when <a href="https://yhetil.org/emacs/CAFXAjY5f4YfHAtZur1RAqH34UbYU56_t6t2Er0YEh1Sb7-W=hg@mail.gmail.com/">Wilfred Hughes noted</a> that code completion can lead to arbitrary
code execution via macro-expansion.  In October 2019, <a href="https://yhetil.org/emacs/CAJw81da4=R1jMJ0enx6SbO7G1rzaL61K2kqbY+jxhe=AM-3vtQ@mail.gmail.com/">Adam Plaice
reported</a> that Flymake specifically can be used in a similar exploit.
Some solutions have been floated in the discussions following these
reports, but unfortunately, Emacs remains vulnerable to this very day.
</p>

<p>
Following my report, the maintainers requested 90 days to work on a
fix before public disclosure.  That non-disclosure period have since
expired, hence this advisory.  They continue to work on a fix, which I
hope will be available soon, and now we at least have a CVE to track
this vulnerability.  Until new guardrails are put in place to mitigate
this risk, it is important to realize that macro-expansion of
untrusted Emacs Lisp code is unsafe, and to be vigilant about <code>.el</code>
files that you open in Emacs.  Crucially, <b>do not enable
Flymake/Flycheck in ELisp mode automatically</b>.  Only allow automatic
macro-expansion in <code>.el</code> files that trust and you control, and protect
those files from tampering.
</p>
</div>
</div>
</div></div>
  </body>
</html>
