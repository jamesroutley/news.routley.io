<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.micahlerner.com/2022/06/04/data-parallel-actors-a-programming-model-for-scalable-query-serving-systems.html">Original</a>
    <h1>Data-Parallel Actors: A Programming Model for Scalable Query Serving Systems</h1>
    
    <div id="readability-page-1" class="page"><article>
<section>
<header>
<a href="https://www.micahlerner.com/">
<h3>micahlerner.com</h3>
</a>
</header>
</section>

<h4>Published June 04, 2022</h4>
<h5>
Found something wrong?
<a href="https://github.com/mlerner/mlerner.github.io/edit/master/_posts/2022-06-04-data-parallel-actors-a-programming-model-for-scalable-query-serving-systems.md">Submit a pull request!</a>
</h5>
<section>
<p>Discussion on <a href="https://news.ycombinator.com/item?id=32228569"> Hacker News</a></p>
<p>
<em>
After this paper, I’ll be switching gears a bit and reading/writing about papers from NSDI 2022. These paper reviews can <a href="https://newsletter.micahlerner.com/">be delivered weekly to your inbox</a>, or you can subscribe to the <a href="https://www.micahlerner.com/feed.xml">Atom feed</a>. As always, feel free to reach out on <a href="https://twitter.com/micahlerner">Twitter</a> with feedback or suggestions!
</em>
</p>
<p><a href="https://www.usenix.org/system/files/nsdi22-paper-kraft.pdf">Data-Parallel Actors: A Programming Model for Scalable Query Serving Systems</a></p>
<h2 id="what-is-the-research">What is the research?</h2>
<p>The research describes an actor-based framework<label for="actor"></label><span>Actors are a programming paradigm where one deploys multiple independent units that communicate through messages - <a href="https://www.brianstorti.com/the-actor-model/">here</a> is one resource on the approach. </span> for building <em>query-serving systems</em>, a class of database that predominantly respond to read requests and frequent bulk writes. The paper cites several examples of these systems, including Druid (covered in a <a href="https://www.micahlerner.com/2022/06/04/2022/05/15/druid-a-real-time-analytical-data-store.html">previous paper review</a>) and <a href="https://github.com/elastic/elasticsearch">ElasticSearch</a>.</p>
<p>The paper argues that <em>query-serving systems</em> are a common database deployment pattern sharing many functionalities and challenges (including scaling in cloud environments and recovery in the face of failure). Rather than relying on shared implementations that enable database scaling and fault tolerance, <em>query-serving systems</em> often reinvent the wheel<label for="choose"></label><span>Or choose not to provide functionality. </span>. Custom implementations incur unnnecessary developer effort and require further optimizations beyond the initial implementation. For example, Druid clusters provide scaling using a database-specific implementation, but often end up overprovisioning<label for="druidscaling"></label><span>The paper cites <a href="https://blog.acolyer.org/2018/06/15/popular-is-cheaper-curtailing-memory-costs-in-interactive-analytics-engines/">Popular is cheaper: curtailing memory costs in interactive analytics engines</a>, an article about Yahoo/Oath’s efforts to improve the provisioning of their Druid cluster. </span>. Sometimes <em>query-serving systems</em> take a long time to develop their own implementation of a feature - for example, Druid’s implementation of joins<label for="druidjoin"></label><span>Druid’s join support was proposed <a href="https://github.com/apache/druid/issues/8728">in 2019</a>, many years after the project’s initial release. </span>, and MongoDB’s implementation of consensus<label for="mongonote"></label><span>MongoDB replication is covered by <a href="https://www.usenix.org/conference/nsdi21/presentation/zhou">
Fault-Tolerant Replication with Pull-Based Consensus in MongoDB</a>, which is very interesting in and of itself. :) </span>.</p>
<figure><img src="https://www.micahlerner.com/assets/dpa/table2.png"/><figcaption></figcaption></figure>
<p>The DPA paper aims to simplify development, scaling, and maintenace of <em>query-serving systems</em>, using a runtime based on stateful actors. While the idea of building distributed systems on top of stateful actors is not necessarily new<label for="orleans"></label><span>Examples of using stateful actors exist in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Orleans-MSR-TR-2014-41.pdf">Orleans</a> and <a href="https://www.micahlerner.com/2021/06/27/ray-a-distributed-framework-for-emerging-ai-applications.html">Ray</a>. </span>, implementing a database runtime targeted at a common class of databases (<em>query-serving systems</em>) is novel.</p>
<figure><img src="https://www.micahlerner.com/assets/dpa/figure1.png"/><figcaption></figcaption></figure>
<h2 id="what-are-the-papers-contributions">What are the paper’s contributions?</h2>
<p>The paper makes three main contributions:</p>
<ul>
<li>Identifying and categorizing <em>query-serving systems</em>, a class of databases supporting “low-latency data-parallel queries and frequent bulk data updates”</li>
<li>A <em>Data Parallel Actor (DPA)</em> framework aimed at simplifying the implementation of <em>query-serving systems</em> using stateful actors.</li>
<li>Porting several <em>query-serving systems</em> to the <em>Data Parallel Actor</em> paradigm, then evaluating the performnace of the resulting implementations.</li>
</ul>
<h2 id="how-does-the-system-work">How does the system work?</h2>
<h3 id="actors-and-data">Actors and Data</h3>
<p>Actors are a key component of the <em>DPA</em> framework - several ideas from existing databases are reworked to fit an actor-based model, in particular <em>partitioning</em>, <em>writes</em>, and <em>reads</em>.</p>
<p>Many databases use <em>partitioning</em> to address problems related to fault tolerance, load balancing, and elasticity<label for="partitions"></label><span>Partitioning a dataset increases <em>fault tolerance</em> because a partitioned dataset can be scaled by adding more copies of each partition - if any one of them fails, requests can be forwarded to another copy. The paper cites the Shard Manager paper (covered by a <a href="https://www.micahlerner.com/2022/01/08/shard-manager-a-generic-shard-management-framework-for-geo-distributed-applications.html">previous paper review</a>), when discussing this idea of forwarding requests. A partitioned dataset is also easier to <em>load balance</em> because partitions can be shifted independently away from hotspots, distributing load across more machines. Lastly, partitioning increases <em>elasticity</em> by facilitating capacity increases in response to additional load - new machines can be started, each containing additional copies of partitions. </span>. DPA adapts partitioning by assigning partitions of a dataset to an actor. Actors manage partitions using a limited set of methods (including <code>create</code>, <code>destroy</code>, <code>serialize</code>, and <code>deserialize</code>) that a database developer implements according to the internals of their project.</p>
<p>The paper describes several advantages to the actor-based approach - in particular, building a distributed database on top of the DPA-based actor abstraction simplifies the implementation of fault tolerance, load balancing, and elasticity that databases would otherwise build themselves (or not at all). Rather than each <em>query-serving system</em> custom-writing these featuresets, the DPA framework handles them. In turn, the main component that developers become responsible for is implementing the Actor interface with the DPA framework.</p>
<figure><img src="https://www.micahlerner.com/assets/dpa/figure2.png"/><figcaption></figcaption></figure>
<h3 id="write-handling">Write handling</h3>
<p>To handle <em>writes</em>, a <em>query-serving system</em> based on DPA implements an <code>UpdateFunction</code> (accepting parameters like the table to be updated, the records to change or add, and the consistency<label for="consistency"></label><span>Consistency relates to how data updates are processed and reflected in the system - for example, does the system fail a transaction if some of its writes fail? The <a href="https://jepsen.io/consistency">Jepsen</a> content is one of the resourcs I commonly reference. If you like any other resources on the topic feel free to send a pull request! </span> of the update). The DPA framework then determines which actors need to be updated (and how) under the hood. Importantly, DPA supports building <em>query-serving systems</em> with different consistency guarantees, from <a href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html">eventually consistent</a> to <a href="https://jepsen.io/consistency/models/serializable">full serializability</a> - depending on the consistency level chosen, the update has different behavior. This configurability is useful because consistency requirements vary by <em>query-serving system</em>.</p>
<h3 id="read-handling">Read handling</h3>
<figure><img src="https://www.micahlerner.com/assets/dpa/figure3.png"/><figcaption></figcaption></figure>
<p>To handle <em>reads</em>, DPA uses a client layer for receiving queries. The client layer converts queries into <code>ParallelOperators</code> that can be run across many actors as needed. Example of <code>ParallelOperators</code> are <em>Map</em> (which “applies a function to actors in parallel and materializes the transformed data.”), and <em>Scatter and Gather</em> (a <a href="https://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/">“collective”</a> operation used in functionality like like joins).</p>
<h3 id="architecture">Architecture</h3>
<p>The <em>DPA</em> paper discusses a runtime (called <em>Uniserve</em>) for running <em>query-serving systems</em> using an actor-based model. The runtime has four high-level components: a <em>query planner</em>, a <em>client layer</em>, <em>the server layer</em>, and a <em>coordinator</em>.</p>
<figure><img src="https://www.micahlerner.com/assets/dpa/figure4.png"/><figcaption></figcaption></figure>
<p>The <em>query planner</em> is responsible for receiving queries from clients, and “translates them to DPA parallel operators (or update functions)” - in other words, determining which partitions and actors the query needs to access. The paper discusses how developers can (or need to) implement the query planner themselves, which seemed related to the idea of creating a general query planner (discussed in existing research like <a href="http://www.vldb.org/pvldb/vol11/p1835-samwel.pdf">F1</a>).</p>
<p>The <em>client layer</em> communicates with the query planner, fanning out subqueries to the deeper layers of the Uniserve stack - in particular the nodes with actors and the partitions they are associated with.</p>
<p>Actors (and the partitions they are responsible for) live in the <em>Uniserve Server Layer</em>. There are many nodes in this layer, each with several actors and their associated partitions. The nodes in this layer communicate with one another in order to execute queries (like <em>Scatter and Gather</em> operations) and replicate data from one actor to another as needed.</p>
<p>Lastly, the allocation of actors to servers is handled by the <em>coordinator</em>. The <em>coordinator</em> scales the system by adding or removing servers/actors in response to demand, in addition to managing fault tolerance (by ensuring that there are multiple replicas of an actor, all of which converge to the same state through replication).</p>
<h2 id="how-is-the-research-evaluated">How is the research evaluated?</h2>
<p>In addition to establishing the paradigm of DPA, the paper also discusses how several existing databases were ported to the approach, including <a href="https://solr.apache.org/">Solr</a>, <a href="https://www.mongodb.com/">MongoDB</a>, and <a href="https://www.micahlerner.com/2022/05/15/druid-a-real-time-analytical-data-store.html">Druid</a>. The implementations of these databases on DPA is significantly shorter with respect to lines of code:</p>
<blockquote>
<p>DPA makes distributing these systems considerably simpler; each requires &lt;1K lines of code to distribute as compared to the tens of thousands of lines in custom distribution layers (~90K in Solr, ~120K in MongoDB, and ~70K in Druid).</p>
</blockquote>
<p>The paper also measures overheads associated with the DPA model by comparing native systems to the comparable system on DPA, finding that the approach adds minimal overhead.</p>
<figure><img src="https://www.micahlerner.com/assets/dpa/figure5.png"/><figcaption></figcaption></figure>
<p>Another key feature of DPA is its ability to generally load balance actors and partitions. To test this behavior, the system executed skewed queries that introduce “hot spots” in the cluster - the <em>coordinator</em> component is able to dissipate “hot spots” across machines while scaling actors.</p>
<figure><img src="https://www.micahlerner.com/assets/dpa/figure9.png"/><figcaption></figcaption></figure>
<p>The evaluation also considered how a DPA system scaled in response to load - autoscaling while limiting load balancing and managing faults is difficult<label for="evenif"></label><span>Even if some databases like <a href="https://dl.acm.org/doi/abs/10.1145/2723372.2742795">Redshift</a> or <a href="https://dl.acm.org/doi/pdf/10.1145/2882903.2903741">Snowflake</a> make it look easy! </span></p>
<figure><img src="https://www.micahlerner.com/assets/dpa/figure10.png"/><figcaption></figcaption></figure>
<h2 id="conclusion">Conclusion</h2>
<p>The DPA paper combines several ideas from existing research in a novel way - in particular, it draws on ideas related to deploying actor-based systems like <a href="https://www.micahlerner.com/2021/06/27/ray-a-distributed-framework-for-emerging-ai-applications.html">Ray</a> and <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Orleans-MSR-TR-2014-41.pdf">Orleans</a>.</p>
<p>It would be interesting to learn how the DPA design performs for other types of database deployments<label for="mongo"></label><span>One example would be MongoDB used with a different (non- <em>query-serving system</em>) access pattern. </span>. For example, how does the DPA paradigm work for OLTP workloads? Are the overheads associated with the paradigm too high (and if so, can they be managed)?</p>
<p>I’m looking forward to seeing answers to these questions, along with further developments in this space - a unified framework for building <em>query serving systems</em> would likely be useful for the many different teams working on similar problems!</p>

</section>
<section>
Found something wrong?
<a href="https://github.com/mlerner/mlerner.github.io/edit/master/_posts/2022-06-04-data-parallel-actors-a-programming-model-for-scalable-query-serving-systems.md">Submit a pull request!</a>
</section>
</article></div>
  </body>
</html>
