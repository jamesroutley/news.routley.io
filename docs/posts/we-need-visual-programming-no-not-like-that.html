<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sbensu.com/posts/demand-for-visual-programming/">Original</a>
    <h1>We need visual programming. No, not like that</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h2 id="summary">Summary</h2><p>Most visual programming environments fail to get any usage. Why? They try to replace code syntax and business logic but developers never try to visualize that. Instead, developers visualize state transitions, memory layouts, or network requests. </p><p>In my opinion, those working on visual programming would be more likely to succeed if they started with aspects of software that developers already visualize.</p><p>Every few months somebody puts out a very nice visual programming language that looks something like this:</p><p><img src="https://blog.sbensu.com/img/demand-for-visual-programming/visual_programming.png" alt=""/> This one looks particularly sleek, most of them are much less inviting.</p><p>The algorithm above is replacing some pseudo-code that looks like<a href="#fn-1" id="fnref1"><sup>1</sup></a>:</p><pre><code>def merge_sort(a):
  if (length(a) == 2):
    if (a[0] &lt; a[1])
      return a
    else
      return [a[1], a[0]]
  else:
    [x1, x2]  = split_in_half(a)
    sorted_x1 = merge_sort(x1)
    sorted_x2 = merge_sort(x2)
    return priority_merge(sorted_x1, sorted_x2)
</code></pre><p>Like the example above, the systems I am referring to are trying to replace the code syntax itself. </p><p>But every time one of these visual programming systems come out, we think &#34;oh neat!&#34; and never try them. I have never seen any of these visual programming systems even be mentioned while trying to solve problems. Why? Why do we keep circling back to visual programming if nobody ever uses it?</p><p>One reason is because we think that other, more inexperienced, programmers might have an easier time with visual programming. If only code wasn&#39;t as scary! If only it was visual! Excel Formula is the most popular programming language by a few orders of magnitude and it <a href="https://www.reddit.com/r/excel/comments/r9w3wb/what_is_the_craziest_formula_youve_ever_usedseen/">can look like this</a>:</p><pre><code>=INDEX(A1:A4,SMALL(IF(Active[A1:A4]=E$1,ROW(A1:A4)-1),ROW(1:1)),2)
</code></pre><p>I&#39;ll ignore this reason because many of these tools explicitly meant for experienced developers. They assume that you will install them with <code>npm install</code> or deploy its code to AWS Lambdas.</p><p>Why does visual programming fail for developers?</p><p>Developers say they want &#34;visual programming&#34;, which makes you think &#34;oh, let&#39;s replace <code>if</code> and <code>for</code>&#34;. But nobody ever made a flow chart to read <code>for (i in 0..10) if even?(i) print(i)</code>. Developers familiar with code already like and understand textual representations to read and write business logic<a href="#fn-2" id="fnref2"><sup>2</sup></a>.</p><p><strong>Let&#39;s observe what developers <em>do</em>, not what they <em>say</em>.</strong></p><p>Developers do spend the time to visualize aspects of their code but rarely the logic itself. They visualize other aspects of their software that are <em>important, implicit, and hard to understand</em>.</p><p>Here are some visualizations that I encounter often in <a href="https://notes.andymatuschak.org/z7vdiuQK7HuFyi4V5EemF3e">serious contexts of use</a>:</p><ul><li>Various ways to visualize the codebase overall.</li><li>Diagrams that show how computers are connected in a network</li><li>Diagrams that show how data is laid out in memory</li><li>Transition diagrams for state machines.</li><li>Swimlane diagrams for request / response protocols.</li></ul><p><em>This</em> is the visual programming developers are asking for. Developers need help with those problems and they resort to visuals to tackle them.</p><p>If you are skeptical about needing these, let me ask you: do you know exactly how your data is laid out in memory? Bad memory layouts are one of the biggest contributors to poor performance. Yet it is very hard to &#34;see&#34; how a given piece of data is laid out and contrast it with the access patterns present in the codebase.</p><p>Alternatively, do you know all the external dependencies your code hits when responding to a given HTTP request? Are you sure? Didn&#39;t you notice that Bob just added a call to a rate limiter service in the middleware? Don&#39;t worry, you&#39;ll learn about it in the next outage.</p><p>For both of these questions, the answer is usually &#34;I think I know the answer?&#34; with a creeping fear that <i>maybe you missed something you couldn&#39;t see</i>.</p><p>Sadly most of those visualizations are:</p><ul><li>made ad-hoc by somebody that goes out of their way to do it</li><li>manually made, on a napkin or Whimsical</li><li>rarely integrated to a standard workflow</li></ul><p>This is not to say that the industry has nothing to show for. Some visualization techniques are integrated into developer environments and heavily used:</p><ul><li>The DOM element inspector view</li><li>Flamegraphs in profilers</li><li>SQL tables diagrams</li></ul><p>But these are the exceptions not the default. Isn&#39;t it great when you can pinpoint the performance problem in a flamegraph? We need that for everything else.</p><p>I&#39;ll now cover some of those visualizations to prime you to consider them for your current work or even integrating them into existing developer environments.</p><h2 id="codebase_visualization">Codebase visualization</h2> <p><a href="https://www.youtube.com/watch?v=fnIFVYFspfc">This great talk</a> shows many ways to visualize different aspects of a codebase. There are a lot! Here are some that interest me:</p><ul><li>Treemap: statistical overview of files in a codebase</li><li>Sourcetrail: a class hierarchy and dependency browser</li><li>Code retention over time</li></ul><h3 id="sourcetrail">Sourcetrail</h3><p><a href="https://github.com/CoatiSoftware/Sourcetrail">Sourcetrail is an open source</a> to visualize codebases (no longer active), written by the speaker in the talk above. <a href="https://www.youtube.com/watch?v=Cfu6f0uyzc8">Here</a> is a great overview of how the tool helps you navigate a codebase. It looks like this:</p><p><img src="https://blog.sbensu.com/img/demand-for-visual-programming/code_browser.png" alt=""/></p><p>Sourcetrail solves many of the common design problems of code visualization:</p><ul><li>It shows the visualization next to the code. When you over on the code, it highlights its visual representation. When you hover on the diagram, it highlights the code. When you click on a dependency, it takes you to the code responsible for that dependency (e.g. one function calling another, one module requiring another).</li><li>It is smart about <em>hiding</em> information. In codebases, there are often too many connections to visualize at any given time without overwhelming the user. Sourcetrail tool shows you what it thinks you are looking for first, and asks you to click / hover for more. The UI is designed to to pull on threads that seem interesting, not to get an bird&#39;s eye view of the codebase. This is the opposite from Treemap (covered below), which is explicitly designed to get an overview</li></ul><p>But, as the demo shows, it suffers from some of the common problems of this type of visualization:</p><ul><li>There are no obvious hooks to &#34;when do I need this&#34;. When you are profiling, you think &#34;I need a flamegraph&#34;. When do you <em>need</em> this visualization?</li><li>It is not <em>in</em> the same tools that I want to use. The demo shows the user switching between Sourcetrail and Sublime. That type of code visualization and navigation wants to live <em>inside</em> of the code editor.</li></ul><h3 id="treemap">Treemap</h3><p>In this <a href="https://www.youtube.com/watch?v=BqF2SbY99B8">set of videos</a>, Jonathan Blow implements a &#34;treemap&#34; to inspect different aspects of a codebase. From watching the videos (I&#39;ve never used his viewer), the last version looks like this:</p><p><img src="https://blog.sbensu.com/img/demand-for-visual-programming/treemap.png" alt=""/></p><ul><li>Each square represents a code file</li><li>The size of each square represents the size of the file</li><li>The color of the square represents a blended of complexity metrics in each file like depth of nested ifs, depth of nested loops, number of global reads, etc.</li></ul><p>With this type of visualization you can visualize other <code>(size, color)</code> metrics over the codebase, like <code>(code_size, code_quality)</code>, <code>(code_size, heap_access / code_size)</code>, etc.</p><p>Even if you visualize something as simple as just <code>code_size</code> with no color, that can be very useful when onboarding in massive codebases. A typical Big Tech monolith might look something like:</p><pre><code>packages/
  first_dependency/
    first_transitive_dep/
  second_dependency/
    second_transitive_dep/
  ...
src/
  bingo/
  papaya/
  lmnop/
  racoon/
  wingman/
  galactus/
  ...
</code></pre><p>You probably glanced over it, didn&#39;t you? I glanced over it to when I joined a large company. When you <code>git clone</code> this repository and navigate around it, you don&#39;t really learn what is there, not even the basic picture. In the example above, it turns out that most of the code is in the <code>racoon/</code> service (3M LOC) and the <code>second_transitive_dep/</code> (1M LOC). Everything else has less than 300k LOC and is, by comparison, a rounding error. You can work on this codebase for years without learning these basic facts.</p><h3 id="code_retention_diagram">Code retention diagram</h3><p><a href="https://dl.acm.org/doi/pdf/10.1145/3386321">Rich Hickey&#39;s History of Clojure paper</a> has some neat visualizations to understand how the Clojure codebase evolved over time. This is a burndown chart generated from the <a href="https://github.com/src-d/hercules">Hercules CLI</a>:</p><p><img src="https://blog.sbensu.com/img/demand-for-visual-programming/history_of_clojure_burndown.png" alt=""/></p><ul><li>The code that was written each year is represented as an area of a certain color (e.g. red for 2006)</li><li>As some of that code is removed / replaced the next year, its area diminishes</li><li>By tracking the colors, we can see the staying power of the code written each year. For example, the code written in 2006 (red) was largely removed or replaced. But the code written is 2011 (green) has stayed almost untouched since then. This is true for most years!<a href="#fn-3" id="fnref3"><sup>3</sup></a></li></ul><h2 id="computer_networks_and_service_topologies">Computer networks and service topologies</h2><p>If you ever use AWS, you&#39;ll see that its <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/vpc-endpoints-dynamodb.html">documentation</a> is full of diagrams like this one:</p><p><img src="https://blog.sbensu.com/img/demand-for-visual-programming/aws_services.png" alt=""/></p><p>I think the diagram is very clear. It shows you all the &#34;services&#34; involved and their connections. In this case, if you know what each of them does, it is obvious how they relate to each other. (If you don&#39;t you have to go read about each one.)</p><p>Throughout my career, I made one of these topology diagrams for every single team I&#39;ve belonged to. A few lessons from making them:</p><ul><li>As new people joined, I started from the last diagram I had made (6 months or so on average) which made it easier. There was also some change from last time.</li><li>I missed something important each time I made the diagram.</li><li>As far as I can tell, it was the most important technical artifact I ever transmitted to new people in the team.<blockquote></blockquote></li></ul><p> Idea: if you use gRPC service definitions, can you generate these diagrams from them?</p></div></div>
  </body>
</html>
