<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/a48fce5b-8a05-4302-b620-9b26f057f145/">Original</a>
    <h1>Solving a “Layton Puzzle” with Prolog</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                April 8, 2025
                
            </date>
            

            

            

            

            
            
            <p>I have a lot in the works for the this month&#39;s <a href="https://leanpub.com/logic/" target="_blank">Logic for Programmers</a> release. Among other things, I&#39;m completely rewriting the chapter on Logic Programming Languages. </p>
<p>I originally showcased the paradigm with puzzle solvers, like <a href="https://swish.swi-prolog.org/example/queens.pl" target="_blank">eight queens</a> or <a href="https://saksagan.ceng.metu.edu.tr/courses/ceng242/documents/prolog/jrfisher/2_1.html" target="_blank">four-coloring</a>. Lots of other demos do this too! It takes creativity and insight for humans to solve them, so a program doing it feels magical. But I&#39;m trying to write a book about practical techniques and I want everything I talk about to be <em>useful</em>. So in v0.9 I&#39;ll be replacing these examples with a couple of new programs that might get people thinking that Prolog could help them in their day-to-day work.</p>
<p>On the other hand, for a newsletter, showcasing a puzzle solver is pretty cool. And recently I stumbled into <a href="https://morepablo.com/2010/09/some-professor-layton-prolog.html" target="_blank">this post</a> by my friend <a href="https://morepablo.com/" target="_blank">Pablo Meier</a>, where he solves a videogame puzzle with Prolog:<sup id="fnref:path"><a href="#fn:path">1</a></sup></p>
<p><img alt="See description below" src="https://assets.buttondown.email/images/a4ee8689-bbce-4dc9-8175-a1de3bd8f2db.png?w=960&amp;fit=max"/></p>
<p>Summary for the text-only readers: We have a test with 10 true/false questions (denoted <code>a/b</code>) and four student attempts. Given the scores of the first three students, we have to figure out the fourth student&#39;s score.</p>
<div><pre><span></span><code>bbababbabb = 7
baaababaaa = 5
baaabbbaba = 3
bbaaabbaaa = ???
</code></pre></div>
<p>You can see Pablo&#39;s solution <a href="https://morepablo.com/2010/09/some-professor-layton-prolog.html" target="_blank">here</a>, and try it in SWI-prolog <a href="https://swish.swi-prolog.org/p/Some%20Professor%20Layton%20Prolog.pl" target="_blank">here</a>. Pretty cool! But after way too long studying Prolog just to write this dang book chapter, I wanted to see if I could do it more elegantly than him. Code and puzzle spoilers to follow.</p>
<p>(Normally here&#39;s where I&#39;d link to a gentler introduction I wrote but I think this is my first time writing about Prolog online? Uh here&#39;s a <a href="https://www.hillelwayne.com/post/picat/" target="_blank">Picat intro</a> instead)</p>
<h3>The Program</h3>
<p>You can try this all online at <a href="https://swish.swi-prolog.org/p/" target="_blank">SWISH</a> or just jump to my final version <a href="https://swish.swi-prolog.org/p/layton_prolog_puzzle.pl" target="_blank">here</a>.</p>
<div><pre><span></span><code><span>:-</span> <span>use_module</span><span>(</span><span>library</span><span>(</span><span>dif</span><span>)).</span>    <span>% Sound inequality</span>
<span>:-</span> <span>use_module</span><span>(</span><span>library</span><span>(</span><span>clpfd</span><span>)).</span>  <span>% Finite domain constraints</span>
</code></pre></div>
<p>First some imports. <code>dif</code> lets us write <code>dif(A, B)</code>, which is true if <code>A</code> and <code>B</code> are <em>not</em> equal. <code>clpfd</code> lets us write <code>A #= B + 1</code> to say &#34;A is 1 more than B&#34;.<sup id="fnref:superior"><a href="#fn:superior">2</a></sup></p>
<p>We&#39;ll say both the student submission and the key will be lists, where each value is <code>a</code> or <code>b</code>. In Prolog, lowercase identifiers are <strong>atoms</strong> (like symbols in other languages) and identifiers that start with a capital are <strong>variables</strong>. Prolog finds values for variables that match equations (<strong>unification</strong>). The pattern matching is real real good.</p>
<div><pre><span></span><code><span>% ?- means query</span>
<span>?-</span> <span>L</span> <span>=</span> <span>[</span><span>a</span><span>,</span><span>B</span><span>,</span><span>c</span><span>],</span> <span>[</span><span>Y</span><span>|</span><span>X</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>|</span><span>L</span><span>],</span> <span>B</span> <span>+</span> <span>1</span> <span>#=</span> <span>7.</span>

<span>B</span> <span>=</span> <span>6</span><span>,</span>
<span>L</span> <span>=</span> <span>[</span><span>a</span><span>,</span> <span>6</span><span>,</span> <span>c</span><span>],</span>
<span>X</span> <span>=</span> <span>[</span><span>2</span><span>,</span> <span>a</span><span>,</span> <span>6</span><span>,</span> <span>c</span><span>],</span>
<span>Y</span> <span>=</span> <span>1</span>
</code></pre></div>
<p>Next, we define <code>score/3</code><sup id="fnref:arity"><a href="#fn:arity">3</a></sup> recursively. </p>
<div><pre><span></span><code><span>% The student&#39;s test score</span>
<span>% score(student answers, answer key, score)</span>
<span>score</span><span>([],</span> <span>[],</span> <span>0</span><span>).</span>
<span>score</span><span>([</span><span>A</span><span>|</span><span>As</span><span>],</span> <span>[</span><span>A</span><span>|</span><span>Ks</span><span>],</span> <span>N</span><span>)</span> <span>:-</span>
   <span>N</span> <span>#=</span> <span>M</span> <span>+</span> <span>1</span><span>,</span> <span>score</span><span>(</span><span>As</span><span>,</span> <span>Ks</span><span>,</span> <span>M</span><span>).</span>
<span>score</span><span>([</span><span>A</span><span>|</span><span>As</span><span>],</span> <span>[</span><span>K</span><span>|</span><span>Ks</span><span>],</span> <span>N</span><span>)</span> <span>:-</span> 
    <span>dif</span><span>(</span><span>A</span><span>,</span> <span>K</span><span>),</span> <span>score</span><span>(</span><span>As</span><span>,</span> <span>Ks</span><span>,</span> <span>N</span><span>).</span>
</code></pre></div>
<p>First key is the student&#39;s answers, second is the answer key, third is the final score. The base case is the empty test, which has score 0. Otherwise, we take the head values of each list and compare them. If they&#39;re the same, we add one to the score, otherwise we keep the same score. </p>
<p>Notice we couldn&#39;t write <code>if x then y else z</code>, we instead used pattern matching to effectively express <code>(x &amp;&amp; y) || (!x &amp;&amp; z)</code>. Prolog does have a conditional operator, but it prevents backtracking so what&#39;s the point???</p>

<h3>A quick break about bidirectionality</h3>
<p>One of the coolest things about Prolog: all purely logical predicates are bidirectional. We can use <code>score</code> to check if our expected score is correct:</p>
<div><pre><span></span><code><span>?-</span> <span>score</span><span>([</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>],</span> <span>[</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>],</span> <span>2</span><span>).</span>
<span>true</span>
</code></pre></div>
<p>But we can also give it answers and a key and ask it for the score:</p>
<div><pre><span></span><code><span>?-</span> <span>score</span><span>([</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>],</span> <span>[</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>],</span> <span>X</span><span>).</span>
<span>X</span> <span>=</span> <span>2</span>
</code></pre></div>
<p><em>Or</em> we could give it a key and a score and ask &#34;what test answers would have this score?&#34;</p>
<div><pre><span></span><code><span>?-</span> <span>score</span><span>(</span><span>X</span><span>,</span> <span>[</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>],</span> <span>2</span><span>).</span>
<span>X</span> <span>=</span> <span>[</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>_</span><span>A</span><span>],</span>
<span>dif</span><span>(</span><span>_</span><span>A</span><span>,</span><span>b</span><span>)</span>
<span>X</span> <span>=</span> <span>[</span><span>b</span><span>,</span> <span>_</span><span>A</span><span>,</span> <span>b</span><span>],</span>
<span>dif</span><span>(</span><span>_</span><span>A</span><span>,</span><span>b</span><span>)</span>
<span>X</span> <span>=</span> <span>[</span><span>_</span><span>A</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>],</span>
<span>dif</span><span>(</span><span>_</span><span>A</span><span>,</span><span>b</span><span>)</span>
</code></pre></div>
<p>The different value is written <code>_A</code> because we never told Prolog that the array can <em>only</em> contain <code>a</code> and <code>b</code>. We&#39;ll fix this later.</p>
<h3>Okay back to the program</h3>
<p>Now that we have a way of computing scores, we want to find a possible answer key that matches all of our observations, ie gives everybody the correct scores.</p>
<div><pre><span></span><code><span>key</span><span>(</span><span>Key</span><span>)</span> <span>:-</span>
    <span>% Figure it out</span>
    <span>score</span><span>([</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>],</span> <span>Key</span><span>,</span> <span>7</span><span>),</span>
    <span>score</span><span>([</span><span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>],</span> <span>Key</span><span>,</span> <span>5</span><span>),</span>
    <span>score</span><span>([</span><span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>],</span> <span>Key</span><span>,</span> <span>3</span><span>).</span>
</code></pre></div>
<p>So far we haven&#39;t explicitly said that the <code>Key</code> length matches the student answer lengths. This is implicitly verified by <code>score</code> (both lists need to be empty at the same time) but it&#39;s a good idea to explicitly add <code>length(Key, 10)</code> as a clause of <code>key/1</code>. We should also explicitly say that every element of <code>Key</code> is either <code>a</code> or <code>b</code>.<sup id="fnref:explicit"><a href="#fn:explicit">4</a></sup> Now we <em>could</em> write a second predicate saying <code>Key</code> had the right &#39;type&#39;: </p>
<div><pre><span></span><code>keytype([]).
keytype([K|Ks]) :- member(K, [a, b]), keytype(Ks).
</code></pre></div>
<p>But &#34;generating lists that match a constraint&#34; is a thing that comes up often enough that we don&#39;t want to write a separate predicate for each constraint! So after some digging, I found a more elegant solution: <code>maplist</code>. Let <code>L=[l1, l2]</code>. Then <code>maplist(p, L)</code> is equivalent to the clause <code>p(l1), p(l2)</code>. It also accepts partial predicates: <code>maplist(p(x), L)</code> is equivalent to <code>p(x, l1), p(x, l2)</code>. So we could write<sup id="fnref:yall"><a href="#fn:yall">5</a></sup></p>
<div><pre><span></span><code><span>contains</span><span>(</span><span>L</span><span>,</span> <span>X</span><span>)</span> <span>:-</span> <span>member</span><span>(</span><span>X</span><span>,</span> <span>L</span><span>).</span>

<span>key</span><span>(</span><span>Key</span><span>)</span> <span>:-</span>
    <span>length</span><span>(</span><span>Key</span><span>,</span> <span>10</span><span>),</span>
    <span>maplist</span><span>(</span><span>contains</span><span>([</span><span>a</span><span>,</span><span>b</span><span>]),</span> <span>L</span><span>),</span>
    <span>% the score stuff</span>
</code></pre></div>
<p>Now, let&#39;s query for the Key:</p>
<div><pre><span></span><code><span>?-</span> <span>key</span><span>(</span><span>Key</span><span>)</span>
<span>Key</span> <span>=</span> <span>[</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>]</span>
<span>Key</span> <span>=</span> <span>[</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>]</span>
<span>Key</span> <span>=</span> <span>[</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>]</span>
<span>Key</span> <span>=</span> <span>[</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>]</span>
</code></pre></div>
<p>So there are actually four <em>different</em> keys that all explain our data. Does this mean the puzzle is broken and has multiple different answers?</p>
<h3>Nope</h3>
<p>The puzzle wasn&#39;t to find out what the answer key was, the point was to find the fourth student&#39;s score. And if we query for it, we see all four solutions give him the same score:</p>
<div><pre><span></span><code><span>?-</span> <span>key</span><span>(</span><span>Key</span><span>),</span> <span>score</span><span>([</span><span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>,</span> <span>a</span><span>],</span> <span>Key</span><span>,</span> <span>X</span><span>).</span>
<span>X</span> <span>=</span> <span>6</span>
<span>X</span> <span>=</span> <span>6</span>
<span>X</span> <span>=</span> <span>6</span>
<span>X</span> <span>=</span> <span>6</span>
</code></pre></div>
<p>Huh! I really like it when puzzles look like they&#39;re broken, but every &#34;alternate&#34; solution still gives the same puzzle answer.</p>
<p>Total program length: 15 lines of code, compared to the original&#39;s 80 lines. <em>Suck it, Pablo.</em></p>
<p>(Incidentally, you can get all of the answer at once by writing <code>findall(X, (key(Key), score($answer-array, Key, X)), L).</code>) </p>

<h3>I still don&#39;t like puzzles for teaching</h3>
<p>The actual examples I&#39;m using in <a href="https://leanpub.com/logic/" target="_blank">the book</a> are &#34;analyzing a version control commit graph&#34; and &#34;planning a sequence of infrastructure changes&#34;, which are somewhat more likely to occur at work than needing to solve a puzzle. You&#39;ll see them in the next release!</p>

            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            



        </div></div>
  </body>
</html>
