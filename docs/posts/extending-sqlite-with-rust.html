<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ricardoanderegg.com/posts/extending-sqlite-with-rust/">Original</a>
    <h1>Extending SQLite with Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>SQLite has a powerful extension mechanism: <a href="https://www.sqlite.org/loadext.html">loadable extensions</a>.</p>
<p>Being an in-process database, SQLite has other extensions mechanisms like <a href="https://www.sqlite.org/appfunc.html">application-defined functions</a> (UDF for short). But UDFs have some shortcomings:</p>
<ul>
<li>They’re local to an SQLite connection, not shared for every process connected to the DB</li>
<li>They have to be defined in your program. That means that you need to have the function available in the same scope as your application.
This is where loadable extensions come in. Loadable extensions can be written in any programming language that can be compiled to a shared library/DLL. Then you can just share the compiled object and load them from any application or programming language. In this post, we’ll see how we can use <a href="https://www.rust-lang.org/">Rust</a> to write an SQLite loadable extension.</li>
</ul>
<h2 id="intro">Intro</h2>
<p>This post is a simplified version of some techniques I learned from <a href="https://github.com/phiresky/sqlite-zstd">phiresky/sqlite-zstd</a>. That is an SQLite extension that enables zstd compression on SQLite, I highly recommend checking it out if you want to look at more advanced examples than this post.</p>
<h2 id="cargotoml">Cargo.toml</h2>
<p>We’ll need a few external dependencies. The most important details to note here are:</p>
<ul>
<li>Using <a href="https://github.com/Genomicsplc/rusqlite/tree/loadable-extensions">this rusqlite fork from Genomicsplc</a>. For more context why this is needed, see <a href="https://github.com/rusqlite/rusqlite/pull/910">#910</a>.
<ul>
<li><strong>UPDATE</strong>: I’ve created a new fork which merges the changes in that PR with the current latest <code>rusqlite</code> release (v0.27.0) <a href="https://github.com/litements/rusqlite/tree/loadable-extensions-release-2">here</a>.</li>
</ul>
</li>
<li>The <code>crate-type</code> is marked as: <code>[&#34;cdylib&#34;]</code>. This will tell the rust compiler that we are building a shared library.</li>
</ul>
<div><pre tabindex="0"><code data-lang="yaml"><span>[</span><span>package]</span><span>
</span><span></span><span>name = &#34;sqlite-regex&#34;</span><span>
</span><span></span><span>version = &#34;0.1.0&#34;</span><span>
</span><span></span><span>edition = &#34;2021&#34;</span><span>
</span><span>
</span><span></span><span>[</span><span>features]</span><span>
</span><span>
</span><span></span><span>default = []</span><span>
</span><span></span><span>build_extension = [&#34;rusqlite/bundled&#34;, &#34;rusqlite/functions&#34;]</span><span>
</span><span>
</span><span></span><span>[</span><span>lib]</span><span>
</span><span></span><span>crate-type = [&#34;cdylib&#34;]</span><span>
</span><span>
</span><span></span><span>[</span><span>dependencies]</span><span>
</span><span></span><span>regex = &#34;1.5.4&#34;</span><span>
</span><span></span><span>log = &#34;0.4.14&#34;</span><span>
</span><span></span><span>env_logger = &#34;0.9.0&#34;</span><span>
</span><span></span><span>anyhow = &#34;1.0.54&#34;</span><span>
</span><span>
</span><span>
</span><span></span><span>[</span><span>dependencies.rusqlite]</span><span>
</span><span></span><span>package = &#34;rusqlite&#34;</span><span>
</span><span></span><span>git = &#34;https://github.com/litements/rusqlite/&#34;</span><span>
</span><span></span><span>branch = &#34;loadable-extensions-release-2&#34;</span><span>
</span><span></span><span>default-features = false</span><span>
</span><span></span><span>features = [&#34;loadable_extension&#34;, &#34;vtab&#34;, &#34;functions&#34;, &#34;bundled&#34;]</span><span>
</span></code></pre></div><p>We need some basic imports and functions. The function <code>ah</code> will convert an <a href="https://docs.rs/anyhow/latest/anyhow/">anyhow</a> error to a <code>rusqlite</code> error. <code>init_logging</code> will set up <a href="https://docs.rs/env_logger/latest/env_logger/">env_logger</a>.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>#![allow(clippy::missing_safety_doc)]</span><span>
</span><span>
</span><span></span><span>use</span><span> </span><span>crate</span>::<span>ffi</span>::<span>loadable_extension_init</span><span>;</span><span>
</span><span></span><span>use</span><span> </span><span>anyhow</span>::<span>Context</span><span> </span><span>as</span><span> </span><span>ACtxt</span><span>;</span><span>
</span><span></span><span>use</span><span> </span><span>log</span>::<span>LevelFilter</span><span>;</span><span>
</span><span></span><span>use</span><span> </span><span>regex</span>::<span>bytes</span>::<span>Regex</span><span>;</span><span>
</span><span></span><span>use</span><span> </span><span>rusqlite</span>::<span>ffi</span><span>;</span><span>
</span><span></span><span>use</span><span> </span><span>rusqlite</span>::<span>functions</span>::<span>{</span><span>Context</span><span>,</span><span> </span><span>FunctionFlags</span><span>};</span><span>
</span><span></span><span>use</span><span> </span><span>rusqlite</span>::<span>types</span>::<span>{</span><span>ToSqlOutput</span><span>,</span><span> </span><span>Value</span><span>,</span><span> </span><span>ValueRef</span><span>};</span><span>
</span><span></span><span>use</span><span> </span><span>rusqlite</span>::<span>Connection</span><span>;</span><span>
</span><span></span><span>use</span><span> </span><span>std</span>::<span>os</span>::<span>raw</span>::<span>c_int</span><span>;</span><span>
</span><span>
</span><span></span><span>fn</span> <span>ah</span><span>(</span><span>e</span>: <span>anyhow</span>::<span>Error</span><span>)</span><span> </span>-&gt; <span>rusqlite</span>::<span>Error</span><span> </span><span>{</span><span>
</span><span>    </span><span>rusqlite</span>::<span>Error</span>::<span>UserFunctionError</span><span>(</span><span>format!</span><span>(</span><span>&#34;{:?}&#34;</span><span>,</span><span> </span><span>e</span><span>).</span><span>into</span><span>())</span><span>
</span><span></span><span>}</span><span>
</span><span>
</span><span></span><span>fn</span> <span>init_logging</span><span>(</span><span>default_level</span>: <span>LevelFilter</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>let</span><span> </span><span>lib_log_env</span><span> </span><span>=</span><span> </span><span>&#34;SQLITE_REGEX_LOG&#34;</span><span>;</span><span>
</span><span>    </span><span>if</span><span> </span><span>std</span>::<span>env</span>::<span>var</span><span>(</span><span>lib_log_env</span><span>).</span><span>is_err</span><span>()</span><span> </span><span>{</span><span>
</span><span>        </span><span>std</span>::<span>env</span>::<span>set_var</span><span>(</span><span>lib_log_env</span><span>,</span><span> </span><span>format!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>default_level</span><span>))</span><span>
</span><span>    </span><span>}</span><span>
</span><span>
</span><span>    </span><span>let</span><span> </span><span>logger_env</span><span> </span><span>=</span><span> </span><span>env_logger</span>::<span>Env</span>::<span>new</span><span>().</span><span>filter</span><span>(</span><span>lib_log_env</span><span>);</span><span>
</span><span>
</span><span>    </span><span>env_logger</span>::<span>try_init_from_env</span><span>(</span><span>logger_env</span><span>).</span><span>ok</span><span>();</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><h2 id="extension-entry-point">Extension entry point</h2>
<p>When you try to load an extension in SQLite, it needs an entry point function. According to <a href="https://sqlite.org/c3ref/load_extension.html">the docs</a> of the <code>sqlite3_load_extension</code> C function, if an entry point is not provided, it will attempt to guess one base on the filename. If we called our compiled extension <code>regex_ext</code> it will try to load an entry point called <code>sqlite3_regex_ext_init</code> because the extension has the filename <code>regex_ext.{so,dll,dylib}</code> If you need more flexibility, there’s also an SQL function to load extensions, and it lets you specify the entry point. With that, you can do something like:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>SELECT</span><span> </span><span>load_extension</span><span>(</span><span>&#39;path/to/loadable/extension/regex_ext.[extension]&#39;</span><span>,</span><span> </span><span>&#39;sqlite3_regex_init&#39;</span><span>)</span><span>
</span></code></pre></div><p>Now it will try to find a function called <code>sqlite3_regex_init</code> as an entry point, instead of <code>sqlite3_regex_ext_init</code>.</p>
<p>Let’s write our entry point function:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>#[no_mangle]</span><span>
</span><span></span><span>pub</span><span> </span><span>unsafe</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span> <span>sqlite3_regex_init</span><span>(</span><span>
</span><span>    </span><span>db</span>: <span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3</span><span>,</span><span>
</span><span>    </span><span>_pz_err_msg</span>: <span>&amp;</span><span>mut</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>std</span>::<span>os</span>::<span>raw</span>::<span>c_char</span><span>,</span><span>
</span><span>    </span><span>p_api</span>: <span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3_api_routines</span><span>,</span><span>
</span><span></span><span>)</span><span> </span>-&gt; <span>c_int</span><span> </span><span>{</span><span>
</span><span>
</span><span>    </span><span>loadable_extension_init</span><span>(</span><span>p_api</span><span>);</span><span>
</span><span>
</span><span>    </span><span>match</span><span> </span><span>init</span><span>(</span><span>db</span><span>)</span><span> </span><span>{</span><span>
</span><span>        </span><span>Ok</span><span>(())</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>            </span><span>log</span>::<span>info</span><span>!</span><span>(</span><span>&#34;[regex-extension] init ok&#34;</span><span>);</span><span>
</span><span>            </span><span>ffi</span>::<span>SQLITE_OK</span><span>
</span><span>        </span><span>}</span><span>
</span><span>
</span><span>        </span><span>Err</span><span>(</span><span>e</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>            </span><span>log</span>::<span>error</span><span>!</span><span>(</span><span>&#34;[regex-extension] init error: {:?}&#34;</span><span>,</span><span> </span><span>e</span><span>);</span><span>
</span><span>            </span><span>ffi</span>::<span>SQLITE_ERROR</span><span>
</span><span>        </span><span>}</span><span>
</span><span>    </span><span>}</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>Some details of this function:</p>
<ul>
<li>It needs <code>#[no_mangle]</code>: The Rust compiler mangles symbol names differently than native code linkers expect. As such, any function that Rust exports to be used outside of Rust needs to be told not to be mangled by the compiler [<a href="https://docs.rust-embedded.org/book/interoperability/rust-with-c.html#no_mangle">source</a>].</li>
<li>The function is <code>unsafe</code></li>
<li>The function returns <code>ffi:SQLITE_OK</code>. In a few paragraphs, we will see how we can change this return code to make the extension persistent across connections.</li>
<li>The extension is loaded in the <code>init()</code> function, which we’ll go through right now.</li>
</ul>
<h2 id="the-init-function">The <code>init</code> function</h2>
<p>The main thing to consider here is that the function will receive a <code>*mut ffi:sqlite3</code>, which is a raw sqlite3 handle. We can use from <code>rusqlite</code> using <a href="https://docs.rs/rusqlite/latest/rusqlite/struct.Connection.html#method.from_handle">from_handle</a>. Notice that this function is unsafe too.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>init</span><span>(</span><span>db_handle</span>: <span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3</span><span>)</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span><span>    </span><span>let</span><span> </span><span>db</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>rusqlite</span>::<span>Connection</span>::<span>from_handle</span><span>(</span><span>db_handle</span><span>)</span><span>?</span><span> </span><span>};</span><span>
</span><span>    </span><span>load</span><span>(</span><span>&amp;</span><span>db</span><span>)</span><span>?</span><span>;</span><span>
</span><span>    </span><span>Ok</span><span>(())</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p><code>db</code> is now a “normal” <code>rusqlite::Connection</code> object.</p>
<p>The <code>load</code> function will initialize the logger we defined before and load the rust functions to SQLite:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>load</span><span>(</span><span>c</span>: <span>&amp;</span><span>Connection</span><span>)</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span><span>    </span><span>load_with_loglevel</span><span>(</span><span>c</span><span>,</span><span> </span><span>LevelFilter</span>::<span>Info</span><span>)</span><span>
</span><span></span><span>}</span><span>
</span><span>
</span><span></span><span>fn</span> <span>load_with_loglevel</span><span>(</span><span>c</span>: <span>&amp;</span><span>Connection</span><span>,</span><span> </span><span>default_log_level</span>: <span>LevelFilter</span><span>)</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span><span>    </span><span>init_logging</span><span>(</span><span>default_log_level</span><span>);</span><span>
</span><span>    </span><span>add_functions</span><span>(</span><span>c</span><span>)</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><h2 id="loading-rust-functions-to-sqlite">Loading rust functions to SQLite</h2>
<p>Thanks to rusqlite and the flexibility of SQLite, this is straightforward:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>add_functions</span><span>(</span><span>c</span>: <span>&amp;</span><span>Connection</span><span>)</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span><span>    </span><span>let</span><span> </span><span>deterministic</span><span> </span><span>=</span><span> </span><span>FunctionFlags</span>::<span>SQLITE_DETERMINISTIC</span><span> </span><span>|</span><span> </span><span>FunctionFlags</span>::<span>SQLITE_UTF8</span><span>;</span><span>
</span><span>
</span><span>    </span><span>c</span><span>.</span><span>create_scalar_function</span><span>(</span><span>&#34;regex_extract&#34;</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>deterministic</span><span>,</span><span> </span><span>|</span><span>ctx</span>: <span>&amp;</span><span>Context</span><span>|</span><span> </span><span>{</span><span>
</span><span>        </span><span>regex_extract</span><span>(</span><span>ctx</span><span>).</span><span>map_err</span><span>(</span><span>ah</span><span>)</span><span>
</span><span>    </span><span>})</span><span>?</span><span>;</span><span>
</span><span>
</span><span>    </span><span>c</span><span>.</span><span>create_scalar_function</span><span>(</span><span>&#34;regex_extract&#34;</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>deterministic</span><span>,</span><span> </span><span>|</span><span>ctx</span>: <span>&amp;</span><span>Context</span><span>|</span><span> </span><span>{</span><span>
</span><span>        </span><span>regex_extract</span><span>(</span><span>ctx</span><span>).</span><span>map_err</span><span>(</span><span>ah</span><span>)</span><span>
</span><span>    </span><span>})</span><span>?</span><span>;</span><span>
</span><span>
</span><span>    </span><span>Ok</span><span>(())</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>We are using the <code>rusqlite</code> method <a href="https://docs.rs/rusqlite/latest/rusqlite/struct.Connection.html#method.create_scalar_function">create_scalar_function</a>. If you read the <a href="https://www.sqlite.org/appfunc.html#common_parameters">SQLite docs</a>, you’ll see that <code>sqlite3_create_function()</code> receives 5 parameters, the first one, <code>db</code>, is already implicit in our rust code since <code>create_scalar_function</code> is a method on the <code>Connection</code> object, so <code>db</code> is already available on <code>&amp;self</code>. That means that the rust implementation uses 4 parameters.</p>
<p>The <strong>first parameter</strong> is the name we want to use to register the function in SQLite, if we pass the value <code>&#34;regex_extract&#34;</code>, we will be able to use this function as <code>regex_extract()</code> in our SQL queries.</p>
<p>The <strong>second parameter</strong> is the number of arguments that the function accepts.</p>
<h3 id="registering-multiple-versions-of-the-same-function">Registering multiple versions of the same function</h3>
<p>From <a href="https://www.sqlite.org/appfunc.html#multiple_calls_to_sqlite3_create_function_for_the_same_function">the SQLite docs</a>: It is common for an application to invoke <code>sqlite3_create_function()</code> multiple times for the same SQL function. For example, if an SQL function can take either 2 or 3 arguments, then <code>sqlite3_create_function()</code> would be invoked once for the 2-argument version and a second time for the 3-argument version. The underlying implementation (the callbacks) can be different for both variants.</p>
<p>In rust, this translates to multiple calls to <code>Connection::create_scalar_function</code>. Then we need to make sure our rust function knows how to handle the varying number of arguments.</p>
<p>The <strong>third parameter</strong> includes our function flags. In our case, we defined them as a separate variable:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>let</span><span> </span><span>deterministic</span><span> </span><span>=</span><span> </span><span>FunctionFlags</span>::<span>SQLITE_DETERMINISTIC</span><span> </span><span>|</span><span> </span><span>FunctionFlags</span>::<span>SQLITE_UTF8</span><span>;</span><span>
</span></code></pre></div><p>You can add or remove flags here, the <code>FunctionFlags::SQLITE_INNOCUOUS</code> flag may be useful too.</p>
<p>The <strong>fourth parameter</strong> is the function we will register. The function will be passed the <a href="https://docs.rs/rusqlite/latest/rusqlite/functions/struct.Context.html">Context</a> object. Here we are using a closure which then calls our main rust function. We also call <code>.map_err(ah)</code> to convert <code>anyhow</code> errors to <code>rusqlite</code> errors. Wrapping the function in a new closure may be useful if we want to use the function in other parts of our rust program, keeping the <code>anyhow</code> errors, and mapping them to <code>rusqlite</code> errors only in this context. We could also use the closure to split the <code>rusqlite::functions::Context</code> object (more on this in the next section).</p>
<h2 id="our-rust-function">Our rust function</h2>
<p>Finally, this is the rust function we will be using. The function receives a raw <code>rusqlite::functions::Context</code> as input and splits it inside the function’s body.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>regex_extract</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span>(</span><span>ctx</span>: <span>&amp;</span><span>Context</span><span>)</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>ToSqlOutput</span><span>&lt;&#39;</span><span>a</span><span>&gt;&gt;</span><span> </span><span>{</span><span>
</span><span>    </span><span>let</span><span> </span><span>arg_pat</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span><span>    </span><span>let</span><span> </span><span>arg_input_data</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>
</span><span>    </span><span>let</span><span> </span><span>arg_cap_group</span><span> </span><span>=</span><span> </span><span>2</span><span>;</span><span>
</span><span>
</span><span>    </span><span>let</span><span> </span><span>empty_return</span><span> </span><span>=</span><span> </span><span>Ok</span><span>(</span><span>ToSqlOutput</span>::<span>Owned</span><span>(</span><span>Value</span>::<span>Null</span><span>));</span><span>
</span><span>
</span><span>    </span><span>let</span><span> </span><span>pattern</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>ctx</span><span>.</span><span>get_raw</span><span>(</span><span>arg_pat</span><span>)</span><span> </span><span>{</span><span>
</span><span>        </span><span>ValueRef</span>::<span>Text</span><span>(</span><span>t</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>t</span><span>,</span><span>
</span><span>        </span><span>e</span><span> </span><span>=&gt;</span><span> </span><span>anyhow</span>::<span>bail</span><span>!</span><span>(</span><span>&#34;regex pattern must be text, got {}&#34;</span><span>,</span><span> </span><span>e</span><span>.</span><span>data_type</span><span>()),</span><span>
</span><span>    </span><span>};</span><span>
</span><span>
</span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>Regex</span>::<span>new</span><span>(</span><span>std</span>::<span>str</span>::<span>from_utf8</span><span>(</span><span>pattern</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span><span>
</span><span>
</span><span>    </span><span>let</span><span> </span><span>input_value</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>ctx</span><span>.</span><span>get_raw</span><span>(</span><span>arg_input_data</span><span>)</span><span> </span><span>{</span><span>
</span><span>        </span><span>ValueRef</span>::<span>Text</span><span>(</span><span>t</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>t</span><span>,</span><span>
</span><span>        </span><span>ValueRef</span>::<span>Null</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>empty_return</span><span>,</span><span>
</span><span>        </span><span>e</span><span> </span><span>=&gt;</span><span> </span><span>anyhow</span>::<span>bail</span><span>!</span><span>(</span><span>&#34;regex expects text as input, got {}&#34;</span><span>,</span><span> </span><span>e</span><span>.</span><span>data_type</span><span>()),</span><span>
</span><span>    </span><span>};</span><span>
</span><span>
</span><span>    </span><span>let</span><span> </span><span>cap_group</span>: <span>usize</span> <span>=</span><span> </span><span>if</span><span> </span><span>ctx</span><span>.</span><span>len</span><span>()</span><span> </span><span>&lt;=</span><span> </span><span>arg_cap_group</span><span> </span><span>{</span><span>
</span><span>        </span><span>// no capture group, use default
</span><span></span><span>        </span><span>0</span><span>
</span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span><span>        </span><span>ctx</span><span>.</span><span>get</span><span>(</span><span>arg_cap_group</span><span>).</span><span>context</span><span>(</span><span>&#34;capture group&#34;</span><span>)</span><span>?</span><span>
</span><span>    </span><span>};</span><span>
</span><span>
</span><span>    </span><span>// let mut caploc = re.capture_locations();
</span><span></span><span>    </span><span>// re.captures_read(&amp;mut caploc, input_value);
</span><span></span><span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>cap</span><span>)</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>captures</span><span>(</span><span>input_value</span><span>)</span><span> </span><span>{</span><span>
</span><span>        </span><span>match</span><span> </span><span>cap</span><span>.</span><span>get</span><span>(</span><span>cap_group</span><span>)</span><span> </span><span>{</span><span>
</span><span>            </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>empty_return</span><span>,</span><span>
</span><span>            </span><span>// String::from_utf8_lossy
</span><span></span><span>            </span><span>Some</span><span>(</span><span>t</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>                </span><span>let</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>String</span>::<span>from_utf8_lossy</span><span>(</span><span>t</span><span>.</span><span>as_bytes</span><span>());</span><span>
</span><span>                </span><span>return</span><span> </span><span>Ok</span><span>(</span><span>ToSqlOutput</span>::<span>Owned</span><span>(</span><span>Value</span>::<span>Text</span><span>(</span><span>value</span><span>.</span><span>to_string</span><span>())));</span><span>
</span><span>            </span><span>}</span><span>
</span><span>        </span><span>}</span><span>
</span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span><span>        </span><span>empty_return</span><span>
</span><span>    </span><span>}</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>Let’s break down the function. First, we defined the meaning of each <code>rusqlite::functions::Context</code> index.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>let</span><span> </span><span>arg_pat</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span><span></span><span>let</span><span> </span><span>arg_input_data</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>
</span><span></span><span>let</span><span> </span><span>arg_cap_group</span><span> </span><span>=</span><span> </span><span>2</span><span>;</span><span>
</span></code></pre></div><p>Define an empty return (not pattern match found):</p>
<div><pre tabindex="0"><code data-lang="rust"><span>let</span><span> </span><span>empty_return</span><span> </span><span>=</span><span> </span><span>Ok</span><span>(</span><span>ToSqlOutput</span>::<span>Owned</span><span>(</span><span>Value</span>::<span>Null</span><span>));</span><span>
</span></code></pre></div><p>Check that the pattern passed to the function is of <a href="https://www.sqlite.org/datatype3.html">type</a> <code>TEXT</code> and create a regex from it:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>let</span><span> </span><span>pattern</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>ctx</span><span>.</span><span>get_raw</span><span>(</span><span>arg_pat</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>ValueRef</span>::<span>Text</span><span>(</span><span>t</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>t</span><span>,</span><span>
</span><span>    </span><span>e</span><span> </span><span>=&gt;</span><span> </span><span>anyhow</span>::<span>bail</span><span>!</span><span>(</span><span>&#34;regex pattern must be text, got {}&#34;</span><span>,</span><span> </span><span>e</span><span>.</span><span>data_type</span><span>()),</span><span>
</span><span></span><span>};</span><span>
</span><span>
</span><span></span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>Regex</span>::<span>new</span><span>(</span><span>std</span>::<span>str</span>::<span>from_utf8</span><span>(</span><span>pattern</span><span>)</span><span>?</span><span>)</span><span>?</span><span>;</span><span>
</span></code></pre></div><p>Handle empty inputs and return <code>Null</code> early</p>
<div><pre tabindex="0"><code data-lang="rust"><span>let</span><span> </span><span>input_value</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>ctx</span><span>.</span><span>get_raw</span><span>(</span><span>arg_input_data</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>ValueRef</span>::<span>Text</span><span>(</span><span>t</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>t</span><span>,</span><span>
</span><span>    </span><span>ValueRef</span>::<span>Null</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>empty_return</span><span>,</span><span>
</span><span>    </span><span>e</span><span> </span><span>=&gt;</span><span> </span><span>anyhow</span>::<span>bail</span><span>!</span><span>(</span><span>&#34;regex expects text as input, got {}&#34;</span><span>,</span><span> </span><span>e</span><span>.</span><span>data_type</span><span>()),</span><span>
</span><span></span><span>};</span><span>
</span></code></pre></div><p>If you remember from above, we can define the same SQLite function with a different number of parameters, we need to handle both cases inside our function:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>let</span><span> </span><span>cap_group</span>: <span>usize</span> <span>=</span><span> </span><span>if</span><span> </span><span>ctx</span><span>.</span><span>len</span><span>()</span><span> </span><span>&lt;=</span><span> </span><span>arg_cap_group</span><span> </span><span>{</span><span>
</span><span>    </span><span>// no capture group, use default
</span><span></span><span>    </span><span>0</span><span>
</span><span></span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span><span>    </span><span>ctx</span><span>.</span><span>get</span><span>(</span><span>arg_cap_group</span><span>).</span><span>context</span><span>(</span><span>&#34;capture group&#34;</span><span>)</span><span>?</span><span>
</span><span></span><span>};</span><span>
</span></code></pre></div><p>Finally, we run the regex and return the relevant capture group number:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>cap</span><span>)</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>captures</span><span>(</span><span>input_value</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>match</span><span> </span><span>cap</span><span>.</span><span>get</span><span>(</span><span>cap_group</span><span>)</span><span> </span><span>{</span><span>
</span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>empty_return</span><span>,</span><span>
</span><span>        </span><span>// String::from_utf8_lossy
</span><span></span><span>        </span><span>Some</span><span>(</span><span>t</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>            </span><span>let</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>String</span>::<span>from_utf8_lossy</span><span>(</span><span>t</span><span>.</span><span>as_bytes</span><span>());</span><span>
</span><span>            </span><span>return</span><span> </span><span>Ok</span><span>(</span><span>ToSqlOutput</span>::<span>Owned</span><span>(</span><span>Value</span>::<span>Text</span><span>(</span><span>value</span><span>.</span><span>to_string</span><span>())));</span><span>
</span><span>        </span><span>}</span><span>
</span><span>    </span><span>}</span><span>
</span><span></span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span><span>    </span><span>empty_return</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><h2 id="testing-our-new-extension">Testing our new extension</h2>
<p>First, we need to build the project.</p>
<p>Now we can load the extension in the SQLite REPL with (the <code>dylib</code> extension may be different depending on your OS, I’m using macOS):</p>
<div><pre tabindex="0"><code data-lang="sql"><span>SELECT</span><span> </span><span>load_extension</span><span>(</span><span>&#39;target/release/libsqlite_regex.dylib&#39;</span><span>,</span><span> </span><span>&#39;sqlite3_regex_init&#39;</span><span>);</span><span>
</span></code></pre></div><p>Our logger will output a message like:</p>
<div><pre tabindex="0"><code data-lang="plain">[2022-05-14T23:22:09Z INFO  sqlite_regex] [regex-extension] init ok
</code></pre></div><p>We will write some tests, I will keep them in a Python script.</p>
<div><pre tabindex="0"><code data-lang="python"><span>#!/usr/bin/env python3</span>

<span>import</span> <span>sqlite3</span>

<span>conn</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;test.db&#34;</span><span>,</span> <span>isolation_level</span><span>=</span><span>None</span><span>)</span>

<span>print</span><span>(</span><span>f</span><span>&#34;Loading SQLite extension in connection: </span><span>{</span><span>conn</span><span>}</span><span>&#34;</span><span>)</span>
<span>conn</span><span>.</span><span>enable_load_extension</span><span>(</span><span>True</span><span>)</span>
<span>conn</span><span>.</span><span>execute</span><span>(</span>
    <span>&#34;SELECT load_extension(&#39;target/release/libsqlite_regex.dylib&#39;, &#39;sqlite3_regex_init&#39;);&#34;</span>
<span>)</span>

<span>conn</span><span>.</span><span>enable_load_extension</span><span>(</span><span>False</span><span>)</span>

<span>print</span><span>(</span><span>&#34;Running tests...&#34;</span><span>)</span>

<span>print</span><span>(</span><span>&#34;Testing pattern &#39;x(ab)&#39; WITHOUT capture group&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;x(ab)&#39;, &#39;xxabaa&#39;)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;xab&#34;</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>

<span>print</span><span>(</span><span>&#34;Testing pattern &#39;x(ab)&#39; WITH capture group = 1&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;x(ab)&#39;, &#39;xxabaa&#39;, 1)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;ab&#34;</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>

<span>print</span><span>(</span><span>&#34;Testing pattern &#39;x(ab)&#39; WITH capture group = 0&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;x(ab)&#39;, &#39;xxabaa&#39;, 0)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;xab&#34;</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>

<span>print</span><span>(</span><span>&#34;Testing pattern &#39;g(oog)+le&#39; WITHOUT capture group&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;g(oog)+le&#39;, &#39;googoogoogle&#39;)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;googoogoogle&#34;</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>

<span>print</span><span>(</span><span>&#34;Testing pattern &#39;g(oog)+le&#39; WITH capture group = 1&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;g(oog)+le&#39;, &#39;googoogoogle&#39;, 1)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;oog&#34;</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>

<span>print</span><span>(</span><span>&#34;Testing pattern &#39;[Cc]at&#39; WITHOUT capture group&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;[Cc]at&#39;, &#39;cat&#39;)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;cat&#34;</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>

<span>print</span><span>(</span><span>&#34;Testing pattern &#39;[Cc]at&#39; WITHOUT capture group, expecting empty return&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;[Cc]at&#39;, &#39;hello&#39;)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>is</span> <span>None</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>

</code></pre></div><p>It seems to work! We just need to fix one more problem. If we open a new DB connection, the functions will not be available. We can test it by adding the following at the end of our testing script, we will get an error:</p>
<div><pre tabindex="0"><code data-lang="python"><span>conn2</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;test.db&#34;</span><span>,</span> <span>isolation_level</span><span>=</span><span>None</span><span>)</span>
<span>print</span><span>(</span><span>f</span><span>&#34;Testing connection 2: </span><span>{</span><span>conn2</span><span>}</span><span>&#34;</span><span>)</span>
<span>row</span> <span>=</span> <span>conn2</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT regex_extract(&#39;x(ab)&#39;, &#39;xxabaa&#39;)&#34;</span><span>)</span><span>.</span><span>fetchone</span><span>()</span>
<span>assert</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#34;xab&#34;</span><span>,</span> <span>row</span><span>[</span><span>0</span><span>]</span>
<span># sqlite3.OperationalError: no such function: regex_extract</span>
</code></pre></div><h2 id="loading-the-extensions-persistently">Loading the extensions persistently</h2>
<p>The main “problem” with loadable extensions is that they’re only available for the current SQLite connection. Luckily for us, we can <a href="https://www.sqlite.org/loadext.html#persistent_loadable_extensions">make extension persistent</a>. In our <code>sqlite3_regex_init</code> function, we need to return <code>ffi::SQLITE_OK_LOAD_PERMANENTLY</code> instead of <code>ffi::SQLITE_OK</code>. We also have to call <code>ffi:sqlite3_auto_extension</code> with a function pointer that will run the extension initialization. By doing this, the entry point function will be executed on each new connection in this process, even if the original connection loading the extension is closed now. Our initialization function is the same as before, but now it has the name <code>sqlite3_regex_init_internal</code></p>
<div><pre tabindex="0"><code data-lang="rust"><span>#[no_mangle]</span><span>
</span><span></span><span>pub</span><span> </span><span>unsafe</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span> <span>sqlite3_regex_init_internal</span><span>(</span><span>
</span><span>    </span><span>db</span>: <span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3</span><span>,</span><span>
</span><span>    </span><span>_pz_err_msg</span>: <span>&amp;</span><span>mut</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>std</span>::<span>os</span>::<span>raw</span>::<span>c_char</span><span>,</span><span>
</span><span>    </span><span>p_api</span>: <span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3_api_routines</span><span>,</span><span>
</span><span></span><span>)</span><span> </span>-&gt; <span>c_int</span><span> </span><span>{</span><span>
</span><span>    </span><span>loadable_extension_init</span><span>(</span><span>p_api</span><span>);</span><span>
</span><span>
</span><span>    </span><span>match</span><span> </span><span>init</span><span>(</span><span>db</span><span>)</span><span> </span><span>{</span><span>
</span><span>        </span><span>Ok</span><span>(())</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>            </span><span>log</span>::<span>info</span><span>!</span><span>(</span><span>&#34;[regex-extension] init ok&#34;</span><span>);</span><span>
</span><span>            </span><span>ffi</span>::<span>SQLITE_OK_LOAD_PERMANENTLY</span><span> </span><span>// &lt;== Changed here!
</span><span></span><span>        </span><span>}</span><span>
</span><span>
</span><span>        </span><span>Err</span><span>(</span><span>e</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>            </span><span>log</span>::<span>error</span><span>!</span><span>(</span><span>&#34;[regex-extension] init error: {:?}&#34;</span><span>,</span><span> </span><span>e</span><span>);</span><span>
</span><span>            </span><span>ffi</span>::<span>SQLITE_ERROR</span><span>
</span><span>        </span><span>}</span><span>
</span><span>    </span><span>}</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>And we define a new entry point function that will call the function above</p>
<div><pre tabindex="0"><code data-lang="rust"><span>#[no_mangle]</span><span>
</span><span></span><span>pub</span><span> </span><span>unsafe</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span> <span>sqlite3_regex_init</span><span>(</span><span>
</span><span>    </span><span>db</span>: <span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3</span><span>,</span><span>
</span><span>    </span><span>_pz_err_msg</span>: <span>&amp;</span><span>mut</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>std</span>::<span>os</span>::<span>raw</span>::<span>c_char</span><span>,</span><span>
</span><span>    </span><span>p_api</span>: <span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3_api_routines</span><span>,</span><span>
</span><span></span><span>)</span><span> </span>-&gt; <span>c_int</span><span> </span><span>{</span><span>
</span><span>    </span><span>loadable_extension_init</span><span>(</span><span>p_api</span><span>);</span><span>
</span><span>
</span><span>    </span><span>// Create pointer to initialization function
</span><span></span><span>    </span><span>let</span><span> </span><span>ptr</span><span> </span><span>=</span><span> </span><span>sqlite3_regex_init_internal</span><span>
</span><span>        </span><span>as</span><span> </span><span>unsafe</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span><span>(</span><span>
</span><span>            </span><span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3</span><span>,</span><span>
</span><span>            </span><span>&amp;</span><span>mut</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>std</span>::<span>os</span>::<span>raw</span>::<span>c_char</span><span>,</span><span>
</span><span>            </span><span>*</span><span>mut</span><span> </span><span>ffi</span>::<span>sqlite3_api_routines</span><span>,</span><span>
</span><span>        </span><span>)</span><span> </span>-&gt; <span>c_int</span><span>;</span><span>
</span><span>
</span><span>		</span><span>// Pass pointer to sqlite3_auto_extension()
</span><span></span><span>    </span><span>sqlite3_auto_extension</span><span>(</span><span>Some</span><span>(</span><span>std</span>::<span>mem</span>::<span>transmute</span><span>(</span><span>ptr</span><span>)));</span><span>
</span><span>
</span><span>    </span><span>match</span><span> </span><span>init</span><span>(</span><span>db</span><span>)</span><span> </span><span>{</span><span>
</span><span>        </span><span>Ok</span><span>(())</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>            </span><span>log</span>::<span>info</span><span>!</span><span>(</span><span>&#34;[regex-extension] init ok&#34;</span><span>);</span><span>
</span><span>            </span><span>ffi</span>::<span>SQLITE_OK_LOAD_PERMANENTLY</span><span>
</span><span>        </span><span>}</span><span>
</span><span>
</span><span>        </span><span>Err</span><span>(</span><span>e</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span><span>            </span><span>log</span>::<span>error</span><span>!</span><span>(</span><span>&#34;[regex-extension] init error: {:?}&#34;</span><span>,</span><span> </span><span>e</span><span>);</span><span>
</span><span>            </span><span>ffi</span>::<span>SQLITE_ERROR</span><span>
</span><span>        </span><span>}</span><span>
</span><span>    </span><span>}</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>The important part is <code>sqlite3_auto_extension(Some(std::mem::transmute(ptr)));</code>, which will make SQLite run the function pointer from <code>ptr</code> on each new connection. If we compile and re-run our test file, we will see this output:</p>
<div><pre tabindex="0"><code data-lang="plain">Loading SQLite extension in connection: &lt;sqlite3.Connection object at 0x1034b8300&gt;
[2022-05-15T00:48:33Z INFO  sqlite_regex] [regex-extension] init ok
Running tests...
Testing pattern &#39;x(ab)&#39; WITHOUT capture group
Testing pattern &#39;x(ab)&#39; WITH capture group = 1
Testing pattern &#39;x(ab)&#39; WITH capture group = 0
Testing pattern &#39;g(oog)+le&#39; WITHOUT capture group
Testing pattern &#39;g(oog)+le&#39; WITH capture group = 1
Testing pattern &#39;[Cc]at&#39; WITHOUT capture group
Testing pattern &#39;[Cc]at&#39; WITHOUT capture group, expecting empty return
[2022-05-15T00:48:33Z INFO  sqlite_regex] [regex-extension] init ok
Testing connection 2: &lt;sqlite3.Connection object at 0x103563120&gt;
All tests passed
</code></pre></div><p>We can see a second logging message <code>[regex-extension] init ok</code> without having called the initialization function a second time. This is because SQLite has automatically called it for us on the new connection.</p>
<p>Note: I’m certain there must be a way to avoid having to run <code>init</code> both in <code>sqlite3_regex_init</code> and <code>sqlite3_regex_init_internal</code>, but my knowledge of <code>C</code> functions and pointers is very limited, and I haven’t managed to make it work better than this.</p>
<h2 id="final-note">Final note</h2>
<p>Persisting extensions may be useful if we were writing a <a href="https://www.sqlite.org/vfs.html">VFS</a>. But for extensions like the one we created, and considering the nature of SQLite (an in-process DB), I think it’s safer and more convenient to just load the extensions on each new connection and “forgetting” about <code>sqlite3_auto_extension()</code> (just ignore all the changes we made in the “<strong>Loading the extensions persistently</strong>” section).</p>
<p>You can find the code from this blog post <a href="https://github.com/polyrand/rust-sqlite-ext-example">here</a>.</p>
</div></div>
  </body>
</html>
