<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justinpombrio.net/2025/09/22/imagining-a-language-without-booleans.html">Original</a>
    <h1>Imagining a language without booleans</h1>
    
    <div id="readability-page-1" class="page"><div>

<!-- This post gets really hard to read if the inline code blocks aren't distinctive -->


<p>Let’s start where I started. Just thinking about <code>if</code> statements.</p>

<p>An <code>if</code> with an <code>else</code> can produce a value:</p>

<figure><pre><code data-lang="c"><span></span><span>// C</span>
<span>int</span> <span>x</span> <span>=</span> <span>-</span><span>5</span><span>;</span>
<span>int</span> <span>abs_x</span> <span>=</span> <span>x</span> <span>&gt;</span> <span>0</span> <span>?</span> <span>x</span> <span>:</span> <span>-</span><span>x</span><span>;</span></code></pre></figure>

<figure><pre><code data-lang="python"><span></span><span># Python</span>
<span>x</span> <span>=</span> <span>-</span><span>5</span>
<span>abs_x</span> <span>=</span> <span>x</span> <span>if</span> <span>x</span> <span>&gt;</span> <span>0</span> <span>else</span> <span>-</span><span>x</span></code></pre></figure>

<figure><pre><code data-lang="rust"><span></span><span>// Rust</span>
<span>let</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>-</span><span>5</span><span>;</span><span></span>
<span>let</span><span> </span><span>abs_x</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>x</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>x</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>-</span><span>x</span><span> </span><span>};</span><span></span></code></pre></figure>

<p>What about an <code>if</code> <em>without</em> an <code>else</code>?</p>

<figure><pre><code data-lang="c"><span></span><span>// C</span>
<span>int</span> <span>x</span> <span>=</span> <span>-</span><span>5</span><span>;</span>
<span>int</span> <span>abs_x</span> <span>=</span> <span>x</span> <span>&gt;</span> <span>0</span> <span>?</span> <span>x</span><span>;</span> <span>// Syntax error!</span></code></pre></figure>

<figure><pre><code data-lang="python"><span></span><span># Python</span>
<span>x</span> <span>=</span> <span>-</span><span>5</span>
<span>abs_x</span> <span>=</span> <span>x</span> <span>if</span> <span>x</span> <span>&gt;</span> <span>0</span> <span># Syntax error!</span></code></pre></figure>

<figure><pre><code data-lang="rust"><span></span><span>// Rust</span>
<span>let</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>-</span><span>5</span><span>;</span><span></span>
<span>let</span><span> </span><span>abs_x</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>x</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>x</span><span> </span><span>};</span><span> </span><span>// Type error -- evaluates to ()!</span></code></pre></figure>

<p>No dice.</p>

<h3 id="optional-if">Optional <code>if</code></h3>

<p>I realized that there <em>is</em> a meaningful value for <code>if (x &gt; 0) x</code>,
though. It’s <code>Option&lt;i32&gt;</code>:</p>

<figure><pre><code data-lang="rust"><span></span><span>// Hypothetical-Lang</span>

<span>let</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>-</span><span>5</span><span>;</span><span></span>
<span>let</span><span> </span><span>pos_x</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>(</span><span>x</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>x</span><span>;</span><span> </span><span>// = None</span>

<span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>7</span><span>;</span><span></span>
<span>let</span><span> </span><span>pos_y</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>y</span><span>;</span><span> </span><span>// = Some(7)</span></code></pre></figure>

<p>(This hypothetical language will look a lot like Rust, but with different syntax
for <code>if</code> since we’re giving it a different semantics.)</p>

<p>In general, if the conditional evaluates to <code>true</code> then the <code>if</code> evalutes to
<code>Some</code>, otherwise it evaluates to <code>None</code>:</p>

<pre><code>if (true)  e  ⟼  Some(e)
if (false) e  ⟼  None
</code></pre>

<p>So the type of <code>if</code> is that it takes a <code>bool</code> and a <code>T</code>, and produces an
<code>Option&lt;T&gt;</code>:</p>

<pre><code>if (bool) T  :  Option&lt;T&gt;
</code></pre>

<p>(That is to say: if <code>expr_1</code> has type <code>bool</code> and <code>expr_2</code> has type <code>T</code>, then
<code>if (expr_1) expr_2</code> has type <code>Option&lt;T&gt;</code>.)</p>

<p>This generalized <code>if</code> could be used to perform an operation that’s only valid
when the conditional is true:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>strip_prefix</span><span>(</span><span>string</span>: <span>&amp;</span><span>str</span><span>,</span><span> </span><span>prefix</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Option</span><span>&lt;&amp;</span><span>str</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>string</span><span>.</span><span>starts_with</span><span>(</span><span>prefix</span><span>))</span><span> </span><span>&amp;</span><span>string</span><span>[</span><span>prefix</span><span>.</span><span>len</span><span>()..]</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>or in conjunction with a method like
<a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.filter_map"><code>filter_map</code></a>:</p>

<figure><pre><code data-lang="rust"><span></span><span>let</span><span> </span><span>numbers</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[</span><span>9.0</span><span>,</span><span> </span><span>-</span><span>20.0</span><span>,</span><span> </span><span>16.0</span><span>,</span><span> </span><span>-</span><span>16.0</span><span>];</span><span></span>
<span>let</span><span> </span><span>square_roots</span><span> </span><span>=</span><span> </span><span>numbers</span><span></span>
<span>    </span><span>.</span><span>into_iter</span><span>()</span><span></span>
<span>    </span><span>.</span><span>filter_map</span><span>(</span><span>|</span><span>x</span><span>|</span><span> </span><span>if</span><span> </span><span>(</span><span>x</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>x</span><span>.</span><span>sqrt</span><span>());</span><span></span>
<span>assert_eq</span><span>!</span><span>(</span><span>square_roots</span><span>.</span><span>next</span><span>(),</span><span> </span><span>Some</span><span>(</span><span>3.0</span><span>));</span><span></span>
<span>assert_eq</span><span>!</span><span>(</span><span>square_roots</span><span>.</span><span>next</span><span>(),</span><span> </span><span>Some</span><span>(</span><span>4.0</span><span>));</span><span></span>
<span>assert_eq</span><span>!</span><span>(</span><span>square_roots</span><span>.</span><span>next</span><span>(),</span><span> </span><span>None</span><span>);</span><span></span></code></pre></figure>

<h3 id="optional-else">Optional <code>else</code></h3>

<p>There’s a matching interpretation for <code>else</code>. It’s type is:</p>

<pre><code>Option&lt;T&gt; else T  :  T
</code></pre>

<p>and its evaluation rules are that:</p>

<pre><code>None    else e  ⟼  e
Some(x) else e  ⟼  x
</code></pre>

<p>So it supplies a default for an option:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>get_name</span><span>(</span><span>personal_info</span>: <span>&amp;</span><span>HashMap</span><span>&lt;</span><span>String</span><span>,</span><span> </span><span>String</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>str</span> <span>{</span><span></span>
<span>    </span><span>personal_info</span><span>.</span><span>get</span><span>(</span><span>&#34;name&#34;</span><span>)</span><span> </span><span>else</span><span> </span><span>&#34;Whoever you are&#34;</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>(This is exactly the behavior of Rust’s
<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else()</code></a>,
except that you don’t need to manually wrap the expression in a closure.)</p>

<p>Of course, you <em>usually</em> pair an <code>else</code> with an <code>if</code>. This continues to work
like you’d expect, as you can check using the type rules:</p>

<pre><code>let abs_num = if (num &gt; 0) num else -num;
                 --------  ---
                   bool    i32
              ----------------      ----
                Option&lt;i32&gt;         i32
              ---------------------------
                          i32
</code></pre>

<p>Notice what we’ve done: we’ve turned both <code>if</code> and <code>else</code> into <em>binary
operators</em>.</p>

<h3 id="optional-and-and-or">Optional <code>and</code> and <code>or</code></h3>

<p>Can we go further? What about <code>and</code> and <code>or</code> – can they work on options? They
would take options, and return options.</p>

<p><code>or</code> will take the first option if it’s <code>Some</code>, or otherwise take the second.
You could use it to try multiple options each of which may or may not succeed:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>get_color</span><span>(</span><span>attrs</span>: <span>&amp;</span><span>HashMap</span><span>&lt;</span><span>String</span><span>,</span><span> </span><span>String</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>Option</span><span>&lt;&amp;</span><span>str</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>attrs</span><span>.</span><span>get</span><span>(</span><span>&#34;color&#34;</span><span>)</span><span> </span><span>or</span><span> </span><span>attrs</span><span>.</span><span>get</span><span>(</span><span>&#34;colour&#34;</span><span>)</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p><code>and</code> will take the second option, so long as the first option was <code>Some</code>.
You could use it to try something but only if a condition holds. For example,
if you wanted to parse a hex color like <code>&#34;#a52a2a&#34;</code> if a string starts with <code>#</code>,
or a color name like <code>&#34;brown&#34;</code> otherwise, you could write:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>parse_color</span><span>(</span><span>color</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Option</span><span>&lt;</span><span>Color</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>(</span><span>color</span><span>.</span><span>starts_with</span><span>(</span><span>&#34;#&#34;</span><span>)</span><span> </span><span>and</span><span> </span><span>parse_color_hex</span><span>(</span><span>color</span><span>))</span><span></span>
<span>    </span><span>or</span><span> </span><span>parse_color_name</span><span>(</span><span>color</span><span>)</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>More formally, <code>and</code> and <code>or</code> would have the evaluation rules:</p>

<pre><code>None    and e  ⟼  None
Some(x) and e  ⟼  e

None    or  e  ⟼  e
Some(x) or  e  ⟼  Some(x)
</code></pre>

<p>and the type rules:</p>

<pre><code>Option&lt;A&gt; and Option&lt;B&gt;  :  Option&lt;B&gt;
Option&lt;A&gt; or  Option&lt;A&gt;  :  Option&lt;A&gt;
</code></pre>

<p>(This makes <code>and</code> and <code>or</code> equivalent to Rust’s
<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.and_then"><code>and_then</code></a>
and
<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.or_else"><code>or_else</code></a>.)</p>

<p>If you have good mathematical intuition you might notice the asymmetry between
the type rules for <code>and</code> and <code>or</code> and suspect that we’re missing some sort of
generalization. Don’t worry, it will come.</p>

<h3 id="but-booleans">But booleans?</h3>

<p>But wait! You still need to be able to use <code>and</code> and <code>or</code> inside an <code>if</code>’s
condition, for example <code>if (x &gt;= 0 and x &lt; len)</code>. That doesn’t work if <code>and</code>
produces an option!</p>

<p>There’s an easy fix, though. There’s an equivalence between booleans and
options:</p>

<pre><code>bool  = Option&lt;()&gt;
true  = Some(())
false = None
</code></pre>

<p>So we could eliminate booleans from our hypothetical language, and always use
the equivalent options instead.</p>

<h2 id="putting-it-all-together">Putting it all Together</h2>

<p>Now let’s imagine what a programming language without booleans might look like.</p>

<p>We just talked about replacing <code>bool</code> with <code>Option&lt;()&gt;</code>, because those types are
equivalent. But there’s a further equivalence with
<a href="https://doc.rust-lang.org/stable/std/result/index.html">results</a>, as well:</p>

<pre><code>Option&lt;T&gt; = Result&lt;T, ()&gt;
bool      = Option&lt;()&gt;
          = Result&lt;(), ()&gt;
</code></pre>

<p>If we’re going to use the equivalence between booleans and options, we might as
well go all the way and use the equivalence between options and results.
Results everywhere!</p>

<p>Since they’ll be so ubiquitous, let’s invent a short syntax for them. <code>T ? E</code>
can mean “either a successful value <code>T</code>, or an error <code>E</code>”. What Rust would call
<code>Result&lt;T, E&gt;</code>.</p>

<p>Then <code>bool</code> is a type alias for <code>()?()</code>. Except… that looks like an ASCII
drawing of a fly’s face. So let’s call the unit value (and the unit type) <code>nil</code>
instead. Then we have:</p>

<pre><code>bool  = nil?nil

true  = Ok(nil)
false = Err(nil)
</code></pre>

<p>These will be aliases built into the language.</p>

<p>Writing all of the type rules from before but using results instead of
options, we have:</p>

<pre><code>if (A?E) B   :  B?E
A?E else A   :  A
A?E and B?E  :  B?E
A?E or  A?F  :  A?F
not A?E      :  E?A
</code></pre>

<p>(There’s the nice symmetry that was lacking before.)</p>

<p>And writing all of the evaluation rules:</p>

<pre><code>if (Ok(x))  e  ⟼  Ok(e)
if (Err(x)) e  ⟼  Err(x)

Ok(x)  else e  ⟼  x
Err(x) else e  ⟼  e

Ok(x)  and e   ⟼  e
Err(x) and e   ⟼  Err(x)

Ok(x)  or  e   ⟼  Ok(x)
Err(x) or  e   ⟼  e

not Ok(x)      ⟼  Err(x)
not Err(x)     ⟼  Ok(x)
</code></pre>

<p>(I’m not really sure whether <code>if (A?E) B</code> is the right type, or if <code>if</code> should
require its conditional’s error to be <code>nil</code>, like <code>if (A?nil) B</code>.)</p>

<p>Now we can start to imagine what conditionals in this language might look like.</p>

<h3 id="else-if"><code>else if</code></h3>

<p>We’ve replaced <code>if</code> and <code>else</code> with binary operators, so we should verify that
<code>else if</code> still works the way it’s supposed to:</p>

<figure><pre><code data-lang="rust"><span></span><span>let</span><span> </span><span>sign</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>(</span><span>n</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>1</span><span></span>
<span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>n</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>-</span><span>1</span><span></span>
<span>else</span><span></span>
<span>    </span><span>0</span><span>;</span><span></span></code></pre></figure>

<p>It does, so long as <code>else</code> is right associative. That is, the grouping needs to
be like this:</p>

<pre><code>    if (n &gt; 0) 1 else if (n &lt; 0) -1 else 0
    ------------      -------------
                      --------------------
    --------------------------------------
</code></pre>

<h3 id="or-if"><code>or if</code></h3>

<p>Surprisingly there’s another way to write multi-way conditionals:</p>

<figure><pre><code data-lang="rust"><span></span><span>let</span><span> </span><span>sign</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>(</span><span>n</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>1</span><span></span>
<span>or</span><span> </span><span>if</span><span> </span><span>(</span><span>n</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>-</span><span>1</span><span></span>
<span>else</span><span></span>
<span>    </span><span>0</span><span>;</span><span></span></code></pre></figure>

<p>This behaves exactly the same as <code>else if</code>! It’s relying on the <code>or</code> binding
tighter than the <code>else</code>:</p>

<pre><code>    if (n &gt; 0) 1 or if (n &lt; 0) -1 else 0
    ------------    -------------
    -----------------------------
    ------------------------------------
</code></pre>

<p>It took me a bit to get past my “WTF” reaction, but now I kind of like saying
“or if”.</p>

<h3 id="true-and-false"><code>true</code> and <code>false</code></h3>

<p>Remember that <code>true</code> and <code>false</code> are simply shorthands for <code>Ok(nil)</code> and
<code>Err(nil)</code>. So you can write:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>delete_file</span><span>(</span><span>path</span>: <span>FilePath</span><span>)</span><span> </span>-&gt; <span>nil</span><span> </span><span>?</span><span> </span><span>IOError</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>not</span><span> </span><span>file_exists</span><span>(</span><span>path</span><span>))</span><span> </span><span>return</span><span> </span><span>true</span><span>;</span><span></span>

<span>    </span><span>...</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>and:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>pop</span><span>(</span><span>vec</span>: <span>&amp;</span><span>mut</span><span> </span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>i32</span> <span>?</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>vec</span><span>.</span><span>len</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>

<span>    </span><span>...</span><span></span>
<span>}</span><span></span></code></pre></figure>

<h3 id="is"><code>is</code></h3>

<p>It’s very useful to be able to bind a pattern inside a conditional. Rust uses
the syntax <code>if let</code> for this; let’s use the syntax <code>is</code> instead:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>parse_and_clamp</span><span>(</span><span>s</span>: <span>&amp;</span><span>str</span><span>,</span><span> </span><span>min</span>: <span>i32</span><span>,</span><span> </span><span>max</span>: <span>i32</span><span>)</span><span> </span>-&gt; <span>i32</span> <span>?</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>parse_num</span><span>(</span><span>s</span><span>)</span><span> </span><span>is</span><span> </span><span>Ok</span><span>(</span><span>n</span><span>))</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>(</span><span>n</span><span> </span><span>&lt;</span><span> </span><span>min</span><span>)</span><span> </span><span>min</span><span></span>
<span>        </span><span>or</span><span> </span><span>if</span><span> </span><span>(</span><span>n</span><span> </span><span>&gt;</span><span> </span><span>max</span><span>)</span><span> </span><span>max</span><span></span>
<span>        </span><span>else</span><span> </span><span>n</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<h3 id="try--else"><code>try / else</code></h3>

<p>Python lets you put an <code>else</code> clause after a <code>for</code> loop. The <code>else</code> clause runs
if the <code>for</code> loop doesn’t <code>break</code>. For example:</p>

<figure><pre><code data-lang="python"><span></span><span>for</span> <span>elem</span> <span>in</span> <span>list</span><span>:</span>
    <span>if</span> <span>predicate</span><span>(</span><span>elem</span><span>):</span>
        <span>print</span><span>(</span><span>&#34;Found!&#34;</span><span>,</span> <span>elem</span><span>)</span>
        <span>break</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Not found :-(&#34;</span><span>)</span></code></pre></figure>

<p>There’s a natural extension of this in our hypothetical language – a <code>for</code> loop
can <code>break</code> with a value, and prodcues <code>Ok</code> if it does:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>find</span><span>(</span><span>list</span>: <span>&amp;</span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>,</span><span> </span><span>predicate</span>: <span>fn</span><span>(</span><span>i32</span><span>)</span><span> </span>-&gt; <span>bool</span><span>)</span><span> </span>-&gt; <span>i32</span> <span>?</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>for</span><span> </span><span>elem</span><span> </span><span>in</span><span> </span><span>list</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>(</span><span>predicate</span><span>(</span><span>elem</span><span>))</span><span> </span><span>break</span><span> </span><span>elem</span><span>;</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>This can be composed with our existing <code>else</code> construct:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>find_with_default</span><span>(</span><span></span>
<span>    </span><span>list</span>: <span>&amp;</span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>,</span><span></span>
<span>    </span><span>predicate</span>: <span>fn</span><span>(</span><span>i32</span><span>)</span><span> </span>-&gt; <span>bool</span><span>,</span><span></span>
<span>    </span><span>default</span>: <span>i32</span>
<span>)</span><span> </span>-&gt; <span>i32</span> <span>{</span><span></span>
<span>    </span><span>for</span><span> </span><span>elem</span><span> </span><span>in</span><span> </span><span>list</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>(</span><span>predicate</span><span>(</span><span>elem</span><span>))</span><span> </span><span>break</span><span> </span><span>elem</span><span>;</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>default</span><span></span>
<span>}</span><span></span></code></pre></figure>

<h3 id="fewer-oks-and-errs">Fewer <code>Ok</code>s and <code>Err</code>s</h3>

<p>Many functions which would require wrapping their result in <code>Ok</code> or <code>Err</code> or
<code>Some</code> if they were written in Rust, no longer require that. For example,
parsing a boolean in Rust:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>parse_bool</span><span>(</span><span>s</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Option</span><span>&lt;</span><span>bool</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>s</span><span> </span><span>==</span><span> </span><span>&#34;true&#34;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Some</span><span>(</span><span>true</span><span>)</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>s</span><span> </span><span>==</span><span> </span><span>&#34;false&#34;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Some</span><span>(</span><span>false</span><span>)</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>        </span><span>None</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>vs. in our hypothetical language:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>parse_bool</span><span>(</span><span>s</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>bool</span> <span>?</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>s</span><span> </span><span>==</span><span> </span><span>&#34;true&#34;</span><span>)</span><span> </span><span>true</span><span></span>
<span>    </span><span>or</span><span> </span><span>if</span><span> </span><span>(</span><span>s</span><span> </span><span>==</span><span> </span><span>&#34;false&#34;</span><span>)</span><span> </span><span>false</span><span></span>
<span>}</span><span></span></code></pre></figure>

<h3 id="real-messy-examples">Real Messy Examples</h3>

<p>All the examples so far have been short. Let’s look at some real code, code from
deep inside the guts of my personal projects. No need to understand what it does
(I certainly don’t remember the details), we just need to rewrite it in this
hypothetical language and see how it compares.</p>

<p>Here’s one snippet:</p>

<figure><pre><code data-lang="rust"><span></span><span>if</span><span> </span><span>!</span><span>node</span><span>.</span><span>can_have_children</span><span>(</span><span>s</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>None</span><span>;</span><span></span>
<span>}</span><span></span>
<span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>last_child</span><span>)</span><span> </span><span>=</span><span> </span><span>node</span><span>.</span><span>last_child</span><span>(</span><span>s</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>Some</span><span>(</span><span>Location</span><span>(</span><span>AtNode</span><span>(</span><span>last_child</span><span>)))</span><span></span>
<span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>Some</span><span>(</span><span>Location</span><span>(</span><span>BelowNode</span><span>(</span><span>node</span><span>)))</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>which can now be written as:</p>

<figure><pre><code data-lang="rust"><span></span><span>if</span><span> </span><span>(</span><span>node</span><span>.</span><span>can_have_children</span><span>(</span><span>s</span><span>))</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>node</span><span>.</span><span>last_child</span><span>(</span><span>s</span><span>)</span><span> </span><span>is</span><span> </span><span>Ok</span><span>(</span><span>last_child</span><span>))</span><span></span>
<span>        </span><span>Location</span><span>(</span><span>AtNode</span><span>(</span><span>last_child</span><span>))</span><span></span>
<span>    </span><span>else</span><span></span>
<span>        </span><span>Location</span><span>(</span><span>BelowNode</span><span>(</span><span>node</span><span>))</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>And other example:</p>

<figure><pre><code data-lang="rust"><span></span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>menu</span><span>)</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>.</span><span>active_menu</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>key_prog</span><span>)</span><span> </span><span>=</span><span> </span><span>menu</span><span>.</span><span>lookup</span><span>(</span><span>key</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>Some</span><span>(</span><span>KeyLookupResult</span>::<span>KeyProg</span><span>(</span><span>key_prog</span><span>));</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>ch</span><span>)</span><span> </span><span>=</span><span> </span><span>key</span><span>.</span><span>as_plain_char</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>menu</span><span>.</span><span>execute</span><span>(</span><span>MenuSelectionCmd</span>::<span>Insert</span><span>(</span><span>ch</span><span>))</span><span> </span><span>{</span><span></span>
<span>            </span><span>return</span><span> </span><span>Some</span><span>(</span><span>KeyLookupResult</span>::<span>Redisplay</span><span>);</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>layer</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>composite_layer</span><span>(</span><span>doc_name</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>keymap</span><span> </span><span>=</span><span> </span><span>layer</span><span>.</span><span>keymaps</span><span>.</span><span>get</span><span>(</span><span>&amp;</span><span>KeymapLabel</span>::<span>Mode</span><span>(</span><span>mode</span><span>));</span><span></span>
<span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>key_prog</span><span>)</span><span> </span><span>=</span><span> </span><span>keymap</span><span>.</span><span>lookup</span><span>(</span><span>key</span><span>,</span><span> </span><span>None</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>Some</span><span>(</span><span>KeyLookupResult</span>::<span>KeyProg</span><span>(</span><span>key_prog</span><span>));</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>if</span><span> </span><span>mode</span><span> </span><span>==</span><span> </span><span>Mode</span>::<span>Text</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>ch</span><span>)</span><span> </span><span>=</span><span> </span><span>key</span><span>.</span><span>as_plain_char</span><span>()</span><span> </span><span>{</span><span></span>
<span>            </span><span>return</span><span> </span><span>Some</span><span>(</span><span>KeyLookupResult</span>::<span>InsertChar</span><span>(</span><span>ch</span><span>));</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>
<span>None</span><span></span></code></pre></figure>

<p>would be written as:</p>

<figure><pre><code data-lang="rust"><span></span><span>if</span><span> </span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>.</span><span>active_menu</span><span> </span><span>is</span><span> </span><span>Ok</span><span>(</span><span>menu</span><span>))</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>menu</span><span>.</span><span>lookup</span><span>(</span><span>key</span><span>)</span><span> </span><span>is</span><span> </span><span>Ok</span><span>(</span><span>key_prog</span><span>))</span><span> </span><span>{</span><span></span>
<span>        </span><span>KeyLookupResult</span>::<span>KeyProg</span><span>(</span><span>key_prog</span><span>)</span><span></span>
<span>    </span><span>}</span><span> </span><span>or</span><span> </span><span>if</span><span> </span><span>(</span><span>key</span><span>.</span><span>as_plain_char</span><span>()</span><span> </span><span>is</span><span> </span><span>Ok</span><span>(</span><span>ch</span><span>)</span><span></span>
<span>           </span><span>and</span><span> </span><span>menu</span><span>.</span><span>execute</span><span>(</span><span>MenuSelectionCmd</span>::<span>Insert</span><span>(</span><span>ch</span><span>)))</span><span> </span><span>{</span><span></span>
<span>        </span><span>KeyLookupResult</span>::<span>Redisplay</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>layer</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>composite_layer</span><span>(</span><span>doc_name</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>keymap</span><span> </span><span>=</span><span> </span><span>layer</span><span>.</span><span>keymaps</span><span>.</span><span>get</span><span>(</span><span>&amp;</span><span>KeymapLabel</span>::<span>Mode</span><span>(</span><span>mode</span><span>));</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>keymap</span><span>.</span><span>lookup</span><span>(</span><span>key</span><span>,</span><span> </span><span>false</span><span>)</span><span> </span><span>is</span><span> </span><span>Ok</span><span>(</span><span>key_prog</span><span>))</span><span> </span><span>{</span><span></span>
<span>        </span><span>KeyLookupResult</span>::<span>KeyProg</span><span>(</span><span>key_prog</span><span>)</span><span></span>
<span>    </span><span>}</span><span> </span><span>or</span><span> </span><span>if</span><span> </span><span>(</span><span>mode</span><span> </span><span>==</span><span> </span><span>Mode</span>::<span>Text</span><span> </span><span>and</span><span> </span><span>key</span><span>.</span><span>as_plain_char</span><span>()</span><span> </span><span>is</span><span> </span><span>Ok</span><span>(</span><span>ch</span><span>))</span><span> </span><span>{</span><span></span>
<span>        </span><span>KeyLookupResult</span>::<span>InsertChar</span><span>(</span><span>ch</span><span>)</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Notice that this loses the need for wrapping the results in <code>Some</code> and the need
for early <code>return</code> statements.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This sure seems to be a coherent design! It will certainly influence how I think
about conditionals.</p>

<p>The closest thing I’ve seen is <a href="https://dev.epicgames.com/documentation/en-us/fortnite/failure-in-verse">fallible
expressions</a>
in <a href="https://en.wikipedia.org/wiki/Verse_(programming_language)">Verse</a>, but
those are pretty different because they (i) don’t assign a value to an <code>if</code>
without an <code>else</code>, and (ii) involve speculative execution. Let me know if you’ve
seen anything more similar.</p>

<p>UPDATES:</p>

<ul>
  <li>I mentioned Verse, but commenters point out that its ideas are <em>much</em> older,
originally called “goal directed evaluation” and developed in SNOBOL and Icon
in the <em>sixties and seventies</em>.</li>
  <li>Many dynamically typed languages allow <code>and</code> and <code>or</code> to act on values other
than booleans, making them behave much like this post suggests.</li>
  <li>This post used to say that <code>not a?e</code> had type <code>nil?nil</code>. Commenter <code>dpercy</code>
points out that it could instead have type <code>e?a</code>. This seems so right that
I edited the post to make it so.</li>
  <li>Jimmy Koppel says of this post “So basically, Rust’s <code>or_else</code> and friends,
but as built-in syntax.” Yup, exactly that. Plus the related realization that
<code>if</code> and <code>else</code> can be binary operators.</li>
</ul>

<p>Discussion was on
<a href="https://www.reddit.com/r/programming/comments/1no2u4j/imagining_a_language_without_booleans/">r/programming</a>
and <a href="https://lobste.rs/s/a8bwsw/imagining_language_without_booleans">lobste.rs</a>.</p>

<p>
September 22, 2025
<a href="https://justinpombrio.net/feed.xml"><img width="16rem" src="https://justinpombrio.net/src/img/rss.png"/></a>
</p>
</div></div>
  </body>
</html>
