<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/">Original</a>
    <h1>Structures in C: From Basics to Memory Alignment</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1043">
	<div>
		<!-- .entry-header -->

		<div>
			
<p>Structures allow us to combine several variables to create a new data type. Some other languages support the same concept but call it “records”. If you come from object-oriented programming you can think about them as classes without methods.</p>



<h2>Declaration</h2>



<p>A structure is declared by the keyword <strong>struct</strong> followed by the name of the new structure and a list of its members enclosed in parentheses:</p>


<div><pre title="">struct s {
    char a;
    int b;
    double c;
    char d[10];
};
</pre></div>


<p>Here we declared a new structure with the name <strong>s</strong> that has the members <strong>a</strong> (a single character), <strong>b</strong> (an integer), <strong>c</strong> (a double), and <strong>d</strong> (a char array of size 10 which can store up to 9 characters and a terminating null character).</p>



<h2>Using a Structure</h2>



<p>To use our new structure type we have to declare a new variable of type struct s and from then on we can access all individual members by writing the variable name followed by a dot and the name of the member:</p>


<div><pre title="">// declare s1 as a variable of type struct s
struct s s1;

// set a, b, and c to a value of their respective type
s1.a = &#39;H&#39;;
s1.b = 42;
s1.c = 3.14;

// set d to the string &#34;Hello&#34; by setting each character individually
s1.d[0] = &#39;H&#39;;
s1.d[1] = &#39;e&#39;;
s1.d[2] = &#39;l&#39;;
s1.d[3] = &#39;l&#39;;
s1.d[4] = &#39;o&#39;;
s1.d[5] = &#39;\0&#39;; // null-character to terminate the string

printf(&#34;s1.a: %c\n&#34;, s1.a);
printf(&#34;s1.b: %i\n&#34;, s1.b);
printf(&#34;s1.c: %f\n&#34;, s1.c);
printf(&#34;s1.d: %s\n&#34;, s1.d);
</pre></div>


<p>Output:</p>



<pre><code>s1.a: H
s1.b: 42
s1.c: 3.140000
s1.d: Hello</code></pre>



<h2>Using a Structure via a Pointer</h2>



<p>The dot syntax from the previous example works for direct access to a structure variable but it doesn’t work if we want to access a structure via a pointer. For this kind of access, we need to use the <strong>-&gt;</strong> operator or you will get a compiler error.</p>



<p>If we declare a pointer to s1 and use it exclusively to access the members of s1, our previous example will look like this:</p>


<div><pre title="">// declare s1 as a variable of type struct s
struct s s1;

// declare sp to be a pointer to s1
struct s *sp = &amp;s1;

// set a, b, and c to a value of their respective type
sp-&gt;a = &#39;H&#39;;
sp-&gt;b = 42;
sp-&gt;c = 3.14;

// set d to the string &#34;Hello&#34; by setting each character individually
s1.d[0] = &#39;H&#39;;
s1.d[1] = &#39;e&#39;;
s1.d[2] = &#39;l&#39;;
s1.d[3] = &#39;l&#39;;
s1.d[4] = &#39;o&#39;;
s1.d[5] = &#39;\0&#39;; // null-character to terminate the string

printf(&#34;s1-&gt;a: %c\n&#34;, s1.a);
printf(&#34;s1-&gt;b: %i\n&#34;, s1.b);
printf(&#34;s1-&gt;c: %f\n&#34;, s1.c);
printf(&#34;s1-&gt;d: %s\n&#34;, s1.d);
</pre></div>


<p>Output:</p>



<pre><code>s1.&gt;a: H
s1-&gt;b: 42
s1-&gt;c: 3.140000
s1-&gt;d: Hello</code></pre>



<h2>Declaring a Struct and Variables</h2>



<p>The declaration of a struct can include the declaration of variables of the new struct:</p>


<div><pre title="">struct s {
    char a;
    int b;
    double c;
    char d[10];
} example1, example2;
</pre></div>


<p>This code declares the struct s as well as the variables example1 and example2, both of them being instances of s.</p>



<h2>Initialization</h2>



<p>If we declare a structure variable without initializing it, like any other variable in C, it will be uninitialized at first and may contain random values.</p>



<p>In the previous examples, we initialized our structure variables manually by setting each member individually. This is perfectly fine (as long as we don’t forget to do so) but we can also initialize a structure variable when we declare it.</p>



<p>The C89 Standard allows us to initialize a structure variable like this:</p>


<div><pre title="">struct s s1 = {
    &#39;H&#39;,
    42,
    3.14,
    &#34;Hello&#34;
};
</pre></div>


<p>With this syntax, we have to provide the values in the same order in which the members of the structure are declared. The problem with this is that we can never be sure that the values are assigned to the right member unless we look up the structure declaration. </p>



<p>It is not much of a problem with a structure that has only four members as in this example. But in complex programs, a structure can easily have 20 members and more. Things will get even more problematic when a structure changes over time. In such a case it is easy to make some subtle mistakes and put some values on the wrong line. The compiler will refuse to compile such a program if at least one initialization value is incompatible with the corresponding member of the structure. But if they are compatible you are out of luck and the compiler will accept the program, and you might have a subtle bug that is hard to find.</p>



<p>In the past, people tried to mitigate this problem by adding a comment with the name of the structure member to be initialized behind every initialization value.</p>



<p>Fortunately, nowadays there is a better solution. The C99 Standard introduced the so-called designated initializers. This new syntax for initializing struct members allows you to make explicit which members are initialized with which value:</p>


<div><pre title="">struct s s1 = {
    .a = &#39;H&#39;,
    .b = 42,
    .c = 3.14,
    .d = &#34;Hello&#34;
};
</pre></div>


<p>The new syntax is way superior to the old one. You should always prefer it. The only reason not to use it is if you are forced to work with a C89 compiler and can’t upgrade.</p>



<h2>Comparing Structs</h2>



<p>C does not support the comparison of struts. In fact, if we try to compare two structs (even of the same type) with the == operator we will get a compile error.</p>



<p>The only way to compare two structs in C is to compare them member by member and the best way to do this is to write a comparison function for each struct type we want to compare.</p>



<p>So say we have a struct named Vector2D that represents a two-dimensional vector:</p>


<div><pre title="">struct Vector2D {
    float x;
    float y;
};
</pre></div>


<p>And we want to be able to compare this type. The comparison function could look like this:</p>


<div><pre title="">bool vector2d_compare(struct Vector2D *vec1, struct Vector2D *vec2)
{
    return vec1-&gt;x == vec2-&gt;x &amp;&amp; vec1-&gt;y == vec2-&gt;y;
}
</pre></div>


<h2>Declaring a Struct as a New Type</h2>



<p>Whenever we want to use a struct that we declared previously, we have to prefix it with the keyword struct because structs live in their own namespace. But what if we want a struct to feel like a real C type?</p>



<p>In this case, we can just use typedef:</p>


<div><pre title="">struct Vector2D {
    float x;
    float y;
};

typedef struct Vector2D Vector2D;
</pre></div>


<p>In this example, we first declare a struct named Vector2D and afterward, we use typedef to define struct Vector2D as the new type Vector2D. We can also combine the typedef and the declaration of the struct into one single declaration (which is the best way to do it):</p>


<div><pre title="">typedef struct Vector2D {
    float x;
    float y;
} Vector2D;
</pre></div>


<p>Both declarations have the same effect. We can now use our vector type as if it were a built-in C type:</p>





<h2>Dynamic Allocation</h2>



<p>Until now we always declared our structs as normal variables and therefore created them on the stack. But of course, we can also allocate a structure dynamically on the heap.</p>



<p>To do this, we just call malloc with the size of the struct and store the resulting value in a pointer to our struct. We then have to check if the pointer returned by malloc is NULL. If this is the case the allocation failed (usually because the system is out of memory) and we have to handle this error condition (e.g. by making sure all data touched by the program is in a consistent state and exiting the program with an error message).</p>


<div><pre title="">#include &lt;stdlib.h&gt;

...

struct Vector2D *vec;
vec = malloc(sizeof(struct Vector2D));
if (sec == NULL) {
    // handle allocation failure
}
</pre></div>


<p>If the pointer is not NULL we have a newly allocated instance of your struct. The memory is uninitialized so it is a good idea to initialize it to zero bytes. We can do this by calling the memset function with the pointer to our new struct, the initialization value 0, and the size of our structure:</p>


<div><pre title="">#include &lt;string.h&gt;

...

memset(sec, 0, sizeof(struct Vector2D));
</pre></div>


<p>Of course, we must not forget to free this newly allocated struct once we don’t need it anymore with the following code:</p>





<p>Failing to do so will cause a memory leak.</p>



<h2>Copying Structs</h2>



<p>Before C99 compilers were not required to be able to copy structs. Therefore, the only way to pass them around was via pointers. So if you wanted to write a function that manipulates a struct you had to do it like this:</p>


<div><pre title="">void change_struct(struct example *value)
{
    // do something with value
    ...
}
</pre></div>


<p>With C99 passing structs by value is an option:</p>


<div><pre title="">struct example change_struct(struct example value)
{
    // do something with value
    ...

    return value
}
</pre></div>


<p>Of course, this also means that you have to pass value to the function and assign the return value of the function to value when calling it:</p>


<div><pre title="">struct value;

// init value
...

value = change_struct(value);
</pre></div>


<p>Some people might argue that this is slower than passing around pointers. But in many cases, it is not. It might even be faster than passing pointers.</p>



<p>The only way to know for sure is by measuring it.</p>



<p>The great thing about this is that it allows us to omit to allocate structs with malloc on the heap. Instead, we could create a struct on the stack and pass it around by copying it. This opens the door to new approaches for writing safer C code.</p>



<h2>Nested Structures</h2>



<p>Structures can be nested. That means a structure can contain another structure. Let’s use our 2D vector as an example again:</p>


<div><pre title="">typedef struct Vector2D {
    float x;
    float y;
} Vector2D;
</pre></div>


<p>We could then declare a structure type that represents a Sprite and uses our 2D vector type to represent the position of the sprite:</p>


<div><pre title="">typedef struct Sprite {
    char *name;
    Vector2D position;
    uint8_t *gfx_data;
} Sprite;
</pre></div>


<p>Of course, C also allows us to initialize our nested structure together with the containing structure:</p>


<div><pre title="">Sprite sprite = {
    .name = &#34;Space Ship&#34;,
    .position = {.x = 1.5f, .y = 6.8f},
    .gfx_data = &#34;\xe3\xf8\x42\xd8...&#34;
};
</pre></div>


<h2>Self Referential Structures</h2>



<p>A structure can contain instances of other structures as members but it cannot contain members of its own type. </p>



<p>So if we tried to create a very simplistic binary tree like this:</p>


<div><pre title="">struct tree {
    struct tree left;
    struct tree right;
    char str[32];
};
</pre></div>


<p>we would get a compile error. The reason for this is that this would create an endless recursion and the structure would take up an infinite amount of memory.</p>



<p>The only way around this problem is to use pointers to the structure of the same type as a member:</p>


<div><pre title="">struct tree {
    struct tree *left;
    struct tree *right;
    char str[32];
};
</pre></div>


<h2>Element Order and Addressing</h2>



<p>The C Standard guarantees that all members of a structure occur in memory in the same order as in the declaration.</p>



<p>That means if we have a structure definition like this:</p>


<div><pre title="">struct abc {
    char a;
    int b;
    double c;
};
</pre></div>


<p>then the member <strong>a</strong> will always be the first element in memory, <strong>b</strong> will be placed after <strong>a</strong>, and <strong>c</strong> will be placed after <strong>b</strong>.</p>



<figure><img data-attachment-id="1294" data-permalink="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/struct-ordering-1/" data-orig-file="https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png" data-orig-size="1200,173" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="struct-ordering-1" data-image-description="" data-image-caption="" data-medium-file="https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png?w=300" data-large-file="https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png?w=640" src="https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png?w=1024" alt="Struct members appear in memory in the order of their declaration" srcset="https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png?w=1024 1024w, https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png?w=150 150w, https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png?w=300 300w, https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png?w=768 768w, https://abstractexpr.files.wordpress.com/2023/06/struct-ordering-1.png 1200w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Now if we want to get the address of a member inside a structure it is as simple as this:</p>





<p>And with a pointer </p>


<div><pre title="">struct abc s1;
struct abc *p = &amp;s1;

&amp;p-&gt;b;
</pre></div>


<p>If you don’t want to get the memory address of a member but just want to know how many bytes it starts from the beginning of the structure (its offset) you can use the very neat <em>offsetof</em> macro that is defined in stddef.h:</p>


<div><pre title="">sizet_t offset_b = offsetof(struct abc, b);
</pre></div>


<p>If this macro returned 8 for example this would mean that the member variable is located at the memory address of the struct plus 8 bytes.</p>



<p>This macro is useful to check if the compiler added any padding in between the members of the structure. It can also be used to get the memory address of the structure if you only have the address of one of its members and know what type of struct it is a member of. This is used in some advanced code e.g. the OOP implementation of the Linux Kernel.</p>



<h2>Alignment and Padding</h2>



<p>One might assume that the compiler puts all its members directly behind each other in memory with no gaps in between and that the size of each structure is exactly the same as the sum of the sizes of all of its members. Such a structure is called a packed structure:</p>



<figure><img data-attachment-id="1296" data-permalink="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/struct-packed-1/" data-orig-file="https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png" data-orig-size="1200,231" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="struct-packed-1" data-image-description="" data-image-caption="" data-medium-file="https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png?w=300" data-large-file="https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png?w=640" src="https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png?w=1024" alt="A packed struct has no gaps and no padding" srcset="https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png?w=1024 1024w, https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png?w=150 150w, https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png?w=300 300w, https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png?w=768 768w, https://abstractexpr.files.wordpress.com/2023/06/struct-packed-1.png 1200w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>This is <strong>NOT</strong> how a compiler usually lays out a structure in memory.</p>



<p>In the previous section, we already said that the C standard guarantees that struct members always appear in memory in the exact same order in which they are declared in code. In addition, the C standard also says the following things regarding the memory layout of structures:</p>



<ul>
<li>The first member must always start at the same memory address as the structure itself</li>



<li>There may be padding before each other member of the structure to ensure that it is located at a memory address that complies with whatever rules the hardware platform defines for such a type</li>



<li>There may be padding at the end of the structure</li>
</ul>



<p>The possible padding as allowed by the C standard can be visualized like this:</p>



<figure><img data-attachment-id="1298" data-permalink="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/struct-padding-standard-1/" data-orig-file="https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png" data-orig-size="1200,239" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="struct-padding-standard-1" data-image-description="" data-image-caption="" data-medium-file="https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png?w=300" data-large-file="https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png?w=640" src="https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png?w=1024" alt="Locations of possible padding according to the C Standard" srcset="https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png?w=1024 1024w, https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png?w=150 150w, https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png?w=300 300w, https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png?w=768 768w, https://abstractexpr.files.wordpress.com/2023/06/struct-padding-standard-1.png 1200w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>The compiler is allowed to add padding at those locations shown in the graphic but it is not obliged to do so. There is no guarantee about the data that is stored in those areas that the compiler uses as padding. It might be all zeroed, it might be only ones or zeros or it might be a bit pattern. It could also be just random data.</p>



<p>Packed structures are so much nicer and they don’t waste any memory. Why doesn’t the standard enforce their use and why does it leave so many things open for the implementation to decide?</p>



<p>The most general reason is that one of the design goals of C was to be a language that can be implemented on as many hardware platforms as possible. Therefore the standard needs to be flexible to allow compilers to adapt the actual implementation to the specialties and quirks of their hardware respective platforms.</p>



<p>The other reason is that even on modern platforms it is faster to access data that is located at a memory address that is divisible by a certain number. Putting your data on such “even” addresses is called <strong>memory alignment</strong>. On some platforms (e.g. SPARC) memory alignment is even strictly necessary because memory access to unaligned addresses leads to a CPU exception and crashes the misbehaving program.</p>



<p>Thankfully, most modern hardware platforms (especially x64 and ARM64) follow the same rules for alignment. On modern platforms, all basic C types have to be self-aligned. This means that each basic type has to be located at a memory address that is a multiple of its size:</p>



<figure><table><tbody><tr><td><strong>Data Type</strong></td><td><strong>Size in Bytes</strong></td><td><strong>Self-Alignment</strong></td></tr><tr><td>char</td><td>1</td><td>None (any address is fine)</td></tr><tr><td>short</td><td>2</td><td>The address has to be a multiple of 2</td></tr><tr><td>int</td><td>4</td><td>The address has to be a multiple of 4</td></tr><tr><td>long</td><td>8</td><td>The address has to be a multiple of 8</td></tr><tr><td>Pointer</td><td>8</td><td>The address has to be a multiple of 8</td></tr></tbody></table><figcaption><em>Self-alignment rules of a modern 64-bit machine (e.g. x86-64 or ARM 64)</em></figcaption></figure>



<p>If we suppose for a moment for the sake of having nice and easy memory addresses that we could store data in the very first 64-bit word in memory which begins at address 0 (which in practice we can’t because this part of the memory is usually protected), then we could visualize the possible addresses of our basic data types like this:</p>



<figure><img data-attachment-id="1300" data-permalink="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/memory-alignment-1/" data-orig-file="https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png" data-orig-size="1200,686" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="memory-alignment-1" data-image-description="" data-image-caption="" data-medium-file="https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png?w=300" data-large-file="https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png?w=640" src="https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png?w=1024" alt="Possible memory addresses of self-aligned basic data types" srcset="https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png?w=1024 1024w, https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png?w=150 150w, https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png?w=300 300w, https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png?w=768 768w, https://abstractexpr.files.wordpress.com/2023/06/memory-alignment-1.png 1200w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><em>Possible memory addresses of self-aligned basic data types</em></figcaption></figure>



<p>The reason for those rules is that on such a machine we have a load instruction that can read a full 64-bit word from memory. If we imagine memory as a sequence of 64-bit words then there starts a new word every 8 bytes (64 bits).</p>



<figure><img data-attachment-id="1302" data-permalink="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/machine-words-1/" data-orig-file="https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png" data-orig-size="1200,320" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="machine-words-1" data-image-description="" data-image-caption="" data-medium-file="https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png?w=300" data-large-file="https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png?w=640" src="https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png?w=1024" alt="Machine words in memory" srcset="https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png?w=1024 1024w, https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png?w=150 150w, https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png?w=300 300w, https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png?w=768 768w, https://abstractexpr.files.wordpress.com/2023/06/machine-words-1.png 1200w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>All those starting addresses of our machine words (0, 8, 16, 24, etc.) are “even”. Loading such a “regular” word from an “even” address is fast. But we can also load 8 bytes starting at any address of our choosing. Let’s say we load a word beginning at address 4. In this case, the word we load would span two machine words. It would consist of the last 4 bytes of the first machine word in memory and the first 4 bytes of the second machine word. Due to hardware limitations, a load operation that spans two machine words is slow.</p>



<p>And here you have it. If you look at the graphic of the possible self-aligned addresses of our basic data types again you can see that it is not possible for one of those variables to be in more than one machine word. This is the purpose of those rules.</p>



<p>There is one problem left. And that is arrays. Members of arrays are put in memory in sequence with no gaps between them. So arrays themselves have no padding. What would happen if we have a structure where all the members are carefully aligned but its total size is odd and we put another struct of the same type right behind it in memory? Right! We get array members that cross the boundaries of machine words and our carefully crafted alignment falls apart.</p>



<p>Just look at the diagram of our self-aligned data types and add 3 to all the starting addresses in your mind and you see what I mean. Add an 8 instead and everything is fine. Our data just moved to the second “regular” word in memory. Add a 2 and the shorts are fine (the chars are always fine). Add a 4 and the shorts and the ints are fine and only the 8-byte types live in two different machine words.</p>



<p>And here we already see the solution. A structure has to get enough trailing padding to align with its biggest data type. So if your structure contains an 8-byte type the total size of the structure has to be a multiple of 8. If your biggest type is 4 bytes the total size has to be a multiple of 4. And with the biggest type being 2 bytes – you guessed it – the size of the structure has to be a multiple of 2.</p>



<h3>Example</h3>



<p>Alignment and padding can be confusing topics.</p>



<p>So let’s look at some code to get a better feel for it:</p>


<div><pre title="">#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;

struct s {
    char a;
    int b;
    double c;
    char d[10];
};

int main(void) {
    // add the size of each member of struct s
    size_t expected_size = sizeof(char) + sizeof(int) +
                           sizeof(double) + sizeof(char[10]);

    printf(&#34;expected offset of a: 0\n&#34;);
    printf(&#34;real offsetof a: %ld\n&#34;, offsetof(struct s, a));

    printf(&#34;expected offset of b: %ld\n&#34;, sizeof(char));
    printf(&#34;offsetof b: %ld\n&#34;, offsetof(struct s, b));

    printf(&#34;expected offset of c: %ld\n&#34;, sizeof(char) + sizeof(int));
    printf(&#34;offsetof c: %ld\n&#34;, offsetof(struct s, c));

    printf(&#34;expected offset of d: %ld\n&#34;, sizeof(char) + sizeof(int) + sizeof(double));
    printf(&#34;offsetof d: %ld\n&#34;, offsetof(struct s, d));

    printf(&#34;\n&#34;);

    printf(&#34;Expected struct size: %ld\n&#34;, expected_size);
    printf(&#34;Real struct size: %ld\n&#34;, sizeof(struct s));
}
</pre></div>


<p>First, we declare the struct that we also used at the beginning of this article. It contains a char variable, an integer variable, a double variable, and a char array of size 10.</p>



<p>We calculate the expected size of the struct by adding the values returned by sizeof for all of the types.</p>



<p>Then we print the offsets of all the members in the struct, followed by the expected size and the real size of the struct.</p>



<p>This program can be compiled with:</p>


<div><pre title="">$ gcc struct-align.c struct-align
</pre></div>


<p>On an x64 machine running Linux, this program gives the following output:</p>



<pre><code>expected offset of a: 0
real offsetof a: 0
expected offset of b: 1
offsetof b: 4
expected offset of c: 5
offsetof c: 8
expected offset of d: 13
offsetof d: 16

Expected struct size: 23
Real struct size: 32</code></pre>



<p>The offsets are bigger than we would expect if there were no gaps between the members. From this output, we can deduce that the memory layout of our structure looks like this:</p>



<figure><img data-attachment-id="1304" data-permalink="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/struct-intel-example-1/" data-orig-file="https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png" data-orig-size="1200,379" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="struct-intel-example-1" data-image-description="" data-image-caption="" data-medium-file="https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png?w=300" data-large-file="https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png?w=640" src="https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png?w=1024" alt="A real-world struct with padding" srcset="https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png?w=1024 1024w, https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png?w=150 150w, https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png?w=300 300w, https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png?w=768 768w, https://abstractexpr.files.wordpress.com/2023/06/struct-intel-example-1.png 1200w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>With clang, we can even make the compiler print us this padding information as warnings by compiling the program the <em>-wpadded</em> option:</p>


<div><pre title="">$ clang -Wpadded -o struct-align struct-align.c
</pre></div>


<p>This will yield the following warnings:</p>



<pre><code>struct-align.c:6:9: warning: padding struct &#39;struct s&#39; with 3 bytes to align &#39;b&#39; [-Wpadded]
    int b;
        ^
struct-align.c:4:8: warning: padding size of &#39;struct s&#39; with 6 bytes to alignment boundary [-Wpadded]
struct s {
       ^
2 warnings generated.
</code></pre>



<p>These warnings match up with the paddings we figured out on our own with the help of the <em>offset</em> macro. It is just much easier to let the compiler do the work for us which makes this especially useful if you have bigger structures in your program and wonder about their padding.</p>



<p>If you absolutely need a packed structure instead of what the compiler generates by default (e.g. because you want to map a file format or some hardware registers exposed in memory) you can use non-standard compiler extensions to force the compiler to create a structure without gaps.</p>



<p>With gcc and clang, you do this by using the packed attribute:</p>


<div><pre title="">struct s {
    char a;
    int b;
    double c;
    char d[10];
} __attribute__((packed));
</pre></div>


<p>If we compile and run the program again with this modified structure declaration the output looks like this:</p>



<pre><code>expected offset of a: 0
real offsetof a: 0
expected offset of b: 1
offsetof b: 1
expected offset of c: 5
offsetof c: 5
expected offset of d: 13
offsetof d: 13

Expected struct size: 23
Real struct size: 23</code></pre>



<p>As we can see from this output our structure is now laid out in memory without any gaps and padding. The size of the struct is equal to the sum of the sizes of all members.</p>



<p><strong>Don’t use this on all your structures from now on!</strong> Packed structures are a non-standard feature and they make your code run slower. On some architectures, they might even cause your program to crash. Depending on your architecture your compiler might have to create extra code to access the non-aligned members of your structure. If you pass around pointers to non-aligned members in your program not all compilers are smart enough to know that they need to generate this extra code when dereferencing those pointers and on some architectures (e.g. SPARC) this leads to a crash.</p>



<p>There are good reasons why normally the compiler adds padding to structures. The only good reason to use packed structures is when you need to map some memory (e.g. hardware registers exposed to memory) bit by bit to a structure.</p>



<h2>Bitfields</h2>



<p>Imagine you want to store eight flags in a structure. You could add 8 bool fields and be done with it:</p>


<div><pre title="">struct MyFlags {
    bool flag1;
    bool flag2;
    bool flag3;
    bool flag4;
    bool flag5;
    bool flag6;
    bool flag7;
    bool flag8;
};
</pre></div>


<p>But since each bool variable is one byte (8 bits) in size and a flag can be stored in a single bit you would waste 7 bytes because your flags could be stored in one single byte.</p>



<p>Thankfully, C supports so-called bitfields. Bitfields allow us to define fields of a certain data type but use only a freely defined number of bits. If we define more than one bitfield it is the compiler’s job to organize them in memory in a way that (hopefully) uses no more memory than necessary.</p>



<p>With bitfields can rewrite our flags example like this:</p>


<div><pre title="">struct MyFlags {
    bool flag1 : 1;
    bool flag2 : 1;
    bool flag3 : 1;
    bool flag4 : 1;
    bool flag5 : 1;
    bool flag6 : 1;
    bool flag7 : 1;
    bool flag8 : 1;
};
</pre></div>


<p>The “: 1” tells the compiler that each of our 8 bool fields should use only one bit. Therefore they fill exactly one byte and we store 8 bools in one bool variable. If we would declare less than 8 flags some bits would be unused. If we declared more than 8 the compiler would allocate enough additional bytes.</p>



<p>Don’t expect to save too much storage, though. Because of data alignment, the compiler will waste a lot of space anyway unless you hand-optimize the structure.</p>



<p>Of course, bit fields can’t only be used to save space when storing booleans.</p>



<p>For example, assume we would build an ancient terminal emulator and we would like to store a single character of 7-bit ASCII as well as its text and background color and some other simple text attributes in 32 bits of memory.</p>



<p>We could create a struct like this to achieve our goal:</p>


<div><pre title="">struct ScreenCharacter {
    unsigned int character : 7;
    unsigned int fgcolor : 11; // 2^11 =&gt; 2048 possible colors
    unsigned int bgcolor : 11; // 2^11 =&gt; 2048 possible colors
    unsigned int isBold : 1;
    unsigned int isItalic : 1;
    unsigned int isUnderline : 1;
};
</pre></div>


<p>Here we use 7 bits to store the ASCII character, 11 bits for the foreground and the background color each, and 3 bits in total to add attributes for bold, italic, and underline to our character.</p>



<p>Another use case for bitfields is to map hardware registers or file formats one by one. But this is a use case that should better be omitted because the memory organization of bit fields depends on the compiler and therefore such code will probably not be portable.</p>



<p>Most compilers try to pack bitfields as tightly as possible in memory but since they are quite implementation dependent when working with bitfields it is best to check for yourself how your compiler stores the data in the structure instead of relying on unproven assumptions.</p>



<p>Another thing to keep in mind is that – unlike with normal structure members – it is not possible to get the address of a bitfield member. So this code will not compile:</p>


<div><pre title="">struct ScreenCharacter ch;
printf(&#34;%p\n&#34;, &amp;ch.fgcolor);
</pre></div>


<p>The following data types can be used for bitfields in C99 (some compilers support additional data types):</p>



<ul>
<li>bool</li>



<li>unsigned int</li>



<li>signed int (int)</li>
</ul>



<h2>Flexible Array Members</h2>



<p>In C99 it is allowed to declare the last member of a structure as an array with no number of elements specified. The size of the struct will then be as if the last member did not exist.</p>



<p>This allows us to do something like this:</p>


<div><pre title="">struct DynamicString {
    int len;
    char str[];
};
</pre></div>


<p>We have a struct called DynamicString that can store the length of a string and it has a char array of unspecified length as its last member. When we want to allocate such a dynamic string we have to allocate enough bytes for the struct itself plus the bytes needed for the number of elements we want the array to have. The nice thing is that we can choose freely how many elements we want the array to have whenever we create a new instance of DynamicString:</p>


<div><pre title="">int n = 30;
DynamicString *str;

str = malloc(sizeof(struct DynamicString) + n * sizeof(char));
if (str == NULL) {
    fprintf(stderr, &#34;ERROR: Failed to allocate memory\n&#34;);
    exit(1);
}

str-&gt;len = n;
</pre></div>


<p>Now we have an array of chars that can take up to 29 characters plus the terminating null byte and knows its size. And we could create more such strings with all kinds of different sizes.</p>



<h2>Further Reading</h2>



<p>C: A Reference Manual (Fifth Edition), ISBN: 978-0130895929</p>



<p><a href="http://www.catb.org/esr/structure-packing/">The Lost Art of Structure Packing</a></p>
					</div><!-- .entry-content -->

		<!-- .entry-footer -->
	</div>
</article></div>
  </body>
</html>
