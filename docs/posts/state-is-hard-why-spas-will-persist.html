<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nolanlawson.com/2022/05/29/state-is-hard-why-spas-will-persist/">Original</a>
    <h1>State is hard: why SPAs will persist</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>When I write about web development, sometimes it feels like <a href="https://en.wikipedia.org/wiki/Blind_men_and_an_elephant">the parable of the blind men and the elephant</a>. I’m out here eagerly describing the trunk, someone else protests that no, it’s a tail, and meanwhile the person riding on its back is wondering what all the commotion is down there.</p>
<p>We’re all building so many different types of products using web technology – e-commerce sites, productivity apps, blogs, streaming sites, video games, hybrid mobile apps, dashboards on <a href="https://twitter.com/BenDelarre/status/1269384599609593856"><em>actual spaceships</em></a> – that it gets difficult to even have a shared vocabulary to describe what we’re doing. And each sub-discipline of web development is so deep that it’s easy to get tunnel-visioned and forget that other people are working with different tools and constraints.</p>
<p>This is what I like about blogging, though: it can help solve the problem of “feeling out the elephant.” I can offer my own perspective, even if flawed, and summon the human hive-mind to help describe the rest of the beast.</p>
<p>My last <a href="https://nolanlawson.com/2022/05/21/the-balance-has-shifted-away-from-spas/">two</a> <a href="https://nolanlawson.com/2022/05/25/more-thoughts-on-spas/">posts</a> have been a somewhat clumsy fumbling toward a new definition of SPAs (Single-Page Apps) and MPAs (Multi-Page Apps), and why you’d choose one versus the other when building a website. As it turns out, there is probably enough here to fill a book, but my goal is just to bring my own point of view (and bias) to the table and let others fill in the gaps with their comments and feedback.</p>
<p>I have a few main biases on this topic:</p>
<ol>
<li>I usually prize performance over ergonomics. I’ll go for the more performant solution, even if it’s awkward or unintuitive.</li>
<li>I like understanding how browsers work, and relying on the “browser-y” way of doing things rather than inventing my own prosthetic solution.</li>
<li>I don’t pay nearly enough attention to what’s happening in “user land” – I like to stay “close to the metal” and see the world from the browser’s perspective. Show me your compiled code, not your source code!</li>
</ol>
<p>In thinking about this topic and reading what others have written on it, one thing that struck me is that a big attraction for SPAs is the same thing that can cause so many problems: <em>state</em>. People who like SPAs often celebrate the fact than an SPA maintains state between navigations. For instance:</p>
<ol>
<li>You have a search input. You type into it, click somewhere else to navigate, and the next page still has the text in the input.</li>
<li>You have <a href="https://remix.run/docs/en/v1/pages/technical-explanation#browser-framework">a scrollable sidebar</a>. You scroll halfway down, click on something, and the next page still has the sidebar at the last scroll position.</li>
<li>You have <a href="https://youtu.be/TQQPAU21ZUw?t=1980">a list of expandable cards</a>. You expand one of them, click somewhere else, and the next page still has the one card expanded.</li>
</ol>
<p role="complementary">Note that these kinds of examples are particularly important for so-called <a href="https://remix.run/docs/en/v1/guides/routing#what-is-nested-routing">“nested routes”</a>, especially in complex desktop UIs. Think of sidebars, headers, and footers that maintain their state while the rest of the UI changes. I find it interesting that this is much less of an issue in mobile UIs, where it’s more common to change (nearly) the whole viewport on navigation.</p>
<p>Managing state is one of the hardest things about writing software. And in many ways, this aspect of state management is a great boon to SPAs. In particular, you don’t have to think about persisting state between navigations; it just happens automatically. In an MPA, you would have to serialize this state into some persistent format (LocalStorage, IndexedDB, etc.) when the page unloads, and then rehydrate on page load.</p>
<p>On the other hand, the fact that the state never gets blown away is exactly what leads to memory leaks – a problem endemic to SPAs that <a href="https://nolanlawson.com/2022/01/05/memory-leaks-the-forgotten-side-of-web-performance/">I’ve already documented <em>ad nauseam</em></a>. Plus, the further that the state can veer from a known good initial value, <a href="https://keunwoo.com/notes/rebooting/">the more likely you are to run into bugs</a>, which is why a misbehaving SPA often just needs a good refresh.</p>
<p>Interestingly, though, it’s not always the case that an MPA navigation lands on a fresh state. As mentioned in a previous post, the <a href="https://web.dev/bfcache/">back-forward cache</a> (now implemented in all browsers) makes this discussion more nuanced.</p>
<h2>Cache contents</h2>
<p>A quick refresher: in modern browsers, the back-forward cache (or BF cache for short) keeps a cache of the previous and next page when navigating between pages on the same origin. This vastly reduces load times when navigating back and forth through standard MPA pages.</p>
<p>But how exactly does this cache work? Even an MPA page can be very dynamic. What if the page has been dynamically modified, or the DOM state has changed, or the JavaScript state has changed? What does the browser actually cache?</p>
<p>To test this out, I wrote <a href="https://bl.ocks.org/nolanlawson/raw/4b4cfd5c2df125899752da1a7e59d481/">a simple test page</a>. On this page, you can set state in a variety of ways: DOM state, JavaScript heap state, scroll state. Then you can click a link to another page, press the back button, and see what the browser remembers.</p>
<p>As it turns out, the browser remembers a lot. I tested this in various browsers (Chrome/Firefox/Safari on desktop, Chrome/Firefox on Android, Safari on iOS), and saw the same result in all of them: the full page state is maintained after pressing the back button. Here is a video demonstration:</p>

<p>Note that the scroll positions on both the main document and the subscroller are preserved. More impressively, JavaScript state that isn’t even represented in the DOM (here, the number of times a button was clicked) is also preserved.</p>
<p>Now, to be clear: this doesn’t solve the problem of maintaining state in normal forward navigations. Everything I said above about MPAs needing to serialize their state would apply to any navigation that isn’t cached. Also, this behavior may vary subtly between browsers, and their heuristics <a href="https://web.dev/bfcache/#optimize-your-pages-for-bfcache">might not work</a> for your website. But it is impressive that the browser gives you so much out-of-the-box.</p>
<h2>Conclusion</h2>
<p>There are dozens of reasons to reach for an SPA technology, MPA technology, or some blend of the two. Everything depends on the needs and constraints of what you’re trying to build.</p>
<p>In these past few posts, I’ve tried to shed light on some interesting changes to MPAs that have happened under our very feet, while we might not have noticed. These changes are important, and may shift the calculus when trying to decide between an SPA or MPA architecture. To be fair, though, SPAs haven’t stopped moving either: experimental browser APIs like the <a href="https://wicg.github.io/navigation-api/">Navigation API</a> are even trying to solve <a href="https://github.com/WICG/navigation-api#customizations-and-consequences-of-navigation-interception">longstanding problems of focus and scroll management</a>. And of course, frameworks are still innovating on both SPAs and MPAs.</p>
<p>The fact that SPAs neatly simplify so many aspects of application development – keeping state in one place, on the main thread, persistent across navigations – is one of their greatest strengths as well as a predictable wellspring of problems. Performance and accessibility wonks can continue harping on the problems of SPAs, but at the end of the day, if developers find it easier to code an SPA than the equivalent MPA, then SPAs will continue to be built. Making MPAs more capable is only one way of solving the problem: approaching things from the other end – such as improved tooling, guidance, and education for SPA developers – can also work toward the same end goal.</p>
<p>As tempting as it may be to pronounce one set of tools as dead and another as ascendant, it’s important to remain humble and remember that everyone is working under a different set of constraints, and we all have a different take on web development. For that reason, I’ve come around to the conclusion that SPAs are not going anywhere anytime soon, and will probably remain a compelling development paradigm for as long as the web is around. Some developers will choose one perspective, some will choose another, and the big, beautiful elephant will continue lumbering forward.</p>
							</div></div>
  </body>
</html>
