<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ivankahl.com/decompiling-the-new-csharp-14-field-keyword/">Original</a>
    <h1>Decompiling the New C# 14 field Keyword</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>Properties in C# are a powerful tool for encapsulating data inside a class. They let you specify getter and setter logic that’s automatically applied when reading from or writing to the property. They’ve been supported since C# 1.0, which required manual backing fields for storage. <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history?ref=blog.ivankahl.com#c-version-30">C# 3.0 then introduced auto-implemented properties</a> to remove these boilerplate backing fields. However, it came with a trade-off: if you needed custom logic in your <code>get</code> or <code>set</code> method, you still had to use a manual backing field.</p><p>C# 14 introduces the new <code>field</code> keyword, which combines the flexibility of a manual backing field with the simplicity of an auto-implemented property. In the sections that follow, you&#39;ll see how the compiler handles this new keyword in practice. We&#39;ll also cover some important caveats to keep in mind as you start using it.</p><h2 id="a-brief-overview-of-the-field-keyword">A Brief Overview of the <code>field</code> Keyword</h2><p>Before C# 14, backing fields were necessary whenever a property needed logic beyond just retrieving and setting a field value. The snippet below demonstrates how a manual backing field is required for the <code>Email</code> property, since it cleans up the incoming value before storing it:</p><pre><code>public class User
{
    // Auto-property: simple getter and setter
    public string Name { get; set; }

    // Field-backed property: more complex getter and setter
    private string _email;
    public string Email
    {
        get =&gt; _email;
        set =&gt; _email = value.Trim().ToLower();
    }

    public User(string name, string email)
    {
        Name = name;
        Email = email;
    }
}</code></pre><p>Auto-implemented properties are convenient for simple scenarios, but as shown above, they fall short when you attempt to add custom logic. The new <code>field</code> keyword in C# 14 fills this gap. It lets you keep your code concise, while still allowing for custom logic in your property accessors.</p><p>The above snippet can be simplified in C# 14 as follows:</p>
<!--kg-card-begin: html-->
<pre><code>public class User
{
    public string Name { get; set; }

-   private string _email;
    public string Email
    {
-       get =&gt; _email;
+       get;
-       set =&gt; _email = value.Trim().ToLower();
+       set =&gt; field = value.Trim().ToLower();
    }

    public User(string name, string email)
    {
        Name = name;
        Email = email;
    }
}</code></pre>
<!--kg-card-end: html-->
<p>Notice how the manual backing field is no longer needed. But what actually happens behind the scenes? In the next section, we&#39;ll look at the disassembled <a href="https://learn.microsoft.com/en-us/dotnet/standard/managed-code?ref=blog.ivankahl.com">Intermediate Language (IL)</a> code to see exactly how the compiler handles the <code>field</code> keyword.</p><h2 id="inspecting-the-il-code">Inspecting the IL Code</h2><p>To demonstrate how the compiler handles different implementations of properties, we’ll use SharpLab to examine the following code snippet, which contains a standard auto-implemented property (<code>Name</code>), a manual backing field (<code>Email</code>), and the new C# 14 property implementation (<code>Username</code>):</p><pre><code>public class User
{
    // Auto-property: simple getter and setter
    public string Name { get; set; }

    // Field-backed property: more complex getter and setter
    private string _email;
    public string Email
    {
        get =&gt; _email;
        set =&gt; _email = value.Trim().ToLower();
    }

    // New C# 14 &#39;field&#39; property
    public string Username
    {
        get =&gt; field;
        set =&gt; field = value.Trim().ToLower();
    }
}</code></pre><p>You can view the compiler-generated code for this example on <a href="https://sharplab.io/?ref=blog.ivankahl.com#gist:236827e1bfe32760581d93a9906809bc">SharpLab</a>. When you examine the IL code, you&#39;ll see how a property using the <code>field</code> keyword is very similar to an auto-implemented property behind the scenes.</p><h3 id="identical-backing-fields">Identical Backing Fields</h3><p>When you use the <code>field</code> keyword, the compiler automatically creates a private backing field. This generated field is identical to what you&#39;d get with a standard auto-implemented property.</p><p>Here is the IL code for the standard auto-implemented property, <code>Name</code>:</p><pre><code>.field private string &#39;&lt;Name&gt;k__BackingField&#39;
.custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute...
.custom instance void [System.Runtime]System.Diagnostics.DebuggerBrowsableAttribute...</code></pre><p>And here’s the IL code for the C# 14 <code>field</code> property, <code>Username</code>:</p><pre><code>.field private string &#39;&lt;Username&gt;k__BackingField&#39;
.custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute...
.custom instance void [System.Runtime]System.Diagnostics.DebuggerBrowsableAttribute...</code></pre><p>In both cases, the compiler takes the same approach:</p><ol><li>It uses the same <code>&lt;Property&gt;k__BackingField</code> naming format for the underlying field name. The angle brackets make the name illegal in C# source code, preventing naming conflicts between user code and compiler-generated code.</li><li>It adds the <code>CompilerGenerated</code> attribute to mark the field as an artifact of the build process.</li><li>It adds the <code>DebuggerHidden</code> attribute to hide the field in the debug window.</li></ol><h3 id="the-getter-implementation">The Getter Implementation</h3><p>All three properties have simple <code>get</code> implementations that return the underlying field value. If you look at the IL code for each, you&#39;ll see they&#39;re essentially the same, except that the <code>Email</code> property uses the manual <code>_email</code> field, while the others use a compiler-generated field.</p><p>Here’s the <code>get</code> method for the <code>Email</code> property, which uses a manual backing field:</p><pre><code>.method public hidebysig specialname instance string get_Email () cil managed 
{
    // ...
    IL_0000: ldarg.0
    IL_0001: ldfld string User::_email
    IL_0006: ret
}</code></pre><p>And here’s the <code>get</code> method for the <code>Username</code> property, which uses the <code>field</code> keyword:</p><pre><code>.method public hidebysig specialname instance string get_Username () cil managed 
{
    // ...
    IL_0000: ldarg.0
    IL_0001: ldfld string User::&#39;&lt;Username&gt;k__BackingField&#39;
    IL_0006: ret
}</code></pre><p>Both sets of instructions do the same thing: they load the value from the backing field and return it. The only difference is which field is used to store the value.</p><h3 id="the-setter-implementation">The Setter Implementation</h3><p>How about the <code>set</code> method implementation? Both the <code>Username</code> and <code>Email</code> properties perform processing on the incoming value before storing it.</p><p>Here’s the IL code for setting the <code>Email</code> property, which uses a backing field:</p><pre><code>.method public hidebysig specialname instance void set_Email (string &#39;value&#39;) cil managed 
{
    // ...
    IL_0000: ldarg.0
    IL_0001: ldarg.1
    IL_0002: callvirt instance string [System.Runtime]System.String::Trim()
    IL_0007: callvirt instance string [System.Runtime]System.String::ToLower()
    IL_000c: stfld string User::_email
    IL_0011: ret
}</code></pre><p>Then, here’s the <code>set</code> method for the <code>Username</code> property:</p><pre><code>.method public hidebysig specialname instance void set_Username (string &#39;value&#39;) cil managed 
{
    // ...
    IL_0000: ldarg.0
    IL_0001: ldarg.1
    IL_0002: callvirt instance string [System.Runtime]System.String::Trim()
    IL_0007: callvirt instance string [System.Runtime]System.String::ToLower()
    IL_000c: stfld string User::&#39;&lt;Username&gt;k__BackingField&#39;
    IL_0011: ret
}</code></pre><p>In both code snippets:</p><ol><li>The method loads the current class instance onto the stack</li><li>It then loads the incoming <code>value</code> parameter on the stack</li><li>It performs the processing on the <code>value</code> parameter, in this case, trimming the string and converting it to lowercase</li><li>It updates the underlying field with the processed value.</li></ol><p>This shows that the <code>field</code> keyword is purely syntactic sugar. When you compile your code, it produces the same underlying IL code as manual and auto-implemented properties.</p><h2 id="potential-pitfalls-to-consider-when-refactoring-to-the-field-keyword">Potential Pitfalls to Consider When Refactoring to the <code>field</code> Keyword</h2><p>Before you start refactoring your codebase to use the new keyword, there are a few important caveats to keep in mind. While the underlying IL code is essentially the same, how your code accesses the backing field can affect your application in subtle ways.</p><h3 id="magic-strings-and-reflection-will-break">Magic Strings and Reflection Will Break</h3><p>If you use reflection to access private members, removing manual backing fields in favour of compiler-generated fields will break reflection. This is because the underlying field name changes. As shown above, the compiler uses a mangled naming convention, such as <code>&lt;Property&gt;k__BackingField</code>, for compiler-generated fields. If your code, or libraries you use, rely on finding a specific private field by name via reflection, it will crash at runtime when you refactor your code.</p><p>The sections below highlight two common scenarios where reflection might cause issues: <a href="https://learn.microsoft.com/en-us/ef/core/?ref=blog.ivankahl.com">Entity Framework Core</a> and <a href="https://docs.automapper.io/en/stable/?ref=blog.ivankahl.com">AutoMapper</a>.</p><h4 id="entity-framework-core">Entity Framework Core</h4><p>EF Core supports writing to private fields in a class using reflection so that you can bypass logic in your property’s <code>set</code> method when hydrating the entity. </p><p>For example, say you refactor your EF Core model class by utilizing the <code>field</code> keyword:</p>
<!--kg-card-begin: html-->
<pre><code>public class OrderLineItem
{
-   private int _quantity;

    // …
    public int Quantity
    {
-       get =&gt; _quantity;
+       get;
        set
        {
            ArgumentOutOfRangeException.ThrowIfNegativeOrZero(value);
-           _quantity = value;
+           field = value;
        }
    }
}</code></pre>
<!--kg-card-end: html-->
<p>If your EF Core configuration class references the field by name, it will fail since the field doesn’t exist anymore with that name:</p><pre><code>public class OrderLineItemConfiguration : IEntityTypeConfiguration&lt;OrderLineItem&gt;
{
    public void Configure(EntityTypeBuilder&lt;OrderLineItem&gt; builder)
    {
        // …
        
        builder.Property(p =&gt; p.Quantity)
            .HasColumnName(&#34;quantity&#34;)
            .HasField(&#34;_quantity&#34;);

        // ...
    }
}</code></pre><p>Here’s an example of the exception you can expect to see in this scenario, which reports that EF Core cannot find the underlying field for the property.</p><pre><code>System.InvalidOperationException: The specified field &#39;_quantity&#39; could not be found for property &#39;OrderLineItem.Quantity&#39;.
   at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase.GetFieldInfo(String fieldName, TypeBase type, String propertyName, Boolean shouldThrow)
   at Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.CanSetField(String fieldName, Nullable`1 configurationSource)
   at Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.HasField(String fieldName, ConfigurationSource configurationSource)
   at Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder.HasField(String fieldName, ConfigurationSource configurationSource)
   at Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder.HasField(String fieldName)
   at Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasField(String fieldName)
   at EfCoreFields.OrderLineItemConfiguration.Configure(EntityTypeBuilder`1 builder) in C:\Code\EfCoreFields\EfCoreFields\OrderLineItemConfiguration.cs:line 16
   at Microsoft.EntityFrameworkCore.ModelBuilder.ApplyConfiguration[TEntity](IEntityTypeConfiguration`1 configuration)
   at InvokeStub_ModelBuilder.ApplyConfiguration(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)</code></pre><p>This error only appears at runtime and not build time, so you’ll have to carefully update your EF Core entity configuration files as you refactor your model classes. </p><p>Fortunately, fixing your EF Core configuration classes is straightforward. Instead of looking for the backing field by name, you instruct it always to access the property using its underlying backing field with the <code>UsePropertyAccessMode</code> method:</p>
<!--kg-card-begin: html-->
<pre><code>public class OrderLineItemConfiguration : IEntityTypeConfiguration&lt;OrderLineItem&gt;
{
    public void Configure(EntityTypeBuilder&lt;OrderLineItem&gt; builder)
    {
        // …
        
        builder.Property(p =&gt; p.Quantity)
            .HasColumnName(&#34;quantity&#34;)
-           .HasField(&#34;_quantity&#34;);
+           .UsePropertyAccessMode(PropertyAccessMode.Field);

        // ...
    }
}</code></pre>
<!--kg-card-end: html-->
<p>This approach avoids hardcoding a field name. By removing <code>HasField</code>, EF Core reverts to its default conventions, which are <a href="https://github.com/dotnet/efcore/blob/212dcc048b6031e13fbb7032a409310d93b27a0f/src/EFCore/Metadata/Conventions/BackingFieldConvention.cs?ref=blog.ivankahl.com#L164">capable of locating the compiler-generated backing field</a>. The <code>UsePropertyAccessMode</code> method then ensures EF Core uses the located field rather than the property.</p><h4 id="automapper">AutoMapper</h4><p>A similar issue exists when using object mappers that rely on reflection, such as AutoMapper. For example, consider the following class, which has been refactored to use the <code>field</code> keyword:</p>
<!--kg-card-begin: html-->
<pre><code>public class Product : AuditableEntity
{
-   private decimal _price;
    
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price
    {
-       get =&gt; _price;
+       get;
        set
        {
            AuditPropertyChanged(&#34;Price&#34;, field, value);
-           _price = value;
+           field = value;
        }
    }
}</code></pre>
<!--kg-card-end: html-->
<p>It’s possible that your AutoMapper <code>Profile</code> class still refers to the old field by name, which will cause issues:</p><pre><code>public class ProductProfile : Profile
{
    public ProductProfile()
    {
        ShouldMapField = fi =&gt; !fi.IsDefined(typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute));
        
        CreateMap&lt;CreateProductDto, Product&gt;()
            // Hard-coded field name in the string below
            .ForMember(&#34;_price&#34;, opt =&gt; opt.MapFrom(src =&gt; src.Price))
            .ForMember(dest =&gt; dest.Name, opt =&gt; opt.MapFrom(src =&gt; src.Name));
    }
}</code></pre><p>Whenever you try to map objects or validate your configuration, you’ll run into an exception similar to this:</p><pre><code>System.ArgumentOutOfRangeException: Cannot find member _price of type AutoMapperFields.Product. (Parameter &#39;name&#39;)
   at AutoMapper.Internal.TypeExtensions.GetFieldOrProperty(Type type, String name)
   at AutoMapper.Configuration.MappingExpression`2.ForMember(String name, Action`1 memberOptions)
   at AutoMapperFields.ProductProfile..ctor() in C:\Code\AutoMapperFields\ProductProfile.cs:line 12
   at System.RuntimeType.CreateInstanceDefaultCtor(Boolean publicOnly, Boolean wrapExceptions)</code></pre><p>The best solution I’ve found for finding reflection-based mapping issues is to assert your mappings at application startup. That way, you can find invalid mapping configurations as soon as your application starts, rather than when the actual mapping occurs.</p><pre><code>var app = builder.Build();

// …

app.Services.GetRequiredService&lt;IMapper&gt;().ConfigurationProvider.AssertConfigurationIsValid();

// …

await app.RunAsync();</code></pre><p>If you want to avoid this issue altogether, consider using a <a href="https://blog.ivankahl.com/introduction-to-mapster-in-csharp/">source generator library like Mapster</a>. That way, mapping issues can be caught at build time rather than at runtime.</p><p>Be cautious when using magic strings and reflection. These patterns can make your codebase fragile and more likely to break during refactoring, such as switching to using the <code>field</code> keyword. </p><h3 id="the-field-keyword-is-restricted-to-the-property">The <code>field</code> Keyword Is Restricted to the Property</h3><p>When you declare a <code>private</code> backing field, that variable is available throughout the class. The <code>field</code> keyword, on the other hand, is only available inside the property&#39;s accessor methods.</p><p>This can cause issues if you have methods that need to directly manipulate the underlying field value. For example, take a look at the <code>Reset</code> method in the class below:</p><pre><code>public class Counter
{
    private int _count;

    public int Count
    {
        get =&gt; _count;
        set
        {
            ArgumentOutOfRangeException.ThrowIfNegative(value);
            _count = value;
        }
    }

    public void Reset()
    {
        _count = 0;
    }
}</code></pre><p>When you refactor the class to use the <code>field</code> keyword, you’ll run into the following error if you try set the underlying field value in a method:</p><figure><img src="https://blog.ivankahl.com/content/images/2025/12/image.png" alt="" loading="lazy" width="982" height="526"/><figcaption><span>Screenshot showing how the field keyword cannot be resolved outside property accessors.</span></figcaption></figure><p>The only way to fix this is to use the <code>set</code> method on the property as well:</p>
<!--kg-card-begin: html-->
<pre><code>public class Counter
{
-   private int _count;
-    
    public int Count
    {
-       get =&gt; _count;
+       get;
        set
        {
            ArgumentOutOfRangeException.ThrowIfNegative(value);
-           _count = value;
+           field = value;
        }
    }

    public void Reset()
    {
-       _count = 0;
+       Count = 0;
    }
}</code></pre>
<!--kg-card-end: html-->
<p>In general, this is considered best practice, since it ensures your value is always validated before being stored. But what if your <code>set</code> method has side effects you want to avoid in certain cases?</p><p>For example, the following class raises an event every time the <code>FirstName</code> or <code>LastName</code> properties are updated:</p><pre><code>public class Customer
{
    private string _firstName;
    private string _lastName;

    public string FirstName
    {
        get =&gt; _firstName;
        set
        {
            _firstName = value;
            RaiseEvent(new FirstNameUpdated(Id, _firstName));
        }
    }

    public string LastName
    {
        get =&gt; _lastName;
        set
        {
            _lastName = value;
            RaiseEvent(new LastNameUpdated(Id, _lastName));
        }
    }

    public void Anonymize()
    {
        _firstName = &#34;ANONYMIZED&#34;;
        _lastName = &#34;ANONYMIZED&#34;;
        RaiseEvent(new CustomerAnonymized(Id));
    }
}</code></pre><p>If you need to set the first and last name values without triggering side effects in the <code>set</code> method, for example, from an <code>Anonymize</code> method, then you&#39;ll need to stick with manual backing fields.</p><h3 id="targeting-fields-with-attributes">Targeting Fields with Attributes</h3><p>If you previously applied attributes to your private backing fields, you need to use slightly different syntax when using auto-implemented and <code>field</code> properties. Consider the following code sample, which applies a custom <code>[WatchField]</code> attribute to the backing field.</p><pre><code>public class Order
{
    [WatchField]
    private string _deliveryAddress;

    public string DeliveryAddress
    {
        get =&gt; _deliveryAddress;
        set
        {
            ValidateDeliveryAddress(value);
            _deliveryAddress = value;
        }
    }
    
    private void ValidateDeliveryAddress(string address)
    {
        // Validation logic throws exception if invalid.
    }
}</code></pre><p>When you refactor the property, you have to use the <code>field:</code> prefix so that the attribute targets the underlying field rather than the property:</p>
<!--kg-card-begin: html-->
<pre data-line="3" tabindex="0"><code>public class Order
{
    [field: WatchField]
    public string DeliveryAddress
    {
        get;
        set
        {
            ValidateDeliveryAddress(value);
            field = value;
        }
    }
    
    private void ValidateDeliveryAddress(string address)
    {
        // Validation logic throws exception if invalid.
    }
}</code></pre>
<!--kg-card-end: html-->
<p>Notice how the attribute is applied directly to the compiler-generated backing field in the compiled code:</p>
<!--kg-card-begin: html-->
<pre data-line="5" tabindex="0"><code>public class Order
{
    [CompilerGenerated]
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    [WatchField]
    private string <deliveryaddress>k__BackingField;

    // ...
}</deliveryaddress></code></pre>
<!--kg-card-end: html-->
<h3 id="naming-conflicts-with-existing-class-members">Naming Conflicts with Existing Class Members</h3><p>The <code>field</code> keyword hasn’t always been a <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/?ref=blog.ivankahl.com#contextual-keywords">contextual keyword</a>, and you could use it as an identifier in previous versions of C#. For example, the following code compiles in C# 13 and earlier:</p><pre><code>class ResearchProject(string field)
{
    private string field = field;
    
    public string Field
    {
        get =&gt; field;
        set =&gt; field = value ?? throw new ArgumentNullException(nameof(value));
    }
}</code></pre><p>In the snippet above, the <code>field</code> variable used within the <code>Field</code> accessor methods references the private field defined immediately above.</p><p>However, when updating your project to use C# 14, you’ll run into the following warning, indicating that using the <code>field</code> keyword inside the accessor will reference a compiler-generated field rather than the existing `field` member.</p><figure><img src="https://blog.ivankahl.com/content/images/2025/12/image-1.png" alt="" loading="lazy" width="1130" height="301"/><figcaption><span>Screenshot showing a compiler warning that’s shown when you have a private member field called field.</span></figcaption></figure><p>To fix this, you can refer to the existing <code>field</code> member using <code>this.field</code> or <code>@field</code>:</p>
<!--kg-card-begin: html-->
<pre><code>class ResearchProject(string field)
{
    private string field = field;
    
    public string Field
    {
        // Example of using the `this.` syntax to refer to the backing field
-       get =&gt; field;
+       get =&gt; this.field;
        // Example of using the `@` prefix to avoid naming conflicts
-       set =&gt; field = value ?? throw new ArgumentNullException(nameof(value));
+       set =&gt; @field = value ?? throw new ArgumentNullException(nameof(value));
    }
}</code></pre>
<!--kg-card-end: html-->
<h2 id="conclusion">Conclusion</h2><p>The <code>field</code> keyword in C# 14 helps you avoid unnecessary boilerplate by removing the need for explicit <code>private</code> backing fields. It lets you use auto-implemented properties even when you need custom logic. </p><p>As we inspected the generated IL code, it became clear that the keyword is syntactic sugar. The compiler still generates the same backing field and connects it to your property accessors. However, the abstraction does come with trade-offs, which we unpacked in the second half of the article.</p><p>This new feature moves C# toward less verbose code by making auto-implemented properties more flexible. Most codebases will benefit from adopting it. Just remember the caveats, especially if you&#39;re working with legacy code or reflection-based libraries. Proceed with caution, and ensure you have good test coverage to catch any issues during refactoring.</p>
    </div></div>
  </body>
</html>
