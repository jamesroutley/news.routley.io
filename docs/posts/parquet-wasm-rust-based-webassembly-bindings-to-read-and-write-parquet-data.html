<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/kylebarron/parquet-wasm">Original</a>
    <h1>Parquet-WASM: Rust-based WebAssembly bindings to read and write Parquet data</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">WebAssembly bindings to read and write the <a href="https://parquet.apache.org/" rel="nofollow">Apache Parquet</a> format to and from <a href="https://arrow.apache.org/" rel="nofollow">Apache Arrow</a> using the Rust <a href="https://crates.io/crates/parquet" rel="nofollow"><code>parquet</code></a> and <a href="https://crates.io/crates/arrow" rel="nofollow"><code>arrow</code></a> crates.</p>
<p dir="auto">This is designed to be used alongside a JavaScript Arrow implementation, such as the canonical <a href="https://arrow.apache.org/docs/js/" rel="nofollow">JS Arrow library</a>.</p>
<p dir="auto">Including read and write support and all compression codecs, the brotli-compressed WASM bundle is 1.2 MB. Refer to <a href="#custom-builds">custom builds</a> for how to build a smaller bundle. A minimal read-only bundle without compression support can be as small as 456 KB brotli-compressed.</p>

<p dir="auto"><code>parquet-wasm</code> is published to NPM. Install with</p>

<p dir="auto">or</p>


<p dir="auto">Parquet-wasm has both a synchronous and asynchronous API. The sync API is simpler but requires fetching the entire Parquet buffer in advance, which is often prohibitive.</p>

<p dir="auto">Refer to these functions:</p>
<ul dir="auto">
<li><a href="https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.readParquet.html" rel="nofollow"><code>readParquet</code></a>: Read a Parquet file synchronously.</li>
<li><a href="https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.readSchema.html" rel="nofollow"><code>readSchema</code></a>: Read an Arrow schema from a Parquet file synchronously.</li>
<li><a href="https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.writeParquet.html" rel="nofollow"><code>writeParquet</code></a>: Write a Parquet file synchronously.</li>
</ul>

<ul dir="auto">
<li><a href="https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.readParquetStream.html" rel="nofollow"><code>readParquetStream</code></a>: Create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" rel="nofollow">ReadableStream</a> that emits Arrow RecordBatches from a Parquet file.</li>
<li><a href="https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html" rel="nofollow"><code>ParquetFile</code></a>: A class for reading portions of a remote Parquet file. Use <a href="https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html#fromUrl" rel="nofollow"><code>fromUrl</code></a> to construct from a remote URL or <a href="https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html#fromFile" rel="nofollow"><code>fromFile</code></a> to construct from a <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="nofollow"><code>File</code></a> handle. Note that when you&#39;re done using this class, you&#39;ll need to call <a href="https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html#free" rel="nofollow"><code>free</code></a> to release any memory held by the ParquetFile instance itself.</li>
</ul>
<p dir="auto">Both sync and async functions return or accept a <a href="https://kylebarron.dev/parquet-wasm/classes/bundler_parquet_wasm.Table.html" rel="nofollow"><code>Table</code></a> class, an Arrow table in WebAssembly memory. Refer to its documentation for moving data into/out of WebAssembly.</p>

<table>
<thead>
<tr>
<th>Entry point</th>
<th>Description</th>
<th>Documentation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>parquet-wasm</code>, <code>parquet-wasm/esm</code>, or <code>parquet-wasm/esm/parquet_wasm.js</code></td>
<td>ESM, to be used directly from the Web as an ES Module</td>
<td><a href="https://kylebarron.dev/parquet-wasm/modules/esm_parquet_wasm.html" rel="nofollow">Link</a></td>
</tr>
<tr>
<td><code>parquet-wasm/bundler</code></td>
<td>&#34;Bundler&#34; build, to be used in bundlers such as Webpack</td>
<td><a href="https://kylebarron.dev/parquet-wasm/modules/bundler_parquet_wasm.html" rel="nofollow">Link</a></td>
</tr>
<tr>
<td><code>parquet-wasm/node</code></td>
<td>Node build, to be used with synchronous <code>require</code> in NodeJS</td>
<td><a href="https://kylebarron.dev/parquet-wasm/modules/node_parquet_wasm.html" rel="nofollow">Link</a></td>
</tr>
</tbody>
</table>

<p dir="auto">The <code>esm</code> entry point is the primary entry point. It is the default export from <code>parquet-wasm</code>, and is also accessible at <code>parquet-wasm/esm</code> and <code>parquet-wasm/esm/parquet_wasm.js</code> (for symmetric imports <a href="#using-directly-from-a-browser">directly from a browser</a>).</p>
<p dir="auto"><strong>Note that when using the <code>esm</code> bundles, you must manually initialize the WebAssembly module before using any APIs</strong>. Otherwise, you&#39;ll get an error <code>TypeError: Cannot read properties of undefined</code>. There are multiple ways to initialize the WebAssembly code:</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Asynchronous initialization</h4><a id="user-content-asynchronous-initialization" aria-label="Permalink: Asynchronous initialization" href="#asynchronous-initialization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The primary way to initialize is by awaiting the default export.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import wasmInit, {readParquet} from &#34;parquet-wasm&#34;;

await wasmInit();"><pre><span>import</span> <span>wasmInit</span><span>,</span> <span>{</span><span>readParquet</span><span>}</span> <span>from</span> <span>&#34;parquet-wasm&#34;</span><span>;</span>

<span>await</span> <span>wasmInit</span><span>(</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Without any parameter, this will try to fetch a file named <code>&#39;parquet_wasm_bg.wasm&#39;</code> at the same location as <code>parquet-wasm</code>. (E.g. this snippet <code>input = new URL(&#39;parquet_wasm_bg.wasm&#39;, import.meta.url);</code>).</p>
<p dir="auto">Note that you can also pass in a custom URL if you want to host the <code>.wasm</code> file on your own servers.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import wasmInit, {readParquet} from &#34;parquet-wasm&#34;;

// Update this version to match the version you&#39;re using.
const wasmUrl = &#34;https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.0/esm/parquet_wasm_bg.wasm&#34;;
await wasmInit(wasmUrl);"><pre><span>import</span> <span>wasmInit</span><span>,</span> <span>{</span><span>readParquet</span><span>}</span> <span>from</span> <span>&#34;parquet-wasm&#34;</span><span>;</span>

<span>// Update this version to match the version you&#39;re using.</span>
<span>const</span> <span>wasmUrl</span> <span>=</span> <span>&#34;https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.0/esm/parquet_wasm_bg.wasm&#34;</span><span>;</span>
<span>await</span> <span>wasmInit</span><span>(</span><span>wasmUrl</span><span>)</span><span>;</span></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Synchronous initialization</h4><a id="user-content-synchronous-initialization" aria-label="Permalink: Synchronous initialization" href="#synchronous-initialization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>initSync</code> named export allows for</p>
<div dir="auto" data-snippet-clipboard-copy-content="import {initSync, readParquet} from &#34;parquet-wasm&#34;;

// The contents of esm/parquet_wasm_bg.wasm in an ArrayBuffer
const wasmBuffer = new ArrayBuffer(...);

// Initialize the Wasm synchronously
initSync(wasmBuffer)"><pre><span>import</span> <span>{</span><span>initSync</span><span>,</span> <span>readParquet</span><span>}</span> <span>from</span> <span>&#34;parquet-wasm&#34;</span><span>;</span>

<span>// The contents of esm/parquet_wasm_bg.wasm in an ArrayBuffer</span>
<span>const</span> <span>wasmBuffer</span> <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span>...<span>)</span><span>;</span>

<span>// Initialize the Wasm synchronously</span>
<span>initSync</span><span>(</span><span>wasmBuffer</span><span>)</span></pre></div>
<p dir="auto">Async initialization should be preferred over downloading the Wasm buffer and then initializing it synchronously, as <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming_static" rel="nofollow"><code>WebAssembly.instantiateStreaming</code></a> is the most efficient way to both download and initialize Wasm code.</p>

<p dir="auto">The <code>bundler</code> entry point doesn&#39;t require manual initialization of the WebAssembly blob, but needs setup with whatever bundler you&#39;re using. <a href="https://rustwasm.github.io/docs/wasm-bindgen/reference/deployment.html#bundlers" rel="nofollow">Refer to the Rust Wasm documentation for more info</a>.</p>

<p dir="auto">The <code>node</code> entry point can be loaded synchronously from Node.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const {readParquet} = require(&#34;parquet-wasm&#34;);

const wasmTable = readParquet(...);"><pre><span>const</span> <span>{</span>readParquet<span>}</span> <span>=</span> <span>require</span><span>(</span><span>&#34;parquet-wasm&#34;</span><span>)</span><span>;</span>

<span>const</span> <span>wasmTable</span> <span>=</span> <span>readParquet</span><span>(</span>...<span>)</span><span>;</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Using directly from a browser</h3><a id="user-content-using-directly-from-a-browser" aria-label="Permalink: Using directly from a browser" href="#using-directly-from-a-browser"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can load the <code>esm/parquet_wasm.js</code> file directly from a CDN</p>
<div dir="auto" data-snippet-clipboard-copy-content="const parquet = await import(
  &#34;https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.0/esm/parquet_wasm.js&#34;
)
await parquet.default();

const wasmTable = parquet.readParquet(...);"><pre><span>const</span> <span>parquet</span> <span>=</span> <span>await</span> <span>import</span><span>(</span>
  <span>&#34;https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.0/esm/parquet_wasm.js&#34;</span>
<span>)</span>
<span>await</span> <span>parquet</span><span>.</span><span>default</span><span>(</span><span>)</span><span>;</span>

<span>const</span> <span>wasmTable</span> <span>=</span> <span>parquet</span><span>.</span><span>readParquet</span><span>(</span>...<span>)</span><span>;</span></pre></div>

<p dir="auto">These functions are not present in normal builds to cut down on bundle size. To create a custom build, see <a href="#custom-builds">Custom Builds</a> below.</p>

<p dir="auto"><code>setPanicHook(): void</code></p>
<p dir="auto">Sets <a href="https://github.com/rustwasm/console_error_panic_hook"><code>console_error_panic_hook</code></a> in Rust, which provides better debugging of panics by having more informative <code>console.error</code> messages. Initialize this first if you&#39;re getting errors such as <code>RuntimeError: Unreachable executed</code>.</p>
<p dir="auto">The WASM bundle must be compiled with the <code>console_error_panic_hook</code> feature for this function to exist.</p>

<div dir="auto" data-snippet-clipboard-copy-content="import * as arrow from &#34;apache-arrow&#34;;
import initWasm, {
  Compression,
  readParquet,
  Table,
  writeParquet,
  WriterPropertiesBuilder,
} from &#34;parquet-wasm&#34;;

// Instantiate the WebAssembly context
await initWasm();

// Create Arrow Table in JS
const LENGTH = 2000;
const rainAmounts = Float32Array.from({ length: LENGTH }, () =&gt;
  Number((Math.random() * 20).toFixed(1))
);

const rainDates = Array.from(
  { length: LENGTH },
  (_, i) =&gt; new Date(Date.now() - 1000 * 60 * 60 * 24 * i)
);

const rainfall = arrow.tableFromArrays({
  precipitation: rainAmounts,
  date: rainDates,
});

// Write Arrow Table to Parquet

// wasmTable is an Arrow table in WebAssembly memory
const wasmTable = Table.fromIPCStream(arrow.tableToIPC(rainfall, &#34;stream&#34;));
const writerProperties = new WriterPropertiesBuilder()
  .setCompression(Compression.ZSTD)
  .build();
const parquetUint8Array = writeParquet(wasmTable, writerProperties);

// Read Parquet buffer back to Arrow Table
// arrowWasmTable is an Arrow table in WebAssembly memory
const arrowWasmTable = readParquet(parquetUint8Array);

// table is now an Arrow table in JS memory
const table = arrow.tableFromIPC(arrowWasmTable.intoIPCStream());
console.log(table.schema.toString());
// Schema&lt;{ 0: precipitation: Float32, 1: date: Date64&lt;MILLISECOND&gt; }&gt;"><pre><span>import</span> <span>*</span> <span>as</span> <span>arrow</span> <span>from</span> <span>&#34;apache-arrow&#34;</span><span>;</span>
<span>import</span> <span>initWasm</span><span>,</span> <span>{</span>
  <span>Compression</span><span>,</span>
  <span>readParquet</span><span>,</span>
  <span>Table</span><span>,</span>
  <span>writeParquet</span><span>,</span>
  <span>WriterPropertiesBuilder</span><span>,</span>
<span>}</span> <span>from</span> <span>&#34;parquet-wasm&#34;</span><span>;</span>

<span>// Instantiate the WebAssembly context</span>
<span>await</span> <span>initWasm</span><span>(</span><span>)</span><span>;</span>

<span>// Create Arrow Table in JS</span>
<span>const</span> <span>LENGTH</span> <span>=</span> <span>2000</span><span>;</span>
<span>const</span> <span>rainAmounts</span> <span>=</span> <span>Float32Array</span><span>.</span><span>from</span><span>(</span><span>{</span> <span>length</span>: <span>LENGTH</span> <span>}</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span>
  <span>Number</span><span>(</span><span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>20</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span><span>)</span>
<span>)</span><span>;</span>

<span>const</span> <span>rainDates</span> <span>=</span> <span>Array</span><span>.</span><span>from</span><span>(</span>
  <span>{</span> <span>length</span>: <span>LENGTH</span> <span>}</span><span>,</span>
  <span>(</span><span>_</span><span>,</span> <span>i</span><span>)</span> <span>=&gt;</span> <span>new</span> <span>Date</span><span>(</span><span>Date</span><span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> <span>1000</span> <span>*</span> <span>60</span> <span>*</span> <span>60</span> <span>*</span> <span>24</span> <span>*</span> <span>i</span><span>)</span>
<span>)</span><span>;</span>

<span>const</span> <span>rainfall</span> <span>=</span> <span>arrow</span><span>.</span><span>tableFromArrays</span><span>(</span><span>{</span>
  <span>precipitation</span>: <span>rainAmounts</span><span>,</span>
  <span>date</span>: <span>rainDates</span><span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>// Write Arrow Table to Parquet</span>

<span>// wasmTable is an Arrow table in WebAssembly memory</span>
<span>const</span> <span>wasmTable</span> <span>=</span> <span>Table</span><span>.</span><span>fromIPCStream</span><span>(</span><span>arrow</span><span>.</span><span>tableToIPC</span><span>(</span><span>rainfall</span><span>,</span> <span>&#34;stream&#34;</span><span>)</span><span>)</span><span>;</span>
<span>const</span> <span>writerProperties</span> <span>=</span> <span>new</span> <span>WriterPropertiesBuilder</span><span>(</span><span>)</span>
  <span>.</span><span>setCompression</span><span>(</span><span>Compression</span><span>.</span><span>ZSTD</span><span>)</span>
  <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>const</span> <span>parquetUint8Array</span> <span>=</span> <span>writeParquet</span><span>(</span><span>wasmTable</span><span>,</span> <span>writerProperties</span><span>)</span><span>;</span>

<span>// Read Parquet buffer back to Arrow Table</span>
<span>// arrowWasmTable is an Arrow table in WebAssembly memory</span>
<span>const</span> <span>arrowWasmTable</span> <span>=</span> <span>readParquet</span><span>(</span><span>parquetUint8Array</span><span>)</span><span>;</span>

<span>// table is now an Arrow table in JS memory</span>
<span>const</span> <span>table</span> <span>=</span> <span>arrow</span><span>.</span><span>tableFromIPC</span><span>(</span><span>arrowWasmTable</span><span>.</span><span>intoIPCStream</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>table</span><span>.</span><span>schema</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// Schema&lt;{ 0: precipitation: Float32, 1: date: Date64&lt;MILLISECOND&gt; }&gt;</span></pre></div>

<p dir="auto">(These may use older versions of the library with a different API).</p>
<ul dir="auto">
<li><a href="https://observablehq.com/@kylebarron/geoparquet-on-the-web" rel="nofollow">GeoParquet on the Web (Observable)</a></li>
<li><a href="https://observablehq.com/@bmschmidt/hello-parquet-wasm" rel="nofollow">Hello, Parquet-WASM (Observable)</a></li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Performance considerations</h2><a id="user-content-performance-considerations" aria-label="Permalink: Performance considerations" href="#performance-considerations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Tl;dr: When you have a <code>Table</code> object (resulting from <code>readParquet</code>), try the new
<a href="https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.Table.html#intoFFI" rel="nofollow"><code>Table.intoFFI</code></a>
API to move it to JavaScript memory. This API is less well tested than the <a href="https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.Table.html#intoIPCStream" rel="nofollow"><code>Table.intoIPCStream</code></a> API, but should be
faster and have <strong>much</strong> less memory overhead (by a factor of 2). If you hit any bugs, please
<a href="https://github.com/kylebarron/parquet-wasm/issues/new">create a reproducible issue</a>.</p>
<p dir="auto">Under the hood, <code>parquet-wasm</code> first decodes a Parquet file into Arrow <em>in WebAssembly memory</em>. But
then that WebAssembly memory needs to be copied into JavaScript for use by Arrow JS. The &#34;normal&#34;
conversion APIs (e.g. <code>Table.intoIPCStream</code>) use the <a href="https://arrow.apache.org/docs/python/ipc.html" rel="nofollow">Arrow IPC
format</a> to get the data back to JavaScript. But this
requires another memory copy <em>inside WebAssembly</em> to assemble the various arrays into a single
buffer to be copied back to JS.</p>
<p dir="auto">Instead, the new <code>Table.intoFFI</code> API uses Arrow&#39;s <a href="https://arrow.apache.org/docs/format/CDataInterface.html" rel="nofollow">C Data
Interface</a> to be able to copy or view
Arrow arrays from within WebAssembly memory without any serialization.</p>
<p dir="auto">Note that this approach uses the <a href="https://github.com/kylebarron/arrow-js-ffi"><code>arrow-js-ffi</code></a>
library to parse the Arrow C Data Interface definitions. This library has not yet been tested in
production, so it may have bugs!</p>
<p dir="auto">I wrote an <a href="https://observablehq.com/@kylebarron/zero-copy-apache-arrow-with-webassembly" rel="nofollow">interactive blog
post</a> on this approach
and the Arrow C Data Interface if you want to read more!</p>

<div dir="auto" data-snippet-clipboard-copy-content="import * as arrow from &#34;apache-arrow&#34;;
import { parseTable } from &#34;arrow-js-ffi&#34;;
import initWasm, { wasmMemory, readParquet } from &#34;parquet-wasm&#34;;

// Instantiate the WebAssembly context
await initWasm();

// A reference to the WebAssembly memory object.
const WASM_MEMORY = wasmMemory();

const resp = await fetch(&#34;https://example.com/file.parquet&#34;);
const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());
const wasmArrowTable = readParquet(parquetUint8Array).intoFFI();

// Arrow JS table that was directly copied from Wasm memory
const table: arrow.Table = parseTable(
  WASM_MEMORY.buffer,
  wasmArrowTable.arrayAddrs(),
  wasmArrowTable.schemaAddr()
);

// VERY IMPORTANT! You must call `drop` on the Wasm table object when you&#39;re done using it
// to release the Wasm memory.
// Note that any access to the pointers in this table is undefined behavior after this call.
// Calling any `wasmArrowTable` method will error.
wasmArrowTable.drop();"><pre><span>import</span> <span>*</span> <span>as</span> <span>arrow</span> <span>from</span> <span>&#34;apache-arrow&#34;</span><span>;</span>
<span>import</span> <span>{</span> <span>parseTable</span> <span>}</span> <span>from</span> <span>&#34;arrow-js-ffi&#34;</span><span>;</span>
<span>import</span> <span>initWasm</span><span>,</span> <span>{</span> <span>wasmMemory</span><span>,</span> <span>readParquet</span> <span>}</span> <span>from</span> <span>&#34;parquet-wasm&#34;</span><span>;</span>

<span>// Instantiate the WebAssembly context</span>
<span>await</span> <span>initWasm</span><span>(</span><span>)</span><span>;</span>

<span>// A reference to the WebAssembly memory object.</span>
<span>const</span> <span>WASM_MEMORY</span> <span>=</span> <span>wasmMemory</span><span>(</span><span>)</span><span>;</span>

<span>const</span> <span>resp</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#34;https://example.com/file.parquet&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>parquetUint8Array</span> <span>=</span> <span>new</span> <span>Uint8Array</span><span>(</span><span>await</span> <span>resp</span><span>.</span><span>arrayBuffer</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>const</span> <span>wasmArrowTable</span> <span>=</span> <span>readParquet</span><span>(</span><span>parquetUint8Array</span><span>)</span><span>.</span><span>intoFFI</span><span>(</span><span>)</span><span>;</span>

<span>// Arrow JS table that was directly copied from Wasm memory</span>
<span>const</span> <span>table</span>: <span>arrow</span><span>.</span><span>Table</span> <span>=</span> <span>parseTable</span><span>(</span>
  <span>WASM_MEMORY</span><span>.</span><span>buffer</span><span>,</span>
  <span>wasmArrowTable</span><span>.</span><span>arrayAddrs</span><span>(</span><span>)</span><span>,</span>
  <span>wasmArrowTable</span><span>.</span><span>schemaAddr</span><span>(</span><span>)</span>
<span>)</span><span>;</span>

<span>// VERY IMPORTANT! You must call `drop` on the Wasm table object when you&#39;re done using it</span>
<span>// to release the Wasm memory.</span>
<span>// Note that any access to the pointers in this table is undefined behavior after this call.</span>
<span>// Calling any `wasmArrowTable` method will error.</span>
<span>wasmArrowTable</span><span>.</span><span>drop</span><span>(</span><span>)</span><span>;</span></pre></div>

<p dir="auto">The Parquet specification permits several compression codecs. This library currently supports:</p>
<ul>
<li> Uncompressed</li>
<li> Snappy</li>
<li> Gzip</li>
<li> Brotli</li>
<li> ZSTD</li>
<li> LZ4_RAW</li>
<li> LZ4 (deprecated)</li>
</ul>
<p dir="auto">LZ4 support in Parquet is a bit messy. As described <a href="https://github.com/apache/parquet-format/blob/54e53e5d7794d383529dd30746378f19a12afd58/Compression.md">here</a>, there are <em>two</em> LZ4 compression options in Parquet (as of version 2.9.0). The original version <code>LZ4</code> is now deprecated; it used an undocumented framing scheme which made interoperability difficult. The specification now reads:</p>
<blockquote>
<p dir="auto">It is strongly suggested that implementors of Parquet writers deprecate this compression codec in their user-facing APIs, and advise users to switch to the newer, interoperable <code>LZ4_RAW</code> codec.</p>
</blockquote>
<p dir="auto">It&#39;s currently unknown how widespread the ecosystem support is for <code>LZ4_RAW</code>. As of <code>pyarrow</code> v7, it now writes <code>LZ4_RAW</code> by default and presumably has read support for it as well.</p>

<p dir="auto">In some cases, you may know ahead of time that your Parquet files will only include a single compression codec, say Snappy, or even no compression at all. In these cases, you may want to create a custom build of <code>parquet-wasm</code> to keep bundle size at a minimum. If you install the Rust toolchain and <code>wasm-pack</code> (see <a href="https://github.com/kylebarron/parquet-wasm/blob/main/DEVELOP.md">Development</a>), you can create a custom build with only the compression codecs you require.</p>
<p dir="auto">The minimum supported Rust version in this project is 1.60. To upgrade your toolchain, use <code>rustup update stable</code>.</p>

<p dir="auto">Reader-only bundle with Snappy compression:</p>
<div data-snippet-clipboard-copy-content="wasm-pack build --no-default-features --features snappy --features reader"><pre><code>wasm-pack build --no-default-features --features snappy --features reader
</code></pre></div>
<p dir="auto">Writer-only bundle with no compression support, targeting Node:</p>
<div data-snippet-clipboard-copy-content="wasm-pack build --target nodejs --no-default-features --features writer"><pre><code>wasm-pack build --target nodejs --no-default-features --features writer
</code></pre></div>
<p dir="auto">Bundle with reader and writer support, targeting Node, using <code>arrow</code> and <code>parquet</code> crates with all their supported compressions, with <code>console_error_panic_hook</code> enabled:</p>
<div dir="auto" data-snippet-clipboard-copy-content="wasm-pack build \
  --target nodejs \
  --no-default-features \
  --features reader \
  --features writer \
  --features all_compressions \
  --features debug
# Or, given the fact that the default feature includes several of these features, a shorter version:
wasm-pack build --target nodejs --features debug"><pre>wasm-pack build \
  --target nodejs \
  --no-default-features \
  --features reader \
  --features writer \
  --features all_compressions \
  --features debug
<span><span>#</span> Or, given the fact that the default feature includes several of these features, a shorter version:</span>
wasm-pack build --target nodejs --features debug</pre></div>
<p dir="auto">Refer to the <a href="https://rustwasm.github.io/docs/wasm-pack/commands/build.html" rel="nofollow"><code>wasm-pack</code> documentation</a> for more info on flags such as <code>--release</code>, <code>--dev</code>, <code>target</code>, and to the <a href="https://doc.rust-lang.org/cargo/reference/features.html" rel="nofollow">Cargo documentation</a> for more info on how to use features.</p>

<p dir="auto">By default, <code>all_compressions</code>, <code>reader</code>, <code>writer</code>, and <code>async</code> features are enabled. Use <code>--no-default-features</code> to remove these defaults.</p>
<ul dir="auto">
<li><code>reader</code>: Activate read support.</li>
<li><code>writer</code>: Activate write support.</li>
<li><code>async</code>: Activate asynchronous read support.</li>
<li><code>all_compressions</code>: Activate all supported compressions.</li>
<li><code>brotli</code>: Activate Brotli compression.</li>
<li><code>gzip</code>: Activate Gzip compression.</li>
<li><code>snappy</code>: Activate Snappy compression.</li>
<li><code>zstd</code>: Activate ZSTD compression.</li>
<li><code>lz4</code>: Activate LZ4_RAW compression.</li>
<li><code>debug</code>: Expose the <code>setPanicHook</code> function for better error messages for Rust panics.</li>
</ul>

<p dir="auto">On Node versions before 20, you&#39;ll have to <a href="https://docs.rs/getrandom/latest/getrandom/#nodejs-es-module-support" rel="nofollow">polyfill the Web Cryptography API</a>.</p>

<ul>
<li> Example of pushdown predicate filtering, to download only chunks that match a specific condition</li>
<li> Column filtering, to download only certain columns</li>
<li> More tests</li>
</ul>

<p dir="auto">A starting point of my work came from @my-liminal-space&#39;s <a href="https://github.com/my-liminal-space/read-parquet-browser"><code>read-parquet-browser</code></a> (which is also dual licensed MIT and Apache 2).</p>
<p dir="auto">@domoritz&#39;s <a href="https://github.com/domoritz/arrow-wasm"><code>arrow-wasm</code></a> was a very helpful reference for bootstrapping Rust-WASM bindings.</p>
</article></div></div>
  </body>
</html>
