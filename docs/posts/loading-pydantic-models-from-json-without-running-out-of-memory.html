<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pythonspeed.com/articles/pydantic-json-memory/">Original</a>
    <h1>Loading Pydantic models from JSON without running out of memory</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      <p>You have a large JSON file, and you want to load the data into Pydantic.
Unfortunately, this uses a lot of memory, to the point where large JSON files are very difficult to read.
What to do?</p>

<p>Assuming you’re stuck with JSON, in this article we’ll cover:</p>

<ul>
  <li>The high memory usage you get with Pydantic’s default JSON loading.</li>
  <li>How to reduce memory usage by switching to another JSON library.</li>
  <li>Going further by switching to dataclasses with slots.</li>
</ul>

<!-- TEASER_END -->

<h2 id="the-problem-20-memory-multiplier">The problem: 20× memory multiplier</h2>

<p>We’re going to start with a 100MB JSON file, and load it into Pydantic (v2.11.4).
Here’s what our model looks like:</p>

<div><div><pre><code><span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span><span>,</span> <span>RootModel</span>

<span>class</span> <span>Name</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>first</span><span>:</span> <span>str</span> <span>|</span> <span>None</span>
    <span>last</span><span>:</span> <span>str</span> <span>|</span> <span>None</span>

<span>class</span> <span>Customer</span><span>(</span><span>BaseModel</span><span>):</span>
    <span>id</span><span>:</span> <span>str</span>
    <span>name</span><span>:</span> <span>Name</span>
    <span>notes</span><span>:</span> <span>str</span>

<span># Map id to corresponding Customer:
</span><span>CustomerDirectory</span> <span>=</span> <span>RootModel</span><span>[</span><span>dict</span><span>[</span><span>str</span><span>,</span> <span>Customer</span><span>]]</span>
</code></pre></div></div>

<p>The JSON we’re loading looks more or less like this:</p>

<div><div><pre><code><span>{</span>
    <span>&#34;</span><span>123</span><span>&#34;</span><span>:</span> <span>{</span>
        <span>&#34;</span><span>id</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>123</span><span>&#34;</span><span>,</span>
        <span>&#34;</span><span>name</span><span>&#34;</span><span>:</span> <span>{</span>
            <span>&#34;</span><span>first</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>Itamar</span><span>&#34;</span><span>,</span>
            <span>&#34;</span><span>last</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>Turner-Trauring</span><span>&#34;</span>
        <span>},</span>
        <span>&#34;</span><span>notes</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>Some notes about Itamar</span><span>&#34;</span>
    <span>},</span>
    <span># ... etc ...
</span><span>}</span>
</code></pre></div></div>
<p>Pydantic has built-in support for loading JSON, though sadly it doesn’t support reading from a file.
So we load the file into a string and then parse it:</p>

<div><div><pre><code><span>with</span> <span>open</span><span>(</span><span>&#34;</span><span>customers.json</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>rb</span><span>&#34;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
    <span>raw_json</span> <span>=</span> <span>f</span><span>.</span><span>read</span><span>()</span>
    <span>directory</span> <span>=</span> <span>CustomerDirectory</span><span>.</span><span>model_validate_json</span><span>(</span>
        <span>raw_json</span>
    <span>)</span>
</code></pre></div></div>

<p>This is very straightforward.</p>

<p>But there’s a problem.
If we <a href="https://pythonspeed.com/articles/measuring-memory-python/">measure peak memory usage</a>, it’s using a <em>lot</em> of memory:</p>

<div><div><pre><code><span>$</span><span> </span>/usr/bin/time <span>-v</span> python v1.py
<span>...
</span><span>Maximum resident set size (kbytes): 2071620
</span><span>...
</span></code></pre></div></div>

<p>That’s around 2000MB of memory, 20× the size of the JSON file.
If our JSON file had been 10GB, memory usage would be 200GB, and we’d probably <a href="https://pythonspeed.com/articles/python-out-of-memory/">run out of memory</a>.
Can we do better?</p>

<h2 id="reducing-memory-usage">Reducing memory usage</h2>

<p>There are two fundamental sources of peak memory usage when parsing JSON:</p>

<ol>
  <li>The memory used during parsing; many JSON parsers aren’t careful about memory usage, and use more than necessary.</li>
  <li>The memory used by the final representation, the objects we’re creating.</li>
</ol>

<p>We’ll try to reduce memory usage in each.</p>

<h3 id="1-memory-efficient-json-parsing">1. Memory-efficient JSON parsing</h3>

<p>We’ll use <code>ijson</code>, an <a href="https://pythonspeed.com/articles/json-memory-streaming/">incremental JSON parser that lets us <em>stream</em> the JSON document we’re parsing</a>.
Instead of loading the whole document into memory, we’ll load it one key/value pair at a time.
The result is that most of the memory usage will now come from the in-memory representation of the resulting objects, rather than parsing:</p>

<div><div><pre><code><span>import</span> <span>ijson</span>

<span>with</span> <span>open</span><span>(</span><span>&#34;</span><span>customers.json</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>rb</span><span>&#34;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
    <span># We&#39;ll create the root dictionary ourselves:
</span>    <span>data</span> <span>=</span> <span>{}</span>
    <span># The empty string is part of ijson&#39;s query language,
</span>    <span># in this case it means &#34;iterate over top-level&#34;, and
</span>    <span># since we&#39;re using kvitems() that means top-level
</span>    <span># key-value pairs in the root JSON object/dict:
</span>    <span>for</span> <span>cid</span><span>,</span> <span>cust_dict</span> <span>in</span> <span>ijson</span><span>.</span><span>kvitems</span><span>(</span><span>f</span><span>,</span> <span>&#34;&#34;</span><span>):</span>
        <span># Create a Customer for the value dict:
</span>        <span>customer</span> <span>=</span> <span>Customer</span><span>.</span><span>model_validate</span><span>(</span><span>cust_dict</span><span>)</span>
        <span># Store it in the root dict using the key:
</span>        <span>data</span><span>[</span><span>cid</span><span>]</span> <span>=</span> <span>customer</span>
    <span># And now create the root object:
</span>    <span>directory</span> <span>=</span> <span>CustomerDirectory</span><span>.</span><span>model_validate</span><span>(</span><span>data</span><span>)</span>
</code></pre></div></div>

<p>While parsing this way is significantly slower (5×), it reduces memory usage significantly, to just 1200MB.</p>

<p>It also requires us to do a bit more of the work of parsing the JSON, but anything below the top-level JSON object or list can be done by Pydantic.</p>

<h3 id="2-memory-efficient-representation">2. Memory-efficient representation</h3>

<p>We’re creating a lot of Python objects, and <a href="https://pythonspeed.com/articles/python-object-memory/">one way to save memory on Python objects is to use “slots”</a>.
Essentially, slots are a more efficient in-memory representation for Python objects, where the list of possible attributes is fixed.
This saves memory at the cost of disallowing adding extra attributes to an object, which in practice isn’t that common so it’s often a good tradeoff.</p>

<p>Unfortunately, <code>pydantic.BaseModel</code> doesn’t seem to support that at the moment, so I switched to Pydantic’s dataclass support, which does.
Here’s our new model:</p>

<div><div><pre><code><span>from</span> <span>pydantic</span> <span>import</span> <span>RootModel</span>
<span>from</span> <span>pydantic.dataclasses</span> <span>import</span> <span>dataclass</span>

<span># Create a class using slots; this means you can&#39;t
# add additional attributes, but it will use less memory:
</span><span>@dataclass</span><span>(</span><span>slots</span><span>=</span><span>True</span><span>)</span>
<span>class</span> <span>Name</span><span>:</span>
    <span>first</span><span>:</span> <span>str</span> <span>|</span> <span>None</span>
    <span>last</span><span>:</span> <span>str</span> <span>|</span> <span>None</span>

<span>@dataclass</span><span>(</span><span>slots</span><span>=</span><span>True</span><span>)</span>
<span>class</span> <span>Customer</span><span>:</span>
    <span>id</span><span>:</span> <span>str</span>
    <span>name</span><span>:</span> <span>Name</span>
    <span>notes</span><span>:</span> <span>str</span>

<span># Map id to corresponding Customer:
</span><span>CustomerDirectory</span> <span>=</span> <span>RootModel</span><span>[</span><span>dict</span><span>[</span><span>str</span><span>,</span> <span>Customer</span><span>]]</span>
</code></pre></div></div>

<p>And we also need to tweak our parsing code slightly:</p>

<div><div><pre><code><span>import</span> <span>ijson</span>

<span>with</span> <span>open</span><span>(</span><span>&#34;</span><span>customers.json</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>rb</span><span>&#34;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
    <span>data</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>cust_id</span><span>,</span> <span>cust_dict</span> <span>in</span> <span>ijson</span><span>.</span><span>kvitems</span><span>(</span><span>f</span><span>,</span> <span>&#34;&#34;</span><span>):</span>
        <span>customer</span> <span>=</span> <span>Customer</span><span>(</span><span>**</span><span>cust_dict</span><span>)</span>
        <span>data</span><span>[</span><span>cust_id</span><span>]</span> <span>=</span> <span>customer</span>
    <span>directory</span> <span>=</span> <span>CustomerDirectory</span><span>.</span><span>model_validate</span><span>(</span><span>data</span><span>)</span>
</code></pre></div></div>

<p>With this version of the code, memory usage has shrunk to 450MB.</p>

<h2 id="final-thoughts">Final thoughts</h2>

<p>Here’s a summary of peak memory usage when parsing a 100MB JSON file with the three techniques we covered:</p>

<table>
  <thead>
    <tr>
      <th>Implementation</th>
      <th>Peak memory usage (MB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Model.model_validate_json()</code></td>
      <td>2000</td>
    </tr>
    <tr>
      <td><code>ijson</code></td>
      <td>1200</td>
    </tr>
    <tr>
      <td><code>ijson</code> + <code>@dataclass(slots=True)</code></td>
      <td>450</td>
    </tr>
  </tbody>
</table>

<p>This particular use case, of loading a large number of objects, may not be something Pydantic developers care about, or have the time to prioritize.
But it would certainly be possible for Pydantic to internally work more like <code>ijson</code>, and to add the option for using <code>__slots__</code> to <code>BaseModel</code>.
The end result would use far less memory, while still benefiting from Pydantic’s faster JSON parser.</p>

<p>Until then, you have options you can implement yourself.</p>

  </div></div>
  </body>
</html>
