<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mawfig.github.io/2022/06/18/v-lang-in-2022.html">Original</a>
    <h1>V Language Review</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><a href="https://vlang.io/">V</a> is a programming language promising to be “Simple, fast, safe, compiled. For developing maintainable software.”
V <a href="https://news.ycombinator.com/item?id=20229632">has</a> <a href="https://github.com/vlang/v/issues/35">a</a> <a href="https://christine.website/blog/v-vaporware-2019-06-23">controversial</a> <a href="https://christine.website/blog/v-vvork-in-progress-2020-01-03">past</a> but what is the state of V in 2022?</p>

<p>Is V worth checking out?</p>

<p>In this post, we’ll take a look at V as it exists in May 2022.</p>

<p><strong>TLDR</strong> <a href="#summary">Read the summary</a></p>

<h2 id="rules-of-engagement">Rules of engagement</h2>

<p>I’ll be using the current version of V built from git which is <a href="https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6"><code>50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6</code></a>.
I’ll also stick to the compiler defaults as much as possible to keep to the <a href="https://en.wikipedia.org/wiki/Happy_path">“happy path”</a> so that I get a typical V experience.</p>

<p>To evaluate the language, I’ll validate the major claims made on their homepage and related sub-pages/documentation.
Features indicated to be incomplete/work in progress/unimplemented will be mentioned as such.
Where possible, I’ll try to include the code used to evaluate a claim.</p>

<p>I’m also scoping this to focus on V the language and not any of the standard libraries or other related projects as V seems to be the most developed.</p>

<h2 id="evaluation">Evaluation</h2>

<h3 id="simple-language-for-building-maintainable-programs">Simple language for building maintainable programs</h3>

<p>I don’t see any objective way to evaluate the claims in this section, so we’ll give them a pass.</p>

<p><em>Evaluation</em>: N/a (subjective claim)</p>

<h3 id="safety">Safety</h3>

<blockquote>
  <ul>
    <li>No null</li>
  </ul>
</blockquote>

<p>The <a href="https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md">V docs</a> indicate V has references and “in general, V’s references are similar to Go pointers and C++ references”.</p>

<p>Let’s see if we can pass a null reference to a function.
The docs contain an example of a tree structure, so let’s adapt that and see if we can create a null reference.
Null usually corresponds to <code>0</code> so we’ll try that:</p>

<pre><code>struct Node {
    val   int
    left  &amp;Node
    right &amp;Node
}

fn main() {
    n := Node { 123, 0, 0 }
    println(n.left)
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.2938032035736349851.tmp.c:6750: at print_backtrace: Backtrace
/tmp/v_1000/test.2938032035736349851.tmp.c:6821: by v_segmentation_fault_handler
7f6ff9bfe210 : by ???
/tmp/v_1000/test.2938032035736349851.tmp.c:11990: by main
</code></pre></div></div>

<p>Oh, no. 😰
Let’s check the generated C and <em>see</em> what’s up:</p>

<div><div><pre><code><span>...</span>
<span>struct</span> <span>main__Node</span> <span>{</span>
    <span>int</span> <span>val</span><span>;</span>
    <span>main__Node</span><span>*</span> <span>left</span><span>;</span>
    <span>main__Node</span><span>*</span> <span>right</span><span>;</span>
<span>};</span>
<span>...</span>
<span>VV_LOCAL_SYMBOL</span> <span>void</span> <span>main__main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>main__Node</span> <span>n</span> <span>=</span> <span>((</span><span>main__Node</span><span>){.</span><span>val</span> <span>=</span> <span>123</span><span>,.</span><span>left</span> <span>=</span> <span>0</span><span>,.</span><span>right</span> <span>=</span> <span>0</span><span>,});</span>
    <span>println</span><span>(</span><span>str_intp</span><span>(</span><span>1</span><span>,</span> <span>_MOV</span><span>((</span><span>StrIntpData</span><span>[])})));</span>
<span>}</span>
<span>...</span>
</code></pre></div></div>

<p>So yeah, we’re able to create a null pointer (V reference) with no compiler errors or warnings.</p>

<p><em>Evaluation</em>: 🛑 Doesn’t seem to hold up</p>

<blockquote>
  <ul>
    <li>No undefined values</li>
  </ul>
</blockquote>

<p>It’s not obvious to me what this means.
Javascript has a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> value but that doesn’t really seem relevant.
C allows you to use an uninitialized variable which can result in Undefined Behavior.
I’ll assume that’s what this means.</p>

<p>Typically, uninitialized values come from a memory allocation that hasn’t been written to.
The <a href="https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md#array-initialization">V docs say</a> we can create an empty array by passing the allocation length in the initialization expression.
Let’s see if we can get the V compiler to allocate memory for us without writing to it:</p>

<pre><code>fn main() {
    a := []&amp;int { len: 1 }
    println(a)
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.926306498470184027.tmp.c:6770: at print_backtrace: Backtrace
/tmp/v_1000/test.926306498470184027.tmp.c:6841: by v_segmentation_fault_handler
7fc58f7fd210 : by ???
/tmp/v_1000/test.926306498470184027.tmp.c:1973: by Array_main__Node_ptr_str
/tmp/v_1000/test.926306498470184027.tmp.c:11644: by main__main
/tmp/v_1000/test.926306498470184027.tmp.c:12010: by main
</code></pre></div></div>

<p>Sigh.
The generated C code is 12,000 lines long and nothing jumps out to me with a quick glance, so I won’t try to dig in further.</p>

<p><em>Evaluation</em>: 🛑 Doesn’t seem to hold up</p>

<blockquote>
  <ul>
    <li>No undefined behavior</li>
  </ul>
</blockquote>

<p>Wikipedia <a href="https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++">has a list</a> of Undefined Behaviors (UB) in C and C++.
Let’s see if we can get V to generate C code which contains some of these behaviors!</p>

<ul>
  <li>Integer Overflow</li>
</ul>

<p>In C and C++, signed integer overflow results in UB.
Let’s try to add <code>1</code> to the max value of an integer and see what happens:</p>

<pre><code>fn main() {
    x := i32(2147483647) + 1
    println(x)
}
</code></pre>

<div><div><pre><code>$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
test.c: In function ‘main__main’:
test.c:11605:30: warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow]
11605 |  int x = ((i32)(2147483647)) + 1;
      |                              ^
$ ./a.out
test.c:7248:33: runtime error: signed integer overflow: -2147483648 - 2147483600 cannot be represented in type &#39;int&#39;
-2147483648
</code></pre></div></div>

<p>That’s no good.</p>

<p>Let’s try some of the other classic cases of UB.</p>

<ul>
  <li>Divide by 0</li>
</ul>

<pre><code>fn main() {
    x := 42
    y := 0
    z := x / y
    println(z)
}
</code></pre>

<div><div><pre><code>$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
$ ./a.out
test.c:11607:12: runtime error: division by zero
Floating point exception
</code></pre></div></div>

<ul>
  <li>Temporal memory safety violations (dangling pointer)</li>
</ul>

<pre><code>struct Something {
    val   int
}

fn main() {
    x := voidptr(123)
    y := &amp;Something(x)
    println(y)
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.5460990319614516137.tmp.c:6746: at print_backtrace: Backtrace
/tmp/v_1000/test.5460990319614516137.tmp.c:6817: by v_segmentation_fault_handler
7f062f88d210 : by ???
/tmp/v_1000/test.5460990319614516137.tmp.c:11987: by main
</code></pre></div></div>

<p>There’s more UB we could test for but I’m just going to call it there.</p>

<p><em>Evaluation</em>: 🛑 Doesn’t seem to hold up</p>

<blockquote>
  <ul>
    <li>No variable shadowing</li>
  </ul>
</blockquote>

<p>I don’t see how variable shadowing is a safety issue and shadowing variables after they should no longer be used in a common technique in functional programming languages but let’s test it out:</p>

<pre><code>fn main() {
    x := 1
    x := 2

    if true {
        x := 3
    }
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
test.v:3:2: error: redefinition of `x`
    1 | fn main() {
    2 |     x := 1
    3 |     x := 2
      |     ^
    4 |
    5 |     if true {
</code></pre></div></div>

<p>and removing that line:</p>

<div><div><pre><code>$ ./v run test.v
test.v:5:3: error: redefinition of `x`
    3 |
    4 |     if true {
    5 |         x := 3
      |         ^
    6 |     }
    7 | }
</code></pre></div></div>

<p>Works as advertised! ✔️</p>

<p>I see though that V supports closures.
What are the rules for shadowing variables in closures?</p>

<pre><code>fn main() {
    x := 1

    y := fn (x int) {
        println(x)
    }

    y(x)
    y(2)
}
</code></pre>



<p>It looks like shadowing is allowed for closure arguments? 
There are also explicit closure captures, what happens if I also capture <code>x</code>?</p>

<pre><code>$ cat test.v
fn main() {
    x := 1

    y := fn [x] (x int) {
        println(x)
    }

    y(x)
    y(2)
}
</code></pre>



<p>Well, that seems like it should be disallowed.
It makes sense that <code>x</code> can be captured but to then shadow the argument with the same name without error or warning doesn’t seem inline with the rest of V’s behavior.</p>

<p>Even with this surprising behavior, I’m going to give it to V.</p>

<p><em>Evaluation</em>: ✔️ Seems to work</p>

<blockquote>
  <ul>
    <li>Bounds checking</li>
  </ul>
</blockquote>

<p>Bounds checking is important to prevent out-of-bounds access to arrays.</p>

<p>Let’s check a simple example:</p>

<pre><code>fn main() {
    x := [1, 2, 3]
    println(x[4])
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
V panic: array.get: index out of range (i == 4, a.len == 3)
v hash: 50ab2cf
/tmp/v_1000/test.17032083146791375427.tmp.c:6344: at _v_panic: Backtrace
/tmp/v_1000/test.17032083146791375427.tmp.c:5860: by array_get
/tmp/v_1000/test.17032083146791375427.tmp.c:11597: by main__main
/tmp/v_1000/test.17032083146791375427.tmp.c:11963: by main
</code></pre></div></div>

<p>Seeing <code>a.len == 3</code> reminds me that V allows you to mess with some of the array (vector) properties at creation:</p>

<pre><code>fn main() {
    x := []&amp;int { len: 10, cap: 0 }
    println(x[4])
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.8104236387804386445.tmp.c:6724: at print_backtrace: Backtrace
/tmp/v_1000/test.8104236387804386445.tmp.c:6795: by v_segmentation_fault_handler
7f8aa2432210 : by ???
/tmp/v_1000/test.8104236387804386445.tmp.c:11964: by main
</code></pre></div></div>

<p>Allowing the user to control the <code>len</code> property is a <strong>really</strong> bad idea.</p>

<p><em>Evaluation</em>: ⚠️ Some basic checking exists but can be trivially bypassed</p>

<blockquote>
  <ul>
    <li>Immutable variables by default</li>
  </ul>
</blockquote>

<p>Immutable values by default is a good default in a modern programming language.</p>

<pre><code>fn main() {
    x := 4
    x = 2
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
test.v:2:2: warning: unused variable: `x`
    1 | fn main() {
    2 |     x := 4
      |     ^
    3 |     x = 2
    4 | }
test.v:3:2: error: `x` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     x := 4
    3 |     x = 2
      |     ^
    4 | }
</code></pre></div></div>

<p>So far so good!
V seems to be pretty loose with typecasts though so can we trick the compiler into letting us mutate an immutable value?
Yes, we can:</p>

<pre><code>[heap]
struct Foo {
    mut: value int
}

fn y(x &amp;Foo) {
    mut m := x
    m.value = 42
}

fn main() {
    x := Foo { 123 }
    y(x)
    println(x)
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
Foo{
    value: 42
}
</code></pre></div></div>

<p>You really shouldn’t be able to convert the immutable reference to a mutable one (<code>mut m := x</code>).
This results in us being able to mutate the “immutable” value <code>x</code> in <code>main</code> with no indication at the call site, there’s not even the clue that we’re passing the value by reference.</p>

<p><em>Evaluation</em>: 🛑 Variables aren’t immutable in any significant way because you can trivially turn an immutable reference into a mutable one.</p>

<blockquote>
  <ul>
    <li>Pure functions by default</li>
  </ul>
</blockquote>

<p>The <a href="https://github.com/vlang/v/blob/master/doc/docs.md#pure-functions-by-default">docs say</a>:</p>

<blockquote>
  <p>V functions are pure by default, meaning that their return values are a function of their arguments only, and their evaluation has no side effects (besides I/O).</p>
</blockquote>

<p><strong>besides I/O</strong></p>

<p><a href="https://www.destroyallsoftware.com/talks/wat">wat</a></p>

<p>I/O is <a href="https://en.wikipedia.org/wiki/Pure_function#I/O_in_pure_functions">literally the definition of an impure operation</a> because it allows a function to trivially break referential transparency which V claims to uphold (“their {V functions} return values are a function of their arguments only”).</p>

<blockquote>
  <p>This is achieved by a lack of global variables and all function arguments being immutable by default, even when references are passed.</p>
</blockquote>

<p>As we saw in the previous section, immutability in V is broken so this guarantee doesn’t hold.</p>

<p>To demonstrate how completely ludicrous this definition is, here is a “pure” V module that re-implements global variables using file I/O:</p>

<pre><code>import os

fn read_global(name string) int {
    content := os.read_file(name) or { return 0 }
    return content.int()
}

fn write_global(name string, value int) {
    s := value.str()
    os.write_file(name, s) or { }
}
</code></pre>

<p>and we’ll go ahead and use it:</p>

<pre><code>import globals

fn x() {
    globals.write_global(&#34;my_global&#34;, 7)
}

fn y() {
    my_global := globals.read_global(&#34;my_global&#34;)
    globals.write_global(&#34;my_global&#34;, my_global * 3)
}

fn z() int {
    my_global := globals.read_global(&#34;my_global&#34;)
    globals.write_global(&#34;my_global&#34;, my_global * 2)
    return globals.read_global(&#34;my_global&#34;)
}

fn main() {
    x()
    y()
    my_global := z()
    println(my_global)
}
</code></pre>



<p><em>Evaluation</em>: 🛑 Claim is meaningless as it redefines “pure” to mean “impure”</p>

<blockquote>
  <p>Immutable structs by default</p>
</blockquote>

<p>We’ve already broke immutable values in a previous section using structs so we know this doesn’t hold.</p>

<p><em>Evaluation</em>: 🛑 Doesn’t seem to hold</p>

<blockquote>
  <ul>
    <li>Option/Result and mandatory error checks</li>
  </ul>
</blockquote>

<p>Mandatory error checks seem to work correctly in most contexts.
Is it possible to confuse the compiler and have it ignore the return value?</p>

<pre><code>fn ignore(x any) {
}

fn create_error() ?int {
    return error(&#34;an error&#34;)
}

fn main() {
    ignore(create_error())
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
test.v:9:9: error: create_error() returns an option, so it should have either an `or {}` block, or `?` at the end
    7 |
    8 | fn main() {
    9 |     ignore(create_error())
      |            ~~~~~~~~~~~~~~
   10 | }
</code></pre></div></div>

<p>Looks good! 
I tried a few different variations on this idea but wasn’t able to confuse the compiler.</p>

<p><em>Evaluation</em>: ✔️ Works as advertised</p>

<blockquote>
  <ul>
    <li>Sum types</li>
  </ul>
</blockquote>

<p>Sum types are a very nice feature!
Let’s see how they work:</p>

<pre><code>type MyType = f64 | i64

fn test(x MyType) {
    println(x)
}

fn main() {
    test(i64(0))
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
MyType(0)
</code></pre></div></div>

<p>Good!
The implementation seems pretty fragile though.
Many operations that are allowed for normal types, seem to crash the compiler when used with sumtypes.
For instance, casting:</p>

<pre><code>type MyType = f64 | i64

fn test(x MyType) {
    println(i64(x))
}

fn main() {
    test(i64(0))
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
==================
/tmp/v_1000/test.11297848884384464859.tmp.c:11633: error: cannot convert &#39;struct main__MyType&#39; to &#39;long&#39;
...
==================
(Use `v -cg` to print the entire error message)

builder error:
==================
C error. This should never happen.

This is a compiler bug, please report it using `v bug file.v`.

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
</code></pre></div></div>

<p>Sum types have some restrictions:</p>

<pre><code>type MyType = &amp;i64 | &amp;f64

fn main() {
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
test.v:1:15: error: sum type cannot hold a reference type
    1 | type MyType = &amp;i64 | &amp;f64
      |               ~~~~
    2 |
    3 | fn main() {
</code></pre></div></div>

<p>but they don’t seem to be well checked 😢:</p>

<pre><code>type MyType = Foo | Bar
type Foo = &amp;i64
type Bar = &amp;f64

fn main() {
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
$ echo $?
0
</code></pre></div></div>

<p><em>Evaluation</em>: ⚠️ Sum types generally seem to work but there are implementation issues.</p>

<blockquote>
  <ul>
    <li>Generics</li>
  </ul>
</blockquote>

<p>V generics are a little strange.
They’re much more like C++ templates than they are generics as known from Java, C#, ML, Rust, etc.
V doesn’t have a way to restrict the set of types allowed to be substituted (<code>where T: IInterface</code> in C#) which means the compiler can’t check generic code at declaration time:</p>

<pre><code>fn foo&lt;T&gt;(x T) {
        this_func_does_not_exist(x)
        what.the.f = &#34;wut&#34;
        x.not_a_real_method()
}

fn main() {
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
$ echo $?
0
</code></pre></div></div>

<p>Even though V ~generics~ templates are conceptually similar to C++ templates, the lack of <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a> seems to lead to compiler crashes:</p>

<pre><code>struct Wrapped&lt;T&gt; {
    value T
}

fn (w Wrapped&lt;T&gt;) double() Wrapped&lt;T&gt; {
    return Wrapped&lt;T&gt; { w.value * 2 }
}

fn make_wrapped&lt;T&gt;(value T) Wrapped&lt;T&gt; {
    return Wrapped&lt;T&gt; { value }
}

fn main() {
    println(make_wrapped(&#34;str&#34;))
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
==================
/tmp/v_1000/test.6663405339574001690.tmp.c:11622: error: invalid operand types for binary operation
/tmp/v_1000/test.6663405339574001690.tmp.c:11622: error: invalid aggregate type for register load
...
==================
(Use `v -cg` to print the entire error message)

builder error:
==================
C error. This should never happen.

This is a compiler bug, please report it using `v bug file.v`.

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
</code></pre></div></div>

<p>V’s decision here requires stamping out (<a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphisizing</a>) functions for all concrete instances of templated types used in the program.
In C++, this generally leads to “template bloat” as often many monomorphic instances of a templated function can share code.
While the effects on code size can often be resolved via link-time optimizations, this can significantly hurt compile times. 
Given V’s desire for <em>extremely</em> fast compile times, this is probably not a good strategy for the long term as it requires both V’s compiler to type-check each copy of the function separately as well as the C compiler to compile each instantiation as well.</p>

<p>The V compiler doesn’t seem to prevent the “mangled” templated type names from colliding with user defined type names either:</p>

<pre><code>struct MyStruct&lt;T&gt; {
    val T
}

struct Foo {
    x int
}

struct MyStruct_T_main__Foo {
    bla string
}

fn main() {
    x := MyStruct&lt;Foo&gt; { Foo { 0 } }
    y := MyStruct_T_main__Foo { &#34;&#34; }
    println(x)
    println(y)
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
==================
/tmp/v_1000/test.5104305706961604858.tmp.c:1112: error: struct/union/enum already defined
...
==================
(Use `v -cg` to print the entire error message)

builder error:
==================
C error. This should never happen.

This is a compiler bug, please report it using `v bug file.v`.

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
</code></pre></div></div>

<p>I’m very torn on evaluating this feature.
On the one hand, very basic usage seems to work.
On the other hand, the implementation seems to be little more than textual substitution and bears no real relation to the generics of other programming languages (Go included!).</p>

<p><em>Evaluation</em>: 🛑 A basic implementation exists but is very buggy and seems completely out of place in a language with an self described emphasis on safety and compiler performance.</p>

<blockquote>
  <ul>
    <li>No global variables (can be enabled for low level applications like kernels via a command line flag)</li>
  </ul>
</blockquote>

<p>By default, V doesn’t allow global variables.</p>

<pre><code>__global(
    x = i64(42)
)

fn main() {
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
test.v:1:1: error: use `v -enable-globals ...` to enable globals
    1 | __global(
      | ~~~~~~~~
    2 |     x = i64(42)
    3 | )
</code></pre></div></div>

<p>However, we’ve already re-implemented global variables using “pure” functions only.
Can we do better than that?
Oh, yes!</p>

<p>Presenting global variables in V:</p>

<pre><code>const foo = make_global(&#39;hello world&#39;)

[heap]
struct Global&lt;T&gt; {
    mut: value &amp;T
}

fn make_global&lt;T&gt;(value T) Global&lt;T&gt; {
    return Global&lt;T&gt; { &amp;value }
}

fn assign_global&lt;T&gt;(g &amp;Global&lt;T&gt;, value T) {
    mut g_m := g
    g_m.value = &amp;value
}

fn main() {
    println(foo)
    assign_global(foo, &#39;changed&#39;)
    println(foo)
}
</code></pre>

<div><div><pre><code>$ ./v run test.v
Global&lt;string&gt;{
    value: &amp;&#39;hello world&#39;
}
Global&lt;string&gt;{
    value: &amp;&#39;changed&#39;
}
</code></pre></div></div>

<p>We’re able to use V <em>constants</em> to re-implement <em>global variables</em>.
To do this, we use a function call to implicitly cast away the “const-ness” (to borrow a C++ term) of the <code>foo</code> constant and then we can confuse the compiler by aliasing an immutable reference as a mutable one.
Once there, we can directly assign to the <code>value</code> field of the <code>Global</code>.
Since V constants are just global variables to begin with, there’s no runtime protection for this either.</p>

<p><em>Evaluation</em>: 🛑 V does not prevent you from creating and mutating globally shared state in any meaningful way.</p>

<h3 id="performance">Performance</h3>

<blockquote>
  <ul>
    <li>As fast as C (V’s main backend compiles to human readable C)</li>
  </ul>
</blockquote>

<p>To start, I’ll preface this by saying that comparing programming languages on the basis of performance is extremely difficult.
There are many factors and tradeoffs which have to be weighed for a complete comparison.
No individual benchmark or measurement will be perfect and results can vary widely from one machine to another.</p>

<p>I think it’s also important to point out that compiling to C does not automatically make your language fast and specifically it does not automatically give you C level performance.
To see this statement being used to justify the performance claim is frankly shocking.</p>

<p>As a novice V programmer, I can’t claim to be able to write fast V code.
I will therefore lean on community benchmarks where interested parties can battle it out themselves.</p>

<p>First up, let’s look at <a href="https://github.com/kostya/benchmarks"><code>kostya/benchmarks</code></a>.
Let’s check out <a href="https://programming-language-benchmarks.vercel.app/v-vs-c">V vs C</a>.
For each benchmark that has both a C entry and a V entry, we’ll compare the fastest versions of each language:</p>

<table>
  <thead>
    <tr>
      <th>Benchmark</th>
      <th>Fastest V time</th>
      <th>Fastest C time</th>
      <th>V delta</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>helloworld</td>
      <td>1.5ms</td>
      <td>1.5ms</td>
      <td>Equal</td>
    </tr>
    <tr>
      <td>nbody</td>
      <td>988ms</td>
      <td>321ms</td>
      <td>3.1x slower 🔻</td>
    </tr>
    <tr>
      <td>nsieve</td>
      <td>509ms</td>
      <td>795ms</td>
      <td>1.5% faster ⬆️</td>
    </tr>
    <tr>
      <td>spectral-norm</td>
      <td>4117ms</td>
      <td>1406ms</td>
      <td>2.9x slower 🔻</td>
    </tr>
  </tbody>
</table>

<p>It seems early to draw conclusions from so few data points, but this doesn’t look good for V.
C is missing from quite a few of these benchmarks which makes it difficult to draw a conclusion.
Rust has many more of these benchmarks implemented and is considered to be on par with C for performance, so let’s look at those:</p>

<table>
  <thead>
    <tr>
      <th>Benchmark</th>
      <th>Fastest V time</th>
      <th>Fastest Rust time</th>
      <th>V delta</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>binarytrees</td>
      <td>1118ms</td>
      <td>1792ms</td>
      <td>1.6x faster ⬆️</td>
    </tr>
    <tr>
      <td>coro-prime-sieve</td>
      <td>2078ms</td>
      <td>74ms</td>
      <td>28.1x slower 🔻</td>
    </tr>
    <tr>
      <td>edigits</td>
      <td><em>timeout</em></td>
      <td>147ms</td>
      <td><em>Significantly</em> slower 🔻</td>
    </tr>
    <tr>
      <td>fannkuch-redux</td>
      <td>3311ms</td>
      <td>726ms</td>
      <td>4.6x slower 🔻</td>
    </tr>
    <tr>
      <td>fasta</td>
      <td>769ms</td>
      <td>180ms</td>
      <td>4.3x slower 🔻</td>
    </tr>
    <tr>
      <td>helloworld</td>
      <td>1.5ms</td>
      <td>2.1ms</td>
      <td>1.4x faster ⬆️</td>
    </tr>
    <tr>
      <td>lru</td>
      <td>399ms</td>
      <td>53ms</td>
      <td>7.5x slower 🔻</td>
    </tr>
    <tr>
      <td>nbody</td>
      <td>988ms</td>
      <td>253ms</td>
      <td>3.9x slower 🔻</td>
    </tr>
    <tr>
      <td>nsieve</td>
      <td>509ms</td>
      <td>465ms</td>
      <td>1.1x slower 🔻</td>
    </tr>
    <tr>
      <td>pidigits</td>
      <td>4672ms</td>
      <td>1829ms</td>
      <td>2.6x slower 🔻</td>
    </tr>
    <tr>
      <td>spectral-norm</td>
      <td>4117ms</td>
      <td>1065ms</td>
      <td>3.9x slower 🔻</td>
    </tr>
  </tbody>
</table>

<p>So V doesn’t seem to even be close to either C or Rust in these benchmarks.
Perhaps we should try looking at higher-level language that doesn’t offer as much control as C and Rust aim to: C#.</p>

<table>
  <thead>
    <tr>
      <th>Benchmark</th>
      <th>Fastest V time</th>
      <th>Fastest C# time</th>
      <th>V delta</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>binarytrees</td>
      <td>1118ms</td>
      <td>1400ms</td>
      <td>1.3x faster ⬆️</td>
    </tr>
    <tr>
      <td>coro-prime-sieve</td>
      <td>2078ms</td>
      <td>410ms</td>
      <td>5.1x slower 🔻</td>
    </tr>
    <tr>
      <td>edigits</td>
      <td><em>timeout</em></td>
      <td>1112ms</td>
      <td><em>Significantly</em> slower 🔻</td>
    </tr>
    <tr>
      <td>fasta</td>
      <td>769ms</td>
      <td>386ms</td>
      <td>2.0x slower 🔻</td>
    </tr>
    <tr>
      <td>helloworld</td>
      <td>1.5ms</td>
      <td>19ms</td>
      <td>12.7x faster ⬆️</td>
    </tr>
    <tr>
      <td>lru</td>
      <td>399ms</td>
      <td>187ms</td>
      <td>2.1x slower 🔻</td>
    </tr>
    <tr>
      <td>nbody</td>
      <td>988ms</td>
      <td>438ms</td>
      <td>2.3x slower 🔻</td>
    </tr>
    <tr>
      <td>nsieve</td>
      <td>509ms</td>
      <td>910ms</td>
      <td>1.8x faster ⬆️</td>
    </tr>
    <tr>
      <td>pidigits</td>
      <td>4672ms</td>
      <td><em>timeout</em></td>
      <td><em>Significantly</em> faster ⬆️</td>
    </tr>
    <tr>
      <td>spectral-norm</td>
      <td>4117ms</td>
      <td>2999ms</td>
      <td>1.4x slower 🔻</td>
    </tr>
  </tbody>
</table>

<p>This seems like a much more mixed result and so I think it would be fair to say V is more competitive with a language like C# or Java than C.</p>

<p>If V was closer with either of C or Rust, I’d be interested to investigate more deeply but as it stands, I think it’s safe to say:</p>

<p><em>Evaluation</em>: 🛑 V’s performance claims don’t seem to be valid</p>

<blockquote>
  <ul>
    <li>C interop without any costs</li>
  </ul>
</blockquote>

<p>V does not use greenthreads or segmented stacks for async programming which can lead to C interp being expensive.
V strings are essentially just wrappers over C strings and there are convenient and cheap functions to convert between them.
v functions are just regular functions so you can freely pass pointers to them into C and vice-versa.</p>

<p><em>Evaluation</em>: ✔️ Works as advertised</p>

<blockquote>
  <p>Minimal amount of allocations</p>
</blockquote>

<p>This seems like an inherently subjective claim to me that can’t be objectively evaluated (who decides which allocations are necessary and which aren’t?).</p>

<p>Coming from a C background, I’m <em>very</em> surprised to see that merely taking the address of a value causes it to be heap allocated:</p>

<pre><code>fn main() {
    x := 1
    y := &amp;x
}
</code></pre>

<div><div><pre><code><span>...</span>
<span>voidptr</span> <span>memdup</span><span>(</span><span>voidptr</span> <span>src</span><span>,</span> <span>int</span> <span>sz</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>sz</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>vcalloc</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>
    <span>{</span> <span>// Unsafe block</span>
        <span>u8</span><span>*</span> <span>mem</span> <span>=</span> <span>_v_malloc</span><span>(</span><span>sz</span><span>);</span>
        <span>return</span> <span>memcpy</span><span>(</span><span>mem</span><span>,</span> <span>src</span><span>,</span> <span>sz</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
<span>...</span>
<span>#define HEAP(type, expr) ((type*)memdup((void*)&amp;((type[]){expr}[0]), sizeof(type)))
</span><span>...</span>
<span>VV_LOCAL_SYMBOL</span> <span>void</span> <span>main__main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>int</span> <span>*</span><span>x</span> <span>=</span> <span>HEAP</span><span>(</span><span>int</span><span>,</span> <span>(</span><span>1</span><span>));</span>
    <span>int</span><span>*</span> <span>y</span> <span>=</span> <span>&amp;</span><span>(</span><span>*</span><span>(</span><span>x</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p>I would even argue this is clearly an <em>unnecessary</em> allocation which should not occur in a language that has a “minimal number of allocations”. 
As I said earlier though, this claim is inherently subjective.</p>

<p><em>Evaluation</em>: N/a (subjective claim)</p>

<blockquote>
  <ul>
    <li>Built-in serialization without runtime reflection</li>
  </ul>
</blockquote>

<p>According to the <a href="https://github.com/vlang/v/blob/master/doc/docs.md#json">docs</a>, “V generates code for JSON encoding and decoding. No runtime reflection is used.”</p>

<p>Let’s see what code is generated:</p>

<pre><code>import json

struct SerializeMe {
    field_one int
    field_two string
    field_three SomethingElse
}

struct SomethingElse {
    another_field bool
}

fn main() {
    x := SerializeMe { }
    json.encode(x)
}
</code></pre>

<div><div><pre><code><span>...</span>
<span>cJSON</span><span>*</span> <span>json__encode_main__SerializeMe</span><span>(</span><span>main__SerializeMe</span> <span>val</span><span>)</span> <span>{</span>
    <span>cJSON</span> <span>*</span><span>o</span><span>;</span>
    <span>o</span> <span>=</span> <span>cJSON_CreateObject</span><span>();</span>
    <span>cJSON_AddItemToObject</span><span>(</span><span>o</span><span>,</span> <span>&#34;field_one&#34;</span><span>,</span> <span>json__encode_int</span><span>(</span><span>val</span><span>.</span><span>field_one</span><span>));</span>

    <span>cJSON_AddItemToObject</span><span>(</span><span>o</span><span>,</span> <span>&#34;field_two&#34;</span><span>,</span> <span>json__encode_string</span><span>(</span><span>val</span><span>.</span><span>field_two</span><span>));</span>

    <span>cJSON_AddItemToObject</span><span>(</span><span>o</span><span>,</span> <span>&#34;field_three&#34;</span><span>,</span> <span>json__encode_main__SomethingElse</span><span>(</span><span>val</span><span>.</span><span>field_three</span><span>));</span>

    <span>return</span> <span>o</span><span>;</span>
<span>}</span>

<span>cJSON</span><span>*</span> <span>json__encode_main__SomethingElse</span><span>(</span><span>main__SomethingElse</span> <span>val</span><span>)</span> <span>{</span>
    <span>cJSON</span> <span>*</span><span>o</span><span>;</span>
    <span>o</span> <span>=</span> <span>cJSON_CreateObject</span><span>();</span>
    <span>cJSON_AddItemToObject</span><span>(</span><span>o</span><span>,</span> <span>&#34;another_field&#34;</span><span>,</span> <span>json__encode_bool</span><span>(</span><span>val</span><span>.</span><span>another_field</span><span>));</span>

    <span>return</span> <span>o</span><span>;</span>
<span>}</span>
<span>...</span>
</code></pre></div></div>

<p>Straightforward enough!
What’s <code>cJSON</code> though?</p>

<div><div><pre><code><span>...</span>
<span>#if defined(__has_include)
</span>
<span>#if __has_include(&#34;cJSON.h&#34;)
#include &#34;cJSON.h&#34;
#else
#error VERROR_MESSAGE Header file &#34;cJSON.h&#34;, needed for module `json` was not found. Please install the corresponding development headers.
#endif
</span>
<span>#else
#include &#34;cJSON.h&#34;
#endif
</span><span>...</span>
</code></pre></div></div>

<p>I don’t recall installing this library on my dev machine …
We’ll return to this in the next section.</p>

<p>As for this claim:</p>

<p><em>Evaluation</em>: ✔️ Works as advertised</p>

<blockquote>
  <ul>
    <li>Compiles to native binaries without any dependencies: a simple web server is only 65 KB</li>
  </ul>
</blockquote>

<p>There’s really two claims here and we’ll look at them both.</p>

<blockquote>
  <p>Compiles to native binaries without any dependencies</p>
</blockquote>

<p>Let’s look at the program <code>v run</code> made for us:</p>

<div><div><pre><code><span>$ </span>file ./run
./run: ELF 64-bit LSB executable, x86-64, version 1 <span>(</span>SYSV<span>)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, not stripped
<span>$ </span>ldd ./run
        linux-vdso.so.1 <span>(</span>0x00007ffd17dfa000<span>)</span>
        libc.so.6 <span>=&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span>(</span>0x00007f58a2988000<span>)</span>
        /lib64/ld-linux-x86-64.so.2 <span>(</span>0x00007f58a2b84000<span>)</span>
</code></pre></div></div>

<p>So our program is a native binary that links to the system’s libc and loader dynamically but has no other dependencies. 
Given that the claim was “without <em>any</em> dependencies”, I was expecting to see a statically linked binary but dynamically linking to libc is a reasonable choice and I can’t really fault V for that.</p>

<p>But wait, what was that <code>cJSON</code> business from the previous section?
Oh …</p>

<div><div><pre><code>$ tree -L 2 thirdparty/
thirdparty/
├── cJSON
│   ├── cJSON.c
│   ├── cJSON.h
│   └── readme.txt
├── fontstash
│   ├── fontstash.h
│   └── stb_truetype.h
├── ios
│   └── ios.m
├── libbacktrace
│   ├── amalgamation.txt
│   ├── backtrace.c
│   ├── backtrace.h
│   ├── base.c
│   ├── darwin.c
│   ├── linux.c
│   └── windows.c
├── libgc
│   ├── amalgamation.txt
│   ├── gc.c
│   └── include
├── mssql
│   └── include
├── picoev
│   ├── picoev.c
│   └── src
├── picohttpparser
│   ├── picohttpparser.c
│   ├── picohttpparser.h
│   └── src
├── sokol
│   ├── sokol_app.h
│   ├── sokol_app2.h
│   ├── sokol_audio.h
│   ├── sokol_gfx.h
│   ├── sokol_v.post.h
│   ├── sokol_v.pre.h
│   └── util
├── stb_image
│   ├── stb_image.h
│   ├── stb_image_write.h
│   ├── stb_v_header.h
│   └── stbi.c
├── stdatomic
│   ├── nix
│   └── win
├── tcc
│   ├── README.md
│   ├── include
│   ├── lib
│   ├── share
│   └── tcc.exe
├── vschannel
│   ├── vschannel.c
│   └── vschannel.h
├── walloc
│   └── walloc.c
└── zip
    ├── miniz.h
    ├── zip.c
    └── zip.h
33 directories, 85 files
</code></pre></div></div>

<p>So when V says “without any dependencies”, it seems like what they’re actually saying is “we’ve bundled the dependencies for you”.
This isn’t the worst thing (although, I’m sure Linux distros will love having to undo this if they ever decide they want to package V for some reason) but it hardly seems like V programs exist “without any dependencies”.</p>

<p>I would suggest that the V developers consider changing this claim to something more precise such as “Compiles to native binaries without additional runtime dependencies.”</p>

<p>Now, onto the other claim:</p>

<blockquote>
  <p>a simple web server is only 65 KB</p>
</blockquote>

<p>V comes with a builtin web server library called vweb which is tightly integrated into the compiler and standard library.
There’s also a “hello world” example using vweb in <a href="https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/examples/vweb"><code>examples/vweb</code></a>.
Let’s try compiling it and see what we get:</p>

<div><div><pre><code>$ cd examples/vweb
$ ../../v ./vweb_example.v
builder error: &#39;openssl/rand.h&#39; not found
</code></pre></div></div>

<p>I thought we were done talking about dependencies!
<em>Sigh</em></p>

<div><div><pre><code>$ sudo apt install libssl-dev
...
$ ../../v ./vweb_example.v
$ du -sh vweb_example
2.0M    vweb_example
</code></pre></div></div>

<p>Uh…
Maybe let’s try in prod mode which enables optimizations?</p>

<div><div><pre><code>$ ../../v -prod ./vweb_example.v
$ du -sh vweb_example
280K    vweb_example
</code></pre></div></div>

<p>Well, that’s quite a bit smaller but still over 4x larger than what was claimed.
Maybe we should try stripping it?</p>

<div><div><pre><code>$ strip vweb_example
$ du -sh vweb_example
264K    vweb_example
</code></pre></div></div>

<p>Not much difference.</p>

<p>Perhaps this example isn’t as minimal as it could be, but the code for the example fits on one screen.
It’s also possible the claim is referring to the most minimal web server possible: one which parses HTTP requests and does nothing with them.
Staking this claim on something so useless seems unreasonable though and I don’t feel particularly compelled to investigate that possibility further.</p>

<p><em>Evaluation</em>: ⚠️ V doesn’t seem to achieve the exact claims made at this time but there is some truth to the general ideas that V programs are relatively self-contained and small.</p>

<h3 id="fast-compilation">Fast compilation</h3>

<blockquote>
  <p>V compiles ≈110k (Clang backend) and ≈1 million (x64 and tcc backends) lines of code per second per CPU core.</p>
</blockquote>

<p>According to <a href="https://mawfig.github.io/2022/06/18/fast.vlang.io">Is V still fast</a>, V’s compiler benchmarking site, V currently compiles 207,972 “V lines/s” using tcc.
Even if we accept the note on the page that “typical desktop hardware is 2-3 times faster”, which seems <em>dubious</em> in a single-threaded benchmark, that still puts the compiler around 500,000 - 600,000 lines of V per second: half the claimed amount.</p>

<p>On a side note, why is the V benchmark being run on a <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html">burstable</a> AWS instance?
When measuring performance, especially wall clock time like is done here, it is critical you keep you keep your environment as stable as possible, especially CPU performance.
Serious performance investigations often go so far as to disable turboboosting, hyper threading, lock process affinity and <a href="https://easyperf.net/blog/2019/08/02/Perf-measurement-environment-on-Linux">other various tweaks</a> in an attempt to produce consistent results.
Given the incredibly noisy environment these tests are being run in, I’m not that surprised to see that the site seems to only trigger the green/red (faster/slower) indicators at changes of at least <strong>10%</strong>.</p>

<p>I’ll also try generating some 1,000,000 V programs locally and then time how long compiling them takes.
Since I’m using tcc, it should only take about 1 second to compile each program.</p>

<p>First up is “hello world - 1m” a basic program that contains 999,998 <code>println(&#39;hello world&#39;)</code> statements (so that the total line count including the main function declaration is 1,000,000 lines):</p>

<div><div><pre><code><span>#!/usr/bin/bash</span>
<span>echo</span> <span>&#39;fn main() {&#39;</span>
<span>for </span>i <span>in</span> <span>{</span>3..1000000<span>}</span>
<span>do
    </span><span>echo</span> <span>&#39;    println(&#34;hello world&#34;)&#39;</span>
<span>done
</span><span>echo</span> <span>&#39;}&#39;</span>
</code></pre></div></div>

<div><div><pre><code>$ ./t.sh &gt; 1m_helloworld.v
$ wc -l 1m_helloworld.v
1000000 1m_helloworld.v
$ time ./v 1m_helloworld.v
parsed 100000 statements so far from fn main.main ...
parsed 200000 statements so far from fn main.main ...
parsed 300000 statements so far from fn main.main ...
parsed 400000 statements so far from fn main.main ...
parsed 500000 statements so far from fn main.main ...
parsed 600000 statements so far from fn main.main ...
parsed 700000 statements so far from fn main.main ...
parsed 800000 statements so far from fn main.main ...
parsed 900000 statements so far from fn main.main ...

real    0m12.451s
user    0m11.158s
sys     0m1.236s
</code></pre></div></div>

<p>It was at this point I suspected that when I built the compiler, it wasn’t built with optimizations enabled by default.
A quick look at the <code>Makefile</code> confirmed this and a rebuild later:</p>

<div><div><pre><code>$ VFLAGS=&#34;-prod&#34; make
cd ./vc &amp;&amp; git clean -xf &amp;&amp; git pull --quiet
cd ./thirdparty/tcc &amp;&amp; git clean -xf &amp;&amp; git pull --quiet
cc  -std=gnu99 -w -o v1.exe ./vc/v.c -lm -lpthread
./v1.exe -no-parallel -o v2.exe -prod cmd/v
./v2.exe -o ./v -prod cmd/v
rm -rf v1.exe v2.exe
Note: building an optimized binary takes much longer. It shouldn&#39;t be used with `v run`.
Use `v run` without optimization, or build an optimized binary with -prod first, then run it separately.

Note: `tcc` was not used, so unless you install it yourself, your backend
C compiler will be `cc`, which is usually either `clang`, `gcc` or `msvc`.

These C compilers, are several times slower at compiling C source code,
compared to `tcc`. They do produce more optimised executables, but that
is done at the cost of compilation speed.

V has been successfully built
V 0.2.4 50ab2cf
</code></pre></div></div>

<p>The “Note” in the above is wrong in this case.
I confirmed via <code>strace</code> that my optimized version of <code>v</code> still invokes <code>tcc</code> and not <code>cc</code>.</p>

<p>With that out of the way:</p>

<div><div><pre><code>$ time ./v 1m_helloworld.v
parsed 100000 statements so far from fn main.main ...
parsed 200000 statements so far from fn main.main ...
parsed 300000 statements so far from fn main.main ...
parsed 400000 statements so far from fn main.main ...
parsed 500000 statements so far from fn main.main ...
parsed 600000 statements so far from fn main.main ...
parsed 700000 statements so far from fn main.main ...
parsed 800000 statements so far from fn main.main ...
parsed 900000 statements so far from fn main.main ...

real    0m7.158s
user    0m5.910s
sys     0m1.275s
</code></pre></div></div>

<p>So quite a bit faster (now at 169,205 lines/second), but not close to the 1 second time that was advertised.</p>

<p>For the record, my (quite old 😢) hardware is a i7-4770 with an SSD while the claim uses a i5-7500 with SSD.
A quick search shows these are <a href="https://cpu.userbenchmark.com/Compare/Intel-Core-i7-4770-vs-Intel-Core-i5-7500/1978vs3648">essentially equivalent to each other</a> or, at least, there isn’t a 7x performance difference between them.</p>

<p>Let’s try another test, this time we’ll generate 499,999 empty functions and an empty main function for a total of 1,000,000 lines:</p>

<div><div><pre><code><span>#!/usr/bin/bash</span>
<span>echo</span> <span>&#39;fn main() {&#39;</span>
<span>echo</span> <span>&#39;}&#39;</span>
<span>for </span>i <span>in</span> <span>{</span>0..499998<span>}</span>
<span>do
        </span><span>echo</span> <span>&#34;fn my_func</span><span>${</span><span>i</span><span>}</span><span>() {&#34;</span>
        <span>echo</span> <span>&#39;}&#39;</span>
<span>done</span>
</code></pre></div></div>

<div><div><pre><code>$ ./t.sh &gt; 1m_funcs.v
$ wc -l 1m_funcs.v
1000000 1m_funcs.v
$ time ./v 1m_funcs.v

real    0m3.686s
user    0m2.587s
sys     0m1.105s
</code></pre></div></div>

<p>Quite a bit faster (386,548 lines/second) but still 2.5x slower than claimed.</p>

<p>Let’s try one more test in which we’ll create a sum type and a function to print an argument of that type:</p>

<div><div><pre><code><span>#!/usr/bin/bash</span>
<span>for </span>i <span>in</span> <span>{</span>3..65000<span>}</span>
<span>do
        </span><span>echo</span> <span>&#34;type Foo</span><span>${</span><span>i</span><span>}</span><span> = i64 | byte | string&#34;</span>
        <span>echo</span> <span>&#34;fn my_func</span><span>${</span><span>i</span><span>}</span><span>(x Foo</span><span>${</span><span>i</span><span>}</span><span>) {&#34;</span>
        <span>echo</span> <span>&#34;    println(x)&#34;</span>
        <span>echo</span> <span>&#34;}&#34;</span>
<span>done
</span><span>echo</span> <span>&#39;fn main() {&#39;</span>
<span>echo</span> <span>&#39;}&#39;</span>
</code></pre></div></div>

<p>Wait, why are we only looping to <code>65000</code> and not <code>1000000</code>?
The V compiler ICEs if you have more than <code>2^16 - 1</code> types in it:</p>

<div><div><pre><code>$ time ./v 1m_types_and_funcs.v
V panic: new_type: idx must be between 1 &amp; 65535
v hash: 50ab2cf
    | 0x55896206ca8e | ./v(+0x7ea8e)
    | 0x55896207a449 | ./v(+0x8c449)
    | 0x5589620805d0 | ./v(+0x925d0)
    | 0x558962083f64 | ./v(+0x95f64)
    | 0x558962075bbb | ./v(+0x87bbb)
    | 0x558962079533 | ./v(+0x8b533)
    | 0x558962029e15 | ./v(+0x3be15)
    | 0x55896202e1b4 | ./v(+0x401b4)
    | 0x558961ff059e | ./v(+0x259e)
    | 0x7fc805ff40b3 | /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf3)
    | 0x558961ff05de | ./v(+0x25de)
</code></pre></div></div>

<p>Therefore, after adjusting the test case to account for that, we get this:</p>

<div><div><pre><code>$ ./t.sh &gt; 1m_types_and_funcs.v
$ wc -l 1m_types_and_funcs.v
259994 1m_types_and_funcs.v
$ time ./v 1m_types_and_funcs.v

real    0m46.592s
user    0m45.574s
sys     0m1.030s
</code></pre></div></div>

<p>Aka 5,705 lines/second.</p>

<p>Measuring compiler throughput in “lines per second” is completely useless because it matters so much <em>what</em> those lines are.
As we’ve seen, by changing the programs we fed to V, we got anywhere from just under 400,000 lines per second to less than 6,000 lines per second.</p>

<p><em>Evaluation</em>: 🛑 The V compiler does not come close to the claimed level of performance.</p>

<blockquote>
  <p>V is written in V and compiles itself in under a second.</p>
</blockquote>

<p>V is most certainly written in V, so that is accurate!</p>

<p>Let’s change their <code>Makefile</code> to include timings:</p>

<div><div><pre><code><span>diff --git a/GNUmakefile b/GNUmakefile
index aab552aa1..e81520924 100644
</span><span>--- a/GNUmakefile
</span><span>+++ b/GNUmakefile
</span><span>@@ -91,8 +91,8 @@</span> ifdef WIN32
        del v2.exe
 else
        $(CC) $(CFLAGS) -std=gnu99 -w -o v1.exe $(VC)/$(VCFILE) -lm -lpthread $(LDFLAGS)
<span>-       ./v1.exe -no-parallel -o v2.exe $(VFLAGS) cmd/v
-       ./v2.exe -o $(V) $(VFLAGS) cmd/v
</span><span>+       bash -c &#39;time ./v1.exe -no-parallel -o v2.exe $(VFLAGS) cmd/v&#39;
+       bash -c &#39;time ./v2.exe -o $(V) $(VFLAGS) cmd/v&#39;
</span>        rm -rf v1.exe v2.exe
 endif
        @$(V) run cmd/tools/detect_tcc.v
</code></pre></div></div>

<div><div><pre><code>$ make
cd ./vc &amp;&amp; git clean -xf &amp;&amp; git pull --quiet
cd ./thirdparty/tcc &amp;&amp; git clean -xf &amp;&amp; git pull --quiet
cc  -std=gnu99 -w -o v1.exe ./vc/v.c -lm -lpthread
bash -c &#39;time ./v1.exe -no-parallel -o v2.exe  cmd/v&#39;

real    0m0.955s
user    0m0.885s
sys     0m0.070s
bash -c &#39;time ./v2.exe -o ./v  cmd/v&#39;

real    0m1.029s
user    0m1.338s
sys     0m0.067s
rm -rf v1.exe v2.exe
Your `tcc` is working. Good - it is much faster at compiling C source code.
V has been successfully built
V 0.2.4 50ab2cf
</code></pre></div></div>

<p>So a stage 2 compiler builds in ~1 second and so does a stage 3 compiler.
Excellent!</p>

<p><em>Evaluation</em>: ✔️ Works as advertised</p>

<h3 id="innovative-memory-management">Innovative memory management</h3>

<p>I’m not even sure how to approach this topic.
There are a ton of claims made in this section and I can’t really figure out what the basis for these claims is.</p>

<p>Let’s start with the example given in <a href="https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md#examples">the docs</a>:</p>

<pre><code>import strings

fn draw_text(s string, x int, y int) {
	// ...
}

fn draw_scene() {
	// ...
	name1 := &#39;abc&#39;
	name2 := &#39;def ghi&#39;
	draw_text(&#39;hello $name1&#39;, 10, 10)
	draw_text(&#39;hello $name2&#39;, 100, 10)
	draw_text(strings.repeat(`X`, 10000), 10, 50)
	// ...
}
</code></pre>

<blockquote>
  <p>The strings don’t escape draw_text, so they are cleaned up when the function exits.</p>
</blockquote>

<p>While this is true, it’s not clear <em>how</em> the compiler knows this.
The types don’t include “does escape”/”does not escape” information so we must deduce that the compiler performs an analysis of the body of <code>draw_text</code> to determine if the values escape or not.
We’ll modify <code>draw_text</code> in a minute to see if we can determine how this analysis works but right now, let’s compile this with autofree enabled and see if any memory is leaked:</p>

<p>(Note, the docs say “Autofree is still WIP” but this <em>really</em> should be mentioned on the feature list)</p>

<div><div><pre><code>$ ./v -autofree autofree_example.v
$ valgrind --leak-check=full ./autofree_example
==2183== Memcheck, a memory error detector
==2183== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.
==2183== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==2183== Command: ./autofree_example
==2183==
==2183==
==2183== HEAP SUMMARY:
==2183==     in use at exit: 0 bytes in 0 blocks
==2183==   total heap usage: 18 allocs, 18 frees, 17,240 bytes allocated
==2183==
==2183== All heap blocks were freed -- no leaks are possible
==2183==
==2183== For lists of detected and suppressed errors, rerun with: -s
==2183== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre></div></div>

<p>Ok, so far so good!
However, I’m not sure that these strings are actually being heap allocated.
The docs also say “V tries to put objects on the stack if possible” so let’s see if we can force a heap allocation by creating a <code>[heap]</code> struct instead:</p>

<pre><code>[heap]
struct MyHeapValue {
    value i64
}

fn draw_text(value MyHeapValue) {
}

fn main() {
    // ...
    arg1 := MyHeapValue { 42 }
    arg2 := MyHeapValue { 100 }
    draw_text(arg1)
    draw_text(arg2)
    // ...
}
</code></pre>

<div><div><pre><code>$ ./v -autofree autofree_example.v
$ valgrind --leak-check=full ./autofree_example
==2312== Memcheck, a memory error detector
==2312== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.
==2312== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==2312== Command: ./autofree_example
==2312==
==2312==
==2312== HEAP SUMMARY:
==2312==     in use at exit: 32 bytes in 4 blocks
==2312==   total heap usage: 22 allocs, 18 frees, 17,272 bytes allocated
==2312==
==2312== 8 bytes in 1 blocks are definitely lost in loss record 1 of 4
==2312==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==2312==    by 0x41B3AE: _v_malloc (in /tmp/v/autofree_example)
==2312==    by 0x41C095: memdup (in /tmp/v/autofree_example)
==2312==    by 0x435070: main__main (in /tmp/v/autofree_example)
==2312==    by 0x4472C4: main (in /tmp/v/autofree_example)
==2312==
==2312== 8 bytes in 1 blocks are definitely lost in loss record 2 of 4
==2312==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==2312==    by 0x41B3AE: _v_malloc (in /tmp/v/autofree_example)
==2312==    by 0x41C095: memdup (in /tmp/v/autofree_example)
==2312==    by 0x4350B9: main__main (in /tmp/v/autofree_example)
==2312==    by 0x4472C4: main (in /tmp/v/autofree_example)
==2312==
==2312== 8 bytes in 1 blocks are definitely lost in loss record 3 of 4
==2312==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==2312==    by 0x41B3AE: _v_malloc (in /tmp/v/autofree_example)
==2312==    by 0x41C095: memdup (in /tmp/v/autofree_example)
==2312==    by 0x43501A: main__draw_text (in /tmp/v/autofree_example)
==2312==    by 0x4350D4: main__main (in /tmp/v/autofree_example)
==2312==    by 0x4472C4: main (in /tmp/v/autofree_example)
==2312==
==2312== 8 bytes in 1 blocks are definitely lost in loss record 4 of 4
==2312==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==2312==    by 0x41B3AE: _v_malloc (in /tmp/v/autofree_example)
==2312==    by 0x41C095: memdup (in /tmp/v/autofree_example)
==2312==    by 0x43501A: main__draw_text (in /tmp/v/autofree_example)
==2312==    by 0x4350EB: main__main (in /tmp/v/autofree_example)
==2312==    by 0x4472C4: main (in /tmp/v/autofree_example)
==2312==
==2312== LEAK SUMMARY:
==2312==    definitely lost: 32 bytes in 4 blocks
==2312==    indirectly lost: 0 bytes in 0 blocks
==2312==      possibly lost: 0 bytes in 0 blocks
==2312==    still reachable: 0 bytes in 0 blocks
==2312==         suppressed: 0 bytes in 0 blocks
==2312==
==2312== For lists of detected and suppressed errors, rerun with: -s
==2312== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
</code></pre></div></div>

<p>So forcing the value to be allocated on the heap reveals that autofree leaks the values.
That doesn’t really inspire confidence in the “most objects (~90-100%) are freed by V’s autofree engine” claim.</p>

<p>It’s interesting though that we see 4 leaks for only 2 values.
What is <code>main__draw_text</code> doing that causes the additional leaks?</p>

<div><div><pre><code><span>...</span>
<span>#define HEAP(type, expr) ((type*)memdup((void*)&amp;((type[]){expr}[0]), sizeof(type)))
</span><span>...</span>
<span>VV_LOCAL_SYMBOL</span> <span>void</span> <span>main__draw_text</span><span>(</span><span>main__MyHeapValue</span> <span>_v_toheap_value</span><span>)</span> <span>{</span>
<span>main__MyHeapValue</span><span>*</span> <span>value</span> <span>=</span> <span>HEAP</span><span>(</span><span>main__MyHeapValue</span><span>,</span> <span>_v_toheap_value</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>So even though the parameter is completely unused, V still heap allocates a copy of it for no reason?
What happened to “no unnecessary allocations”?</p>

<p>I’m starting to suspect that there isn’t some complex compiler pass that works for strings but fails on a heap allocated integer and the reason we’re not seeing leaks when using strings has something to do with the string implementation.</p>

<p>Let’s take a look at the <a href="https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/vlib/builtin/string.v#L44">string implementation</a>:</p>

<pre><code>pub struct string {
pub:
	str &amp;u8 = 0 // points to a C style 0 terminated string of bytes.
	len int // the length of the .str field, excluding the ending 0 byte. It is always equal to strlen(.str).
	// NB string.is_lit is an enumeration of the following:
	// .is_lit == 0 =&gt; a fresh string, should be freed by autofree
	// .is_lit == 1 =&gt; a literal string from .rodata, should NOT be freed
	// .is_lit == -98761234 =&gt; already freed string, protects against double frees.
	// ---------&gt; ^^^^^^^^^ calling free on these is a bug.
	// Any other value means that the string has been corrupted.
mut:
	is_lit int
}
</code></pre>

<p>So, it looks like string literals are special cased to never have free called on them.
What happens if we take the original program but clone the strings?</p>

<pre><code>import strings

fn draw_text(s string, x int, y int) {
}

fn main() {
        name1 := &#39;abc&#39;.str()
        name2 := &#39;def ghi&#39;.str()
        draw_text(&#39;hello $name1&#39;.str(), 10, 10)
        draw_text(&#39;hello $name2&#39;.str(), 100, 10)
        draw_text(strings.repeat(`X`, 10000).str(), 10, 50)
}
</code></pre>

<div><div><pre><code>$ ./v -autofree autofree_example.v
$ valgrind --leak-check=full ./autofree_example
==2723== Memcheck, a memory error detector
==2723== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.
==2723== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==2723== Command: ./autofree_example
==2723==
==2723==
==2723== HEAP SUMMARY:
==2723==     in use at exit: 10,025 bytes in 3 blocks
==2723==   total heap usage: 30 allocs, 27 frees, 37,826 bytes allocated
==2723==
==2723== 10 bytes in 1 blocks are definitely lost in loss record 1 of 3
==2723==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==2723==    by 0x41B732: malloc_noscan (in /tmp/v/autofree_example)
==2723==    by 0x41C113: memdup_noscan (in /tmp/v/autofree_example)
==2723==    by 0x402D7C: strings__Builder_str (in /tmp/v/autofree_example)
==2723==    by 0x432D31: str_intp (in /tmp/v/autofree_example)
==2723==    by 0x435224: main__main (in /tmp/v/autofree_example)
==2723==    by 0x44776E: main (in /tmp/v/autofree_example)
==2723==
==2723== 14 bytes in 1 blocks are definitely lost in loss record 2 of 3
==2723==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==2723==    by 0x41B732: malloc_noscan (in /tmp/v/autofree_example)
==2723==    by 0x41C113: memdup_noscan (in /tmp/v/autofree_example)
==2723==    by 0x402D7C: strings__Builder_str (in /tmp/v/autofree_example)
==2723==    by 0x432D31: str_intp (in /tmp/v/autofree_example)
==2723==    by 0x435424: main__main (in /tmp/v/autofree_example)
==2723==    by 0x44776E: main (in /tmp/v/autofree_example)
==2723==
==2723== 10,001 bytes in 1 blocks are definitely lost in loss record 3 of 3
==2723==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==2723==    by 0x41B732: malloc_noscan (in /tmp/v/autofree_example)
==2723==    by 0x403D19: strings__repeat (in /tmp/v/autofree_example)
==2723==    by 0x4354C6: main__main (in /tmp/v/autofree_example)
==2723==    by 0x44776E: main (in /tmp/v/autofree_example)
==2723==
==2723== LEAK SUMMARY:
==2723==    definitely lost: 10,025 bytes in 3 blocks
==2723==    indirectly lost: 0 bytes in 0 blocks
==2723==      possibly lost: 0 bytes in 0 blocks
==2723==    still reachable: 0 bytes in 0 blocks
==2723==         suppressed: 0 bytes in 0 blocks
==2723==
==2723== For lists of detected and suppressed errors, rerun with: -s
==2723== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
</code></pre></div></div>

<blockquote>
  <p>The strings don’t escape draw_text, so they are cleaned up when the function exits.</p>
</blockquote>

<p>So the docs are completely wrong, there’s no analysis being performed to determine when the function arguments escape and when they don’t and the compiler isn’t inserting cleanups (calls to <code>free</code>).
There’s no leaks because there are no heap allocations and introducing heap allocations immediately causes memory to be leaked.</p>

<p>Let’s see if we can figure out <em>what</em> the compiler actually does.</p>

<h4 id="is-there-an-escape-analysis">Is there an escape analysis?</h4>

<p>The compiler source code is located in <a href="https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/vlib/v"><code>vlib/v</code></a>.</p>

<p>Grepping for “escape” shows 166 results, all of which are related to parsing or printing special (escape) characters in strings or paths.</p>

<p>I don’t think there is any escape analysis in the V compiler.</p>

<h4 id="is-there-a-lifetime-analysis">Is there a lifetime analysis?</h4>

<p>Some of the documentation <a href="https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md#vs-default-approach">implies</a> there might be some kind of lifetime analysis that decides whether to stack or heap allocate variables.</p>

<p>Grepping for “lifetime” returns no results.
“live” leads us to an attribute called <code>[keep_args_alive]</code> which only has an effect in GC’d binaries.
No other instances of “live” are related to a lifetime analysis.</p>

<p>I can’t find any lifetime analysis in the V compiler.</p>

<h4 id="so-what-does--autofree-actually-do">So what does <code>-autofree</code> actually do?</h4>

<p>It’s very unclear to me.
<a href="https://github.com/vlang/v/issues/1247">“Reference counting, mut parameters and memory safety”</a> seems to be the most detailed discussion I can find in GitHub and even it is sparse on details.</p>

<p>Looking through the various references to “autofree” in the <a href="https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/vlib/v/gen/c">gen</a> phase of the compiler, it seems like autofree is an <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII-like</a> scheme.</p>

<p>The current implementation lacks any kind of detailed analysis that would make it safe to elide these unnecessary copies/clones.
There does not appear to by any fallback code which would insert reference counting or garbage collection either.
At least as it is presently, autofree does not seem to be particularly innovative in any way.</p>

<p><em>Evaluation</em>: 🛑 V’s claims are not well supported and the existing implementation cannot be described as “innovative”.</p>

<h2 id="summary">Summary</h2>

<p>To consolidate the above into one table:</p>

<table>
  <thead>
    <tr>
      <th>Area</th>
      <th>Rating</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Simple language for building maintainable programs</strong></td>
      <td>N/a</td>
      <td>Subjective claim.</td>
    </tr>
    <tr>
      <td><strong>Safety</strong></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&gt; No null</td>
      <td>🛑</td>
      <td>We’re able to create a null pointer (V reference) with no compiler errors or warnings.</td>
    </tr>
    <tr>
      <td>&gt; No undefined values</td>
      <td>🛑</td>
      <td>We could read uninitialized memory without compiler error or warnings.</td>
    </tr>
    <tr>
      <td>&gt; No undefined behavior</td>
      <td>🛑</td>
      <td>The V compiler didn’t stop us from creating three different forms of UB.</td>
    </tr>
    <tr>
      <td>&gt; No variable shadowing</td>
      <td>✔️</td>
      <td>We weren’t able to shadow local variables.</td>
    </tr>
    <tr>
      <td>&gt; Bounds checking</td>
      <td>⚠️</td>
      <td>Some basic checking exists but can be trivially bypassed.</td>
    </tr>
    <tr>
      <td>&gt; Immutable variables by default</td>
      <td>🛑</td>
      <td>Variables aren’t immutable in any significant way because you can trivially turn an immutable reference into a mutable one.</td>
    </tr>
    <tr>
      <td>&gt; Pure functions by default</td>
      <td>🛑</td>
      <td>Claim is meaningless as it redefines “pure” to mean “impure”.</td>
    </tr>
    <tr>
      <td>&gt; Immutable structs by default</td>
      <td>🛑</td>
      <td>Immutability can be by-passed trivially.</td>
    </tr>
    <tr>
      <td>&gt; Option/Result and mandatory error checks</td>
      <td>✔️</td>
      <td>Works as advertised.</td>
    </tr>
    <tr>
      <td>&gt; Sum types</td>
      <td>⚠️</td>
      <td>Sum types generally seem to work but there are implementation issues.</td>
    </tr>
    <tr>
      <td>&gt; Generics</td>
      <td>🛑</td>
      <td>A basic implementation exists but is very buggy and seems completely out of place in a language with an self described emphasis on safety and compiler performance.</td>
    </tr>
    <tr>
      <td>&gt; No global variables</td>
      <td>🛑</td>
      <td>V does not prevent you from creating and mutating globally shared state in any meaningful way.</td>
    </tr>
    <tr>
      <td><strong>Performance</strong></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&gt; As fast as C (V’s main backend compiles to human readable C)</td>
      <td>🛑</td>
      <td>V’s performance claims don’t seem to be valid.</td>
    </tr>
    <tr>
      <td>&gt; C interop without any costs</td>
      <td>✔️</td>
      <td>Works as advertised.</td>
    </tr>
    <tr>
      <td>&gt; Minimal amount of allocations</td>
      <td>N/a</td>
      <td>Subjective claim.</td>
    </tr>
    <tr>
      <td>&gt; Built-in serialization without runtime reflection</td>
      <td>✔️</td>
      <td>Works as advertised.</td>
    </tr>
    <tr>
      <td>&gt; Compiles to native binaries without any dependencies</td>
      <td>⚠️</td>
      <td>V doesn’t seem to achieve the exact claims made at this time but there is some truth to the general ideas that V programs are relatively self-contained and small.</td>
    </tr>
    <tr>
      <td><strong>Fast Compilation</strong></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&gt; V compiles ≈1 million lines of code per second per CPU core</td>
      <td>🛑</td>
      <td>The V compiler does not come close to the claimed level of performance.</td>
    </tr>
    <tr>
      <td>&gt; V is written in V and compiles itself in under a second</td>
      <td>✔️</td>
      <td>Works as advertised.</td>
    </tr>
    <tr>
      <td><strong>Innovative memory management</strong></td>
      <td>🛑</td>
      <td>V’s claims are not well supported and the existing implementation cannot be described as “innovative”.</td>
    </tr>
  </tbody>
</table>

<p>At this time, I would <strong>not</strong> recommend spending time on V.
I would also be very cautious when taking claims made by the authors at face value.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
