<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/">Original</a>
    <h1>Let&#39;s code a TCP/IP stack, 1: Ethernet and ARP (2016)</h1>
    
    <div id="readability-page-1" class="page"><div>

  

  <article>
    <p>Writing your own TCP/IP stack may seem like a daunting task. Indeed, TCP has accumulated many specifications over its lifetime of more than thirty years. The core specification, however, is seemingly compact<sup id="fnref:tcp-roadmap" role="doc-noteref"><a href="#fn:tcp-roadmap">1</a></sup> - the important parts being TCP header parsing, the state machine, congestion control and retransmission timeout computation.</p>

<p>The most common layer 2 and layer 3 protocols, Ethernet and IP respectively, pale in comparison to TCP’s complexity. In this blog series, we will implement a minimal userspace TCP/IP stack for Linux.</p>

<p>The purpose of these posts and the resulting software is purely educational - to learn network and system programming at a deeper level.</p>



<ul id="markdown-toc">
  <li><a href="#tuntap-devices" id="markdown-toc-tuntap-devices">TUN/TAP devices</a></li>
  <li><a href="#ethernet-frame-format" id="markdown-toc-ethernet-frame-format">Ethernet Frame Format</a></li>
  <li><a href="#ethernet-frame-parsing" id="markdown-toc-ethernet-frame-parsing">Ethernet Frame Parsing</a></li>
  <li><a href="#address-resolution-protocol" id="markdown-toc-address-resolution-protocol">Address Resolution Protocol</a></li>
  <li><a href="#address-resolution-algorithm" id="markdown-toc-address-resolution-algorithm">Address Resolution Algorithm</a></li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
  <li><a href="#sources" id="markdown-toc-sources">Sources</a></li>
</ul>



<p>To intercept low-level network traffic from the Linux kernel, we will use a Linux TAP device. In short, a TUN/TAP device is often used by networking userspace applications to manipulate L3/L2 traffic, respectively. A popular example is <a href="https://www.saminiir.com/openvpn-puts-packets-inside-your-packets/#tunneling">tunneling</a>, where a packet is wrapped inside the payload of another packet.</p>

<p>The advantage of TUN/TAP devices is that they’re easy to set up in a userspace program and they are already being used in a multitude of programs, such as <a href="https://www.saminiir.com/openvpn-puts-packets-inside-your-packets/">OpenVPN</a>.</p>

<p>As we want to build the networking stack from the layer 2 up, we need a TAP device. We instantiate it like so:</p>

<figure><pre><code data-lang="c"><span>/*
 * Taken from Kernel Documentation/networking/tuntap.txt
 */</span>
<span>int</span> <span>tun_alloc</span><span>(</span><span>char</span> <span>*</span><span>dev</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>ifreq</span> <span>ifr</span><span>;</span>
    <span>int</span> <span>fd</span><span>,</span> <span>err</span><span>;</span>

    <span>if</span><span>(</span> <span>(</span><span>fd</span> <span>=</span> <span>open</span><span>(</span><span>&#34;/dev/net/tap&#34;</span><span>,</span> <span>O_RDWR</span><span>))</span> <span>&lt;</span> <span>0</span> <span>)</span> <span>{</span>
        <span>print_error</span><span>(</span><span>&#34;Cannot open TUN/TAP dev&#34;</span><span>);</span>
        <span>exit</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>

    <span>CLEAR</span><span>(</span><span>ifr</span><span>);</span>

    <span>/* Flags: IFF_TUN   - TUN device (no Ethernet headers)
     *        IFF_TAP   - TAP device
     *
     *        IFF_NO_PI - Do not provide packet information
     */</span>
    <span>ifr</span><span>.</span><span>ifr_flags</span> <span>=</span> <span>IFF_TAP</span> <span>|</span> <span>IFF_NO_PI</span><span>;</span>
    <span>if</span><span>(</span> <span>*</span><span>dev</span> <span>)</span> <span>{</span>
        <span>strncpy</span><span>(</span><span>ifr</span><span>.</span><span>ifr_name</span><span>,</span> <span>dev</span><span>,</span> <span>IFNAMSIZ</span><span>);</span>
    <span>}</span>

    <span>if</span><span>(</span> <span>(</span><span>err</span> <span>=</span> <span>ioctl</span><span>(</span><span>fd</span><span>,</span> <span>TUNSETIFF</span><span>,</span> <span>(</span><span>void</span> <span>*</span><span>)</span> <span>&amp;</span><span>ifr</span><span>))</span> <span>&lt;</span> <span>0</span> <span>){</span>
        <span>print_error</span><span>(</span><span>&#34;ERR: Could not ioctl tun: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>strerror</span><span>(</span><span>errno</span><span>));</span>
        <span>close</span><span>(</span><span>fd</span><span>);</span>
        <span>return</span> <span>err</span><span>;</span>
    <span>}</span>

    <span>strcpy</span><span>(</span><span>dev</span><span>,</span> <span>ifr</span><span>.</span><span>ifr_name</span><span>);</span>
    <span>return</span> <span>fd</span><span>;</span>
<span>}</span></code></pre></figure>

<p>After this, the returned file descriptor <code>fd</code> can be used to <code>read</code> and <code>write</code> data to the virtual device’s ethernet buffer.</p>

<p>The flag <code>IFF_NO_PI</code> is crucial here, otherwise we end up with unnecessary packet information prepended to the Ethernet frame. You can actually take a look at the kernel’s <a href="https://github.com/torvalds/linux/blob/v4.4/drivers/net/tun.c#L1306">source code</a> of the tun-device driver and verify this yourself.</p>



<p>The multitude of different Ethernet networking technologies are the backbone of connecting computers in <em>Local Area Networks</em> (LANs). As with all physical technology, the Ethernet standard has greatly evolved from its first version<sup id="fnref:ethernet" role="doc-noteref"><a href="#fn:ethernet">2</a></sup>, published by Digital Equipment Corporation, Intel and Xerox in 1980.</p>

<p>The first version of Ethernet was slow in today’s standards - about 10Mb/s and it utilized half-duplex communication, meaning that you either sent or received data, but not at the same time. This is why a <em>Media Access Control</em> (MAC) protocol had to be incorporated to organize the data flow. Even to this day, <em>Carrier Sense, Multiple Access with Collision Detection</em> (CSMA/CD) is required as the MAC method if running an Ethernet interface in half-duplex mode.</p>

<p>The invention of the <em>100BASE-T</em> Ethernet standard used twisted-pair wiring to enable full-duplex communication and higher throughput speeds. Additionally, the simultaneous increase in popularity of Ethernet switches made CSMA/CD largely obsolete.</p>

<p>The different Ethernet standards are maintained by the IEEE 802.3<sup id="fnref:ieee-802-3" role="doc-noteref"><a href="#fn:ieee-802-3">3</a></sup> working group.</p>

<p>Next, we’ll take a look at the Ethernet Frame header. It can be declared as a C struct followingly:</p>

<figure><pre><code data-lang="c"><span>#include &lt;linux/if_ether.h&gt;
</span>
<span>struct</span> <span>eth_hdr</span>
<span>{</span>
    <span>unsigned</span> <span>char</span> <span>dmac</span><span>[</span><span>6</span><span>];</span>
    <span>unsigned</span> <span>char</span> <span>smac</span><span>[</span><span>6</span><span>];</span>
    <span>uint16_t</span> <span>ethertype</span><span>;</span>
    <span>unsigned</span> <span>char</span> <span>payload</span><span>[];</span>
<span>}</span> <span>__attribute__</span><span>((</span><span>packed</span><span>));</span></code></pre></figure>

<p>The <code>dmac</code> and <code>smac</code> are pretty self-explanatory fields. They contain the MAC addresses of the communicating parties (destination and source, respectively).</p>

<p>The overloaded field, <code>ethertype</code>, is a 2-octet field, that depending on its value, either indicates the length or the type of the payload. Specifically, if the field’s value is greater or equal to 1536, the field contains the type of the payload (e.g. IPv4, ARP). If the value is less than that, it contains the length of the payload.</p>

<p>After the type field, there is a possibility of several different <em>tags</em> for the Ethernet frame. These tags can be used to describe the <em>Virtual LAN</em> (VLAN) or the <em>Quality of Service</em> (QoS) type of the frame. Ethernet frame tags are excluded from our implementation, so the corresponding field also does not show up in our protocol declaration.</p>

<p>The field <code>payload</code> contains a pointer to the Ethernet frame’s payload. In our case, this will contain an ARP or IPv4 packet. If the payload length is smaller than the minimum required 48 bytes (without tags), pad bytes are appended to the end of the payload to meet the requirement.</p>

<p>We also include the <code>if_ether.h</code> Linux header to provide a mapping between ethertypes and their hexadecimal values.</p>

<p>Lastly, the Ethernet Frame Format also includes the <em>Frame Check Sequence</em> field in the end, which is used with <em>Cyclic Redundancy Check</em> (CRC) to check the integrity of the frame. We will omit the handling of this field in our implementation.</p>



<p>The attribute <em>packed</em> in a struct’s declaration is an implementation detail - It is used to instruct the GNU C compiler not to optimize the struct memory layout for data alignment with padding bytes<sup id="fnref:gnu-c-packed" role="doc-noteref"><a href="#fn:gnu-c-packed">4</a></sup>. The use of this attribute stems purely out of the way we are “parsing” the protocol buffer, which is just a type cast over the data buffer with the proper protocol struct:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>eth_hdr</span> <span>*</span><span>hdr</span> <span>=</span> <span>(</span><span>struct</span> <span>eth_hdr</span> <span>*</span><span>)</span> <span>buf</span><span>;</span></code></pre></figure>

<p>A portable, albeit slightly more laborious approach, would be to serialize the protocol data manually. This way, the compiler is free to add padding bytes to conform better to different processor’s data alignment requirements.</p>

<p>The overall scenario for parsing and handling incoming Ethernet frames is straightforward:</p>

<figure><pre><code data-lang="c"><span>if</span> <span>(</span><span>tun_read</span><span>(</span><span>buf</span><span>,</span> <span>BUFLEN</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>print_error</span><span>(</span><span>&#34;ERR: Read from tun_fd: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>strerror</span><span>(</span><span>errno</span><span>));</span>
<span>}</span>

<span>struct</span> <span>eth_hdr</span> <span>*</span><span>hdr</span> <span>=</span> <span>init_eth_hdr</span><span>(</span><span>buf</span><span>);</span>

<span>handle_frame</span><span>(</span><span>&amp;</span><span>netdev</span><span>,</span> <span>hdr</span><span>);</span></code></pre></figure>

<p>The <code>handle_frame</code> function just looks at the <code>ethertype</code> field of the Ethernet header, and decides its next action based upon the value.</p>



<p>The <em>Address Resolution Protocol</em> (ARP) is used for dynamically mapping a 48-bit Ethernet address (MAC address) to a protocol address (e.g. IPv4 address). The key here is that with ARP, multitude of different L3 protocols can be used: Not just IPv4, but other protocols like CHAOS, which declares 16-bit protocol addresses.</p>

<p>The usual case is that you know the IP address of some service in your LAN, but to establish actual communications, also the hardware address (MAC) needs to be known. Hence, ARP is used to broadcast and query the network, asking the owner of the IP address to report its hardware address.</p>

<p>The ARP packet format is relatively straightforward:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>arp_hdr</span>
<span>{</span>
    <span>uint16_t</span> <span>hwtype</span><span>;</span>
    <span>uint16_t</span> <span>protype</span><span>;</span>
    <span>unsigned</span> <span>char</span> <span>hwsize</span><span>;</span>
    <span>unsigned</span> <span>char</span> <span>prosize</span><span>;</span>
    <span>uint16_t</span> <span>opcode</span><span>;</span>
    <span>unsigned</span> <span>char</span> <span>data</span><span>[];</span>
<span>}</span> <span>__attribute__</span><span>((</span><span>packed</span><span>));</span></code></pre></figure>

<p>The ARP header (<code>arp_hdr</code>) contains the 2-octet <code>hwtype</code>, which determines the link layer type used. This is Ethernet in our case, and the actual value is <code>0x0001</code>.</p>

<p>The 2-octet <code>protype</code> field indicates the protocol type. In our case, this is IPv4, which is communicated with the value <code>0x0800</code>.</p>

<p>The <code>hwsize</code> and <code>prosize</code> fields are both 1-octet in size, and they contain the sizes of the hardware and protocol fields, respectively. In our case, these would be 6 bytes for MAC addresses, and 4 bytes for IP addresses.</p>

<p>The 2-octet field <code>opcode</code> declares the type of the ARP message. It can be ARP request (1), ARP reply (2), RARP request (3) or RARP reply (4).</p>

<p>The <code>data</code> field contains the actual payload of the ARP message, and in our case, this will contain IPv4 specific information:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>arp_ipv4</span>
<span>{</span>
    <span>unsigned</span> <span>char</span> <span>smac</span><span>[</span><span>6</span><span>];</span>
    <span>uint32_t</span> <span>sip</span><span>;</span>
    <span>unsigned</span> <span>char</span> <span>dmac</span><span>[</span><span>6</span><span>];</span>
    <span>uint32_t</span> <span>dip</span><span>;</span>
<span>}</span> <span>__attribute__</span><span>((</span><span>packed</span><span>));</span></code></pre></figure>

<p>The fields are pretty self explanatory. <code>smac</code> and <code>dmac</code> contain the 6-byte MAC addresses of the sender and receiver, respectively. <code>sip</code> and <code>dip</code> contain the sender’s and receiver’s IP addresses, respectively.</p>



<p>The <a href="https://tools.ietf.org/html/rfc826">original specification</a> depicts this simple algorithm for address resolution:</p>

<figure><pre><code data-lang="bash">?Do I have the hardware <span>type </span><span>in </span>ar<span>$hrd</span>?
Yes: <span>(</span>almost definitely<span>)</span>
  <span>[</span>optionally check the hardware length ar<span>$hln</span><span>]</span>
  ?Do I speak the protocol <span>in </span>ar<span>$pro</span>?
  Yes:
    <span>[</span>optionally check the protocol length ar<span>$pln</span><span>]</span>
    Merge_flag :<span>=</span> <span>false
    </span>If the pair &lt;protocol <span>type</span>, sender protocol address&gt; is
        already <span>in </span>my translation table, update the sender
        hardware address field of the entry with the new
        information <span>in </span>the packet and <span>set </span>Merge_flag to true.
    ?Am I the target protocol address?
    Yes:
      If Merge_flag is <span>false</span>, add the triplet &lt;protocol <span>type</span>,
          sender protocol address, sender hardware address&gt; to
          the translation table.
      ?Is the opcode ares_op<span>$REQUEST</span>?  <span>(</span>NOW look at the opcode!!<span>)</span>
      Yes:
        Swap hardware and protocol fields, putting the <span>local
            </span>hardware and protocol addresses <span>in </span>the sender fields.
        Set the ar<span>$op</span> field to ares_op<span>$REPLY</span>
        Send the packet to the <span>(</span>new<span>)</span> target hardware address on
            the same hardware on which the request was received.</code></pre></figure>

<p>Namely, the <code>translation table</code> is used to store the results of ARP, so that hosts can just look up whether they already have the entry in their cache. This avoids spamming the network for redundant ARP requests.</p>

<p>The algorithm is implemented in <a href="https://github.com/saminiir/level-ip/blob/e9ceb08f01a5499b85f03e2d615309c655b97e8f/src/arp.c#L53">arp.c</a>.</p>

<p>Finally, the ultimate test for an ARP implementation is to see whether it replies to ARP requests correctly:</p>

<figure><pre><code data-lang="bash"><span>[</span>saminiir@localhost lvl-ip]<span>$ </span>arping <span>-I</span> tap0 10.0.0.4
ARPING 10.0.0.4 from 192.168.1.32 tap0
Unicast reply from 10.0.0.4 <span>[</span>00:0C:29:6D:50:25]  3.170ms
Unicast reply from 10.0.0.4 <span>[</span>00:0C:29:6D:50:25]  13.309ms

<span>[</span>saminiir@localhost lvl-ip]<span>$ </span>arp
Address                  HWtype  HWaddress           Flags Mask            Iface
10.0.0.4                 ether   00:0c:29:6d:50:25   C                     tap0</code></pre></figure>

<p>The kernel’s networking stack recognized the ARP reply from our custom networking stack, and consequently populated its ARP cache with the entry of our virtual network device. Success!</p>



<p>The minimal implementation of Ethernet Frame handling and ARP is relatively easy and can be done in a few lines of code. On the contrary, the reward-factor is quite high, since you get to populate a Linux host’s ARP cache with your own make-belief Ethernet device!</p>

<p>The source code for the project can be found at <a href="https://github.com/saminiir/level-ip">GitHub</a>.</p>

<p>In the next post, we’ll continue the implementation with ICMP echo &amp; reply (ping) and IPv4 packet parsing.</p>

<p>If you liked this post, you can
<a href="https://twitter.com/intent/tweet?url=https://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/&amp;text=Let%27s+code+a+TCP%2FIP+stack%2C+1%3A+Ethernet+%26+ARP&amp;via=saminiir" target="_blank">
  share it with your followers</a> 
and 
<a href="https://twitter.com/saminiir">
  follow me on Twitter</a>!</p>

<p><em>Kudos to Xiaochen Wang, whose similar implementation proved invaluable for me in getting up to speed with C network programming and protocol handling. I find his <a href="https://github.com/chobits/tapip">source code</a><sup id="fnref:tapip" role="doc-noteref"><a href="#fn:tapip">5</a></sup> easy to understand and some of my design choices were straight-out copied from his implementation.</em></p>




  </article>

</div></div>
  </body>
</html>
