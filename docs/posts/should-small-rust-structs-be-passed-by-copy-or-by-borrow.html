<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/">Original</a>
    <h1>Should Small Rust Structs be Passed by-copy or by-borrow?</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Like many good stories, this one started with a simple question. Should small Rust structs be passed by-copy or by-borrow? For example:</p>

<pre><span>struct</span> Vector3 {
    x<span>:</span> <span>f32</span>,
    y<span>:</span> <span>f32</span>,
    z<span>:</span> <span>f32</span>
}

<span>fn</span> dot_product_by_copy(a<span>:</span> Vector3, b<span>:</span> Vector3) <span>-&gt;</span> <span>float</span> {
    a.x<span>*</span>b.x <span>+</span> a.y<span>*</span>b.y <span>+</span> a.z<span>*</span>b.z
}

<span>fn</span> dot_product_by_borrow(a<span>:</span> <span>&amp;</span>Vector3, b<span>:</span> <span>&amp;</span>Vector3) <span>-&gt;</span> <span>float</span> {
    a.x<span>*</span>b.x <span>+</span> a.y<span>*</span>b.y <span>+</span> a.z<span>*</span>b.z
}
</pre>

            <p>This simple question sent me on a benchmarking odyssey with some surprising twists and discoveries.</p>

            
            
            <p>The answer to this question matters for two reasons ‚Äî performance and ergonomics.</p>

            

            <p>Passing by-copy should mean we copy 12-bytes per <code>Vector3</code>. Passing by-borrow should pass an 8-byte pointer per <code>Vector3</code> (on 64-bit). That&#39;s close enough to maybe not matter.</p>

            <p>But if we change <code>f32</code> to <code>f64</code> now it&#39;s 8-bytes (by-borrow) versus 24-bytes (by-copy). For code that uses a <code>Vector4</code> of <code>f64</code> we&#39;re suddenly talking about 8-bytes versus 32-bytes.</p>

            

            <p>In C++ I know exactly how I&#39;d write this.</p>

<pre><span>struct</span> Vector3 {
    <span>float</span> x;
    <span>float</span> y;
    <span>float</span> z;
};

<span>float</span> <span>dot_product</span>(Vector3 <span>const</span><span>&amp;</span> a, Vector3 <span>const</span><span>&amp;</span> b) {
    <span>return</span> a.x<span>*</span>b.x <span>+</span> a.y<span>*</span>b.y <span>+</span> a.z<span>*</span>b.z
}
</pre>

            <p>Easy peasy. Pass by const-reference and call it day.</p>

            <p>The problem with Rust is ergonomics. When passing by-copy you can combine mathematical operations cleanly and simply.</p>

<pre st=""><span>fn</span> do_math(p1<span>:</span> Vector3, p2<span>:</span> Vector3, d1<span>:</span> Vector3, d2<span>:</span> Vector3, s<span>:</span> <span>f32</span>, t<span>:</span> <span>f32</span>) <span>-&gt;</span> <span>f32</span> {
    <span>let</span> a <span>=</span> p1 <span>+</span> s<span>*</span>d1;
    <span>let</span> b <span>=</span> p2 <span>+</span> s<span>*</span>d2;
    dot_product(b <span>-</span> a, b <span>-</span> a)
}
</pre>

            <p>However when using borrow semantics it turns into this ugly mess:</p>

            <pre><span>fn</span> do_math(p1<span>:</span> <span>&amp;</span>Vector3, p2<span>:</span> <span>&amp;</span>Vector3, d1<span>:</span> <span>&amp;</span>Vector3, d2<span>:</span> <span>&amp;</span>Vector3, s<span>:</span> <span>f32</span>, t<span>:</span> <span>f32</span>) <span>-&gt;</span> <span>f32</span> {
    <span>let</span> a <span>=</span> p1 <span>+</span> <span>&amp;</span>(<span>&amp;</span>d1<span>*</span>s);
    <span>let</span> b <span>=</span> p2 <span>+</span> <span>&amp;</span>(<span>&amp;</span>d2<span>*</span>t);
    <span>let</span> result <span>=</span> dot_product(<span>&amp;</span>(<span>&amp;</span>b <span>-</span> <span>&amp;</span>a), <span>&amp;</span>(<span>&amp;</span>b <span>-</span> <span>&amp;</span>a));
}
</pre>


            <p>Blech! Having to explicitly borrow temporary values is super gross. ü§Æ</p>

            
            
            <p>So, should Rust pass small structs, like <code>Vector3</code>, by-copy or by-borrow? </p>

            <p>None of Twitter, Reddit, or StackOverflow had a good answer. I checked popular crates like nalgebra (by-borrow) and cgmath (by-value) and found both ways are common.</p>
            
            <p>I don&#39;t like the ergonomics of by-borrow. But what about performance? If by-copy is fast then none of this matters. So I did the only thing that seemed reasonable. I built a benchmark!</p>
            
            <p>I wanted some to test something slightly more than raw operator performance. It&#39;s still a silly synthetic benchmark that is not representative of a real application. But it&#39;s a good starting point. Here&#39;s <i>roughly</i> what I came up with.</p>

<pre><span>let</span> num_shapes <span>=</span> <span>4000</span>;
<span>for</span> cycle in <span>0.</span>..<span>5</span> {
    <span>let</span> (spheres, capsules, segments, triangles) <span>=</span> generate_shapes(num_shapes);
    <span>for</span> run in <span>0.</span>.<span>5</span> {
        <span>for</span> (a,b) in collision_pairs {
            test_by_copy(a,b)
        }
        <span>for</span> pair in collision_pairs {
            test_by_borrow(<span>&amp;</span>a, <span>&amp;</span>b)
        }
    }
}
</pre>

            <p>I randomly generate 4000 spheres, capsules, segments, and triangles. Then I perform a simple overlap test for SphereSphere, SphereCapsule, CapsuleCapsule, and SegmentTriangle for all pairs. These tests are run by-copy and by-borrow. Only time spent inside test_by_copy and test_by_borrow is counted.</p>

            <p>Each full benchmark performs 3.2 billion comparisons and finds ~220 million overlapping pairs. Here are some results running single-threaded on my beefy i7-8700k Windows desktop. All times are in milliseconds.</p>

            <p>
                ¬†¬†Rust</p>

            <p>Well this is mildly surprising. Passing by-copy or by-borrow barely makes a difference! These results are quite consistent. Although a difference of less than 1% is well within the margin of error.</p>

            <p>Is this the answer to our question? Should we pass by-copy and call it a day? I&#39;m not ready to say.</p>

            
            

            <p>After my initial Rust benchmarks I decided to port my test suite to C++. The code is similar, but not identical. Both Rust and C++ implementations are what I would consider idiomatic in their respective languages.</p>
           
            <p>
                ¬†¬†C++</p>
            
            <p>Wait, what?! At least two things are super weird here.</p>

            <ol>
                <li><code>double</code> by-value is <i>faster</i> than <code>float</code> by-value</li>
                <li>C++ <code>float</code> is twice as slow as Rust <code>f32</code></li>         
            </ol>


            
            

            <p>Clearly something unexpected is going on. Using Visual Studio 2019 I grabbed a pair of quick CPU profiles.</p>

            <p><img src="https://aaronstrick.com/posts/assets/img/01.png" alt="Visual Studio Benchmark C++ Result"/></p><p>C++ Profile</p>
            
            <p><img src="https://aaronstrick.com/posts/assets/img/02.png" alt="Visual Studio Benchmark Reust Result"/></p><p>Rust Profile</p>

            <p>Ah hah! Rust appears to be inlining almost everything. Let&#39;s copy Rust and throw a quick <code>__forceinline</code> infront of everything in our C++ impl.</p>

            <p>
                ¬†¬†C++ w/ inlining</p>

            <p>Inlining C++ provides a decent ~12% boost. But <code>double</code> is still faster than <code>float</code>. And C++ is still way slower than Rust.</p>

            
            
            <p>I would consider my C++ and Rust implementations to both be idiomatic. However they are different! C++ takes out parameters by reference while Rust returns a tuple. This is because Rust tuples are delightful to use and C++ tuples are a monstrosity. But I digress.</p>

<pre st=""><span>// Rust</span>
<span>fn</span> closest_pt_segment_segment(p1<span>:</span> Vector3, q1<span>:</span> Vector3, p2<span>:</span> Vector3, q2<span>:</span> Vector3) 
<span>-&gt;</span> (T, T, T, Vector3, Vector3) 
{
    <span>// Do math</span>
}
</pre>

<pre><span>// C++</span>
<span>float</span> <span>closest_pt_segment_segment</span>(
    Vector3 p1, Vector3 q1, Vector3 p2, Vector3 q2,
    <span>float</span><span>&amp;</span> s, <span>float</span><span>&amp;</span> t, Vector3<span>&amp;</span> c1, Vector3<span>&amp;</span> c2)
{
    <span>// Do math</span>
}
</pre>
    
            <p>This subtle difference could cause a huge impact on performance. The C++ version compiler can&#39;t be sure the out parameters aren&#39;t aliased. Which may limit its ability to optimize. Meanwhile Rust uses and returns local variables which are known to be non-aliased.</p>

            <p>Interestingly, fixing the aliasing above doesn&#39;t make a difference! With inlining the compiler handles it already. Much to my surprise, what C++ does not handle well is the following:</p>

<pre><span>void</span> <span>run_test</span>(
    vector<span>&lt;</span>TSphere<span>&gt;</span> <span>const</span><span>&amp;</span> _spheres,
    vector<span>&lt;</span>TCapsule<span>&gt;</span> <span>const</span><span>&amp;</span> _capsules,
    vector<span>&lt;</span>TSegment<span>&gt;</span> <span>const</span><span>&amp;</span> _segments,
    vector<span>&lt;</span>TTriangle<span>&gt;</span> <span>const</span><span>&amp;</span> _triangles,
    <span>int64_t</span><span>&amp;</span> num_overlaps,
    <span>int64_t</span><span>&amp;</span> milliseconds)
{
    <span>// perform overlaps</span>
}
</pre>

            <p>Changing <code>run_test</code> to return <code>std::tuple&lt;int64_t, int64_t&gt;</code> provides a small but noticeable improvement.</p>

            <p>
                ¬†¬†C++ w/ inlining, tuples</p>

            
            

            <p>At this point both C++ and Rust are compiling with default options. Visual Studio exposes a ton of flags. I tried tweaking a bunch of flags to improve performance.</p>

            <ul>
                <li>Favor fast code (/Ot)</li>
                <li>Disable exceptions</li>
                <li>Advanced Vector Extensions 2 (/arch:AVX2)</li>
                <li>Floating Point Mode: Fast (/fp:fast)</li>
                <li>Enable Floating Point Exceptions: No (/fp:except-)</li>
                <li>Disable security check /GS-</li>
                <li>Control flow guard: No</li>
            </ul>

            <p>The only flags that made a real difference were &#34;disable exceptions&#34; and AVX2. Each about 10%. I decided to leave off AVX2 in an attempt to equal Rust.</p>

            <p>
                ¬†¬†C++ w/ inlining, tuples, no C++ exceptions</p>

            <p>We&#39;ve made three C++ optimizations but our two mysteries remain. Why is <code>double</code> faster than <code>float</code>? And why is C++ still so much slower than Rust? </p>


            
            

            <p>I tried looking at the disassembly in <a href="https://godbolt.org/z/1gENA_">Godbolt</a>. There&#39;s obviously differences. But I&#39;m not smart enough to quantify them.</p>
        </div><p>Next I decided to crack open VTune. Here the difference was revealed plain as day!</p><div>
            <p>Branch misprediction is awful. Not surprising. Take a close look at Vector Capacity Usage (FPU). Here&#39;s how that value is reported for different builds:</p>
        
            <p>
                ¬†¬†Rust f32¬†¬†¬†    42.3%</p>
        
            <p>Yowza! For whatever reason, and I don&#39;t know exactly what, Rust is remarkably more efficient at utilizing my CPU&#39;s floating point vectors. The difference is enormous! Rust <code>f32</code> is almost 3.5x more efficient than C++ <code>float</code>. And, for some reason, C++ <code>double</code> is twice as efficient as <code>float</code>! ü§∑‚Äç‚ôÇÔ∏è</p>

            <p>The obvious guess is that the Rust compiler simply does a better job of auto-vectorization. Is that the whole story or is there more? I honestly don&#39;t know. This is as deep as I&#39;m going to dig for now. If any experts would like to chime in with more details I&#39;m all ears.</p>

            
            

            <p>Somehow my Rust article has spent more time talking about C++. But that&#39;s ok!</p>

            <p>Our initial tests showed a less than one-percent different between by-copy and by-borrow. In my synthetic test the key reason appears to be because Rust auto-inlined the crap out of my code. Despite my not having a single <code>#[inline]</code> declaration! Furthermore, Rust automatically produced code twice as fast as a similar C++ implementation.</p>

            <p>My answer to by-copy versus by-borrow for small Rust structs is <b>by-copy</b>. This answer comes with several caveats.</p>

            <ol>
                <li>The definition of &#34;small&#34; is untested and unknown.</li>
                <li>Less mathematical structs may not work as well due to less auto-vectorization.</li>
                <li>Performant by-copy code likely requires inlining and trusting the compiler. üò±</li>
                <li>Including small structs implemented in another crate is untested.</li>
                <li>Synthetic benchmarks are not reflective of the real world. Always measure!</li>
            </ol>


            
            

            <p>I started with a simple question and went on a fun and educational journey. At this point I&#39;m going to move forward with passing small structs by-copy. I&#39;m not 100% convinced it&#39;s the right choice in all cases. But I&#39;m going to give it a whirl for a vector math library.</p>

            <p>I suspect there will be a scenario where this is not as performant. I would advise cautious optimism. Trust the compiler to make good decisions... but verify your real-world scenario.</p>

            <p>Thanks for reading.</p>


            
            
            <p>Full source code for my benchmark is available.</p>

            <p>
                <a href="https://aaronstrick.com/posts/assets/data/fts_small_struct_bench.zip">FullProjects.zip</a></p>

            
            
            <p>All C++ benchmarks above were done using the MSVC build chain in Visual Studio 2019. I wondered if Clang would do a better job. It&#39;s a little faster for by-value. But it does a remarkably poor job of handling doubles by-ref.</p>

            <p>
                ¬†¬†C++ (Clang) w/ inlining, tuples, no C++ exceptions</p>

            <p>All of this code could be optimized to be better. It should be possible to get C++ and Rust to the exact same level. But that&#39;s beyond the scope of this article and answering my original question.</p>
        </div></div>
  </body>
</html>
