<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.garros.gallery/">Original</a>
    <h1>The Art of Roland-Garros</h1>
    
    <div id="readability-page-1" class="page"><div><section><p>I have a problem. My work was throwing out a pile of monitors so I took a few home. Unfortunately, they&#39;re much nicer than my existing monitors! Woe is me, I know.</p><p>The reason this is a problem is because the new monitors are 4K, and most of my current ones are 1080p. Most(all?) major operating systems (Linux and the other ones) consider the virtual size of the monitor to be directly proportional to its pixel count. For example, this is what my laptop workstation setup currently looks like:</p><p><a href="https://www.scd31.com/img/cursor-wormhole/setup.png"><img src="https://www.scd31.com/thumb/cursor-wormhole/setup.png"/></a></p><p>On the left I have a 1080p monitor, rotated vertically. On top I have a 4K display from work, and on the bottom is my 1080p laptop display. Here&#39;s how these displays look virtually:</p><p><a href="https://www.scd31.com/img/cursor-wormhole/layout.png"><img src="https://www.scd31.com/thumb/cursor-wormhole/layout.png"/></a></p><p>It doesn&#39;t line up with physical reality at all! The top display is, virtually, much too big, and as a result the left screen doesn&#39;t reach up high enough. If I move my cursor into the top half of the left edge of the top display, it just gets stuck. What I would like is for it to move to the same spot (in physical reality) on the left display.</p><p>This is also a problem between my top and bottom displays, since their resolutions don&#39;t match. I could center the bottom display, which might make the map between the top/bottom screen a bit more sane, but then I wouldn&#39;t be able to move the cursor between the bottom display and the left display at all!</p><p>Really, what I want is this:</p><p><a href="https://www.scd31.com/img/cursor-wormhole/wormholes.png"><img src="https://www.scd31.com/thumb/cursor-wormhole/wormholes.png"/></a></p><p>The pink sections are what I&#39;m calling cursor wormholes, and the green lines are the mouths of these wormholes. When the cursor collides with a mouth, it should be seamlessly teleported to the opposite mouth. The position on the new mouth should correspond to where the mouse collided with the old mouth.</p><p>And so, I built a very simple <a href="https://gitlab.scd31.com/stephen/mouse-wormhole/">proof of concept</a>! I threw it together in about half a day, so it&#39;s pretty janky. The way it works is by polling the mouse cursor 1000 times per second, and when crossing a mouth, moving the cursor to where you expect. The wormholes are defined as follows (this is the actual config for the setup pictured above):</p><pre><span> [[vertical_wormhole]]
</span><span>   </span><span>mouth1</span><span>.</span><span>x1 </span><span>= </span><span>1080
</span><span>   </span><span>mouth1</span><span>.</span><span>x2 </span><span>= </span><span>2999 </span><span># 1080 + 1919
</span><span>   </span><span>mouth1</span><span>.</span><span>y </span><span>= </span><span>2160
</span><span> 
</span><span>   </span><span>mouth2</span><span>.</span><span>x1 </span><span>= </span><span>1080
</span><span>   </span><span>mouth2</span><span>.</span><span>x2 </span><span>= </span><span>4919 </span><span># 1080 + 3839
</span><span>   </span><span>mouth2</span><span>.</span><span>y </span><span>= </span><span>2159
</span><span>  
</span><span> [[horizontal_wormhole]]
</span><span>   </span><span>mouth1</span><span>.</span><span>y1 </span><span>= </span><span>1320
</span><span>   </span><span>mouth1</span><span>.</span><span>y2 </span><span>= </span><span>2646
</span><span>   </span><span>mouth1</span><span>.</span><span>x </span><span>= </span><span>1079
</span><span> 
</span><span>   </span><span>mouth2</span><span>.</span><span>y1 </span><span>= </span><span>0
</span><span>   </span><span>mouth2</span><span>.</span><span>y2 </span><span>= </span><span>2160
</span><span>   </span><span>mouth2</span><span>.</span><span>x </span><span>= </span><span>1080
</span><span> 
</span><span> [[horizontal_wormhole]]
</span><span>   </span><span>mouth1</span><span>.</span><span>y1 </span><span>= </span><span>2647
</span><span>   </span><span>mouth1</span><span>.</span><span>y2 </span><span>= </span><span>3239
</span><span>   </span><span>mouth1</span><span>.</span><span>x </span><span>= </span><span>1079
</span><span> 
</span><span>   </span><span>mouth2</span><span>.</span><span>y1 </span><span>= </span><span>2161
</span><span>   </span><span>mouth2</span><span>.</span><span>y2 </span><span>= </span><span>3239
</span><span>   </span><span>mouth2</span><span>.</span><span>x </span><span>= </span><span>1080
</span><span>
</span></pre>
<p>As a PoC, it works decently well. I can move my cursor between monitors in an intuitive way, which is pretty satisfying.</p></section><h2>Shortcomings</h2><section><p>My PoC definitely needs some work before I&#39;d recommend using it as a daily driver. For one, the polling mechanism is pretty inefficient. Between the <code>mouse-wormhole</code> process and the increased load on X, it sucks down about 10% of my CPU when I move the mouse rapidly. This is really something I&#39;d want to hack into X/Wayland directly, as part of its mouse handling routine (wherever that lives). The amount of actual work we&#39;re doing is so low that it shouldn&#39;t affect CPU usage in any meaningful way.</p><p>Aside from performance, polling also makes the mouse a bit &#34;jumpy&#34;. For instance, after the wormhole code runs and updates the mouse position, the display still needs to refresh. This means sometimes you see one frame of where the mouse would be if the program wasn&#39;t running, which can be a bit distracting.</p><p>Also, because we&#39;re only updating the mouse position, if you put the cursor right at the border of two monitors (such that it&#39;s rendered on both), the two halves won&#39;t line up as you expect - they don&#39;t respect the wormholes.</p><p>One other badly-needed feature is the ability to associate wormhole configs with monitor setups, such that e.g. plugging in a monitor automatically loads the relevant wormhole config. Without this, it requires the user to manually retweak/change their config and restart the program.</p><p>Finally, there needs to be some kind of GUI way to create wormholes. Since I&#39;m on X, I&#39;d want it to be a part of arandr, and I imagine Wayland has something similar. Creating wormholes by manually tweaking a config file is tedious and error-prone, and if I rearrange things I&#39;ll need to redo it.</p></section><h2>Final Thoughts</h2><section><p>I think I am most surprised that what I&#39;ve built isn&#39;t something that most systems already have. It&#39;s not that hard to implement, and presumably it must be a common problem. I&#39;ve run into it myself before, such as when I first started migrating to 1080p displays (and mixed them with various 720p or 4:3 displays). I think I would eventually like to see something like this supported first-class in... something... rather than being an add-on daemon.</p></section></div></div>
  </body>
</html>
