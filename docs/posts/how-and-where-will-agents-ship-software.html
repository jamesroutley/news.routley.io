<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.instantdb.com/essays/agents">Original</a>
    <h1>How and where will agents ship software?</h1>
    
    <div id="readability-page-1" class="page"><div><p>We’re entering a new phase of software engineering. People are becoming addicted to agents. Beginners are vibe-coding apps and experts are maxing out their LLM subscriptions. This means that a lot more people are going to make a lot more apps, and for that we’re going to need new tools.</p>
<p>Today we’re releasing an API that gives you and your agents full-stack backends. Each backend comes with a database, a sync engine, auth tools, file storage, and presence.</p>
<p>Agents can use these tools to ship high-level code that’s easier for them to write and for humans to review. It’s all hosted on multi-tenant infrastructure, so you can spin up millions of databases in milliseconds. We have a <a href="#demo" node="[object Object]">demo</a> at the end of this essay.</p>
<p>Let us explain exactly why we built this. We think that humans and agents can make the most progress when they have (1) built-in abstractions that (2) can be hosted efficiently and (3) expose data.</p>

<p>To build an app you write two kinds of code. The business logic that solves your specific problem, and the generic stuff that most apps have to take care of: authenticating users, making queries, running permissions, uploading files, and executing transactions.</p>
<p>These are simultaneously critical to get right, full of edge cases, and also not the differentiating factor for your app — unless they’re broken.</p>
<p>If all this work isn’t differentiating, why build it? When a good abstraction exists, it’s a waste of tokens to build it again.</p>
<p><img src="https://www.instantdb.com/posts/agents/good_abstractions.png" alt=""/></p>
<p>And agents need good abstractions even more than human programmers do.</p>
<h2>Locality</h2>
<p>To make agents work well we need to manage their context windows. It’s very easy to break through limits. Especially when agents write code that involves multiple moving pieces.</p>
<p>Consider what happens when an agent adds a feature to a traditional client-server app. They change (a) the frontend (b) the backend and (c) the database. In order to safely make these changes, they have to remember more of the codebase and be exact about how things work together.</p>
<p>Good abstractions can combine multiple moving pieces into one piece. This is more conducive to local reasoning. The agent only has to concern themselves with a smaller interface, so they don’t have to remember so much. They can use less context and write higher-level code. And that’s great for humans too. After all we have to review the agent’s work. Shorter, higher-level code is easier to understand. <sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label" node="[object Object]">[<!-- -->1<!-- -->]</a></sup></p>
<p>And when both humans and agents make more progress, they build more apps. And when they build more apps, how will they host them?</p>

<p>The dominant way to host applications has been to use virtual machines. VMs are efficient when you have a single app that serves many users. They’re inefficient when you have many apps that serve fewer users.</p>
<h2>Overhead</h2>
<p>Let me illustrate with some napkin math. Consider 1 app that servers 20,000 active users, versus 20,000 apps that serve 1 active user:</p>
<p><img src="https://www.instantdb.com/posts/agents/big_vs_small.png" alt=""/></p>
<p>For our 1 big app, we would need 2 beefy VMs. That’s about $800 a month. Not only is this affordable, but it makes for a fast app. Slow algorithms can take advantage of hefty CPUs and a lot more data can stay in memory.</p>
<p>For our 20,000 small apps we would need 40,000 VMs. That’s about $95,000 a month. Not only is this expensive, but it makes for slow apps. Slow algorithms would choke tiny CPUs and less data would stay in memory.</p>
<h2>Friction</h2>
<p>We’re not suggesting that people want to make 20,000 apps. We’re pointing out an inefficiency. Running applications today comes with overhead, particularly in RAM.</p>
<p>And when there’s overhead there’s friction. Today platforms freeze machines or limit how many apps you can spin up. In an era where every human can create lots of apps, this feels like a bummer.</p>
<p>Could we do better?</p>
<h2>Getting Specific</h2>
<p>Let’s think about why we needed VMs in the first place. VMs let programmers write code that’s arbitrarily different. But most apps aren’t arbitrarily different.</p>
<p>If we can get specific about what applications actually do, we can choose better isolation strategies.</p>
<p><img src="https://www.instantdb.com/posts/agents/getting_specific.png" alt=""/></p>
<p>For example what if we knew that an agent didn’t have to use the GPU? We could skip traditional VMs and use Micro VMs <sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label" node="[object Object]">[<!-- -->2<!-- -->]</a></sup> instead. That reduces the overhead by a few tens of megabytes of RAM, and lets us spin down inactive apps <sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label" node="[object Object]">[<!-- -->3<!-- -->]</a></sup>. That’s better, but we can keep going.</p>
<p>What if we knew that an agent wanted to write Javascript functions? We could skip VMs and use V8 Isolates <sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="" aria-describedby="footnote-label" node="[object Object]">[<!-- -->4<!-- -->]</a></sup>. Each isolate takes about 3 megabytes of RAM. That’s 2 orders of magnitude more efficient. But we can still keep going.</p>
<p>What if we knew that agent wanted to write access controls? We could give them a more restricted language like CEL <sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="" aria-describedby="footnote-label" node="[object Object]">[<!-- -->5<!-- -->]</a></sup>. CEL only needs a few kilobytes of overhead per function. That’s close to 4 orders of magnitude more efficient than VMs. And we can still keep going.</p>
<p>What if the agent didn’t have to write any code at all? If we knew what the agent was trying to accomplish — say to authenticate users — we could give them a multi-tenant service which did that.</p>
<h2>A maximally efficient future</h2>
<p>We can create efficient apps by choosing appropriate isolation strategies.</p>
<p><img src="https://www.instantdb.com/posts/agents/max_efficient.png" alt=""/></p>
<p>Shared abstractions could be served from multi-tenant services on big machines. Permissions could use CEL, javascript callbacks could run on V8 Isolates, and shell commands run on Micro VMs. If we did that, 20,000 apps with 1 active user would cost about the same as 1 app with 20,000 users.</p>
<p>Humans and agents would be able to deploy apps with little friction. Once these apps are deployed, how will people use them?</p>

<p>Traditionally, end-users were non-technical and would be stuck with whatever the application developer gave them. But now every user has an LLM too.</p>
<p>If one agent helps build the software, why shouldn’t another agent be able to extend it?</p>
<p><img src="https://www.instantdb.com/posts/agents/exposed_data.png" alt=""/></p>
<p>When every user has an agent, extendable software is an advantage. It’s in the application developer’s best interest: it can turn their apps into platforms, which are stickier. And it’s in the end-user’s best interest: they can get more out of their apps.</p>
<p>To make software extendable, developers generally used APIs. But APIs have a problem: application developers have to build them first. This means users are limited by what application developers <em>thought</em> were needed.</p>
<p>Databases are different. When apps are written on a database-like abstraction, users are free to make arbitrary queries and transactions. The application developer doesn’t have to foresee much. End-users can read and write whatever data they need to build all sorts of custom UIs <sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref="" aria-describedby="footnote-label" node="[object Object]">[<!-- -->6<!-- -->]</a></sup>.</p>
<p>And if that&#39;s true, database-like abstractions are going to be an advantage.</p>

<p>So if agents and humans work best when they have (1) built-in abstractions that are (2) hosted efficiently and (3) expose data, what infrastructure works best?</p>
<p>Let&#39;s start by thinking through what agents are good at. Agents are good at writing self-contained code. Code that they can reason about in one place, without too much extraneous state and edge cases. This is why the traditional client-server architecture is hard for them: it involves multiple parts that all need to work in unison — a server, a client, and a database.</p>
<p>There are several ways to build self-contained apps. You can build a local-only desktop app (but then — no internet, multiple devices, or collaboration). You can build a server-only app (then you get latency, no offline mode, hosting costs). Or you could build a client-only app that treats the backend like a remote database.</p>
<p>In other words, a sync engine.</p>
<p><img src="https://www.instantdb.com/posts/agents/sync_engine.png" alt=""/></p>
<p>Sync engines let you work with data as if it was local and not worry about fetching it, persisting it, managing optimistic state, atomic transactions, retries and many other schleps. That’s a powerful abstraction (1).</p>
<p>Queries and transactions are straight-forward to sandbox. You can host them on multi-tenant platforms. Which makes for efficient apps (2).</p>
<p>And since you get a database-like abstraction, exposing data is relatively straightforward too (3).</p>
<p>That’s the future we are building Instant for.</p>

<p>When we started Instant, agents were nowhere in sight. We focused on builders. Turns out if you design for builders, you end up making something good for agents too.</p>
<p><img src="https://www.instantdb.com/posts/agents/instant_arch.png" alt=""/></p>
<p>Builders want good abstractions. So we built a sync engine, permissions, auth, file storage, and ephemeral state (like cursors).</p>
<p>Builders also want efficient hosting. They have lots of projects, and it sucks when apps end up frozen. So we made our sync engine and database multi-tenant. This way we could offer a generous free tier.</p>


<p>Instant is already great for builders. Real startups use Instant, and push upwards of 10,000 concurrent connections.</p>
<p>Today we&#39;re making it even easier. We&#39;re releasing three things:</p>
<ul>
<li><a href="https://github.com/instantdb/instant/tree/main/client/packages/platform" target="_blank" node="[object Object]">A platform SDK</a> that lets you create new apps on demand</li>
<li><a href="https://www.instantdb.com/docs/using-llms#instant-mcp-server" target="_blank" node="[object Object]">A remote MCP server</a> that makes it easy to integrate Instant in your editor.</li>
<li><a href="https://www.instantdb.com/docs/using-llms#instant-rules" target="_blank" node="[object Object]">A set of Agent rules</a> that teach LLMs how to use Instant</li>
</ul>
<p>Put this together and you get a toolkit that lets humans and agents make more progress and do it efficiently. Let&#39;s try them out.</p>
<div><div><p>We’re going to build a habit tracker with one important twist: dinosaurs and aliens are going to be involved. And we&#39;ll build it right inside this essay.</p><p>If you keep pressing the buttons that follow, you’ll have an app you can play with at the end.</p><h2>An example prompt</h2><p>Before we continue, here&#39;s the prompt we gave Claude to generate all the code that follows:</p><blockquote>Create a habit tracking app where users can create habits, mark daily completions, and visualize streaks. Include features for setting habit frequency (daily/weekly), viewing completion calendars, and tracking overall progress percentages. Make it all dinosaur and alien themed.<!-- --><!-- --></blockquote><p>We&#39;re going to wire this up to a real backend step-by-step.</p><h2 id="create-a-database">Create a database</h2><p>The first thing we&#39;ll ask our agent is to create a new database. It can use the MCP server to do that.</p><p>We’ve added a <code>create-app</code> tool right inside this essay. Click it, and we’ll spin up a new database.</p><div><div><div><pre><code><span>{</span><span> </span><span>title</span><span>:</span><span> </span><span>&#39;dino-habit-tracker&#39;</span><span> </span><span>}</span>
</code></pre></div></div></div><div><div><p>Click &#39;Run tool&#39; to see the result.</p><p>(There&#39;s more in the essay!)</p></div></div></div></div>
<hr/>
<p><em>Thanks to Joe Averbukh, Daniel Woelfel, Alex Kotliarskyi, Ian Alejandro Sinnott, Cam Glynn, Anupam Batra, Predrag Gruevski, Irakli Popkhadze, Cody Breene, Kote Mushegiani, Nicole Garcia Fischer for reviewing drafts of this essay</em></p>
</div></div>
  </body>
</html>
