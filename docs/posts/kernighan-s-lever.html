<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://linusakesson.net/programming/kernighans-lever/index.php">Original</a>
    <h1>Kernighan&#39;s Lever</h1>
    
    <div id="readability-page-1" class="page"><div>


<p><a href="http://en.wikipedia.org/wiki/Brian_Kernighan">Brian Kernighan</a>
famously wrote:</p>

<div>
	<p><span>
		Everyone knows that debugging is twice as hard as writing a program in
		the first place. So if you&#39;re as clever as you can be when you write
		it, how will you ever debug it?
	</span></p>

	<p>— <i>The Elements of Programming Style</i>, 2nd edition, chapter 2</p>
</div>

<p>The following version also circulates on the net:</p>

<p>
		Debugging is twice as hard as writing the code in the first place.
		Therefore, if you write the code as cleverly as possible, you are, by
		definition, not smart enough to debug it. 
	</p>

<p>This second quote may or may not be by Kernighan — the questionable
use of &#34;by definition&#34; makes me uncertain — but it is useful as a
provocative sound bite conveying the same essential idea.</p>

<p>It is tempting to interpret Kernighan&#39;s aphorism as a warning: Stay away from
clever techniques, it seems to say, because if you write clever code, you will
never be able to get it to work. But this interpretation is unfortunate, and
rests on the false assumption that cleverness is static.</p>

<p>While it is possible that Kernighan intended us to interpret the message in a
specific way, he wisely restricted himself to merely presenting an observation,
allowing us to draw our own conclusions from it.</p>

<p>Pay close attention to what is actually being said: Having written code as
cleverly as you can, you will suddenly face a problem that you are not clever
enough to solve. Certainly, &#34;clever&#34; in this context does not refer to some
innate talent, because nobody is born with the ability to write clever code in
the first place. The &#34;cleverness&#34; required to write and understand intricate
code is an acquired mental skill.</p>

<p><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/cat.png" alt="Cat at keyboard"/>
</p>

<p>If you are a programmer, you will be familiar with a sense of wonder,
gradually transforming into utter stupor, as you stare at some perfectly
reasonable code that couldn&#39;t possibly fail, and yet somehow it does. And since
you are confident that you understand how the code works, having written it
yourself, you feel that you must be able to figure out what is going on. Not
only the desire to deliver working software on time, but other powerful forces
such as pride, stubbornness and curiosity contribute to the motivation that
pushes you onwards through the arduous task of tracking down the root cause of
the error.  Suddenly you see it, and you&#39;re blinded by a bright light as all
the pieces fall into place. The inexperienced programmer may fall into the trap
of self-degradation: &#34;Oh, look at how stupid I was!&#34; But that same sentiment is
proof that your programming-related cleverness, or skill, has increased: &#34;Oh,
look at how clever I&#39;ve become!&#34; (Although I wouldn&#39;t recommend saying that out
loud.)</p>

<p>Skill is the result of practice, that is, of systematically trying to work
slightly beyond one&#39;s ability. Quite understandably, most of us don&#39;t spend
that kind of effort unless we have good reason to. Hence, without motivation we
do not practise, but simply cruise along at our current level and never improve
any further.</p>

<p>The mind is very good at rationalising, and will convince us that our
current skills are sufficient, that we are all &#34;good enough&#34;; certainly
better than the average programmer anyway. The human brain will do this trick
regardless of our actual level of skill. So while we all tend to consider
ourselves sufficiently skilled right now, we never regret improving.</p>

<p><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/archimedes.png" alt="Lever"/>
</p>

<p>You effortlessly wield clever programming techniques today that would&#39;ve
baffled your younger self. (If not, then I&#39;m afraid you stopped evolving as a
programmer long ago.) But this improvement is the result of practice, and
something must have motivated you to put in all those hours of work.
Kernighan&#39;s witty remarks provide a clue: In programming, as soon as you work
at your current level, you will automatically end up in a situation where you
have to work beyond your current level. By means of this very fortunate
mechanism, you will leverage several basic human drives (honour, pride,
stubbornness, curiosity) into providing the motivation necessary for
improvement.</p>

<p>I call this mechanism <i>Kernighan&#39;s lever</i>. By putting in a small
amount of motivation towards the short-term goal of implementing some
functionality, you suddenly end up with a much larger amount of motivation
towards a long term investment in your own personal growth as a programmer.</p>

<p>If we deliberately stay away from clever techniques when writing code, in
order to avoid the need for skill when debugging, we dodge the lever and miss
out on the improvement. We would then need other sources of motivation in order
to grow as programmers, and if no such motivation appears, our abilities
stagnate (or even deteriorate).</p>

<p>The psychological concept of <i>flow</i>, somewhat simplified, can be used
to visualise the process. Flow is when you are &#34;fully immersed in a feeling of
energised focus, full involvement, and enjoyment in the process of the
activity&#34; (<a href="http://en.wikipedia.org/wiki/Flow_(Psychology)">wikipedia</a>), and it
only occurs when the challenge that you are tackling matches your current level
of skill.</p>

<div>
	<div>
		<p><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/flow1.png" alt="Flow chart"/></p><p>Implement below your ability,
			and you get to debug in the &#34;flow&#34; area.</p>
	</div>
	<div>
		<p><img src="http://ablwr.github.io/blog/2025/12/18/annual-report/flow2.png" alt="Flow chart"/></p><p>Implement at your ability, and
			the debugging will be frustrating, but you gain skill.</p>
	</div>
</div>

<p>You will find yourself situated at a particular x-coordinate, corresponding
to your current level of skill. If writing code is a point on this graph, then
(according to Kernighan&#39;s assumption) debugging the same code would
be a point a fair bit directly above it.</p>

<p>It is certainly possible to deliberately pick a low starting point just to
avoid ending up in the frustration area. But this will put you squarely in the
boredom area, and boredom is frankly no better than frustration. However,
should you pick a starting point in the enjoyable flow area, Kernighan&#39;s lever
will screech into action and push you sideways through the graph, increasing
your skill until it matches the challenge posed by the bugs in your code.</p>

<p>Naturally, the real world is more complex than this, and you will sometimes
have compelling reasons to go for the boring option, and artificially reduce
your cleverness in order to dumb down the debugging phase. But it may harm
your long-term personal development if you go down that road every single time
you write a program.</p>

<p>In conclusion, the answer to Kernighan&#39;s rhetorical question — &#34;how
will you ever debug it?&#34; — is straight-forward: By tackling the problem,
thereby gaining valuable experience and becoming more clever in the process.
And the second version of the quote can be adorned with a single word at the
end: Yet.</p>

<p>Posted Tuesday 11-Dec-2012 21:33</p>
<div>
<h3>Discuss this page</h3><p>Disclaimer: I am not responsible for what people (other than myself) write in the forums. Please report any abuse, such as insults, slander, spam and illegal material, and I will take appropriate actions. Don&#39;t feed the trolls.</p><p>Jag tar inget ansvar för det som skrivs i forumet, förutom mina egna inlägg. Vänligen rapportera alla inlägg som bryter mot reglerna, så ska jag se vad jag kan göra. Som regelbrott räknas till exempel förolämpningar, förtal, spam och olagligt material. Mata inte trålarna.</p><div><div><p>If this is all true, a perfect solution would be to debug the program 10 years after you&#39;ve wrote it...</p></div></div>

<div><div><p>This matches with my experience as well. Thanks for sharing.</p></div></div>
<div><p>My interpretation of &#34;clever&#34; as Kernighan uses it is based on writings by him and Thompson in the Unix heyday. Thompson wrote the kernel using simple mechanisms that could be optimzied later if required, and only optimized after profiling. So &#34;clever&#34; could be interpreted as overdesigned. Of course the points you make about improvement are valid, and if we interpret &#34;clever&#34; as meaning as good an algorithm and data structure as possible, then yes, by all means, so long as the pattern can be discerned by others later. Like good writing, one must write elegantly and clearly.</p></div>
<div><p>Two authors, Brian Kernighan and Bill Plauger, wrote &#34;The Elements of Programming Style&#34; while working at Bell Labs in the 70&#39;s. Bill also authored several books. Bill probably wrote the first commercial C compiler and a UNIX clone called Idris. Brian and Bill were brilliant programmers who were convinced to write the elements of programming style because of the dreadful Fortran code published in numerical analysis texts. They collaborated on two further books focused on software tools, one in Ratfor and the other in Pascal.</p></div>
</div>
</div></div>
  </body>
</html>
