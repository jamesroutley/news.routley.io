<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://datum-b.com/blog/code_studies_for_algorithm_optimization">Original</a>
    <h1>Code Studies for Algorithm Optimization in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><a href="https://news.ycombinator.com/home">
        <img src="https://news.ycombinator.com/static/dblogo.png" width="60%" max-width="50%" height="auto" alt="Made with PowerPoint"/>
        </a></p>
    <p>26 March, 2023</p>
    <p>Painters have long been known to perform studies in preparation for larger works. Like a painting, computer programs are often composed of several interlocking elements. Oftentimes composing a larger program makes development and iteration of the individual components challenging within the larger context. Breaking out these components and iterating on them in isolation is a great way to get your components right, without needing to worry about the interface to the surrounding implementation. In this article, I give an example of this type of study applied to a small Rust program. In doing so, we delve into benchmarking execution time, CPU usage, and memory allocation.</p>
<figure>
<img src="https://news.ycombinator.com/static/post_images/hands_study_sm.png" alt=""/><figcaption>Leonardo Da Vinci’s Study of Arms and Hands. Source: https://www.leonardodavinci.net/study-of-arms-and-hands.jsp</figcaption>
</figure>
<h2 id="the-problem">The Problem</h2>
<p>I previously wrote about our efforts <a href="https://news.ycombinator.com/blog/visualizing_holograms">efforts to generate and visualize holograms</a>. One of the issues I noticed with the animated visualizations is that arcs that were supposed to move along a circular path actually moved in a linear path:</p>
<figure>
<img src="https://news.ycombinator.com/static/post_images/arc_demo_anim-2.svg" alt=""/><figcaption>Animation behavior before using multiple interpolated points in animation definition.</figcaption>
</figure>
<p>The reason for this is that my animation strategy had simply been to move the arc from one point to another and then back again. This works for small movements, but is obviously flawed for larger ones.</p>
<p>The parameters for the animations are path data for <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs">SVG elliptical arcs</a>. The first iteration of the visualizer only used starting and ending positions; to keep the arcs on a circular path, I simply need to interpolate intermediate positions between the start and end of the animation. Importantly, cause the animation to reverse, we need to specify every position in the animation twice: once going there, once coming back.</p>
<p>The original implementation created a vector of <a href="https://docs.rs/svg/0.13.0/svg/node/element/path/struct.Data.html"><code>svg::node::element::path::Data</code></a> objects, then mapped these to strings and joined them to create the full animation. The path objects are created by calculating where the arc should be illuminated based on the center of the circle, radius, light-source incidence angle, and arc width:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span>fn</span> circular_arc_by_angle(center<span>:</span> <span>&amp;</span>Vec2<span>,</span> radius<span>:</span> <span>f32</span><span>,</span> angle<span>:</span> <span>f32</span><span>,</span> width_deg<span>:</span> <span>f32</span>) <span>-&gt;</span> Data <span>{</span> <span>...</span> <span>}</span></span></code></pre></div>
<p>The <a href="https://crates.io/crates/svg">svg crate</a> didn’t have any obvious way to generate compound animations as we required, so the data string had to be built manually from the data objects. The docstring for this function shows how it works:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>use</span> <span>svg::node::element::path::</span>Data<span>;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span>let</span> data <span>=</span> <span>Data::</span>new()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span>.</span>move_to((<span>0</span><span>,</span> <span>0</span>))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span>.</span>elliptical_arc_to((<span>80</span><span>,</span> <span>80</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>10</span><span>,</span> <span>10</span>))<span>;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span>assert_eq!</span>(data_to_string(<span>&amp;</span>data)<span>,</span> <span>&#34;M0 0 A80 80 0 0 0 10 10&#34;</span>)<span>;</span></span></code></pre></div>
<p>The code below is a snippet from the original function that generates an animated arc. I’ve already gotten the arcs to animate along smooth paths with the function below, but I think this solution is inelegant and needs further study. Some details of the function, such as how the angles are calculated and how the number of steps is determined, have been omitted for brevity.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>fn</span> animated_arc(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    input_circle<span>:</span> <span>&amp;</span>Circle<span>,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    light_source_start<span>:</span> <span>&amp;</span>Point<span>,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    light_source_end<span>:</span> <span>&amp;</span>Point<span>,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    duration_secs<span>:</span> <span>f32</span><span>,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>) <span>-&gt;</span> <span>Path</span> <span>{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span>/* Setup code for determining num_steps, angle, and start_angle omitted */</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span>let</span> <span>mut</span> frames<span>:</span> <span>Vec</span><span>&lt;</span>Data<span>&gt;</span> <span>=</span> <span>Vec</span><span>::</span>new()<span>;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    <span>// Create animation frames one by one</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>    <span>for</span> step <span>in</span> <span>0</span><span>..=</span>num_steps <span>{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        <span>let</span> angle <span>=</span> start_angle <span>+</span> step <span>as</span> <span>f32</span> <span>*</span> step_size<span>;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>        frames<span>.</span>push(circular_arc_by_angle(<span>&amp;</span>center<span>,</span> r<span>,</span> angle<span>,</span> HOLO_WIDTH_DEG))<span>;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>    </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>    <span>// Generate the animation frames for the opposite direction</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>    <span>let</span> <span>mut</span> rev_frames <span>=</span> frames<span>.</span>clone()<span>;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>    rev_frames<span>.</span>pop()<span>;</span> <span>// don&#39;t draw the middle frame twice</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>                      <span>// I.e. [ A, B, C ] should become [ A, B, C, B, A ]</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>                      <span>// and not [A, B, C, C, B, A]</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>    rev_frames<span>.</span>reverse()<span>;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>    frames<span>.</span>append(<span>&amp;</span><span>mut</span> rev_frames)<span>;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>    </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>    <span>// Build the animation data to attach to the path element</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a>    <span>let</span> animation_data<span>:</span> <span>String</span> <span>=</span> frames</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a>        <span>.</span>iter()</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>        <span>.</span>map(<span>|</span>frame<span>|</span> data_to_string(frame))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>        <span>.</span><span>collect::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span>()</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a>        <span>.</span>join(<span>&#34;;&#34;</span>)<span>;</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true"></a>    </span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true"></a>    <span>// Finally build the path element and return it</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true"></a>    <span>Path</span><span>::</span>new()<span>.</span>add(</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true"></a>        <span>Animate::</span>new()</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true"></a>            <span>.</span>set(<span>&#34;dur&#34;</span><span>,</span> duration_secs)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true"></a>            <span>.</span>set(<span>&#34;repeatCount&#34;</span><span>,</span> <span>&#34;indefinite&#34;</span>)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true"></a>            <span>.</span>set(<span>&#34;attributeName&#34;</span><span>,</span> <span>&#34;d&#34;</span>)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true"></a>            <span>.</span>set(<span>&#34;values&#34;</span><span>,</span> animation_data)<span>,</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true"></a>    )</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>The image below shows the result, which is what we intended.</p>
<figure>
<img src="https://news.ycombinator.com/static/post_images/arc_demo_anim.svg" alt=""/><figcaption>Animating the holograms using several interpolated steps creates a smooth circular motion as intended.</figcaption>
</figure>
<p>What inspires this study is that I think there must be a better way to play a vector forwards and then backwards again; something more elegant than the <code>clone</code>, <code>pop</code>, <code>reverse</code>, and <code>append</code> algorithm I’ve kludged together above. My observation here is that it’s was using more memory than it has a right to; repeated elements on the return trip were being allocated as path <code>Data</code> objects in the heap.</p>
<p>Generalizing the problem somewhat, we need create several animation positions between <code>start</code> and <code>end</code>, and then reverse those positions. Thus, given a vector of objects <span>[<em>D</em><sub>1</sub>...<em>D</em><sub><em>n</em></sub>]</span> and a function <span><em>f</em>(<em>D</em>)</span> that returns a <code>String</code>, we want to generate <span>[<em>f</em>(<em>D</em><sub>1</sub>)...<em>f</em>(<em>D</em><sub><em>n</em></sub>)...<em>f</em>(<em>D</em><sub>1</sub>)]</span> as efficiently as possible.</p>
<h3 id="initial-benchmark">Initial Benchmark</h3>
<p>Prior to this exercise, the <code>build_animated_hologram</code> function was benchmarked at 77 ms to make a visualization of a hologram built up from 3,180 input circles. The <code>animated_arc</code> function above takes 15 μs per iteration:</p>
<pre><code>test tests::build_animated_hologram ... bench:  77,287,726 ns/iter (+/- 2,932,403)
test tests::bench_animated_arc      ... bench:      15,274 ns/iter (+/- 1,960)</code></pre>
<p>Multiplying the benchmark for <code>animated_arc</code> times the number of circles gives us 48 ms, or about <span>2/3</span> the time it takes to build the full hologram. Running a <a href="https://github.com/flamegraph-rs/flamegraph">flamegraph</a> on the same input confirms my suspicion that <code>animated_arc</code> is a good choice to optimize:</p>
<figure>
<a href="https://news.ycombinator.com/static/post_images/flamegraph.svg"><img src="https://news.ycombinator.com/static/post_images/flamegraph.svg" alt=""/></a><figcaption>Baby’s first flamegraph</figcaption>
</figure>
<h2 id="setting-up-a-testbed">Setting up a Testbed</h2>
<p>I set up a separate crate outside of the <a href="https://github.com/samuelselleck/holographit">holographit</a> project, and built some mock-objects and functions to simulate what I was working with. I brought in the test crate so that I could do some benchmark tests. If you’re playing along at home, you can get the full code for this study <a href="https://gist.github.com/blairfrandeen/3b268f78bc9ab8cd67f50744f854e558">at this GitHub Gist</a>; make sure that you’re using the Rust nightly build in order to run benchmarks.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span>#![</span>feature<span>(</span>test<span>)]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span>extern</span> <span>crate</span> test<span>;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span>use</span> <span>rand::</span>random<span>;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span>#[</span>derive<span>(</span><span>Debug</span><span>,</span> <span>Clone</span><span>,</span> <span>Copy</span><span>)]</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span>struct</span> Data <span>{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    x<span>:</span> <span>f32</span><span>,</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    y<span>:</span> <span>f32</span><span>,</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span>}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a><span>fn</span> data_to_string(data<span>:</span> <span>&amp;</span>Data) <span>-&gt;</span> <span>String</span> <span>{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    <span>format!</span>(<span>&#34;{},{}&#34;</span><span>,</span> data<span>.</span>x<span>,</span> data<span>.</span>y)<span>.</span>to_string()</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span>}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a><span>fn</span> generate_data(num_points<span>:</span> <span>usize</span>) <span>-&gt;</span> <span>Vec</span><span>&lt;</span>Data<span>&gt;</span> <span>{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>    <span>let</span> <span>mut</span> data <span>=</span> <span>Vec</span><span>::</span>new()<span>;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>    <span>for</span> _ <span>in</span> <span>0</span><span>..</span>num_points <span>{</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>        data<span>.</span>push(Data <span>{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>            x<span>:</span> random()<span>,</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>            y<span>:</span> random()<span>,</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>        <span>}</span>)<span>;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>    data</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>The above code has a <code>Data</code> <code>struct</code> to simulate the path data, and a <code>data_to_string</code> function that operates on the <code>Data</code>. The <code>generate_data</code> function simply makes a large number of random data points to work with.</p>
<h2 id="algorithm-development">Algorithm Development</h2>
<h3 id="attempt-1">Attempt #1</h3>
<p>My first attempt mirrored the way I had written the function for the visualizer library:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span>fn</span> attempt_1(data<span>:</span> <span>Vec</span><span>&lt;</span>Data<span>&gt;</span>) <span>-&gt;</span> <span>String</span> <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span>let</span> <span>mut</span> d2 <span>=</span> data<span>.</span>clone()<span>;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span>let</span> <span>mut</span> data_rev <span>=</span> data<span>.</span>clone()<span>;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    data_rev<span>.</span>pop()<span>;</span> <span>// avoid repeating the middle element</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    data_rev<span>.</span>reverse()<span>;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    d2<span>.</span>append(<span>&amp;</span><span>mut</span> data_rev)<span>;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    <span>let</span> s<span>:</span> <span>String</span> <span>=</span> d2</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>        <span>.</span>iter()</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        <span>.</span>map(<span>|</span>d<span>|</span> data_to_string(d))</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        <span>.</span><span>collect::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span>()</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>        <span>.</span>join(<span>&#34;</span><span>\n</span><span>&#34;</span>)<span>;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    s</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>The image below shows my mental model for Rust’s memory allocation with this appoarch. <code>d2: Vec&lt;Data&gt;</code> lives on the stack, and contains a pointer to the heap memory for the <code>Data</code> objects, as well as the vector’s size &amp; capacity. Each <code>Data</code> object in turn points to its constituients, which for this exercise are simply <code>f32</code>s.</p>
<figure>
<img src="https://news.ycombinator.com/static/post_images/attempt_1_memory.png" alt=""/><figcaption>A mental model for stack and heap allocations for the initial algorithm.</figcaption>
</figure>
<h3 id="attempt-2">Attempt #2</h3>
<p>My second attempt addressed my previous observation that I was perhaps allocating twice as much memory as I needed to. I wanted to use pointers to point back at the same objects on the heap rather than repeating them.</p>
<figure>
<img src="https://news.ycombinator.com/static/post_images/attempt_2_memory.png" alt=""/><figcaption>My plan for optimizing the algorithm involved using a vector of references back to a smaller set of objects.</figcaption>
</figure>
<p>The image above shows my mental model for the data structure I wanted; I would still need a <code>Vec</code> with <span>2<em>n</em> − 1</span> elements, but this time it could be a <code>Vec&lt;&amp;Data&gt;</code>, and I’d push the pointers there deliberately rather than using the messy clone-pop-reverse-append approach from the first attempt. The implementation of this algorithm is below.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span>fn</span> attempt_2(data<span>:</span> <span>Vec</span><span>&lt;</span>Data<span>&gt;</span>) <span>-&gt;</span> <span>String</span> <span>{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span>let</span> n <span>=</span> data<span>.</span>len() <span>*</span> <span>2</span> <span>-</span> <span>1</span><span>;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span>let</span> <span>mut</span> res<span>:</span> <span>Vec</span><span>&lt;&amp;</span>Data<span>&gt;</span> <span>=</span> <span>Vec</span><span>::</span>with_capacity(n)<span>;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span>for</span> i <span>in</span> <span>0</span><span>..=</span>n <span>{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        <span>if</span> i <span>&lt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>            res<span>.</span>push(<span>&amp;</span>data[i])<span>;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>if</span> i <span>&gt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>            res<span>.</span>push(<span>&amp;</span>data[n <span>-</span> i])<span>;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>{</span> <span>// don&#39;t repeat the middle element</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>            <span>continue</span><span>;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>        <span>}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>    <span>let</span> s<span>:</span> <span>String</span> <span>=</span> res</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>        <span>.</span>iter()</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>        <span>.</span>map(<span>|</span>d<span>|</span> data_to_string(d))</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>        <span>.</span><span>collect::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span>()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>        <span>.</span>join(<span>&#34;</span><span>\n</span><span>&#34;</span>)<span>;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>    s</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>This algorithm starts by calculating the length of the final vector, and then creating an empty vector using the <code>Vec::with_capacity(n)</code> call; this works just like <code>Vec::new()</code>, but avoids having to reallocate memory on every <code>push</code>. You can always find the capacity of a vector using <code>Vec::capacity()</code>.</p>
<p>I added some debugging &amp; profiling code to the above algorithm to check how many heap allocations were being done on my behalf. For 5,000 data points (and a resulting final vector length of 9,999), there were 14 re-allocations. Rust doubles the capacity every time it runs out and needs to reallocate on the heap.</p>
<pre><code>Vector Capacity Over Time: [0, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384]
Number of reallocations: 14</code></pre>
<p>I also ran both this and attempt #1 above with some additional debugging code to interrogate the memory addresses of where the vectors are pointing to:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span>for</span> d <span>in</span> res<span>.</span>clone() <span>{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span>println!</span>(<span>&#34;{:p}&#34;</span><span>,</span> d)<span>;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>The <code>:p</code> format specifier prints the memory addresses. The table below shows the memory addresses for attempt 1 keep incrementing, while for attempt 2 they repeat in reverse order as intended.</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>Attempt 1</th>
<th>Attempt 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x5630a5810a10</td>
<td>0x5630a5810f10</td>
</tr>
<tr>
<td>1</td>
<td>0x5630a5810a18</td>
<td>0x5630a5810f18</td>
</tr>
<tr>
<td>2</td>
<td>0x5630a5810a20</td>
<td>0x5630a5810f20</td>
</tr>
<tr>
<td>3</td>
<td>0x5630a5810a28</td>
<td>0x5630a5810f18</td>
</tr>
<tr>
<td>4</td>
<td>0x5630a5810a30</td>
<td>0x5630a5810f10</td>
</tr>
</tbody>
</table>
<p>But this doesn’t perform any better at all:</p>
<pre><code>test tests::bench_1 ... bench:   6,287,113 ns/iter (+/- 1,510,446)
test tests::bench_2 ... bench:   6,270,934 ns/iter (+/- 2,323,705)</code></pre>
<p>Why is this? One reason is that in setting up some mock up objects, I neglected to add any heap allocated items to <code>Data</code> itself. My mock <code>Data</code> struct only contains <code>f32</code>s, which have the <code>Copy</code> trait. This means that Rust has no reason to heap-allocate 32 bits for an <code>f32</code> and then make an additional 32-bit pointer to that data; it just allocates space for the <code>f32</code>s on each <code>Data</code> struct and keeps them right there.</p>
<p>Rerunning these benchmarks and adding a heap allocated <code>String</code> to each <code>Data</code> struct improves the performance relative to the first attempt by about 12%. What this tells me is that the wasteful heap allocation is real, but not critical. Is there anything else I can do better?</p>
<h3 id="attempt-3">Attempt #3</h3>
<p>Slightly over-allocating <code>Vec&lt;Data&gt;</code> isn’t a smoking gun, but the fact that I’m running <code>data_to_string</code> on the same <code>Data</code> structs multiple times is suspect. I can’t expect Rust to be doing any caching or memoization of the results of <code>data_to_string</code> at this time.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span>fn</span> attempt_3(data<span>:</span> <span>Vec</span><span>&lt;</span>Data<span>&gt;</span>) <span>-&gt;</span> <span>String</span> <span>{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span>let</span> n <span>=</span> data<span>.</span>len() <span>*</span> <span>2</span> <span>-</span> <span>1</span><span>;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span>let</span> <span>mut</span> res <span>=</span> <span>Vec</span><span>::</span><span>&lt;</span><span>String</span><span>&gt;</span><span>::</span>with_capacity(n)<span>;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    <span>for</span> i <span>in</span> <span>0</span><span>..=</span>n <span>{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>        <span>if</span> i <span>&lt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>            res<span>.</span>push(data_to_string(<span>&amp;</span>data[i]))<span>;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>if</span> i <span>&gt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>            res<span>.</span>push(res[n <span>-</span> i]<span>.</span>clone())<span>;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>            <span>continue</span><span>;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>        <span>}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>    res<span>.</span>join(<span>&#34;</span><span>\n</span><span>&#34;</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>The control flow is identical to attempt #2, except it’s building a <code>Vec&lt;String&gt;</code> instead. There are thus half the number of calls to <code>data_to_string</code>, and <em>now</em> it runs twice as fast:</p>
<pre><code>test tests::bench_1 ... bench:   6,287,113 ns/iter (+/- 1,510,446)
test tests::bench_2 ... bench:   6,270,934 ns/iter (+/- 2,323,705)
test tests::bench_3 ... bench:   2,838,830 ns/iter (+/- 434,103)</code></pre>
<h3 id="attempt-4">Attempt #4</h3>
<p>What if instead of building up a vector of strings, I just append to the result string directly?</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span>fn</span> attempt_4(data<span>:</span> <span>Vec</span><span>&lt;</span>Data<span>&gt;</span>) <span>-&gt;</span> <span>String</span> <span>{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    <span>let</span> n <span>=</span> data<span>.</span>len() <span>*</span> <span>2</span> <span>-</span> <span>1</span><span>;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span>let</span> <span>mut</span> res <span>=</span> <span>String</span><span>::</span>with_capacity(n <span>*</span> <span>22</span>)<span>;</span> <span>// resulting strings are about 20 bytes each</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span>for</span> i <span>in</span> <span>0</span><span>..=</span>n <span>{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>        <span>if</span> i <span>&lt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>            res<span>.</span>push_str(<span>&amp;</span>data_to_string(<span>&amp;</span>data[i]))<span>;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>if</span> i <span>&gt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>            res<span>.</span>push_str(<span>&amp;</span>data_to_string(<span>&amp;</span>data[n <span>-</span> i]))<span>;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>            <span>continue</span><span>;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>        <span>}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>        res<span>.</span>push_str(<span>&#34;</span><span>\n</span><span>&#34;</span>)<span>;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>    res</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>This is better than the first two attempts, and worse than the third:</p>
<pre><code>test tests::bench_1 ... bench:   6,287,113 ns/iter (+/- 1,510,446)
test tests::bench_2 ... bench:   6,270,934 ns/iter (+/- 2,323,705)
test tests::bench_3 ... bench:   2,838,830 ns/iter (+/- 434,103)
test tests::bench_4 ... bench:   3,621,324 ns/iter (+/- 434,707)</code></pre>
<p>The problem here is that by pushing the results to the returned string immediately, we’re making more calls to <code>data_to_string</code> than the previous attempt. Saving those results was useful.</p>
<h2 id="attempt-5">Attempt #5</h2>
<p>The final version of this algorithm is a hybrid of #3 and #4: I save the results of <code>data_to_string</code> to a <code>Vec&lt;String&gt;</code> to avoid calling that function any more than necessary, and I push the results to the output string as I get them:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span>fn</span> attempt_5(data<span>:</span> <span>Vec</span><span>&lt;</span>Data<span>&gt;</span>) <span>-&gt;</span> <span>String</span> <span>{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span>let</span> n <span>=</span> data<span>.</span>len() <span>*</span> <span>2</span> <span>-</span> <span>1</span><span>;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span>let</span> <span>mut</span> strs <span>=</span> <span>Vec</span><span>::</span><span>&lt;</span><span>String</span><span>&gt;</span><span>::</span>with_capacity(data<span>.</span>len())<span>;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    <span>let</span> <span>mut</span> res <span>=</span> <span>String</span><span>::</span>with_capacity(n <span>*</span> <span>25</span>)<span>;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    <span>for</span> i <span>in</span> <span>0</span><span>..=</span>n <span>{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>        <span>if</span> i <span>&lt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>            strs<span>.</span>push(data_to_string(<span>&amp;</span>data[i]))<span>;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>            res<span>.</span>push_str(<span>&amp;</span>strs[i])<span>;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>if</span> i <span>&gt;</span> data<span>.</span>len() <span>{</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>            res<span>.</span>push_str(<span>&amp;</span>strs[n <span>-</span> i])<span>;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>        <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>            <span>continue</span><span>;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>        <span>}</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>        res<span>.</span>push_str(<span>&#34;</span><span>\n</span><span>&#34;</span>)<span>;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>    res</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>This turns out to be the fastest implementation yet, by a handful of microseconds:</p>
<pre><code>test tests::bench_1 ... bench:   6,287,113 ns/iter (+/- 1,510,446)
test tests::bench_2 ... bench:   6,270,934 ns/iter (+/- 2,323,705)
test tests::bench_3 ... bench:   2,838,830 ns/iter (+/- 434,103)
test tests::bench_4 ... bench:   3,621,324 ns/iter (+/- 434,707)
test tests::bench_5 ... bench:   2,524,902 ns/iter (+/- 1,733,258)</code></pre>
<h2 id="re-implementation">Re-implementation</h2>
<p>Now that I’ve done a few studies of the algorithm, I can implement my learnings back into holoviz. Here’s the part of the code in question, refactored with the better algorithm:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span>let</span> <span>mut</span> frames<span>:</span> <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>=</span> <span>Vec</span><span>::</span>new()<span>;</span> <span>// animation frames</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span>let</span> <span>mut</span> animation_data <span>=</span> <span>String</span><span>::</span>new()<span>;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span>// Create animation frames one by one</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span>for</span> step <span>in</span> <span>0</span><span>..=</span>num_frames <span>{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span>if</span> step <span>&lt;</span> num_steps <span>{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>        <span>let</span> angle <span>=</span> start_angle <span>+</span> step <span>as</span> <span>f32</span> <span>*</span> step_size<span>;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>        frames<span>.</span>push(data_to_string(circular_arc_by_angle(</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>            <span>&amp;</span>center<span>,</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>            r<span>,</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>            angle<span>,</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>            HOLO_WIDTH_DEG<span>,</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>        )))<span>;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>        animation_data<span>.</span>push_str(<span>&amp;</span>frames[step])<span>;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a>    <span>}</span> <span>else</span> <span>if</span> step <span>&gt;</span> num_steps <span>{</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>        animation_data<span>.</span>push_str(<span>&amp;</span>frames[num_frames <span>-</span> step])<span>;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>    <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a>        <span>continue</span><span>;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>    <span>}</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>As expected, this is nearly a 100% performance improvement for the <code>animated_arc</code> function, and a 76% performance improvement for the build animated hologram benchmark:</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Before [ns/iter]</th>
<th>After [ns/iter]</th>
<th>% Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>animated_arc</code></td>
<td>15,274</td>
<td>7,844</td>
<td>94.7%</td>
</tr>
<tr>
<td><code>build_animated_hologram</code></td>
<td>77,287,726</td>
<td>43,899,887</td>
<td>76.1%</td>
</tr>
</tbody>
</table>
<p>But there’s still more waste to be cut out! The <code>circular_arc_by_angle</code> function allocates a new path <code>Data</code> structure to the heap, which is immediately passed to <code>data_to_string</code> which consumes the <code>Data</code> and returns a heap allocated <code>String</code>. We can cut out the middle-man here, so I’ll write a new version of <code>circular_arc_by_angle</code> that returns a string instead:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span>fn</span> circular_arc_animation_by_angle(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    center<span>:</span> <span>&amp;</span>Vec2<span>,</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    radius<span>:</span> <span>f32</span><span>,</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    angle<span>:</span> <span>f32</span><span>,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    width_deg<span>:</span> <span>f32</span><span>,</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>) <span>-&gt;</span> <span>String</span> <span>{</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>    <span>let</span> start <span>=</span> <span>*</span>center <span>+</span> <span>Vec2::</span>from_angle(angle <span>-</span> width_deg<span>.</span>to_radians() <span>/</span> <span>2f32</span>) <span>*</span> radius<span>;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    <span>let</span> end <span>=</span> <span>*</span>center <span>+</span> <span>Vec2::</span>from_angle(angle <span>+</span> width_deg<span>.</span>to_radians() <span>/</span> <span>2f32</span>) <span>*</span> radius<span>;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    <span>format!</span>(</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>        <span>&#34;M{} {} A{} {} 0 0 1 {} {}&#34;</span><span>,</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>        start<span>.</span>x<span>,</span> start<span>.</span>y<span>,</span> radius<span>,</span> radius<span>,</span> end<span>.</span>x<span>,</span> end<span>.</span>y</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>    )</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>I also get to completely delete <code>data_to_string</code> and the original <code>circular_arc_by_angle</code>; deleting old code is <em>so cathartic</em>. Factoring the new function into the code above, I get <em>another</em> performance improvement! The final tally:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Benchmark</th>
<th>Before [ns/iter]</th>
<th>First Refactor [ns/iter]</th>
<th>Second Refactor [ns/iter]</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>animated_arc</code></td>
<td>15,274</td>
<td>7,844</td>
<td>4,076</td>
</tr>
<tr>
<td><code>build_animated_hologram</code></td>
<td>77,287,726</td>
<td>43,899,887</td>
<td>27,040,831</td>
</tr>
</tbody>
</table>
<p>The updated flamegraph shows the <code>animated_arc</code> function taking a much smaller percentage of the overall CPU time:</p>
<figure>
<a href="https://news.ycombinator.com/static/post_images/flamegraph-final.svg"><img src="https://news.ycombinator.com/static/post_images/flamegraph-final.svg" alt=""/></a><figcaption>Baby’s second flamegraph</figcaption>
</figure>
<h2 id="examining-memory-usage">Examining Memory Usage</h2>
<p>In addition to checking the timing of the algorithms above, I can also use the <a href="https://man.archlinux.org/man/memusage.1.en"><code>memusage</code></a> utility to see the profile of the calls to <code>malloc</code> during the life of the program. I ran the program both before and after the optimizations were implemented. The key results are summarized below:</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Original</th>
<th>Optimized</th>
</tr>
</thead>
<tbody>
<tr>
<td>Heap total</td>
<td>17.09 MB</td>
<td>9.84 MB</td>
</tr>
<tr>
<td>Heap peak</td>
<td>6.02 MB</td>
<td>5.79 MB</td>
</tr>
<tr>
<td>Stack peak</td>
<td>11.35 KB</td>
<td>11.35 KB</td>
</tr>
<tr>
<td>Total malloc</td>
<td>397,659</td>
<td>124,179</td>
</tr>
<tr>
<td>Total malloc mem</td>
<td>12.14 MB</td>
<td>6.32 MB</td>
</tr>
</tbody>
</table>
<p>What’s interesting to see here is that the peak heap and stack memory allocations are nearly identical. However, the optimized version has just over half of total heap allocation, with less than <span>1/3</span> of the calls to <code>malloc</code>.</p>
<p>The graphical output for the original and optimized versions of the hologram generation are below. Note that while the y-axes of these images are nearly equal scale, the x-axis of the optimized version is approximately <span>1/3</span> the length as the original.</p>
<p>One interesting feature of these images is the tall spike near the end, which is about ~1.5 MB in height. This corresponds to the 1.4 MB .svg file that is generated by the benchmark test.</p>
<figure>
<img src="https://news.ycombinator.com/static/post_images/memusage_comparison.png" alt=""/><figcaption>Comparison of memory usage for the original algorithm (above) and optimized version (below) for the hologram visualizer benchmark.</figcaption>
</figure>
<p>While both versions free all their memory after writing the .svg, the optimized version allocates only what it needs, when it needs it; the original kept allocating heap memory, most of which shouldn’t have been kept around.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Thinking of programming as art is nothing new, nor is the idea of performing small studies like the one detailed in this post. For further reading on this philosophy, I recommend Manuel Odendahl’s essay on <a href="https://the.scapegoat.dev/having-a-creative-practice-as-a-programmer/">Having a Creative Practice as a Programmer</a>. I owe credit to Max Shron and his 5-minute Recurse Center presentation earlier this year for the inspiration.</p>
<p>In a systems programming language like Rust, there is almost no limit in how deep you can go with optimizing and interrogating your code. The process described here only scratches the surface. When done well, I find that these types of studies enable a deeper understanding of algorithms, memory management, and programming principles.</p>


        <hr/>
        <h2>About</h2>
        <p>I am a new software engineer with nearly a decade of specialized experience in mechanical engineering. This blog chronicles my journey with coding, agile hardware development, and leadership principles.</p>

        <div>
            <a href="mailto:thoughts@datum-b.com">
<svg fill="none" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 7.00005L10.2 11.65C11.2667 12.45 12.7333 12.45 13.8 11.65L20 7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke="white"></path>
<rect x="3" y="5" width="18" height="14" rx="2" stroke-width="2" stroke-linecap="round" stroke="white"></rect>
</svg>
            </a><a href="https://recurse.social/@blair">
<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" xml:space="preserve"><path d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"></path></svg></a>
            <a href="https://github.com/blairfrandeen">
                 <svg width="24" height="24" aria-hidden="true" viewBox="0 0 16 16" version="1.1" data-view-component="true">
    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
</svg></a>
            <a href="https://news.ycombinator.com/feed/">
                <svg width="24" height="24" title="RSS Feed Icon" role="img" aria-label="RSS Feed Icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" tabindex="-1"><path d="M576 1344q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zm512 123q2 28-17 48-18 21-47 21h-135q-25 0-43-16.5t-20-41.5q-22-229-184.5-391.5t-391.5-184.5q-25-2-41.5-20t-16.5-43v-135q0-29 21-47 17-17 43-17h5q160 13 306 80.5t259 181.5q114 113 181.5 259t80.5 306zm512 2q2 27-18 47-18 20-46 20h-143q-26 0-44.5-17.5t-19.5-42.5q-12-215-101-408.5t-231.5-336-336-231.5-408.5-102q-25-1-42.5-19.5t-17.5-43.5v-143q0-28 20-46 18-18 44-18h3q262 13 501.5 120t425.5 294q187 186 294 425.5t120 501.5z"></path></svg></a>
        <p>© 2022 - 2023. The views expressed here are solely my own and do not reflect those of my employer.</p>
        </div>
    </div></div>
  </body>
</html>
