<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sesse.net/blog/tech/2025-10-23-21-23_modern_perfect_hashing.html">Original</a>
    <h1>Modern Perfect Hashing</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Wojciech Muła posted about <a href="http://0x80.pl/notesen/2023-04-30-lookup-in-strings.html">modern perfect hashing for strings</a>
and I wanted to make some comments about my own implementation (that sadly
never got productionized because doubling the speed compared to gperf
wasn&#39;t really that impactful in the end).</p>

<p>First, let&#39;s define the problem, just so we&#39;re all on the same page;
the goal is to create code that maps a known, fixed set of strings to a
predefined integer (per string), and rejects everything else.
This is essentially the same as a hash table, except that since the
set of strings is known ahead of time, we can do better than a normal
hash table. (So no “but I heard SwissTables uses SIMD and thus cannot
be beat”, please. :-) ) My use case is around a thousand strings or so,
and we&#39;ll assume that a couple of minutes of build time is OK (shorter
would be better, but we can probably cache somehow). If you&#39;ve got
millions of strings, and you don&#39;t know them compile-time (for instance
because you want to use your hash table in the join phase of a database),
see <a href="https://arxiv.org/abs/2506.06536">this survey</a>; it&#39;s a different
problem with largely different solutions.</p>

<p>Like Wojciech, I started splitting by length. This means that we can
drop all bounds checking after this, memcmp will be optimized by the
compiler to use SIMD if relevant, and so on.</p>

<p>But after that, he recommends using PEXT (bit extraction, from BMI2), which has
two problems: First, the resulting table can get quite big if your
input set isn&#39;t well-behaved. (You can do better than the greedy algorithm
he suggests, but not infinitely so, and finding the optimal mask quickly
is sort of annoying if you don&#39;t want to embed a SAT solver or something.)
Second, I needed the code to work on Arm, where you simply don&#39;t have this
instruction or anything like it available. (Also, not all x86 has it, and on
older Zen, it&#39;s slow.)</p>

<p>So, we need some other way, short of software emulation of PEXT (which
exists, but we&#39;d like to do better), to convert a sparse set of bits
into a table without any collisions. It turns out the computer chess
community has needed to grapple with this for a long time (they want to
convert from “I have a \<piece\> on \<square\> and there are pieces on
relevant squares \<bitmask\>, give me an index that points to an array
of squares I can move to”), and their solution is to use… well,
<a href="https://www.chessprogramming.org/Magic_Bitboards">magic</a>. It turns out
that if you do something like <code>((value &amp; mask) * magic)</code>, it is very
likely that the upper bits will be collision-free between your different
<code>value</code>s if you try enough different numbers for <code>magic</code>. We can use this
too; for instance, here is code for all length-4 CSS keywords:</bitmask\></square\></piece\></p>

<pre>   static const uint8_t table[] = {
        6,   0,   0,   3,   2,   5,   9,   0,   0,   1,   0,   8,   7,   0,   0,
   };
   static const uint8_t strings[] = {
       1,   0, &#39;z&#39;, &#39;o&#39;, &#39;o&#39;, &#39;m&#39;,
       2,   0, &#39;c&#39;, &#39;l&#39;, &#39;i&#39;, &#39;p&#39;,
       3,   0, &#39;f&#39;, &#39;i&#39;, &#39;l&#39;, &#39;l&#39;,
       4,   0, &#39;l&#39;, &#39;e&#39;, &#39;f&#39;, &#39;t&#39;,
       5,   0, &#39;p&#39;, &#39;a&#39;, &#39;g&#39;, &#39;e&#39;,
       6,   0, &#39;s&#39;, &#39;i&#39;, &#39;z&#39;, &#39;e&#39;,
       7,   0, &#39;f&#39;, &#39;l&#39;, &#39;e&#39;, &#39;x&#39;,
       8,   0, &#39;f&#39;, &#39;o&#39;, &#39;n&#39;, &#39;t&#39;,
       9,   0, &#39;g&#39;, &#39;r&#39;, &#39;i&#39;, &#39;d&#39;,
      10,   0, &#39;m&#39;, &#39;a&#39;, &#39;s&#39;, &#39;k&#39;,
   };

   uint16_t block;
   memcpy(&amp;block, str + 0, sizeof(block));
   uint32_t pos = uint32_t(block * 0x28400000U) &gt;&gt; 28;
   const uint8_t *candidate = strings + 6 * table[pos];
   if (memcmp(candidate + 2, str, 4) == 0) {
     return candidate[0] + (candidate[1] &lt;&lt; 8);
   }
   return 0;
</pre>

<p>There&#39;s a bit to unpack here; we read the first 16 bits from our value
with memcpy (big-endian users beware!), multiply it with the magic value <code>0x28400000U</code> found by trial
and error, shift the top bits down, and now all of our ten candidate
values (“zoom”, “clip”, etc.) have different top four bits. We use that to index
into a small table, check that we got the right one instead of a random collision
(e.g. “abcd”, 0x6261, would get a value of 12, and <code>table[12]</code> is 7,
so we need to disambiguate that from “flex”, which is what we are <em>actually</em> looking
for in that spot), and then return the 16-bit identifier related to the match (or zero,
if we didn&#39;t find it).</p>

<p>We don&#39;t need to use the first 16 bits; we could have used any other
consecutive 16 bits, or any 32 bits, or any 64 bits, or possibly any of
those masked off, or even XOR of two different 32-bit sets if need be. My code
prefers smaller types because a) they tend to give smaller code size
(easier to load into registers, or can even be used as immediates),
and b) you can bruteforce them instead of doing random searches
(which, not the least, has the advantage that you can give up much quicker).</p>

<p>You also don&#39;t really <em>need</em> the intermediate table; if the fit is particularly good,
you can just index directly into the final result without wasting any
space. Here&#39;s the case for length-24 CSS keywords, where we happened to have
exactly 16 candidates <em>and</em> we found a magic giving a perfect (4-bit) value,
making it a no-brainer:</p>

<pre>  static const uint8_t strings[] = {
     95,   0, &#39;b&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;e&#39;, &#39;r&#39;, &#39;-&#39;, &#39;b&#39;, &#39;l&#39;, &#39;o&#39;, &#39;c&#39;, &#39;k&#39;, &#39;-&#39;, &#39;s&#39;, &#39;t&#39;, &#39;a&#39;, &#39;r&#39;, &#39;t&#39;, &#39;-&#39;, &#39;w&#39;, &#39;i&#39;, &#39;d&#39;, &#39;t&#39;, &#39;h&#39;,
     40,   0, &#39;-&#39;, &#39;w&#39;, &#39;e&#39;, &#39;b&#39;, &#39;k&#39;, &#39;i&#39;, &#39;t&#39;, &#39;-&#39;, &#39;t&#39;, &#39;e&#39;, &#39;x&#39;, &#39;t&#39;, &#39;-&#39;, &#39;o&#39;, &#39;r&#39;, &#39;i&#39;, &#39;e&#39;, &#39;n&#39;, &#39;t&#39;, &#39;a&#39;, &#39;t&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;,
    115,   1, &#39;s&#39;, &#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;l&#39;, &#39;l&#39;, &#39;-&#39;, &#39;p&#39;, &#39;a&#39;, &#39;d&#39;, &#39;d&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;, &#39;-&#39;, &#39;b&#39;, &#39;l&#39;, &#39;o&#39;, &#39;c&#39;, &#39;k&#39;, &#39;-&#39;, &#39;e&#39;, &#39;n&#39;, &#39;d&#39;,
    198,   2, &#39;-&#39;, &#39;w&#39;, &#39;e&#39;, &#39;b&#39;, &#39;k&#39;, &#39;i&#39;, &#39;t&#39;, &#39;-&#39;, &#39;t&#39;, &#39;r&#39;, &#39;a&#39;, &#39;n&#39;, &#39;s&#39;, &#39;f&#39;, &#39;o&#39;, &#39;r&#39;, &#39;m&#39;, &#39;-&#39;, &#39;o&#39;, &#39;r&#39;, &#39;i&#39;, &#39;g&#39;, &#39;i&#39;, &#39;n&#39;,
    225,   0, &#39;-&#39;, &#39;i&#39;, &#39;n&#39;, &#39;t&#39;, &#39;e&#39;, &#39;r&#39;, &#39;n&#39;, &#39;a&#39;, &#39;l&#39;, &#39;-&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39;r&#39;, &#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;w&#39;, &#39;-&#39;, &#39;b&#39;, &#39;l&#39;, &#39;o&#39;, &#39;c&#39;, &#39;k&#39;,
    101,   2, &#39;-&#39;, &#39;w&#39;, &#39;e&#39;, &#39;b&#39;, &#39;k&#39;, &#39;i&#39;, &#39;t&#39;, &#39;-&#39;, &#39;b&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;e&#39;, &#39;r&#39;, &#39;-&#39;, &#39;e&#39;, &#39;n&#39;, &#39;d&#39;, &#39;-&#39;, &#39;s&#39;, &#39;t&#39;, &#39;y&#39;, &#39;l&#39;, &#39;e&#39;,
     93,   0, &#39;b&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;e&#39;, &#39;r&#39;, &#39;-&#39;, &#39;b&#39;, &#39;l&#39;, &#39;o&#39;, &#39;c&#39;, &#39;k&#39;, &#39;-&#39;, &#39;s&#39;, &#39;t&#39;, &#39;a&#39;, &#39;r&#39;, &#39;t&#39;, &#39;-&#39;, &#39;c&#39;, &#39;o&#39;, &#39;l&#39;, &#39;o&#39;, &#39;r&#39;,
    102,   2, &#39;-&#39;, &#39;w&#39;, &#39;e&#39;, &#39;b&#39;, &#39;k&#39;, &#39;i&#39;, &#39;t&#39;, &#39;-&#39;, &#39;b&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;e&#39;, &#39;r&#39;, &#39;-&#39;, &#39;e&#39;, &#39;n&#39;, &#39;d&#39;, &#39;-&#39;, &#39;w&#39;, &#39;i&#39;, &#39;d&#39;, &#39;t&#39;, &#39;h&#39;,
    169,   1, &#39;t&#39;, &#39;e&#39;, &#39;x&#39;, &#39;t&#39;, &#39;-&#39;, &#39;d&#39;, &#39;e&#39;, &#39;c&#39;, &#39;o&#39;, &#39;r&#39;, &#39;a&#39;, &#39;t&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;, &#39;-&#39;, &#39;s&#39;, &#39;k&#39;, &#39;i&#39;, &#39;p&#39;, &#39;-&#39;, &#39;i&#39;, &#39;n&#39;, &#39;k&#39;,
    156,   0, &#39;c&#39;, &#39;o&#39;, &#39;n&#39;, &#39;t&#39;, &#39;a&#39;, &#39;i&#39;, &#39;n&#39;, &#39;-&#39;, &#39;i&#39;, &#39;n&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;s&#39;, &#39;i&#39;, &#39;c&#39;, &#39;-&#39;, &#39;h&#39;, &#39;e&#39;, &#39;i&#39;, &#39;g&#39;, &#39;h&#39;, &#39;t&#39;,
    201,   2, &#39;-&#39;, &#39;w&#39;, &#39;e&#39;, &#39;b&#39;, &#39;k&#39;, &#39;i&#39;, &#39;t&#39;, &#39;-&#39;, &#39;t&#39;, &#39;r&#39;, &#39;a&#39;, &#39;n&#39;, &#39;s&#39;, &#39;i&#39;, &#39;t&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;, &#39;-&#39;, &#39;d&#39;, &#39;e&#39;, &#39;l&#39;, &#39;a&#39;, &#39;y&#39;,
    109,   1, &#39;s&#39;, &#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;l&#39;, &#39;l&#39;, &#39;-&#39;, &#39;m&#39;, &#39;a&#39;, &#39;r&#39;, &#39;g&#39;, &#39;i&#39;, &#39;n&#39;, &#39;-&#39;, &#39;i&#39;, &#39;n&#39;, &#39;l&#39;, &#39;i&#39;, &#39;n&#39;, &#39;e&#39;, &#39;-&#39;, &#39;e&#39;, &#39;n&#39;, &#39;d&#39;,
    240,   0, &#39;-&#39;, &#39;i&#39;, &#39;n&#39;, &#39;t&#39;, &#39;e&#39;, &#39;r&#39;, &#39;n&#39;, &#39;a&#39;, &#39;l&#39;, &#39;-&#39;, &#39;v&#39;, &#39;i&#39;, &#39;s&#39;, &#39;i&#39;, &#39;t&#39;, &#39;e&#39;, &#39;d&#39;, &#39;-&#39;, &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;o&#39;, &#39;k&#39;, &#39;e&#39;,
    100,   2, &#39;-&#39;, &#39;w&#39;, &#39;e&#39;, &#39;b&#39;, &#39;k&#39;, &#39;i&#39;, &#39;t&#39;, &#39;-&#39;, &#39;b&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;e&#39;, &#39;r&#39;, &#39;-&#39;, &#39;e&#39;, &#39;n&#39;, &#39;d&#39;, &#39;-&#39;, &#39;c&#39;, &#39;o&#39;, &#39;l&#39;, &#39;o&#39;, &#39;r&#39;,
     94,   0, &#39;b&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;e&#39;, &#39;r&#39;, &#39;-&#39;, &#39;b&#39;, &#39;l&#39;, &#39;o&#39;, &#39;c&#39;, &#39;k&#39;, &#39;-&#39;, &#39;s&#39;, &#39;t&#39;, &#39;a&#39;, &#39;r&#39;, &#39;t&#39;, &#39;-&#39;, &#39;s&#39;, &#39;t&#39;, &#39;y&#39;, &#39;l&#39;, &#39;e&#39;,
    196,   2, &#39;-&#39;, &#39;w&#39;, &#39;e&#39;, &#39;b&#39;, &#39;k&#39;, &#39;i&#39;, &#39;t&#39;, &#39;-&#39;, &#39;t&#39;, &#39;e&#39;, &#39;x&#39;, &#39;t&#39;, &#39;-&#39;, &#39;s&#39;, &#39;i&#39;, &#39;z&#39;, &#39;e&#39;, &#39;-&#39;, &#39;a&#39;, &#39;d&#39;, &#39;j&#39;, &#39;u&#39;, &#39;s&#39;, &#39;t&#39;,
  };

  uint32_t block;
  memcpy(&amp;block, str + 16, sizeof(block));
  uint32_t pos = uint32_t(block * 0xe330a008U) &gt;&gt; 28;
  const uint8_t *candidate = strings + 26 * pos;
  if (memcmp(candidate + 2, str, 24) == 0) {
    return candidate[0] + (candidate[1] &lt;&lt; 8);
  }
  return 0;
</pre>

<p>You can see that we used a 32-bit value here (bytes 16 through 19
of the input), and a corresponding 32-bit magic (though still not
with an AND mask). So we got fairly lucky, but sometimes you do that.
Of course, we need to validate the entire 24-byte value even though
we only discriminated on four of the bytes! (Unless you know for sure
that you never have any out-of-distribution inputs, that is. There are
use cases where this is true.)</p>

<p>(If you wonder what <code>95, 0</code> or similar is above; that&#39;s just
“the answer the user wanted for that input”. It corresponds to
a 16-bit enum in the parser.)</p>

<p>If there are only a few values, we don&#39;t need any of this; just like
Wojciech, we do with a simple compare. Here&#39;s the generated code for
all length-37 CSS keywords, plain and simple:</p>

<pre>  if (memcmp(str, &#34;-internal-inactive-list-box-selection&#34;, 37) == 0) {
    return 171;
  }
  return 0;
</pre>

<p>(Again 171 is “the desired output for that input”, not a value the
code generator decides in any way.)</p>

<p>So how do we find these magic values? There&#39;s really only one way:
Try lots of different ones and see if they work. But there&#39;s a trick
to accelerate “see if they work”, which I also borrowed from computer
chess: The <a href="https://en.wikipedia.org/wiki/Killer_heuristic">killer heuristic</a>.</p>

<p>See, to try if a magic is good, you generally try to hash all the
different values and see if any two go into the same bucket. (If
they do, it&#39;s not a perfect hash and the entire point of the exercise
is gone.) But it turns out that most of the time, it&#39;s the <em>same two</em>
values that collide. So every couple hundred candidates, we check
which two values disproved the magic, and put those in a slot. Whenever
we check magics, we can now try those first, and more likely than not,
discard the candidate right away and move on to the next one (whether
it is by exhaustive search or randomness). It&#39;s actually a significant
speedup.</p>

<p>But occasionally, we simply cannot find a magic for a given group; either
there is none, or we didn&#39;t have enough time to scan through enough of the
64-bit space.  At this point, Wojciech suggests we switch on one of the
characters (heuristically) to get smaller subgroups and try again.
I didn&#39;t actually find this to perform all that well; indirect branch
predictors are better than 20 years ago, but the pattern is typically
not that predictable. What I tried instead was to have more of a yes/no
on some character (i.e., a non-indirect branch), which makes for a coarser
split.</p>

<p>It&#39;s not at all obvious where the best split would be. You&#39;d intuitively
think that 50/50 would be a good idea, but if you have e.g. 40 elements,
you&#39;d much rather split them 32/8… if you can find perfect hashes for
both subgroups (5-bit and 3-bit, respectively). If not, a 20–20 split
is most likely better, since you very easily can find magics that put
20 elements into 32 buckets without collisions. I ended up basically
trying all the different splits and scoring them, but this makes the
searcher rather slow, and it means you basically must have some sort of
cache if you want to run it as part of your build system. This is the
part I&#39;m by far the least happy about; gperf isn&#39;t great by modern
standards, but it never feels slow to run.</p>

<p>The end result for me was: Runtime about twice as fast as gperf,
compiled code about half as big. That&#39;s with everything hard-coded;
if you&#39;re pushed for space (or are icache-bound), you could make
more generic code at the expense of some speed.</p>

<p>So, if anyone wants to make a more modern gperf, I guess this space
is up for grabs? It&#39;s not exactly technology that will make your stock
go to AI levels, though.</p>

</div></div>
  </body>
</html>
