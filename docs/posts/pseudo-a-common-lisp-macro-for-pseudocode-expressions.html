<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://funcall.blogspot.com/2025/07/pseudo.html">Original</a>
    <h1>Pseudo, a Common Lisp macro for pseudocode expressions</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3014087669365263200" itemprop="description articleBody">
<p>I was wondering what it would look like if a large language model
  were part of your programming language.  I&#39;m not talking about
  calling the model as an API, but rather embedding it as a language
  construct.  I came up with this idea as a first cut.</p>

<p>The <code>pseudo</code> macro allows you to embed pseudocode
  expressions in your Common Lisp code.  It takes a string description
  and uses an LLM to expand it into an s-expression.  You can
  use <code>pseudo</code> anywhere an expression would be
  expected.</p>

<pre>(defun my-func (a b)
  (pseudo &#34;multiply b by factorial of a.&#34;))
MY-FUNC

(my-func 5 3)
360

(defun quadratic (a b c)
  (let ((d (sqrt (pseudo &#34;compute discriminant of quadratic equation&#34;))))
    (values (/ (+ (- b) d) (* 2 a)) (/ (- (- b) d) (* 2 a)))))
QUADRATIC

(quadratic 1 2 -3)
1.0
-3.0</pre>

<p>The <code>pseudo</code> macro gathers contextual information and
  packages it up in a big set of system instructions to the LLM.  The
  instructions include</p>

<ul><li>the lexically visible variables in the macro
      environment</li>
    <li>fbound symbols</li>
    <li>bound symbols</li>
    <li>overall directives to influence code generation</li>
    <li>directives to influence the style of the generated code
    (functional vs. imperative)</li>
    <li>directives to influence the use of the loop macro (prefer
      vs. avoid)</li>
    <li>the source code of the file currently being compiled, if there
    is one</li></ul>

<p><code>pseduo</code> sets the LLM to use a low temperature for more
  predictable generation.  It prints the “thinking” of the
  LLM.</p>

<p>Lisp is a big win here.  Since Lisp&#39;s macro system operates at the
  level of s-expressions, it has more contextual information available
  to it than a macro system that is just text expansion.  The
  s-expression representation means that we don&#39;t need to interface
  with the language&#39;s parser or compiler to operate on the syntax tree
  of the code.  Adding <code>pseudo</code> to a language like Java
  would be a much more significant undertaking.</p>

<p><code>pseudo</code> has the usual LLM caveats:</p>
<ul><li>The LLM is slow.</li>
  <li>The LLM can be expensive.</li>
  <li>The LLM can produce unpredictable and unwanted code.</li>
  <li>The LLM can produce incorrect code; the more precise you
  are in your pseudocode, the more likely you are to get the results
    you want.</li>
  <li>You would be absolutely mad to use this in production.</li></ul>

<p><code>pseudo</code> has one dependency on SBCL which is a function
  to extract the lexically visible variables from the macro
  environment.  If you port it to another Common Lisp, you&#39;ll want to
  provide an equivalent function.</p>

<p><code>pseudo</code> was developed using Google&#39;s Gemini as the back
  end, but there&#39;s no reason it couldn&#39;t be adapted to use other
  LLMs.  To try it out, you&#39;ll need the gemini library, available
  at <a href="https://github.com/jrm-code-project/gemini">https://github.com/jrm-code-project/gemini</a>,
  and a Google API key.</p>

<p>Download <code>pseudo</code>
  from <a href="https://github.com/jrm-code-project/pseudo">https://github.com/jrm-code-project/pseudo</a>.</p>

<p>You&#39;ll also need these dependencies.
  </p><ul><li><code>alexandria</code> — available from Quicklisp</li>
    <li><code>cl-json</code> — available from Quicklisp</li>
    <li><code>dexador</code> — available from Quicklisp</li>
    <li><code>fold</code> — <a href="https://github.com/jrm-code-project/fold">https://github.com/jrm-code-project/fold</a></li>
    <li><code>function</code> — <a href="https://github.com/jrm-code-project/function">https://github.com/jrm-code-project/function</a></li>
    <li><code>named-let</code> — <a href="https://github.com/jrm-code-project/named-let">https://github.com/jrm-code-project/named-let</a></li>
    <li><code>uiop</code> — available from Quicklisp</li></ul>


<p>If you try it, let me know how it goes.</p>

</div></div>
  </body>
</html>
