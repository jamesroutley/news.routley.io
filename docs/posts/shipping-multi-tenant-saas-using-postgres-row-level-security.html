<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thenile.dev/blog/multi-tenant-rls">Original</a>
    <h1>Shipping Multi-Tenant SaaS Using Postgres Row-Level Security</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content" itemprop="articleBody"><p>At Nile, we’re making it easier for companies to build world-class control planes for their infra SaaS products. Multi-tenancy is core to all SaaS products and especially those with <a href="https://www.thenile.dev/blog/infrastructure-saas?utm_source=blog.nile&amp;utm_medium=blog&amp;utm_campaign=pg_rls_blog&amp;utm_content=cross_link" target="_blank" rel="">control-plane architectures</a>. At Nile, we’ve built multi-tenancy into our product from day one. If you are working on an infra SaaS product and need a multi-tenant control plane, you should <a href="https://thenile.dev?utm_source=blog.nile&amp;utm_medium=blog&amp;utm_campaign=pg_rls_blog&amp;utm_content=top_link" target="_blank" rel=""> talk to us</a>.</p><p>From previous experience, we’re familiar with multiple multi-tenant SaaS
architecture options. We decided to store everything in a single Postgres schema since it provides a
balance of scalability, cost optimization, and flexibility. However, this requires serious investment in
database authorization to guarantee that we never leak customer data.</p><p>Authorization in a multi-tenant db is something many companies have to deal with, and in previous
companies, I saw authorization implemented in probably the most common way:
appending <code>WHERE user_id = $USER_ID</code> to queries. This is also the way things started out at
Nile, but as we added more features we noticed that we were forced to add many branching and
repetitive <code>WHERE</code>s to our code. We needed a solution that would allow us to add features quickly
and confidently, and using custom filters in every single query was error-prone and hard to evolve
if our data model changed.</p><p><img loading="lazy" alt="RLS code excerpt" src="https://donnywinston.com/assets/images/code_excerpt-d674395f49df852f14a6b229544b2aa1.png" width="1451" height="295"/></p><p>One solution that I knew about was
Postgres <a href="https://www.postgresql.org/docs/9.5/ddl-rowsecurity.html" target="_blank" rel="noopener noreferrer">Row-Level Security</a> (RLS), a
db-level mechanism that filters rows based on a per-user basis. I expected it would allow us to
iterate faster and dramatically reduce security risks. You can learn the basics with
these <a href="https://www.bytefish.de/blog/spring_boot_multitenancy_using_rls.html" target="_blank" rel="noopener noreferrer">two</a> <a href="https://callistaenterprise.se/blogg/teknik/2020/10/24/multi-tenancy-with-spring-boot-part6/" target="_blank" rel="noopener noreferrer">blogs</a>
that show how to build multi-tenant apps using Postgres RLS. As with most solutions, the blog
version was easy to implement, but there was an especially long tail to ship to production.</p><p>In this blog post, I’ll talk about the alternatives we considered - both for multi-tenant
architecture and for securing data access - why we chose RLS, and the various challenges we
encountered and overcame while shipping it to production.</p><h2 id="existing-multi-tenancy-solutions">Existing multi-tenancy solutions<a href="#existing-multi-tenancy-solutions" title="Direct link to heading">​</a></h2><h3 id="schema-per-tenant-and-database-per-tenant">Schema-per-tenant and database-per-tenant<a href="#schema-per-tenant-and-database-per-tenant" title="Direct link to heading">​</a></h3><p>We considered both of these approaches but went with the single-schema approach for its minimal
operational complexity, low cost, and ability to scale later on. I won’t go into detail about these
approaches, as there are countless resources on the topic. Here are two resources I’ve found to be
helpful:</p><ol><li><a href="https://docs.microsoft.com/en-us/azure/azure-sql/database/saas-tenancy-app-design-patterns?view=azuresql" target="_blank" rel="noopener noreferrer">Multi-tenant SaaS patterns - Azure SQL Database | Microsoft Docs</a></li><li>A great paper from Microsoft -<a href="https://renatoargh.files.wordpress.com/2018/01/article-multi-tenant-data-architecture-2006.pdf" target="_blank" rel="noopener noreferrer">Multi-Tenant Data Architecture</a></li></ol><h3 id="single-schema-with-dynamic-where-queries">Single schema with dynamic WHERE queries<a href="#single-schema-with-dynamic-where-queries" title="Direct link to heading">​</a></h3><h4 id="pros">Pros<a href="#pros" title="Direct link to heading">​</a></h4><ol><li>Easiest and most straightforward zero-to-one solution.</li><li>Transparent and easy to reason about.</li></ol><h4 id="cons">Cons<a href="#cons" title="Direct link to heading">​</a></h4><ol><li>Possibility of forgetting to add a filter to a query. Since queries are permissive by default,
this
is easy to miss and hard to detect without extensive testing. There are some solutions to this (
i.e: <a href="https://callistaenterprise.se/blogg/teknik/2020/10/17/multi-tenancy-with-spring-boot-part5/" target="_blank" rel="noopener noreferrer">@Filter in Hibernate</a>)
but I find that ORMs make simple querying easier and complicated querying harder. At Nile, our
authorization model is complicated enough that we didn’t want to rely on Hibernate for this.</li><li>Repetitive, ugly, and annoying to implement. Imagine you have 20 API endpoints that require
authorization and 2 different types of roles, <code>USER</code> and <code>ADMIN</code>. The access controls for these
two
roles are different, so you might have to define 40 <code>WHERE</code>s across your codebase. This doesn&#39;t scale well when adding new roles or modifying existing ones across many API endpoints.</li></ol><h3 id="external-authorization-systems">External authorization systems<a href="#external-authorization-systems" title="Direct link to heading">​</a></h3><h4 id="pros-1">Pros<a href="#pros-1" title="Direct link to heading">​</a></h4><ol><li>Highly flexible</li><li>(Claim to be) scalable</li></ol><h4 id="cons-1">Cons<a href="#cons-1" title="Direct link to heading">​</a></h4><ol><li>$$$ cost, if managed. Operational cost, if self-hosted.</li><li>Unnecessary if the permissioning model isn’t particularly complicated. At Nile, so far it’s not.</li><li>External dependencies often make testing more difficult and reduce engineering velocity. The
benefits have to outweigh these costs.</li><li>As a control plane, multi-tenancy is core to our product. We believe in building foundational
capabilities in-house so that we can push the envelope rather than be constrained by external
solutions.</li></ol><h3 id="what-might-a-better-solution-look-like">What might a better solution look like?<a href="#what-might-a-better-solution-look-like" title="Direct link to heading">​</a></h3><p>After we chose to use a single multi-tenant schema, we were looking for a solution that would be
cleaner and less error-prone than dynamic queries and lighter than an external authorization
system.</p><p>In the rest of this blog post, I’ll lay out what I discovered about RLS in the few weeks I spent
researching and implementing it at Nile, and how it solved our problem (at least for now) of
building authorization with speed, confidence, and maintainable architecture.</p><h2 id="a-quick-overview-of-rls">A quick overview of RLS<a href="#a-quick-overview-of-rls" title="Direct link to heading">​</a></h2><p>The high-level process to set up RLS is:</p><ol><li>Define your data model as usual, but include a tenant identifier in every table</li><li>Define RLS policies on your tables (i.e: “only return rows for the current tenant”)</li><li>Define a db user (i.e: <code>app_user</code>) with all the privileges your application will need to interact
with the db, but without any superuser roles. In Postgres, this is necessary
since <a href="https://www.postgresql.org/docs/current/sql-createrole.html" target="_blank" rel="noopener noreferrer">superuser roles bypass all permission checks</a>
, including RLS  (more on that later).</li></ol><h3 id="a-simple-org-access-control-example">A simple org access control example<a href="#a-simple-org-access-control-example" title="Direct link to heading">​</a></h3><p>Imagine your API has an <code>/orgs</code> endpoint that should only return organizations the calling user
is a member of. To achieve this via RLS, you’d define your tables, policies, and db user as such:</p><div><p>rls_policy_setup.sql</p><div><pre tabindex="0"><code><span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>TABLE</span><span></span><br/></span><span><span>    users</span><span>(</span><span></span><br/></span><span><span>      id </span><span>SERIAL</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span></span><br/></span><span><span>    </span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>TABLE</span><span></span><br/></span><span><span>    orgs</span><span>(</span><span></span><br/></span><span><span>      id </span><span>SERIAL</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span></span><br/></span><span><span>    </span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>TABLE</span><span></span><br/></span><span><span>    org_members</span><span>(</span><span></span><br/></span><span><span>      </span><span>user</span><span> </span><span>INTEGER</span><span> </span><span>REFERENCES</span><span> users </span><span>NOT</span><span> </span><span>NULL</span><span>,</span><span></span><br/></span><span><span>      org </span><span>INTEGER</span><span> </span><span>REFERENCES</span><span> orgs </span><span>NOT</span><span> </span><span>NULL</span><span></span><br/></span><span><span>    </span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>-- ** RLS setup **</span><span></span><br/></span><span><span></span><span>ALTER</span><span> </span><span>TABLE</span><span></span><br/></span><span><span>  orgs </span><span>ENABLE</span><span> </span><span>ROW</span><span> </span><span>LEVEL</span><span> SECURITY</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>-- Create a function, current_app_user(),</span><span></span><br/></span><span><span></span><span>-- that returns the user to authorize against.</span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>FUNCTION</span><span> current_app_user</span><span>(</span><span>)</span><span> </span><span>RETURNS</span><span> </span><span>INTEGER</span><span> </span><span>AS</span><span> $$ </span><span>SELECT</span><span></span><br/></span><span><span>    </span><span>NULLIF</span><span>(</span><span></span><br/></span><span><span>      current_setting</span><span>(</span><span></span><br/></span><span><span>        </span><span>&#39;app.current_app_user&#39;</span><span>,</span><span></span><br/></span><span><span>        </span><span>TRUE</span><span></span><br/></span><span><span>      </span><span>)</span><span>,</span><span></span><br/></span><span><span>      </span><span>&#39;&#39;</span><span></span><br/></span><span><span>    </span><span>)</span><span>::</span><span>INTEGER</span><span> $$ </span><span>LANGUAGE</span><span> </span><span>SQL</span><span> SECURITY </span><span>DEFINER</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  POLICY org_member_policy </span><span>ON</span><span></span><br/></span><span><span>  orgs</span><br/></span><span><span>    </span><span>USING</span><span>(</span><span></span><br/></span><span><span>    </span><span>EXISTS</span><span>(</span><span></span><br/></span><span><span>      </span><span>SELECT</span><span></span><br/></span><span><span>        </span><span>1</span><span></span><br/></span><span><span>      </span><span>FROM</span><span></span><br/></span><span><span>        org_members</span><br/></span><span><span>      </span><span>WHERE</span><span></span><br/></span><span><span>        </span><span>user</span><span> </span><span>=</span><span> current_app_user</span><span>(</span><span>)</span><span></span><br/></span><span><span>        </span><span>AND</span><span> org </span><span>=</span><span> id</span><br/></span><span><span>    </span><span>)</span><span></span><br/></span><span><span>  </span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>-- Create the db user that&#39;ll be used in your application.</span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>USER</span><span> app_user</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>GRANT</span><span> </span><span>ALL</span><span> </span><span>PRIVILEGES</span><span> </span><span>ON</span><span></span><br/></span><span><span></span><span>ALL</span><span> </span><span>TABLES</span><span> </span><span>IN</span><span> </span><span>SCHEMA</span><span> </span><span>public</span><span> </span><span>TO</span><span> app_user</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>GRANT</span><span> </span><span>ALL</span><span> </span><span>PRIVILEGES</span><span> </span><span>ON</span><span></span><br/></span><span><span></span><span>ALL</span><span> SEQUENCES </span><span>IN</span><span> </span><span>SCHEMA</span><span> </span><span>public</span><span> </span><span>TO</span><span> app_user</span><span>;</span><br/></span></code></pre></div></div><p>The above RLS policy will only return true for organizations that the current user is a member of.
Simple enough. Later on, we’ll see how things can get more complicated.</p><p>Note the <code>current_app_user()</code> function. In the traditional use case of direct db access, RLS works
by defining policies on tables that filter rows based on the current db user. For a SaaS
application, however, defining a new db user for each app user is clunky. For an application use
case you can dynamically set and retrieve users using
Postgres’ <a href="https://pgpedia.info/c/current_setting.html" target="_blank" rel="noopener noreferrer">current_settings()</a> function (
i.e: <code>SET app.current_app_user = ‘usr_123’</code> and <code>SELECT current_settings(‘app.current_app_user)</code>).</p><h3 id="what-it-looks-like-from-request-to-response">What it looks like from request to response<a href="#what-it-looks-like-from-request-to-response" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="Request to response diagram" src="https://donnywinston.com/assets/images/request_to_response-950f16d457f68b78550ec022fdb5c586.svg" width="1916" height="1183"/></p><h2 id="why-we-chose-rls">Why we chose RLS<a href="#why-we-chose-rls" title="Direct link to heading">​</a></h2><h3 id="it-fails-by-default---and-therefore-secure-by-default">It fails by default - and therefore secure by default<a href="#it-fails-by-default---and-therefore-secure-by-default" title="Direct link to heading">​</a></h3><p>The biggest benefit of RLS is that if you define a policy that’s too restrictive, or forget to
define a policy, things just fail. Compared to dynamic queries where forgetting to add a <code>WHERE</code>
will leak data, this is a big win for security. I didn’t appreciate this until I wrote some
integration tests for access patterns (i.e: testing if a user can access orgs they’re a part of).
Initially, all the tests failed, and for cases where users should have access tests only passed when
I added the appropriate RLS policies.</p><p>RLS is, of course, not a silver bullet. Accidentally defining an overly permissive policy is hard to
catch without extensive tests so it’s important to still be careful.</p><h3 id="defined-once-applied-everywhere">Defined once, applied everywhere<a href="#defined-once-applied-everywhere" title="Direct link to heading">​</a></h3><p>One of the main challenges with dynamic queries in single-schema multi-tenancy is that changes to
tables often require touching many different queries. RLS solves this problem since <strong>policies are
tied to tables and not queries</strong>. After modifying a table, all you need to do is to change its
access
policies, which will be applied to all queries.</p><h3 id="composability">Composability<a href="#composability" title="Direct link to heading">​</a></h3><p>With RLS, it’s easy to add more access rules as your multi-tenant data model evolves. According to
the
<a href="https://www.postgresql.org/docs/current/ddl-rowsecurity.html#:~:text=When%20multiple%20policies%20apply%20to,they%20are%20a%20member%20of." target="_blank" rel="noopener noreferrer">Postgres docs</a>:</p><blockquote><p><em>“When multiple policies apply to a given query, they are combined using either OR (for permissive
policies, which are the default) or using AND (for restrictive policies).”</em></p></blockquote><p>Since by default policies are combined with OR, this makes it super easy to define more policies as
your access rules get more complex. This isn’t so straightforward with dynamic queries, where you
might have to define your own logic for combining access rules. Or, as probably many of us have seen
before, just create monster <code>WHERE</code> statements.</p><h3 id="separation-of-concerns">Separation of Concerns<a href="#separation-of-concerns" title="Direct link to heading">​</a></h3><p>Instead of mixing filters that are related to our application logic with filters that are related to
the multi-tenant database design in the same WHERE clauses, we now have a clean separation:</p><ul><li>Our application applies all the filters that are requested by users through APIs and other
application logic.</li><li>RLS is responsible for filters that are required due to the multi-tenant database design.</li></ul><h2 id="cases-where-rls-isnt-a-great-fit">Cases where RLS isn’t a great fit<a href="#cases-where-rls-isnt-a-great-fit" title="Direct link to heading">​</a></h2><p>Every technology has its tradeoffs and cases where you shouldn’t use it. Here are two cases where we
think RLS isn’t a great fit:</p><h4 id="if-you-need-stronger-isolation-between-tenants">If you need stronger isolation between tenants<a href="#if-you-need-stronger-isolation-between-tenants" title="Direct link to heading">​</a></h4><p>RLS in a multi-tenant db isolates access to database rows, but all other database resources are
still shared between tenants. It doesn’t help with limiting the disk space, CPU, or db cache used
per tenant. If you need stronger isolation at the db level, you will need to look elsewhere.</p><h4 id="if-you-have-sophisticated-access-policies">If you have sophisticated access policies<a href="#if-you-have-sophisticated-access-policies" title="Direct link to heading">​</a></h4><p>As you will see in the next section, our current access policy is fairly simple - tenants are
isolated from each other, and within a tenant, you have administrators with additional access. More
mature access control policies such as RBAC/ABAC require their own schema design and can be more
challenging to integrate with RLS and even more challenging to make performant.</p><p>We’ve recently started the design for the RBAC/ABAC feature in Nile (talk to us if you are
interested in joining the conversation), and we will have a follow-up blog with recommendations on
best practices for adding RBAC/ABAC to multi-tenant SaaS.</p><h2 id="implementation-challenges">Implementation challenges<a href="#implementation-challenges" title="Direct link to heading">​</a></h2><h3 id="a-few-gotchas">A few gotchas<a href="#a-few-gotchas" title="Direct link to heading">​</a></h3><p><strong>One gotcha we encountered was that RLS doesn’t apply to superusers and table owners.</strong> According
to
the <a href="https://www.postgresql.org/docs/current/ddl-rowsecurity.html#:~:text=Superusers%20and%20roles%20with%20the,security%20with%20ALTER%20TABLE%20..." target="_blank" rel="noopener noreferrer">Postgres docs</a>:</p><blockquote><p><em>“Superusers and roles with the BYPASSRLS attribute always bypass the row security system when
accessing a table. Table owners normally bypass row security as well, though a table owner can
choose to be subject to row security with ALTER TABLE ... FORCE ROW LEVEL SECURITY.”</em></p></blockquote><p>Both of the blogs I shared earlier create a user called <code>app_user</code> that’s used in the application.
We did this as well, locally, but didn’t change the database user when deploying to our testing
environment. Thankfully, we caught and fixed this issue quickly.</p><p><strong>Another issue we caught during testing was that some requests were being authorized with a
previous
request’s user id.</strong> We discovered that since the user id for RLS was being stored in
thread-local storage and threads were being reused for requests, it was necessary to set up a
post-response handler to reset thread-local storage.</p><p>Overall, so far the gotchas haven’t been too tricky to diagnose and resolve, but as one might expect
with anything security-related, they do have serious consequences if not addressed.</p><h3 id="initial-widespread-code-changes">Initial widespread code changes<a href="#initial-widespread-code-changes" title="Direct link to heading">​</a></h3><p>Although RLS addresses the problem of continuous widespread changes well (see <a href="https://thenile.dev/blog#defined-once-applied-everywhere" target="_blank" rel="noopener noreferrer">“Defined once, applied
everywhere”</a>), initially switching from dynamic queries to RLS requires more code changes than you
might think. Here’s an example of how RLS might affect an API endpoint to update an organization
that’s only callable by users in that org:</p><div><p>before_and_after_rls.java</p><div><pre tabindex="0"><code><span><span>/*</span><br/></span><span><span>** ---- Without RLS ---- **</span><br/></span><span><span></span><br/></span><span><span>1. Check if user is a member of the org</span><br/></span><span><span>  a. If so, execute the update query</span><br/></span><span><span>  b. Else, return a 404</span><br/></span><span><span>*/</span><span></span><br/></span><span><span></span><br/></span><span><span>Org </span><span>update</span><span>(</span><span>userId</span><span>,</span><span> orgId</span><span>,</span><span> updatePayload</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span>if</span><span> </span><span>(</span><span>dao</span><span>.</span><span>isOrgMember</span><span>(</span><span>userId</span><span>,</span><span> orgId</span><span>)</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>return</span><span> dao</span><span>.</span><span>updateOrg</span><span>(</span><span>updatePayload</span><span>)</span><span>;</span><span></span><br/></span><span><span>  </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>throw</span><span> </span><span>new</span><span> </span><span>NotFoundException</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>  </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>/* -- DAO layer -- */</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>boolean</span><span> </span><span>isOrgMember</span><span>(</span><span>userId</span><span>,</span><span> orgId</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span>return</span><span> </span><span>query</span><span>(</span><span>&#34;EXISTS(SELECT 1 ...)&#34;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span>Org </span><span>updateOrg</span><span>(</span><span>updatePayload</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span>return</span><span> </span><span>query</span><span>(</span><span>&#34;UPDATE orgs SET ... RETURNING *&#34;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>/*</span><br/></span><span><span>** ----- With RLS ---- **</span><br/></span><span><span></span><br/></span><span><span>1. Execute the update query</span><br/></span><span><span>  a. If the org was returned from the db, return the org in the response</span><br/></span><span><span>  b. Else, return a 404</span><br/></span><span><span>*/</span><span></span><br/></span><span><span></span><br/></span><span><span>Org </span><span>update</span><span>(</span><span>userId</span><span>,</span><span> orgId</span><span>,</span><span> updatePayload</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>    Optional</span><span>&lt;</span><span>Org</span><span>&gt;</span><span> maybeOrg </span><span>=</span><span> dao</span><span>.</span><span>updateOrg</span><span>(</span><span>updatePayload</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>if</span><span> </span><span>(</span><span>maybeOrg</span><span>.</span><span>isPresent</span><span>(</span><span>)</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>      </span><span>return</span><span> maybeOrg</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span><br/></span><span><span>       </span><span>throw</span><span> </span><span>new</span><span> </span><span>NotFoundException</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>/* -- DAO layer -- */</span><span></span><br/></span><span><span></span><br/></span><span><span>Optional</span><span>&lt;</span><span>Org</span><span>&gt;</span><span> </span><span>updateOrg</span><span>(</span><span>updatePayload</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span>return</span><span> </span><span>query</span><span>(</span><span>&#34;UPDATE orgs SET ... RETURNING *&#34;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>In this example, authorization without RLS is done before writing to the db. With RLS, since
authorization is determined at query time, write queries might fail so error handling has to be
pushed down to the db level. This isn’t a mind-boggling change but is one you should keep in mind
when planning to add RLS in any project that involves a multi-tenant db.</p><h2 id="the-gaps-between-blog-ready-and-production-ready-rls">The gaps between blog-ready and production-ready RLS<a href="#the-gaps-between-blog-ready-and-production-ready-rls" title="Direct link to heading">​</a></h2><h3 id="recursive-permission-policies">Recursive permission policies<a href="#recursive-permission-policies" title="Direct link to heading">​</a></h3><p>Let’s say you want to add an admin user type and implement the following access rules:</p><ol><li>Users can read, update, and delete their own user profiles.</li><li>Users can read the profiles of other users who belong to the same tenant.</li><li>Users with admin access can read, update, and delete other users who belong to the same tenant.</li></ol><p>The first two use cases are possible with straightforward RLS policies, but the third isn’t. This is
because we must query the <code>users</code> table to see if the user in question is an admin (
i.e: <code>SELECT 1 FROM users WHERE id = current_app_user() AND is_admin = TRUE</code>). Since querying a
table triggers its RLS policy checks, executing this query within a <code>users</code> RLS policy will
trigger <code>users</code> RLS policy checks, which will call this query, which will trigger RLS policy checks,
resulting in an infinite loop. Postgres will catch this error instead of timing out, but you should
make sure to test your policies so this doesn’t happen at runtime. You can avoid this problem by
defining a function with <code>SECURITY DEFINER</code> permissions that’s to be used in the RLS
policy. According to
the <a href="https://www.postgresql.org/docs/current/sql-createfunction.html#:~:text=SECURITY%20DEFINER%20specifies%20that%20the,functions%20not%20only%20external%20ones." target="_blank" rel="noopener noreferrer">Postgres docs</a>:</p><blockquote><p><em>&#34;<code>SECURITY DEFINER</code> specifies that the function is to be executed with the privileges of the user
that owns it.&#34;</em></p></blockquote><p>In our case, this user is the superuser that you probably used to set up your database. So they
bypass RLS.</p><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</p><p>By using <code>SECURITY DEFINER</code> you are allowing users to bypass the security policy and use
superuser
privileges regardless of who they really are, so you must be careful. I recommend reviewing the
“<a href="https://www.postgresql.org/docs/current/sql-createfunction.html#:~:text=Writing%20SECURITY%20DEFINER%20Functions%20Safely&amp;text=For%20security%2C%20search_path%20should%20be,be%20used%20by%20the%20function." target="_blank" rel="noopener noreferrer">Writing SECURITY DEFINER Functions Safely</a>
” section of the Postgres documentation before using this capability.</p></div><p>Here’s an example of how to implement RLS policies that satisfy the three use cases above:</p><div><p>complex_rls_policy.sql</p><div><pre tabindex="0"><code><span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>TABLE</span><span></span><br/></span><span><span>    users</span><span>(</span><span></span><br/></span><span><span>      id </span><span>SERIAL</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span>,</span><span></span><br/></span><span><span>      is_admin </span><span>BOOLEAN</span><span></span><br/></span><span><span>    </span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>ALTER</span><span> </span><span>TABLE</span><span></span><br/></span><span><span>  users </span><span>ENABLE</span><span> </span><span>ROW</span><span> </span><span>LEVEL</span><span> SECURITY</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>-- Users can do anything to themselves.</span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  POLICY self_policy </span><span>ON</span><span></span><br/></span><span><span>  users</span><br/></span><span><span>    </span><span>USING</span><span>(</span><span></span><br/></span><span><span>    id </span><span>=</span><span> current_app_user</span><span>(</span><span>)</span><span></span><br/></span><span><span>  </span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>FUNCTION</span><span> is_user_admin</span><span>(</span><span></span><br/></span><span><span>    _user_id </span><span>INTEGER</span><span></span><br/></span><span><span>  </span><span>)</span><span> </span><span>RETURNS</span><span> </span><span>bool</span><span> </span><span>AS</span><span> $$ </span><span>SELECT</span><span></span><br/></span><span><span>    </span><span>EXISTS</span><span>(</span><span></span><br/></span><span><span>      </span><span>SELECT</span><span></span><br/></span><span><span>        </span><span>1</span><span></span><br/></span><span><span>      </span><span>FROM</span><span></span><br/></span><span><span>        users</span><br/></span><span><span>      </span><span>WHERE</span><span></span><br/></span><span><span>        id </span><span>=</span><span> _user_id</span><br/></span><span><span>        </span><span>AND</span><span> is_admin </span><span>=</span><span> </span><span>TRUE</span><span></span><br/></span><span><span>    </span><span>)</span><span> $$ </span><span>LANGUAGE</span><span> </span><span>SQL</span><span> SECURITY </span><span>DEFINER</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  </span><span>FUNCTION</span><span> do_users_share_org</span><span>(</span><span></span><br/></span><span><span>    _user_id_1 </span><span>INTEGER</span><span>,</span><span></span><br/></span><span><span>    _user_id_2 </span><span>INTEGER</span><span></span><br/></span><span><span>  </span><span>)</span><span> </span><span>RETURNS</span><span> </span><span>bool</span><span> </span><span>AS</span><span> $$ </span><span>SELECT</span><span></span><br/></span><span><span>    </span><span>EXISTS</span><span>(</span><span></span><br/></span><span><span>      </span><span>SELECT</span><span></span><br/></span><span><span>        </span><span>1</span><span></span><br/></span><span><span>      </span><span>FROM</span><span></span><br/></span><span><span>        org_members om1</span><span>,</span><span></span><br/></span><span><span>        org_members om2</span><br/></span><span><span>      </span><span>WHERE</span><span></span><br/></span><span><span>        om1</span><span>.</span><span>user</span><span> </span><span>!=</span><span> om2</span><span>.</span><span>user</span><span></span><br/></span><span><span>        </span><span>AND</span><span> om1</span><span>.</span><span>org </span><span>=</span><span> om2</span><span>.</span><span>org</span><br/></span><span><span>        </span><span>AND</span><span> om1</span><span>.</span><span>user</span><span> </span><span>=</span><span> _user_id_1</span><br/></span><span><span>        </span><span>AND</span><span> om2</span><span>.</span><span>user</span><span> </span><span>=</span><span> _user_id_2</span><br/></span><span><span>    </span><span>)</span><span> $$ </span><span>LANGUAGE</span><span> </span><span>SQL</span><span> SECURITY </span><span>INVOKER</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>-- Non-admins can only read users in their orgs.</span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  POLICY read_in_shared_orgs_policy </span><span>ON</span><span></span><br/></span><span><span>  users </span><span>FOR</span><span> </span><span>SELECT</span><span></span><br/></span><span><span>      </span><span>USING</span><span>(</span><span></span><br/></span><span><span>      do_users_share_org</span><span>(</span><span></span><br/></span><span><span>        current_app_user</span><span>(</span><span>)</span><span>,</span><span></span><br/></span><span><span>        id</span><br/></span><span><span>      </span><span>)</span><span></span><br/></span><span><span>    </span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>CREATE</span><span></span><br/></span><span><span>  POLICY admin_policy </span><span>ON</span><span></span><br/></span><span><span>  users</span><br/></span><span><span>    </span><span>USING</span><span>(</span><span></span><br/></span><span><span>    do_users_share_org</span><span>(</span><span></span><br/></span><span><span>      current_app_user</span><span>(</span><span>)</span><span>,</span><span></span><br/></span><span><span>      id</span><br/></span><span><span>    </span><span>)</span><span></span><br/></span><span><span>    </span><span>AND</span><span> is_user_admin</span><span>(</span><span></span><br/></span><span><span>      current_app_user</span><span>(</span><span>)</span><span></span><br/></span><span><span>    </span><span>)</span><span></span><br/></span><span><span>  </span><span>)</span><span>;</span><br/></span></code></pre></div></div><p>Note the use of the <code>do_users_share_org()</code> <code>SECURITY INVOKER</code> function. According to
the <a href="https://www.postgresql.org/docs/current/sql-createfunction.html#:~:text=SECURITY%20INVOKER%20indicates%20that%20the,the%20user%20that%20owns%20it." target="_blank" rel="noopener noreferrer">Postgres docs</a>:</p><blockquote><p><em>“SECURITY INVOKER indicates that the function is to be executed with the privileges of the user
that
calls it.”</em></p></blockquote><p>In our case, this is <code>app_user</code> (who doesn’t bypass RLS), so we just define these functions for
reusability purposes.</p><h3 id="logging">Logging<a href="#logging" title="Direct link to heading">​</a></h3><p>It’s important to set up logging before shipping any feature to production. This is especially true
with RLS where logging the execution of the actual
policies <a href="https://dba.stackexchange.com/questions/299963/log-occurrences-when-row-level-security-policies-filter-out-rows" target="_blank" rel="noopener noreferrer">isn’t directly possible</a>
. For each request, it’s helpful to log the user and tenant IDs to be used for RLS when:</p><ul><li>Parsing them from auth headers</li><li>Setting and getting them from thread-local storage</li><li>Setting them in the db connection</li><li>This makes it easier to identify bugs related to thread-local storage
When resetting them in thread-local storage</li></ul><p>It’s also a good idea to enable more detailed logging in the db, at least initially, to see the
values actually being inserted/retrieved. If policies return too few/many results, or inserts fail
unexpectedly, it’s easier to figure out what went wrong.</p><h2 id="testing">Testing<a href="#testing" title="Direct link to heading">​</a></h2><p>In multi-tenant SaaS, guaranteeing the security of each tenant is critical. We have an extensive
suite of integration tests that test every access pattern to make sure that nothing ever leaks. The
tests spin up a Postgres <a href="https://www.testcontainers.org/modules/databases/postgres/" target="_blank" rel="noopener noreferrer">Testcontainer</a>
and call the relevant API endpoints, checking that proper access is always enforced.</p><p>In order to minimize the execution time of a large suite of integration tests, we avoid setup and
teardown of the database between tests and annotate the order in which tests run to make sure the
results are deterministic even without a full cleanup in between tests. As we scale, we’ll look into
other options like property-based testing and parallelizing our tests.</p><p>The switch from dynamic queries to RLS has been seamless in our integration tests. All we had to do
was to make sure our tests were using the newly-created <code>app_user</code> that doesn’t bypass RLS.</p><h2 id="conclusion">Conclusion<a href="#conclusion" title="Direct link to heading">​</a></h2><p>Every modern SaaS product is multi-tenant, but the good ones are also scalable, cost-effective, and
maintainable. Scalability and cost-effectiveness are the results of careful system design.
Maintainability includes design considerations such as
the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener noreferrer">DRY principle</a> (don’t repeat yourself)
and a separation of concerns, which make mistakes less likely and testing and troubleshooting
easier.</p><p>As we’ve shown, a single-schema multi-tenant database with RLS ticks all the checkboxes for
scalable, cost-effective, and maintainable architecture. This blog includes everything you need to
get started with your own multi-tenant SaaS architecture. But if this seems like too much and you’d
rather have someone else handle this for
you - <a href="https://thenile.dev?utm_source=blog.nile&amp;utm_medium=blog&amp;utm_campaign=pg_rls_blog&amp;utm_content=bottom_link" target="_blank" rel="">
talk to us</a> :)</p></div></div>
  </body>
</html>
