<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/">Original</a>
    <h1>Building a modern durable execution engine from first principles</h1>
    
    <div id="readability-page-1" class="page"><div><p>We dive into the architecture details of <a href="https://github.com/restatedev/restate">Restate</a>, a Durable Execution engine we built from the ground up. Restate requires no database/log or other system, but implements a full stack that competes with the best logs in terms of durability and operations.</p><p>This is the second article in our series on building a durable execution system from first principles. The first blog post in this series, <a href="https://restate.dev/blog/every-system-is-a-log-avoiding-coordination-in-distributed-applications/">Every System is a Log</a>, looks at this from the application side, and shows how a unified log architecture results in a tremendous simplification of distributed coordination logic. This post discusses the details of how we built the log-based runtime for that paradigm.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/one_log_lock_state_huf79fe27eae024b6d52604be04a8ab412_213138_2109x0_resize_q75_h2_box_3.webp" width="2109" height="1330"/></p><p><em>Modelling locking and database updates through an application log,</em></p><p>To build this runtime, we asked ourselves, what such a system would look like when designed from first principles? We built a precursor to this with <a href="https://github.com/apache/flink-statefun">Stateful Functions</a>, and from all the lessons learned there, we arrived at a design with a <em>self-contained complete stack, centered around a command log and event-processor, shipping as a single Rust binary</em>. To get an idea of the user experience we arrived at, check the <a href="https://restate.dev/blog/announcing-restate-1.2#distributed-deployments-for-mission-critical-workloads">videos in the announcement post</a>.</p><p>This stands somewhat in contrast to the common wisdom <em>“don’t build a new stateful system, just use Postgres”</em>. But we saw a clear case to build a new stack, for multiple reasons: <em>First</em>, the interactions and access patterns are different enough from existing systems that we can offer both better performance and operational behavior, similar to why message queues exist, even though you can queue with a SQL table. <em>Second</em>, the architecture of event logs has made significant advancements in recent years, but the advanced implementations are exclusive to proprietary stacks and managed offerings - the open source logs and queues still follow architectures from the on-prem era. <em>Third</em>, we saw how a converged stack lets us provide a much better end-to-end developer experience, from first experiments on your laptop to multi-region production deployments.</p><h2 id="recap-server-and-services">Recap: Server and Services <a href="#recap-server-and-services" aria-hidden="true">#</a></h2><p>A Restate application stack consists of two components: <em>Restate Server</em>, which sits at a similar place in your stack as a message broker, and the application <em>services</em>, which are durable functions/handlers containing the application logic. The server receives invocation events, persists them, and pushes them to the services, similar to an event broker. The services run the code that corresponds to RPC- or event-handlers, workflows, activities, or actors. Services may run as processes, containers, or even serverless functions.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/restate_in_the_stack_hu7e7b7ff41730dbfae8a525b20f6cb4be_178266_1640x0_resize_q75_h2_box_3.webp" width="1640" height="756"/></p><p>But Restate doesn’t just push invocations, it maintains a bidirectional connection with the executing service handler and lets the code perform durable actions as part of the invocation, including journaling steps, sending events to other handlers, accessing/modifying state, creating persistent futures (callbacks) and timers. The services use a thin SDK library which communicates the actions to the server - somewhat comparable to a KafkaConsumer or JDBC client, but more high-level. See <a href="https://github.com/restatedev/examples">Restate’s examples</a> for sample code and details.</p><p>The server handles all coordination and durability for the invocation life cycle, journals, embedded K/V state, and manages failover, leader-election, and fencing. The server’s view on an invocation and its journal is the ground truth; the services follow the server’s view and function executions may be cancelled/reset/retried as needed.</p><p>That approach makes the services completely stateless and simple to operate. They scale rapidly and run on serverless infrastructure like AWS Lambda, Cloudflare workers, etc.</p><h2 id="clusters-object-stores-and-the-latency-gap">Clusters, Object Stores, and the Latency Gap <a href="#clusters-object-stores-and-the-latency-gap" aria-hidden="true">#</a></h2><p>A distributed Restate deployment is a cluster of nodes that are connected to each other. Invocations and events can be sent to any node, and all nodes participate in the storage of events and dispatching of invocations to services/functions. Restate is active/active from a cluster-perspective, but has leader/follower roles at the granularity of <a href="#partitioned-scale-out">individual partitions</a>, similar to systems like <a href="https://kafka.apache.org/">Kafka</a> or <a href="https://tikv.org/">TiKV</a>.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/cluster_object_store_huad7abe99961f34962e72915ceb447350_938354_3776x0_resize_q75_h2_box_3.webp" width="3776" height="2682"/></p><p>Restate stores data using two mechanisms: New events (invocations, journal entries, state updates, …) are <strong>persisted in an embedded replicated log</strong> <em>(called Bifrost)</em>. From there, events move to state indexes in RocksDB, which are <strong>periodically snapshotted to an object store</strong>. So at any point in time, the majority of the data is durable in the object store (the nodes maintain a copy as cache) while a smaller part of the data is durable in the log replicated across the nodes.</p><p>This is a form of storage tiering, though not the classical tiering like in modern logs. It is more similar to a database management system, where the write-ahead-log (WAL) would be replicated across nodes, while the table data files and indexes would be persisted on S3 (and cached on the nodes).</p><h3 id="object-store--latency-gap">Object store + latency gap <a href="#object-store--latency-gap" aria-hidden="true">#</a></h3><p>Architectures that keep most- or all - of their data on object stores have become popular for many reasons: Object stores are unbeatable in terms of combined scalability, durability, and cost (AWS S3 cites eleven 9s of durability, stores more than 100 trillion objects, and is cheaper than persistent disks). Plus, the storage exists disaggregated from compute nodes, making the nodes stateless (or owning little state), which is highly desirable for efficient operations.</p><p>Object stores are also available in most on-prem setups we’ve encountered. It was natural for us to design Restate such that object storage would be the primary durability for the majority of the data.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/log_rocksdb_object_store_hubdedb68e47c64373e1d0d7388cd97b60_554233_3693x0_resize_q75_h2_box_3.webp" width="3693" height="1299"/></p><p>The reason why Restate has additionally a replication layer that persists new events (rather than writing events straight to object storage) is to provide low latency. Pure object store approaches have latencies that average around 100ms to make data durable, with tail latencies being a multiple of that. While that is feasible for analytical systems (e.g., <a href="https://flink.apache.org/">Apache Flink</a>) and data pipelines (like <a href="https://www.warpstream.com/">WarpStream</a>), such latencies can quickly become prohibitive for many applications.</p><p>Restate’s replication bridges the latency gap between the requirements of fast durable functions and the capabilities of object storage.</p><h3 id="navigating-the-cloud-latency-cost-disk-triad">Navigating the cloud latency-cost-disk triad <a href="#navigating-the-cloud-latency-cost-disk-triad" aria-hidden="true">#</a></h3><p>The setup described above is what we ship first, in Restate 1.2: a fast log replicated between Restate server nodes. However, Restate uses virtual log abstraction, to easily support other log implementations as well, without having to build a full consensus machinery each time. This is a defining feature of Restate’s runtime implementation that we’ll dive deeper into in the <a href="#up-next-a-fast-flexible-state-of-the-art-log">next article in this series</a>. We are currently using that mechanism to build object-store support in the log as well, which is a powerful feature for bringing the amount of data persistent on nodes to very small amounts, even zero.</p><p>There is no single best configuration for that setup - only a spectrum of trade-offs to pick from. In his <a href="https://materializedview.io/">Materialized View</a> newsletter, Chris Riccomini <a href="https://materializedview.io/p/cloud-storage-triad-latency-cost-durability">describes it as a CAP-theorem-like choice</a>:</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/riccomini_hu61251c42e6ec51f88d1f355057ee6414_264098_2208x0_resize_q75_h2_box_3.webp" width="2208" height="928"/></p><p>In our context (durable execution runtime), durability must be a given, but we have the additional dimension of how much replicated data is kept on the nodes. Restate’s triad thus is: latency-cost-disk.</p><ul><li><p><em>➕ Low latency, ➕ low cost, ➖some data on disks:</em> Quorum replication to nodes with async batch writes to S3.</p></li><li><p><em>➕ Low latency, ➖ high cost, ➕ no data on disks:</em> Quorum replication directly to S3 Express One Zone.</p></li><li><p><em>➖ High latency, ➕ low cost, ➕ no data on disks</em>: Synchronous batch writes to S3.</p></li></ul><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/latency_cost_disk_tradeoff.png"/></p><p>Naturally, there are nuances: direct replication has an even lower latency than S3 Express 1Z quorums. Synchronous batch writes to S3 can be cheaper than anything else, because that approach may avoid cross AZ bandwidth cost. Disks still exist as caches in all configurations. And there is the option of using quorum replication to S3 Express 1Z in different regions, to support multi-region deployments without relying on disks. But it shows that there is the spectrum of options, with which we aim to enable developers to use Restate in diverse setups across cloud and on-prem, while maintaining a simple dependency: just an object store.</p><p>Restate 1.2 ships with all the virtual log infrastructure, and a low-latency replicated log implementation. We are currently working on the other configurations - if you are interested in being an early tester or design partner, <a href="mailto:info@restate.dev">please reach out to us</a>.</p><p>As a final thought, being able to adjust to different trade-offs also helps Restate and its users adapt to changing cloud pricing models. To quote another prolific dist. sys. writer:</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/vanlightly_hud6f5919085c9f140e46793c420ddfdd1_196293_2188x0_resize_q75_h2_box_3.webp" width="2188" height="646"/></p><h2 id="partitioned-scale-out">Partitioned Scale out <a href="#partitioned-scale-out" aria-hidden="true">#</a></h2><p>Restate follows the partitioned scale-out model: A cluster has a set of partitions, each with a log partition and an event processor instance. Partitions operate independently and allow the system to scale both across cores and nodes.</p><p>Everything related to an invocation happens within a single partition: invocation, idempotency &amp; deduplication, journal entries, state, promises/futures, avoiding the need to synchronize and coordinate with any other shards. The target partition for an invocation is determined by hashing the virtual object key, workflow ID, or idempotency key, if applicable - otherwise, the partition is freely chosen.</p><p>In some cases, a function execution produces an event for another partition, for example RPC events or completions. In that case, events are still written to the local partition, and the server has an out-of-band exactly-once event shuffler to move events to the right target partition.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/partitioned_scale_out_huc27f91f7f5a7c87895dacc88bc12c15c_266889_3421x0_resize_q75_h2_box_3.webp" width="3421" height="916"/></p><p>The partitions are not exposed to applications (though you see them when using <code>restatectl</code>) - only keys are directly addressable (virtual object id, workflow id, idempotency key), to allow changing the number of partitions without losing consistency.</p><p>From here on, we look only at what happens inside a single partition.</p><h2 id="event-log-and-processor">Event Log and Processor <a href="#event-log-and-processor" aria-hidden="true">#</a></h2><p>The work that Restate Server does inside one partition happens in two components: the <strong>distributed durable log</strong> <em>(called Bifrost)</em> and the <strong>processors</strong>. The log is the fast primary durability for events <em>(e.g., make invocations, add journal entry, update state, create durable promise, …)</em>, the processor acts on events (e.g., invokes handlers) and materializes their state. Log and processor are co-partitioned, meaning a partition processor connects to one log partition. They are independent, but frequently co-located in the same process.</p><p>Compared to databases, you can think of Bifrost as the transaction WAL, and the processor as the query engine and table storage. Compared to stream processing, you can think of Restate’s log as Kafka and the processor as a stream processing application (like KStreams or Flink).</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/event_loop_hua3d1b6a9601fecc5a17d9b62e8a1a136_840477_5333x0_resize_q75_h2_box_3.webp" width="5333" height="2227"/></p><p>Log and processor form a tight loop: the processor continuously tails the log, and acts on the events (e.g., making invocation). That may produce more events (journal entries, state updates, …), which are written to the log and again processed by the processor.</p><p>Let’s go through an example to illustrate this:</p><ol><li>A client invokes service handler <code>processPayment</code> with idempotency key <em>K</em> through Restate. The ingress enqueues the invocation to the log partition, as determined by hashing <em>K</em>.</li><li>The leader Processor for the partition receives that event and checks its local idempotency key state. K is not contained there for <code>processPayment</code>. The processor atomically adds K to the state and transitions the invocation to <em>running</em>, then builds a connection to the target service endpoint, and pushes the invoke journal entry.</li><li>The service streams back a step result event (<code>ctx.run({...})</code>) and the processor enqueues that journal entry event in the log. Being persistent in the log is the point when “the step happened”, meaning from there on it will always be recovered.</li><li>When the processor receives the event from the log (that means <a href="#failover--reconfiguration">no other processor has taken over leadership</a> in the meantime) then it adds the event to the invocation’s journal state and sends an ack to the service.</li><li>Similar steps happen when the service sends a state update, a timer, an RPC event, or creates a durable promise. Events get always added to the log first, and once they are received by the processor they are acted upon (e.g., added to journal, routed as invocation to other service, etc.)</li><li>Once the invocation completes, the Processor adds the result event to the log. Upon receiving that event, it sets the invocation state as complete and sends the result back to the client.</li></ol><p>When the function execution fails (e.g., crash, loss of connection, user-defined error), the processor dispatches a new invocation, attaching the full journal events from this invocation so far. To avoid split brain scenarios between services, the processor tracks invocation execution attempts (retries) and rejects events sent from an invocation if a newer attempt has started. This can be tracked with simple in-memory state, because invocations are sticky to partitions, and partitions have <a href="#failover--reconfiguration">strong leaders</a>.</p><h3 id="state-storage">State storage <a href="#state-storage" aria-hidden="true">#</a></h3><p>The processor stores all its non-transient state in an embedded RocksDB instance. Operations on that embedded store are very fast, but the state is lost when the node is lost. However, all state of the processor is deterministically derived from the durable log and can always be rebuilt from the log during recovery. To avoid arbitrarily long re-build phases, the RocksDB database is periodically snapshotted to the object store and the log is trimmed to the point of the snapshot. Processors can be restored by fetching the latest snapshot and attaching to the log at the event sequence number when the snapshot was taken.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/trimming.png"/></p><p>The implementation of the partition processor is a tight event loop in Rust’s <a href="https://tokio.rs/">Tokio runtime</a>. Partition Processors operate independently from each other and access exclusively local data structures (in memory, RocksDB, streams to ongoing invocations). The partition-local handling of invocations is easy in a log-first design, and would be much harder to achieve if we built this on a general purpose database.</p><p>That property makes the design also both simple and fast: Committing an event (e.g., step / activity) means appending the event to the log (obtaining a write quorum). As soon as that happens, the event is pushed from the log leader in-memory to the attached processor and ack-ed to the handler/workflow. This takes a single network roundtrip for a replication quorum, and no distributed reads. The durability of RocksDB happens completely asynchronously in the background.</p><h3 id="leaders-and-followers">Leaders and Followers <a href="#leaders-and-followers" aria-hidden="true">#</a></h3><p>Both log and processors have one leader and optional followers. In the case of the log, followers increase durability for events through additional copies. In the case of processors, followers are hot standbys that have a copy of the state (deterministically derived from the log) and can quickly take over upon failure. Only the processor leader actually dispatches invocations for functions and workflows to the services, and only the leader writes snapshots to object store.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/invocation_flow_huaa0e03af6e7aefb4e6db4b933824621a_113867_1818x0_resize_q75_h2_box_3.webp" width="1818" height="655"/></p><h2 id="control-plane-data-plane-external-consensus">Control Plane, Data Plane, External Consensus <a href="#control-plane-data-plane-external-consensus" aria-hidden="true">#</a></h2><p>So far, everything we looked at was the <em>data plane</em> of the system: The log and the partition processor.</p><p>Everything is coordinated by a <em>control plane</em>, which is responsible for failure detection, failover coordination, and re-configuration. The control plane stores metadata for the cluster (like configurations) and runs the cluster controller that handles partition placement and leader election.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/control_plane_data_plane_hue624826ffd31c49c10e7078593d82243_438892_3285x0_resize_q75_h2_box_3.webp" width="3285" height="1491"/></p><p><em>Control Plane and Data Plane</em></p><p>Because Restate has one control plane for both log and processors, it can co-coordinate both, for example ensuring that the leader processor is always co-located with the log partition leader, to reduce network hops and optimize reading from local memory caches. In contrast, if we were to build this transparently on an external log like Kafka, this co-location would be harder to achieve. The benefits of this joint control plane show in many parts of the system and are one of the reasons Restate is simpler to set up, scale, and operate.</p><p>Besides managing re-configurations and failover, the control plane also provides the <em>external consensus</em> for the data plane, allowing the data plane to operate more efficiently and with simpler properties than full consensus. We’ll go into the details of Restate’s log implementation in <a href="#up-next-a-fast-flexible-state-of-the-art-log">the next blog post</a> - for now, a useful high-level way to think about this is that the control plane moves the data plane from one steady configuration to another, whenever the previous configuration is no longer functional (a failure happened) or desired (e.g., re-balancing). <a href="https://jack-vanlightly.com/blog/2025/2/5/an-introduction-to-virtual-consensus-in-delos">This blog post</a> from Jack Vanlightly gives a nice introduction to that concept.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/reconfiguration_hu7fc1794128b3bd86c85d92079b38ef7d_35565_643x0_resize_q75_h2_box_3.webp" width="643" height="192"/>
<em>The Control Plane reconfigures the Data Plane (Figure from “An Introduction to Virtual Consensus in Delos “by Jack Vanlightly)</em></p><p>Another benefit of this design is that it allows Restate to use a simpler/slower implementation of consensus on the control plane, because it is rarely invoked. Restate abstracts its consensus to just an atomic compare-and-swap (CAS) metadata operation, which the built-in metadata store backs with an implementation of the RAFT consensus algorithm. But this can be easily extended to plug in different storage systems, as long as they support atomic CAS.</p><h3 id="failover--reconfiguration">Failover &amp; Reconfiguration <a href="#failover--reconfiguration" aria-hidden="true">#</a></h3><p>Though the control plane jointly coordinates log and processor reconfiguration, each has their own mechanisms to ensure consistency.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/loglet_chain_hu709ceac8f2a3c8ac3bc169aa25f181ae_30775_711x0_resize_q75_h2_box_3.webp" width="711" height="157"/></p><p>Bifrost’s (the log’s) mechanism is based on a mix of Delos (Virtual Consensus) and LogDevice. From a high-level, bifrost is segmented and failover or reconfiguration seals the active segment and creates a new segment, possibly with a new leader and a different set of nodes that store replicas. To the outside and the partition processors, everything looks like a single contiguous log.</p><p>When a partition processor fails, the control plane selects a new leader for that partition.The failover procedure relies on the external consensus provided by the control plane: New leaders obtain the next epoch in a strictly monotonous sequence (so newer leaders have higher epochs). The new leader appends a message to the log to signal their epoch is now active, and then simply starts appending events from its operations. The old leader (who might still be following the log) will receive that epoch bump message and step down at that exact point - it will keep materializing state (as a follower) but not dispatch invocations any more. The old leader also aborts ongoing function executions and lets the new leader recover those.</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/leader_handover_hufb23198ad294aec16dbdbd240f98cd46_503382_3861x0_resize_q75_h2_box_3.webp" width="3861" height="1391"/></p><p>Any messages carrying lower epochs than the latest epoch-bumping message will be ignored, which filters messages that the old leader might have still been appending to the log before it found out that it was superseded by another leader. If the old leader was attempting to commit a journal entry, but the message was appended after the epoch-bump message, that commit cannot happen: The new leader will (or might have already) recover the process without that journal entry and execute and commit that step. This mechanism ensures that any step / activity result is committed exactly once. No split brain view is possible.</p><p>This mechanism also automatically resolves concurrent competition for leadership - the highest epoch will win, and late events are consistently ignored.</p><h2 id="converged-single-binary">Converged Single Binary <a href="#converged-single-binary" aria-hidden="true">#</a></h2><p>Restate is architected as a set of individual components that communicate with each other and make no assumptions about the whereabouts of their peers. A Restate binary can run every component or a subset of them; a set of components is described by a role.</p><p>The default configuration is the <strong>converged mode</strong>, where every binary runs every role. In that case, you get a distributed architecture in a single binary. You can start more instances of the binary to form clusters. This mode is easy to use and efficient, because it also lets different components communicate efficiently through in-memory channels and caches whenever possible (e.g., log to processor).</p><p><img src="https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/node_internal_architecture_hud4377212249746746f307b134cc2fae0_212791_1924x0_resize_q75_h2_box_3.webp" width="1924" height="918"/></p><p>However, you can of course also run it as a <strong>disaggregated</strong> setup, where different sets of nodes run different roles. That lets you separate control plane from data plane and pick your best trade-offs in terms of cost/durability/availability for metadata and data. For example:</p><ul><li>Deploy three nodes with the <em>admin</em> role across three different regions, ensure application and consensus metadata are disaster proof.</li><li>Deploy six nodes with the Log-Server role across three availability zones, making sure data is replicated to tolerate zone outages.</li><li>Deploy Ingress and Worker roles in one availability zone to strictly co-locate them with zone-local services.</li></ul><p>Restate’s architecture gives you a great developer experience from the start (launching a single binary on your laptop) all the way to sophisticated distributed deployments (disaggregated distributed setups).</p><h2 id="some-performance-numbers">Some Performance Numbers <a href="#some-performance-numbers" aria-hidden="true">#</a></h2><p>How fast can a system like this be? The answer is, we don’t really know, we have plenty more optimization we can do. Our main focus for this release was durability, resilience, and operational tooling.</p><p>But even before any deep performance optimization, the system already pushes some pretty cool numbers, both latency- and throughput wise. Below are numbers from Restate 1.2. We measure the throughput / latency of the server against mock functions and activities, to put maximum stress on the server.</p><h3 id="latency">Latency <a href="#latency" aria-hidden="true">#</a></h3><p>Restate aims to keep latencies low, despite giving strong guarantees on durability (replication) and consistency (strong consensus on locking keys, workflow ids, etc.).</p><p>Below are the numbers for durable functions with an increasing number of intermediate durable steps, running on a 3-way replicated cluster. Under low load, things are generally fast and a single step has a <strong>median latency of 3ms</strong>. Under high load, steps still have a median latency of 10ms after the initial workflow setup. Tail latencies under low load are a bit higher than we like (possibly caused by some Tokio / RocksDB issues) and we believe we can get these down in the future.</p><table><thead><tr><th>Load</th><th>Intermediate Steps</th><th>Latency</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td>p50</td><td>p90</td><td>p99</td></tr><tr><td>Low <em>(10 concurrent clients)</em></td><td>0</td><td>5ms</td><td>34ms</td><td>54ms</td></tr><tr><td></td><td>3</td><td>15ms</td><td>42ms</td><td>69ms</td></tr><tr><td></td><td>9</td><td>31ms</td><td>57ms</td><td>93ms</td></tr><tr><td></td><td>27</td><td>61ms</td><td>106ms</td><td>155ms</td></tr><tr><td>High <em>(1200 concurrent clients)</em></td><td>0</td><td>28ms</td><td>41ms</td><td>58ms</td></tr><tr><td></td><td>3</td><td>58ms</td><td>76ms</td><td>98ms</td></tr><tr><td></td><td>9</td><td>116ms</td><td>138ms</td><td>163ms</td></tr><tr><td></td><td>27</td><td>283ms</td><td>320ms</td><td>356ms</td></tr></tbody></table><p>One thing you can observe here is that Restate is built to make durable steps cheap. An initial function or workflow invocation needs to check whether the workflow ID, idempotency key, or object key already exists and whether it is under execution. But once an invocation has been made, adding steps is just the equivalent of a conditional append to the log.</p><h3 id="throughput">Throughput <a href="#throughput" aria-hidden="true">#</a></h3><p>We ran a workflow of 9 intermediate durable steps (totalling 11 actions, including invoke/result), using 1200 concurrent clients to submit workflows.</p><p>Restate pushes <strong>94,286 actions (steps) per second</strong>, equalling <strong>8,571 full workflows each second</strong>. The system maintains a <strong>p50 of 116.36ms</strong> and a <strong>p99 of 163.33ms</strong> for the full workflow! The <strong>p50 per step is 10ms</strong>.</p><p>The experiment ran on AWS c6id.8xlarge nodes, which are admittedly beefy, but also deliver a throughput that most companies will not ever reach or exceed in their transactional load. And, if they exceed that, Restate still scales to more nodes through more partitions.</p><h2 id="up-next-a-fast-flexible-state-of-the-art-log">Up next: a fast, flexible, state-of-the-art log <a href="#up-next-a-fast-flexible-state-of-the-art-log" aria-hidden="true">#</a></h2><p>We mentioned that we built our own implementation of a distributed replicated log (called Bifrost), because we didn’t find any of the existing logs suitable in terms of latency (single roundtrip, quorum replication with external consensus), durability (active-active with flexible quorums), flexibility (segmented log that can be dynamically reconfigured).</p><p>The next post in this series will dig into all the nitty gritty details of how we built that log. This log itself is a marvel of engineering and one of the reasons Restate is as powerful as it is. If you are into distributed systems, you will enjoy that one for sure!</p><h2 id="try-it-out">Try it out! <a href="#try-it-out" aria-hidden="true">#</a></h2><p>We hope you find this work as exciting as we do. If you want to try this out, the <a href="https://docs.restate.dev/get_started/quickstart">quickstart</a>, helps to get you to your first demo app (and give us a star on <a href="https://github.com/restatedev/restate">GitHub</a>).</p><p>Let us know what you think or ask questions in our community on <a href="https://discord.gg/skW3AZ6uGd">Discord</a> or <a href="https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA">Slack</a> and get more deep content like this from us on <a href="https://twitter.com/restatedev">X</a>, <a href="https://www.linkedin.com/company/restatedev">LinkedIn</a>, <a href="https://bsky.app/profile/restate.dev">Bluesky</a>, or via <a href="https://restate.dev/newsletter-sign-up/">email</a>.</p><p>Restate is also available as a <a href="https://restate.dev/cloud/">fully managed cloud service</a>, if all you want is to use it and let us operate it.</p></div></div>
  </body>
</html>
