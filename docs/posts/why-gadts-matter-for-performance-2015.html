<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.janestreet.com/why-gadts-matter-for-performance/">Original</a>
    <h1>Why GADTs matter for performance (2015)</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>When GADTs (<a href="http://en.wikipedia.org/wiki/Generalized_algebraic_data_type">Generalized Algebraic Data
Types</a>) landed in
OCaml, I wasn’t particularly happy about it. I assumed that it was the kind of
nonsense you get when you let compiler writers design your programming language.</p>

<p>Which is to say that the standard GADT examples all seem to be about the kinds
of things that compiler writers do, like embed domain-specific languages or
build typed abstract-syntax trees. But it didn’t seem particularly relevant for
the kind of systems programming that I think about.</p>

<p>But it became apparent pretty quickly that I was wrong. In particular, since
GADTs have landed, at Jane Street we’ve found lots of examples where GADTs are
important for performance, of all things. The theme in these examples is that
GADTs enable you to tweak your memory representations in ways that would
otherwise be painful or impossible to do safely in OCaml.</p>

<h2 id="the-problem-of-polymorphism">The Problem of Polymorphism</h2>

<p>I’d like to walk through a simple example that illustrates this aspect of GADTs,
but first, a few words about OCaml’s memory representation. OCaml’s polymorphism
is in an important way backed on that memory representation. In particular,
consider a simple polymorphic function like <code>List.iter</code>, which has the following
type:</p>

<div><pre><code><span>val</span> <span>iter</span><span>:</span> <span>&#39;</span><span>a</span> <span>list</span> <span>-&gt;</span> <span>f</span><span>:(</span><span>&#39;</span><span>a</span> <span>-&gt;</span> <span>unit</span><span>)</span> <span>-&gt;</span> <span>unit</span>
</code></pre>
</div>

<p>The polymorphic type tells you that <code>List.iter</code> can operate on lists of any
type, and in OCaml, this is achieved with a single compiled version of the code.
This is possible because the memory representation of the elements of a list are
uniform: you can always refer to an OCaml value in a single word, either as a
pointer to a heap-allocated value, or as an immediate that fits inside that
word.</p>

<p>That means that some OCaml datatypes are less efficient space-wise than you
might imagine. Arrays, for example, take the same amount of space per element
whether those elements are bytes, 32-bit ints, or 64-bit ints. (There’s actually
some special magic in the compiler for float arrays, though this is probably
more trouble than it’s worth, as described by Alain Frisch
<a href="http://www.lexifi.com/blog/about-unboxed-float-arrays">here</a>. But let’s ignore
float arrays for now.)</p>

<p>OCaml does have a tighter representations for byte arrays, called <code>bytes</code>. But
it’s a completely different type, and so building a general purpose data
structure that uses <code>bytes</code> when it would make sense, and ordinary arrays
otherwise, is a little awkward.</p>

<h2 id="controlling-memory-representation-without-gadts">Controlling memory representation without GADTs</h2>

<p>Let’s see what happens if we try to design (without GADTs) an array type that
sometimes uses the general array representation and sometimes uses <code>bytes</code>.</p>

<p>You could imagine representing such a value using an ordinary variant.</p>

<div><pre><code><span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>|</span> <span>Array</span> <span>of</span> <span>&#39;</span><span>a</span> <span>array</span>
            <span>|</span> <span>Bytes</span> <span>of</span> <span>bytes</span>
</code></pre>
</div>

<p>We could then implement each of the operations we want on our new array type,
implementing each operation differently depending on the particular
representation. Let’s see what happens if we just take this idea and run with
it, implementing all the required functions in the most straightforward way.</p>

<div><pre><code><span>&gt;</span> <span>module</span> <span>Compact_array</span> <span>=</span> <span>struct</span>

    <span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>|</span> <span>Array</span> <span>of</span> <span>&#39;</span><span>a</span> <span>array</span>
                <span>|</span> <span>Bytes</span> <span>of</span> <span>bytes</span>

    <span>let</span> <span>of_bytes</span> <span>x</span> <span>:</span> <span>char</span> <span>t</span> <span>=</span> <span>Bytes</span> <span>x</span>
    <span>let</span> <span>of_array</span> <span>x</span> <span>=</span> <span>Array</span> <span>x</span>

    <span>let</span> <span>length</span> <span>=</span> <span>function</span>
      <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>length</span> <span>a</span>
      <span>|</span> <span>Bytes</span> <span>s</span> <span>-&gt;</span> <span>Bytes</span><span>.</span><span>length</span> <span>s</span>

    <span>let</span> <span>get</span> <span>t</span> <span>i</span> <span>=</span>
      <span>match</span> <span>t</span> <span>with</span>
      <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>a</span><span>.(</span><span>i</span><span>)</span>
      <span>|</span> <span>Bytes</span> <span>s</span> <span>-&gt;</span> <span>s</span><span>.[</span><span>i</span><span>]</span>

    <span>let</span> <span>set</span> <span>t</span> <span>i</span> <span>v</span> <span>=</span>
      <span>match</span> <span>t</span> <span>with</span>
      <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>a</span><span>.(</span><span>i</span><span>)</span> <span>&lt;-</span> <span>v</span>
      <span>|</span> <span>Bytes</span> <span>s</span> <span>-&gt;</span> <span>s</span><span>.[</span><span>i</span><span>]</span> <span>&lt;-</span> <span>v</span>

  <span>end</span><span>;;</span>

<span>module</span> <span>Compact_array</span> <span>:</span>
  <span>sig</span>
    <span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>Array</span> <span>of</span> <span>&#39;</span><span>a</span> <span>array</span> <span>|</span> <span>Bytes</span> <span>of</span> <span>bytes</span>
    <span>val</span> <span>of_bytes</span> <span>:</span> <span>bytes</span> <span>-&gt;</span> <span>char</span> <span>t</span>
    <span>val</span> <span>of_array</span> <span>:</span> <span>&#39;</span><span>a</span> <span>array</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span>
    <span>val</span> <span>length</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span>
    <span>val</span> <span>get</span> <span>:</span> <span>char</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>-&gt;</span> <span>char</span>
    <span>val</span> <span>set</span> <span>:</span> <span>char</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>-&gt;</span> <span>char</span> <span>-&gt;</span> <span>unit</span>
  <span>end</span>
</code></pre>
</div>

<p>This seems pretty good at first glance, but the inferred types aren’t quite what
we want. In particular, <code>get</code> and <code>set</code> only work with <code>Compact_array</code>s
containing characters. If you think about how type inference works, it’s not
really all that surprising. If you think about the code for <code>get</code>:</p>

<div><pre><code><span>let</span> <span>get</span> <span>t</span> <span>i</span> <span>=</span>
  <span>match</span> <span>t</span> <span>with</span>
  <span>|</span> <span>Array</span>  <span>a</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>get</span>  <span>a</span> <span>i</span>
  <span>|</span> <span>String</span> <span>s</span> <span>-&gt;</span> <span>String</span><span>.</span><span>get</span> <span>s</span> <span>i</span>
</code></pre>
</div>

<p>The OCaml compiler is looking for a single type to assign to the return value
for all the cases of the match. Given that <code>String.get</code> always returns a <code>char</code>,
then <code>Compact_array.get</code> will be restricted to only returning a <code>char</code>.</p>

<p>One way to work around this problem is to essentially implement what we want as
a poor-man’s object. Here, we just write the code separately for the different
cases, and stuff those functions into a record full of closures. Here’s how that
looks.</p>

<div><pre><code><span>&gt;</span> <span>module</span> <span>Compact_array</span> <span>=</span> <span>struct</span>

  <span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>{</span> <span>len</span><span>:</span> <span>unit</span> <span>-&gt;</span> <span>int</span>
              <span>;</span> <span>get</span><span>:</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span>
              <span>;</span> <span>set</span><span>:</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>-&gt;</span> <span>unit</span>
              <span>}</span>

  <span>let</span> <span>of_string</span> <span>s</span> <span>=</span>
    <span>{</span> <span>len</span> <span>=</span> <span>(</span><span>fun</span> <span>()</span> <span>-&gt;</span> <span>String</span><span>.</span><span>length</span> <span>s</span><span>)</span>
    <span>;</span> <span>get</span> <span>=</span> <span>(</span><span>fun</span> <span>i</span> <span>-&gt;</span> <span>String</span><span>.</span><span>get</span> <span>s</span> <span>i</span><span>)</span>
    <span>;</span> <span>set</span> <span>=</span> <span>(</span><span>fun</span> <span>i</span> <span>x</span> <span>-&gt;</span> <span>String</span><span>.</span><span>set</span> <span>s</span> <span>i</span> <span>x</span><span>)</span>
    <span>}</span>

  <span>let</span> <span>of_array</span> <span>a</span> <span>=</span>
    <span>{</span> <span>len</span> <span>=</span> <span>(</span><span>fun</span> <span>()</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>length</span> <span>a</span><span>)</span>
    <span>;</span> <span>get</span> <span>=</span> <span>(</span><span>fun</span> <span>i</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>get</span> <span>a</span> <span>i</span><span>)</span>
    <span>;</span> <span>set</span> <span>=</span> <span>(</span><span>fun</span> <span>i</span> <span>x</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>set</span> <span>a</span> <span>i</span> <span>x</span><span>)</span>
    <span>}</span>

  <span>let</span> <span>length</span> <span>t</span> <span>=</span> <span>t</span><span>.</span><span>len</span> <span>()</span>
  <span>let</span> <span>get</span> <span>t</span> <span>i</span> <span>=</span> <span>t</span><span>.</span><span>get</span> <span>i</span>
  <span>let</span> <span>set</span> <span>t</span> <span>i</span> <span>x</span> <span>=</span> <span>t</span><span>.</span><span>set</span> <span>i</span> <span>x</span>

<span>end</span><span>;;</span>
<span>module</span> <span>Compact_array</span> <span>:</span>
  <span>sig</span>
    <span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>{</span>
      <span>len</span> <span>:</span> <span>unit</span> <span>-&gt;</span> <span>int</span><span>;</span>
      <span>get</span> <span>:</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span><span>;</span>
      <span>set</span> <span>:</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>-&gt;</span> <span>unit</span><span>;</span>
    <span>}</span>
    <span>val</span> <span>of_string</span> <span>:</span> <span>bytes</span> <span>-&gt;</span> <span>char</span> <span>t</span>
    <span>val</span> <span>of_array</span> <span>:</span> <span>&#39;</span><span>a</span> <span>array</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span>
    <span>val</span> <span>length</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span>
    <span>val</span> <span>get</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span>
    <span>val</span> <span>set</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>-&gt;</span> <span>unit</span>
  <span>end</span>
</code></pre>
</div>

<p>This more or less solves the problem, but it’s still not really the memory
representation we want. In particular, we have to allocate three closures for
each <code>Compact_array.t</code>, and this number of closures will only go up as we add
more functions whose behavior depends on the underlying array.</p>

<h2 id="gadts-to-the-rescue">GADTs to the rescue</h2>

<p>Let’s go back to our failed variant-based implementation, but rewrite it using
the GADT syntax. Note that we’re not trying to change the types at all this
time, just rewriting the same type we had before in the language of GADTs.</p>

<div><pre><code><span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>|</span> <span>Array</span> <span>:</span> <span>&#39;</span><span>a</span> <span>array</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span>
            <span>|</span> <span>Bytes</span> <span>:</span> <span>bytes</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span>
</code></pre>
</div>

<p>The syntax of this declaration suggests thinking about variant constructor like
<code>Array</code> or <code>Bytes</code> as functions from the constructor arguments to the type of
the resulting value, with the thing to the right of the <code>:</code> roughly
corresponding to the type signature of the constructor.</p>

<p>Note that for the <code>Array</code> constructor, the type value of <code>&#39;a</code> depends on the
type of the argument:</p>

<div><pre><code><span>&gt;</span> <span>Array</span> <span>[|</span><span>1</span><span>;</span><span>2</span><span>;</span><span>3</span><span>|];;</span>
<span>-</span> <span>:</span> <span>int</span> <span>t</span> <span>=</span> <span>Array</span> <span>[|</span><span>1</span><span>;</span> <span>2</span><span>;</span> <span>3</span><span>|]</span>
<span>&gt;</span> <span>Array</span> <span>[|</span><span>&#34;one&#34;</span><span>;</span><span>&#34;two&#34;</span><span>;</span><span>&#34;three&#34;</span><span>|];;</span>
<span>-</span> <span>:</span> <span>bytes</span> <span>t</span> <span>=</span> <span>Array</span> <span>[|</span><span>&#34;one&#34;</span><span>;</span> <span>&#34;two&#34;</span><span>;</span> <span>&#34;three&#34;</span><span>|]</span>
</code></pre>
</div>

<p>But for the <code>Bytes</code> constructor, the type <code>&#39;a</code> in the type is still free.</p>

<div><pre><code><span>&gt;</span> <span>Bytes</span> <span>&#34;foo&#34;</span><span>;;</span>
<span>-</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>Bytes</span> <span>&#34;foo&#34;</span>
</code></pre>
</div>

<p>This is really the problematic case, because we’d like for <code>Bytes &#34;foo&#34;</code> for the
parameter <code>&#39;a</code> to by <code>char</code>, since in the <code>Bytes</code> case, that’s what the element
type of our array is.</p>

<p>Because GADTs give us the ability to specify the type on the right-hand side of
the arrow, we can get that.</p>

<div><pre><code><span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>|</span> <span>Array</span> <span>:</span> <span>&#39;</span><span>a</span> <span>array</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span>
            <span>|</span> <span>Bytes</span> <span>:</span> <span>bytes</span> <span>-&gt;</span> <span>char</span> <span>t</span>
</code></pre>
</div>

<p>Now, the Bytes constructor behaves as we’d like it too.</p>

<div><pre><code><span>&gt;</span> <span>Bytes</span> <span>&#34;foo&#34;</span><span>;;</span>
<span>-</span> <span>:</span> <span>char</span> <span>t</span> <span>=</span> <span>Bytes</span> <span>&#34;foo&#34;</span>
</code></pre>
</div>

<p>Now let’s see what happens when we try to write the length function.</p>

<div><pre><code><span>&gt;</span> <span>let</span> <span>length</span> <span>t</span> <span>=</span> 
     <span>match</span> <span>t</span> <span>with</span>
     <span>|</span> <span>Bytes</span> <span>b</span> <span>-&gt;</span> <span>Bytes</span><span>.</span><span>length</span> <span>b</span>
     <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>length</span> <span>a</span>
  <span>;;</span>
<span>val</span> <span>length</span> <span>:</span> <span>char</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>=</span> <span>&lt;</span><span>fun</span><span>&gt;</span>
</code></pre>
</div>

<p>Disappointingly, we’re again stuck with a function that doesn’t have the right
type. In particular, the compiler has decided that this function can only
operate on <code>char t</code>, when we want it to work for arrays of any type.</p>

<p>But the problem now is that type inference in the presence of GADTs is
difficult, and the compiler needs a little help. Roughly speaking, without some
hints, OCaml’s type system will try to identify all types as having a single
value within a given function. But in this case, we need a type variable which
might have different values in different branches of a match statement.</p>

<p>We can do this by creating a locally-abstract type <code>el</code> to represent the type
parameter of <code>t</code> (and the element type), and annotating <code>t</code> accordingly.</p>

<div><pre><code><span>&gt;</span> <span>let</span> <span>length</span> <span>(</span><span>type</span> <span>el</span><span>)</span> <span>(</span><span>t</span><span>:</span><span>el</span> <span>t</span><span>)</span> <span>=</span> 
     <span>match</span> <span>t</span> <span>with</span>
     <span>|</span> <span>Bytes</span> <span>b</span> <span>-&gt;</span> <span>Bytes</span><span>.</span><span>length</span> <span>b</span>
     <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>length</span> <span>a</span>
  <span>;;</span>
<span>val</span> <span>length</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>=</span> <span>&lt;</span><span>fun</span><span>&gt;</span>
</code></pre>
</div>

<p>Now we see that we get the right type. We can push this approach through to get
a complete implementation.</p>

<div><pre><code><span>&gt;</span> <span>module</span> <span>Compact_array</span> <span>=</span> <span>struct</span>

    <span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>|</span> <span>Array</span>  <span>:</span> <span>&#39;</span><span>a</span> <span>array</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span>
                <span>|</span> <span>Bytes</span> <span>:</span> <span>bytes</span> <span>-&gt;</span> <span>char</span> <span>t</span>

    <span>let</span> <span>of_bytes</span> <span>x</span> <span>=</span> <span>Bytes</span> <span>x</span>
    <span>let</span> <span>of_array</span> <span>x</span> <span>=</span> <span>Array</span> <span>x</span>

    <span>let</span> <span>length</span> <span>(</span><span>type</span> <span>el</span><span>)</span> <span>(</span><span>t</span><span>:</span><span>el</span> <span>t</span><span>)</span> <span>=</span>
      <span>match</span> <span>t</span> <span>with</span>
      <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>length</span> <span>a</span>
      <span>|</span> <span>Bytes</span> <span>s</span> <span>-&gt;</span> <span>Bytes</span><span>.</span><span>length</span> <span>s</span>

    <span>let</span> <span>get</span> <span>(</span><span>type</span> <span>el</span><span>)</span> <span>(</span><span>t</span><span>:</span><span>el</span> <span>t</span><span>)</span> <span>i</span> <span>:</span> <span>el</span> <span>=</span>
      <span>match</span> <span>t</span> <span>with</span>
      <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>get</span> <span>a</span> <span>i</span>
      <span>|</span> <span>Bytes</span> <span>s</span> <span>-&gt;</span> <span>Bytes</span><span>.</span><span>get</span> <span>s</span> <span>i</span>

    <span>let</span> <span>set</span> <span>(</span><span>type</span> <span>el</span><span>)</span> <span>(</span><span>t</span><span>:</span><span>el</span> <span>t</span><span>)</span> <span>i</span> <span>(</span><span>v</span><span>:</span><span>el</span><span>)</span> <span>=</span>
      <span>match</span> <span>t</span> <span>with</span>
      <span>|</span> <span>Array</span> <span>a</span> <span>-&gt;</span> <span>Array</span><span>.</span><span>set</span> <span>a</span> <span>i</span> <span>v</span>
      <span>|</span> <span>Bytes</span> <span>s</span> <span>-&gt;</span> <span>Bytes</span><span>.</span><span>set</span> <span>s</span> <span>i</span> <span>v</span>

  <span>end</span><span>;;</span>
<span>module</span> <span>Compact_array</span> <span>:</span>
  <span>sig</span>
    <span>type</span> <span>&#39;</span><span>a</span> <span>t</span> <span>=</span> <span>Array</span> <span>:</span> <span>&#39;</span><span>a</span> <span>array</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span> <span>|</span> <span>Bytes</span> <span>:</span> <span>bytes</span> <span>-&gt;</span> <span>char</span> <span>t</span>
    <span>val</span> <span>of_bytes</span> <span>:</span> <span>bytes</span> <span>-&gt;</span> <span>char</span> <span>t</span>
    <span>val</span> <span>of_array</span> <span>:</span> <span>&#39;</span><span>a</span> <span>array</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>t</span>
    <span>val</span> <span>length</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span>
    <span>val</span> <span>get</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span>
    <span>val</span> <span>set</span> <span>:</span> <span>&#39;</span><span>a</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>-&gt;</span> <span>unit</span>
  <span>end</span>
</code></pre>
</div>

<p>As I said at the beginning, this is really just an example of the more general
theme. GADTs are about more than clever typed interpreters; they’re a powerful
mechanism for building easy to use abstractions that give you more precise
control of your memory representation. And getting the right memory
representation is often critical for building high performance applications.</p>

        </div><p>Yaron Minsky joined Jane Street back in 2002, and claims the dubious honor
of having convinced the firm to start using OCaml.
</p></div>
  </body>
</html>
