<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/introducing-litefs/">Original</a>
    <h1>LiteFS</h1>
    
    <div id="readability-page-1" class="page"><section> <img src="https://fly.io/blog/2022-09-21/litefs-cover.jpg" alt="A bird is packing a box full of logs to be shipped."/> <p><a href="http://fly.io/">Fly.io</a> runs apps close to users around the world, by taking containers and upgrading them to full-fledged virtual machines running on our own hardware around the world. We&#39;re also building an open-source distributed file system for SQLite called LiteFS which is pretty cool too. <a href="https://fly.io/docs/speedrun/">Give us a whirl</a> and get up and running quickly.</p><p>Full-stack developers are sleeping on SQLite, a database most devs think more suited to unit tests than production loads. That&#39;s true enough for some apps. Most web apps are read-heavy, though, and we can use that to our advantage. With the right tooling, SQLite makes for faster, simpler web apps.</p> <p>To understand why we won&#39;t shut up about SQLite, think about latency. You have a budget of around 100ms to make an app feel snappy. Individual Postgres queries add milliseconds of latency. Apps often run multiple queries before responding to users. Database round trips can take a big bite out of a latency budget.</p> <p>The same problem infects your full-stack code. Developing against a relational database requires devs to watch out for &#34;N+1&#34; query patterns, where a query leads to a loop that leads to more queries. N+1 queries against Postgres and MySQL can be lethal to performance. <a href="https://www.sqlite.org/np1queryprob.html">Not so much for SQLite</a>.</p> <p>The challenge of building full-stack on SQLite is that it isn&#39;t client-server: it&#39;s a library that runs inside of your app. In the past, that&#39;s made it hard to get durability and replication. Most devs aren&#39;t comfortable with <a href="https://crawshaw.io/blog/one-process-programming-notes">a &#34;single-server&#34; architecture</a>, where any downtime in your app server takes your whole app down.</p> <p>But you don&#39;t need to make peace with single-server designs to take advantage of SQLite. Earlier this year, we wrote about why we&#39;re <a href="https://fly.io/blog/all-in-on-sqlite-litestream/">all in on Litestream</a>. Litestream is SQLite&#39;s missing disaster recovery system: it&#39;s a sidecar process that hooks into SQLite&#39;s journaling and copies database pages to object stores such as S3. Like SQLite itself, it has the virtue of being easy to get your head around; we explained most of the design <a href="https://fly.io/blog/all-in-on-sqlite-litestream/">in a single blog post</a>, and using it just takes a couple commands.</p> <p>We want to see how far we can push this model, and so we&#39;ve been working on something new.</p> <h2 id="litefs-where-we-re-going-we-don-t-need-database-servers"><a href="#litefs-where-we-re-going-we-don-t-need-database-servers" aria-label="Anchor"></a>LiteFS: Where We&#39;re Going We Don&#39;t Need Database Servers</h2><p>At least, not as such.</p> <p>LiteFS extends the idea of Litestream with fine-grained transactional control. Where Litestream simply copies the raw SQLite WAL file, LiteFS can inspect and ship individual transactions, which span pages, and are the true unit of change in a SQL database.</p> <p>SQLite imposes on us a constraint that makes this transactional control harder: SQLite is baked into the apps that use it. If you build something that changes the SQLite library itself, you&#39;re not building tooling; you&#39;re building a new database. And we&#39;re not interested in getting people to switch to a new flavor of SQLite.</p> <p>There&#39;s two options for intercepting the file system API in SQLite:</p> <ol> <li>Use the <a href="https://www.sqlite.org/vfs.html">Virtual File System (VFS)</a> abstraction in SQLite. </li><li>Build a <a href="https://www.kernel.org/doc/html/latest/filesystems/fuse.html">FUSE file system</a>. </li></ol> <p>The VFS option is easier so, naturally, we chose to build a FUSE file system. That&#39;s how you&#39;re supposed to do it, right?</p> <p>LiteFS works by interposing a very thin virtual filesystem between your app and your on-disk database file. It&#39;s not a file system like ext4, but rather a pass-through. Think of it as a file system proxy. What that proxy does is track SQLite databases to spot transactions and then LiteFS copies out those transactions to be shipped to replicas.</p> <p>In the default journaling mode, transactions are easy to identify: a write transaction starts when the <code>-journal</code> file is created, and ends when it&#39;s deleted. The journal stores the page numbers and old page data and we can look up the new page data from the main database file.</p> <p>You see where this is going. SQLite&#39;s exquisitely documented file format makes it easy for LiteFS to replicate whole databases. Now we&#39;ve got transaction boundaries. So we roll those transactions up into a simple file format we call <a href="https://github.com/superfly/ltx">LTX</a>. LiteFS replicas can replay those transactions back to recreate the current (or any previous) transaction state of a LiteFS-tracked SQLite database — without touching app code. It seems like magic, but it&#39;s a natural consequence of SQLite&#39;s strong design.</p> <h3 id="ok-so-why-didn-t-you-write-a-vfs-instead"><a href="#ok-so-why-didn-t-you-write-a-vfs-instead" aria-label="Anchor"></a>Ok, So Why Didn&#39;t You Write a VFS Instead?</h3><p>First off, we have nothing against the SQLite VFS system—it&#39;s great! We&#39;re planning on also releasing LiteFS as a VFS with a super catchy name like… LiteVFS.</p> <p>If you&#39;re unfamiliar with VFSes, they serve as an abstracted file system API. In fact, you use them all the time since SQLite ships with two built-in VFS modules: one for Unix &amp; one for Windows. You can also load a third-party VFS as an extension, however, therein lies the first problem. There&#39;s an extra step to use it. Every time someone needs to use the database, they have to remember to load the VFS. That includes when your application runs but also when you just load up the <code>sqlite3</code> CLI.</p> <p>LiteFS also needs to run an API server to replicate data between nodes. This gets complicated if you have multiple processes on a single machine trying to access the same local database. Which one runs the API server?</p> <p>The FUSE file system solves many of these usability issues by being a single point that all database calls go through. Once you mount it, there&#39;s no additional steps to remember and any number of processes can use it just like a regular file system.</p> <h2 id="what-litefs-can-do-today"><a href="#what-litefs-can-do-today" aria-label="Anchor"></a>What LiteFS Can Do Today</h2><p>LiteFS&#39; roots are in Litestream which was built with a simple purpose: keep your data safe on S3. However, it still ran with a single-server architecture which poses two important limitations.</p> <p>First, if your one server goes down during a deploy, your application stops. That sucks.</p> <p>Second, your application can only serve requests from that one server. If you fired up your server in Dallas then that&#39;ll be snappy for Texans. But your users in Chennai will be cursing your sluggish response times since there&#39;s a 250ms ping time between Texas &amp; India.</p> <p>LiteFS aims to fix these limitations.</p> <p>To improve availability, it uses leases to determine the primary node in your cluster. By default, it uses Hashicorp&#39;s <a href="https://www.consul.io/">Consul</a>.</p> <p>With Consul, any node marked as a candidate can become the primary node by obtaining a time-based lease and is the sole node that can write to the database during that time. This fits well in SQLite&#39;s single-writer paradigm. When you deploy your application and need to shut down the primary, that node can release its lease and the &#34;primary&#34; status will instantly move to another node.</p> <p>To improve latency, we&#39;re aiming at a scale-out model that works <a href="https://fly.io/blog/globally-distributed-postgres/">similarly to Fly Postgres</a>. That&#39;s to say: writes get forwarded to the primary and all read requests get served from their local copies. Most app requests are reads, and those reads can be served lightning fast from in-core SQLite replicas anywhere in your deployment.</p> <p>But wait, that&#39;s not all! There are many ways to do replication and each application has its own needs around data access. LiteFS also lets you use a static primary node if you don&#39;t want to use Consul.</p> <p>We even have more topologies in the works. We&#39;ve had suggestions from the community to support other approaches like <a href="https://github.com/superfly/litefs/issues/24">primary-initiated replication</a>. That would allow folks to stream real-time database updates to customers outside their network instead of customers connecting in. Kinda niche, but cool.</p> <h2 id="split-brain-detection"><a href="#split-brain-detection" aria-label="Anchor"></a>Split Brain Detection</h2><p>LiteFS uses asynchronous replication between a loose membership of ephemeral nodes. It trades some durability guarantees for performance and operational simplicity that can make sense for many applications.</p> <p>It&#39;s able to do this because the primary election through Consul is dynamic and self-healing, which is again both the good and the bad news. Because dynamic topologies can have weird failure modes, LiteFS is designed defensively: we maintain a checksum for the entire state of the database and include it in each LTX file. This sounds expensive, but we can maintain it incrementally.</p> <p>We&#39;re able to maintain this checksum by calculating the checksum for each page and XOR&#39;ing the results together:</p> <div><pre><code>chksum = 0
FOREACH page
    chksum = chksum XOR crc64(page.number, page.data)
END
</code></pre></div><p>When a transaction changes pages in the database, we&#39;ll start with the checksum of the previous LTX file, remove the old checksums for the changed pages, and add in the new checksums for the changed pages:</p> <div><pre><code>chksum = prev_chksum
FOREACH page
    chksum = chksum XOR crc64(page.number, page.old_data)
    chksum = chksum XOR crc64(page.number, page.new_data)
END
</code></pre></div><p>Since XOR operations are commutative, we can even checksum across compacted LTX files or checksum the current state of the database. We can do this in LiteFS because we have fine-grained control over the file system writes.</p> <p>These database checksums ensure that an LTX file cannot be applied out of order and corrupt your database: they ensure byte-for-byte consistency for all the underlying data. We verify these on startup so that every database must be in a consistent state relative to its LTX checksum.</p> <h2 id="where-we-re-heading-with-this"><a href="#where-we-re-heading-with-this" aria-label="Anchor"></a>Where We&#39;re Heading With This</h2><p>We think LiteFS has a good shot at offering the best of both n-tier database designs like Postgres and in-core databases like SQLite. In a LiteFS deployment, the parts of your database that really want to be networked are networked, but heavy lifting of the data itself isn&#39;t.</p> <p>It&#39;s not just about performance. If you&#39;re using a database server like Postgres or MySQL today, chances are you&#39;re using a &#34;managed&#34; database service, where some other team is making sure your database is up and running. Everybody uses managed services because keeping database servers happy is annoying. With SQLite, there&#39;s not as much stuff that can break.</p> <p>And we&#39;ll keep saying this: the reason we think LiteFS and full-stack SQLite is a good bet is that the design is simple. You can <a href="https://github.com/superfly/litefs/blob/main/docs/ARCHITECTURE.md">read a summary of the LiteFS design</a> and understand what each of these components is doing. SQLite is one of of the most trusted libraries in the world; most of our job is just letting SQLite be SQLite. Your app doesn&#39;t even need to know LiteFS is there.</p> <p>We&#39;re plowing ahead on LiteFS features. Here are a few big ones to look out for:</p> <p><strong>WAL-mode Support:</strong> today, LiteFS works with SQLite&#39;s default rollback journal mode. But WAL mode is where it&#39;s at with modern SQLite. The FUSE proxy model works fine here too: transactions start with a write to the <code>-wal</code> file, and end with another write that marks a header with the <em>commit</em> field set.</p> <p><strong>Write Forwarding:</strong> SQLite works with a single-writer, multiple-reader model and our primary/replica replication mimics that. However, it adds friction to require developers to forward writes to the primary node. Instead, we&#39;re making it so any node can perform a write and then forward that transaction data to the primary. The primary can then replicate it out to the rest of the cluster.</p> <p><strong>S3 Replication:</strong> running a cluster of LiteFS nodes significantly improves your durability over a single-server deployment. However, nothing gives quite the same warm fuzzy feeling as tucking away a copy of your database in object storage. This will work similarly to Litestream, however, LiteFS&#39; LTX files are built to be efficiently compacted so restoring a point-in-time copy of your database will be nearly instant.</p> <p><strong>Encryption:</strong> we want developers to feel safe keeping SQLite replicas on services like S3. So we&#39;ve designed an AEAD encryption scheme that fits into LiteFS naturally and ensures that even if you manage to expose your LTX files to the Internet, you won&#39;t have exposed any plaintext.</p> <h2 id="try-it-out"><a href="#try-it-out" aria-label="Anchor"></a>Try It Out</h2><p>After several months of work, we&#39;re comfortable calling LiteFS beta-ready. We&#39;d be happy if you played around with it.</p> <p>We&#39;ve set up a <a href="https://fly.io/docs/litefs/">documentation site for LiteFS</a> so you can get going with it and understand how it works. The easiest way to get up and running is to walk through our <a href="https://fly.io/docs/litefs/getting-started/"><em>Getting Started with LiteFS</em></a> guide. It only takes about 10 minutes and you&#39;ll have a globally-distributed SQLite application running. Crazy, right!?</p> <p>LiteFS is completely open source, developed in the open, and in no way locked into Fly.io, which invests resources in this solely because we are nerds about SQLite and not in any way because LiteFS is part of a secret plan to take over the world. Pinky-swear!</p>  </section></div>
  </body>
</html>
