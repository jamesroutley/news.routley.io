<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonhearne.com/2021/layout-shifts-webfonts/">Original</a>
    <h1>How to avoid layout shifts caused by web fonts</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>One of the outcomes of the release of <a href="https://simonhearne.com/2020/core-web-vitals/">Core Web Vitals</a> (and subsequent <a href="https://developers.google.com/search/blog/2020/11/timing-for-page-experience">inclusion</a> in Google’s page ranking algorithm) is that we have been paying more attention to unexpected layout shifts and the cumulative layout shift (CLS) score.</p>
<p>Some sources of layout shifts have been simple to resolve: pre-allocate the correct space for dynamic elements, use width and height attributes on images and prioritise visible elements in your HTML document. One common cause of layout shift is surprisingly difficult to resolve though: flashes of unstyled text (FOUT).</p>
<p>In this post we will explore the surprisingly complex world of text rendering on the web and some techniques to remove FOUT while not incurring a <abbr title="Cumulative Layout Shift">CLS</abbr> penalty.</p>
<p>In summary we need to prevent the layout shift by letting the browser render in a fallback system font if it doesn’t get the web font in time, then optimise our fonts to try to get them to the browser before it needs them:</p>
<ul>
<li>use <code>font-display: optional</code> to prevent layout shifts</li>
<li>subset fonts and serve as <code>woff2</code></li>
<li>use variable fonts or a limited set of weight variations</li>
<li>preload critical fonts</li>
<li>host your own fonts on your main domain</li>
</ul>
<h2 id="why-fonts-cause-layout-shifts">Why fonts cause layout shifts</h2>
<p>Unexpected layout shifts (page content moving around without user interaction) are bad for user experience. Fonts cause layout shifts when the size of the containing element (e.g. a <code>&lt;div&gt;</code> or paragraph) changes when the web font is downloaded. This occurs when the height of the font or the length of the paragraph is different with the web font compared to the system font. When laying out a page, browsers will use the dimensions and properties of the fallback font to determine the size of the containing elements, even if you have declared a web font to block the system font with <code>font-display: block</code>!</p>

<figure>
<p id="demo-text-1">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin aliquam metus eu lacus placerat feugiat. Suspendisse quis elit fringilla, luctus felis ut, ultricies leo. Morbi vel dui non risus aliquam rhoncus in ac justo. Mauris cursus diam id ipsum aliquet tempus. Praesent feugiat consequat risus, ut eleifend neque consequat quis. Maecenas rhoncus faucibus dui quis pretium. Nam ultrices rhoncus dui, at pretium erat rhoncus et. Vestibulum tempus diam vel ex venenatis placerat. Nam sed elementum odio. Suspendisse vel orci turpis. Fusce in maximus ante, non malesuada justo. Duis in tellus erat.</p>
<figcaption>Flash of Unstyled Text</figcaption>
</figure>

<h3 id="detecting-layout-shifts">Detecting layout shifts</h3>
<p>There are a number of methods to detect layout shifts due to web fonts, the most simple is to run your page through <a href="https://webpagetest.org/">WebPageTest</a> and use the filmstrip view. There is a toggle to show layout shifts, combine that with ‘huge’ screenshot images and a 0.1s interval to get a clear view of what is happening as your page renders (you can simply add this to the end of the URL: <code>&amp;highlightCLS=1&amp;thumbSize=600&amp;ival=100&amp;end=visual&amp;text=000&amp;bg=fff&#34;</code>). The Washington Post has a couple of layout shifts due to web fonts, in the example below the headline text is one line shorter with the web font than without which results in a layout shift. Layout shifts are dependent on viewport size so make sure you test a few different devices.</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/wapo-headline.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/wapo-headline.png" alt="" loading="lazy" width="1000" height="369" srcset="
    /images/layout-shifts-webfonts/wapo-headline.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/wapo-headline.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/wapo-headline.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/wapo-headline.png 1000w" sizes="(min-width: 125em) px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, px"/></a>
<figcaption>Headline web font loading causes a layout shift. <a href="https://webpagetest.org/video/compare.php?tests=210120_Di3C_126898f84daca6ada62ee7736a29bddb-r%3A1-c%3A0&amp;highlightCLS=1&amp;thumbSize=600&amp;ival=100&amp;end=visual&amp;text=000&amp;bg=fff">View test on WPT</a></figcaption>
</figure>
<p>You can also find layout shifts in the Chrome Developer Tools Performance tab, look for layout shifts attributed to text elements.</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/wapo-shift.jpg">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/wapo-shift.jpg" alt="" loading="lazy" width="1000" height="573" srcset="
    /images/layout-shifts-webfonts/wapo-shift.jpg?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/wapo-shift.jpg?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/wapo-shift.jpg?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/wapo-shift.jpg 1000w" sizes="(min-width: 125em) px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, px"/></a>
<figcaption>Chrome developer tools shows attribution of layout shifts</figcaption>
</figure>
<p>I’ve covered general layout shifts in more detail in a post on <a href="https://simonhearne.com/2020/core-web-vitals/">How to Improve Core Web Vitals</a>.</p>
<h2 id="prevent-layout-shifts-with-font-display">Prevent layout shifts with font-display</h2>
<p>The dirty little secret of this blog post is that you can resolve layout shifts due to fonts with a single line of CSS:</p>
<p><code>font-display: optional</code></p>
<p>This directive lives in your font-face declaration and tells the browser to use a fallback system font if the web font is not available at the time of rendering text (plus 100ms). This means that on uncached page loads there is a chance that the fallback font will be used, but all subsequent page loads should be rendered with the web font, as it will be downloaded and available in cache. There are other options, shown in the image below:</p>
<ul>
<li><strong>block</strong> - hide text for up to three seconds while waiting for the web font, and always swap in the web font when it loads</li>
<li><strong>swap</strong> - show text as soon as possible, and always swap in the web font when it loads</li>
<li><strong>fallback</strong> - hide text for up to 100ms, then only swap in the web font if it loads within three seconds</li>
<li><strong>optional</strong> - hide text for up to 100ms, then only use the web font if it is available - never swapping</li>
</ul>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/font-display.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/font-display.png" alt="" loading="lazy" width="1000" height="562" srcset="
    /images/layout-shifts-webfonts/font-display.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/font-display.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/font-display.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/font-display.png 1000w" sizes="(min-width: 125em) 600px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, 600px"/></a>
<figcaption>Optional is the only font-display value which guarantees no layout shift. <a href="https://speakerdeck.com/notwaldorf/fontastic-web-performance?slide=74">Image</a> by <a href="https://twitter.com/notwaldorf">@notwalforf</a>. <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display">Read more on MDN</a></figcaption>
</figure>
<p>If it’s that simple, why this whole blog post? Unfortunately system fonts are not necessarily the nicest designs, and they are not consistent between operating systems. Most designers will cringe at the thought of showing users a fallback system font. The rest of this blog post details various optimisations to get the font files to the browser quicker, allowing the use of any font-display option but with minimal risk of showing a system font, or for options other than <code>optional</code>: without triggering a layout shift. We will also look at font-face descriptors / f-mods and progressive font enrichment for potential further optimisations in the future.</p>
<h2 id="load-fewer-font-files">Load fewer font files</h2>
<p>Downloading one or two font files to render text won’t have a massive impact on speed, downloading five or ten font files will! Ensuring that you deliver the minimium viable number of font files is the best way to ensure that the browser has them available at layout, thus reducing the likelihood of <abbr title="Flash of Unstyled Text">FOUT</abbr> layout shifts. Let’s look at some tricks to load fewer font files while maintaining your design.</p>
<h3 id="use-faux-bold-and-italic">Use faux bold and italic</h3>
<blockquote>
<p>Designers hate this one weird trick!</p>
</blockquote>
<p>Font stacks generally include a bunch of different files, from extra-light italic through to extra-bold. Combining nine font weights with normal and italic variants produces 18 separate font files! Fonts that are not used on the page will not be downloaded, but for the odd occasion where only a single word is both bold and italic (for example) the whole font file will be downloaded to render the single word.</p>
<p>Browsers can make bold and italic versions of fonts themselves, this is called faux bold and faux italic. This could mean that a single regular weight font file is all you need! This should be tested and approved by any designers involved, I recommend a blind <a href="https://juiceboxinteractive.com/blog/how-pepsi-won-the-battle-but-lost-the-challenge/">Coke vs. Pepsi</a> style test to prevent any bias impacting the outcome.</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/faux-bold.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/faux-bold.png" alt="image showing faux bold of roboto font compared to real bold, there is little difference" loading="lazy" width="1000" height="530" srcset="
    /images/layout-shifts-webfonts/faux-bold.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/faux-bold.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/faux-bold.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/faux-bold.png 1000w" sizes="(min-width: 125em) 600px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, 600px"/></a>
<figcaption>Example of differences between faux and real bold. <a href="https://graphicdesign.stackexchange.com/questions/75965/distinguishing-real-and-faux-bold-and-italics">source</a></figcaption>
</figure>
<p>There may be subtle differences between the browser’s version of a bold font and the font creator’s version, as shown above. For some fonts the differences will be too great to consider, especially fancy ones! You can check yours by simply removing the @font-face declarations for all but the regular font version and comparing screenshots of rendered text.</p>
<h3 id="use-a-variable-font">Use a variable font</h3>
<p>All modern browsers support variable fonts (notable exceptions are <a href="https://caniuse.com/variable-fonts">IE11 and Opera Mini</a>), this allows a single font file to include multiple variable axes like font weight and slant. This results in a larger file than a single weight font, but it replaces multiple weight files and provides more flexibility for the variable axes (e.g. font-weight: <span>457</span>).</p>
<p>Variable fonts can be found in multiple places, for example Google Fonts <a href="https://fonts.google.com/?vfonly=true">has a filter</a> to only show variable fonts. The majority of variable fonts have a single variable axis for weight, but there are a number of possible dimensions including slant, serif and optical size. <a href="https://fonts.google.com/specimen/Exo?vfonly=true">Exo</a> for example has both weight and a binary italic dimension. <a href="https://www.axis-praxis.org/specimens/__DEFAULT__">Axis Praxis</a> is a great place to explore the possibilities of variable fonts.</p>
<h3 id="death-to-icon-fonts">Death to icon fonts</h3>
<p>Icon font sets like <a href="https://fontawesome.com/">Font Awesome</a> and Bootsrap’s <a href="https://getbootstrap.com/docs/3.3/components/">glyphicons</a> have popularised the use of web fonts for iconography. Unfortunately this means that your icons will not render until a (typically) large font file has downloaded, and sometimes results in an unsightly <span>⃞</span> symbol instead of your icons when the font file fails to download in time.</p>
<p>Icon fonts are bad practice for performance and accessibility, <a href="https://www.wouterbulten.nl/blog/tech/blog-optimization-replacing-font-awesome-with-svg/">replace them with SVG</a> as soon as possible.</p>
<p>N.B. this section is named after the great talk given by <a href="https://twitter.com/ninjanails">Seren Davies</a>: <a href="https://www.youtube.com/watch?v=9xXBYcWgCHA">Death to Iconfonts ☠️</a></p>
<h3 id="use-system-fonts">Use system fonts</h3>
<p>Web fonts are popular because they allow designers to maintain a consistent look and feel across browsers. Where this isn’t necessary, system fonts will be the fastest method to render text. If your current web font is close to a system font, you can use <a href="https://meowni.ca/font-style-matcher/">Font Style Matcher</a> by <a href="https://twitter.com/notwaldorf">Monica</a> to tweak the font settings until you get a near-perfect match. I’ve worked with a client who surreptitiously replaced their web font stack with a tweaked system font for two weeks - neither designers nor customers apparently noticed the difference!</p>
<p>Using a system font means that text will render at the earliest possible time. We also now have methods to make the font match the operating system, which may be more attractive than previous fallback options like Arial and Helvetica. To do this you’ll need to list the system fonts for all operating systems in a specific order:</p>
<div><div><pre><code><span>body</span> <span>{</span>
  <span>font-family</span><span>:</span> <span>-apple-system</span><span>,</span> <span>BlinkMacSystemFont</span><span>,</span>
    <span>&#34;Segoe UI&#34;</span><span>,</span> <span>&#34;Roboto&#34;</span><span>,</span> <span>&#34;Oxygen&#34;</span><span>,</span> <span>&#34;Ubuntu&#34;</span><span>,</span> <span>&#34;Cantarell&#34;</span><span>,</span>
    <span>&#34;Fira Sans&#34;</span><span>,</span> <span>&#34;Droid Sans&#34;</span><span>,</span> <span>&#34;Helvetica Neue&#34;</span><span>,</span>
    <span>sans-serif</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>You can read more about this approach in a Smashing Magazine <a href="https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/">article from 2015</a>. One drawback to this approach is that it cannot co-exist with the <a href="#reduce-layout-shift-with-f-mods">f-mods</a> approach we describe below, this is to be used <em>instead</em> of web fonts. <a href="#conversation">Let me know</a> if I’m wrong in this assumption!</p>
<h2 id="optimise-font-files">Optimise font files</h2>
<p>If we must download a font file, we should make it as small as possible to ensure it downloads quickly. There are two key methods to optimise web fonts: subsetting and formats.</p>
<h3 id="subset-fonts">Subset fonts</h3>
<p>Many fonts will have glyphs (glyphs are individual characters like <code>a</code> or <code>&amp;</code>) from multiple alphabets. If your website is only delivered in the latin alphabet (a - Z) and does not use ligatures (like <code>é</code>) then these glyphs represent wasted bytes in your font file. Roboto, the most popular Google font, has 277 glyphs.</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/roboto-glyphs.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/roboto-glyphs.png" alt="image of all glyphs in the roboto font from google, showing many non-latin characters" loading="lazy" width="1000" height="310" srcset="
    /images/layout-shifts-webfonts/roboto-glyphs.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/roboto-glyphs.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/roboto-glyphs.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/roboto-glyphs.png 1000w" sizes="(min-width: 125em) 600px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, 600px"/></a>
<figcaption>Glyphs in the popular Roboto font. <a href="https://fonts.google.com/specimen/Roboto?selection.family=Roboto&amp;sidebar.open=true#glyphs">source</a></figcaption>
</figure>
<p>Removing non-latin characters from this font results in a <code>woff2</code> file that is one sixth the size!</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/subset-roboto.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/subset-roboto.png" alt="screenshot of file system showing subset roboto font is 11KB, original is 66KB" loading="lazy" width="1000" height="179" srcset="
    /images/layout-shifts-webfonts/subset-roboto.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/subset-roboto.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/subset-roboto.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/subset-roboto.png 1000w" sizes="(min-width: 125em) 500px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, 500px"/></a>
<figcaption>Subset font is 5x smaller</figcaption>
</figure>
<p>If you use Google fonts, you can <a href="https://developers.google.com/fonts/docs/getting_started#specifying_script_subsets">specify which subsets</a> you require in the CSS request. If you host your own fonts (which I would always recommend, where possible) you will need to check with the font provider if they have subset versions, or where your license permits you can create subsets yourself.</p>
<p>To create subsets you will ideally start with the <code>ttf</code> file and work out what glyphs you need to keep. Filament Group have created <a href="https://github.com/filamentgroup/glyphhanger">glyphhanger</a> to take out the hard work here, read their <a href="https://www.filamentgroup.com/lab/glyphhanger/">blog post</a> to see how easy it is to create a unique subset font just for your pages. Note that missing glyphs will be rendered in the fallback system font, so they won’t just disappear!</p>
<p>It is possible to create multiple subset variations of your fonts if your website supports multiple languages. In this case, use the <code>unicode-range</code> declaration in your @font-face rule to let the browser know which characters are in which font file. Read more about this on <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range">MDN</a> or take a look at <a href="https://fonts.googleapis.com/css2?family=Open+Sans&amp;display=swap">a response</a> from Google Fonts for inspiration.</p>
<h3 id="use-modern-formats">Use modern formats</h3>
<p>There are a set of different formats available to serve web fonts: <code>ttf</code>, <code>otf</code>, <code>eot</code>, <code>woff</code> and <code>woff2</code>. <code>ttf</code> and <code>otf</code> are the ‘raw’ font files, and probably shouldn’t be sent to a browser. <code>eot</code> supports subsetting and is compressed using LZ compression, whereas <code>woff</code> uses gzip compression and <code>woff2</code> uses brotli compression.</p>
<p>Font stacks will often have many or all of these formats available, but you really only need <code>woff2</code>. The newer format is around 30% smaller than <code>woff</code> and is supported in all modern browsers. Supporting only <code>woff2</code> will make it more simple to apply some of the other optimisations recommended, such as subsetting.</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/woff2-support.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/woff2-support.png" alt="can i use dot com shows all browsers except opera and IE11 support woff2" loading="lazy" width="1000" height="331" srcset="
    /images/layout-shifts-webfonts/woff2-support.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/woff2-support.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/woff2-support.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/woff2-support.png 1000w" sizes="(min-width: 125em) px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, px"/></a>
<figcaption><code>woff2</code> is supported on all the browsers you care about. <a href="https://caniuse.com/woff2">source</a></figcaption>
</figure>
<h2 id="deliver-your-fonts-fast">Deliver your fonts fast</h2>
<p>It may seem obvious, but we must make sure that the browser can download our font files as soon as possible! There are a few techniques we should follow to ensure this is always the case. Hosting fonts on your own domain (and ideally on a content delivery network (CDN)) will result in the best performance.</p>
<h3 id="host-your-own-fonts">Host your own fonts</h3>
<p>Font foundries such as Google Fonts are popular: the HTTP Archive shows that <a href="https://almanac.httparchive.org/en/2020/fonts#where-are-web-fonts-being-used">80% of sites</a> use web fonts, and <a href="https://almanac.httparchive.org/en/2020/third-parties#third-party-domains">7.5%</a> of all web fonts are served by Google. Using a third-party service can incur a performance penalty, though. The Google Fonts embed process uses either a CSS link or @import, with the CSS file returning a dynamic set of @font-face rules. The rules are distinct for the given font, user agent and any additional query parameters (like subsetting and font-display options).</p>
<p>Using a third-party service means that your fonts will be delayed. The best-case scenario is that you are requesting the font file directly from another hostname (e.g. fonts.gstatic.com) which incurs a connection cost - DNS lookup, TCP connection and TLS negotiation. The worst case is multiple hops, like loading a CSS file from fonts.googleapis.com which references files on fonts.gstatic.com, incurring two connection penalties. This cost may be outweighed by the benefit in some cases for Google Fonts though, as the fonts they deliver are well optimised and subset by alphabet automatically.</p>
<p>In general you should serve the fonts from your domain to avoid the cost of connecting to third-party domains, this will be especially important on high latency connections.</p>
<h3 id="cache-your-fonts">Cache your fonts</h3>
<p>Fonts can be cached in two places: the client and the <abbr title="Content Delivery Network">CDN</abbr>. Caching on the client is important for mid-session navigations and should be done in such a way as to avoid revalidation requests. Revalidation requests (<code>if-not-modified</code> and <code>if-modified-since</code>) will block the browser from using the font file until it has verified that it has not changed on the server. Fonts rarely change, so we should implement a cache header as follows and update the filename if the font changes to break the cache:</p>
<p><code>cache-control: max-age=31536000,immutable</code></p>
<p>This tells browsers that they can keep the font for up to a year and that it does not need to be revalidated (<code>immutable</code> <a href="https://caniuse.com/mdn-http_headers_cache-control_immutable">is supported</a> in Firefox and Safari, Chrome should avoid revalidation requests automatically). Avoid adding ETags to these responses as they may force revalidation.</p>
<p>Check also that your Content Delivery Network configuration can store the font files in cache, older configurations may not include the <code>.woff2</code> extension resulting in origin hits and slowing down the response.</p>
<h3 id="use-preload-hints">Use preload hints</h3>
<p>Web browsers do not download fonts unnecessarily, they wait until the render tree has been constructed in order to know which fonts are required. This means that web fonts are only requested when the browser has downloaded and parsed the HTML and CSS, right before text is rendered. Note that inline CSS does not require a network request - meaning your fonts could be fetched earlier in the page load.</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/font-crp.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/font-crp.png" alt="flow diagram shows that web font loading is blocked by render tree construction" loading="lazy" width="1000" height="379" srcset="
    /images/layout-shifts-webfonts/font-crp.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/font-crp.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/font-crp.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/font-crp.png 1000w" sizes="(min-width: 125em) 600px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, 600px"/></a>
<figcaption>Render tree construction delays web font request. <a href="https://web.dev/optimize-webfont-loading/">source</a></figcaption>
</figure>
<p>If we know that a web font is definitely going to be required to render text on a page, we can make a promise to the browser that it needs to be downloaded as soon as possible. This is a preload hint:</p>
<div><div><pre><code><span>&lt;link</span> <span>rel=</span><span>&#34;preload&#34;</span> <span>href=</span><span>&#34;/my-font.woff2&#34;</span> <span>crossorigin=</span><span>&#34;anonymous&#34;</span> <span>as=</span><span>&#34;font&#34;</span> <span>type=</span><span>&#34;font/woff2&#34;</span><span>&gt;</span>
</code></pre></div></div>
<p>When the browser parses this line of HTML it will immediately dispatch a high priority request for the font file. Doing this means that the web font is much more likely to be available when the browser renders text.</p>
<blockquote><p>preloaded requests will cannibalise bandwidth from other early requests, use with caution!</p></blockquote>
<p>Preloaded requests are high-priority. In the waterfall section below you can see that five font files are downloaded, one blocks the page CSS (possibly because the <code>&lt;link rel=&#34;preload&#34;&gt;</code> was above the <code>&lt;link rel=&#34;stylesheet&#34;&gt;</code>) and the others block the main JavaScript bundle for the page. Note that this page was served over HTTP/2 on Chrome, other browsers and protocols will vary!</p>
<figure>
<a target="_blank" href="https://simonhearne.com/images/layout-shifts-webfonts/preload-slow-script.png">
<img src="https://simonhearne.com/images/layout-shifts-webfonts/preload-slow-script.png" alt="waterfall section showing fonts blocking main javascript bundle download" loading="lazy" width="1000" height="639" srcset="
    /images/layout-shifts-webfonts/preload-slow-script.png?nf_resize=fit&amp;w=600 600w,
    /images/layout-shifts-webfonts/preload-slow-script.png?nf_resize=fit&amp;w=800 800w,
    /images/layout-shifts-webfonts/preload-slow-script.png?nf_resize=fit&amp;w=1000 1000w,
    /images/layout-shifts-webfonts/preload-slow-script.png 1000w" sizes="(min-width: 125em) 600px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, 600px"/></a>
<figcaption>Preloaded fonts delay main JS bundle.</figcaption>
</figure>
<p>Ensure that your preload tags are below critical content in the head and limit to two or three font files to get the best benefit.</p>
<h2 id="reduce-layout-shift-with-f-mods">Reduce layout shift with f-mods</h2>
<p>If <code>font-display: optional</code> is not possible for your design, we need to attempt to match the fallback font layout to the web font as closely as possible. Enter font-display modifiers (f-mods), also known as font-face descriptors.</p>
<p>F-mods are in a <a href="https://docs.google.com/document/d/1PW-5ML5hOZw7GczOargelPo6_8Zkuk2DXtgfOtJ59Eo/edit">proposed update</a> to the font-face descriptors specification which includes four new descriptors:</p>
<ul>
<li><strong>ascent-override (%)</strong> - overrides the size allocated for ascenders</li>
<li><strong>descent-override (%)</strong> - overrides the line height allocated for descenders</li>
<li><strong>line-gap-override (%)</strong> - overrides the gap between lines</li>
<li><strong>advance-override (#)</strong> - sets an extra advance for each character, to help match line width and prevent word overflows</li>
</ul>
<p>The first three all impact the height of a line: line box height = ascent + descent + line gap. Baseline position = line box top + line gap / 2 + ascent. For example, if we have <code>ascent-override: 80%; descent-override: 20%; line-gap-override: 0%</code>, then each line box has height 1em (assuming 1em used font size), and the baseline is positioned at 0.8em below the line box top. The <code>advance-override</code> descriptor adds a fraction of the font-size as a gap before each character, for example <code>font-size:16px; advance-override: 0.1;</code> will add a 1.6px gap before each character.</p>
<p>The combination of these four descriptors allow us to override the layout of the fallback font to match the web font, by telling the browser how much space the characters will take up before the web font is downloaded. Read more in the <a href="https://docs.google.com/document/d/1PW-5ML5hOZw7GczOargelPo6_8Zkuk2DXtgfOtJ59Eo/edit">proposal</a>.</p>
<h3 id="implementing-f-mods">Implementing f-mods</h3>
<p>The trick to implementing f-mods is to manually define your fallback system fonts with <code>src: local()</code>. This allows us to override the display of the fallback font to match the web font:</p>
<div><div><pre><code><span>@font-face</span> <span>{</span>
  <span>font-family</span><span>:</span> <span>custom-font</span><span>;</span>
  <span>src</span><span>:</span> <span>url(&#34;https://example.com/font.woff2&#34;)</span><span>;</span>
<span>}</span>
<span>@font-face</span> <span>{</span>
  <span>font-family</span><span>:</span> <span>fallback-font</span><span>;</span>
  <span>src</span><span>:</span> <span>local</span><span>(</span><span>Arial</span><span>);</span> <span>/* required! */</span>
  <span>advance-override</span><span>:</span> <span>xx</span><span>;</span>
  <span>ascent-override</span><span>:</span> <span>xx</span><span>;</span>
  <span>descent-override</span><span>:</span> <span>xx</span><span>;</span>
  <span>line-gap-override</span><span>:</span> <span>xx</span><span>;</span>
<span>}</span>
<span>body</span> <span>{</span>
  <span>font-family</span><span>:</span> <span>custom-font</span><span>,</span> <span>fallback-font</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>Calculating the required values might seem complex, but the information we need is already in your web font file. First you’ll need the TTF file for your font; if you use Google Fonts then you can check find the TTF in the <a href="https://github.com/google/fonts/tree/master/ofl/">GitHub repository</a>. If you have licensed a font from a foundry then the TTF should have been supplied already.</p>
<p>Once you have the TTF head on over to <a href="https://fontdrop.info/">FontDrop</a> and upload the file. Open the <strong>Data</strong> tab and scroll to the <code>hhea - Horizontal Header Table</code>. There you should find four key values: <code>ascender</code>, <code>descender</code> , <code>line-gap</code> and <code>advanceWidthMax</code>.</p>
<figure>
<img src="https://simonhearne.com/images/fontdrop.jpg" alt="screenshot of font drop showing font HHEA table" loading="lazy" width="1000" height="668" srcset="
    /images/fontdrop.jpg?nf_resize=fit&amp;w=600 600w,
    /images/fontdrop.jpg?nf_resize=fit&amp;w=800 800w,
    /images/fontdrop.jpg?nf_resize=fit&amp;w=1000 1000w,
    /images/fontdrop.jpg 1000w" sizes="(min-width: 125em) 350px, (min-width: 86.375em) 50vw, (min-width: 37.5em) 66.6vw, (max-width: 37.5em) 83vw, 350px"/>
<figcaption>HHEA table data in FontDrop</figcaption>
</figure>
<p>These values are exactly what we need to set the font-face modifiers! In this case the web font has unitsPerEm = 1000 and ascender = 1027, so it’s best to set <code>ascent-override: 102.7%</code> in the fallback font face. I recommend experimenting with values until you find the right balance, using the playground below.</p>
<h3 id="f-mods-playground">F-mods Playground</h3>
<p>Use <a href="https://codepen.io/simonjhearne/pen/rNMGJyr">this codepen</a> to load your custom and fallback fonts, then play with the overrides to get a perfect match! Note that this will be specific to the operating system you are using, it may be worth validating across multiple devices.</p>
<p data-height="852" data-theme-id="light" data-default-tab="result" data-user="simonjhearne" data-slug-hash="rNMGJyr" data-pen-title="font-face descriptor playground">
<span>See the Pen <a href="https://codepen.io/simonjhearne/pen/rNMGJyr">
font-face descriptor playground</a> by Simon Hearne (<a href="https://codepen.io/simonjhearne">@simonjhearne</a>)
on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<h3 id="f-mods-limitations">F-mods limitations</h3>
<p>F-mods only really modify vertical spacing and positioning. This means that character- and letter-spacing still need to be dealt with otherwise you could have words breaking lines at different points, leading to a change in element heights and thus layout shifts. Unfortunately the <code>letter-spacing</code> and <code>word-spacing</code> properties are not available in the @font-face declaration so they must be declared on the body or an element. This means we may still have some work to do in order to prevent layout shift.</p>
<p>If the character and letter spacing needs to be modified for the web font, will need to apply CSS rules to all elements with the web font applied for when the fallback font is shown. This style must then be removed when the web font is loaded. This is possible using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Font_Loading_API">font loading API</a>, but the whole process feels racy and fragile. Changing layout-critical CSS with JavaScript doesn’t sit right with me.</p>
<p>Browser support for font-face descriptors is… well it’s only in Chrome, in v87+. There are, however, positive signals from Safari. No matter the browser support, font-face descriptors are a progressive enhancement so there is no reason not to implement them now.</p>
<h2 id="guaranteeing-fonts-load-in-time">Guaranteeing fonts load in time</h2>
<p>It has been suggested that fonts can be embedded in CSS as Base64 strings, thus removing the need for additional font requests and ensuring that the font is available at the time of rendering text. I have seen this on production websites, and it does achieve these goals.</p>
<p>Embedding fonts as Base64 strings comes with a number of drawbacks, as such I would not recommend this approach:</p>
<ol>
<li>Font files are compressed binary objects, encoding as Base64 strings will inflate the size significantly. gzip or brotli compression of the CSS bundle will not totally make up for this inflation.</li>
<li>The fonts will be sent to every browser, even if they can’t use them (e.g. Opera Mini and IE11 for woff2, users of <a href="https://chrome.google.com/webstore/detail/dyslexia-friendly/miepjgfkkommhllbbjaedffcpkncboeo?hl=en">Dyslexia Friendly</a>)</li>
<li>Fonts rarely change, but CSS changes often - this will reduce cache effectiveness for fonts as every CSS change will invalidate the whole bundle</li>
<li>Inflating CSS size will almost certainly delay page render</li>
<li>Embedding fonts prevents you from effectively using subsets and unicode-range for different alphabets</li>
</ol>
<p>In general, embedding fonts in CSS breaks the magic of web fonts: that browsers know what they need and will download it when they need it. There are two other options if you absolutely require the fonts to be available before the page renders:</p>
<ol>
<li>Hide the body until the font is ready, using <code>opacity: 0</code> and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Font_Loading_API">Font Loading API</a> to show content once the font loads (with a sensible timeout)</li>
<li>Use <code>display:block</code> and match the fallback font as closely as possible to your web font</li>
</ol>
<p>Option 1 would need a lot of testing to ensure that content is always shown eventually, I would avoid it entirely.</p>
<h2 id="the-future-of-font-performance">The future of font performance</h2>
<p>It is clear that font performance is not yet a solved problem. Thankfully, there a works afoot to improve this in the <a href="https://www.w3.org/Fonts/WG/">W3C Web Fonts Working Group</a>. One of the proposals is progressive font enrichment, this is an incremental font loading concept which allows browsers to request exactly the characters they need to render text, potentially drastically reducing initial font file size and thus improving render speed.</p>
<p>Google <a href="https://fonts.gstatic.com/experimental/incxfer_demo">has a demo</a> of this incremental transfer concept, and <a href="https://twitter.com/jpamental">Jason Pamental</a> has written up the concept in <a href="https://rwt.io/typography-tips/progressive-font-enrichment-reinventing-web-font-performance">much more detail</a> than I could here.</p>
<p>Whilst the incremental font loading concept is interesting, the main use case will be for very large font sets for non-latin languages. There are potential issues of cache dilution to resolve and the overall size of fonts delivered could exceed the optimal subset font file. Watch this space for more developments!</p>
<h2 id="in-conclusion">In conclusion</h2>
<p>Layout shifts are bad for user experience and tricky to resolve. Rendering text without layout shifts is much more complex than it should be! You can avoid layout shifts entirely if you can apply <code>font-display: optional</code> to your web fonts, otherwise it’s a case of racing the browser - trying to get your fonts to the browser before it starts to render text.</p>
<p>Racing the browser is possible by optimising your font files:</p>
<ul>
<li>Use <code>woff2</code> to minimise file size</li>
<li>Serve fonts from your own domain</li>
<li>Preload critical fonts</li>
<li>Subset the font to required characters</li>
<li>Limit the number of weight variations used</li>
<li>Explore variable fonts</li>
<li>Experiment with system fonts</li>
<li>Use f-mods to reduce the impact of font swaps</li>
</ul>
<p>As always, test all changes with real users and only keep them if you see a positive change. On this site I have set the body text to <code>font-display: optional</code> but my heading font and the italic variant of the body font to <code>font-display: swap</code>. Swapping in the heading font and italic variant do not cause a layout shift in most cases (except multi-line headings) so this is a good compromise between design and performance, in my opinion.</p>
</div></div>
  </body>
</html>
