<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fi-le.net/pypi/">Original</a>
    <h1>A Map of Python</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>
    
    <span>P</span>yPi, the Python Software Foundation&#39;s package repo, counts over half a million open source projects. Since I use many of these every day, it seemed appropriate to get to know this set of packages better, and show some appreciation. The index website provides nice search and filtering, which is good when looking for something specific. Here though, we want to take a look at every package at once, to construct a visualization, and perhaps even discover some cool new packages.
    </p>

    <p>
      To visualize the set, then, we need to find out its structure. Luckily PyPi provides a nice JSON API (see <a href="https://pypi.org/pypi/numpy/json">here</a> for numpy&#39;s entry for instance) and even luckier, there is a copy on <a href="https://cloud.google.com/bigquery">BigQuery</a> so that we don&#39;t have to bother the poor PyPi servers with &gt;600,000 requests.
    </p>

    <p>
      One SQL query later, we have a .jsonl of all the metadata we want. So what metadata do we want? Since we want to uncover the internal structure of the dataset, we focus on the defining feature of open source and look at the dependencies of each package. This gives a natural directed graph topology. For once, dependency hell is actually helpful!
    </p>

    <p>
      Half a million nodes is a lot for an interactive graph - good motivation to look at the data more closely. As all big datasets, the BigQuery mirror is messy, containing many not-so-classic Python packages like &#34;the-sims-freeplay-hack&#34;, &#34;cda-shuju-fenxishi-202209-202302&#34; and other collateral. These seem to have been detected and taken down by PyPi, because they don&#39;t have a package website. To get down to a reasonable sized dataset, we therefore filter for packages where some important columns aren&#39;t null. This gets us down to around 100000, so we somewhat arbitrarily filter for packages with more than 2 dependencies (and let them fill us in on the packages that they depend upon) for a smaller test dataset. We use all dependencies, including experimental, development and testing ones.
    </p>

    <p>
      Graph layouts are a classic computer science problem, and we can use handy software designed exactly for this kind of task, like <a href="https://gephi.org/">Gephi</a>. This lets us use an algorithm of our choice, and after playing around with a few, I find that the default <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0098679">Force Atlas 2</a>, an iterative spring-energy minimization, does the best job. This was expected! (<a href="https://www.youtube.com/watch?v=CDMQR422LGM">This amazing talk</a> by Daniel Spielman will convince you to love force-directed graph layouts, if you don&#39;t yet.)
    </p>

    <p>Here is the interactive graph:</p>

    

    <!-- Chart container starts hidden, toggled by JS -->
    

    <!-- Explanation and concluding paragraphs -->
    <p>
      I would have expected a very tightly knit cloud centering around the most common packages as the result, with little clustering. This is more or less what happens - two dimensions are just not enough to capture the neighborhoods of a highly connected graph. The mean degree is 4.97. But that is not the whole story.
    </p>

    <p>
      We obtain clusters of packages that depend on the same set of packages. Some are innocent: Only depending on numpy for example is a very good thing, in fact I wish that cluster was bigger. Another cluster though, it contains only packages depending on &#34;peppercorn&#34;, &#34;check-manifest&#34; and &#34;coverage&#34;. In there, we find packages with names like &#34;among-us-always-imposter-hack&#34;. Good job for passing the previous filter I suppose! These are copied from a template python package called <a href="https://pypi.org/project/pqc/">pqc</a>, and were uploaded uninitialized. Those with obviously spammy names are taken down, but some weird ones remain. A subcluster of 10 packages named variations of &#34;python-smshub-org&#34; sits in there since an upload in May 2019. As far as I can tell they no currently online packages contain malicious code, but I feel this is a proof of concept that graph drawing can find anomalies. Neat!
    </p>

    <p>
      Some organizations generate a lot Python packages. An enterprise software miscellanea company called Triton, for instance, puts out over 300 packages with their name in it. They all depend on the same base package and are thus visualized close together. Perhaps the biggest one is another enterprise software company, Odoo, whose main package has over 3000 child packages. Similar groupings include a data pipeline company called Airbyte with 320 packages, the Objective C bridge PyObjC with 167 packages and the content management system Plone. A corporate API client called aiobotocore apparently uses <a href="https://pypi.org/search/?q=%22types-aiobotocore%22&amp;o=">421 packages only for its types</a>.
    </p>
    <p>
      The energy-based layout also finds recognizable semantic neighborhoods. Some, I know better, such as north of numpy, where scikit-learn, seaborn and tensorflow are hanging out. Others less, like the region around cryptography. This is already a nice way to window shop some packages, but I am very sure that this only scratches the surface of this dataset. Some further steps would be to visualize recursive dependency trees nicely, improve performance, and add search.
    </p>
        <p>
          <i>Edit: Luckily, as suggested by a reader, a more mature version of this concept with better UI exists, <a href="https://anvaka.github.io/pm/#/galaxy/python?cx=-2700&amp;cy=377&amp;cz=5622&amp;lx=-0.0869&amp;ly=-0.2315&amp;lz=-0.0338&amp;lw=0.9684&amp;ml=150&amp;s=1.75&amp;l=1&amp;v=2015-09-27T13-00-00Z">available here</a>.</i>
          
        </p>
    <p>
      For replicating this, see the accompanying <a href="https://github.com/lennart-finke/pypi-map">repository</a>.
    </p>

  <!-- Footer -->
  

  <!-- Script to handle the load/close chart toggles,
       lazy-load D3, and build the graph once user clicks. -->
  

    </div></div>
  </body>
</html>
