<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://systemf.epfl.ch/blog/rust-regex-lookbehinds/">Original</a>
    <h1>Adding lookbehinds to rust-lang/regex</h1>
    
    <div id="readability-page-1" class="page"><div id="blog-rust_regex_lookbehinds-index">
<header>
  
</header>
<section>
  <p>An annotated guide to adding captureless lookbehinds to the Rust linear-time regex engine.</p>

</section>
  <p>In a <a href="https://systemf.epfl.ch/blog/re2-lookbehinds/">previous blogpost</a>, Erik wrote about how he implemented
the linear time matching algorithm from <a href="#regelk-pldi24" id="citation-reference-1" role="doc-biblioref">[RegElk+PLDI24]</a> in the popular regex engine RE2.
In this one, we&#39;re looking at how to do the same thing for the official regex engine from
the Rust language. Namely, we add support for unbounded captureless lookbehinds.</p>

<p>First, let&#39;s discover the newly supported feature and its limitations.
Lookbehinds allow regexes to make assertions about things preceding some part of the
regex pattern without considering it as part of the match. Similarly, negative lookbehinds,
which we also support, assert that something is not preceding. Consider the regex</p>
<p><span><span>(?&lt;=Title:\s+)\w+</span></span></p>
<p>which would match the following strings (matches underlined with <code>~</code>):</p>
<pre><code>Title: HelloWorld
       ~~~~~~~~~~

Title: Title: foo
       ~~~~~
              ~~~</code></pre>
<p>But does not match:</p>
<blockquote>
<ul>
<li><p><span>No heading</span></p></li>
<li><p><span>title: bad case</span></p></li>
<li><p><span>Title:nospace</span></p></li>
</ul>
</blockquote>
<p>As seen in the example, lookbehind expression can be unbounded. This means we do not know ahead
of time how many characters a lookbehind will match. This is an improvement over many existing
regex engines which support lookbehinds but only if they are of a bounded
(like the ubiquitous <a href="https://www.pcre.org/current/doc/html/pcre2syntax.html#SEC23">PCRE</a>)
or sometimes even fixed (like Python&#39;s <a href="https://docs.python.org/3/library/re.html">re</a>) length.
However, as a downside our lookbehinds do not support containing capture groups which are a
feature allowing to extract a substring that matched a part of the regex pattern.</p>
<p>The actual implementation can be found in the <a href="https://github.com/rust-lang/regex/pull/1266">PR</a> to the
rust-lang/regex repository.</p>
<section id="architecture-of-the-regex-crate">
<h2>Architecture of the regex crate</h2>
<p>In the Rust ecosystem, libraries that are published are called crates. The language team
maintains a handful of official crates, among which there is one called &#34;regex&#34; that provides
exactly what you would expect: a regex matching engine.</p>
<p>Under the hood, the <a href="https://github.com/rust-lang/regex">regex crate</a> is only a thin wrapper around the much more elaborate
&#34;regex-automata&#34; crate, which provides several different engine implementations to match
regexes. Furthermore, the code for parsing regexes is split into yet another crate called
&#34;regex-syntax&#34;. In the following, we will give an overview of the architecture of
both these crates.</p>
<section id="regex-syntax">
<h3><a href="https://github.com/rust-lang/regex/tree/master/regex-syntax">Regex-Syntax</a></h3>
<p>This crate takes care of processing the raw regex input into a representation that can be
easily used by the regex compiler. The first step is to parse the string representing a
regex into the AST (abstract syntax tree) representation. At this stage all unsupported
regex features are rejected, such as backreferences. Then, the AST is translated into
a more normalized representation called HIR (high-level intermediate representation).
Each node in the HIR stores properties which help the compiler and the engines
to optimize or guarantee correctness of the regex matching process. An example of such a
property is the length of the shortest and longest string that can be matched by
the HIR node.</p>
</section>
<section id="regex-automata">
<h3><a href="https://github.com/rust-lang/regex/tree/master/regex-automata">Regex-Automata</a></h3>
<p>This crate features many different implementations of a regex engine, each with different
capabilities and runtime characteristics. All engines promise to have linear runtime
complexity (in the length of the haystack and size of the regex), but the constant factors
differ. The main engine that we modified for our implementation is the PikeVM which performs
extended NFA simulation.</p>
<p>However, there is one other engine in this crate that is of great importance: the meta-regex.
This engine is what is used by the wrapping top-level &#34;regex&#34; crate and its job is to select
the &#34;best&#34; of the other engines for performing a search. This decision procedure is based on
some heuristics that don&#39;t matter much for understanding our work, but one important detail
is that the engine first tries to find a match without using any regex engine if possible.
This is the case when the regex consists of only a literal character sequence or a disjunction
of multiple such sequences or if it can be transformed into such a disjunction.
A match can then be searched by a &#34;simple&#34; substring search.</p>
</section>
</section>
<section id="implementation-work">
<h2>Implementation work</h2>
<p>Most of the initial work to get lookbehinds up and running consisted of implementing the two
new NFA state types &#34;WriteLookAround&#34; and &#34;CheckLookAround&#34; (<a href="https://github.com/epfl-systemf/rust-regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/nfa/thompson/nfa.rs#L1587-L1606">code</a>).
The first is essentially the equivalent of a &#34;match&#34; state but for a lookbehind, while the
second instructs the regex engine to check whether or not a certain lookbehind matches at
the current string position. We named them &#34;*LookAround&#34; instead of &#34;*LookBehind&#34; because,
in principle, they are enough to implement lookaheads as well. In this section and the
following sub-sections, we will dive deeper into the used lookbehind algorithm and the issues
that arise from it.</p>
<p>Once these states were properly produced by the <a href="https://github.com/rust-lang/regex/pull/1266/files#diff-6086793734c2733d432458201553a2e9dc898f7d0b63d03c754ccc5f9e2145ca">regex-parser</a>
and <a href="https://github.com/epfl-systemf/rust-regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/nfa/thompson/compiler.rs#L1024-L1048">compiler pipeline</a>,
and once we told the <a href="https://github.com/rust-lang/regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/nfa/thompson/pikevm.rs#L1914">PikeVM</a>
how to interpret these instructions, we had an implementation that was basically working.
The kind of changes to the code base were very similar in spirit to the changes done to RE2,
albeit a bit more verbose, mainly due to Rust&#39;s strict type system and the way the crate is structured.</p>
<p>However, there were certain challenges worth looking at in detail. Some of them showed up
during the initial implementation phase while others surfaced only once we started benchmarking
the resulting engine.</p>
<section id="frontend">
<h3>Frontend</h3>
<figure>
<img alt="Graph illustrating the frontend pipeline of the regex crate." src="https://systemf.epfl.ch/blog/rust-regex-lookbehinds/frontend.svg"/>
<figcaption>
<p>Updated frontend pipeline: from raw input to an HIR.</p>
</figcaption>
</figure>
<p>To support lookbehinds, the parser had to accept them while still rejecting lookaheads.
Additionally, if a lookbehind contained a capture group, the parser would also need to
reject it, due to it being unsupported currently by our implementation. The error messages
indicate to the user that the syntax is recognized but not supported.</p>
<p>During the AST to HIR translation, the stored properties are updated to account for the
different semantics of lookbehinds. For example, a lookbehind does not contribute to the
length of the match, so the length properties of the HIR node are set to zero. A new property
is added to the HIR node that indicates whether or not the node contains a lookbehind. This is
used in places where one has to behave differently depending on whether or not the regex contains
a lookbehind.</p>
</section>
<section id="the-meta-engine">
<h3>The Meta-Engine</h3>
<p>As explained above, the meta-engine (or meta-regex) bundles all other engines into one and
chooses the &#34;most efficient&#34; of them for any search executed. Since we only implemented
lookbehind support for the PikeVM, we had to make sure the meta-engine only considers the
PikeVM as soon as there are any lookbehind expressions in the regex. This includes forbidding
of skipping all engines and using a substring search. This was <a href="https://github.com/epfl-systemf/rust-regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/meta/strategy.rs#L261-L265">explicitly disabled</a>,
since lookbehinds are not part of the match, yet contribute to what is considered a match.</p>
<p>This turned out to be easier than anticipated. The selection strategy essentially boils down
to trying to build each of the engines in order of efficiency and using the first one that
succeeds. Therefore, we simply had to make sure the build process of all engines other than
the PikeVM fails with a proper error, whenever there is a lookbehind in the regex.</p>
<p>There was one caveat though: the meta-regex expected the build process of the bounded
backtracker to always succeed, because a backtracking engine supports all regex features.
The only reason the backtracking engine would not be used is if the configured max memory
usage is not sufficient to guarantee linear runtime. Therefore, we added a manual condition
that checks for lookbehinds explicitly and skips the backtracker in that case
(<a href="https://github.com/epfl-systemf/rust-regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/meta/wrappers.rs#L213-L214">code</a>).</p>
</section>
<section id="lookbehind-threads">
<h3>Lookbehind Threads</h3>
<p>When we started benchmarking, it became evident that something caused matching with lookbehinds
to run longer than needed. Once we figured out the cause, it wasn&#39;t too hard to fix, but let&#39;s
first take a look at how we implemented the problematic part initially.</p>
<p>The concept of the algorithm is to run multiple NFA simulations in lockstep, one automaton
for each lookbehind and one for the main regex. However, in practice it would have taken quite
a bit of refactoring to account for the possibility of actually running multiple simulations in
lockstep. So how did we do it instead? Well, in the case of the PikeVM, running multiple NFAs
is equivalent to running the automaton that consists of a union of all individual sub-automata,
since the PikeVM does not perform a depth first search like the backtracking engine. Therefore,
that is exactly what we did: compile the automaton for each lookbehind and for the main regex
and then patch them together in one big union state from which the simulation is then started.</p>
<p>Now for the algorithm to work correctly, it is essential that the NFAs corresponding to
lookbehinds that are more deeply nested are executed first. This is because we need the results
of inner lookbehinds in order to correctly determine the results of outer ones. To make sure
this is the case, the live threads of the inner lookbehinds must have higher priority than the
ones of the outer lookbehinds. For the particular implementation of the PikeVM we were dealing
with, this means that the threads of the inner lookbehinds must be added to the ordered set of
live threads first, which is easy to guarantee by ordering the corresponding sub-automaton
earlier in the top-level union state.</p>
<p>So far so good, but now comes the problematic part: priority not only determines which
threads are processed first, it also determines what match is returned when multiple are found.
This is important to uphold the same match semantics as a backtracking engine. Consider,
for example, the regex &#34;a*b|a&#34; on the haystack &#34;aaab&#34;. At the beginning of the search, the
PikeVM registers a match immediately after consuming the first character. However, because
the first alternative in a regex takes priority over the second, the PikeVM cannot return
that match yet. It must continue scanning the haystack until it reaches the end, at which
point it registers that the first alternative actually matches as well and this is the match
that is finally returned. Importantly, even on the haystack &#34;aaaa&#34;, where the first alternative
does not match, the PikeVM must still scan to the end of the string to realize that the first
alternative does not match and it is ok to return the match of the second alternative; there
is simply no way to know beforehand.</p>
<p>What does this have to do with lookbehinds? Remember we compile the NFA in a way where all
sub-automata have higher priority than the main regex. What&#39;s more, every lookbehind
sub-automaton has a &#34;.*?&#34; prefix, in order to make sure we capture all lookbehind matches
during our search and not only one at the beginning of the haystack. This in combination
means that there are always live threads that have higher priority than any thread that
could produce a match from the main regex, which in turn means that the PikeVM will scan
to the end of the haystack regardless of found matches. Because this behavior arises as
soon as any lookbehind is present, no matter the complexity of the lookbehind or the main
regex, this was quite problematic performance wise.</p>
<p>As already stated, the solution to this problem was more or less straight forward: we needed
to keep the live threads of the lookbehinds in a place separate from the threads that belong
to the main regex. That way, as soon as the ordered set of live threads of the main regex
runs empty, we can be sure there won&#39;t be any more matches and similarly, if there is a match
of the highest priority main regex thread, this will actually be registered as such and the
search can be concluded immediately.</p>
<p>To make this separation work required to refactor the NFA compilation a bit. We still compile
all sub-automata into a single NFA struct, albeit without patching them together with a
union anymore. Additionally, the NFA struct now has a field that contains the index of all
the sub-automata starting states. This is necessary because we now need to explicitly
initialize the starting thread for each sub-automaton.</p>
<figure>
<img alt="Two NFAs, one with a union of lookbehinds and the main regex, the other with separate lookbehinds and the main regex." src="https://systemf.epfl.ch/blog/rust-regex-lookbehinds/union_to_separate.svg"/>
<figcaption>
<p>Resulting NFA structure after separating the lookbehinds and removing the union.</p>
</figcaption>
</figure>
<p>It should be noted that we also considered the idea of tagging the live threads with the
information of whether or not they belong to a lookbehind (either by storing this information
in the thread itself or in the state of the NFA that is referenced by the thread). While this
would most likely have worked too, the code for detecting whether there are still live threads
from the main regex would, in comparison, be much more complicated and most likely less performant.</p>
</section>
<section id="match-all">
<h3>Match-All</h3>
<p>The reason the problem described above with scanning to the end unnecessarily actually became
apparent during benchmarking match-all searches, in which the regex engine returns all
non-overlapping matches found in the string. The reason is that scanning to the end of the
string regardless of found matches causes the overall search to have quadratic runtime
complexity in the length of the haystack instead of linear. The quadratic behavior of a
match-all is a known existing issue, even without any lookbehinds present.
However, for most regexes, this is not the case and certainly it was not the case for the
simple examples we used in our benchmarks.</p>
<p>Once the lookbehind thread separation was implemented, we were shocked to find that the
search, although faster, still had quadratic complexity. After some debugging, we noticed
the problem now was that the lookbehind threads were not kept alive between the different
search iterations to find all matches. Essentially, the way match-all was implemented is as
follows: find a match and return it, then start a completely fresh search at the position
where the previous match ended. Before starting this successive search, all state accumulated
during the previous search is discarded, including the lookbehind threads.</p>
<p>This is of course detrimental to performance because it means that now, instead of scanning
until the end for every match, we have to start searching from the beginning of the haystack
after each match to make sure we have up to date lookbehind threads when we reach the actual
starting position of the search. This &#34;catching up&#34; is essential for correctness as we need to
know whether a lookbehind holds or not even for the first position in the haystack that is searched.</p>
<p>The work done in this case is, however, wasted effort because the information was available
during the search of the previous match. Hence, the solution was to implement a <a href="https://github.com/rust-lang/regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/nfa/thompson/pikevm.rs#L2206-L2221">configuration</a>
that was activated only for match-all searches,
which would keep the live threads of the lookbehinds whenever a match is found. These threads
are then <a href="https://github.com/rust-lang/regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/nfa/thompson/pikevm.rs#L1274-L1275">restored</a>
at the beginning of the next search, thereby making the &#34;catching up&#34; unnecessary.</p>
</section>
</section>
<section id="evaluation">
<h2>Evaluation</h2>
<p>Firstly, in each modified module, unit tests have been added to give us assurance that the
implementation is correct. Integration tests have also been added to test the entire regex
pipeline
(<a href="https://github.com/epfl-systemf/rust-regex/blob/captureless-lookbehinds/testdata/lookaround.toml">code</a>).</p>
<p>The author of the regex crate has also created a benchmarking tool to compare various regex
search engines called <a href="https://github.com/burntsushi/rebar">rebar</a>. Using this code, it was rather straightforward to add our
modified version of the engine to the tool and then comparing the performance both to the
original regex crate as well as to other engines. We benchmarked our modifications for
three reasons: First, we wanted to make sure that our changes did not cause a significant
slowdown for any searches that do not include lookbehinds. Second, we wanted to check whether
the performance for searches that do include lookbehinds is reasonable. To that end, we
compared the performance to the python library &#34;re&#34;. We chose this engine as a comparison
due to ease of use, which made the benchmark procedure more straightforward, as well as due
to it being used ubiquitously in python programs. Importantly however, the &#34;re&#34; library uses
a different algorithm, a backtracker. Finally, we wanted to make sure that the search
implementation with lookbehinds respects the linear time complexity constraint.
(<a href="https://github.com/epfl-systemf/rebar/blob/909deb6d9a03849c889e3b9a76cb89454702d351/benchmarks/definitions/lookbehind/snort.toml">benchmark definition</a>).</p>
<p>The comparison between our modified version and the original crate showed no significant
slowdowns, which leads us to believe that we were successful in implementing lookbehinds
in a way that does not cause a downside to regexes that don&#39;t need the feature.</p>
<p>After having fixed the performance issues mentioned earlier, we were also successful in
demonstrating linearity using the benchmarking results on searches of increasing size.</p>
<p>The comparison of the overall performance to python-re was a bit more challenging.
Since the existing benchmarking suite does not contain regexes with features unsupported
by the regex crate, there are no benchmarks included, which contain regexes with lookbehinds.
Coming up with meaningful and representative benchmarks is challenging on its own. What&#39;s
more is that many regexes one can find in real software either don&#39;t use any of the extended
regex features at all, because they use an engine that does not support them, or they use
not only lookbehinds but also lookaheads and backreferences, which we did not implement
support for (where backreference matching is known to be NP-hard).</p>
<p>In the end, we decided to adopt the benchmarking strategy described in <a href="#regexmatching-popl24" id="citation-reference-2" role="doc-biblioref">[RegexMatching+POPL24]</a>.
They used the ruleset of the network monitoring tool Snort, which contains some rules that
use regexes. Out of all these regexes, there were only 5 which fulfilled the criteria of
containing lookbehinds but no other unsupported regex features. We also used the network
capture logs from the wrccdc archive as a haystack as did the authors of the paper.</p>
<p>The results showed that we were around 2-5x slower than python-re on most benchmarks.
This is certainly acceptable, given that the regexes are most likely written in a way
that optimizes them for a backtracking engine, which is what python-re provides.</p>
<p>There were, however, two benchmarks on which our implementation performed around 60x slower.
The suspicion was on python-re optimizing bounded lookbehinds leading to huge speedups.
We were happy to be affirmed in this hypothesis later on, when we implemented optimizations
for bounded lookbehinds, which caused the performance to improve into the same ballpark
as the other benchmarks.</p>

</section>
<section id="extensions">
<h2>Extensions</h2>
<p>We spent most time polishing the basic implementation described above. The goal was to get
a working implementation of unbounded lookbehind expressions in the regex crate, and we
opened a PR to get our changes merged upstream. There is, however, quite a bit more that
is possible and we decided to spend some time on the following two topics. Given the clean
implementation in the PikeVM and all required changes in the parser, compiler, etc. it was
also easier to split the work among the two of us to go in different directions.</p>
<section id="bounded-lookbehinds-optimization-marcin">
<h3>Bounded lookbehinds optimization - Marcin</h3>
<p>To understand the optimization, we must first understand the problem of playing catch-up by
the lookbehind automatons. A search is performed on a haystack, but more specifically on its
subset; the search range. For instance, as mentioned, match-all works by starting brand new
searches on the same haystack, however, the beginning of the new search range is set to be
the end of the previous match. The issue is that lookbehinds must disregard the search range
and always start their execution from the very beginning of the haystack. This is due to the
lookbehind&#39;s expression potentially staring its match before the start of the search range.
But if we know that a lookbehind needs to start only <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> characters before the search
range instead of the very beginning of the haystack, we can avoid doing a lot of useless work.
This is exactly what this optimization does. In practice, in our benchmarks this optimization
yielded speedups of up to 150x. The implementation can be found
<a href="https://github.com/epfl-systemf/rust-regex/pull/11">here</a>.</p>
<section id="computing-the-k">
<h4>Computing the <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math></h4>
<p>To guarantee correctness of matching, the chosen <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> can be overestimated but not
underestimated. Hence why starting at the very beginning of the haystack is always a correct
approach. In that case, <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
  <mo>=</mo>
  <mo>∞</mo>
</math>.</p>
<p>To compute <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> for each lookbehind, two components are needed: the longest length of a
string that can be matched by that lookbehind (called <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math>), and the shortest length of a
string that can be matched by the regex that precedes the lookbehind (called <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>).</p>
<p>Let&#39;s look at an example:</p>
<figure>
<img alt="A regex with lookbehinds and their respective n and m values." src="https://systemf.epfl.ch/blog/rust-regex-lookbehinds/example_computing_k.svg"/>
<figcaption>
<p>An example colorcoded regex with lookbehinds and their respective <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math>, <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math> values.</p>
</figcaption>
</figure>
<ol>
<li><p>The red lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
  <mo>=</mo>
  <mo>∞</mo>
</math> since <span>a+</span> can match any amount of characters. <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
  <mo>=</mo>
  <mn>0</mn>
</math>
since there is nothing preceding that lookbehind.</p></li>
<li><p>The yellow lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
  <mo>=</mo>
  <mn>4</mn>
</math> since it always matches exactly 4 characters. <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
  <mo>=</mo>
  <mn>0</mn>
</math>
since there is nothing preceding that lookbehind. Note that the <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math> value is relative to the
surrounding lookbehind.</p></li>
<li><p>The brown lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
  <mo>=</mo>
  <mn>1</mn>
</math> since it always matches exactly 1 character. <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
  <mo>=</mo>
  <mn>2</mn>
</math>
because that is the shortest matching length of <span>aa</span>.</p></li>
<li><p>The blue lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
  <mo>=</mo>
  <mn>2</mn>
</math> since it always matches exactly 2 characters. The surrounding
lookbehinds do not contribute to the match length. <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
  <mo>=</mo>
  <mn>1</mn>
</math> because that is the shortest matching
length of <span>a*a</span> (zero of &#34;a&#34; followed by one &#34;a&#34;).</p></li>
</ol>
<p>Then, <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> is equal to the sum of all surrounding lookbehind <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> values plus <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> minus <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>.</p>
<ol>
<li><p>The red lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>d</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <mo>∞</mo>
  <mo>−</mo>
  <mn>0</mn>
  <mo>=</mo>
  <mo>∞</mo>
</math></p></li>
<li><p>The blue lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>b</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <mn>2</mn>
  <mo>−</mo>
  <mn>1</mn>
  <mo>=</mo>
  <mn>1</mn>
</math></p></li>
<li><p>The yellow lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>y</mi>
      <mi>e</mi>
      <mi>l</mi>
      <mi>l</mi>
      <mi>o</mi>
      <mi>w</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>b</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
    </mrow>
  </msub>
  <mo>+</mo>
  <mn>4</mn>
  <mo>−</mo>
  <mn>0</mn>
  <mo>=</mo>
  <mn>5</mn>
</math></p></li>
<li><p>The brown lookbehind has <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>b</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>w</mi>
      <mi>n</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>b</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
    </mrow>
  </msub>
  <mo>+</mo>
  <mn>1</mn>
  <mo>−</mo>
  <mn>2</mn>
  <mo>=</mo>
  <mn>0</mn>
</math></p></li>
</ol>
<p>Notice that it is possible for <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> to be negative, such as with <span><span>aaa(?&lt;=a)</span></span>. That simply means that
the lookbehind automaton can start after the main automaton.</p>
<p>The <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> values are computed during the NFA compilation phase, which allows all engines to utilize them
for their own optimizations. In the scope of our work, we take advantage of these <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> values only in
the PikeVM, and <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math> is not computed and always set to zero.</p>
</section>
<section id="new-game-of-catch-up">
<h4>New game of catch-up</h4>
<p>Now that we know the <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> value for each lookbehind, we can start each lookbehind automaton at
a different position of the haystack, <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> away from the start of the search range. Of course, this
optimization works only for bounded lookbehinds, since any unbounded lookbehind would have a value of
<math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
  <mo>=</mo>
  <mo>∞</mo>
</math> and would therefore always start at the beginning of the haystack.</p>
<p>There is however one more aspect that has to be considered for the correctness of this optimization when
used by the PikeVM. As mentioned before it is crucial that the inner lookbehinds are executed before the outer
ones to make the side effect results of <span>WriteLookAround</span> visible by <span>CheckLookAround</span>. Since the haystack
is traversed from left to right, lookbehinds with a larger <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> value will start their execution before those
with a smaller <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> value. Thus to maintain correctness, we cannot allow inner lookbehinds to have values of
<math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> that are smaller than the <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> of the outer ones.</p>
<p>The <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math> values are computed by the NFA compiler. Then the PikeVM conservatively adjusts them to ensure
correctness. The adjustment is done by taking the maximum of the lookbehind&#39;s and the outer lookbehind&#39;s <math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>k</mi>
</math>
values. After this adjustment a lookbehind will never start before its outer lookbehinds. Thus,
<math mathvariant="normal" xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>b</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>w</mi>
      <mi>n</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <mo>max</mo>
  <mo stretchy="false">(</mo>
  <msub>
    <mi>k</mi>
    <mrow>
      <mi>b</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
    </mrow>
  </msub>
  <mo>,</mo>
  <mn>0</mn>
  <mo stretchy="false">)</mo>
  <mo>=</mo>
  <mo>max</mo>
  <mo stretchy="false">(</mo>
  <mn>1</mn>
  <mo>,</mo>
  <mn>0</mn>
  <mo stretchy="false">)</mo>
  <mo>=</mo>
  <mn>1</mn>
</math>.</p>
</section>
</section>
<section id="bounded-backtracker-robin">
<h3>Bounded Backtracker - Robin</h3>
<p>Among the NFA simulating PikeVM and a couple of DFA simulation strategies, the regex crate
also features a backtracking engine. Now, hold on, you might say, doesn&#39;t a backtracking
engine have exponential time complexity? You would be right for a standard backtracking
engine, but this one is implemented with memoization; also called bitstate backtracker sometimes.</p>
<p>Since backtracking is generally faster than NFA simulation and most backtracking engines
have lookbehind support built in, I decided to try and implement lookbehind support in
the backtracker of the regex crate. There were two main challenges to be solved: lookbehind
reversal and memoization of lookbehind results.</p>
<section id="lookbehind-reversal">
<h4>Lookbehind reversal</h4>
<p>The way a backtracking engine works can be described as &#34;trial-and-error&#34;. It tries to
match the haystack with the highest priority variant of the given regex, that is, leftmost
alternative in a union, as many repetitions as possible for quantifiers, etc. As soon as
there is a failure, it backtracks to the position in the haystack where it last took a
decision and tries the next possibility in decreasing priority order.</p>
<p>When the backtracker reaches a position at which a lookbehind is to be checked, it has
hence no idea whether the characters preceding that position match the lookbehind or not.
Because we allow unbounded lookbehinds, meaning the maximum possible number of characters
which one needs to inspect for the lookbehind is not known in advance, the only possibility
the backtracker has is to step through the haystack in reverse. To be able to do this,
it needs to know how to match the lookbehind in reverse.</p>
<p>Luckily, the regex crate already had a feature in the compiler that does reversed compilation
of an arbitrary regex. So what I did was simply <a href="https://github.com/epfl-systemf/rust-regex/blob/0bfb995eefad99117e02d4466e9c5d612377e5a3/regex-automata/src/nfa/thompson/compiler.rs#L1045-L1059">compile</a>
each lookbehind subexpression both
in the forward (used by the PikeVM) as well as the reverse (used by the backtracker) direction.
To be able to use the correct NFA states, I had to add another field to the NFA struct with
the starting states of the reverse sub-expressions for the lookbehinds.</p>
<p>One important detail to note is that the reverse sub-automaton for each lookbehind must not
have the &#34;.*?&#34; prefix added, since the backtracker already knows at what position in the
haystack the lookbehind should hold when it comes around to checking one.</p>
</section>
<section id="lookbehind-memoization">
<h4>Lookbehind memoization</h4>
<p>The way memoization is implemented for the main regex is roughly as follows: whenever the
backtracker reaches a (NFA state, haystack position)-pair for the second time, it
<a href="https://github.com/epfl-systemf/rust-regex/blob/cb8d7eaa9d582765989c6f0d9f25e9dc8dbe64ab/regex-automata/src/nfa/thompson/backtrack.rs#L1473-L1475">immediately cancels</a>
the current search thread and backtracks to the last decision point. Why is that?
Because the backtracker has the great advantage that it is always exploring the highest
priority match, meaning as soon as a match is found, it can return the match instantly.
Therefore, if it reaches such a state-position-pair a second time, this can only mean the
path that follows it will not lead to a match.</p>
<p>We would like to have the same kind of memoization for lookbehind exploration, but there
is a problem. We will illustrate it with the following (nonsensical) example regex:</p>
<p><code>^(a|aa)(?&lt;=aa?)b</code></p>
<p>Suppose we run it on the haystack &#34;aab&#34;. Here is an illustration for the
first execution path the backtracker will try:</p>
<figure>
<img alt="Graph illustrating the path explored by the backtracking engine." src="https://systemf.epfl.ch/blog/rust-regex-lookbehinds/bt_path1.svg"/>
<figcaption>
<p>First explored path.</p>
</figcaption>
</figure>
<p>The left automaton is the main regex and the right one is the lookbehind. The green arrows
indicate the path explored by the backtracker and the red arrows indicate a failed transition.
Note that the transition from state 3 to 4 is attempted only after the entire lookbehind
automaton has been explored and thereby a match for the lookbehind has been found at position
1 in the haystack. The sequence lists the state-position-pair visited in order of execution.
Once the backtracker fails in the transition from 3 to 4, it will backtrack to state 0 and
explore the missing path in the main regex. Here is an illustration for the second execution path:</p>
<figure>
<img alt="Graph illustrating the path explored by the backtracking engine." src="https://systemf.epfl.ch/blog/rust-regex-lookbehinds/bt_path2.svg"/>
<figcaption>
<p>Second explored path.</p>
</figcaption>
</figure>
<p>As you can see, the state 7 is reached in position 0 of the haystack as for the previous
execution path. This means that the backtracker will abort and report no match found, even
though clearly a match would be found if the backtracker continued with the execution. The
blue arrow indicates that the backtracker aborted execution during the check of the lookbehind.</p>
<p>The reason for this wrong behaviour is that we might reach lookbehind states again, even
though they actually lead to a successful match of the lookbehind expression. Hence, it is
important to store the information of whether the exploration has led to a match or
not when state-position-pairs of lookbehind automata are concerned. It is sufficient to store
an additional bit in the memoization table that indicates this very <a href="https://github.com/epfl-systemf/rust-regex/blob/0bfb995eefad99117e02d4466e9c5d612377e5a3/regex-automata/src/nfa/thompson/backtrack.rs#L1495-L1499">result</a>.</p>
<p>The table is initialized with false and is only updated when an exploration has led to a
positive result.
This is sound because of the depth first search order inherent to backtracking,
meaning that the earliest time a state-position pair can be revisited is after an exploration
has terminated.</p>
<p>The way we set the bit works as follows: whenever the backtracker transitions
to a new state, it first checks the visited table to see if it has seen the state-position-pair
before. If it has not, and it is currently exploring a transition belonging to a lookbehind,
it pushes a note onto it&#39;s DFS-Stack. The note contains the current state id and haystack position.
Once the result of the lookbehind check is known (by running out of options to explore or by
encountering a WriteLookAround state), the DFS algorithm pops off the notes from the stack.
For each note popped off, it sets the memoization bit for the corresponding state-position-pair
to true, provided that a WriteLookAround state has been encountered.</p>
</section>
<section id="match-all-1">
<h4>Match-All</h4>
<p>Similar to the initial implementation of the algorithm in the PikeVM, the implementation of
the backtracker suffers from quadratic runtime complexity when performing a match-all search.
The reason is, however, a different one. The bitstate vector is cleared whenever a new search
is started (resetting both the memoization of what state-position-pairs it has visited as well
as the memoized lookbehind outcome). It&#39;s not so much the information that is lost in doing so
that causes the quadratic runtime, but rather the fact that this <a href="https://github.com/epfl-systemf/rust-regex/blob/0bfb995eefad99117e02d4466e9c5d612377e5a3/regex-automata/src/nfa/thompson/backtrack.rs#L1989-L1995">clearing operation</a>
itself takes
time linear in the size of the haystack and the size of the regex. Therefore, this is actually
a problem that affects the backtracker for all regexes.</p>
<p>My guess for why this isn&#39;t a problem per se is that it only materializes when the amount of
matches is very close to the size of the haystack and in that case, usually the regex is so
simple that it can easily be handled by the other engines and there&#39;s no need to fall back to
the backtracker or even PikeVM.</p>
<p>I tried to fix the problem in the same spirit as for the PikeVM: simply don&#39;t reset the visited
cache during a match-all search. This, unfortunately does not work though. The reason is subtle
but I couldn&#39;t find a way around it: matches are delayed one character in the engine, for the
reason of being able to check simple lookahead assertions (e.g. end-of-string). This causes
states to be visited at the end position of the match, inserting (state, position)-pairs into
the visited set. Now, when the next search is started, we&#39;re in trouble because the starting
position is equal to the end position of the preceding match. This means there are certain
states that were visited in the preceding search, that should now be re-explored but will
simply cause a failed match due to already being present in the memoization table.</p>
<p>One way to potentially solve this problem would be to clear only the bits associated with
the end position of the last match instead of the entire memoization table. However, this
would still cause quadratic complexity in the size of the regex. This is arguably much better
than in both the size of the regex and the size of the haystack, but still, it&#39;s not a
satisfying solution, so I didn&#39;t bother implementing it, as it would have been quite a bit
of work and I&#39;m not even sure it would correct the search semantics.</p>
</section>
</section>
</section>
<section id="conclusion">
<h2>Conclusion</h2>
<p>The feature of lookbehinds is very often absent in linear regex engines. In this effort, we have
laid the work to bring them into the Rust ecosystem by implementing lookbehinds in the regex crate.
The implementation has been polished by implementing practical optimizations such as those for
bounded lookbehinds, the prevention of quadratic runtime complexity in match-all searches, or
prevention of unnecessary lookbehind scanning till the end of the haystack. The benchmarks show
a reasonable and usable performance making it ready for real-world applications. Finally, solid
foundations have been established in the backtracking engine for further extensions, namely for
lookaheads. We hope that this work will benefit the Rust community and encourage other linear
regex engines to implement lookbehinds as well!</p>
</section>
<section id="appendix">
<h2>Appendix</h2>
<section id="benchmarks">
<h3>benchmarks</h3>
<pre><code>benchmark                                     python/re            rust/regex-lookbehind  rust/regex-lookbehind-new
---------                                     ---------            ---------------------  -------------------------
lookbehind/snort/snort-0                      2.2 GB/s (1.00x)     45.0 MB/s (50.40x)     1034.7 MB/s (2.19x)
lookbehind/snort/snort-1                      204.0 MB/s (1.00x)   34.3 MB/s (5.94x)      34.1 MB/s (5.99x)
lookbehind/snort/snort-2                      107.1 MB/s (71.24x)  53.0 MB/s (143.94x)    7.5 GB/s (1.00x)
lookbehind/snort/snort-3                      100.7 MB/s (80.25x)  102.2 MB/s (79.08x)    7.9 GB/s (1.00x)
lookbehind/snort/snort-4                      2041.9 MB/s (1.00x)  45.9 MB/s (44.52x)     967.3 MB/s (2.11x)
lookbehind/snort/linear-haystack-1000         119.4 MB/s (1.00x)   27.2 MB/s (4.39x)      26.3 MB/s (4.54x)
lookbehind/snort/linear-haystack-10000        136.3 MB/s (1.00x)   27.3 MB/s (4.98x)      25.8 MB/s (5.28x)
lookbehind/snort/linear-haystack-100000       136.8 MB/s (1.00x)   27.3 MB/s (5.01x)      25.8 MB/s (5.29x)
lookbehind/snort/linear-haystack-many-1000    17.0 MB/s (1.00x)    7.8 MB/s (2.19x)       7.8 MB/s (2.18x)
lookbehind/snort/linear-haystack-many-10000   17.0 MB/s (1.00x)    7.8 MB/s (2.19x)       7.8 MB/s (2.18x)
lookbehind/snort/linear-haystack-many-100000  18.0 MB/s (1.00x)    7.8 MB/s (2.31x)       7.8 MB/s (2.31x)</code></pre>
</section>
</section>

    </div></div>
  </body>
</html>
