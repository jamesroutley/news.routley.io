<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yiming.dev/blog/2022/07/10/how-let-it-fail-leads-to-simpler-code/">Original</a>
    <h1>How “let it fail” leads to simpler code</h1>
    
    <div id="readability-page-1" class="page"><section id="content" role="main">
    <div id="post-container">
        
        <p>
The BEAM virtual machine (The VM that runs our Elixir and Erlang code) is famous for being fault-tolerant.</p>

<div id="outline-container-Distinguish%20expected%20and%20unexpected%20errors">
<h2 id="Distinguish%20expected%20and%20unexpected%20errors">Distinguish expected and unexpected errors</h2>
<div id="text-Distinguish%20expected%20and%20unexpected%20errors">
<p>
The biggest lesson here, is not to use Supervisors in every way possible and sweep error-handling code under the rug.</p>

<p>
In short, I would put &#34;errors&#34; into 2 categories:<br/>
</p>
<dl>
<dt>Expected errors</dt><dd>Expected errors are predictable situations that are slightly off from the happy-path.</dd>

<dt>Unexpected errors</dt><dd>Unexpected errors are unpredictable situations that are not fixable by the user.</dd>
</dl>

<p>
Error is a simple word but has too many meanings.</p>

<p>
The Erlang paper (<a href="http://erlang.org/download/armstrong_thesis_2003.pdf">Making reliable distributed system in the presence of software errors</a>) gives a great answer to the question of &#34;what is an error?&#34;<br/>
</p>
<blockquote>
<p>
It is the programmer who decides if an exception corresponds to an error...<br/>
</p>

<p>
Schneider gives a number of definitions of fault-tolerance in his 1990 ACM tutorial paper.</p>
</blockquote>
<p>
In the end it all comes down to the specifications (i.e. expected or unexpected).</p>

<p>
Here are some examples to help you distinguish expected and unexpected when you think about errors:<br/>
</p>
<ol>
<li>Divide by zero error</li>

<li>File does not exist error</li>
</ol>
</div>
</div>

<div id="outline-container-Write%20less%20code%20by%20%22ignoring%22%20unexpected%20errors">
<h2 id="Write%20less%20code%20by%20%22ignoring%22%20unexpected%20errors">Write less code by &#34;ignoring&#34; unexpected errors</h2>
<div id="text-Write%20less%20code%20by%20%22ignoring%22%20unexpected%20errors">
<p>
Now that we&#39;ve distinguished expected and unexpected errors,</p>

<p>
The trick is that we can now &#34;ignore&#34; unexpected errors once and for all.</p>

<p>
First, let&#39;s admit it, we cannot predict or handle all the unexpected errors.</p>

<p>
The same logic applies to all the unexpected errors.</p>

<p>
The easier task might be:<br/>
</p>
<ul>
<li>log the unexpected error<br/></li>
<li>retry from scratch (i.e. restart the process in BEAM)<br/></li>
<li>stop the application<br/></li>
</ul>
</div>
</div>

<div id="outline-container-Write%20more%20confident%20code%20by%20asserting%20our%20assumptions">
<h2 id="Write%20more%20confident%20code%20by%20asserting%20our%20assumptions">Write more confident code by asserting our assumptions</h2>
<div id="text-Write%20more%20confident%20code%20by%20asserting%20our%20assumptions">
<p>
With the privilege of &#34;ignoring&#34; unexpected errors, we can write less, but more confident code.</p>
<ul>
<li><p>
If a function only accepts an non-empty list, pattern match that in the function header:<br/>
</p>
<div>
<pre>def average([_ | _] = list) do
  ...
end
</pre>
</div></li>
<li><p>
If a result is always expected from a list, pattern match that and ensure it&#39;s not <code>nil</code>:<br/>
</p>
<div>
<pre>%SomeStruct{} = result = Enum.find(list, ...)
</pre>
</div></li>
<li><p>
If a <code>case</code> statement only expect some possible inputs, there is no need to add an always match clause in the end:<br/>
</p>
<div>
<pre>case File.read(path) do
  {:ok, binary} -&gt;
    ...

  {:error, :enoent} -&gt;
    {:error, :file_does_not_exist}

  # the other errors are unexpected and we should abort when they appear
end
</pre>
</div></li>
</ul>

<p>
By writing code in this style, we are basically distilling the input of our functions<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>, making it purer and purer as they travel deeper into our core logic.</p>

<p>
And this coding style is also very MVP-ish and extensible.</p>
</div>
</div>

<div id="outline-container-BEAM%20VM%20makes%20%22let%20it%20fail%22%20production-ready">
<h2 id="BEAM%20VM%20makes%20%22let%20it%20fail%22%20production-ready">BEAM VM makes &#34;let it fail&#34; production-ready</h2>
<div id="text-BEAM%20VM%20makes%20%22let%20it%20fail%22%20production-ready">
<p>
We can apply this coding style in any programming language.</p>

<p>
Every process is isolated from each other in the BEAM VM.</p>

<p>
In other languages like Ruby, I&#39;m not so confident to raise an exception in a random function.</p>

<p>
I guess this is why this coding style is not so popular after all.</p>
</div>
</div>
<div id="outline-container-Summary">
<h2 id="Summary">Summary</h2>
<div id="text-Summary">
<p>
&#34;Let it fail&#34; and fault-tolerant is a cliche topic in the BEAM community.</p>

<p>
I&#39;m glad with the final piece though,</p>
</div>
</div>

    </div>
</section></div>
  </body>
</html>
