<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2024/03/8088-prefetch-circuitry.html">Original</a>
    <h1>The Intel 8088 processor&#39;s instruction prefetch circuitry: a look inside</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6945380884103902536" itemprop="description articleBody">
<p>In 1979, Intel introduced the 8088 microprocessor, a variant of the 16-bit 8086 processor.
IBM&#39;s decision to use the 8088 processor in the IBM PC (1981) was a critical point in computer history,
leading to the dominance of the x86 architecture that continues to the present.
One way that the 8086 and 8088 increased performance was by prefetching:
the processor fetches instructions from memory before they are needed,
so the processor can execute them without waiting on the relatively slow memory.
I&#39;ve been reverse-engineering the 8088 from die photos and this blog post discusses what I&#39;ve uncovered
about the prefetch circuitry.</p>
<p>The die photo below shows the 8088 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath. Around the edges of the die, bond wires connect pads to
the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; 
this article focuses on the prefetch queue components highlighted in red.
The components in purple also play a role, and will be discussed below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top
and an Execution Unit (EU) below.
The BIU handles memory accesses, while the Execution Unit (EU) executes instructions.
In particular, the BIU fetches instructions, which are transferred from the prefetch queue to the Execution Unit via the
queue bus.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/die-labeled.jpg"><img alt="The 8088 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." height="632" src="https://static.righto.com/images/8086-prefetch8088/die-labeled-w600.jpg" title="The 8088 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8088 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.</p>
<p>The 8086 and 8088 processors present the same 16-bit architecture to the programmer.
The key difference is that
the 8088 has an 8-bit data bus for communication with memory and I/O, rather than the 16-bit bus of the 8086.
The 8088&#39;s narrower bus reduced performance, since the processor only transfers one byte at a time rather than two.
However, the 8-bit bus enabled cheaper computer hardware.
The 8-bit bus was also a better match for hardware based on the older but popular 8-bit
Intel 8080 and 8085 processors, allowing the reuse of 8-bit I/O circuitry for instance.
Much of the IBM PC was based on the little-known IBM <a href="https://www.ardent-tool.com/5150/PC_origins.html">DataMaster</a>, a computer built around the Intel 8085.
Thus, selecting the 8088 processor was a natural choice for the IBM PC.</p>
<p>For the most part, the 8086 and 8088 are very similar internally, apart from trivial but numerous layout changes on the die.
The biggest differences are in the Bus Interface Unit, the circuitry that communicates with memory and I/O devices, since
this circuitry handles 16 bits in the 8086 versus 8 bits in the 8088.
There are a few microcode differences between the two chips.
One interesting change is that for performance reasons the 8088 has a smaller prefetch queue
than the 8086 (four bytes instead of six).
(I wrote about the <a href="https://www.righto.com/2023/01/inside-8086-processors-instruction.html">8086&#39;s prefetch circuity</a> earlier.)</p>
<h2>Prefetching and the architecture of the 8086 and 8088</h2>
<p>The 8086 and 8088 were introduced at an interesting point in microprocessor history, when memory was becoming slower than the CPU.
For the first microprocessors, the speed of the CPU and the speed of memory were comparable.<span id="fnref:memory-speed"><a href="#fn:memory-speed">2</a></span>
However, as processors became faster, the speed of memory failed to keep up.
The 8086 was probably the first microprocessor to prefetch instructions to improve performance.
While modern microprocessors have megabytes of fast cache<span id="fnref:cache"><a href="#fn:cache">3</a></span> to act as a buffer between the CPU and much slower main memory,
the 8088 has just 4 bytes of prefetch queue. However, this was enough to substantially increase performance.</p>
<p>Prefetching had a major impact on the design of the 8086 and thus the 8088.
Earlier processors such as the 6502, 8080, or Z80 were deterministic:
the processor fetched an instruction, executed the instruction, and so forth.
Memory accesses corresponded directly to instruction fetching and execution and
instructions took a predictable number of clock cycles.
This all changed with the introduction of the prefetch queue.
Memory operations became unlinked from instruction execution since prefetches happen as needed and when the memory bus is available.</p>
<p>To handle memory operations and instruction execution independently,
the implementors of the 8086 and 8088 divided the processors into two processing units: the Bus Interface Unit (BIU) that handles memory accesses, and the Execution Unit (EU) that executes instructions.
The Bus Interface Unit contains the instruction prefetch queue; it supplies instructions to
the Execution Unit via the Q (queue) bus.
The BIU also contains an
adder (Î£) for address calculation, adding the segment register base to an address offset, among other things.
The Execution Unit is what comes to mind when you think of a processor: it has most of the registers, the arithmetic/logic unit (ALU), and the microcode that implements instructions.
The segment registers (CS, DS, SS, ES) and the Instruction Pointer (IP) are in the Bus Interface Unit since they are directly involved in memory accesses,
while the general-purpose registers are in the Execution Unit.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/8088-block-diagram.jpg"><img alt="Block diagram of the 8088 processor.
This diagram differs from most 8088 block diagrams because it shows the actual physical implementation, rather than the programmer&#39;s view of the processor.
The &#34;Internal Communication Registers&#34; consist of the Indirect Register (IND) and the Operand Register (OPR). These hold a memory address and memory data value respectively.
From The 8086 Family User&#39;s Manual page 243." height="600" src="https://static.righto.com/images/8086-prefetch8088/8088-block-diagram-w800.jpg" title="Block diagram of the 8088 processor.
This diagram differs from most 8088 block diagrams because it shows the actual physical implementation, rather than the programmer&#39;s view of the processor.
The &#34;Internal Communication Registers&#34; consist of the Indirect Register (IND) and the Operand Register (OPR). These hold a memory address and memory data value respectively.
From The 8086 Family User&#39;s Manual page 243." width="800"/></a></p><p>Block diagram of the 8088 processor.
This diagram differs from most 8088 block diagrams because it shows the actual physical implementation, rather than the programmer&#39;s view of the processor.
The &#34;Internal Communication Registers&#34; consist of the Indirect Register (IND) and the Operand Register (OPR). These hold a memory address and memory data value respectively.
From <a href="http://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf">The 8086 Family User&#39;s Manual</a> page 243.</p>
<p>It may seem inefficient for the Bus Interface Unit to have its own adder instead of using the ALU,
but there are reasons for the separate adder.
First, every memory access uses the adder at least once to add the segment base and offset.
The adder is also used to increment the PC or index registers.
Since these operations are so frequent, they would create a bottleneck if they used the ALU.
Second, since the Execution Unit and the Bus Interface Unit run asynchronously with respect to each other, it would be complicated
to share the ALU without conflicts.</p>
<p>Prefetching had another major but little-known effect on the 8086 architecture: the designers were considering
making the 8086 a two-chip microprocessor.
Prefetching, however, required a one-chip design because the number of control signals required to synchronize prefetching across two chips exceeded the package pins available.
This became a compelling argument for the one-chip design that was used for the 8086.<span id="fnref:mckevitt"><a href="#fn:mckevitt">4</a></span>
(The unsuccessful Intel <a href="https://en.wikipedia.org/wiki/Intel_iAPX_432">iAPX 432</a>, which was under development at the same time, ended up being a two-chip processor: one to fetch and decode instructions, and one to execute them.)</p>
<h2>Implementing the queue</h2>
<p>The 8088&#39;s instruction prefetch queue is implemented with four 8-bit queue registers along with two hardware &#34;pointers&#34;
into the queue.
One two-bit counter keeps track of the current read position from 0 to 3,
i.e. the queue register that will provide the next instruction byte.
The second counter keeps track of the current write position, i.e. the queue register that will receive the next instruction from memory.<span id="fnref:read"><a href="#fn:read">5</a></span>
As bytes are fetched from the queue, the read pointer advances. As bytes are added to the queue, the write pointer advances.</p>
<p>The diagram below shows an example queue configuration with two prefetched bytes. The middle two queue registers (Q1 and Q2) hold data.
The read pointer indicates that the Execution Unit will get its next byte from Q1.
The write pointer indicates that the next prefetched byte will go into Q3.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/queue-diagram-2.jpg"><img alt="A queue configuration with two bytes in the prefetch queue. Bytes in blue hold prefetched data." height="200" src="https://static.righto.com/images/8086-prefetch8088/queue-diagram-2-w300.jpg" title="A queue configuration with two bytes in the prefetch queue. Bytes in blue hold prefetched data." width="300"/></a></p><p>A queue configuration with two bytes in the prefetch queue. Bytes in blue hold prefetched data.</p>
<p>The diagram below shows how the queue pointers can wrap around. In this configuration, two more bytes have been written
to the queue (Q3 and Q0), so the queue is full.
The write pointer now points to Q1, the same as the read pointer.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/queue-diagram-4.jpg"><img alt="A queue configuration with four bytes in the prefetch queue." height="198" src="https://static.righto.com/images/8086-prefetch8088/queue-diagram-4-w300.jpg" title="A queue configuration with four bytes in the prefetch queue." width="300"/></a></p><p>A queue configuration with four bytes in the prefetch queue.</p>
<p>There is an important ambiguity, however. Suppose that four bytes are read from the queue, so the read pointer
advances four positions, wrapping around back to Q1.
The queue is now empty, as shown below, but the pointers have the same position as the full case above.
Thus, if the read pointer and the write pointer both point to the same position, the queue may be empty or full.
To distinguish these cases, a flip-flop is set
if the queue enters the empty state. This flip-flop generates a signal that Intel called MT (empty).</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/queue-diagram-0.jpg"><img alt="A queue configuration with the queue empty." height="199" src="https://static.righto.com/images/8086-prefetch8088/queue-diagram-0-w300.jpg" title="A queue configuration with the queue empty." width="300"/></a></p><p>A queue configuration with the queue empty.</p>
<p>To determine how many bytes are in the queue, the queue circuitry uses a two-bit queue length value, along with the MT flip-flop value to distinguish the empty state.
Conceptually, the queue length is generated by subtracting the read position from the write position.
However, the implementation does not use a standard subtraction circuit, but instead uses hardcoded logic to
determine the two bits of the length, as shown below.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/length-logic.png"><img alt="The circuitry to determine the queue length." height="277" src="https://static.righto.com/images/8086-prefetch8088/length-logic-w500.png" title="The circuitry to determine the queue length." width="500"/></a></p><p>The circuitry to determine the queue length.</p>
<p>The low bit of the length is the XOR of the two positions. 
In NMOS logic (used by the 8088), an AND-NOR gate is easy to implement, while an XOR gate is difficult. Thus, XOR is
implemented as shown in the top circuit.
(You can verify that if one input is 1 and the other is 0, the output is 1.)
The high-order bit of the length is also based on an AND-NOR gate, one with six inputs.
Each input is a combination of read and write positions that yields an output bit 1; each input is computed by a NOR gate,
which I haven&#39;t drawn.<span id="fnref:demorgan"><a href="#fn:demorgan">6</a></span>
As a result, the amount of logic circuitry to compute the length is fairly large.</p>
<p>The diagram below zooms in on the queue control circuitry on the die, with the main flip-flops and circuitry labeled.
The circuitry in the middle computes the queue length with
the 6-input NOR gate stretched across the whole region.
The flip-flops for the read and write positions are in the lower region.
Despite the relative simplicity of the queue circuits, they take up a substantial part of the die.
Compared to modern chips, the density of the 8088 is very low; you can almost see the flip-flops with the naked eye.
But this isn&#39;t all the circuitry as prefetching also required
queue registers and memory cycle control circuitry.
Thus, prefetching was a moderately expensive feature for the 8088, as far as die area.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/prefetch-die.jpg"><img alt="The queue and prefetch circuitry on the die. The metal layer has been removed for the closeup to show the silicon of the underlying transistors." height="465" src="https://static.righto.com/images/8086-prefetch8088/prefetch-die-w600.jpg" title="The queue and prefetch circuitry on the die. The metal layer has been removed for the closeup to show the silicon of the underlying transistors." width="600"/></a></p><p>The queue and prefetch circuitry on the die. The metal layer has been removed for the closeup to show the silicon of the underlying transistors.</p>
<h2>The loader</h2>
<!--
The 8086 processor is implemented with microcode: most 8086 machine instructions are broken down into simple micro-instructions that are
stored in the microcode ROM.
For example, an ADD instruction is implemented through a sequence of micro-instructions to move the arguments to the Arithmetic/Logic Unit, perform the addition, and store the result.
The multiple addressing modes are implemented in micro-instruction subroutines that access index registers and compute the
memory address.

In 1978 the space available for microcode was limited, so the 8086 designers
moved a lot of control logic outside the microcode, including insruction fetching and decoding.

The relevant part for this discussion is the instruction fetch and decode loop is implemented outside the microcode.
A state machine called the "loader" fetches the first one or two bytes of an instruction. A ROM called the Group Decode ROM
does a "high-level" classification of the instruction.
Simple instructions (such as clearing the carry flag) or prefixes (such as LOCK or selecting a segment register) are performed
directly. More complex instructions are dispatched to the microcode engine, which runs the micro-instructions to carry
out the instruction.
-->

<p>To decode and execute an instruction, the Execution Unit must get instruction bytes from the Bus Interface Unit, but this is not entirely straightforward.
The main problem is that the queue can be empty, in which case instruction decoding must block until a byte is available from
the queue.
The second problem is that instruction decoding is relatively slow so it is pipelined.
For maximum performance, the decoder needs a new byte before the current instruction
is finished.
A circuit called the &#34;loader&#34; solves these problems by providing
synchronization between the prefetch queue and the instruction decoder.
The loader uses a small state machine to efficiently fetch bytes from the queue at the right time and to provide timing
signals to the decoder and microcode engine.</p>
<!--
To explain how instructions are fetched, I'll first give a brief overview of 8086 instructions.
The 8086 instruction format is fairly complicated, with instructions from one to six bytes long.
The first byte is the opcode, specifying the instruction.
In some cases, this byte completely specifies the instruction, for example PUSH AX to push the AX register to the stack.
Most of the instructions, however, have a second byte that specifies the addressing mode and register: the Mod R/M byte.
Depending on the addressing mode selected, this may be followed by an 8- or 16-bit memory displacement.
Finally, there can be an 8- or 16-bit immediate operand.
-->

<p>In more detail, as the loader requests the first two instruction bytes from the prefetch queue, it generates two timing signals that control the microcode execution.
The FC (First Clock) indicates that the first instruction byte is available, while the SC (Second Clock) indicates the second
instruction byte.
Note that the First Clock and Second Clock are not necessarily consecutive clock cycles because
the prefetch queue could be empty or contain just one byte, in which case the First Clock and/or Second Clock would be
delayed.
The instruction decoding circuitry and the microcode engine are controlled by the First Clock and Second Clock signals, so
they remain synchronized with the bytes supplied by the prefetch queue.</p>
<p>At the end of a microcode sequence, the Run Next Instruction (RNI) micro-operation causes the loader to fetch the next machine instruction.
However, fetching and decoding the next instruction is a bit slow so microcode execution would be blocked for a cycle.
In many cases, this slowdown can be avoided: if the microcode knows that it is one micro-instruction away from finishing,
it issues a Next-to-last (NXT) micro-operation so the loader can start loading the next instruction.
This achieves a degree of pipelining in most cases; fetching the next instruction is overlapped with finishing the execution
of the previous instruction.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/loader.png"><img alt="The state machine for the 8086/8088 &#34;loader&#34; circuit.
The 1BL signal indicates a 1-byte instruction implemented in logic rather than microcode.
From patent US4449184." height="345" src="https://static.righto.com/images/8086-prefetch8088/loader-w400.png" title="The state machine for the 8086/8088 &#34;loader&#34; circuit.
The 1BL signal indicates a 1-byte instruction implemented in logic rather than microcode.
From patent US4449184." width="400"/></a></p><p>The state machine for the 8086/8088 &#34;loader&#34; circuit.
The 1BL signal indicates a 1-byte instruction implemented in logic rather than microcode.
From <a href="https://patents.google.com/patent/US4449184A">patent US4449184</a>.</p>
<p>The diagram above shows the state machine for the loader.
I won&#39;t explain it in detail, but essentially it keeps track of whether it is waiting for a First Clock byte or a
Second Clock byte, and if it is performing a fetch in advance (NXT) or at the end of an instruction (RNI).
The state machine is implemented with two flip-flops to support its four states.</p>
<h2>Microcode and the prefetch queue</h2>
<p>The loader takes care of fetching an instruction that consists of an opcode byte and a Mod R/M (addressing mode) byte.
However, many instructions have additional bytes or don&#39;t follow this format
For example, an opcode such as &#34;ADD AX&#34; can be followed by an 8- or 16-bit immediate value, adding that value to the AX register.
Or a &#34;move memory to AX&#34; instruction can be followed by a 16-bit memory address
The microcode uses a separate mechanism for fetching these instruction bytes from the queue.
Specifically, each micro-instruction contains a source register and a destination register that specify a data move.
By specifying &#34;Q&#34; (the queue) as the source, a byte is fetched from the prefetch queue.
If the queue is empty, microcode execution blocks until the 
Bus Interface Unit loads a byte into the prefetch queue.
Thus, the complexity of instruction fetching and the prefetch queue is invisible to the microcode.<span id="fnref:memory"><a href="#fn:memory">7</a></span></p>
<p>A jump, subroutine call, or other control flow change causes the prefetch queue to be flushed since the queue contents
are no longer useful.
This is accomplished in microcode with the <code>FLUSH</code> micro-instruction, which resets the queue read and write pointers and
sets the MT (empty) flip-flop.
Note that the queue is flushed even if the target address is in the queue, for example if you jump one byte ahead.</p>
<p>One complication due to the prefetch queue is that the processor&#39;s Instruction Pointer points to the next instruction to
be <em>fetched</em>, not the next instruction to be <em>executed</em>.
This becomes a problem for a subroutine call, which needs to push the return address.
It is also a problem for a relative jump, which is computed from the current instruction.
The solution is the <code>CORR</code> micro-instruction, which corrects the Instruction Pointer by subtracting the queue length to
determine the current execution position.
This is implemented by the Bus Interface Unit, which holds correction constants in the Constant ROM, and subtracts them
using the address adder (not the ALU).<span id="fnref:constants"><a href="#fn:constants">8</a></span></p>
<h2>The queue registers</h2>
<p>The 8086 and 8088 partition the registers into upper registers (in the Bus Interface Unit) and lower registers
(in the Execution Unit).
The upper registers are the registers associated with memory accesses (e.g. Instruction Pointer, segment registers)
while the lower registers are more general purpose (e.g. AX, BX, SI, SP).
The upper registers are connected to two 16-bit internal buses: the B bus and the C bus.</p>
<p>The queue registers are physically part of the upper registers, but are wired into the buses slightly differently, as shown below.
In particular, the 8088&#39;s queue registers are written 8 bits at a time from the C bus.
(In contrast, the 8086&#39;s queue registers can be written 16 bits at a time to support two-byte prefetches.)
When accessing the queue, the queue registers are read 16 bits at a time, but only one byte is transferred to the Q bus for instruction processing.<span id="fnref:motivation"><a href="#fn:motivation">9</a></span></p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/queue-regs.jpg"><img alt="The queue registers in the 8088." height="429" src="https://static.righto.com/images/8086-prefetch8088/queue-regs-w270.jpg" title="The queue registers in the 8088." width="270"/></a></p><p>The queue registers in the 8088.</p>
<p>The diagram below shows how the queue registers appear on the die, comparing the six-byte prefetch queue in the 8086 (top) to the four-byte 8088 queue (bottom).
The 8086 prefetch registers are structured as three rows of 16-bit registers, while the 8088 prefetch registers are
structured as four rows of 8-bit registers.
In both cases, each bit is stored in a cross-coupled pair of inverters.
The bit lines (not present) are vertical, while the control lines to select a register are horizontal.
The layout is different between the processors to support 16-bit versus 8-bit writes.
Note the empty space at the bottom of the 8088 registers.
Because the rest of the chips are mostly the same, the 8088 couldn&#39;t be &#34;compacted&#34; to avoid this wasted space.</p>
<p><a href="https://static.righto.com/images/8086-prefetch8088/8086-vs-8088.jpg"><img alt="The prefetch registers in the 8086 (top) and 8088 (bottom). For the 8086, the metal and polysilicon layers were removed, exposing the underlying silicon. For the 8088, the polysilicon and silicon are visible." height="382" src="https://static.righto.com/images/8086-prefetch8088/8086-vs-8088-w600.jpg" title="The prefetch registers in the 8086 (top) and 8088 (bottom). For the 8086, the metal and polysilicon layers were removed, exposing the underlying silicon. For the 8088, the polysilicon and silicon are visible." width="600"/></a></p><p>The prefetch registers in the 8086 (top) and 8088 (bottom). For the 8086, the metal and polysilicon layers were removed, exposing the underlying silicon. For the 8088, the polysilicon and silicon are visible.</p>
<p>Intel used simulations to determine the best queue sizes for the 8086 and 8088, balancing the performance cost of prefetching
against the benefit. (The cost is that prefetching makes the bus unavailable for other memory or I/O operations.)
The prefetch queue is discarded on a jump instruction or other change of control flow, causing the prefetched bytes to
be wasted.
Thus, as the queue gets longer, the chance of discarding a prefetched byte becomes larger,
so the potential benefit of prefetching becomes smaller.
Since the 8088 prefetches one byte at a time, compared
to two bytes at a time on the 8086,
prefetching on the 8088 costs twice as much as on the 8086 in terms of bus cycles used per byte.
This changes the tradeoffs in favor of a shorter queue.</p>
<p>Because of the difference in queue lengths, the queue control circuitry is different between the 8086 and 8088.
In particular, the 8086 needs three-bit counters for the
read and write positions, while the 8088 uses two-bit counters.
Because of this, the length computation circuitry is also different between the processors.</p>
<p>I plan to continue reverse-engineering the 8088 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@oldbytes.space@kenshirriff</a>.
If you&#39;re interested in the 8086, I wrote about the <a href="https://www.righto.com/2020/06/a-look-at-die-of-8086-processor.html">8086 die</a>, its <a href="https://www.righto.com/2020/06/die-shrink-how-intel-scaled-down-8086.html">die shrink process</a> and the <a href="https://www.righto.com/2020/07/the-intel-8086-processors-registers.html">8086 registers</a> earlier.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
