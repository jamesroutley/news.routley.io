<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.rgsilva.com/smartifying-my-hi-fi-system/">Original</a>
    <h1>&#34;Smartifying&#34; my hi-fi system</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        

            <p>Have you ever wondered if it would be possible to make a &#34;dumb&#34; &#34;hi-fi system&#34; smart? Not that smart, but simply connect a device and it would play whatever stream you want into you? Maybe even stream from your phone? Then this is for you.</p>

        <div>
        <section>

            <ul>
                <li>
                    <a href="https://blog.rgsilva.com/author/ricardo/">
                        <img src="https://blog.rgsilva.com/content/images/size/w100/2022/10/pp.jpg" alt="Ricardo Gomes da Silva"/>
                    </a>
                </li>
            </ul>

            <div>
                
                <p><time datetime="2021-12-22">Dec 22, 2021</time>
                        <span><span>•</span> 10 min read</span>
                </p>
            </div>

        </section>
        </div>

            <figure>
                <img srcset="/content/images/size/w300/2021/12/Clipboard01.jpg 300w,
                            /content/images/size/w600/2021/12/Clipboard01.jpg 600w,
                            /content/images/size/w1000/2021/12/Clipboard01.jpg 1000w,
                            /content/images/size/w2000/2021/12/Clipboard01.jpg 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://blog.rgsilva.com/content/images/size/w2000/2021/12/Clipboard01.jpg" alt="&#34;Smartifying&#34; my Hi-Fi system"/>
            </figure>

    </header>

    <section>
        <h2 id="background-story">Background story</h2><p>I have a &#34;dumb&#34; &#34;hi-fi system&#34; that I used as speakers for my desktop computer. They are pretty good considering what I paid for them many years ago, and work pretty well. I am not, however, using all of its features, such as USB and FM Radio - and that&#39;s fine. But I wonder if I can do better.</p><p>You see, I use Spotify as a streaming service. Whenever I&#39;m working (from home), I&#39;m not using the hi-fi&#39;s speakers, as they are connected to my desktop computer. That can be easily fixed by having some kind of switching (or mixing) device that would allow me to connect the hi-fi to my employer&#39;s laptop. But honestly I don&#39;t care about that: all I want is to play Spotify using those speakers. Not only that, if possible, I want to use prev/next song buttons to change songs on the streaming. Simple as that.</p><p>Then I started to wonder: what would happen if I had an USB drive that I would connect to the hi-fi and whatever song it played it would actually play an Internet stream? Would that even be possible? Well, I&#39;m glad to say that <strong>yes</strong>, it is possible - it&#39;s just messy.</p><h2 id="the-challenge">The Challenge</h2><p>Based on the very basic knowledge of how USB mass storage devices work, I know that whenever a block/sector/cluster/whatever is requested by the host, the device can delay the return of such value. This happens all the time on mechanical drives: it first needs to <em>seek </em>the correct position and <em>then </em>read the data. This takes time. Therefore, the answers are asynchronous, which is important.</p><p>My idea: create an USB device that presents itself with a sound file on it. Whenever a player wants to play such files, it would receive different data on every read, as it would actually be returning a stream of data from somewhere else.</p><p>The original idea also used multiple sound files, as, based on the positions of each file, I could also detect a navigation, such as going back a song or playing the next one: you just need to detected the host reading the first block of each file. But that is a challenge for another day (although very much possible!).</p><h2 id="about-not-taking-the-hard-way">About not taking the hard way</h2><p>I have played with <a href="https://www.obdev.at/products/vusb/index.html">V-USB</a> and manual USB device configuration in the past (and again in this project). My first idea was to create a custom device that, once connected, would present itself as the controllable mass storage device. I would then intercept reads and writes to control the replies to the host, giving the proper bytes for the stream it was reading.</p><p>This is not easy though. You need to deeply understand the USB protocol (endpoints, transfers, etc) as well as understand how mass storage devices are presented to the OS. You&#39;ll need to translate USB calls to disk calls, then those calls to filesystem positions, and finally those to file positions.</p><p>Is it doable? Yes. Do I want to? No. Hell no.</p><p>I really enjoy playing with very complicated stuff, such as USB communication. I am, however, on vacation and don&#39;t want to spend 10, 12, 14 hours in front of my computer trying to debug the USB device implementation I wrote. I might do it in the future (to create a smaller version of this project), but it&#39;s not my goal at this moment at all.</p><h2 id="is-there-an-easy-way">Is there an easy way?</h2><p>Have you heard of the <a href="https://learn.adafruit.com/turning-your-raspberry-pi-zero-into-a-usb-gadget">Raspberry Pi Zero&#39;s USB Gadget mode</a>? It&#39;s a pretty cool feature embedded in the RPi&#39;s CPU that allow an USB port to be configurable and behave as a device. This is also called sometimes USB OTG, although I&#39;m not sure this name is correct. This gadget mode in the kernel allows you to make the RPi behaves itself an USB device instead of a host, meaning it can present itself as anything: a serial port, a network card, or even a mass storage device! Cool, right?</p><p>This would fit my needs perfectly: a way of making the USB communication transparent (so I don&#39;t have to implement it manually) and I would only have to deal with the filesystem stuff. This would allow me to start and finish this project in a single day!</p><blockquote>Ricardo from the future: boy oh boy. I was so wrong on this one. It has been 4 days already :)</blockquote><p>As everything else so far, there&#39;s a catch: the gadget mode won&#39;t allow me to fine-tune the data I/O. Not only that, it requires a disk image to work with, and such image is then loaded by the kernel module (<code>g_mass_storage</code>) and fed into the USB port. Also, both the kernel (AFAIK) and the host will cache data, which is, as you can imagine, bad. I&#39;m assuming my hi-fi won&#39;t cache data (this was later proved to be correct).</p><p>Let&#39;s go deeper into this though. The <a href="https://www.kernel.org/doc/Documentation/usb/mass-storage.txt">kernel module documentation</a> states that you should not modify this file while loaded as changes might not be detected:</p><blockquote>&#34;Beware that if a file is used as a backing storage, it may not be modified by any other process.  This is because the host assumes the data does not change without its knowledge.  It may be read, but (if the logical unit is writable) due to buffering on the host side, the contents are not well defined.&#34;</blockquote><p>I tested this and it&#39;s true. It changes, but once the host OS reads the filesystem, it&#39;s cached, so you are screwed. File data is also cached, so yeah, it&#39;s a no-go. And trust me when I say this: at least with Windows, this is a no-go at all. Probably the hi-fi won&#39;t cache too much stuff, but still.</p><blockquote>&#34;But Ricardo, didn&#39;t the kernel docs said this already?&#34; - Hey, just because they say you <strong>shouldn&#39;t </strong>do it, it doesn&#39;t mean you <em><strong>can&#39;t</strong></em> do it.</blockquote><p>So.. is the gadget mode a no-go? Maybe. Let&#39;s keep it on the side for now and focus on a different part of the project: the filesystem. I started to wonder: is there <em>any</em> way of creating a custom filesystem where you can control the the reads and writes?</p><h2 id="blowing-some-fuses">Blowing some fuses</h2><p>Have you ever heard of <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a>? FUSE stands for Filesystem in Userspace and is an interface for writing filesystems in Linux (and Unix it seems). Not only that, it works in userspace, meaning that the &#34;driver&#34; you write won&#39;t be loaded into kernel, but as a standard user process. It&#39;s a pretty cool thing.</p><p>You know what else is cool? FUSE allows you to control read and write functions: you just get the handle, offset, size/buffer, and you decide what you want to do with it: fail, delay, return, whatever. You are in control of the filesystem. This is perfect for what I want to do.</p><p>I actually played with this for <em>hours</em> and was able to reproduce what I want. I created a filesystem that has an MP3 file in it (a fake one). Once you load it into <code>ffplay</code>, it will &#34;hang&#34; while the filesystem waits for data from a socket. I then piped StarFM Berlin into it and, sure enough, the supposedly &#34;local&#34; MP3 started playing an Internet stream. Stop the pipe and the player hangs. Restart it and there it goes again. <em>Perfect!</em></p><p>There is, however, a catch (get used to this, you&#39;re hear this a lot). I can&#39;t mix this with the <code>g_mass_storage</code>. This means I can&#39;t create a custom filesystem and simply map it into the module, as the module requires a disk image, not an existing filesystem. I can&#39;t fake a block device or something to even make it work. <em>Damn it, this would be so easy.</em></p><h2 id="the-no-so-easy-way">The no-so-easy way</h2><p>Ok, so this is where we stand right now:</p><ol><li>We have a way of creating a controllable filesystem that allows use to return whatever we want when we read a file.</li><li>We have a way of providing a disk image containing a FAT filesystem as an USB mass storage device.</li></ol><p>Can we mix those two? I mean, the gadget module for USB mass storage won&#39;t accept a FUSE filesystem directly into it without any modification - plus the FUSE filesystem doesn&#39;t have disk information as it is not a block device. But what if we loaded the disk image <em>inside</em> the FUSE filesystem and hijack the reads for the position of the files we want to control? Would this be possible?</p><p>Ironically, yes. I even made a drawing because it&#39;s a mess to understand this.</p><figure><img src="https://blog.rgsilva.com/content/images/2021/12/image.png" alt="" loading="lazy" width="662" height="342" srcset="https://blog.rgsilva.com/content/images/size/w600/2021/12/image.png 600w, https://blog.rgsilva.com/content/images/2021/12/image.png 662w"/><figcaption>This is a basic idea - there&#39;s a bunch more at the table but won&#39;t need to care about it</figcaption></figure><p>So, this is what I want to do: whenever the FUSE filesystem gets a read at the <em>exact position</em> of our stream file, it replies something else. Obviously the player will want more data, so we&#39;ll keep it coming while we&#39;re still the bounds of such file. Once out of it, then we&#39;ll just pass through the original data.</p><p>To make this work, we need a few things first:</p><ol><li>A way of loading the disk image into our custom filesystem.</li><li>A way of finding the exact position of our stream file and its bounds (as well as handling fragmentation).</li></ol><p>You might be wondering: why do we need a real file within the filesystem if we&#39;re not gonna return its data? Well, that&#39;s only to make the FAT table work. If the player itself will handle an empty read as EOF or will it respect the FAT clusters, it&#39;s a whole different story.</p><h2 id="the-implementation">The implementation</h2><p>Beware: crappy coding ahead! :) No, really, the code is not clean <em>at all</em>. Honestly I don&#39;t care (and you shouldn&#39;t as well), as this is just a proof-of-concept! Please do not refer to this code as any kind of guide.</p><p>The code is here:</p><figure><a href="https://github.com/rgsilva/stream-to-usb"><div><p>GitHub - rgsilva/stream-to-usb</p><p>Contribute to rgsilva/stream-to-usb development by creating an account on GitHub.</p><p><img src="https://github.com/fluidicon.png" alt=""/><span>GitHub</span><span>rgsilva</span></p></div><p><img src="https://opengraph.githubassets.com/518aca9aa26b0dbc68b08fcf1135456b7a1ca8f0d7e691b74fa3d224050924d4/rgsilva/stream-to-usb" alt=""/></p></a></figure><p>The implementation is essentially what I said before: it&#39;s a custom filesystem using FUSE that will intercept all reads for offsets of the file. It does this by doing the following:</p><ol><li>Read the <code>storage</code> file (with an offset to bypass the MBR and other disk info) as a FAT filesystem and figure out all clusters for the &#34;needle file&#34; (the stream one).</li><li>Convert those clusters into file offsets for the <code>storage</code> file, so that we know the exact position within the real file itself. That means that if reading cluster 1234 will give you offset 349393 in the file, I want to know that position.</li><li>Simplify these offsets to make faster to check them. For example, if we have to hijack the offsets 1000 to 2000 and 2000 to 3000, we can simply hijack 1000 to 3000. This is done for performance.</li><li>Start the FUSE filesystem with a single file within: the <code>storage</code> one. At this point we also start listening on port <code>3123</code> for data to write into a thread-safe FIFO buffer we created.</li></ol><p>At this point the program is running and the filesystem is mounted. If you list files on it, you&#39;ll see only the <code>storage</code> file, and this is correct. If you map this into loop device using <code>losetup</code> and mount it locally, you&#39;ll see the contents of such image. Here is the tricky though:</p><p>Any read outside the monitored offsets will seek and return the original file contents. Any read <em>within the monitored offsets</em> will wait and return data from our buffer, which is populated by the socket. This means such read will <em>hang</em> until it has data. Originally I&#39;ve designed this to return a silence file for 100ms, but this was introducing way too much lag.</p><p>So... does it work? Yes, but of course! Here&#39;s a video (without audio because of how I recorded it and due to copyright reasons) so you can enjoy it:</p><figure><iframe width="200" height="113" src="https://www.youtube.com/embed/xPhuP6ryUpw?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><figcaption>Please excuse my command mistakes :)</figcaption></figure><p>Quick small details: you might have noticed I&#39;ve mapped the <code>loop0</code> with offset 1048576. That&#39;s the offset of the FAT filesystem in the disk image. Plus, if you look closely, you&#39;ll see I&#39;ve mounted the filesystem with <code>ro,sync</code>: this is because 1) I don&#39;t want to make any changes on it, and 2) I want it to do direct I/O and not cache stuff. Caching things on this project is <em>bad</em>.</p><p>Ok, that&#39;s cool and everything... but how about loading it into <code>g_mass_storage</code>? Does it work? Does it does the same thing when I load this thing into a Raspberry Pi Zero? <strong>Yes, it does.</strong></p><p>Here&#39;s a quick demo for you:</p><figure><iframe width="200" height="113" src="https://www.youtube.com/embed/2VqqV_oaXFs?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><figcaption>Unlisted and thanks StarFM Berlin :)</figcaption></figure><p>Yep, that&#39;s it. It works and, somehow, it works great!</p><h2 id="next-steps">Next steps</h2><p>You might be wondering: but Ricardo, how about Spotify? Well, it&#39;s not that complicated: you just need to load <code>spotifyd</code> or other similar project and convert the stream into an MP3 one, so you can patch to the file. The reason why I&#39;m using MP3s here is because it&#39;s the only thing my hi-fi will load. Originally I was planning to use an WAV file for simplicity, but that didn&#39;t work out. Also MP3s can be streamed by concatenating them it seems - although I think it might not be recommended.</p><p>My main next steps, in no particular order, would be:</p><ol><li>Find a way to make it smaller. Maybe V-USB? Maybe streaming USB data over the network, some kind of USB/IP mixed with V-USB? Who knows, but making it the size of a flash drive would be amazing.</li><li>Performance is slow, mostly due to the RPi Zero I&#39;m using. Even at 1GHz it sometimes outputs crappy, choppy audio. This is due to the FUSE being a bit too slow in Python. I need to fix that, but trust me, the version I published is <em>way</em> better than the original one!</li><li>Detecting track navigation: if you go to the previous or next tracks, emit a signal to somewhere. This would allow triggering a track change on the stream source, such as Spotify.</li></ol><p>But until then... enjoy some StarFM Berlin!</p><figure><a href="https://berlin.starfm.de/"><div><p>SEO Infos frontpage B</p><p>STAR FM</p><p><img src="https://berlin.starfm.de/assets/icons/icon-180x180.png" alt=""/><span>STAR FM</span><span>STAR FM Berlin 87,9 Rundfunkveranstalter GmbH &amp; Co. KG</span></p></div><p><img src="https://berlin.starfm.de/assets/fallback/fallback_1x1.jpg" alt=""/></p></a></figure>
    </section>


</article>
</div></div>
  </body>
</html>
