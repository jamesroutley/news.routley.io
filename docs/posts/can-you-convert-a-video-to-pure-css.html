<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dgerrells.com/blog/can-you-convert-a-video-to-pure-css">Original</a>
    <h1>Can you convert a video to pure CSS?</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://dgerrells.com/images/video-to-css.png" alt="text of css to video on a background with a upload file icon"/></p>
<p>Twitter formerly known as X, a strange experience. It is the place where only the coolest of kids hang or so they say. The cool kids idle away their time smelling farts and fart like opinions. Sometimes I add my own to the mix but I usually lurk in the corners marinating in the warm miasma.</p>
<p>Not all flatulence is created equal. Some, is rather nice, interesting even, and dare I say it can be quite delectable. For example. Take this dude, <a href="https://x.com/jh3yy">jh3yy</a>. What a guy.</p>
<p>He regularly shares cool examples of fancy css animations. At the time of writing his focus has been on css scroll animations. I guess there are some new properties that allow playing a css animation based on the scroll position. Apple has been using this on their marketing pages or so jhehy says. The property seems pretty powerful.</p>
<p>But how powerful?</p>
<p>This got me thinking...could it play a video as pure css?</p>
<h2>a baseline</h2>
<p>Before getting too crazy it may be best to get something simple working. The idea seems to be to slap <code>scroll-timeline-name: someKindOfName;</code> on a scrollable container. Then you can slap <code>animation-timeline: --someKindOfName;</code> on the element which animates. <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline">Simple enough</a>.</p>
<p>Here is an example with 25 divs that animate a bunch of properties based on scroll.</p>

<p>Pretty cool unless....you are on Safari. Yup, Safari doesn&#39;t support this feature yet. Sad pandas. Too bad because it is pretty easy to use. That is fine. Just imagine for now that it animates as it scrolls all nice like.</p>
<p>The way this example works is pretty simple.</p>
<pre><code><span>#v1</span> {
  <span>position</span>: relative;
  <span>overflow-x</span>: hidden;
  <span>overflow-y</span>: scroll;
  <span>scroll-timeline-name</span>: --section;
}
<span>#v1</span> <span>.container</span> {
  <span>height</span>: <span>800vh</span>;
}
<span>#v1</span> <span>.animated-div</span> {
  <span>animation-timeline</span>: --section;
  <span>position</span>: absolute;
  <span>animation-name</span>: scrolly;
  <span>animation-fill-mode</span>: both;
  <span>animation-timing-function</span>: linear;
}
</code></pre>
<p>Absolutely position the scroll animated elements within a scrollable div. I added another div with a fixed height in the scroll view to control how much scrolling there is to play the full animation.</p>
<p>It may be worth trying a different method of animating via scroll position which works on all browsers. The idea is to use a tiny bit of js to set a css variable to what the current scroll position is. This can then be used to set a negative animation delay to &#34;scrub&#34; the key frames as the scroll position changes. This should work across browsers but is technically not &#34;pure&#34; css. I am going to use this technique moving forward for compatibility.</p>
<p>Here is the previous example with this method implemented.</p>

<p>The css is is a bit more complicated than the timeline version.</p>
<pre><code><span>#wrapper</span> {
  <span>position</span>: relative;
  <span>overflow-x</span>: hidden;
  <span>overflow-y</span>: scroll;
  <span>--scroll</span>: <span>0</span>; // &lt;== set via js
}
<span>.scroll-height</span> {
  <span>height</span>: <span>800vh</span>;
}
<span>.animated-div</span> {
  <span>position</span>: absolute;
  <span>width</span>: <span>100px</span>;
  <span>height</span>: <span>100px</span>;
  <span>animation-name</span>: mySpicyBoyAnimation;
  <span>animation-fill-mode</span>: both;
  <span>animation-timing-function</span>: linear;
  <span>animation-play-state</span>: paused;
  <span>animation-delay</span>: <span>calc</span>(var(--scroll, <span>0</span>) * -<span>1s</span>);
  <span>animation-duration</span>: <span>1s</span>;
  <span>box-shadow</span>: <span>0</span> <span>2px</span> <span>22px</span> <span>#0008</span>;
}
</code></pre>
<p>The secret here is that a negative animation delay will act as starting the animation earlier. This means that a delay of <code>-.5s</code> functions as starting in the middle of the animation. A css variable can be used to scrub the position of the animation and if set from js based on scroll works just like the timeline version. It is important to pause the animation and set the timing function to linear. You can use other timing functions but they all felt...wrong to me.</p>
<p>The js to set scroll position is pretty standard.</p>
<pre><code><span>const</span> targetDiv = <span>document</span>.getElementById(<span>&#34;container&#34;</span>);
targetDiv.addEventListener(<span>&#34;scroll&#34;</span>, <span>() =&gt;</span> {
  <span>const</span> scrollTop = targetDiv.scrollTop;
  <span>const</span> scrollHeight = targetDiv.scrollHeight - targetDiv.clientHeight;
  <span>const</span> scrollPercent = scrollTop / scrollHeight;
  targetDiv.style.setProperty(<span>&#34;--scroll&#34;</span>, <span>`<span>${scrollPercent}</span>`</span>);
});
</code></pre>
<p>This is a good time to stress test both versions to make sure they don&#39;t perform radically different before moving on. Ideally, it would be great to have millions of divs but I am going to guess that 1-5k is the upper limit.</p>
<p>Here are 500 divs.</p>

<p>There wasn&#39;t much difference between using timeline or the animation delay hack. Likely hitting a limit on a css animation limit. Looks like the budget is 500.</p>
<p>It would be fun to set the div positions to something more interesting than random numbers...maybe something more 3d?</p>
<p>What about positioning divs along the vertices of a 3d model based on scroll?</p>
<h2>fancy pants adventure</h2>
<p>Loading a model isn&#39;t too bad depending on format. I used <code>.obj</code> because it is easy to ignore other data I don&#39;t care about. I only need vertices. This little function will let me load a model and apply some optional scaling and rotation to the points. Ye&#39;old gypity did the rotate vertex function for me.</p>
<pre><code><span>const</span> loadObjModel = <span>(<span>
  objData,
  [rx, ry, rz] = [<span>0</span>, <span>0</span>, <span>0</span>],
  [sx, sy, sz] = [<span>1</span>, <span>1</span>, <span>1</span>]
</span>) =&gt;</span> {
  <span>const</span> vertices: <span>Array</span>&lt;{ x: <span>number</span>; y: <span>number</span>; z: <span>number</span> }&gt; = [];
  <span>const</span> lines = objData.split(<span>&#34;\n&#34;</span>);

  lines.forEach(<span>(<span>line</span>) =&gt;</span> {
    <span>if</span> (line.startsWith(<span>&#34;v &#34;</span>)) {
      <span>const</span> [, x, y, z] = line.split(<span>&#34; &#34;</span>).map(<span>Number</span>);
      <span>const</span> v = rotateVertex(x, y, z, { x: rx, y: ry, z: rz });
      v.x *= sx;
      v.y *= -sy; 
      v.z *= sz;
      vertices.push(v);
    }
  });

  <span>return</span> vertices;
};
</code></pre>
<p>Then slap this ugly as sin <code>useMemo</code> to generate styles indexing into the models.</p>
<pre><code><span>const</span> divStyles = useMemo(
  <span>() =&gt;</span>
    <span>Array</span>.from({ length: count })
      .map(
        <span>(<span>_, index</span>) =&gt;</span> <span>`
          .div<span>${index + <span>1</span>}</span> {
            --x1pos: <span>${cx + m1[index % m1.length].x}</span>px;
            --y1pos: <span>${cy + m1[index % m1.length].y}</span>px;
            --z1pos: <span>${cz + m1[index % m1.length].z}</span>px;
            --x2pos: <span>${cx + rnd(<span>-200</span>, <span>200</span>)}</span>px;
            --y2pos: <span>${cy + rnd(<span>-200</span>, <span>200</span>)}</span>px;
            --z2pos: <span>${cz + rnd(<span>-200</span>, <span>200</span>)}</span>px;
            --x3pos: <span>${cx + m2[index % m2.length].x}</span>px;
            --y3pos: <span>${cy + m2[index % m2.length].y + <span>100</span>}</span>px;
            --z3pos: <span>${cz + m2[index % m2.length].z}</span>px;
            --x4pos: <span>${cx + rnd(<span>-200</span>, <span>200</span>)}</span>px;
            --y4pos: <span>${cy + rnd(<span>-200</span>, <span>200</span>)}</span>px;
            --z4pos: <span>${cz + rnd(<span>-200</span>, <span>200</span>)}</span>px;
            --col1: <span>${gen()}</span>;
            --col2: <span>${gen(colorPalette2)}</span>;
            --col3: <span>${gen()}</span>;
            --col4: <span>${gen(colorPalette3)}</span>;
          }
        `</span> 
      )
      .join(<span>&#34;&#34;</span>),
  [cx, cy, cz, width, height]
);
</code></pre>
<p>I didn&#39;t really need to use a memo. It works fine without it but I makes me feel like it is more efficient like I am saving electricity. Premature optimization makes me feel like captain planet.</p>
<p><img src="https://dgerrells.com/images/imcaptainnow.jpg" alt="captain planet meme with programming buzzwords" width="100%"/></p><p>The example looks pretty cool but it has over 600 points and can be sluggish. The models are fun, the mainecoon is my favorite.</p>

<p>The divs when rotated can be seen to be paper thin. This is normal and correct behavior when rendering rotated quads (2d planes) in 3d. There is a technique called billboarding which rotates the quads to always face the camera but it isn&#39;t something built into css.</p>
<p>The examples shown used only 4 keyframes. What if that number were bumped up a bit? like alot a bit....</p>
<p>What if a video were to be downscaled and then for each pixel a div were to be animated such that each keyframe was a pixel value corresponding to a frame of the video? It would be a shitload of keyframes. Megabytes of keyframes even. I am not sorry for what I am about to do to your browser.</p>
<h2>near infinity and beyond</h2>
<p>Ok. First. Make a <code>videoUrlToArrayOfPixelData</code> function. How exactly does one convert a video into pixel data? I don&#39;t know. There are all kinds of encodings. The simplest method is to just let the browser handle it. It turns out you can render a browser supported video format onto a canvas and then read back the pixels.</p>
<p>I want to be able to configure a sample frame rate to allow for optionally reducing the number of keyframes used. This would allow sampling 10 fps from a video running at 24 fps for example.</p>
<p>This is the code.</p>
<pre><code><span>async</span> <span><span>function</span> <span>getUrlFrameData</span>(<span>{
  url,
  targetWidth,
  targetHeight,
  scale,
  fps,
}: typestuff</span>) </span>{
  <span>const</span> video = <span>document</span>.createElement(<span>&#34;video&#34;</span>);
  video.crossOrigin = <span>&#34;anonymous&#34;</span>;
  video.src = url;

  <span>await</span> video.load();
  <span>await</span> <span>new</span> <span>Promise</span>(<span>(<span>resolve</span>) =&gt;</span> {
    video.addEventListener(<span>&#34;loadedmetadata&#34;</span>, resolve);
  });

  <span>if</span> (!scale) scale = <span>1</span>;
  <span>if</span> (!targetWidth) targetWidth = video.videoWidth;
  <span>if</span> (!targetHeight) targetHeight = video.videoHeight;
  <span>if</span> (!fps) fps = <span>1</span>;
  targetWidth *= scale;
  targetHeight *= scale;

  <span>const</span> aspectRatio = video.videoWidth / video.videoHeight;
  <span>if</span> (targetWidth / targetHeight &gt; aspectRatio) {
    targetWidth = targetHeight * aspectRatio;
  } <span>else</span> {
    targetHeight = targetWidth / aspectRatio;
  }

  targetWidth = <span>Math</span>.floor(targetWidth);
  targetHeight = <span>Math</span>.floor(targetHeight);

  <span>const</span> canvas = <span>document</span>.createElement(<span>&#34;canvas&#34;</span>);
  canvas.width = targetWidth;
  canvas.height = targetHeight;
  <span>const</span> ctx = canvas.getContext(<span>&#34;2d&#34;</span>, { willReadFrequently: <span>true</span> });

  <span>if</span> (!ctx) {
    <span>throw</span> <span>&#34;failed to create context&#34;</span>;
  }

  <span>const</span> frames: <span>Uint8ClampedArray</span>[] = [];

  video.currentTime = <span>0</span>;
  <span>const</span> duration = video.duration;
  <span>const</span> interval = <span>1</span> / fps;

  <span>while</span> (video.currentTime &lt; duration) {
    ctx.drawImage(video, <span>0</span>, <span>0</span>, targetWidth, targetHeight);
    <span>const</span> frameData = ctx.getImageData(<span>0</span>, <span>0</span>, targetWidth, targetHeight).data;
    frames.push(frameData);
    video.currentTime += interval;
    <span>await</span> <span>new</span> <span>Promise</span>(<span>(<span>resolve</span>) =&gt;</span>
      video.addEventListener(<span>&#34;seeked&#34;</span>, resolve, { once: <span>true</span> })
    );
  }

  <span>return</span> { frames, width: targetWidth, height: targetHeight };
}
</code></pre>
<p>It would be good refactor to reuse the canvas and video elements. An interesting note is that this doesn&#39;t wait for fully loading the video. Instead, it will &#34;seek&#34; to each frame it is sampling from based on the input fps. The downside is that this ends up being a request waterfall as each seek restarts the stream. There is a way where you could cache multiple video and canvas elements and use them to make the frames loadable in parallel.</p>
<p>Today, I am not captain planet so this will be left as is.</p>
<p>Next is to reduce this giant array of raw frame data down into several big monster css animation strings, one for each pixel.</p>
<pre><code><span>const</span> pixelKeyframes: <span>Array</span>&lt;<span>string</span>[]&gt; = [];

<span>for</span> (<span>const</span> frame <span>of</span> frames) {
  <span>for</span> (<span>let</span> x = <span>0</span>; x &lt; width; x++) {
    <span>for</span> (<span>let</span> y = <span>0</span>; y &lt; height; y++) {
      <span>const</span> i = y * <span>Math</span>.floor(width) + x;
      <span>const</span> fi = i * <span>4</span>;
      <span>const</span> r = frame[fi];
      <span>const</span> g = frame[fi + <span>1</span>];
      <span>const</span> b = frame[fi + <span>2</span>];
      <span>const</span> a = frame[fi + <span>3</span>];
      <span>const</span> hex = rgbToHex(r, g, b);
      <span>if</span> (!pixelKeyframes[i]) {
        pixelKeyframes[i] = [];
      }
      pixelKeyframes[i].push(hex);
    }
  }
}

<span>const</span> css = generateCssKeyframes(pixelKeyframes, frames.length);
</code></pre>
<p>This step in theory could be removed but I found it easier to step away from raw bytes. The generate key frame function was helped in part by gypity. I say this because I hate the code it made but it worked after a few tweaks.</p>
<p>In the previous examples I was in react land. I got sick of it and decided to create the html in plain js. I tried css grids as I wanted easy scaling and aspect ratio control. It didn&#39;t work well. Instead, I had to write way too much js to position it all just right regardless of video source size, downsampled size, container size, or screen size. It works fine as long as you don&#39;t resize your window.</p>
<p>Here is the bit which positions the divs and sets their animation name.</p>
<pre><code><span>for</span> (<span>let</span> index = <span>0</span>; index &lt; width * height; index++) {
  <span>const</span> gridItem = <span>document</span>.createElement(<span>&#34;div&#34;</span>);
  gridItem.id = <span>`pixel-<span>${index}</span>`</span>;
  gridItem.style.animationName = <span>`pixel-<span>${index}</span>`</span>;

  <span>const</span> x = (index % width) * scaleX + targetWidth / <span>2</span> - (width * scaleX) / <span>2</span>;
  <span>const</span> y = <span>Math</span>.floor(index / width) * scaleY + targetHeight / <span>2</span> - (height * scaleY) / <span>2</span>;
  gridItem.style.left = <span>`<span>${x}</span>px`</span>;
  gridItem.style.top = <span>`<span>${y}</span>px`</span>;

  gridContainer.appendChild(gridItem);
}
</code></pre>
<p>That is some ugly ass code. Keep in mind the pixels are in a flat array hence the indexing.</p>
<p>Here is a video with a target fps of 5, downscaled 98%, and rounded pixels. It may take a few seconds to load if you are on chrome.</p>

<p>Speaking of chrome. Safari is much faster. Like 30x faster, maybe more. It both handles more animated divs but also can handle 100x larger css strings. Chrome will crash pretty quick when the fps or resolution is bumped up. It doesn&#39;t matter which one since it seems that the css string is too big for chrome to handle. Safari also doesn&#39;t restart the request stream when seeking video playback so parsing the video is also much faster.</p>
<p>It is pretty hilarious that Safari owns chrome so bad here. It isn&#39;t even a competition. <a href="https://dgerrells.com/video-to-css/example5" target="_blank">This example</a> is scaled up to 8 fps at 6% native resolution but be warned, it sometimes crashes on chrome. Here is a video for those who cannot run it.</p>
<iframe width="100%" height="500px" src="https://www.youtube.com/embed/dIFYa6ckcQQ" title="css video divs" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>By dropping the resolution the fps can be cranked up to native speed. <a href="https://dgerrells.com/video-to-css/example5video" target="_blank">Here</a> is an example at a lower resolution. The animation is looped without the scroll control. Again, this may crash chromium browsers but should be fine on mobile safari. It will take up to 30s seconds to load on chrome. You can tell that sometimes the playback glitches out a bit. This is a little less obvious when controlled by scroll position.</p>
<p>My partner sent me a video of their cat <a href="https://dgerrells.com/video-to-css/example6" target="_blank">Zombie flipping out</a> and I thought it would be a good example to cssify. Hilarious. If you hold your phone away, it almost looks like a cat. This also shows how the scaling works with different aspect ratios. A scrolly version is <a href="https://dgerrells.com/video-to-css/example6scrolly" target="_blank">here</a> too.</p>
<p>It is worth mentioning that the css generated for this is huge but not stupidly yuge. The examples above can hit almost triple digit megabytes. At native 1080p, let alone 4k, it runs in the many  hundreds of mb. The bottle neck seems to be css string size along with the number of animated divs with Safari doing the best.</p>
<p>One optimization idea to reduce the size of the css string is to skip keyframes if the pixel value is unchanged frame to frame. This could provide a huge reduction depending on the video. My gut says a 60-80% reduction depending on desired quality is a reasonable expectation.</p>
<pre><code><span>const</span> keyframes: <span>string</span>[] = [];

pixelKeyframes.forEach(<span>(<span>frameColors, pixelIndex</span>) =&gt;</span> {
  <span>const</span> pixelAnimation: <span>string</span>[] = [];
  <span>let</span> previousColor: <span>string</span> | <span>null</span> = <span>null</span>;

  frameColors.forEach(<span>(<span>color, frameIndex</span>) =&gt;</span> {
    <span>if</span> (previousColor === <span>null</span> || !isColorSimilar(previousColor, color, <span>.96</span>)) {
      <span>const</span> percent = ((frameIndex / (totalFrames - <span>1</span>)) * <span>100</span>).toFixed(<span>2</span>);
      pixelAnimation.push(<span>`<span>${percent}</span>% { background: <span>${color}</span>; }`</span>);
      previousColor = color;
    }
  });

  <span>const</span> pixelKeyframe = <span>`
      @keyframes pixel-<span>${pixelIndex}</span> {
          <span>${pixelAnimation.join(<span>&#34;\n&#34;</span>)}</span>
      }`</span>;
  keyframes.push(pixelKeyframe);
});

<span>return</span> keyframes.join(<span>&#34;\n&#34;</span>);
</code></pre>
<p>At a 96% similarity check it does cut css video size in half. However, there is some artifacting now. I found that putting a limit on the number of frames skipped reduces the artifacts but doesn&#39;t eliminate it. I am sure sampling more pixels when comparing between frames would help. However, it still doesn&#39;t solve the problem of being overall slow to render.</p>
<p>Like, I still need to have a bunch of divs carefully positioned. Each div has its own animation with keyframes. It doesn&#39;t feel like pure css. Too much html. If only there were some kind of way to render a bunch of pixels on a single div using only css and keyframes. if only...</p>
<h2>going full circle</h2>
<p><img src="https://dgerrells.com/images/memberboxshadows.jpg" alt="southpark meember berries box shadow article" width="100%"/></p><p>Member <a href="https://dgerrells.com/blog/how-not-to-use-box-shadows">box shadows?</a> I member.</p>
<p>Take a div, add a big&#39;ol box shadow string, and then animate the string across keyframes. Each key frame is a frame of the video. This should be much simpler than the before. And it will be pure css. One should be able to slap a class on a div and watch the video go or scroll to animate.</p>
<p>Let&#39;s see if it works.</p>

<p>This is much faster on both chrome and safari. It can handle almost 4x the resolution and framerate. Interestingly, chrome does better with box shadow rendering so if it doesn&#39;t crash parsing the css string it ends up being smoother than safari.</p>
<p>The code is cleaner too.</p>
<pre><code>  <span>const</span> boxShadows: <span>string</span>[] = [];

  <span>for</span> (<span>let</span> y = <span>0</span>; y &lt; height; y++) {
    <span>for</span> (<span>let</span> x = <span>0</span>; x &lt; width; x++) {
      <span>const</span> index = (y * width + x) * <span>4</span>;
      <span>const</span> r = frameData[index];
      <span>const</span> g = frameData[index + <span>1</span>];
      <span>const</span> b = frameData[index + <span>2</span>];
      <span>const</span> hexColor = rgbToHex(r, g, b);
      boxShadows.push(<span>`<span>${x}</span>px <span>${y}</span>px <span>${hexColor}</span>`</span>);
    }
  }

  <span>const</span> step = (frameIndex / (totalFrames - <span>1</span>)) * <span>100</span>;
  <span>return</span> <span>`<span>${step.toFixed(<span>2</span>)}</span>% {box-shadow:<span>${boxShadows.join(<span>&#34;,&#34;</span>)}</span>;}`</span>;
</code></pre>
<p>Creating the box shadow keyframes is pretty simple assuming each shadow is a single pixel.</p>
<p>The pure css string for this is as follows.</p>
<pre><code><span>const</span> css = <span>`
  .cssToVideo {
    position: absolute;
    top: -1px;
    left: -1px;
    overflow: visible;
    width: 1px;
    height: 1px;
    animation: cssToVideo linear <span>${duration}</span>s both infinite;
    <span>${
      animateWithScroll ? <span>`
      animation-duration: 1s;
      animation-delay: calc(var(--scroll, 0) * -1s);
      animation-play-state: paused;   
    `</span> : <span>``</span>
    }</span>
  }
  @keyframes cssToVideo {\n <span>${cssKeyframes.join(<span>&#34;\n&#34;</span>)}</span> \n}
`</span>;
</code></pre>
<p>Now strap that bad boy <code>cssToVideo</code> class onto a div and you are off to the races. There is a little more glue code which adds divs, css, scroll listener, etc but the above alone will play a pure css video. So stupid. I love it.</p>
<p>But I know what you are thinking. Right now you have a bunch of videos which are begging to be transformed into pure css. You want a little app where you can upload a video and preview different resolutions, fps, etc, which will spit out a css string for your video just like all those other online css tools. <a target="_blank" href="https://dgerrells.com/video-to-css">Say no more fam</a>.</p>
<p>Ok, the <a target="_blank" href="https://dgerrells.com/video-to-css">app</a> was a pain to make. I am going to skip &#34;how&#34; it was made. What is important is that you can now convert videos to pure css strings to use on your startup&#39;s next landing page. Don&#39;t worry about the fact most of your user&#39;s browsers will crash. That isn&#39;t important right now. What is important is that people understand what you stand for. You are willing to use the most esoteric and nonsensical technology for no practical reasons but to send a message to your customers and your competition, especially the competition. Style over substance wins the battle 50% of the time every time. Never change.</p>
<p>Perhaps if pure css videos catch on, I will update the app to include more features. Maybe even create special file format for it called <code>.vibcss</code> along with an RFC because god knows the web needs more &#34;standards&#34;. It is worth noting that on iphone&#39;s there seems to be a hard limit on resolution but not as much css size. So as long as the resolution is small enough, you should be able to have hundreds of megabytes of css.</p>
<h2>extra mile</h2>
<p>When I showed my buddy the app he was like, &#34;should dump playbakc to gif&#34;. I assumed he meant that there should be a way to save your cssified video into an animated gif. To keep with the spirit here, the goal is to take the previously generated css string and convert it to an animated gif. There is a <code>gif.js</code> library with a canvas like api for creating gifs. This is perfect because all the pixel data is in the css string if I can just parse it out. I tried getting gypitydoodah to AI me up some parsing code but it failed.</p>
<p>When in doubt, split split slice, map, split slice map map, and finally map again.</p>
<pre><code><span><span>function</span> <span>extractBoxShadowColorsAsUint8Arrays</span>(<span>css: <span>string</span></span>) </span>{
  <span>return</span> css
    .split(<span>&#34;@keyframes cssToVideo {&#34;</span>)[<span>1</span>]
    .split(<span>&#34;box-shadow&#34;</span>)
    .slice(<span>1</span>)
    .map(<span>(<span>shadow</span>) =&gt;</span>
      shadow
        .split(<span>&#34; #&#34;</span>)
        .slice(<span>1</span>)
        .map(<span>(<span>pixel</span>) =&gt;</span> pixel.split(<span>/,|;/g</span>)[<span>0</span>])
        .map(<span>(<span>pixel</span>) =&gt;</span> hexToRgb(pixel))
    )
    .map(<span>(<span>frame</span>) =&gt;</span> {
      <span>const</span> raw = <span>new</span> <span>Uint8ClampedArray</span>(frame.length * <span>4</span>);
      frame.forEach(<span>(<span>pixel, i</span>) =&gt;</span> {
        raw[i * <span>4</span>] = pixel[<span>0</span>];
        raw[i * <span>4</span> + <span>1</span>] = pixel[<span>1</span>];
        raw[i * <span>4</span> + <span>2</span>] = pixel[<span>2</span>];
        raw[i * <span>4</span> + <span>3</span>] = <span>255</span>;
      });
      <span>return</span> raw;
    });
}
</code></pre>
<p>Is this fancy? No. Is it Brittle? Probably. Does it work? kinda.</p>
<p>I kept the original gyptiy function name <code>extractBoxShadowColorsAsUint8Arrays</code> because it reminds me of java. <em>sips coffee</em></p>
<p>To support keeping the preview resolution scale I need to render an image to another canvas scaling it up making sure to turn off image smoothing to keep the pixelated style. Graphics people call this kind of image scaling <code>nearest neighbor</code>.</p>
<pre><code><span><span>function</span> <span>framesToGif</span>(<span>
  frames: <span>Uint8ClampedArray</span>[],
  originalWidth: <span>number</span>,
  originalHeight: <span>number</span>,
  scaleFactor: <span>number</span>,
  delay: <span>number</span>
</span>) </span>{
  <span>return</span> <span>new</span> <span>Promise</span>&lt;<span>string</span>&gt;(<span>(<span>resolve, reject</span>) =&gt;</span> {
    <span>const</span> width = originalWidth * scaleFactor;
    <span>const</span> height = originalHeight * scaleFactor;

    <span>const</span> originalCanvas = <span>document</span>.createElement(<span>&#34;canvas&#34;</span>);
    <span>const</span> scaledCanvas = <span>document</span>.createElement(<span>&#34;canvas&#34;</span>);
    <span>const</span> originalCtx = originalCanvas.getContext(<span>&#34;2d&#34;</span>, {
      willReadFrequently: <span>true</span>, 
    });
    <span>const</span> scaledCtx = scaledCanvas.getContext(<span>&#34;2d&#34;</span>, {
      willReadFrequently: <span>true</span>, 
    });

    originalCanvas.width = originalWidth;
    originalCanvas.height = originalHeight;
    scaledCanvas.width = width;
    scaledCanvas.height = height;
    scaledCtx.imageSmoothingEnabled = <span>false</span>; 

    <span>const</span> gif = <span>new</span> GIF({
      workers: <span>2</span>, 
      quality: <span>10</span>, 
      width: width,
      height: height,
    });

    <span>const</span> imageData = originalCtx.createImageData(
      originalWidth,
      originalHeight
    );

    frames.forEach(<span>(<span>frameData</span>) =&gt;</span> {
      imageData.data.set(frameData);
      originalCtx.putImageData(imageData, <span>0</span>, <span>0</span>);
      scaledCtx.drawImage(originalCanvas,<span>0</span>,<span>0</span>,originalWidth,originalHeight,<span>0</span>,<span>0</span>,width,height);
      gif.addFrame(scaledCtx, { delay, copy: <span>true</span> }); 
    });

    gif.on(<span>&#34;finished&#34;</span>, <span><span>function</span> (<span>blob</span>) </span>{
      resolve( URL.createObjectURL(blob));
    });

    gif.render();
  });
}
</code></pre>
<p>Then to put them together.</p>
<pre><code><span>export</span> <span>async</span> <span><span>function</span> <span>cssToGif</span>(<span>
  css: <span>string</span>,
  width: <span>number</span>,
  height: <span>number</span>,
  scale: <span>number</span>,
  fps: <span>number</span>
</span>) </span>{
  <span>const</span> frames = extractBoxShadowColorsAsUint8Arrays(css);
  <span>const</span> url = <span>await</span> framesToGif(frames, width, height, scale, (<span>1</span> / fps) * <span>1000</span>);
  <span>window</span>.open(url);
}
</code></pre>
<p>So simple. Now, you too can convert a video into pure css and then convert that css into a gif. It is basically a video to gif app. It is critically important we don&#39;t skip the pure css step as style matters.</p>
<p><a target="_blank" href="https://dgerrells.com/video-to-css">Here</a> is a link to the app again. Go ahead, make some gifs. Don&#39;t worry. Your browser loves css, like alot. I promise.</p>
<p>I will leave you with Zombie donning her helm before an attack as a <code>gif</code> made from <code>css</code> made from a video.</p>
<p><img alt="cute cat putting on box for helmet before attacking" src="https://dgerrells.com/images/zombieattack.gif" height="280px"/></p><p>Until next time.</p><h2>where to find me?</h2></div></div>
  </body>
</html>
