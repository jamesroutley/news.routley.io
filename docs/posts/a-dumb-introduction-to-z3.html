<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://asibahi.github.io/thoughts/a-gentle-introduction-to-z3/">Original</a>
    <h1>A dumb introduction to z3</h1>
    
    <div id="readability-page-1" class="page"><div><p>Recently I have come across a nice article: <a href="https://buttondown.com/hillelwayne/archive/many-hard-leetcode-problems-are-easy-constraint/">Many Hard Leetcode Problems are Easy Constraint Problems</a>, and I figured, I really should learn how to use these things! What else do I really have to do? I have had use for solvers (or as they are commonly called: theorem provers) <a href="https://asibahi.github.io/thoughts/the-hanging-gardens-problem/">In a previous article</a>, but then I tried to prove the things with good old algorithms. I looked at <code>z3</code> at the time, but found the whole concept a bit too opaque. Now however, it seemed a bit easier to get into.</p>
<p>To be clear, as of writing these words, I have only been looking at <code>z3</code> reading material for two days. I am in no way an expert, and I have not written anything more complex than a solver for the change counter problem (the first example in the article listed above). So I am writing this really knowing nothing about the underlying theory, theorem provers, or whatever the hell &#34;unification&#34; is. There is a good chance you know more about this than I do.</p>
<p>There are <code>z3</code> bindings in many popular languages. I will be using <a href="https://docs.rs/z3/latest/z3/"><code>z3</code>&#39;s Rust bindings</a>, because I am more comfortable in Rust than, say, Python or JavaScript. The examples I worked with to understand <code>z3</code> however, can be found in two nice documents:</p>
<ol>
<li><a href="https://z3prover.github.io/papers/programmingz3.html">First is in Python</a></li>
<li><a href="https://microsoft.github.io/z3guide/programming/Z3%20JavaScript%20Examples/">Second in JavaScript</a></li>
</ol>
<h2 id="what-are-solvers">What are Solvers?</h2>
<p>Solvers are a class of .. tools? libraries? where you input some rules and constraints and have the tool just .. solve it for you. It is not going to be a faster or more optimized solution than a custom made algorithm, but it is much easier to change the rules on the fly.</p>
<p>There are many real world uses. They are often used for scheduling and resource allocation problems. Consider the common scenario of a school schedule: Mary cannot work on Tuesdays because she needs to take care of her father; John lives far so he cannot give classes before 10; Class 3-A is full of nerds so their math hours are double; city council regulates no outdoor activity after 12; Susan and Sarah hate each other so you should not have them teach the same class; etc. You can either have two teachers work on it for a week, or just pop it in a solver!</p>
<p>The <a href="https://www.minizinc.org">MiniZinc homepage</a> (another popular solver) has a couple of nice examples: a seating chart, rostering, vehicle routing, grid coloring.</p>
<p>On that note, you might wonder: why did I go with <code>z3</code> when MiniZinc has a more colorful homepage and is actually referenced by the article linked at the start of this article? The answer is because <code>z3</code> has bindings in Rust. That is pretty much it.</p>
<h2 id="a-note-on-terminology">A Note on Terminology</h2>
<p>Documentation on <code>z3</code> and its API use a lot of jargon, which makes the whole thing really difficult to wade into without a previous background. I will explain things as I understand when I get to them, but two things really stand out.</p>
<p>The first is the word <code>Sort</code>. You see this in the context of arrays and function declarations (we will get to those, I hope). But it has nothing to do with .. well .. sorting. <code>Sort</code> is just the jargon word for <em>types</em>.</p>
<p>The second one is <strong>constants</strong>. They are not what a normal person would call constants: they are actually the knobs the solvers use to solve problems. There are two types of constants: <em>free</em>, which are what one would call variables; and <em>interpreted</em>, which is when you&#39;d type an integer literal and clever type machinations turns it into a constant in the solver.</p>
<p>Note that also solvers do not work within the regular type system of the programming language. They have their own types (sorry, sorts), and operations that may or may not map nicely to the language&#39;s types and operations. Much of the actual code you are writing is about expressing things in the target solver&#39;s language. <code>z3</code> uses a language called &#34;SMT-LIB2&#34; (henceforth called <code>smt2</code>), apparently. And you can actually write your constraints immediately in said language and have the library consume it. Much of what the bindings is take your code and translate internally to this language before feeding it to the solver.</p>
<hr/>
<h2 id="a-simple-equation">A Simple Equation</h2>
<p>Let&#39;s start with what might be the simplest, dumbest equation. Solve for <code>x</code>:</p>
<pre><code><span>x + 4 = 7
</span></code></pre>
<p>Yes, a child (literally) can solve this. But it is nice. Here is the Rust program to solve it.</p>
<pre data-lang="rs"><code data-lang="rs"><span>use </span><span>z3::{Solver, ast::Int};
</span><span>fn </span><span>main</span><span>() {
</span><span>	</span><span>let</span><span> solver </span><span>= </span><span>Solver::new();
</span><span>
</span><span>	</span><span>// define the variable.
</span><span>	</span><span>let</span><span> x </span><span>= </span><span>Int::new_const(</span><span>&#34;x&#34;</span><span>);
</span><span>
</span><span>	</span><span>// define the equation
</span><span>	solver.</span><span>assert</span><span>((</span><span>&amp;</span><span>x </span><span>+ </span><span>4</span><span>).</span><span>eq</span><span>(</span><span>7</span><span>));
</span><span>
</span><span>	</span><span>// run the solver
</span><span>	</span><span>_ =</span><span> solver.</span><span>check</span><span>();
</span><span>	</span><span>let</span><span> model </span><span>=</span><span> solver.</span><span>get_model</span><span>().</span><span>unwrap</span><span>();
</span><span>
</span><span>	println!(</span><span>&#34;</span><span>{model:?}</span><span>&#34;</span><span>);
</span><span>}
</span></code></pre>
<p>This prints out the solution. <code>x</code> equals three. Who would have guessed?</p>
<pre data-lang="smt2"><code data-lang="smt2"><span>x -&gt; </span><span>3
</span></code></pre>
<p>The Rust bindings have some nice ergonomics here. You can simply do <code>&amp;x + 4</code> and it would do all the bookkeeping behind closed doors to transform the <code>4</code> (and the <code>7</code>) into an interpreted constant and have them inserted into the internal model.</p>
<p>The reason you have to pass in a string in <code>new_const</code> is that this is the name given to the variable in <code>smt2</code>. It does not have to be <code>&#34;x&#34;</code>, it can be anything. Why do the bindings not autogenerate the name for you? Who knows.</p>
<p>If you print the solver (as in <code>println!(&#34;{solver:?}&#34;);</code>), you will get the following output in the <code>smt2</code>.</p>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>x </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>+</span><span> x </span><span>4</span><span>) </span><span>7</span><span>))
</span></code></pre>
<p>Note that the variable you declared is declared as a <em>function</em>. A free constant is basically a function that takes no input and gives an output (here of <del>type</del> sort <code>Int</code>). The solver finds which version of the function satisfies the assertions. This also explains the arrow in <code>x -&gt; 3</code> earlier. <code>x</code> <em>evaluates to</em> 3.</p>
<hr/>
<h2 id="a-jump-in-complexity">A Jump in Complexity</h2>
<p>In school, jumping from solving equations with a single variable to equations with two variables was a real jump on complexity. Everything was doubled! Here is a pair of equations we will try to solve next:</p>
<pre><code><span>x + y = 17
</span><span>y = 2 * x
</span></code></pre>
<p>Here is the program. I am going to print the result of <code>solver.check()</code> first, tho. I just made up those numbers!</p>
<pre data-lang="rs"><code data-lang="rs"><span>use </span><span>z3::{Solver, ast::Int};
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>	</span><span>let</span><span> solver </span><span>= </span><span>Solver::new();
</span><span>
</span><span>	</span><span>// define the variable.
</span><span>	</span><span>let</span><span> x </span><span>= </span><span>Int::new_const(</span><span>&#34;x&#34;</span><span>);
</span><span>	</span><span>let</span><span> y </span><span>= </span><span>Int::new_const(</span><span>&#34;y&#34;</span><span>);
</span><span>
</span><span>	</span><span>// define the equation
</span><span>	solver.</span><span>assert</span><span>((</span><span>&amp;</span><span>x </span><span>+ &amp;</span><span>y).</span><span>eq</span><span>(</span><span>17</span><span>));
</span><span>	solver.</span><span>assert</span><span>((</span><span>&amp;</span><span>x </span><span>* </span><span>2</span><span>).</span><span>eq</span><span>(</span><span>&amp;</span><span>y));
</span><span>
</span><span>	println!(</span><span>&#34;</span><span>{solver:?}</span><span>&#34;</span><span>);
</span><span>
</span><span>	</span><span>let</span><span> c </span><span>=</span><span> solver.</span><span>check</span><span>();
</span><span>	println!(</span><span>&#34;; </span><span>{c:?}</span><span>&#34;</span><span>);
</span><span>}
</span></code></pre>
<p>This prints out the following:</p>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>y </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>x </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>+</span><span> x y) </span><span>17</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>*</span><span> x </span><span>2</span><span>) y))
</span><span>
</span><span>; Unsat
</span></code></pre>
<p>Oh it is <code>Unsat</code>. Unsatisfiable. Bummer. This means this cannot be solved as defined.</p>
<p>Let&#39;s try changing the type to <code>Real</code>. The <code>Real</code> type does not have the same nice ergonomics as <code>Int</code> apparently, so the code will look slightly uglier. This is the new updated code.</p>
<pre data-lang="rs"><code data-lang="rs"><span>use </span><span>z3::{Solver, ast::Real};
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>	</span><span>let</span><span> solver </span><span>= </span><span>Solver::new();
</span><span>
</span><span>	</span><span>// define the variable.
</span><span>	</span><span>let</span><span> x </span><span>= </span><span>Real::new_const(</span><span>&#34;x&#34;</span><span>);
</span><span>	</span><span>let</span><span> y </span><span>= </span><span>Real::new_const(</span><span>&#34;y&#34;</span><span>);
</span><span>
</span><span>	</span><span>let</span><span> seventeen </span><span>= </span><span>Real::from_rational(</span><span>17</span><span>, </span><span>1</span><span>);
</span><span>	</span><span>let</span><span> two </span><span>= </span><span>Real::from_rational(</span><span>2</span><span>, </span><span>1</span><span>);
</span><span>
</span><span>	</span><span>// define the equation
</span><span>	solver.</span><span>assert</span><span>((</span><span>&amp;</span><span>x </span><span>+ &amp;</span><span>y).</span><span>eq</span><span>(</span><span>&amp;</span><span>seventeen));
</span><span>	solver.</span><span>assert</span><span>((</span><span>&amp;</span><span>x </span><span>* &amp;</span><span>two).</span><span>eq</span><span>(</span><span>&amp;</span><span>y));
</span><span>
</span><span>	println!(</span><span>&#34;</span><span>{solver:?}</span><span>&#34;</span><span>);
</span><span>
</span><span>	</span><span>let</span><span> c </span><span>=</span><span> solver.</span><span>check</span><span>();
</span><span>	println!(</span><span>&#34;; </span><span>{c:?}</span><span>&#34;</span><span>);
</span><span>}
</span></code></pre>
<p>Which prints</p>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>y </span><span>() </span><span>Real</span><span>)
</span><span>(</span><span>declare-fun </span><span>x </span><span>() </span><span>Real</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>+</span><span> x y) </span><span>17</span><span>.</span><span>0</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>*</span><span> x </span><span>2</span><span>.</span><span>0</span><span>) y))
</span><span>
</span><span>; Sat
</span></code></pre>
<p>Excellent! Using <code>get_model()</code> and printing the model as before gives us the following answer, presented as a nice rational number.</p>
<pre data-lang="smt2"><code data-lang="smt2"><span>y -&gt; (/ </span><span>34</span><span>.</span><span>0 3</span><span>.</span><span>0</span><span>)
</span><span>x -&gt; (/ </span><span>17</span><span>.</span><span>0 3</span><span>.</span><span>0</span><span>)
</span></code></pre>
<p>To actually extract the values programmatically, instead of debug printing <code>model</code>, requires some song and dance with the API, but it is simple, really. This is what it would look like.</p>
<pre data-lang="rust"><code data-lang="rust"><span>// to avoid panicking on unsatisfiable models
</span><span>if let </span><span>z3::SatResult::Sat </span><span>=</span><span> solver.</span><span>check</span><span>() {
</span><span>	</span><span>let</span><span> model </span><span>=</span><span> solver.</span><span>get_model</span><span>().</span><span>unwrap</span><span>();
</span><span>
</span><span>	</span><span>// do not ask me what the `true` is for. I don&#39;t know.
</span><span>	</span><span>let</span><span> x </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>x, </span><span>true</span><span>).</span><span>unwrap</span><span>().</span><span>approx_f64</span><span>();
</span><span>	</span><span>let</span><span> y </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>y, </span><span>true</span><span>).</span><span>unwrap</span><span>().</span><span>approx_f64</span><span>();
</span><span>
</span><span>	println!(</span><span>&#34;x: </span><span>{x:.3}\t</span><span>y: </span><span>{y:.3}</span><span>&#34;</span><span>);
</span><span>}
</span></code></pre>
<p>Which prints</p>
<pre><code><span>x: 5.667	y: 11.333
</span></code></pre>
<p>Nice. Isn&#39;t this grand?</p>
<hr/>
<h2 id="multiple-solutions">Multiple Solutions</h2>
<p>As I am sure you know from your high school math, some equations have multiple solutions. Here is a simple one.</p>
<pre><code><span>x * x = 4
</span></code></pre>
<p>The Rust bindings have a nice method for getting multiple solutions out of a solver, simply called <code>solutions</code>. It works similarly to <code>model.eval()</code> above, and takes the same parameters with the same output. Here is the complete program. (I am going back to <code>Int</code> because I am not cool enough for <code>Real</code> numbers.)</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>z3::{Solver, ast::Int};
</span><span>fn </span><span>main</span><span>() {
</span><span>	</span><span>let</span><span> solver </span><span>= </span><span>Solver::new();
</span><span>	</span><span>let</span><span> x </span><span>= </span><span>Int::new_const(</span><span>&#34;x&#34;</span><span>);
</span><span>
</span><span>	solver.</span><span>assert</span><span>((</span><span>&amp;</span><span>x </span><span>* &amp;</span><span>x).</span><span>eq</span><span>(</span><span>4</span><span>));
</span><span>	println!(</span><span>&#34;</span><span>{solver:?}</span><span>&#34;</span><span>);
</span><span>
</span><span>	</span><span>// This terminates when `check` does not return `Sat`
</span><span>	</span><span>for </span><span>(idx, s) </span><span>in</span><span> solver.</span><span>solutions</span><span>(x, </span><span>true</span><span>).</span><span>enumerate</span><span>() {
</span><span>		</span><span>let</span><span> s </span><span>=</span><span> s.</span><span>as_i64</span><span>().</span><span>unwrap</span><span>();
</span><span>		println!(</span><span>&#34;;</span><span>{}</span><span>:</span><span>\t{s}</span><span>&#34;</span><span>, idx </span><span>+ </span><span>1</span><span>);
</span><span>	}
</span><span>}
</span></code></pre>
<p>Which prints:</p>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>x </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>*</span><span> x x) </span><span>4</span><span>))
</span><span>
</span><span>;1:	-2
</span><span>;2:	2
</span></code></pre>
<p>I am not clear really on how to get multiple solutions with the regular <code>check</code> followed by <code>get_model</code> method, but this one is easy enough to use. Also, some problems might have infinitely many solutions, so it is advisable to use <code>take</code> with the <code>solutions</code> iterator. To demonstrate, I will use the circle equation.</p>
<pre><code><span>x * x + y * y = 25
</span></code></pre>
<p>Here is the straightforward script followed by the printed out result. Note that the <code>fresh_const</code> API creates a unique name for every invocation.</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>z3::{Solver, ast::Int};
</span><span>fn </span><span>main</span><span>() {
</span><span>	</span><span>let</span><span> solver </span><span>= </span><span>Solver::new();
</span><span>
</span><span>	</span><span>let</span><span> x </span><span>= </span><span>Int::fresh_const(</span><span>&#34;x&#34;</span><span>);
</span><span>	</span><span>let</span><span> y </span><span>= </span><span>Int::fresh_const(</span><span>&#34;x&#34;</span><span>);
</span><span>
</span><span>	</span><span>let</span><span> area </span><span>= &amp;</span><span>x </span><span>* &amp;</span><span>x </span><span>+ &amp;</span><span>y </span><span>* &amp;</span><span>y;
</span><span>	solver.</span><span>assert</span><span>(area.</span><span>eq</span><span>(</span><span>25</span><span>));
</span><span>
</span><span>	println!(</span><span>&#34;</span><span>{solver:?}</span><span>&#34;</span><span>);
</span><span>
</span><span>	</span><span>for </span><span>(idx, (x,y)) </span><span>in</span><span> solver.</span><span>solutions</span><span>((x,y), </span><span>true</span><span>).</span><span>enumerate</span><span>() {
</span><span>		</span><span>let</span><span> x </span><span>=</span><span> x.</span><span>as_i64</span><span>().</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> y </span><span>=</span><span> y.</span><span>as_i64</span><span>().</span><span>unwrap</span><span>();
</span><span>		println!(</span><span>&#34;; </span><span>{}</span><span>:</span><span>\t{x:&gt;2}</span><span>,{y:?2} &#34;</span><span>, idx </span><span>+ </span><span>1</span><span>);
</span><span>	}
</span><span>}
</span></code></pre>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>x!1 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>x!0 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>+</span><span> (</span><span>*</span><span> x!</span><span>0</span><span> x!</span><span>0</span><span>) (</span><span>*</span><span> x!</span><span>1</span><span> x!</span><span>1</span><span>)) </span><span>25</span><span>))
</span><span>
</span><span>; 1:	 0, 5
</span><span>; 2:	-5, 0
</span><span>; 3:	-3,-4
</span><span>; 4:	-4,-3
</span><span>; 5:	 0,-5
</span><span>; 6:	 3,-4
</span><span>; 7:	 4,-3
</span><span>; 8:	 5, 0
</span><span>; 9:	 3, 4
</span><span>; 10:	 4, 3
</span><span>; 11:	-3, 4
</span><span>; 12:	-4, 3
</span></code></pre>
<p>This goes without saying, but if I used the <code>Real</code> type in this example it would generate infinite solutions.</p>
<hr/>
<h2 id="coin-change-problem">Coin Change Problem</h2>
<p>The Coin Change problem is a simple one: given a list of denominations and a total, find the smallest number of coins that add up to said total. Emphasis on <em>smallest</em>. Unlike previous problems, this is an optimization problem. We are looking for a solution that satisfies specific criteria instead of just <em>a</em> solution. Conveniently enough, <code>z3</code> provides an <code>Optimize</code> object which we can use to optimize.</p>
<p>Let us set up the parameters of the problem in plain language. The denominations we have are 1, 5, and 10. We need to give 37 money in the least amount of coins. This is simple enough that we can know the solution is three 10 coins, one 5 coin, and two 1 coins. Let&#39;s see if we can get the same result. As usual, code followed by output:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>z3::{Optimize, ast::Int};
</span><span>fn </span><span>main</span><span>() {
</span><span>	</span><span>let</span><span> opt </span><span>= </span><span>Optimize::new();
</span><span>
</span><span>	</span><span>let</span><span> c1 </span><span>= </span><span>Int::new_const(</span><span>&#34;c1&#34;</span><span>);
</span><span>	</span><span>let</span><span> c5 </span><span>= </span><span>Int::new_const(</span><span>&#34;c5&#34;</span><span>);
</span><span>	</span><span>let</span><span> c10 </span><span>= </span><span>Int::new_const(</span><span>&#34;c10&#34;</span><span>);
</span><span>
</span><span>	</span><span>let</span><span> total </span><span>= </span><span>(</span><span>&amp;</span><span>c1 </span><span>* </span><span>1</span><span>) </span><span>+ </span><span>(</span><span>&amp;</span><span>c5 </span><span>* </span><span>5</span><span>) </span><span>+ </span><span>(</span><span>&amp;</span><span>c10 </span><span>* </span><span>10</span><span>);
</span><span>	</span><span>let</span><span> count </span><span>= &amp;</span><span>c1 </span><span>+ &amp;</span><span>c5 </span><span>+ &amp;</span><span>c10;
</span><span>
</span><span>	opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>total.</span><span>eq</span><span>(</span><span>37</span><span>));
</span><span>	opt.</span><span>minimize</span><span>(</span><span>&amp;</span><span>count);
</span><span>
</span><span>	println!(</span><span>&#34;</span><span>{opt:?}</span><span>&#34;</span><span>);
</span><span>
</span><span>	</span><span>if let </span><span>z3::SatResult::Sat </span><span>=</span><span> opt.</span><span>check</span><span>(</span><span>&amp;</span><span>[]) {
</span><span>		</span><span>let</span><span> model </span><span>=</span><span> opt.</span><span>get_model</span><span>().</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> c1 </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>c1, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> c5 </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>c5, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> c10 </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>c10, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>
</span><span>		println!(</span><span>&#34;; c1: </span><span>{c1:?}</span><span>, c5: </span><span>{c5:?}</span><span>, c10: </span><span>{c10:?}</span><span>&#34;</span><span>);
</span><span>	} </span><span>else </span><span>{
</span><span>		println!(</span><span>&#34;; woe for us&#34;</span><span>);
</span><span>	}
</span><span>}
</span></code></pre>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>c10 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>c5 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>c1 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>+</span><span> (</span><span>*</span><span> c1 </span><span>1</span><span>) (</span><span>*</span><span> c5 </span><span>5</span><span>) (</span><span>*</span><span> c10 </span><span>10</span><span>)) </span><span>37</span><span>))
</span><span>(minimize (</span><span>+</span><span> c1 c5 c10))
</span><span>(</span><span>check-sat</span><span>)
</span><span>
</span><span>; c1: 37, c5: 0, c10: 0
</span></code></pre>
<p>Oops. This cannot be right.</p>
<p>I do not really understand why the answer is so nonsensical here. The problem is that <code>Int</code> really spans the entire natural integers range, so it is accounting for negative amounts of coins. This still does not explain how the optimal solution given is 37 coins. (If you can explain, please let me know.)</p>
<p>The solution for this is to constrain the amount of coins to be non-negative. So let&#39;s do that. Add these assertions somewhere before <code>check</code>, and Bob&#39;s your uncle.</p>
<pre data-lang="rust"><code data-lang="rust"><span>opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>c1.</span><span>ge</span><span>(</span><span>0</span><span>));
</span><span>opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>c5.</span><span>ge</span><span>(</span><span>0</span><span>));
</span><span>opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>c10.</span><span>ge</span><span>(</span><span>0</span><span>));
</span></code></pre>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>c1 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>c5 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>c10 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>&gt;=</span><span> c1 </span><span>0</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>&gt;=</span><span> c5 </span><span>0</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>&gt;=</span><span> c10 </span><span>0</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>+</span><span> (</span><span>*</span><span> c1 </span><span>1</span><span>) (</span><span>*</span><span> c5 </span><span>5</span><span>) (</span><span>*</span><span> c10 </span><span>10</span><span>)) </span><span>37</span><span>))
</span><span>(minimize (</span><span>+</span><span> c1 c5 c10))
</span><span>(</span><span>check-sat</span><span>)
</span><span>
</span><span>; c1: 2, c5: 1, c10: 3
</span></code></pre>
<p>That&#39;s more like it.  Now let&#39;s try with different denominations. Something like 10. 9, and 1. Note that the optimal solution for 37 would be: one 10 coin, three 9 coins, and no 1 coins. The greedy solution would fail to catch that. Here is the output of printing the optimizer and the result.</p>
<pre data-lang="smt2"><code data-lang="smt2"><span>(</span><span>declare-fun </span><span>c1 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>c9 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>declare-fun </span><span>c10 </span><span>() </span><span>Int</span><span>)
</span><span>(</span><span>assert</span><span> (</span><span>&gt;=</span><span> c1 </span><span>0</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>&gt;=</span><span> c9 </span><span>0</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>&gt;=</span><span> c10 </span><span>0</span><span>))
</span><span>(</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>+</span><span> (</span><span>*</span><span> c1 </span><span>1</span><span>) (</span><span>*</span><span> c9 </span><span>9</span><span>) (</span><span>*</span><span> c10 </span><span>10</span><span>)) </span><span>37</span><span>))
</span><span>(minimize (</span><span>+</span><span> c1 c9 c10))
</span><span>(</span><span>check-sat</span><span>)
</span><span>
</span><span>; c1: 0, c9: 3, c10: 1
</span></code></pre>
<p>Success!</p>
<h2 id="push-and-pop"><code>push</code> and <code>pop</code></h2>
<p>Currently, the total 37 is hardcoded. But what if I want the answers for a number of different totals? Thankfully, you do not need to build the optimizer from scratch for every total. Instead, use the magical functions <code>push</code> and <code>pop</code>. The first one essentially creates a bookmark in the stack of assertions. The second removes everything above said bookmark, and the bookmark. It is simple really. Here are the solutions from 30 to 39, because why not.</p>
<p>Here is the full <code>main</code>. I will spare you the output.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> opt </span><span>= </span><span>Optimize::new();
</span><span>
</span><span>let</span><span> c1 </span><span>= </span><span>Int::new_const(</span><span>&#34;c1&#34;</span><span>);
</span><span>let</span><span> c9 </span><span>= </span><span>Int::new_const(</span><span>&#34;c9&#34;</span><span>);
</span><span>let</span><span> c10 </span><span>= </span><span>Int::new_const(</span><span>&#34;c10&#34;</span><span>);
</span><span>
</span><span>opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>c1.</span><span>ge</span><span>(</span><span>0</span><span>));
</span><span>opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>c9.</span><span>ge</span><span>(</span><span>0</span><span>));
</span><span>opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>c10.</span><span>ge</span><span>(</span><span>0</span><span>));
</span><span>
</span><span>let</span><span> total </span><span>= </span><span>(</span><span>&amp;</span><span>c1 </span><span>* </span><span>1</span><span>) </span><span>+ </span><span>(</span><span>&amp;</span><span>c9 </span><span>* </span><span>9</span><span>) </span><span>+ </span><span>(</span><span>&amp;</span><span>c10 </span><span>* </span><span>10</span><span>);
</span><span>let</span><span> count </span><span>= &amp;</span><span>c1 </span><span>+ &amp;</span><span>c9 </span><span>+ &amp;</span><span>c10;
</span><span>
</span><span>opt.</span><span>minimize</span><span>(</span><span>&amp;</span><span>count);
</span><span>
</span><span>println!(</span><span>&#34;; total</span><span>\t</span><span>count</span><span>\t</span><span>c1</span><span>\t</span><span>c9</span><span>\t</span><span>c10&#34;</span><span>);
</span><span>
</span><span>for</span><span> t </span><span>in </span><span>(</span><span>30</span><span>u32..</span><span>).</span><span>take</span><span>(</span><span>10</span><span>) {
</span><span>	print!(</span><span>&#34;; </span><span>{t}\t</span><span>&#34;</span><span>);
</span><span>
</span><span>	opt.</span><span>push</span><span>();
</span><span>
</span><span>	opt.</span><span>assert</span><span>(</span><span>&amp;</span><span>total.</span><span>eq</span><span>(t));
</span><span>
</span><span>	</span><span>if let </span><span>SatResult::Sat </span><span>=</span><span> opt.</span><span>check</span><span>(</span><span>&amp;</span><span>[]) {
</span><span>		</span><span>let</span><span> model </span><span>=</span><span> opt.</span><span>get_model</span><span>().</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> c1 </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>c1, </span><span>true</span><span>).</span><span>unwrap</span><span>().</span><span>as_u64</span><span>().</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> c9 </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>c9, </span><span>true</span><span>).</span><span>unwrap</span><span>().</span><span>as_u64</span><span>().</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> c10 </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>c10, </span><span>true</span><span>).</span><span>unwrap</span><span>().</span><span>as_u64</span><span>().</span><span>unwrap</span><span>();
</span><span>
</span><span>		</span><span>let</span><span> count </span><span>=</span><span> c1 </span><span>+</span><span> c9 </span><span>+</span><span> c10;
</span><span>
</span><span>		println!(</span><span>&#34;</span><span>{count}\t{c1:?}\t{c9:?}\t{c10:?}</span><span>&#34;</span><span>);
</span><span>	} </span><span>else </span><span>{
</span><span>		println!(</span><span>&#34;; woe for us&#34;</span><span>);
</span><span>	}
</span><span>
</span><span>	opt.</span><span>pop</span><span>(); </span><span>// no RAII for you
</span><span>}
</span></code></pre>
<p>Note that the <code>push</code> and <code>pop</code> API is available for <code>Solver</code> as well. At any rate, back to solving.</p>
<hr/>
<h2 id="sudoku">Sudoku</h2>
<p>This is a significant jump in complexity, so bear with me. We are going to solve a Sudoku. So let&#39;s write the constraints first. We can use Rust&#39;s arrays or <code>Vec</code> to organize our <code>z3.Int</code>s and check their constraints. First, this is the puzzle we are solving:</p>
<pre><code><span>....94.3.
</span><span>...51...7
</span><span>.89....4.
</span><span>......2.8
</span><span>.6.2.1.5.
</span><span>1.2......
</span><span>.7....52.
</span><span>9...65...
</span><span>.4.97....
</span></code></pre>
<p>I will forgo the steps to turn that into a <code>[[Option&lt;u8&gt;;9];9]</code>. Instead the code below will get that info from a <code>get_puzzle()</code> function.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> solver </span><span>= </span><span>Solver::new();
</span><span>
</span><span>// Note that we&#39;re using Rust arrays here. The solver does not really know about them.
</span><span>let</span><span> grid: [[</span><span>_</span><span>; </span><span>9</span><span>]; </span><span>9</span><span>] </span><span>=
</span><span>	array::from_fn(|i| array::from_fn(|j| Int::new_const(format!(</span><span>&#34;x</span><span>{i}{j}</span><span>&#34;</span><span>))));
</span><span>
</span><span>// each cell contains a value 1&lt;=x&lt;=9
</span><span>grid.</span><span>iter</span><span>().</span><span>flatten</span><span>().</span><span>for_each</span><span>(|i| {
</span><span>	solver.</span><span>assert</span><span>(i.</span><span>ge</span><span>(</span><span>1</span><span>) </span><span>&amp;</span><span> i.</span><span>le</span><span>(</span><span>9</span><span>));
</span><span>});
</span><span>
</span><span>// each row contains a digit only once
</span><span>for</span><span> row </span><span>in &amp;</span><span>grid {
</span><span>	solver.</span><span>assert</span><span>(Ast::distinct(row));
</span><span>}
</span><span>
</span><span>// each column contains a digit only once
</span><span>for</span><span> idx </span><span>in </span><span>0</span><span>..</span><span>9 </span><span>{
</span><span>	</span><span>let mut</span><span> col </span><span>= </span><span>Vec</span><span>::with_capacity(</span><span>9</span><span>);
</span><span>	grid.</span><span>iter</span><span>().</span><span>for_each</span><span>(|r| col.</span><span>push</span><span>(r[idx].</span><span>clone</span><span>()));
</span><span>	solver.</span><span>assert</span><span>(Ast::distinct(</span><span>&amp;</span><span>col))
</span><span>}
</span><span>
</span><span>// each 3x3 contains a digit at most once
</span><span>for</span><span> x_s </span><span>in </span><span>(</span><span>0</span><span>..</span><span>9</span><span>).</span><span>step_by</span><span>(</span><span>3</span><span>) {
</span><span>	</span><span>for</span><span> y_s </span><span>in </span><span>(</span><span>0</span><span>..</span><span>9</span><span>).</span><span>step_by</span><span>(</span><span>3</span><span>) {
</span><span>		</span><span>let mut</span><span> square </span><span>= </span><span>Vec</span><span>::with_capacity(</span><span>9</span><span>);
</span><span>		</span><span>for</span><span> x </span><span>in </span><span>(x_s</span><span>..</span><span>).</span><span>take</span><span>(</span><span>3</span><span>) {
</span><span>			</span><span>for</span><span> y </span><span>in </span><span>(y_s</span><span>..</span><span>).</span><span>take</span><span>(</span><span>3</span><span>) {
</span><span>				</span><span>// very nested loop
</span><span>				square.</span><span>push</span><span>(grid[x][y].</span><span>clone</span><span>());
</span><span>			}
</span><span>		}
</span><span>
</span><span>		solver.</span><span>assert</span><span>(Ast::distinct(</span><span>&amp;</span><span>square))
</span><span>	}
</span><span>}
</span><span>
</span><span>// Finally, assert that each cell equals a provided clue in the given puzzle
</span><span>get_puzzle</span><span>().</span><span>iter</span><span>().</span><span>flatten</span><span>().</span><span>zip</span><span>(grid.</span><span>iter</span><span>().</span><span>flatten</span><span>()).</span><span>for_each</span><span>(|(clue, variable)| {
</span><span>	</span><span>if let </span><span>Some</span><span>(clue) </span><span>=</span><span> clue {
</span><span>		solver.</span><span>assert</span><span>(variable.</span><span>eq</span><span>(</span><span>*</span><span>clue));
</span><span>	}
</span><span>});
</span><span>
</span><span>eprintln!(</span><span>&#34;</span><span>{solver:?}</span><span>&#34;</span><span>);
</span></code></pre>
<p>Printing the solver after each step lets you debug whether you have your constraints correctly. The printout is over 200 lines long, so let&#39;s skip that. All we have to do next is to check the value of each cell in <code>grid</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span>if let </span><span>SatResult::Sat </span><span>=</span><span> solver.</span><span>check</span><span>() {
</span><span>	</span><span>let</span><span> model </span><span>=</span><span> solver.</span><span>get_model</span><span>().</span><span>unwrap</span><span>();
</span><span>	</span><span>for</span><span> row </span><span>in</span><span> grid {
</span><span>		</span><span>for</span><span> int </span><span>in</span><span> row {
</span><span>			</span><span>let</span><span> result </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>int, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>			print!(</span><span>&#34;</span><span>{result:?}</span><span>&#34;</span><span>);
</span><span>		}
</span><span>		println!();
</span><span>	}
</span><span>} </span><span>else </span><span>{
</span><span>	println!(</span><span>&#34;Unsolvable&#34;</span><span>)
</span><span>}
</span></code></pre>
<p>And this prints out the result. You can verify for yourself whether this is correct or not. Maybe try other puzzles. Or add more constraints. <a href="https://www.youtube.com/watch?v=yKf9aUIxdb4">You can even try the Miracle Sudoku</a>.</p>
<pre><code><span>715894632
</span><span>234516897
</span><span>689723145
</span><span>493657218
</span><span>867231954
</span><span>152489763
</span><span>376148529
</span><span>928365471
</span><span>541972386
</span></code></pre>
<p>One thing of note here: which is how <em>dumb</em> the solver is. Note that if you print out the solver, there is no notion of rows and columns and squares. It does not know any Sudoku tricks like X-wings and what have you. All the data is organized on the Rust side of things, and what is given to the solver is &#34;these two variables cannot be the same&#34; over and over and over again. And it just .. tells you what the rest of them are.</p>
<p>Another thing that is not obvious at first glance, is that it does not check if there is a unique solution. The puzzle may be badly constructed and have multiple solutions, and it will happily give you one, or two, or how many you ask for. It does, however, check if it is unsolvable!</p>
<hr/>
<h2 id="page-layout">Page Layout</h2>
<p>One of the famous examples of using solvers in production is .. layouting. You have a number of elements and you want to arrange them on a page, or a browser window, or whatever. So let&#39;s do a rudimentary version of that.</p>
<p>The page we are layouting has an arbitrary size of 190mm width by 270mm tall. We are to put three boxes on the page of varying sizes and rules. I am just spitballing the sizes here: first box is 105mm by 140mm; second is 85 by 135, third is 120 by 110. They should not overlap, and like .. that&#39;s it?</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> page_width </span><span>= </span><span>190</span><span>;
</span><span>let</span><span> page_height </span><span>= </span><span>270</span><span>;
</span><span>
</span><span>let</span><span> solver </span><span>= </span><span>Solver::new();
</span><span>
</span><span>let</span><span> box_dims </span><span>= </span><span>[(</span><span>105</span><span>, </span><span>140</span><span>), (</span><span>85</span><span>, </span><span>135</span><span>), (</span><span>120</span><span>, </span><span>110</span><span>)];
</span><span>let</span><span> box_locs </span><span>=</span><span> box_dims.</span><span>map</span><span>(|b| {
</span><span>	</span><span>let</span><span> left </span><span>= </span><span>Int::fresh_const(</span><span>&#34;x&#34;</span><span>);
</span><span>	</span><span>let</span><span> top </span><span>= </span><span>Int::fresh_const(</span><span>&#34;y&#34;</span><span>);
</span><span>
</span><span>	</span><span>let</span><span> right </span><span>= &amp;</span><span>left </span><span>+</span><span> b.</span><span>0</span><span>;
</span><span>	</span><span>let</span><span> bottom </span><span>= &amp;</span><span>top </span><span>+</span><span> b.</span><span>1</span><span>;
</span><span>
</span><span>	</span><span>// assert the boxes fit within the page
</span><span>	solver.</span><span>assert</span><span>(</span><span>&amp;</span><span>left.</span><span>ge</span><span>(</span><span>0</span><span>));
</span><span>	solver.</span><span>assert</span><span>(</span><span>&amp;</span><span>top.</span><span>ge</span><span>(</span><span>0</span><span>));
</span><span>
</span><span>	solver.</span><span>assert</span><span>(</span><span>&amp;</span><span>right.</span><span>le</span><span>(page_width));
</span><span>	solver.</span><span>assert</span><span>(</span><span>&amp;</span><span>bottom.</span><span>le</span><span>(page_height));
</span><span>
</span><span>	</span><span>// assert each box aligns to lines. line height is 10mm
</span><span>	solver.</span><span>assert</span><span>(</span><span>&amp;</span><span>bottom.</span><span>rem</span><span>(</span><span>10</span><span>).</span><span>eq</span><span>(</span><span>0</span><span>));
</span><span>
</span><span>	(left, top, right, bottom)
</span><span>});
</span><span>
</span><span>// assert boxes do not overlap
</span><span>for</span><span> i </span><span>in </span><span>0</span><span>..</span><span>box_locs.</span><span>len</span><span>() {
</span><span>	</span><span>for</span><span> j </span><span>in</span><span> i </span><span>+ </span><span>1</span><span>..</span><span>box_locs.</span><span>len</span><span>() {
</span><span>		</span><span>let</span><span> fst_box </span><span>= &amp;</span><span>box_locs[i];
</span><span>		</span><span>let</span><span> snd_box </span><span>= &amp;</span><span>box_locs[j];
</span><span>		</span><span>// tuple structure: (left, top, right, bottom)
</span><span>		</span><span>let</span><span> cond_1 </span><span>=</span><span> fst_box.</span><span>0.</span><span>ge</span><span>(</span><span>&amp;</span><span>snd_box.</span><span>2</span><span>); </span><span>// fst left &gt;= snd right
</span><span>		</span><span>let</span><span> cond_2 </span><span>=</span><span> fst_box.</span><span>1.</span><span>ge</span><span>(</span><span>&amp;</span><span>snd_box.</span><span>3</span><span>); </span><span>// fst top &gt;= snd bottom
</span><span>		</span><span>let</span><span> cond_3 </span><span>=</span><span> fst_box.</span><span>2.</span><span>le</span><span>(</span><span>&amp;</span><span>snd_box.</span><span>0</span><span>); </span><span>// fst right &lt;= snd left
</span><span>		</span><span>let</span><span> cond_4 </span><span>=</span><span> fst_box.</span><span>3.</span><span>le</span><span>(</span><span>&amp;</span><span>snd_box.</span><span>1</span><span>); </span><span>// fst bottom &lt;= snd top
</span><span>		solver.</span><span>assert</span><span>(Bool::or(</span><span>&amp;</span><span>[cond_1, cond_2, cond_3, cond_4]));
</span><span>	}
</span><span>}
</span><span>
</span><span>// println!(&#34;{solver:?}&#34;);
</span><span>
</span><span>if let </span><span>SatResult::Sat </span><span>=</span><span> solver.</span><span>check</span><span>() {
</span><span>	</span><span>let</span><span> model </span><span>=</span><span> solver.</span><span>get_model</span><span>().</span><span>unwrap</span><span>();
</span><span>
</span><span>	</span><span>for </span><span>(idx, b) </span><span>in</span><span> box_locs.</span><span>into_iter</span><span>().</span><span>enumerate</span><span>() {
</span><span>		print!(</span><span>&#34;box </span><span>{}\t</span><span>&#34;</span><span>, idx </span><span>+ </span><span>1</span><span>);
</span><span>		</span><span>let</span><span> left </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>b.</span><span>0</span><span>, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> top </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>b.</span><span>1</span><span>, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> right </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>b.</span><span>2</span><span>, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>		</span><span>let</span><span> bottom </span><span>=</span><span> model.</span><span>eval</span><span>(</span><span>&amp;</span><span>b.</span><span>3</span><span>, </span><span>true</span><span>).</span><span>unwrap</span><span>();
</span><span>		println!(</span><span>&#34;</span><span>{left}</span><span>, </span><span>{top}</span><span>, </span><span>{right}</span><span>, </span><span>{bottom}</span><span>&#34;</span><span>);
</span><span>	}
</span><span>} </span><span>else </span><span>{
</span><span>	println!(</span><span>&#34;Unsolvable&#34;</span><span>);
</span><span>}
</span></code></pre>
<p>This prints out this neat solution:</p>
<pre><code><span>box 1	85, 0, 190, 140
</span><span>box 2	0, 5, 85, 140
</span><span>box 3	0, 140, 120, 250
</span></code></pre>
<p>Turned out easier than I thought. Hah.</p>
<hr/>
<h2 id="epilogue">Epilogue</h2>
<p>Obviously, all these examples are rather simple. Figuring out how to model the problem in the form of boolean rules and constraints is almost all the challenge. There are some limitations, too: <code>z3</code> cannot solve equations of the sort <code>2^x == 3</code>; it cannot call external functions to get values (though there are ways to work around that).</p>
<p>There is plenty of stuff I have not shown. <code>Array</code>s, which are nothing like programming language arrays and more mappings from one domain to another. <code>BV</code>, bit vectors, which allow bitwise operations on their values like <code>and</code> and <code>or</code> and bit shifting. (Which are the key to solving <a href="https://asibahi.github.io/thoughts/the-hanging-gardens-problem/">the Hanging Gardens Problem</a>.) <code>Set</code>s and <code>Seq</code>s and <code>String</code>s and regexes and stuff I have not really looked into. Unfortunately, most resources on the web are a bit heavy on theory, and are not targeted to stupid coders like myself.</p>
<p>Until later.</p>
<hr/>

</div></div>
  </body>
</html>
