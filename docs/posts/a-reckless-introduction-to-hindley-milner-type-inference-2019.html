<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://reasonableapproximation.net/2019/05/05/hindley-milner.html">Original</a>
    <h1>A reckless introduction to Hindley-Milner type inference (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <header>
        
        <h3><a href="https://reasonableapproximation.net/archive.html">Latest posts</a></h3>
        <ul>
          
          
          
            
              
              
              <li><a href="https://reasonableapproximation.net/2024/06/18/book-review-the-iliad.html">Book review: the Iliad</a></li>
            
          
            
              
              
              <li><a href="https://reasonableapproximation.net/2024/04/03/conditional-prediction-markets-evidential.html">Conditional prediction markets are evidential, not causal</a></li>
            
          
            
              
              
              <li><a href="https://reasonableapproximation.net/2024/03/28/uk-crypto-taxes.html">Cryptocurrency taxation in the UK</a></li>
            
          
            
              
              
              <li><a href="https://reasonableapproximation.net/2023/09/29/headphones-hook.html">Headphones hook</a></li>
            
          
            
              
              
              <li><a href="https://reasonableapproximation.net/2023/08/20/ruining-a-log-money-maximizer.html">Ruining an expected-log-money maximizer</a></li>
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
          <li>
            <small>
              <a href="https://reasonableapproximation.net/archive.html">all</a> | <a href="https://reasonableapproximation.net/tags.html">tags</a>
            </small>
          </li>
        </ul>
      </header>
      <section>
        <h3><a href="https://reasonableapproximation.net/2019/05/05/hindley-milner.html">A reckless introduction to Hindley-Milner type inference</a></h3>

<p><em>(I&#39;ve been editing this post on and off for almost a year. I&#39;m not really happy with it, but I suspect I never will be.)</em></p>

<p>Several months ago I gave a talk at work about Hindley-Milner type inference. When I agreed to give the talk I didn&#39;t know much about the subject, so I learned about it. And now I&#39;m writing about it, based on the contents of my talk but more fleshed out and hopefully better explained.</p>

<p>I call this a reckless introduction, because my main source is <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">wikipedia</a>. A bunch of people on the internet have collectively attempted to synthesise a technical subject. I&#39;ve read their synthesis, and now I&#39;m trying to re-synthesise it, without particularly putting in the effort to check my own understanding. I&#39;m not going to argue that this is a good idea. Let&#39;s just roll with it.</p>

<p>I&#39;m also trying to tie in some quasi-philosophy that surely isn&#39;t original to me but I don&#39;t know if or where I&#39;ve encountered it before.<sup id="fnref:constraints-liberties" role="doc-noteref"><a href="#fn:constraints-liberties" rel="footnote">1</a></sup></p>

<h3 id="background">Background</h3>

<p>When people write software, sometimes it doesn&#39;t do exactly what we want. One way to find out is to try running it and see, but that&#39;s not ideal because any complicated program will have way too many possible inputs to test. (Especially when you consider that inputs include things like &#34;amount of free space on disk&#34; and &#34;time taken for a web server to respond to a request&#34;.) So it would be nice if we could mathematically prove whether our software does what we want, without actually running it. Can we do that?</p>

<p>That&#39;s not a very well-defined question, but we can ask more precise versions of it. Here&#39;s a well-known one: given some possible input to our software, we might want to prove that our software will eventually stop running. Can we prove that?</p>

<p>That question is known as the halting problem, and the simple answer is that we can&#39;t, not in general; the halting problem is <em>undecideable</em>. But the full answer is more complicated.</p>

<p>To solve the halting problem, we want a program that, when shown another program and some input to be fed to that program, satisfies three different conditions:</p>

<ol>
  <li>It will always return an answer.</li>
  <li>The answer will always be either &#34;yes, this always terminates&#34; or &#34;no, sometimes this doesn&#39;t terminate&#34;.</li>
  <li>The answer is always correct.</li>
</ol>

<p>And that&#39;s not possible. But we can compromise on any of the three. We can make a program that sometimes doesn&#39;t return an answer, or one that sometimes gets the answer wrong. But perhaps most interestingly, we can make a program that sometimes says &#34;I don&#39;t know&#34;.</p>

<p>And when you allow that answer, you can create a <em>language</em> on which the halting problem is decideable. You can write a program that will tell you truthfully whether any program written <em>in that language</em> will terminate; and for any other program, will say &#34;I don&#39;t know&#34;. (Perhaps expressed in words like &#34;syntax error on line 1&#34;.)</p>

<p>Now, the halting problem is tricky. It turns out that if you create a language like that, there are a lot of interesting things that programs written in that language just won&#39;t be able to do; the language will necessarily be <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing incomplete</a>.<sup id="fnref:incomplete" role="doc-noteref"><a href="#fn:incomplete" rel="footnote">2</a></sup> But there are also lots of interesting things that they can do. To give three examples of such languages<sup id="fnref:nonterminating" role="doc-noteref"><a href="#fn:nonterminating" rel="footnote">3</a></sup>:</p>

<ul>
  <li>Regular expressions are really useful for certain operations on strings, but that&#39;s about all they&#39;re good for.</li>
  <li>SQL is really useful for working with databases. According to <a href="https://stackoverflow.com/questions/900055/is-sql-or-even-tsql-turing-complete">some people on stack overflow</a>, the ANSI SQL-92 standard was Turing incomplete and the ANSI SQL-99 standard is Turing complete. (No mention of the SQL-96 standard that came between these, but reading between the lines, probably Turing incomplete.) If I understand correctly, the feature required to make SQL-99 Turing complete<sup id="fnref:recursive-cte" role="doc-noteref"><a href="#fn:recursive-cte" rel="footnote">4</a></sup> is one I&#39;ve literally never used; so for my purposes, it may as well be Turing incomplete.</li>
  <li>Coq is used for proving math theorems. It&#39;s an interesting one because when you write your program, you have to also provide a proof that your program terminates. (I think this is <a href="https://news.ycombinator.com/item?id=9038315">slightly false</a>, but again, good enough for the point I&#39;m making.)</li>
</ul>

<p>So although these languages can&#39;t do everything, they can still be incredibly useful in their domains. More useful than a more general purpose language might be. One reason for this is that being able to prove non-termination is a useful property of the language. If you had to write a SQL query in C, it would be all too easy to write some C code that would accidentally loop forever.</p>

<p>I&#39;m trying to illustrate here something that seems to me important, which is that there&#39;s a tradeoff between what I&#39;ll call expressiveness and legibility. A programming language is <em>expressive</em> if you can easily write many interesting programs in it<sup id="fnref:expressive" role="doc-noteref"><a href="#fn:expressive" rel="footnote">5</a></sup>; it&#39;s <em>legible</em> if you can easily say many interesting things about the programs you&#39;ve written in it. And I claim that the most expressive programming languages won&#39;t be the most legible, and vice-versa; though there will certainly be <a href="https://en.wikipedia.org/wiki/Malbolge">languages</a> which are neither expressive nor legible. This tradeoff seems fundamental to me, and I expect that some approximation of it has been proven as a theorem.<sup id="fnref:zfpa" role="doc-noteref"><a href="#fn:zfpa" rel="footnote">6</a></sup></p>

<p>I haven&#39;t defined these very well, but hopefully some examples will help. I will also clarify that both of them are highly dimensional; and that &#34;raw computational power&#34; is one of the things that expressiveness can point at, but not the only thing; and &#34;human readability&#34; is not really one of the things that legibility points at, but many things that increase legibility will also increase human readability.</p>

<ul>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions">Perl-compatible regular expressions</a> can classify sets of strings that normal regular expressions can&#39;t. But they&#39;re harder to make time and space guarantees about. And it&#39;s possible to prove whether two regular expressions are equivalent, but that&#39;s not possible in general for PCREs (proof: <a href="https://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html">PCREs can encode CFGs</a>; <a href="https://math.stackexchange.com/questions/231187/an-efficient-way-to-determine-if-two-context-free-grammars-are-equivalent">CFGs can&#39;t be proved equivalent</a>).</p>
  </li>
  <li>
    <p>Under certain assumptions, Haskell&#39;s monadic IO lets you look at the type of a piece of code and know that it won&#39;t depend on external state. In return, a function can only bring in external state if its caller allows it to (which requires having permission from its own caller, and so on).</p>

    <p>The assumptions in question are false (partly because <code>unsafePerformIO</code> exists), but I&#39;ve been able to get away with pretending they&#39;re true (partly because <code>unsafePerformIO</code> is punishable with excommunication).</p>
  </li>
  <li>
    <p>Custom operators (at least as implemented in Haskell and Elm) are equivalent to named functions, and don&#39;t gain or cost much in terms of legibility and expressivity. They simply make code more or less readable. But operator overloading, at least when combined with dynamic typing, gains expressivity at the cost of legibility (you no longer know that <code>a + b</code> will do anything remotely like an addition).</p>
  </li>
  <li>
    <p>Macros make it easier to do things like create DSLs, reduce boilerplate, and set compile-time config options. But they mean that a function call might not look like one, or vice-versa; expressions might get evaluated many times, or not at all; and the code might perform differently depending on the phase of the moon when it was compiled.</p>
  </li>
</ul>

<h3 id="motivation">Motivation</h3>

<p>So we&#39;ve got this tradeoff, and in our programming language design we try to navigate it. We try to find kinds of legibility that can be bought for little cost in expressiveness. Or more precisely, we try to find kinds of legibility <em>that we care about</em>, and that can be bought for little cost in <em>kinds of expressiveness that we care about</em>.</p>

<p>And Hindley-Milner type systems are a tradeoff that&#39;s proved fairly successful, both in direct use and as inspiration. At my company<sup id="fnref:my-company" role="doc-noteref"><a href="#fn:my-company" rel="footnote">7</a></sup>, we use <a href="https://en.wikipedia.org/wiki/Elm_\(programming_language\)">Elm</a><sup id="fnref:elm18" role="doc-noteref"><a href="#fn:elm18" rel="footnote">8</a></sup>, which runs on an approximately HM type system. (I don&#39;t think it&#39;s pure HM, due to extensible record types.) We also use <a href="https://en.wikipedia.org/wiki/Haskell_\(programming_language\)">Haskell</a><sup id="fnref:ghc" role="doc-noteref"><a href="#fn:ghc" rel="footnote">9</a></sup>, which runs on a type system that extends HM in many directions. Haskell&#39;s system is more expressive and less legible, but still successful. (I&#39;ll mostly be using Elm for examples in this post, and not extensible records.) ML and OCaml are other notable languages based on HM, though I haven&#39;t used either.</p>

<p>The legibility HM offers is, roughly, the ability to prove that a program typechecks. I&#39;m not going to clarify exactly what that means, but we probably all have a decent idea. It&#39;s the thing that lets the Elm compiler say &#34;no, that program is trying to add a string to an int, bad program&#34;, while the Python interpreter doesn&#39;t know that&#39;s going to happen until it&#39;s too late. The Elm compiler will refuse to compile your program unless it can logically prove that it will typecheck.</p>

<p>More precisely, what HM offers isn&#39;t type <em>checking</em> but the more general type <em>inference</em>. (And beyond that, type inference <em>in roughly linear time</em>.) Type inference doesn&#39;t just tell you <em>whether</em> a program typechecks, but <em>what</em> its type is; a program fails to typecheck iff no type can be inferred for it.</p>

<p>What this means is that there&#39;s no need to supply type annotations. And indeed, in Elm you can get away without them, except I think for extensible records. In Haskell you sometimes can&#39;t, because Haskell loses some of the legibility that HM offers.</p>

<p>(We typically do supply type annotations, but that&#39;s because they&#39;re useful. Partly as documentation for humans, partly to help pinpoint errors when our programs fail to typecheck.)</p>

<p>And so in an HM system you get no runtime type errors. And although not all runtime errors are type errors, in many cases they could be. For example, an array out-of-bounds exception isn&#39;t a type error. But when designing a language, you can decide that array out-of-bounds exceptions won&#39;t exist, any array lookup will return either a value from the array or <code>null</code>. If type errors are possible, you&#39;ve just eliminated one source of errors by pushing them somewhere else, and possibly somewhere harder to debug. But in HM, you&#39;ve eliminated one source of errors by pushing them somewhere more visible, where they can be ruthlessly executed.</p>

<p>Elm actually tries to promise no runtime errors, period, provided you stay inside Elm. On one level, I think that&#39;s a fairly minor imposition on language design, something you get &#34;for free&#34; by deciding that none of the built-in functions you provide will ever throw a runtime error. On another level, it seems completely impractical to decide for example that <code>cons</code> will return a meaningful value if it can&#39;t allocate more memory. I&#39;m not aware that Elm even tries to handle those errors.</p>

<p>(Haskell doesn&#39;t try to promise the same thing, and allows functions to return <code>undefined</code>. This is another legibility-expressiveness tradeoff.)</p>

<p>So HM&#39;s legibility gain is: type inference, powerful type system, no runtime type errors, optionally no runtime errors at all. It&#39;s good.</p>

<p>Meanwhile, the expressiveness cost is that you need to write your programs in ways that the type inference algorithms can work with, which forbids some things that you might like to do.</p>

<p>For example, suppose you want to clamp a number to between -1 and +1. In Python, you could write that like</p>

<div><div><pre><code><span>def</span> <span>clamp</span><span>(</span><span>x</span><span>):</span> <span>sorted</span><span>([</span><span>-</span><span>1</span><span>,</span> <span>x</span><span>,</span> <span>1</span><span>])[</span><span>1</span><span>]</span>
</code></pre></div></div>

<p>and as long as <code>sorted</code> always returns a list of the same length it started with, that works fine<sup id="fnref:clamp" role="doc-noteref"><a href="#fn:clamp" rel="footnote">10</a></sup>. But it only works because the Python interpreter allows you to be reckless with array indexing. Elm doesn&#39;t let you be reckless, and so Elm has no equivalent way to perform array lookup. If you tried to write the same function in the same way in Elm, the result in the compiler&#39;s eyes would not be a number but a <code>Maybe</code> number - AKA &#34;either a number or <code>Nothing</code>&#34;. (<code>Nothing</code> is roughly equivalent to <code>None</code> in python or <code>null</code> in many other languages, but you have to explicitly flag when it&#39;s allowed.) When you actually run this code, you will always get a number and never <code>Nothing</code>. But the compiler can&#39;t prove that.</p>

<p>(Again, I stress that you will never get <code>Nothing</code> <em>as long as</em> your sort function always returns a list of the same length it started with. That&#39;s something you can prove for yourself, but it&#39;s not something the Elm compiler can prove. It&#39;s not even the sort of thing the Elm compiler knows can be proven. And so in turn, it can&#39;t prove that you&#39;ll never get a <code>Nothing</code> here.)</p>

<p>And then the Elm compiler would force you to account for the possibility of <code>Nothing</code>, even though there&#39;s no way that possibility could occur at runtime. One option is to pick an arbitrary result that will never be exposed. That works fine until the code goes through several layers of changes, an assumption that used to be true is now violated, and suddenly that arbitrary result is wreaking havoc elsewhere. Or in Haskell, your program is crashing at runtime.</p>

<p>To be clear, that&#39;s not significantly worse than what we get in Python, where the code can also go through several layers of changes that result in it crashing at runtime. But we were hoping for better.</p>

<p>And in this case &#34;better&#34; is easy enough, you can just write your function to avoid indexing into a list, and then it can return a number with no need for trickery. The point isn&#39;t that you can&#39;t do the thing. The point is that (a), even if the thing is safe, the compiler might not know that; (b), if you decide it&#39;s safe anyway and find some way to trick the compiler, the compiler no longer protects you; and (c), if you want to do it in a way the compiler knows is safe, you might need to put in some extra work.</p>

<p>For another example, HM type systems can&#39;t implement heterogenous lists. So this is really easy in python:</p>

<div><div><pre><code><span>def</span> <span>stringify_list</span><span>(</span><span>l</span><span>):</span>
    <span>return</span> <span>[</span> <span>repr</span><span>(</span><span>x</span><span>)</span> <span>for</span> <span>x</span> <span>in</span> <span>l</span> <span>]</span>

<span>stringify_list</span><span>([</span><span>&#34;hello&#34;</span><span>,</span>
                <span>0</span><span>,</span>
                <span>[</span><span>&#34;here&#39;s a&#34;</span><span>,</span> <span>&#34;nested list&#34;</span><span>,</span> <span>{</span><span>&#34;and&#34;</span><span>:</span> <span>&#34;maybe&#34;</span><span>,</span> <span>&#34;a&#34;</span><span>:</span> <span>&#34;dict&#34;</span><span>}],</span>
                <span>&#34;it can even be passed itself, like so:&#34;</span><span>,</span>
                <span>stringify_list</span><span>])</span>
</code></pre></div></div>

<p>but impossible in Elm. You can <em>sort of</em> get the same effect by creating a type with many constructors</p>

<div><div><pre><code><span>type</span> <span>HeteroType</span> <span>=</span> <span>HTInt</span> <span>Int</span>
                <span>|</span> <span>HTString</span> <span>String</span>
                <span>|</span> <span>HTBool</span> <span>Bool</span>
                <span>|</span> <span>HTList</span> <span>(</span><span>List</span> <span>HeteroType</span><span>)</span>
                <span>|</span> <span>...</span>
</code></pre></div></div>

<p>but it&#39;s not quite the same, because it can only accept types you know about in advance. Also, it&#39;s a massive pain to work with.</p>

<p>For a third example: Haskell is known for its monads. But Elm has no equivalent, because an HM type system can&#39;t support generic monad programming. You can implement the generic monad functions for specific cases, so there&#39;s <code>Maybe.map</code> and <code>List.map</code>, but there&#39;s no equivalent of Haskell&#39;s <code>fmap</code> which works on all monads.</p>

<h3 id="hindley-milner-type-systems">Hindley-Milner type systems</h3>

<p>I&#39;ve talked about the tradeoffs that HM type systems offer, but not what HM type systems actually are. So here is where I get particularly reckless.</p>

<p>This bit is more formal than the rest. It&#39;s based on the treatment at wikipedia, but I&#39;ve tried to simplify the notation. I&#39;m aiming for something that I would have found fairly readable several months ago, but I no longer have access to that version of me.</p>

<p>Also, this part is likely to make more sense if you&#39;re familiar with at least one HM-based language. That&#39;s not a design feature, I just don&#39;t trust myself to bridge that inferential gap.</p>

<p>For an HM system, you need a language to run type inference on, and you need types to run type inference with, and you need some way to combine the two. You could use the language with no type inference, if you didn&#39;t mind crashes or weird behaviour at runtime, when you made a mistake with typing. (Haskell <a href="https://ghc.haskell.org/trac/ghc/wiki/DeferErrorsToRuntime">allows this</a> with a compiler option.<sup id="fnref:defer-type-errors" role="doc-noteref"><a href="#fn:defer-type-errors" rel="footnote">11</a></sup>) And you could run type inference without caring about the semantics of the language, treating it as essentially a SuDoku, an interesting puzzle but meaningless. (Haskell <a href="https://stackoverflow.com/questions/12373722/make-ghc-only-type-check">supports this</a>, too.) But by combining them, the semantics of the language are constrained by the type system, and runtime type errors are eliminated.</p>

<h4 id="types">Types</h4>

<p>Types come in a conceptual hierarchy which starts with <strong>type constants</strong>. That&#39;s things like, in Elm, <code>Int</code>, <code>Float</code>, <code>Bool</code>, <code>String</code>, <code>Date</code>, <code>()</code>. It also includes type variables, which in Elm are notated with initial lower-case, like <code>a</code> and <code>msg</code>. (Though the type variables <code>number</code>, <code>comparable</code> and <code>appendable</code> are special cases that I won&#39;t cover here.)</p>

<p>Next in the type hierarchy is <strong>applied types</strong>. Here a &#34;type function&#34; is applied to arguments, which are type constants and/or other applied types. These are things like <code>List Int</code>, <code>Maybe (List Float)</code>, <code>Result () Date</code>, and <code>a -&gt; String</code>. (In that last one, the type function is the arrow; Haskell would allow you to write it <code>(-&gt;) a String</code>. Aside, <code>(-&gt;)</code> is the only type that HM specifically requires to exist; <code>a -&gt; b</code> is the type of functions taking a parameter of type <code>a</code> and evaluating to a result of type <code>b</code>.) Notably, an applied type must have a specific named type function as its root; you can&#39;t have <code>m Int</code>, which you would need for generalised monads.</p>

<p>Type constants and applied types are <strong>monotypes</strong>. You get a <strong>polytype</strong> by optionally sticking one or more &#34;∀&#34;s in front of a monotype. (&#34;∀&#34; is pronounced &#34;for all&#34;, and in Haskell can be written <code>forall</code>.) So for example <code>a -&gt; Int</code> is a monotype, but <code>∀a. a -&gt; Int</code> is a polytype. So is <code>∀a. ∀b. a -&gt; Int -&gt; b</code>, which is written equivalently as <code>∀a b. a -&gt; Int -&gt; b</code>. <code>∀b. a -&gt; Int</code> is also a polytype; since the quantified variable doesn&#39;t show up, it&#39;s equivalent to the monotype <code>a -&gt; Int</code>. We can do something like that to any monotype, so for simplicity we might as well decide that monotypes count as a special case of polytypes, not as a distinct set.</p>

<p>Type signatures in Elm typically have an implied &#34;∀&#34; over whichever variables it makes sense to quantify. (There&#39;s no syntax for explicitly writing the &#34;∀&#34;.) So the type of <code>List.map</code> would be written</p>

<div><div><pre><code><span>map</span> <span>:</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>List</span> <span>a</span> <span>-&gt;</span> <span>List</span> <span>b</span>
</code></pre></div></div>

<p>but I&#39;ll be writing</p>

<div><div><pre><code><span>map</span> <span>:</span> <span>∀</span><span>a</span> <span>b</span><span>.</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>List</span> <span>a</span> <span>-&gt;</span> <span>List</span> <span>b</span>
</code></pre></div></div>

<p>for clarity. Because there&#39;s one place where Elm <em>doesn&#39;t</em> give an implied ∀, which is when you have scoped types. To demonstrate by example,</p>

<div><div><pre><code><span>const</span> <span>:</span> <span>∀</span><span>a</span> <span>b</span><span>.</span> <span>a</span> <span>-&gt;</span> <span>b</span> <span>-&gt;</span> <span>a</span>
<span>const</span> <span>x</span> <span>=</span> <span>let</span> <span>foo</span> <span>:</span> <span>b</span> <span>-&gt;</span> <span>a</span>
              <span>foo</span> <span>y</span> <span>=</span> <span>x</span>
           <span>in</span> <span>foo</span>
</code></pre></div></div>

<p><code>const</code> has a polytype here, but <code>foo</code> has a monotype, because (in context) its argument type and return type are constrained. If you tried to swap <code>a</code> and <code>b</code> in the type signature for <code>foo</code>, or rename either of them, the Elm compiler would complain.</p>

<h4 id="language">Language</h4>

<p>The <strong>language</strong> has four kinds of expression, and each has a rule relating it to the type system. You need variables and constants, function calls, lambda expressions, and let statements.</p>

<h5 id="variables-and-constants">Variables and constants</h5>

<p>Variables and constants are things like <code>True</code>, <code>0.2</code>, <code>Just</code>, <code>&#34;Hello&#34;</code>, <code>[]</code>, <code>()</code>, <code>List.map</code>. Each of these has a declared type, which in Elm is notated with <code>:</code>. So <code>True : Bool</code>, <code>0.2 : Float</code>, <code>Just : ∀a. a -&gt; Maybe a</code>, <code>&#34;Hello&#34;: String</code>, <code>[] : ∀a. List a</code>, <code>() : ()</code>, <code>List.map : ∀a b. (a -&gt; b) -&gt; List a -&gt; List b</code>.</p>

<p>The rule that relates these to the type system is that <em>type declarations imply type judgments</em>. Mathematically it looks like</p>

<div><div><pre><code>$$ \frac{x : π \quad π ⊑ μ}{x \sim μ}. $$
</code></pre></div></div>

<p>Reading clockwise from top left, this says: if you have a variable $x$ declared to have some polytype $π$, and if the monotype $μ$ is a specialisation of $π$, then $x$ can be judged to have type $μ$. ($π$ always denotes a polytype, and $μ$ always denotes a monotype.)</p>

<p>A type <em>judgment</em>, as opposed to a declaration, provides a type that an expression can be used as. A judgment is always as a monotype.</p>

<p>And type specialisation, denoted $⊑$, is the process of replacing quantified variables with less-quantified ones. So for example the type <code>∀a b. a -&gt; b -&gt; a</code> might be specialized to <code>∀a. a -&gt; String -&gt; a</code>, or to <code>∀b. Int -&gt; b -&gt; Int</code>; and from either of those, it could be further specialised to <code>Int -&gt; String -&gt; Int</code>. Of course <code>String -&gt; Int -&gt; String</code> and <code>List Float -&gt; (Float -&gt; String) -&gt; List Float</code> are valid specialisations too.</p>

<p>Thus: we have the type declaration <code>[] : ∀a. List a</code>, and we have <code>(∀a. List a) ⊑ List Int</code>, and so we can form the type judgment <code>[] ~ List Int</code>. We also have <code>(∀a. List a) ⊑ List String</code>, and so <code>[] ~ List String</code>. And <code>[] ~ List (List (Maybe Bool))</code>, and so on.</p>

<h5 id="function-calls">Function calls</h5>

<p>Function calls are things like <code>not True</code>, <code>(+ 1)</code>, <code>List.Map Just</code>. And the rule relating them to the type system is that <em>function calls consume function types</em>. This is the simplest of the rules. Mathematically it looks like</p>

<div><div><pre><code>$$ \frac{f \sim μ → μ&#39; \quad v \sim μ}{f v \sim μ&#39;}. $$
</code></pre></div></div>

<p>Or: if $f$ can be judged to have a function type $μ → μ&#39;$, and $v$ can be judged to have type $μ$, then the function call $fv$ can be judged to have type $μ&#39;$.</p>

<p>Thus: we can infer the type judgment <code>toString ~ (Int -&gt; String)</code>, and we can infer <code>3 ~ Int</code>, and so we can infer <code>toString 3 ~ String</code>.</p>

<p>Also, we can infer <code>List.map ~ ((Int -&gt; Maybe Int) -&gt; (List Int -&gt; List (Maybe Int)))</code>, and we can infer <code>Just ~ (Int -&gt; Maybe Int)</code>. So we can infer <code>List.map Just ~ (List Int -&gt; List (Maybe Int))</code></p>

<h5 id="lambda-expressions">Lambda expressions</h5>

<p>Lambda expressions are things like <code>\x -&gt; Just x</code>, and in Elm they&#39;re used implicitly when something like <code>const x y = x</code> is turned into <code>const = \x -&gt; \y -&gt; x</code>. The type system rule is that <em>lambda expressions produce function types</em>. Mathematically:</p>

<div><div><pre><code>$$ \frac{x : μ ⇒ e \sim μ&#39;}{λx.e \sim μ → μ&#39;}. $$
</code></pre></div></div>

<p>Or: suppose that the type declaration $x : μ$ would allow us to infer the judgment $e \sim μ&#39;$. In that case, we could judge that $λx.e \sim (μ → μ)&#39;$.</p>

<p>Typically $e$ would be some expression mentioning the variable $x$, but it&#39;s no problem if not. In that case, if you can get $e \sim μ&#39;$ at all, you can get it assuming any $x : μ$, and so you have $λx.e \sim (\mathtt{Int} → μ&#39;)$ and $λx.e \sim (\mathtt{String} → μ&#39;)$ and $λx.e \sim (\mathtt{Result\ String\ (List\ (Maybe\ Float))} → μ&#39;)$ and so on.</p>

<p>Thus: given the declaration <code>x : Int</code>, we can infer the judgment <code>[x] ~ List Int</code>. And so we can infer the judgment <code>(\x -&gt; [x]) ~ (Int -&gt; List Int)</code>.</p>

<h5 id="let-expressions">Let expressions</h5>

<p>Let expressions read like <code>let x = y in a</code>. Semantically, this is very similar to using a lambda expression, <code>(\x -&gt; a) y</code>. But HM treats them differently in the type system, allowing a let expression to introduce polytypes. That permits code like</p>

<div><div><pre><code><span>let</span> <span>f</span> <span>x</span> <span>=</span> <span>[</span><span>x</span><span>]</span>
<span>in</span> <span>(</span><span>f</span> <span>&#34;</span><span>&#34;</span><span>,</span> <span>f</span> <span>True</span><span>)</span>
<span>-- returns ([&#34;&#34;], [True])</span>
</code></pre></div></div>

<p>If you tried to rewrite this as a lambda, you would get</p>

<div><div><pre><code><span>(</span><span>\</span><span>f</span> <span>-&gt;</span> <span>(</span><span>f</span> <span>&#34;</span><span>&#34;</span><span>,</span> <span>f</span> <span>True</span><span>))(</span><span>\</span><span>x</span> <span>-&gt;</span> <span>[</span><span>x</span><span>])</span>
</code></pre></div></div>

<p>But type inference fails here, because there&#39;s no monotype declaration for <code>f</code> that allows a type judgment for <code>(f &#34;&#34;, f True)</code>. So the precondition for the lambda rule never obtains, and so in turn, no type judgment can be made for the expression <code>\f -&gt; (f &#34;&#34;, f True)</code>.</p>

<p>Let expressions compensate for this deficiency, with the rule <em>let expressions are like polymorphic lambda applications</em>. (I don&#39;t have a good name for it.) Mathematically:</p>

<div><div><pre><code>$$ \frac{a \sim μ \quad x : \bar{μ} ⇒ b \sim μ&#39;}
        {(\mathtt{let}\ x = a\ \mathtt{in}\ b) \sim μ&#39;} $$
</code></pre></div></div>

<p>Or: suppose that $a$ can be judged to have type $μ$, and that the declaration $x : \bar{μ}$ would allow us to infer the judgment $b \sim μ&#39;$. In that case, we could judge that $(\mathtt{let}\ x = a\ \mathtt{in}\ b)$ has type $μ&#39;$.</p>

<p>This introduces the notation $\bar{μ}$, which generalises a monotype to a polytype. How it works is: if $μ$ mentions a type variable $a$, and $a$ isn&#39;t quantified over in the surrounding context, then $\bar{μ}$ contains a &#34;$∀a$&#34;.</p>

<p>Thus: we can infer <code>(\x -&gt; [x]) ~ (a -&gt; List a)</code>, where <code>a</code> is a type variable unused in the surrounding context. That type generalises to <code>∀a. a -&gt; List a</code>. And given the declaration <code>f : ∀a. a -&gt; List a</code>, we can infer <code>(f &#34;&#34;, f True) ~ (List String, List Bool)</code>. So in total, we can infer</p>

<div><div><pre><code>$$ (\mathtt{let\ f\ x\ =\ [x]\ in\ (f\ &#34;&#34;,\ f\ True)})
   \sim \mathtt{(List\ String,\ List\ Bool)}. $$
</code></pre></div></div>

<p>(It seems a little strange to me that the approach here is to first construct a meaningless type, and then quantify over it. Still, that&#39;s my understanding. It&#39;s of course possible I&#39;m mistaken.)</p>

<p>Why do we need both <code>let</code> and lambda? Well, we can&#39;t replace lambda expressions with let expressions: they&#39;re not re-usable. (When you translate a let expression into a lambda expression, you actually generate a lambda <em>applied to an argument</em>. There&#39;s no way to translate a lambda expression by itself into a let expression.) Meanwhile, I&#39;m not entirely sure why we can&#39;t make lambdas polymorphic in the same way let expressions are. I think the answer is that if we tried it, we&#39;d lose some of the legibility that HM offers - so let can be more powerful in the type system because it&#39;s less powerful in the language. But I&#39;m not sure exactly what legibility would be lost.</p>

<h4 id="recursion">Recursion</h4>

<p>There&#39;s an interesting thing about the system I just described: it may or may not be Turing complete.</p>

<p>The problem is that there&#39;s no specified way of doing recursion. A function can&#39;t call itself, and it can&#39;t call any other function that can call it.</p>

<p>But a <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">fixed-point combinator</a> allows recursion, and might be included in the initial set of variables. Failing that, the proper recursive types can be used to define one. (Elm and Haskell <a href="http://rosettacode.org/wiki/Y_combinator">allow us</a> to define such types<sup id="fnref:brag" role="doc-noteref"><a href="#fn:brag" rel="footnote">12</a></sup>.)</p>

<p>Failing both of those, we can introduce a new kind of expression</p>

<div><div><pre><code>$$ \frac{x : μ ⇒ a \sim μ \quad x : \bar{μ} ⇒ b \sim μ&#39;}
        {(\mathtt{letrec}\ x = a\ \mathtt{in}\ b) \sim μ&#39;}. $$
</code></pre></div></div>

<p>This is much the same as <code>let</code>, but makes the variable <code>x = a</code> available when evaluating <code>a</code>. It&#39;s only available as a monotype when evaluating <code>a</code>, and still doesn&#39;t get generalised to a polytype until evaluating <code>b</code>.</p>

<p>(Elm and Haskell provide <code>letrec</code> as <code>let</code> and don&#39;t provide simple <code>let</code> at all.)</p>

<p>But if an HM language doesn&#39;t provide the appropriate variables or types, and doesn&#39;t implement <code>letrec</code> or something similar, it won&#39;t be Turing complete. Legibility gain, expressivity cost.</p>

<h3 id="wrapping-up">Wrapping up</h3>

<p>And modulo some small details, that&#39;s the entirety of a Hindley-Milner type system. If you have a language with those features, and a suitable set of types, you can perform type inference.</p>

<p>What we have is a set of rules that allows us to construct proofs. That is, if we look at a program written in this language, we would be able to construct a proof of its type (or lack thereof). But I already said HM is better than that: it lets us <em>mechanically</em> construct a proof, in (roughly) linear time.</p>

<p>I confess, I&#39;m not entirely sure how to do that. The outline is obvious, recurse down the parse tree and at each step apply the appropriate rule. But since a constant can be judged as one of many types, you need to keep track of which types are acceptable. Wikipedia hints at how it works, but not in a way that I understand particularly well.</p>

<p>Elm and Haskell both support many things not covered so far. To look at some of them briefly, and occasionally getting even more recklesss,</p>

<ul>
  <li>
    <p>It seems obvious, but both allow you to evaluate the language, something I haven&#39;t touched on much. And it does need to be touched on, because there&#39;s more than one way to do it. Haskell uses a lazy evaluation model, while Elm is strict.</p>
  </li>
  <li>
    <p>Both have ways to introduce new types. That doesn&#39;t change what we&#39;ve seen, but it does separate the languages into two parts. One part describes the types used in a program and one part implements the semantics of a program.</p>
  </li>
  <li>
    <p>Both also support case statements along with destructuring, like</p>

    <div><div><pre><code><span>mHead</span> <span>:</span> <span>Maybe</span> <span>(</span><span>List</span> <span>a</span><span>)</span> <span>-&gt;</span> <span>Result</span> <span>Bool</span> <span>a</span>
<span>mHead</span> <span>ml</span> <span>=</span> <span>case</span> <span>ml</span> <span>of</span>
    <span>Just</span> <span>(</span><span>a</span><span>::</span><span>_</span><span>)</span> <span>-&gt;</span> <span>Ok</span> <span>a</span>
    <span>Just</span> <span>_</span> <span>-&gt;</span>     <span>Err</span> <span>True</span>
    <span>Nothing</span> <span>-&gt;</span>    <span>Err</span> <span>False</span>
</code></pre></div>    </div>

    <p>To implement these, you&#39;d want to add a fifth class of language expression. But I think it would be possible in theory to write a &#34;thin&#34; first-pass compiler to translate these statements into the existing language. By &#34;thin&#34; I mean to do this in such a way that we don&#39;t lose any of the legibility guarantees we care about.<sup id="fnref:case-compiled" role="doc-noteref"><a href="#fn:case-compiled" rel="footnote">13</a></sup> (For example, if this compiler turned $n$ bytes of code in a case statement into more than $O(n)$ bytes of code in the base language, or if it ran in more than O(n) time, this condition would fail.)</p>

    <p>If I&#39;m right about that, then case statements neither make the language more expressive nor less legible, at least in one important sense.</p>
  </li>
</ul>

<ul>
  <li>
    <p>(By comparison, if-then-else statements are also another class of language expression, but one which can obviously be thinly compiled down to the existing ones.)</p>
  </li>
  <li>
    <p>In the type system, Elm supports record types, which are a lot like tuples but with nicer syntax. I believe these too could be thinly compiled down. But it also supports <em>extensible</em> records, which are more complicated. On one level you can think of a type like <code>{a | x : Int, y : Int}</code> like a tuple <code>∀a. (a, Int, Int)</code>. But then this tuple needs to be unpacked and manipulated when you pass it into a function expecting an <code>{a | x : Int}</code>.</p>

    <p>I believe this is unresolvable, and extensible records represent an extension of Elm from HM. (But one with fairly minor legibility costs, in comparison to the expressiveness gains.)</p>
  </li>
  <li>
    <p>Haskell supports typeclasses, which are a way of allowing functions to operate on multiple different types. (For example, the <code>show</code> function can be applied to a <code>String</code>, an <code>Int</code>, a <code>()</code>, a <code>[Float]</code>, ….) Elm doesn&#39;t, but simple typeclasses can be emulated with only a little added verbosity.</p>
  </li>
</ul>

<p>Another thing I&#39;ll say is that I&#39;ve been talking about legibility and expressivity of a language. But a type system is itself a language, and may be more or less legible and expressive. I don&#39;t have a strong intuition for how these interact.</p>

<p>There&#39;s a lot more I could add to this post. Some things that I omitted for brevity, some that I omitted because I don&#39;t know enough about them yet<sup id="fnref:enough" role="doc-noteref"><a href="#fn:enough" rel="footnote">14</a></sup>, and some that I omitted because I don&#39;t know about them at all. I don&#39;t know what a sensible cutoff point is, so I&#39;m just going to end it here.</p>

<p>From writing my original talk, and subsequently this blog post, I think I understand HM type systems much better than I used to. Hopefully you think the same. Hopefully we&#39;re both correct. If you see any inaccuracies, please point them out.</p>



<p><em>Posted on 05 May 2019</em></p>


<p><em>
  Tagged:
  
  <a href="http://reasonableapproximation.net/tags.html#software">software</a>
</em></p>



<p><em>
  Comments elsewhere:
  
  <a href="https://www.reddit.com/r/haskell/comments/cs7jyu/a_reckless_introduction_to_hindleymilner_type/">/r/haskell</a>; <a href="https://lesswrong.com/posts/vTS8K4NBSi9iyCrPo/a-reckless-introduction-to-hindley-milner-type-inference">LessWrong</a>
</em></p>






<a href="http://disqus.com">comments powered by </a>


      </section>
      
    </div></div>
  </body>
</html>
