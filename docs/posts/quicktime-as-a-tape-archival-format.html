<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eschatologist.net/blog/?p=409">Original</a>
    <h1>QuickTime as a Tape Archival Format</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>On the <a href="https://groups.io/g/simh/">SIMH group</a>, <a href="https://bitsavers.org/">Al Kossow</a> and others <a href="https://groups.io/g/simh/message/3722">have been discussing how <code>.tap</code> is a terrible archival container format</a> that also has a bunch of problems for use in emulation and simulation of systems. This is a problem I’ve been thinking about for a while since I hired <a href="https://mietek.io/">Miëtek</a> to implement SCSI tape support in MAME including the <code>.tap</code> format, and I had a sudden realization: There’s already a great format for representing sequential media, QuickTime!</p>
<p>A lot of people think QuickTime is a “video format,” but that’s not really accurate. Video and audio playback are applications <em>atop</em> the QuickTime container format; the container format itself is a means of representing multiple typed <em>tracks</em> of time-based <em>media</em>, each of which may have their own representation in the form of <em>samples</em> interpreted according to their own CODECs.</p>
<h2>QuickTime Media Structure at a High Level</h2>
<p>As an example, a QuickTime file containing a video with associated stereo audio and subtitles may have three tracks, each with their own timebase:</p>
<ol>
<li>The video track, whose timebase is the number of frames per second, and whose <em>track media</em> is the CODEC metadata needed to decode its samples.</li>
<li>The audio track for the two audio channels, whose timebase is the number of samples per second. Its track media will be similar to that of the video, specifying the CODEC to use for the audio samples to decode.</li>
<li>The text track for the subtitles, whose timebase is probably derived from the video timebase, whose track media will specify things like the language and font of the subtitles, and whose samples consist of the text to present and the size, location, duration, and styling for that presentation.</li>
</ol>
<p>All of these are represented within a file as <em>atoms</em> which represent well-identified bags of data with arbitrary size and content, making it very easy to write general-purpose tooling and also to extend over time. (The last major extension to the low-level design was in the 1990s, to support 64-bit atom sizes, so it’s quite a stable format already.)</p>
<h2>Mapping QuickTime to Data Tape</h2>
<p>Once you realize that the tracks themselves can be arbitrary, it starts to become clear how this format maps nicely to tape content: Since tapes themselves are linear, they’re fundamentally time-based.</p>
<p>The actual content of a tape isn’t a pure stream of raw data, it’s a set of blocks of raw data between magnetic flux marks, with some gaps between — and thanks to media decay, those blocks can be good or bad. Usually these marks are used to organize tapes into files, but that’s not a guarantee; for both archival and emulation, it’s best to stick to the low-level representation and let applications impose the higher-level semantics.</p>
<p>In this case, you’d have a “tape data” track whose track media describes the original medium (7-track, 9-track, etc.) and the interpretation of its samples. The samples themselves would be the marks and data blocks. And there’s even a native representation of tape gaps, in the form of non-contiguous samples.</p>
<p>The format can also be leveraged to support random access <em>including writes</em>, since the intelligence for that can be in the “CODEC” for the “tape” track media, combined with the QuickTime format’s existing support for non-destructive edits. New data can be overlaid based on its “temporal” position, which should more or less accurately simulate how a rewritten tape would actually work, while still preserving the data that was just overwritten.</p>
<p>Finally, QuickTime has a concept of “references” that can be used to implement things like tape files independent of (rather than inline with) the tape data itself. A catalog of block references, for example, could also be stored with the tape data’s track media to indicate the block extents for individual files on tape, thus allowing direct access by tooling without having to stream through the entire file.</p>
<h2>Implementation</h2>
<p>Since QuickTime movie files are a moderately complex structure atop a simple base, it’s important to have a reasonable API to work with both the low-level atom structures as well as the higher-level constructs like tracks, track media, sample chunks and samples. Fortunately there already exists at least one Open Source library allowing this, <a href="https://github.com/macosforge/dss/tree/master/QTFileLib">QTFileLib</a> from the <a href="https://github.com/macosforge/dss">Darwin Streaming Server</a> that Apple made Open Source in 1999.</p>
<p>Darwin Streaming Server as a whole and its QTFileLib component are written in quite straightforward “C with Classes”-style C++, and QTFileLib has an API surface representing all of the major low-level and application-level concepts of the file format. As a side effect of the implementation of its read support, it also has a lot of the API necessary for creating and wiring together QuickTime data structures for creating files, just not support for writing it all out. Structurally that should be straightforward to add. It even looks straightforward to port to plain C, if that’s desired.</p>

				</div></div>
  </body>
</html>
