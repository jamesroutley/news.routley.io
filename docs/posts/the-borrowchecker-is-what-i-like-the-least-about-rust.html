<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://viralinstruction.com/posts/borrowchecker/">Original</a>
    <h1>The borrowchecker is what I like the least about Rust</h1>
    
    <div id="readability-page-1" class="page"><div> <p><em>Written 2025-07-18</em></p> <p>Among the 2010&#39;s cohort of programming languages, Rust is probably the most widely lauded.</p> <p>The main selling point of Rust is that it manages to combine speed and low-level control with a high level of bug-resistance, more commonly referred to as <em>safety</em>. The main innovation of Rust - really, its claim to fame - is its borrowchecker: the part of its compiler that enforces Rust&#39;s ownership rules and thereby allows Rust to achieve all the memory safety that garbage collected language enjoy, but with zero runtime cost. </p> <p> The <s>evangelists</s> proponents of Rust have made memory safety the central selling point of Rust, to the extent that the borrowchecker has become the defining feature of Rust&#39;s identity. I think the conflation of Rust&#39;s safety with the borrowchecker&#39;s guarantees is somewhat misguided. In this post, I want to make two arguments:</p> <ol> <li><p>That the borrowchecker causes <em>serious</em> ergonomic problems for Rust.</p> </li><li><p>That the role of the borrowchecker in Rust&#39;s safety is overstated.</p> </li></ol> <h3 id="the_fundamental_problem_of_the_borrowchecker"><a href="#the_fundamental_problem_of_the_borrowchecker">The fundamental problem of the borrowchecker</a></h3> <p>In a nutshell, the problem with Rust&#39;s borrowchecker is that it makes references a pain in the ass.</p> <p>On an abstract level, the reason for the pain is that the borrowchecker needs to know the lifetimes of all references <em>at compile time</em>, and this is simply an unrealistic proposal. Lifetimes are often an inherently runtime property.</p> <p>On an algorithmic level, the borrowchecker enforces a specific model, or set of rules around ownership, but this model is overly restrictive, and degrade Rust&#39;s ergonomics by rejecting far too many well-behaving programs.</p> <p>At the implementation level, the borrowchecker&#39;s current instantiation is incomplete, and often rejects programs that <em>adhere</em> to the model of ownership, even as that model is too restrictive in the first place. </p> <p>Borrowchecker frustration is like being brokenhearted - you can&#39;t easily demonstrate it, you have to suffer it yourself to understand what people are talking about. Real borrowchecker pain is not felt when your small, 20-line demonstration snippet fails to compile. It&#39;s when your existing project requires a small modification to ownership structure, and the borrowchecker then refuses to compile your code. Then, once you pull at the tiny loose fiber in your code&#39;s fabric, you find you have to unspool half your code before the borrowchecker is satisfied.</p> <p>Nonetheless, tiny examples can still serve to demonstrate the borrowchecker&#39;s propensity to reject perfectly fine code.</p> <h3 id="examples_where_the_borrowchecker_fails"><a href="#examples_where_the_borrowchecker_fails">Examples where the borrowchecker fails</a></h3> <p>The most clear examples are when the borrowchecker simply doesn&#39;t do what it&#39;s supposed to, because it rejects code that doesn&#39;t even violate the spirit of Rust&#39;s ownership rules.</p> <p>For example, consider this code I got from <a href="https://medium.com/@lordmoma/partial-borrowing-in-rust-the-struggle-is-real-17db9ed9be1a">a blog post</a>:</p> <div><pre><code><span>struct</span> Point {
    x: f64,
    y: f64,
}

impl Point {
    fn x_mut(&amp;mut self) -&gt; &amp;mut f64 {
        &amp;mut self.x
    }

    fn y_mut(&amp;mut self) -&gt; &amp;mut f64 {
        &amp;mut self.y
    }
}

fn main() {
    <span>let</span> mut point = Point { x: <span>1.0</span>, y: <span>2.0</span> };
    <span>let</span> x_ref = point.x_mut();
    <span>let</span> y_ref = point.y_mut();
    *x_ref *= <span>2.0</span>;
    *y_ref *= <span>2.0</span>;
}</code></pre></div> <p>This code won&#39;t compile, because the two mutable references <code>x_ref</code> and <code>y_ref</code> needs to exist simultaenously, which violates Rust&#39;s principle that a mutable reference to some data needs to unique at any point.</p> <p>Of course, this case is a false positive, since the references point to distinct fields of the same struct, and therefore <em>don&#39;t</em> refer to the same data. The borrowchecker rejects this code because the underlying rule of of the borrowchecker - namely: &#34;Mutation requires exclusivity&#34; is implemented <em>imprecisely</em>, such that the naunce between a reference to a field and a reference to a struct is lost.</p> <p>A similar, but slightly different example occurs in the code below</p> <div><pre><code><span>struct</span> Collection {
    counter: u32,
    items: Vec&lt;u32&gt;,
}

impl Collection {
    fn increment_counter(&amp;mut self) {
        self.counter += <span>1</span>;
    }
    
    pub fn count_items(&amp;mut self) {
        <span>for</span> _ <span>in</span> &amp;self.items {
            self.increment_counter();
        }    
    }
}</code></pre></div> <p>To the human reader, it&#39;s clear that <code>increment_counter</code> doesn&#39;t mutate <code>self.items</code>, and therefore cannot interfere with looping over the vector. Therefore, the of the borrowchecker: &#34;Mutation requires exclusivity&#34; is not violated, and the code should compile fine.</p> <p>Unfortunately, the borrowchecker can&#39;t reason across functions, and therefore incorrectly rejects the function.</p> <p>The borrowchecker is not only overly conservative when checking loans across functions; it can&#39;t even reason well about control flow <em>within</em> a function. The following example is a famous illustration of how it can&#39;t properly reason across <em>branches</em>, either:</p> <div><pre><code>fn get_default&lt;&#39;r, K: Hash + Eq + Copy, V: Default&gt;(
    map: &amp;&#39;r mut HashMap&lt;K, V&gt;,
    key: K,
) -&gt; &amp;&#39;r mut V {
    match map.get_mut(&amp;key) {
        <span>Some</span>(value) =&gt; value,
        None =&gt; {
            map.insert(key, V::default());
            map.get_mut(&amp;key).unwrap()
        }
    }
}</code></pre></div> <p>This is rejected due to the two mutable references, despite the program logic guaranteeing that the second reference is only created in the <code>None</code> branch, where the first reference is no longer live.</p> <p>There are more such <a href="https://blog.polybdenum.com/2024/12/21/four-limitations-of-rust-s-borrow-checker.html">unnecessary limitations of the borrowchecker</a>.</p> <h2 id="a_sufficiently_smart_borrowchecker"><a href="#a_sufficiently_smart_borrowchecker">A &#39;sufficiently smart borrowchecker&#39;</a></h2> <p>At this point, an Rust apologist might point out that, precisely because the above examples are implementation limitations, they are not fundamental, and might be lifted in the future as the implementation improves. There is some merit to the hope: Rust adopted so called <a href="https://blog.rust-lang.org/2022/08/05/nll-by-default/">non-lexical lifetimes</a> in 2022, which did improve the borrowchecker&#39;s accuracy. Similarly, a new formulation of the borrowchecker, called <a href="https://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/">Polonius</a> is in the works, which will improve accuracy still further.</p> <p>I remain sceptical. Polonius has been in the works for seven years now, and doesn&#39;t seem to be close to completion. More fundamentally, the borrowchecker will never be &#39;complete&#39;, because its job is to <em>reason</em> about your code, and programs just can&#39;t do that on level that is sufficiently deep. There is an obvious parallel with the mythical &#39;sufficiently smart compiler&#39; - just like compilers continuously improve, and yet never seem to really <em>understand</em> your code, and rarely are able to rewrite it on an algoritmic level, the borrowchecker will probably always reject seemingly obviously correct code.</p> <h3 id="the_rules_themselves_are_unergonomical"><a href="#the_rules_themselves_are_unergonomical">The rules themselves are unergonomical</a></h3> <p>Above, I demonstrated limitations in the <em>implementation</em> of the abstract ownership model. However, sometimes the model itself is just wrong for your program.</p> <p>Consider: </p> <div><pre><code><span>struct</span> Id(u32);

fn main() {
    <span>let</span> id = Id(<span>5</span>);
    <span>let</span> mut v = vec![id];
    println!(<span>&#34;{}&#34;</span>, id<span>.0</span>);
}</code></pre></div> <p>This is a clear-cut violation of the ownership rules: After <code>v</code> is constructed, <code>id</code> is moved into <code>v</code>, which prevents the function <code>main</code> from using <code>id</code> on the last line. There is a sense, then, in which the borrowchecker - in <em>any</em> implementation - ought to reject the program. It does fail the ownership rules.</p> <p>But what&#39;s the point of the rules in this case, though? Here, the ownership rules does not prevent use after free, or double free, or data races, or <em>any other bug</em>. It&#39;s perfectly clear to a human that this code is fine and doesn&#39;t have any <em>actual</em> ownership issues. But the borrowchecker, being a program, is very hard to negotiate with and dissuade from overly pedantic enforcement of a rigid, though in this case, pointless, set of rules.</p> <p>In the above case, the pedanticness doesn&#39;t matter much because the workaround is easy. But my experience has been <em>regularly</em> hitting these fundamental problems where the ownership model does not correspond to the needs of my program. For example: </p> <ul> <li><p>References to temporary values, e.g. values created in a closure, are forbidden even though it&#39;s obvious to a human that the solution is simply to extend the lifetime of the value to its use outside the closure.</p> </li><li><p>Struct withs mixed ownership: You can&#39;t have a struct with a field that contains a <code>Vec&lt;Thing&gt;</code> of things, which then also stores groups of the same things in another field in a <code>Vec&lt;Vec&lt;&amp;Thing&gt;&gt;</code>.</p> </li><li><p>Phylogenetic trees are a <em>massive pain</em> to implement, because each node having bidirectional references is fundamentally in conflict with Rust&#39;s concept that data has exactly one owner.</p> </li></ul> <p>It&#39;s hard to overstate how much these problems just <em>are not a thing</em> in garbage collected languages, but purely self-inflicted by Rust&#39;s borrowchecker. You want to build a tree with bidirectional references in Python? Just do the obvious thing, and it works perfectly. It&#39;s <em>possible</em> to do in Rust, but it&#39;s terribly complicated<sup id="fnref:1"><a href="#fndef:1">[1]</a></sup>.</p> <p>A common defense of Rust are that the pain Rust&#39;s borrowchecker inflicts on you is not <em>excess pain</em>, but rather <em>upfront pain</em>. The talking point goes: You have a program with a complicated ownership structure, and Rust merely forces you to be explicit about this. In doing so, it guarantees memory safety - and wouldn&#39;t you rather deal with compiler errors than production crashes?</p> <p>But that hasn&#39;t been my experience. My experience has been that borrowchecker problems are <em>mostly</em> just bullshit - invented problems without real grounding. For every time I experience a bug in Python that would have been prevented in Rust by its borrowchecker, I experience maybe twenty borrowchecker issues.</p> <p>Another common claim is that this kind of borrowchecker frustration is merely a beginner&#39;s struggle. Once you internalize the ownership model of Rust, you will automatically structure your code to conform to the borrowchecker, making all the problems go away. Unfortunately, after using Rust intermittently for a few years, this hasn&#39;t been my experience yet, and <a href="https://loglog.games/blog/leaving-rust-gamedev/#once-you-get-good-at-rust-all-of-these-problems-will-go-away">it seems I&#39;m not alone</a>.</p> <h3 id="why_dont_you_just"><a href="#why_dont_you_just">Why don&#39;t you just...</a></h3> <p>My examples code above may not be persuasive to experienced Rustaceans. They might argue that the snippets don&#39;t show there is any real ergonomic problem, because the solutions to make the snippets compile are completely trivial. In the last example, I could <em>just</em> derive <code>Clone + Copy</code> for <code>Id</code>.</p> <p>I know. The commonality of these stumbling blocks is that you <em>can</em> jump over them. You can, indeed, do extra work to fix whatever borrowchecker problems you have.</p> <p>The issue is that there was never a problem to begin with to warrant this extra work. Rust gates your <em>perfectly functional code</em> behind a lifetime puzzle, and forces you to refactor until you&#39;ve solved it. Rust insists your program&#39;s structure is a house of cards - touch one tiny thing, and large parts of it has to scrapped and rebuilt. The more Rust experience I gain, the more I suspect that is usually plain wrong. For <em>most</em> borrowchecker issues I face, the problem is not my program&#39;s structure, but the largely arbitrary restrictions of Rust.</p> <p>And sure, in the snippets above, the solution to the borrowchecker problems are trivial, but in larger-scale, real life code, they can be a real challenge. Perversely, <em>because</em> Rust&#39;s lifetime riddles are challenging, they are sort of <em>fun</em>. I believe that partly explains why so many people don&#39;t seem to mind them. Instead of thinking about how to write my code to solve the scientific problems I&#39;m being paid to solve, I have to think about how to write it to please the borrowchecker. The latter is usually more tractable, limited in scope, have clearer requirements and is more &#39;puzzle-like&#39;. In that sense, Rust enables <em>escapism</em>: When writing Rust, you get to solve lots of &#39;problems&#39; - not <em>real</em> problems, mind you, but <em>fun</em> problems.</p> <p>The usual way of obeying the borrowchecker is to refactor your code. Which is already unwelcome extra work, but sometimes even that is not enough. Let&#39;s look at some other ways people usually recommend me solving borrowchecker problems:</p> <h4 id="use_fewer_references_and_copy_data_or_just_clone"><a href="#use_fewer_references_and_copy_data_or_just_clone">Use fewer references and copy data. Or: &#34;Just clone&#34;.</a></h4> <p>This is generally good advice. Usually, extra allocations are fine, and the resulting performance degradation is not an issue. But it is a little strange that it allocations are encouraged in an otherwise performance-forcused language, not because the program logic demands it, but because the borrowchecker does.</p> <p>Of course, sometimes cloning doesn&#39;t solve the issue, because you really do need to mutate shared objects.</p> <h4 id="rc_arc_refcell_box_spam"><a href="#rc_arc_refcell_box_spam"><code>Rc / Arc / RefCell / Box</code> spam</a></h4> <p>Rust&#39;s <code>Arc</code> type disables some of Rust&#39;s ownership rules of the object it wraps, and instead reference counts that specific object. That means sometimes, the borrowchecker can be appeased by slapping <code>Arc</code> on a bunch of data throughout your program. Or, as I also like to call it &#34;managing the world&#39;s worst garbage collector, but with none of the convenience or performance&#34;.</p> <p>To be fair, adding a few selective <code>Arc</code>s or <code>RefCell</code>s are not a performance problem. It becomes a problem when these are used extensively to skirt around the borrowchecker, e.g. for every single node in a big graph.</p> <h4 id="use_indices_instead_of_references"><a href="#use_indices_instead_of_references">Use indices instead of references</a></h4> <p>When I first tried implementing a bidirected graph in Rust, I was suggested this pattern. A bidirected graph&#39;s edges can be represented by referencing the vertices by an integer ID, instead of an actual reference. Since you don&#39;t use references this way, you don&#39;t get any issues with the borrowchecker.</p> <p>The first time someone gave be this advice, I had to do a double take. The Rust community&#39;s <em>whole thing</em> is commitment to compiler-enforced correctness, and they built the borrowchecker on the premise that humans can&#39;t be trusted to handle references manually. When the same borrowchecker makes references unworkable, their solution is to... recommend that I manually manage them, with <em>zero</em> safety and <em>zero</em> language support?!? The irony is unreal. Asking people to manually manage references is so hilariously unsafe and unergonomic, the suggestion would be funny if it wasn&#39;t mostly sad.</p> <h2 id="rusts_safety_is_only_partly_due_to_the_borrowchecker"><a href="#rusts_safety_is_only_partly_due_to_the_borrowchecker">Rust&#39;s safety is only partly due to the borrowchecker</a></h2> <p>In online discourse, Rust&#39;s safety is sometimes equated with its memory safety in particular, which is attributed to the borrowchecker. Rust&#39;s reputation for bug-resistance is deserved, I think, but I believe it&#39;s due to Rust&#39;s <em>broadly</em> good taste and solid design. Like performance, correctness dies by a thousand cuts, and Rust is notable for being <em>consistently</em> correctness-focused:</p> <ul> <li><p>Its widespread use of enums plus exhaustive pattern matches, including for error states, makes it hard to ignore potential errors and edge cases.</p> </li><li><p>Its heavy use of custom types to encode information in the type system, where the compiler can statically prevent mistakes.</p> </li><li><p>Forced use of keyword arguments to construct structs, making it hard to switch up fields.</p> </li><li><p>A consistent focus on, and documentation of, edge cases in function APIs.</p> </li><li><p>Good tooling, e.g. <a href="https://crates.io/crates/cargo-semver-checks">cargo-semver-checks</a>, and a good built-in linter.</p> </li></ul> <p>More amorphous, but not less important is Rust&#39;s strong <em>cultural affinity</em> for correctness. For example, go to YouTube and click on some Rust conference channel. You&#39;ll see that a large fraction of the talks are on correctness, in some way or another. That&#39;s not something I see in Julia or Python conference talks.</p> <p>One way this materializes is that its standard library is packed with hard-to-misuse APIs. For example, compare Pythons <code>int.from_bytes</code> and Julia&#39;s analogous <code>reinterpret(::Int, ::AbstractArray)</code> with Rust&#39;s <code>i64::from_le_bytes</code>. All these functions&#39; results is determined by <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>, but <em>only</em> the Rust function makes the endianness explicit - in the two other languages, the onus is on the user to remember this potential correctness issue.</p> <p>I&#39;m certain that a language with the above features, but with a garbage collector instead of a borrowchecker would have the majority of Rust&#39;s correctness. OCaml and Haskell are like that, and they, too, have a strong reputation for safety and correctness. </p> <h2 id="okay_the_borrowchecker_isnt_all_bad"><a href="#okay_the_borrowchecker_isnt_all_bad">Okay, the borrowchecker isn&#39;t <em>all bad</em></a></h2> <p>As you might have noted by now, <em>I don&#39;t like the borrowchecker</em>, but even I have to grudgingly admit it has some use cases.</p> <p>Without a borrowchecker, you&#39;re left with either manual memory management, which is annoying and error-prone, or garbage collection (GC)<sup id="fnref:2"><a href="#fndef:2">[2]</a></sup>. GC also has its downsides:</p> <ul> <li><p>Marking and sweeping cause latency spikes which may be unacceptable if your program must have millisecond responsiveness.</p> </li><li><p>GC happens intermittently, which means garbage accumulates until each collection, and so your program is overall less memory efficient.</p> </li></ul> <p>Those two drawbacks alone could make GC a non-starter for some applications. Since Rust aims to be usable for low-level applications, such as bare-metal software operating system kernels, GC is not really a viable choice. Those constrains are entirely valid, but it&#39;s not constrains that most software, and certainly not most <em>scientific</em> software, are under. If you, like me, aren&#39;t building operating systems or programming microcontrollers, those drawbacks of GC doesn&#39;t apply.</p> <p>When comparing the borrowchecker to GC, there is also the issue of performance, which is not straightforward. GC has a reputation for poor performance because most GC languages like Java and Python are <em>otherwise</em> not performance oriented. When non-GC languages are compared to performance oriented GC languages like Julia and Go, the gap narrows. And even Julia and Go are decidedly higher level and offer the programmer less control than non-GC languages like Rust or C, making the comparison somewhat confounded.</p> <p>It&#39;s <a href="https://bitbashing.io/gc-for-systems-programmers.html">not entirely clear to me GC is slower than deterministic destruction</a>. Certainly, there are situations where the GC causes slowdown. One such situation is when the program&#39;s object graph is large, and it needs to be traversed at every collection. In that situation, I&#39;ve heard a programmer deride a GC by calling it a &#34;heap scanner&#34;. Or, when the program&#39;s allocation pattern means it blows the CPU cache between garbage collections, whereas deterministic destruction would reuse memory in hot cache. I&#39;ve seen demonstration Julia code showing this behaviour, where manually invoking <code>malloc</code> / <code>free</code> was <em>six times</em> faster than Julia&#39;s GC.</p> <p>On the other hand, a straightforward implementation of the <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/binarytrees.html">binary-trees benchmark</a><sup id="fnref:3"><a href="#fndef:3">[3]</a></sup> is several times faster in Julia than in Rust, because Julia&#39;s GC has higher throughput when run in bulk, compared to Rust&#39;s deterministic destruction which is invoked individually for each object.</p> <h3 id="and_okay_the_borrowchecker_does_prevent_some_bugs"><a href="#and_okay_the_borrowchecker_does_prevent_some_bugs">And okay, the borrowchecker <em>does</em> prevent some bugs</a></h3> <p>A garbage collector will prevent dangling pointers, use after free, and double free bugs. Buffer overflows are prevented by bounds checking. These are the main memory safety issues that Rust prevents, and it wouldn&#39;t need a borrowchecker to do so.</p> <p>But there <em>are</em> some bugs that a borrowchecker is uniquely suited to prevent: Data races in multithreaded code are elegantly and statically prevented by Rust. I have never written a large concurrent Rust program, and I&#39;ll grant the possibility that the borrowchecker is miraculous for that use case and easily pays for its own clunkiness. However, async Rust doesn&#39;t exacty <a href="https://bitbashing.io/async-rust.html">have a great reputation</a>.</p> <p>In single-threaded code, statically preventing mutation of externally held references <em>sounds</em> like it would prevent a lot of bugs, but my experience in Julia and Python is that I rarely encounter these bugs. Your mileage may vary.</p> <p>There are also some unexpected minor benefits of the borrowchecker that deserves mention: Guaranteeing the compiler that data is immutable unlocks optimisations, and likewise, guaranteeing that mutable data is not aliased enables other optimisations. The borrowchecker&#39;s mechanism can be leveraged for some nice, seemingly unrelated tricks, such as <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.get_mut">lock-free mutation of locks</a>, and <a href="https://crates.io/crates/parking_lot">locks that take up 1 byte of memory</a>.</p> <h3 id="conclusion"><a href="#conclusion">Conclusion</a></h3> <p>When coding in my day job, I switch between Julia, Python and Rust. I persistently experience the grass is greener on the other side of the fence: When I switch from Julia to Rust, I miss Julia&#39;s strengths. When I don&#39;t program in Rust, I miss the many good things that Rust offers: I miss Rust&#39;s concise enums and their exhaustive matches. I miss traits, and the strong guarantees they come with. I miss the great tooling, such as rust-analyser.</p> <p>I <em>absolutely</em> don&#39;t miss the borrowchecker.</p> <table id="fndef:1"> <tbody><tr> <td><a href="#fnref:1">[1]</a> </td><td>A famous Rust resource teaches people to write a doubly linked list in Rust, and in doing so demonstrates tonnes of Rust&#39;s features, because those are the wild hoops Rust programmers have to jump through: https://rust-unofficial.github.io/too-many-lists/. </td></tr></tbody></table> <table id="fndef:2"> <tbody><tr> <td><a href="#fnref:2">[2]</a> </td><td>I suppose you could also have reference counting like Swift, which, although it&#39;s technically garbage collection, is not what most people mean by that term. And you could have syntactic sugar coating manual memory management, like Zig. </td></tr></tbody></table> <table id="fndef:3"> <tbody><tr> <td><a href="#fnref:3">[3]</a> </td><td>The benchmark page lists Rust as being 7x faster than Julia. Amazingly, this is because there are different rules for GC versus non-GC languages. Only the latter are allowed to use custom memory management, and Rust only achieves its performance by using a custom bump allocator. This is perfectly doable in Julia, but arbitrarily banned in the competition. </td></tr></tbody></table>   </div></div>
  </body>
</html>
