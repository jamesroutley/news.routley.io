<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maltsev.space/blog/012-simd-within-a-register-how-i-doubled-hash-table-lookup-performance">Original</a>
    <h1>SIMD Within a Register: How I Doubled Hash Table Lookup Performance</h1>
    
    <div id="readability-page-1" class="page"><div><p>While working on a <a href="https://maltsev.space/blog/010-cuckoo-filters" rel="nofollow">Cuckoo Filter</a> implementation in C#, I created an array-like structure for the underlying hash table. I chose an 8-bit fingerprint: it aligns nicely on a byte boundary and still keeps the false-positive rate around <strong>3 %</strong>.</p> <p>The layout looked straightforward—just a byte array where the start of each bucket is calculated as <code>bucketIdx * bucketSize</code>. The size of each bucket is 4 slots, which is a solid choice for Cuckoo Filter.</p> <p><svg xmlns="http://www.w3.org/2000/svg" width="648" height="80"><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3"></circle></marker></defs><rect x="0" y="0" width="648" height="80"></rect><text x="114" y="12">Bucket</text><text x="170" y="12">0</text><text x="74" y="44">3A</text><text x="114" y="44">00</text><text x="154" y="44">B7</text><text x="194" y="44">F2</text><text x="290" y="12">Bucket</text><text x="346" y="12">1</text><text x="250" y="44">4C</text><text x="290" y="44">91</text><text x="330" y="44">00</text><text x="370" y="44">DE</text><text x="530" y="12">Bucket</text><text x="586" y="12">n</text><text x="490" y="44">AA</text><text x="530" y="44">00</text><text x="570" y="44">5F</text><text x="610" y="44">C8</text><text x="2" y="44">Table:</text><text x="426" y="44">...</text><g><line x1="60" y1="24" x2="220" y2="24"></line><line x1="60" y1="24" x2="60" y2="56"></line><line x1="100" y1="24" x2="100" y2="56"></line><line x1="140" y1="24" x2="140" y2="56"></line><line x1="180" y1="24" x2="180" y2="56"></line><line x1="220" y1="24" x2="220" y2="56"></line><line x1="60" y1="56" x2="220" y2="56"></line></g><g><line x1="236" y1="24" x2="396" y2="24"></line><line x1="236" y1="24" x2="236" y2="56"></line><line x1="276" y1="24" x2="276" y2="56"></line><line x1="316" y1="24" x2="316" y2="56"></line><line x1="356" y1="24" x2="356" y2="56"></line><line x1="396" y1="24" x2="396" y2="56"></line><line x1="236" y1="56" x2="396" y2="56"></line></g><g><line x1="476" y1="24" x2="636" y2="24"></line><line x1="476" y1="24" x2="476" y2="56"></line><line x1="516" y1="24" x2="516" y2="56"></line><line x1="556" y1="24" x2="556" y2="56"></line><line x1="596" y1="24" x2="596" y2="56"></line><line x1="636" y1="24" x2="636" y2="56"></line><line x1="476" y1="56" x2="636" y2="56"></line></g></svg><!----></p><!----> <p>But those four bytes in a bucket reminded me of something. They <em>feel</em> like … an integer!</p> <p>I wasn’t chasing ultra-low latency—after all, this is C#—but I couldn’t resist experimenting. Could I speed up lookups in my Cuckoo Filter by replacing the 4-byte bucket with a plain old 32-bit integer?</p> <p>Time to find out. 💪</p> <h2 id="contents"><a aria-hidden="true" tabindex="-1" href="#contents">#</a>Contents</h2> <ul><li><a href="#a-flexible-and-simple-implementation">A Flexible and Simple Implementation</a></li> <li><a href="#migrating-to-a-uint-table">Migrating to a <code>uint</code> Table</a></li> <li><a href="#finding-a-byte-with-masking">Finding a Byte with Masking</a></li> <li><a href="#xor-to-the-rescue">XOR to the Rescue</a></li> <li><a href="#what-about-existing-zeros">What About Existing Zeros?</a></li> <li><a href="#putting-it-all-together">Putting It All Together</a></li> <li><a href="#final-thoughts">Final Thoughts</a></li></ul> <h2 id="a-flexible-and-simple-implementation"><a aria-hidden="true" tabindex="-1" href="#a-flexible-and-simple-implementation">#</a>A Flexible and Simple Implementation</h2> <p>Here’s the naïve storage I began with. To keep the rest of the code clean, all table logic lives in its own class, whose heart is a pre-allocated byte array:</p> <!----><pre tabindex="0"><code><span><span>private</span><span> readonly</span><span> byte</span><span>[]</span><span> _table</span><span>;</span></span></code></pre><!----> <p>Each bucket has 4 slots, so there was no need for a second dimension; mapping a key to its bucket is obvious:</p> <!----><pre tabindex="0"><code><span><span>var</span><span> offset</span><span> =</span><span> bucketIdx </span><span>*</span><span> 4</span><span>;</span></span></code></pre><!----> <p>Checking whether a particular fingerprint (a single byte) sits in a bucket is just as obvious:</p> <!----><pre tabindex="0"><code><span><span>public</span><span> bool</span><span> Contains</span><span>(</span><span>byte</span><span> fingerprint</span><span>,</span><span> uint</span><span> bucketIdx</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    var</span><span> s</span><span> =</span><span> bucketIdx </span><span>*</span><span> 4</span><span>;</span></span>
<span><span>    for</span><span> (</span><span>var</span><span> i</span><span> =</span><span> s</span><span>;</span><span> i </span><span>&lt;</span><span> s </span><span>+</span><span> BucketSize</span><span>;</span><span> i</span><span>++</span><span>)</span></span>
<span><span>    {</span></span>
<span><span>        if</span><span> (</span><span>_table</span><span>[</span><span>i</span><span>]</span><span> ==</span><span> fingerprint</span><span>)</span><span> return</span><span> true</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    return</span><span> false</span><span>;</span></span>
<span><span>}</span></span></code></pre><!----> <p>(Please ignore the missing bounds checks—they’re not the point today.)</p> <p>I’m no bit-twiddling wizard—I live in a cosy, GC-collected world—but those 4 bytes kept itching. A bucket lines up <em>perfectly</em> with a 32-bit <code>uint</code>; that opens the door to a future lock-free <a href="https://en.wikipedia.org/wiki/Compare-and-swap" rel="nofollow">compare-and-swap</a>. So I decided to play.</p> <h2 id="migrating-to-a-uint-table"><a aria-hidden="true" tabindex="-1" href="#migrating-to-a-uint-table">#</a>Migrating to a <code>uint</code> Table</h2> <p>Switching the backing array is trivial because the hash table is still one-dimensional:</p> <!----><pre tabindex="0"><code><span><span>-</span><span> private readonly byte[] _table;</span></span>
<span><span>+</span><span> private readonly uint[] _table;</span></span></code></pre><!----> <p>Now let’s refactor the lookup:</p> <!----><pre tabindex="0"><code><span><span>public bool Contains(byte fingerprint, uint bucketIdx)</span></span>
<span><span>{</span></span>
<span><span>-</span><span>   var s = bucketIdx * 4;</span></span>
<span><span>+</span><span>   var bucket = _table[bucketIdx];</span></span>
<span><span>-</span><span>   for (var i = s; i &lt; s + BucketSize; i++)</span></span>
<span><span>+</span><span>   for (var i = 0; i &lt; BucketSize; i++)</span></span>
<span><span>    {</span></span>
<span><span>-</span><span>       if (_table[i] == fingerprint) return true;</span></span>
<span><span>+</span><span>       var shift = i * 8;</span></span>
<span><span>+</span><span>       var fp = (byte)(bucket &gt;&gt; shift);</span></span>
<span><span>+</span><span>       if (fp == fingerprint) return true;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    return false;</span></span>
<span><span>}</span></span></code></pre><!----> <p>The bucket offset disappears because each <code>uint</code> is a bucket. But I’ve lost the luxury of direct indexing—unless I convert the integer to bytes first:</p> <!----><pre tabindex="0"><code><span><span>  Span</span><span>&lt;</span><span>byte</span><span>&gt;</span><span> bucketBytes</span><span> =</span><span> stackalloc</span><span> byte</span><span>[</span><span>sizeof</span><span>(</span><span>uint</span><span>)];</span></span>
<span><span>  BitConverter</span><span>.</span><span>TryWriteBytes</span><span>(</span><span>bucketBytes</span><span>,</span><span> _table</span><span>[</span><span>bucketIdx</span><span>]);</span></span>
<span></span>
<span><span>  for</span><span> (</span><span>var</span><span> i</span><span> =</span><span> 0</span><span>;</span><span> i </span><span>&lt;</span><span> BucketSize</span><span>;</span><span> i</span><span>++</span><span>)</span></span>
<span><span>  {</span></span>
<span><span>      var</span><span> fp</span><span> =</span><span> bucketBytes</span><span>[</span><span>i</span><span>];</span></span>
<span><span>      if</span><span> (</span><span>fp </span><span>==</span><span> fingerprint</span><span>)</span><span> return</span><span> true</span><span>;</span></span>
<span><span>  }</span></span></code></pre><!----> <p>I ran a quick benchmark on both <code>uint</code>-based lookups, and the results were revealing. The shifting version gave a nice speed boost, about <strong>35%</strong> faster than the original byte-array loop. I’ve also tested the unrolled loop, but it showed no significant improvement because the compiler has already unrolled it.</p> <!----> <p>The <code>BitConverter</code> approach, however, was a step backward. It was even slower than the original, likely due to the additional <code>Span</code> overhead. I’m not about to introduce complexity for negative gain, so the <code>BitConverter</code> version was a non-starter.</p> <!----> <div data-callout="question" data-collapsible="false"><p>Even the shifting version is quite performant, can we do better? Maybe just eliminate the loop entirely?</p></div> <h2 id="finding-a-byte-with-masking"><a aria-hidden="true" tabindex="-1" href="#finding-a-byte-with-masking">#</a>Finding a Byte with Masking</h2> <p>Long ago I bookmarked Sean Anderson’s great <em><a href="https://graphics.stanford.edu/%7Eseander/bithacks.html" rel="nofollow">Bit Twiddling Hacks</a></em>. One gem there—<em>Determine if a word has a zero byte</em>—is exactly what I need. The C# version is nearly identical:</p> <!----><pre tabindex="0"><code><span><span>private</span><span> static</span><span> bool</span><span> HasZero</span><span>(</span><span>uint</span><span> v</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    return</span><span> ((</span><span>v </span><span>-</span><span> 0x01010101U</span><span>)</span><span> &amp;</span><span> ~</span><span>v </span><span>&amp;</span><span> 0x80808080U</span><span>)</span><span> !=</span><span> 0</span><span>;</span></span>
<span><span>}</span></span></code></pre><!----> <p>Admittedly opaque, so let’s unpack it.</p> <p>The core of the trick is <code>(v - 0x01010101U) &amp; ~v</code>. This expression has a special property:</p> <ul><li><strong>For any non-zero byte b</strong>, the most significant bit of <code>(b - 1) &amp; ~b</code> will always be <code>0</code>.</li> <li><strong>For a zero-byte b = 0x00</strong>, the expression becomes <code>(0x00 - 1) &amp; ~0x00</code>, which is <code>0xFF &amp; 0xFF = 0xFF</code>. The most significant bit is <code>1</code>.</li></ul> <p>So, this operation creates a “marker” bit (it sets the most significant bit to <code>1</code>) in any byte position that was originally <code>0x00</code>.</p> <p>Let’s apply it to our <code>v</code>, e.g., <code>0x4462002E</code>:</p> <p>First, we subtract <code>0x01010101U</code>.</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right" columnspacing="1em" rowlines="none solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">01000100</mtext><mtext>  </mtext><mtext mathvariant="monospace">01100010</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00101110</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x4462002E</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mtext>  </mtext><mrow><mtext mathvariant="monospace">00000001</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000001</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000001</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000001</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x01010101</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">01000011</mtext><mtext>  </mtext><mtext mathvariant="monospace">01100000</mtext><mtext>  </mtext><mtext mathvariant="monospace">11111111</mtext><mtext>  </mtext><mtext mathvariant="monospace">00101101</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x4360FF2D</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{r}
\texttt{01000100\;01100010\;00000000\;00101110}\;(\texttt{0x4462002E}) \\[-2pt]
-\;
\texttt{00000001\;00000001\;00000001\;00000001}\;(\texttt{0x01010101}) \\ \hline
\texttt{01000011\;01100000\;11111111\;00101101}\;(\texttt{0x4360FF2D})
\end{array}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>01000100</span><span></span><span>01100010</span><span></span><span>00000000</span><span></span><span>00101110</span></span><span></span><span>(</span><span><span>0x4462002E</span></span><span>)</span></span></span><span><span></span><span><span>−</span><span></span><span><span>00000001</span><span></span><span>00000001</span><span></span><span>00000001</span><span></span><span>00000001</span></span><span></span><span>(</span><span><span>0x01010101</span></span><span>)</span></span></span><span><span></span><span><span><span>01000011</span><span></span><span>01100000</span><span></span><span>11111111</span><span></span><span>00101101</span></span><span></span><span>(</span><span><span>0x4360FF2D</span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p> <div data-callout="note" data-collapsible="false"><p>Note that this is a single 32-bit subtraction, so borrows can cross byte boundaries. The <code>0x00</code> byte borrows from <code>0x62</code>, resulting in <code>0x...60FF...</code>.</p></div> <p>Second, we apply a bitwise NOT to the original value:</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right" columnspacing="1em" rowlines="solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">¬</mi><mtext>  </mtext><mrow><mtext mathvariant="monospace">01000100</mtext><mtext>  </mtext><mtext mathvariant="monospace">01100010</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00101110</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x4462002E</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">10111011</mtext><mtext>  </mtext><mtext mathvariant="monospace">10011101</mtext><mtext>  </mtext><mtext mathvariant="monospace">11111111</mtext><mtext>  </mtext><mtext mathvariant="monospace">11010001</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0xBB9DFFD1</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{r}
\neg\;
\texttt{01000100\;01100010\;00000000\;00101110}\;(\texttt{0x4462002E}) \\ \hline
\texttt{10111011\;10011101\;11111111\;11010001}\;(\texttt{0xBB9DFFD1})
\end{array}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>¬</span><span></span><span><span>01000100</span><span></span><span>01100010</span><span></span><span>00000000</span><span></span><span>00101110</span></span><span></span><span>(</span><span><span>0x4462002E</span></span><span>)</span></span></span><span><span></span><span><span><span>10111011</span><span></span><span>10011101</span><span></span><span>11111111</span><span></span><span>11010001</span></span><span></span><span>(</span><span><span>0xBB9DFFD1</span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p> <p>Now, <code>&amp;</code> them together:</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right" columnspacing="1em" rowlines="none solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">01000011</mtext><mtext>  </mtext><mtext mathvariant="monospace">01100000</mtext><mtext>  </mtext><mtext mathvariant="monospace">11111111</mtext><mtext>  </mtext><mtext mathvariant="monospace">00101101</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x4360FF2D</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo mathvariant="normal" lspace="0.22em" rspace="0.22em">&amp;</mo><mtext>  </mtext><mrow><mtext mathvariant="monospace">10111011</mtext><mtext>  </mtext><mtext mathvariant="monospace">10011101</mtext><mtext>  </mtext><mtext mathvariant="monospace">11111111</mtext><mtext>  </mtext><mtext mathvariant="monospace">11010001</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0xBB9DFFD1</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">00000011</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">11111111</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000001</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x0300FF01</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{r}
\texttt{01000011\;01100000\;11111111\;00101101}\;(\texttt{0x4360FF2D}) \\[-2pt]
\mathbin{\&amp;}\;
\texttt{10111011\;10011101\;11111111\;11010001}\;(\texttt{0xBB9DFFD1}) \\ \hline
\texttt{00000011\;00000000\;11111111\;00000001}\;(\texttt{0x0300FF01})
\end{array}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>01000011</span><span></span><span>01100000</span><span></span><span>11111111</span><span></span><span>00101101</span></span><span></span><span>(</span><span><span>0x4360FF2D</span></span><span>)</span></span></span><span><span></span><span><span><span>&amp;</span></span><span></span><span><span>10111011</span><span></span><span>10011101</span><span></span><span>11111111</span><span></span><span>11010001</span></span><span></span><span>(</span><span><span>0xBB9DFFD1</span></span><span>)</span></span></span><span><span></span><span><span><span>00000011</span><span></span><span>00000000</span><span></span><span>11111111</span><span></span><span>00000001</span></span><span></span><span>(</span><span><span>0x0300FF01</span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p> <p>Notice that the third byte from the left is <code>0xFF</code>. Its most significant bit is <code>1</code>, indicating that this was our zero-byte position.</p> <p>The final <code>&amp; 0x80808080U</code> is a mask that removes all other bits, leaving only the most significant bit of each byte.</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right" columnspacing="1em" rowlines="none solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">00000011</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">11111111</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000001</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x0300FF01</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo mathvariant="normal" lspace="0.22em" rspace="0.22em">&amp;</mo><mtext>  </mtext><mrow><mtext mathvariant="monospace">10000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">10000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">10000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">10000000</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x80808080</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">10000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x00008000</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{r}
\texttt{00000011\;00000000\;11111111\;00000001}\;(\texttt{0x0300FF01}) \\[-2pt]
\mathbin{\&amp;}\;
\texttt{10000000\;10000000\;10000000\;10000000}\;(\texttt{0x80808080}) \\ \hline
\texttt{00000000\;00000000\;10000000\;00000000}\;(\texttt{0x00008000})
\end{array}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>00000011</span><span></span><span>00000000</span><span></span><span>11111111</span><span></span><span>00000001</span></span><span></span><span>(</span><span><span>0x0300FF01</span></span><span>)</span></span></span><span><span></span><span><span><span>&amp;</span></span><span></span><span><span>10000000</span><span></span><span>10000000</span><span></span><span>10000000</span><span></span><span>10000000</span></span><span></span><span>(</span><span><span>0x80808080</span></span><span>)</span></span></span><span><span></span><span><span><span>00000000</span><span></span><span>00000000</span><span></span><span>10000000</span><span></span><span>00000000</span></span><span></span><span>(</span><span><span>0x00008000</span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p> <p>The method returns the result of <code>0x00008000 != 0</code>. Since <code>0x8000</code> is not zero, the expression is <code>true</code>, and the method correctly reports that the zero byte was found.</p> <p>Great, now I can detect a zero byte without branches. All that remains is to <em>turn the byte I’m searching for into zero</em>.</p> <h2 id="xor-to-the-rescue"><a aria-hidden="true" tabindex="-1" href="#xor-to-the-rescue">#</a>XOR to the Rescue</h2> <p>Let’s assume our integer, aka bucket, is <code>0x12345678</code> and I’m looking for byte <code>0x56</code>. Without shifts, this seems tough. Luckily, all we need to do is transform the <code>0x56</code> byte to <code>0x00</code>.</p> <div data-callout="note" data-collapsible="false"><p>What happens to the other bytes is irrelevant, because our <code>HasZero</code> trick only cares if <em>any</em> byte is zero.</p></div> <p>The XOR (<code>^</code>) operator has a useful property: <code>A ^ B = 0</code> if and only if <code>A == B</code>. So, if we XOR the entire bucket with a repeating mask of our target byte, only the matching byte will become zero.</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right" columnspacing="1em" rowlines="none solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">00010010</mtext><mtext>  </mtext><mtext mathvariant="monospace">00110100</mtext><mtext>  </mtext><mtext mathvariant="monospace">01010110</mtext><mtext>  </mtext><mtext mathvariant="monospace">01111000</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x12345678</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>⊕</mo><mtext>  </mtext><mrow><mtext mathvariant="monospace">01010110</mtext><mtext>  </mtext><mtext mathvariant="monospace">01010110</mtext><mtext>  </mtext><mtext mathvariant="monospace">01010110</mtext><mtext>  </mtext><mtext mathvariant="monospace">01010110</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x56565656</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">01000100</mtext><mtext>  </mtext><mtext mathvariant="monospace">01100010</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00101110</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x4462002E</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{r}
\texttt{00010010\;00110100\;01010110\;01111000}\;(\texttt{0x12345678}) \\[-2pt]
\oplus\;
\texttt{01010110\;01010110\;01010110\;01010110}\;(\texttt{0x56565656}) \\ \hline
\texttt{01000100\;01100010\;00000000\;00101110}\;(\texttt{0x4462002E})
\end{array}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>00010010</span><span></span><span>00110100</span><span></span><span>01010110</span><span></span><span>01111000</span></span><span></span><span>(</span><span><span>0x12345678</span></span><span>)</span></span></span><span><span></span><span><span>⊕</span><span></span><span><span>01010110</span><span></span><span>01010110</span><span></span><span>01010110</span><span></span><span>01010110</span></span><span></span><span>(</span><span><span>0x56565656</span></span><span>)</span></span></span><span><span></span><span><span><span>01000100</span><span></span><span>01100010</span><span></span><span>00000000</span><span></span><span>00101110</span></span><span></span><span>(</span><span><span>0x4462002E</span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p> <p>So the remaining part of this puzzle is to make a repetitive mask, which is pretty arithmetic: I should multiply target byte by <code>0x01010101U</code>:</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>mask</mtext><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mtext>0x56</mtext><mo>×</mo><mtext>0x01010101</mtext><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mtext>0x56565656</mtext></mrow><annotation encoding="application/x-tex">\text{mask} \;=\; \text{0x56} \times \text{0x01010101} \;=\; \text{0x56565656}

</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>mask</span></span><span></span><span></span><span>=</span><span></span><span></span></span><span><span></span><span><span>0x56</span></span><span></span><span>×</span><span></span></span><span><span></span><span><span>0x01010101</span></span><span></span><span></span><span>=</span><span></span><span></span></span><span><span></span><span><span>0x56565656</span></span></span></span></span></span></p> <h2 id="what-about-existing-zeros"><a aria-hidden="true" tabindex="-1" href="#what-about-existing-zeros">#</a>What About Existing Zeros?</h2> <p>A careful reader might ask: what happens if the bucket <em>already</em> has a zero byte in it? Does that mess up the logic?</p> <p>Let’s say our bucket is <code>0xAA00CCDD</code> and we’re searching for a non-zero fingerprint like <code>0xBB</code>. The XOR operation transforms the original zero into a non-zero value, so <code>HasZero</code> correctly returns <code>false</code>.</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right" columnspacing="1em" rowlines="none solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">10101010</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">11001100</mtext><mtext>  </mtext><mtext mathvariant="monospace">11011101</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0xAA00CCDD</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>⊕</mo><mtext>  </mtext><mrow><mtext mathvariant="monospace">10111011</mtext><mtext>  </mtext><mtext mathvariant="monospace">10111011</mtext><mtext>  </mtext><mtext mathvariant="monospace">10111011</mtext><mtext>  </mtext><mtext mathvariant="monospace">10111011</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0xBBBBBBBB</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">00010001</mtext><mtext>  </mtext><mtext mathvariant="monospace">10111011</mtext><mtext>  </mtext><mtext mathvariant="monospace">01110111</mtext><mtext>  </mtext><mtext mathvariant="monospace">01100110</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x11BB7766</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{r}
\texttt{10101010\;00000000\;11001100\;11011101}\;(\texttt{0xAA00CCDD}) \\[-2pt]
\oplus\;
\texttt{10111011\;10111011\;10111011\;10111011}\;(\texttt{0xBBBBBBBB}) \\ \hline
\texttt{00010001\;10111011\;01110111\;01100110}\;(\texttt{0x11BB7766})
\end{array}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>10101010</span><span></span><span>00000000</span><span></span><span>11001100</span><span></span><span>11011101</span></span><span></span><span>(</span><span><span>0xAA00CCDD</span></span><span>)</span></span></span><span><span></span><span><span>⊕</span><span></span><span><span>10111011</span><span></span><span>10111011</span><span></span><span>10111011</span><span></span><span>10111011</span></span><span></span><span>(</span><span><span>0xBBBBBBBB</span></span><span>)</span></span></span><span><span></span><span><span><span>00010001</span><span></span><span>10111011</span><span></span><span>01110111</span><span></span><span>01100110</span></span><span></span><span>(</span><span><span>0x11BB7766</span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p> <p>Now, what if we search for <code>0x00</code> itself (an empty slot in my case)? The mask is <code>0x00000000</code>, so the XOR leaves the bucket unchanged. <code>HasZero</code> is then applied to the result, which correctly finds the pre-existing zero and returns <code>true</code>.</p> <p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right" columnspacing="1em" rowlines="none solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">10101010</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">11001100</mtext><mtext>  </mtext><mtext mathvariant="monospace">11011101</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0xAA00CCDD</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>⊕</mo><mtext>  </mtext><mrow><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0x00000000</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="monospace">10101010</mtext><mtext>  </mtext><mtext mathvariant="monospace">00000000</mtext><mtext>  </mtext><mtext mathvariant="monospace">11001100</mtext><mtext>  </mtext><mtext mathvariant="monospace">11011101</mtext></mrow><mtext>  </mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">0xAA00CCDD</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{r}
\texttt{10101010\;00000000\;11001100\;11011101}\;(\texttt{0xAA00CCDD}) \\[-2pt]
\oplus\;
\texttt{00000000\;00000000\;00000000\;00000000}\;(\texttt{0x00000000}) \\ \hline
\texttt{10101010\;00000000\;11001100\;11011101}\;(\texttt{0xAA00CCDD})
\end{array}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>10101010</span><span></span><span>00000000</span><span></span><span>11001100</span><span></span><span>11011101</span></span><span></span><span>(</span><span><span>0xAA00CCDD</span></span><span>)</span></span></span><span><span></span><span><span>⊕</span><span></span><span><span>00000000</span><span></span><span>00000000</span><span></span><span>00000000</span><span></span><span>00000000</span></span><span></span><span>(</span><span><span>0x00000000</span></span><span>)</span></span></span><span><span></span><span><span><span>10101010</span><span></span><span>00000000</span><span></span><span>11001100</span><span></span><span>11011101</span></span><span></span><span>(</span><span><span>0xAA00CCDD</span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p> <p>So no, nothing breaks, the algorithm is still robust: <code>HasZero</code> only gives a positive result if a zero byte exists after the XOR, which only happens if our target fingerprint was in the bucket to begin with.</p> <h2 id="putting-it-all-together"><a aria-hidden="true" tabindex="-1" href="#putting-it-all-together">#</a>Putting It All Together</h2> <p>Here’s the final, branch-free lookup:</p> <!----><pre tabindex="0"><code><span><span>public</span><span> bool</span><span> Contains</span><span>(</span><span>byte</span><span> fingerprint</span><span>,</span><span> uint</span><span> bucketIdx</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    uint</span><span> bucket</span><span> =</span><span> _table</span><span>[</span><span>bucketIdx</span><span>];</span></span>
<span><span>    uint</span><span> mask</span><span> =</span><span> fingerprint </span><span>*</span><span> 0x01010101U</span><span>;</span></span>
<span><span>    uint</span><span> xored</span><span> =</span><span> bucket </span><span>^</span><span> mask</span><span>;</span></span>
<span><span>    return</span><span> ((</span><span>xored </span><span>-</span><span> 0x01010101U</span><span>)</span><span> &amp;</span><span> ~</span><span>xored </span><span>&amp;</span><span> 0x80808080U</span><span>)</span><span> !=</span><span> 0</span><span>;</span></span>
<span><span>}</span></span></code></pre><!----> <p>We XOR to zero-out matching bytes, then use the bit-twiddling trick to see if any byte is zero.</p> <p>The benchmarks confirmed this bit-twiddling exercise was well worth the effort. Positive lookups became over <strong>60% faster</strong>, while negative lookups became <strong>more than twice as fast</strong> compared to the original byte-array implementation. It’s a significant leap over the shifting version, too. While readability certainly took a hit, the raw performance gain is a trade-off I’m ok with.</p> <!----> <h2 id="final-thoughts"><a aria-hidden="true" tabindex="-1" href="#final-thoughts">#</a>Final Thoughts</h2> <p>I’m still not a huge fan of stuffing dense <a href="https://maltsev.space/blog/011-practical-bitwise-tricks-in-everyday-code" rel="nofollow">bit tricks</a> into production C#—they can be hard to read and even harder to maintain if something goes wrong. But I think this little adventure has been worth it: the lookup path is now twice as fast, and the codebase is still compact enough to keep the trick well-commented. I hope these notes save someone else a detour—or at the very least that you enjoyed this little optimization trip with me.</p><!----></div></div>
  </body>
</html>
