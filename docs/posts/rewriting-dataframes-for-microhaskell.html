<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mchav.github.io/rewriting-dataframes-for-microhs/">Original</a>
    <h1>Rewriting Dataframes for MicroHaskell</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h2 id="my-fondness-for-alternative-haskells">My fondness for alternative Haskells</h2>

<p>It’s often said that the best way to learn a programming language (or programming in general) is to make things that you actively use. After I first learnt Haskell, I thought it natural to try and make something I’ll use in my day-to-day life. An idea of what to make almost immediately sprang up in my head. Because I spent most of my college years travelling with the university’s debate team, I thought it would be cool to make a simple countdown timer with large bold text and changing colours that I’d use to time my speeches.</p>

<p>At that time (around 2015), it was incredibly difficult to write Haskell GUI applications, let alone mobile applications. The few examples that existed online were scant, “hello world” applications that didn’t seem like they could do much.</p>

<p>I stumbled across <a href="https://github.com/Frege/frege">Frege</a> (a dialect of Haskell for the JVM) and was warmly welcomed by the language’s small community. With the help of the two primary maintainers, Ingo and Dierk, I wrote my first large project in a functional programming language: <a href="https://github.com/mchav/froid">froid - a library for using the Frege programming language in Android development</a>.</p>

<p>I had many ideas of the directions I wanted to take the library - most of which were all the rage at the time: STM, functional reactive programming, etc. But using anything in the Haskell ecosystem was difficult because most libraries were extremely GHC-specific.</p>

<p>Eventually, Frege’s community fizzled out as the maintainers got busy and the general mid-2010s fervour around functional programming faded. All the other Haskell implementations lost traction slowly after (GHCJS and Eta).</p>

<p>But I still wish that there were a wider Haskell ecosystem that focused on use cases that GHC can’t address. I still wish that people would write code that other Haskells could co-opt with little to no friction.</p>

<p>The release of <a href="https://github.com/augustss/MicroHs/blob/master/doc/hs2024.pdf">MicroHs</a> was a strong reminder of that time. A new Haskell with much smaller binaries that came at a time when <a href="https://discourse.haskell.org/t/haskell-tools-could-loose-some-weight/11159">people were showing concern about the size of the GHC ecosystem</a>.</p>

<p>To be a good steward of the Haskell ecosystem at large, I figured it would be good to think through how my current personal effort, dataframe, could be decoupled from GHC.</p>

<h2 id="our-north-star">Our north star</h2>

<h3 id="what-is-a-dataframe">What is a dataframe?</h3>

<p>A dataframe is a heterogeneous collection of columns and their labels. It is, at its core, a very loosely typed thing since types in this domain are evolving “guesses” of what the data should look like. This is very hand-wavy, but there is a more serious treatment of the topic in the <a href="https://docs.google.com/document/d/1oIX_OWzoTXFeN9q7ZRuDuP1mQaRSvu4RhT2Tnj8uV2c/edit?pli=1&amp;tab=t.0">dataframe design document</a>.</p>

<p>The goal for this blog post will be to make an API that looks roughly like this (taken from the actual <a href="https://docs.google.com/document/d/1oIX_OWzoTXFeN9q7ZRuDuP1mQaRSvu4RhT2Tnj8uV2c/edit?pli=1&amp;tab=t.0"><code>dataframe</code></a> implementation):</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td><pre><span>{-# LANGUAGE OverloadedStrings #-}</span>
<span>module</span> <span>Main</span> <span>(</span><span>main</span><span>)</span> <span>where</span>

<span>import</span> <span>qualified</span> <span>DataFrame</span> <span>as</span> <span>D</span>
<span>import</span> <span>qualified</span> <span>DataFrame.Functions</span> <span>as</span> <span>F</span>

<span>import</span> <span>Data.Function</span> <span>((</span><span>&amp;</span><span>))</span>

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
    <span>let</span> <span>highs</span> <span>=</span> <span>[(</span><span>24</span> <span>::</span> <span>Int</span><span>),</span> <span>20</span><span>,</span> <span>22</span><span>,</span> <span>23</span><span>,</span> <span>25</span><span>,</span> <span>26</span><span>,</span> <span>26</span><span>]</span>
    <span>let</span> <span>lows</span> <span>=</span> <span>[(</span><span>14</span> <span>::</span> <span>Int</span><span>),</span> <span>13</span><span>,</span> <span>13</span><span>,</span> <span>13</span><span>,</span> <span>14</span><span>,</span> <span>15</span><span>,</span> <span>15</span><span>]</span>
    <span>let</span> <span>df</span> <span>=</span> <span>D</span><span>.</span><span>fromNamedColumns</span> <span>[</span>
        <span>(</span><span>&#34;Day&#34;</span><span>,</span> <span>D</span><span>.</span><span>fromList</span> <span>(</span><span>take</span> <span>(</span><span>length</span> <span>highs</span><span>)</span> <span>(</span><span>cycle</span> <span>[</span><span>&#34;Monday&#34;</span><span>,</span> <span>&#34;Tuesday&#34;</span><span>,</span> <span>&#34;Wednesday&#34;</span><span>,</span> <span>&#34;Thursday&#34;</span><span>,</span> <span>&#34;Friday&#34;</span><span>,</span> <span>&#34;Saturday&#34;</span><span>,</span> <span>&#34;Sunday&#34;</span><span>]))),</span>
        <span>(</span><span>&#34;High Temperature (Celcius)&#34;</span><span>,</span> <span>D</span><span>.</span><span>fromList</span> <span>highs</span><span>),</span>
        <span>(</span><span>&#34;Low Temperature (Celcius)&#34;</span><span>,</span> <span>D</span><span>.</span><span>fromList</span> <span>lows</span><span>)]</span>

    <span>-- Typed column references</span>
    <span>let</span> <span>high</span> <span>=</span> <span>F</span><span>.</span><span>col</span> <span>&#34;High Temperature (Celcius)&#34;</span> <span>::</span> <span>D</span><span>.</span><span>Expr</span> <span>Int</span>
    <span>let</span> <span>low</span> <span>=</span> <span>F</span><span>.</span><span>col</span> <span>&#34;Low Temperature (Celcius)&#34;</span> <span>::</span> <span>D</span><span>.</span><span>Expr</span> <span>Int</span>

    <span>-- Some expressions.</span>
    <span>let</span> <span>hotDays</span> <span>=</span> <span>df</span>
        <span>&amp;</span> <span>D</span><span>.</span><span>filterWhere</span> <span>(</span><span>high</span> <span>F</span><span>.&gt;=</span> <span>D</span><span>.</span><span>lit</span> <span>(</span><span>25</span> <span>::</span> <span>Int</span><span>))</span>
        <span>&amp;</span> <span>D</span><span>.</span><span>derive</span> <span>&#34;total&#34;</span> <span>(</span><span>high</span> <span>+</span> <span>low</span><span>)</span> 
        <span>&amp;</span> <span>D</span><span>.</span><span>derive</span> <span>&#34;year&#34;</span> <span>(</span><span>F</span><span>.</span><span>lit</span> <span>(</span><span>2025</span> <span>::</span> <span>Int</span><span>))</span> 
    <span>print</span> <span>hotDays</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The output should look roughly like this:</p>

<table>
  <thead>
    <tr>
      <th>row</th>
      <th>Day</th>
      <th>High Temp…</th>
      <th>Low Tempe…</th>
      <th>total</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>Friday</td>
      <td>25</td>
      <td>14</td>
      <td>39</td>
      <td>2025</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Saturday</td>
      <td>26</td>
      <td>15</td>
      <td>41</td>
      <td>2025</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Sunday</td>
      <td>26</td>
      <td>15</td>
      <td>41</td>
      <td>2025</td>
    </tr>
  </tbody>
</table>

<h3 id="our-constraints">Our constraints</h3>
<p>This will be a harder challenge than just using MicroHs (which already has some extensions enabled by default). What if we wanted to implement this without any extensions (well, except for one, which we’ll see later)? The current dataframe implementation makes liberal use of type families, GADTs and reflection to make the codebase easier to navigate. The features aren’t strictly necessary, however. If we make some sacrifices, we can create a base-only implementation of dataframes.</p>

<h2 id="implementation">Implementation</h2>
<h3 id="the-core-data-types">The core data types</h3>

<p>As we said above, a dataframe is a heterogeneous collection of columns and their labels. We can create a data type directly from this definition:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>data</span> <span>DataFrame</span> <span>=</span> <span>DataFrame</span> <span>{</span> <span>columns</span> <span>::</span> <span>[(</span><span>String</span><span>,</span> <span>Column</span><span>)]}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>That’s it. Anything tacked onto that definition is a refinement for performance or usability. For this post we’ll stick with this simple definition.</p>

<p>But what is a column?</p>

<p>In the main library, we allow columns to be of any type with a Show, Ord, and Eq instance. Since such flexibility would, in the future, compel us to use more complicated tactics to create functions, we’ll start with a simple formulation of a column. Our columns will be one of <code>Int</code>, <code>String</code>, or <code>Double</code>. Again, the data type comes straight from the definition (with a small addition):</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>data</span> <span>Column</span> <span>=</span> <span>CInt</span> <span>[(</span><span>Int</span><span>,</span><span>Int</span><span>)]</span>
            <span>|</span> <span>CDouble</span> <span>[(</span><span>Int</span><span>,</span> <span>Double</span><span>)]</span>
            <span>|</span> <span>CString</span> <span>[(</span><span>Int</span><span>,</span> <span>String</span><span>)]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>List are not a great choice for our column. Ideally, we would use vectors, arrays, or any other contiguous-memory data structure, but none of the options currently compile with microhs, so lists with indexes will do for now.</p>

<p>Now we can make a constructor for our dataframe:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>fromNamedColumns</span> <span>::</span> <span>[(</span><span>String</span><span>,</span> <span>Column</span><span>)]</span> <span>-&gt;</span> <span>DataFrame</span>
<span>fromNamedColumns</span> <span>=</span> <span>DataFrame</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>For columns, we use a type class which allows us to have a single function dispatched by each type in our universe.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>class</span> <span>ToColumn</span> <span>a</span> <span>where</span>
  <span>toColumn</span> <span>::</span> <span>[(</span><span>Int</span><span>,</span> <span>a</span><span>)]</span> <span>-&gt;</span> <span>Column</span>

<span>instance</span> <span>ToColumn</span> <span>Int</span>    <span>where</span> <span>toColumn</span> <span>=</span> <span>CInt</span>
<span>instance</span> <span>ToColumn</span> <span>Double</span> <span>where</span> <span>toColumn</span> <span>=</span> <span>CDouble</span>
<span>instance</span> <span>ToColumn</span> <span>[</span><span>Char</span><span>]</span> <span>where</span> <span>toColumn</span> <span>=</span> <span>CString</span>
<span>instance</span> <span>ToColumn</span> <span>Bool</span> <span>where</span> <span>toColumn</span> <span>=</span> <span>CBool</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We have to include the <code>FlexibleInstances</code> extension here, otherwise the compiler complains that we can only use simple types in instance declarations.</p>

<p>Our constructor for columns can therefore be written as follows:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>fromList</span> <span>::</span> <span>ToColumn</span> <span>a</span> <span>=&gt;</span> <span>[</span><span>a</span><span>]</span> <span>-&gt;</span> <span>Column</span>
<span>fromList</span> <span>xs</span> <span>=</span> <span>toColumn</span> <span>(</span><span>zip</span> <span>[</span><span>0</span><span>..</span><span>]</span> <span>xs</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We now have the first part of our program covered:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
  <span>let</span> <span>highs</span> <span>=</span> <span>[(</span><span>24</span> <span>::</span> <span>Int</span><span>),</span> <span>20</span><span>,</span> <span>22</span><span>,</span> <span>23</span><span>,</span> <span>25</span><span>,</span> <span>26</span><span>,</span> <span>26</span><span>]</span>
  <span>let</span> <span>lows</span> <span>=</span> <span>[(</span><span>14</span> <span>::</span> <span>Int</span><span>),</span> <span>13</span><span>,</span> <span>13</span><span>,</span> <span>13</span><span>,</span> <span>14</span><span>,</span> <span>15</span><span>,</span> <span>15</span><span>]</span>
  <span>let</span> <span>df</span> <span>=</span> <span>D</span><span>.</span><span>fromNamedColumns</span> <span>[</span>
                <span>(</span><span>&#34;Day&#34;</span><span>,</span> <span>D</span><span>.</span><span>fromList</span> <span>(</span><span>take</span> <span>(</span><span>length</span> <span>highs</span><span>)</span> <span>(</span><span>cycle</span> <span>[</span><span>&#34;Monday&#34;</span><span>,</span> <span>&#34;Tuesday&#34;</span><span>,</span> <span>&#34;Wednesday&#34;</span><span>,</span> <span>&#34;Thursday&#34;</span><span>,</span> <span>&#34;Friday&#34;</span><span>,</span> <span>&#34;Saturday&#34;</span><span>,</span> <span>&#34;Sunday&#34;</span><span>]))),</span>
                <span>(</span><span>&#34;High Temperature (Celcius)&#34;</span><span>,</span> <span>D</span><span>.</span><span>fromList</span> <span>highs</span><span>),</span>
                <span>(</span><span>&#34;Low Temperature (Celcius)&#34;</span><span>,</span> <span>D</span><span>.</span><span>fromList</span> <span>lows</span><span>)]</span>
  <span>pure</span> <span>()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>To see the dataframe we define a small helper module for pretty printing.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td><pre><span>module</span> <span>DataFrame.PrettyPrint</span> <span>(</span>
    <span>renderMarkdownTable</span>
<span>)</span> <span>where</span>

<span>import</span> <span>qualified</span> <span>Data.List</span> <span>as</span> <span>L</span>
<span>import</span>           <span>Data.Maybe</span>
<span>import</span>           <span>DataFrame.Core</span>
<span>import</span>           <span>DataFrame.Column</span>

<span>colMap</span> <span>::</span> <span>Column</span> <span>-&gt;</span> <span>[(</span><span>Int</span><span>,</span> <span>String</span><span>)]</span>
<span>colMap</span> <span>(</span><span>CInt</span> <span>xs</span><span>)</span>    <span>=</span> <span>[</span> <span>(</span><span>i</span><span>,</span> <span>show</span> <span>v</span><span>)</span> <span>|</span> <span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>&lt;-</span> <span>xs</span> <span>]</span>
<span>colMap</span> <span>(</span><span>CDouble</span> <span>xs</span><span>)</span> <span>=</span> <span>[</span> <span>(</span><span>i</span><span>,</span> <span>show</span> <span>v</span><span>)</span> <span>|</span> <span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>&lt;-</span> <span>xs</span> <span>]</span>
<span>colMap</span> <span>(</span><span>CString</span> <span>xs</span><span>)</span> <span>=</span> <span>[</span> <span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span>      <span>|</span> <span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>&lt;-</span> <span>xs</span> <span>]</span>

<span>escapeCell</span> <span>::</span> <span>String</span> <span>-&gt;</span> <span>String</span>
<span>escapeCell</span> <span>=</span> <span>concatMap</span> <span>(</span><span>\</span><span>c</span> <span>-&gt;</span> <span>case</span> <span>c</span> <span>of</span>
  <span>&#39;|&#39;</span> <span>-&gt;</span> <span>&#34;</span><span>\\</span><span>|&#34;</span>
  <span>&#39;</span><span>\n</span><span>&#39;</span> <span>-&gt;</span> <span>&#34;&lt;br&gt;&#34;</span>
 <span>_</span>    <span>-&gt;</span> <span>[</span><span>c</span><span>])</span>

<span>data</span> <span>Align</span> <span>=</span> <span>LeftA</span> <span>|</span> <span>RightA</span>

<span>colAlign</span> <span>::</span> <span>Column</span> <span>-&gt;</span> <span>Align</span>
<span>colAlign</span> <span>(</span><span>CString</span> <span>_</span><span>)</span> <span>=</span> <span>LeftA</span>
<span>colAlign</span> <span>_</span>           <span>=</span> <span>RightA</span>

<span>fit</span> <span>::</span> <span>Int</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>String</span>
<span>fit</span> <span>w</span> <span>s</span> <span>=</span>
  <span>let</span> <span>t</span> <span>=</span> <span>escapeCell</span> <span>s</span>
  <span>in</span> <span>if</span> <span>length</span> <span>t</span> <span>&lt;=</span> <span>w</span> <span>then</span> <span>t</span> <span>else</span> <span>take</span> <span>(</span><span>max</span> <span>1</span> <span>(</span><span>w</span><span>-</span><span>1</span><span>))</span> <span>t</span> <span>++</span> <span>&#34;…&#34;</span>

<span>pad</span> <span>::</span> <span>Align</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>String</span>
<span>pad</span> <span>LeftA</span>  <span>w</span> <span>s</span> <span>=</span> <span>s</span> <span>++</span> <span>replicate</span> <span>(</span><span>max</span> <span>0</span> <span>(</span><span>w</span> <span>-</span> <span>length</span> <span>s</span><span>))</span> <span>&#39; &#39;</span>
<span>pad</span> <span>RightA</span> <span>w</span> <span>s</span> <span>=</span> <span>replicate</span> <span>(</span><span>max</span> <span>0</span> <span>(</span><span>w</span> <span>-</span> <span>length</span> <span>s</span><span>))</span> <span>&#39; &#39;</span> <span>++</span> <span>s</span>

<span>alignMarker</span> <span>::</span> <span>Align</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>String</span>
<span>alignMarker</span> <span>LeftA</span>  <span>w</span> <span>=</span> <span>&#34;:&#34;</span> <span>++</span> <span>replicate</span> <span>(</span><span>max</span> <span>0</span> <span>(</span><span>w</span><span>-</span><span>1</span><span>))</span> <span>&#39;-&#39;</span>
<span>alignMarker</span> <span>RightA</span> <span>w</span> <span>=</span> <span>replicate</span> <span>(</span><span>max</span> <span>0</span> <span>(</span><span>w</span><span>-</span><span>1</span><span>))</span> <span>&#39;-&#39;</span> <span>++</span> <span>&#34;:&#34;</span>

<span>renderMarkdownTable</span> <span>::</span> <span>Maybe</span> <span>Int</span> <span>-&gt;</span> <span>DataFrame</span> <span>-&gt;</span> <span>String</span>
<span>renderMarkdownTable</span> <span>mW</span> <span>(</span><span>DataFrame</span> <span>cols</span><span>)</span> <span>=</span>
  <span>let</span> <span>names</span>   <span>=</span> <span>map</span> <span>fst</span> <span>cols</span>
 <span>maps</span>    <span>=</span> <span>map</span> <span>(</span><span>colMap</span> <span>.</span> <span>snd</span><span>)</span> <span>cols</span>
 <span>aligns</span>  <span>=</span> <span>map</span> <span>(</span><span>colAlign</span> <span>.</span> <span>snd</span><span>)</span> <span>cols</span>
 <span>allIdx</span>  <span>=</span> <span>L</span><span>.</span><span>sort</span> <span>.</span> <span>L</span><span>.</span><span>nub</span> <span>$</span> <span>concatMap</span> <span>(</span><span>map</span> <span>fst</span><span>)</span> <span>maps</span>

 <span>autoW</span> <span>=</span>
        <span>let</span> <span>headerParts</span> <span>=</span> <span>&#34;row&#34;</span> <span>:</span> <span>names</span>
 <span>cellLens</span>    <span>=</span> <span>concatMap</span> <span>(</span><span>map</span> <span>(</span><span>length</span> <span>.</span> <span>escapeCell</span><span>)</span> <span>.</span> <span>(</span><span>map</span> <span>snd</span><span>))</span> <span>maps</span>
 <span>headerLens</span>  <span>=</span> <span>map</span> <span>length</span> <span>headerParts</span>
 <span>rowLens</span>     <span>=</span> <span>map</span> <span>(</span><span>length</span> <span>.</span> <span>show</span><span>)</span> <span>allIdx</span>
        <span>in</span> <span>maximum</span> <span>(</span><span>1</span> <span>:</span> <span>(</span><span>cellLens</span> <span>++</span> <span>headerLens</span> <span>++</span> <span>rowLens</span><span>))</span>

 <span>w</span> <span>=</span> <span>max</span> <span>3</span> <span>$</span> <span>maybe</span> <span>autoW</span> <span>id</span> <span>mW</span>

 <span>fmtHeaderCell</span> <span>a</span> <span>s</span> <span>=</span> <span>pad</span> <span>a</span> <span>w</span> <span>(</span><span>fit</span> <span>w</span> <span>s</span><span>)</span>
 <span>fmtCell</span> <span>a</span> <span>s</span>       <span>=</span> <span>pad</span> <span>a</span> <span>w</span> <span>(</span><span>fit</span> <span>w</span> <span>s</span><span>)</span>

 <span>header</span> <span>=</span>
        <span>let</span> <span>first</span> <span>=</span> <span>fmtHeaderCell</span> <span>RightA</span> <span>&#34;row&#34;</span>
 <span>rest</span>  <span>=</span> <span>zipWith</span> <span>(</span><span>\</span><span>nm</span> <span>_</span> <span>-&gt;</span> <span>fmtHeaderCell</span> <span>LeftA</span> <span>nm</span><span>)</span> <span>names</span> <span>aligns</span>
        <span>in</span> <span>&#34;| &#34;</span> <span>++</span> <span>L</span><span>.</span><span>intercalate</span> <span>&#34; | &#34;</span> <span>(</span><span>first</span> <span>:</span> <span>rest</span><span>)</span> <span>++</span> <span>&#34; |</span><span>\n</span><span>&#34;</span>

 <span>sep</span> <span>=</span>
        <span>let</span> <span>first</span> <span>=</span> <span>alignMarker</span> <span>RightA</span> <span>w</span>
 <span>rest</span>  <span>=</span> <span>map</span> <span>(`</span><span>alignMarker</span><span>`</span> <span>w</span><span>)</span> <span>aligns</span>
        <span>in</span> <span>&#34;| &#34;</span> <span>++</span> <span>L</span><span>.</span><span>intercalate</span> <span>&#34; | &#34;</span> <span>(</span><span>first</span> <span>:</span> <span>rest</span><span>)</span> <span>++</span> <span>&#34; |</span><span>\n</span><span>&#34;</span>

 <span>row</span> <span>i</span> <span>=</span>
        <span>let</span> <span>first</span> <span>=</span> <span>fmtCell</span> <span>RightA</span> <span>(</span><span>show</span> <span>i</span><span>)</span>
 <span>rest</span>  <span>=</span> <span>zipWith3</span>
 <span>(</span><span>\</span><span>m</span> <span>a</span> <span>_</span> <span>-&gt;</span> <span>fmtCell</span> <span>a</span> <span>(</span><span>fromMaybe</span> <span>&#34;&#34;</span> <span>(</span><span>lookup</span> <span>i</span> <span>m</span><span>)))</span>
 <span>maps</span> <span>aligns</span> <span>names</span>
        <span>in</span> <span>&#34;| &#34;</span> <span>++</span> <span>L</span><span>.</span><span>intercalate</span> <span>&#34; | &#34;</span> <span>(</span><span>first</span> <span>:</span> <span>rest</span><span>)</span> <span>++</span> <span>&#34; |</span><span>\n</span><span>&#34;</span>
  <span>in</span> <span>header</span> <span>++</span> <span>sep</span> <span>++</span> <span>concatMap</span> <span>row</span> <span>allIdx</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The <code>renderMarkdownTable</code> function takes an optional width argument and truncates all columns to that width.</p>

<h3 id="expressions">Expressions</h3>

<p>This is the difficult part. We want to be able to express binary and unary operations for our dataframe.</p>

<p>We have the extra constraint that our operations can only work within our type universe (<code>Int</code>, <code>String</code>, and <code>Double</code>). In GHC we’d typically pull out GADTs for this and define the expression as follows:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>data</span> <span>Expr</span> <span>a</span> <span>where</span>
 <span>Col</span> <span>::</span> <span>String</span> <span>-&gt;</span> <span>Expr</span> <span>a</span>  <span>-- | Column references</span>
 <span>Lit</span> <span>::</span> <span>a</span> <span>-&gt;</span> <span>Expr</span> <span>a</span>       <span>-- | Literals</span>
 <span>UnaryOp</span> <span>::</span> <span>(</span><span>ToColumn</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>(</span><span>b</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>-&gt;</span> <span>Expr</span> <span>b</span> <span>-&gt;</span> <span>Expr</span> <span>a</span>
 <span>BinaryOp</span> <span>::</span> <span>(</span><span>ToColumn</span> <span>c</span><span>,</span> <span>ToColumn</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>(</span><span>c</span> <span>-&gt;</span> <span>b</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>-&gt;</span> <span>Expr</span> <span>c</span> <span>-&gt;</span> <span>Expr</span> <span>b</span> <span>-&gt;</span> <span>Expr</span> <span>a</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>But since we don’t have that at our disposal (NB: MicroHs has GADTs, but remember we’re making this problem strictly more difficult), we have to enumerate our type universe. Since we only have three types, this is still fine.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td><pre><span>data</span> <span>Expr</span> <span>a</span> <span>=</span>
 <span>Col</span> <span>String</span>
 <span>|</span> <span>Lit</span> <span>a</span>
 <span>|</span> <span>UnaryIntOp</span> <span>(</span><span>Int</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span>
 <span>|</span> <span>UnaryDoubleOp</span> <span>(</span><span>Double</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span>
 <span>|</span> <span>UnaryStringOp</span> <span>(</span><span>String</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span>
 <span>|</span> <span>UnaryBoolOp</span> <span>(</span><span>Bool</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span>

    <span>-- Binary Ops</span>
 <span>|</span> <span>BinaryIntToIntOp</span> <span>(</span><span>Int</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span>
 <span>|</span> <span>BinaryIntToDoubleOp</span> <span>(</span><span>Int</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span>
 <span>|</span> <span>BinaryIntToStringOp</span> <span>(</span><span>Int</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span>
 <span>|</span> <span>BinaryIntToBoolOp</span> <span>(</span><span>Int</span> <span>-&gt;</span> <span>Bool</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span>

 <span>|</span> <span>BinaryDoubleToIntOp</span> <span>(</span><span>Double</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span>
 <span>|</span> <span>BinaryDoubleToDoubleOp</span> <span>(</span><span>Double</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span>
 <span>|</span> <span>BinaryDoubleToStringOp</span> <span>(</span><span>Double</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span>
 <span>|</span> <span>BinaryDoubleToBoolOp</span> <span>(</span><span>Double</span> <span>-&gt;</span> <span>Bool</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span>
    
 <span>|</span> <span>BinaryStringToIntOp</span> <span>(</span><span>String</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span>
 <span>|</span> <span>BinaryStringToDoubleOp</span> <span>(</span><span>String</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span>
 <span>|</span> <span>BinaryStringToStringOp</span> <span>(</span><span>String</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span>
 <span>|</span> <span>BinaryStringToBoolOp</span> <span>(</span><span>String</span> <span>-&gt;</span> <span>Bool</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span>

 <span>|</span> <span>BinaryBoolToIntOp</span> <span>(</span><span>Bool</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span> <span>(</span><span>Expr</span> <span>Int</span><span>)</span>
 <span>|</span> <span>BinaryBoolToDoubleOp</span> <span>(</span><span>Bool</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span> <span>(</span><span>Expr</span> <span>Double</span><span>)</span>
 <span>|</span> <span>BinaryBoolToStringOp</span> <span>(</span><span>Bool</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span> <span>(</span><span>Expr</span> <span>String</span><span>)</span>
 <span>|</span> <span>BinaryBoolToBoolOp</span> <span>(</span><span>Bool</span> <span>-&gt;</span> <span>Bool</span> <span>-&gt;</span> <span>a</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span> <span>(</span><span>Expr</span> <span>Bool</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>To interpret our expressions, we need to create a function that takes in an expression and a dataframe.</p>

<p>The <code>interpret</code> function should return a column that is the result of applying our expression to the dataframe. Because our expression tree is verbose, the interpret function will be verbose as well.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td><pre><span>interpret</span> <span>::</span> <span>(</span><span>ToColumn</span> <span>a</span><span>)</span> <span>=&gt;</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>DataFrame</span> <span>-&gt;</span> <span>Column</span>
<span>interpret</span> <span>(</span><span>Col</span> <span>name</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>lookup</span> <span>name</span> <span>(</span><span>columns</span> <span>df</span><span>)</span> <span>of</span>
 <span>Nothing</span> <span>-&gt;</span> <span>fromList</span> <span>(</span><span>[]</span> <span>::</span> <span>[[</span><span>Char</span><span>]])</span>
 <span>Just</span> <span>c</span>  <span>-&gt;</span> <span>c</span>
<span>interpret</span> <span>(</span><span>Lit</span> <span>value</span><span>)</span> <span>df</span> <span>=</span> <span>let</span>
 <span>ixs</span> <span>=</span> <span>case</span> <span>(</span><span>columns</span> <span>df</span><span>)</span> <span>of</span>
 <span>((</span><span>_</span><span>,</span> <span>(</span><span>CInt</span> <span>xs</span><span>))</span><span>:</span> <span>rest</span><span>)</span>    <span>-&gt;</span> <span>map</span> <span>fst</span> <span>xs</span>
 <span>((</span><span>_</span><span>,</span> <span>(</span><span>CDouble</span> <span>xs</span><span>))</span><span>:</span> <span>rest</span><span>)</span> <span>-&gt;</span> <span>map</span> <span>fst</span> <span>xs</span>
 <span>((</span><span>_</span><span>,</span> <span>(</span><span>CString</span> <span>xs</span><span>))</span><span>:</span> <span>rest</span><span>)</span> <span>-&gt;</span> <span>map</span> <span>fst</span> <span>xs</span>
 <span>((</span><span>_</span><span>,</span> <span>(</span><span>CBool</span> <span>xs</span><span>))</span><span>:</span> <span>rest</span><span>)</span>   <span>-&gt;</span> <span>map</span> <span>fst</span> <span>xs</span>
            <span>[]</span> <span>-&gt;</span> <span>(</span><span>[]</span> <span>::</span> <span>[</span><span>Int</span><span>])</span>
    <span>in</span> <span>toColumn</span> <span>(</span><span>zip</span> <span>ixs</span> <span>(</span><span>replicate</span> <span>(</span><span>length</span> <span>ixs</span><span>)</span> <span>value</span><span>))</span>
<span>interpret</span> <span>(</span><span>UnaryIntOp</span> <span>f</span> <span>e</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>interpret</span> <span>e</span> <span>df</span> <span>of</span>
 <span>CInt</span> <span>xs</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>map</span> <span>(</span><span>\</span><span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>-&gt;</span> <span>(</span><span>i</span><span>,</span> <span>f</span> <span>v</span><span>))</span> <span>xs</span><span>)</span>
 <span>_</span>       <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>UnaryDoubleOp</span> <span>f</span> <span>e</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>interpret</span> <span>e</span> <span>df</span> <span>of</span>
 <span>CDouble</span> <span>xs</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>map</span> <span>(</span><span>\</span><span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>-&gt;</span> <span>(</span><span>i</span><span>,</span> <span>f</span> <span>v</span><span>))</span> <span>xs</span><span>)</span>
 <span>_</span>       <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>UnaryStringOp</span> <span>f</span> <span>e</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>interpret</span> <span>e</span> <span>df</span> <span>of</span>
 <span>CString</span> <span>xs</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>map</span> <span>(</span><span>\</span><span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>-&gt;</span> <span>(</span><span>i</span><span>,</span> <span>f</span> <span>v</span><span>))</span> <span>xs</span><span>)</span>
 <span>_</span>       <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>UnaryBoolOp</span> <span>f</span> <span>e</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>interpret</span> <span>e</span> <span>df</span> <span>of</span>
 <span>CBool</span> <span>xs</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>map</span> <span>(</span><span>\</span><span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>-&gt;</span> <span>(</span><span>i</span><span>,</span> <span>f</span> <span>v</span><span>))</span> <span>xs</span><span>)</span>
 <span>_</span>       <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryIntToIntOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
    <span>-- Assumes indices are the same.</span>
    <span>-- TODO: We could line these up.</span>
 <span>(</span><span>CInt</span> <span>xs</span><span>,</span> <span>CInt</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryIntToDoubleOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CInt</span> <span>xs</span><span>,</span> <span>CDouble</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryIntToStringOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CInt</span> <span>xs</span><span>,</span> <span>CString</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryIntToBoolOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CInt</span> <span>xs</span><span>,</span> <span>CBool</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>-- | Double</span>
<span>interpret</span> <span>(</span><span>BinaryDoubleToIntOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CDouble</span> <span>xs</span><span>,</span> <span>CInt</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryDoubleToDoubleOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CDouble</span> <span>xs</span><span>,</span> <span>CDouble</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryDoubleToStringOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CDouble</span> <span>xs</span><span>,</span> <span>CString</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryDoubleToBoolOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CDouble</span> <span>xs</span><span>,</span> <span>CBool</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>-- | String</span>
<span>interpret</span> <span>(</span><span>BinaryStringToIntOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CString</span> <span>xs</span><span>,</span> <span>CInt</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryStringToDoubleOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CString</span> <span>xs</span><span>,</span> <span>CDouble</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryStringToStringOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CString</span> <span>xs</span><span>,</span> <span>CString</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryStringToBoolOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CString</span> <span>xs</span><span>,</span> <span>CBool</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>-- | Bool</span>
<span>interpret</span> <span>(</span><span>BinaryBoolToIntOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CBool</span> <span>xs</span><span>,</span> <span>CInt</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryBoolToDoubleOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CBool</span> <span>xs</span><span>,</span> <span>CDouble</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryBoolToStringOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CBool</span> <span>xs</span><span>,</span> <span>CString</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
<span>interpret</span> <span>(</span><span>BinaryBoolToBoolOp</span> <span>f</span> <span>l</span> <span>r</span><span>)</span> <span>df</span> <span>=</span> <span>case</span> <span>(</span><span>interpret</span> <span>l</span> <span>df</span><span>,</span> <span>interpret</span> <span>r</span> <span>df</span><span>)</span> <span>of</span>
 <span>(</span><span>CBool</span> <span>xs</span><span>,</span> <span>CBool</span> <span>ys</span><span>)</span> <span>-&gt;</span> <span>toColumn</span> <span>(</span><span>zipWith</span> <span>(</span><span>\</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>(</span><span>a&#39;</span><span>,</span> <span>b&#39;</span><span>)</span> <span>-&gt;</span> <span>(</span><span>a</span><span>,</span> <span>f</span> <span>b</span> <span>b&#39;</span><span>))</span> <span>xs</span> <span>ys</span><span>)</span>
 <span>_</span> <span>-&gt;</span> <span>error</span> <span>&#34;Type mismatch&#34;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Functions must also be laboriously defined in this way. We define type classes of operations that dispatch our operations to the right node of our expression tree. We’ll start with addition, equality and the greater-than-or-equal-to operation. The approach can easily be extended to other functions.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td><pre><span>-- | Each function must have a type class that specialises it to the</span>
<span>-- | right type.</span>

<span>class</span> <span>ExprEq</span> <span>a</span> <span>where</span>
    <span>eq</span> <span>::</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>Expr</span> <span>Bool</span>

<span>instance</span> <span>ExprEq</span> <span>Int</span> <span>where</span>
 <span>eq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryIntToIntOp</span> <span>(</span><span>==</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprEq</span> <span>Double</span> <span>where</span>
 <span>eq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryDoubleToDoubleOp</span> <span>(</span><span>==</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprEq</span> <span>[</span><span>Char</span><span>]</span> <span>where</span>
 <span>eq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryStringToStringOp</span> <span>(</span><span>==</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprEq</span> <span>Bool</span> <span>where</span>
 <span>eq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryBoolToBoolOp</span> <span>(</span><span>==</span><span>)</span> <span>l</span> <span>r</span>


<span>class</span> <span>ExprGeq</span> <span>a</span> <span>where</span>
    <span>geq</span> <span>::</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>Expr</span> <span>Bool</span>

<span>instance</span> <span>ExprGeq</span> <span>Int</span> <span>where</span>
 <span>geq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryIntToIntOp</span> <span>(</span><span>&gt;=</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprGeq</span> <span>Double</span> <span>where</span>
 <span>geq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryDoubleToDoubleOp</span> <span>(</span><span>&gt;=</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprGeq</span> <span>[</span><span>Char</span><span>]</span> <span>where</span>
 <span>geq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryStringToStringOp</span> <span>(</span><span>&gt;=</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprGeq</span> <span>Bool</span> <span>where</span>
 <span>geq</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryBoolToBoolOp</span> <span>(</span><span>&gt;=</span><span>)</span> <span>l</span> <span>r</span>

<span>-- For addition</span>
<span>class</span> <span>ExprAdd</span> <span>a</span> <span>where</span>
    <span>add</span> <span>::</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>Expr</span> <span>a</span>

<span>instance</span> <span>ExprAdd</span> <span>Int</span> <span>where</span>
 <span>add</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryIntToIntOp</span> <span>(</span><span>+</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprAdd</span> <span>Double</span> <span>where</span>
 <span>add</span> <span>l</span> <span>r</span> <span>=</span> <span>BinaryDoubleToDoubleOp</span> <span>(</span><span>+</span><span>)</span> <span>l</span> <span>r</span>

<span>instance</span> <span>ExprAdd</span> <span>[</span><span>Char</span><span>]</span> <span>where</span>
 <span>add</span> <span>l</span> <span>r</span> <span>=</span> <span>error</span> <span>&#34;Cannot add strings&#34;</span>

<span>instance</span> <span>ExprAdd</span> <span>Bool</span> <span>where</span>
 <span>add</span> <span>l</span> <span>r</span> <span>=</span> <span>error</span> <span>&#34;Cannot add bools&#34;</span>

<span>-- | Num instance</span>
<span>instance</span> <span>(</span><span>ToColumn</span> <span>a</span><span>,</span> <span>Num</span> <span>a</span><span>,</span> <span>ExprAdd</span> <span>a</span><span>)</span> <span>=&gt;</span> <span>Num</span> <span>(</span><span>Expr</span> <span>a</span><span>)</span> <span>where</span>
 <span>(</span><span>+</span><span>)</span> <span>=</span> <span>add</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we are ready to define our work-horses: <code>filterWhere</code> and <code>derive</code>. <code>filterWhere</code> takes the indices of the column returned by a boolean expression and selects them from all the other columns. <code>derive</code> takes an expression, evaluates it to a column, then adds it to the dataframe.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>filterWhere</span> <span>::</span> <span>Expr</span> <span>Bool</span> <span>-&gt;</span> <span>DataFrame</span> <span>-&gt;</span> <span>DataFrame</span>
<span>filterWhere</span> <span>expr</span> <span>df</span> <span>=</span> <span>case</span> <span>interpret</span> <span>expr</span> <span>df</span> <span>of</span>
 <span>(</span><span>CBool</span> <span>xs</span><span>)</span> <span>-&gt;</span> <span>let</span>
 <span>ixs</span> <span>=</span> <span>map</span> <span>fst</span> <span>(</span><span>filter</span> <span>snd</span> <span>xs</span><span>)</span>
        <span>in</span> <span>fromNamedColumns</span> <span>$</span> <span>map</span> <span>(</span><span>\</span><span>(</span><span>i</span><span>,</span> <span>v</span><span>)</span> <span>-&gt;</span> <span>(</span><span>i</span><span>,</span> <span>atIndicies</span> <span>ixs</span> <span>v</span><span>))</span> <span>(</span><span>columns</span> <span>df</span><span>)</span>
 <span>_</span>          <span>-&gt;</span> <span>error</span> <span>&#34;Should not be possible&#34;</span>

<span>derive</span> <span>::</span> <span>ToColumn</span> <span>a</span> <span>=&gt;</span> <span>String</span> <span>-&gt;</span> <span>Expr</span> <span>a</span> <span>-&gt;</span> <span>DataFrame</span> <span>-&gt;</span> <span>DataFrame</span>
<span>derive</span> <span>name</span> <span>expr</span> <span>df</span> <span>=</span> <span>DataFrame</span> <span>((</span><span>columns</span> <span>df</span><span>)</span> <span>++</span> <span>[(</span><span>name</span><span>,</span> <span>interpret</span> <span>expr</span> <span>df</span><span>)])</span>


<span>-- | Small helper to select indices</span>
<span>atIndicies</span> <span>::</span> <span>[</span><span>Int</span><span>]</span> <span>-&gt;</span> <span>Column</span> <span>-&gt;</span> <span>Column</span>
<span>atIndicies</span> <span>ixs</span> <span>(</span><span>CInt</span> <span>xs</span><span>)</span> <span>=</span> <span>CInt</span> <span>(</span><span>filter</span> <span>((`</span><span>elem</span><span>`</span> <span>ixs</span><span>)</span> <span>.</span> <span>fst</span><span>)</span> <span>xs</span><span>)</span>
<span>atIndicies</span> <span>ixs</span> <span>(</span><span>CDouble</span> <span>xs</span><span>)</span> <span>=</span> <span>CDouble</span> <span>(</span><span>filter</span> <span>((`</span><span>elem</span><span>`</span> <span>ixs</span><span>)</span> <span>.</span> <span>fst</span><span>)</span> <span>xs</span><span>)</span>
<span>atIndicies</span> <span>ixs</span> <span>(</span><span>CString</span> <span>xs</span><span>)</span> <span>=</span> <span>CString</span> <span>(</span><span>filter</span> <span>((`</span><span>elem</span><span>`</span> <span>ixs</span><span>)</span> <span>.</span> <span>fst</span><span>)</span> <span>xs</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We can now run the code we initially set out to run.</p>

<p><a href="https://github.com/mchav/dataframe-mhs">The full code for this example is on Github</a>.</p>

<h2 id="comparing-microhs-and-ghc">Comparing MicroHs and GHC</h2>
<p>Lennart’s rule of thumb is that MicroHs has 100x smaller binaries but is 10x slower.</p>

<p>When the program above is compiled with ghc 9.4.5 this is somewhat true. The binary is 13MB (which is ~100X compared to MicroHs’s 200KB). On my computer, it is only about 5 times slower.</p>

<p>On GHC 9.10.2 the binary size difference is less stark (1.3MB vs 200KB), but the speed gap is the same.</p>

<h3 id="take-away">Take away</h3>
<p>Sticking to Haskell 2010 pushed me to separate the public API from the implementation details, so the same code runs on MicroHs and GHC. The experiment showed:</p>

<ul>
  <li><strong>It’s doable.</strong> A usable DataFrame core—construction, simple expressions, <code>filterWhere</code>, <code>derive</code>, and Markdown rendering—works fine without GADTs, type families, or reflection. You pay in verbosity, not viability.</li>
  <li><strong>Portability buys options.</strong> A base-first design means the same front-end API can run on MicroHs for tiny CLIs or embedded contexts and on GHC for speed and ecosystem access.</li>
  <li><strong>Trade-offs are clear.</strong> MicroHs binaries are ~100× smaller and ~5–10× slower for this workload; for many data-wrangling tasks that’s a great swap, and you can still keep a GHC backend for heavy lifting.</li>
</ul>

  </div></div>
  </body>
</html>
