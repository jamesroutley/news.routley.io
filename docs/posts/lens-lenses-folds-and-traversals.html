<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hackage.haskell.org/package/lens">Original</a>
    <h1>Lens: Lenses, Folds and Traversals</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><a href="https://hackage.haskell.org/package/lens"><img src="https://img.shields.io/hackage/v/lens.svg" alt="Hackage"/></a> <a href="https://github.com/ekmett/lens/actions?query=workflow%3AHaskell-CI"><img src="https://github.com/ekmett/lens/workflows/Haskell-CI/badge.svg" alt="Build Status"/></a> <a href="http://packdeps.haskellers.com/reverse/lens"><img src="https://img.shields.io/hackage-deps/v/lens.svg" alt="Hackage Deps"/></a></p>
<p>This package provides families of <a href="https://github.com/ekmett/lens/blob/master/src/Control/Lens/Type.hs">lenses</a>, <a href="https://github.com/ekmett/lens/blob/master/src/Control/Lens/Iso.hs">isomorphisms</a>, <a href="https://github.com/ekmett/lens/blob/master/src/Control/Lens/Fold.hs">folds</a>, <a href="https://github.com/ekmett/lens/blob/master/src/Control/Lens/Traversal.hs">traversals</a>, <a href="https://github.com/ekmett/lens/blob/master/src/Control/Lens/Getter.hs">getters</a> and <a href="https://github.com/ekmett/lens/blob/master/src/Control/Lens/Setter.hs">setters</a>.</p>
<p>If you are looking for where to get started, <a href="http://youtu.be/cefnmjtAolY?hd=1">a crash course video</a> on how <code>lens</code> was constructed and how to use the basics is available on youtube. It is best watched in high definition to see the slides, but the <a href="http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf">slides</a> are also available if you want to use them to follow along.</p>
<p>The <a href="https://github.com/ekmett/lens/wiki/FAQ">FAQ</a>, which provides links to a large number of different resources for learning about lenses and an overview of the <a href="https://github.com/ekmett/lens/wiki/Derivation">derivation</a> of these types can be found on the <a href="https://github.com/ekmett/lens/wiki">Lens Wiki</a> along with a brief <a href="https://github.com/ekmett/lens/wiki/Overview">overview</a> and some <a href="https://github.com/ekmett/lens/wiki/Examples">examples</a>.</p>
<p>Documentation is available through <a href="https://ekmett.github.io/lens/frames.html">github</a> (for HEAD) or <a href="http://hackage.haskell.org/package/lens">hackage</a> for the current and preceding releases.</p>
<h2 id="field-guide">Field Guide</h2>
<p><a href="https://creately.com/diagram/h5nyo9ne1/QZ9UBOtw4AJWtmAKYK3wT8Mm1HM%3D"><img src="https://raw.githubusercontent.com/wiki/ekmett/lens/images/Hierarchy.png" alt="Lens Hierarchy"/></a></p>
<h2 id="examples">Examples</h2>
<p>(See <a href="https://github.com/ekmett/lens/wiki/Examples"><code>wiki/Examples</code></a>)</p>
<p>First, import <code>Control.Lens</code>.</p>
<pre><code>ghci&gt; import Control.Lens
</code></pre>
<p>Now, you can read from lenses</p>
<pre><code>ghci&gt; (&#34;hello&#34;,&#34;world&#34;)^._2
&#34;world&#34;
</code></pre>
<p>and you can write to lenses.</p>
<pre><code>ghci&gt; set _2 42 (&#34;hello&#34;,&#34;world&#34;)
(&#34;hello&#34;,42)
</code></pre>
<p>Composing lenses for reading (or writing) goes in the order an imperative programmer would expect, and just uses <code>(.)</code> from the <code>Prelude</code>.</p>
<pre><code>ghci&gt; (&#34;hello&#34;,(&#34;world&#34;,&#34;!!!&#34;))^._2._1
&#34;world&#34;
</code></pre>
<pre><code>ghci&gt; set (_2._1) 42 (&#34;hello&#34;,(&#34;world&#34;,&#34;!!!&#34;))
(&#34;hello&#34;,(42,&#34;!!!&#34;))
</code></pre>
<p>You can make a <code>Getter</code> out of a pure function with <code>to</code>.</p>
<pre><code>ghci&gt; &#34;hello&#34;^.to length
5
</code></pre>
<p>You can easily compose a <code>Getter</code> with a <code>Lens</code> just using <code>(.)</code>. No explicit coercion is necessary.</p>
<pre><code>ghci&gt; (&#34;hello&#34;,(&#34;world&#34;,&#34;!!!&#34;))^._2._2.to length
3
</code></pre>
<p>As we saw above, you can write to lenses and these writes can change the type of the container. <code>(.~)</code> is an infix alias for <code>set</code>.</p>
<pre><code>ghci&gt; _1 .~ &#34;hello&#34; $ ((),&#34;world&#34;)
(&#34;hello&#34;,&#34;world&#34;)
</code></pre>
<p>Conversely <code>view</code>, can be used as a prefix alias for <code>(^.)</code>.</p>
<pre><code>ghci&gt; view _2 (10,20)
20
</code></pre>
<p>There are a large number of other lens variants provided by the library, in particular a <code>Traversal</code> generalizes <code>traverse</code> from <code>Data.Traversable</code>.</p>
<p>We&#39;ll come back to those later, but continuing with just lenses:</p>
<p>You can let the library automatically derive lenses for fields of your data type</p>
<pre><code>data Foo a = Foo { _bar :: Int, _baz :: Int, _quux :: a }
makeLenses &#39;&#39;Foo
</code></pre>
<p>This will automatically generate the following lenses:</p>
<pre><code>bar, baz :: Lens&#39; (Foo a) Int
quux :: Lens (Foo a) (Foo b) a b
</code></pre>
<p>A <code>Lens</code> takes 4 parameters because it can change the types of the whole when you change the type of the part.</p>
<p>Often you won&#39;t need this flexibility, a <code>Lens&#39;</code> takes 2 parameters, and can be used directly as a <code>Lens</code>.</p>
<p>You can also write to setters that target multiple parts of a structure, or their composition with other
lenses or setters. The canonical example of a setter is &#39;mapped&#39;:</p>
<pre><code>mapped :: Functor f =&gt; Setter (f a) (f b) a b
</code></pre>
<p><code>over</code> is then analogous to <code>fmap</code>, but parameterized on the Setter.</p>
<pre><code>ghci&gt; fmap succ [1,2,3]
[2,3,4]
ghci&gt; over mapped succ [1,2,3]
[2,3,4]
</code></pre>
<p>The benefit is that you can use any <code>Lens</code> as a <code>Setter</code>, and the composition of setters with other setters or lenses using <code>(.)</code> yields
a <code>Setter</code>.</p>
<pre><code>ghci&gt; over (mapped._2) succ [(1,2),(3,4)]
[(1,3),(3,5)]
</code></pre>
<p><code>(%~)</code> is an infix alias for &#39;over&#39;, and the precedence lets you avoid swimming in parentheses:</p>
<pre><code>ghci&gt; _1.mapped._2.mapped %~ succ $ ([(42, &#34;hello&#34;)],&#34;world&#34;)
([(42, &#34;ifmmp&#34;)],&#34;world&#34;)
</code></pre>
<p>There are a number of combinators that resemble the <code>+=</code>, <code>*=</code>, etc. operators from C/C++ for working with the monad transformers.</p>
<p>There are <code>+~</code>, <code>*~</code>, etc. analogues to those combinators that work functionally, returning the modified version of the structure.</p>
<pre><code>ghci&gt; both *~ 2 $ (1,2)
(2,4)
</code></pre>
<p>There are combinators for manipulating the current state in a state monad as well</p>
<pre><code>fresh :: MonadState Int m =&gt; m Int
fresh = id &lt;+= 1
</code></pre>
<p>Anything you know how to do with a <code>Foldable</code> container, you can do with a <code>Fold</code></p>
<pre><code>ghci&gt; :m + Data.Char Data.Text.Lens
ghci&gt; allOf (folded.text) isLower [&#34;hello&#34;^.packed, &#34;goodbye&#34;^.packed]
True
</code></pre>
<p>You can also use this for generic programming. Combinators are included that are based on Neil Mitchell&#39;s <code>uniplate</code>, but which
have been generalized to work on or as lenses, folds, and traversals.</p>
<pre><code>ghci&gt; :m + Data.Data.Lens
ghci&gt; anyOf biplate (==&#34;world&#34;) (&#34;hello&#34;,(),[(2::Int,&#34;world&#34;)])
True
</code></pre>
<p>As alluded to above, anything you know how to do with a <code>Traversable</code> you can do with a <code>Traversal</code>.</p>
<pre><code>ghci&gt; mapMOf (traverse._2) (\xs -&gt; length xs &lt;$ putStrLn xs) [(42,&#34;hello&#34;),(56,&#34;world&#34;)]
&#34;hello&#34;
&#34;world&#34;
[(42,5),(56,5)]
</code></pre>
<p>Moreover, many of the lenses supplied are actually isomorphisms, that means you can use them directly as a lens or getter:</p>
<pre><code>ghci&gt; let hello = &#34;hello&#34;^.packed
&#34;hello&#34;
ghci&gt; :t hello
hello :: Text
</code></pre>
<p>but you can also flip them around and use them as a lens the other way with <code>from</code>!</p>
<pre><code>ghci&gt; hello^.from packed.to length
5
</code></pre>
<p>You can automatically derive isomorphisms for your own newtypes with <code>makePrisms</code>. e.g.</p>
<pre><code>newtype Neither a b = Neither { _nor :: Either a b } deriving (Show)
makePrisms &#39;&#39;Neither
</code></pre>
<p>will automatically derive</p>
<pre><code>_Neither :: Iso (Neither a b) (Neither c d) (Either a b) (Either c d)
</code></pre>
<p>such that</p>
<pre><code>_Neither.from _Neither = id
from _Neither._Neither = id
</code></pre>
<p>Alternatively, you can use <code>makeLenses</code> to automatically derive isomorphisms for your own newtypes. e.g..</p>
<pre><code>makeLenses &#39;&#39;Neither
</code></pre>
<p>will automatically derive</p>
<pre><code>nor :: Iso (Either a b) (Either c d) (Neither a b) (Neither c d)
</code></pre>
<p>which behaves identically to <code>_Neither</code> above.</p>
<p>There is also a fully operational, but simple game of <a href="https://github.com/ekmett/lens/blob/master/examples/Pong.hs">Pong</a> in the <a href="https://github.com/ekmett/lens/blob/master/examples/">examples/</a> folder.</p>
<p>There are also a couple of hundred examples distributed throughout the haddock documentation.</p>

<p>Contributions and bug reports are welcome!</p>
<p>Please feel free to contact me through GitHub or on the <a href="https://web.libera.chat/#haskell-lens">#haskell-lens</a> or <a href="https://web.libera.chat/#haskell">#haskell</a> IRC channel on Libera Chat.</p>
<p>-Edward Kmett</p>
</div></div>
  </body>
</html>
