<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/run-llama/llama-agents">Original</a>
    <h1>Llama-agents: an async-first framework for building production ready agents</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><code>llama-agents</code> is an async-first framework for building, iterating, and productionizing multi-agent systems, including multi-agent communication, distributed tool execution, human-in-the-loop, and more!</p>
<p dir="auto">In <code>llama-agents</code>, each agent is seen as a <code>service</code>, endlessly processing incoming tasks. Each agent pulls and publishes messages from a <code>message queue</code>.</p>
<p dir="auto">At the top of a <code>llama-agents</code> system is the <code>control plane</code>. The control plane keeps track of ongoing tasks, which services are in the network, and also decides which service should handle the next step of a task using an <code>orchestrator</code>.</p>
<p dir="auto">The overall system layout is pictured below.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/run-llama/llama-agents/blob/main/system_diagram.png"><img src="https://github.com/run-llama/llama-agents/raw/main/system_diagram.png" alt="A basic system in llama-agents"/></a></p>

<p dir="auto"><code>llama-agents</code> can be installed with pip, and relies mainly on <code>llama-index-core</code>:</p>

<p dir="auto">If you don&#39;t already have llama-index installed, to follow these examples, you&#39;ll also need</p>
<div dir="auto" data-snippet-clipboard-copy-content="pip install llama-index-agent-openai"><pre>pip install llama-index-agent-openai</pre></div>

<p dir="auto">The quickest way to get started is with an existing agent (or agents) and wrapping into launcher.</p>
<p dir="auto">The example below shows a trivial example with two agents from <code>llama-index</code>.</p>
<p dir="auto">First, lets setup some agents and initial components for our <code>llama-agents</code> system:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from llama_agents import (
    AgentService,
    AgentOrchestrator,
    ControlPlaneServer,
    SimpleMessageQueue,
)

from llama_index.core.agent import ReActAgent
from llama_index.core.tools import FunctionTool
from llama_index.llms.openai import OpenAI


# create an agent
def get_the_secret_fact() -&gt; str:
    &#34;&#34;&#34;Returns the secret fact.&#34;&#34;&#34;
    return &#34;The secret fact is: A baby llama is called a &#39;Cria&#39;.&#34;


tool = FunctionTool.from_defaults(fn=get_the_secret_fact)

agent1 = ReActAgent.from_tools([tool], llm=OpenAI())
agent2 = ReActAgent.from_tools([], llm=OpenAI())

# create our multi-agent framework components
message_queue = SimpleMessageQueue(port=8000)
control_plane = ControlPlaneServer(
    message_queue=message_queue,
    orchestrator=AgentOrchestrator(llm=OpenAI(model=&#34;gpt-4-turbo&#34;)),
    port=8001,
)
agent_server_1 = AgentService(
    agent=agent1,
    message_queue=message_queue,
    description=&#34;Useful for getting the secret fact.&#34;,
    service_name=&#34;secret_fact_agent&#34;,
    port=8002,
)
agent_server_2 = AgentService(
    agent=agent2,
    message_queue=message_queue,
    description=&#34;Useful for getting random dumb facts.&#34;,
    service_name=&#34;dumb_fact_agent&#34;,
    port=8003,
)"><pre><span>from</span> <span>llama_agents</span> <span>import</span> (
    <span>AgentService</span>,
    <span>AgentOrchestrator</span>,
    <span>ControlPlaneServer</span>,
    <span>SimpleMessageQueue</span>,
)

<span>from</span> <span>llama_index</span>.<span>core</span>.<span>agent</span> <span>import</span> <span>ReActAgent</span>
<span>from</span> <span>llama_index</span>.<span>core</span>.<span>tools</span> <span>import</span> <span>FunctionTool</span>
<span>from</span> <span>llama_index</span>.<span>llms</span>.<span>openai</span> <span>import</span> <span>OpenAI</span>


<span># create an agent</span>
<span>def</span> <span>get_the_secret_fact</span>() <span>-&gt;</span> <span>str</span>:
    <span>&#34;&#34;&#34;Returns the secret fact.&#34;&#34;&#34;</span>
    <span>return</span> <span>&#34;The secret fact is: A baby llama is called a &#39;Cria&#39;.&#34;</span>


<span>tool</span> <span>=</span> <span>FunctionTool</span>.<span>from_defaults</span>(<span>fn</span><span>=</span><span>get_the_secret_fact</span>)

<span>agent1</span> <span>=</span> <span>ReActAgent</span>.<span>from_tools</span>([<span>tool</span>], <span>llm</span><span>=</span><span>OpenAI</span>())
<span>agent2</span> <span>=</span> <span>ReActAgent</span>.<span>from_tools</span>([], <span>llm</span><span>=</span><span>OpenAI</span>())

<span># create our multi-agent framework components</span>
<span>message_queue</span> <span>=</span> <span>SimpleMessageQueue</span>(<span>port</span><span>=</span><span>8000</span>)
<span>control_plane</span> <span>=</span> <span>ControlPlaneServer</span>(
    <span>message_queue</span><span>=</span><span>message_queue</span>,
    <span>orchestrator</span><span>=</span><span>AgentOrchestrator</span>(<span>llm</span><span>=</span><span>OpenAI</span>(<span>model</span><span>=</span><span>&#34;gpt-4-turbo&#34;</span>)),
    <span>port</span><span>=</span><span>8001</span>,
)
<span>agent_server_1</span> <span>=</span> <span>AgentService</span>(
    <span>agent</span><span>=</span><span>agent1</span>,
    <span>message_queue</span><span>=</span><span>message_queue</span>,
    <span>description</span><span>=</span><span>&#34;Useful for getting the secret fact.&#34;</span>,
    <span>service_name</span><span>=</span><span>&#34;secret_fact_agent&#34;</span>,
    <span>port</span><span>=</span><span>8002</span>,
)
<span>agent_server_2</span> <span>=</span> <span>AgentService</span>(
    <span>agent</span><span>=</span><span>agent2</span>,
    <span>message_queue</span><span>=</span><span>message_queue</span>,
    <span>description</span><span>=</span><span>&#34;Useful for getting random dumb facts.&#34;</span>,
    <span>service_name</span><span>=</span><span>&#34;dumb_fact_agent&#34;</span>,
    <span>port</span><span>=</span><span>8003</span>,
)</pre></div>

<p dir="auto">Next, when working in a notebook or for faster iteration, we can launch our <code>llama-agents</code> system in a single-run setting, where one message is propagated through the network and returned.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from llama_agents import LocalLauncher

# launch it
launcher = LocalLauncher(
    [agent_server_1, agent_server_2],
    control_plane,
    message_queue,
)
result = launcher.launch_single(&#34;What is the secret fact?&#34;)

print(f&#34;Result: {result}&#34;)"><pre><span>from</span> <span>llama_agents</span> <span>import</span> <span>LocalLauncher</span>

<span># launch it</span>
<span>launcher</span> <span>=</span> <span>LocalLauncher</span>(
    [<span>agent_server_1</span>, <span>agent_server_2</span>],
    <span>control_plane</span>,
    <span>message_queue</span>,
)
<span>result</span> <span>=</span> <span>launcher</span>.<span>launch_single</span>(<span>&#34;What is the secret fact?&#34;</span>)

<span>print</span>(<span>f&#34;Result: <span><span>{</span><span>result</span><span>}</span></span>&#34;</span>)</pre></div>
<p dir="auto">As with any agentic system, its important to consider how reliable the LLM is that you are using. In general, APIs that support function calling (OpenAI, Anthropic, Mistral, etc.) are the most reliable.</p>

<p dir="auto">Once you are happy with your system, we can launch all our services as independent processes, allowing for higher throughput and scalability.</p>
<p dir="auto">By default, all task results are published to a specific &#34;human&#34; queue, so we also define a consumer to handle this result as it comes in. (In the future, this final queue will be configurable!)</p>
<p dir="auto">To test this, you can use the server launcher in a script:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from llama_agents import ServerLauncher, CallableMessageConsumer


# Additional human consumer
def handle_result(message) -&gt; None:
    print(f&#34;Got result:&#34;, message.data)


human_consumer = CallableMessageConsumer(
    handler=handle_result, message_type=&#34;human&#34;
)

# Define Launcher
launcher = ServerLauncher(
    [agent_server_1, agent_server_2],
    control_plane,
    message_queue,
    additional_consumers=[human_consumer],
)

# Launch it!
launcher.launch_servers()"><pre><span>from</span> <span>llama_agents</span> <span>import</span> <span>ServerLauncher</span>, <span>CallableMessageConsumer</span>


<span># Additional human consumer</span>
<span>def</span> <span>handle_result</span>(<span>message</span>) <span>-&gt;</span> <span>None</span>:
    <span>print</span>(<span>f&#34;Got result:&#34;</span>, <span>message</span>.<span>data</span>)


<span>human_consumer</span> <span>=</span> <span>CallableMessageConsumer</span>(
    <span>handler</span><span>=</span><span>handle_result</span>, <span>message_type</span><span>=</span><span>&#34;human&#34;</span>
)

<span># Define Launcher</span>
<span>launcher</span> <span>=</span> <span>ServerLauncher</span>(
    [<span>agent_server_1</span>, <span>agent_server_2</span>],
    <span>control_plane</span>,
    <span>message_queue</span>,
    <span>additional_consumers</span><span>=</span>[<span>human_consumer</span>],
)

<span># Launch it!</span>
<span>launcher</span>.<span>launch_servers</span>()</pre></div>
<p dir="auto">Now, since everything is a server, you need API requests to interact with it. The easiest way is to use our client and the control plane URL:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from llama_agents import LlamaAgentsClient, AsyncLlamaAgentsClient

client = LlamaAgentsClient(&#34;&lt;control plane URL&gt;&#34;)  # i.e. http://127.0.0.1:8001
task_id = client.create_task(&#34;What is the secret fact?&#34;)
# &lt;Wait a few seconds&gt;
# returns TaskResult or None if not finished
result = client.get_task_result(task_id)"><pre><span>from</span> <span>llama_agents</span> <span>import</span> <span>LlamaAgentsClient</span>, <span>AsyncLlamaAgentsClient</span>

<span>client</span> <span>=</span> <span>LlamaAgentsClient</span>(<span>&#34;&lt;control plane URL&gt;&#34;</span>)  <span># i.e. http://127.0.0.1:8001</span>
<span>task_id</span> <span>=</span> <span>client</span>.<span>create_task</span>(<span>&#34;What is the secret fact?&#34;</span>)
<span># &lt;Wait a few seconds&gt;</span>
<span># returns TaskResult or None if not finished</span>
<span>result</span> <span>=</span> <span>client</span>.<span>get_task_result</span>(<span>task_id</span>)</pre></div>
<p dir="auto">Rather than using a client or raw <code>curl</code> requests, you can also use a built-in CLI tool to monitor and interact with your services.</p>
<p dir="auto">In another terminal, you can run:</p>
<div dir="auto" data-snippet-clipboard-copy-content="llama-agents monitor --control-plane-url http://127.0.0.1:8000"><pre>llama-agents monitor --control-plane-url http://127.0.0.1:8000</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/run-llama/llama-agents/blob/main/llama_agents_monitor.png"><img src="https://github.com/run-llama/llama-agents/raw/main/llama_agents_monitor.png" alt="The llama-agents monitor app"/></a></p>

<p dir="auto">You can find a host of examples in our examples folder:</p>
<ul dir="auto">
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/agentic_rag_toolservice.ipynb">Agentic RAG + Tool Service</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/agentic_local_single.py">Agentic Orchestrator w/ Local Launcher</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/agentic_server.py">Agentic Orchestrator w/ Server Launcher</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/agentic_human_local_single.py">Agentic Orchestrator w/ Human in the Loop</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/agentic_toolservice_local_single.py">Agentic Orchestrator w/ Tool Service</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/pipeline_local_single.py">Pipeline Orchestrator w/ Local Launcher</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/pipeline_human_local_single.py">Pipeline Orchestrator w/ Human in the Loop</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/pipeline_agent_service_tool_local_single.py">Pipeline Orchestrator w/ Agent Server As Tool</a></li>
<li><a href="https://github.com/run-llama/llama-agents/blob/main/examples/query_rewrite_rag.ipynb">Pipeline Orchestrator w/ Query Rewrite RAG</a></li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Components of a <code>llama-agents</code> System</h2><a id="user-content-components-of-a-llama-agents-system" aria-label="Permalink: Components of a llama-agents System" href="#components-of-a-llama-agents-system"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In <code>llama-agents</code>, there are several key components that make up the overall system</p>
<ul dir="auto">
<li><code>message queue</code> -- the message queue acts as a queue for all services and the <code>control plane</code>. It has methods for publishing methods to named queues, and delegates messages to consumers.</li>
<li><code>control plane</code> -- the control plane is a the central gateway to the <code>llama-agents</code> system. It keeps track of current tasks, as well as the services that are registered to the system. It also holds the <code>orchestrator</code>.</li>
<li><code>orchestrator</code> -- The module handles incoming tasks and decides what service to send it to, as well as how to handle results from services. An orchestrator can be agentic (with an LLM making decisions), explicit (with a query pipeline defining a flow), a mix of both, or something completely custom.</li>
<li><code>services</code> -- Services are where the actual work happens. A services accepts some incoming task and context, processes it, and publishes a result
<ul dir="auto">
<li>A <code>tool service</code> is a special service used to off-load the compution of agent tools. Agents can instead be equipped with a meta-tool that calls the tool service.</li>
</ul>
</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Low-Level API in <code>llama-agents</code></h2><a id="user-content-low-level-api-in-llama-agents" aria-label="Permalink: Low-Level API in llama-agents" href="#low-level-api-in-llama-agents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">So far, you&#39;ve seen how to define components and how to launch them. However in most production use-cases, you will need to launch services manually, as well as define your own consumers!</p>
<p dir="auto">So, here is a quick guide on exactly that!</p>

<p dir="auto">First, you will want to launch everything. This can be done in a single script, or you can launch things with multiple scripts per service, or on different machines, or even in docker images.</p>
<p dir="auto">In this example, we will assume launching from a single script.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio

# launch the message queue
queue_task = asyncio.create_task(message_queue.launch_server())

# wait for the message queue to be ready
await asyncio.sleep(1)

# launch the control plane
control_plane_task = asyncio.create_task(self.control_plane.launch_server())

# wait for the control plane to be ready
await asyncio.sleep(1)

# register the control plane as a consumer
await self.message_queue.client.register_consumer(
    self.control_plane.as_consumer(remote=True)
)

# register the services
control_plane_url = (
    f&#34;http://{self.control_plane.host}:{self.control_plane.port}&#34;
)
service_tasks = []
for service in self.services:
    # first launch the service
    service_tasks.append(asyncio.create_task(service.launch_server()))

    # register the service to the message queue
    await service.register_to_message_queue()

    # register the service to the control plane
    await service.register_to_control_plane(control_plane_url)"><pre><span>import</span> <span>asyncio</span>

<span># launch the message queue</span>
<span>queue_task</span> <span>=</span> <span>asyncio</span>.<span>create_task</span>(<span>message_queue</span>.<span>launch_server</span>())

<span># wait for the message queue to be ready</span>
<span>await</span> <span>asyncio</span>.<span>sleep</span>(<span>1</span>)

<span># launch the control plane</span>
<span>control_plane_task</span> <span>=</span> <span>asyncio</span>.<span>create_task</span>(<span>self</span>.<span>control_plane</span>.<span>launch_server</span>())

<span># wait for the control plane to be ready</span>
<span>await</span> <span>asyncio</span>.<span>sleep</span>(<span>1</span>)

<span># register the control plane as a consumer</span>
<span>await</span> <span>self</span>.<span>message_queue</span>.<span>client</span>.<span>register_consumer</span>(
    <span>self</span>.<span>control_plane</span>.<span>as_consumer</span>(<span>remote</span><span>=</span><span>True</span>)
)

<span># register the services</span>
<span>control_plane_url</span> <span>=</span> (
    <span>f&#34;http://<span><span>{</span><span>self</span>.<span>control_plane</span>.<span>host</span><span>}</span></span>:<span><span>{</span><span>self</span>.<span>control_plane</span>.<span>port</span><span>}</span></span>&#34;</span>
)
<span>service_tasks</span> <span>=</span> []
<span>for</span> <span>service</span> <span>in</span> <span>self</span>.<span>services</span>:
    <span># first launch the service</span>
    <span>service_tasks</span>.<span>append</span>(<span>asyncio</span>.<span>create_task</span>(<span>service</span>.<span>launch_server</span>()))

    <span># register the service to the message queue</span>
    <span>await</span> <span>service</span>.<span>register_to_message_queue</span>()

    <span># register the service to the control plane</span>
    <span>await</span> <span>service</span>.<span>register_to_control_plane</span>(<span>control_plane_url</span>)</pre></div>
<p dir="auto">With that done, you may want to define a consumer for the results of tasks.</p>
<p dir="auto">By default, the results of tasks get published to a <code>human</code> message queue.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from llama_agents import (
    CallableMessageConsumer,
    RemoteMessageConsumer,
    QueueMessage,
)


def handle_result(message: QueueMessage) -&gt; None:
    print(message.data)


human_consumer = CallableMessageConsumer(
    handler=handle_result, message_type=&#34;human&#34;
)

message_queue.register_consumer(human_consumer)

# or, you can send the message to any URL
# human_consumer = RemoteMessageConsumer(url=&#34;some destination url&#34;)
# message_queue.register_consumer(human_consumer)"><pre><span>from</span> <span>llama_agents</span> <span>import</span> (
    <span>CallableMessageConsumer</span>,
    <span>RemoteMessageConsumer</span>,
    <span>QueueMessage</span>,
)


<span>def</span> <span>handle_result</span>(<span>message</span>: <span>QueueMessage</span>) <span>-&gt;</span> <span>None</span>:
    <span>print</span>(<span>message</span>.<span>data</span>)


<span>human_consumer</span> <span>=</span> <span>CallableMessageConsumer</span>(
    <span>handler</span><span>=</span><span>handle_result</span>, <span>message_type</span><span>=</span><span>&#34;human&#34;</span>
)

<span>message_queue</span>.<span>register_consumer</span>(<span>human_consumer</span>)

<span># or, you can send the message to any URL</span>
<span># human_consumer = RemoteMessageConsumer(url=&#34;some destination url&#34;)</span>
<span># message_queue.register_consumer(human_consumer)</span></pre></div>
<p dir="auto">Or, if you don&#39;t want to define a consumer, you can just use the <code>monitor</code> to observe your system results</p>
<div dir="auto" data-snippet-clipboard-copy-content="llama-agents monitor --control-plane-url http://127.0.0.1:8000"><pre>llama-agents monitor --control-plane-url http://127.0.0.1:8000</pre></div>
</article></div></div>
  </body>
</html>
