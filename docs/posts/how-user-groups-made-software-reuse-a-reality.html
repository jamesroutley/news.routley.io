<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ztoz.blog/posts/user-group-reuse/">Original</a>
    <h1>How user groups made software reuse a reality</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>Before the widespread existence of software repositories like CPAN, NPM, and PyPI, developers seeking to reuse an existing algorithm or library of routines would either check books or journals for code, or, they just might post a classified ad:</p>



<figure>

    <img src="https://ztoz.blog/posts/user-group-reuse/Wanted-Subroutine-Decuscope-1965-02.png" alt="Wanted: Fixed Point Sine/Cosine subroutine faster than 10 ms for PDP-14"/>
    
        <figcaption>Request posted in Decuscope 1965, Vol 4/Iss 2</figcaption>
</figure>



<p>User groups provided catalogues of software, from mathematical algorithms to system utilities to games and demos. Leveraging the user group’s periodicals, developers could post requests for specific examples of code. Or, more frequently, developers would review catalogs for existing solutions. They would contribute by sending their own creations to the group for others to use.</p>
<p>In this article, we will examine how these user groups coordinated development and shared code, how they promoted discoverability of software, and how they attempted to maintain a high bar of quality.</p>

<p>While the importance of a set of reusable subroutines to reduce the cost of development was noted in (Goldstine 1947) and the first set of published subroutines came out in (Wheeler 1951), the lack of standardization between computers and sites meant that it was concepts that were being shared, not code. Reuse implied porting code between architectures and languages.</p>
<p>By the mid-1950s, computers had shifted from a research and bespoke creation, where an organization might build their own computer, to one where manufacturers sold multiple copies of the same model of computer. IBM announced the 701 or “Defense Calculator” in 1952 and installed it in nineteen sites. For business computing, the IBM 650 first shipped in December 1954 and eventually saw over 2,000 installations.</p>
<p>With multiple instances of the same machine model, programs and practices could be replicated directly between sites.</p>
<p>Faced with a programmer shortage, productive utilization of their 701s as low as 60%, and the coming obsolecense of the 701s by the 704s, a few West Coast aerospace companies decided to cooperate on a Project for the Advancement of Coding Techniques (PACT) (Malahn 1956). Formed in November 1954, they designed and developed a coding preprocessor to automate repetitious coding efforts. By June 1955 an implementation was available. Members of the project reported initial success and started evangelizing both the techniques used in the project and the cooperative nature by September 1955 (Greenwald 1956).</p>
<p>In August 1955, the first cooperative user group, SHARE, was formed. The formative group of seventeen installations were all users of the IBM 701 and were anticipating the transition to the 704. The listed advantages for joining included “[…] do considerably less programming and checkout of utility routines, mathematical routines, and complete systems”. In addition, the group represented “authoritative customer opinion” and thus promised greater influence on IBM’s product plans (SHARE 1956).</p>
<p>Obligation of SHARE membership included “have a cooperative spirit” and “respect for the competence of other members”. Furthermore, each member site was expected to attend meetings with at least two members, one with a technical understanding of the system and another with the ability to commit resources. They also were expected to promptly answer the mail and keep the Secretary informed of any delays in their programming assignments.  Programs were distributed as type-written copies of the documentation and code.</p>
<p>The Univac Scientific Exchange, or USE, was founded in January 1956. This group was initially focused on the 1103A, Univac’s competitor to the 704. Similar to PACT and SHARE, they proposed using a similar “minimum standard assembly” language and cooperatively developing and sharing programs. The list of proposed programs included function subroutines, matrix, linear programming, tape handlers, and data output. The committee deferred developing of data input and post mortems utilities until a common language had been adopted (USE 1956).</p>
<p>Of the proposed programs, USE volunteers submitted and accepted seven work assignments. USE members checked the programs on a 1103. The subroutines were for exponential calculations, logarithms, square root, sine/cosine, arc sine, and arc tangent (USE-c 1956).</p>
<p>DECUS or the Digital Equipment Computer Users Society, which eventually became the largest user group, was formed in 1961. As DEC’s first computer was only delivered in November 1960, this demonstrates that customers saw immediate value in joining these groups. By 1971, there were sixteen operational user groups.</p>

<p>As user groups assembled their initial catalogs of algorithms, they were concerned about the accuracy, efficiency, and documentation of the submissions. Since authors and their employers were recorded in the catalog, authors were expected to be highly conscientious about their submissions. After code was submitted, it was then normally sent to a second person who would verify the code worked as expected on a different set of hardware. A third person would then verify that both the submitter and checker had performed their duty and signed off on the result.</p>
<p>A typical form for this process is from the SWAP user group (SWAP 1968). SWAP was the user group for Control Data Computer systems.</p>



<figure>

    <img src="https://ztoz.blog/posts/user-group-reuse/SWAP-Acceptance-Report.jpg" alt="Form documenting tests and hardware used to check code"/>
    
        <figcaption>Form for certification/acceptance of M1-ITEK-DATE Algorithm</figcaption>
</figure>



<p>The expectations for documentation quality at SHARE and USE were robust. The proposed documentation sections (USE-b 1956) were:</p>
<ol>
<li>Identification
<ol>
<li>Title</li>
<li>Author - Date</li>
<li>Installation</li>
</ol>
</li>
<li>Purpose</li>
<li>Method
<ol>
<li>Accuracy</li>
<li>Range</li>
<li>Derivation or Reference</li>
</ol>
</li>
<li>Usage
<ol>
<li>Calling Sequence</li>
<li>Control Data</li>
<li>Operational Procedure</li>
<li>Space Required</li>
<li>Error Codes</li>
<li>Format Received or Generated if an Input-Output Routine</li>
</ol>
</li>
<li>Restrictions
<ol>
<li>Components required other than minimum 1103A</li>
<li>Other Programs Required</li>
<li>Data</li>
<li>Card Form, Tape Format</li>
<li>Wiring Diagram or Board Used, if a Print Routine</li>
</ol>
</li>
<li>Coding Information
<ol>
<li>Constraints</li>
<li>Erasable Input-Output Locations</li>
<li>Time</li>
</ol>
</li>
</ol>
<p>SHARE required the same list of top-level sections (although in slightly different order), plus a “Checkout” section to describe tests performed by the author that could be replicated to verify correct duplication or porting of the code.</p>
<p>As an example of timing information, MTI-0, a linear matrix equation solver, provided the machine time in milliseconds as (USE-b 1956):</p>
<blockquote>
<p>.3n^3 + .9n^2 * m + 1.7n^2 + .3m^2 + 2.5nm + 1.8n + 1.6m + 2.7</p>
</blockquote>
<p>The write-up for MTI-0 required eight typewritten pages. The author took five pages for documentation and three for the source code. Perhaps unusually, the code was both written and checked by the same person, while in the other cases the author observed distinct individuals.</p>
<p>While user groups attempted to hold a high bar for quality, none went so far as to guarantee the fitness of software. In a July 1956 memo, SHARE adopted the following disclaimer on all programs:</p>
<blockquote>
<p>Although this program has been carefully tested by its contributor, no guarantee is made of its correct functioning under all conditions, and no responsibility is taken by him in case of possible failure.</p>
</blockquote>
<p>Although the review system seems to have been robust for SHARE and USE, it seems not all user groups adopted it. DECUS had formed a catalog of about twenty programs early in 1962. However, as reported in the Nov 1962 (Vol I, No 8) issue of Decuscope, the organization had suspended distribution of the tapes due to reported corruption issues. As documented in January 1963, their method of duplicating paper tapes was unreliable, requiring them to reassemble programs. DECUS continued to struggle with paper tape corruption throughout the year as a letter in the Nov 1963 newsletter notes that the tape has garbage at the end, visible labels causing checksum errors, and out of spec spacing of holes.</p>
<p>For DECUS, January 1963 also saw the beginning of their system of certification which required <em>two</em> checkers. A letter to the editor asked “how to induce users to report program failures and how best to utilize such reports.” The author was also concerned about free-loaders and advocated to “establish punitive measures for failure to contribute to the ‘certification’ process.”</p>
<p>By 1966, though, DECUS saw a need to distribute software with less overhead. In Vol 5, Issue 5, the editors launched a new section “Available from Authors” to allow advertisements of software that lacked certification. Authors could advertise software while it was still being debugged or lacked full documentation, but was sufficiently complete to be useful.</p>
<p>A year later, DECUS expanded its advertising policy yet again by allowing commercial software to be listed. Only corporations were allowed to submit programs, not individuals. (Individuals could only post no-cost programs.) As a quality measure, DECUS stated it would act as a “repository for complaints” but stated it “will not ordinarily investigate complaints”.</p>
<p>The first commercial advertisement might have been in Volume 8, Issue 2 (1969) with a routine for controlling a Calcomp plotter.</p>
<p>In 1979 (Issue 6), the DECUS certification process seems to have gone away, as instructions on submitting programs no longer mention it. Submitting a program required only a small amount of documentation (enough to populate a catalog entry) and specified how to provide the code for reproducibility.</p>
<p>There was a resurgence of quality concerns in 1983 (Issue 4) with the launch of a new “DECUS Library Program Quality Assurance”. This program’s objective was to verify programs worked as advertised, focusing on the PDP-11. Volunteers were again asked to perform the evaluation. A pilot program evaluated 25 programs, finding seventeen still useful and marked for retention while recommending eight for archival. Rather than being a quality assurance program for individual programs, this was a process for cleaning up the catalog. Demonstrating the human discretion required, an archival decision required more context than just the age and lack of updates to a program.</p>
<p>The multipage form for submitting programs in the 1990 DECUS catalog did not include any questions on testing performed by the author or require any checks by third-parties. Further, the role of DECUS was defined as a “clearinghouse” and they took no position on the quality of software.</p>
<p>This trajectory was influenced by two trends. One, manufacturers were delivering much more software with the computer and thus were responsible for the core functionality. For instance, manufactures supplied operating sytems, compilers, and standard libraries. Customers no longer expected to write their own math routines. This also meant customers relied more on the manufacturer and less on each other. Two, the volume of software being developed and shared exceeded the user group’s ability to review and control it. Economically, most of the collected fees went for basic distribution and administration of conferences. There were few volunteers to review code and little money to incentivize people.</p>

<p>The first computer science textbook, <em>The Preparation of Programs for an Electronic Digital Computer</em> included an appendix of programs developed for the EDSAC (Wheeler, 1951). Wheeler et al. organized the programs into a hierarchy based on their application area, each area denoted by a single letter. USE and SHARE adopted very similar schemes (Table 1 and 2, (USTB 1958) (Balstad 1975), respectively).</p>
<p><strong>Table 1: Top-level Revised Univac Scientific Routine Index, 1958</strong></p>
<table>
<thead>
<tr>
<th>Section</th>
<th>Category</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Programmed Arithmetic</td>
</tr>
<tr>
<td>2</td>
<td>Elementary Functions</td>
</tr>
<tr>
<td>3</td>
<td>Polynomials and Special Functions</td>
</tr>
<tr>
<td>4</td>
<td>Differential Equations</td>
</tr>
<tr>
<td>5</td>
<td>Interpolations and Approximations</td>
</tr>
<tr>
<td>6</td>
<td>Matrices, Vectors, Simultaneous Linear Equations</td>
</tr>
<tr>
<td>7</td>
<td>Statistical Analysis and Probability</td>
</tr>
<tr>
<td>8</td>
<td>Operations Research and Linear Programming</td>
</tr>
<tr>
<td>9</td>
<td>Input Routines</td>
</tr>
<tr>
<td>10</td>
<td>Output Routines</td>
</tr>
<tr>
<td>11</td>
<td>Executive Routines</td>
</tr>
<tr>
<td>12</td>
<td>Information Processing</td>
</tr>
<tr>
<td>13</td>
<td>Debugging Routines</td>
</tr>
<tr>
<td>14</td>
<td>Simulation Programs</td>
</tr>
<tr>
<td>15</td>
<td>Diagnostic Routines</td>
</tr>
<tr>
<td>16</td>
<td>Service Programs</td>
</tr>
<tr>
<td>17</td>
<td>All Others</td>
</tr>
</tbody>
</table>
<p><strong>Table 2: Top-level SHARE Classification Scheme, 1965</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Category</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Arithmetic Routines</td>
</tr>
<tr>
<td>B</td>
<td>Elementary Functions</td>
</tr>
<tr>
<td>C</td>
<td>Polynomials and Special Functions</td>
</tr>
<tr>
<td>D</td>
<td>Operations on Functions and Solutions of Differential Equations</td>
</tr>
<tr>
<td>E</td>
<td>Interpolation and Approximations</td>
</tr>
<tr>
<td>F</td>
<td>Operations on Matrices, Vectors, and Simultaneous Linear Equations</td>
</tr>
<tr>
<td>G</td>
<td>Statistical Analysis and Probability</td>
</tr>
<tr>
<td>H</td>
<td>Operations Research Techniques, Simulation and Management Science</td>
</tr>
<tr>
<td>I</td>
<td>Input</td>
</tr>
<tr>
<td>J</td>
<td>Output</td>
</tr>
<tr>
<td>K</td>
<td>Internal Information Transfer</td>
</tr>
<tr>
<td>L</td>
<td>Executive Routines</td>
</tr>
<tr>
<td>M</td>
<td>Data Handling</td>
</tr>
<tr>
<td>N</td>
<td>Debugging</td>
</tr>
<tr>
<td>O</td>
<td>Simulation of Computers and Data Processors; Interpreters</td>
</tr>
<tr>
<td>P</td>
<td>Diagnostics</td>
</tr>
<tr>
<td>Q</td>
<td>Service or Housekeeping; Programming Aids</td>
</tr>
<tr>
<td>R</td>
<td>Logical and Symbolic</td>
</tr>
<tr>
<td>S</td>
<td>Information Retrieval</td>
</tr>
<tr>
<td>T</td>
<td>Applications and Application-oriented Programs</td>
</tr>
<tr>
<td>U</td>
<td>Linguistics and Languages</td>
</tr>
<tr>
<td>V</td>
<td>General Purpose Utility Subroutines</td>
</tr>
<tr>
<td>Z</td>
<td>All Others</td>
</tr>
</tbody>
</table>
<p>Within the 1950s and to the mid-1960s, each user group’s focus was on code that a developer could copy into their own programs, rather than free-standing programs. There were full-fledged programs and utilities available, such as assemblers, editors, and maintenance tools, but they were in the minority.</p>
<p>In 1961, the Joint Users Group (JUG) organized itself within the the Association for Computing Machinery. JUG sought to close the “software gap”, the time and effort required between specification and implementation. By 1971, JUG worked with 16 different user groups to assemble a directory, with well-defined metadata, of software available on the various systems. <em>Computer Programs Directory</em> was published first in 1971 with a second volume following in 1974. These directories represent a snapshot in time of software being exchanged within user groups as well as what developers thought others might find useful.</p>
<p>The 1974 directory included a classification system (adopted in 1972) that expanded the list with many application areas, but maintained categories from the earlier SHARE and WWG list. There was a need for application areas as user members were increasingly sharing full programs rather than individual routines. In the 61 Education category, the directory lists twenty programs under Demonstrations (61.1), thirty-five programs under Problem Solving (61.2), and twenty-one programs under Record Keeping (61.3). Most of these programs were written in BASIC.</p>
<p><strong>Table 3: Top-level Program Library Classification Code, 1974</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Category</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Utility (External) Programs</td>
</tr>
<tr>
<td>01</td>
<td>Utility (Internal) Programs</td>
</tr>
<tr>
<td>02</td>
<td>Diagnostics</td>
</tr>
<tr>
<td>03</td>
<td>Programming Systems</td>
</tr>
<tr>
<td>04</td>
<td>Testing and Debugging</td>
</tr>
<tr>
<td>05</td>
<td>Executive Routines</td>
</tr>
<tr>
<td>06</td>
<td>Data Handling</td>
</tr>
<tr>
<td>07</td>
<td>Input/Output</td>
</tr>
<tr>
<td>10</td>
<td>Systems Analysis</td>
</tr>
<tr>
<td>11</td>
<td>Simulation of Computer and Components</td>
</tr>
<tr>
<td>12</td>
<td>Conversion of Programs and Data</td>
</tr>
<tr>
<td>13</td>
<td>Statistical</td>
</tr>
<tr>
<td>15</td>
<td>Management Science/Operations Research</td>
</tr>
<tr>
<td>16</td>
<td>Engineering</td>
</tr>
<tr>
<td>17</td>
<td>Sciences and Mathematics</td>
</tr>
<tr>
<td>18</td>
<td>Nuclear Codes</td>
</tr>
<tr>
<td>19</td>
<td>Financial</td>
</tr>
<tr>
<td>20</td>
<td>Cost Accounting</td>
</tr>
<tr>
<td>21</td>
<td>Payroll and Benefits</td>
</tr>
<tr>
<td>22</td>
<td>Personnel</td>
</tr>
<tr>
<td>23</td>
<td>Manufacturing</td>
</tr>
<tr>
<td>24</td>
<td>Quality Assurance/Reliability</td>
</tr>
<tr>
<td>25</td>
<td>Inventory</td>
</tr>
<tr>
<td>26</td>
<td>Purchasing</td>
</tr>
<tr>
<td>27</td>
<td>Marketing</td>
</tr>
<tr>
<td>28</td>
<td>Sales Entered and Billed</td>
</tr>
<tr>
<td>29</td>
<td>General Business Services</td>
</tr>
<tr>
<td>30</td>
<td>Demonstration and Games</td>
</tr>
<tr>
<td>40</td>
<td>Arithmetic Routines</td>
</tr>
<tr>
<td>41</td>
<td>Elementary Functions</td>
</tr>
<tr>
<td>42</td>
<td>Polynomials and Special Functions</td>
</tr>
<tr>
<td>43</td>
<td>Operations on Functions and Solutions of Differential Equations</td>
</tr>
<tr>
<td>44</td>
<td>Interpolation and Approximations</td>
</tr>
<tr>
<td>45</td>
<td>Operations on Matrices, Vectors, and Simultaneous Linear Equations</td>
</tr>
<tr>
<td>50</td>
<td>Insurance</td>
</tr>
<tr>
<td>61</td>
<td>Education</td>
</tr>
<tr>
<td>62</td>
<td>Literary Data Processing</td>
</tr>
<tr>
<td>63</td>
<td>Humanities</td>
</tr>
<tr>
<td>71</td>
<td>Hybrid Computing</td>
</tr>
<tr>
<td>72</td>
<td>Time Sharing</td>
</tr>
<tr>
<td>99</td>
<td>Miscellaneous</td>
</tr>
</tbody>
</table>
<p>What languages did contributors use? Drawing from JUG 1971 and 1974 using a random sampling approach, the author sampled 193 programs and counted by the primary computer language (Table 3). In cases where a language had multiple versions (e.g. FORTRAN II is distinct from Fortran 66), the author simplified to the “parent” language name. The author also grouped together all assembly languages.</p>
<p><strong>Table 4: Programming Language Count and Percentage from the JUG listings</strong></p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Count</th>
<th>Percentage</th>
</tr>
</thead>
<tbody>
<tr>
<td>FORTRAN</td>
<td>73</td>
<td>38%</td>
</tr>
<tr>
<td>Assembly (incl. MACRO &amp; COMPASS)</td>
<td>49</td>
<td>25%</td>
</tr>
<tr>
<td>PAL (Pedagogic Algorithmic Language)</td>
<td>20</td>
<td>10%</td>
</tr>
<tr>
<td><em>Unspecified</em></td>
<td>11</td>
<td>6%</td>
</tr>
<tr>
<td>BASIC</td>
<td>10</td>
<td>5%</td>
</tr>
<tr>
<td>FOCAL</td>
<td>10</td>
<td>5%</td>
</tr>
<tr>
<td>LAP6</td>
<td>5</td>
<td>3%</td>
</tr>
<tr>
<td>ALGOL</td>
<td>4</td>
<td>2%</td>
</tr>
<tr>
<td>Wang</td>
<td>4</td>
<td>2%</td>
</tr>
<tr>
<td>COBOL</td>
<td>3</td>
<td>2%</td>
</tr>
<tr>
<td>ASPER, CODAP-1, CP, DIAL</td>
<td>All n=1</td>
<td>2%</td>
</tr>
</tbody>
</table>
<p>As the majority of computer sites were performing technical work, it is unsurprising that FORTRAN, as the first high-level language targeting engineering and scientific use cases, counts for nearly 40% of the programs. FORTRAN also had the advantage of being supported on multiple platforms, rather than being a vendor-specific language. Assembly counted for approximately one quarter of the programs, but by this point, programs shipped in assembly focused on hardware drivers or low-level equipment tests and tools. The large amount of programs written in PAL can be contributed to their educational lesson focus and that large numbers of lessons could be cranked out with little effort. FOCAL and BASIC competed in the same niche, and were similar syntactically and functionally, but FOCAL was DEC-specific while BASIC was ported between many architectures. LAP6 was the language for the LINC personal workstation. Although there were only 50 workstations built, the LINC community were especially enthusiastic about sharing what software they wrote.</p>
<p>Perhaps to the chagrin of the ACM, ALGOL barely registered even though it was designed for cross-platform use and there were compilers available for most architectures. Similarly, COBOL barely registers on the list. ACM anticipated greater sharing of business related software as shown by their adding categories like “27 Marketing”, but the actual directory showed only minimal activity in such categories. The activity that existed were more likely to be BASIC programs, such as one for handling personnel recruiting workflows.</p>
<p>Wang and the other items in the table were vendor-specific languages.</p>
<p>Since DECUS was the largest user group and contributed the largest number of items to the JUG directory, we would expect the table to be biased towards languages available on the PDP minicomputers.</p>

<p>The initial threats to software integrity were fairly prosaic: errors introduced by manual copying of code from one medium to another and the degradation of storage over time. To combat this, documentation included steps for verifying and checkout out code to ensure it was copied correctly.</p>
<p>As user groups acquired duplicating machinery, they started distributed software via paper tape. However, paper tape was error prone, as were the technologies used to process it. In the 1966 Volume 5, Issue 2 of DECUScope, a review of the ASR-33 stated it  was a “weak link in the system in both speed and reliability” and “is quite capable of preparing a tape with a checksum error”. (The Teletype Corporation would improve the reliability of the ASR-33 over the next nearly two decades life of the product.)</p>
<p>Magnetic tape was more reliable, but also more expensive. Floppy diskettes were first commercially available in 1973 and by the late 1970s were supported extensively in minicomputer and microcomputer models. In 1978, 5 1/4 diskettes had fallen to <a href="https://en.wikipedia.org/wiki/History_of_the_floppy_disk#cite_note-NYT1978-19">$1.50 in price in bulk</a> or $7 in 2022 dollars. Reliability improved, but replication costs still made mass distribution expensive.</p>
<p>A typical practice, recommended as early as (Wheeler 1951), was to maintain master copies of software which were not to be used directly, but rather copied from time to time to tapes in use.</p>
<p>Although improved media reliability and checksums improved the integrity of software distribution, these measures did not ward against adversarial attacks. In the Winter/Spring 1990 DECUS program library, the editors included this note about viruses:</p>



<figure>

    <img src="https://ztoz.blog/posts/user-group-reuse/DECUS-Virus.jpg" alt="States DECUS policy about viruses - will stop distribution and might investigate (see DECUS policy below)"/>
    
        <figcaption>DECUS policy toward reports about viruses or malware in the catalog</figcaption>
</figure>



<p>Within this policy we see the continuation of norms from SHARE, that of quality and good behavior coming from the developer’s desire to maintain their reputation. This norm was likely reinforced because user groups did meet face-to-face at conferences. However, based on the submission forms, there were few controls against impersonating another person.</p>
<p>Based on documents the author has reviewed, supply chain adversarial attacks were not a concern until the late 80s. Instead, the user groups expected members to follow norms and avoid inadvertent or intentional harm to other members.</p>

<p>In “Software Parts Nostalgia”, Robert C. Glass (Glass 1981) argues that SHARE worked because:</p>
<ol>
<li>Available to everyone (within a site)</li>
<li>“Effective parts taxonomy” and “effective delivery document”</li>
<li>Pride in software authorship</li>
<li>Not available elsewhere</li>
</ol>
<p>Do these factor apply to a online software repository?</p>
<p>A modern software respository is more available than software through a user group as they simply require an internet connection — no need to prove you own a specific machine or pay any dues. Further, new software and updates can be made accessed within seconds. This level of availability may be a handicap as the bandwidth costs can be expensive and the sites operate in a hostile environment with constant denial of service attacks. However, compared to sending physical media, websites are multiple orders less expensive.</p>
<p>Modern tooling greatly reduces the friction of adding a dependency to a project and tracking updates, but finding and selecting a library is largely an adhoc process by the developer leveraging search engines and popularity metrics. There are still attempts at a taxonomy, for example <a href="https://crates.io/category_slugs">crate’s list</a> for Rust, but these are not fine-grained. Modern repositories place greater weight on free-form search  than taxonomies. When user groups were sharing paper catalogs, reverse indexed search was not an option.</p>
<p>The MTI-0 write-up and similar documents in the SHARE and USE binders are models of documentation and are analagous to a Unix man page. However, as these programs are really just functions and typically written in assembly, their scope is limited and much of the documentation would be unnecessary if the code was written in a higher-level language. Over time, user groups reduced their expectations on documentation, but user groups also were sharing fewer routines and more stand-alone programs.</p>
<p>Pride is a difficult subject to measure as are the feelings of responsibility, reputation, and ownership. Within the early days of SHARE and USE, a developer would be releasing code to colleagues that met face-to-face at least monthly. Not only could poor quality code lead to ostracization or reduced influence within the group, but high quality code could lead to better jobs and enhanced status. By 1981, when Glass was writing, “software parts” were more likely released commercially by a company. Individual contributions were anonymized, although quality might still be recognized and rewarded within a company.</p>
<p>Alternatives to anonymity, however, were quickly changing with the beginnings of the Free and Open Source movements (GNU was first announced in 1983; OSI formed in 1998). Contributions from individual authors were public and trackable, particularly with software project management sites such as SourceForge, launched in 1999. While public recognition for contributions can be socially rewarding, simply releasing code or a patch is insufficient. Software repositories have ample packages that are buggy, abandoned, and unfit for consumption. Modeled as a clearinghouse, similar to DECUS finding a need to remove obsolete software from their catalog, clearinghouses will fill with junk over time.</p>
<p>Due to network effects and economic efficiency, there tends to be a single repository per programming language – e.g. PyPI for Python, Central Repository for Java, Rubygems for Ruby, NPM for JavaScript. (An organization will often run a private repository for their internal development, but they will share software via an external repository.) The switch from repository per manufacturer to repository per language started with CTAN, the Comprehensive TeX Archive Network, which inspired the very popular CPAN or Comprehensive Perl Archive Network. Officially announced in 1993, CTAN consolidated via mirrors and tooling TeX macros previously distributed across many sites. The balkanization of software sources, which had greatly increased once software started to be unbundled from hardware in 1969, began to reduce with centralized systems (even if they used distributed mirrors).</p>

<ul>
<li>Communities can rapidly fill missing documentation and features</li>
</ul>
<p>If a community can come together and organize, they can effectively defend their interests and create solutions. The computer manufacturers of the time helped the user groups grow by including notices for them when they sold a machine, whether the user group was directly managed by the manufacturer or not.</p>
<ul>
<li>Mirrors are great for availability</li>
</ul>
<p>The answer to code availability and corruption issues has always been local copies. External dependencies should be stored within a caching proxy or similar mirroring system.</p>
<ul>
<li>Curatorship is more expensive than development</li>
</ul>
<p>Programmers may be in short supply, but programmers have consistently shown greater willingness to volunteer their programming output versus their skills in reviewing and auditing other’s output. While there are groups that have a tradition of deep review (e.g. netlib, openbsd), the user groups struggled to maintain a similar review system past a small set of ‘standard’ libraries. Instead, it seems less expensive to let the consumers try to determine fitness and quality themselves and attract customers with the quantity of available software.</p>

<p>I’d like to thank the <a href="https://cse.umn.edu/cbi">Charles Babbage Institute</a> for their assistance with the research.</p>

<p>(Balstad 1975): John Bolstad. 1975. A proposed classification for computer program library subroutines. SIGUCCS Newsl. 5, 2 (May 1975), 25–37. <a href="https://doi.org/10.1145/1098881.1098882">https://doi.org/10.1145/1098881.1098882</a></p>
<p>(Glass 1981): Robert C. Glass. 1981. Software Parts Nostalgia. Datamation, Vol 27, (Nov. 1981), 245-247.</p>
<p>(Goldstine 1947): Herman Goldstine and John Von Neumann. Planning and coding of problems for an electronic computing instrument, Vol. 1. Inst. for Advanced Study, Princeton, N. J, Apml 1, 1947 (69 pp.). (Reprinted in von Neumann’s Collected Works, Vol 5, A H Taub, Ed., Pergamon, London, 1963, pp. 80-151.)</p>
<p>(Greenwald 1956): I. D. Greenwald and H. G. Martin. 1956. Conclusions After Using the PACT I Advanced Coding Technique. J. ACM 3, 4 (Oct. 1956), 309–313. <a href="https://doi.org/10.1145/320843.320850">https://doi.org/10.1145/320843.320850</a></p>
<p>(Melahn 1956): Wesley S. Melahn. 1956. A Description of a Cooperative Venture in the Production of an Automatic Coding System. J. ACM 3, 4 (Oct. 1956), 266–271. <a href="https://doi.org/10.1145/320843.320844">https://doi.org/10.1145/320843.320844</a></p>
<p>(SHARE 1956): John Greenstadt, Editor-in-Chief. SHARE Reference Manual for the IBM 704. 1956. <a href="https://www.piercefuller.com/scan/share59.pdf">https://www.piercefuller.com/scan/share59.pdf</a></p>
<p>(SWAP 1968): Users Organization for Control Data Computer Systems, Handbook, Part III: Program Catalog, (June 1968). <a href="https://archives.lib.umn.edu/repositories/3/archival_objects/1616775">https://archives.lib.umn.edu/repositories/3/archival_objects/1616775</a></p>
<p>(USE 1956): Minutes of Meeting of USE, Seattle WA. (9-10 January 1956). <a href="https://archives.lib.umn.edu/repositories/3/resources/19">https://archives.lib.umn.edu/repositories/3/resources/19</a></p>
<p>(USE-b 1956): Minutes of Meeting of USE, St. Paul MN. (15-16 February 1956). <a href="https://archives.lib.umn.edu/repositories/3/resources/19">https://archives.lib.umn.edu/repositories/3/resources/19</a></p>
<p>(USE-c 1956): Minutes of Meeting of USE, Van Nerys CA. (29-30 March 1956). <a href="https://archives.lib.umn.edu/repositories/3/resources/19">https://archives.lib.umn.edu/repositories/3/resources/19</a></p>
<p>(USTB 1958): USTB-5 Revised Univac Scientific Routines Index. (January 31 1958). <a href="https://archives.lib.umn.edu/repositories/3/resources/19">https://archives.lib.umn.edu/repositories/3/resources/19</a></p>
<p>(Wheeler 1951): David John Wheeler, et al. The Preparation of Programs for an Electronic Digital Computer: With Special Reference to the Edsac and the Use of a Library of Subroutines. Reprint of the ed. 1951 ed. Addison-Wesley 1951.</p>

<h2 id="decus-about-viruses-policy-1990">DECUS ‘About Viruses’ Policy (1990)</h2>
<p>The DECUS Library is a clearinghouse only. As such, it cannot checks it software for proper function, quality of implementation, covert behavior, or other similar issues. However, it will not knowingly release software which is known to be harmful to its users.</p>
<p>While we cannot provide absolute assurance against covert behavior, we believe it is rendered less probable because:</p>
<ul>
<li>Submitters&#39; names remain permanently associated with their submissions; anyone contributing a virus or trojan horse risks his or her reputation.</li>
<li>A large user community is likely to have someone notice covert behavior. Since this can be reported quickly to a central location, there is safety in numbers.</li>
<li>Submitting sources is encouraged, so that covert behavior is harder to hide.</li>
</ul>
<p>If covert behavior is reported in software submitted to the DECUS library, the library will take the following actions:</p>
<ul>
<li>Suspend distribution of that software.</li>
<li>Investigate the report and if it is found true, remove the offending software from the library.</li>
<li>Report the complete incident to all known sites to whom the software was distributed, with all available information, including where the software came from.</li>
<li>Attempts to remove the objectionable behavior may be made by volunteers, to reclaim what value may exist in the software. Any such reclaimed software will appear only with a full explanation of what was done.</li>
</ul>
        
    </div></div>
  </body>
</html>
