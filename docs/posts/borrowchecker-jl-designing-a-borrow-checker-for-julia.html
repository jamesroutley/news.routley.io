<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/MilesCranmer/BorrowChecker.jl">Original</a>
    <h1>Borrowchecker.jl â€“ Designing a borrow checker for Julia</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This package implements a borrow checker in Julia using a macro layer over standard Julia code. This is built to emulate Rust&#39;s ownership, lifetime, and borrowing semantics. This tool is mainly to be used in development and testing to flag memory safety issues, and help you design safer code.</p>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p><p dir="auto">BorrowChecker.jl does not promise memory safety. This library emulates aspects of Rust&#39;s ownership model, but it does not do this at a compiler level. Furthermore, BorrowChecker.jl heavily relies on the user&#39;s cooperation, and will not prevent you from misusing it, or from mixing it with regular Julia code.</p>
</div>

<p dir="auto">In Julia, objects exist independently of the variables that refer to them. When you write <code>x = [1, 2, 3]</code> in Julia, the actual <em>object</em> lives in memory completely independently of the symbol, and you can refer to it from as many variables as you want without issue:</p>
<div dir="auto" data-snippet-clipboard-copy-content="x = [1, 2, 3]
y = x
println(length(x))
# 3"><pre>x <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
y <span>=</span> x
<span>println</span>(<span>length</span>(x))
<span><span>#</span> 3</span></pre></div>
<p dir="auto">Once there are no more references to the object, the &#34;garbage collector&#34; will work to free the memory.</p>
<p dir="auto">Rust is much different. For example, the equivalent code is <strong>invalid</strong> in Rust</p>
<div dir="auto" data-snippet-clipboard-copy-content="let x = vec![1, 2, 3];
let y = x;
println!(&#34;{}&#34;, x.len());
// error[E0382]: borrow of moved value: `x`"><pre><span>let</span> x = <span>vec</span><span>!</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>
<span>let</span> y = x<span>;</span>
<span>println</span><span>!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> x<span>.</span>len<span>(</span><span>)</span><span>)</span><span>;</span>
<span>// error[E0382]: borrow of moved value: `x`</span></pre></div>
<p dir="auto">Rust refuses to compile this code. Why? Because in Rust, objects (<code>vec![1, 2, 3]</code>) are <em>owned</em> by variables. When you write <code>let y = x</code>, the ownership of <code>vec![1, 2, 3]</code> is <em>moved</em> to <code>y</code>. Now <code>x</code> is no longer allowed to access it.</p>
<p dir="auto">To fix this, we would either write</p>
<div dir="auto" data-snippet-clipboard-copy-content="let y = x.clone();
// OR
let y = &amp;x;"><pre><span>let</span> y = x<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
<span>// OR</span>
<span>let</span> y = <span>&amp;</span>x<span>;</span></pre></div>
<p dir="auto">to either create a copy of the vector, or <em>borrow</em> <code>x</code> using the <code>&amp;</code> operator to create a reference. You can create as many references as you want, but there can only be one original object.</p>
<p dir="auto">The purpose of this &#34;ownership&#34; paradigm is to improve safety of code. Especially in complex, multithreaded codebases, it is really easy to shoot yourself in the foot and modify objects which are &#34;owned&#34; (editable) by something else. Rust&#39;s ownership and lifetime model makes it so that you can <em>prove</em> memory safety of code! Standard thread races are literally impossible. (Assuming you are not using <code>unsafe { ... }</code> to disable safety features, or rust itself has a bug, or a cosmic ray hits your PC!)</p>
<p dir="auto">In BorrowChecker.jl, we demonstrate a very simple implementation of some of these core ideas. The aim is to build a development layer that, eventually, can help prevent a few classes of memory safety issues, without affecting runtime behavior of code. The above example, with BorrowChecker.jl, would look like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="using BorrowChecker

@own x = [1, 2, 3]
@own y = x
println(length(x))
# ERROR: Cannot use x: value has been moved"><pre><span>using</span> BorrowChecker

<span>@own</span> x <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>@own</span> y <span>=</span> x
<span>println</span>(<span>length</span>(x))
<span><span>#</span> ERROR: Cannot use x: value has been moved</span></pre></div>
<p dir="auto">You see, the <code>@own</code> operation has <em>bound</em> the variable <code>x</code> with the object <code>[1, 2, 3]</code>. The second operation then moves the object to <code>y</code>, and flips the <code>.moved</code> flag on <code>x</code> so it can no longer be used by regular operations.</p>
<p dir="auto">The equivalent fixes would respectively be:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@clone y = x
# OR
@lifetime a begin
    @ref ~a y = x
    #= operations on reference =#
end"><pre><span>@clone</span> y <span>=</span> x
<span><span>#</span> OR</span>
<span>@lifetime</span> a <span>begin</span>
    <span>@ref</span> <span>~</span>a y <span>=</span> x
    <span><span>#=</span> operations on reference <span>=#</span></span>
<span>end</span></pre></div>
<p dir="auto">Note that BorrowChecker.jl does not prevent you from cheating the system and using <code>y = x</code><sup><a href="#user-content-fn-1-472df44c11b4215ae9966a2874bed20c" id="user-content-fnref-1-472df44c11b4215ae9966a2874bed20c" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>. To use this library, you will need to <em>buy in</em> to the system to get the most out of it. But the good news is that you can introduce it in a library gradually:  add <code>@own</code>, <code>@move</code>, etc., inside a single function, and call <code>@take!</code> when passing objects to external functions. And for convenience, a variety of standard library functions will automatically forward operations on the underlying objects.</p>

<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Caution</p><p dir="auto">The API is under active development and may change in future versions.</p>
</div>

<ul dir="auto">
<li><code>@own [:mut] x = value</code>: Create a new owned value (mutable if <code>:mut</code> is specified)
<ul dir="auto">
<li>These are <code>Owned{T}</code> and <code>OwnedMut{T}</code> objects, respectively.</li>
<li>You can use <code>@own [:mut] x</code> as a shorthand for <code>@own [:mut] x = x</code> to create owned values at the start of a function.</li>
</ul>
</li>
<li><code>@move [:mut] new = old</code>: Transfer ownership from one variable to another (mutable destination if <code>:mut</code> is specified). <em>Note that this is simply a more explicit version of <code>@own</code> for moving values.</em></li>
<li><code>@clone [:mut] new = old</code>: Create a deep copy of a value without moving the source (mutable destination if <code>:mut</code> is specified).</li>
<li><code>@take[!] var</code>: Unwrap an owned value. Using <code>@take!</code> will mark the original as moved, while <code>@take</code>will perform a copy.</li>
<li><code>getproperty</code> and <code>getindex</code> access (e.g., <code>x.field</code> or <code>x[i]</code>) on owned or borrowed values will return a <code>LazyAccessor</code> that propagates ownership and lifetime information until the raw value needs to be used.</li>
</ul>

<ul dir="auto">
<li><code>@lifetime lt begin ... end</code>: Create a scope for references whose lifetimes <code>lt</code> are the duration of the block</li>
<li><code>@ref ~lt [:mut] var = value</code>: Create a reference, for the duration of <code>lt</code>, to owned value <code>value</code> and assign it to <code>var</code> (mutable if <code>:mut</code> is specified)
<ul dir="auto">
<li>These are <code>Borrowed{T}</code> and <code>BorrowedMut{T}</code> objects, respectively. Use these in the signature of any function you wish to make compatible with references. In the signature you can use <code>OrBorrowed{T}</code> and <code>OrBorrowedMut{T}</code> to also allow regular <code>T</code>.</li>
</ul>
</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Automatic Ownership Transfer</h3><a id="user-content-automatic-ownership-transfer" aria-label="Permalink: Automatic Ownership Transfer" href="#automatic-ownership-transfer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><code>BorrowChecker.Experimental.@managed begin ... end</code>: create a scope where contextual dispatch is performed using <a href="https://github.com/JuliaLabs/Cassette.jl">Cassette.jl</a>: recursively, all functions (<em><strong>in all dependencies</strong></em>) are automatically modified to apply <code>@take!</code> to any <code>Owned{T}</code> or <code>OwnedMut{T}</code> input arguments.
<ul dir="auto">
<li>Note: this is an experimental feature that may change or be removed in future versions. It relies on compiler internals and seems to break on certain functions (like SIMD operations).</li>
</ul>
</li>
</ul>

<ul dir="auto">
<li><code>@set x = value</code>: Assign a new value to an existing owned mutable variable</li>
</ul>

<ul dir="auto">
<li><code>@own [:mut] for var in iter</code>: Create a loop over an iterable, assigning ownership of each element to <code>var</code>. The original <code>iter</code> is marked as moved.</li>
<li><code>@ref ~lt [:mut] for var in iter</code>: Create a loop over an owned iterable, generating references to each element, for the duration of <code>lt</code>.</li>
</ul>

<p dir="auto">You can disable BorrowChecker.jl&#39;s functionality by setting <code>borrow_checker = false</code> in your LocalPreferences.toml file (using Preferences.jl). When disabled, all macros like <code>@own</code>, <code>@move</code>, etc., will simply pass through their arguments without any ownership or borrowing checks.</p>
<p dir="auto">You can also set the <em>default</em> behavior from within a module:</p>
<div dir="auto" data-snippet-clipboard-copy-content="module MyModule
    using BorrowChecker: disable_by_default!

    disable_by_default!(@__MODULE__)
    #= Other code =#
end"><pre><span>module</span> MyModule
    <span>using</span> BorrowChecker<span>:</span> disable_by_default!

    <span>disable_by_default!</span>(<span>@__MODULE__</span>)
    <span><span>#=</span> Other code <span>=#</span></span>
<span>end</span></pre></div>
<p dir="auto">This can then be overridden by the LocalPreferences.toml file.</p>


<p dir="auto">Let&#39;s look at the basic ownership system. When you create an owned value, it&#39;s immutable by default:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own x = [1, 2, 3]
push!(x, 4)  # ERROR: Cannot write to immutable"><pre><span>@own</span> x <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>push!</span>(x, <span>4</span>)  <span><span>#</span> ERROR: Cannot write to immutable</span></pre></div>
<p dir="auto">For mutable values, use the <code>:mut</code> flag:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut data = [1, 2, 3]
push!(data, 4)  # Works! data is mutable"><pre><span>@own</span> <span>:mut</span> data <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>push!</span>(data, <span>4</span>)  <span><span>#</span> Works! data is mutable</span></pre></div>
<p dir="auto">Note that various functions have been overloaded with the write access settings, such as <code>push!</code>, <code>getindex</code>, etc.</p>
<p dir="auto">The <code>@own</code> macro creates an <code>Owned{T}</code> or <code>OwnedMut{T}</code> object. Most functions will not be written to accept these, so you can use <code>@take</code> (copying) or <code>@take!</code> (moving) to extract the owned value:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Functions that expect regular Julia types:
push_twice!(x::Vector{Int}) = (push!(x, 4); push!(x, 5); x)

@own x = [1, 2, 3]
@own y = push_twice!(@take!(x))  # Moves ownership of x

push!(x, 4)  # ERROR: Cannot use x: value has been moved"><pre><span><span>#</span> Functions that expect regular Julia types:</span>
<span>push_twice!</span>(x<span>::</span><span>Vector{Int}</span>) <span>=</span> (<span>push!</span>(x, <span>4</span>); <span>push!</span>(x, <span>5</span>); x)

<span>@own</span> x <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>@own</span> y <span>=</span> <span>push_twice!</span>(<span>@take!</span>(x))  <span><span>#</span> Moves ownership of x</span>

<span>push!</span>(x, <span>4</span>)  <span><span>#</span> ERROR: Cannot use x: value has been moved</span></pre></div>
<p dir="auto">However, for recursively immutable types (like tuples of integers), <code>@take!</code> is smart enough to know that the original can&#39;t change, and thus it won&#39;t mark a moved:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own point = (1, 2)
sum1 = write_to_file(@take!(point))  # point is still usable
sum2 = write_to_file(@take!(point))  # Works again!"><pre><span>@own</span> point <span>=</span> (<span>1</span>, <span>2</span>)
sum1 <span>=</span> <span>write_to_file</span>(<span>@take!</span>(point))  <span><span>#</span> point is still usable</span>
sum2 <span>=</span> <span>write_to_file</span>(<span>@take!</span>(point))  <span><span>#</span> Works again!</span></pre></div>
<p dir="auto">This is the same behavior as in Rust (c.f., the <code>Copy</code> trait).</p>
<p dir="auto">There is also the <code>@take(...)</code> macro which never marks the original as moved,
and performs a <code>deepcopy</code> when needed:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut data = [1, 2, 3]
@own total = sum_vector(@take(data))  # Creates a copy
push!(data, 4)  # Original still usable"><pre><span>@own</span> <span>:mut</span> data <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>@own</span> total <span>=</span> <span>sum_vector</span>(<span>@take</span>(data))  <span><span>#</span> Creates a copy</span>
<span>push!</span>(data, <span>4</span>)  <span><span>#</span> Original still usable</span></pre></div>
<p dir="auto">Note also that for improving safety when using BorrowChecker.jl, the macro will actually store the <em>symbol</em> used.
This helps catch mistakes like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; @own x = [1, 2, 3];

julia&gt; y = x;  # Unsafe! Should use @clone, @move, or @own

julia&gt; @take(y)
ERROR: Variable `y` holds an object that was reassigned from `x`."><pre>julia<span>&gt;</span> <span>@own</span> x <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>];

julia<span>&gt;</span> y <span>=</span> x;  <span><span>#</span> Unsafe! Should use @clone, @move, or @own</span>

julia<span>&gt;</span> <span>@take</span>(y)
ERROR<span>:</span> Variable <span><span>`</span>y<span>`</span></span> holds an object that was reassigned from <span><span>`</span>x<span>`</span></span>.</pre></div>
<p dir="auto">This won&#39;t catch all misuses but it can help prevent some.</p>

<p dir="auto">References let you temporarily <em>borrow</em> values. This is useful for passing values to functions without moving them. These are created within an explicit <code>@lifetime</code> block:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut data = [1, 2, 3]

@lifetime lt begin
    @ref ~lt r = data
    @ref ~lt r2 = data  # Can create multiple _immutable_ references!
    @test r == [1, 2, 3]

    # While ref exists, data can&#39;t be modified:
    data[1] = 4 # ERROR: Cannot write original while immutably borrowed
end

# After lifetime ends, we can modify again!
data[1] = 4"><pre><span>@own</span> <span>:mut</span> data <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]

<span>@lifetime</span> lt <span>begin</span>
    <span>@ref</span> <span>~</span>lt r <span>=</span> data
    <span>@ref</span> <span>~</span>lt r2 <span>=</span> data  <span><span>#</span> Can create multiple _immutable_ references!</span>
    <span>@test</span> r <span>==</span> [<span>1</span>, <span>2</span>, <span>3</span>]

    <span><span>#</span> While ref exists, data can&#39;t be modified:</span>
    data[<span>1</span>] <span>=</span> <span>4</span> <span><span>#</span> ERROR: Cannot write original while immutably borrowed</span>
<span>end</span>

<span><span>#</span> After lifetime ends, we can modify again!</span>
data[<span>1</span>] <span>=</span> <span>4</span></pre></div>
<p dir="auto">Just like in Rust, while you can create multiple <em>immutable</em> references, you can only have one <em>mutable</em> reference at a time:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut data = [1, 2, 3]

@lifetime lt begin
    @ref ~lt :mut r = data
    @ref ~lt :mut r2 = data  # ERROR: Cannot create mutable reference: value is already mutably borrowed
    @ref ~lt r2 = data  # ERROR: Cannot create immutable reference: value is mutably borrowed

    # Can modify via mutable reference:
    r[1] = 4
end"><pre><span>@own</span> <span>:mut</span> data <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]

<span>@lifetime</span> lt <span>begin</span>
    <span>@ref</span> <span>~</span>lt <span>:mut</span> r <span>=</span> data
    <span>@ref</span> <span>~</span>lt <span>:mut</span> r2 <span>=</span> data  <span><span>#</span> ERROR: Cannot create mutable reference: value is already mutably borrowed</span>
    <span>@ref</span> <span>~</span>lt r2 <span>=</span> data  <span><span>#</span> ERROR: Cannot create immutable reference: value is mutably borrowed</span>

    <span><span>#</span> Can modify via mutable reference:</span>
    r[<span>1</span>] <span>=</span> <span>4</span>
<span>end</span></pre></div>
<p dir="auto">When you need to pass immutable references of a value to a function, you would modify the signature to accept a <code>Borrowed{T}</code> type. This is similar to the <code>&amp;T</code> syntax in Rust. And, similarly, <code>BorrowedMut{T}</code> is similar to <code>&amp;mut T</code>.</p>
<p dir="auto">Don&#39;t worry about references being used <em>after</em> the lifetime ends, because the <code>lt</code> variable will be expired!</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; @own x = 1
       @own :mut cheating = []
       @lifetime lt begin
           @ref ~lt r = x
           push!(cheating, r)
       end
       

julia&gt; @show cheating[1]
ERROR: Cannot use r: value&#39;s lifetime has expired"><pre>julia<span>&gt;</span> <span>@own</span> x <span>=</span> <span>1</span>
       <span>@own</span> <span>:mut</span> cheating <span>=</span> []
       <span>@lifetime</span> lt <span>begin</span>
           <span>@ref</span> <span>~</span>lt r <span>=</span> x
           <span>push!</span>(cheating, r)
       <span>end</span>
       

julia<span>&gt;</span> <span>@show</span> cheating[<span>1</span>]
ERROR<span>:</span> Cannot use r<span>:</span> value<span>&#39;</span>s lifetime has expired</pre></div>
<p dir="auto">This makes the use of references inside threads safe, because the threads <em>must</em> finish inside the scope of the lifetime.</p>
<p dir="auto">Though we can&#39;t create multiple mutable references, you <em>are</em> allowed to create multiple mutable references to elements of a collection via the <code>@ref ~lt for</code> syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut data = [[1], [2], [3]]

@lifetime lt begin
    @ref ~lt :mut for r in data
        push!(r, 4)
    end
end

@show data  # [[1, 4], [2, 4], [3, 4]]"><pre><span>@own</span> <span>:mut</span> data <span>=</span> [[<span>1</span>], [<span>2</span>], [<span>3</span>]]

<span>@lifetime</span> lt <span>begin</span>
    <span>@ref</span> <span>~</span>lt <span>:mut</span> <span>for</span> r <span>in</span> data
        <span>push!</span>(r, <span>4</span>)
    <span>end</span>
<span>end</span>

<span>@show</span> data  <span><span>#</span> [[1, 4], [2, 4], [3, 4]]</span></pre></div>

<p dir="auto">The (experimental) <code>@managed</code> block can be used to perform borrow checking automatically. It basically transforms all functions, everywhere, to perform <code>@take!</code> on function calls that take <code>Owned{T}</code> or <code>OwnedMut{T}</code> arguments:</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct Particle
    position::Vector{Float64}
    velocity::Vector{Float64}
end

function update!(p::Particle)
    p.position .+= p.velocity
    return p
end"><pre><span>struct</span> Particle
    position<span>::</span><span>Vector{Float64}</span>
    velocity<span>::</span><span>Vector{Float64}</span>
<span>end</span>

<span>function</span> <span>update!</span>(p<span>::</span><span>Particle</span>)
    p<span>.</span>position <span>.+</span><span>=</span> p<span>.</span>velocity
    <span>return</span> p
<span>end</span></pre></div>
<p dir="auto">With <code>@managed</code>, you don&#39;t need to manually move ownership:</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; using BorrowChecker.Experimental: @managed

julia&gt; @own :mut p = Particle([0.0, 0.0], [1.0, 1.0])
       @managed begin
           update!(p)
       end;

julia&gt; p
[moved]"><pre>julia<span>&gt;</span> <span>using</span> BorrowChecker<span>.</span>Experimental<span>:</span> <span>@managed</span>

julia<span>&gt;</span> <span>@own</span> <span>:mut</span> p <span>=</span> <span>Particle</span>([<span>0.0</span>, <span>0.0</span>], [<span>1.0</span>, <span>1.0</span>])
       <span>@managed</span> <span>begin</span>
           <span>update!</span>(p)
       <span>end</span>;

julia<span>&gt;</span> p
[moved]</pre></div>
<p dir="auto">This works via <a href="https://github.com/JuliaLabs/Cassette.jl">Cassette.jl</a> overdubbing, which recursively modifies all function calls in the entire call stack - not just the top-level function, but also any functions it calls, and any functions those functions call, and so on. But do note that this is very experimental as it modifies the compilation itself. For more robust usage, just use <code>@take!</code> manually.</p>
<p dir="auto">This also works with nested field access, just like in Rust:</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct Container
    x::Vector{Int}
end

f!(x::Vector{Int}) = push!(x, 3)

@own a = Container([2])
@managed begin
    f!(a.x)  # Container ownership handled automatically
end

@take!(a)  # ERROR: Cannot use a: value has been moved"><pre><span>struct</span> Container
    x<span>::</span><span>Vector{Int}</span>
<span>end</span>

<span>f!</span>(x<span>::</span><span>Vector{Int}</span>) <span>=</span> <span>push!</span>(x, <span>3</span>)

<span>@own</span> a <span>=</span> <span>Container</span>([<span>2</span>])
<span>@managed</span> <span>begin</span>
    <span>f!</span>(a<span>.</span>x)  <span><span>#</span> Container ownership handled automatically</span>
<span>end</span>

<span>@take!</span>(a)  <span><span>#</span> ERROR: Cannot use a: value has been moved</span></pre></div>

<p dir="auto">For mutating an owned value directly, you should use the <code>@set</code> macro,
which prevents the creation of a new owned value.</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut local_counter = 0
for _ in 1:10
    @set local_counter = local_counter + 1
end
@take! local_counter"><pre><span>@own</span> <span>:mut</span> local_counter <span>=</span> <span>0</span>
<span>for</span> _ <span>in</span> <span>1</span><span>:</span><span>10</span>
    <span>@set</span> local_counter <span>=</span> local_counter <span>+</span> <span>1</span>
<span>end</span>
<span>@take!</span> local_counter</pre></div>
<p dir="auto">But note that if you have a mutable struct, you can just use <code>setproperty!</code> as normal:</p>
<div dir="auto" data-snippet-clipboard-copy-content="mutable struct A
    x::Int
end

@own :mut a = A(0)
for _ in 1:10
    a.x += 1
end
# Move it to an immutable:
@own a_imm = a"><pre><span>mutable struct</span> A
    x<span>::</span><span>Int</span>
<span>end</span>

<span>@own</span> <span>:mut</span> a <span>=</span> <span>A</span>(<span>0</span>)
<span>for</span> _ <span>in</span> <span>1</span><span>:</span><span>10</span>
    a<span>.</span>x <span>+=</span> <span>1</span>
<span>end</span>
<span><span>#</span> Move it to an immutable:</span>
<span>@own</span> a_imm <span>=</span> a</pre></div>
<p dir="auto">And, as expected:</p>
<div dir="auto" data-snippet-clipboard-copy-content="julia&gt; a_imm.x += 1
ERROR: Cannot write to immutable

julia&gt; a.x += 1
ERROR: Cannot use a: value has been moved"><pre>julia<span>&gt;</span> a_imm<span>.</span>x <span>+=</span> <span>1</span>
ERROR<span>:</span> Cannot write to immutable

julia<span>&gt;</span> a<span>.</span>x <span>+=</span> <span>1</span>
ERROR<span>:</span> Cannot use a<span>:</span> value has been moved</pre></div>

<p dir="auto">Sometimes you want to create a completely independent copy of a value.
While you could use <code>@own new = @take(old)</code>, the <code>@clone</code> macro provides a clearer way to express this intent:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut original = [1, 2, 3]
@clone copy = original  # Creates an immutable deep copy
@clone :mut mut_copy = original  # Creates a mutable deep copy

push!(mut_copy, 4)  # Can modify the mutable copy
@test_throws BorrowRuleError push!(copy, 4)  # Can&#39;t modify the immutable copy
push!(original, 5)  # Original still usable

@test original == [1, 2, 3, 5]
@test copy == [1, 2, 3]
@test mut_copy == [1, 2, 3, 4]"><pre><span>@own</span> <span>:mut</span> original <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>@clone</span> copy <span>=</span> original  <span><span>#</span> Creates an immutable deep copy</span>
<span>@clone</span> <span>:mut</span> mut_copy <span>=</span> original  <span><span>#</span> Creates a mutable deep copy</span>

<span>push!</span>(mut_copy, <span>4</span>)  <span><span>#</span> Can modify the mutable copy</span>
<span>@test_throws</span> BorrowRuleError <span>push!</span>(copy, <span>4</span>)  <span><span>#</span> Can&#39;t modify the immutable copy</span>
<span>push!</span>(original, <span>5</span>)  <span><span>#</span> Original still usable</span>

<span>@test</span> original <span>==</span> [<span>1</span>, <span>2</span>, <span>3</span>, <span>5</span>]
<span>@test</span> copy <span>==</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>@test</span> mut_copy <span>==</span> [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>]</pre></div>
<p dir="auto">Another macro is <code>@move</code>, which is a more explicit version of <code>@own new = @take!(old)</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@own :mut original = [1, 2, 3]
@move new = original  # Creates an immutable deep copy

@test_throws MovedError push!(original, 4)"><pre><span>@own</span> <span>:mut</span> original <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
<span>@move</span> new <span>=</span> original  <span><span>#</span> Creates an immutable deep copy</span>

<span>@test_throws</span> MovedError <span>push!</span>(original, <span>4</span>)</pre></div>
<p dir="auto">Note that <code>@own new = old</code> will also work as a convenience, but <code>@move</code> is more explicit and also asserts that the new value is owned.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Introducing BorrowChecker.jl to Your Codebase</h3><a id="user-content-introducing-borrowcheckerjl-to-your-codebase" aria-label="Permalink: Introducing BorrowChecker.jl to Your Codebase" href="#introducing-borrowcheckerjl-to-your-codebase"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When introducing BorrowChecker.jl to your codebase, the first thing is to <code>@own</code> all variables at the top of a particular function. The single-arg version of <code>@own</code> is particularly useful in this case:</p>
<div dir="auto" data-snippet-clipboard-copy-content="function process_data(x, y, z)
    @own x, y
    @own :mut z

    #= body =#
end"><pre><span>function</span> <span>process_data</span>(x, y, z)
    <span>@own</span> x, y
    <span>@own</span> <span>:mut</span> z

    <span><span>#=</span> body <span>=#</span></span>
<span>end</span></pre></div>
<p dir="auto">This pattern is useful for generic functions because if you pass an owned variable as either <code>x</code>, <code>y</code>, or <code>z</code>, the original function will get marked as moved.</p>
<p dir="auto">The next pattern that is useful is to use <code>OrBorrowed{T}</code> (basically <code>==Union{T,Borrowed{&lt;:T}}</code>) and <code>OrBorrowedMut{T}</code> aliases for extending signatures. Let&#39;s say you have some function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct Bar{T}
    x::Vector{T}
end

function foo(bar::Bar{T}) where {T}
    sum(bar.x)
end"><pre><span>struct</span> Bar{T}
    x<span>::</span><span>Vector{T}</span>
<span>end</span>

<span>function</span> <span>foo</span>(bar<span>::</span><span>Bar{T}</span>) <span>where</span> {T}
    <span>sum</span>(bar<span>.</span>x)
<span>end</span></pre></div>
<p dir="auto">Now, you&#39;d like to modify this so that it can accept <em>references</em> to <code>Bar</code> objects from other functions. Since <code>foo</code> doesn&#39;t need to mutate <code>bar</code>, we can modify this as follows:</p>
<div dir="auto" data-snippet-clipboard-copy-content="function foo(bar::OrBorrowed{Bar{T}}) where {T}
    sum(bar.x)
end"><pre><span>function</span> <span>foo</span>(bar<span>::</span><span>OrBorrowed{Bar{T}}</span>) <span>where</span> {T}
    <span>sum</span>(bar<span>.</span>x)
<span>end</span></pre></div>
<p dir="auto">Thus, the full <code>process_data</code> function might be something like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="function process_data(x, y, z)
    @own x, y
    @own :mut z

    @own total = @lifetime lt begin
        @ref ~lt r1 = z
        @ref ~lt r2 = z

        @own tasks = [
            Threads.@spawn(foo(r1))
            Threads.@spawn(foo(r2))
        ]
        sum(map(fetch, @take!(tasks)))
    end
end"><pre><span>function</span> <span>process_data</span>(x, y, z)
    <span>@own</span> x, y
    <span>@own</span> <span>:mut</span> z

    <span>@own</span> total <span>=</span> <span>@lifetime</span> lt <span>begin</span>
        <span>@ref</span> <span>~</span>lt r1 <span>=</span> z
        <span>@ref</span> <span>~</span>lt r2 <span>=</span> z

        <span>@own</span> tasks <span>=</span> [
            Threads<span>.</span><span>@spawn</span>(<span>foo</span>(r1))
            Threads<span>.</span><span>@spawn</span>(<span>foo</span>(r2))
        ]
        <span>sum</span>(<span>map</span>(fetch, <span>@take!</span>(tasks)))
    <span>end</span>
<span>end</span></pre></div>
<p dir="auto">Because we modified <code>foo</code> to accept <code>OrBorrowed{Bar{T}}</code>, we can safely pass immutable references to <code>z</code>, and it will <em>not</em> be marked as moved in the original context!</p>
<p dir="auto">Immutable references are safe to pass in a multi-threaded context, so doubles as a good way to prevent unintended thread races.</p>
<section data-footnotes="">
<ol dir="auto">
<li id="user-content-fn-1-472df44c11b4215ae9966a2874bed20c">
<p dir="auto">Luckily, the library has a way to try flag such mistakes by recording symbols used in the macro. <a href="#user-content-fnref-1-472df44c11b4215ae9966a2874bed20c" data-footnote-backref="" aria-label="Back to reference 1">â†©</a></p>
</li>
</ol>
</section>
</article></div></div>
  </body>
</html>
