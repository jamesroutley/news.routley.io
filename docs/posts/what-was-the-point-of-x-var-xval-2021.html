<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.vidarholen.net/contents/blog/?p=1035">Original</a>
    <h1>What was the point of [ “x$var” = “xval” ]? (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><p>In shell scripting you sometimes come across comparisons where each value is prefixed with &#34;x&#34;. Here are some examples from GitHub:</p>
<pre><code>if [ &#34;x${JAVA}&#34; = &#34;x&#34; ]; then
if [ &#34;x${server_ip}&#34; = &#34;xlocalhost&#34; ]; then
if test x$1 = &#39;x--help&#39; ; then
</code></pre>
<p>I’ll call this the x-hack.</p>
<p>For any <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html">POSIX compliant shell</a>, the value of the x-hack is exactly zero: this comparison works without the <code>x</code> 100% of the time. But why was it a thing?</p>
<p>Online sources like <a href="https://stackoverflow.com/questions/174119/why-do-shell-script-comparisons-often-use-xvar-xyes">this stackoverflow Q&amp;A</a> are a little handwavy, saying it’s an alternative to quoting (oof), pointing towards issues with &#34;some versions&#34; of certain shells, or generally cautioning against the mystic behaviors of especially ancient Unix system without concrete examples.</p>
<p>To determine whether or not <a href="https://www.shellcheck.net">ShellCheck</a> should warn about this, and if so, what its <a href="https://www.shellcheck.net/wiki/SC2268">long form rationale</a> should be, I decided to dig into the history of Unix with the help of <a href="https://www.tuhs.org/">The Unix Heritage Society</a>‘s archives. I was unfortunately unable to peer into the closely guarded world of the likes of HP-UX and AIX, so dinosaur herders beware.</p>
<p>These are the cases I found that can fail.</p>
<h3>Left-hand side matches a unary operator</h3>
<p>The AT&amp;T Unix v6 shell from 1973, at least as found in PWB/UNIX from 1977, would fail to run test commands whose left-hand side
matched a unary operator. This must have been immediately obvious to anyone who tried to check for command line parameters:</p>
<pre><code>% arg=&#34;-f&#34;
% test &#34;$arg&#34; = &#34;-f&#34;
syntax error: -f
% test &#34;x$arg&#34; = &#34;x-f&#34;
(true)
</code></pre>
<p>This was fixed in the AT&amp;T Unix v7 Bourne shell builtin in 1979. However, <code>test</code> and <code>[</code> were also available as separate
executables, and appear to have retained a variant of the buggy behavior:</p>
<pre><code>$ arg=&#34;-f&#34;
$ [ &#34;$arg&#34; = &#34;-f&#34; ]
(false)
$ [ &#34;x$arg&#34; = &#34;x-f&#34; ]
(true)
</code></pre>
<p>This happened because the utility used a simple recursive descent parser without backtracking, which gave unary operators precedence over binary operators and ignored trailing arguments.</p>
<p>The &#34;modern&#34; Bourne shell behavior was copied by the Public Domain KornShell in 1988, and made part of POSIX.2 in 1992. GNU Bash 1.14 did the same thing for its builtin <code>[</code>, and the GNU shellutils package that provided the external <code>test</code>/<code>[</code> binaries followed POSIX, so the early GNU/Linux distros like SLS were not affected, nor was FreeBSD 1.0.</p>
<p>The x-hack is effective because no unary operators can start with <code>x</code>.</p>
<h3>Either side matches string length operator <code>-l</code></h3>
<p>A similar issue that survived longer was with the string length operator <code>-l</code>. Unlike the normal unary predicates, this one was only parsed as part as part of an operand to binary predicates:</p>
<pre><code>var=&#34;helloworld&#34;
[ -l &#34;$var&#34; -gt 8 ] &amp;&amp; echo &#34;String is longer than 8 chars&#34;
</code></pre>
<p>It did not make it into POSIX because, as the rationale puts it, &#34;it was undocumented in most implementations, has been removed from some implementations (including System V), and the functionality is provided by the shell&#34;, referring to <code>[ ${#var} -gt 8 ]</code>.</p>
<p>It was not a problem in UNIX v7 where <code>=</code> took precedence, but Bash 1.14 from 1996 would parse it greedily up front:</p>
<pre><code>$ var=&#34;-l&#34;
$ [ &#34;$var&#34; = &#34;-l&#34; ]
test: -l: binary operator expected
$ [ &#34;x$var&#34; = &#34;x-l&#34; ]
(true)
</code></pre>
<p>It was also a problem on the right-hand side, but only in nested expressions.
The <code>-l</code> check made sure there was a second argument, so you would need an
additional expression or parentheses to trigger it:</p>
<pre><code>$ [ &#34;$1&#34; = &#34;-l&#34; -o 1 -eq 1 ]
[: too many arguments
$ [ &#34;x$1&#34; = &#34;x-l&#34; -o 1 -eq 1 ]
(true)
</code></pre>
<p>This operator was removed in Bash 2.0 later that year, eliminating the problem.</p>
<h3>Left-hand side is <code>!</code></h3>
<p>Another issue in early shells was when the left-hand side was the negation operator <code>!</code>:</p>
<pre><code>$ var=&#34;!&#34;
$ [ &#34;$var&#34; = &#34;!&#34; ]
test: argument expected            (UNIX v7, 1979)
test: =: unary operator expected   (bash 1.14, 1996)
(false)                            (pd-ksh88, 1988)
$ [ &#34;x$var&#34; = &#34;x!&#34; ]
(true)
</code></pre>
<p>Again, the x-hack is effective by preventing the <code>!</code> from being recognized as a negation operator.</p>
<p>ksh treated this the same as <code>[ ! &#34;=&#34; ]</code>, and ignored the rest of the arguments. This quiety returned false, as <code>=</code> is not a null string.
Ksh continues to ignore trailing arguments to this day:</p>
<pre><code>$ [ -e / random words/ops here ]
(true)                              (ksh93, 2021)
bash: [: too many arguments         (bash5, 2021)
</code></pre>
<p>Bash 2.0 and ksh93 both fixed this problem by letting <code>=</code> take precedence in the 3-argument case, in accordance with POSIX.</p>
<h3>Left-hand side is &#34;(&#34;</h3>
<p>This is by far my favorite.</p>
<p>The UNIX v7 builtin failed when the left-hand side was a left-parenthesis:</p>
<pre><code>$ left=&#34;(&#34; right=&#34;(&#34;
$ [ &#34;$left&#34; = &#34;$right&#34; ]
test: argument expected
$ [ &#34;x$left&#34; = &#34;x$right&#34; ]
(true)
</code></pre>
<p>This happens because the <code>(</code> takes precedence over the <code>=</code>, and becomes an invalid parenthesis group.</p>
<p>Why is this my favorite? Behold Dash 0.5.4 up until 2009:</p>
<pre><code>$ left=&#34;(&#34; right=&#34;(&#34;
$ [ &#34;$left&#34; = &#34;$right&#34; ]
[: 1: closing paren expected
$ [ &#34;x$left&#34; = &#34;x$right&#34; ]
(true)
</code></pre>
<p>That was an active bug when the StackOverflow Q&amp;A was posted.</p>
<p>But wait, there’s more!</p>
<p>Here’s Zsh in <a href="https://github.com/zsh-users/zsh/commit/67877f60552019226e93f56b108f7b61a60ea11b"><strong>late 2015</strong></a>, right before version 5.3:</p>
<pre><code>% left=&#34;(&#34; right=&#34;)&#34;
% [ &#34;$left&#34; = &#34;$right&#34; ]
(true)
% [ &#34;x$left&#34; = &#34;x$right&#34; ]
(false)
</code></pre>
<p>Amazingly, the x-hack could be used to work around certain bugs all the way up until 2015, seven years after StackOverflow wrote it off as an archaic relic of the past!</p>
<p>The bugs are of course increasingly hard to come across. The Zsh one only triggers when comparing left-paren against right-paren, as otherwise the parser will backtrack and figure it out.</p>
<p>Another late holdout was Solaris, whose /bin/sh was the legacy Bourne shell as
late as Solaris 10 in 2009. However, this was undoubtedly for compatibility, and
not because they believed this was a viable shell. A &#34;standards compliant&#34; shell
had been an option for a long time before Solaris 11 dragged it kicking and screaming
into 21th century — or at least into the 90s — by switching to ksh93 by default in 2011.</p>
<p>In all cases, the x-hack is effective because it prevents the operands from being recognized as parentheses.</p>
<h3>Conclusion</h3>
<p>The x-hack was indeed useful and effective against several real and practical
problems in multiple shells.</p>
<p>However, the value was mostly gone by the mid-to-late 1990s, and the few
remaining issues were cleaned up before 2010 — shockingly late, but still over a
decade ago.</p>
<p>The last one managed to stay until 2015, but only in the very specific case of
comparing opening parenthesis to a closed parenthesis in one specific non-system shell.</p>
<p>I think it’s time to retire this idiom, and ShellCheck
<a href="https://github.com/koalaman/shellcheck/commit/5669eb22037980c5a6b74b0d420cb452990bcf88">now offers</a> a style suggestion by default.</p>
<h3>Epilogue</h3>
<p>The Dash issue of <code>[ &#34;(&#34; = &#34;)&#34; ]</code> was originally reported in a form that affected both Bash 3.2.48 and Dash 0.5.4 in 2008. You can still see this on macOS bash today:</p>
<pre><code>$ str=&#34;-e&#34;
$ [ \( ! &#34;$str&#34; \) ]
[: 1: closing paren expected     # dash
bash: [: `)&#39; expected, found ]   # bash
</code></pre>
<p>POSIX fixes all these ambiguities for up to 4 parameters, ensuring that shells conditions work the same way, everywhere, all the time.</p>
<p>Here’s how Dash maintainer Herbert Xu put it <a href="https://git.kernel.org/pub/scm/utils/dash/dash.git/commit/?id=4df1e776cd079357f877f0d491a80a234f670452">in the fix</a>:</p>
<pre><code>/*
 * POSIX prescriptions: he who wrote this deserves the Nobel
 * peace prize.
 */
</code></pre>
</div></div>
  </body>
</html>
