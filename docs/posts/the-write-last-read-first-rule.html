<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2025-11-06-the-write-last-read-first-rule/">Original</a>
    <h1>The write last, read first rule</h1>
    
    <div id="readability-page-1" class="page"><div><p>TigerBeetle is a financial transactions database built for
correctness. Yet, building a correct system from correct components
remains a challenge:</p>
<p>Composing systems, each correct in isolation, does not necessarily
yield a correct system. In this post, we’ll explore how to maintain
consistency in the absence of transactions, how to reason about
correctness when intermediate states are externalized, and how to
recover from partial failures.</p>
<h2 id="keeping-systems-in-sync"><a href="#keeping-systems-in-sync" aria-hidden="true">Keeping Systems in Sync</a></h2>
<p>TigerBeetle is a financial transactions database that offers two
primitives for double-entry bookkeeping: accounts and transfers. A
separate data store, such as Postgres, stores master data, such as name
and address of the account holder or terms and conditions of the
account.</p>
<p>This separation enables transfers to scale independently of general
purpose master data (for example dealing with Black Friday events) and
solves different security, compliance, or retention requirements of the
independent data sets (for example enforce immutability of
transfers).</p>
<p><img src="https://tigerbeetle.com/blog/2025-11-06-the-write-last-read-first-rule/architecture-dark.svg" alt="Architecture"/></p>
<p>Just as a bank may have need for both a filing cabinet and a bank
vault, Postgres specializes in strings and describing entities (master
data), while TigerBeetle specializes in integers and moving integers
between these entities.</p>
<p>A transaction is a sequence of operations ending in a commit, where
all operations take effect, or an abort, where no operation takes
effect. The completion is instant, intermediate state is not
externalized and is not observable. Disruptions (such as process failure
or network failure) are mitigated transparently.</p>
<p><img alt="Transaction Boundaries" src="https://tigerbeetle.com/blog/2025-11-06-the-write-last-read-first-rule/transaction-boundary-1-dark.svg" width="100%"/></p><p>However, the sequential composition of two transactions is not itself
a transaction. The completion of the entire sequence is (at best)
eventual, intermediate state is externalized and observable. Disruptions
are not mitigated transparently.</p>
<p><img alt="Transaction Boundaries" src="https://tigerbeetle.com/blog/2025-11-06-the-write-last-read-first-rule/transaction-boundary-2-dark.svg" width="100%"/></p><p>Since Postgres and TigerBeetle do not share a transaction boundary,
the application must ensure consistency through repeated attempts at
completion and coordination, not transactions.</p>
<p>To reason about such coordination, we need to understand the
guarantees we expect our system to uphold.</p>
<p>A system is characterized by a set of safety and liveness properties.
A safety property states that nothing bad ever happens, while a liveness
property states that something good eventually happens.</p>
<p>In this post, we will focus on two safety properties:</p>
<ul>
<li><strong>Consistent</strong></li>
</ul>
<pre><code>Consistent =
  ∧ ∀ a₁ ∈ PG: ∃ a₂ ∈ TB: id(a₁) = id(a₂)
  ∧ ∀ a₁ ∈ TB: ∃ a₂ ∈ PG: id(a₁) = id(a₂)</code></pre>
<ul>
<li><strong>Traceable</strong></li>
</ul>
<pre><code>Traceable = ∀ a₁ ∈ TB: balance(a₁) &gt; 0 =&gt; ∃ a₂ ∈ PG: id(a₁) = id(a₂)</code></pre>
<p>In the absence of transactions, the system may be
<em>temporarily</em> inconsistent. However, the system must
<em>always</em> remain traceable to avoid the possibility of losing—or,
more precisely, orphaning—money.</p>
<h2 id="choosing-your-champion"><a href="#choosing-your-champion" aria-hidden="true">Choosing your Champion</a></h2>
<p>In the absence of transactions, we need to make an explicit
architectural decision that transactions used to make implicitly: Which
system determines the existence of an account? In other words: Which
system is the source of truth?</p>
<p>We must designate a:</p>
<ul>
<li><p><strong>System of Record</strong>. The champion. If the account
exists here, the account exists on a system level.</p></li>
<li><p><strong>System of Reference</strong>. The supporter. If the
account exists here but not in the system of record, the account does
not exist on a system level.</p></li>
</ul>
<p>So which system is the system of record and which is the system of
reference? That is an architectural decision that depends on your
requirements and the properties of the subsystems. In this case,
TigerBeetle is the system of record:</p>
<ul>
<li><p>If the account is present in Postgres, the account is not able to
process transfers, so the account in Postgres merely represents a staged
record.</p></li>
<li><p>If the account is present in TigerBeetle, the account is able to
process transfers, so the account in TigerBeetle represents a committed
record.</p></li>
</ul>
<p>In other words, as soon as the account is created in TigerBeetle, the
account exists system wide.</p>
<h2 id="order-of-operations"><a href="#order-of-operations" aria-hidden="true">Order of Operations</a></h2>
<p>Once the system of record is chosen, correctness depends on
performing operations in the right order.</p>
<p>Since the system of reference doesn’t determine existence, we can
safely write to it first without committing anything. Only when we write
to the system of record does the account spring into existence.</p>
<p>Conversely, when reading to check existence, we must consult the
system of record, because reading from the system of reference tells us
nothing about whether the account actually exists.</p>
<p><strong>This principle—Write Last, Read First—ensures that we
maintain application level consistency.</strong></p>
<p>Remarkably, if the system of record provides strict serializability,
like TigerBeetle, and if ordering is correctly applied, then the system
as a whole preserves strict serializability, leading to a delightful
developer experience.</p>
<h2 id="the-consequences-of-the-wrong-choice"><a href="#the-consequences-of-the-wrong-choice" aria-hidden="true">The consequences of the wrong choice</a></h2>
<p>Choosing the correct system of record and the correct order of
operations is not just a philosophical exercise. If we designate the
wrong system as the source of truth and perform operations in the wrong
order, we may quickly violate safety properties.</p>
<p>For example, if we create the account in TigerBeetle but not in
Postgres, the system may start processing transfers without containing
any information about who this account belongs to. If the system crashes
and forensics do not surface the necessary information to establish
ownership, we violated the golden rule: traceability.</p>
<p>However, if we create the account in Postgres but subsequently not in
TigerBeetle, no harm, no foul. Any transfer attempt is simply rejected
by TigerBeetle, money cannot flow to an account that doesn’t exist in
the ledger.</p>
<h2 id="implementation"><a href="#implementation" aria-hidden="true">Implementation</a></h2>
<p>Clients interact with the system exclusively via the Application
Programming Interface exposed by the application layer, which in turn
interacts via the interfaces exposed by the subsystems, Postgres and
TigerBeetle.</p>
<p>The Application Programming Interface has two responsibilities,
Orchestration and aggregation: The API determines the order of
operations and aggregates operation results into application level
semantics.</p>
<h2 id="distributed-async-await"><a href="#distributed-async-await" aria-hidden="true">Distributed Async Await</a></h2>
<p>We will implement the API with Resonate’s durable execution
framework, Distributed Async Await. Distributed Async Await guarantees
eventual completion simplifying reaching consistency even in the absence
of transactions.</p>
<p>Resonate guarantees eventual completion via language integrated
checkpointing and reliable resumption in case of disruptions: Executions
resume where they left off by restarting from the beginning and skipping
steps that have already been recorded (see Figure 4.)</p>
<p><img alt="Idempotence" src="https://tigerbeetle.com/blog/2025-11-06-the-write-last-read-first-rule/idempotence-dark.svg" width="100%"/></p><p>However, we must consider a subtle issue inherent to checkpointing:
In the event of a disruption, after performing an operation but before
recording its completion, the operation will be performed again.</p>
<p><strong>Therefore, every operation must be idempotent, i.e. the
repeated application of an operation does not have any effects beyond
the initial application.</strong></p>
<h2 id="subsystem-level"><a href="#subsystem-level" aria-hidden="true">Subsystem Level</a></h2>
<p>For each subsystem, Postgres and TigerBeetle, we implement an
idempotent function to create an account. In our case, both the Postgres
and TigerBeetle account creation functions return whether the account
was created, already existed with the same values, or already existed
with different values:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Result <span>=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span>|</span> { type<span>:</span> “created” }</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> { type<span>:</span> “exists_same” }</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> { type<span>:</span> “exists_diff” }</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span>// Create account in Postgres</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span>async</span> <span>function</span> <span>pgCreateAccount</span>(uuid<span>:</span> <span>string</span><span>,</span> data<span>:</span> <span>any</span>)<span>:</span> <span>Promise</span><span>&lt;</span>Result<span>&gt;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span>// Create Account in TigerBeetle</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span>async</span> <span>function</span> <span>tbCreateAccount</span>(uuid<span>:</span> <span>string</span><span>,</span> data<span>:</span> <span>any</span>)<span>:</span> <span>Promise</span><span>&lt;</span>Result<span>&gt;</span></span></code></pre></div>
<p>The Listing below illustrates <code>tbCreateAccount</code>.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>async</span> <span>function</span> <span>tbCreateAccount</span>(context<span>:</span> Context<span>,</span> guid<span>:</span> <span>number</span>) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span>const</span> client <span>=</span> context<span>.</span><span>getDependency</span>(<span>&#34;client&#34;</span>)<span>;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span>// Construct account object</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span>const</span> account<span>:</span> Account <span>=</span> {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span>...</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  }<span>;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span>const</span> errors <span>=</span> <span>await</span> client<span>.</span><span>createAccounts</span>([account])<span>;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span>// Success case: account was created</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span>if</span> (errors<span>.</span><span>length</span> <span>===</span> <span>0</span>) {</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span>return</span> { type<span>:</span> “created” }<span>;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span>const</span> error <span>=</span> errors[<span>0</span>]<span>;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span>// Account exists with the same properties (idempotent)</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  <span>if</span> (error<span>.</span><span>result</span> <span>===</span> CreateAccountError<span>.</span><span>exists</span>) {</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span>return</span> { type<span>:</span> “exists_same” }<span>;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span>// Account exists with different properties</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  <span>if</span> (</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    error<span>.</span><span>result</span> <span>===</span> CreateAccountError<span>.</span><span>exists_with_different_flags</span> <span>||</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    error<span>.</span><span>result</span> <span>===</span> <span>...</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span>return</span> { type<span>:</span> “exists_diff” }<span>;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  <span>// For any other error, throw</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  <span>throw</span> <span>new</span> <span>Error</span>(<span>`Failed to create account: </span><span>${</span><span>JSON</span><span>.</span><span>stringify</span>(error)<span>}</span><span>`</span>)<span>;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="system-level"><a href="#system-level" aria-hidden="true">System Level</a></h2>
<p>At the system level, the application composes these idempotent
building blocks, interpreting subsystem responses and translating them
into application-level semantics.</p>
<p>For example, Postgres or TigerBeetle may return that an account
already exists but with different values. The application layer must
determine whether this represents a success or a failure, translating
platform level semantics into application level semantics.</p>
<p>In our case, because operations may be repeated, both created or
already exists with the same values constitutes success, but exists with
different values indicates a bug in the system. Additionally, due to
write last, read first, if the Postgres account was created but the
TigerBeetle account already existed, an ordering violation occurred.</p>
<h2 id="account-creation"><a href="#account-creation" aria-hidden="true">Account Creation</a></h2>
<div>
<table>
<thead>
<tr>
<th>Postgres Result</th>
<th>TigerBeetle Result</th>
<th>System Result</th>
<th>Scenario</th>
</tr>
</thead>
<tbody>
<tr>
<td>Created</td>
<td>Created</td>
<td>Success</td>
<td></td>
</tr>
<tr>
<td>Created</td>
<td>Exists/Same</td>
<td>Panic</td>
<td>Violates ordering</td>
</tr>
<tr>
<td>Created</td>
<td>Exists/Diff</td>
<td>Panic</td>
<td>Violates ordering</td>
</tr>
<tr>
<td>Exists/Same</td>
<td>Created</td>
<td>Success</td>
<td>Recovery</td>
</tr>
<tr>
<td>Exists/Same</td>
<td>Exists/Same</td>
<td>Success</td>
<td>Recovery</td>
</tr>
<tr>
<td>Exists/Same</td>
<td>Exists/Diff</td>
<td>Panic</td>
<td>Conflict</td>
</tr>
<tr>
<td>Exists/Diff</td>
<td>Any</td>
<td>Panic</td>
<td>Conflict</td>
</tr>
</tbody>
</table>
</div>
<p>The Listing below illustrates <code>createAccount</code>:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>function</span><span>*</span> <span>createAccount</span>(context<span>:</span> Context<span>,</span> uuid<span>:</span> <span>string</span><span>,</span> data<span>:</span> <span>any</span>) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span>// Generate internal account ID for TigerBeetle</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span>const</span> guid <span>=</span> <span>yield</span><span>*</span> context<span>.</span><span>run</span>(generateId)<span>;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span>// Create account in Postgres</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span>const</span> pgResult <span>=</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span>yield</span><span>*</span> context<span>.</span><span>run</span>(pgCreateAccount<span>,</span> uuid<span>,</span> { <span>...</span>data<span>,</span> guid<span>:</span> guid })<span>;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span>// Panic and alert the operator if the account exists</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span>// but with different values</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span>yield</span><span>*</span> context<span>.</span><span>panic</span>(pgResult<span>.</span><span>type</span> <span>==</span> “exists_diff”)<span>;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span>// Create account in TigerBeetle</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span>const</span> tbResult <span>=</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span>yield</span><span>*</span> context<span>.</span><span>run</span>(tbCreateAccount<span>,</span> guid)<span>;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span>// Panic and alert the operator if the account exists</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span>// but with different values</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>  <span>yield</span><span>*</span> context<span>.</span><span>panic</span>(tbResult<span>.</span><span>type</span> <span>==</span> “exists_diff”)<span>;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>  <span>// Panic and alert the operator if ordering was violated</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>  <span>yield</span><span>*</span> context<span>.</span><span>panic</span>(pgResult<span>.</span><span>type</span> <span>==</span> <span>&#34;created&#34;</span> <span>&amp;&amp;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                       tbResult<span>.</span><span>type</span> <span>==</span> “exists_same”)<span>;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>  <span>return</span> {uuid<span>,</span> guid}<span>;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We need to detect and mitigate correctness violations, here by
refusing to proceed and inform the operator.</p>
<p>To create an account, the developer executes createAccount with a
unique id, for example the account id</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>await</span> resonate<span>.</span><span>run</span>(<span>`create-</span><span>${</span>uuid<span>}</span><span>`</span><span>,</span> createAccount<span>,</span> uuid<span>,</span> {<span>...</span>})<span>;</span></span></code></pre></div>
<p>The unique identifier <code>create-${uuid}</code> assigned a unique
identity to the top level execution and transitively to every sub level
execution, ensuring consistent checkpointing and eliminating the need
for explicit recovery logic.</p>
<h2 id="conclusion"><a href="#conclusion" aria-hidden="true">Conclusion</a></h2>
<p>In the absence of transaction, we turn to coordination to ensure the
correctness of our applications. A powerful framework to reason about
correctness is to delineate the system into system of record and system
of reference and ordering operations according to your requirements.</p>
<p>While correctness still requires careful design, with durable
executions, intentional ordering, and idempotent operations, we can
build correct systems from correct components.</p>
<p>Note: To run the example, visit the GitHub repository at <a href="https://github.com/resonatehq-examples/example-tigerbeetle-account-creation-ts">https://github.com/resonatehq-examples/example-tigerbeetle-account-creation-ts</a>.</p>
<hr/>
<p>Thanks to <a href="https://www.dtornow.com">Dominik Tornow</a>,
Founder and CEO of <a href="https://www.resonatehq.io">Resonate</a>, for
penning this guest post!</p>
  </div></div>
  </body>
</html>
