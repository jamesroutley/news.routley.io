<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/buraksezer/olric">Original</a>
    <h1>Olric: Distributed, embeddable data structures in Go</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="https://pkg.go.dev/github.com/buraksezer/olric" rel="nofollow"><img src="https://camo.githubusercontent.com/c21b6916ce5cdd6292800221098d1d581f020a1a9adb41ae2027f31cb03882e5/68747470733a2f2f706b672e676f2e6465762f62616467652f6769746875622e636f6d2f627572616b73657a65722f6f6c7269632e737667" alt="Go Reference" data-canonical-src="https://pkg.go.dev/badge/github.com/buraksezer/olric.svg"/></a> <a href="https://coveralls.io/github/buraksezer/olric?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/acfadd68515e391c94423207e5bff9078809f69d2a8e4a25c2fa227ded44276d/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f627572616b73657a65722f6f6c7269632f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/buraksezer/olric/badge.svg?branch=master"/></a> <a href="https://travis-ci.org/buraksezer/olric" rel="nofollow"><img src="https://camo.githubusercontent.com/62618b3058ee9acbe42a58e63209c49aa780827d01da0688755c3126d1027327/68747470733a2f2f7472617669732d63692e6f72672f627572616b73657a65722f6f6c7269632e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/buraksezer/olric.svg?branch=master"/></a> <a href="https://goreportcard.com/report/github.com/buraksezer/olric" rel="nofollow"><img src="https://camo.githubusercontent.com/41fa2d94e6d4bb9bfbab7c3d1a55f14fcbb42e98af34da507ac1fb21745df54b/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f627572616b73657a65722f6f6c726963" alt="Go Report Card" data-canonical-src="https://goreportcard.com/badge/github.com/buraksezer/olric"/></a> <a href="https://discord.gg/ahK7Vjr8We" rel="nofollow"><img src="https://camo.githubusercontent.com/bc6d14f45204575588675cae0a1b695bf079a4eb09115ec3ccbe0914d235ec95/68747470733a2f2f696d672e736869656c64732e696f2f646973636f72642f3732313730383939383032313038373237332e7376673f6c6162656c3d266c6f676f3d646973636f7264266c6f676f436f6c6f723d66666666666626636f6c6f723d373338394438266c6162656c436f6c6f723d364137454332" alt="Discord" data-canonical-src="https://img.shields.io/discord/721708998021087273.svg?label=&amp;logo=discord&amp;logoColor=ffffff&amp;color=7389D8&amp;labelColor=6A7EC2"/></a> <a href="https://opensource.org/licenses/Apache-2.0" rel="nofollow"><img src="https://camo.githubusercontent.com/2a2157c971b7ae1deb8eb095799440551c33dcf61ea3d965d86b496a5a65df55/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d417061636865253230322e302d626c75652e737667" alt="License" data-canonical-src="https://img.shields.io/badge/License-Apache%202.0-blue.svg"/></a></p>
<p dir="auto">Olric is a distributed, in-memory object store. It&#39;s designed from the ground up to be distributed, and it can be
used both as an embedded Go library and as a language-independent service.</p>
<p dir="auto">With Olric, you can instantly create a fast, scalable, shared pool of RAM across a cluster of computers.</p>
<p dir="auto">Olric is implemented in <a href="https://go.dev/" rel="nofollow">Go</a> and uses the <a href="https://redis.io/topics/protocol" rel="nofollow">Redis serialization protocol</a>. So Olric has client implementations in all major programming
languages.</p>
<p dir="auto">Olric is highly scalable and available. Distributed applications can use it for distributed caching, clustering and
publish-subscribe messaging.</p>
<p dir="auto">It is designed to scale out to hundreds of members and thousands of clients. When you add new members, they automatically
discover the cluster and linearly increase the memory capacity. Olric offers simple scalability, partitioning (sharding),
and re-balancing out-of-the-box. It does not require any extra coordination processes. With Olric, when you start another
process to add more capacity, data and backups are automatically and evenly balanced.</p>
<p dir="auto">See <a href="#docker">Docker</a> and <a href="#samples">Samples</a> sections to get started!</p>
<p dir="auto">Join our <a href="https://discord.gg/ahK7Vjr8We" rel="nofollow">Discord server!</a></p>
<p dir="auto">The current production version is <a href="https://github.com/buraksezer/olric/tree/release/v0.4.0#olric-">v0.4.9</a></p>
<h3 dir="auto"><a id="user-content-about-versions" aria-hidden="true" href="#about-versions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>About versions</h3>
<p dir="auto">Olric v0.4 and previous versions use <em>Olric Binary Protocol</em>, v0.5 uses <a href="https://redis.io/docs/reference/protocol-spec/" rel="nofollow">Redis serialization protocol</a> for communication and the API was significantly changed.
Olric v0.4.x tree is going to receive bug fixes and security updates forever, but I would recommend considering an upgrade to the new version.</p>
<p dir="auto">This document only covers <code>v0.5</code>. See v0.4.x documents <a href="https://github.com/buraksezer/olric/tree/release/v0.4.0#olric-">here</a>.</p>
<p dir="auto"><strong>Important note</strong>: Documenting <code>v0.5</code> is an ongoing effort. So some parts of this document may be wrong or inaccurate.</p>
<h2 dir="auto"><a id="user-content-at-a-glance" aria-hidden="true" href="#at-a-glance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>At a glance</h2>
<ul dir="auto">
<li>Designed to share some transient, approximate, fast-changing data between servers,</li>
<li>Uses Redis serialization protocol,</li>
<li>Implements a distributed hash table,</li>
<li>Provides a drop-in replacement for Redis Publish/Subscribe messaging system,</li>
<li>Supports both programmatic and declarative configuration,</li>
<li>Embeddable but can be used as a language-independent service with <em>olricd</em>,</li>
<li>Supports different eviction algorithms (including LRU and TTL),</li>
<li>Highly available and horizontally scalable,</li>
<li>Provides best-effort consistency guarantees without being a complete CP (indeed PA/EC) solution,</li>
<li>Supports replication by default (with sync and async options),</li>
<li>Quorum-based voting for replica control (Read/Write quorums),</li>
<li>Supports atomic operations,</li>
<li>Implements an iterator on distributed maps,</li>
<li>Provides a plugin interface for service discovery daemons,</li>
<li>Provides a locking primitive which inspired by <a href="https://redis.io/commands/setnx#design-pattern-locking-with-codesetnxcode" rel="nofollow">SETNX of Redis</a>,</li>
</ul>
<h2 dir="auto"><a id="user-content-possible-use-cases" aria-hidden="true" href="#possible-use-cases"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Possible Use Cases</h2>
<p dir="auto">Olric is an eventually consistent, unordered key/value data store. It supports various eviction mechanisms for distributed caching implementations. Olric
also provides publish-subscribe messaging, data replication, failure detection and simple anti-entropy services.</p>
<p dir="auto">It&#39;s good at distributed caching and publish/subscribe messaging.</p>
<h2 dir="auto"><a id="user-content-table-of-contents" aria-hidden="true" href="#table-of-contents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Table of Contents</h2>
<ul dir="auto">
<li><a href="#features">Features</a></li>
<li><a href="#support">Support</a></li>
<li><a href="#installing">Installing</a>
<ul dir="auto">
<li><a href="#docker">Docker</a></li>
<li><a href="#kubernetes">Kubernetes</a></li>
<li><a href="#working-with-docker-compose">Working with Docker Compose</a></li>
</ul>
</li>
<li><a href="#getting-started">Getting Started</a>
<ul dir="auto">
<li><a href="#operation-modes">Operation Modes</a>
<ul dir="auto">
<li><a href="#embedded-member">Embedded Member</a></li>
<li><a href="#client-server">Client-Server</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#golang-client">Golang client</a></li>
<li><a href="#commands">Commands</a>
<ul dir="auto">
<li><a href="#distributed-map">Distributed Map</a>
<ul dir="auto">
<li><a href="#dmput">DM.PUT</a></li>
<li><a href="#dmget">DM.GET</a></li>
<li><a href="#dmdel">DM.DEL</a></li>
<li><a href="#dmexpire">DM.EXPIRE</a></li>
<li><a href="#dmpexpire">DM.PEXPIRE</a></li>
<li><a href="#dmdestroy">DM.DESTROY</a></li>
<li><a href="#atomic-operations">Atomic Operations</a>
<ul dir="auto">
<li><a href="#dmincr">DM.INCR</a></li>
<li><a href="#dmdecr">DM.DECR</a></li>
<li><a href="#dmgetput">DM.GETPUT</a></li>
<li><a href="#dmincrbyfloat">DM.INCRBYFLOAT</a></li>
</ul>
</li>
<li><a href="#locking">Locking</a>
<ul dir="auto">
<li><a href="#dmlock">DM.LOCK</a></li>
<li><a href="#dmunlock">DM.UNLOCK</a></li>
<li><a href="#dmlocklease">DM.LOCKLEASE</a></li>
<li><a href="#dmplocklease">DM.PLOCKLEASE</a></li>
</ul>
</li>
<li><a href="#dmscan">DM.SCAN</a></li>
</ul>
</li>
<li><a href="#publish-subscribe">Publish-Subscribe</a>
<ul dir="auto">
<li><a href="#subscribe">SUBSCRIBE</a></li>
<li><a href="#psubscribe">PSUBSCRIBE</a></li>
<li><a href="#unsubscribe">UNSUBSCRIBE</a></li>
<li><a href="#punsubscribe">PUNSUBSCRIBE</a></li>
<li><a href="#pubsub-channels">PUBSUB CHANNELS</a></li>
<li><a href="#pubsub-numpat">PUBSUB NUMPAT</a></li>
<li><a href="#pubsub-numsub">PUBSUB NUMSUB</a></li>
<li><a href="#quit">QUIT</a></li>
<li><a href="#ping">PING</a></li>
</ul>
</li>
<li><a href="#cluster">Cluster</a>
<ul dir="auto">
<li><a href="#clusterroutingtable">CLUSTER.ROUTINGTABLE</a></li>
<li><a href="#clustermembers">CLUSTER.MEMBERS</a></li>
</ul>
</li>
<li><a href="#others">Others</a>
<ul dir="auto">
<li><a href="#ping">PING</a></li>
<li><a href="#stats">STATS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#configuration">Configuration</a>
<ul dir="auto">
<li><a href="#embedded-member-mode">Embedded Member Mode</a>
<ul dir="auto">
<li><a href="#manage-the-configuration-in-yaml-format">Manage the configuration in YAML format</a></li>
</ul>
</li>
<li><a href="#client-server-mode">Client-Server Mode</a></li>
<li><a href="#network-configuration">Network Configuration</a></li>
<li><a href="#service-discovery">Service discovery</a></li>
<li><a href="#timeouts">Timeouts</a></li>
</ul>
</li>
<li><a href="#architecture">Architecture</a>
<ul dir="auto">
<li><a href="#overview">Overview</a></li>
<li><a href="#consistency-and-replication-model">Consistency and Replication Model</a>
<ul dir="auto">
<li><a href="#last-write-wins-conflict-resolution">Last-write-wins conflict resolution</a></li>
<li><a href="#pacelc-theorem">PACELC Theorem</a></li>
<li><a href="#read-repair-on-dmaps">Read-Repair on DMaps</a></li>
<li><a href="#quorum-based-replica-control">Quorum-based Replica Control</a></li>
<li><a href="#simple-split-brain-protection">Simple Split-Brain Protection</a></li>
</ul>
</li>
<li><a href="#eviction">Eviction</a>
<ul dir="auto">
<li><a href="#expire-with-ttl">Expire with TTL</a></li>
<li><a href="#expire-with-maxidleduration">Expire with MaxIdleDuration</a></li>
<li><a href="#expire-with-lru">Expire with LRU</a></li>
</ul>
</li>
<li><a href="#lock-implementation">Lock Implementation</a></li>
<li><a href="#storage-engine">Storage Engine</a></li>
</ul>
</li>
<li><a href="#samples">Samples</a></li>
<li><a href="#contributions">Contributions</a></li>
<li><a href="#license">License</a></li>
<li><a href="#about-the-name">About the name</a></li>
</ul>
<h2 dir="auto"><a id="user-content-features" aria-hidden="true" href="#features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Features</h2>
<ul dir="auto">
<li>Designed to share some transient, approximate, fast-changing data between servers,</li>
<li>Accepts arbitrary types as value,</li>
<li>Only in-memory,</li>
<li>Uses Redis protocol,</li>
<li>Compatible with existing Redis clients,</li>
<li>Embeddable but can be used as a language-independent service with olricd,</li>
<li>GC-friendly storage engine,</li>
<li>O(1) running time for lookups,</li>
<li>Supports atomic operations,</li>
<li>Provides a lock implementation which can be used for non-critical purposes,</li>
<li>Different eviction policies: LRU, MaxIdleDuration and Time-To-Live (TTL),</li>
<li>Highly available,</li>
<li>Horizontally scalable,</li>
<li>Provides best-effort consistency guarantees without being a complete CP (indeed PA/EC) solution,</li>
<li>Distributes load fairly among cluster members with a <a href="https://github.com/buraksezer/consistent">consistent hash function</a>,</li>
<li>Supports replication by default (with sync and async options),</li>
<li>Quorum-based voting for replica control,</li>
<li>Thread-safe by default,</li>
<li>Supports <a href="#query">distributed queries</a> on keys,</li>
<li>Provides a plugin interface for service discovery daemons and cloud providers,</li>
<li>Provides a locking primitive which inspired by <a href="https://redis.io/commands/setnx#design-pattern-locking-with-codesetnxcode" rel="nofollow">SETNX of Redis</a>,</li>
<li>Provides a drop-in replacement of Redis&#39; Publish-Subscribe messaging feature.</li>
</ul>
<p dir="auto">See <a href="#architecture">Architecture</a> section to see details.</p>
<h2 dir="auto"><a id="user-content-support" aria-hidden="true" href="#support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Support</h2>
<p dir="auto">You feel free to ask any questions about Olric and possible integration problems.</p>
<ul dir="auto">
<li><a href="https://discord.gg/ahK7Vjr8We" rel="nofollow">Discord server</a></li>
<li><a href="https://groups.google.com/forum/#!forum/olric-user" rel="nofollow">Mail group on Google Groups</a></li>
<li><a href="https://github.com/buraksezer/olric/discussions">GitHub Discussions</a></li>
</ul>
<p dir="auto">You also feel free to open an issue on GitHub to report bugs and share feature requests.</p>
<h2 dir="auto"><a id="user-content-installing" aria-hidden="true" href="#installing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installing</h2>
<p dir="auto">With a correctly configured Golang environment:</p>
<div data-snippet-clipboard-copy-content="go install github.com/buraksezer/olric/cmd/olricd@v0.5.0-rc.1"><pre><code>go install github.com/buraksezer/olric/cmd/olricd@v0.5.0-rc.1
</code></pre></div>
<p dir="auto">Now you can start using Olric:</p>
<div data-snippet-clipboard-copy-content="olricd -c cmd/olricd/olricd-local.yaml"><pre><code>olricd -c cmd/olricd/olricd-local.yaml
</code></pre></div>
<p dir="auto">See <a href="#configuration">Configuration</a> section to create your cluster properly.</p>
<h3 dir="auto"><a id="user-content-docker" aria-hidden="true" href="#docker"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Docker</h3>
<p dir="auto">You can launch <code>olricd</code> Docker container by running the following command.</p>
<div dir="auto" data-snippet-clipboard-copy-content="docker run -p 3320:3320 olricio/olricd:v0.5.0-beta.2"><pre>docker run -p 3320:3320 olricio/olricd:v0.5.0-beta.2</pre></div>
<p dir="auto">This command will pull olricd Docker image and run a new Olric Instance. You should know that the container exposes
<code>3320</code> and <code>3322</code> ports.</p>
<p dir="auto">Now, you can access an Olric cluster using any Redis client including <code>redis-cli</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="redis-cli -p 3320
127.0.0.1:3320&gt; DM.PUT my-dmap my-key &#34;Olric Rocks!&#34;
OK
127.0.0.1:3320&gt; DM.GET my-dmap my-key
&#34;Olric Rocks!&#34;
127.0.0.1:3320&gt;"><pre>redis-cli -p 3320
127.0.0.1:<span>3320&gt;</span> DM.PUT my-dmap my-key <span><span>&#34;</span>Olric Rocks!<span>&#34;</span></span>
OK
127.0.0.1:<span>3320&gt;</span> DM.GET my-dmap my-key
<span><span>&#34;</span>Olric Rocks!<span>&#34;</span></span>
127.0.0.1:<span>3320&gt;</span></pre></div>
<h2 dir="auto"><a id="user-content-getting-started" aria-hidden="true" href="#getting-started"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Getting Started</h2>
<p dir="auto">With olricd, you can create an Olric cluster with a few commands. This is how to install olricd:</p>
<div dir="auto" data-snippet-clipboard-copy-content="go install github.com/buraksezer/olric/cmd/olricd@v0.5.0-rc.1"><pre>go install github.com/buraksezer/olric/cmd/olricd@v0.5.0-rc.1</pre></div>
<p dir="auto">Let&#39;s create a cluster with the following:</p>
<div data-snippet-clipboard-copy-content="olricd -c &lt;YOUR_CONFIG_FILE_PATH&gt;"><pre><code>olricd -c &lt;YOUR_CONFIG_FILE_PATH&gt;
</code></pre></div>
<p dir="auto">You can find the sample configuration file under <code>cmd/olricd/olricd-local.yaml</code>. It can perfectly run with single node.
olricd also supports <code>OLRICD_CONFIG</code> environment variable to set configuration. Just like that:</p>
<div data-snippet-clipboard-copy-content="OLRICD_CONFIG=&lt;YOUR_CONFIG_FILE_PATH&gt; olricd"><pre><code>OLRICD_CONFIG=&lt;YOUR_CONFIG_FILE_PATH&gt; olricd
</code></pre></div>
<p dir="auto">Olric uses <a href="https://github.com/hashicorp/memberlist">hashicorp/memberlist</a> for failure detection and cluster membership.
Currently, there are different ways to discover peers in a cluster. You can use a static list of nodes in your configuration.
It&#39;s ideal for development and test environments. Olric also supports Consul, Kubernetes and all well-known cloud providers
for service discovery. Please take a look at <a href="#service-discovery">Service Discovery</a> section for further information.</p>
<p dir="auto">See <a href="#client-server">Client-Server</a> section to get more information about this deployment scenario.</p>
<h4 dir="auto"><a id="user-content-maintaining-a-list-of-peers-manually" aria-hidden="true" href="#maintaining-a-list-of-peers-manually"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Maintaining a list of peers manually</h4>
<p dir="auto">Basically, there is a list of nodes under <code>memberlist</code> block in the configuration file. In order to create an Olric cluster,
you just need to add <code>Host:Port</code> pairs of the other nodes. Please note that the <code>Port</code> is the memberlist port of the peer.
It is <code>3322</code> by default.</p>
<div dir="auto" data-snippet-clipboard-copy-content="memberlist:
  peers:
    - &#34;localhost:3322&#34;"><pre><span>memberlist</span>:
  <span>peers</span>:
    - <span><span>&#34;</span>localhost:3322<span>&#34;</span></span></pre></div>
<p dir="auto">Thanks to <a href="https://github.com/hashicorp/memberlist">hashicorp/memberlist</a>, Olric nodes can share the full list of members
with each other. So an Olric node can discover the whole cluster by using a single member address.</p>
<h4 dir="auto"><a id="user-content-embedding-into-your-go-application" aria-hidden="true" href="#embedding-into-your-go-application"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Embedding into your Go application.</h4>
<p dir="auto">See <a href="#samples">Samples</a> section to learn how to embed Olric into your existing Golang application.</p>
<h3 dir="auto"><a id="user-content-operation-modes" aria-hidden="true" href="#operation-modes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Operation Modes</h3>
<p dir="auto">Olric has two different operation modes.</p>
<h4 dir="auto"><a id="user-content-embedded-member" aria-hidden="true" href="#embedded-member"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Embedded Member</h4>
<p dir="auto">In Embedded Member Mode, members include both the application and Olric data and services. The advantage of the Embedded
Member Mode is having a low-latency data access and locality.</p>
<h4 dir="auto"><a id="user-content-client-server" aria-hidden="true" href="#client-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Client-Server</h4>
<p dir="auto">In Client-Server Mode, Olric data and services are centralized in one or more servers, and they are accessed by the
application through clients. You can have a cluster of servers that can be independently created and scaled. Your clients
communicate with these members to reach to Olric data and services on them.</p>
<p dir="auto">Client-Server deployment has advantages including more predictable and reliable performance, easier identification
of problem causes and, most importantly, better scalability. When you need to scale in this deployment type, just add more
Olric server members. You can address client and server scalability concerns separately.</p>
<h2 dir="auto"><a id="user-content-golang-client" aria-hidden="true" href="#golang-client"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Golang Client</h2>
<p dir="auto">The official Golang client is defined by the <code>Client</code> interface. There are two different implementations of that interface in
this repository. <code>EmbeddedClient</code> provides a client implementation for <a href="#embedded-member">embedded-member</a> scenario,
<code>ClusterClient</code> provides an implementation of the same interface for <a href="#client-server">client-server</a> deployment scenario.
Obviously, you can use <code>ClusterClient</code> for your embedded-member deployments. But it&#39;s good to use <code>EmbeddedClient</code> provides
a better performance due to localization of the queries.</p>
<p dir="auto">See the client documentation on <a href="https://pkg.go.dev/github.com/buraksezer/olric@v0.5.0-rc.1" rel="nofollow">pkg.go.dev</a></p>
<h2 dir="auto"><a id="user-content-commands" aria-hidden="true" href="#commands"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Commands</h2>
<p dir="auto">Olric uses Redis protocol and supports Redis-style commands to query the database. You can use any Redis client, including
<code>redis-cli</code>. The official Go client is a thin layer around <a href="https://github.com/go-redis/redis">go-redis/redis</a> package.
See <a href="#golang-client">Golang Client</a> section for the documentation.</p>
<h3 dir="auto"><a id="user-content-distributed-map" aria-hidden="true" href="#distributed-map"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Distributed Map</h3>
<h4 dir="auto"><a id="user-content-dmput" aria-hidden="true" href="#dmput"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.PUT</h4>
<p dir="auto">DM.PUT sets the value for the given key. It overwrites any previous value for that key.</p>
<div data-snippet-clipboard-copy-content="DM.PUT dmap key value [ EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds ] [ NX | XX]"><pre><code>DM.PUT dmap key value [ EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds ] [ NX | XX]
</code></pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.PUT my-dmap my-key value
OK"><pre><code>127.0.0.1:3320&gt; DM.PUT my-dmap my-key value
OK
</code></pre></div>
<p dir="auto"><strong>Options:</strong></p>
<p dir="auto">The DM.PUT command supports a set of options that modify its behavior:</p>
<ul dir="auto">
<li><strong>EX</strong> <em>seconds</em> -- Set the specified expire time, in seconds.</li>
<li><strong>PX</strong> <em>milliseconds</em> -- Set the specified expire time, in milliseconds.</li>
<li><strong>EXAT</strong> <em>timestamp-seconds</em> -- Set the specified Unix time at which the key will expire, in seconds.</li>
<li><strong>PXAT</strong> <em>timestamp-milliseconds</em> -- Set the specified Unix time at which the key will expire, in milliseconds.</li>
<li><strong>NX</strong> -- Only set the key if it does not already exist.</li>
<li><strong>XX</strong> -- Only set the key if it already exist.</li>
</ul>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> OK if DM.PUT was executed correctly.</li>
<li><strong>KEYFOUND:</strong> (error) if the DM.PUT operation was not performed because the user specified the NX option but the condition was not met.</li>
<li><strong>KEYNOTFOUND:</strong> (error) if the DM.PUT operation was not performed because the user specified the XX option but the condition was not met.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmget" aria-hidden="true" href="#dmget"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.GET</h4>
<p dir="auto">DM.GET gets the value for the given key. It returns (error)<code>KEYNOTFOUND</code> if the key doesn&#39;t exist.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.GET dmap key
&#34;value&#34;"><pre><code>127.0.0.1:3320&gt; DM.GET dmap key
&#34;value&#34;
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<p dir="auto"><strong>Bulk string reply</strong>: the value of key, or (error)<code>KEYNOTFOUND</code> when key does not exist.</p>
<h4 dir="auto"><a id="user-content-dmdel" aria-hidden="true" href="#dmdel"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.DEL</h4>
<p dir="auto">DM.DEL deletes values for the given keys. It doesn&#39;t return any error if the key does not exist.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.DEL dmap key1 key2
(integer) 2"><pre><code>127.0.0.1:3320&gt; DM.DEL dmap key1 key2
(integer) 2
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Integer reply</strong>: The number of keys that were removed.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmexpire" aria-hidden="true" href="#dmexpire"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.EXPIRE</h4>
<p dir="auto">DM.EXPIRE updates or sets the timeout for the given key. It returns <code>KEYNOTFOUND</code> if the key doesn&#39;t exist. After the timeout has expired,
the key will automatically be deleted.</p>
<p dir="auto">The timeout will only be cleared by commands that delete or overwrite the contents of the key, including DM.DEL, DM.PUT, DM.GETPUT.</p>
<div data-snippet-clipboard-copy-content="DM.EXPIRE dmap key seconds"><pre><code>DM.EXPIRE dmap key seconds
</code></pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.EXPIRE dmap key 1
OK"><pre><code>127.0.0.1:3320&gt; DM.EXPIRE dmap key 1
OK
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> OK if DM.EXPIRE was executed correctly.</li>
<li><strong>KEYNOTFOUND:</strong> (error) when key does not exist.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmpexpire" aria-hidden="true" href="#dmpexpire"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.PEXPIRE</h4>
<p dir="auto">DM.PEXPIRE updates or sets the timeout for the given key. It returns <code>KEYNOTFOUND</code> if the key doesn&#39;t exist. After the timeout has expired,
the key will automatically be deleted.</p>
<p dir="auto">The timeout will only be cleared by commands that delete or overwrite the contents of the key, including DM.DEL, DM.PUT, DM.GETPUT.</p>
<div data-snippet-clipboard-copy-content="DM.PEXPIRE dmap key milliseconds"><pre><code>DM.PEXPIRE dmap key milliseconds
</code></pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.PEXPIRE dmap key 1000
OK"><pre><code>127.0.0.1:3320&gt; DM.PEXPIRE dmap key 1000
OK
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> OK if DM.EXPIRE was executed correctly.</li>
<li><strong>KEYNOTFOUND:</strong> (error) when key does not exist.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmdestroy" aria-hidden="true" href="#dmdestroy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.DESTROY</h4>
<p dir="auto">DM.DESTROY flushes the given DMap on the cluster. You should know that there is no global lock on DMaps. DM.PUT and DM.DESTROY commands
may run concurrently on the same DMap.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.DESTROY dmap
OK"><pre><code>127.0.0.1:3320&gt; DM.DESTROY dmap
OK
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> OK, if DM.DESTROY was executed correctly.</li>
</ul>
<h3 dir="auto"><a id="user-content-atomic-operations" aria-hidden="true" href="#atomic-operations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Atomic Operations</h3>
<p dir="auto">Operations on key/value pairs are performed by the partition owner. In addition, atomic operations are guarded by a lock implementation which can be found under <code>internal/locker</code>. It means that
Olric guaranties consistency of atomic operations, if there is no network partition. Basic flow for <code>DM.INCR</code>:</p>
<ul dir="auto">
<li>Acquire the lock for the given key,</li>
<li>Call <code>DM.GET</code> to retrieve the current value,</li>
<li>Calculate the new value,</li>
<li>Call <code>DM.PUT</code> to set the new value,</li>
<li>Release the lock.</li>
</ul>
<p dir="auto">It&#39;s important to know that if you call <code>DM.PUT</code> and <code>DM.GETPUT</code> concurrently on the same key, this will break the atomicity.</p>
<p dir="auto"><code>internal/locker</code> package is provided by <a href="https://github.com/moby/moby">Docker</a>.</p>
<p dir="auto"><strong>Important note about consistency:</strong></p>
<p dir="auto">You should know that Olric is a PA/EC (see <a href="#consistency-and-replication-model">Consistency and Replication Model</a>) product. So if your network is stable, all the operations on key/value
pairs are performed by a single cluster member. It means that you can be sure about the consistency when the cluster is stable. It&#39;s important to know that computer networks fail
occasionally, processes crash and random GC pauses may happen. Many factors can lead a network partitioning. If you cannot tolerate losing strong consistency under network partitioning,
you need to use a different tool for atomic operations.</p>
<p dir="auto">See <a href="https://dbmsmusings.blogspot.com/2017/10/hazelcast-and-mythical-paec-system.html" rel="nofollow">Hazelcast and the Mythical PA/EC System</a> and <a href="https://hazelcast.com/blog/jepsen-analysis-hazelcast-3-8-3/" rel="nofollow">Jepsen Analysis on Hazelcast 3.8.3</a> for more insight on this topic.</p>
<h4 dir="auto"><a id="user-content-dmincr" aria-hidden="true" href="#dmincr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.INCR</h4>
<p dir="auto">DM.INCR atomically increments the number stored at key by delta. The return value is the new value after being incremented or an error.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.INCR dmap key 10
(integer) 10"><pre><code>127.0.0.1:3320&gt; DM.INCR dmap key 10
(integer) 10
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Integer reply:</strong> the value of key after the increment.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmdecr" aria-hidden="true" href="#dmdecr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.DECR</h4>
<p dir="auto">DM.DECR atomically decrements the number stored at key by delta. The return value is the new value after being incremented or an error.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.DECR dmap key 10
(integer) 0"><pre><code>127.0.0.1:3320&gt; DM.DECR dmap key 10
(integer) 0
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Integer reply:</strong> the value of key after the increment.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmgetput" aria-hidden="true" href="#dmgetput"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.GETPUT</h4>
<p dir="auto">DM.GETPUT atomically sets key to value and returns the old value stored at the key.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.GETPUT dmap key value-1
(nil)
127.0.0.1:3320&gt; DM.GETPUT dmap key value-2
&#34;value-1&#34;"><pre><code>127.0.0.1:3320&gt; DM.GETPUT dmap key value-1
(nil)
127.0.0.1:3320&gt; DM.GETPUT dmap key value-2
&#34;value-1&#34;
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Bulk string reply</strong>: the old value stored at the key.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmincrbyfloat" aria-hidden="true" href="#dmincrbyfloat"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.INCRBYFLOAT</h4>
<p dir="auto">DM.INCRBYFLOAT atomically increments the number stored at key by delta. The return value is the new value after being incremented or an error.</p>
<div data-snippet-clipboard-copy-content="DM.INCRBYFLOAT dmap key delta"><pre><code>DM.INCRBYFLOAT dmap key delta
</code></pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.PUT dmap key 10.50
OK
127.0.0.1:3320&gt; DM.INCRBYFLOAT dmap key 0.1
&#34;10.6&#34;
127.0.0.1:3320&gt; DM.PUT dmap key 5.0e3
OK
127.0.0.1:3320&gt; DM.INCRBYFLOAT dmap key 2.0e2
&#34;5200&#34;"><pre><code>127.0.0.1:3320&gt; DM.PUT dmap key 10.50
OK
127.0.0.1:3320&gt; DM.INCRBYFLOAT dmap key 0.1
&#34;10.6&#34;
127.0.0.1:3320&gt; DM.PUT dmap key 5.0e3
OK
127.0.0.1:3320&gt; DM.INCRBYFLOAT dmap key 2.0e2
&#34;5200&#34;
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Bulk string reply</strong>: the value of key after the increment.</li>
</ul>
<h3 dir="auto"><a id="user-content-locking" aria-hidden="true" href="#locking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Locking</h3>
<p dir="auto"><strong>Important:</strong> The lock provided by DMap implementation is approximate and only to be used for non-critical purposes.</p>
<p dir="auto">The DMap implementation is already thread-safe to meet your thread safety requirements. When you want to have more control on the
concurrency, you can use <strong>DM.LOCK</strong> command. Olric borrows the locking algorithm from Redis. Redis authors propose
the following algorithm:</p>
<blockquote>
<p dir="auto">The command  is a simple way to implement a locking system with Redis.</p>
<p dir="auto">A client can acquire the lock if the above command returns OK (or retry after some time if the command returns Nil), and remove the lock just using DEL.</p>
<p dir="auto">The lock will be auto-released after the expire time is reached.</p>
<p dir="auto">It is possible to make this system more robust modifying the unlock schema as follows:</p>
<p dir="auto">Instead of setting a fixed string, set a non-guessable large random string, called token.
Instead of releasing the lock with DEL, send a script that only removes the key if the value matches.
This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</p>
</blockquote>
<p dir="auto">Equivalent of <code>SETNX</code> command in Olric is <code>DM.PUT dmap key value NX</code>. DM.LOCK command are properly implements
the algorithm which is proposed above.</p>
<p dir="auto">You should know that this implementation is subject to the clustering algorithm. So there is no guarantee about reliability in the case of network partitioning. I recommend the lock implementation to be used for
efficiency purposes in general, instead of correctness.</p>
<p dir="auto"><strong>Important note about consistency:</strong></p>
<p dir="auto">You should know that Olric is a PA/EC (see <a href="#consistency-and-replication-model">Consistency and Replication Model</a>) product. So if your network is stable, all the operations on key/value
pairs are performed by a single cluster member. It means that you can be sure about the consistency when the cluster is stable. It&#39;s important to know that computer networks fail
occasionally, processes crash and random GC pauses may happen. Many factors can lead a network partitioning. If you cannot tolerate losing strong consistency under network partitioning,
you need to use a different tool for locking.</p>
<p dir="auto">See <a href="https://dbmsmusings.blogspot.com/2017/10/hazelcast-and-mythical-paec-system.html" rel="nofollow">Hazelcast and the Mythical PA/EC System</a> and <a href="https://hazelcast.com/blog/jepsen-analysis-hazelcast-3-8-3/" rel="nofollow">Jepsen Analysis on Hazelcast 3.8.3</a> for more insight on this topic.</p>
<h4 dir="auto"><a id="user-content-dmlock" aria-hidden="true" href="#dmlock"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.LOCK</h4>
<p dir="auto">DM.LOCK sets a lock for the given key. The acquired lock is only valid for the key in this DMap.
It returns immediately if it acquires the lock for the given key. Otherwise, it waits until deadline.</p>
<p dir="auto">DM.LOCK returns a token. You must keep that token to unlock the key. Using prefixed keys is highly recommended.
If the key does already exist in the DMap, DM.LOCK will wait until the deadline is exceeded.</p>
<div data-snippet-clipboard-copy-content="DM.LOCK dmap key seconds [ EX seconds | PX milliseconds ]"><pre><code>DM.LOCK dmap key seconds [ EX seconds | PX milliseconds ]
</code></pre></div>
<p dir="auto"><strong>Options:</strong></p>
<ul dir="auto">
<li><strong>EX</strong> <em>seconds</em> -- Set the specified expire time, in seconds.</li>
<li><strong>PX</strong> <em>milliseconds</em> -- Set the specified expire time, in milliseconds.</li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.LOCK dmap lock.key 10
2363ec600be286cb10fbb35181efb029"><pre><code>127.0.0.1:3320&gt; DM.LOCK dmap lock.key 10
2363ec600be286cb10fbb35181efb029
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> a token to unlock or lease the lock.</li>
<li><strong>NOSUCHLOCK</strong>: (error) returned when the requested lock does not exist.</li>
<li><strong>LOCKNOTACQUIRED</strong>: (error) returned when the requested lock could not be acquired.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmunlock" aria-hidden="true" href="#dmunlock"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.UNLOCK</h4>
<p dir="auto">DM.UNLOCK releases an acquired lock for the given key. It returns <code>NOSUCHLOCK</code> if there is no lock for the given key.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.UNLOCK dmap key 2363ec600be286cb10fbb35181efb029
OK"><pre><code>127.0.0.1:3320&gt; DM.UNLOCK dmap key 2363ec600be286cb10fbb35181efb029
OK
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> OK if DM.UNLOCK was executed correctly.</li>
<li><strong>NOSUCHLOCK</strong>: (error) returned when the lock does not exist.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmlocklease" aria-hidden="true" href="#dmlocklease"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.LOCKLEASE</h4>
<p dir="auto">DM.LOCKLEASE sets or updates the timeout of the acquired lock for the given key. It returns <code>NOSUCHLOCK</code> if there is no lock for the given key.</p>
<p dir="auto">DM.LOCKLEASE accepts seconds as timeout.</p>
<div data-snippet-clipboard-copy-content="DM.LOCKLEASE dmap key token seconds"><pre><code>DM.LOCKLEASE dmap key token seconds
</code></pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.LOCKLEASE dmap key 2363ec600be286cb10fbb35181efb029 100
OK"><pre><code>127.0.0.1:3320&gt; DM.LOCKLEASE dmap key 2363ec600be286cb10fbb35181efb029 100
OK
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> OK if DM.UNLOCK was executed correctly.</li>
<li><strong>NOSUCHLOCK</strong>: (error) returned when the lock does not exist.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmplocklease" aria-hidden="true" href="#dmplocklease"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.PLOCKLEASE</h4>
<p dir="auto">DM.PLOCKLEASE sets or updates the timeout of the acquired lock for the given key. It returns <code>NOSUCHLOCK</code> if there is no lock for the given key.</p>
<p dir="auto">DM.PLOCKLEASE accepts milliseconds as timeout.</p>
<div data-snippet-clipboard-copy-content="DM.LOCKLEASE dmap key token milliseconds"><pre><code>DM.LOCKLEASE dmap key token milliseconds
</code></pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.PLOCKLEASE dmap key 2363ec600be286cb10fbb35181efb029 1000
OK"><pre><code>127.0.0.1:3320&gt; DM.PLOCKLEASE dmap key 2363ec600be286cb10fbb35181efb029 1000
OK
</code></pre></div>
<p dir="auto"><strong>Return:</strong></p>
<ul dir="auto">
<li><strong>Simple string reply:</strong> OK if DM.PLOCKLEASE was executed correctly.</li>
<li><strong>NOSUCHLOCK</strong>: (error) returned when the lock does not exist.</li>
</ul>
<h4 dir="auto"><a id="user-content-dmscan" aria-hidden="true" href="#dmscan"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DM.SCAN</h4>
<p dir="auto">DM.SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor
that the user needs to use as the cursor argument in the next call.</p>
<p dir="auto">An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0. The iterator runs
locally on every partition. So you need to know the partition count. If the returned cursor is 0 for a particular partition,
you have to start scanning the next partition.</p>
<div data-snippet-clipboard-copy-content="DM.SCAN partID dmap cursor [ MATCH pattern | COUNT count ]"><pre><code>DM.SCAN partID dmap cursor [ MATCH pattern | COUNT count ]
</code></pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; DM.SCAN 3 bench 0
1) &#34;96990&#34;
2)  1) &#34;memtier-2794837&#34;
    2) &#34;memtier-8630933&#34;
    3) &#34;memtier-6415429&#34;
    4) &#34;memtier-7808686&#34;
    5) &#34;memtier-3347072&#34;
    6) &#34;memtier-4247791&#34;
    7) &#34;memtier-3931982&#34;
    8) &#34;memtier-7164719&#34;
    9) &#34;memtier-4710441&#34;
   10) &#34;memtier-8892916&#34;
127.0.0.1:3320&gt; DM.SCAN 3 bench 96990
1) &#34;193499&#34;
2)  1) &#34;memtier-429905&#34;
    2) &#34;memtier-1271812&#34;
    3) &#34;memtier-7835776&#34;
    4) &#34;memtier-2717575&#34;
    5) &#34;memtier-95312&#34;
    6) &#34;memtier-2155214&#34;
    7) &#34;memtier-123931&#34;
    8) &#34;memtier-2902510&#34;
    9) &#34;memtier-2632291&#34;
   10) &#34;memtier-1938450&#34;"><pre><code>127.0.0.1:3320&gt; DM.SCAN 3 bench 0
1) &#34;96990&#34;
2)  1) &#34;memtier-2794837&#34;
    2) &#34;memtier-8630933&#34;
    3) &#34;memtier-6415429&#34;
    4) &#34;memtier-7808686&#34;
    5) &#34;memtier-3347072&#34;
    6) &#34;memtier-4247791&#34;
    7) &#34;memtier-3931982&#34;
    8) &#34;memtier-7164719&#34;
    9) &#34;memtier-4710441&#34;
   10) &#34;memtier-8892916&#34;
127.0.0.1:3320&gt; DM.SCAN 3 bench 96990
1) &#34;193499&#34;
2)  1) &#34;memtier-429905&#34;
    2) &#34;memtier-1271812&#34;
    3) &#34;memtier-7835776&#34;
    4) &#34;memtier-2717575&#34;
    5) &#34;memtier-95312&#34;
    6) &#34;memtier-2155214&#34;
    7) &#34;memtier-123931&#34;
    8) &#34;memtier-2902510&#34;
    9) &#34;memtier-2632291&#34;
   10) &#34;memtier-1938450&#34;
</code></pre></div>
<h3 dir="auto"><a id="user-content-publish-subscribe" aria-hidden="true" href="#publish-subscribe"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Publish-Subscribe</h3>
<p dir="auto"><strong>SUBSCRIBE</strong>, <strong>UNSUBSCRIBE</strong> and <strong>PUBLISH</strong> implement the Publish/Subscribe messaging paradigm where
senders are not programmed to send their messages to specific receivers. Rather, published messages are characterized
into channels, without knowledge of what (if any) subscribers there may be. Subscribers express interest in one or more
channels, and only receive messages that are of interest, without knowledge of what (if any) publishers there are.
This decoupling of publishers and subscribers can allow for greater scalability and a more dynamic network topology.</p>
<p dir="auto"><strong>Important note:</strong> In an Olric cluster, clients can subscribe to every node, and can also publish to every other node. The cluster
will make sure that published messages are forwarded as needed.</p>
<p dir="auto"><em>Source of this section: <a href="https://redis.io/commands/?group=pubsub" rel="nofollow">https://redis.io/commands/?group=pubsub</a></em></p>
<h4 dir="auto"><a id="user-content-subscribe" aria-hidden="true" href="#subscribe"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SUBSCRIBE</h4>
<p dir="auto">Subscribes the client to the specified channels.</p>
<div data-snippet-clipboard-copy-content="SUBSCRIBE channel [channel...]"><pre><code>SUBSCRIBE channel [channel...]
</code></pre></div>
<p dir="auto">Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional <strong>SUBSCRIBE</strong>,
<strong>PSUBSCRIBE</strong>, <strong>UNSUBSCRIBE</strong>, <strong>PUNSUBSCRIBE</strong>, <strong>PING</strong>, and <strong>QUIT</strong> commands.</p>
<h4 dir="auto"><a id="user-content-psubscribe" aria-hidden="true" href="#psubscribe"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PSUBSCRIBE</h4>
<p dir="auto">Subscribes the client to the given patterns.</p>
<div data-snippet-clipboard-copy-content="PSUBSCRIBE pattern [ pattern ...]"><pre><code>PSUBSCRIBE pattern [ pattern ...]
</code></pre></div>
<p dir="auto">Supported glob-style patterns:</p>
<ul dir="auto">
<li><code>h?llo</code> subscribes to hello, hallo and hxllo</li>
<li><code>h*llo</code> subscribes to hllo and heeeello</li>
<li><code>h[ae]llo</code> subscribes to hello and hallo, but not hillo</li>
<li>Use <strong>\</strong> to escape special characters if you want to match them verbatim.</li>
</ul>
<h4 dir="auto"><a id="user-content-unsubscribe" aria-hidden="true" href="#unsubscribe"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>UNSUBSCRIBE</h4>
<p dir="auto">Unsubscribes the client from the given channels, or from all of them if none is given.</p>
<div data-snippet-clipboard-copy-content="UNSUBSCRIBE [channel [channel ...]]"><pre><code>UNSUBSCRIBE [channel [channel ...]]
</code></pre></div>
<p dir="auto">When no channels are specified, the client is unsubscribed from all the previously subscribed channels. In this case,
a message for every unsubscribed channel will be sent to the client.</p>
<h4 dir="auto"><a id="user-content-punsubscribe" aria-hidden="true" href="#punsubscribe"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PUNSUBSCRIBE</h4>
<p dir="auto">Unsubscribes the client from the given patterns, or from all of them if none is given.</p>
<div data-snippet-clipboard-copy-content="PUNSUBSCRIBE [pattern [pattern ...]]"><pre><code>PUNSUBSCRIBE [pattern [pattern ...]]
</code></pre></div>
<p dir="auto">When no patterns are specified, the client is unsubscribed from all the previously subscribed patterns. In this case,
a message for every unsubscribed pattern will be sent to the client.</p>
<h4 dir="auto"><a id="user-content-pubsub-channels" aria-hidden="true" href="#pubsub-channels"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PUBSUB CHANNELS</h4>
<p dir="auto">Lists the currently active channels.</p>
<div data-snippet-clipboard-copy-content="PUBSUB CHANNELS [pattern]"><pre><code>PUBSUB CHANNELS [pattern]
</code></pre></div>
<p dir="auto">An active channel is a Pub/Sub channel with one or more subscribers (excluding clients subscribed to patterns).</p>
<p dir="auto">If no pattern is specified, all the channels are listed, otherwise if pattern is specified only channels matching the
specified glob-style pattern are listed.</p>
<h4 dir="auto"><a id="user-content-pubsub-numpat" aria-hidden="true" href="#pubsub-numpat"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PUBSUB NUMPAT</h4>
<p dir="auto">Returns the number of unique patterns that are subscribed to by clients (that are performed using the PSUBSCRIBE command).</p>

<p dir="auto">Note that this isn&#39;t the count of clients subscribed to patterns, but the total number of unique patterns all the clients are subscribed to.</p>
<p dir="auto"><strong>Important note</strong>: In an Olric cluster, clients can subscribe to every node, and can also publish to every other node. The cluster
will make sure that published messages are forwarded as needed. That said, PUBSUB&#39;s replies in a cluster only report information
from the node&#39;s Pub/Sub context, rather than the entire cluster.</p>
<h4 dir="auto"><a id="user-content-pubsub-numsub" aria-hidden="true" href="#pubsub-numsub"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PUBSUB NUMSUB</h4>
<p dir="auto">Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified channels.</p>
<div data-snippet-clipboard-copy-content="PUBSUB NUMSUB [channel [channel ...]]"><pre><code>PUBSUB NUMSUB [channel [channel ...]]
</code></pre></div>
<p dir="auto">Note that it is valid to call this command without channels. In this case it will just return an empty list.</p>
<p dir="auto"><strong>Important note</strong>: In an Olric cluster, clients can subscribe to every node, and can also publish to every other node. The cluster
will make sure that published messages are forwarded as needed. That said, PUBSUB&#39;s replies in a cluster only report information
from the node&#39;s Pub/Sub context, rather than the entire cluster.</p>
<h4 dir="auto"><a id="user-content-quit" aria-hidden="true" href="#quit"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QUIT</h4>
<p dir="auto">Ask the server to close the connection. The connection is closed as soon as all pending replies have been written to the client.</p>

<h3 dir="auto"><a id="user-content-cluster" aria-hidden="true" href="#cluster"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Cluster</h3>
<h4 dir="auto"><a id="user-content-clusterroutingtable" aria-hidden="true" href="#clusterroutingtable"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>CLUSTER.ROUTINGTABLE</h4>
<p dir="auto">CLUSTER.ROUTINGTABLE returns the latest view of the routing table. Simply, it&#39;s a data structure that maps
partitions to members.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; CLUSTER.ROUTINGTABLE
 1) 1) (integer) 0
     2) 1) &#34;127.0.0.1:3320&#34;
     3) (empty array)
  2) 1) (integer) 1
     2) 1) &#34;127.0.0.1:3320&#34;
     3) (empty array)
  3) 1) (integer) 2
     2) 1) &#34;127.0.0.1:3320&#34;
     3) (empty array)"><pre><code>127.0.0.1:3320&gt; CLUSTER.ROUTINGTABLE
 1) 1) (integer) 0
     2) 1) &#34;127.0.0.1:3320&#34;
     3) (empty array)
  2) 1) (integer) 1
     2) 1) &#34;127.0.0.1:3320&#34;
     3) (empty array)
  3) 1) (integer) 2
     2) 1) &#34;127.0.0.1:3320&#34;
     3) (empty array)
</code></pre></div>
<p dir="auto">It returns an array of arrays.</p>
<p dir="auto"><strong>Fields:</strong></p>
<div data-snippet-clipboard-copy-content="1) (integer) 0 &lt;- Partition ID
  2) 1) &#34;127.0.0.1:3320&#34; &lt;- Array of the current and previous primary owners
  3) (empty array) &lt;- Array of backup owners. "><pre><code>1) (integer) 0 &lt;- Partition ID
  2) 1) &#34;127.0.0.1:3320&#34; &lt;- Array of the current and previous primary owners
  3) (empty array) &lt;- Array of backup owners. 
</code></pre></div>
<h4 dir="auto"><a id="user-content-clustermembers" aria-hidden="true" href="#clustermembers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>CLUSTER.MEMBERS</h4>
<p dir="auto">CLUSTER.MEMBERS returns an array of known members by the server.</p>

<p dir="auto"><strong>Example:</strong></p>
<div data-snippet-clipboard-copy-content="127.0.0.1:3320&gt; CLUSTER.MEMBERS
1) 1) &#34;127.0.0.1:3320&#34;
   2) (integer) 1652619388427137000
   3) &#34;true&#34;"><pre><code>127.0.0.1:3320&gt; CLUSTER.MEMBERS
1) 1) &#34;127.0.0.1:3320&#34;
   2) (integer) 1652619388427137000
   3) &#34;true&#34;
</code></pre></div>
<p dir="auto"><strong>Fields:</strong></p>
<div data-snippet-clipboard-copy-content="1) 1) &#34;127.0.0.1:3320&#34; &lt;- Member&#39;s name in the cluster
   2) (integer) 1652619388427137000 &lt;-Member&#39;s birthedate
   3) &#34;true&#34; &lt;- Is cluster coordinator (the oldest node)"><pre><code>1) 1) &#34;127.0.0.1:3320&#34; &lt;- Member&#39;s name in the cluster
   2) (integer) 1652619388427137000 &lt;-Member&#39;s birthedate
   3) &#34;true&#34; &lt;- Is cluster coordinator (the oldest node)
</code></pre></div>
<h3 dir="auto"><a id="user-content-others" aria-hidden="true" href="#others"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Others</h3>
<h4 dir="auto"><a id="user-content-ping" aria-hidden="true" href="#ping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PING</h4>
<p dir="auto">Returns PONG if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to
test if a connection is still alive, or to measure latency.</p>

<h4 dir="auto"><a id="user-content-stats" aria-hidden="true" href="#stats"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>STATS</h4>
<p dir="auto">The STATS command returns information and statistics about the server in JSON format. See <code>stats/stats.go</code> file.</p>
<h2 dir="auto"><a id="user-content-configuration" aria-hidden="true" href="#configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Configuration</h2>
<p dir="auto">Olric supports both declarative and programmatic configurations. You can choose one of them depending on your needs.
You should feel free to ask any questions about configuration and integration. Please see <a href="#support">Support</a> section.</p>
<h3 dir="auto"><a id="user-content-embedded-member-mode" aria-hidden="true" href="#embedded-member-mode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Embedded-Member Mode</h3>
<h4 dir="auto"><a id="user-content-programmatic-configuration" aria-hidden="true" href="#programmatic-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Programmatic Configuration</h4>
<p dir="auto">Olric provides a function to generate default configuration to use in embedded-member mode:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import &#34;github.com/buraksezer/olric/config&#34;
...
c := config.New(&#34;local&#34;)"><pre><span>import</span> <span>&#34;github.com/buraksezer/olric/config&#34;</span>
<span>...</span>
<span>c</span> <span>:=</span> <span>config</span>.<span>New</span>(<span>&#34;local&#34;</span>)</pre></div>
<p dir="auto">The <code>New</code> function takes a parameter called <code>env</code>. It denotes the network environment and consumed by <a href="https://github.com/hashicorp/memberlist">hashicorp/memberlist</a>.
Default configuration is good enough for distributed caching scenario. In order to see all configuration parameters, please take a look at <a href="https://godoc.org/github.com/buraksezer/olric/config" rel="nofollow">this</a>.</p>
<p dir="auto">See <a href="#sample-code">Sample Code</a> section for an introduction.</p>
<h4 dir="auto"><a id="user-content-declarative-configuration-with-yaml-format" aria-hidden="true" href="#declarative-configuration-with-yaml-format"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Declarative configuration with YAML format</h4>
<p dir="auto">You can also import configuration from a YAML file by using the <code>Load</code> function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="c, err := config.Load(path/to/olric.yaml)"><pre><span>c</span>, <span>err</span> <span>:=</span> <span>config</span>.<span>Load</span>(<span>path</span><span>/</span><span>to</span><span>/</span><span>olric</span>.<span>yaml</span>)</pre></div>
<p dir="auto">A sample configuration file in YAML format can be found <a href="https://github.com/buraksezer/olric/blob/master/cmd/olricd/olricd.yaml">here</a>. This may be the most appropriate way to manage the Olric configuration.</p>
<h3 dir="auto"><a id="user-content-client-server-mode" aria-hidden="true" href="#client-server-mode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Client-Server Mode</h3>
<p dir="auto">Olric provides <strong>olricd</strong> to implement client-server mode. olricd gets a YAML file for the configuration. The most basic  functionality of olricd is that
translating YAML configuration into Olric&#39;s configuration struct. A sample <code>olricd.yaml</code> file  is being provided <a href="https://github.com/buraksezer/olric/blob/master/cmd/olricd/olricd.yaml">here</a>.</p>
<h3 dir="auto"><a id="user-content-network-configuration" aria-hidden="true" href="#network-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Network Configuration</h3>
<p dir="auto">In an Olric instance, there are two different TCP servers. One for Olric, and the other one is for memberlist. <code>BindAddr</code> is very
critical to deploy a healthy Olric node. There are different scenarios:</p>
<ul dir="auto">
<li>You can freely set a domain name or IP address as <code>BindAddr</code> for both Olric and memberlist. Olric will resolve and use it to bind.</li>
<li>You can freely set <code>localhost</code>, <code>127.0.0.1</code> or <code>::1</code> as <code>BindAddr</code> in development environment for both Olric and memberlist.</li>
<li>You can freely set <code>0.0.0.0</code> as <code>BindAddr</code> for both Olric and memberlist. Olric will pick an IP address, if there is any.</li>
<li>If you don&#39;t set <code>BindAddr</code>, hostname will be used, and it will be resolved to get a valid IP address.</li>
<li>You can set a network interface by using <code>Config.Interface</code> and <code>Config.MemberlistInterface</code> fields. Olric will find an appropriate IP address for the given interfaces, if there is any.</li>
<li>You can set both <code>BindAddr</code> and interface parameters. In this case Olric will ensure that <code>BindAddr</code> is available on the given interface.</li>
</ul>
<p dir="auto">You should know that Olric needs a single and stable IP address to function properly. If you don&#39;t know the IP address of the host at the deployment time,
you can set <code>BindAddr</code> as <code>0.0.0.0</code>. Olric will very likely to find an IP address for you.</p>
<h3 dir="auto"><a id="user-content-service-discovery" aria-hidden="true" href="#service-discovery"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Service Discovery</h3>
<p dir="auto">Olric provides a service discovery interface which can be used to implement plugins.</p>
<p dir="auto">We currently have a bunch of service discovery plugins for automatic peer discovery on cloud environments:</p>
<ul dir="auto">
<li><a href="https://github.com/buraksezer/olric-consul-plugin">buraksezer/olric-consul-plugin</a> provides a plugin using Consul.</li>
<li><a href="https://github.com/buraksezer/olric-cloud-plugin">buraksezer/olric-cloud-plugin</a> provides a plugin for well-known cloud providers. Including Kubernetes.</li>
<li><a href="https://github.com/justinfx/olric-nats-plugin">justinfx/olric-nats-plugin</a> provides a plugin using nats.io</li>
</ul>
<p dir="auto">In order to get more info about installation and configuration of the plugins, see their GitHub page.</p>
<h3 dir="auto"><a id="user-content-timeouts" aria-hidden="true" href="#timeouts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Timeouts</h3>
<p dir="auto">Olric nodes supports setting <code>KeepAlivePeriod</code> on TCP sockets.</p>
<p dir="auto"><strong>Server-side:</strong></p>
<h5 dir="auto"><a id="user-content-configkeepaliveperiod" aria-hidden="true" href="#configkeepaliveperiod"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>config.KeepAlivePeriod</h5>
<p dir="auto">KeepAlivePeriod denotes whether the operating system should send keep-alive messages on the connection.</p>
<p dir="auto"><strong>Client-side:</strong></p>
<h5 dir="auto"><a id="user-content-configdialtimeout" aria-hidden="true" href="#configdialtimeout"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>config.DialTimeout</h5>
<p dir="auto">Timeout for TCP dial. The timeout includes name resolution, if required. When using TCP, and the host in the address
parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is
given an appropriate fraction of the time to connect.</p>
<h5 dir="auto"><a id="user-content-configreadtimeout" aria-hidden="true" href="#configreadtimeout"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>config.ReadTimeout</h5>
<p dir="auto">Timeout for socket reads. If reached, commands will fail with a timeout instead of blocking. Use value -1 for no
timeout and 0 for default. The default is config.DefaultReadTimeout</p>
<h5 dir="auto"><a id="user-content-configwritetimeout" aria-hidden="true" href="#configwritetimeout"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>config.WriteTimeout</h5>
<p dir="auto">Timeout for socket writes. If reached, commands will fail with a timeout instead of blocking. The default is config.DefaultWriteTimeout</p>
<h5 dir="auto"><a id="user-content-configkeepalive" aria-hidden="true" href="#configkeepalive"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>config.KeepAlive</h5>
<p dir="auto">KeepAlive specifies the interval between keep-alive probes for an active network connection. If zero, keep-alive probes
are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols
or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.</p>
<h2 dir="auto"><a id="user-content-architecture" aria-hidden="true" href="#architecture"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Architecture</h2>
<h3 dir="auto"><a id="user-content-overview" aria-hidden="true" href="#overview"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Overview</h3>
<p dir="auto">Olric uses:</p>
<ul dir="auto">
<li><a href="https://github.com/hashicorp/memberlist">hashicorp/memberlist</a> for cluster membership and failure detection,</li>
<li><a href="https://github.com/buraksezer/consistent">buraksezer/consistent</a> for consistent hashing and load balancing,</li>
<li><a href="https://github.com/tidwall/redcon">Redis Serialization Protocol</a> for communication.</li>
</ul>
<p dir="auto">Olric distributes data among partitions. Every partition is being owned by a cluster member and may have one or more backups for redundancy.
When you read or write a DMap entry, you transparently talk to the partition owner. Each request hits the most up-to-date version of a
particular data entry in a stable cluster.</p>
<p dir="auto">In order to find the partition which the key belongs to, Olric hashes the key and mod it with the number of partitions:</p>
<div data-snippet-clipboard-copy-content="partID = MOD(hash result, partition count)"><pre><code>partID = MOD(hash result, partition count)
</code></pre></div>
<p dir="auto">The partitions are being distributed among cluster members by using a consistent hashing algorithm. In order to get details, please see <a href="https://github.com/buraksezer/consistent">buraksezer/consistent</a>.</p>
<p dir="auto">When a new cluster is created, one of the instances is elected as the <strong>cluster coordinator</strong>. It manages the partition table:</p>
<ul dir="auto">
<li>When a node joins or leaves, it distributes the partitions and their backups among the members again,</li>
<li>Removes empty previous owners from the partition owners list,</li>
<li>Pushes the new partition table to all the members,</li>
<li>Pushes the partition table to the cluster periodically.</li>
</ul>
<p dir="auto">Members propagate their birthdate(POSIX time in nanoseconds) to the cluster. The coordinator is the oldest member in the cluster.
If the coordinator leaves the cluster, the second oldest member gets elected as the coordinator.</p>
<p dir="auto">Olric has a component called <strong>rebalancer</strong> which is responsible for keeping underlying data structures consistent:</p>
<ul dir="auto">
<li>Works on every node,</li>
<li>When a node joins or leaves, the cluster coordinator pushes the new partition table. Then, the <strong>rebalancer</strong> runs immediately and moves the partitions and backups to their new hosts,</li>
<li>Merges fragmented partitions.</li>
</ul>
<p dir="auto">Partitions have a concept called <strong>owners list</strong>. When a node joins or leaves the cluster, a new primary owner may be assigned by the
coordinator. At any time, a partition may have one or more partition owners. If a partition has two or more owners, this is called <strong>fragmented partition</strong>.
The last added owner is called <strong>primary owner</strong>. Write operation is only done by the primary owner. The previous owners are only used for read and delete.</p>
<p dir="auto">When you read a key, the primary owner tries to find the key on itself, first. Then, queries the previous owners and backups, respectively.
The delete operation works the same way.</p>
<p dir="auto">The data(distributed map objects) in the fragmented partition is moved slowly to the primary owner by the <strong>rebalancer</strong>. Until the move is done,
the data remains available on the previous owners. The DMap methods use this list to query data on the cluster.</p>
<p dir="auto"><em>Please note that, &#39;multiple partition owners&#39; is an undesirable situation and the <strong>rebalancer</strong> component is designed to fix that in a short time.</em></p>
<h3 dir="auto"><a id="user-content-consistency-and-replication-model" aria-hidden="true" href="#consistency-and-replication-model"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Consistency and Replication Model</h3>
<p dir="auto"><strong>Olric is an AP product</strong> in the context of <a href="https://en.wikipedia.org/wiki/CAP_theorem" rel="nofollow">CAP theorem</a>, which employs the combination of primary-copy
and <a href="https://en.wikipedia.org/wiki/Optimistic_replication" rel="nofollow">optimistic replication</a> techniques. With optimistic replication, when the partition owner
receives a write or delete operation for a key, applies it locally, and propagates it to the backup owners.</p>
<p dir="auto">This technique enables Olric clusters to offer high throughput. However, due to temporary situations in the system, such as network
failure, backup owners can miss some updates and diverge from the primary owner. If a partition owner crashes while there is an
inconsistency between itself and the backups, strong consistency of the data can be lost.</p>
<p dir="auto">Two types of backup replication are available: <strong>sync</strong> and <strong>async</strong>. Both types are still implementations of the optimistic replication
model.</p>
<ul dir="auto">
<li><strong>sync</strong>: Blocks until write/delete operation is applied by backup owners.</li>
<li><strong>async</strong>: Just fire &amp; forget.</li>
</ul>
<h4 dir="auto"><a id="user-content-last-write-wins-conflict-resolution" aria-hidden="true" href="#last-write-wins-conflict-resolution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Last-write-wins conflict resolution</h4>
<p dir="auto">Every time a piece of data is written to Olric, a timestamp is attached by the client. Then, when Olric has to deal with conflict data in the case
of network partitioning, it simply chooses the data with the most recent timestamp. This called LWW conflict resolution policy.</p>
<h4 dir="auto"><a id="user-content-pacelc-theorem" aria-hidden="true" href="#pacelc-theorem"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PACELC Theorem</h4>
<p dir="auto">From Wikipedia:</p>
<blockquote>
<p dir="auto">In theoretical computer science, the <a href="https://en.wikipedia.org/wiki/PACELC_theorem" rel="nofollow">PACELC theorem</a> is an extension to the <a href="https://en.wikipedia.org/wiki/CAP_theorem" rel="nofollow">CAP theorem</a>. It states that in case of network partitioning (P) in a
distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is
running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).</p>
</blockquote>
<p dir="auto">In the context of PACELC theorem, Olric is a <strong>PA/EC</strong> product. It means that Olric is considered to be <strong>consistent</strong> data store if the network is stable.
Because the key space is divided between partitions and every partition is controlled by its primary owner. All operations on DMaps are redirected to the
partition owner.</p>
<p dir="auto">In the case of network partitioning, Olric chooses <strong>availability</strong> over consistency. So that you can still access some parts of the cluster when the network is unreliable,
but the cluster may return inconsistent results.</p>
<p dir="auto">Olric implements read-repair and quorum based voting system to deal with inconsistencies in the DMaps.</p>
<p dir="auto">Readings on PACELC theorem:</p>
<ul dir="auto">
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html" rel="nofollow">Please stop calling databases CP or AP</a></li>
<li><a href="https://dbmsmusings.blogspot.com/2010/04/problems-with-cap-and-yahoos-little.html" rel="nofollow">Problems with CAP, and Yahoos little known NoSQL system</a></li>
<li><a href="https://arxiv.org/abs/1509.05393" rel="nofollow">A Critique of the CAP Theorem</a></li>
<li><a href="https://dbmsmusings.blogspot.com/2017/10/hazelcast-and-mythical-paec-system.html" rel="nofollow">Hazelcast and the Mythical PA/EC System</a></li>
</ul>
<h4 dir="auto"><a id="user-content-read-repair-on-dmaps" aria-hidden="true" href="#read-repair-on-dmaps"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Read-Repair on DMaps</h4>
<p dir="auto">Read repair is a feature that allows for inconsistent data to be fixed at query time. Olric tracks every write operation with a timestamp value and assumes
that the latest write operation is the valid one. When you want to access a key/value pair, the partition owner retrieves all available copies for that pair
and compares the timestamp values. The latest one is the winner. If there is some outdated version of the requested pair, the primary owner propagates the latest
version of the pair.</p>
<p dir="auto">Read-repair is disabled by default for the sake of performance. If you have a use case that requires a more strict consistency control than a distributed caching
scenario, you can enable read-repair via the configuration.</p>
<h4 dir="auto"><a id="user-content-quorum-based-replica-control" aria-hidden="true" href="#quorum-based-replica-control"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Quorum-based replica control</h4>
<p dir="auto">Olric implements Read/Write quorum to keep the data in a consistent state. When you start a write operation on the cluster and write quorum (W) is 2,
the partition owner tries to write the given key/value pair on its own data storage and on the replica nodes. If the number of successful write operations
is below W, the primary owner returns <code>ErrWriteQuorum</code>. The read flow is the same: if you have R=2 and the owner only access one of the replicas,
it returns <code>ErrReadQuorum</code>.</p>
<h4 dir="auto"><a id="user-content-simple-split-brain-protection" aria-hidden="true" href="#simple-split-brain-protection"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Simple Split-Brain Protection</h4>
<p dir="auto">Olric implements a technique called <em>majority quorum</em> to manage split-brain conditions. If a network partitioning occurs, and some members
lost the connection to rest of the cluster, they immediately stops functioning and return an error to incoming requests. This behaviour is controlled by
<code>MemberCountQuorum</code> parameter. It&#39;s default <code>1</code>.</p>
<p dir="auto">When the network healed, the stopped nodes joins again the cluster and fragmented partitions is merged by their primary owners in accordance with
<em>LWW policy</em>. Olric also implements an <em>ownership report</em> mechanism to fix inconsistencies in partition distribution after a partitioning event.</p>
<h3 dir="auto"><a id="user-content-eviction" aria-hidden="true" href="#eviction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Eviction</h3>
<p dir="auto">Olric supports different policies to evict keys from distributed maps.</p>
<h4 dir="auto"><a id="user-content-expire-with-ttl" aria-hidden="true" href="#expire-with-ttl"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Expire with TTL</h4>
<p dir="auto">Olric implements TTL eviction policy. It shares the same algorithm with <a href="https://redis.io/commands/expire#appendix-redis-expires" rel="nofollow">Redis</a>:</p>
<blockquote>
<p dir="auto">Periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</p>
<p dir="auto">Specifically this is what Redis does 10 times per second:</p>
<ul dir="auto">
<li>Test 20 random keys from the set of keys with an associated expire.</li>
<li>Delete all the keys found expired.</li>
<li>If more than 25% of keys were expired, start again from step 1.</li>
</ul>
<p dir="auto">This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</p>
</blockquote>
<p dir="auto">When a client tries to access a key, Olric returns <code>ErrKeyNotFound</code> if the key is found to be timed out. A background task evicts keys with the algorithm described above.</p>
<h4 dir="auto"><a id="user-content-expire-with-maxidleduration" aria-hidden="true" href="#expire-with-maxidleduration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Expire with MaxIdleDuration</h4>
<p dir="auto">Maximum time for each entry to stay idle in the DMap. It limits the lifetime of the entries relative to the time of the last read
or write access performed on them. The entries whose idle period exceeds this limit are expired and evicted automatically.
An entry is idle if no Get, Put, PutEx, Expire, PutIf, PutIfEx on it. Configuration of MaxIdleDuration feature varies by
preferred deployment method.</p>
<h4 dir="auto"><a id="user-content-expire-with-lru" aria-hidden="true" href="#expire-with-lru"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Expire with LRU</h4>
<p dir="auto">Olric implements LRU eviction method on DMaps. Approximated LRU algorithm is borrowed from Redis. The Redis authors proposes the following algorithm:</p>
<blockquote>
<p dir="auto">It is important to understand that the eviction process works like this:</p>
<ul dir="auto">
<li>A client runs a new command, resulting in more data added.</li>
<li>Redis checks the memory usage, and if it is greater than the maxmemory limit , it evicts keys according to the policy.</li>
<li>A new command is executed, and so forth.</li>
</ul>
<p dir="auto">So we continuously cross the boundaries of the memory limit, by going over it, and then by evicting keys to return back under the limits.</p>
<p dir="auto">If a command results in a lot of memory being used (like a big set intersection stored into a new key) for some time the memory
limit can be surpassed by a noticeable amount.</p>
<p dir="auto"><strong>Approximated LRU algorithm</strong></p>
<p dir="auto">Redis LRU algorithm is not an exact implementation. This means that Redis is not able to pick the best candidate for eviction,
that is, the access that was accessed the most in the past. Instead it will try to run an approximation of the LRU algorithm,
by sampling a small number of keys, and evicting the one that is the best (with the oldest access time) among the sampled keys.</p>
</blockquote>
<p dir="auto">Olric tracks access time for every DMap instance. Then it picks and sorts some configurable amount of keys to select keys for eviction.
Every node runs this algorithm independently. The access log is moved along with the partition when a network partition is occured.</p>
<h4 dir="auto"><a id="user-content-configuration-of-eviction-mechanisms" aria-hidden="true" href="#configuration-of-eviction-mechanisms"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Configuration of eviction mechanisms</h4>
<p dir="auto">Here is a simple configuration block for <code>olricd.yaml</code>:</p>
<div data-snippet-clipboard-copy-content="cache:
  numEvictionWorkers: 1
  maxIdleDuration: &#34;&#34;
  ttlDuration: &#34;100s&#34;
  maxKeys: 100000
  maxInuse: 1000000 # in bytes
  lRUSamples: 10
  evictionPolicy: &#34;LRU&#34; # NONE/LRU"><pre><code>cache:
  numEvictionWorkers: 1
  maxIdleDuration: &#34;&#34;
  ttlDuration: &#34;100s&#34;
  maxKeys: 100000
  maxInuse: 1000000 # in bytes
  lRUSamples: 10
  evictionPolicy: &#34;LRU&#34; # NONE/LRU
</code></pre></div>
<p dir="auto">You can also set cache configuration per DMap. Here is a simple configuration for a DMap named <code>foobar</code>:</p>
<div data-snippet-clipboard-copy-content="dmaps:
  foobar:
    maxIdleDuration: &#34;60s&#34;
    ttlDuration: &#34;300s&#34;
    maxKeys: 500000 # in-bytes
    lRUSamples: 20
    evictionPolicy: &#34;NONE&#34; # NONE/LRU"><pre><code>dmaps:
  foobar:
    maxIdleDuration: &#34;60s&#34;
    ttlDuration: &#34;300s&#34;
    maxKeys: 500000 # in-bytes
    lRUSamples: 20
    evictionPolicy: &#34;NONE&#34; # NONE/LRU
</code></pre></div>
<p dir="auto">If you prefer embedded-member deployment scenario, please take a look at <a href="https://godoc.org/github.com/buraksezer/olric/config#CacheConfig" rel="nofollow">config#CacheConfig</a> and <a href="https://godoc.org/github.com/buraksezer/olric/config#DMapCacheConfig" rel="nofollow">config#DMapCacheConfig</a> for the configuration.</p>
<h3 dir="auto"><a id="user-content-lock-implementation" aria-hidden="true" href="#lock-implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lock Implementation</h3>
<p dir="auto">The DMap implementation is already thread-safe to meet your thread safety requirements. When you want to have more control on the
concurrency, you can use <strong>LockWithTimeout</strong> and <strong>Lock</strong> methods. Olric borrows the locking algorithm from Redis. Redis authors propose
the following algorithm:</p>
<blockquote>
<p dir="auto">The command  is a simple way to implement a locking system with Redis.</p>
<p dir="auto">A client can acquire the lock if the above command returns OK (or retry after some time if the command returns Nil), and remove the lock just using DEL.</p>
<p dir="auto">The lock will be auto-released after the expire time is reached.</p>
<p dir="auto">It is possible to make this system more robust modifying the unlock schema as follows:</p>
<p dir="auto">Instead of setting a fixed string, set a non-guessable large random string, called token.
Instead of releasing the lock with DEL, send a script that only removes the key if the value matches.
This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</p>
</blockquote>
<p dir="auto">Equivalent of<code>SETNX</code> command in Olric is <code>PutIf(key, value, IfNotFound)</code>. Lock and LockWithTimeout commands are properly implements
the algorithm which is proposed above.</p>
<p dir="auto">You should know that this implementation is subject to the clustering algorithm. So there is no guarantee about reliability in the case of network partitioning. I recommend the lock implementation to be used for
efficiency purposes in general, instead of correctness.</p>
<p dir="auto"><strong>Important note about consistency:</strong></p>
<p dir="auto">You should know that Olric is a PA/EC (see <a href="#consistency-and-replication-model">Consistency and Replication Model</a>) product. So if your network is stable, all the operations on key/value
pairs are performed by a single cluster member. It means that you can be sure about the consistency when the cluster is stable. It&#39;s important to know that computer networks fail
occasionally, processes crash and random GC pauses may happen. Many factors can lead a network partitioning. If you cannot tolerate losing strong consistency under network partitioning,
you need to use a different tool for locking.</p>
<p dir="auto">See <a href="https://dbmsmusings.blogspot.com/2017/10/hazelcast-and-mythical-paec-system.html" rel="nofollow">Hazelcast and the Mythical PA/EC System</a> and <a href="https://hazelcast.com/blog/jepsen-analysis-hazelcast-3-8-3/" rel="nofollow">Jepsen Analysis on Hazelcast 3.8.3</a> for more insight on this topic.</p>
<h3 dir="auto"><a id="user-content-storage-engine" aria-hidden="true" href="#storage-engine"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Storage Engine</h3>
<p dir="auto">Olric implements a GC-friendly storage engine to store large amounts of data on RAM. Basically, it applies an append-only log file approach with indexes.
Olric inserts key/value pairs into pre-allocated byte slices (table in Olric terminology) and indexes that memory region by using Golang&#39;s built-in map.
The data type of this map is <code>map[uint64]uint64</code>. When a pre-allocated byte slice is full Olric allocates a new one and continues inserting the new data into it.
This design greatly reduces the write latency.</p>
<p dir="auto">When you want to read a key/value pair from the Olric cluster, it scans the related DMap fragment by iterating over the indexes(implemented by the built-in map).
The number of allocated byte slices should be small. So Olric would find the key immediately but technically, the read performance depends on the number of keys in the fragment.
The effect of this design on the read performance is negligible.</p>
<p dir="auto">The size of the pre-allocated byte slices is configurable.</p>
<h2 dir="auto"><a id="user-content-samples" aria-hidden="true" href="#samples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Samples</h2>
<p dir="auto">In this section, you can find code snippets for various scenarios.</p>
<h3 dir="auto"><a id="user-content-embedded-member-scenario" aria-hidden="true" href="#embedded-member-scenario"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Embedded-member scenario</h3>
<h4 dir="auto"><a id="user-content-distributed-map-1" aria-hidden="true" href="#distributed-map-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Distributed map</h4>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
  &#34;context&#34;
  &#34;fmt&#34;
  &#34;log&#34;
  &#34;time&#34;

  &#34;github.com/buraksezer/olric&#34;
  &#34;github.com/buraksezer/olric/config&#34;
)

func main() {
  // Sample for Olric v0.5.x

  // Deployment scenario: embedded-member
  // This creates a single-node Olric cluster. It&#39;s good enough for experimenting.

  // config.New returns a new config.Config with sane defaults. Available values for env:
  // local, lan, wan
  c := config.New(&#34;local&#34;)

  // Callback function. It&#39;s called when this node is ready to accept connections.
  ctx, cancel := context.WithCancel(context.Background())
  c.Started = func() {
    defer cancel()
    log.Println(&#34;[INFO] Olric is ready to accept connections&#34;)
  }

  // Create a new Olric instance.
  db, err := olric.New(c)
  if err != nil {
    log.Fatalf(&#34;Failed to create Olric instance: %v&#34;, err)
  }

  // Start the instance. It will form a single-node cluster.
  go func() {
    // Call Start at background. It&#39;s a blocker call.
    err = db.Start()
    if err != nil {
      log.Fatalf(&#34;olric.Start returned an error: %v&#34;, err)
    }
  }()

  &lt;-ctx.Done()

  // In embedded-member scenario, you can use the EmbeddedClient. It implements
  // the Client interface.
  e := db.NewEmbeddedClient()

  dm, err := e.NewDMap(&#34;bucket-of-arbitrary-items&#34;)
  if err != nil {
    log.Fatalf(&#34;olric.NewDMap returned an error: %v&#34;, err)
  }

  ctx, cancel = context.WithCancel(context.Background())

  // Magic starts here!
  fmt.Println(&#34;##&#34;)
  fmt.Println(&#34;Simple Put/Get on a DMap instance:&#34;)
  err = dm.Put(ctx, &#34;my-key&#34;, &#34;Olric Rocks!&#34;)
  if err != nil {
    log.Fatalf(&#34;Failed to call Put: %v&#34;, err)
  }

  gr, err := dm.Get(ctx, &#34;my-key&#34;)
  if err != nil {
    log.Fatalf(&#34;Failed to call Get: %v&#34;, err)
  }

  // Olric uses the Redis serialization format.
  value, err := gr.String()
  if err != nil {
    log.Fatalf(&#34;Failed to read Get response: %v&#34;, err)
  }

  fmt.Println(&#34;Response for my-key:&#34;, value)
  fmt.Println(&#34;##&#34;)

  // Don&#39;t forget the call Shutdown when you want to leave the cluster.
  ctx, cancel = context.WithTimeout(context.Background(), 10*time.Second)
  defer cancel()

  err = db.Shutdown(ctx)
  if err != nil {
    log.Printf(&#34;Failed to shutdown Olric: %v&#34;, err)
  }
}"><pre><span>package</span> main

<span>import</span> (
  <span>&#34;context&#34;</span>
  <span>&#34;fmt&#34;</span>
  <span>&#34;log&#34;</span>
  <span>&#34;time&#34;</span>

  <span>&#34;github.com/buraksezer/olric&#34;</span>
  <span>&#34;github.com/buraksezer/olric/config&#34;</span>
)

<span>func</span> <span>main</span>() {
  <span>// Sample for Olric v0.5.x</span>

  <span>// Deployment scenario: embedded-member</span>
  <span>// This creates a single-node Olric cluster. It&#39;s good enough for experimenting.</span>

  <span>// config.New returns a new config.Config with sane defaults. Available values for env:</span>
  <span>// local, lan, wan</span>
  <span>c</span> <span>:=</span> <span>config</span>.<span>New</span>(<span>&#34;local&#34;</span>)

  <span>// Callback function. It&#39;s called when this node is ready to accept connections.</span>
  <span>ctx</span>, <span>cancel</span> <span>:=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())
  <span>c</span>.<span>Started</span> <span>=</span> <span>func</span>() {
    <span>defer</span> <span>cancel</span>()
    <span>log</span>.<span>Println</span>(<span>&#34;[INFO] Olric is ready to accept connections&#34;</span>)
  }

  <span>// Create a new Olric instance.</span>
  <span>db</span>, <span>err</span> <span>:=</span> <span>olric</span>.<span>New</span>(<span>c</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to create Olric instance: %v&#34;</span>, <span>err</span>)
  }

  <span>// Start the instance. It will form a single-node cluster.</span>
  <span>go</span> <span>func</span>() {
    <span>// Call Start at background. It&#39;s a blocker call.</span>
    <span>err</span> <span>=</span> <span>db</span>.<span>Start</span>()
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
      <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.Start returned an error: %v&#34;</span>, <span>err</span>)
    }
  }()

  <span>&lt;-</span><span>ctx</span>.<span>Done</span>()

  <span>// In embedded-member scenario, you can use the EmbeddedClient. It implements</span>
  <span>// the Client interface.</span>
  <span>e</span> <span>:=</span> <span>db</span>.<span>NewEmbeddedClient</span>()

  <span>dm</span>, <span>err</span> <span>:=</span> <span>e</span>.<span>NewDMap</span>(<span>&#34;bucket-of-arbitrary-items&#34;</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.NewDMap returned an error: %v&#34;</span>, <span>err</span>)
  }

  <span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())

  <span>// Magic starts here!</span>
  <span>fmt</span>.<span>Println</span>(<span>&#34;##&#34;</span>)
  <span>fmt</span>.<span>Println</span>(<span>&#34;Simple Put/Get on a DMap instance:&#34;</span>)
  <span>err</span> <span>=</span> <span>dm</span>.<span>Put</span>(<span>ctx</span>, <span>&#34;my-key&#34;</span>, <span>&#34;Olric Rocks!&#34;</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to call Put: %v&#34;</span>, <span>err</span>)
  }

  <span>gr</span>, <span>err</span> <span>:=</span> <span>dm</span>.<span>Get</span>(<span>ctx</span>, <span>&#34;my-key&#34;</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to call Get: %v&#34;</span>, <span>err</span>)
  }

  <span>// Olric uses the Redis serialization format.</span>
  <span>value</span>, <span>err</span> <span>:=</span> <span>gr</span>.<span>String</span>()
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to read Get response: %v&#34;</span>, <span>err</span>)
  }

  <span>fmt</span>.<span>Println</span>(<span>&#34;Response for my-key:&#34;</span>, <span>value</span>)
  <span>fmt</span>.<span>Println</span>(<span>&#34;##&#34;</span>)

  <span>// Don&#39;t forget the call Shutdown when you want to leave the cluster.</span>
  <span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithTimeout</span>(<span>context</span>.<span>Background</span>(), <span>10</span><span>*</span><span>time</span>.<span>Second</span>)
  <span>defer</span> <span>cancel</span>()

  <span>err</span> <span>=</span> <span>db</span>.<span>Shutdown</span>(<span>ctx</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Printf</span>(<span>&#34;Failed to shutdown Olric: %v&#34;</span>, <span>err</span>)
  }
}</pre></div>
<h4 dir="auto"><a id="user-content-publish-subscribe-1" aria-hidden="true" href="#publish-subscribe-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Publish-Subscribe</h4>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
  &#34;context&#34;
  &#34;fmt&#34;
  &#34;log&#34;
  &#34;time&#34;

  &#34;github.com/buraksezer/olric&#34;
  &#34;github.com/buraksezer/olric/config&#34;
)

func main() {
  // Sample for Olric v0.5.x

  // Deployment scenario: embedded-member
  // This creates a single-node Olric cluster. It&#39;s good enough for experimenting.

  // config.New returns a new config.Config with sane defaults. Available values for env:
  // local, lan, wan
  c := config.New(&#34;local&#34;)

  // Callback function. It&#39;s called when this node is ready to accept connections.
  ctx, cancel := context.WithCancel(context.Background())
  c.Started = func() {
    defer cancel()
    log.Println(&#34;[INFO] Olric is ready to accept connections&#34;)
  }

  // Create a new Olric instance.
  db, err := olric.New(c)
  if err != nil {
    log.Fatalf(&#34;Failed to create Olric instance: %v&#34;, err)
  }

  // Start the instance. It will form a single-node cluster.
  go func() {
    // Call Start at background. It&#39;s a blocker call.
    err = db.Start()
    if err != nil {
      log.Fatalf(&#34;olric.Start returned an error: %v&#34;, err)
    }
  }()

  &lt;-ctx.Done()

  // In embedded-member scenario, you can use the EmbeddedClient. It implements
  // the Client interface.
  e := db.NewEmbeddedClient()

  ps, err := e.NewPubSub()
  if err != nil {
    log.Fatalf(&#34;olric.NewPubSub returned an error: %v&#34;, err)
  }

  ctx, cancel = context.WithCancel(context.Background())

  // Olric implements a drop-in replacement of Redis Publish-Subscribe messaging
  // system. PubSub client is just a thin layer around go-redis/redis.
  rps := ps.Subscribe(ctx, &#34;my-channel&#34;)

  // Get a message to read messages from my-channel
  msg := rps.Channel()

  go func() {
    // Publish a message here.
    _, err := ps.Publish(ctx, &#34;my-channel&#34;, &#34;Olric Rocks!&#34;)
    if err != nil {
      log.Fatalf(&#34;PubSub.Publish returned an error: %v&#34;, err)
    }
  }()

  // Consume messages
  rm := &lt;-msg

  fmt.Printf(&#34;Received message: \&#34;%s\&#34; from \&#34;%s\&#34;&#34;, rm.Channel, rm.Payload)

  // Don&#39;t forget the call Shutdown when you want to leave the cluster.
  ctx, cancel = context.WithTimeout(context.Background(), 10*time.Second)
  defer cancel()

  err = e.Close(ctx)
  if err != nil {
    log.Printf(&#34;Failed to close EmbeddedClient: %v&#34;, err)
  }
}"><pre><span>package</span> main

<span>import</span> (
  <span>&#34;context&#34;</span>
  <span>&#34;fmt&#34;</span>
  <span>&#34;log&#34;</span>
  <span>&#34;time&#34;</span>

  <span>&#34;github.com/buraksezer/olric&#34;</span>
  <span>&#34;github.com/buraksezer/olric/config&#34;</span>
)

<span>func</span> <span>main</span>() {
  <span>// Sample for Olric v0.5.x</span>

  <span>// Deployment scenario: embedded-member</span>
  <span>// This creates a single-node Olric cluster. It&#39;s good enough for experimenting.</span>

  <span>// config.New returns a new config.Config with sane defaults. Available values for env:</span>
  <span>// local, lan, wan</span>
  <span>c</span> <span>:=</span> <span>config</span>.<span>New</span>(<span>&#34;local&#34;</span>)

  <span>// Callback function. It&#39;s called when this node is ready to accept connections.</span>
  <span>ctx</span>, <span>cancel</span> <span>:=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())
  <span>c</span>.<span>Started</span> <span>=</span> <span>func</span>() {
    <span>defer</span> <span>cancel</span>()
    <span>log</span>.<span>Println</span>(<span>&#34;[INFO] Olric is ready to accept connections&#34;</span>)
  }

  <span>// Create a new Olric instance.</span>
  <span>db</span>, <span>err</span> <span>:=</span> <span>olric</span>.<span>New</span>(<span>c</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to create Olric instance: %v&#34;</span>, <span>err</span>)
  }

  <span>// Start the instance. It will form a single-node cluster.</span>
  <span>go</span> <span>func</span>() {
    <span>// Call Start at background. It&#39;s a blocker call.</span>
    <span>err</span> <span>=</span> <span>db</span>.<span>Start</span>()
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
      <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.Start returned an error: %v&#34;</span>, <span>err</span>)
    }
  }()

  <span>&lt;-</span><span>ctx</span>.<span>Done</span>()

  <span>// In embedded-member scenario, you can use the EmbeddedClient. It implements</span>
  <span>// the Client interface.</span>
  <span>e</span> <span>:=</span> <span>db</span>.<span>NewEmbeddedClient</span>()

  <span>ps</span>, <span>err</span> <span>:=</span> <span>e</span>.<span>NewPubSub</span>()
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.NewPubSub returned an error: %v&#34;</span>, <span>err</span>)
  }

  <span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())

  <span>// Olric implements a drop-in replacement of Redis Publish-Subscribe messaging</span>
  <span>// system. PubSub client is just a thin layer around go-redis/redis.</span>
  <span>rps</span> <span>:=</span> <span>ps</span>.<span>Subscribe</span>(<span>ctx</span>, <span>&#34;my-channel&#34;</span>)

  <span>// Get a message to read messages from my-channel</span>
  <span>msg</span> <span>:=</span> <span>rps</span>.<span>Channel</span>()

  <span>go</span> <span>func</span>() {
    <span>// Publish a message here.</span>
    <span>_</span>, <span>err</span> <span>:=</span> <span>ps</span>.<span>Publish</span>(<span>ctx</span>, <span>&#34;my-channel&#34;</span>, <span>&#34;Olric Rocks!&#34;</span>)
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
      <span>log</span>.<span>Fatalf</span>(<span>&#34;PubSub.Publish returned an error: %v&#34;</span>, <span>err</span>)
    }
  }()

  <span>// Consume messages</span>
  <span>rm</span> <span>:=</span> <span>&lt;-</span><span>msg</span>

  <span>fmt</span>.<span>Printf</span>(<span>&#34;Received message: <span>\&#34;</span>%s<span>\&#34;</span> from <span>\&#34;</span>%s<span>\&#34;</span>&#34;</span>, <span>rm</span>.<span>Channel</span>, <span>rm</span>.<span>Payload</span>)

  <span>// Don&#39;t forget the call Shutdown when you want to leave the cluster.</span>
  <span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithTimeout</span>(<span>context</span>.<span>Background</span>(), <span>10</span><span>*</span><span>time</span>.<span>Second</span>)
  <span>defer</span> <span>cancel</span>()

  <span>err</span> <span>=</span> <span>e</span>.<span>Close</span>(<span>ctx</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Printf</span>(<span>&#34;Failed to close EmbeddedClient: %v&#34;</span>, <span>err</span>)
  }
}</pre></div>
<h3 dir="auto"><a id="user-content-client-server-scenario" aria-hidden="true" href="#client-server-scenario"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Client-Server scenario</h3>
<h4 dir="auto"><a id="user-content-distributed-map-2" aria-hidden="true" href="#distributed-map-2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Distributed map</h4>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
  &#34;context&#34;
  &#34;fmt&#34;
  &#34;log&#34;
  &#34;time&#34;

  &#34;github.com/buraksezer/olric&#34;
)

func main() {
  // Sample for Olric v0.5.x

  // Deployment scenario: client-server

  // NewClusterClient takes a list of the nodes. This list may only contain a
  // load balancer address. Please note that Olric nodes will calculate the partition owner
  // and proxy the incoming requests.
  c, err := olric.NewClusterClient([]string{&#34;localhost:3320&#34;})
  if err != nil {
    log.Fatalf(&#34;olric.NewClusterClient returned an error: %v&#34;, err)
  }

  // In client-server scenario, you can use the ClusterClient. It implements
  // the Client interface.
  dm, err := c.NewDMap(&#34;bucket-of-arbitrary-items&#34;)
  if err != nil {
    log.Fatalf(&#34;olric.NewDMap returned an error: %v&#34;, err)
  }

  ctx, cancel := context.WithCancel(context.Background())

  // Magic starts here!
  fmt.Println(&#34;##&#34;)
  fmt.Println(&#34;Simple Put/Get on a DMap instance:&#34;)
  err = dm.Put(ctx, &#34;my-key&#34;, &#34;Olric Rocks!&#34;)
  if err != nil {
    log.Fatalf(&#34;Failed to call Put: %v&#34;, err)
  }

  gr, err := dm.Get(ctx, &#34;my-key&#34;)
  if err != nil {
    log.Fatalf(&#34;Failed to call Get: %v&#34;, err)
  }

  // Olric uses the Redis serialization format.
  value, err := gr.String()
  if err != nil {
    log.Fatalf(&#34;Failed to read Get response: %v&#34;, err)
  }

  fmt.Println(&#34;Response for my-key:&#34;, value)
  fmt.Println(&#34;##&#34;)

  // Don&#39;t forget the call Shutdown when you want to leave the cluster.
  ctx, cancel = context.WithTimeout(context.Background(), 10*time.Second)
  defer cancel()

  err = c.Close(ctx)
  if err != nil {
    log.Printf(&#34;Failed to close ClusterClient: %v&#34;, err)
  }
}"><pre><span>package</span> main

<span>import</span> (
  <span>&#34;context&#34;</span>
  <span>&#34;fmt&#34;</span>
  <span>&#34;log&#34;</span>
  <span>&#34;time&#34;</span>

  <span>&#34;github.com/buraksezer/olric&#34;</span>
)

<span>func</span> <span>main</span>() {
  <span>// Sample for Olric v0.5.x</span>

  <span>// Deployment scenario: client-server</span>

  <span>// NewClusterClient takes a list of the nodes. This list may only contain a</span>
  <span>// load balancer address. Please note that Olric nodes will calculate the partition owner</span>
  <span>// and proxy the incoming requests.</span>
  <span>c</span>, <span>err</span> <span>:=</span> <span>olric</span>.<span>NewClusterClient</span>([]<span>string</span>{<span>&#34;localhost:3320&#34;</span>})
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.NewClusterClient returned an error: %v&#34;</span>, <span>err</span>)
  }

  <span>// In client-server scenario, you can use the ClusterClient. It implements</span>
  <span>// the Client interface.</span>
  <span>dm</span>, <span>err</span> <span>:=</span> <span>c</span>.<span>NewDMap</span>(<span>&#34;bucket-of-arbitrary-items&#34;</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.NewDMap returned an error: %v&#34;</span>, <span>err</span>)
  }

  <span>ctx</span>, <span>cancel</span> <span>:=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())

  <span>// Magic starts here!</span>
  <span>fmt</span>.<span>Println</span>(<span>&#34;##&#34;</span>)
  <span>fmt</span>.<span>Println</span>(<span>&#34;Simple Put/Get on a DMap instance:&#34;</span>)
  <span>err</span> <span>=</span> <span>dm</span>.<span>Put</span>(<span>ctx</span>, <span>&#34;my-key&#34;</span>, <span>&#34;Olric Rocks!&#34;</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to call Put: %v&#34;</span>, <span>err</span>)
  }

  <span>gr</span>, <span>err</span> <span>:=</span> <span>dm</span>.<span>Get</span>(<span>ctx</span>, <span>&#34;my-key&#34;</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to call Get: %v&#34;</span>, <span>err</span>)
  }

  <span>// Olric uses the Redis serialization format.</span>
  <span>value</span>, <span>err</span> <span>:=</span> <span>gr</span>.<span>String</span>()
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to read Get response: %v&#34;</span>, <span>err</span>)
  }

  <span>fmt</span>.<span>Println</span>(<span>&#34;Response for my-key:&#34;</span>, <span>value</span>)
  <span>fmt</span>.<span>Println</span>(<span>&#34;##&#34;</span>)

  <span>// Don&#39;t forget the call Shutdown when you want to leave the cluster.</span>
  <span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithTimeout</span>(<span>context</span>.<span>Background</span>(), <span>10</span><span>*</span><span>time</span>.<span>Second</span>)
  <span>defer</span> <span>cancel</span>()

  <span>err</span> <span>=</span> <span>c</span>.<span>Close</span>(<span>ctx</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Printf</span>(<span>&#34;Failed to close ClusterClient: %v&#34;</span>, <span>err</span>)
  }
}</pre></div>
<h3 dir="auto"><a id="user-content-scan-on-dmaps" aria-hidden="true" href="#scan-on-dmaps"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SCAN on DMaps</h3>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
	&#34;context&#34;
	&#34;fmt&#34;
	&#34;log&#34;
	&#34;time&#34;

	&#34;github.com/buraksezer/olric&#34;
	&#34;github.com/buraksezer/olric/config&#34;
)

func main() {
	// Sample for Olric v0.5.x

	// Deployment scenario: embedded-member
	// This creates a single-node Olric cluster. It&#39;s good enough for experimenting.

	// config.New returns a new config.Config with sane defaults. Available values for env:
	// local, lan, wan
	c := config.New(&#34;local&#34;)

	// Callback function. It&#39;s called when this node is ready to accept connections.
	ctx, cancel := context.WithCancel(context.Background())
	c.Started = func() {
		defer cancel()
		log.Println(&#34;[INFO] Olric is ready to accept connections&#34;)
	}

	// Create a new Olric instance.
	db, err := olric.New(c)
	if err != nil {
		log.Fatalf(&#34;Failed to create Olric instance: %v&#34;, err)
	}

	// Start the instance. It will form a single-node cluster.
	go func() {
		// Call Start at background. It&#39;s a blocker call.
		err = db.Start()
		if err != nil {
			log.Fatalf(&#34;olric.Start returned an error: %v&#34;, err)
		}
	}()

	&lt;-ctx.Done()

	// In embedded-member scenario, you can use the EmbeddedClient. It implements
	// the Client interface.
	e := db.NewEmbeddedClient()

	dm, err := e.NewDMap(&#34;bucket-of-arbitrary-items&#34;)
	if err != nil {
		log.Fatalf(&#34;olric.NewDMap returned an error: %v&#34;, err)
	}

	ctx, cancel = context.WithCancel(context.Background())

	// Magic starts here!
	fmt.Println(&#34;##&#34;)
	fmt.Println(&#34;Insert 10 keys&#34;)
	var key string
	for i := 0; i &lt; 10; i++ {
		if i%2 == 0 {
			key = fmt.Sprintf(&#34;even:%d&#34;, i)
		} else {
			key = fmt.Sprintf(&#34;odd:%d&#34;, i)
		}
		err = dm.Put(ctx, key, nil)
		if err != nil {
			log.Fatalf(&#34;Failed to call Put: %v&#34;, err)
		}
	}

	i, err := dm.Scan(ctx)
	if err != nil {
		log.Fatalf(&#34;Failed to call Scan: %v&#34;, err)
	}

	fmt.Println(&#34;Iterate over all the keys&#34;)
	for i.Next() {
		fmt.Println(&#34;&gt;&gt; Key&#34;, i.Key())
	}

	i.Close()

	i, err = dm.Scan(ctx, olric.Match(&#34;^even:&#34;))
	if err != nil {
		log.Fatalf(&#34;Failed to call Scan: %v&#34;, err)
	}

	fmt.Println(&#34;\n\nScan with regex: ^even:&#34;)
	for i.Next() {
		fmt.Println(&#34;&gt;&gt; Key&#34;, i.Key())
	}

	i.Close()

	// Don&#39;t forget the call Shutdown when you want to leave the cluster.
	ctx, cancel = context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	err = db.Shutdown(ctx)
	if err != nil {
		log.Printf(&#34;Failed to shutdown Olric: %v&#34;, err)
	}
}"><pre><span>package</span> main

<span>import</span> (
	<span>&#34;context&#34;</span>
	<span>&#34;fmt&#34;</span>
	<span>&#34;log&#34;</span>
	<span>&#34;time&#34;</span>

	<span>&#34;github.com/buraksezer/olric&#34;</span>
	<span>&#34;github.com/buraksezer/olric/config&#34;</span>
)

<span>func</span> <span>main</span>() {
	<span>// Sample for Olric v0.5.x</span>

	<span>// Deployment scenario: embedded-member</span>
	<span>// This creates a single-node Olric cluster. It&#39;s good enough for experimenting.</span>

	<span>// config.New returns a new config.Config with sane defaults. Available values for env:</span>
	<span>// local, lan, wan</span>
	<span>c</span> <span>:=</span> <span>config</span>.<span>New</span>(<span>&#34;local&#34;</span>)

	<span>// Callback function. It&#39;s called when this node is ready to accept connections.</span>
	<span>ctx</span>, <span>cancel</span> <span>:=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())
	<span>c</span>.<span>Started</span> <span>=</span> <span>func</span>() {
		<span>defer</span> <span>cancel</span>()
		<span>log</span>.<span>Println</span>(<span>&#34;[INFO] Olric is ready to accept connections&#34;</span>)
	}

	<span>// Create a new Olric instance.</span>
	<span>db</span>, <span>err</span> <span>:=</span> <span>olric</span>.<span>New</span>(<span>c</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to create Olric instance: %v&#34;</span>, <span>err</span>)
	}

	<span>// Start the instance. It will form a single-node cluster.</span>
	<span>go</span> <span>func</span>() {
		<span>// Call Start at background. It&#39;s a blocker call.</span>
		<span>err</span> <span>=</span> <span>db</span>.<span>Start</span>()
		<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
			<span>log</span>.<span>Fatalf</span>(<span>&#34;olric.Start returned an error: %v&#34;</span>, <span>err</span>)
		}
	}()

	<span>&lt;-</span><span>ctx</span>.<span>Done</span>()

	<span>// In embedded-member scenario, you can use the EmbeddedClient. It implements</span>
	<span>// the Client interface.</span>
	<span>e</span> <span>:=</span> <span>db</span>.<span>NewEmbeddedClient</span>()

	<span>dm</span>, <span>err</span> <span>:=</span> <span>e</span>.<span>NewDMap</span>(<span>&#34;bucket-of-arbitrary-items&#34;</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatalf</span>(<span>&#34;olric.NewDMap returned an error: %v&#34;</span>, <span>err</span>)
	}

	<span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())

	<span>// Magic starts here!</span>
	<span>fmt</span>.<span>Println</span>(<span>&#34;##&#34;</span>)
	<span>fmt</span>.<span>Println</span>(<span>&#34;Insert 10 keys&#34;</span>)
	<span>var</span> <span>key</span> <span>string</span>
	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span> {
		<span>if</span> <span>i</span><span>%</span><span>2</span> <span>==</span> <span>0</span> {
			<span>key</span> <span>=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;even:%d&#34;</span>, <span>i</span>)
		} <span>else</span> {
			<span>key</span> <span>=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;odd:%d&#34;</span>, <span>i</span>)
		}
		<span>err</span> <span>=</span> <span>dm</span>.<span>Put</span>(<span>ctx</span>, <span>key</span>, <span>nil</span>)
		<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
			<span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to call Put: %v&#34;</span>, <span>err</span>)
		}
	}

	<span>i</span>, <span>err</span> <span>:=</span> <span>dm</span>.<span>Scan</span>(<span>ctx</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to call Scan: %v&#34;</span>, <span>err</span>)
	}

	<span>fmt</span>.<span>Println</span>(<span>&#34;Iterate over all the keys&#34;</span>)
	<span>for</span> <span>i</span>.<span>Next</span>() {
		<span>fmt</span>.<span>Println</span>(<span>&#34;&gt;&gt; Key&#34;</span>, <span>i</span>.<span>Key</span>())
	}

	<span>i</span>.<span>Close</span>()

	<span>i</span>, <span>err</span> <span>=</span> <span>dm</span>.<span>Scan</span>(<span>ctx</span>, <span>olric</span>.<span>Match</span>(<span>&#34;^even:&#34;</span>))
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatalf</span>(<span>&#34;Failed to call Scan: %v&#34;</span>, <span>err</span>)
	}

	<span>fmt</span>.<span>Println</span>(<span>&#34;<span>\n</span><span>\n</span>Scan with regex: ^even:&#34;</span>)
	<span>for</span> <span>i</span>.<span>Next</span>() {
		<span>fmt</span>.<span>Println</span>(<span>&#34;&gt;&gt; Key&#34;</span>, <span>i</span>.<span>Key</span>())
	}

	<span>i</span>.<span>Close</span>()

	<span>// Don&#39;t forget the call Shutdown when you want to leave the cluster.</span>
	<span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithTimeout</span>(<span>context</span>.<span>Background</span>(), <span>10</span><span>*</span><span>time</span>.<span>Second</span>)
	<span>defer</span> <span>cancel</span>()

	<span>err</span> <span>=</span> <span>db</span>.<span>Shutdown</span>(<span>ctx</span>)
	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Printf</span>(<span>&#34;Failed to shutdown Olric: %v&#34;</span>, <span>err</span>)
	}
}</pre></div>
<h4 dir="auto"><a id="user-content-publish-subscribe-2" aria-hidden="true" href="#publish-subscribe-2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Publish-Subscribe</h4>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
  &#34;context&#34;
  &#34;fmt&#34;
  &#34;log&#34;
  &#34;time&#34;

  &#34;github.com/buraksezer/olric&#34;
)

func main() {
  // Sample for Olric v0.5.x

  // Deployment scenario: client-server

  // NewClusterClient takes a list of the nodes. This list may only contain a
  // load balancer address. Please note that Olric nodes will calculate the partition owner
  // and proxy the incoming requests.
  c, err := olric.NewClusterClient([]string{&#34;localhost:3320&#34;})
  if err != nil {
    log.Fatalf(&#34;olric.NewClusterClient returned an error: %v&#34;, err)
  }

  // In client-server scenario, you can use the ClusterClient. It implements
  // the Client interface.
  ps, err := c.NewPubSub()
  if err != nil {
    log.Fatalf(&#34;olric.NewPubSub returned an error: %v&#34;, err)
  }

  ctx, cancel := context.WithCancel(context.Background())

  // Olric implements a drop-in replacement of Redis Publish-Subscribe messaging
  // system. PubSub client is just a thin layer around go-redis/redis.
  rps := ps.Subscribe(ctx, &#34;my-channel&#34;)

  // Get a message to read messages from my-channel
  msg := rps.Channel()

  go func() {
    // Publish a message here.
    _, err := ps.Publish(ctx, &#34;my-channel&#34;, &#34;Olric Rocks!&#34;)
    if err != nil {
      log.Fatalf(&#34;PubSub.Publish returned an error: %v&#34;, err)
    }
  }()

  // Consume messages
  rm := &lt;-msg

  fmt.Printf(&#34;Received message: \&#34;%s\&#34; from \&#34;%s\&#34;&#34;, rm.Channel, rm.Payload)

  // Don&#39;t forget the call Shutdown when you want to leave the cluster.
  ctx, cancel = context.WithTimeout(context.Background(), 10*time.Second)
  defer cancel()

  err = c.Close(ctx)
  if err != nil {
    log.Printf(&#34;Failed to close ClusterClient: %v&#34;, err)
  }
}
"><pre><span>package</span> main

<span>import</span> (
  <span>&#34;context&#34;</span>
  <span>&#34;fmt&#34;</span>
  <span>&#34;log&#34;</span>
  <span>&#34;time&#34;</span>

  <span>&#34;github.com/buraksezer/olric&#34;</span>
)

<span>func</span> <span>main</span>() {
  <span>// Sample for Olric v0.5.x</span>

  <span>// Deployment scenario: client-server</span>

  <span>// NewClusterClient takes a list of the nodes. This list may only contain a</span>
  <span>// load balancer address. Please note that Olric nodes will calculate the partition owner</span>
  <span>// and proxy the incoming requests.</span>
  <span>c</span>, <span>err</span> <span>:=</span> <span>olric</span>.<span>NewClusterClient</span>([]<span>string</span>{<span>&#34;localhost:3320&#34;</span>})
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.NewClusterClient returned an error: %v&#34;</span>, <span>err</span>)
  }

  <span>// In client-server scenario, you can use the ClusterClient. It implements</span>
  <span>// the Client interface.</span>
  <span>ps</span>, <span>err</span> <span>:=</span> <span>c</span>.<span>NewPubSub</span>()
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Fatalf</span>(<span>&#34;olric.NewPubSub returned an error: %v&#34;</span>, <span>err</span>)
  }

  <span>ctx</span>, <span>cancel</span> <span>:=</span> <span>context</span>.<span>WithCancel</span>(<span>context</span>.<span>Background</span>())

  <span>// Olric implements a drop-in replacement of Redis Publish-Subscribe messaging</span>
  <span>// system. PubSub client is just a thin layer around go-redis/redis.</span>
  <span>rps</span> <span>:=</span> <span>ps</span>.<span>Subscribe</span>(<span>ctx</span>, <span>&#34;my-channel&#34;</span>)

  <span>// Get a message to read messages from my-channel</span>
  <span>msg</span> <span>:=</span> <span>rps</span>.<span>Channel</span>()

  <span>go</span> <span>func</span>() {
    <span>// Publish a message here.</span>
    <span>_</span>, <span>err</span> <span>:=</span> <span>ps</span>.<span>Publish</span>(<span>ctx</span>, <span>&#34;my-channel&#34;</span>, <span>&#34;Olric Rocks!&#34;</span>)
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
      <span>log</span>.<span>Fatalf</span>(<span>&#34;PubSub.Publish returned an error: %v&#34;</span>, <span>err</span>)
    }
  }()

  <span>// Consume messages</span>
  <span>rm</span> <span>:=</span> <span>&lt;-</span><span>msg</span>

  <span>fmt</span>.<span>Printf</span>(<span>&#34;Received message: <span>\&#34;</span>%s<span>\&#34;</span> from <span>\&#34;</span>%s<span>\&#34;</span>&#34;</span>, <span>rm</span>.<span>Channel</span>, <span>rm</span>.<span>Payload</span>)

  <span>// Don&#39;t forget the call Shutdown when you want to leave the cluster.</span>
  <span>ctx</span>, <span>cancel</span> <span>=</span> <span>context</span>.<span>WithTimeout</span>(<span>context</span>.<span>Background</span>(), <span>10</span><span>*</span><span>time</span>.<span>Second</span>)
  <span>defer</span> <span>cancel</span>()

  <span>err</span> <span>=</span> <span>c</span>.<span>Close</span>(<span>ctx</span>)
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
    <span>log</span>.<span>Printf</span>(<span>&#34;Failed to close ClusterClient: %v&#34;</span>, <span>err</span>)
  }
}</pre></div>
<h2 dir="auto"><a id="user-content-contributions" aria-hidden="true" href="#contributions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contributions</h2>
<p dir="auto">Please don&#39;t hesitate to fork the project and send a pull request or just e-mail me to ask questions and share ideas.</p>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">The Apache License, Version 2.0 - see LICENSE for more details.</p>
<h2 dir="auto"><a id="user-content-about-the-name" aria-hidden="true" href="#about-the-name"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>About the name</h2>
<p dir="auto">The inner voice of Turgut zben who is the main character of <a href="https://www.themodernnovel.org/asia/other-asia/turkey/oguz-atay/the-disconnected/" rel="nofollow">Ouz Atay&#39;s masterpiece -The Disconnected-</a>.</p>
</article>
          </div></div>
  </body>
</html>
