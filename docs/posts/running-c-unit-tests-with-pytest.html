<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://p403n1x87.github.io/running-c-unit-tests-with-pytest.html">Original</a>
    <h1>Running C unit tests with pytest</h1>
    
    <div id="readability-page-1" class="page"><div id="content-block">
<section id="content">
  <p>In this post I will describe my approach to C unit testing using pytest. In particular, we get to see how to gracefully handle SIGSEGVs and prevent them from stopping the test runner abruptly. Furthermore, we shall try to write tests in a Pythonic way.</p>


  <div>
    

<p>That&#39;s probably what you might be asking right now. Why use a Python testing
framework to test C code? Why don&#39;t just use C testing frameworks, like <a href="https://github.com/google/googletest">Google
Test</a>, or <a href="https://libcheck.github.io/check/">Check</a>. I can give you an answer with all the
reasons that led me to adopt <a href="https://github.com/pytest-dev/pytest/">pytest</a> as the testing framework of choice
for one of my C projects, <a href="https://github.com/p403n1x87/austin">Austin</a>. The first is that I spend most time
coding in Python these days and I have more familiarity with pytest than any
other testing framework. Secondly, whilst Austin is a C project, it actually
targets Python programs, so Python is already one of the testing dependencies
that ends up being installed in CI anyway. Hence, instead of spending time
learning an entire new testing framework, I could quickly write them in Python,
and leverage all the features of pytest, as well as all the packages that are
available for Python, should I ever need to. But these are not all the reasons
for adopting pytest for running C tests. If you keep reading you will discover a
few more that might convince you to use pytest for your C unit tests too!</p>

<p>Testing C code with Python would only make sense if it were easy to call native
code from the interpreter. Thankfully, the Python standard library comes with
the <a href="https://docs.python.org/3/library/ctypes.html"><code>ctypes</code></a> module that allows us to do just that! So let&#39;s start
looking at some C code, for instance,</p>
<div><pre><span></span><span># file: fact.c</span>

<span>long</span><span> </span><span>fact</span><span>(</span><span>long</span><span> </span><span>n</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>n</span><span> </span><span>&lt;</span><span> </span><span>1</span><span>)</span><span></span>
<span>        </span><span>return</span><span> </span><span>1</span><span>;</span><span></span>
<span>    </span><span>return</span><span> </span><span>n</span><span> </span><span>*</span><span> </span><span>fact</span><span>(</span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span></span>
<span>}</span><span></span>
</pre></div>


<p>which we want to compile as a shared object, e.g. with</p>
<div><pre><span></span>gcc -shared -o fact.so fact.c
</pre></div>


<p>How do we test the <code>fact</code> function from Python? Easy peasy!</p>
<div><pre><span></span><span># file: fact.py</span>

<span>from</span> <span>ctypes</span> <span>import</span> <span>CDLL</span>

<span>libfact</span> <span>=</span> <span>CDLL</span><span>(</span><span>&#34;./fact.so&#34;</span><span>)</span>

<span>assert</span> <span>libfact</span><span>.</span><span>fact</span><span>(</span><span>6</span><span>)</span> <span>==</span> <span>720</span>
<span>assert</span> <span>libfact</span><span>.</span><span>fact</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>1</span>
<span>assert</span> <span>libfact</span><span>.</span><span>fact</span><span>(</span><span>-</span><span>42</span><span>)</span> <span>==</span> <span>1</span>
</pre></div>


<p>Assuming we are in the directory where both <code>fact.so</code> and <code>fact.py</code> reside, we
can test the <code>fact</code> function inside <code>fact.c</code> simply with</p>



<p>If the test succeeds, the script&#39;s return code will be 0.</p>
<blockquote>
<p>Congratulations! You have now tested some C code with Python! üéâ</p>
</blockquote>

<p>We are not here to just play around with bare <code>assert</code>s. I promised you the full
power of Python and <code>pytest</code>, so we can&#39;t settle with just this simple
example. Let&#39;s add <code>pytest</code> to our test dependencies and do this instead</p>
<div><pre><span></span><span># file: test_fact.py</span>

<span>from</span> <span>ctypes</span> <span>import</span> <span>CDLL</span>

<span>import</span> <span>pytest</span>

<span>@pytest</span><span>.</span><span>fixture</span>
<span>def</span> <span>libfact</span><span>():</span>
    <span>yield</span> <span>CDLL</span><span>(</span><span>&#34;./fact.so&#34;</span><span>)</span>


<span>def</span> <span>test_fact</span><span>(</span><span>libfact</span><span>):</span>
    <span>assert</span> <span>libfact</span><span>.</span><span>fact</span><span>(</span><span>6</span><span>)</span> <span>==</span> <span>720</span>
    <span>assert</span> <span>libfact</span><span>.</span><span>fact</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>1</span>
    <span>assert</span> <span>libfact</span><span>.</span><span>fact</span><span>(</span><span>-</span><span>42</span><span>)</span> <span>==</span> <span>1</span>
</pre></div>


<p>Now run <code>pytest</code> to get</p>
<div><pre><span></span>$ pytest
=========================== test session starts ============================
platform linux -- Python 3.10.2, pytest-7.0.0, pluggy-1.0.0
rootdir: /tmp
collected 1 item

test_fact.py .                                                       [100%]

============================ 1 passed in 0.00s =============================
</pre></div>


<p>That&#39;s some more informative output than what a plain Python test script would
give us! How about starting to leverage some of the other <code>pytest</code> features,
like parametrised tests? Let&#39;s rewrite our test case like so</p>
<div><pre><span></span><span># file: test_fact.py</span>

<span>from</span> <span>ctypes</span> <span>import</span> <span>CDLL</span>

<span>import</span> <span>pytest</span>


<span>@pytest</span><span>.</span><span>fixture</span>
<span>def</span> <span>libfact</span><span>():</span>
    <span>yield</span> <span>CDLL</span><span>(</span><span>&#34;./fact.so&#34;</span><span>)</span>


<span>@pytest</span><span>.</span><span>mark</span><span>.</span><span>parametrize</span><span>(</span><span>&#34;n,e&#34;</span><span>,</span> <span>[(</span><span>6</span><span>,</span> <span>720</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>-</span><span>42</span><span>,</span> <span>1</span><span>)])</span>
<span>def</span> <span>test_fact</span><span>(</span><span>libfact</span><span>,</span> <span>n</span><span>,</span> <span>e</span><span>):</span>
    <span>assert</span> <span>libfact</span><span>.</span><span>fact</span><span>(</span><span>n</span><span>)</span> <span>==</span> <span>e</span>
</pre></div>


<p>Let&#39;s run this again with <code>pytest</code>, this time with a more verbose output:</p>
<div><pre><span></span>pytest -vv
=========================== test session starts ============================
platform linux -- Python 3.10.2, pytest-7.0.0, pluggy-1.0.0 -- /tmp/.venv/bin/python3.10
cachedir: .pytest_cache
rootdir: /tmp
collected 3 items

test_fact.py::test_fact[6-720] PASSED                                [ 33%]
test_fact.py::test_fact[0-1] PASSED                                  [ 66%]
test_fact.py::test_fact[-42-1] PASSED                                [100%]

============================ 3 passed in 0.01s =============================
</pre></div>


<p>Sweet! üçØ</p>

<p>Thus far we&#39;ve got an idea of how to invoke C from Python and how to write some
simple tests that we can run with <code>pytest</code> while also leveraging features like
fixtures and parametrised tests. Let us now step this up a notch and consider
the organisation of sources within an <em>actual</em> C project, for instance</p>
<div><pre><span></span>my-c-project/
‚îú‚îÄ‚îÄ docs/
‚îú‚îÄ‚îÄ src/    &lt;- All *.c and *.h sources, perhaps organised into sub-folders
‚îú‚îÄ‚îÄ tests/  &lt;- Our test sources, obviously!
‚îú‚îÄ‚îÄ ChangeLog
‚îú‚îÄ‚îÄ configure.ac
‚îú‚îÄ‚îÄ LICENCE
‚îú‚îÄ‚îÄ Makefile.am
‚îú‚îÄ‚îÄ README
...
</pre></div>


<p>In the previous example, we built the shared object <code>fact.so</code> by hand, but in a
CI environment we would probably want to automate that step too. What should we
use for that? A bash script? A makefile? Python, of course! What else?!? üòÄ</p>
<p>Let&#39;s make our sample C sources slightly more interesting. For example, we could
borrow a few parts of the <code>cache.c</code> and <code>cache.h</code> sources from <a href="https://github.com/p403n1x87/austin">Austin</a>,
which implement a simple LRU cache. This is part of the spec</p>
<div><pre><span></span><span>// file: src/cache.h</span>

<span>#ifndef CACHE_H</span>
<span>#define CACHE_H</span>

<span>#include</span><span> </span><span>&lt;stdint.h&gt;</span><span></span>
<span>#include</span><span> </span><span>&lt;stdlib.h&gt;</span><span></span>

<span>typedef</span><span> </span><span>uintptr_t</span><span> </span><span>key_dt</span><span>;</span><span></span>
<span>typedef</span><span> </span><span>void</span><span> </span><span>*</span><span>value_t</span><span>;</span><span></span>

<span>typedef</span><span> </span><span>struct</span><span> </span><span>queue_item_t</span><span></span>
<span>{</span><span></span>
<span>    </span><span>struct</span><span> </span><span>queue_item_t</span><span> </span><span>*</span><span>prev</span><span>,</span><span> </span><span>*</span><span>next</span><span>;</span><span></span>
<span>    </span><span>key_dt</span><span> </span><span>key</span><span>;</span><span></span>
<span>    </span><span>value_t</span><span> </span><span>value</span><span>;</span><span> </span><span>// Takes ownership of a free-able object</span>
<span>}</span><span> </span><span>queue_item_t</span><span>;</span><span></span>

<span>typedef</span><span> </span><span>struct</span><span> </span><span>queue_t</span><span></span>
<span>{</span><span></span>
<span>    </span><span>unsigned</span><span> </span><span>count</span><span>;</span><span></span>
<span>    </span><span>unsigned</span><span> </span><span>capacity</span><span>;</span><span></span>
<span>    </span><span>queue_item_t</span><span> </span><span>*</span><span>front</span><span>,</span><span> </span><span>*</span><span>rear</span><span>;</span><span></span>
<span>    </span><span>void</span><span> </span><span>(</span><span>*</span><span>deallocator</span><span>)(</span><span>value_t</span><span>);</span><span></span>
<span>}</span><span> </span><span>queue_t</span><span>;</span><span></span>

<span>queue_item_t</span><span> </span><span>*</span><span></span>
<span>queue_item_new</span><span>(</span><span>value_t</span><span>,</span><span> </span><span>key_dt</span><span>);</span><span></span>

<span>void</span><span></span>
<span>queue_item__destroy</span><span>(</span><span>queue_item_t</span><span> </span><span>*</span><span>,</span><span> </span><span>void</span><span> </span><span>(</span><span>*</span><span>)(</span><span>value_t</span><span>));</span><span></span>

<span>queue_t</span><span> </span><span>*</span><span></span>
<span>queue_new</span><span>(</span><span>int</span><span>,</span><span> </span><span>void</span><span> </span><span>(</span><span>*</span><span>)(</span><span>value_t</span><span>));</span><span></span>

<span>int</span><span></span>
<span>queue__is_full</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>);</span><span></span>

<span>int</span><span></span>
<span>queue__is_empty</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>);</span><span></span>

<span>value_t</span><span></span>
<span>queue__dequeue</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>);</span><span></span>

<span>queue_item_t</span><span> </span><span>*</span><span></span>
<span>queue__enqueue</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>,</span><span> </span><span>value_t</span><span>,</span><span> </span><span>key_dt</span><span>);</span><span></span>

<span>void</span><span></span>
<span>queue__destroy</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>);</span><span></span>
</pre></div>


<p>and this is the corresponding part of the implementation</p>
<div><pre><span></span><span>// file: src/cache.c</span>

<span>#include</span><span> </span><span>&lt;stdbool.h&gt;</span><span></span>
<span>#include</span><span> </span><span>&lt;stdio.h&gt;</span><span></span>

<span>#include</span><span> </span><span>&#34;cache.h&#34;</span><span></span>

<span>#define isvalid(x) ((x) != NULL)</span>

<span>// ----------------------------------------------------------------------------</span>
<span>queue_item_t</span><span> </span><span>*</span><span></span>
<span>queue_item_new</span><span>(</span><span>value_t</span><span> </span><span>value</span><span>,</span><span> </span><span>key_dt</span><span> </span><span>key</span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>queue_item_t</span><span> </span><span>*</span><span>item</span><span> </span><span>=</span><span> </span><span>(</span><span>queue_item_t</span><span> </span><span>*</span><span>)</span><span>calloc</span><span>(</span><span>1</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>queue_item_t</span><span>));</span><span></span>

<span>    </span><span>item</span><span>-&gt;</span><span>value</span><span> </span><span>=</span><span> </span><span>value</span><span>;</span><span></span>
<span>    </span><span>item</span><span>-&gt;</span><span>key</span><span> </span><span>=</span><span> </span><span>key</span><span>;</span><span></span>

<span>    </span><span>return</span><span> </span><span>item</span><span>;</span><span></span>
<span>}</span><span></span>

<span>// ----------------------------------------------------------------------------</span>
<span>void</span><span></span>
<span>queue_item__destroy</span><span>(</span><span>queue_item_t</span><span> </span><span>*</span><span>self</span><span>,</span><span> </span><span>void</span><span> </span><span>(</span><span>*</span><span>deallocator</span><span>)(</span><span>value_t</span><span>))</span><span></span>
<span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>isvalid</span><span>(</span><span>self</span><span>))</span><span></span>
<span>        </span><span>return</span><span>;</span><span></span>

<span>    </span><span>deallocator</span><span>(</span><span>self</span><span>-&gt;</span><span>value</span><span>);</span><span></span>

<span>    </span><span>free</span><span>(</span><span>self</span><span>);</span><span></span>
<span>}</span><span></span>

<span>// ----------------------------------------------------------------------------</span>
<span>queue_t</span><span> </span><span>*</span><span></span>
<span>queue_new</span><span>(</span><span>int</span><span> </span><span>capacity</span><span>,</span><span> </span><span>void</span><span> </span><span>(</span><span>*</span><span>deallocator</span><span>)(</span><span>value_t</span><span>))</span><span></span>
<span>{</span><span></span>
<span>    </span><span>queue_t</span><span> </span><span>*</span><span>queue</span><span> </span><span>=</span><span> </span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>)</span><span>calloc</span><span>(</span><span>1</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>queue_t</span><span>));</span><span></span>

<span>    </span><span>queue</span><span>-&gt;</span><span>capacity</span><span> </span><span>=</span><span> </span><span>capacity</span><span>;</span><span></span>
<span>    </span><span>queue</span><span>-&gt;</span><span>deallocator</span><span> </span><span>=</span><span> </span><span>deallocator</span><span>;</span><span></span>

<span>    </span><span>return</span><span> </span><span>queue</span><span>;</span><span></span>
<span>}</span><span></span>

<span>// ----------------------------------------------------------------------------</span>
<span>int</span><span></span>
<span>queue__is_full</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>queue</span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>queue</span><span>-&gt;</span><span>count</span><span> </span><span>==</span><span> </span><span>queue</span><span>-&gt;</span><span>capacity</span><span>;</span><span></span>
<span>}</span><span></span>

<span>// ----------------------------------------------------------------------------</span>
<span>int</span><span></span>
<span>queue__is_empty</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>queue</span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>queue</span><span>-&gt;</span><span>rear</span><span> </span><span>==</span><span> </span><span>NULL</span><span>;</span><span></span>
<span>}</span><span></span>

<span>// ----------------------------------------------------------------------------</span>
<span>value_t</span><span></span>
<span>queue__dequeue</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>queue</span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>queue__is_empty</span><span>(</span><span>queue</span><span>))</span><span></span>
<span>        </span><span>return</span><span> </span><span>NULL</span><span>;</span><span></span>

<span>    </span><span>if</span><span> </span><span>(</span><span>queue</span><span>-&gt;</span><span>front</span><span> </span><span>==</span><span> </span><span>queue</span><span>-&gt;</span><span>rear</span><span>)</span><span></span>
<span>        </span><span>queue</span><span>-&gt;</span><span>front</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span><span></span>

<span>    </span><span>queue_item_t</span><span> </span><span>*</span><span>temp</span><span> </span><span>=</span><span> </span><span>queue</span><span>-&gt;</span><span>rear</span><span>;</span><span></span>
<span>    </span><span>queue</span><span>-&gt;</span><span>rear</span><span> </span><span>=</span><span> </span><span>queue</span><span>-&gt;</span><span>rear</span><span>-&gt;</span><span>prev</span><span>;</span><span></span>

<span>    </span><span>if</span><span> </span><span>(</span><span>queue</span><span>-&gt;</span><span>rear</span><span>)</span><span></span>
<span>        </span><span>queue</span><span>-&gt;</span><span>rear</span><span>-&gt;</span><span>next</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span><span></span>

<span>    </span><span>void</span><span> </span><span>*</span><span>value</span><span> </span><span>=</span><span> </span><span>temp</span><span>-&gt;</span><span>value</span><span>;</span><span></span>
<span>    </span><span>free</span><span>(</span><span>temp</span><span>);</span><span></span>

<span>    </span><span>queue</span><span>-&gt;</span><span>count</span><span>--</span><span>;</span><span></span>

<span>    </span><span>return</span><span> </span><span>value</span><span>;</span><span></span>
<span>}</span><span></span>

<span>// ----------------------------------------------------------------------------</span>
<span>queue_item_t</span><span> </span><span>*</span><span></span>
<span>queue__enqueue</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>self</span><span>,</span><span> </span><span>value_t</span><span> </span><span>value</span><span>,</span><span> </span><span>key_dt</span><span> </span><span>key</span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>queue__is_full</span><span>(</span><span>self</span><span>))</span><span></span>
<span>        </span><span>return</span><span> </span><span>NULL</span><span>;</span><span></span>

<span>    </span><span>queue_item_t</span><span> </span><span>*</span><span>temp</span><span> </span><span>=</span><span> </span><span>queue_item_new</span><span>(</span><span>value</span><span>,</span><span> </span><span>key</span><span>);</span><span></span>
<span>    </span><span>temp</span><span>-&gt;</span><span>next</span><span> </span><span>=</span><span> </span><span>self</span><span>-&gt;</span><span>front</span><span>;</span><span></span>

<span>    </span><span>if</span><span> </span><span>(</span><span>queue__is_empty</span><span>(</span><span>self</span><span>))</span><span></span>
<span>        </span><span>self</span><span>-&gt;</span><span>rear</span><span> </span><span>=</span><span> </span><span>self</span><span>-&gt;</span><span>front</span><span> </span><span>=</span><span> </span><span>temp</span><span>;</span><span></span>
<span>    </span><span>else</span><span></span>
<span>    </span><span>{</span><span></span>
<span>        </span><span>self</span><span>-&gt;</span><span>front</span><span>-&gt;</span><span>prev</span><span> </span><span>=</span><span> </span><span>temp</span><span>;</span><span></span>
<span>        </span><span>self</span><span>-&gt;</span><span>front</span><span> </span><span>=</span><span> </span><span>temp</span><span>;</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>self</span><span>-&gt;</span><span>count</span><span>++</span><span>;</span><span></span>

<span>    </span><span>return</span><span> </span><span>temp</span><span>;</span><span></span>
<span>}</span><span></span>

<span>// ----------------------------------------------------------------------------</span>
<span>void</span><span></span>
<span>queue__destroy</span><span>(</span><span>queue_t</span><span> </span><span>*</span><span>self</span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>isvalid</span><span>(</span><span>self</span><span>))</span><span></span>
<span>        </span><span>return</span><span>;</span><span></span>

<span>    </span><span>queue_item_t</span><span> </span><span>*</span><span>next</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span><span></span>
<span>    </span><span>for</span><span> </span><span>(</span><span>queue_item_t</span><span> </span><span>*</span><span>item</span><span> </span><span>=</span><span> </span><span>self</span><span>-&gt;</span><span>front</span><span>;</span><span> </span><span>isvalid</span><span>(</span><span>item</span><span>);</span><span> </span><span>item</span><span> </span><span>=</span><span> </span><span>next</span><span>)</span><span></span>
<span>    </span><span>{</span><span></span>
<span>        </span><span>next</span><span> </span><span>=</span><span> </span><span>item</span><span>-&gt;</span><span>next</span><span>;</span><span></span>
<span>        </span><span>queue_item__destroy</span><span>(</span><span>item</span><span>,</span><span> </span><span>self</span><span>-&gt;</span><span>deallocator</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>free</span><span>(</span><span>self</span><span>);</span><span></span>
<span>}</span><span></span>
</pre></div>


<p>It&#39;s quite a fair bit of code; however, we are not interested in how the data
structures are implemented, but rather to what it actually implements. This
already gives us plenty to play with.</p>
<p>The important detail here is that our C application has a component implemented
in <code>cache.c</code> and we want to unit-test it. Before we can run any actual tests, we
need to build a binary object that we can invoke from Python. So let&#39;s put this
code in <code>tests/cunit/__init__.py</code></p>
<div><pre><span></span><span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>
<span>from</span> <span>subprocess</span> <span>import</span> <span>PIPE</span><span>,</span> <span>STDOUT</span><span>,</span> <span>run</span>

<span>HERE</span> <span>=</span> <span>Path</span><span>(</span><span>__file__</span><span>)</span><span>.</span><span>resolve</span><span>()</span><span>.</span><span>parent</span>
<span>TEST</span> <span>=</span> <span>HERE</span><span>.</span><span>parent</span>
<span>ROOT</span> <span>=</span> <span>TEST</span><span>.</span><span>parent</span>
<span>SRC</span> <span>=</span> <span>ROOT</span> <span>/</span> <span>&#34;src&#34;</span>


<span>class</span> <span>CompilationError</span><span>(</span><span>Exception</span><span>):</span>
    <span>pass</span>


<span>def</span> <span>compile</span><span>(</span><span>source</span><span>:</span> <span>Path</span><span>,</span> <span>cflags</span><span>=</span><span>[],</span> <span>ldadd</span><span>=</span><span>[]):</span>
    <span>binary</span> <span>=</span> <span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>)</span>

    <span>result</span> <span>=</span> <span>run</span><span>(</span>
        <span>[</span><span>&#34;gcc&#34;</span><span>,</span> <span>&#34;-shared&#34;</span><span>,</span> <span>*</span><span>cflags</span><span>,</span> <span>&#34;-o&#34;</span><span>,</span> <span>str</span><span>(</span><span>binary</span><span>),</span> <span>str</span><span>(</span><span>source</span><span>),</span> <span>*</span><span>ldadd</span><span>],</span>
        <span>stdout</span><span>=</span><span>PIPE</span><span>,</span>
        <span>stderr</span><span>=</span><span>STDOUT</span><span>,</span>
        <span>cwd</span><span>=</span><span>SRC</span><span>,</span>
    <span>)</span>

    <span>if</span> <span>result</span><span>.</span><span>returncode</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span>

    <span>raise</span> <span>CompilationError</span><span>(</span><span>result</span><span>.</span><span>stdout</span><span>.</span><span>decode</span><span>())</span>
</pre></div>


<p>This simply defines the <code>compile</code> utility that allows us to invoke <code>gcc</code> to
compile a source and generate the <code>.so</code> shared object. We can then use it in our
test source this way</p>
<div><pre><span></span><span>from</span> <span>ctypes</span> <span>import</span> <span>CDLL</span>

<span>import</span> <span>pytest</span>
<span>from</span> <span>tests.cunit</span> <span>import</span> <span>SRC</span><span>,</span> <span>compile</span>

<span>C</span> <span>=</span> <span>CDLL</span><span>(</span><span>&#34;libc.so.6&#34;</span><span>)</span>


<span>@pytest</span><span>.</span><span>fixture</span>
<span>def</span> <span>cache</span><span>():</span>
    <span>source</span> <span>=</span> <span>SRC</span> <span>/</span> <span>&#34;cache.c&#34;</span>
    <span>compile</span><span>(</span><span>source</span><span>)</span>
    <span>yield</span> <span>CDLL</span><span>(</span><span>str</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>)))</span>


<span>def</span> <span>test_cache</span><span>(</span><span>cache</span><span>):</span>
    <span>lru_cache</span> <span>=</span> <span>cache</span><span>.</span><span>lru_cache_new</span><span>(</span><span>10</span><span>,</span> <span>C</span><span>.</span><span>free</span><span>)</span>
    <span>assert</span> <span>lru_cache</span>
    <span>cache</span><span>.</span><span>lru_cache__destroy</span><span>(</span><span>lru_cache</span><span>)</span>
</pre></div>


<p>At this point, your project folder should have the following structure</p>
<div><pre><span></span>my-c-project/
...
‚îú‚îÄ‚îÄ src/
|   ‚îú‚îÄ‚îÄ cache.c
|   ‚îî‚îÄ‚îÄ cache.h
‚îú‚îÄ‚îÄ tests/
|   ‚îú‚îÄ‚îÄ cunit/
|   |   ‚îú‚îÄ‚îÄ __init__.py
|   |   ‚îî‚îÄ‚îÄ test_cache.py
|   ‚îî‚îÄ‚îÄ __init__.py
...
</pre></div>


<p>and when you run <code>pytest</code> again, this time the C source would be compiled at
runtime using <code>gcc</code>. The tests then run as before, which should produce the same
output we saw earlier.</p>

<p>If you&#39;re still with me, then things are probably looking interesting to you
too. So let&#39;s test a bit more of the functions exported by the caching
component. Let&#39;s make a test case for the <code>queue_item_t</code> and <code>queue_t</code> objects,
like so</p>
<div><pre><span></span><span>from</span> <span>ctypes</span> <span>import</span> <span>CDLL</span>

<span>import</span> <span>pytest</span>
<span>from</span> <span>tests.cunit</span> <span>import</span> <span>SRC</span><span>,</span> <span>compile</span>

<span>C</span> <span>=</span> <span>CDLL</span><span>(</span><span>&#34;libc.so.6&#34;</span><span>)</span>


<span>@pytest</span><span>.</span><span>fixture</span>
<span>def</span> <span>cache</span><span>():</span>
    <span>source</span> <span>=</span> <span>SRC</span> <span>/</span> <span>&#34;cache.c&#34;</span>
    <span>compile</span><span>(</span><span>source</span><span>)</span>
    <span>yield</span> <span>CDLL</span><span>(</span><span>str</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>)))</span>


<span>NULL</span> <span>=</span> <span>0</span>


<span>def</span> <span>test_queue_item</span><span>(</span><span>cache</span><span>):</span>
    <span>value</span> <span>=</span> <span>1</span>
    <span>queue_item</span> <span>=</span> <span>cache</span><span>.</span><span>queue_item_new</span><span>(</span><span>value</span><span>,</span> <span>42</span><span>)</span>
    <span>assert</span> <span>queue_item</span>

    <span>cache</span><span>.</span><span>queue_item__destroy</span><span>(</span><span>queue_item</span><span>,</span> <span>C</span><span>.</span><span>free</span><span>)</span>


<span>@pytest</span><span>.</span><span>mark</span><span>.</span><span>parametrize</span><span>(</span><span>&#34;qsize&#34;</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>10</span><span>,</span> <span>100</span><span>,</span> <span>1000</span><span>])</span>
<span>def</span> <span>test_queue</span><span>(</span><span>cache</span><span>,</span> <span>qsize</span><span>):</span>
    <span>q</span> <span>=</span> <span>cache</span><span>.</span><span>queue_new</span><span>(</span><span>qsize</span><span>,</span> <span>C</span><span>.</span><span>free</span><span>)</span>

    <span>assert</span> <span>cache</span><span>.</span><span>queue__is_empty</span><span>(</span><span>q</span><span>)</span>
    <span>assert</span> <span>qsize</span> <span>==</span> <span>0</span> <span>or</span> <span>not</span> <span>cache</span><span>.</span><span>queue__is_full</span><span>(</span><span>q</span><span>)</span>

    <span>assert</span> <span>cache</span><span>.</span><span>queue__dequeue</span><span>(</span><span>q</span><span>)</span> <span>is</span> <span>NULL</span>

    <span>values</span> <span>=</span> <span>[</span><span>C</span><span>.</span><span>malloc</span><span>(</span><span>16</span><span>)</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>qsize</span><span>)]</span>
    <span>assert</span> <span>all</span><span>(</span><span>values</span><span>)</span>

    <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>enumerate</span><span>(</span><span>values</span><span>):</span>
        <span>assert</span> <span>cache</span><span>.</span><span>queue__enqueue</span><span>(</span><span>q</span><span>,</span> <span>v</span><span>,</span> <span>k</span><span>)</span>

    <span>assert</span> <span>qsize</span> <span>==</span> <span>0</span> <span>or</span> <span>not</span> <span>cache</span><span>.</span><span>queue__is_empty</span><span>(</span><span>q</span><span>)</span>
    <span>assert</span> <span>cache</span><span>.</span><span>queue__is_full</span><span>(</span><span>q</span><span>)</span>
    <span>assert</span> <span>cache</span><span>.</span><span>queue__enqueue</span><span>(</span><span>q</span><span>,</span> <span>42</span><span>,</span> <span>42</span><span>)</span> <span>is</span> <span>NULL</span>

    <span>assert</span> <span>values</span> <span>==</span> <span>[</span><span>cache</span><span>.</span><span>queue__dequeue</span><span>(</span><span>q</span><span>)</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>qsize</span><span>)]</span>
</pre></div>


<p>Let&#39;s run the new tests with <code>pytest -vv</code> and</p>
<div><pre><span></span>=============================== test session starts ===============================
platform linux -- Python 3.10.2, pytest-7.0.0, pluggy-1.0.0 -- /home/gabriele/Projects/cunit/.venv/bin/python3.10
cachedir: .pytest_cache
rootdir: /home/gabriele/Projects/cunit
collected 5 items

tests/cunit/test_cache.py::test_queue_item Fatal Python error: Segmentation fault

Current thread 0x00007f4016e4f740 (most recent call first):
  File &#34;/home/gabriele/Projects/cunit/tests/cunit/test_cache.py&#34;, line 24 in test_queue_item
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/python.py&#34;, line 192 in pytest_pyfunc_call
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_callers.py&#34;, line 39 in _multicall
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_manager.py&#34;, line 80 in _hookexec
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_hooks.py&#34;, line 265 in __call__
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/python.py&#34;, line 1718 in runtest
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/runner.py&#34;, line 168 in pytest_runtest_call
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_callers.py&#34;, line 39 in _multicall
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_manager.py&#34;, line 80 in _hookexec
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_hooks.py&#34;, line 265 in __call__
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/runner.py&#34;, line 261 in &lt;lambda&gt;
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/runner.py&#34;, line 340 in from_call
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/runner.py&#34;, line 260 in call_runtest_hook
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/runner.py&#34;, line 221 in call_and_report
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/runner.py&#34;, line 132 in runtestprotocol
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/runner.py&#34;, line 113 in pytest_runtest_protocol
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_callers.py&#34;, line 39 in _multicall
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_manager.py&#34;, line 80 in _hookexec
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_hooks.py&#34;, line 265 in __call__
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/main.py&#34;, line 347 in pytest_runtestloop
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_callers.py&#34;, line 39 in _multicall
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_manager.py&#34;, line 80 in _hookexec
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_hooks.py&#34;, line 265 in __call__
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/main.py&#34;, line 322 in _main
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/main.py&#34;, line 268 in wrap_session
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/main.py&#34;, line 315 in pytest_cmdline_main
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_callers.py&#34;, line 39 in _multicall
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_manager.py&#34;, line 80 in _hookexec
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/pluggy/_hooks.py&#34;, line 265 in __call__
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/config/__init__.py&#34;, line 165 in main
  File &#34;/home/gabriele/Projects/cunit/.venv/lib/python3.10/site-packages/_pytest/config/__init__.py&#34;, line 188 in console_main
  File &#34;/home/gabriele/Projects/cunit/.venv/bin/pytest&#34;, line 8 in &lt;module&gt;
[1]    337951 segmentation fault  .venv/bin/pytest -vv
</pre></div>


<p>Wait, what?! Where are our tests? A segmentation fault?!? Where did that come
from? Well, there goes all this <code>pytest</code> hype! üò°</p>
<p>Now, do you think I would have written this post if this was really the end of
the story? </p>
<p>If you want to figure out for yourself where the problem is, pause here. When
you are ready to carry on, change line 20 to</p>



<p>and now the tests will all be happy! However, we really want to avoid crashing
the <code>pytest</code> process when we run into a segmentation fault, which is not so rare
when running arbitrary C code. Not only that, but we would like to get some
useful information, like a traceback, that could give us insight as to where the
problem might be! One of the many strengths of <code>pytest</code> is its <a href="https://docs.pytest.org/en/latest/reference/reference.html">extensive
configuration API</a>. How do we use it to not crash the test runner?
The idea is to spawn another <code>pytest</code> process that runs just <em>a</em> test. Now, if
that test causes a segmentation fault, the parent process will keep running the
other tests. Let&#39;s put this into <code>tests/cunit/conftest.py</code></p>
<div><pre><span></span><span># file: tests/cunit/conftest.py</span>

<span>import</span> <span>os</span>
<span>import</span> <span>sys</span>
<span>from</span> <span>subprocess</span> <span>import</span> <span>PIPE</span><span>,</span> <span>run</span>
<span>from</span> <span>types</span> <span>import</span> <span>FunctionType</span>


<span>class</span> <span>SegmentationFault</span><span>(</span><span>Exception</span><span>):</span>
    <span>pass</span>


<span>class</span> <span>CUnitTestFailure</span><span>(</span><span>Exception</span><span>):</span>
    <span>pass</span>


<span>def</span> <span>pytest_pycollect_makeitem</span><span>(</span><span>collector</span><span>,</span> <span>name</span><span>,</span> <span>obj</span><span>):</span>
    <span>if</span> <span>(</span>
        <span>not</span> <span>os</span><span>.</span><span>getenv</span><span>(</span><span>&#34;PYTEST_CUNIT&#34;</span><span>)</span>
        <span>and</span> <span>isinstance</span><span>(</span><span>obj</span><span>,</span> <span>FunctionType</span><span>)</span>
        <span>and</span> <span>name</span><span>.</span><span>startswith</span><span>(</span><span>&#34;test_&#34;</span><span>)</span>
    <span>):</span>
        <span>obj</span><span>.</span><span>__cunit__</span> <span>=</span> <span>(</span><span>str</span><span>(</span><span>collector</span><span>.</span><span>fspath</span><span>),</span> <span>name</span><span>)</span>


<span>def</span> <span>cunit</span><span>(</span><span>module</span><span>:</span> <span>str</span><span>,</span> <span>name</span><span>:</span> <span>str</span><span>,</span> <span>full_name</span><span>:</span> <span>str</span><span>):</span>
    <span>def</span> <span>_</span><span>(</span><span>*</span><span>_</span><span>,</span> <span>**</span><span>__</span><span>):</span>
        <span>test</span> <span>=</span> <span>f</span><span>&#34;</span><span>{</span><span>module</span><span>}</span><span>::</span><span>{</span><span>name</span><span>}</span><span>&#34;</span>
        <span>env</span> <span>=</span> <span>os</span><span>.</span><span>environ</span><span>.</span><span>copy</span><span>()</span>
        <span>env</span><span>[</span><span>&#34;PYTEST_CUNIT&#34;</span><span>]</span> <span>=</span> <span>full_name</span>

        <span>result</span> <span>=</span> <span>run</span><span>([</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>0</span><span>],</span> <span>&#34;-svv&#34;</span><span>,</span> <span>test</span><span>],</span> <span>stdout</span><span>=</span><span>PIPE</span><span>,</span> <span>stderr</span><span>=</span><span>PIPE</span><span>,</span> <span>env</span><span>=</span><span>env</span><span>)</span>

        <span>if</span> <span>result</span><span>.</span><span>returncode</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>

        <span>raise</span> <span>CUnitTestFailure</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span> <span>+</span> <span>result</span><span>.</span><span>stdout</span><span>.</span><span>decode</span><span>())</span>

    <span>return</span> <span>_</span>


<span>def</span> <span>pytest_collection_modifyitems</span><span>(</span><span>session</span><span>,</span> <span>config</span><span>,</span> <span>items</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>if</span> <span>test_name</span> <span>:=</span> <span>os</span><span>.</span><span>getenv</span><span>(</span><span>&#34;PYTEST_CUNIT&#34;</span><span>):</span>
        <span># We are inside the sandbox process. We select the only test we care</span>
        <span>items</span><span>[:]</span> <span>=</span> <span>[</span><span>_</span> <span>for</span> <span>_</span> <span>in</span> <span>items</span> <span>if</span> <span>_</span><span>.</span><span>name</span> <span>==</span> <span>test_name</span><span>]</span>
        <span>return</span>

    <span>for</span> <span>item</span> <span>in</span> <span>items</span><span>:</span>
        <span>if</span> <span>hasattr</span><span>(</span><span>item</span><span>.</span><span>_obj</span><span>,</span> <span>&#34;__cunit__&#34;</span><span>):</span>
            <span>item</span><span>.</span><span>_obj</span> <span>=</span> <span>cunit</span><span>(</span><span>*</span><span>item</span><span>.</span><span>_obj</span><span>.</span><span>__cunit__</span><span>,</span> <span>full_name</span><span>=</span><span>item</span><span>.</span><span>name</span><span>)</span>
</pre></div>


<p>Let&#39;s re-run our broken test suite and see what happens this time:</p>
<div><pre><span></span>================================ test session starts =================================
platform linux -- Python 3.10.2, pytest-7.0.0, pluggy-1.0.0 -- /home/gabriele/Projects/cunit/.venv/bin/python3.10
cachedir: .pytest_cache
rootdir: /home/gabriele/Projects/cunit
collected 5 items

tests/cunit/test_cache.py::test_queue_item &lt;- tests/cunit/conftest.py FAILED   [ 20%]
tests/cunit/test_cache.py::test_queue[0] &lt;- tests/cunit/conftest.py PASSED     [ 40%]
tests/cunit/test_cache.py::test_queue[10] &lt;- tests/cunit/conftest.py PASSED    [ 60%]
tests/cunit/test_cache.py::test_queue[100] &lt;- tests/cunit/conftest.py PASSED   [ 80%]
tests/cunit/test_cache.py::test_queue[1000] &lt;- tests/cunit/conftest.py PASSED  [100%]

====================================== FAILURES ======================================
__________________________________ test_queue_item ___________________________________

_ = ()
__ = {&#39;cache&#39;: &lt;CDLL &#39;/home/gabriele/Projects/cunit/src/cache.so&#39;, handle 25c8400 at 0x7efd5b5d83d0&gt;}
test = &#39;/home/gabriele/Projects/cunit/tests/cunit/test_cache.py::test_queue_item&#39;
env = {&#39;ANDROID_HOME&#39;: &#39;/home/gabriele/.android/sdk&#39;, &#39;COLORTERM&#39;: &#39;truecolor&#39;, &#39;DBUS_SESSION_BUS_ADDRESS&#39;: &#39;unix:path=/run/user/1000/bus&#39;, &#39;DEFAULTS_PATH&#39;: &#39;/usr/share/gconf/ubuntu.default.path&#39;, ...}
result = CompletedProcess(args=[&#39;.venv/bin/pytest&#39;, &#39;-svv&#39;, &#39;/home/gabriele/Projects/cunit/tests/cunit/test_cache.py::test_queu...__init__.py&#34;, line 188 in console_main\n  File &#34;/home/gabriele/Projects/cunit/.venv/bin/pytest&#34;, line 8 in &lt;module&gt;\n&#39;)

    def _(*_, **__):
        test = f&#34;{module}::{name}&#34;
        env = os.environ.copy()
        env[&#34;PYTEST_CUNIT&#34;] = full_name

        result = run([sys.argv[0], &#34;-svv&#34;, test], stdout=PIPE, stderr=PIPE, env=env)

        if result.returncode == 0:
            return

&gt;       raise CUnitTestFailure(&#34;\n&#34; + result.stdout.decode())
E       tests.cunit.conftest.CUnitTestFailure: 
E       ============================= test session starts ==============================
E       platform linux -- Python 3.10.2, pytest-7.0.0, pluggy-1.0.0 -- /home/gabriele/Projects/cunit/.venv/bin/python3.10
E       cachedir: .pytest_cache
E       rootdir: /home/gabriele/Projects/cunit
E       collecting ... collected 1 item
E       
E       tests/cunit/test_cache.py::test_queue_item

tests/cunit/conftest.py:49: CUnitTestFailure
============================== short test summary info ===============================
FAILED tests/cunit/test_cache.py::test_queue_item - tests.cunit.conftest.CUnitTestF...
============================ 1 failed, 4 passed in 1.21s =============================
</pre></div>


<p>How do we like this better? Now the first test fails with the segmentation
fault, but the rest of the test suite still runs and we can see the reason of
the failure for the first test in the report, i.e. the segmentation fault.</p>
<p>But what is the <code>conftest.py</code> code actually doing? Let&#39;s have a look. The
<code>pytest_pycollect_makeitem</code> hook gets invoked when the tests inside
<code>tests\cunit</code> are being collected by <code>pytest</code>. At this stage we &#34;mark&#34; them as C
unit tests by giving each collected <code>item</code> the <code>__cunit__</code> attribute. The value
is a tuple containing the information of where the item came from
(<code>collection.fspath</code> is the path of the module that defined the test, e.g.
<code>tests/cunit/test_cache.py</code>) and the test name (e.g. <code>test_queue_item</code>). In our
case we only care about items that are of <code>FunctionType</code> type and that start
with <code>test_</code>. The environment variable <code>PYTEST_CUNIT</code> is used to detect whether
we are running in the parent <code>pytest</code> process or the &#34;sandbox&#34; child. In the
latter case we don&#39;t care of marking tests because we know exactly what we want
to run.</p>
<p>Once all the tests have been collected, we use the
<code>pytest_collection_modifyitems</code> hook to actually modify the tests that we
previously marked as C unit tests. Again, the behaviour depends on whether we
are in the parent <code>pytest</code> process, or in the sandbox. If <code>PYTEST_CUNIT</code> is set,
that&#39;s the signal that we are in the child <code>pytest</code> process. The value, as we
shall see shortly, contains the information needed to pick the test that we want
to run. So we use it to modify the list <code>items</code> to just the test that matches
the information stored in <code>PYTEST_CUNIT</code>. In the parent <code>pytest</code> process we
actually modify what the items that we marked as C unit tests do. Obviously, we
don&#39;t want them to run the actual test, but rather a new instance of <code>pytest</code>
that will then run the test on behalf of the parent process. The magic happens
inside the &#34;decorator&#34; <code>cunit</code>, which we use to build a closure around the test
that we want to run. As you can see, it returns a function (with a bit of a
funny and unusual signature) which, when called, will set the <code>PYTEST_CUNIT</code>
variable with the full name of the test (this is to support parametrised tests)
and then run <code>sys.argv[0]</code> (which should be <code>pytest</code> if we run the test suite
with <code>pytest</code>), followed by the switches <code>-svv</code> and the path of the module that
provides the test we are wrapping around. This way, when the process terminates,
either because the test passed or something really bad happened, we can inspect
the return code and the streams, and act accordingly.</p>
<p>So now we have a test runner that can handle segmentation faults gracefully but
still doesn&#39;t tell us where they actually happened. Can we get some more
detailed information in the output? When a Python test fails we get a nice
traceback that tells us where things went wrong. Can we do the same with C unit
tests? The answer is <strong>yes</strong>, provided we collect core dumps while tests run. If
you are running on Ubuntu, you can do <code>ulimit -c unlimited</code> and a <code>core</code> dump
will be generated in the working directory every time a segmentation fault
occurs. We can then run <code>gdb</code> in batch mode to print a nice traceback that will
hopefully help us investigate the problem. So let&#39;s add these helpers to the
<code>conftest.py</code> file</p>
<div><pre><span></span><span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>
<span>from</span> <span>subprocess</span> <span>import</span> <span>STDOUT</span><span>,</span> <span>check_output</span>


<span>def</span> <span>gdb</span><span>(</span><span>cmds</span><span>:</span> <span>list</span><span>[</span><span>str</span><span>],</span> <span>*</span><span>args</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>return</span> <span>check_output</span><span>(</span>
        <span>[</span><span>&#34;gdb&#34;</span><span>,</span> <span>&#34;-q&#34;</span><span>,</span> <span>&#34;-batch&#34;</span><span>]</span>
        <span>+</span> <span>[</span><span>_</span> <span>for</span> <span>cs</span> <span>in</span> <span>((</span><span>&#34;-ex&#34;</span><span>,</span> <span>_</span><span>)</span> <span>for</span> <span>_</span> <span>in</span> <span>cmds</span><span>)</span> <span>for</span> <span>_</span> <span>in</span> <span>cs</span><span>]</span>
        <span>+</span> <span>list</span><span>(</span><span>args</span><span>),</span>
        <span>stderr</span><span>=</span><span>STDOUT</span><span>,</span>
    <span>)</span><span>.</span><span>decode</span><span>()</span>


<span>def</span> <span>bt</span><span>(</span><span>binary</span><span>:</span> <span>Path</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>if</span> <span>Path</span><span>(</span><span>&#34;core&#34;</span><span>)</span><span>.</span><span>is_file</span><span>():</span>
        <span>return</span> <span>gdb</span><span>([</span><span>&#34;bt full&#34;</span><span>,</span> <span>&#34;q&#34;</span><span>],</span> <span>str</span><span>(</span><span>binary</span><span>),</span> <span>&#34;core&#34;</span><span>)</span>
    <span>return</span> <span>&#34;No core dump available.&#34;</span>
</pre></div>


<p>and improve the <code>cunit</code> decorator like so</p>
<div><pre><span></span><span>from</span> <span>tests.cunit</span> <span>import</span> <span>SRC</span>


<span>def</span> <span>cunit</span><span>(</span><span>module</span><span>:</span> <span>str</span><span>,</span> <span>name</span><span>:</span> <span>str</span><span>,</span> <span>full_name</span><span>:</span> <span>str</span><span>):</span>
    <span>def</span> <span>_</span><span>(</span><span>*</span><span>_</span><span>,</span> <span>**</span><span>__</span><span>):</span>
        <span>test</span> <span>=</span> <span>f</span><span>&#34;</span><span>{</span><span>module</span><span>}</span><span>::</span><span>{</span><span>name</span><span>}</span><span>&#34;</span>
        <span>env</span> <span>=</span> <span>os</span><span>.</span><span>environ</span><span>.</span><span>copy</span><span>()</span>
        <span>env</span><span>[</span><span>&#34;PYTEST_CUNIT&#34;</span><span>]</span> <span>=</span> <span>full_name</span>

        <span>result</span> <span>=</span> <span>run</span><span>([</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>0</span><span>],</span> <span>&#34;-svv&#34;</span><span>,</span> <span>test</span><span>],</span> <span>stdout</span><span>=</span><span>PIPE</span><span>,</span> <span>stderr</span><span>=</span><span>PIPE</span><span>,</span> <span>env</span><span>=</span><span>env</span><span>)</span>

        <span>match</span> <span>result</span><span>.</span><span>returncode</span><span>:</span>
            <span>case</span> <span>0</span><span>:</span>
                <span>return</span>

            <span>case</span> <span>-</span><span>11</span><span>:</span>
                <span>binary_name</span> <span>=</span> <span>Path</span><span>(</span><span>module</span><span>)</span><span>.</span><span>stem</span><span>.</span><span>replace</span><span>(</span><span>&#34;test_&#34;</span><span>,</span> <span>&#34;&#34;</span><span>)</span>
                <span>raise</span> <span>SegmentationFault</span><span>(</span><span>bt</span><span>((</span><span>SRC</span> <span>/</span> <span>binary_name</span><span>)</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>)))</span>

        <span>raise</span> <span>CUnitTestFailure</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span> <span>+</span> <span>result</span><span>.</span><span>stdout</span><span>.</span><span>decode</span><span>())</span>

    <span>return</span> <span>_</span>
</pre></div>


<p>Now, when we run our broken test suite we should get this more verbose output</p>
<div><pre><span></span>================================ test session starts =================================
platform linux -- Python 3.10.2, pytest-7.0.0, pluggy-1.0.0 -- /home/gabriele/Projects/cunit/.venv/bin/python3.10
cachedir: .pytest_cache
rootdir: /home/gabriele/Projects/cunit
collected 5 items

tests/cunit/test_cache.py::test_queue_item &lt;- tests/cunit/conftest.py FAILED   [ 20%]
tests/cunit/test_cache.py::test_queue[0] &lt;- tests/cunit/conftest.py PASSED     [ 40%]
tests/cunit/test_cache.py::test_queue[10] &lt;- tests/cunit/conftest.py PASSED    [ 60%]
tests/cunit/test_cache.py::test_queue[100] &lt;- tests/cunit/conftest.py PASSED   [ 80%]
tests/cunit/test_cache.py::test_queue[1000] &lt;- tests/cunit/conftest.py PASSED  [100%]

====================================== FAILURES ======================================
__________________________________ test_queue_item ___________________________________

_ = ()
__ = {&#39;cache&#39;: &lt;CDLL &#39;/home/gabriele/Projects/cunit/src/cache.so&#39;, handle fc4ba0 at 0x7f5ec8d50460&gt;}
test = &#39;/home/gabriele/Projects/cunit/tests/cunit/test_cache.py::test_queue_item&#39;
env = {&#39;ANDROID_HOME&#39;: &#39;/home/gabriele/.android/sdk&#39;, &#39;COLORTERM&#39;: &#39;truecolor&#39;, &#39;DBUS_SESSION_BUS_ADDRESS&#39;: &#39;unix:path=/run/user/1000/bus&#39;, &#39;DEFAULTS_PATH&#39;: &#39;/usr/share/gconf/ubuntu.default.path&#39;, ...}
result = CompletedProcess(args=[&#39;.venv/bin/pytest&#39;, &#39;-svv&#39;, &#39;/home/gabriele/Projects/cunit/tests/cunit/test_cache.py::test_queu...__init__.py&#34;, line 188 in console_main\n  File &#34;/home/gabriele/Projects/cunit/.venv/bin/pytest&#34;, line 8 in &lt;module&gt;\n&#39;)
binary_name = &#39;cache&#39;

    def _(*_, **__):
        test = f&#34;{module}::{name}&#34;
        env = os.environ.copy()
        env[&#34;PYTEST_CUNIT&#34;] = full_name

        result = run([sys.argv[0], &#34;-svv&#34;, test], stdout=PIPE, stderr=PIPE, env=env)

        match result.returncode:
            case 0:
                return

            case -11:
                binary_name = Path(module).stem.replace(&#34;test_&#34;, &#34;&#34;)
&gt;               raise SegmentationFault(bt((SRC / binary_name).with_suffix(&#34;.so&#34;)))
E               tests.cunit.conftest.SegmentationFault: 
E               warning: core file may not match specified executable file.
E               [New LWP 548824]
E               [Thread debugging using libthread_db enabled]
E               Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.
E               Core was generated by `/home/gabriele/Projects/cunit/.venv/bin/python3.10 .venv/bin/pytest -svv /home/&#39;.
E               Program terminated with signal SIGSEGV, Segmentation fault.
E               #0  raise (sig=&lt;optimised out&gt;) at ../sysdeps/unix/sysv/linux/raise.c:50
E               50  ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
E               #0  raise (sig=&lt;optimised out&gt;) at ../sysdeps/unix/sysv/linux/raise.c:50
E                       set = {
E                         __val = {[0] = 0, [1] = 1, [2] = 3, [3] = 140049677169600, [4] = 8, [5] = 4714713, [6] = 140049688588951, [7] = 140049678146624, [8] = 3, [9] = 5586517, [10] = 17917168, [11] = 3, [12] = 3, [13] = 140049678074368, [14] = 140049678074368, [15] = 4663610}
E                       }
E                       pid = &lt;optimised out&gt;
E                       tid = &lt;optimised out&gt;
E                       ret = &lt;optimised out&gt;
E               #1  &lt;signal handler called&gt;
E               No locals.
E               #2  __GI___libc_free (mem=0x1) at malloc.c:3102
E                       ar_ptr = &lt;optimised out&gt;
E                       p = &lt;optimised out&gt;
E                       hook = 0x0
E               #3  0x00007f5fdbf1b40a in queue_item.destroy () from /home/gabriele/Projects/cunit/src/cache.so
E               No symbol table info available.
E               #4  0x00007f5fdb188ff5 in ?? () from /usr/lib/x86_64-linux-gnu/libffi.so.7
E               No symbol table info available.
E               #5  0x00007f5fdb18840a in ?? () from /usr/lib/x86_64-linux-gnu/libffi.so.7
E               No symbol table info available.
E               #6  0x00007f5fdb1a2286 in ?? () from /usr/lib/python3.10/lib-dynload/_ctypes.cpython-310-x86_64-linux-gnu.so
E               No symbol table info available.
E               #7  0x00007f5fdb196eba in ?? () from /usr/lib/python3.10/lib-dynload/_ctypes.cpython-310-x86_64-linux-gnu.so
E               No symbol table info available.
E               #8  0x0000000000512f83 in ?? ()
E               No symbol table info available.
E               #9  0x00007f5fda9fd160 in ?? ()
E               No symbol table info available.
E               #10 0x00007f5fdb1a12d0 in ?? () from /usr/lib/python3.10/lib-dynload/_ctypes.cpython-310-x86_64-linux-gnu.so
E               No symbol table info available.
E               #11 0x00007f5fdaa1b658 in ?? ()
E               No symbol table info available.
E               #12 0x00007f5fda9f9690 in ?? ()
E               No symbol table info available.
E               #13 0x00007f5fdabd1f20 in ?? ()
E               No symbol table info available.
E               #14 0x00007f5fdaa1b680 in ?? ()
E               No symbol table info available.
E               #15 0x00000000011325a0 in ?? ()
E               No symbol table info available.
E               #16 0x00007f5fda9f214a in ?? ()
E               No symbol table info available.
E               #17 0x00007f5fdaa1b820 in ?? ()
E               No symbol table info available.
E               #18 0x00007f5fda9f20f0 in ?? ()
E               No symbol table info available.
E               #19 0x00007f5fda9fd160 in ?? ()
E               No symbol table info available.
E               #20 0x000000000057b1ec in ?? ()
E               No symbol table info available.
E               #21 0x59586f2afaac8ab6 in ?? ()
E               No symbol table info available.
E               #22 0x00007f5fdaa1b7e0 in ?? ()
E               No symbol table info available.
E               #23 0x0000000001116534 in ?? ()
E               No symbol table info available.
E               #24 0x00007f5fda9d50c0 in ?? ()
E               No symbol table info available.
E               #25 0x00007f5fdaa1b808 in ?? ()
E               No symbol table info available.
E               #26 0x8000000000000002 in ?? ()
E               No symbol table info available.
E               #27 0x00007f5fda949480 in ?? ()
E               No symbol table info available.
E               #28 0x00007f5fdaa1b810 in ?? ()
E               No symbol table info available.
E               #29 0x00007f5fda96aec0 in ?? ()
E               No symbol table info available.
E               #30 0x00007f5fdaa1b800 in ?? ()
E               No symbol table info available.
E               #31 0x00000000011164f0 in ?? ()
E               No symbol table info available.
E               #32 0x0000000000575f1d in ?? ()
E               No symbol table info available.
E               #33 0x42439dfdd749cffb in ?? ()
E               No symbol table info available.
E               #34 0x00007f5fdaa1b620 in ?? ()
E               No symbol table info available.
E               #35 0x0000000001116534 in ?? ()
E               No symbol table info available.
E               #36 0x00007f5fdb4ec070 in ?? ()
E               No symbol table info available.
E               #37 0x00007f5fda9fbb80 in ?? ()
E               No symbol table info available.
E               #38 0x0000000000000000 in ?? ()
E               No symbol table info available.

tests/cunit/conftest.py:56: SegmentationFault
============================== short test summary info ===============================
FAILED tests/cunit/test_cache.py::test_queue_item - tests.cunit.conftest.Segmentati...
============================ 1 failed, 4 passed in 1.73s =============================
</pre></div>


<p>Hmm, Still not that useful. What if we compile with debug symbols? Let&#39;s change
the <code>cache</code> fixture in <code>test_cache.py</code> so that it compiles the caching sources
with the <code>-g</code> option</p>
<div><pre><span></span><span>@pytest</span><span>.</span><span>fixture</span>
<span>def</span> <span>cache</span><span>():</span>
    <span>source</span> <span>=</span> <span>SRC</span> <span>/</span> <span>&#34;cache.c&#34;</span>
    <span>compile</span><span>(</span><span>source</span><span>,</span> <span>cflags</span><span>=</span><span>[</span><span>&#34;-g&#34;</span><span>])</span>
    <span>yield</span> <span>CDLL</span><span>(</span><span>str</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>)))</span>
</pre></div>


<p>Now that&#39;s much, <em>much</em> better!</p>
<div><pre><span></span>E               #3  0x00007ff51cf8b40a in queue_item__destroy (self=0x104ac60, deallocator=0x7ff51cc68850 &lt;__GI___libc_free&gt;) at /home/gabriele/Projects/cunit/src/cache.c:37
</pre></div>


<p>This tells us <em>exactly</em> where the problem occurred. Now that we have this
information we can fix the test and make the test suite happy again! üéâ</p>

<p>OK, running C unit tests is nice and fun, but it doesn&#39;t save us much in terms
of typing. In fact, the tests we wrote so far not only feel quite verbose,
considering we are writing Python code, but don&#39;t feel Pythonic at all. Whilst
there is, in principle, no reason why non-Python tests written in Python should
look and feel Pythonic, can we somehow do something perhaps more elegant? The
idea of using a fixture to wrap around a binary object is perhaps interesting,
but can we maybe pretend that <code>cache</code> is a Python module instead so that we can
do things like <code>from cache import queue_item_new</code> etc... and sweep all this
<code>ctypes</code> business under the carpet? Well, let&#39;s give this a try, shall we?</p>
<p>Back in <code>tests/cunit/__init__.py</code>, let&#39;s add the following subtype of
<code>ModuleType</code>:</p>
<div><pre><span></span><span>from</span> <span>ctypes</span> <span>import</span> <span>CDLL</span>
<span>from</span> <span>types</span> <span>import</span> <span>ModuleType</span>


<span>class</span> <span>CModule</span><span>(</span><span>ModuleType</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>source</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>source</span><span>.</span><span>name</span><span>,</span> <span>f</span><span>&#34;Generated from </span><span>{</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#39;.c&#39;</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
        <span>self</span><span>.</span><span>__binary__</span> <span>=</span> <span>CDLL</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>))</span>
        <span>print</span><span>(</span><span>self</span><span>.</span><span>__binary__</span><span>.</span><span>__dict__</span><span>)</span>

    <span>def</span> <span>__getattr__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>):</span>
        <span>return</span> <span>getattr</span><span>(</span><span>self</span><span>.</span><span>__binary__</span><span>,</span> <span>name</span><span>)</span>

    <span>@classmethod</span>
    <span>def</span> <span>compile</span><span>(</span><span>cls</span><span>,</span> <span>source</span><span>,</span> <span>cflags</span><span>=</span><span>[],</span> <span>ldadd</span><span>=</span><span>[]):</span>
        <span>compile</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.c&#34;</span><span>),</span> <span>cflags</span><span>,</span> <span>ldadd</span><span>)</span>
        <span>return</span> <span>cls</span><span>(</span><span>source</span><span>)</span>
</pre></div>


<p>Now create <code>tests/cunit/cache.py</code> with the following content</p>
<div><pre><span></span><span>import</span> <span>sys</span>
<span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>

<span>from</span> <span>tests.cunit</span> <span>import</span> <span>SRC</span><span>,</span> <span>CModule</span>

<span>CFLAGS</span> <span>=</span> <span>[</span><span>&#34;-g&#34;</span><span>]</span>

<span>sys</span><span>.</span><span>modules</span><span>[</span><span>__name__</span><span>]</span> <span>=</span> <span>CModule</span><span>.</span><span>compile</span><span>(</span><span>SRC</span> <span>/</span> <span>Path</span><span>(</span><span>__file__</span><span>)</span><span>.</span><span>stem</span><span>,</span> <span>cflags</span><span>=</span><span>CFLAGS</span><span>)</span>
</pre></div>


<p>and get rid of the <code>cache</code> fixture in <code>test_cache.py</code> (make sure to remove it
also from the test arguments!). Instead, add</p>
<div><pre><span></span><span>import</span> <span>tests.cunit.cache</span> <span>as</span> <span>cache</span>
</pre></div>


<p><em>et voil√†</em>! Now <code>cache</code> feels like a Python module that exports ordinary
functions that we can call like any other Python function.</p>
<p>Now, what about this code</p>
<div><pre><span></span><span>def</span> <span>test_queue_item</span><span>():</span>
    <span>value</span> <span>=</span> <span>C</span><span>.</span><span>malloc</span><span>(</span><span>16</span><span>)</span>
    <span>queue_item</span> <span>=</span> <span>cache</span><span>.</span><span>queue_item_new</span><span>(</span><span>value</span><span>,</span> <span>42</span><span>)</span>
    <span>assert</span> <span>queue_item</span>

    <span>cache</span><span>.</span><span>queue_item__destroy</span><span>(</span><span>queue_item</span><span>,</span> <span>C</span><span>.</span><span>free</span><span>)</span>
</pre></div>


<p>Clearly <code>cache.queue_item_new</code> is creating a new object. The Pythonic way of
writing something like this would be</p>
<div><pre><span></span><span>def</span> <span>test_queue_item</span><span>():</span>
    <span>value</span> <span>=</span> <span>C</span><span>.</span><span>malloc</span><span>(</span><span>16</span><span>)</span>
    <span>queue_item</span> <span>=</span> <span>cache</span><span>.</span><span>QueueItem</span><span>(</span><span>value</span><span>,</span> <span>42</span><span>)</span>
    <span>assert</span> <span>queue_item</span>
</pre></div>


<p>and we don&#39;t even care about destroying the object as we&#39;d love the garbage
collector to take care of that for us. Now that&#39;s a more Pythonic way of going
about our C unit tests! Can we achieve something like this? The answer is once
again <em>yes</em>, but ... we can make this work provided we make some further
assumptions, like some naming conventions. You might have noticed that the data
structures defined in <code>cache.h</code> have the naming <code>&lt;adt&gt;_t</code>, in an OOP flavour.
Methods follow the naming convention <code>&lt;adt&gt;_&lt;staticmethod&gt;</code> and
<code>&lt;adt&gt;__&lt;emethod&gt;</code>. Some of the methods have <em>special</em> names, like <code>&lt;adt&gt;_new</code>,
<code>&lt;adt&gt;__destroy</code> etc.... So, provided we adhere to <em>some</em> naming conventions,
like this one, we could dynamically create Python types at runtime. How? With
the secret art of <a href="https://realpython.com/python-metaclasses/">metaprogramming</a>. But before we can start
creating new types at runtime, we need to be able to parse C header files to
infer their definitions. That&#39;s why our next step is to add <code>pycparser</code> to our
test dependencies and implement a C AST visitor that can collect all the
relevant type and method declarations that we can use to build the spec for
Python types. Here is what it might look like</p>
<div><pre><span></span><span>from</span> <span>ctypes</span> <span>import</span> <span>c_char_p</span>

<span>from</span> <span>pycparser</span> <span>import</span> <span>c_ast</span><span>,</span> <span>c_parser</span>
<span>from</span> <span>pycparser.plyparser</span> <span>import</span> <span>ParseError</span>

<span>class</span> <span>DeclCollector</span><span>(</span><span>c_ast</span><span>.</span><span>NodeVisitor</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>types</span> <span>=</span> <span>{}</span>
        <span>self</span><span>.</span><span>functions</span> <span>=</span> <span>[]</span>

    <span>def</span> <span>_get_type</span><span>(</span><span>self</span><span>,</span> <span>node</span><span>):</span>
        <span>print</span><span>(</span><span>node</span><span>)</span>
        <span>return</span> <span>self</span><span>.</span><span>types</span><span>[</span><span>&#34; &#34;</span><span>.</span><span>join</span><span>(</span><span>node</span><span>.</span><span>type</span><span>.</span><span>type</span><span>.</span><span>names</span><span>)]</span>

    <span>def</span> <span>visit_Typedef</span><span>(</span><span>self</span><span>,</span> <span>node</span><span>):</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>node</span><span>.</span><span>type</span><span>.</span><span>type</span><span>,</span> <span>c_ast</span><span>.</span><span>Struct</span><span>)</span> <span>and</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>declname</span><span>.</span><span>endswith</span><span>(</span>
            <span>&#34;_t&#34;</span>
        <span>):</span>
            <span>struct</span> <span>=</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>type</span>
            <span>self</span><span>.</span><span>types</span><span>[</span><span>node</span><span>.</span><span>type</span><span>.</span><span>declname</span><span>[:</span><span>-</span><span>2</span><span>]]</span> <span>=</span> <span>CTypeDef</span><span>(</span>
                <span>node</span><span>.</span><span>type</span><span>.</span><span>declname</span><span>,</span>
                <span>[</span><span>decl</span><span>.</span><span>name</span> <span>for</span> <span>decl</span> <span>in</span> <span>struct</span><span>.</span><span>decls</span><span>],</span>
            <span>)</span>

    <span>def</span> <span>visit_Decl</span><span>(</span><span>self</span><span>,</span> <span>node</span><span>):</span>
        <span>if</span> <span>&#34;extern&#34;</span> <span>in</span> <span>node</span><span>.</span><span>storage</span><span>:</span>
            <span>return</span>

        <span>if</span> <span>isinstance</span><span>(</span><span>node</span><span>.</span><span>type</span><span>,</span> <span>c_ast</span><span>.</span><span>FuncDecl</span><span>):</span>
            <span>func_name</span> <span>=</span> <span>node</span><span>.</span><span>name</span>
            <span>ret_type</span> <span>=</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>type</span>
            <span>rtype</span> <span>=</span> <span>None</span>
            <span>if</span> <span>isinstance</span><span>(</span><span>ret_type</span><span>,</span> <span>c_ast</span><span>.</span><span>PtrDecl</span><span>):</span>
                <span>if</span> <span>&#34;&#34;</span><span>.</span><span>join</span><span>(</span><span>ret_type</span><span>.</span><span>type</span><span>.</span><span>type</span><span>.</span><span>names</span><span>)</span> <span>==</span> <span>&#34;char&#34;</span><span>:</span>
                    <span>rtype</span> <span>=</span> <span>c_char_p</span>
            <span>args</span> <span>=</span> <span>(</span>
                <span>[</span><span>_</span><span>.</span><span>name</span> <span>if</span> <span>hasattr</span><span>(</span><span>_</span><span>,</span> <span>&#34;name&#34;</span><span>)</span> <span>else</span> <span>None</span> <span>for</span> <span>_</span> <span>in</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>args</span><span>.</span><span>params</span><span>]</span>
                <span>if</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>args</span> <span>is</span> <span>not</span> <span>None</span>
                <span>else</span> <span>[]</span>
            <span>)</span>
            <span>if</span> <span>func_name</span><span>.</span><span>endswith</span><span>(</span><span>&#34;_new&#34;</span><span>):</span>
                <span>self</span><span>.</span><span>types</span><span>[</span><span>f</span><span>&#34;</span><span>{</span><span>func_name</span><span>[:</span><span>-</span><span>4</span><span>]</span><span>}</span><span>&#34;</span><span>]</span><span>.</span><span>constructor</span> <span>=</span> <span>CFunctionDef</span><span>(</span>
                    <span>&#34;new&#34;</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span>
                <span>)</span>
            <span>elif</span> <span>&#34;__&#34;</span> <span>in</span> <span>func_name</span><span>:</span>
                <span>type_name</span><span>,</span> <span>_</span><span>,</span> <span>method_name</span> <span>=</span> <span>func_name</span><span>.</span><span>partition</span><span>(</span><span>&#34;__&#34;</span><span>)</span>
                <span>if</span> <span>not</span> <span>type_name</span><span>:</span>
                    <span>return</span>
                <span>self</span><span>.</span><span>types</span><span>[</span><span>type_name</span><span>]</span><span>.</span><span>methods</span><span>.</span><span>append</span><span>(</span>
                    <span>CFunctionDef</span><span>(</span><span>method_name</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span><span>)</span>
                <span>)</span>
            <span>else</span><span>:</span>
                <span>self</span><span>.</span><span>functions</span><span>.</span><span>append</span><span>(</span><span>CFunctionDef</span><span>(</span><span>func_name</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span><span>))</span>

    <span>def</span> <span>collect</span><span>(</span><span>self</span><span>,</span> <span>decl</span><span>):</span>
        <span>parser</span> <span>=</span> <span>c_parser</span><span>.</span><span>CParser</span><span>()</span>
        <span>try</span><span>:</span>
            <span>ast</span> <span>=</span> <span>parser</span><span>.</span><span>parse</span><span>(</span><span>decl</span><span>,</span> <span>filename</span><span>=</span><span>&#34;&lt;preprocessed&gt;&#34;</span><span>)</span>
        <span>except</span> <span>ParseError</span> <span>as</span> <span>e</span><span>:</span>
            <span>lines</span> <span>=</span> <span>decl</span><span>.</span><span>splitlines</span><span>()</span>
            <span>line</span><span>,</span> <span>col</span> <span>=</span> <span>(</span>
                <span>int</span><span>(</span><span>_</span><span>)</span> <span>-</span> <span>1</span> <span>for</span> <span>_</span> <span>in</span> <span>e</span><span>.</span><span>args</span><span>[</span><span>0</span><span>]</span><span>.</span><span>partition</span><span>(</span><span>&#34; &#34;</span><span>)[</span><span>0</span><span>]</span><span>.</span><span>split</span><span>(</span><span>&#34;:&#34;</span><span>)[</span><span>1</span><span>:</span><span>3</span><span>]</span>
            <span>)</span>
            <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>max</span><span>(</span><span>0</span><span>,</span> <span>line</span> <span>-</span> <span>4</span><span>),</span> <span>min</span><span>(</span><span>line</span> <span>+</span> <span>5</span><span>,</span> <span>len</span><span>(</span><span>lines</span><span>))):</span>
                <span>if</span> <span>i</span> <span>!=</span> <span>line</span><span>:</span>
                    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>i</span><span>+</span><span>1</span><span>:</span><span>5d</span><span>}</span><span>  </span><span>{</span><span>lines</span><span>[</span><span>i</span><span>]</span><span>}</span><span>&#34;</span><span>)</span>
                <span>else</span><span>:</span>
                    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>i</span><span>+</span><span>1</span><span>:</span><span>5d</span><span>}</span><span>  </span><span>\033</span><span>[33;1m</span><span>{</span><span>lines</span><span>[</span><span>line</span><span>]</span><span>}</span><span>\033</span><span>[0m&#34;</span><span>)</span>
                    <span>print</span><span>(</span><span>&#34; &#34;</span> <span>*</span> <span>(</span><span>col</span> <span>+</span> <span>5</span><span>)</span> <span>+</span> <span>&#34;</span><span>\033</span><span>[31;1m&lt;&lt;^</span><span>\033</span><span>[0m&#34;</span><span>)</span>
            <span>raise</span>

        <span>self</span><span>.</span><span>visit</span><span>(</span><span>ast</span><span>)</span>
        <span>return</span> <span>{</span>
            <span>k</span><span>:</span> <span>v</span>
            <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>self</span><span>.</span><span>types</span><span>.</span><span>items</span><span>()</span>
            <span>if</span> <span>isinstance</span><span>(</span><span>v</span><span>,</span> <span>CTypeDef</span><span>)</span> <span>and</span> <span>v</span><span>.</span><span>constructor</span>
        <span>}</span>
</pre></div>


<p>This is also a handful, but the behaviour is very simple. We define an AST
visitor that listens to <code>typedef</code>s and declarations. For the former, we single
out structure declarations and store the relevant information inside an
instance of the custom <code>CTypeDef</code> dataclass; as for the latter, we only trap
function declaration (plus a special handling for those functions that return
<code>char *</code>). The two intermediate dataclasses <code>CTypeDef</code> and <code>CFunctionDef</code> are
merely defined as (up to you to use the more elegant <code>@dataclass</code> decorator)</p>
<div><pre><span></span><span>class</span> <span>CFunctionDef</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>self</span><span>.</span><span>args</span> <span>=</span> <span>args</span>
        <span>self</span><span>.</span><span>rtype</span> <span>=</span> <span>rtype</span>


<span>class</span> <span>CTypeDef</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>fields</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>self</span><span>.</span><span>fields</span> <span>=</span> <span>fields</span>
        <span>self</span><span>.</span><span>methods</span> <span>=</span> <span>[]</span>
        <span>self</span><span>.</span><span>constructor</span> <span>=</span> <span>False</span>
</pre></div>


<p>Armed with these definitions we can enhance our <code>CModule</code> class like so</p>
<div><pre><span></span><span>class</span> <span>CModule</span><span>(</span><span>ModuleType</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>source</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>source</span><span>.</span><span>name</span><span>,</span> <span>f</span><span>&#34;Generated from </span><span>{</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#39;.c&#39;</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
        <span>self</span><span>.</span><span>__binary__</span> <span>=</span> <span>CDLL</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>))</span>

        <span>collector</span> <span>=</span> <span>DeclCollector</span><span>()</span>

        <span>for</span> <span>name</span><span>,</span> <span>ctypedef</span> <span>in</span> <span>collector</span><span>.</span><span>collect</span><span>(</span>
            <span>preprocess</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.h&#34;</span><span>))</span>
        <span>)</span><span>.</span><span>items</span><span>():</span>
            <span>parts</span> <span>=</span> <span>name</span><span>.</span><span>split</span><span>(</span><span>&#34;_&#34;</span><span>)</span>
            <span>py_name</span> <span>=</span> <span>&#34;&#34;</span><span>.</span><span>join</span><span>((</span><span>_</span><span>.</span><span>capitalize</span><span>()</span> <span>for</span> <span>_</span> <span>in</span> <span>parts</span><span>))</span>
            <span>setattr</span><span>(</span><span>self</span><span>,</span> <span>py_name</span><span>,</span> <span>CMetaType</span><span>(</span><span>self</span><span>,</span> <span>ctypedef</span><span>,</span> <span>None</span><span>))</span>

        <span>for</span> <span>cfuncdef</span> <span>in</span> <span>collector</span><span>.</span><span>functions</span><span>:</span>
            <span>name</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>name</span>
            <span>try</span><span>:</span>
                <span>cfunc</span> <span>=</span> <span>CFunction</span><span>(</span><span>cfuncdef</span><span>,</span> <span>getattr</span><span>(</span><span>self</span><span>.</span><span>__binary__</span><span>,</span> <span>name</span><span>))</span>
                <span>setattr</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>cfunc</span><span>)</span>
            <span>except</span> <span>AttributeError</span><span>:</span>
                <span># Not part of the binary</span>
                <span>pass</span>

    <span>@classmethod</span>
    <span>def</span> <span>compile</span><span>(</span><span>cls</span><span>,</span> <span>source</span><span>,</span> <span>cflags</span><span>=</span><span>[],</span> <span>ldadd</span><span>=</span><span>[]):</span>
        <span>compile</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.c&#34;</span><span>),</span> <span>cflags</span><span>,</span> <span>ldadd</span><span>)</span>
        <span>return</span> <span>cls</span><span>(</span><span>source</span><span>)</span>
</pre></div>


<p>That is, we add the collected types and functions as attributes to the C module.
This is the C type metaclass that we use as a C type factory</p>
<div><pre><span></span><span>class</span> <span>CMetaType</span><span>(</span><span>type</span><span>(</span><span>Structure</span><span>)):</span>
    <span>def</span> <span>__new__</span><span>(</span><span>cls</span><span>,</span> <span>cmodule</span><span>,</span> <span>ctypedef</span><span>,</span> <span>_</span><span>=</span><span>None</span><span>):</span>
        <span>ctype</span> <span>=</span> <span>super</span><span>()</span><span>.</span><span>__new__</span><span>(</span>
            <span>cls</span><span>,</span>
            <span>ctypedef</span><span>.</span><span>name</span><span>,</span>
            <span>(</span><span>CType</span><span>,),</span>
            <span>{</span><span>&#34;__cmodule__&#34;</span><span>:</span> <span>cmodule</span><span>},</span>
        <span>)</span>

        <span>constructor</span> <span>=</span> <span>getattr</span><span>(</span><span>cmodule</span><span>.</span><span>__binary__</span><span>,</span> <span>f</span><span>&#34;</span><span>{</span><span>ctypedef</span><span>.</span><span>name</span><span>[:</span><span>-</span><span>2</span><span>]</span><span>}</span><span>_new&#34;</span><span>)</span>
        <span>ctype</span><span>.</span><span>new</span> <span>=</span> <span>CStaticMethod</span><span>(</span><span>ctypedef</span><span>.</span><span>constructor</span><span>,</span> <span>constructor</span><span>,</span> <span>ctype</span><span>)</span>

        <span>for</span> <span>method_def</span> <span>in</span> <span>ctypedef</span><span>.</span><span>methods</span><span>:</span>
            <span>method_name</span> <span>=</span> <span>method_def</span><span>.</span><span>name</span>
            <span>method</span> <span>=</span> <span>getattr</span><span>(</span><span>cmodule</span><span>.</span><span>__binary__</span><span>,</span> <span>f</span><span>&#34;</span><span>{</span><span>ctypedef</span><span>.</span><span>name</span><span>[:</span><span>-</span><span>2</span><span>]</span><span>}</span><span>__</span><span>{</span><span>method_name</span><span>}</span><span>&#34;</span><span>)</span>
            <span>setattr</span><span>(</span><span>ctype</span><span>,</span> <span>method_name</span><span>,</span> <span>CMethod</span><span>(</span><span>method_def</span><span>,</span> <span>method</span><span>,</span> <span>ctype</span><span>))</span>

        <span>ctype</span><span>.</span><span>__cname__</span> <span>=</span> <span>ctypedef</span><span>.</span><span>name</span>

        <span>return</span> <span>ctype</span>
</pre></div>


<p>This is responsible for creating a new C type as a Python type, with all the
methods added as appropriate instances of wrappers around the C functions (note
the special handling of the <code>_new</code> method!):</p>
<div><pre><span></span><span>class</span> <span>CFunction</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>cfuncdef</span><span>,</span> <span>cfunc</span><span>):</span>
        <span>self</span><span>.</span><span>__name__</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>name</span>
        <span>self</span><span>.</span><span>__args__</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>args</span>
        <span>self</span><span>.</span><span>__cfunc__</span> <span>=</span> <span>cfunc</span>
        <span>if</span> <span>cfuncdef</span><span>.</span><span>rtype</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>__cfunc__</span><span>.</span><span>restype</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>rtype</span>

        <span>self</span><span>.</span><span>_posonly</span> <span>=</span> <span>all</span><span>(</span><span>_</span> <span>is</span> <span>None</span> <span>for</span> <span>_</span> <span>in</span> <span>self</span><span>.</span><span>__args__</span><span>)</span>

    <span>def</span> <span>check_args</span><span>(</span><span>self</span><span>,</span> <span>args</span><span>,</span> <span>kwargs</span><span>):</span>
        <span>if</span> <span>self</span><span>.</span><span>_posonly</span> <span>and</span> <span>kwargs</span><span>:</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>self</span><span>}</span><span> takes only positional arguments&#34;</span><span>)</span>

        <span>nargs</span> <span>=</span> <span>len</span><span>(</span><span>args</span><span>)</span> <span>+</span> <span>len</span><span>(</span><span>kwargs</span><span>)</span>
        <span>if</span> <span>nargs</span> <span>!=</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>__args__</span><span>):</span>
            <span>raise</span> <span>TypeError</span><span>(</span>
                <span>f</span><span>&#34;</span><span>{</span><span>self</span><span>}</span><span> takes exactly </span><span>{</span><span>len</span><span>(</span><span>self</span><span>.</span><span>__args__</span><span>)</span><span>}</span><span> arguments (</span><span>{</span><span>nargs</span><span>}</span><span> given)&#34;</span>
            <span>)</span>

    <span>def</span> <span>__call__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>check_args</span><span>(</span><span>args</span><span>,</span> <span>kwargs</span><span>)</span>
        <span>return</span> <span>self</span><span>.</span><span>__cfunc__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;CFunction &#39;</span><span>{</span><span>self</span><span>.</span><span>__name__</span><span>}</span><span>&#39;&gt;&#34;</span>


<span>class</span> <span>CMethod</span><span>(</span><span>CFunction</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>cfuncdef</span><span>,</span> <span>cfunc</span><span>,</span> <span>ctype</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>cfuncdef</span><span>,</span> <span>cfunc</span><span>)</span>
        <span>self</span><span>.</span><span>__ctype__</span> <span>=</span> <span>ctype</span>

    <span>def</span> <span>__get__</span><span>(</span><span>self</span><span>,</span> <span>obj</span><span>,</span> <span>objtype</span><span>=</span><span>None</span><span>):</span>
        <span>def</span> <span>_</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
            <span>cargs</span> <span>=</span> <span>[</span><span>obj</span><span>.</span><span>__cself__</span><span>,</span> <span>*</span><span>args</span><span>]</span>
            <span>self</span><span>.</span><span>check_args</span><span>(</span><span>cargs</span><span>,</span> <span>kwargs</span><span>)</span>

            <span>return</span> <span>self</span><span>.</span><span>__cfunc__</span><span>(</span><span>*</span><span>cargs</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>

        <span>_</span><span>.</span><span>__cmethod__</span> <span>=</span> <span>self</span>

        <span>return</span> <span>_</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;CMethod &#39;</span><span>{</span><span>self</span><span>.</span><span>__name__</span><span>}</span><span>&#39; of CType &#39;</span><span>{</span><span>self</span><span>.</span><span>__ctype__</span><span>.</span><span>__name__</span><span>}</span><span>&#39;&gt;&#34;</span>


<span>class</span> <span>CStaticMethod</span><span>(</span><span>CFunction</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>cfuncdef</span><span>,</span> <span>cfunc</span><span>,</span> <span>ctype</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>cfuncdef</span><span>,</span> <span>cfunc</span><span>)</span>
        <span>self</span><span>.</span><span>__ctype__</span> <span>=</span> <span>ctype</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;CStaticMethod &#39;</span><span>{</span><span>self</span><span>.</span><span>__name__</span><span>}</span><span>&#39; of CType &#39;</span><span>{</span><span>self</span><span>.</span><span>__ctype__</span><span>.</span><span>__name__</span><span>}</span><span>&#39;&gt;&#34;</span>
</pre></div>


<p>The <code>CType</code> class implementation tries to mimic the behaviour of Python classes,
with <code>__cself__</code> playing the role of the C analogue of <code>self</code>:</p>
<div><pre><span></span><span>class</span> <span>CType</span><span>(</span><span>Structure</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>__cself__</span> <span>=</span> <span>self</span><span>.</span><span>new</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>

    <span>def</span> <span>__del__</span><span>(</span><span>self</span><span>):</span>
        <span>if</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>destroy</span><span>.</span><span>__cmethod__</span><span>.</span><span>__args__</span><span>)</span> <span>==</span> <span>1</span><span>:</span>
            <span>self</span><span>.</span><span>destroy</span><span>()</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;</span><span>{</span><span>self</span><span>.</span><span>name</span><span>}</span><span> CObject at </span><span>{</span><span>self</span><span>.</span><span>__cself__</span><span>}</span><span>&gt;&#34;</span>
</pre></div>


<p>We also handle the destructor by overriding the <code>__del__</code> special method so that
the garbage collector can take care of freeing memory for us.</p>
<p>In general, we would need to preprocess sources, especially headers, before we
can parse them concretely with <code>pycparser</code>. That&#39;s why we also need to define
something like</p>
<div><pre><span></span><span>restrict_re</span> <span>=</span> <span>re</span><span>.</span><span>compile</span><span>(</span><span>r</span><span>&#34;__restrict \w+&#34;</span><span>)</span>

<span>_header_head</span> <span>=</span> <span>r</span><span>&#34;&#34;&#34;</span>
<span>#define __attribute__(x)</span>
<span>#define __extension__</span>
<span>#define __inline inline</span>
<span>#define __asm__(x)</span>
<span>#define __const=const</span>
<span>#define __inline__ inline</span>
<span>#define __inline inline</span>
<span>#define __restrict</span>
<span>#define __signed__ signed</span>
<span>#define __GNUC_VA_LIST</span>
<span>#define __gnuc_va_list char</span>
<span>#define __thread</span>
<span>&#34;&#34;&#34;</span>


<span>def</span> <span>preprocess</span><span>(</span><span>source</span><span>:</span> <span>Path</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>with</span> <span>source</span><span>.</span><span>open</span><span>()</span> <span>as</span> <span>fin</span><span>:</span>
        <span>code</span> <span>=</span> <span>_header_head</span> <span>+</span> <span>fin</span><span>.</span><span>read</span><span>()</span>
        <span>return</span> <span>restrict_re</span><span>.</span><span>sub</span><span>(</span>
            <span>&#34;&#34;</span><span>,</span>
            <span>run</span><span>(</span>
                <span>[</span><span>&#34;gcc&#34;</span><span>,</span> <span>&#34;-E&#34;</span><span>,</span> <span>&#34;-P&#34;</span><span>,</span> <span>&#34;-&#34;</span><span>],</span>
                <span>stdout</span><span>=</span><span>PIPE</span><span>,</span>
                <span>input</span><span>=</span><span>code</span><span>.</span><span>encode</span><span>(),</span>
                <span>cwd</span><span>=</span><span>SRC</span><span>,</span>
            <span>)</span><span>.</span><span>stdout</span><span>.</span><span>decode</span><span>(),</span>
        <span>)</span>
</pre></div>


<p>The <code>_header_head</code> and the <code>restrict_re</code> are needed to take care of GCC
extensions, which are not supported by <code>pycparser</code>. But apart from them, all we
do is invoke the <code>gcc</code> preprocessor on the C sources. Putting everything
together inside <code>tests/cunit/__init__.py</code> we would then have something that
looks like</p>
<div><pre><span></span><span>import</span> <span>ctypes</span>
<span>import</span> <span>re</span>
<span>from</span> <span>ctypes</span> <span>import</span> <span>CDLL</span><span>,</span> <span>POINTER</span><span>,</span> <span>Structure</span><span>,</span> <span>c_char_p</span><span>,</span> <span>cast</span>
<span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>
<span>from</span> <span>subprocess</span> <span>import</span> <span>PIPE</span><span>,</span> <span>STDOUT</span><span>,</span> <span>run</span>
<span>from</span> <span>types</span> <span>import</span> <span>ModuleType</span>
<span>from</span> <span>typing</span> <span>import</span> <span>Any</span><span>,</span> <span>Optional</span>

<span>from</span> <span>pycparser</span> <span>import</span> <span>c_ast</span><span>,</span> <span>c_parser</span>
<span>from</span> <span>pycparser.plyparser</span> <span>import</span> <span>ParseError</span>

<span>HERE</span> <span>=</span> <span>Path</span><span>(</span><span>__file__</span><span>)</span><span>.</span><span>resolve</span><span>()</span><span>.</span><span>parent</span>
<span>TEST</span> <span>=</span> <span>HERE</span><span>.</span><span>parent</span>
<span>ROOT</span> <span>=</span> <span>TEST</span><span>.</span><span>parent</span>
<span>SRC</span> <span>=</span> <span>ROOT</span> <span>/</span> <span>&#34;src&#34;</span>


<span>restrict_re</span> <span>=</span> <span>re</span><span>.</span><span>compile</span><span>(</span><span>r</span><span>&#34;__restrict \w+&#34;</span><span>)</span>

<span>_header_head</span> <span>=</span> <span>r</span><span>&#34;&#34;&#34;</span>
<span>#define __attribute__(x)</span>
<span>#define __extension__</span>
<span>#define __inline inline</span>
<span>#define __asm__(x)</span>
<span>#define __const=const</span>
<span>#define __inline__ inline</span>
<span>#define __inline inline</span>
<span>#define __restrict</span>
<span>#define __signed__ signed</span>
<span>#define __GNUC_VA_LIST</span>
<span>#define __gnuc_va_list char</span>
<span>#define __thread</span>
<span>&#34;&#34;&#34;</span>


<span>def</span> <span>preprocess</span><span>(</span><span>source</span><span>:</span> <span>Path</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>with</span> <span>source</span><span>.</span><span>open</span><span>()</span> <span>as</span> <span>fin</span><span>:</span>
        <span>code</span> <span>=</span> <span>_header_head</span> <span>+</span> <span>fin</span><span>.</span><span>read</span><span>()</span>
        <span>return</span> <span>restrict_re</span><span>.</span><span>sub</span><span>(</span>
            <span>&#34;&#34;</span><span>,</span>
            <span>run</span><span>(</span>
                <span>[</span><span>&#34;gcc&#34;</span><span>,</span> <span>&#34;-E&#34;</span><span>,</span> <span>&#34;-P&#34;</span><span>,</span> <span>&#34;-&#34;</span><span>],</span>
                <span>stdout</span><span>=</span><span>PIPE</span><span>,</span>
                <span>input</span><span>=</span><span>code</span><span>.</span><span>encode</span><span>(),</span>
                <span>cwd</span><span>=</span><span>SRC</span><span>,</span>
            <span>)</span><span>.</span><span>stdout</span><span>.</span><span>decode</span><span>(),</span>
        <span>)</span>


<span>def</span> <span>compile</span><span>(</span><span>source</span><span>:</span> <span>Path</span><span>,</span> <span>cflags</span><span>=</span><span>[],</span> <span>ldadd</span><span>=</span><span>[]):</span>
    <span>binary</span> <span>=</span> <span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>)</span>

    <span>result</span> <span>=</span> <span>run</span><span>(</span>
        <span>[</span><span>&#34;gcc&#34;</span><span>,</span> <span>&#34;-shared&#34;</span><span>,</span> <span>*</span><span>cflags</span><span>,</span> <span>&#34;-o&#34;</span><span>,</span> <span>str</span><span>(</span><span>binary</span><span>),</span> <span>str</span><span>(</span><span>source</span><span>),</span> <span>*</span><span>ldadd</span><span>],</span>
        <span>stdout</span><span>=</span><span>PIPE</span><span>,</span>
        <span>stderr</span><span>=</span><span>STDOUT</span><span>,</span>
        <span>cwd</span><span>=</span><span>SRC</span><span>,</span>
    <span>)</span>

    <span>if</span> <span>result</span><span>.</span><span>returncode</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span>

    <span>raise</span> <span>RuntimeError</span><span>(</span><span>result</span><span>.</span><span>stdout</span><span>.</span><span>decode</span><span>())</span>


<span>C</span> <span>=</span> <span>CDLL</span><span>(</span><span>&#34;libc.so.6&#34;</span><span>)</span>


<span>class</span> <span>CFunctionDef</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>self</span><span>.</span><span>args</span> <span>=</span> <span>args</span>
        <span>self</span><span>.</span><span>rtype</span> <span>=</span> <span>rtype</span>


<span>class</span> <span>CTypeDef</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>fields</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>self</span><span>.</span><span>fields</span> <span>=</span> <span>fields</span>
        <span>self</span><span>.</span><span>methods</span> <span>=</span> <span>[]</span>
        <span>self</span><span>.</span><span>constructor</span> <span>=</span> <span>False</span>


<span>class</span> <span>CType</span><span>(</span><span>Structure</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>__cself__</span> <span>=</span> <span>self</span><span>.</span><span>new</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>

    <span>def</span> <span>__del__</span><span>(</span><span>self</span><span>):</span>
        <span>if</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>destroy</span><span>.</span><span>__cmethod__</span><span>.</span><span>__args__</span><span>)</span> <span>==</span> <span>1</span><span>:</span>
            <span>self</span><span>.</span><span>destroy</span><span>()</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;</span><span>{</span><span>self</span><span>.</span><span>name</span><span>}</span><span> CObject at </span><span>{</span><span>self</span><span>.</span><span>__cself__</span><span>}</span><span>&gt;&#34;</span>


<span>class</span> <span>CFunction</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>cfuncdef</span><span>,</span> <span>cfunc</span><span>):</span>
        <span>self</span><span>.</span><span>__name__</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>name</span>
        <span>self</span><span>.</span><span>__args__</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>args</span>
        <span>self</span><span>.</span><span>__cfunc__</span> <span>=</span> <span>cfunc</span>
        <span>if</span> <span>cfuncdef</span><span>.</span><span>rtype</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>__cfunc__</span><span>.</span><span>restype</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>rtype</span>

        <span>self</span><span>.</span><span>_posonly</span> <span>=</span> <span>all</span><span>(</span><span>_</span> <span>is</span> <span>None</span> <span>for</span> <span>_</span> <span>in</span> <span>self</span><span>.</span><span>__args__</span><span>)</span>

    <span>def</span> <span>check_args</span><span>(</span><span>self</span><span>,</span> <span>args</span><span>,</span> <span>kwargs</span><span>):</span>
        <span>if</span> <span>self</span><span>.</span><span>_posonly</span> <span>and</span> <span>kwargs</span><span>:</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>self</span><span>}</span><span> takes only positional arguments&#34;</span><span>)</span>

        <span>nargs</span> <span>=</span> <span>len</span><span>(</span><span>args</span><span>)</span> <span>+</span> <span>len</span><span>(</span><span>kwargs</span><span>)</span>
        <span>if</span> <span>nargs</span> <span>!=</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>__args__</span><span>):</span>
            <span>raise</span> <span>TypeError</span><span>(</span>
                <span>f</span><span>&#34;</span><span>{</span><span>self</span><span>}</span><span> takes exactly </span><span>{</span><span>len</span><span>(</span><span>self</span><span>.</span><span>__args__</span><span>)</span><span>}</span><span> arguments (</span><span>{</span><span>nargs</span><span>}</span><span> given)&#34;</span>
            <span>)</span>

    <span>def</span> <span>__call__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>check_args</span><span>(</span><span>args</span><span>,</span> <span>kwargs</span><span>)</span>
        <span>return</span> <span>self</span><span>.</span><span>__cfunc__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;CFunction &#39;</span><span>{</span><span>self</span><span>.</span><span>__name__</span><span>}</span><span>&#39;&gt;&#34;</span>


<span>class</span> <span>CMethod</span><span>(</span><span>CFunction</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>cfuncdef</span><span>,</span> <span>cfunc</span><span>,</span> <span>ctype</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>cfuncdef</span><span>,</span> <span>cfunc</span><span>)</span>
        <span>self</span><span>.</span><span>__ctype__</span> <span>=</span> <span>ctype</span>

    <span>def</span> <span>__get__</span><span>(</span><span>self</span><span>,</span> <span>obj</span><span>,</span> <span>objtype</span><span>=</span><span>None</span><span>):</span>
        <span>def</span> <span>_</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
            <span>cargs</span> <span>=</span> <span>[</span><span>obj</span><span>.</span><span>__cself__</span><span>,</span> <span>*</span><span>args</span><span>]</span>
            <span>self</span><span>.</span><span>check_args</span><span>(</span><span>cargs</span><span>,</span> <span>kwargs</span><span>)</span>

            <span>return</span> <span>self</span><span>.</span><span>__cfunc__</span><span>(</span><span>*</span><span>cargs</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>

        <span>_</span><span>.</span><span>__cmethod__</span> <span>=</span> <span>self</span>

        <span>return</span> <span>_</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;CMethod &#39;</span><span>{</span><span>self</span><span>.</span><span>__name__</span><span>}</span><span>&#39; of CType &#39;</span><span>{</span><span>self</span><span>.</span><span>__ctype__</span><span>.</span><span>__name__</span><span>}</span><span>&#39;&gt;&#34;</span>


<span>class</span> <span>CStaticMethod</span><span>(</span><span>CFunction</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>cfuncdef</span><span>,</span> <span>cfunc</span><span>,</span> <span>ctype</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>cfuncdef</span><span>,</span> <span>cfunc</span><span>)</span>
        <span>self</span><span>.</span><span>__ctype__</span> <span>=</span> <span>ctype</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;&lt;CStaticMethod &#39;</span><span>{</span><span>self</span><span>.</span><span>__name__</span><span>}</span><span>&#39; of CType &#39;</span><span>{</span><span>self</span><span>.</span><span>__ctype__</span><span>.</span><span>__name__</span><span>}</span><span>&#39;&gt;&#34;</span>


<span>class</span> <span>CMetaType</span><span>(</span><span>type</span><span>(</span><span>Structure</span><span>)):</span>
    <span>def</span> <span>__new__</span><span>(</span><span>cls</span><span>,</span> <span>cmodule</span><span>,</span> <span>ctypedef</span><span>,</span> <span>_</span><span>=</span><span>None</span><span>):</span>
        <span>ctype</span> <span>=</span> <span>super</span><span>()</span><span>.</span><span>__new__</span><span>(</span>
            <span>cls</span><span>,</span>
            <span>ctypedef</span><span>.</span><span>name</span><span>,</span>
            <span>(</span><span>CType</span><span>,),</span>
            <span>{</span><span>&#34;__cmodule__&#34;</span><span>:</span> <span>cmodule</span><span>},</span>
        <span>)</span>

        <span>constructor</span> <span>=</span> <span>getattr</span><span>(</span><span>cmodule</span><span>.</span><span>__binary__</span><span>,</span> <span>f</span><span>&#34;</span><span>{</span><span>ctypedef</span><span>.</span><span>name</span><span>[:</span><span>-</span><span>2</span><span>]</span><span>}</span><span>_new&#34;</span><span>)</span>
        <span>ctype</span><span>.</span><span>new</span> <span>=</span> <span>CStaticMethod</span><span>(</span><span>ctypedef</span><span>.</span><span>constructor</span><span>,</span> <span>constructor</span><span>,</span> <span>ctype</span><span>)</span>

        <span>for</span> <span>method_def</span> <span>in</span> <span>ctypedef</span><span>.</span><span>methods</span><span>:</span>
            <span>method_name</span> <span>=</span> <span>method_def</span><span>.</span><span>name</span>
            <span>method</span> <span>=</span> <span>getattr</span><span>(</span><span>cmodule</span><span>.</span><span>__binary__</span><span>,</span> <span>f</span><span>&#34;</span><span>{</span><span>ctypedef</span><span>.</span><span>name</span><span>[:</span><span>-</span><span>2</span><span>]</span><span>}</span><span>__</span><span>{</span><span>method_name</span><span>}</span><span>&#34;</span><span>)</span>
            <span>setattr</span><span>(</span><span>ctype</span><span>,</span> <span>method_name</span><span>,</span> <span>CMethod</span><span>(</span><span>method_def</span><span>,</span> <span>method</span><span>,</span> <span>ctype</span><span>))</span>

        <span>ctype</span><span>.</span><span>__cname__</span> <span>=</span> <span>ctypedef</span><span>.</span><span>name</span>

        <span>return</span> <span>ctype</span>


<span>class</span> <span>DeclCollector</span><span>(</span><span>c_ast</span><span>.</span><span>NodeVisitor</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>types</span> <span>=</span> <span>{}</span>
        <span>self</span><span>.</span><span>functions</span> <span>=</span> <span>[]</span>

    <span>def</span> <span>_get_type</span><span>(</span><span>self</span><span>,</span> <span>node</span><span>):</span>
        <span>print</span><span>(</span><span>node</span><span>)</span>
        <span>return</span> <span>self</span><span>.</span><span>types</span><span>[</span><span>&#34; &#34;</span><span>.</span><span>join</span><span>(</span><span>node</span><span>.</span><span>type</span><span>.</span><span>type</span><span>.</span><span>names</span><span>)]</span>

    <span>def</span> <span>visit_Typedef</span><span>(</span><span>self</span><span>,</span> <span>node</span><span>):</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>node</span><span>.</span><span>type</span><span>.</span><span>type</span><span>,</span> <span>c_ast</span><span>.</span><span>Struct</span><span>)</span> <span>and</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>declname</span><span>.</span><span>endswith</span><span>(</span>
            <span>&#34;_t&#34;</span>
        <span>):</span>
            <span>struct</span> <span>=</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>type</span>
            <span>self</span><span>.</span><span>types</span><span>[</span><span>node</span><span>.</span><span>type</span><span>.</span><span>declname</span><span>[:</span><span>-</span><span>2</span><span>]]</span> <span>=</span> <span>CTypeDef</span><span>(</span>
                <span>node</span><span>.</span><span>type</span><span>.</span><span>declname</span><span>,</span>
                <span>[</span><span>decl</span><span>.</span><span>name</span> <span>for</span> <span>decl</span> <span>in</span> <span>struct</span><span>.</span><span>decls</span><span>],</span>
            <span>)</span>

    <span>def</span> <span>visit_Decl</span><span>(</span><span>self</span><span>,</span> <span>node</span><span>):</span>
        <span>if</span> <span>&#34;extern&#34;</span> <span>in</span> <span>node</span><span>.</span><span>storage</span><span>:</span>
            <span>return</span>

        <span>if</span> <span>isinstance</span><span>(</span><span>node</span><span>.</span><span>type</span><span>,</span> <span>c_ast</span><span>.</span><span>FuncDecl</span><span>):</span>
            <span>func_name</span> <span>=</span> <span>node</span><span>.</span><span>name</span>
            <span>ret_type</span> <span>=</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>type</span>
            <span>rtype</span> <span>=</span> <span>None</span>
            <span>if</span> <span>isinstance</span><span>(</span><span>ret_type</span><span>,</span> <span>c_ast</span><span>.</span><span>PtrDecl</span><span>):</span>
                <span>if</span> <span>&#34;&#34;</span><span>.</span><span>join</span><span>(</span><span>ret_type</span><span>.</span><span>type</span><span>.</span><span>type</span><span>.</span><span>names</span><span>)</span> <span>==</span> <span>&#34;char&#34;</span><span>:</span>
                    <span>rtype</span> <span>=</span> <span>c_char_p</span>
            <span>args</span> <span>=</span> <span>(</span>
                <span>[</span><span>_</span><span>.</span><span>name</span> <span>if</span> <span>hasattr</span><span>(</span><span>_</span><span>,</span> <span>&#34;name&#34;</span><span>)</span> <span>else</span> <span>None</span> <span>for</span> <span>_</span> <span>in</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>args</span><span>.</span><span>params</span><span>]</span>
                <span>if</span> <span>node</span><span>.</span><span>type</span><span>.</span><span>args</span> <span>is</span> <span>not</span> <span>None</span>
                <span>else</span> <span>[]</span>
            <span>)</span>
            <span>if</span> <span>func_name</span><span>.</span><span>endswith</span><span>(</span><span>&#34;_new&#34;</span><span>):</span>
                <span>self</span><span>.</span><span>types</span><span>[</span><span>f</span><span>&#34;</span><span>{</span><span>func_name</span><span>[:</span><span>-</span><span>4</span><span>]</span><span>}</span><span>&#34;</span><span>]</span><span>.</span><span>constructor</span> <span>=</span> <span>CFunctionDef</span><span>(</span>
                    <span>&#34;new&#34;</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span>
                <span>)</span>
            <span>elif</span> <span>&#34;__&#34;</span> <span>in</span> <span>func_name</span><span>:</span>
                <span>type_name</span><span>,</span> <span>_</span><span>,</span> <span>method_name</span> <span>=</span> <span>func_name</span><span>.</span><span>partition</span><span>(</span><span>&#34;__&#34;</span><span>)</span>
                <span>if</span> <span>not</span> <span>type_name</span><span>:</span>
                    <span>return</span>
                <span>self</span><span>.</span><span>types</span><span>[</span><span>type_name</span><span>]</span><span>.</span><span>methods</span><span>.</span><span>append</span><span>(</span>
                    <span>CFunctionDef</span><span>(</span><span>method_name</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span><span>)</span>
                <span>)</span>
            <span>else</span><span>:</span>
                <span>self</span><span>.</span><span>functions</span><span>.</span><span>append</span><span>(</span><span>CFunctionDef</span><span>(</span><span>func_name</span><span>,</span> <span>args</span><span>,</span> <span>rtype</span><span>))</span>

    <span>def</span> <span>collect</span><span>(</span><span>self</span><span>,</span> <span>decl</span><span>):</span>
        <span>parser</span> <span>=</span> <span>c_parser</span><span>.</span><span>CParser</span><span>()</span>
        <span>try</span><span>:</span>
            <span>ast</span> <span>=</span> <span>parser</span><span>.</span><span>parse</span><span>(</span><span>decl</span><span>,</span> <span>filename</span><span>=</span><span>&#34;&lt;preprocessed&gt;&#34;</span><span>)</span>
        <span>except</span> <span>ParseError</span> <span>as</span> <span>e</span><span>:</span>
            <span>lines</span> <span>=</span> <span>decl</span><span>.</span><span>splitlines</span><span>()</span>
            <span>line</span><span>,</span> <span>col</span> <span>=</span> <span>(</span>
                <span>int</span><span>(</span><span>_</span><span>)</span> <span>-</span> <span>1</span> <span>for</span> <span>_</span> <span>in</span> <span>e</span><span>.</span><span>args</span><span>[</span><span>0</span><span>]</span><span>.</span><span>partition</span><span>(</span><span>&#34; &#34;</span><span>)[</span><span>0</span><span>]</span><span>.</span><span>split</span><span>(</span><span>&#34;:&#34;</span><span>)[</span><span>1</span><span>:</span><span>3</span><span>]</span>
            <span>)</span>
            <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>max</span><span>(</span><span>0</span><span>,</span> <span>line</span> <span>-</span> <span>4</span><span>),</span> <span>min</span><span>(</span><span>line</span> <span>+</span> <span>5</span><span>,</span> <span>len</span><span>(</span><span>lines</span><span>))):</span>
                <span>if</span> <span>i</span> <span>!=</span> <span>line</span><span>:</span>
                    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>i</span><span>+</span><span>1</span><span>:</span><span>5d</span><span>}</span><span>  </span><span>{</span><span>lines</span><span>[</span><span>i</span><span>]</span><span>}</span><span>&#34;</span><span>)</span>
                <span>else</span><span>:</span>
                    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>i</span><span>+</span><span>1</span><span>:</span><span>5d</span><span>}</span><span>  </span><span>\033</span><span>[33;1m</span><span>{</span><span>lines</span><span>[</span><span>line</span><span>]</span><span>}</span><span>\033</span><span>[0m&#34;</span><span>)</span>
                    <span>print</span><span>(</span><span>&#34; &#34;</span> <span>*</span> <span>(</span><span>col</span> <span>+</span> <span>5</span><span>)</span> <span>+</span> <span>&#34;</span><span>\033</span><span>[31;1m&lt;&lt;^</span><span>\033</span><span>[0m&#34;</span><span>)</span>
            <span>raise</span>

        <span>self</span><span>.</span><span>visit</span><span>(</span><span>ast</span><span>)</span>
        <span>return</span> <span>{</span>
            <span>k</span><span>:</span> <span>v</span>
            <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>self</span><span>.</span><span>types</span><span>.</span><span>items</span><span>()</span>
            <span>if</span> <span>isinstance</span><span>(</span><span>v</span><span>,</span> <span>CTypeDef</span><span>)</span> <span>and</span> <span>v</span><span>.</span><span>constructor</span>
        <span>}</span>


<span>class</span> <span>CModule</span><span>(</span><span>ModuleType</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>source</span><span>):</span>
        <span>super</span><span>()</span><span>.</span><span>__init__</span><span>(</span><span>source</span><span>.</span><span>name</span><span>,</span> <span>f</span><span>&#34;Generated from </span><span>{</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#39;.c&#39;</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
        <span>self</span><span>.</span><span>__binary__</span> <span>=</span> <span>CDLL</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.so&#34;</span><span>))</span>

        <span>collector</span> <span>=</span> <span>DeclCollector</span><span>()</span>

        <span>for</span> <span>name</span><span>,</span> <span>ctypedef</span> <span>in</span> <span>collector</span><span>.</span><span>collect</span><span>(</span>
            <span>preprocess</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.h&#34;</span><span>))</span>
        <span>)</span><span>.</span><span>items</span><span>():</span>
            <span>parts</span> <span>=</span> <span>name</span><span>.</span><span>split</span><span>(</span><span>&#34;_&#34;</span><span>)</span>
            <span>py_name</span> <span>=</span> <span>&#34;&#34;</span><span>.</span><span>join</span><span>((</span><span>_</span><span>.</span><span>capitalize</span><span>()</span> <span>for</span> <span>_</span> <span>in</span> <span>parts</span><span>))</span>
            <span>setattr</span><span>(</span><span>self</span><span>,</span> <span>py_name</span><span>,</span> <span>CMetaType</span><span>(</span><span>self</span><span>,</span> <span>ctypedef</span><span>,</span> <span>None</span><span>))</span>

        <span>for</span> <span>cfuncdef</span> <span>in</span> <span>collector</span><span>.</span><span>functions</span><span>:</span>
            <span>name</span> <span>=</span> <span>cfuncdef</span><span>.</span><span>name</span>
            <span>try</span><span>:</span>
                <span>cfunc</span> <span>=</span> <span>CFunction</span><span>(</span><span>cfuncdef</span><span>,</span> <span>getattr</span><span>(</span><span>self</span><span>.</span><span>__binary__</span><span>,</span> <span>name</span><span>))</span>
                <span>setattr</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>cfunc</span><span>)</span>
            <span>except</span> <span>AttributeError</span><span>:</span>
                <span># Not part of the binary</span>
                <span>pass</span>

    <span>@classmethod</span>
    <span>def</span> <span>compile</span><span>(</span><span>cls</span><span>,</span> <span>source</span><span>,</span> <span>cflags</span><span>=</span><span>[],</span> <span>ldadd</span><span>=</span><span>[]):</span>
        <span>compile</span><span>(</span><span>source</span><span>.</span><span>with_suffix</span><span>(</span><span>&#34;.c&#34;</span><span>),</span> <span>cflags</span><span>,</span> <span>ldadd</span><span>)</span>
        <span>return</span> <span>cls</span><span>(</span><span>source</span><span>)</span>
</pre></div>


<p>So let&#39;s use this new technology to make our C unit tests more <em>Pythonesque</em>.
This is what our new <code>test_cache.py</code> can look like</p>
<div><pre><span></span><span>import</span> <span>pytest</span>
<span>from</span> <span>tests.cunit</span> <span>import</span> <span>C</span>
<span>from</span> <span>tests.cunit.cache</span> <span>import</span> <span>Queue</span><span>,</span> <span>QueueItem</span>

<span>NULL</span> <span>=</span> <span>0</span>


<span>def</span> <span>test_queue_item</span><span>():</span>
    <span>value</span> <span>=</span> <span>C</span><span>.</span><span>malloc</span><span>(</span><span>16</span><span>)</span>
    <span>queue_item</span> <span>=</span> <span>QueueItem</span><span>(</span><span>value</span><span>,</span> <span>42</span><span>)</span>
    <span>assert</span> <span>queue_item</span><span>.</span><span>__cself__</span>

    <span>queue_item</span><span>.</span><span>destroy</span><span>(</span><span>C</span><span>.</span><span>free</span><span>)</span>


<span>@pytest</span><span>.</span><span>mark</span><span>.</span><span>parametrize</span><span>(</span><span>&#34;qsize&#34;</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>10</span><span>,</span> <span>100</span><span>,</span> <span>1000</span><span>])</span>
<span>def</span> <span>test_queue</span><span>(</span><span>qsize</span><span>):</span>
    <span>q</span> <span>=</span> <span>Queue</span><span>(</span><span>qsize</span><span>,</span> <span>C</span><span>.</span><span>free</span><span>)</span>

    <span>assert</span> <span>q</span><span>.</span><span>is_empty</span><span>()</span>
    <span>assert</span> <span>qsize</span> <span>==</span> <span>0</span> <span>or</span> <span>not</span> <span>q</span><span>.</span><span>is_full</span><span>()</span>

    <span>assert</span> <span>q</span><span>.</span><span>dequeue</span><span>()</span> <span>is</span> <span>NULL</span>

    <span>values</span> <span>=</span> <span>[</span><span>C</span><span>.</span><span>malloc</span><span>(</span><span>16</span><span>)</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>qsize</span><span>)]</span>
    <span>assert</span> <span>all</span><span>(</span><span>values</span><span>)</span>

    <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>enumerate</span><span>(</span><span>values</span><span>):</span>
        <span>assert</span> <span>q</span><span>.</span><span>enqueue</span><span>(</span><span>v</span><span>,</span> <span>k</span><span>)</span>

    <span>assert</span> <span>qsize</span> <span>==</span> <span>0</span> <span>or</span> <span>not</span> <span>q</span><span>.</span><span>is_empty</span><span>()</span>
    <span>assert</span> <span>q</span><span>.</span><span>is_full</span><span>()</span>
    <span>assert</span> <span>q</span><span>.</span><span>enqueue</span><span>(</span><span>42</span><span>,</span> <span>42</span><span>)</span> <span>is</span> <span>NULL</span>

    <span>assert</span> <span>values</span> <span>==</span> <span>[</span><span>q</span><span>.</span><span>dequeue</span><span>()</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>qsize</span><span>)]</span>
</pre></div>


<p>We can practically treat our C binary object as if it were an actual Python
module and import the <code>Queue</code> and <code>QueueItem</code> types from it. We can then use
them as if they were actual Python classes and call methods on them. How cool is
that? üòÑ</p>

<p>What about test coverage? If you&#39;ve used <code>pytest</code> before, you are probably
familiar with the <code>pytest-cov</code> plugin, which is a handy way of collecting and
reporting test coverage. GCC supports the <code>-fprofile-arcs</code> and <code>-ftest-coverage</code>
to emit coverage data. So if we also wanted to get test coverage data while
running C unit tests with <code>pytest</code>, all we would have to do is add these flags
to the <code>CFLAGS</code> list in the <code>cache.py</code> module. The <a href="https://gcovr.com/en/stable/"><code>gcovr</code></a> tool is
actually inspired by the Python counterpart <code>coverage.py</code> and can be used to
generate some nice reports. In particular, it could be used to generate
Cobertura XML reports that could be uploaded to services like
<a href="https://codecov.io/">codecov.io</a>.</p>
  </div><!-- /.entry-content -->
</section>




    </div></div>
  </body>
</html>
