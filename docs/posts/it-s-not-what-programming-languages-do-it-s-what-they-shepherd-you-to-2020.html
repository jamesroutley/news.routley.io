<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nibblestew.blogspot.com/2020/03/its-not-what-programming-languages-do.html">Original</a>
    <h1>It&#39;s not what programming languages do, it&#39;s what they shepherd you to (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<div>
<div itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting">
<meta content="5968355124473522212" itemprop="blogId"/>
<meta content="1318135828711063313" itemprop="postId"/>
<h3 itemprop="name">
It&#39;s not what programming languages do, it&#39;s what they shepherd you to
</h3>

<div id="post-body-1318135828711063313" itemprop="description articleBody"><p>
How many of you have listened, read or taken part in a discussion about programming languages that goes like the following:</p></div>

</div>
<div id="comments">
<h4>17 comments:</h4>
<div>


<div id="comment-holder">
<div><ol id="top-ra"><li id="c5905628353012750858"><p><img src="https://3.bp.blogspot.com/-Si7uduNMoLc/UQC2M0Upx3I/AAAAAAAAAIE/63P1Qnm9ltU/s35/symbol.png" alt=""/></p><div><p>Python (and really most scripting languages) shepherds you into using exceptions as control flow</p><p><span><a target="_self" data-comment-id="5905628353012750858">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=5905628353012750858">Delete</a></span></span></p></div><div><div id="c5905628353012750858-rt"><p><span><span></span><span><a target="_self">Replies</a></span></span></p><ol id="c5905628353012750858-ra"><div><li id="c3203221668865236122"><p><img src="https://4.bp.blogspot.com/_QtiwL8MYVWc/TO0bl_c5s7I/AAAAAAAAAGk/y6DMpLkymhU/S45-s35/headspace.JPG" alt=""/></p><div><p>Python shepherds you into thinking about how others will read your code.  Optimisation is for readability rather than speed.</p><p><span><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=3203221668865236122">Delete</a></span></span></p></div></li><li id="c5473167719006080200"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>Readability (and maintainability) goes sideways with exceptions. Best way of handling errors are ADTs. Which btw are well supported by Python, almost everything you work with in Python represents an algebraic data type.</p><p><span><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=5473167719006080200">Delete</a></span></span></p></div></li><li id="c1584619390459361790"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>Python shepherds you into rewriting your code in some other language, because it&#39;s too damn slow. ;P</p><p><span><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=1584619390459361790">Delete</a></span></span></p></div></li></div></ol></div></div></li><li id="c2043491807846615309"><p><img src="https://resources.blogblog.com/img/blank.gif" alt=""/></p><div><p>I like this idea as a way to talk about programming languages, but I think it would be hard to reach a consensus on this. For example would you say that languages for example like python, ruby or haskell shepherds it&#39;s users to write overly complicated list comprehensions?<br/></p><p><span><a target="_self" data-comment-id="2043491807846615309">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=2043491807846615309">Delete</a></span></span></p></div><div><div id="c2043491807846615309-rt"><p><span><span></span><span><a target="_self">Replies</a></span></span></p><ol id="c2043491807846615309-ra"><div><li id="c6249983648600902077"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>No, because there are other options that are just as easy. Java shepherds you to use inversion of control with all this crappy spring and other dependency injection frameworks which leads to dependency hell and runtime errors instead of compile time errors and other complexity issues.</p><p><span><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=6249983648600902077">Delete</a></span></span></p></div></li><li id="c6427780308251693834"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>You don&#39;t have to use Spring.</p><p><span><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=6427780308251693834">Delete</a></span></span></p></div></li></div></ol></div></div></li><li id="c5462474302934833299"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>Some of it is also timing too. Java&#39;s shepherding into XML and later and less so JSON config files has a legacy in J2EE which it just can&#39;t shake as a language. The way it handled the split of code/config then was about the companies that developed J2EE and their needs. That reminds me of the mythical man month essay on the topic of organisation structure impacting code.</p><p><span><a target="_self" data-comment-id="5462474302934833299">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=5462474302934833299">Delete</a></span></span></p></div></li><li id="c4343505987934215050"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>I think you are on the right track.  Languages tend to have a central concept or problem area that they are trying to solve, so the syntax and structure is optimized in a certain way to address or encourage a way of thinking towards a problem set.  If languages were like tools in a toolbox, someone skilled in their craft would use the tool best suited for the problem at hand.  We don&#39;t do that often in the software industry because companies tend to mandate some subset of possible languages to use to ease training, code maintenance, and hiring concerns.  The result is that our solutions are strongly influenced by our use of language.  Perhaps the interesting question is if it is possible to determine the degree of &#34;impedance&#34; mis-match between the problem and the language chosen to solve the problem.</p><p><span><a target="_self" data-comment-id="4343505987934215050">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=4343505987934215050">Delete</a></span></span></p></div></li><li id="c351851838851565401"><p><img src="https://1.bp.blogspot.com/_PIM6r0YLhk4/SaHeKhJXrlI/AAAAAAAAAD8/77h5_Rn4udU/S45-s35/klaverfingre.jpg" alt=""/></p><div><p>One thing I&#39;ve noticed after some years of working in Python is that that the C++ community shepherds you into thinking about performance for trivial things. For instance, the typical C++ book would introduce building blocks, aka abstractions, and then spend much time discussing the overhead of them, e.g. virtual functions.</p><p><span><a target="_self" data-comment-id="351851838851565401">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=351851838851565401">Delete</a></span></span></p></div></li><li id="c6785882155605305296"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>Excellent insight into how and why people write bad code in a variety of languages. I like the shepherding concept.</p><p><span><a target="_self" data-comment-id="6785882155605305296">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=6785882155605305296">Delete</a></span></span></p></div></li><li id="c7969770477795408481"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>This could be quantified.  If we agree on practices that are &#34;bad&#34;, then looking through github for examples in different languages could actually tell what percentage of the codebases used those &#34;bad&#34; practices, which would be a good measurement of how much the language shepherds people into bad practices.</p><p><span><a target="_self" data-comment-id="7969770477795408481">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=7969770477795408481">Delete</a></span></span></p></div></li><li id="c5065997422767379807"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>It&#39;s a 38-year old issue, see: &#34;Determined Real Programmer can write FORTRAN programs in any language.&#34; https://web.mit.edu/humor/Computers/real.programmers #humor</p><p><span><a target="_self" data-comment-id="5065997422767379807">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=5065997422767379807">Delete</a></span></span></p></div></li><li id="c5776985977538041079"><p><img src="https://3.bp.blogspot.com/_ztFc4AiNk_k/SahrPC_8rZI/AAAAAAAAAG0/WbZA_3aQmJ8/S45-s35/User_Whiteknight.jpg" alt=""/></p><div><p>I&#39;ve been complaining about this a lot lately. A language like C# shepherds you into mutable data by default (the &#34;readonly&#34; keyword has to be added), and Java shepherds you into inheritance because methods are virtual by default. All procedural-based languages shepherd you into spaghetti code because it&#39;s always easier to just add another &#34;if&#34;/&#34;else&#34; than it is to refactor code out into a separate class or method. When modern best practice includes things like &#34;data should be immutable&#34; or &#34;prefer delegation over inheritance&#34; or &#34;keep cyclomatic complexity low&#34;, these should be easiest to do but they are often harder.</p><p><span><a target="_self" data-comment-id="5776985977538041079">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=5776985977538041079">Delete</a></span></span></p></div></li><li id="c5033621162538380151"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>I find it interesting how most of the comments reinforce the first part of the essay :-D</p><p><span><a target="_self" data-comment-id="5033621162538380151">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=5033621162538380151">Delete</a></span></span></p></div></li><li id="c1422161533133189858"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>Congratulations, you&#39;ve reformulated the Sapir-Whorf hypothesis</p><p><span><a target="_self" data-comment-id="1422161533133189858">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=1422161533133189858">Delete</a></span></span></p></div></li><li id="c5406026442718102190"><p><img src="https://www.blogger.com/img/blogger_logo_round_35.png" alt=""/></p><div><p>This is a fun way to combine the Blub Paradox and people lazyness. You basically take a feature from Blub language, and you take someone lazy enough to abuse the feature.</p><p><span><a target="_self" data-comment-id="5406026442718102190">Reply</a><span><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=5968355124473522212&amp;postID=5406026442718102190">Delete</a></span></span></p></div></li></ol></div>
</div>
</div>



</div>
</div>

        </div></div>
  </body>
</html>
