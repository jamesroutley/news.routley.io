<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/vpand/icpp">Original</a>
    <h1>ICPP â€“ Run C&#43;&#43; anywhere like a script</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>Interpreting C++, executing the source and executable like a script.</strong></p>
<ul dir="auto">
<li>Writing powerful script using C++ just as easy as Python;</li>
<li>Writing hot-loading C++ script code in running process;</li>
<li>Based on <a href="https://github.com/unicorn-engine/unicorn.git">Unicorn Engine</a> qemu virtual cpu and <a href="https://github.com/llvm/llvm-project.git">Clang/LLVM</a> C++ compiler;</li>
<li>Integrated internally with <a href="https://en.cppreference.com/w/cpp/23" rel="nofollow">Standard C++23</a> and <a href="https://github.com/boostorg/boost.git">Boost</a> libraries;</li>
<li>To reuse the existing C/C++ library as an icpp module extension is extremely simple.</li>
</ul>
<p dir="auto">Copyright (c) vpand.com 2024.</p>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>*</th>
<th>Source</th>
<th>Executable</th>
<th>Package</th>
<th>Memory Resident</th>
<th>Remote</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ICPP</strong></td>
<td><strong>C++</strong></td>
<td><strong>ARM64/X86_64</strong> Object</td>
<td><strong>imod</strong> for *.icpp</td>
<td><strong>iopad</strong>/<strong>icpp-gadget</strong></td>
<td><strong>icpp-server</strong></td>
</tr>
<tr>
<td><strong>Cling</strong></td>
<td>C++</td>
<td><strong>LLVM-IR</strong> Bitcode</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>LLI</strong></td>
<td>C++</td>
<td><strong>LLVM-IR</strong> Bitcode</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>WASM</strong></td>
<td>C++</td>
<td><strong>WebAssembly</strong> Bitcode</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>Python</strong></td>
<td>Python</td>
<td>Bytecode</td>
<td>pip for *.wheel</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>Frida</strong></td>
<td>JavaScript</td>
<td>Bytecode</td>
<td>N/A</td>
<td>frida/frida-gadget</td>
<td>frida-server</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto"><strong>Using ICPP to write C++ code just as a script.</strong> Write and then run directly, no creating project, no configuring build, no compiling and linking...</p>
<p dir="auto">No matter if you&#39;re a beginner or an expert with C++, ICPP is suitable for you. With ICPP, you can focus on:</p>
<ul dir="auto">
<li>Writing <strong>snippet code</strong> to study any of the newest C++ features;</li>
<li>Writing <strong>glue script</strong> to do some tasks;</li>
<li>Writing <strong>test code</strong> before applying to the formal project;</li>
<li>Writing <strong>sample code</strong> to study some new third C/C++ libraries;</li>
<li>Making native plugin development scriptable, i.e., <strong>writing plugin using C++ dynamically</strong>.</li>
<li>Tracing, profiling, performance optimizing;</li>
<li>And so on...</li>
</ul>
<p dir="auto"><strong>ICPP, make programming all in one.</strong></p>


<p dir="auto">Local interpreter mode lets you run C++ directly in your local system.</p>
<section data-identity="5e9a83cb-0327-4435-b54d-acd6830a5cab" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div data-json="{&#34;data&#34;:&#34;graph LR\n    A(C++ Source) -- Clang --&amp;gt; B(Object)\n    B -- Loader --&amp;gt; C(ICPP Interpreter)\n    A(C++ Source) -- Source.io --&amp;gt; H(IObject)\n    H(IObject) -- Parser --&amp;gt; C\n    E(Executable) -- Loader --&amp;gt; C\n    C -- Unicorn --&amp;gt; D(Output)\n    C -- Tracer --&amp;gt; F(Traces)\n    C -- Profiler --&amp;gt; G(Profiles)\n&#34;}" data-plain="graph LR
    A(C++ Source) -- Clang --&gt; B(Object)
    B -- Loader --&gt; C(ICPP Interpreter)
    A(C++ Source) -- Source.io --&gt; H(IObject)
    H(IObject) -- Parser --&gt; C
    E(Executable) -- Loader --&gt; C
    C -- Unicorn --&gt; D(Output)
    C -- Tracer --&gt; F(Traces)
    C -- Profiler --&gt; G(Profiles)
" dir="auto">
    <div dir="auto">
      <pre lang="mermaid" aria-label="Raw mermaid code">graph LR
    A(C++ Source) -- Clang --&gt; B(Object)
    B -- Loader --&gt; C(ICPP Interpreter)
    A(C++ Source) -- Source.io --&gt; H(IObject)
    H(IObject) -- Parser --&gt; C
    E(Executable) -- Loader --&gt; C
    C -- Unicorn --&gt; D(Output)
    C -- Tracer --&gt; F(Traces)
    C -- Profiler --&gt; G(Profiles)
</pre>
    </div>
  </div>
  <span role="presentation">
    <svg style="box-sizing: content-box; color: var(--color-icon-primary);" width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true" data-view-component="true">
  <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-opacity="0.25" stroke-width="2" vector-effect="non-scaling-stroke" fill="none"></circle>
  <path d="M15 8a7.002 7.002 0 00-7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"></path>
</svg>  <span>Loading</span>

  </span>
</section>


<p dir="auto">Remote interpreter mode lets you run C++ remotely in a different process or system which loads the icpp-gadget library. This mode allows you to run C++ code dynamically in a running local process or a remote system like Android/iOS.</p>
<section data-identity="bb48634d-ad3e-483e-9ee7-7a8ec0e9d6ee" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div data-json="{&#34;data&#34;:&#34;graph LR\n    A(C++ Source) -- ICPP --&amp;gt; B(IObject)\n    B -- IOPAD --&amp;gt; C(ICPP Gadget)\n    C -- Interpreter --&amp;gt; D(Run in Process)\n    C -- Extension --&amp;gt; E(Hooking/Tracing)\n    C -- Extension --&amp;gt; F(Testing)\n&#34;}" data-plain="graph LR
    A(C++ Source) -- ICPP --&gt; B(IObject)
    B -- IOPAD --&gt; C(ICPP Gadget)
    C -- Interpreter --&gt; D(Run in Process)
    C -- Extension --&gt; E(Hooking/Tracing)
    C -- Extension --&gt; F(Testing)
" dir="auto">
    <div dir="auto">
      <pre lang="mermaid" aria-label="Raw mermaid code">graph LR
    A(C++ Source) -- ICPP --&gt; B(IObject)
    B -- IOPAD --&gt; C(ICPP Gadget)
    C -- Interpreter --&gt; D(Run in Process)
    C -- Extension --&gt; E(Hooking/Tracing)
    C -- Extension --&gt; F(Testing)
</pre>
    </div>
  </div>
  <span role="presentation">
    <svg style="box-sizing: content-box; color: var(--color-icon-primary);" width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true" data-view-component="true">
  <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-opacity="0.25" stroke-width="2" vector-effect="non-scaling-stroke" fill="none"></circle>
  <path d="M15 8a7.002 7.002 0 00-7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"></path>
</svg>  <span>Loading</span>

  </span>
</section>



<ul dir="auto">
<li><strong>icpp</strong>: a local C++ source compiler, interpreter and REPL used to interpret C++ directly;</li>
<li><strong>imod</strong>: an icpp module package manager tool used to install, uninstall and show the third-party modules;</li>
<li><strong>iopad</strong>: a local C++ source compiler driver, object launch pad and REPL for the remote icpp-gadget;</li>
<li><strong>icpp-gadget</strong>: a remote memory resident daemon which may run inside an Android/iOS process, waiting for iopad to send the interpretable object to execute.</li>
<li><strong>icpp-server</strong>: a remote icpp-gadget server daemon, waiting for iopad to send the interpretable object to execute.</li>
</ul>

<p dir="auto">Within an IDE frontend should be easier and more convenient to use the icpp package, you can download it at the <a href="https://github.com/vpand/icpp-vscode/releases">icpp-vscode</a> release page or search &#34;icpp&#34; in vscode extension market.</p>

<div dir="auto" data-snippet-clipboard-copy-content="vpand@MacBook-Pro icpp % icpp -h              
OVERVIEW: ICPP v0.1.0.255 based on Unicorn and Clang/LLVM.
  Interpreting C++, running C++ in anywhere like a script.

USAGE: icpp [options] exec0 [exec1 ...] [[--] args]
OPTIONS:
  -v, -version: print icpp version.
  --version: print icpp and clang version.
  -h, -help: print icpp help list.
  --help: print icpp and clang help list.
  -f: format the input source file as LLVM code style.
  -O0, -O1, -O2, -O3, -Os, -Oz: optimization level passed to clang, default to -O2.
  -I/path/to/include: header include directory passed to clang.
  -L/path/to/library: library search directory passed to icpp interpreter.
  -lname: full name of the dependent library file passed to icpp interpreter, e.g.: liba.dylib, liba.so, a.dll.
  -F/path/to/framework: framework search directory passed to icpp interpreter.
  -fname: framework name of the dependent library file passed to icpp interpreter.
  -p/path/to/json: professional json configuration file for trace/profile/plugin/etc..
FILES: input file can be C++ source code(.c/.cc/.cpp/.cxx), MachO/ELF/PE executable.
ARGS: arguments passed to the main entry function of the input files.

Run a C++ source file, e.g.:
  icpp helloworld.cc
  icpp helloworld.cc -- Hello World (i.e.: argc=3, argv[]={&#34;helloworld.cc&#34;, &#34;Hello&#34;, &#34;World&#34;})
  icpp -O3 helloworld.cc
  icpp -O0 -p/path/to/profile.json helloworld.cc
  icpp -I/qt/include -L/qt/lib -llibQtCore.so hellowrold.cc
  icpp -I/qt/include -L/qt/lib -lQtCore.dll hellowrold.cc
  icpp -I/qt/include -F/qt/framework -fQtCore hellowrold.cc

Run an executable, e.g.:
  icpp -p/path/to/trace.json helloworld.exe
  icpp -p/path/to/profile.json helloworld

Run an installed module, e.g.:
  icpp helloworld
  icpp helloworld -- hello world

Run an C++ expression, e.g:
  icpp &#34;puts(std::format(\&#34;{:x}\&#34;, 88888888).data())&#34;"><pre>vpand@MacBook-Pro icpp % icpp -h              
OVERVIEW: ICPP v0.1.0.255 based on Unicorn and Clang/LLVM.
  Interpreting C++, running C++ <span>in</span> anywhere like a script.

USAGE: icpp [options] exec0 [exec1 ...] [[--] args]
OPTIONS:
  -v, -version: print icpp version.
  --version: print icpp and clang version.
  -h, -help: print icpp <span>help</span> list.
  --help: print icpp and clang <span>help</span> list.
  -f: format the input <span>source</span> file as LLVM code style.
  -O0, -O1, -O2, -O3, -Os, -Oz: optimization level passed to clang, default to -O2.
  -I/path/to/include: header include directory passed to clang.
  -L/path/to/library: library search directory passed to icpp interpreter.
  -lname: full name of the dependent library file passed to icpp interpreter, e.g.: liba.dylib, liba.so, a.dll.
  -F/path/to/framework: framework search directory passed to icpp interpreter.
  -fname: framework name of the dependent library file passed to icpp interpreter.
  -p/path/to/json: professional json configuration file <span>for</span> trace/profile/plugin/etc..
FILES: input file can be C++ <span>source</span> code(.c/.cc/.cpp/.cxx), MachO/ELF/PE executable.
ARGS: arguments passed to the main entry <span>function</span> <span>of</span> the input files.

Run a C++ <span>source</span> file, e.g.:
  icpp helloworld.cc
  icpp helloworld.cc -- Hello World (i.e.: argc=3, argv[]={<span><span>&#34;</span>helloworld.cc<span>&#34;</span></span>, <span><span>&#34;</span>Hello<span>&#34;</span></span>, <span><span>&#34;</span>World<span>&#34;</span></span>})
  icpp -O3 helloworld.cc
  icpp -O0 -p/path/to/profile.json helloworld.cc
  icpp -I/qt/include -L/qt/lib -llibQtCore.so hellowrold.cc
  icpp -I/qt/include -L/qt/lib -lQtCore.dll hellowrold.cc
  icpp -I/qt/include -F/qt/framework -fQtCore hellowrold.cc

Run an executable, e.g.:
  icpp -p/path/to/trace.json helloworld.exe
  icpp -p/path/to/profile.json helloworld

Run an installed module, e.g.:
  icpp helloworld
  icpp helloworld -- hello world

Run an C++ expression, e.g:
  icpp <span><span>&#34;</span>puts(std::format(<span>\&#34;</span>{:x}<span>\&#34;</span>, 88888888).data())<span>&#34;</span></span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="vpand@MacBook-Pro icpp % icpp     
ICPP v0.1.0.255. Copyright (c) vpand.com.
Running C++ in anywhere like a script.
&gt;&gt;&gt; #include &lt;stdio.h&gt;
&gt;&gt;&gt; puts(&#34;Hello, world.&#34;)   
Hello, world.
&gt;&gt;&gt; import std 
&gt;&gt;&gt; std::cout &lt;&lt; &#34;Hello, world.&#34; &lt;&lt; std::endl
Hello, world.
&gt;&gt;&gt; std::cout &lt;&lt; std::hex &lt;&lt; 88888888 &lt;&lt; std::endl
54c5638"><pre>vpand@MacBook-Pro icpp % icpp     
ICPP v0<span>.1.0.255</span>. Copyright (c) vpand.com.
Running C++ in anywhere like a script.
&gt;&gt;&gt; #include &lt;stdio.h&gt;
&gt;&gt;&gt; <span>puts</span>(<span><span>&#34;</span>Hello, world.<span>&#34;</span></span>)   
Hello, world.
&gt;&gt;&gt; import std 
&gt;&gt;&gt; std::cout &lt;&lt; &#34;Hello, world.&#34; &lt;&lt; std::endl
Hello, world.
&gt;&gt;&gt; std::cout &lt;&lt; std::hex &lt;&lt; 88888888 &lt;&lt; std::endl
54c5638</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="vpand@MacBook-Pro icpp % imod -h                
OVERVIEW: ICPP, Interpreting C++, running C++ in anywhere like a script.
  IObject Module Manager Tool built with ICPP v0.1.0.255
USAGE: imod [options]

OPTIONS:

ICPP Module Manager Options:

  --create=&lt;string&gt;    - Create an icpp package from a json configuration file.
  --install=&lt;string&gt;   - Install an icpp package file.
  --list               - List all the installed modules.
  --uninstall=&lt;string&gt; - Uninstall an installed module."><pre>vpand@MacBook-Pro icpp % imod -h                
OVERVIEW: ICPP, Interpreting C++, running C++ <span>in</span> anywhere like a script.
  IObject Module Manager Tool built with ICPP v0.1.0.255
USAGE: imod [options]

OPTIONS:

ICPP Module Manager Options:

  --create=<span>&lt;</span>string<span>&gt;</span>    - Create an icpp package from a json configuration file.
  --install=<span>&lt;</span>string<span>&gt;</span>   - Install an icpp package file.
  --list               - List all the installed modules.
  --uninstall=<span>&lt;</span>string<span>&gt;</span> - Uninstall an installed module.</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="vpand@MacBook-Pro icpp % iopad -h
OVERVIEW: ICPP, Interpreting C++, running C++ in anywhere like a script.
  IObject Launch Pad Tool built with ICPP v0.1.0.255
USAGE: iopad [options]

OPTIONS:

ICPP Interpretable Object Launch Pad Options:

  --fire=&lt;string&gt;   - Fire the input source file to the connected remote icpp-gadget to execute it.
  --incdir=&lt;string&gt; - Specify the include directory for compilation, can be multiple.
  --ip=&lt;string&gt;     - Set the remote ip address of icpp-gadget.
  --ndk=&lt;string&gt;    - Set the Android NDK root path, default to the parent directory of the ndk-build in PATH.
  --port=&lt;int&gt;      - Set the connection port.
  --repl            - Enter into a REPL interactive shell to fire the input snippet code to the connected remote icpp-gadget to execute it."><pre>vpand@MacBook-Pro icpp % iopad -h
OVERVIEW: ICPP, Interpreting C++, running C++ <span>in</span> anywhere like a script.
  IObject Launch Pad Tool built with ICPP v0.1.0.255
USAGE: iopad [options]

OPTIONS:

ICPP Interpretable Object Launch Pad Options:

  --fire=<span>&lt;</span>string<span>&gt;</span>   - Fire the input <span>source</span> file to the connected remote icpp-gadget to execute it.
  --incdir=<span>&lt;</span>string<span>&gt;</span> - Specify the include directory <span>for</span> compilation, can be multiple.
  --ip=<span>&lt;</span>string<span>&gt;</span>     - Set the remote ip address of icpp-gadget.
  --ndk=<span>&lt;</span>string<span>&gt;</span>    - Set the Android NDK root path, default to the parent directory of the ndk-build <span>in</span> PATH.
  --port=<span>&lt;</span>int<span>&gt;</span>      - Set the connection port.
  --repl            - Enter into a REPL interactive shell to fire the input snippet code to the connected remote icpp-gadget to execute it.</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="vpand@MacBook-Pro icpp % icpp-server -h
OVERVIEW: ICPP, Interpreting C++, running C++ in anywhere like a script.
  Remote icpp-gadget server built with ICPP v0.1.0.255
USAGE: icpp-server [options]

OPTIONS:

ICPP Remote Gadget Server Options:

  --port=&lt;int&gt; - Set the listening port."><pre>vpand@MacBook-Pro icpp % icpp-server -h
OVERVIEW: ICPP, Interpreting C++, running C++ <span>in</span> anywhere like a script.
  Remote icpp-gadget server built with ICPP v0.1.0.255
USAGE: icpp-server [options]

OPTIONS:

ICPP Remote Gadget Server Options:

  --port=<span>&lt;</span>int<span>&gt;</span> - Set the listening port.</pre></div>


<markdown-accessiblity-table><table>
<thead>
<tr>
<th>OS</th>
<th>C/C++ Source</th>
<th>Executable Binary</th>
<th>X86_64 on AArch64</th>
<th>AArch64 on X86_64</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Windows</strong></td>
<td>âœ”</td>
<td>âœ˜</td>
<td>âœ˜</td>
<td>âœ˜</td>
</tr>
<tr>
<td><strong>macOS</strong></td>
<td>âœ”</td>
<td>âœ˜</td>
<td>âœ˜</td>
<td>âœ˜</td>
</tr>
<tr>
<td><strong>Linux</strong></td>
<td>âœ”</td>
<td>âœ˜</td>
<td>âœ˜</td>
<td>âœ˜</td>
</tr>
<tr>
<td><strong>Android</strong></td>
<td>âœ”</td>
<td>âœ˜</td>
<td>âœ˜</td>
<td>âœ˜</td>
</tr>
<tr>
<td><strong>iOS</strong></td>
<td>âœ”</td>
<td>âœ˜</td>
<td>âœ˜</td>
<td>âœ˜</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<ul dir="auto">
<li>Microsoft: Windows x86_64 &gt;= <strong>10</strong>, Windows arm64 &gt;= <strong>11</strong>;</li>
<li>Apple: macOS x86_64 &gt;= <strong>10.15</strong>, macOS arm64 &gt;= <strong>11.3</strong>;</li>
<li>iOS: iOS arm64 &gt;= <strong>10.0</strong>;</li>
<li>Linux: <strong>Ubuntu</strong> x86_64/aarch64 &gt;= <strong>22.04</strong>;</li>
<li>Android: Android x86_64/arm64-v8a &gt;= <strong>platform 25</strong>;</li>
</ul>

<p dir="auto">To build your own version of icpp, make sure all of the <strong>prerequisites</strong> are in your system PATH environment:</p>
<ul dir="auto">
<li><strong>CMake</strong> (version &gt;= 3.20);</li>
<li><strong>Python</strong> (Windows), Python3 (macOS/Linux);</li>
<li><strong>Ninja</strong> (Windows), <strong>Make</strong> (macOS/Linux);</li>
<li>Visual Studio with <strong>LLVM Toolchain</strong> (Windows);</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="# clone icpp
git clone --depth=1 https://github.com/vpand/icpp.git
cd icpp
# clone llvm, unicorn engine, boost, etc.
git submodule update --init --recursive --depth=1
mkdir build
cd build"><pre><span><span>#</span> clone icpp</span>
git clone --depth=1 https://github.com/vpand/icpp.git
<span>cd</span> icpp
<span><span>#</span> clone llvm, unicorn engine, boost, etc.</span>
git submodule update --init --recursive --depth=1
mkdir build
<span>cd</span> build</pre></div>


<div dir="auto" data-snippet-clipboard-copy-content="# NOTE:
# all the following steps must be done in &#34;x64 Native Tools Command Prompt for VS&#34;
# or
# run VS_ROOT/.../VC/Auxiliary/Build/vcvarsall.bat to initialize for &#39;x64&#39;
vcvarsall x64
# we use clang-cl as our compiler, to make it working, you should:
# have installed the Visual Studio with LLVM Toolchain support.
cmake -G Ninja -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_BUILD_TYPE=Release .."><pre><span><span>#</span> NOTE:</span>
<span><span>#</span> all the following steps must be done in &#34;x64 Native Tools Command Prompt for VS&#34;</span>
<span><span>#</span> or</span>
<span><span>#</span> run VS_ROOT/.../VC/Auxiliary/Build/vcvarsall.bat to initialize for &#39;x64&#39;</span>
vcvarsall x64
<span><span>#</span> we use clang-cl as our compiler, to make it working, you should:</span>
<span><span>#</span> have installed the Visual Studio with LLVM Toolchain support.</span>
cmake -G Ninja -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_BUILD_TYPE=Release ..</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# NOTE:
# all the following steps must be done in &#34;ARM64 Native Tools Command Prompt for VS&#34;
# or
# run VS_ROOT/.../VC/Auxiliary/Build/vcvarsall.bat to initialize for &#39;arm64&#39;
vcvarsall arm64
# we use clang-cl as our compiler, to make it working, you should:
# have installed the Visual Studio with LLVM Toolchain support.
#
# Because of the cmake script of boost and unicorn has kind of hardcode snippet for 
# some paths, like the path of lib.exe, assembler search directory, so we have some 
# extra steps to make this cmake command working:
# 1.copy llvm-lib.exe as lib.exe in LLVM_ROOT/bin;
# 2.copy VC_ROOT/bin/armasm64.exe to LLVM_ROOT/bin/armasm64.exe.exe;
# 3.build cmake/boost/armasm64 and copy it to LLVM_ROOT/bin/armasm64.exe;
#
cmake -G Ninja -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_MT=llvm-mt -DCMAKE_ASM_MASM_COMPILE_OBJECT=armasm64 -DCMAKE_BUILD_TYPE=Release .."><pre><span><span>#</span> NOTE:</span>
<span><span>#</span> all the following steps must be done in &#34;ARM64 Native Tools Command Prompt for VS&#34;</span>
<span><span>#</span> or</span>
<span><span>#</span> run VS_ROOT/.../VC/Auxiliary/Build/vcvarsall.bat to initialize for &#39;arm64&#39;</span>
vcvarsall arm64
<span><span>#</span> we use clang-cl as our compiler, to make it working, you should:</span>
<span><span>#</span> have installed the Visual Studio with LLVM Toolchain support.</span>
<span><span>#</span></span>
<span><span>#</span> Because of the cmake script of boost and unicorn has kind of hardcode snippet for </span>
<span><span>#</span> some paths, like the path of lib.exe, assembler search directory, so we have some </span>
<span><span>#</span> extra steps to make this cmake command working:</span>
<span><span>#</span> 1.copy llvm-lib.exe as lib.exe in LLVM_ROOT/bin;</span>
<span><span>#</span> 2.copy VC_ROOT/bin/armasm64.exe to LLVM_ROOT/bin/armasm64.exe.exe;</span>
<span><span>#</span> 3.build cmake/boost/armasm64 and copy it to LLVM_ROOT/bin/armasm64.exe;</span>
<span><span>#</span></span>
cmake -G Ninja -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_MT=llvm-mt -DCMAKE_ASM_MASM_COMPILE_OBJECT=armasm64 -DCMAKE_BUILD_TYPE=Release ..</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# create the clang to be customized building scripts
cmake -B clangconf -DCMAKE_BUILD_TYPE=Release ../cmake/clangconf
# build our clang compiler with itself&#39;s libc++ support
cmake --build clangconf -- clang runtimes -j8
# use the clang that we built before as our compiler
cmake -DCMAKE_C_COMPILER=$PWD/llvm/bin/clang -DCMAKE_CXX_COMPILER=$PWD/llvm/bin/clang -DCMAKE_BUILD_TYPE=Release .."><pre><span><span>#</span> create the clang to be customized building scripts</span>
cmake -B clangconf -DCMAKE_BUILD_TYPE=Release ../cmake/clangconf
<span><span>#</span> build our clang compiler with itself&#39;s libc++ support</span>
cmake --build clangconf -- clang runtimes -j8
<span><span>#</span> use the clang that we built before as our compiler</span>
cmake -DCMAKE_C_COMPILER=<span>$PWD</span>/llvm/bin/clang -DCMAKE_CXX_COMPILER=<span>$PWD</span>/llvm/bin/clang -DCMAKE_BUILD_TYPE=Release ..</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# if your system default clang doesn&#39;t support C++20 before the version of macOS 14,
# you should compile your own clang and apply it like on Linux.
#
# This is a very complicated process. So I strongly recommend that you update your 
# macOS and Xcode to the latest version to have the C++20 support to simplify the building.
cmake -DCMAKE_BUILD_TYPE=Release .."><pre><span><span>#</span> if your system default clang doesn&#39;t support C++20 before the version of macOS 14,</span>
<span><span>#</span> you should compile your own clang and apply it like on Linux.</span>
<span><span>#</span></span>
<span><span>#</span> This is a very complicated process. So I strongly recommend that you update your </span>
<span><span>#</span> macOS and Xcode to the latest version to have the C++20 support to simplify the building.</span>
cmake -DCMAKE_BUILD_TYPE=Release ..</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# build the protoc compiler
cmake --build . -- protoc -j8
# build all the icpp components
cmake --build . -- icpp icppcli imod iopad icpp-gadget icpp-server -j8"><pre><span><span>#</span> build the protoc compiler</span>
cmake --build <span>.</span> -- protoc -j8
<span><span>#</span> build all the icpp components</span>
cmake --build <span>.</span> -- icpp icppcli imod iopad icpp-gadget icpp-server -j8</pre></div>

<p dir="auto">The newly built naked icpp needs the include/lib related stuff to work. The simplest way to run your own version is to replace the binary in the official release package. If you want to run it in the build directory, you need to construct the directory layout just like in the release package. e.g:</p>
<div dir="auto" data-snippet-clipboard-copy-content="build:
---include
------header-related
---src
------icpp
---lib
------lib-related"><pre>build:
---include
------header-related
---src
------icpp
---lib
------lib-related</pre></div>

<p dir="auto">If you encounter any problems when using icpp, before opening an issue, please check the <a href="https://github.com/vpand/icpp/blob/main/.github/ISSUE_TEMPLATE/bug_report.md">Bug Report</a> template, and provide as many details as you can. Only if we can reproduce the problem, we can then solve it.</p>

<p dir="auto">You can visit <a href="https://vpand.com/" rel="nofollow">vpand.com</a> for more information on <strong>VM, VMProtect, Clang/LLVM and Reverse Engineering</strong> products.</p>
<p dir="auto">Or if you have any questions, just feel free to email to me:</p>

</article></div></div>
  </body>
</html>
