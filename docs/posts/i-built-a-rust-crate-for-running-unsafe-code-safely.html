<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/brannondorsey/mem-isolate">Original</a>
    <h1>Show HN: I built a Rust crate for running unsafe code safely</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://github.com/brannondorsey/mem-isolate/actions/workflows/build.yml"><img src="https://github.com/brannondorsey/mem-isolate/actions/workflows/build.yml/badge.svg" alt="Build Status"/></a></p>
<p dir="auto"><code>mem-isolate</code> runs your function via a <code>fork()</code>, waits for the result, and returns it.</p>
<p dir="auto">This grants your code access to an exact copy of memory and state at the time just before the call, but guarantees that the function will not affect the parent process&#39;s memory footprint in any way.</p>
<p dir="auto">It forces functions to be <em>memory pure</em> (pure with respect to memory), even if they aren&#39;t.</p>
<div dir="auto" data-snippet-clipboard-copy-content="use mem_isolate::execute_in_isolated_process;

// No heap, stack, or program memory out here...
let result = mem_isolate::execute_in_isolated_process(|| {
    // ...Can be affected by anything in here
    unsafe {
        gnarly_cpp_bindings::potentially_leaking_function();
        unstable_ffi::segfault_prone_function();
        heap_fragmenting_operation();
        something_that_panics_in_a_way_you_could_recover_from();
    }
});"><pre><span>use</span> mem_isolate<span>::</span>execute_in_isolated_process<span>;</span>

<span>// No heap, stack, or program memory out here...</span>
<span>let</span> result = mem_isolate<span>::</span><span>execute_in_isolated_process</span><span>(</span>|| <span>{</span>
    <span>// ...Can be affected by anything in here</span>
    <span>unsafe</span> <span>{</span>
        gnarly_cpp_bindings<span>::</span><span>potentially_leaking_function</span><span>(</span><span>)</span><span>;</span>
        unstable_ffi<span>::</span><span>segfault_prone_function</span><span>(</span><span>)</span><span>;</span>
        <span>heap_fragmenting_operation</span><span>(</span><span>)</span><span>;</span>
        <span>something_that_panics_in_a_way_you_could_recover_from</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Example use cases:</p>
<ul dir="auto">
<li>Run code with a known memory leak</li>
<li>Run code that fragments the heap</li>
<li>Run <code>unsafe</code> code</li>
<li>Run your code 1ms slower (<em>har har</em> ðŸ˜‰, see <a href="#limitations">limitations</a>)</li>
</ul>
<blockquote>
<p dir="auto">NOTE: Because of its heavy use of POSIX system calls, this crate only supports Unix-like operating systems (e.g., Linux, macOS, BSD). Windows and wasm support are not planned at this time.</p>
</blockquote>
<p dir="auto">See the <a href="https://github.com/brannondorsey/mem-isolate/blob/main/examples">examples/</a> for more uses, especially <a href="https://github.com/brannondorsey/mem-isolate/blob/main/examples/error-handling-basic.rs">the basic error handling example</a>.</p>

<p dir="auto">POSIX systems use the <code>fork()</code> system call to create a new child process that is a copy of the parent. On modern systems, this is relatively cheap (~1ms) even if the parent process is using a lot of memory at the time of the call. This is because the OS uses copy-on-write memory techniques to avoid duplicating the entire memory of the parent process. At the time <code>fork()</code> is called, the parent and child all share the same physical pages in memory. Only when one of them modifies a page is it copied to a new location.</p>
<p dir="auto"><code>mem-isolate</code> uses this implementation detail as a nifty hack to provide a <code>callable</code> function with a temporary and isolated memory space. You can think of this isolation almost like a snapshot is taken of your program&#39;s memory at the time <code>execute_in_isolated_process()</code> is called, which will be restored once the user-supplied <code>callable</code> function has finished executing.</p>
<p dir="auto">When <code>execute_in_isolated_process()</code> is called, the process will:</p>
<ol dir="auto">
<li>Create a <code>pipe()</code> for inter-process communication between the process <em>it</em> has been invoked in (the &#34;parent&#34;) and the new child process that will be created to isolate and run your <code>callable</code></li>
<li><code>fork()</code> a new child process</li>
<li>Execute the user-supplied <code>callable</code> in the child process and deliver its result back to the parent process through the pipe</li>
<li>Wait for the child process to finish with <code>waitpid()</code></li>
<li>Return the result to the parent process</li>
</ol>
<p dir="auto">We call this trick the &#34;fork and free&#34; pattern. It&#39;s pretty nifty. ðŸ«°</p>

<ul dir="auto">
<li>Works only on POSIX systems (Linux, macOS, BSD)</li>
<li>Data returned from the <code>callable</code> function must be serialized to and from the child process (using <code>serde</code>), which can be expensive for large data.</li>
<li>Excluding serialization/deserialization cost, <code>execute_in_isolated_process()</code> introduces runtime overhead on the order of ~1ms compared to a direct invocation of the <code>callable</code>.</li>
</ul>
<p dir="auto">In performance critical systems, these overheads can be no joke. However, for many use cases, this is an affordable trade-off for the memory safety and snapshotting behavior that <code>mem-isolate</code> provides.</p>

<p dir="auto">In a <a href="https://github.com/brannondorsey/mem-isolate/blob/main/benches/benchmarks.rs">simple benchmark</a>, raw function calls are ~1.5ns, <code>fork()</code> + wait is ~1.7ms, and <code>execute_in_isolated_process()</code> is about 1.9ms. That&#39;s very slow by comparison, but tolerable for many use cases where memory safety is paramount.</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo bench
    Finished `bench` profile [optimized] target(s) in 0.07s
     Running unittests src/lib.rs (target/release/deps/mem_isolate-d96fcfa5f2fd31c0)

running 3 tests
test tests::simple_example ... ignored
test tests::test_static_memory_mutation_with_isolation ... ignored
test tests::test_static_memory_mutation_without_isolation ... ignored

test result: ok. 0 passed; 0 failed; 3 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running benches/benchmarks.rs (target/release/deps/benchmarks-25c74db99f107a73)
Overhead/direct_function_call
                        time:   [1.4347 ns 1.4357 ns 1.4370 ns]
                        change: [-1.4983% +0.6412% +3.4486%] (p = 0.55 &gt; 0.05)
                        No change in performance detected.
Found 11 outliers among 100 measurements (11.00%)
  4 (4.00%) high mild
  7 (7.00%) high severe
Overhead/fork_alone     time:   [1.6893 ms 1.6975 ms 1.7062 ms]
                        change: [+1.3025% +3.8968% +5.7914%] (p = 0.01 &lt; 0.05)
                        Performance has regressed.
Found 2 outliers among 100 measurements (2.00%)
  1 (1.00%) high mild
  1 (1.00%) high severe
Overhead/execute_in_isolated_process
                        time:   [1.8769 ms 1.9007 ms 1.9226 ms]
                        change: [-7.6229% -5.7657% -3.7073%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 1 outliers among 100 measurements (1.00%)
  1 (1.00%) low severe"><pre>cargo bench
    Finished `bench` profile [optimized] target(s) in 0.07s
     Running unittests src/lib.rs (target/release/deps/mem_isolate-d96fcfa5f2fd31c0)

running 3 tests
test tests::simple_example ... ignored
test tests::test_static_memory_mutation_with_isolation ... ignored
test tests::test_static_memory_mutation_without_isolation ... ignored

test result: ok. 0 passed; 0 failed; 3 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running benches/benchmarks.rs (target/release/deps/benchmarks-25c74db99f107a73)
Overhead/direct_function_call
                        time:   [1.4347 ns 1.4357 ns 1.4370 ns]
                        change: [-1.4983% +0.6412% +3.4486%] (p = 0.55 &gt; 0.05)
                        No change in performance detected.
Found 11 outliers among 100 measurements (11.00%)
  4 (4.00%) high mild
  7 (7.00%) high severe
Overhead/fork_alone     time:   [1.6893 ms 1.6975 ms 1.7062 ms]
                        change: [+1.3025% +3.8968% +5.7914%] (p = 0.01 &lt; 0.05)
                        Performance has regressed.
Found 2 outliers among 100 measurements (2.00%)
  1 (1.00%) high mild
  1 (1.00%) high severe
Overhead/execute_in_isolated_process
                        time:   [1.8769 ms 1.9007 ms 1.9226 ms]
                        change: [-7.6229% -5.7657% -3.7073%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 1 outliers among 100 measurements (1.00%)
  1 (1.00%) low severe</pre></div>
<p dir="auto">All benchmarks were run on a ThinkPad T14 Gen 4 AMD (14â€³) laptop with a AMD Ryzen 5 PRO 7540U CPU @ 3.2Ghz max clock speed and 32 GB of RAM. The OS used was Debian 13 with Linux kernel 6.12.</p>

<p dir="auto"><code>mem-isolate</code> is dual-licensed under either of:</p>
<ul dir="auto">
<li><a href="https://opensource.org/license/mit" rel="nofollow">MIT license</a></li>
<li><a href="https://opensource.org/license/apache-2-0" rel="nofollow">Apache License, Version 2.0</a></li>
</ul>
<p dir="auto">at your option.</p>

<p dir="auto">Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you shall be dual licensed as above, without any
additional terms or conditions.</p>
</article></div></div>
  </body>
</html>
