<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://future.mozilla.org/news/llamafiles-for-embeddings-in-local-rag-applications/">Original</a>
    <h1>Using Llamafiles for Embeddings in Local RAG Applications</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    

    
    
    

    

    

    
      <p>A good text embedding model is the lynchpin of retrieval-augmented generation (RAG). Given the computational cost of indexing large datasets in a vector store, we think <a href="https://github.com/Mozilla-Ocho/llamafile">llamafile</a> is a great option for scaleable RAG on local hardware, especially given llamafile&#39;s ongoing <a href="https://justine.lol/matmul/">performance optimizations</a>. </p>
<p>To make local RAG easier, we found some of the best embedding models with respect to performance on RAG-relevant tasks and released them as llamafiles. In this post, we&#39;ll talk about these models and why we chose them. We&#39;ll also show how to use one of these llamafiles to build a local RAG app.</p>
<p>Note: This post only covers English-language models. Some of them might be multi-lingual but we did not take into account performance on non-English tasks when finding models to recommend. </p>
<table>
<thead>
<tr>
<th></th>
<th>Model</th>
<th>License</th>
<th>Memory Usage (GP, fp32)</th>
<th>Embedding Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Best overall</strong></td>
<td><a href="https://huggingface.co/Salesforce/SFR-Embedding-Mistral">Salesforce/SFR-Embedding-Mistral</a></td>
<td>CC-by-NC</td>
<td>26.49</td>
<td>4,096</td>
</tr>
<tr>
<td><strong>Best overall, commercial-friendly license</strong></td>
<td><a href="https://huggingface.co/intfloat/e5-mistral-7b-instruct">intfloat/e5-mistral-7b-instruct</a></td>
<td>MIT</td>
<td>26.49</td>
<td>4,096</td>
</tr>
<tr>
<td><strong>Best small</strong></td>
<td><a href="https://huggingface.co/mixedbread-ai/mxbai-embed-large-v1">mixedbread-ai/mxbai-embed-large-v1</a></td>
<td>Apache 2</td>
<td>1.25</td>
<td>1,024</td>
</tr>
</tbody>
</table>
<p><strong>Best overall:</strong> <a href="https://huggingface.co/Salesforce/SFR-Embedding-Mistral">Salesforce/SFR-Embedding-Mistral</a> (<a href="https://huggingface.co/Mozilla/SFR-Embedding-Mistral-llamafile">llamafile link</a>). Why does it work so well? They carried out additional, multi-task finetuning on top of <a href="https://huggingface.co/intfloat/e5-mistral-7b-instruc">intfloat/e5-mistral-7b-instruct</a> using the training datasets of several tasks in the <a href="https://huggingface.co/spaces/mteb/leaderboard">Massive Text Embedding Benchmark (MTEB)</a>. For more details, see their <a href="https://blog.salesforceairesearch.com/sfr-embedded-mistral/">blog post</a>.</p>
<p><strong>Best overall, commercial-friendly license:</strong> <a href="https://huggingface.co/intfloat/e5-mistral-7b-instruct">intfloat/e5-mistral-7b-instruct</a>  (<a href="https://huggingface.co/Mozilla/e5-mistral-7b-instruct/">llamafile link</a>). Why does it work so well? Synthetic data generation. The authors finetune <a href="https://huggingface.co/mistralai/Mistral-7B-v0.1">mistral-7b-instruct</a> on various synthetic text embedding datasets generated by another LLM. For more information, see their <a href="https://arxiv.org/pdf/2401.00368">paper</a>.</p>
<p><strong>Best small:</strong> <a href="https://huggingface.co/mixedbread-ai/mxbai-embed-large-v1">mixedbread-ai/mxbai-embed-large-v1</a> (<a href="https://huggingface.co/Mozilla/mxbai-embed-large-v1-llamafile/tree/main">llamafile link</a>). Why does it work so well? Data building and curation. The authors scraped and curated 700 million text pairs and trained a BERT model using contrastive training. Then, they finetuned the model on an additional 30 million text triplets using AngIE loss. For more information, see their <a href="https://www.mixedbread.ai/blog/mxbai-embed-large-v1">blog post</a>.</p>
<h2>Which embedding model should I use?</h2>
<p>The embedding model you should pick for your app depends on a variety of factors: </p>
<p><strong>Model size and memory constraints:</strong> The larger models require more memory and are slower, so if you have lots of memory available, go with <code>SFR-Embedding-Mistral</code> or <code>e5-mistral-7b-instruct</code>. Otherwise, go with the smaller <code>mxbai-embed-large-v1</code>. In addition, if you have limited indexing time or you have a very large collection of documents to index, a smaller model will get the job done much faster.</p>
<p><strong>Document length:</strong> You should also consider the type of data you&#39;d like to &#34;store&#34; in your embeddings. The larger models have a longer max sequence length, so they can stuff a longer document into an embedding. Smaller models tend to be more suited to short texts like a sentence or maybe a paragraph. (However, if you&#39;re memory-bound and want to use a smaller model to index longer documents, you can just snippetize the docs into smaller pieces.) In this post, we did not specifically look at model performance by text length, so if you&#39;re looking for a model for long documents, you may have to go through your own evaluation process.</p>
<p><strong>Generation model size:</strong> Also note that you may have to use a separate model or llamafile for the &#39;generation&#39; part of RAG. <code>mxbai-embed-large-v1</code> does not generate text at all (in fact, you&#39;ll get an error if you attempt this) and, since the larger models were fine-tuned specifically for embedding tasks, their generation capabilities might be somewhat worse than a model tuned for text generation. You may need to account for this when choosing a model. You&#39;ll need enough memory available for both the embedding model and the text generation model, assuming you&#39;ll be running them on the same machine.</p>
<p>We&#39;ll also mention that the authors of the <a href="https://huggingface.co/spaces/mteb/leaderboard">MTEB benchmark</a>--a widely-used embeddings benchmark suite described in more detail below--wrote a great <a href="https://huggingface.co/blog/lyon-nlp-group/mteb-leaderboard-best-practices">companion guide</a> to using their leaderboard for model selection. Their post provides a lot more detail about the model selection process than we do here and is an excellent guide to choosing an embedding model for your specific task/data. We highly recommend reading that so you can decide whether the models we recommend are actually right for your use case. </p>
<h2>How do I use these llamafiles in my RAG app?</h2>
<p>Llamafile is now integrated with two popular RAG app development frameworks:</p>
<ul>
<li>LlamaIndex: <a href="https://www.llamaindex.ai/blog/using-llamaindex-and-llamafile-to-build-a-local-private-research-assistant">tutorial</a></li>
<li>LangChain: <a href="https://python.langchain.com/v0.1/docs/get_started/quickstart/">quickstart</a>, <a href="https://python.langchain.com/docs/integrations/text_embedding/llamafile/">llamafile embeddings doc</a></li>
</ul>
<p>We recommend getting familiar with one of these two frameworks via their respective quickstart guides, then following the llamafile-specific documentation at one of the links above.</p>
<p>In addition to the higher-level libraries above, we&#39;ve provided a very minimal example of a local RAG app using llamafile <a href="https://github.com/Mozilla-Ocho/llamafile-rag-example">here</a>.</p>
<h2>How did we choose these models? The short version...</h2>
<p>As our starting point, we looked at the Massive Text Embedding Benchmark (MTEB)  <a href="https://huggingface.co/spaces/mteb/leaderboard">leaderboard</a>, which evaluates models across a diverse battery of tasks that use text embeddings in various ways. The benchmark includes 7 task categories: classification, pair classification, clustering, reranking, retrieval, semantic textual similarity (STS), and summarization. Each task category is associated with a collection of datasets, e.g. the retrieval task includes datasets like <a href="https://huggingface.co/datasets/ms_marco">MS MARCO</a> and <a href="https://huggingface.co/datasets/BeIR/quora">QuoraRetrieval</a>. Models are evaluated on each dataset, then model scores are aggregated by task category. The final leaderboard ranking is determined by the average model score across all task categories.</p>
<p>However, you might notice that the models we recommend above are different from the top-ranked models according to this leaderboard. This is because we made two modifications during our selection process.</p>
<p>First, we filtered the results to include only &#34;RAG-relevant&#34; MTEB task categories that test embeddings in a scenario similar to how they might be used in a RAG application, where you need to retrieve text snippets related to a query from a vector store. We kept results related to clustering, reranking, retrieval, and semantic textual similarity (STS) and ignored results related to classification, pair classification, and summarization. </p>
<p>Second, we used a different metric to determine the overall ranking of models in the leaderboard. While the MTEB leaderboard (and many others) rank according to average model score across tasks, we instead determine the final ranking using <em>mean task rank</em>, or <em>MTR</em>. Essentially, instead of averaging across raw model score on each task, we rank each model on each MTEB dataset, then take the average across those ranks to get the model&#39;s MTR. </p>
<p>Why? In brief: Each task category uses its own metric, so model scores on different datasets don&#39;t necessarily have the same &#34;units&#34;. STS scores tend to fall around 80 whereas retrieval task scores are much lower, in the mid-50s. Since scores on different task types/datasets are not necessarily commensurate, it doesn&#39;t make a lot of sense to average across them. So, instead of averaging across raw model scores, we average across model <em>rank</em>. This essentially maps all the scores into the same shared &#34;unit&#34;. We didn&#39;t come up with this ourselves: This follows the advice for multiple comparisons across multiple datasets detailed in <a href="https://www.jmlr.org/papers/volume7/demsar06a/demsar06a.pdf"><em>Statistical Comparisons of Classifiers over Multiple Data Sets</em></a> (Demšar, 2006). For a longer explanation of this process, see the <a href="#Appendix">Appendix</a>.</p>
<p>After these two changes, our top-10 leaderboard looks like:</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Model</th>
<th>RAG MTR%</th>
<th>RAG Average (40 datasets)</th>
<th>Clustering Average (11 datasets)</th>
<th>Reranking Average (4 datasets)</th>
<th>Retrieval Average (15 datasets)</th>
<th>STS Average (10 datasets)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SFR-Embedding-Mistral</td>
<td>5.72</td>
<td>63.66</td>
<td>51.67</td>
<td>60.64</td>
<td>59.00</td>
<td>85.05</td>
</tr>
<tr>
<td>2</td>
<td>e5-mistral-7b-instruct</td>
<td>9.92</td>
<td>62.33</td>
<td>50.26</td>
<td>60.20</td>
<td>56.89</td>
<td>84.63</td>
</tr>
<tr>
<td>3</td>
<td>voyage-large-2-instruct</td>
<td>10.23</td>
<td>63.68</td>
<td>53.35</td>
<td>60.09</td>
<td>58.28</td>
<td>84.58</td>
</tr>
<tr>
<td>4</td>
<td>GritLM-7B</td>
<td>11.91</td>
<td>62.33</td>
<td>50.61</td>
<td>60.49</td>
<td>57.41</td>
<td>83.35</td>
</tr>
<tr>
<td>5</td>
<td>mxbai-embed-large-v1</td>
<td>14.08</td>
<td>60.51</td>
<td>46.71</td>
<td>60.11</td>
<td>54.39</td>
<td>85.00</td>
</tr>
<tr>
<td>6</td>
<td>GritLM-8x7B</td>
<td>14.49</td>
<td>61.24</td>
<td>50.14</td>
<td>59.80</td>
<td>55.09</td>
<td>83.26</td>
</tr>
<tr>
<td>7</td>
<td>UAE-Large-V1</td>
<td>14.74</td>
<td>60.47</td>
<td>46.73</td>
<td>59.88</td>
<td>54.66</td>
<td>84.54</td>
</tr>
<tr>
<td>8</td>
<td>voyage-lite-02-instruct</td>
<td>14.87</td>
<td>62.91</td>
<td>52.42</td>
<td>58.24</td>
<td>56.60</td>
<td>85.79</td>
</tr>
<tr>
<td>9</td>
<td>google-gecko.text-embedding-preview-0409</td>
<td>15.12</td>
<td>61.10</td>
<td>47.48</td>
<td>58.90</td>
<td>55.70</td>
<td>85.07</td>
</tr>
<tr>
<td>10</td>
<td>GIST-large-Embedding-v0</td>
<td>15.71</td>
<td>59.99</td>
<td>46.55</td>
<td>60.05</td>
<td>53.44</td>
<td>84.59</td>
</tr>
</tbody>
</table>
<p>You can see our full, revised leaderboard <a href="https://huggingface.co/spaces/k8si/mteb_leaderboard_mtr">here</a>.</p>
<p>To make our final recommendations, we 1) eliminated the closed-source models (only the <code>voyage</code> and <code>google-gecko</code> models made it into the top 10) and 2) restricted our list to models whose architecture is compatible with the <a href="https://github.com/ggerganov/ggml/blob/master/docs/gguf.md">gguf file format</a> (see also: <a href="https://vickiboykis.com/2024/02/28/gguf-the-long-way-around/">here</a> and <a href="https://vickiboykis.com/2024/02/28/gguf-the-long-way-around/">here</a>), which llamafile requires. </p>
<h2>Conclusion</h2>
<p>We hope this post was helpful for getting started with llamafiles and embeddings. </p>
<p>For reference, here are some of the links referenced in this post:</p>
<ul>
<li><a href="https://github.com/Mozilla-Ocho/llamafile">llamafile on GitHub</a></li>
<li><a href="https://huggingface.co/spaces/mteb/leaderboard">MTEB leaderboard</a> and our <a href="https://huggingface.co/spaces/k8si/mteb_leaderboard_mtr">revised MTEB leaderboard</a></li>
</ul>
<p>If you have questions or feedback, reach out to us on <a href="https://discord.com/channels/1089876418936180786/1182689832057716778">Discord</a>. </p>
<h2>References</h2>
<pre><code>@article{demvsar2006statistical,
  title={Statistical comparisons of classifiers over multiple data sets},
  author={Dem{\v{s}}ar, Janez},
  journal={The Journal of Machine learning research},
  volume={7},
  pages={1--30},
  year={2006},
  publisher={JMLR. org}
}
@article{muennighoff2022mteb,
    doi = {10.48550/ARXIV.2210.07316},
    url = {https://arxiv.org/abs/2210.07316},
    author = {Muennighoff, Niklas and Tazi, Nouamane and Magne, Lo{\&#34;\i}c and Reimers, Nils},
    title = {MTEB: Massive Text Embedding Benchmark},
    publisher = {arXiv},
    journal={arXiv preprint arXiv:2210.07316},  
    year = {2022}
}
</code></pre>

<h2>Appendix</h2>
<h3>How did we choose these models? The long version...</h3>
<p>Now, you might say: &#34;Why did you write such a long post about this? What&#39;s the problem? Just use <code>SFR-Embedding-Mistral</code>, it&#39;s right there at the top!&#34; In the end, you&#39;d be right, but for the wrong reasons.</p>
<p>As the MTEB authors <a href="https://huggingface.co/blog/lyon-nlp-group/mteb-leaderboard-best-practices">note</a>, &#34;Does [the leaderboard] make it easy to choose the right model for your application? You wish!&#34; What they meant was, while this leaderboard is a great way to see embedding quality <em>in general</em>, it doesn&#39;t necessarily make it obvious which model is best for <em>your specific application</em>.</p>
<p>One problem is simply the complexity of the leaderboard, which is actually a good problem! The MTEB benchmark includes hundreds of datasets grouped into 7 broad task categories: classification, clustering, pair classification, reranking, retrieval, semantic textual similarity (STS), and summarization. Some of these task categories--e.g. retrieval, STS--test embeddings in a scenario similar to how they might be used in a RAG application, where you need to retrieve text snippets related to a query from a vector store. Others, like classification, do not. So, looking at overall performance on MTEB tells us a lot about embedding quality <em>in general</em> but the best overall model is not necessarily the best model for RAG applications. </p>
<p>Here&#39;s the top-10 leaderboard showing rank by mean performance across tasks side-by-side with rank by mean performance across RAG-related tasks only:</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>rank by avg</th>
<th>rank by rag avg</th>
<th>avg</th>
<th>rag avg</th>
</tr>
</thead>
<tbody>
<tr>
<td>voyage-large-2-instruct</td>
<td>1</td>
<td>1</td>
<td>68.28</td>
<td>63.68</td>
</tr>
<tr>
<td>SFR-Embedding-Mistral</td>
<td>2</td>
<td>2</td>
<td>67.56</td>
<td>63.66</td>
</tr>
<tr>
<td>gte-Qwen1.5-7B-instruct</td>
<td>3</td>
<td>3</td>
<td>67.34</td>
<td>63.06</td>
</tr>
<tr>
<td>voyage-lite-02-instruct</td>
<td>4</td>
<td>4</td>
<td>67.13</td>
<td>62.91</td>
</tr>
<tr>
<td>GritLM-7B</td>
<td>5</td>
<td>5</td>
<td>66.76</td>
<td>62.33</td>
</tr>
<tr>
<td>e5-mistral-7b-instruct</td>
<td>6</td>
<td>6</td>
<td>66.63</td>
<td>62.33</td>
</tr>
<tr>
<td><strong>GritLM-8x7B</strong></td>
<td><strong>8</strong></td>
<td><strong>7</strong></td>
<td><strong>65.66</strong></td>
<td><strong>61.24</strong></td>
</tr>
<tr>
<td><strong>gte-large-en-v1.5</strong></td>
<td><strong>9</strong></td>
<td><strong>8</strong></td>
<td><strong>65.39</strong></td>
<td><strong>61.11</strong></td>
</tr>
<tr>
<td><strong>google-gecko.text-embedding-preview-0409</strong></td>
<td><strong>7</strong></td>
<td><strong>9</strong></td>
<td><strong>66.31</strong></td>
<td><strong>61.10</strong></td>
</tr>
<tr>
<td>LLM2Vec-Meta-Llama-3-supervised</td>
<td>10</td>
<td>10</td>
<td>65.01</td>
<td>60.87</td>
</tr>
</tbody>
</table>
<p>There isn&#39;t much difference until we get to ranks 7, 8, and 9.</p>
<p>However, there is a second problem with the MTEB leaderboard: regardless of which task subset you use, models are ranked according to their <em>average performance across those tasks</em>. The model with the highest average score across tasks wins. This is a very common way of ranking multiple models across multiple datasets, but just because it&#39;s a common method doesn&#39;t mean it&#39;s a good method. </p>
<p>Here is average model performance for each task type in the RAG subset: </p>
<table>
<thead>
<tr>
<th>Model</th>
<th>rag avg</th>
<th>clustering avg</th>
<th>reranking avg</th>
<th>retrieval avg</th>
<th>STS avg</th>
</tr>
</thead>
<tbody>
<tr>
<td>voyage-large-2-instruct</td>
<td>63.68</td>
<td>53.35</td>
<td>60.09</td>
<td>58.28</td>
<td>84.58</td>
</tr>
<tr>
<td>SFR-Embedding-Mistral</td>
<td>63.66</td>
<td>51.67</td>
<td>60.64</td>
<td>59.00</td>
<td>85.05</td>
</tr>
<tr>
<td>gte-Qwen1.5-7B-instruct</td>
<td>63.06</td>
<td>55.83</td>
<td>60.13</td>
<td>56.24</td>
<td>82.42</td>
</tr>
<tr>
<td>voyage-lite-02-instruct</td>
<td>62.91</td>
<td>52.42</td>
<td>58.24</td>
<td>56.60</td>
<td>85.79</td>
</tr>
<tr>
<td>GritLM-7B</td>
<td>62.33</td>
<td>50.61</td>
<td>60.49</td>
<td>57.41</td>
<td>83.35</td>
</tr>
<tr>
<td>e5-mistral-7b-instruct</td>
<td>62.33</td>
<td>50.26</td>
<td>60.21</td>
<td>56.89</td>
<td>84.63</td>
</tr>
<tr>
<td>GritLM-8x7B</td>
<td>61.24</td>
<td>50.14</td>
<td>59.80</td>
<td>55.09</td>
<td>83.26</td>
</tr>
<tr>
<td>gte-large-en-v1.5</td>
<td>61.11</td>
<td>47.96</td>
<td>58.50</td>
<td>57.91</td>
<td>81.43</td>
</tr>
<tr>
<td>google-gecko.text-embedding-preview-0409</td>
<td>61.10</td>
<td>47.48</td>
<td>58.90</td>
<td>55.70</td>
<td>85.07</td>
</tr>
<tr>
<td>LLM2Vec-Meta-Llama-3-supervised</td>
<td>60.87</td>
<td>46.45</td>
<td>59.68</td>
<td>56.63</td>
<td>83.58</td>
</tr>
</tbody>
</table>
<p>As you can see, there is a lot of variation in the magnitude of scores across the different tasks. STS scores tend to be in the low 80s whereas clustering scores tend to be the high 40s/low 50s. Does it really make sense to average across these numbers?</p>
<p>Note that each task has its own metric. STS uses the <a href="https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient">Spearman correlation coefficient</a> whereas retrieval uses <a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain">NDCG@10</a> (the <a href="https://arxiv.org/abs/2210.07316">MTEB paper</a> lists them all). While all of these task metrics are technically bounded by the range [0, 1], the actual scores models get for these metrics aren&#39;t going to be spread across that interval the same way.</p>
<p>Here are the descriptive statistics for the distribution of model scores on the STS and retrieval tasks:</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>STS</strong></th>
<th>  <strong>Retrieval</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>count</strong></td>
<td>155</td>
<td>  133</td>
</tr>
<tr>
<td><strong>mean</strong></td>
<td>79.26</td>
<td>  44.93</td>
</tr>
<tr>
<td><strong>std</strong></td>
<td>5.86</td>
<td>  10.97</td>
</tr>
<tr>
<td><strong>min</strong></td>
<td>39.10</td>
<td>  7.94</td>
</tr>
<tr>
<td><strong>25%</strong></td>
<td>78.08</td>
<td>  41.17</td>
</tr>
<tr>
<td><strong>50%</strong></td>
<td>80.84</td>
<td>  48.48</td>
</tr>
<tr>
<td><strong>75%</strong></td>
<td>82.58</td>
<td>  51.99</td>
</tr>
<tr>
<td><strong>max</strong></td>
<td>85.79</td>
<td>  59.00</td>
</tr>
</tbody>
</table>
<p>In other words, a good average score on the STS is ~83 and a good average score on the Retrieval task is ~52. </p>
<p>Now let&#39;s say we have two models, Model A and Model B, that get the following scores on these two tasks:</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>STS</strong></th>
<th><strong>Retrieval</strong></th>
<th><strong>Average</strong></th>
<th> <strong>Rank</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Model A</strong></td>
<td> 82.58  (75%)</td>
<td> 41.17  (25%)</td>
<td> 61.88</td>
<td> 2</td>
</tr>
<tr>
<td><strong>Model B</strong></td>
<td> 78.08  (25%)</td>
<td> 51.99  (75%)</td>
<td> 65.04</td>
<td> 1</td>
</tr>
</tbody>
</table>
<p>Model A is good at STS but bad at retrieval; Model B is bad at STS but good at retrieval. Importantly, they are each equally good at one task and equally bad at the other. However, when we rank according to average score, Model B wins. In effect, this ranking method prioritizes the retrieval task over the STS task. This seems pretty arbitrary, since presumably we care about performance on all tasks equally. </p>
<p>So, what&#39;s the alternative? In <em><a href="https://www.jmlr.org/papers/volume7/demsar06a/demsar06a.pdf">Statistical comparisons of classifiers over multiple data sets.</a></em>, Janez Demšar recommends using the non-parametric <a href="https://en.wikipedia.org/wiki/Friedman_test">Friedman test</a> to ascertain whether there is a statistically-significant difference among a set of classifier scores on a set of datasets. The first step of this test is ranking each model on each dataset, then finding the average rank of each model across the tasks. We refer to this metric as <em>mean task rank</em>, or <em>MTR</em>. </p>
<p>To illustrate how to compute MTR, we&#39;ll go back to our toy example above. Model A is ranked 1st on STS and 2nd on retrieval. Model B is ranked 2nd on STS and 1st on retrieval. To compute MTR for Model A, we take the average <code>(1+2)/2 = 1.5</code>, and likewise for Model B. Then, we rank the entire table with respect to MTR.</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>STS</strong></th>
<th> <strong>STS </strong></th>
<th> <strong>Retrieval</strong></th>
<th> <strong>Retrieval</strong></th>
<th> <strong>MTR</strong></th>
<th>  <strong>Rank by MTR</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Model A</strong></td>
<td> 82.58</td>
<td>  1</td>
<td> 41.17</td>
<td>  2</td>
<td>1.5</td>
<td>  1.5</td>
</tr>
<tr>
<td><strong>Model B</strong></td>
<td> 78.08</td>
<td>  2</td>
<td> 51.99</td>
<td>  1</td>
<td>1.5</td>
<td>  1.5</td>
</tr>
</tbody>
</table>
<p>Now, Model A and Model B tie, which (at least to me) seems like a more accurate outcome than the version where Model B won.</p>
    

    
    <ul>
    
      <li>llamafile</li>
    
      <li>LLM</li>
    
      <li>RAG</li>
    
    </ul>
    
  </article>
</div></div>
  </body>
</html>
